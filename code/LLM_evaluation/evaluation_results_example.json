[
    {
        "func_name": "flash",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4F5F81(__int64 a1)\n{\n  return sub_4F5FA5(0LL, 0LL, a1);\n}\n\n\n Revised code:\nFAST_FUNC bb_ask_stdin(const char *prompt)\n{\n\treturn bb_ask(STDIN_FILENO, 0, prompt);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A88F7(__int64 a1)\n{\n  return sub_4B85D0(a1, 0LL, 1LL);\n}\n\n\n Revised code:\nint FAST_FUNC unpack_bunzip2(transformer_aux_data_t *aux)\n{\n\treturn unpack_bz2_stream(aux, STDIN_FILENO, STDOUT_FILENO);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A898E(__int64 a1)\n{\n  return sub_4BB637(a1, 0LL, 1LL);\n}\n\n\n Revised code:\nint FAST_FUNC unpack_unlzma(transformer_aux_data_t *aux)\n{\n\treturn unpack_lzma_stream(aux, STDIN_FILENO, STDOUT_FILENO);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4EFC8F(int a1)\n{\n  sub_4EFC6D();\n  sub_4F03A4(1LL);\n  sub_4EF515(a1);\n  sub_4EFC7E();\n  return sub_4F03A4(1LL);\n}\n",
        "output": "void process_data(int a1)\n{\n  initialize();\n  perform_task1(1);\n  perform_task2(a1);\n  cleanup();\n  perform_task1(1);\n}",
        "source_code": "static void flash(int h)\n{\n\tstandout_start();\n\tredraw(TRUE);\n\tmysleep(h);\n\tstandout_end();\n\tredraw(TRUE);\n}",
        "parsed_output": "void process_data(int a1)\n{\n  initialize();\n  perform_task1(1);\n  perform_task2(a1);\n  cleanup();\n  perform_task1(1);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4EFC8F(int a1)\n{\n  sub_4EFC6D();\n  sub_4F03A4(1LL);\n  sub_4EF515(a1);\n  sub_4EFC7E();\n  return sub_4F03A4(1LL);\n}\n",
        "baseline_code_debug": "void __cdecl flash(int h)\n{\n  standout_start();\n  redraw(1);\n  mysleep(h);\n  standout_end();\n  redraw(1);\n}\n",
        "similarity_score_unixcoder": 0.36883193254470825,
        "similarity_score_baseline_stripped": 0.30895179510116577,
        "similarity_score_baseline_debug": 0.9155714511871338
    },
    {
        "func_name": "collect_info",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_DWORD *__fastcall sub_461F0C(const char *a1, int a2)\n{\n  _DWORD *result; // rax\n  _QWORD *v3; // rbx\n  char **v4; // rbx\n  int i; // [rsp+1Ch] [rbp-14h]\n\n  for ( i = 0; i < *((_DWORD *)qword_75D408 + 2); ++i )\n  {\n    if ( !strcmp(a1, *(const char **)(16LL * i + *(_QWORD *)qword_75D408)) )\n    {\n      result = (_DWORD *)(16LL * i + *(_QWORD *)qword_75D408);\n      result[2] += a2;\n      return result;\n    }\n  }\n  v3 = qword_75D408;\n  *v3 = sub_50C0E1(*(_QWORD *)qword_75D408, 4100LL, *((unsigned int *)qword_75D408 + 2));\n  v4 = (char **)(*(_QWORD *)qword_75D408 + 16LL * *((int *)qword_75D408 + 2));\n  *v4 = sub_40A11F(a1, 4100LL);\n  *(_DWORD *)(16LL * *((int *)qword_75D408 + 2) + *(_QWORD *)qword_75D408 + 8) = a2;\n  result = qword_75D408;\n  ++*((_DWORD *)qword_75D408 + 2);\n  return result;\n}\n\n\n Revised code:\nstatic void save_line(const char *string, int count)\n{\n\tint i;\n\tfor (i = 0; i < G.lines_cnt; i++) {\n\t\tif (strcmp(string, G.lines[i].string) == 0) {\n\t\t\t/* It's already there, only update count */\n\t\t\tG.lines[i].count += count;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Add new line */\n\tG.lines = xrealloc_vector(G.lines, 4, G.lines_cnt);\n\tG.lines[G.lines_cnt].string = xstrdup(string);\n\tG.lines[G.lines_cnt].count = count;\n\t/*G.lines[G.lines_cnt].disk_count = 0;*/\n\tG.lines_cnt++;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_46E905(_QWORD *a1, __int64 a2)\n{\n  __int64 result; // rax\n  _QWORD *v3; // [rsp+8h] [rbp-18h]\n  _QWORD *ptr; // [rsp+18h] [rbp-8h]\n\n  v3 = a1;\n  result = *a1;\n  if ( *a1 )\n  {\n    ++*(_DWORD *)(qword_75D418 + 48);\n    *(_QWORD *)(qword_75D428 + 8) = a1[3];\n    while ( *(_QWORD *)qword_75D428 != *v3 )\n    {\n      ptr = *(_QWORD **)qword_75D428;\n      *(_QWORD *)qword_75D428 = **(_QWORD **)qword_75D428;\n      a1 = ptr;\n      free(ptr);\n    }\n    *(_QWORD *)(qword_75D428 + 16) = v3[1];\n    *(_QWORD *)(qword_75D428 + 32) = v3[2];\n    *(_QWORD *)(qword_75D428 + 24) = v3[1] + v3[2];\n    return sub_46E03F(a1, a2);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\npopstackmark(struct stackmark *mark)\n{\n\tstruct stack_block *sp;\n\n\tif (!mark->stackp)\n\t\treturn;\n\n\tINT_OFF;\n\tmarkp = mark->marknext;\n\twhile (g_stackp != mark->stackp) {\n\t\tsp = g_stackp;\n\t\tg_stackp = sp->prev;\n\t\tfree(sp);\n\t}\n\tg_stacknxt = mark->stacknxt;\n\tg_stacknleft = mark->stacknleft;\n\tsstrend = mark->stacknxt + mark->stacknleft;\n\tINT_ON;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_49077B(__int64 a1)\n{\n  while ( !(unsigned int)sub_490609(a1) )\n    ;\n  return **(unsigned __int8 **)qword_75D408;\n}\n\n\n Revised code:\nstatic char\nread_nonempty(const char *mesg)\n{\n\twhile (!read_line(mesg))\n\t\tcontinue;\n\treturn *line_ptr;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_460DE5(char *a1)\n{\n  const char *result; // rax\n\n  result = (const char *)qword_75D408;\n  *(_BYTE *)qword_75D408 ^= 1u;\n  while ( a1 )\n  {\n    sub_45F69B(*((const char **)a1 + 2));\n    (*((void (__fastcall **)(char *))a1 + 1))(a1);\n    result = *(const char **)a1;\n    a1 = *(char **)a1;\n  }\n  return result;\n}\n",
        "output": "static const char* process_data(char *a1)\n{\n  const char *result;\n\n  result = (const char *)qword_75D408;\n  *(_BYTE *)qword_75D408 ^= 1u;\n  while (a1)\n  {\n    sub_45F69B(*((const char **)a1 + 2));\n    (*((void (__fastcall **)(char *))a1 + 1))(a1);\n    result = *(const char **)a1;\n    a1 = *(char **)a1;\n  }\n  return result;\n}",
        "source_code": "static void FAST_FUNC collect_info(s_stat *s)\n{\n\tgen ^= 1;\n\twhile (s) {\n\t\tput(s->label);\n\t\ts->collect(s);\n\t\ts = s->next;\n\t}\n}",
        "parsed_output": "static const char* process_data(char *a1)\n{\n  const char *result;\n\n  result = (const char *)qword_75D408;\n  *(_BYTE *)qword_75D408 ^= 1u;\n  while (a1)\n  {\n    sub_45F69B(*((const char **)a1 + 2));\n    (*((void (__fastcall **)(char *))a1 + 1))(a1);\n    result = *(const char **)a1;\n    a1 = *(char **)a1;\n  }\n  return result;\n}",
        "baseline_code_stripped": "const char *__fastcall sub_460DE5(char *a1)\n{\n  const char *result; // rax\n\n  result = (const char *)qword_75D408;\n  *(_BYTE *)qword_75D408 ^= 1u;\n  while ( a1 )\n  {\n    sub_45F69B(*((const char **)a1 + 2));\n    (*((void (__fastcall **)(char *))a1 + 1))(a1);\n    result = *(const char **)a1;\n    a1 = *(char **)a1;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl collect_info(s_stat_0 *s)\n{\n  LOBYTE(ptr_to_globals->timeout) ^= 1u;\n  while ( s )\n  {\n    put(s->label);\n    s->collect(s);\n    s = s->next;\n  }\n}\n",
        "similarity_score_unixcoder": 0.5659849643707275,
        "similarity_score_baseline_stripped": 0.5119513273239136,
        "similarity_score_baseline_debug": 0.6700832843780518
    },
    {
        "func_name": "crc32_block_endian0",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4F74CA(unsigned int a1, unsigned __int8 *a2, int a3, __int64 a4)\n{\n  unsigned __int8 *i; // [rsp+8h] [rbp-20h]\n\n  for ( i = a2; i != &a2[a3]; ++i )\n    a1 = (a1 << 8) ^ *(_DWORD *)(4LL * (HIBYTE(a1) ^ *i) + a4);\n  return a1;\n}\n\n\n Revised code:\nuint32_t FAST_FUNC crc32_block_endian1(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table)\n{\n\tconst void *end = (uint8_t*)buf + len;\n\n\twhile (buf != end) {\n\t\tval = (val << 8) ^ crc_table[(val >> 24) ^ *(uint8_t*)buf];\n\t\tbuf = (uint8_t*)buf + 1;\n\t}\n\treturn val;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4FCBB9(__int64 a1, _BYTE *a2, unsigned __int64 a3)\n{\n  _BYTE *v3; // rax\n  __int64 result; // rax\n  unsigned int v6; // [rsp+28h] [rbp-10h]\n  unsigned int v7; // [rsp+2Ch] [rbp-Ch]\n\n  v7 = *(_DWORD *)(a1 + 200);\n  while ( 1 )\n  {\n    v6 = 72 - v7;\n    if ( a3 < 72 - v7 )\n      v6 = a3;\n    a3 -= v6;\n    while ( v6 )\n    {\n      v3 = a2++;\n      *(_BYTE *)(v7++ + a1) ^= *v3;\n      --v6;\n    }\n    v7 -= 72;\n    if ( v7 )\n      break;\n    sub_4FC67E((_QWORD *)a1);\n  }\n  result = a1;\n  *(_DWORD *)(a1 + 200) = v7 + 72;\n  return result;\n}\n\n\n Revised code:\nvoid FAST_FUNC sha3_hash(sha3_ctx_t *ctx, const void *buffer, size_t len)\n{\n#if SHA3_SMALL\n\tconst uint8_t *data = buffer;\n\tunsigned bufpos = ctx->bytes_queued;\n\n\twhile (1) {\n\t\tunsigned remaining = SHA3_IBLK_BYTES - bufpos;\n\t\tif (remaining > len)\n\t\t\tremaining = len;\n\t\tlen -= remaining;\n\t\t/* XOR data into buffer */\n\t\twhile (remaining != 0) {\n\t\t\tuint8_t *buf = (uint8_t*)ctx->state;\n\t\t\tbuf[bufpos] ^= *data++;\n\t\t\tbufpos++;\n\t\t\tremaining--;\n\t\t}\n\t\t/* Clever way to do \"if (bufpos != N) break; ... ; bufpos = 0;\" */\n\t\tbufpos -= SHA3_IBLK_BYTES;\n\t\tif (bufpos != 0)\n\t\t\tbreak;\n\t\t/* Buffer is filled up, process it */\n\t\tsha3_process_block72(ctx->state);\n\t\t/*bufpos = 0; - already is */\n\t}\n\tctx->bytes_queued = bufpos + SHA3_IBLK_BYTES;\n#else\n\t/* +50 bytes code size, but a bit faster because of long-sized XORs */\n\tconst uint8_t *data = buffer;\n\tunsigned bufpos = ctx->bytes_queued;\n\n\t/* If already data in queue, continue queuing first */\n\twhile (len != 0 && bufpos != 0) {\n\t\tuint8_t *buf = (uint8_t*)ctx->state;\n\t\tbuf[bufpos] ^= *data++;\n\t\tlen--;\n\t\tbufpos++;\n\t\tif (bufpos == SHA3_IBLK_BYTES) {\n\t\t\tbufpos = 0;\n\t\t\tgoto do_block;\n\t\t}\n\t}\n\n\t/* Absorb complete blocks */\n\twhile (len >= SHA3_IBLK_BYTES) {\n\t\t/* XOR data onto beginning of state[].\n\t\t * We try to be efficient - operate one word at a time, not byte.\n\t\t * Careful wrt unaligned access: can't just use \"*(long*)data\"!\n\t\t */\n\t\tunsigned count = SHA3_IBLK_BYTES / sizeof(long);\n\t\tlong *buf = (long*)ctx->state;\n\t\tdo {\n\t\t\tlong v;\n\t\t\tmove_from_unaligned_long(v, (long*)data);\n\t\t\t*buf++ ^= v;\n\t\t\tdata += sizeof(long);\n\t\t} while (--count);\n\t\tlen -= SHA3_IBLK_BYTES;\n do_block:\n\t\tsha3_process_block72(ctx->state);\n\t}\n\n\t/* Queue remaining data bytes */\n\twhile (len != 0) {\n\t\tuint8_t *buf = (uint8_t*)ctx->state;\n\t\tbuf[bufpos] ^= *data++;\n\t\tbufpos++;\n\t\tlen--;\n\t}\n\n\tctx->bytes_queued = bufpos;\n#endif\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_459B24(__int64 a1)\n{\n  unsigned int i; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; *(_BYTE *)((int)i + a1) != 0xFF; ++i )\n  {\n    if ( *(_BYTE *)((int)i + a1) )\n      i += *(unsigned __int8 *)((int)i + 1LL + a1) + 1;\n  }\n  return i;\n}\n\n\n Revised code:\nint FAST_FUNC udhcp_end_option(uint8_t *optionptr)\n{\n\tint i = 0;\n\n\twhile (optionptr[i] != DHCP_END) {\n\t\tif (optionptr[i] != DHCP_PADDING)\n\t\t\ti += optionptr[i + OPT_LEN] + OPT_DATA-1;\n\t\ti++;\n\t}\n\treturn i;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4F7534(unsigned int a1, _BYTE *a2, int a3, __int64 a4)\n{\n  _BYTE *i; // [rsp+8h] [rbp-20h]\n\n  for ( i = a2; i != &a2[a3]; ++i )\n    a1 = (a1 >> 8) ^ *(_DWORD *)(4LL * (unsigned __int8)(a1 ^ *i) + a4);\n  return a1;\n}\n",
        "output": "uint32_t FAST_FUNC crc32_block_endian2(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table)\n{\n\tconst void *end = (uint8_t*)buf + len;\n\n\twhile (buf != end) {\n\t\tval = (val >> 8) ^ crc_table[(val ^ *(uint8_t*)buf) & 0xFF];\n\t\tbuf = (uint8_t*)buf + 1;\n\t}\n\treturn val;\n}",
        "source_code": "uint32_t FAST_FUNC crc32_block_endian0(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table)\n{\n\tconst void *end = (uint8_t*)buf + len;\n\n\twhile (buf != end) {\n\t\tval = crc_table[(uint8_t)val ^ *(uint8_t*)buf] ^ (val >> 8);\n\t\tbuf = (uint8_t*)buf + 1;\n\t}\n\treturn val;\n}",
        "parsed_output": "uint32_t FAST_FUNC crc32_block_endian2(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table)\n{\n\tconst void *end = (uint8_t*)buf + len;\n\n\twhile (buf != end) {\n\t\tval = (val >> 8) ^ crc_table[(val ^ *(uint8_t*)buf) & 0xFF];\n\t\tbuf = (uint8_t*)buf + 1;\n\t}\n\treturn val;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4F7534(unsigned int a1, _BYTE *a2, int a3, __int64 a4)\n{\n  _BYTE *i; // [rsp+8h] [rbp-20h]\n\n  for ( i = a2; i != &a2[a3]; ++i )\n    a1 = (a1 >> 8) ^ *(_DWORD *)(4LL * (unsigned __int8)(a1 ^ *i) + a4);\n  return a1;\n}\n",
        "baseline_code_debug": "uint32_t __cdecl crc32_block_endian0(uint32_t val, const void *buf, unsigned int len, uint32_t *crc_table)\n{\n  _BYTE *bufa; // [rsp+8h] [rbp-20h]\n\n  for ( bufa = buf; bufa != (char *)buf + len; ++bufa )\n    val = (val >> 8) ^ crc_table[(unsigned __int8)(val ^ *bufa)];\n  return val;\n}\n",
        "similarity_score_unixcoder": 0.993118941783905,
        "similarity_score_baseline_stripped": 0.5743221044540405,
        "similarity_score_baseline_debug": 0.8933258056640625
    },
    {
        "func_name": "chain_node",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4DDFDB(__int64 a1, __int64 a2)\n{\n  char *v2; // rbx\n  char *v3; // rbx\n  __int64 v4; // rax\n  __int64 v6; // [rsp+18h] [rbp-28h]\n  __int64 v7; // [rsp+20h] [rbp-20h]\n  __int64 v8; // [rsp+28h] [rbp-18h]\n\n  v8 = *((_QWORD *)qword_75D408 - 15);\n  v7 = *((_QWORD *)qword_75D408 - 14);\n  v6 = sub_4DDE4A(67328, a2);\n  v2 = (char *)qword_75D408 - 208;\n  *((_QWORD *)v2 + 12) = sub_4DD854(512, a2);\n  v3 = (char *)qword_75D408 - 208;\n  *((_QWORD *)v3 + 11) = sub_4DD854(512, a2);\n  sub_4DE10D();\n  v4 = sub_4DDE4A(66048, a2);\n  *(_QWORD *)(v4 + 8) = a1;\n  *(_QWORD *)(v4 + 24) = v6;\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 14) + 24LL) = v4;\n  *(_QWORD *)(v6 + 16) = *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 8LL);\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 15) + 24LL) = *(_QWORD *)(v6 + 16);\n  *((_QWORD *)qword_75D408 - 14) = v7;\n  *((_QWORD *)qword_75D408 - 15) = v8;\n  return v6;\n}\n\n\n Revised code:\nstatic node *chain_loop(node *nn)\n{\n\tnode *n, *n2, *save_brk, *save_cont;\n\n\tsave_brk = break_ptr;\n\tsave_cont = continue_ptr;\n\n\tn = chain_node(OC_BR | Vx);\n\tcontinue_ptr = new_node(OC_EXEC);\n\tbreak_ptr = new_node(OC_EXEC);\n\tchain_group();\n\tn2 = chain_node(OC_EXEC | Vx);\n\tn2->l.n = nn;\n\tn2->a.n = n;\n\tcontinue_ptr->a.n = n2;\n\tbreak_ptr->a.n = n->r.n = seq->last;\n\n\tcontinue_ptr = save_cont;\n\tbreak_ptr = save_brk;\n\n\treturn n;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_46E6A8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v7; // [rsp+18h] [rbp-28h]\n  _QWORD *v8; // [rsp+20h] [rbp-20h]\n  size_t v9; // [rsp+28h] [rbp-18h]\n  unsigned __int64 v10; // [rsp+30h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+38h] [rbp-8h]\n\n  v10 = (a1 + 7) & 0xFFFFFFFFFFFFFFF8LL;\n  if ( v10 > *(_QWORD *)(qword_75D428 + 32) )\n  {\n    v11 = (a1 + 7) & 0xFFFFFFFFFFFFFFF8LL;\n    if ( v10 <= 0x1F7 )\n      v11 = 504LL;\n    v9 = v11 + 8;\n    if ( v11 + 8 < v11 )\n      sub_46E473(\"out of memory\", a2, a3, a4, a5, a6);\n    ++*(_DWORD *)(qword_75D418 + 48);\n    v8 = sub_40A05F(v9, a2);\n    *v8 = *(_QWORD *)qword_75D428;\n    *(_QWORD *)(qword_75D428 + 16) = v8 + 1;\n    *(_QWORD *)(qword_75D428 + 32) = v11;\n    *(_QWORD *)(qword_75D428 + 24) = *(_QWORD *)(qword_75D428 + 16) + v11;\n    *(_QWORD *)qword_75D428 = v8;\n    sub_46E03F(v9, a2);\n  }\n  v7 = *(_QWORD *)(qword_75D428 + 16);\n  *(_QWORD *)(qword_75D428 + 16) = v7 + v10;\n  *(_QWORD *)(qword_75D428 + 32) -= v10;\n  return v7;\n}\n\n\n Revised code:\nstatic void *\nstalloc(size_t nbytes)\n{\n\tchar *p;\n\tsize_t aligned;\n\n\taligned = SHELL_ALIGN(nbytes);\n\tif (aligned > g_stacknleft) {\n\t\tsize_t len;\n\t\tsize_t blocksize;\n\t\tstruct stack_block *sp;\n\n\t\tblocksize = aligned;\n\t\tif (blocksize < MINSIZE)\n\t\t\tblocksize = MINSIZE;\n\t\tlen = sizeof(struct stack_block) - MINSIZE + blocksize;\n\t\tif (len < blocksize)\n\t\t\tash_msg_and_raise_error(bb_msg_memory_exhausted);\n\t\tINT_OFF;\n\t\tsp = ckmalloc(len);\n\t\tsp->prev = g_stackp;\n\t\tg_stacknxt = sp->space;\n\t\tg_stacknleft = blocksize;\n\t\tsstrend = g_stacknxt + blocksize;\n\t\tg_stackp = sp;\n\t\tINT_ON;\n\t}\n\tp = g_stacknxt;\n\tg_stacknxt += aligned;\n\tg_stacknleft -= aligned;\n\treturn p;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4EB4EC(const char *a1, __int64 a2)\n{\n  void **v2; // rbx\n  _QWORD *v3; // rdx\n  _QWORD *v4; // rax\n  _QWORD *v5; // rbx\n  int v7; // [rsp+18h] [rbp-18h]\n  unsigned int v8; // [rsp+1Ch] [rbp-14h]\n\n  v7 = sub_4EF7EE(a1);\n  free(*(void **)qword_75D408);\n  *((_DWORD *)qword_75D408 + 6) = v7 + 10240;\n  v2 = (void **)qword_75D408;\n  *v2 = sub_40A0E8(*((int *)qword_75D408 + 6), a2);\n  v3 = qword_75D408;\n  *((_QWORD *)qword_75D408 + 1) = *v2;\n  v4 = qword_75D408;\n  *((_QWORD *)qword_75D408 + 2) = v3[1];\n  *((_QWORD *)qword_75D408 + 11) = v4[2];\n  if ( a1 != *((const char **)qword_75D408 + 10) )\n  {\n    free(*((void **)qword_75D408 + 10));\n    v5 = qword_75D408;\n    v5[10] = sub_40A11F(a1, a2);\n  }\n  if ( v7 >= 0 )\n  {\n    v8 = sub_4EF83A(a1, *(_QWORD *)qword_75D408, 1LL);\n  }\n  else\n  {\n    sub_4EDFD1(*(_QWORD *)qword_75D408, 10LL);\n    v8 = 0;\n  }\n  *((_DWORD *)qword_75D408 + 8) = 0;\n  *((_DWORD *)qword_75D408 + 9) = -1;\n  memset((char *)qword_75D408 + 408, 0, 0xE0uLL);\n  return v8;\n}\n\n\n Revised code:\nstatic int init_text_buffer(char *fn)\n{\n\tint rc;\n\tint size = file_size(fn);\t// file size. -1 means does not exist.\n\n\t/* allocate/reallocate text buffer */\n\tfree(text);\n\ttext_size = size + 10240;\n\tscreenbegin = dot = end = text = xzalloc(text_size);\n\n\tif (fn != current_filename) {\n\t\tfree(current_filename);\n\t\tcurrent_filename = xstrdup(fn);\n\t}\n\tif (size < 0) {\n\t\t// file dont exist. Start empty buf with dummy line\n\t\tchar_insert(text, '\\n');\n\t\trc = 0;\n\t} else {\n\t\trc = file_insert(fn, text, 1);\n\t}\n\tfile_modified = 0;\n\tlast_file_modified = -1;\n#if ENABLE_FEATURE_VI_YANKMARK\n\t/* init the marks. */\n\tmemset(mark, 0, sizeof(mark));\n#endif\n\treturn rc;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4DDE4A(int a1, __int64 a2)\n{\n  __int64 v2; // rbx\n  __int64 v4; // [rsp+18h] [rbp-18h]\n  __int64 v5; // [rsp+18h] [rbp-18h]\n\n  if ( !**((_QWORD **)qword_75D408 - 16) )\n  {\n    v2 = *((_QWORD *)qword_75D408 - 16);\n    *(_QWORD *)(v2 + 8) = sub_4DD854(0, a2);\n    **((_QWORD **)qword_75D408 - 16) = *(_QWORD *)(v2 + 8);\n  }\n  if ( *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 16LL) != *((_QWORD *)qword_75D408 - 8) )\n  {\n    *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 16LL) = *((_QWORD *)qword_75D408 - 8);\n    v4 = sub_4DDE4A(768LL);\n    *(_QWORD *)(v4 + 8) = sub_40A11F(*((const char **)qword_75D408 - 8), a2);\n  }\n  v5 = *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 8LL);\n  *(_DWORD *)v5 = a1;\n  *(_QWORD *)(v5 + 24) = sub_4DD854(10240, a2);\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 8LL) = *(_QWORD *)(v5 + 24);\n  return v5;\n}\n",
        "output": "static void process_data(int a1, int a2)\n{\n    int v2;\n    int v4;\n    int v5;\n\n    if (!**((int **)qword_75D408 - 16))\n    {\n        v2 = *((int *)qword_75D408 - 16);\n        *((int *)(v2 + 8)) = sub_4DD854(0, a2);\n        **((int **)qword_75D408 - 16) = *((int *)(v2 + 8));\n    }\n    if (*((int *)(*((int *)qword_75D408 - 16) + 16)) != *((int *)qword_75D408 - 8))\n    {\n        *((int *)(*((int *)qword_75D408 - 16) + 16)) = *((int *)qword_75D408 - 8);\n        v4 = sub_4DDE4A(768);\n        *((int *)(v4 + 8)) = sub_40A11F(*((const char **)qword_75D408 - 8), a2);\n    }\n    v5 = *((int *)(*((int *)qword_75D408 - 16) + 8));\n    *((int *)v5) = a1;\n    *((int *)(v5 + 24)) = sub_4DD854(10240, a2);\n    *((int *)(*((int *)qword_75D408 - 16) + 8)) = *((int *)(v5 + 24));\n    return v5;\n}",
        "source_code": "static node *chain_node(uint32_t info)\n{\n\tnode *n;\n\n\tif (!seq->first)\n\t\tseq->first = seq->last = new_node(0);\n\n\tif (seq->programname != g_progname) {\n\t\tseq->programname = g_progname;\n\t\tn = chain_node(OC_NEWSOURCE);\n\t\tn->l.new_progname = xstrdup(g_progname);\n\t}\n\n\tn = seq->last;\n\tn->info = info;\n\tseq->last = n->a.n = new_node(OC_DONE);\n\n\treturn n;\n}",
        "parsed_output": "static void process_data(int a1, int a2)\n{\n    int v2;\n    int v4;\n    int v5;\n\n    if (!**((int **)qword_75D408 - 16))\n    {\n        v2 = *((int *)qword_75D408 - 16);\n        *((int *)(v2 + 8)) = sub_4DD854(0, a2);\n        **((int **)qword_75D408 - 16) = *((int *)(v2 + 8));\n    }\n    if (*((int *)(*((int *)qword_75D408 - 16) + 16)) != *((int *)qword_75D408 - 8))\n    {\n        *((int *)(*((int *)qword_75D408 - 16) + 16)) = *((int *)qword_75D408 - 8);\n        v4 = sub_4DDE4A(768);\n        *((int *)(v4 + 8)) = sub_40A11F(*((const char **)qword_75D408 - 8), a2);\n    }\n    v5 = *((int *)(*((int *)qword_75D408 - 16) + 8));\n    *((int *)v5) = a1;\n    *((int *)(v5 + 24)) = sub_4DD854(10240, a2);\n    *((int *)(*((int *)qword_75D408 - 16) + 8)) = *((int *)(v5 + 24));\n    return v5;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4DDE4A(int a1, __int64 a2)\n{\n  __int64 v2; // rbx\n  __int64 v4; // [rsp+18h] [rbp-18h]\n  __int64 v5; // [rsp+18h] [rbp-18h]\n\n  if ( !**((_QWORD **)qword_75D408 - 16) )\n  {\n    v2 = *((_QWORD *)qword_75D408 - 16);\n    *(_QWORD *)(v2 + 8) = sub_4DD854(0, a2);\n    **((_QWORD **)qword_75D408 - 16) = *(_QWORD *)(v2 + 8);\n  }\n  if ( *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 16LL) != *((_QWORD *)qword_75D408 - 8) )\n  {\n    *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 16LL) = *((_QWORD *)qword_75D408 - 8);\n    v4 = sub_4DDE4A(768LL);\n    *(_QWORD *)(v4 + 8) = sub_40A11F(*((const char **)qword_75D408 - 8), a2);\n  }\n  v5 = *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 8LL);\n  *(_DWORD *)v5 = a1;\n  *(_QWORD *)(v5 + 24) = sub_4DD854(10240, a2);\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 8LL) = *(_QWORD *)(v5 + 24);\n  return v5;\n}\n",
        "baseline_code_debug": "node_0 *__cdecl chain_node(uint32_t info)\n{\n  __int64 v1; // rbx\n  node_0 *n; // [rsp+18h] [rbp-18h]\n  node_0 *na; // [rsp+18h] [rbp-18h]\n\n  if ( !**(_QWORD **)&ptr_to_globals[-1].line_buf[4] )\n  {\n    v1 = *(_QWORD *)&ptr_to_globals[-1].line_buf[4];\n    *(_QWORD *)(v1 + 8) = new_node(0);\n    **(_QWORD **)&ptr_to_globals[-1].line_buf[4] = *(_QWORD *)(v1 + 8);\n  }\n  if ( *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[4] + 16LL) != *(_QWORD *)&ptr_to_globals[-1].line_buf[68] )\n  {\n    *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[4] + 16LL) = *(_QWORD *)&ptr_to_globals[-1].line_buf[68];\n    n = chain_node(0x300u);\n    n->l.n = (node_s *)xstrdup(*(const char **)&ptr_to_globals[-1].line_buf[68]);\n  }\n  na = *(node_0 **)(*(_QWORD *)&ptr_to_globals[-1].line_buf[4] + 8LL);\n  na->info = info;\n  na->a.n = new_node(0x2800u);\n  *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[4] + 8LL) = na->a.n;\n  return na;\n}\n",
        "similarity_score_unixcoder": 0.4598563611507416,
        "similarity_score_baseline_stripped": 0.43704643845558167,
        "similarity_score_baseline_debug": 0.7331241369247437
    },
    {
        "func_name": "stat_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4CD235(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  _QWORD *v11; // [rsp+0h] [rbp-40h]\n  unsigned int v12; // [rsp+1Ch] [rbp-24h] BYREF\n  __int64 v13; // [rsp+20h] [rbp-20h] BYREF\n  int v14; // [rsp+2Ch] [rbp-14h]\n  unsigned int v15; // [rsp+30h] [rbp-10h]\n  unsigned int v16; // [rsp+34h] [rbp-Ch]\n  __int64 v17; // [rsp+38h] [rbp-8h]\n\n  v17 = -1LL;\n  v16 = 0;\n  v15 = 0;\n  qword_75D448 = (__int64)\"mode\";\n  v14 = sub_4FA1EF(a2, (unsigned int)\"m:pv\", (unsigned int)&v13, a4, a5, a6);\n  if ( (v14 & 1) != 0 )\n  {\n    v12 = 511;\n    if ( !(unsigned int)sub_50291C(v13, &v12) )\n      sub_40969E(\"invalid mode '%s'\", v13, v6, v7, v8, v9);\n    v17 = v12;\n  }\n  if ( (v14 & 2) != 0 )\n    v15 |= 4u;\n  v11 = (_QWORD *)(8LL * optind + a2);\n  if ( !*v11 )\n    sub_407F64();\n  do\n  {\n    if ( (unsigned int)sub_501CD0(*v11, v17, v15) )\n      v16 = 1;\n    ++v11;\n  }\n  while ( *v11 );\n  return v16;\n}\n\n\n Revised code:\nint mkdir_main(int argc UNUSED_PARAM, char **argv)\n{\n\tlong mode = -1;\n\tint status = EXIT_SUCCESS;\n\tint flags = 0;\n\tunsigned opt;\n\tchar *smode;\n#if ENABLE_SELINUX\n\tsecurity_context_t scontext;\n#endif\n\n#if ENABLE_FEATURE_MKDIR_LONG_OPTIONS\n\tapplet_long_options = mkdir_longopts;\n#endif\n\topt = getopt32(argv, \"m:p\" IF_SELINUX(\"Z:\") \"v\", &smode IF_SELINUX(,&scontext));\n\tif (opt & 1) {\n\t\tmode_t mmode = 0777;\n\t\tif (!bb_parse_mode(smode, &mmode)) {\n\t\t\tbb_error_msg_and_die(\"invalid mode '%s'\", smode);\n\t\t}\n\t\tmode = mmode;\n\t}\n\tif (opt & 2)\n\t\tflags |= FILEUTILS_RECUR;\n#if ENABLE_SELINUX\n\tif (opt & 4) {\n\t\tselinux_or_die();\n\t\tsetfscreatecon_or_die(scontext);\n\t}\n#endif\n\n\targv += optind;\n\tif (!argv[0])\n\t\tbb_show_usage();\n\n\tdo {\n\t\tif (bb_make_directory(*argv, mode, flags)) {\n\t\t\tstatus = EXIT_FAILURE;\n\t\t}\n\t} while (*++argv);\n\n\treturn status;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4C6031(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  char **v7; // [rsp+0h] [rbp-30h]\n  unsigned int v8[2]; // [rsp+10h] [rbp-20h] BYREF\n  int (*v9)(const char *, __uid_t, __gid_t); // [rsp+18h] [rbp-18h]\n  int v10; // [rsp+24h] [rbp-Ch]\n  unsigned int v11; // [rsp+28h] [rbp-8h]\n  unsigned int v12; // [rsp+2Ch] [rbp-4h]\n\n  v12 = 0;\n  v8[0] = -1;\n  v8[1] = -1;\n  qword_75D448 = (__int64)\"recursive\";\n  qword_75D440 = (__int64)\"-2\";\n  v10 = sub_4FA1EF(a2, (unsigned int)\"RhvcfLHP\", a3, a4, a5, a6);\n  v7 = (char **)(8LL * optind + a2);\n  v9 = chown;\n  if ( (v10 & 2) != 0 || (v10 & 0x61) == 1 )\n    v9 = lchown;\n  v11 = 8;\n  if ( (v10 & 1) != 0 )\n    v11 |= 1u;\n  if ( (v10 & 0x60) != 0 )\n    v11 |= 4u;\n  if ( (v10 & 0x20) != 0 )\n    v11 |= 2u;\n  sub_40D112(v8, *v7);\n  while ( *++v7 )\n  {\n    if ( !(unsigned int)sub_50752C(*v7, v11, sub_4C5F4E, sub_4C5F4E, v8, 0LL) )\n      v12 = 1;\n  }\n  return v12;\n}\n\n\n Revised code:\nint chown_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint retval = EXIT_SUCCESS;\n\tint opt, flags;\n\tstruct param_t param;\n\n\t/* Just -1 might not work: uid_t may be unsigned long */\n\tparam.ugid.uid = -1L;\n\tparam.ugid.gid = -1L;\n\n#if ENABLE_FEATURE_CHOWN_LONG_OPTIONS\n\tapplet_long_options = chown_longopts;\n#endif\n\topt_complementary = \"-2\";\n\topt = getopt32(argv, OPT_STR);\n\targv += optind;\n\n\t/* This matches coreutils behavior (almost - see below) */\n\tparam.chown_func = chown;\n\tif (OPT_NODEREF\n\t/* || (OPT_RECURSE && !OPT_TRAVERSE_TOP): */\n\tIF_DESKTOP( || (opt & (BIT_RECURSE|BIT_TRAVERSE_TOP)) == BIT_RECURSE)\n\t) {\n\t\tparam.chown_func = lchown;\n\t}\n\n\tflags = ACTION_DEPTHFIRST; /* match coreutils order */\n\tif (OPT_RECURSE)\n\t\tflags |= ACTION_RECURSE;\n\tif (OPT_TRAVERSE_TOP)\n\t\tflags |= ACTION_FOLLOWLINKS_L0; /* -H/-L: follow links on depth 0 */\n\tif (OPT_TRAVERSE)\n\t\tflags |= ACTION_FOLLOWLINKS; /* follow links if -L */\n\n\tparse_chown_usergroup_or_die(&param.ugid, argv[0]);\n\n\t/* Ok, ready to do the deed now */\n\twhile (*++argv) {\n\t\tif (!recursive_action(*argv,\n\t\t\t\tflags,          /* flags */\n\t\t\t\tfileAction,     /* file action */\n\t\t\t\tfileAction,     /* dir action */\n\t\t\t\t&param,         /* user data */\n\t\t\t\t0)              /* depth */\n\t\t) {\n\t\t\tretval = EXIT_FAILURE;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4C5E24(__int64 a1, _BYTE **a2, __int64 a3, int a4, int a5, int a6)\n{\n  __int64 *v6; // rax\n  __int64 v8; // [rsp+0h] [rbp-30h]\n  __int64 *v9; // [rsp+0h] [rbp-30h]\n  _QWORD *v10; // [rsp+0h] [rbp-30h]\n  __int64 v11; // [rsp+10h] [rbp-20h]\n  _BYTE **v12; // [rsp+18h] [rbp-18h]\n  _BYTE *v13; // [rsp+20h] [rbp-10h]\n  unsigned int v14; // [rsp+2Ch] [rbp-4h]\n\n  v14 = 0;\n  v12 = a2;\n  while ( 1 )\n  {\n    v13 = *++v12;\n    if ( !*v12 )\n      break;\n    if ( *v13 != 45 )\n    {\n      v13 = 0LL;\n      break;\n    }\n    if ( v13[1] && !strchr(\"-Rvcf\", (char)v13[1]) )\n    {\n      *v13 = 97;\n      break;\n    }\n  }\n  qword_75D440 = (__int64)\"-2\";\n  sub_4FA1EF((_DWORD)a2, 5447004, 5447004, a4, a5, a6, a2);\n  v9 = (__int64 *)(8LL * optind + v8);\n  if ( v13 )\n    *v13 = 45;\n  v6 = v9;\n  v10 = v9 + 1;\n  v11 = *v6;\n  do\n  {\n    if ( !(unsigned int)sub_50752C(*v10, dword_75D450 & 1, sub_4C5D04, sub_4C5D04, v11, 0LL) )\n      v14 = 1;\n    ++v10;\n  }\n  while ( *v10 );\n  return v14;\n}\n\n\n Revised code:\nint chmod_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint retval = EXIT_SUCCESS;\n\tchar *arg, **argp;\n\tchar *smode;\n\n\t/* Convert first encountered -r into ar, -w into aw etc\n\t * so that getopt would not eat it */\n\targp = argv;\n\twhile ((arg = *++argp)) {\n\t\t/* Mode spec must be the first arg (sans -R etc) */\n\t\t/* (protect against mishandling e.g. \"chmod 644 -r\") */\n\t\tif (arg[0] != '-') {\n\t\t\targ = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/* An option. Not a -- or valid option? */\n\t\tif (arg[1] && !strchr(\"-\"OPT_STR, arg[1])) {\n\t\t\targ[0] = 'a';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Parse options */\n\topt_complementary = \"-2\";\n\tgetopt32(argv, (\"-\"OPT_STR) + 1); /* Reuse string */\n\targv += optind;\n\n\t/* Restore option-like mode if needed */\n\tif (arg) arg[0] = '-';\n\n\t/* Ok, ready to do the deed now */\n\tsmode = *argv++;\n\tdo {\n\t\tif (!recursive_action(*argv,\n\t\t\tOPT_RECURSE,    // recurse\n\t\t\tfileAction,     // file action\n\t\t\tfileAction,     // dir action\n\t\t\tsmode,          // user data\n\t\t\t0)              // depth\n\t\t) {\n\t\t\tretval = EXIT_FAILURE;\n\t\t}\n\t} while (*++argv);\n\n\treturn retval;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BOOL8 __fastcall sub_4D3284(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  char v6; // al\n  __int64 v8; // [rsp+0h] [rbp-30h]\n  __int64 v9; // [rsp+10h] [rbp-20h] BYREF\n  int v10; // [rsp+1Ch] [rbp-14h]\n  __int64 (__fastcall *v11)(_QWORD, __int64); // [rsp+20h] [rbp-10h]\n  int v12; // [rsp+28h] [rbp-8h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  v9 = 0LL;\n  v11 = (__int64 (__fastcall *)(_QWORD, __int64))sub_4D318F;\n  qword_75D440 = (__int64)\"-1\";\n  v10 = sub_4FA1EF(a2, (unsigned int)\"ftLc:\", (unsigned int)&v9, a4, a5, a6);\n  if ( (v10 & 1) != 0 )\n    v11 = (__int64 (__fastcall *)(_QWORD, __int64))sub_4D30E9;\n  v12 = 1;\n  v8 = 8LL * optind + a2;\n  for ( i = 0; *(_QWORD *)(8LL * i + v8); ++i )\n  {\n    v6 = v11(*(_QWORD *)(8LL * i + v8), v9);\n    v12 = (unsigned __int8)(v6 & v12);\n  }\n  return v12 == 0;\n}\n",
        "output": "_BOOL8 sub_4D3284(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  char v6; \n  __int64 v8; \n  __int64 v9; \n  int v10; \n  __int64 (__fastcall *v11)(_QWORD, __int64); \n  int v12; \n  int i; \n\n  v9 = 0LL;\n  v11 = (__int64 (__fastcall *)(_QWORD, __int64))sub_4D318F;\n  qword_75D440 = (__int64)\"-1\";\n  v10 = sub_4FA1EF(a2, (unsigned int)\"ftLc:\", (unsigned int)&v9, a4, a5, a6);\n  if ( (v10 & 1) != 0 )\n    v11 = (__int64 (__fastcall *)(_QWORD, __int64))sub_4D30E9;\n  v12 = 1;\n  v8 = 8LL * optind + a2;\n  for ( i = 0; *(_QWORD *)(8LL * i + v8); ++i )\n  {\n    v6 = v11(*(_QWORD *)(8LL * i + v8), v9);\n    v12 = (unsigned __int8)(v6 & v12);\n  }\n  return v12 == 0;\n}",
        "source_code": "int stat_main(int argc UNUSED_PARAM, char **argv)\n{\n\tIF_FEATURE_STAT_FORMAT(char *format = NULL;)\n\tint i;\n\tint ok;\n\tunsigned opts;\n\tstatfunc_ptr statfunc = do_stat;\n\n\topt_complementary = \"-1\"; /* min one arg */\n\topts = getopt32(argv, \"ftL\"\n\t\tIF_SELINUX(\"Z\")\n\t\tIF_FEATURE_STAT_FORMAT(\"c:\", &format)\n\t);\n\tif (opts & OPT_FILESYS) /* -f */\n\t\tstatfunc = do_statfs;\n#if ENABLE_SELINUX\n\tif (opts & OPT_SELINUX) {\n\t\tselinux_or_die();\n\t}\n#endif\n\tok = 1;\n\targv += optind;\n\tfor (i = 0; argv[i]; ++i)\n\t\tok &= statfunc(argv[i] IF_FEATURE_STAT_FORMAT(, format));\n\n\treturn (ok ? EXIT_SUCCESS : EXIT_FAILURE);\n}",
        "parsed_output": "_BOOL8 sub_4D3284(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  char v6; \n  __int64 v8; \n  __int64 v9; \n  int v10; \n  __int64 (__fastcall *v11)(_QWORD, __int64); \n  int v12; \n  int i; \n\n  v9 = 0LL;\n  v11 = (__int64 (__fastcall *)(_QWORD, __int64))sub_4D318F;\n  qword_75D440 = (__int64)\"-1\";\n  v10 = sub_4FA1EF(a2, (unsigned int)\"ftLc:\", (unsigned int)&v9, a4, a5, a6);\n  if ( (v10 & 1) != 0 )\n    v11 = (__int64 (__fastcall *)(_QWORD, __int64))sub_4D30E9;\n  v12 = 1;\n  v8 = 8LL * optind + a2;\n  for ( i = 0; *(_QWORD *)(8LL * i + v8); ++i )\n  {\n    v6 = v11(*(_QWORD *)(8LL * i + v8), v9);\n    v12 = (unsigned __int8)(v6 & v12);\n  }\n  return v12 == 0;\n}",
        "baseline_code_stripped": "_BOOL8 __fastcall sub_4D3284(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  char v6; // al\n  __int64 v8; // [rsp+0h] [rbp-30h]\n  __int64 v9; // [rsp+10h] [rbp-20h] BYREF\n  int v10; // [rsp+1Ch] [rbp-14h]\n  __int64 (__fastcall *v11)(_QWORD, __int64); // [rsp+20h] [rbp-10h]\n  int v12; // [rsp+28h] [rbp-8h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  v9 = 0LL;\n  v11 = (__int64 (__fastcall *)(_QWORD, __int64))sub_4D318F;\n  qword_75D440 = (__int64)\"-1\";\n  v10 = sub_4FA1EF(a2, (unsigned int)\"ftLc:\", (unsigned int)&v9, a4, a5, a6);\n  if ( (v10 & 1) != 0 )\n    v11 = (__int64 (__fastcall *)(_QWORD, __int64))sub_4D30E9;\n  v12 = 1;\n  v8 = 8LL * optind + a2;\n  for ( i = 0; *(_QWORD *)(8LL * i + v8); ++i )\n  {\n    v6 = v11(*(_QWORD *)(8LL * i + v8), v9);\n    v12 = (unsigned __int8)(v6 & v12);\n  }\n  return v12 == 0;\n}\n",
        "baseline_code_debug": "int __cdecl stat_main(int argc, char **argv)\n{\n  bool v2; // al\n  char **argva; // [rsp+0h] [rbp-30h]\n  char *format; // [rsp+10h] [rbp-20h] BYREF\n  unsigned int opts; // [rsp+1Ch] [rbp-14h]\n  statfunc_ptr statfunc; // [rsp+20h] [rbp-10h]\n  int ok; // [rsp+28h] [rbp-8h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  format = 0LL;\n  statfunc = (statfunc_ptr)do_stat;\n  opt_complementary = \"-1\";\n  opts = getopt32(argv, \"ftLc:\", &format);\n  if ( (opts & 1) != 0 )\n    statfunc = (statfunc_ptr)do_statfs;\n  ok = 1;\n  argva = &argv[optind];\n  for ( i = 0; argva[i]; ++i )\n  {\n    v2 = statfunc(argva[i], format);\n    ok = v2 & (unsigned __int8)ok;\n  }\n  return ok == 0;\n}\n",
        "similarity_score_unixcoder": 0.5176083445549011,
        "similarity_score_baseline_stripped": 0.4532128572463989,
        "similarity_score_baseline_debug": 0.7509595155715942
    },
    {
        "func_name": "remove_iacs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47134A(int a1, __int64 a2)\n{\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  void *v5; // rsp\n  __int64 v6; // rdx\n  int v7; // eax\n  __int64 v9; // [rsp+0h] [rbp-40h] BYREF\n  int v10; // [rsp+Ch] [rbp-34h]\n  unsigned int *v11; // [rsp+18h] [rbp-28h]\n  __int64 v12; // [rsp+20h] [rbp-20h]\n  int v13; // [rsp+28h] [rbp-18h]\n  int i; // [rsp+2Ch] [rbp-14h]\n  char *s; // [rsp+30h] [rbp-10h]\n  int v16; // [rsp+3Ch] [rbp-4h]\n\n  v10 = a1;\n  v9 = a2;\n  if ( *(_QWORD *)(a2 + 8) && strcmp(*(const char **)(v9 + 8), \"-l\") )\n  {\n    v16 = 1;\n    do\n    {\n      if ( **(_BYTE **)(8LL * v16 + v9) == 37 )\n      {\n        v12 = sub_470E8F(*(_BYTE **)(8LL * v16 + v9), 0, 8LL * v16, v2, v3, v4);\n        v13 = *(unsigned __int16 *)(v12 + 28);\n        if ( (*(_BYTE *)(v12 + 31) & 2) != 0 )\n          v13 = 1;\n        v2 = 16LL;\n        v5 = alloca(16 * ((16LL * v13 + 23) / 0x10uLL));\n        s = (char *)&v9;\n        *(_QWORD *)(v9 + 8LL * v16) = &v9;\n        for ( i = 0; i < v13; ++i )\n        {\n          v11 = (unsigned int *)(16LL * i + *(_QWORD *)(v12 + 16));\n          if ( v11[1] == -1 || (unsigned __int8)v11[1] == 127 )\n          {\n            v6 = *v11;\n            if ( (*(_BYTE *)(v12 + 31) & 2) != 0 )\n              v7 = sprintf(s, \" -%u\", v6);\n            else\n              v7 = sprintf(s, \" %u\", v6);\n            s += v7;\n          }\n        }\n        *s = 0;\n      }\n      ++v16;\n    }\n    while ( *(_QWORD *)(8LL * v16 + v9) );\n  }\n  return sub_45CB53(v10, v9);\n}\n\n\n Revised code:\nstatic int FAST_FUNC\nkillcmd(int argc, char **argv)\n{\n\tif (argv[1] && strcmp(argv[1], \"-l\") != 0) {\n\t\tint i = 1;\n\t\tdo {\n\t\t\tif (argv[i][0] == '%') {\n\t\t\t\t/*\n\t\t\t\t * \"kill %N\" - job kill\n\t\t\t\t * Converting to pgrp / pid kill\n\t\t\t\t */\n\t\t\t\tstruct job *jp;\n\t\t\t\tchar *dst;\n\t\t\t\tint j, n;\n\n\t\t\t\tjp = getjob(argv[i], 0);\n\t\t\t\t/*\n\t\t\t\t * In jobs started under job control, we signal\n\t\t\t\t * entire process group by kill -PGRP_ID.\n\t\t\t\t * This happens, f.e., in interactive shell.\n\t\t\t\t *\n\t\t\t\t * Otherwise, we signal each child via\n\t\t\t\t * kill PID1 PID2 PID3.\n\t\t\t\t * Testcases:\n\t\t\t\t * sh -c 'sleep 1|sleep 1 & kill %1'\n\t\t\t\t * sh -c 'true|sleep 2 & sleep 1; kill %1'\n\t\t\t\t * sh -c 'true|sleep 1 & sleep 2; kill %1'\n\t\t\t\t */\n\t\t\t\tn = jp->nprocs; /* can't be 0 (I hope) */\n\t\t\t\tif (jp->jobctl)\n\t\t\t\t\tn = 1;\n\t\t\t\tdst = alloca(n * sizeof(int)*4);\n\t\t\t\targv[i] = dst;\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tstruct procstat *ps = &jp->ps[j];\n\t\t\t\t\t/* Skip non-running and not-stopped members\n\t\t\t\t\t * (i.e. dead members) of the job\n\t\t\t\t\t */\n\t\t\t\t\tif (ps->ps_status != -1 && !WIFSTOPPED(ps->ps_status))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t/*\n\t\t\t\t\t * kill_main has matching code to expect\n\t\t\t\t\t * leading space. Needed to not confuse\n\t\t\t\t\t * negative pids with \"kill -SIGNAL_NO\" syntax\n\t\t\t\t\t */\n\t\t\t\t\tdst += sprintf(dst, jp->jobctl ? \" -%u\" : \" %u\", (int)ps->ps_pid);\n\t\t\t\t}\n\t\t\t\t*dst = '\\0';\n\t\t\t}\n\t\t} while (argv[++i]);\n\t}\n\treturn kill_main(argc, argv);\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_4F73F6(int *a1, __int64 a2)\n{\n  int v2; // eax\n  int v3; // eax\n  int v4; // eax\n  int v5; // eax\n  int *v6; // rax\n  int *v8; // [rsp+8h] [rbp-18h]\n  int v9; // [rsp+10h] [rbp-10h]\n  int j; // [rsp+14h] [rbp-Ch]\n  int i; // [rsp+18h] [rbp-8h]\n  int v12; // [rsp+1Ch] [rbp-4h]\n\n  v8 = a1;\n  if ( (_DWORD)a2 )\n    v2 = 79764919;\n  else\n    v2 = -306674912;\n  v9 = v2;\n  if ( !a1 )\n    v8 = (int *)sub_40A05F(0x400uLL, a2);\n  for ( i = 0; i <= 255; ++i )\n  {\n    if ( (_DWORD)a2 )\n      v3 = i << 24;\n    else\n      v3 = i;\n    v12 = v3;\n    for ( j = 8; j; --j )\n    {\n      if ( (_DWORD)a2 )\n      {\n        if ( v12 >= 0 )\n          v4 = 2 * v12;\n        else\n          v4 = v9 ^ (2 * v12);\n        v12 = v4;\n      }\n      else\n      {\n        if ( (v12 & 1) != 0 )\n          v5 = v9 ^ ((unsigned int)v12 >> 1);\n        else\n          v5 = (unsigned int)v12 >> 1;\n        v12 = v5;\n      }\n    }\n    v6 = v8++;\n    *v6 = v12;\n  }\n  return (char *)(v8 - 256);\n}\n\n\n Revised code:\nFAST_FUNC crc32_filltable(uint32_t *crc_table, int endian)\n{\n\tuint32_t polynomial = endian ? 0x04c11db7 : 0xedb88320;\n\tuint32_t c;\n\tint i, j;\n\n\tif (!crc_table)\n\t\tcrc_table = xmalloc(256 * sizeof(uint32_t));\n\n\tfor (i = 0; i < 256; i++) {\n\t\tc = endian ? (i << 24) : i;\n\t\tfor (j = 8; j; j--) {\n\t\t\tif (endian)\n\t\t\t\tc = (c&0x80000000) ? ((c << 1) ^ polynomial) : (c << 1);\n\t\t\telse\n\t\t\t\tc = (c&1) ? ((c >> 1) ^ polynomial) : (c >> 1);\n\t\t}\n\t\t*crc_table++ = c;\n\t}\n\n\treturn crc_table - 256;\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_4C5599(unsigned int a1, unsigned int a2, char *a3)\n{\n  char *result; // rax\n  unsigned int v4; // esi\n  unsigned int v5; // eax\n  unsigned int v6; // esi\n  unsigned int v7; // eax\n  __int64 v8; // rdx\n  __int64 v9; // rdx\n  int v10; // edx\n  unsigned __int64 v13; // [rsp+18h] [rbp-28h]\n  int v14; // [rsp+24h] [rbp-1Ch]\n  unsigned __int64 i; // [rsp+28h] [rbp-18h]\n  int v16; // [rsp+30h] [rbp-10h]\n  int v17; // [rsp+34h] [rbp-Ch]\n  unsigned int v18; // [rsp+38h] [rbp-8h]\n  unsigned int j; // [rsp+3Ch] [rbp-4h]\n\n  memset(a3, -1, 0xA8uLL);\n  if ( a1 == 9 && a2 == 1752 )\n  {\n    v14 = 244 * dword_75D450;\n    for ( i = 0LL; i <= 0x12; ++i )\n    {\n      result = &a3[4 * i + 8];\n      *(_DWORD *)result = *(unsigned __int8 *)(i + 5466736) + v14;\n    }\n  }\n  else\n  {\n    v18 = 1;\n    if ( a1 > 2 && sub_4C4F6A(a2) )\n      v18 = 2;\n    for ( j = a1; j; v18 += (unsigned __int8)byte_536A63[j] )\n      --j;\n    v4 = (a2 - 1) >> 2;\n    if ( a2 - 1 <= 0x6A4 )\n      v5 = 0;\n    else\n      v5 = (a2 - 1) / 0x64 - 17;\n    v6 = v4 - v5;\n    if ( a2 - 1 <= 0x640 )\n      v7 = 0;\n    else\n      v7 = (a2 - 1601) / 0x190;\n    v13 = 365LL * (a2 - 1) + v6 + v7 + v18;\n    if ( v13 > 0x9C32A )\n    {\n      v9 = (0x2492492492492493LL * (unsigned __int128)(v13 - 6)) >> 64;\n      v17 = v13 - 6 - 7 * ((v9 + ((v13 - 6 - v9) >> 1)) >> 2);\n    }\n    else\n    {\n      v8 = (0x2492492492492493LL * (unsigned __int128)(v13 + 5)) >> 64;\n      v17 = v13 + 5 - 7 * ((v8 + ((v13 + 5 - v8) >> 1)) >> 2);\n    }\n    if ( !dword_75D450 )\n      v18 = 1;\n    v16 = (unsigned __int8)byte_536A63[a1];\n    if ( a1 == 2 && sub_4C4F6A(a2) )\n      ++v16;\n    do\n    {\n      result = (char *)v18++;\n      v10 = v17++;\n      *(_DWORD *)&a3[4 * v10] = (_DWORD)result;\n      --v16;\n    }\n    while ( v16 );\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void day_array(unsigned month, unsigned year, unsigned *days)\n{\n\tunsigned long temp;\n\tunsigned i;\n\tunsigned day, dw, dm;\n\n\tmemset(days, SPACE, MAXDAYS * sizeof(int));\n\n\tif ((month == 9) && (year == 1752)) {\n\t\t/* Assumes the Gregorian reformation eliminates\n\t\t * 3 Sep. 1752 through 13 Sep. 1752.\n\t\t */\n\t\tunsigned j_offset = julian * 244;\n\t\tsize_t oday = 0;\n\n\t\tdo {\n\t\t\tdays[oday+2] = sep1752[oday] + j_offset;\n\t\t} while (++oday < sizeof(sep1752));\n\n\t\treturn;\n\t}\n\n\t/* day_in_year\n\t * return the 1 based day number within the year\n\t */\n\tday = 1;\n\tif ((month > 2) && leap_year(year)) {\n\t\t++day;\n\t}\n\n\ti = month;\n\twhile (i) {\n\t\tday += days_in_month[--i];\n\t}\n\n\t/* day_in_week\n\t * return the 0 based day number for any date from 1 Jan. 1 to\n\t * 31 Dec. 9999.  Assumes the Gregorian reformation eliminates\n\t * 3 Sep. 1752 through 13 Sep. 1752.  Returns Thursday for all\n\t * missing days.\n\t */\n\ttemp = (long)(year - 1) * 365 + leap_years_since_year_1(year - 1) + day;\n\tif (temp < FIRST_MISSING_DAY) {\n\t\tdw = ((temp - 1 + SATURDAY) % 7);\n\t} else {\n\t\tdw = (((temp - 1 + SATURDAY) - NUMBER_MISSING_DAYS) % 7);\n\t}\n\n\tif (!julian) {\n\t\tday = 1;\n\t}\n\n\tdm = days_in_month[month];\n\tif ((month == 2) && leap_year(year)) {\n\t\t++dm;\n\t}\n\n\tdo {\n\t\tdays[dw++] = day++;\n\t} while (--dm);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_44283A(int *a1, _DWORD *a2)\n{\n  int v2; // eax\n  char *v3; // rax\n  char *v4; // rax\n  __int16 v6[4]; // [rsp+10h] [rbp-30h] BYREF\n  int v7; // [rsp+18h] [rbp-28h]\n  char v8; // [rsp+1Fh] [rbp-21h]\n  unsigned __int64 v9; // [rsp+20h] [rbp-20h]\n  void *src; // [rsp+28h] [rbp-18h]\n  char *v11; // [rsp+30h] [rbp-10h]\n  char *v12; // [rsp+38h] [rbp-8h]\n\n  src = (char *)a1 + a1[7] + 48;\n  v12 = (char *)src;\n  v11 = (char *)src;\n  v2 = a1[8];\n  if ( v2 > 2024 - a1[7] )\n    v2 = 2024 - a1[7];\n  v9 = (unsigned __int64)&v12[v2];\n  while ( (unsigned __int64)v12 < v9 )\n  {\n    if ( *v12 == -1 )\n    {\n      if ( v9 <= (unsigned __int64)(v12 + 1) )\n        break;\n      if ( v12[1] == -15 )\n      {\n        v12 += 2;\n      }\n      else if ( v12[1] == -1 )\n      {\n        v4 = v11++;\n        *v4 = v12[1];\n        v12 += 2;\n      }\n      else\n      {\n        if ( v9 <= (unsigned __int64)(v12 + 2) )\n          break;\n        if ( v12[1] == -6 && v12[2] == 31 )\n        {\n          if ( v9 <= (unsigned __int64)(v12 + 8) )\n            break;\n          v6[1] = _byteswap_ushort(*(_WORD *)(v12 + 3));\n          v6[0] = _byteswap_ushort(*(_WORD *)(v12 + 5));\n          ioctl(a1[5], 0x5414uLL, v6);\n          v12 += 9;\n        }\n        else\n        {\n          v12 += 3;\n        }\n      }\n    }\n    else\n    {\n      v8 = *v12;\n      v3 = v11++;\n      *v3 = v8;\n      ++v12;\n      if ( v8 == 13 && (unsigned __int64)v12 < v9 && (*v12 == 10 || !*v12) )\n        ++v12;\n    }\n  }\n  v7 = (_DWORD)v11 - (_DWORD)src;\n  *a2 = (_DWORD)v11 - (_DWORD)src;\n  if ( v12 == v11 )\n    return src;\n  a1[7] += (_DWORD)v12 - (_DWORD)v11;\n  a1[8] -= (_DWORD)v12 - (_DWORD)v11;\n  return memmove(&v12[-v7], src, v7);\n}\n",
        "output": "static void *process_data(int *a1, _DWORD *a2)\n{\n  int v2 = a1[8];\n  char *src = (char *)a1 + a1[7] + 48;\n  char *v11 = src;\n  char *v12 = src;\n  unsigned __int64 v9 = (unsigned __int64)&v12[v2];\n  __int16 v6[4];\n  int v7;\n  char v8;\n\n  if (v2 > 2024 - a1[7])\n    v2 = 2024 - a1[7];\n  v9 = (unsigned __int64)&v12[v2];\n  while ((unsigned __int64)v12 < v9)\n  {\n    if (*v12 == -1)\n    {\n      if (v9 <= (unsigned __int64)(v12 + 1))\n        break;\n      if (v12[1] == -15)\n      {\n        v12 += 2;\n      }\n      else if (v12[1] == -1)\n      {\n        *v11++ = v12[1];\n        v12 += 2;\n      }\n      else\n      {\n        if (v9 <= (unsigned __int64)(v12 + 2))\n          break;\n        if (v12[1] == -6 && v12[2] == 31)\n        {\n          if (v9 <= (unsigned __int64)(v12 + 8))\n            break;\n          v6[1] = _byteswap_ushort(*(_WORD *)(v12 + 3));\n          v6[0] = _byteswap_ushort(*(_WORD *)(v12 + 5));\n          ioctl(a1[5], 0x5414uLL, v6);\n          v12 += 9;\n        }\n        else\n        {\n          v12 += 3;\n        }\n      }\n    }\n    else\n    {\n      v8 = *v12;\n      *v11++ = v8;\n      ++v12;\n      if (v8 == 13 && (unsigned __int64)v12 < v9 && (*v12 == 10 || !*v12))\n        ++v12;\n    }\n  }\n  v7 = (_DWORD)v11 - (_DWORD)src;\n  *a2 = (_DWORD)v11 - (_DWORD)src;\n  if (v12 == v11)\n    return src;\n  a1[7] += (_DWORD)v12 - (_DWORD)v11;\n  a1[8] -= (_DWORD)v12 - (_DWORD)v11;\n  return memmove(&v12[-v7], src, v7);\n}",
        "source_code": "static unsigned char *\nremove_iacs(struct tsession *ts, int *pnum_totty)\n{\n\tunsigned char *ptr0 = TS_BUF1(ts) + ts->wridx1;\n\tunsigned char *ptr = ptr0;\n\tunsigned char *totty = ptr;\n\tunsigned char *end = ptr + MIN(BUFSIZE - ts->wridx1, ts->size1);\n\tint num_totty;\n\n\twhile (ptr < end) {\n\t\tif (*ptr != IAC) {\n\t\t\tchar c = *ptr;\n\n\t\t\t*totty++ = c;\n\t\t\tptr++;\n\t\t\t/* We map \\r\\n ==> \\r for pragmatic reasons.\n\t\t\t * Many client implementations send \\r\\n when\n\t\t\t * the user hits the CarriageReturn key.\n\t\t\t * See RFC 1123 3.3.1 Telnet End-of-Line Convention.\n\t\t\t */\n\t\t\tif (c == '\\r' && ptr < end && (*ptr == '\\n' || *ptr == '\\0'))\n\t\t\t\tptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((ptr+1) >= end)\n\t\t\tbreak;\n\t\tif (ptr[1] == NOP) { /* Ignore? (putty keepalive, etc.) */\n\t\t\tptr += 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ptr[1] == IAC) { /* Literal IAC? (emacs M-DEL) */\n\t\t\t*totty++ = ptr[1];\n\t\t\tptr += 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * TELOPT_NAWS support!\n\t\t */\n\t\tif ((ptr+2) >= end) {\n\t\t\t/* Only the beginning of the IAC is in the\n\t\t\tbuffer we were asked to process, we can't\n\t\t\tprocess this char */\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * IAC -> SB -> TELOPT_NAWS -> 4-byte -> IAC -> SE\n\t\t */\n\t\tif (ptr[1] == SB && ptr[2] == TELOPT_NAWS) {\n\t\t\tstruct winsize ws;\n\t\t\tif ((ptr+8) >= end)\n\t\t\t\tbreak;  /* incomplete, can't process */\n\t\t\tws.ws_col = (ptr[3] << 8) | ptr[4];\n\t\t\tws.ws_row = (ptr[5] << 8) | ptr[6];\n\t\t\tioctl(ts->ptyfd, TIOCSWINSZ, (char *)&ws);\n\t\t\tptr += 9;\n\t\t\tcontinue;\n\t\t}\n\t\t/* skip 3-byte IAC non-SB cmd */\n#if DEBUG\n\t\tfprintf(stderr, \"Ignoring IAC %s,%s\\n\",\n\t\t\t\tTELCMD(ptr[1]), TELOPT(ptr[2]));\n#endif\n\t\tptr += 3;\n\t}\n\n\tnum_totty = totty - ptr0;\n\t*pnum_totty = num_totty;\n\t/* The difference between ptr and totty is number of iacs\n\t   we removed from the stream. Adjust buf1 accordingly */\n\tif ((ptr - totty) == 0) /* 99.999% of cases */\n\t\treturn ptr0;\n\tts->wridx1 += ptr - totty;\n\tts->size1 -= ptr - totty;\n\t/* Move chars meant for the terminal towards the end of the buffer */\n\treturn memmove(ptr - num_totty, ptr0, num_totty);\n}",
        "parsed_output": "static void *process_data(int *a1, _DWORD *a2)\n{\n  int v2 = a1[8];\n  char *src = (char *)a1 + a1[7] + 48;\n  char *v11 = src;\n  char *v12 = src;\n  unsigned __int64 v9 = (unsigned __int64)&v12[v2];\n  __int16 v6[4];\n  int v7;\n  char v8;\n\n  if (v2 > 2024 - a1[7])\n    v2 = 2024 - a1[7];\n  v9 = (unsigned __int64)&v12[v2];\n  while ((unsigned __int64)v12 < v9)\n  {\n    if (*v12 == -1)\n    {\n      if (v9 <= (unsigned __int64)(v12 + 1))\n        break;\n      if (v12[1] == -15)\n      {\n        v12 += 2;\n      }\n      else if (v12[1] == -1)\n      {\n        *v11++ = v12[1];\n        v12 += 2;\n      }\n      else\n      {\n        if (v9 <= (unsigned __int64)(v12 + 2))\n          break;\n        if (v12[1] == -6 && v12[2] == 31)\n        {\n          if (v9 <= (unsigned __int64)(v12 + 8))\n            break;\n          v6[1] = _byteswap_ushort(*(_WORD *)(v12 + 3));\n          v6[0] = _byteswap_ushort(*(_WORD *)(v12 + 5));\n          ioctl(a1[5], 0x5414uLL, v6);\n          v12 += 9;\n        }\n        else\n        {\n          v12 += 3;\n        }\n      }\n    }\n    else\n    {\n      v8 = *v12;\n      *v11++ = v8;\n      ++v12;\n      if (v8 == 13 && (unsigned __int64)v12 < v9 && (*v12 == 10 || !*v12))\n        ++v12;\n    }\n  }\n  v7 = (_DWORD)v11 - (_DWORD)src;\n  *a2 = (_DWORD)v11 - (_DWORD)src;\n  if (v12 == v11)\n    return src;\n  a1[7] += (_DWORD)v12 - (_DWORD)v11;\n  a1[8] -= (_DWORD)v12 - (_DWORD)v11;\n  return memmove(&v12[-v7], src, v7);\n}",
        "baseline_code_stripped": "void *__fastcall sub_44283A(int *a1, _DWORD *a2)\n{\n  int v2; // eax\n  char *v3; // rax\n  char *v4; // rax\n  __int16 v6[4]; // [rsp+10h] [rbp-30h] BYREF\n  int v7; // [rsp+18h] [rbp-28h]\n  char v8; // [rsp+1Fh] [rbp-21h]\n  unsigned __int64 v9; // [rsp+20h] [rbp-20h]\n  void *src; // [rsp+28h] [rbp-18h]\n  char *v11; // [rsp+30h] [rbp-10h]\n  char *v12; // [rsp+38h] [rbp-8h]\n\n  src = (char *)a1 + a1[7] + 48;\n  v12 = (char *)src;\n  v11 = (char *)src;\n  v2 = a1[8];\n  if ( v2 > 2024 - a1[7] )\n    v2 = 2024 - a1[7];\n  v9 = (unsigned __int64)&v12[v2];\n  while ( (unsigned __int64)v12 < v9 )\n  {\n    if ( *v12 == -1 )\n    {\n      if ( v9 <= (unsigned __int64)(v12 + 1) )\n        break;\n      if ( v12[1] == -15 )\n      {\n        v12 += 2;\n      }\n      else if ( v12[1] == -1 )\n      {\n        v4 = v11++;\n        *v4 = v12[1];\n        v12 += 2;\n      }\n      else\n      {\n        if ( v9 <= (unsigned __int64)(v12 + 2) )\n          break;\n        if ( v12[1] == -6 && v12[2] == 31 )\n        {\n          if ( v9 <= (unsigned __int64)(v12 + 8) )\n            break;\n          v6[1] = _byteswap_ushort(*(_WORD *)(v12 + 3));\n          v6[0] = _byteswap_ushort(*(_WORD *)(v12 + 5));\n          ioctl(a1[5], 0x5414uLL, v6);\n          v12 += 9;\n        }\n        else\n        {\n          v12 += 3;\n        }\n      }\n    }\n    else\n    {\n      v8 = *v12;\n      v3 = v11++;\n      *v3 = v8;\n      ++v12;\n      if ( v8 == 13 && (unsigned __int64)v12 < v9 && (*v12 == 10 || !*v12) )\n        ++v12;\n    }\n  }\n  v7 = (_DWORD)v11 - (_DWORD)src;\n  *a2 = (_DWORD)v11 - (_DWORD)src;\n  if ( v12 == v11 )\n    return src;\n  a1[7] += (_DWORD)v12 - (_DWORD)v11;\n  a1[8] -= (_DWORD)v12 - (_DWORD)v11;\n  return memmove(&v12[-v7], src, v7);\n}\n",
        "baseline_code_debug": "unsigned __int8 *__cdecl remove_iacs(tsession *ts, int *pnum_totty)\n{\n  int size1; // eax\n  unsigned __int8 *v3; // rax\n  unsigned __int8 *v4; // rax\n  winsize ws; // [rsp+10h] [rbp-30h] BYREF\n  int num_totty; // [rsp+18h] [rbp-28h]\n  char c; // [rsp+1Fh] [rbp-21h]\n  unsigned __int8 *end; // [rsp+20h] [rbp-20h]\n  unsigned __int8 *ptr0; // [rsp+28h] [rbp-18h]\n  unsigned __int8 *totty; // [rsp+30h] [rbp-10h]\n  unsigned __int8 *ptr; // [rsp+38h] [rbp-8h]\n\n  ptr0 = (unsigned __int8 *)&ts[1] + ts->wridx1;\n  ptr = ptr0;\n  totty = ptr0;\n  size1 = ts->size1;\n  if ( size1 > 2024 - ts->wridx1 )\n    size1 = 2024 - ts->wridx1;\n  end = &ptr[size1];\n  while ( ptr < end )\n  {\n    if ( *ptr == 0xFF )\n    {\n      if ( end <= ptr + 1 )\n        break;\n      if ( ptr[1] == 0xF1 )\n      {\n        ptr += 2;\n      }\n      else if ( ptr[1] == 0xFF )\n      {\n        v4 = totty++;\n        *v4 = ptr[1];\n        ptr += 2;\n      }\n      else\n      {\n        if ( end <= ptr + 2 )\n          break;\n        if ( ptr[1] == 0xFA && ptr[2] == 31 )\n        {\n          if ( end <= ptr + 8 )\n            break;\n          ws.ws_col = _byteswap_ushort(*(_WORD *)(ptr + 3));\n          ws.ws_row = _byteswap_ushort(*(_WORD *)(ptr + 5));\n          ioctl(ts->ptyfd, 0x5414uLL, &ws);\n          ptr += 9;\n        }\n        else\n        {\n          ptr += 3;\n        }\n      }\n    }\n    else\n    {\n      c = *ptr;\n      v3 = totty++;\n      *v3 = c;\n      ++ptr;\n      if ( c == 13 && ptr < end && (*ptr == 10 || !*ptr) )\n        ++ptr;\n    }\n  }\n  num_totty = (_DWORD)totty - (_DWORD)ptr0;\n  *pnum_totty = (_DWORD)totty - (_DWORD)ptr0;\n  if ( ptr == totty )\n    return ptr0;\n  ts->wridx1 += (_DWORD)ptr - (_DWORD)totty;\n  ts->size1 -= (_DWORD)ptr - (_DWORD)totty;\n  return (unsigned __int8 *)memmove(&ptr[-num_totty], ptr0, num_totty);\n}\n",
        "similarity_score_unixcoder": 0.6349454522132874,
        "similarity_score_baseline_stripped": 0.571986198425293,
        "similarity_score_baseline_debug": 0.8168365359306335
    },
    {
        "func_name": "interpret_xfermode",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_449BFB(int a1, int a2)\n{\n  unsigned int v3; // [rsp+Ch] [rbp-4h]\n\n  sub_40A659(60);\n  if ( (a1 & 1) != 0 && (a1 & 0x40) == 0 )\n    printf(\"NO-CARRIER,\");\n  v3 = sub_502E59(\"\\b\", \"LOOPBACK\", a1 & 0xFFFFFFBF, \",\");\n  if ( v3 )\n    printf(\"%x\", v3);\n  if ( a2 )\n    printf(\",M-DOWN\");\n  return printf(\"> \");\n}\n\n\n Revised code:\nstatic void print_link_flags(unsigned flags, unsigned mdown)\n{\n\tstatic const int flag_masks[] = {\n\t\tIFF_LOOPBACK, IFF_BROADCAST, IFF_POINTOPOINT,\n\t\tIFF_MULTICAST, IFF_NOARP, IFF_UP, IFF_LOWER_UP };\n\tstatic const char flag_labels[] ALIGN1 =\n\t\t\"LOOPBACK\\0\"\"BROADCAST\\0\"\"POINTOPOINT\\0\"\n\t\t\"MULTICAST\\0\"\"NOARP\\0\"\"UP\\0\"\"LOWER_UP\\0\";\n\n\tbb_putchar('<');\n\tif (flags & IFF_UP && !(flags & IFF_RUNNING))\n\t\tprintf(\"NO-CARRIER,\");\n\tflags &= ~IFF_RUNNING;\n#if 0\n\t_PF(ALLMULTI);\n\t_PF(PROMISC);\n\t_PF(MASTER);\n\t_PF(SLAVE);\n\t_PF(DEBUG);\n\t_PF(DYNAMIC);\n\t_PF(AUTOMEDIA);\n\t_PF(PORTSEL);\n\t_PF(NOTRAILERS);\n#endif\n\tflags = print_flags_separated(flag_masks, flag_labels, flags, \",\");\n\tif (flags)\n\t\tprintf(\"%x\", flags);\n\tif (mdown)\n\t\tprintf(\",M-DOWN\");\n\tprintf(\"> \");\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_417D58(unsigned __int16 a1, unsigned __int16 a2, unsigned int a3, _BYTE *a4)\n{\n  unsigned __int8 v9; // [rsp+2Dh] [rbp-3h]\n  unsigned __int16 i; // [rsp+2Eh] [rbp-2h]\n\n  v9 = 0;\n  for ( i = 0; i <= 7u; ++i )\n  {\n    if ( (a2 & 1) != 0 )\n    {\n      printf(\"*%cdma%u \", a3, i);\n      if ( *a4 )\n        v9 = 1;\n      *a4 = 1;\n    }\n    else if ( (a1 & 1) != 0 )\n    {\n      printf(\"%cdma%u \", a3, i);\n    }\n    a1 >>= 1;\n    a2 >>= 1;\n  }\n  return v9;\n}\n\n\n Revised code:\nstatic uint8_t mode_loop(uint16_t mode_sup, uint16_t mode_sel, int cc, uint8_t *have_mode)\n{\n\tuint16_t ii;\n\tuint8_t err_dma = 0;\n\n\tfor (ii = 0; ii <= MODE_MAX; ii++) {\n\t\tif (mode_sel & 0x0001) {\n\t\t\tprintf(\"*%cdma%u \", cc, ii);\n\t\t\tif (*have_mode)\n\t\t\t\terr_dma = 1;\n\t\t\t*have_mode = 1;\n\t\t} else if (mode_sup & 0x0001)\n\t\t\tprintf(\"%cdma%u \", cc, ii);\n\n\t\tmode_sup >>= 1;\n\t\tmode_sel >>= 1;\n\t}\n\treturn err_dma;\n}\n\n## Example:\n\n Input code:\nconst char *__fastcall sub_4D213C(__int64 a1)\n{\n  switch ( *(_DWORD *)(a1 + 24) & 0xF000 )\n  {\n    case 32768:\n      if ( *(_QWORD *)(a1 + 48) )\n        return \"regular file\";\n      else\n        return \"regular empty file\";\n    case 16384:\n      return \"directory\";\n    case 24576:\n      return \"block special file\";\n    case 8192:\n      return \"character special file\";\n    case 4096:\n      return \"fifo\";\n    case 40960:\n      return \"symbolic link\";\n    case 49152:\n      return \"socket\";\n    default:\n      return \"weird file\";\n  }\n}\n\n\n Revised code:\nendif\n\nstatic const char *file_type(const struct stat *st)\n{\n\t/* See POSIX 1003.1-2001 XCU Table 4-8 lines 17093-17107\n\t * for some of these formats.\n\t * To keep diagnostics grammatical in English, the\n\t * returned string must start with a consonant.\n\t */\n\tif (S_ISREG(st->st_mode))  return st->st_size == 0 ? \"regular empty file\" : \"regular file\";\n\tif (S_ISDIR(st->st_mode))  return \"directory\";\n\tif (S_ISBLK(st->st_mode))  return \"block special file\";\n\tif (S_ISCHR(st->st_mode))  return \"character special file\";\n\tif (S_ISFIFO(st->st_mode)) return \"fifo\";\n\tif (S_ISLNK(st->st_mode))  return \"symbolic link\";\n\tif (S_ISSOCK(st->st_mode)) return \"socket\";\n#ifdef S_TYPEISMQ\n\tif (S_TYPEISMQ(st))        return \"message queue\";\n#endif\n#ifdef S_TYPEISSEM\n\tif (S_TYPEISSEM(st))       return \"semaphore\";\n#endif\n#ifdef S_TYPEISSHM\n\tif (S_TYPEISSHM(st))       return \"shared memory object\";\n#endif\n#ifdef S_TYPEISTMO\n\tif (S_TYPEISTMO(st))       return \"typed memory object\";\n#endif\n\treturn \"weird file\";\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_41A65F(unsigned int a1)\n{\n  printf(\" (\");\n  if ( a1 )\n  {\n    if ( a1 == 1 )\n    {\n      printf(\"default PIO mode, disable IORDY\");\n    }\n    else if ( a1 <= 7 || a1 > 0xF )\n    {\n      if ( a1 <= 0xF || a1 > 0x17 )\n      {\n        if ( a1 <= 0x1F || a1 > 0x27 )\n        {\n          if ( a1 <= 0x3F || a1 > 0x47 )\n            printf(\"unknown\");\n          else\n            printf(\"UltraDMA mode%u\", a1 - 64);\n        }\n        else\n        {\n          printf(\"multiword DMA mode%u\", a1 - 32);\n        }\n      }\n      else\n      {\n        printf(\"singleword DMA mode%u\", a1 - 16);\n      }\n    }\n    else\n    {\n      printf(\"PIO flow control mode%u\", a1 - 8);\n    }\n  }\n  else\n  {\n    printf(\"default PIO mode\");\n  }\n  return puts(\")\");\n}\n",
        "output": "static void print_mode(unsigned int mode)\n{\n    printf(\" (\");\n    if (mode == 0)\n    {\n        printf(\"default PIO mode\");\n    }\n    else if (mode == 1)\n    {\n        printf(\"default PIO mode, disable IORDY\");\n    }\n    else if (mode >= 2 && mode <= 7)\n    {\n        printf(\"PIO flow control mode%u\", mode - 8);\n    }\n    else if (mode >= 8 && mode <= 15)\n    {\n        printf(\"singleword DMA mode%u\", mode - 16);\n    }\n    else if (mode >= 16 && mode <= 23)\n    {\n        printf(\"multiword DMA mode%u\", mode - 32);\n    }\n    else if (mode >= 24 && mode <= 31)\n    {\n        printf(\"UltraDMA mode%u\", mode - 64);\n    }\n    else\n    {\n        printf(\"unknown\");\n    }\n    puts(\")\");\n}",
        "source_code": "static void interpret_xfermode(unsigned xfermode)\n{\n\tprintf(\" (\");\n\tif (xfermode == 0)\n\t\tprintf(\"default PIO mode\");\n\telse if (xfermode == 1)\n\t\tprintf(\"default PIO mode, disable IORDY\");\n\telse if (xfermode >= 8 && xfermode <= 15)\n\t\tprintf(\"PIO flow control mode%u\", xfermode - 8);\n\telse if (xfermode >= 16 && xfermode <= 23)\n\t\tprintf(\"singleword DMA mode%u\", xfermode - 16);\n\telse if (xfermode >= 32 && xfermode <= 39)\n\t\tprintf(\"multiword DMA mode%u\", xfermode - 32);\n\telse if (xfermode >= 64 && xfermode <= 71)\n\t\tprintf(\"UltraDMA mode%u\", xfermode - 64);\n\telse\n\t\tprintf(\"unknown\");\n\tprintf(\")\\n\");\n}",
        "parsed_output": "static void print_mode(unsigned int mode)\n{\n    printf(\" (\");\n    if (mode == 0)\n    {\n        printf(\"default PIO mode\");\n    }\n    else if (mode == 1)\n    {\n        printf(\"default PIO mode, disable IORDY\");\n    }\n    else if (mode >= 2 && mode <= 7)\n    {\n        printf(\"PIO flow control mode%u\", mode - 8);\n    }\n    else if (mode >= 8 && mode <= 15)\n    {\n        printf(\"singleword DMA mode%u\", mode - 16);\n    }\n    else if (mode >= 16 && mode <= 23)\n    {\n        printf(\"multiword DMA mode%u\", mode - 32);\n    }\n    else if (mode >= 24 && mode <= 31)\n    {\n        printf(\"UltraDMA mode%u\", mode - 64);\n    }\n    else\n    {\n        printf(\"unknown\");\n    }\n    puts(\")\");\n}",
        "baseline_code_stripped": "int __fastcall sub_41A65F(unsigned int a1)\n{\n  printf(\" (\");\n  if ( a1 )\n  {\n    if ( a1 == 1 )\n    {\n      printf(\"default PIO mode, disable IORDY\");\n    }\n    else if ( a1 <= 7 || a1 > 0xF )\n    {\n      if ( a1 <= 0xF || a1 > 0x17 )\n      {\n        if ( a1 <= 0x1F || a1 > 0x27 )\n        {\n          if ( a1 <= 0x3F || a1 > 0x47 )\n            printf(\"unknown\");\n          else\n            printf(\"UltraDMA mode%u\", a1 - 64);\n        }\n        else\n        {\n          printf(\"multiword DMA mode%u\", a1 - 32);\n        }\n      }\n      else\n      {\n        printf(\"singleword DMA mode%u\", a1 - 16);\n      }\n    }\n    else\n    {\n      printf(\"PIO flow control mode%u\", a1 - 8);\n    }\n  }\n  else\n  {\n    printf(\"default PIO mode\");\n  }\n  return puts(\")\");\n}\n",
        "baseline_code_debug": "void __cdecl interpret_xfermode(unsigned int xfermode)\n{\n  printf(\" (\");\n  if ( xfermode )\n  {\n    if ( xfermode == 1 )\n    {\n      printf(\"default PIO mode, disable IORDY\");\n    }\n    else if ( xfermode <= 7 || xfermode > 0xF )\n    {\n      if ( xfermode <= 0xF || xfermode > 0x17 )\n      {\n        if ( xfermode <= 0x1F || xfermode > 0x27 )\n        {\n          if ( xfermode <= 0x3F || xfermode > 0x47 )\n            printf(\"unknown\");\n          else\n            printf(\"UltraDMA mode%u\", xfermode - 64);\n        }\n        else\n        {\n          printf(\"multiword DMA mode%u\", xfermode - 32);\n        }\n      }\n      else\n      {\n        printf(\"singleword DMA mode%u\", xfermode - 16);\n      }\n    }\n    else\n    {\n      printf(\"PIO flow control mode%u\", xfermode - 8);\n    }\n  }\n  else\n  {\n    printf(\"default PIO mode\");\n  }\n  puts(\")\");\n}\n",
        "similarity_score_unixcoder": 0.9298915863037109,
        "similarity_score_baseline_stripped": 0.8640303015708923,
        "similarity_score_baseline_debug": 0.9551931023597717
    },
    {
        "func_name": "do_subst_w_backrefs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4DF387(int *a1, __int64 a2)\n{\n  int v2; // eax\n  __int64 result; // rax\n  __int64 v4; // [rsp+10h] [rbp-20h]\n  __int64 v5; // [rsp+18h] [rbp-18h]\n  __int64 v6; // [rsp+24h] [rbp-Ch]\n  __int64 i; // [rsp+28h] [rbp-8h]\n\n  if ( (*a1 & 0x800) != 0 )\n  {\n    v5 = *((_QWORD *)a1 + 3);\n  }\n  else\n  {\n    v2 = *a1;\n    BYTE1(v2) = BYTE1(*a1) | 8;\n    *a1 = v2;\n    v5 = 0LL;\n  }\n  *((_QWORD *)a1 + 3) = sub_40A0E8(*(unsigned int *)(a2 + 12) + 33LL, a2);\n  v4 = *((_QWORD *)a1 + 3);\n  *(_QWORD *)v4 = v4 + 24;\n  *(_QWORD *)(v4 + 8) = *(_QWORD *)v4;\n  *(_QWORD *)(v4 + 16) = v5;\n  LODWORD(v6) = 0;\n  while ( 1 )\n  {\n    result = *(unsigned int *)(a2 + 4);\n    if ( (unsigned int)v6 >= (unsigned int)result )\n      break;\n    for ( i = *(_QWORD *)(8LL * (unsigned int)v6 + *(_QWORD *)(a2 + 16)); i; i = *(_QWORD *)(i + 32) )\n    {\n      strcpy(*(char **)v4, (const char *)(i + 40));\n      sub_4DC55F((__int64 *)v4);\n    }\n    v6 = (unsigned int)(v6 + 1);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void hashwalk_init(var *v, xhash *array)\n{\n\thash_item *hi;\n\tunsigned i;\n\twalker_list *w;\n\twalker_list *prev_walker;\n\n\tif (v->type & VF_WALK) {\n\t\tprev_walker = v->x.walker;\n\t} else {\n\t\tv->type |= VF_WALK;\n\t\tprev_walker = NULL;\n\t}\n\tdebug_printf_walker(\"hashwalk_init: prev_walker:%p\\n\", prev_walker);\n\n\tw = v->x.walker = xzalloc(sizeof(*w) + array->glen + 1); /* why + 1? */\n\tdebug_printf_walker(\" walker@%p=%p\\n\", &v->x.walker, w);\n\tw->cur = w->end = w->wbuf;\n\tw->prev = prev_walker;\n\tfor (i = 0; i < array->csize; i++) {\n\t\thi = array->items[i];\n\t\twhile (hi) {\n\t\t\tstrcpy(w->end, hi->name);\n\t\t\tnextword(&w->end);\n\t\t\thi = hi->next;\n\t\t}\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_493918(__int64 a1, __int64 a2)\n{\n  int v2; // ebx\n  __int64 result; // rax\n  __int64 v4; // [rsp+18h] [rbp-20h]\n  char *v5; // [rsp+20h] [rbp-18h]\n  unsigned int i; // [rsp+2Ch] [rbp-Ch]\n\n  v5 = (char *)qword_75D408 + 2504;\n  for ( i = 0; ; ++i )\n  {\n    result = *((unsigned int *)qword_75D408 + 4);\n    if ( i >= (unsigned int)result )\n      break;\n    v4 = *(_QWORD *)v5;\n    if ( !*(_BYTE *)(*(_QWORD *)v5 + 4LL)\n      || *(_BYTE *)(v4 + 4) == 5\n      || *(_BYTE *)(v4 + 4) == 15\n      || *(_BYTE *)(v4 + 4) == 0x85 )\n    {\n      *(_DWORD *)(4LL * i + a1) = -1;\n      *(_DWORD *)(4LL * i + a2) = 0;\n    }\n    else\n    {\n      *(_DWORD *)(4LL * i + a1) = sub_490A13((__int64)v5);\n      v2 = *(_DWORD *)(4LL * i + a1);\n      *(_DWORD *)(4LL * i + a2) = v2 + sub_4908E3(v4) - 1;\n    }\n    v5 += 40;\n  }\n  return result;\n}\n\n\n Revised code:\nif ENABLE_FEATURE_FDISK_WRITABLE\nstatic void\nfill_bounds(sector_t *first, sector_t *last)\n{\n\tunsigned i;\n\tconst struct pte *pe = &ptes[0];\n\tconst struct partition *p;\n\n\tfor (i = 0; i < g_partitions; pe++,i++) {\n\t\tp = pe->part_table;\n\t\tif (!p->sys_ind || IS_EXTENDED(p->sys_ind)) {\n\t\t\tfirst[i] = 0xffffffff;\n\t\t\tlast[i] = 0;\n\t\t} else {\n\t\t\tfirst[i] = get_partition_start_from_dev_start(pe);\n\t\t\tlast[i] = first[i] + get_nr_sects(p) - 1;\n\t\t}\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4AF84C(__int64 a1, signed int a2)\n{\n  unsigned __int16 v2; // ax\n  __int64 result; // rax\n  __int16 v4[16]; // [rsp+10h] [rbp-30h]\n  int v5; // [rsp+30h] [rbp-10h]\n  unsigned int j; // [rsp+34h] [rbp-Ch]\n  int i; // [rsp+38h] [rbp-8h]\n  __int16 v8; // [rsp+3Eh] [rbp-2h]\n\n  v8 = 0;\n  for ( i = 1; i <= 15; ++i )\n  {\n    v8 = 2 * (*((_WORD *)qword_75D408 + i + 2619) + v8);\n    v4[i] = v8;\n  }\n  for ( j = 0; ; ++j )\n  {\n    result = j;\n    if ( (int)j > a2 )\n      break;\n    v5 = *(unsigned __int16 *)(4LL * (int)j + a1 + 2);\n    if ( v5 )\n    {\n      v2 = v4[v5];\n      v4[v5] = v2 + 1;\n      *(_WORD *)(4LL * (int)j + a1) = sub_4AE96D(v2, v5);\n    }\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void gen_codes(ct_data * tree, int max_code)\n{\n\tush next_code[MAX_BITS + 1];\t/* next code value for each bit length */\n\tush code = 0;\t\t/* running code value */\n\tint bits;\t\t\t/* bit index */\n\tint n;\t\t\t\t/* code index */\n\n\t/* The distribution counts are first used to generate the code values\n\t * without bit reversal.\n\t */\n\tfor (bits = 1; bits <= MAX_BITS; bits++) {\n\t\tnext_code[bits] = code = (code + G2.bl_count[bits - 1]) << 1;\n\t}\n\t/* Check that the bit counts in bl_count are consistent. The last code\n\t * must be all ones.\n\t */\n\tAssert(code + G2.bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,\n\t\t\t\"inconsistent bit counts\");\n\tTracev((stderr, \"\\ngen_codes: max_code %d \", max_code));\n\n\tfor (n = 0; n <= max_code; n++) {\n\t\tint len = tree[n].Len;\n\n\t\tif (len == 0)\n\t\t\tcontinue;\n\t\t/* Now reverse the bits */\n\t\ttree[n].Code = bi_reverse(next_code[len]++, len);\n\n\t\tTracec(tree != G2.static_ltree,\n\t\t\t   (stderr, \"\\nn %3d %c l %2d c %4x (%x) \", n,\n\t\t\t\t(n > ' ' ? n : ' '), len, tree[n].Code,\n\t\t\t\tnext_code[len] - 1));\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4E99A1(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  signed int v3; // eax\n  __int64 result; // rax\n  unsigned int v5; // [rsp+14h] [rbp-Ch]\n  int j; // [rsp+18h] [rbp-8h]\n  signed int k; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; ; ++i )\n  {\n    result = *(unsigned __int8 *)(i + a2);\n    if ( !(_BYTE)result )\n      break;\n    if ( *(_BYTE *)(i + a2) == 92 )\n    {\n      v5 = *(char *)(++i + a2) - 48;\n      if ( v5 > 9 )\n        goto LABEL_15;\n      if ( *(_DWORD *)&dest.c_cc[8 * v5 + 31] != -1 )\n      {\n        for ( j = *(_DWORD *)&dest.c_cc[8 * v5 + 31]; j < *(_DWORD *)&dest.c_cc[8 * v5 + 35]; ++j )\n        {\n          v2 = j;\n          sub_4E98F8(*(_BYTE *)(v2 + a1));\n        }\n      }\n    }\n    else\n    {\n      if ( *(_BYTE *)(i + a2) != 38 )\n      {\nLABEL_15:\n        sub_4E98F8(*(_BYTE *)(i + a2));\n        continue;\n      }\n      for ( k = *(_DWORD *)&dest.c_cc[31]; k < (signed int)dest.c_ispeed; ++k )\n      {\n        v3 = k;\n        sub_4E98F8(*(_BYTE *)(v3 + a1));\n      }\n    }\n  }\n  return result;\n}\n",
        "output": "static void process_input(char *input, int input_length)\n{\n    int i;\n    unsigned int v5;\n    int j;\n    int k;\n\n    for (i = 0; i < input_length; ++i)\n    {\n        if (input[i] == '\\0')\n            break;\n        if (input[i] == '\\\\')\n        {\n            v5 = input[++i] - '0';\n            if (v5 > 9)\n                continue;\n            if (dest.c_cc[8 * v5 + 31] != -1)\n            {\n                for (j = dest.c_cc[8 * v5 + 31]; j < dest.c_cc[8 * v5 + 35]; ++j)\n                {\n                    sub_4E98F8(input[j]);\n                }\n            }\n        }\n        else\n        {\n            if (input[i] != '&')\n            {\n                sub_4E98F8(input[i]);\n                continue;\n            }\n            for (k = dest.c_cc[31]; k < dest.c_ispeed; ++k)\n            {\n                sub_4E98F8(input[k]);\n            }\n        }\n    }\n}",
        "source_code": "static void do_subst_w_backrefs(char *line, char *replace)\n{\n\tint i, j;\n\n\t/* go through the replacement string */\n\tfor (i = 0; replace[i]; i++) {\n\t\t/* if we find a backreference (\\1, \\2, etc.) print the backref'ed text */\n\t\tif (replace[i] == '\\\\') {\n\t\t\tunsigned backref = replace[++i] - '0';\n\t\t\tif (backref <= 9) {\n\t\t\t\t/* print out the text held in G.regmatch[backref] */\n\t\t\t\tif (G.regmatch[backref].rm_so != -1) {\n\t\t\t\t\tj = G.regmatch[backref].rm_so;\n\t\t\t\t\twhile (j < G.regmatch[backref].rm_eo)\n\t\t\t\t\t\tpipe_putc(line[j++]);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* I _think_ it is impossible to get '\\' to be\n\t\t\t * the last char in replace string. Thus we dont check\n\t\t\t * for replace[i] == NUL. (counterexample anyone?) */\n\t\t\t/* if we find a backslash escaped character, print the character */\n\t\t\tpipe_putc(replace[i]);\n\t\t\tcontinue;\n\t\t}\n\t\t/* if we find an unescaped '&' print out the whole matched text. */\n\t\tif (replace[i] == '&') {\n\t\t\tj = G.regmatch[0].rm_so;\n\t\t\twhile (j < G.regmatch[0].rm_eo)\n\t\t\t\tpipe_putc(line[j++]);\n\t\t\tcontinue;\n\t\t}\n\t\t/* Otherwise just output the character. */\n\t\tpipe_putc(replace[i]);\n\t}\n}",
        "parsed_output": "static void process_input(char *input, int input_length)\n{\n    int i;\n    unsigned int v5;\n    int j;\n    int k;\n\n    for (i = 0; i < input_length; ++i)\n    {\n        if (input[i] == '\\0')\n            break;\n        if (input[i] == '\\\\')\n        {\n            v5 = input[++i] - '0';\n            if (v5 > 9)\n                continue;\n            if (dest.c_cc[8 * v5 + 31] != -1)\n            {\n                for (j = dest.c_cc[8 * v5 + 31]; j < dest.c_cc[8 * v5 + 35]; ++j)\n                {\n                    sub_4E98F8(input[j]);\n                }\n            }\n        }\n        else\n        {\n            if (input[i] != '&')\n            {\n                sub_4E98F8(input[i]);\n                continue;\n            }\n            for (k = dest.c_cc[31]; k < dest.c_ispeed; ++k)\n            {\n                sub_4E98F8(input[k]);\n            }\n        }\n    }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4E99A1(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  signed int v3; // eax\n  __int64 result; // rax\n  unsigned int v5; // [rsp+14h] [rbp-Ch]\n  int j; // [rsp+18h] [rbp-8h]\n  signed int k; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; ; ++i )\n  {\n    result = *(unsigned __int8 *)(i + a2);\n    if ( !(_BYTE)result )\n      break;\n    if ( *(_BYTE *)(i + a2) == 92 )\n    {\n      v5 = *(char *)(++i + a2) - 48;\n      if ( v5 > 9 )\n        goto LABEL_15;\n      if ( *(_DWORD *)&dest.c_cc[8 * v5 + 31] != -1 )\n      {\n        for ( j = *(_DWORD *)&dest.c_cc[8 * v5 + 31]; j < *(_DWORD *)&dest.c_cc[8 * v5 + 35]; ++j )\n        {\n          v2 = j;\n          sub_4E98F8(*(_BYTE *)(v2 + a1));\n        }\n      }\n    }\n    else\n    {\n      if ( *(_BYTE *)(i + a2) != 38 )\n      {\nLABEL_15:\n        sub_4E98F8(*(_BYTE *)(i + a2));\n        continue;\n      }\n      for ( k = *(_DWORD *)&dest.c_cc[31]; k < (signed int)dest.c_ispeed; ++k )\n      {\n        v3 = k;\n        sub_4E98F8(*(_BYTE *)(v3 + a1));\n      }\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl do_subst_w_backrefs(char *line, char *replace)\n{\n  int v2; // eax\n  int v3; // eax\n  unsigned int backref; // [rsp+14h] [rbp-Ch]\n  int j; // [rsp+18h] [rbp-8h]\n  int ja; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; replace[i]; ++i )\n  {\n    if ( replace[i] == 92 )\n    {\n      backref = replace[++i] - 48;\n      if ( backref > 9 )\n        goto LABEL_15;\n      if ( *(_DWORD *)&bb_common_bufsiz1.c_cc[8 * backref + 31] != -1 )\n      {\n        for ( j = *(_DWORD *)&bb_common_bufsiz1.c_cc[8 * backref + 31];\n              j < *(_DWORD *)&bb_common_bufsiz1.c_cc[8 * backref + 35];\n              ++j )\n        {\n          v2 = j;\n          pipe_putc(line[v2]);\n        }\n      }\n    }\n    else\n    {\n      if ( replace[i] != 38 )\n      {\nLABEL_15:\n        pipe_putc(replace[i]);\n        continue;\n      }\n      for ( ja = *(_DWORD *)&bb_common_bufsiz1.c_cc[31]; ja < (signed int)bb_common_bufsiz1.c_ispeed; ++ja )\n      {\n        v3 = ja;\n        pipe_putc(line[v3]);\n      }\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.6583772301673889,
        "similarity_score_baseline_stripped": 0.5019652843475342,
        "similarity_score_baseline_debug": 0.829400897026062
    },
    {
        "func_name": "xsocket_type",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4ED92D(void *a1, void *a2)\n{\n  void *v3; // [rsp+0h] [rbp-20h]\n  unsigned __int64 v4; // [rsp+0h] [rbp-20h]\n  void *v5; // [rsp+8h] [rbp-18h]\n  _BYTE *v6; // [rsp+8h] [rbp-18h]\n  unsigned int v7; // [rsp+1Ch] [rbp-4h]\n\n  v5 = a1;\n  v3 = a2;\n  if ( a2 < a1 )\n  {\n    v5 = a2;\n    v3 = a1;\n  }\n  v7 = 0;\n  v4 = sub_4ED77B(v3);\n  while ( (unsigned __int64)v5 <= v4 && (unsigned __int64)v5 <= *((_QWORD *)qword_75D408 + 1) - 1LL )\n  {\n    v6 = (_BYTE *)sub_4ED77B(v5);\n    if ( *v6 == 10 )\n      ++v7;\n    v5 = v6 + 1;\n  }\n  return v7;\n}\n\n\n Revised code:\ncount line from start to stop\nstatic int count_lines(char *start, char *stop)\n{\n\tchar *q;\n\tint cnt;\n\n\tif (stop < start) { // start and stop are backwards- reverse them\n\t\tq = start;\n\t\tstart = stop;\n\t\tstop = q;\n\t}\n\tcnt = 0;\n\tstop = end_line(stop);\n\twhile (start <= stop && start <= end - 1) {\n\t\tstart = end_line(start);\n\t\tif (*start == '\\n')\n\t\t\tcnt++;\n\t\tstart++;\n\t}\n\treturn cnt;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47B991(__int64 a1, __int64 a2, int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 result; // rax\n  _QWORD *v8; // rdx\n  int v10; // [rsp+2Ch] [rbp-4h]\n\n  if ( !a3 )\n    *(_QWORD *)(a1 + 24) = 0LL;\n  v10 = sub_40BECF((const char *)a2, 0LL, 10);\n  if ( *(_DWORD *)qword_75D400 || v10 < 0 )\n  {\n    if ( *(_BYTE *)a2 != 45 || *(_BYTE *)(a2 + 1) )\n    {\n      if ( a3 )\n        sub_46E514((__int64)\"bad fd number\", 0LL, v3, v4, v5, v6);\n      v8 = sub_47B950(a2, 0LL, v3, v4, v5, v6);\n      result = a1;\n      *(_QWORD *)(a1 + 24) = v8;\n    }\n    else\n    {\n      result = a1;\n      *(_DWORD *)(a1 + 20) = -1;\n    }\n  }\n  else\n  {\n    result = a1;\n    *(_DWORD *)(a1 + 20) = v10;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\nfixredir(union node *n, const char *text, int err)\n{\n\tint fd;\n\n\tTRACE((\"Fix redir %s %d\\n\", text, err));\n\tif (!err)\n\t\tn->ndup.vname = NULL;\n\n\tfd = bb_strtou(text, NULL, 10);\n\tif (!errno && fd >= 0)\n\t\tn->ndup.dupfd = fd;\n\telse if (LONE_DASH(text))\n\t\tn->ndup.dupfd = -1;\n\telse {\n\t\tif (err)\n\t\t\traise_error_syntax(\"bad fd number\");\n\t\tn->ndup.vname = makename();\n\t}\n}\n\n## Example:\n\n Input code:\nvoid __fastcall __noreturn sub_4CD85D(int a1, _QWORD *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  _QWORD *v6; // [rsp+0h] [rbp-20h]\n  int v7; // [rsp+Ch] [rbp-14h]\n  unsigned int v8; // [rsp+18h] [rbp-8h]\n  int v9; // [rsp+1Ch] [rbp-4h]\n\n  v7 = a1;\n  v8 = getpriority(PRIO_PROCESS, 0);\n  v6 = a2 + 1;\n  if ( !a2[1] )\n  {\n    printf(\"%d\\n\", v8);\n    sub_4F93C9(0LL);\n  }\n  v9 = 10;\n  if ( *(_BYTE *)*v6 == 45 )\n  {\n    if ( *(_BYTE *)(*v6 + 1LL) == 110 )\n    {\n      if ( *(_BYTE *)(*v6 + 2LL) )\n      {\n        *v6 += 2LL;\n        v6 = a2;\n        v7 = a1 + 1;\n      }\n    }\n    else\n    {\n      ++*v6;\n      v6 = a2;\n      v7 = a1 + 1;\n    }\n    if ( v7 <= 3 )\n      sub_407F64();\n    v9 = sub_50B272(v6[1], 3221225472LL, 0x3FFFFFFFLL);\n    v6 += 2;\n  }\n  if ( setpriority(PRIO_PROCESS, 0, v8 + v9) < 0 )\n    sub_4092A2((__int64)\"setpriority(%d)\", v8 + v9, v2, v3, v4, v5);\n  sub_4F931D(v6);\n}\n\n\n Revised code:\nint nice_main(int argc, char **argv)\n{\n\tint old_priority, adjustment;\n\n\told_priority = getpriority(PRIO_PROCESS, 0);\n\n\tif (!*++argv) { /* No args, so (GNU) output current nice value. */\n\t\tprintf(\"%d\\n\", old_priority);\n\t\tfflush_stdout_and_exit(EXIT_SUCCESS);\n\t}\n\n\tadjustment = 10;  /* Set default adjustment. */\n\n\tif (argv[0][0] == '-') {\n\t\tif (argv[0][1] == 'n') { /* -n */\n\t\t\tif (argv[0][2]) { /* -nNNNN (w/o space) */\n\t\t\t\targv[0] += 2; argv--; argc++;\n\t\t\t}\n\t\t} else { /* -NNN (NNN may be negative) == -n NNN */\n\t\t\targv[0] += 1; argv--; argc++;\n\t\t}\n\t\tif (argc < 4) {  /* Missing priority and/or utility! */\n\t\t\tbb_show_usage();\n\t\t}\n\t\tadjustment = xatoi_range(argv[1], INT_MIN/2, INT_MAX/2);\n\t\targv += 2;\n\t}\n\n\t{  /* Set our priority. */\n\t\tint prio = old_priority + adjustment;\n\n\t\tif (setpriority(PRIO_PROCESS, 0, prio) < 0) {\n\t\t\tbb_perror_msg_and_die(\"setpriority(%d)\", prio);\n\t\t}\n\t}\n\n\tBB_EXECVP_or_die(argv);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_50BB7E(_QWORD *a1, int a2, unsigned int a3)\n{\n  __int64 v3; // rsi\n  _WORD *v4; // rax\n  int v7; // [rsp+4h] [rbp-1Ch]\n  int v8; // [rsp+18h] [rbp-8h]\n  int v9; // [rsp+1Ch] [rbp-4h]\n\n  v7 = a2;\n  if ( !a2 )\n  {\n    v3 = a3;\n    v9 = socket(10, a3, 0);\n    if ( v9 >= 0 )\n    {\n      LOWORD(v7) = 10;\nLABEL_8:\n      v8 = 28;\n      goto LABEL_9;\n    }\n    v7 = 2;\n  }\n  v3 = a3;\n  v9 = sub_40A999(v7, a3, 0);\n  v8 = 16;\n  if ( v7 == 1 )\n    v8 = 110;\n  if ( v7 == 10 )\n    goto LABEL_8;\nLABEL_9:\n  v4 = sub_40A0E8(v8 + 4, v3);\n  *(_DWORD *)v4 = v8;\n  v4[2] = v7;\n  *a1 = v4;\n  return (unsigned int)v9;\n}\n",
        "output": "static int create_socket(_QWORD *socket_ptr, int protocol, unsigned int flags)\n{\n\tint sockfd;\n\tint type;\n\n\tif (!protocol) {\n\t\tsockfd = socket(AF_INET, protocol, 0);\n\t\tif (sockfd >= 0) {\n\t\t\ttype = SOCK_STREAM;\n\t\t\tgoto LABEL_8;\n\t\t}\n\t\tprotocol = 2;\n\t}\n\tsockfd = sub_40A999(protocol, flags, 0);\n\ttype = SOCK_DGRAM;\n\tif (protocol == 1)\n\t\ttype = SOCK_RAW;\n\tif (protocol == 10)\n\t\tgoto LABEL_8;\nLABEL_9:\n\t_WORD *buffer = sub_40A0E8(type + 4, flags);\n\t*(_DWORD *)buffer = type;\n\tbuffer[2] = protocol;\n\t*socket_ptr = buffer;\n\treturn sockfd;\n}",
        "source_code": "int FAST_FUNC xsocket_type(len_and_sockaddr **lsap, int family, int sock_type)\n{\n\tlen_and_sockaddr *lsa;\n\tint fd;\n\tint len;\n\n\tif (family == AF_UNSPEC) {\n#if ENABLE_FEATURE_IPV6\n\t\tfd = socket(AF_INET6, sock_type, 0);\n\t\tif (fd >= 0) {\n\t\t\tfamily = AF_INET6;\n\t\t\tgoto done;\n\t\t}\n#endif\n\t\tfamily = AF_INET;\n\t}\n\n\tfd = xsocket(family, sock_type, 0);\n\n\tlen = sizeof(struct sockaddr_in);\n\tif (family == AF_UNIX)\n\t\tlen = sizeof(struct sockaddr_un);\n#if ENABLE_FEATURE_IPV6\n\tif (family == AF_INET6) {\n done:\n\t\tlen = sizeof(struct sockaddr_in6);\n\t}\n#endif\n\tlsa = xzalloc(LSA_LEN_SIZE + len);\n\tlsa->len = len;\n\tlsa->u.sa.sa_family = family;\n\t*lsap = lsa;\n\treturn fd;\n}",
        "parsed_output": "static int create_socket(_QWORD *socket_ptr, int protocol, unsigned int flags)\n{\n\tint sockfd;\n\tint type;\n\n\tif (!protocol) {\n\t\tsockfd = socket(AF_INET, protocol, 0);\n\t\tif (sockfd >= 0) {\n\t\t\ttype = SOCK_STREAM;\n\t\t\tgoto LABEL_8;\n\t\t}\n\t\tprotocol = 2;\n\t}\n\tsockfd = sub_40A999(protocol, flags, 0);\n\ttype = SOCK_DGRAM;\n\tif (protocol == 1)\n\t\ttype = SOCK_RAW;\n\tif (protocol == 10)\n\t\tgoto LABEL_8;\nLABEL_9:\n\t_WORD *buffer = sub_40A0E8(type + 4, flags);\n\t*(_DWORD *)buffer = type;\n\tbuffer[2] = protocol;\n\t*socket_ptr = buffer;\n\treturn sockfd;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_50BB7E(_QWORD *a1, int a2, unsigned int a3)\n{\n  __int64 v3; // rsi\n  _WORD *v4; // rax\n  int v7; // [rsp+4h] [rbp-1Ch]\n  int v8; // [rsp+18h] [rbp-8h]\n  int v9; // [rsp+1Ch] [rbp-4h]\n\n  v7 = a2;\n  if ( !a2 )\n  {\n    v3 = a3;\n    v9 = socket(10, a3, 0);\n    if ( v9 >= 0 )\n    {\n      LOWORD(v7) = 10;\nLABEL_8:\n      v8 = 28;\n      goto LABEL_9;\n    }\n    v7 = 2;\n  }\n  v3 = a3;\n  v9 = sub_40A999(v7, a3, 0);\n  v8 = 16;\n  if ( v7 == 1 )\n    v8 = 110;\n  if ( v7 == 10 )\n    goto LABEL_8;\nLABEL_9:\n  v4 = sub_40A0E8(v8 + 4, v3);\n  *(_DWORD *)v4 = v8;\n  v4[2] = v7;\n  *a1 = v4;\n  return (unsigned int)v9;\n}\n",
        "baseline_code_debug": "int __cdecl xsocket_type(len_and_sockaddr_0 **lsap, int family, int sock_type)\n{\n  len_and_sockaddr_0 *v3; // rax\n  int familya; // [rsp+4h] [rbp-1Ch]\n  int len; // [rsp+18h] [rbp-8h]\n  int fd; // [rsp+1Ch] [rbp-4h]\n\n  familya = family;\n  if ( !family )\n  {\n    fd = socket(10, sock_type, 0);\n    if ( fd >= 0 )\n    {\n      LOWORD(familya) = 10;\ndone:\n      len = 28;\n      goto LABEL_9;\n    }\n    familya = 2;\n  }\n  fd = xsocket(familya, sock_type, 0);\n  len = 16;\n  if ( familya == 1 )\n    len = 110;\n  if ( familya == 10 )\n    goto done;\nLABEL_9:\n  v3 = (len_and_sockaddr_0 *)xzalloc(len + 4);\n  v3->len = len;\n  v3->u.sa.sa_family = familya;\n  *lsap = v3;\n  return fd;\n}\n",
        "similarity_score_unixcoder": 0.7545139193534851,
        "similarity_score_baseline_stripped": 0.6170375347137451,
        "similarity_score_baseline_debug": 0.8826645016670227
    },
    {
        "func_name": "o_addstr_with_NUL",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_48153D(__int64 a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  return sub_4814C5(a1, a2, v2);\n}\n\n\n Revised code:\nstatic void o_addstr(o_string *o, const char *str)\n{\n\to_addblock(o, str, strlen(str));\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_48187C(__int64 a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  return sub_48182B(a1, a2, v2);\n}\n\n\n Revised code:\nstatic void o_addQstr(o_string *o, const char *str)\n{\n\to_addQblock(o, str, strlen(str));\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_480D48(const char *a1)\n{\n  int v1; // eax\n\n  v1 = strlen(a1);\n  return sub_480C0A(a1, v1);\n}\n\n\n Revised code:\nstatic int unset_local_var(const char *name)\n{\n\treturn unset_local_var_len(name, strlen(name));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_481571(__int64 a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  return sub_4814C5(a1, a2, v2 + 1);\n}\n",
        "output": "static void o_addstr(o_string *o, const char *str)\n{\n\to_addblock(o, str, strlen(str) + 1);\n}",
        "source_code": "endif\n\nstatic void o_addstr_with_NUL(o_string *o, const char *str)\n{\n\to_addblock(o, str, strlen(str) + 1);\n}",
        "parsed_output": "static void o_addstr(o_string *o, const char *str)\n{\n\to_addblock(o, str, strlen(str) + 1);\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_481571(__int64 a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  return sub_4814C5(a1, a2, v2 + 1);\n}\n",
        "baseline_code_debug": "void __cdecl o_addstr_with_NUL(o_string_0 *o, const char *str)\n{\n  int v2; // edx\n\n  v2 = strlen(str) + 1;\n  o_addblock(o, str, v2);\n}\n",
        "similarity_score_unixcoder": 0.9223321080207825,
        "similarity_score_baseline_stripped": 0.5025771856307983,
        "similarity_score_baseline_debug": 0.8282907009124756
    },
    {
        "func_name": "addgroup_wrapper",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40D471(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v7; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v8; // [rsp+20h] [rbp-20h]\n  char *v9; // [rsp+38h] [rbp-8h]\n\n  v8 = a2;\n  v7 = a1;\n  sub_40D371((__int64)&v7, a2);\n  v9 = sub_40A6B3(\"x:%u:\", v8, v2, v3, v4, v5);\n  if ( (int)sub_50967B(\"/etc/group\", a1, v9, 0LL) < 0 )\n    exit(1);\n  return sub_50967B(\"/etc/gshadow\", a1, \"!::\", 0LL);\n}\n\n\n Revised code:\nstatic void new_group(char *group, gid_t gid)\n{\n\tstruct group gr;\n\tchar *p;\n\n\t/* make sure gid and group haven't already been allocated */\n\tgr.gr_gid = gid;\n\tgr.gr_name = group;\n\txgroup_study(&gr);\n\n\t/* add entry to group */\n\tp = xasprintf(\"x:%u:\", (unsigned) gr.gr_gid);\n\tif (update_passwd(bb_path_group_file, group, p, NULL) < 0)\n\t\texit(EXIT_FAILURE);\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tfree(p);\n#if ENABLE_FEATURE_SHADOWPASSWDS\n\t/* /etc/gshadow fields:\n\t * 1. Group name.\n\t * 2. Encrypted password.\n\t *    If set, non-members of the group can join the group\n\t *    by typing the password for that group using the newgrp command.\n\t *    If the value is of this field ! then no user is allowed\n\t *    to access the group using the newgrp command. A value of !!\n\t *    is treated the same as a value of ! only it indicates\n\t *    that a password has never been set before. If the value is null,\n\t *    only group members can log into the group.\n\t * 3. Group administrators (comma delimited list).\n\t *    Group members listed here can add or remove group members\n\t *    using the gpasswd command.\n\t * 4. Group members (comma delimited list).\n\t */\n\t/* Ignore errors: if file is missing we assume admin doesn't want it */\n\tupdate_passwd(bb_path_gshadow_file, group, \"!::\", NULL);\n#endif\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_43A1E5(__int64 a1, const char *a2)\n{\n  char v3[48]; // [rsp+10h] [rbp-70h] BYREF\n  char v4[44]; // [rsp+40h] [rbp-40h] BYREF\n  int v5; // [rsp+6Ch] [rbp-14h]\n\n  v5 = sscanf(\n         a2,\n         \"%*d: %32[0-9A-Fa-f]:%X %32[0-9A-Fa-f]:%X %X %lX:%lX %*X:%*X %*X %d %*d %ld \",\n         v4,\n         a1,\n         v3,\n         a1 + 4,\n         a1 + 8,\n         a1 + 80,\n         a1 + 72,\n         a1 + 12,\n         a1 + 88);\n  if ( v5 <= 8 )\n    return 1LL;\n  if ( strlen(v4) <= 8 )\n  {\n    sub_43A0BE(v4, (_WORD *)(a1 + 16));\n    sub_43A0BE(v3, (_WORD *)(a1 + 44));\n  }\n  else\n  {\n    sub_43A037(v4, (_WORD *)(a1 + 16));\n    sub_43A037(v3, (_WORD *)(a1 + 44));\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic int scan_inet_proc_line(struct inet_params *param, char *line)\n{\n\tint num;\n\t/* IPv6 /proc files use 32-char hex representation\n\t * of IPv6 address, followed by :PORT_IN_HEX\n\t */\n\tchar local_addr[33], rem_addr[33]; /* 32 + 1 for NUL */\n\n\tnum = sscanf(line,\n\t\t\t\"%*d: %32[0-9A-Fa-f]:%X \"\n\t\t\t\"%32[0-9A-Fa-f]:%X %X \"\n\t\t\t\"%lX:%lX %*X:%*X \"\n\t\t\t\"%*X %d %*d %ld \",\n\t\t\tlocal_addr, &param->local_port,\n\t\t\trem_addr, &param->rem_port, &param->state,\n\t\t\t&param->txq, &param->rxq,\n\t\t\t&param->uid, &param->inode);\n\tif (num < 9) {\n\t\treturn 1; /* error */\n\t}\n\n\tif (strlen(local_addr) > 8) {\n#if ENABLE_FEATURE_IPV6\n\t\tbuild_ipv6_addr(local_addr, &param->localaddr.sin6);\n\t\tbuild_ipv6_addr(rem_addr, &param->remaddr.sin6);\n#endif\n\t} else {\n\t\tbuild_ipv4_addr(local_addr, &param->localaddr.sin);\n\t\tbuild_ipv4_addr(rem_addr, &param->remaddr.sin);\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_43A583(const char *a1)\n{\n  _BOOL4 v2; // eax\n  const char *v3; // rax\n  char v4[8]; // [rsp+10h] [rbp-70h] BYREF\n  int v5; // [rsp+18h] [rbp-68h]\n  __int16 v6; // [rsp+3Ch] [rbp-44h]\n  int v7; // [rsp+40h] [rbp-40h]\n  int v8; // [rsp+44h] [rbp-3Ch]\n  int v9; // [rsp+48h] [rbp-38h]\n  int v10; // [rsp+4Ch] [rbp-34h]\n  int v11; // [rsp+50h] [rbp-30h]\n  int v12; // [rsp+7Ch] [rbp-4h]\n\n  if ( (unsigned int)sub_43A1E5((__int64)v4, a1) )\n    return 1LL;\n  v2 = v6 == 10 && v10 | v9 | v8 | v11 || v6 == 2 && v7;\n  v12 = v2;\n  v3 = sub_409B8C(v5);\n  sub_43A2EA((__int64)v4, v3, \"raw\", v12);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC raw_do_one(char *line)\n{\n\tint have_remaddr;\n\tstruct inet_params param;\n\n\tif (scan_inet_proc_line(&param, line))\n\t\treturn 1;\n\n\thave_remaddr = NOT_NULL_ADDR(param.remaddr);\n\tprint_inet_line(&param, itoa(param.state), \"raw\", have_remaddr);\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40D7F2(__int64 a1, const char *a2)\n{\n  const char *v3; // [rsp+10h] [rbp-30h] BYREF\n  const char *v4; // [rsp+18h] [rbp-28h]\n  _BYTE *v5; // [rsp+20h] [rbp-20h]\n  const char *v6; // [rsp+28h] [rbp-18h]\n  _BYTE *v7; // [rsp+30h] [rbp-10h]\n  __int64 v8; // [rsp+38h] [rbp-8h]\n\n  v3 = \"addgroup\";\n  if ( a2 )\n  {\n    v4 = \"--\";\n    v5 = *(_BYTE **)a1;\n    v6 = a2;\n    v7 = 0LL;\n  }\n  else\n  {\n    v4 = \"--gid\";\n    v5 = sub_409B63(*(_DWORD *)(a1 + 20));\n    v6 = \"--\";\n    v7 = *(_BYTE **)a1;\n    v8 = 0LL;\n  }\n  return sub_50A624(&v3);\n}\n",
        "output": "static void add_group(const char *group_name, const char *gid)\n{\n\tconst char *arg1 = \"addgroup\";\n\tconst char *arg2 = \"--\";\n\tconst char *arg3 = \"--gid\";\n\tconst char *arg4 = NULL;\n\tconst char *arg5 = NULL;\n\n\tif (gid) {\n\t\targ1 = \"addgroup\";\n\t\targ2 = \"--\";\n\t\targ3 = group_name;\n\t\targ4 = gid;\n\t} else {\n\t\targ1 = \"addgroup\";\n\t\targ2 = \"--gid\";\n\t\targ3 = group_name;\n\t\targ4 = \"--\";\n\t\targ5 = gid;\n\t}\n\n\tsub_50A624(arg1, arg2, arg3, arg4, arg5);\n}",
        "source_code": "static int addgroup_wrapper(struct passwd *p, const char *group_name)\n{\n\tchar *argv[6];\n\n\targv[0] = (char*)\"addgroup\";\n\tif (group_name) {\n\t\t/* Add user to existing group */\n\t\targv[1] = (char*)\"--\";\n\t\targv[2] = p->pw_name;\n\t\targv[3] = (char*)group_name;\n\t\targv[4] = NULL;\n\t} else {\n\t\t/* Add user to his own group with the first free gid\n\t\t * found in passwd_study.\n\t\t */\n#if ENABLE_FEATURE_ADDGROUP_LONG_OPTIONS || !ENABLE_ADDGROUP\n\t\t/* We try to use --gid, not -g, because \"standard\" addgroup\n\t\t * has no short option -g, it has only long --gid.\n\t\t */\n\t\targv[1] = (char*)\"--gid\";\n#else\n\t\t/* Breaks if system in fact does NOT use busybox addgroup */\n\t\targv[1] = (char*)\"-g\";\n#endif\n\t\targv[2] = utoa(p->pw_gid);\n\t\targv[3] = (char*)\"--\";\n\t\targv[4] = p->pw_name;\n\t\targv[5] = NULL;\n\t}\n\n\treturn spawn_and_wait(argv);\n}",
        "parsed_output": "static void add_group(const char *group_name, const char *gid)\n{\n\tconst char *arg1 = \"addgroup\";\n\tconst char *arg2 = \"--\";\n\tconst char *arg3 = \"--gid\";\n\tconst char *arg4 = NULL;\n\tconst char *arg5 = NULL;\n\n\tif (gid) {\n\t\targ1 = \"addgroup\";\n\t\targ2 = \"--\";\n\t\targ3 = group_name;\n\t\targ4 = gid;\n\t} else {\n\t\targ1 = \"addgroup\";\n\t\targ2 = \"--gid\";\n\t\targ3 = group_name;\n\t\targ4 = \"--\";\n\t\targ5 = gid;\n\t}\n\n\tsub_50A624(arg1, arg2, arg3, arg4, arg5);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40D7F2(__int64 a1, const char *a2)\n{\n  const char *v3; // [rsp+10h] [rbp-30h] BYREF\n  const char *v4; // [rsp+18h] [rbp-28h]\n  _BYTE *v5; // [rsp+20h] [rbp-20h]\n  const char *v6; // [rsp+28h] [rbp-18h]\n  _BYTE *v7; // [rsp+30h] [rbp-10h]\n  __int64 v8; // [rsp+38h] [rbp-8h]\n\n  v3 = \"addgroup\";\n  if ( a2 )\n  {\n    v4 = \"--\";\n    v5 = *(_BYTE **)a1;\n    v6 = a2;\n    v7 = 0LL;\n  }\n  else\n  {\n    v4 = \"--gid\";\n    v5 = sub_409B63(*(_DWORD *)(a1 + 20));\n    v6 = \"--\";\n    v7 = *(_BYTE **)a1;\n    v8 = 0LL;\n  }\n  return sub_50A624(&v3);\n}\n",
        "baseline_code_debug": "int __cdecl addgroup_wrapper(passwd *p, const char *group_name)\n{\n  char *argv[6]; // [rsp+10h] [rbp-30h] BYREF\n\n  argv[0] = \"addgroup\";\n  if ( group_name )\n  {\n    argv[1] = \"--\";\n    argv[2] = p->pw_name;\n    argv[3] = (char *)group_name;\n    argv[4] = 0LL;\n  }\n  else\n  {\n    argv[1] = \"--gid\";\n    argv[2] = utoa(p->pw_gid);\n    argv[3] = \"--\";\n    argv[4] = p->pw_name;\n    argv[5] = 0LL;\n  }\n  return spawn_and_wait(argv);\n}\n",
        "similarity_score_unixcoder": 0.7555468082427979,
        "similarity_score_baseline_stripped": 0.5966931581497192,
        "similarity_score_baseline_debug": 0.8558531403541565
    },
    {
        "func_name": "recover_mode",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_451C40(_DWORD *a1, int a2, const char *a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 v8; // rdx\n  __int64 v9; // rcx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  char *s; // [rsp+8h] [rbp-58h]\n  unsigned int v13; // [rsp+2Ch] [rbp-34h] BYREF\n  char v14[4]; // [rsp+30h] [rbp-30h] BYREF\n  int v15; // [rsp+34h] [rbp-2Ch]\n  char *v16; // [rsp+50h] [rbp-10h]\n  int i; // [rsp+5Ch] [rbp-4h]\n\n  s = (char *)a3;\n  if ( strchr(a3, 46) )\n  {\n    if ( (unsigned int)sub_452DAB(v14, s, 2LL) )\n    {\n      sub_409747(\"\\\"%s\\\" is invalid lladdr\", (__int64)s, v3, v4, v5, v6);\n      return 0xFFFFFFFFLL;\n    }\n    else if ( a2 > 3 )\n    {\n      *a1 = v15;\n      return 4LL;\n    }\n    else\n    {\n      return 0xFFFFFFFFLL;\n    }\n  }\n  else\n  {\n    for ( i = 0; i < a2; ++i )\n    {\n      v16 = strchr(s, 58);\n      if ( v16 )\n        *v16++ = 0;\n      if ( sscanf(s, \"%x\", &v13) != 1 || v13 >= 0x100 )\n      {\n        sub_409747(\"\\\"%s\\\" is invalid lladdr\", (__int64)s, v8, v9, v10, v11);\n        return 0xFFFFFFFFLL;\n      }\n      *((_BYTE *)a1 + i) = v13;\n      if ( !v16 )\n        break;\n      s = v16;\n    }\n    return (unsigned int)(i + 1);\n  }\n}\n\n\n Revised code:\nint FAST_FUNC ll_addr_a2n(unsigned char *lladdr, int len, char *arg)\n{\n\tint i;\n\n\tif (strchr(arg, '.')) {\n\t\tinet_prefix pfx;\n\t\tif (get_addr_1(&pfx, arg, AF_INET)) {\n\t\t\tbb_error_msg(\"\\\"%s\\\" is invalid lladdr\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tif (len < 4) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(lladdr, pfx.data, 4);\n\t\treturn 4;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tint temp;\n\t\tchar *cp = strchr(arg, ':');\n\t\tif (cp) {\n\t\t\t*cp = 0;\n\t\t\tcp++;\n\t\t}\n\t\tif (sscanf(arg, \"%x\", &temp) != 1 || (temp < 0 || temp > 255)) {\n\t\t\tbb_error_msg(\"\\\"%s\\\" is invalid lladdr\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tlladdr[i] = temp;\n\t\tif (!cp) {\n\t\t\tbreak;\n\t\t}\n\t\targ = cp;\n\t}\n\treturn i+1;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_428FC2(const char *a1, __int64 a2)\n{\n  const char *v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v9; // [rsp+10h] [rbp-20h] BYREF\n  char v10; // [rsp+14h] [rbp-1Ch] BYREF\n  char v11; // [rsp+18h] [rbp-18h] BYREF\n  char v12; // [rsp+1Ch] [rbp-14h] BYREF\n  char v13; // [rsp+20h] [rbp-10h] BYREF\n  char v14; // [rsp+24h] [rbp-Ch] BYREF\n  int i; // [rsp+28h] [rbp-8h]\n  int v16; // [rsp+2Ch] [rbp-4h]\n\n  v2 = \"%2x:%2x:%2x:%2x:%2x:%2x\";\n  v16 = sscanf(a1, \"%2x:%2x:%2x:%2x:%2x:%2x\", &v9, &v10, &v11, &v12, &v13, &v14);\n  if ( v16 <= 3 )\n  {\n    v2 = \"%u.%u.%u.%u\";\n    v16 = sscanf(a1, \"%u.%u.%u.%u\", &v9, &v10, &v11, &v12);\n  }\n  if ( v16 > 3 )\n  {\n    for ( i = 0; i < v16; ++i )\n      *(_BYTE *)(i + a2) = *(&v9 + i);\n    return (unsigned int)v16;\n  }\n  else\n  {\n    sub_409747(\"can't read Wake-On-LAN pass\", (__int64)v2, v3, v4, v5, v6);\n    return 0LL;\n  }\n}\n\n\n Revised code:\nstatic int get_wol_pw(const char *ethoptarg, unsigned char *wol_passwd)\n{\n\tunsigned passwd[6];\n\tint byte_cnt, i;\n\n\t/* handle MAC format */\n\tbyte_cnt = sscanf(ethoptarg, \"%2x:%2x:%2x:%2x:%2x:%2x\",\n\t                  &passwd[0], &passwd[1], &passwd[2],\n\t                  &passwd[3], &passwd[4], &passwd[5]);\n\t/* handle IP format */\n// FIXME: why < 4?? should it be < 6?\n\tif (byte_cnt < 4)\n\t\tbyte_cnt = sscanf(ethoptarg, \"%u.%u.%u.%u\",\n\t\t                  &passwd[0], &passwd[1], &passwd[2], &passwd[3]);\n\tif (byte_cnt < 4) {\n\t\tbb_error_msg(\"can't read Wake-On-LAN pass\");\n\t\treturn 0;\n\t}\n// TODO: check invalid numbers >255??\n\tfor (i = 0; i < byte_cnt; ++i)\n\t\twol_passwd[i] = passwd[i];\n\n\tbb_debug_msg(\"password: %2.2x %2.2x %2.2x %2.2x (%d)\\n\\n\",\n\t             wol_passwd[0], wol_passwd[1], wol_passwd[2], wol_passwd[3],\n\t             byte_cnt);\n\n\treturn byte_cnt;\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_464C09(const char *a1, __int64 a2, char a3)\n{\n  char s[100]; // [rsp+20h] [rbp-210h] BYREF\n  char v5[8]; // [rsp+84h] [rbp-1ACh] BYREF\n  char v6[8]; // [rsp+8Ch] [rbp-1A4h] BYREF\n  char v7[8]; // [rsp+94h] [rbp-19Ch] BYREF\n  char v8[12]; // [rsp+9Ch] [rbp-194h] BYREF\n  char v9[12]; // [rsp+A8h] [rbp-188h] BYREF\n  char v10[109]; // [rsp+B4h] [rbp-17Ch] BYREF\n  __int64 v11; // [rsp+121h] [rbp-10Fh]\n  unsigned int v12; // [rsp+228h] [rbp-8h]\n  int i; // [rsp+22Ch] [rbp-4h]\n\n  memset(s, 0, 0x200uLL);\n  strcpy(s, a1);\n  sprintf(v5, \"%o\", *(_DWORD *)(a2 + 24) & 0x1FF);\n  sprintf(v6, \"%o\", *(_DWORD *)(a2 + 28) & 0x1FFFFF);\n  sprintf(v7, \"%o\", *(_DWORD *)(a2 + 32) & 0x1FFFFF);\n  sprintf(v8, \"%o\", (unsigned int)*(_QWORD *)(a2 + 48));\n  sprintf(v9, \"%llo\", *(_QWORD *)(a2 + 88) & 0x1FFFFFFFFLL);\n  v10[8] = a3;\n  v11 = 0x20207261747375LL;\n  v10[7] = 32;\n  v12 = 224;\n  for ( i = 0; i <= 511; ++i )\n    v12 += (unsigned __int8)s[i];\n  sprintf(v10, \"%06o\", v12);\n  sub_40A4AB(1u, (__int64)s, 512LL);\n}\n\n\n Revised code:\nstatic void writeheader(const char *path, struct stat *sb, int type)\n{\n\tstruct tar_header_t header;\n\tint i, sum;\n\n\tmemset(&header, 0, TAR_BLOCK_SIZE);\n\tstrcpy(header.name, path);\n\tsprintf(header.mode, \"%o\", sb->st_mode & 0777);\n\t/* careful to not overflow fields! */\n\tsprintf(header.uid, \"%o\", sb->st_uid & 07777777);\n\tsprintf(header.gid, \"%o\", sb->st_gid & 07777777);\n\tsprintf(header.size, \"%o\", (unsigned)sb->st_size);\n\tsprintf(header.mtime, \"%llo\", sb->st_mtime & 077777777777LL);\n\theader.typeflag = type;\n\tstrcpy(header.magic, \"ustar  \"); /* like GNU tar */\n\n\t/* Calculate and store the checksum (the sum of all of the bytes of\n\t * the header). The checksum field must be filled with blanks for the\n\t * calculation. The checksum field is formatted differently from the\n\t * other fields: it has 6 digits, a NUL, then a space -- rather than\n\t * digits, followed by a NUL like the other fields... */\n\theader.chksum[7] = ' ';\n\tsum = ' ' * 7;\n\tfor (i = 0; i < TAR_BLOCK_SIZE; i++)\n\t\tsum += ((unsigned char*)&header)[i];\n\tsprintf(header.chksum, \"%06o\", sum);\n\n\txwrite(STDOUT_FILENO, &header, TAR_BLOCK_SIZE);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BOOL8 __fastcall sub_4D38D9(const char *a1, _DWORD *a2)\n{\n  char *s; // [rsp+10h] [rbp-38h]\n  __int64 v4; // [rsp+18h] [rbp-30h] BYREF\n  __int64 v5; // [rsp+20h] [rbp-28h] BYREF\n  __int64 v6; // [rsp+28h] [rbp-20h] BYREF\n  __int64 v7; // [rsp+30h] [rbp-18h] BYREF\n  int v8; // [rsp+3Ch] [rbp-Ch] BYREF\n  int v9; // [rsp+40h] [rbp-8h] BYREF\n  int i; // [rsp+44h] [rbp-4h]\n\n  if ( sscanf(a1, \"%lx:%lx:%lx:%lx%n\", &v7, &v6, &v5, &v4, &v9) != 4 )\n    return 0LL;\n  *a2 = v7;\n  a2[1] = v6;\n  a2[2] = v5;\n  a2[3] = v4;\n  s = (char *)&a1[v9];\n  for ( i = 0; i <= 31; ++i )\n  {\n    if ( sscanf(s, \":%x%n\", &v8, &v9) != 1 )\n      return 0LL;\n    *((_BYTE *)a2 + i + 17) = v8;\n    s += v9;\n  }\n  return *s == 0;\n}\n",
        "output": "_BOOL8 FAST_FUNC parse_mac(const char *mac_str, uint8_t *mac)\n{\n    char *s;\n    uint64_t v4, v5, v6, v7;\n    int v8, v9;\n    int i;\n\n    if (sscanf(mac_str, \"%lx:%lx:%lx:%lx%n\", &v7, &v6, &v5, &v4, &v9) != 4)\n        return 0;\n\n    mac[0] = (v7 >> 40) & 0xFF;\n    mac[1] = (v7 >> 32) & 0xFF;\n    mac[2] = (v7 >> 24) & 0xFF;\n    mac[3] = (v7 >> 16) & 0xFF;\n    mac[4] = (v7 >> 8) & 0xFF;\n    mac[5] = v7 & 0xFF;\n\n    s = (char *)&mac_str[v9];\n    for (i = 0; i <= 31; ++i)\n    {\n        if (sscanf(s, \":%x%n\", &v8, &v9) != 1)\n            return 0;\n        mac[i + 6] = v8;\n        s += v9;\n    }\n\n    return *s == 0;\n}",
        "source_code": "static int recover_mode(const char *arg, struct termios *mode)\n{\n\tint i, n;\n\tunsigned chr;\n\tunsigned long iflag, oflag, cflag, lflag;\n\n\t/* Scan into temporaries since it is too much trouble to figure out\n\t   the right format for 'tcflag_t' */\n\tif (sscanf(arg, \"%lx:%lx:%lx:%lx%n\",\n\t\t\t   &iflag, &oflag, &cflag, &lflag, &n) != 4)\n\t\treturn 0;\n\tmode->c_iflag = iflag;\n\tmode->c_oflag = oflag;\n\tmode->c_cflag = cflag;\n\tmode->c_lflag = lflag;\n\targ += n;\n\tfor (i = 0; i < NCCS; ++i) {\n\t\tif (sscanf(arg, \":%x%n\", &chr, &n) != 1)\n\t\t\treturn 0;\n\t\tmode->c_cc[i] = chr;\n\t\targ += n;\n\t}\n\n\t/* Fail if there are too many fields */\n\tif (*arg != '\\0')\n\t\treturn 0;\n\n\treturn 1;\n}",
        "parsed_output": "_BOOL8 FAST_FUNC parse_mac(const char *mac_str, uint8_t *mac)\n{\n    char *s;\n    uint64_t v4, v5, v6, v7;\n    int v8, v9;\n    int i;\n\n    if (sscanf(mac_str, \"%lx:%lx:%lx:%lx%n\", &v7, &v6, &v5, &v4, &v9) != 4)\n        return 0;\n\n    mac[0] = (v7 >> 40) & 0xFF;\n    mac[1] = (v7 >> 32) & 0xFF;\n    mac[2] = (v7 >> 24) & 0xFF;\n    mac[3] = (v7 >> 16) & 0xFF;\n    mac[4] = (v7 >> 8) & 0xFF;\n    mac[5] = v7 & 0xFF;\n\n    s = (char *)&mac_str[v9];\n    for (i = 0; i <= 31; ++i)\n    {\n        if (sscanf(s, \":%x%n\", &v8, &v9) != 1)\n            return 0;\n        mac[i + 6] = v8;\n        s += v9;\n    }\n\n    return *s == 0;\n}",
        "baseline_code_stripped": "_BOOL8 __fastcall sub_4D38D9(const char *a1, _DWORD *a2)\n{\n  char *s; // [rsp+10h] [rbp-38h]\n  __int64 v4; // [rsp+18h] [rbp-30h] BYREF\n  __int64 v5; // [rsp+20h] [rbp-28h] BYREF\n  __int64 v6; // [rsp+28h] [rbp-20h] BYREF\n  __int64 v7; // [rsp+30h] [rbp-18h] BYREF\n  int v8; // [rsp+3Ch] [rbp-Ch] BYREF\n  int v9; // [rsp+40h] [rbp-8h] BYREF\n  int i; // [rsp+44h] [rbp-4h]\n\n  if ( sscanf(a1, \"%lx:%lx:%lx:%lx%n\", &v7, &v6, &v5, &v4, &v9) != 4 )\n    return 0LL;\n  *a2 = v7;\n  a2[1] = v6;\n  a2[2] = v5;\n  a2[3] = v4;\n  s = (char *)&a1[v9];\n  for ( i = 0; i <= 31; ++i )\n  {\n    if ( sscanf(s, \":%x%n\", &v8, &v9) != 1 )\n      return 0LL;\n    *((_BYTE *)a2 + i + 17) = v8;\n    s += v9;\n  }\n  return *s == 0;\n}\n",
        "baseline_code_debug": "int __cdecl recover_mode(const char *arg, termios *mode)\n{\n  const char *arga; // [rsp+10h] [rbp-38h]\n  unsigned __int64 lflag; // [rsp+18h] [rbp-30h] BYREF\n  unsigned __int64 cflag; // [rsp+20h] [rbp-28h] BYREF\n  unsigned __int64 oflag; // [rsp+28h] [rbp-20h] BYREF\n  unsigned __int64 iflag; // [rsp+30h] [rbp-18h] BYREF\n  unsigned int chr; // [rsp+3Ch] [rbp-Ch] BYREF\n  int n; // [rsp+40h] [rbp-8h] BYREF\n  int i; // [rsp+44h] [rbp-4h]\n\n  if ( sscanf(arg, \"%lx:%lx:%lx:%lx%n\", &iflag, &oflag, &cflag, &lflag, &n) != 4 )\n    return 0;\n  mode->c_iflag = iflag;\n  mode->c_oflag = oflag;\n  mode->c_cflag = cflag;\n  mode->c_lflag = lflag;\n  arga = &arg[n];\n  for ( i = 0; i <= 31; ++i )\n  {\n    if ( sscanf(arga, \":%x%n\", &chr, &n) != 1 )\n      return 0;\n    mode->c_cc[i] = chr;\n    arga += n;\n  }\n  return *arga == 0;\n}\n",
        "similarity_score_unixcoder": 0.6169005036354065,
        "similarity_score_baseline_stripped": 0.49461084604263306,
        "similarity_score_baseline_debug": 0.846967875957489
    },
    {
        "func_name": "redraw",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_4CE92F(__int64 a1, char a2)\n{\n  sub_4CE8BB(a1, 32);\n  return sub_4CE8EF(qword_75B228 + a1, a2);\n}\n\n\n Revised code:\nstatic void\nformat_address_label(off_t address, char c)\n{\n\tformat_address_std(address, ' ');\n\tformat_address_paren(address + pseudo_offset, c);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4EFC8F(int a1)\n{\n  sub_4EFC6D();\n  sub_4F03A4(1LL);\n  sub_4EF515(a1);\n  sub_4EFC7E();\n  return sub_4F03A4(1LL);\n}\n\n\n Revised code:\nstatic void flash(int h)\n{\n\tstandout_start();\n\tredraw(TRUE);\n\tmysleep(h);\n\tstandout_end();\n\tredraw(TRUE);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_46A3E2(const char *a1)\n{\n  *(_DWORD *)qword_75D400 = 0;\n  return sub_46A3B4(a1);\n}\n\n\n Revised code:\nstatic void failx(const char *m1)\n{\n\terrno = 0;\n\tfail(m1);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_4F03A4(unsigned int a1)\n{\n  sub_4EFB8B(0, 0);\n  sub_4EFC5C();\n  sub_4EFCF7();\n  *((_DWORD *)qword_75D408 + 19) = 0;\n  sub_4F05FB(a1);\n  return sub_4EFD6C();\n}\n",
        "output": "static void process(unsigned int a1)\n{\n\tinitialize(0, 0);\n\tsetup();\n\tconfigure();\n\treset_counter();\n\tperform_action(a1);\n\tfinalize();\n}",
        "source_code": "static void redraw(int full_screen)\n{\n\tplace_cursor(0, 0);\n\tclear_to_eos();\n\tscreen_erase();\t\t// erase the internal screen buffer\n\tlast_status_cksum = 0;\t// force status update\n\trefresh(full_screen);\t// this will redraw the entire display\n\tshow_status_line();\n}",
        "parsed_output": "static void process(unsigned int a1)\n{\n\tinitialize(0, 0);\n\tsetup();\n\tconfigure();\n\treset_counter();\n\tperform_action(a1);\n\tfinalize();\n}",
        "baseline_code_stripped": "int __fastcall sub_4F03A4(unsigned int a1)\n{\n  sub_4EFB8B(0, 0);\n  sub_4EFC5C();\n  sub_4EFCF7();\n  *((_DWORD *)qword_75D408 + 19) = 0;\n  sub_4F05FB(a1);\n  return sub_4EFD6C();\n}\n",
        "baseline_code_debug": "void __cdecl redraw(int full_screen)\n{\n  place_cursor(0, 0);\n  clear_to_eos();\n  screen_erase();\n  ptr_to_globals->speeds[6] = 0;\n  refresh(full_screen);\n  show_status_line();\n}\n",
        "similarity_score_unixcoder": 0.4489824175834656,
        "similarity_score_baseline_stripped": 0.38629841804504395,
        "similarity_score_baseline_debug": 0.8730636239051819
    },
    {
        "func_name": "bb_init_module",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_500804(__int64 a1, unsigned int a2)\n{\n  int v2; // eax\n  int v5; // [rsp+18h] [rbp-18h] BYREF\n  char v6[7]; // [rsp+1Dh] [rbp-13h] BYREF\n  char v7[7]; // [rsp+1Eh] [rbp-12h] BYREF\n  int v8; // [rsp+24h] [rbp-Ch]\n  __int64 v9; // [rsp+28h] [rbp-8h]\n\n  v8 = 0;\n  while ( 1 )\n  {\n    v9 = sub_506C17(0LL, a1, a2);\n    if ( *(_DWORD *)qword_75D400 )\n      break;\n    if ( (int)v9 < 0 )\n      return v9;\n    v2 = v8++;\n    v6[v2] = v9;\n    v6[v8] = 0;\n    if ( sub_509315(&v5, v6, 1LL) == 1 )\n      return v5;\n    if ( v8 > 5 )\n      goto LABEL_10;\n    a2 = 50;\n  }\n  if ( *(_DWORD *)qword_75D400 == 11 && v8 )\n  {\nLABEL_10:\n    sub_507024(a1, v7, (unsigned int)(v8 - 1));\n    return 63LL;\n  }\n  return v9;\n}\n\n\n Revised code:\nstatic int lineedit_read_key(char *read_key_buffer, int timeout)\n{\n\tint64_t ic;\n#if ENABLE_UNICODE_SUPPORT\n\tchar unicode_buf[MB_CUR_MAX + 1];\n\tint unicode_idx = 0;\n#endif\n\n\twhile (1) {\n\t\t/* Wait for input. TIMEOUT = -1 makes read_key wait even\n\t\t * on nonblocking stdin, TIMEOUT = 50 makes sure we won't\n\t\t * insist on full MB_CUR_MAX buffer to declare input like\n\t\t * \"\\xff\\n\",pause,\"ls\\n\" invalid and thus won't lose \"ls\".\n\t\t *\n\t\t * Note: read_key sets errno to 0 on success.\n\t\t */\n\t\tic = read_key(STDIN_FILENO, read_key_buffer, timeout);\n\t\tif (errno) {\n#if ENABLE_UNICODE_SUPPORT\n\t\t\tif (errno == EAGAIN && unicode_idx != 0)\n\t\t\t\tgoto pushback;\n#endif\n\t\t\tbreak;\n\t\t}\n\n#if ENABLE_FEATURE_EDITING_ASK_TERMINAL\n\t\tif ((int32_t)ic == KEYCODE_CURSOR_POS\n\t\t && S.sent_ESC_br6n\n\t\t) {\n\t\t\tS.sent_ESC_br6n = 0;\n\t\t\tif (cursor == 0) { /* otherwise it may be bogus */\n\t\t\t\tint col = ((ic >> 32) & 0x7fff) - 1;\n\t\t\t\tif (col > cmdedit_prmt_len) {\n\t\t\t\t\tcmdedit_x += (col - cmdedit_prmt_len);\n\t\t\t\t\twhile (cmdedit_x >= cmdedit_termw) {\n\t\t\t\t\t\tcmdedit_x -= cmdedit_termw;\n\t\t\t\t\t\tcmdedit_y++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n#endif\n\n#if ENABLE_UNICODE_SUPPORT\n\t\tif (unicode_status == UNICODE_ON) {\n\t\t\twchar_t wc;\n\n\t\t\tif ((int32_t)ic < 0) /* KEYCODE_xxx */\n\t\t\t\tbreak;\n\t\t\t// TODO: imagine sequence like: 0xff,<left-arrow>: we are currently losing 0xff...\n\n\t\t\tunicode_buf[unicode_idx++] = ic;\n\t\t\tunicode_buf[unicode_idx] = '\\0';\n\t\t\tif (mbstowcs(&wc, unicode_buf, 1) != 1) {\n\t\t\t\t/* Not (yet?) a valid unicode char */\n\t\t\t\tif (unicode_idx < MB_CUR_MAX) {\n\t\t\t\t\ttimeout = 50;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n pushback:\n\t\t\t\t/* Invalid sequence. Save all \"bad bytes\" except first */\n\t\t\t\tread_key_ungets(read_key_buffer, unicode_buf + 1, unicode_idx - 1);\n# if !ENABLE_UNICODE_PRESERVE_BROKEN\n\t\t\t\tic = CONFIG_SUBST_WCHAR;\n# else\n\t\t\t\tic = unicode_mark_raw_byte(unicode_buf[0]);\n# endif\n\t\t\t} else {\n\t\t\t\t/* Valid unicode char, return its code */\n\t\t\t\tic = wc;\n\t\t\t}\n\t\t}\n#endif\n\t\tbreak;\n\t}\n\n\treturn ic;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4CB5B9(__int64 a1)\n{\n  char *s; // [rsp+8h] [rbp-18h]\n  char v3[8]; // [rsp+10h] [rbp-10h] BYREF\n  unsigned int v4; // [rsp+18h] [rbp-8h]\n  unsigned int v5; // [rsp+1Ch] [rbp-4h]\n\n  s = (char *)sub_502FB1(v3, a1);\n  if ( (dword_75D450 & 0x400) != 0 )\n  {\n    v5 = v4 + 2;\n    putchar_unlocked(34);\n    while ( *s )\n    {\n      if ( *s == 34 || *s == 92 )\n      {\n        putchar_unlocked(92);\n        ++v5;\n      }\n      putchar_unlocked(*s++);\n    }\n    putchar_unlocked(34);\n    return v5;\n  }\n  else\n  {\n    fputs_unlocked(s, stdout);\n    return v4;\n  }\n}\n\n\n Revised code:\nstatic unsigned print_name(const char *name)\n{\n\tunsigned len;\n\tuni_stat_t uni_stat;\n\n\t// TODO: quote tab as \\t, etc, if -Q\n\tname = printable_string(&uni_stat, name);\n\n\tif (!(option_mask32 & OPT_Q)) {\n\t\tfputs(name, stdout);\n\t\treturn uni_stat.unicode_width;\n\t}\n\n\tlen = 2 + uni_stat.unicode_width;\n\tputchar('\"');\n\twhile (*name) {\n\t\tif (*name == '\"' || *name == '\\\\') {\n\t\t\tputchar('\\\\');\n\t\t\tlen++;\n\t\t}\n\t\tputchar(*name);\n\t\tname++;\n\t}\n\tputchar('\"');\n\treturn len;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40C9C5(__int64 a1, const char *a2)\n{\n  char *v3; // rax\n  char *sa; // [rsp+0h] [rbp-30h]\n  char *endptr; // [rsp+10h] [rbp-20h] BYREF\n  unsigned __int64 v7; // [rsp+18h] [rbp-18h]\n  _DWORD *v8; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  for ( i = 0; ; ++i )\n  {\n    v8 = (_DWORD *)((unsigned __int8)byte_5350A7[i] + a1);\n    if ( i <= 1 || i > 3 )\n      break;\n    v7 = strtoul(a2, &endptr, 10);\n    if ( a2 == endptr || *endptr != 58 )\n      return 0xFFFFFFFFLL;\n    sa = endptr;\n    *v8 = v7;\nLABEL_11:\n    v3 = sa;\n    a2 = sa + 1;\n    *v3 = 0;\n  }\n  *(_QWORD *)v8 = a2;\n  if ( i == 6 )\n    return 0LL;\n  sa = strchr(a2, 58);\n  if ( sa )\n    goto LABEL_11;\n  return 0xFFFFFFFFLL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC bb__parsepwent(void *data, char *line)\n{\n\tchar *endptr;\n\tchar *p;\n\tint i;\n\n\ti = 0;\n\twhile (1) {\n\t\tp = (char *) data + pw_off[i];\n\n\t\tif (i < 2 || i > 3) {\n\t\t\t*((char **) p) = line;\n\t\t\tif (i == 6) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* NOTE: glibc difference - glibc allows omission of\n\t\t\t * ':' seperators after the gid field if all remaining\n\t\t\t * entries are empty.  We require all separators. */\n\t\t\tline = strchr(line, ':');\n\t\t\tif (!line) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned long t = strtoul(line, &endptr, 10);\n\t\t\t/* Make sure we had at least one digit, and that the\n\t\t\t * failing char is the next field seperator ':'.  See\n\t\t\t * glibc difference note above. */\n\t\t\t/* TODO: Also check for leading whitespace? */\n\t\t\tif ((endptr == line) || (*endptr != ':')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tline = endptr;\n\t\t\tif (i & 1) {\t\t/* i == 3 -- gid */\n\t\t\t\t*((gid_t *) p) = t;\n\t\t\t} else {\t\t\t/* i == 2 -- uid */\n\t\t\t\t*((uid_t *) p) = t;\n\t\t\t}\n\t\t}\n\n\t\t*line++ = '\\0';\n\t\ti++;\n\t} /* while (1) */\n\n\treturn -1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_426133(__int64 a1, void *a2)\n{\n  void *v3; // [rsp+0h] [rbp-30h]\n  size_t len; // [rsp+18h] [rbp-18h] BYREF\n  unsigned int v5; // [rsp+20h] [rbp-10h]\n  char v6; // [rsp+27h] [rbp-9h]\n  void *addr; // [rsp+28h] [rbp-8h]\n\n  v3 = a2;\n  if ( !a2 )\n    v3 = &unk_52AA22;\n  len = 2147479552LL;\n  v6 = 0;\n  addr = 0LL;\n  *(_DWORD *)qword_75D400 = 12;\n  addr = (void *)sub_4C33AC(a1, &len);\n  if ( !addr )\n    return (unsigned int)-*(_DWORD *)qword_75D400;\n  *(_DWORD *)qword_75D400 = 0;\n  syscall(175LL, addr, len, v3);\n  v5 = *(_DWORD *)qword_75D400;\n  if ( v6 )\n    munmap(addr, len);\n  else\n    free(addr);\n  return v5;\n}\n",
        "output": "static int process_data(void *data, size_t data_len, void *buffer)\n{\n\tvoid *addr;\n\tsize_t len;\n\tunsigned int result;\n\n\tif (!buffer)\n\t\tbuffer = &default_buffer;\n\n\tlen = 2147479552;\n\taddr = 0;\n\t*((int *)qword_75D400) = 12;\n\taddr = (void *)sub_4C33AC(data, &len);\n\tif (!addr)\n\t\treturn -(int)*((int *)qword_75D400);\n\n\t*((int *)qword_75D400) = 0;\n\tsyscall(175, addr, len, buffer);\n\tresult = *((int *)qword_75D400);\n\n\tif (v6)\n\t\tmunmap(addr, len);\n\telse\n\t\tfree(addr);\n\n\treturn result;\n}",
        "source_code": "int FAST_FUNC bb_init_module(const char *filename, const char *options)\n{\n\tsize_t image_size;\n\tchar *image;\n\tint rc;\n\tbool mmaped;\n\n\tif (!options)\n\t\toptions = \"\";\n\n//TODO: audit bb_init_module_24 to match error code convention\n#if ENABLE_FEATURE_2_4_MODULES\n\tif (get_linux_version_code() < KERNEL_VERSION(2,6,0))\n\t\treturn bb_init_module_24(filename, options);\n#endif\n\n\timage_size = INT_MAX - 4095;\n\tmmaped = 0;\n\timage = try_to_mmap_module(filename, &image_size);\n\tif (image) {\n\t\tmmaped = 1;\n\t} else {\n\t\terrno = ENOMEM; /* may be changed by e.g. open errors below */\n\t\timage = xmalloc_open_zipped_read_close(filename, &image_size);\n\t\tif (!image)\n\t\t\treturn -errno;\n\t}\n\n\terrno = 0;\n\tinit_module(image, image_size, options);\n\trc = errno;\n\tif (mmaped)\n\t\tmunmap(image, image_size);\n\telse\n\t\tfree(image);\n\treturn rc;\n}",
        "parsed_output": "static int process_data(void *data, size_t data_len, void *buffer)\n{\n\tvoid *addr;\n\tsize_t len;\n\tunsigned int result;\n\n\tif (!buffer)\n\t\tbuffer = &default_buffer;\n\n\tlen = 2147479552;\n\taddr = 0;\n\t*((int *)qword_75D400) = 12;\n\taddr = (void *)sub_4C33AC(data, &len);\n\tif (!addr)\n\t\treturn -(int)*((int *)qword_75D400);\n\n\t*((int *)qword_75D400) = 0;\n\tsyscall(175, addr, len, buffer);\n\tresult = *((int *)qword_75D400);\n\n\tif (v6)\n\t\tmunmap(addr, len);\n\telse\n\t\tfree(addr);\n\n\treturn result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_426133(__int64 a1, void *a2)\n{\n  void *v3; // [rsp+0h] [rbp-30h]\n  size_t len; // [rsp+18h] [rbp-18h] BYREF\n  unsigned int v5; // [rsp+20h] [rbp-10h]\n  char v6; // [rsp+27h] [rbp-9h]\n  void *addr; // [rsp+28h] [rbp-8h]\n\n  v3 = a2;\n  if ( !a2 )\n    v3 = &unk_52AA22;\n  len = 2147479552LL;\n  v6 = 0;\n  addr = 0LL;\n  *(_DWORD *)qword_75D400 = 12;\n  addr = (void *)sub_4C33AC(a1, &len);\n  if ( !addr )\n    return (unsigned int)-*(_DWORD *)qword_75D400;\n  *(_DWORD *)qword_75D400 = 0;\n  syscall(175LL, addr, len, v3);\n  v5 = *(_DWORD *)qword_75D400;\n  if ( v6 )\n    munmap(addr, len);\n  else\n    free(addr);\n  return v5;\n}\n",
        "baseline_code_debug": "int __cdecl bb_init_module(const char *filename, const char *options)\n{\n  const char *optionsa; // [rsp+0h] [rbp-30h]\n  size_t image_size; // [rsp+18h] [rbp-18h] BYREF\n  int rc; // [rsp+20h] [rbp-10h]\n  bool mmaped; // [rsp+27h] [rbp-9h]\n  char *image; // [rsp+28h] [rbp-8h]\n\n  optionsa = options;\n  if ( !options )\n    optionsa = (const char *)&unk_52AA22;\n  image_size = 2147479552LL;\n  mmaped = 0;\n  image = 0LL;\n  *bb_errno = 12;\n  image = (char *)xmalloc_open_zipped_read_close(filename, &image_size);\n  if ( !image )\n    return -*bb_errno;\n  *bb_errno = 0;\n  syscall(175LL, image, image_size, optionsa);\n  rc = *bb_errno;\n  if ( mmaped )\n    munmap(image, image_size);\n  else\n    free(image);\n  return rc;\n}\n",
        "similarity_score_unixcoder": 0.5826371908187866,
        "similarity_score_baseline_stripped": 0.6034728288650513,
        "similarity_score_baseline_debug": 0.8624898195266724
    },
    {
        "func_name": "initialize_context",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_4821E0(__int64 a1, __int64 a2)\n{\n  return sub_40A0E8(0x38uLL, a2);\n}\n\n\n Revised code:\nstatic struct pipe *new_pipe(void)\n{\n\tstruct pipe *pi;\n\tpi = xzalloc(sizeof(struct pipe));\n\t/*pi->followup = 0; - deliberately invalid value */\n\t/*pi->res_word = RES_NONE; - RES_NONE is 0 anyway */\n\treturn pi;\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_4A7E3F(__int64 a1, __int64 a2, int a3, unsigned __int64 a4)\n{\n  return sub_4A7C1E(a1 + 48, 0x41uLL, a2, a3, a4);\n}\n\n\n Revised code:\nvoid volume_id_set_label_unicode16(struct volume_id *id, const uint8_t *buf, enum endian endianess, size_t count)\n{\n\tvolume_id_set_unicode16(id->label, sizeof(id->label), buf, endianess, count);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_436830(__int64 a1, __int64 a2)\n{\n  return sub_4FD5B8(a1, a2, 0LL);\n}\n\n\n Revised code:\nendif\n\nstatic int FAST_FUNC INET_input(/*int type,*/ const char *bufp, struct sockaddr *sap)\n{\n\treturn INET_resolve(bufp, (struct sockaddr_in *) sap, 0);\n/*\n\tswitch (type) {\n\tcase 1:\n\t\treturn (INET_getsock(bufp, sap));\n\tcase 256:\n\t\treturn (INET_resolve(bufp, (struct sockaddr_in *) sap, 1));\n\tdefault:\n\t\treturn (INET_resolve(bufp, (struct sockaddr_in *) sap, 0));\n\t}\n*/\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_482419(void **a1)\n{\n  memset(a1, 0, 0x30uLL);\n  *a1 = sub_4821E0((__int64)a1, 0LL);\n  a1[1] = *a1;\n  return sub_4821FC((__int64)a1);\n}\n",
        "output": "void initialize_array(void **array)\n{\n  memset(array, 0, 0x30uLL);\n  *array = create_pipe((__int64)array, 0LL);\n  array[1] = *array;\n  execute_function((__int64)array);\n}",
        "source_code": "static void initialize_context(struct parse_context *ctx)\n{\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->pipe = ctx->list_head = new_pipe();\n\t/* Create the memory for command, roughly:\n\t * ctx->pipe->cmds = new struct command;\n\t * ctx->command = &ctx->pipe->cmds[0];\n\t */\n\tdone_command(ctx);\n}",
        "parsed_output": "void initialize_array(void **array)\n{\n  memset(array, 0, 0x30uLL);\n  *array = create_pipe((__int64)array, 0LL);\n  array[1] = *array;\n  execute_function((__int64)array);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_482419(void **a1)\n{\n  memset(a1, 0, 0x30uLL);\n  *a1 = sub_4821E0((__int64)a1, 0LL);\n  a1[1] = *a1;\n  return sub_4821FC((__int64)a1);\n}\n",
        "baseline_code_debug": "void __cdecl initialize_context(parse_context *ctx)\n{\n  memset(ctx, 0, sizeof(parse_context));\n  ctx->list_head = new_pipe();\n  ctx->pipe = ctx->list_head;\n  done_command(ctx);\n}\n",
        "similarity_score_unixcoder": 0.6174924969673157,
        "similarity_score_baseline_stripped": 0.41870400309562683,
        "similarity_score_baseline_debug": 0.9066430330276489
    },
    {
        "func_name": "crc32_block_endian1",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4F7534(unsigned int a1, _BYTE *a2, int a3, __int64 a4)\n{\n  _BYTE *i; // [rsp+8h] [rbp-20h]\n\n  for ( i = a2; i != &a2[a3]; ++i )\n    a1 = (a1 >> 8) ^ *(_DWORD *)(4LL * (unsigned __int8)(a1 ^ *i) + a4);\n  return a1;\n}\n\n\n Revised code:\nuint32_t FAST_FUNC crc32_block_endian0(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table)\n{\n\tconst void *end = (uint8_t*)buf + len;\n\n\twhile (buf != end) {\n\t\tval = crc_table[(uint8_t)val ^ *(uint8_t*)buf] ^ (val >> 8);\n\t\tbuf = (uint8_t*)buf + 1;\n\t}\n\treturn val;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A8B04(__int64 a1, int a2, int a3, int a4)\n{\n  __int64 result; // rax\n  unsigned int v8; // [rsp+20h] [rbp-4h]\n\n  while ( a4 > 0 )\n  {\n    v8 = *(_DWORD *)(4LL * a2 + a1);\n    *(_DWORD *)(4LL * a2 + a1) = *(_DWORD *)(4LL * a3 + a1);\n    result = v8;\n    *(_DWORD *)(a1 + 4LL * a3) = v8;\n    ++a2;\n    ++a3;\n    --a4;\n  }\n  return result;\n}\n\n\n Revised code:\nvoid mvswap(uint32_t* ptr, int32_t zzp1, int32_t zzp2, int32_t zzn)\n{\n\twhile (zzn > 0) {\n\t\tmswap(ptr[zzp1], ptr[zzp2]);\n\t\tzzp1++;\n\t\tzzp2++;\n\t\tzzn--;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_459B24(__int64 a1)\n{\n  unsigned int i; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; *(_BYTE *)((int)i + a1) != 0xFF; ++i )\n  {\n    if ( *(_BYTE *)((int)i + a1) )\n      i += *(unsigned __int8 *)((int)i + 1LL + a1) + 1;\n  }\n  return i;\n}\n\n\n Revised code:\nint FAST_FUNC udhcp_end_option(uint8_t *optionptr)\n{\n\tint i = 0;\n\n\twhile (optionptr[i] != DHCP_END) {\n\t\tif (optionptr[i] != DHCP_PADDING)\n\t\t\ti += optionptr[i + OPT_LEN] + OPT_DATA-1;\n\t\ti++;\n\t}\n\treturn i;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4F74CA(unsigned int a1, unsigned __int8 *a2, int a3, __int64 a4)\n{\n  unsigned __int8 *i; // [rsp+8h] [rbp-20h]\n\n  for ( i = a2; i != &a2[a3]; ++i )\n    a1 = (a1 << 8) ^ *(_DWORD *)(4LL * (HIBYTE(a1) ^ *i) + a4);\n  return a1;\n}\n",
        "output": "uint32_t FAST_FUNC crc32_block_endian1(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table)\n{\n\tconst void *end = (uint8_t*)buf + len;\n\n\twhile (buf != end) {\n\t\tval = crc_table[(uint8_t)(val >> 24) ^ *(uint8_t*)buf] ^ (val << 8);\n\t\tbuf = (uint8_t*)buf + 1;\n\t}\n\treturn val;\n}",
        "source_code": "uint32_t FAST_FUNC crc32_block_endian1(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table)\n{\n\tconst void *end = (uint8_t*)buf + len;\n\n\twhile (buf != end) {\n\t\tval = (val << 8) ^ crc_table[(val >> 24) ^ *(uint8_t*)buf];\n\t\tbuf = (uint8_t*)buf + 1;\n\t}\n\treturn val;\n}",
        "parsed_output": "uint32_t FAST_FUNC crc32_block_endian1(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table)\n{\n\tconst void *end = (uint8_t*)buf + len;\n\n\twhile (buf != end) {\n\t\tval = crc_table[(uint8_t)(val >> 24) ^ *(uint8_t*)buf] ^ (val << 8);\n\t\tbuf = (uint8_t*)buf + 1;\n\t}\n\treturn val;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4F74CA(unsigned int a1, unsigned __int8 *a2, int a3, __int64 a4)\n{\n  unsigned __int8 *i; // [rsp+8h] [rbp-20h]\n\n  for ( i = a2; i != &a2[a3]; ++i )\n    a1 = (a1 << 8) ^ *(_DWORD *)(4LL * (HIBYTE(a1) ^ *i) + a4);\n  return a1;\n}\n",
        "baseline_code_debug": "uint32_t __cdecl crc32_block_endian1(uint32_t val, const void *buf, unsigned int len, uint32_t *crc_table)\n{\n  unsigned __int8 *bufa; // [rsp+8h] [rbp-20h]\n\n  for ( bufa = (unsigned __int8 *)buf; bufa != (unsigned __int8 *)((char *)buf + len); ++bufa )\n    val = (val << 8) ^ crc_table[HIBYTE(val) ^ *bufa];\n  return val;\n}\n",
        "similarity_score_unixcoder": 0.9979338645935059,
        "similarity_score_baseline_stripped": 0.565646231174469,
        "similarity_score_baseline_debug": 0.9040864706039429
    },
    {
        "func_name": "sprint_nip6",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_BOOL8 __fastcall sub_4D38D9(const char *a1, _DWORD *a2)\n{\n  char *s; // [rsp+10h] [rbp-38h]\n  __int64 v4; // [rsp+18h] [rbp-30h] BYREF\n  __int64 v5; // [rsp+20h] [rbp-28h] BYREF\n  __int64 v6; // [rsp+28h] [rbp-20h] BYREF\n  __int64 v7; // [rsp+30h] [rbp-18h] BYREF\n  int v8; // [rsp+3Ch] [rbp-Ch] BYREF\n  int v9; // [rsp+40h] [rbp-8h] BYREF\n  int i; // [rsp+44h] [rbp-4h]\n\n  if ( sscanf(a1, \"%lx:%lx:%lx:%lx%n\", &v7, &v6, &v5, &v4, &v9) != 4 )\n    return 0LL;\n  *a2 = v7;\n  a2[1] = v6;\n  a2[2] = v5;\n  a2[3] = v4;\n  s = (char *)&a1[v9];\n  for ( i = 0; i <= 31; ++i )\n  {\n    if ( sscanf(s, \":%x%n\", &v8, &v9) != 1 )\n      return 0LL;\n    *((_BYTE *)a2 + i + 17) = v8;\n    s += v9;\n  }\n  return *s == 0;\n}\n\n\n Revised code:\nstatic int recover_mode(const char *arg, struct termios *mode)\n{\n\tint i, n;\n\tunsigned chr;\n\tunsigned long iflag, oflag, cflag, lflag;\n\n\t/* Scan into temporaries since it is too much trouble to figure out\n\t   the right format for 'tcflag_t' */\n\tif (sscanf(arg, \"%lx:%lx:%lx:%lx%n\",\n\t\t\t   &iflag, &oflag, &cflag, &lflag, &n) != 4)\n\t\treturn 0;\n\tmode->c_iflag = iflag;\n\tmode->c_oflag = oflag;\n\tmode->c_cflag = cflag;\n\tmode->c_lflag = lflag;\n\targ += n;\n\tfor (i = 0; i < NCCS; ++i) {\n\t\tif (sscanf(arg, \":%x%n\", &chr, &n) != 1)\n\t\t\treturn 0;\n\t\tmode->c_cc[i] = chr;\n\t\targ += n;\n\t}\n\n\t/* Fail if there are too many fields */\n\tif (*arg != '\\0')\n\t\treturn 0;\n\n\treturn 1;\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_464C09(const char *a1, __int64 a2, char a3)\n{\n  char s[100]; // [rsp+20h] [rbp-210h] BYREF\n  char v5[8]; // [rsp+84h] [rbp-1ACh] BYREF\n  char v6[8]; // [rsp+8Ch] [rbp-1A4h] BYREF\n  char v7[8]; // [rsp+94h] [rbp-19Ch] BYREF\n  char v8[12]; // [rsp+9Ch] [rbp-194h] BYREF\n  char v9[12]; // [rsp+A8h] [rbp-188h] BYREF\n  char v10[109]; // [rsp+B4h] [rbp-17Ch] BYREF\n  __int64 v11; // [rsp+121h] [rbp-10Fh]\n  unsigned int v12; // [rsp+228h] [rbp-8h]\n  int i; // [rsp+22Ch] [rbp-4h]\n\n  memset(s, 0, 0x200uLL);\n  strcpy(s, a1);\n  sprintf(v5, \"%o\", *(_DWORD *)(a2 + 24) & 0x1FF);\n  sprintf(v6, \"%o\", *(_DWORD *)(a2 + 28) & 0x1FFFFF);\n  sprintf(v7, \"%o\", *(_DWORD *)(a2 + 32) & 0x1FFFFF);\n  sprintf(v8, \"%o\", (unsigned int)*(_QWORD *)(a2 + 48));\n  sprintf(v9, \"%llo\", *(_QWORD *)(a2 + 88) & 0x1FFFFFFFFLL);\n  v10[8] = a3;\n  v11 = 0x20207261747375LL;\n  v10[7] = 32;\n  v12 = 224;\n  for ( i = 0; i <= 511; ++i )\n    v12 += (unsigned __int8)s[i];\n  sprintf(v10, \"%06o\", v12);\n  sub_40A4AB(1u, (__int64)s, 512LL);\n}\n\n\n Revised code:\nstatic void writeheader(const char *path, struct stat *sb, int type)\n{\n\tstruct tar_header_t header;\n\tint i, sum;\n\n\tmemset(&header, 0, TAR_BLOCK_SIZE);\n\tstrcpy(header.name, path);\n\tsprintf(header.mode, \"%o\", sb->st_mode & 0777);\n\t/* careful to not overflow fields! */\n\tsprintf(header.uid, \"%o\", sb->st_uid & 07777777);\n\tsprintf(header.gid, \"%o\", sb->st_gid & 07777777);\n\tsprintf(header.size, \"%o\", (unsigned)sb->st_size);\n\tsprintf(header.mtime, \"%llo\", sb->st_mtime & 077777777777LL);\n\theader.typeflag = type;\n\tstrcpy(header.magic, \"ustar  \"); /* like GNU tar */\n\n\t/* Calculate and store the checksum (the sum of all of the bytes of\n\t * the header). The checksum field must be filled with blanks for the\n\t * calculation. The checksum field is formatted differently from the\n\t * other fields: it has 6 digits, a NUL, then a space -- rather than\n\t * digits, followed by a NUL like the other fields... */\n\theader.chksum[7] = ' ';\n\tsum = ' ' * 7;\n\tfor (i = 0; i < TAR_BLOCK_SIZE; i++)\n\t\tsum += ((unsigned char*)&header)[i];\n\tsprintf(header.chksum, \"%06o\", sum);\n\n\txwrite(STDOUT_FILENO, &header, TAR_BLOCK_SIZE);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_42FB55(const char *a1, int a2)\n{\n  char v3[16]; // [rsp+10h] [rbp-30h] BYREF\n  int v4; // [rsp+20h] [rbp-20h]\n\n  v4 = a2;\n  return sub_42FA47(0x8922u, v3, a1);\n}\n\n\n Revised code:\nstatic int set_mtu(char *ifname, int mtu)\n{\n\tstruct ifreq ifr;\n\n\tifr.ifr_mtu = mtu;\n\treturn set_ifrname_and_do_ioctl(SIOCSIFMTU, &ifr, ifname);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_45A51D(char *a1, char *a2)\n{\n  char v3[4]; // [rsp+10h] [rbp-20h] BYREF\n  char v4[4]; // [rsp+14h] [rbp-1Ch] BYREF\n  char v5[4]; // [rsp+18h] [rbp-18h] BYREF\n  char v6[4]; // [rsp+1Ch] [rbp-14h] BYREF\n  char v7[4]; // [rsp+20h] [rbp-10h] BYREF\n  char v8[4]; // [rsp+24h] [rbp-Ch] BYREF\n  char v9[4]; // [rsp+28h] [rbp-8h] BYREF\n  char v10[4]; // [rsp+2Ch] [rbp-4h] BYREF\n\n  sub_409BB5(v3, a2, 16);\n  return sprintf(a1, \"%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s\", v3, v4, v5, v6, v7, v8, v9, v10);\n}\n",
        "output": "static int format_mac_address(char *output, char *input)\n{\n\tchar v3[5];\n\tchar v4[5];\n\tchar v5[5];\n\tchar v6[5];\n\tchar v7[5];\n\tchar v8[5];\n\tchar v9[5];\n\tchar v10[5];\n\n\tsub_409BB5(v3, input, 16);\n\treturn sprintf(output, \"%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s\", v3, v4, v5, v6, v7, v8, v9, v10);\n}",
        "source_code": "int FAST_FUNC sprint_nip6(char *dest, /*const char *pre,*/ const uint8_t *ip)\n{\n\tchar hexstrbuf[16 * 2];\n\tbin2hex(hexstrbuf, (void*)ip, 16);\n\treturn sprintf(dest, /* \"%s\" */\n\t\t\"%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s\",\n\t\t/* pre, */\n\t\thexstrbuf + 0 * 4,\n\t\thexstrbuf + 1 * 4,\n\t\thexstrbuf + 2 * 4,\n\t\thexstrbuf + 3 * 4,\n\t\thexstrbuf + 4 * 4,\n\t\thexstrbuf + 5 * 4,\n\t\thexstrbuf + 6 * 4,\n\t\thexstrbuf + 7 * 4\n\t);\n}",
        "parsed_output": "static int format_mac_address(char *output, char *input)\n{\n\tchar v3[5];\n\tchar v4[5];\n\tchar v5[5];\n\tchar v6[5];\n\tchar v7[5];\n\tchar v8[5];\n\tchar v9[5];\n\tchar v10[5];\n\n\tsub_409BB5(v3, input, 16);\n\treturn sprintf(output, \"%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s\", v3, v4, v5, v6, v7, v8, v9, v10);\n}",
        "baseline_code_stripped": "int __fastcall sub_45A51D(char *a1, char *a2)\n{\n  char v3[4]; // [rsp+10h] [rbp-20h] BYREF\n  char v4[4]; // [rsp+14h] [rbp-1Ch] BYREF\n  char v5[4]; // [rsp+18h] [rbp-18h] BYREF\n  char v6[4]; // [rsp+1Ch] [rbp-14h] BYREF\n  char v7[4]; // [rsp+20h] [rbp-10h] BYREF\n  char v8[4]; // [rsp+24h] [rbp-Ch] BYREF\n  char v9[4]; // [rsp+28h] [rbp-8h] BYREF\n  char v10[4]; // [rsp+2Ch] [rbp-4h] BYREF\n\n  sub_409BB5(v3, a2, 16);\n  return sprintf(a1, \"%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s\", v3, v4, v5, v6, v7, v8, v9, v10);\n}\n",
        "baseline_code_debug": "int __cdecl sprint_nip6(char *dest, const uint8_t *ip_0)\n{\n  char hexstrbuf[32]; // [rsp+10h] [rbp-20h] BYREF\n\n  bin2hex(hexstrbuf, (const char *)ip_0, 16);\n  return sprintf(\n           dest,\n           \"%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s\",\n           hexstrbuf,\n           &hexstrbuf[4],\n           &hexstrbuf[8],\n           &hexstrbuf[12],\n           &hexstrbuf[16],\n           &hexstrbuf[20],\n           &hexstrbuf[24],\n           &hexstrbuf[28]);\n}\n",
        "similarity_score_unixcoder": 0.7444425821304321,
        "similarity_score_baseline_stripped": 0.5239614248275757,
        "similarity_score_baseline_debug": 0.8713623285293579
    },
    {
        "func_name": "blocking_wait_with_raise_on_sig",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 sub_43708E()\n{\n  unsigned int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_436F0A(0LL);\n  if ( !v1 )\n    return (unsigned int)sub_436DF6();\n  return v1;\n}\n\n\n Revised code:\nstatic int if_readlist(void)\n{\n\tint err = if_readlist_proc(NULL);\n\t/* Needed in order to get ethN:M aliases */\n\tif (!err)\n\t\terr = if_readconf();\n\treturn err;\n}\n\n## Example:\n\n Input code:\n__int64 sub_47813F()\n{\n  unsigned int v1; // [rsp+4h] [rbp-1Ch]\n  __int64 v2; // [rsp+8h] [rbp-18h]\n  char v3; // [rsp+13h] [rbp-Dh]\n  int v4; // [rsp+14h] [rbp-Ch]\n  _BYTE *v5; // [rsp+18h] [rbp-8h]\n\n  v3 = byte_75AF50;\n  *(_BYTE *)(qword_75D418 + 53) = 0;\n  v4 = 1;\n  v5 = (_BYTE *)(qword_75D418 + 136);\n  while ( v4 <= 64 )\n  {\n    if ( *v5 )\n    {\n      v2 = *(_QWORD *)(qword_75D418 + 8 * (v4 + 26LL));\n      if ( v4 != 2 || v2 )\n      {\n        *v5 = 0;\n        if ( v2 )\n        {\n          v1 = sub_47DE2C(v2, 16LL);\n          byte_75AF50 = v3;\n          if ( v1 )\n            return v1;\n        }\n      }\n    }\n    ++v4;\n    ++v5;\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic int\ndotrap(void)\n{\n\tuint8_t *g;\n\tint sig;\n\tuint8_t savestatus;\n\n\tsavestatus = exitstatus;\n\tpending_sig = 0;\n\txbarrier();\n\n\tTRACE((\"dotrap entered\\n\"));\n\tfor (sig = 1, g = gotsig; sig < NSIG; sig++, g++) {\n\t\tint want_exexit;\n\t\tchar *t;\n\n\t\tif (*g == 0)\n\t\t\tcontinue;\n\t\tt = trap[sig];\n\t\t/* non-trapped SIGINT is handled separately by raise_interrupt,\n\t\t * don't upset it by resetting gotsig[SIGINT-1] */\n\t\tif (sig == SIGINT && !t)\n\t\t\tcontinue;\n\n\t\tTRACE((\"sig %d is active, will run handler '%s'\\n\", sig, t));\n\t\t*g = 0;\n\t\tif (!t)\n\t\t\tcontinue;\n\t\twant_exexit = evalstring(t, SKIPEVAL);\n\t\texitstatus = savestatus;\n\t\tif (want_exexit) {\n\t\t\tTRACE((\"dotrap returns %d\\n\", want_exexit));\n\t\t\treturn want_exexit;\n\t\t}\n\t}\n\n\tTRACE((\"dotrap returns 0\\n\"));\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 sub_47DC18()\n{\n  int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_47DB13();\n  byte_75B059 = 1;\n  return *(unsigned __int8 *)*(&off_51D220 + v1);\n}\n\n\n Revised code:\nstatic char\npeektoken(void)\n{\n\tint t;\n\n\tt = readtoken();\n\ttokpushback = 1;\n\treturn tokname_array[t][0];\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_471AA3()\n{\n  int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_4718A4(0, 0LL);\n  if ( v1 <= 0 && *(_BYTE *)(qword_75D418 + 53) )\n    sub_46DF6F(5);\n  return (unsigned int)v1;\n}\n",
        "output": "static int process_data()\n{\n\tint result = sub_4718A4(0, 0LL);\n\tif (result <= 0 && *(_BYTE *)(qword_75D418 + 53))\n\t\tsub_46DF6F(5);\n\treturn result;\n}",
        "source_code": "static int\nblocking_wait_with_raise_on_sig(void)\n{\n\tpid_t pid = dowait(DOWAIT_BLOCK, NULL);\n\tif (pid <= 0 && pending_sig)\n\t\traise_exception(EXSIG);\n\treturn pid;\n}",
        "parsed_output": "static int process_data()\n{\n\tint result = sub_4718A4(0, 0LL);\n\tif (result <= 0 && *(_BYTE *)(qword_75D418 + 53))\n\t\tsub_46DF6F(5);\n\treturn result;\n}",
        "baseline_code_stripped": "__int64 sub_471AA3()\n{\n  int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_4718A4(0, 0LL);\n  if ( v1 <= 0 && *(_BYTE *)(qword_75D418 + 53) )\n    sub_46DF6F(5);\n  return (unsigned int)v1;\n}\n",
        "baseline_code_debug": "int __cdecl blocking_wait_with_raise_on_sig()\n{\n  pid_t pid; // [rsp+Ch] [rbp-4h]\n\n  pid = dowait(0, 0LL);\n  if ( pid <= 0 && ash_ptr_to_globals_misc->pending_sig )\n    raise_exception(5);\n  return pid;\n}\n",
        "similarity_score_unixcoder": 0.46328815817832947,
        "similarity_score_baseline_stripped": 0.35758382081985474,
        "similarity_score_baseline_debug": 0.80995774269104
    },
    {
        "func_name": "fgcolor",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4CB48C(unsigned __int16 a1)\n{\n  if ( (a1 & 0xF000) == 0x8000 && (a1 & 0x49) != 0 )\n    return 1LL;\n  else\n    return (unsigned __int8)byte_522C75[a1 >> 12];\n}\n\n\n Revised code:\nstatic char bold(mode_t mode)\n{\n\tif (S_ISREG(mode) && (mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n\t\treturn ATTR(0xF000);\t/* File is executable ... */\n\treturn ATTR(mode);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4CB4C7(unsigned __int16 a1)\n{\n  if ( (dest.c_oflag & 0x800) == 0 )\n    return 0LL;\n  if ( (a1 & 0xF000) == 0x4000 )\n    return 47LL;\n  if ( (dest.c_oflag & 0x1000) == 0 )\n    return 0LL;\n  if ( (a1 & 0xF000) == 0x8000 && (a1 & 0x49) != 0 )\n    return 42LL;\n  return (unsigned __int8)byte_522C86[a1 >> 12];\n}\n\n\n Revised code:\nif ENABLE_FEATURE_LS_FILETYPES\nstatic char append_char(mode_t mode)\n{\n\tif (!(G.all_fmt & LIST_FILETYPE))\n\t\treturn '\\0';\n\tif (S_ISDIR(mode))\n\t\treturn '/';\n\tif (!(G.all_fmt & LIST_CLASSIFY))\n\t\treturn '\\0';\n\tif (S_ISREG(mode) && (mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n\t\treturn '*';\n\treturn APPCHAR(mode);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4D3466(unsigned int a1, __int64 a2)\n{\n  if ( a1 > 3 )\n    return 0LL;\n  else\n    return (unsigned __int8)byte_524194[a1] + a2;\n}\n\n\n Revised code:\nstatic tcflag_t *mode_type_flag(unsigned type, const struct termios *mode)\n{\n\tstatic const uint8_t tcflag_offsets[] ALIGN1 = {\n\t\toffsetof(struct termios, c_cflag), /* control */\n\t\toffsetof(struct termios, c_iflag), /* input */\n\t\toffsetof(struct termios, c_oflag), /* output */\n\t\toffsetof(struct termios, c_lflag)  /* local */\n\t};\n\n\tif (type <= local) {\n\t\treturn (tcflag_t*) (((char*)mode) + tcflag_offsets[type]);\n\t}\n\treturn NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4CB451(unsigned __int16 a1)\n{\n  if ( (a1 & 0xF000) == 0x8000 && (a1 & 0x49) != 0 )\n    return 32LL;\n  else\n    return (unsigned __int8)byte_522C64[a1 >> 12];\n}\n",
        "output": "static char get_value(unsigned __int16 a1)\n{\n\tif ((a1 & 0xF000) == 0x8000 && (a1 & 0x49) != 0)\n\t\treturn 32;\n\telse\n\t\treturn (unsigned __int8)byte_522C64[a1 >> 12];\n}",
        "source_code": "static char fgcolor(mode_t mode)\n{\n\tif (S_ISREG(mode) && (mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n\t\treturn COLOR(0xF000);\t/* File is executable ... */\n\treturn COLOR(mode);\n}",
        "parsed_output": "static char get_value(unsigned __int16 a1)\n{\n\tif ((a1 & 0xF000) == 0x8000 && (a1 & 0x49) != 0)\n\t\treturn 32;\n\telse\n\t\treturn (unsigned __int8)byte_522C64[a1 >> 12];\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4CB451(unsigned __int16 a1)\n{\n  if ( (a1 & 0xF000) == 0x8000 && (a1 & 0x49) != 0 )\n    return 32LL;\n  else\n    return (unsigned __int8)byte_522C64[a1 >> 12];\n}\n",
        "baseline_code_debug": "char __cdecl fgcolor(mode_t mode)\n{\n  if ( (mode & 0xF000) == 0x8000 && (mode & 0x49) != 0 )\n    return 32;\n  else\n    return byte_522C64[(unsigned __int16)mode >> 12];\n}\n",
        "similarity_score_unixcoder": 0.517625093460083,
        "similarity_score_baseline_stripped": 0.5289628505706787,
        "similarity_score_baseline_debug": 0.7423597574234009
    },
    {
        "func_name": "handle_retr",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __fastcall sub_42A2E9(int a1, __int64 a2)\n{\n  const char *v2; // rax\n  struct stat64 stat_buf; // [rsp+10h] [rbp-C0h] BYREF\n  __int64 v4; // [rsp+A8h] [rbp-28h]\n  int fd; // [rsp+B4h] [rbp-1Ch]\n  __off64_t v6; // [rsp+B8h] [rbp-18h]\n  int oflag; // [rsp+C0h] [rbp-10h]\n  int fildes; // [rsp+C4h] [rbp-Ch]\n  void *ptr; // [rsp+C8h] [rbp-8h]\n\n  v6 = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&dest.c_cc[15] = 0LL;\n  if ( (unsigned int)sub_4298DE() )\n  {\n    ptr = 0LL;\n    fildes = -1;\n    if ( (_DWORD)a2 )\n    {\n      ptr = sub_40A11F(\" FILE: uniq.XXXXXX\", a2);\n      fildes = mkstemp64((char *)ptr + 7);\n    }\n    else if ( *((_QWORD *)&dest + 8) )\n    {\n      oflag = 577;\n      if ( a1 )\n        oflag = 1089;\n      if ( v6 )\n        oflag = 65;\n      fildes = open64(*((const char **)&dest + 8), oflag, 438LL);\n    }\n    if ( fildes >= 0 && !sub_407E00(fildes, &stat_buf) && (stat_buf.st_mode & 0xF000) == 0x8000 )\n    {\n      dest.c_oflag = fildes;\n      if ( v6 )\n        sub_40A557(fildes, v6, 0);\n      if ( ptr )\n        v2 = (const char *)ptr;\n      else\n        v2 = \" Ok to send data\";\n      fd = sub_429885(v2);\n      free(ptr);\n      if ( fd >= 0 )\n      {\n        v4 = sub_40B366(fd, fildes);\n        close(fd);\n        if ( v4 >= 0 )\n          sub_429527(540422706);\n        else\n          sub_429570(540095796);\n      }\n    }\n    else\n    {\n      free(ptr);\n      sub_429570(540226869);\n      if ( fildes < 0 )\n        return;\n    }\n    close(fildes);\n    dest.c_oflag = 0;\n  }\n}\n\n\n Revised code:\nstatic void\nhandle_upload_common(int is_append, int is_unique)\n{\n\tstruct stat statbuf;\n\tchar *tempname;\n\toff_t bytes_transferred;\n\toff_t offset;\n\tint local_file_fd;\n\tint remote_fd;\n\n\toffset = G.restart_pos;\n\tG.restart_pos = 0;\n\n\tif (!port_or_pasv_was_seen())\n\t\treturn; /* port_or_pasv_was_seen emitted error response */\n\n\ttempname = NULL;\n\tlocal_file_fd = -1;\n\tif (is_unique) {\n\t\ttempname = xstrdup(\" FILE: uniq.XXXXXX\");\n\t\tlocal_file_fd = mkstemp(tempname + 7);\n\t} else if (G.ftp_arg) {\n\t\tint flags = O_WRONLY | O_CREAT | O_TRUNC;\n\t\tif (is_append)\n\t\t\tflags = O_WRONLY | O_CREAT | O_APPEND;\n\t\tif (offset)\n\t\t\tflags = O_WRONLY | O_CREAT;\n\t\tlocal_file_fd = open(G.ftp_arg, flags, 0666);\n\t}\n\n\tif (local_file_fd < 0\n\t || fstat(local_file_fd, &statbuf) != 0\n\t || !S_ISREG(statbuf.st_mode)\n\t) {\n\t\tfree(tempname);\n\t\tWRITE_ERR(FTP_UPLOADFAIL);\n\t\tif (local_file_fd >= 0)\n\t\t\tgoto close_local_and_bail;\n\t\treturn;\n\t}\n\tG.local_file_fd = local_file_fd;\n\n\tif (offset)\n\t\txlseek(local_file_fd, offset, SEEK_SET);\n\n\tremote_fd = get_remote_transfer_fd(tempname ? tempname : \" Ok to send data\");\n\tfree(tempname);\n\n\tif (remote_fd < 0)\n\t\tgoto close_local_and_bail;\n\n\tbytes_transferred = bb_copyfd_eof(remote_fd, local_file_fd);\n\tclose(remote_fd);\n\tif (bytes_transferred < 0)\n\t\tWRITE_ERR(FTP_BADSENDFILE);\n\telse\n\t\tWRITE_OK(FTP_TRANSFEROK);\n\n close_local_and_bail:\n\tclose(local_file_fd);\n\tG.local_file_fd = 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B52FD(int a1, int a2, unsigned int a3, _QWORD *a4, __int64 a5, unsigned int a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  __int64 v10; // rdx\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  __int64 v13; // r9\n  int v19; // [rsp+2Ch] [rbp-C4h] BYREF\n  int fd[2]; // [rsp+30h] [rbp-C0h] BYREF\n  __int64 v21; // [rsp+38h] [rbp-B8h]\n  __int64 v22; // [rsp+40h] [rbp-B0h]\n  struct stat64 v23; // [rsp+50h] [rbp-A0h] BYREF\n  unsigned int v24; // [rsp+ECh] [rbp-4h]\n\n  v24 = 0;\n  v22 = 0LL;\n  fd[0] = a1;\n  fd[1] = a2;\n  sub_40AAE7(a1, &v23, (__int64)\"can't stat tar file\");\n  if ( a6 )\n    sub_4B51EC(fd[0], a6);\n  v21 = a5;\n  while ( a4 )\n  {\n    if ( !(unsigned int)sub_50752C(a4[1], a3, sub_4B4FB0, sub_4B4FB0, fd, 0LL) )\n      v24 = 1;\n    a4 = (_QWORD *)*a4;\n  }\n  memset(&dest, 0, 0x400uLL);\n  sub_40A4AB(fd[0], (__int64)&dest, 1024LL);\n  close(fd[0]);\n  if ( v24 )\n    sub_409747(\"error exit delayed from previous errors\", (__int64)&dest, v6, v7, v8, v9);\n  if ( a6 )\n  {\n    if ( (unsigned int)sub_409F48(-1, &v19, 0) == -1 )\n    {\n      sub_4091D9((__int64)\"waitpid\", (__int64)&v19, v10, v11, v12, v13);\n    }\n    else if ( (v19 & 0x7F) != 0 || BYTE1(v19) )\n    {\n      return 1;\n    }\n  }\n  return v24;\n}\n\n\n Revised code:\nstatic NOINLINE int writeTarFile(int tar_fd, int verboseFlag,\n\tint recurseFlags, const llist_t *include,\n\tconst llist_t *exclude, int gzip)\n{\n\tint errorFlag = FALSE;\n\tstruct TarBallInfo tbInfo;\n\n\ttbInfo.hlInfoHead = NULL;\n\ttbInfo.tarFd = tar_fd;\n\ttbInfo.verboseFlag = verboseFlag;\n\n\t/* Store the stat info for the tarball's file, so\n\t * can avoid including the tarball into itself....  */\n\txfstat(tbInfo.tarFd, &tbInfo.tarFileStatBuf, \"can't stat tar file\");\n\n#if ENABLE_FEATURE_SEAMLESS_GZ || ENABLE_FEATURE_SEAMLESS_BZ2\n\tif (gzip)\n\t\tvfork_compressor(tbInfo.tarFd, gzip);\n#endif\n\n\ttbInfo.excludeList = exclude;\n\n\t/* Read the directory/files and iterate over them one at a time */\n\twhile (include) {\n\t\tif (!recursive_action(include->data, recurseFlags,\n\t\t\t\twriteFileToTarball, writeFileToTarball, &tbInfo, 0)\n\t\t) {\n\t\t\terrorFlag = TRUE;\n\t\t}\n\t\tinclude = include->link;\n\t}\n\t/* Write two empty blocks to the end of the archive */\n\tmemset(block_buf, 0, 2*TAR_BLOCK_SIZE);\n\txwrite(tbInfo.tarFd, block_buf, 2*TAR_BLOCK_SIZE);\n\n\t/* To be pedantically correct, we would check if the tarball\n\t * is smaller than 20 tar blocks, and pad it if it was smaller,\n\t * but that isn't necessary for GNU tar interoperability, and\n\t * so is considered a waste of space */\n\n\t/* Close so the child process (if any) will exit */\n\tclose(tbInfo.tarFd);\n\n\t/* Hang up the tools, close up shop, head home */\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tfreeHardLinkInfo(&tbInfo.hlInfoHead);\n\n\tif (errorFlag)\n\t\tbb_error_msg(\"error exit delayed from previous errors\");\n\n#if ENABLE_FEATURE_SEAMLESS_GZ || ENABLE_FEATURE_SEAMLESS_BZ2\n\tif (gzip) {\n\t\tint status;\n\t\tif (safe_waitpid(-1, &status, 0) == -1)\n\t\t\tbb_perror_msg(\"waitpid\");\n\t\telse if (!WIFEXITED(status) || WEXITSTATUS(status))\n\t\t\t/* gzip was killed or has exited with nonzero! */\n\t\t\terrorFlag = TRUE;\n\t}\n#endif\n\treturn errorFlag;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_429E00(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  int fd; // [rsp+18h] [rbp-48h] BYREF\n  int v5; // [rsp+1Ch] [rbp-44h]\n  __int64 v6[3]; // [rsp+20h] [rbp-40h] BYREF\n  char *v7; // [rsp+38h] [rbp-28h]\n  __int64 v8; // [rsp+40h] [rbp-20h]\n  char *v10; // [rsp+58h] [rbp-8h]\n\n  v6[0] = (__int64)\"ftpd\";\n  v6[1] = a1;\n  v6[2] = (__int64)\"--\";\n  v7 = (char *)*((_QWORD *)&dest + 8);\n  v8 = 0LL;\n  if ( *((_QWORD *)&dest + 8) && **((_BYTE **)&dest + 8) == 45 )\n  {\n    a2 = 32LL;\n    v10 = strchr(*((const char **)&dest + 8), 32);\n    if ( v10 )\n      ++v10;\n    v7 = v10;\n  }\n  sub_40A415(&fd, a2);\n  if ( !(unsigned int)sub_40AEE6((__int64)&fd, a2) )\n  {\n    close(fd);\n    sub_40A477(v5, 1u);\n    close(0);\n    dup(1);\n    v2 = sub_4CC866(4LL, v6);\n    exit(v2);\n  }\n  close(v5);\n  return (unsigned int)fd;\n}\n\n\n Revised code:\nstatic int\npopen_ls(const char *opt)\n{\n\tconst char *argv[5];\n\tstruct fd_pair outfd;\n\tpid_t pid;\n\n\targv[0] = \"ftpd\";\n\targv[1] = opt; /* \"-l\" or \"-1\" */\n#if BB_MMU\n\targv[2] = \"--\";\n#else\n\t/* NOMMU ftpd ls helper chdirs to argv[2],\n\t * preventing peer from seeing real root. */\n\targv[2] = xrealloc_getcwd_or_warn(NULL);\n#endif\n\targv[3] = G.ftp_arg;\n\targv[4] = NULL;\n\n\t/* Improve compatibility with non-RFC conforming FTP clients\n\t * which send e.g. \"LIST -l\", \"LIST -la\", \"LIST -aL\".\n\t * See https://bugs.kde.org/show_bug.cgi?id=195578 */\n\tif (ENABLE_FEATURE_FTPD_ACCEPT_BROKEN_LIST\n\t && G.ftp_arg && G.ftp_arg[0] == '-'\n\t) {\n\t\tconst char *tmp = strchr(G.ftp_arg, ' ');\n\t\tif (tmp) /* skip the space */\n\t\t\ttmp++;\n\t\targv[3] = tmp;\n\t}\n\n\txpiped_pair(outfd);\n\n\t/*fflush_all(); - so far we dont use stdio on output */\n\tpid = BB_MMU ? xfork() : xvfork();\n\tif (pid == 0) {\n\t\t/* child */\n#if !BB_MMU\n\t\t/* On NOMMU, we want to execute a child - copy of ourself.\n\t\t * In chroot we usually can't do it. Thus we chdir\n\t\t * out of the chroot back to original root,\n\t\t * and (see later below) execute bb_busybox_exec_path\n\t\t * relative to current directory */\n\t\tif (fchdir(G.root_fd) != 0)\n\t\t\t_exit(127);\n\t\t/*close(G.root_fd); - close_on_exec_on() took care of this */\n#endif\n\t\t/* NB: close _first_, then move fd! */\n\t\tclose(outfd.rd);\n\t\txmove_fd(outfd.wr, STDOUT_FILENO);\n\t\t/* Opening /dev/null in chroot is hard.\n\t\t * Just making sure STDIN_FILENO is opened\n\t\t * to something harmless. Paranoia,\n\t\t * ls won't read it anyway */\n\t\tclose(STDIN_FILENO);\n\t\tdup(STDOUT_FILENO); /* copy will become STDIN_FILENO */\n#if BB_MMU\n\t\t/* memset(&G, 0, sizeof(G)); - ls_main does it */\n\t\texit(ls_main(ARRAY_SIZE(argv) - 1, (char**) argv));\n#else\n\t\t/* + 1: we must use relative path here if in chroot.\n\t\t * For example, execv(\"/proc/self/exe\") will fail, since\n\t\t * it looks for \"/proc/self/exe\" _relative to chroot!_ */\n\t\texecv(bb_busybox_exec_path + 1, (char**) argv);\n\t\t_exit(127);\n#endif\n\t}\n\n\t/* parent */\n\tclose(outfd.wr);\n#if !BB_MMU\n\tfree((char*)argv[2]);\n#endif\n\treturn outfd.rd;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid sub_429C7C()\n{\n  int v0; // eax\n  __int64 v1; // rcx\n  __int64 v2; // r8\n  __int64 v3; // r9\n  struct stat64 stat_buf; // [rsp+0h] [rbp-C0h] BYREF\n  __int64 v5; // [rsp+98h] [rbp-28h]\n  int fd; // [rsp+A4h] [rbp-1Ch]\n  void *ptr; // [rsp+A8h] [rbp-18h]\n  int fildes; // [rsp+B4h] [rbp-Ch]\n  __off64_t v9; // [rsp+B8h] [rbp-8h]\n\n  v9 = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&dest.c_cc[15] = 0LL;\n  if ( (unsigned int)sub_4298DE() )\n  {\n    if ( *((_QWORD *)&dest + 8) )\n      v0 = open64(*((const char **)&dest + 8), 2048);\n    else\n      v0 = -1;\n    fildes = v0;\n    if ( v0 >= 0 )\n    {\n      if ( !sub_407E00(fildes, &stat_buf) && (stat_buf.st_mode & 0xF000) == 0x8000 )\n      {\n        dest.c_oflag = fildes;\n        sub_4099DC(fildes);\n        if ( v9 )\n          sub_40A557(fildes, v9, 0);\n        ptr = sub_40A6B3(\n                \" Opening BINARY connection for %s (%lu bytes)\",\n                *((_QWORD *)&dest + 8),\n                stat_buf.st_size,\n                v1,\n                v2,\n                v3);\n        fd = sub_429885((const char *)ptr);\n        free(ptr);\n        if ( fd >= 0 )\n        {\n          v5 = sub_40B366(fildes, fd);\n          close(fd);\n          if ( v5 >= 0 )\n            sub_429527(540422706);\n          else\n            sub_429570(540095796);\n        }\n      }\n      else\n      {\n        sub_429570(540030261);\n      }\n      close(fildes);\n      dest.c_oflag = 0;\n    }\n    else\n    {\n      sub_429570(540030261);\n    }\n  }\n}\n",
        "output": "static void handle_binary_connection()\n{\n    int file_descriptor;\n    struct stat64 stat_buffer;\n    __off64_t file_size;\n    void *message;\n    int fd;\n    __int64 v5;\n\n    file_size = *(_QWORD *)&dest.c_cc[15];\n    *(_QWORD *)&dest.c_cc[15] = 0LL;\n\n    if ((unsigned int)sub_4298DE())\n    {\n        if (*((_QWORD *)&dest + 8))\n            file_descriptor = open64(*((const char **)&dest + 8), 2048);\n        else\n            file_descriptor = -1;\n\n        fildes = file_descriptor;\n\n        if (file_descriptor >= 0)\n        {\n            if (!sub_407E00(file_descriptor, &stat_buffer) && (stat_buffer.st_mode & 0xF000) == 0x8000)\n            {\n                dest.c_oflag = file_descriptor;\n                sub_4099DC(file_descriptor);\n\n                if (file_size)\n                    sub_40A557(file_descriptor, file_size, 0);\n\n                message = sub_40A6B3(\" Opening BINARY connection for %s (%lu bytes)\", *((_QWORD *)&dest + 8), stat_buffer.st_size, v1, v2, v3);\n                fd = sub_429885((const char *)message);\n                free(message);\n\n                if (fd >= 0)\n                {\n                    v5 = sub_40B366(file_descriptor, fd);\n                    close(fd);\n\n                    if (v5 >= 0)\n                        sub_429527(540422706);\n                    else\n                        sub_429570(540095796);\n                }\n            }\n            else\n            {\n                sub_429570(540030261);\n            }\n\n            close(file_descriptor);\n            dest.c_oflag = 0;\n        }\n        else\n        {\n            sub_429570(540030261);\n        }\n    }\n}",
        "source_code": "static void\nhandle_retr(void)\n{\n\tstruct stat statbuf;\n\toff_t bytes_transferred;\n\tint remote_fd;\n\tint local_file_fd;\n\toff_t offset = G.restart_pos;\n\tchar *response;\n\n\tG.restart_pos = 0;\n\n\tif (!port_or_pasv_was_seen())\n\t\treturn; /* port_or_pasv_was_seen emitted error response */\n\n\t/* O_NONBLOCK is useful if file happens to be a device node */\n\tlocal_file_fd = G.ftp_arg ? open(G.ftp_arg, O_RDONLY | O_NONBLOCK) : -1;\n\tif (local_file_fd < 0) {\n\t\tWRITE_ERR(FTP_FILEFAIL);\n\t\treturn;\n\t}\n\n\tif (fstat(local_file_fd, &statbuf) != 0 || !S_ISREG(statbuf.st_mode)) {\n\t\t/* Note - pretend open failed */\n\t\tWRITE_ERR(FTP_FILEFAIL);\n\t\tgoto file_close_out;\n\t}\n\tG.local_file_fd = local_file_fd;\n\n\t/* Now deactive O_NONBLOCK, otherwise we have a problem\n\t * on DMAPI filesystems such as XFS DMAPI.\n\t */\n\tndelay_off(local_file_fd);\n\n\t/* Set the download offset (from REST) if any */\n\tif (offset != 0)\n\t\txlseek(local_file_fd, offset, SEEK_SET);\n\n\tresponse = xasprintf(\n\t\t\" Opening BINARY connection for %s (%\"OFF_FMT\"u bytes)\",\n\t\tG.ftp_arg, statbuf.st_size);\n\tremote_fd = get_remote_transfer_fd(response);\n\tfree(response);\n\tif (remote_fd < 0)\n\t\tgoto file_close_out;\n\n\tbytes_transferred = bb_copyfd_eof(local_file_fd, remote_fd);\n\tclose(remote_fd);\n\tif (bytes_transferred < 0)\n\t\tWRITE_ERR(FTP_BADSENDFILE);\n\telse\n\t\tWRITE_OK(FTP_TRANSFEROK);\n\n file_close_out:\n\tclose(local_file_fd);\n\tG.local_file_fd = 0;\n}",
        "parsed_output": "static void handle_binary_connection()\n{\n    int file_descriptor;\n    struct stat64 stat_buffer;\n    __off64_t file_size;\n    void *message;\n    int fd;\n    __int64 v5;\n\n    file_size = *(_QWORD *)&dest.c_cc[15];\n    *(_QWORD *)&dest.c_cc[15] = 0LL;\n\n    if ((unsigned int)sub_4298DE())\n    {\n        if (*((_QWORD *)&dest + 8))\n            file_descriptor = open64(*((const char **)&dest + 8), 2048);\n        else\n            file_descriptor = -1;\n\n        fildes = file_descriptor;\n\n        if (file_descriptor >= 0)\n        {\n            if (!sub_407E00(file_descriptor, &stat_buffer) && (stat_buffer.st_mode & 0xF000) == 0x8000)\n            {\n                dest.c_oflag = file_descriptor;\n                sub_4099DC(file_descriptor);\n\n                if (file_size)\n                    sub_40A557(file_descriptor, file_size, 0);\n\n                message = sub_40A6B3(\" Opening BINARY connection for %s (%lu bytes)\", *((_QWORD *)&dest + 8), stat_buffer.st_size, v1, v2, v3);\n                fd = sub_429885((const char *)message);\n                free(message);\n\n                if (fd >= 0)\n                {\n                    v5 = sub_40B366(file_descriptor, fd);\n                    close(fd);\n\n                    if (v5 >= 0)\n                        sub_429527(540422706);\n                    else\n                        sub_429570(540095796);\n                }\n            }\n            else\n            {\n                sub_429570(540030261);\n            }\n\n            close(file_descriptor);\n            dest.c_oflag = 0;\n        }\n        else\n        {\n            sub_429570(540030261);\n        }\n    }\n}",
        "baseline_code_stripped": "void sub_429C7C()\n{\n  int v0; // eax\n  __int64 v1; // rcx\n  __int64 v2; // r8\n  __int64 v3; // r9\n  struct stat64 stat_buf; // [rsp+0h] [rbp-C0h] BYREF\n  __int64 v5; // [rsp+98h] [rbp-28h]\n  int fd; // [rsp+A4h] [rbp-1Ch]\n  void *ptr; // [rsp+A8h] [rbp-18h]\n  int fildes; // [rsp+B4h] [rbp-Ch]\n  __off64_t v9; // [rsp+B8h] [rbp-8h]\n\n  v9 = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&dest.c_cc[15] = 0LL;\n  if ( (unsigned int)sub_4298DE() )\n  {\n    if ( *((_QWORD *)&dest + 8) )\n      v0 = open64(*((const char **)&dest + 8), 2048);\n    else\n      v0 = -1;\n    fildes = v0;\n    if ( v0 >= 0 )\n    {\n      if ( !sub_407E00(fildes, &stat_buf) && (stat_buf.st_mode & 0xF000) == 0x8000 )\n      {\n        dest.c_oflag = fildes;\n        sub_4099DC(fildes);\n        if ( v9 )\n          sub_40A557(fildes, v9, 0);\n        ptr = sub_40A6B3(\n                \" Opening BINARY connection for %s (%lu bytes)\",\n                *((_QWORD *)&dest + 8),\n                stat_buf.st_size,\n                v1,\n                v2,\n                v3);\n        fd = sub_429885((const char *)ptr);\n        free(ptr);\n        if ( fd >= 0 )\n        {\n          v5 = sub_40B366(fildes, fd);\n          close(fd);\n          if ( v5 >= 0 )\n            sub_429527(540422706);\n          else\n            sub_429570(540095796);\n        }\n      }\n      else\n      {\n        sub_429570(540030261);\n      }\n      close(fildes);\n      dest.c_oflag = 0;\n    }\n    else\n    {\n      sub_429570(540030261);\n    }\n  }\n}\n",
        "baseline_code_debug": "void __cdecl handle_retr()\n{\n  int v0; // eax\n  stat statbuf; // [rsp+0h] [rbp-C0h] BYREF\n  off_t bytes_transferred; // [rsp+98h] [rbp-28h]\n  int remote_fd; // [rsp+A4h] [rbp-1Ch]\n  char *response; // [rsp+A8h] [rbp-18h]\n  int local_file_fd; // [rsp+B4h] [rbp-Ch]\n  off_t offset; // [rsp+B8h] [rbp-8h]\n\n  offset = *(_QWORD *)&bb_common_bufsiz1.c_cc[15];\n  *(_QWORD *)&bb_common_bufsiz1.c_cc[15] = 0LL;\n  if ( port_or_pasv_was_seen() )\n  {\n    if ( *((_QWORD *)&bb_common_bufsiz1 + 8) )\n      v0 = open64(*((const char **)&bb_common_bufsiz1 + 8), 2048);\n    else\n      v0 = -1;\n    local_file_fd = v0;\n    if ( v0 >= 0 )\n    {\n      if ( !fstat64(local_file_fd, (stat64 *)&statbuf) && (statbuf.st_mode & 0xF000) == 0x8000 )\n      {\n        bb_common_bufsiz1.c_oflag = local_file_fd;\n        ndelay_off(local_file_fd);\n        if ( offset )\n          xlseek(local_file_fd, offset, 0);\n        response = xasprintf(\n                     \" Opening BINARY connection for %s (%lu bytes)\",\n                     *((const char **)&bb_common_bufsiz1 + 8),\n                     statbuf.st_size);\n        remote_fd = get_remote_transfer_fd(response);\n        free(response);\n        if ( remote_fd >= 0 )\n        {\n          bytes_transferred = bb_copyfd_eof(local_file_fd, remote_fd);\n          close(remote_fd);\n          if ( bytes_transferred >= 0 )\n            cmdio_write_ok(0x20363232u);\n          else\n            cmdio_write_error(0x20313534u);\n        }\n      }\n      else\n      {\n        cmdio_write_error(0x20303535u);\n      }\n      close(local_file_fd);\n      bb_common_bufsiz1.c_oflag = 0;\n    }\n    else\n    {\n      cmdio_write_error(0x20303535u);\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.659177303314209,
        "similarity_score_baseline_stripped": 0.575982928276062,
        "similarity_score_baseline_debug": 0.8112479448318481
    },
    {
        "func_name": "xrealloc_getcwd_or_warn",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_489210(__int64 a1)\n{\n  const char *v1; // rax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  char *v7; // [rsp+10h] [rbp-10h]\n  char *path; // [rsp+18h] [rbp-8h]\n\n  path = *(char **)sub_48914D(a1);\n  if ( !path )\n  {\n    v7 = sub_4807EA(\"HOME\");\n    if ( v7 )\n      v1 = v7;\n    else\n      v1 = \"/\";\n    path = (char *)v1;\n  }\n  if ( chdir(path) )\n  {\n    sub_4091D9((__int64)\"cd: %s\", (__int64)path, v2, v3, v4, v5);\n    return 1LL;\n  }\n  else\n  {\n    sub_480BCB(0);\n    return 0LL;\n  }\n}\n\n\n Revised code:\nstatic int FAST_FUNC builtin_cd(char **argv)\n{\n\tconst char *newdir;\n\n\targv = skip_dash_dash(argv);\n\tnewdir = argv[0];\n\tif (newdir == NULL) {\n\t\t/* bash does nothing (exitcode 0) if HOME is \"\"; if it's unset,\n\t\t * bash says \"bash: cd: HOME not set\" and does nothing\n\t\t * (exitcode 1)\n\t\t */\n\t\tconst char *home = get_local_var_value(\"HOME\");\n\t\tnewdir = home ? home : \"/\";\n\t}\n\tif (chdir(newdir)) {\n\t\t/* Mimic bash message exactly */\n\t\tbb_perror_msg(\"cd: %s\", newdir);\n\t\treturn EXIT_FAILURE;\n\t}\n\t/* Read current dir (get_cwd(1) is inside) and set PWD.\n\t * Note: do not enforce exporting. If PWD was unset or unexported,\n\t * set it again, but do not export. bash does the same.\n\t */\n\tset_pwd_var(/*exp:*/ 0);\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4F680B(const char *a1, char a2)\n{\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  unsigned int v6; // [rsp+1Ch] [rbp-4h]\n\n  v6 = *(_DWORD *)qword_75D400;\n  if ( (a2 & 0x10) != 0 )\n  {\n    fprintf(stderr, \"%s: overwrite '%s'? \", ident, a1);\n    if ( !sub_4F5F18() )\n      return 0LL;\n  }\n  if ( unlink(a1) >= 0 )\n    return 1LL;\n  *(_DWORD *)qword_75D400 = v6;\n  sub_4091D9((__int64)\"can't create '%s'\", (__int64)a1, v6, v3, v4, v5);\n  return 0xFFFFFFFFLL;\n}\n\n\n Revised code:\nstatic int ask_and_unlink(const char *dest, int flags)\n{\n\tint e = errno;\n\n#if !ENABLE_FEATURE_NON_POSIX_CP\n\tif (!(flags & (FILEUTILS_FORCE|FILEUTILS_INTERACTIVE))) {\n\t\t/* Either it exists, or the *path* doesnt exist */\n\t\tbb_perror_msg(\"can't create '%s'\", dest);\n\t\treturn -1;\n\t}\n#endif\n\t// else: act as if -f is always in effect.\n\t// We don't want \"can't create\" msg, we want unlink to be done\n\t// (silently unless -i). Why? POSIX cp usually succeeds with\n\t// O_TRUNC open of existing file, and user is left ignorantly happy.\n\t// With above block unconditionally enabled, non-POSIX cp\n\t// will complain a lot more than POSIX one.\n\n\t/* TODO: maybe we should do it only if ctty is present? */\n\tif (flags & FILEUTILS_INTERACTIVE) {\n\t\t// We would not do POSIX insanity. -i asks,\n\t\t// then _unlinks_ the offender. Presto.\n\t\t// (No \"opening without O_EXCL\", no \"unlink only if -f\")\n\t\t// Or else we will end up having 3 open()s!\n\t\tfprintf(stderr, \"%s: overwrite '%s'? \", applet_name, dest);\n\t\tif (!bb_ask_confirmation())\n\t\t\treturn 0; /* not allowed to overwrite */\n\t}\n\tif (unlink(dest) < 0) {\n#if ENABLE_FEATURE_VERBOSE_CP_MESSAGE\n\t\tif (e == errno && e == ENOENT) {\n\t\t\t/* e == ENOTDIR is similar: path has non-dir component,\n\t\t\t * but in this case we don't even reach copy_file() */\n\t\t\tbb_error_msg(\"can't create '%s': Path does not exist\", dest);\n\t\t\treturn -1; /* error */\n\t\t}\n#endif\n\t\terrno = e; /* do not use errno from unlink */\n\t\tbb_perror_msg(\"can't create '%s'\", dest);\n\t\treturn -1; /* error */\n\t}\n\treturn 1; /* ok (to try again) */\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_408E19(void *a1, _BYTE *a2)\n{\n  int v2; // r8d\n  int v3; // r9d\n  const char *v4; // rsi\n  void *v7; // [rsp+8h] [rbp-18h]\n  __int64 v8; // [rsp+18h] [rbp-8h]\n\n  v7 = a1;\n  if ( !a1 )\n    v7 = &unk_534FA3;\n  v8 = sub_408F79(v7, 47LL);\n  while ( *a2 == 47 )\n    ++a2;\n  if ( v8 )\n    v4 = (const char *)&unk_534FA3;\n  else\n    v4 = \"/\";\n  return sub_40A6B3((unsigned int)\"%s%s%s\", (_DWORD)v7, (_DWORD)v4, (_DWORD)a2, v2, v3);\n}\n\n\n Revised code:\nFAST_FUNC concat_path_file(const char *path, const char *filename)\n{\n\tchar *lc;\n\n\tif (!path)\n\t\tpath = \"\";\n\tlc = last_char_is(path, '/');\n\twhile (*filename == '/')\n\t\tfilename++;\n\treturn xasprintf(\"%s%s%s\", path, (lc==NULL ? \"/\" : \"\"), filename);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_50BFFD(void *a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  size_t v6; // rax\n  unsigned int size; // [rsp+1Ch] [rbp-4h]\n\n  size = 128;\n  while ( 1 )\n  {\n    size += 64;\n    a1 = sub_40A09E(a1, size);\n    if ( getcwd((char *)a1, size) )\n      break;\n    if ( *(_DWORD *)qword_75D400 != 34 )\n    {\n      free(a1);\n      sub_4091D9((__int64)\"getcwd\", size, v1, v2, v3, v4);\n      return 0LL;\n    }\n  }\n  v6 = strlen((const char *)a1);\n  return sub_40A09E(a1, v6 + 1);\n}\n",
        "output": "static void* get_current_directory(void* buffer)\n{\n    size_t size = 128;\n    while (1)\n    {\n        size += 64;\n        buffer = sub_40A09E(buffer, size);\n        if (getcwd((char*)buffer, size))\n            break;\n        if (*(int*)qword_75D400 != 34)\n        {\n            free(buffer);\n            sub_4091D9((__int64)\"getcwd\", size, v1, v2, v3, v4);\n            return NULL;\n        }\n    }\n    size_t length = strlen((const char*)buffer);\n    return sub_40A09E(buffer, length + 1);\n}",
        "source_code": "FAST_FUNC\nxrealloc_getcwd_or_warn(char *cwd)\n{\n#define PATH_INCR 64\n\n\tchar *ret;\n\tunsigned path_max;\n\n\tpath_max = 128; /* 128 + 64 should be enough for 99% of cases */\n\n\twhile (1) {\n\t\tpath_max += PATH_INCR;\n\t\tcwd = xrealloc(cwd, path_max);\n\t\tret = getcwd(cwd, path_max);\n\t\tif (ret == NULL) {\n\t\t\tif (errno == ERANGE)\n\t\t\t\tcontinue;\n\t\t\tfree(cwd);\n\t\t\tbb_perror_msg(\"getcwd\");\n\t\t\treturn NULL;\n\t\t}\n\t\tcwd = xrealloc(cwd, strlen(cwd) + 1);\n\t\treturn cwd;\n\t}\n}",
        "parsed_output": "static void* get_current_directory(void* buffer)\n{\n    size_t size = 128;\n    while (1)\n    {\n        size += 64;\n        buffer = sub_40A09E(buffer, size);\n        if (getcwd((char*)buffer, size))\n            break;\n        if (*(int*)qword_75D400 != 34)\n        {\n            free(buffer);\n            sub_4091D9((__int64)\"getcwd\", size, v1, v2, v3, v4);\n            return NULL;\n        }\n    }\n    size_t length = strlen((const char*)buffer);\n    return sub_40A09E(buffer, length + 1);\n}",
        "baseline_code_stripped": "void *__fastcall sub_50BFFD(void *a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  size_t v6; // rax\n  unsigned int size; // [rsp+1Ch] [rbp-4h]\n\n  size = 128;\n  while ( 1 )\n  {\n    size += 64;\n    a1 = sub_40A09E(a1, size);\n    if ( getcwd((char *)a1, size) )\n      break;\n    if ( *(_DWORD *)qword_75D400 != 34 )\n    {\n      free(a1);\n      sub_4091D9((__int64)\"getcwd\", size, v1, v2, v3, v4);\n      return 0LL;\n    }\n  }\n  v6 = strlen((const char *)a1);\n  return sub_40A09E(a1, v6 + 1);\n}\n",
        "baseline_code_debug": "char *__cdecl xrealloc_getcwd_or_warn(char *cwd)\n{\n  size_t v2; // rdx\n  unsigned int path_max; // [rsp+1Ch] [rbp-4h]\n\n  path_max = 128;\n  while ( 1 )\n  {\n    path_max += 64;\n    cwd = (char *)xrealloc(cwd, path_max);\n    if ( getcwd(cwd, path_max) )\n      break;\n    if ( *bb_errno != 34 )\n    {\n      free(cwd);\n      bb_perror_msg(\"getcwd\");\n      return 0LL;\n    }\n  }\n  v2 = strlen(cwd) + 1;\n  return (char *)xrealloc(cwd, v2);\n}\n",
        "similarity_score_unixcoder": 0.773567795753479,
        "similarity_score_baseline_stripped": 0.6398547887802124,
        "similarity_score_baseline_debug": 0.900534987449646
    },
    {
        "func_name": "logdir_close",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E7583(int a1, const void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  int v7; // [rsp+8h] [rbp-18h]\n  _QWORD *ptr; // [rsp+10h] [rbp-10h]\n  char *v9; // [rsp+18h] [rbp-8h]\n\n  v7 = a3;\n  if ( a1 <= 0 || a1 > *((_DWORD *)qword_75D408 + 1) + 1 )\n  {\n    sub_409747(\"inserting at bad line number\", (__int64)a2, a3, a4, a5, a6, a2);\n    return 0LL;\n  }\n  ptr = sub_40A05F((int)a3 + 23LL, (__int64)a2);\n  memcpy((char *)ptr + 20, a2, v7);\n  *((_DWORD *)ptr + 4) = v7;\n  if ( a1 <= *((_DWORD *)qword_75D408 + 1) )\n  {\n    v9 = (char *)sub_4E78F6((unsigned int)a1);\n    if ( !v9 )\n    {\n      free(ptr);\n      return 0LL;\n    }\n  }\n  else\n  {\n    v9 = (char *)qword_75D408 + 48;\n  }\n  *ptr = v9;\n  ptr[1] = *((_QWORD *)v9 + 1);\n  **((_QWORD **)v9 + 1) = ptr;\n  *((_QWORD *)v9 + 1) = ptr;\n  ++*((_DWORD *)qword_75D408 + 1);\n  *((_BYTE *)qword_75D408 + 72) = 1;\n  return sub_4E7A44((unsigned int)a1);\n}\n\n\n Revised code:\nstatic int insertLine(int num, const char *data, int len)\n{\n\tLINE *newLp, *lp;\n\n\tif ((num < 1) || (num > lastNum + 1)) {\n\t\tbb_error_msg(\"inserting at bad line number\");\n\t\treturn FALSE;\n\t}\n\n\tnewLp = xmalloc(sizeof(LINE) + len - 1);\n\n\tmemcpy(newLp->data, data, len);\n\tnewLp->len = len;\n\n\tif (num > lastNum)\n\t\tlp = &lines;\n\telse {\n\t\tlp = findLine(num);\n\t\tif (lp == NULL) {\n\t\t\tfree((char *) newLp);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tnewLp->next = lp;\n\tnewLp->prev = lp->prev;\n\tlp->prev->next = newLp;\n\tlp->prev = newLp;\n\n\tlastNum++;\n\tdirty = TRUE;\n\treturn setCurNum(num);\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_40E349(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  _QWORD *v6; // rbx\n  __int64 v7; // rdx\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  char *v11; // rax\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  char *result; // rax\n  char *v17; // [rsp+8h] [rbp-18h]\n\n  if ( **((_BYTE **)qword_75D408 + 3) == 45 && !*(_BYTE *)(*((_QWORD *)qword_75D408 + 3) + 1LL) )\n  {\n    if ( (fcntl(0, 3) & 3) != 2 )\n      sub_40969E(\"stdin is not open for read/write\", 3LL, v7, v8, v9, v10);\n    v17 = sub_40AD9A(0, 3LL);\n    if ( v17 )\n      *((_QWORD *)qword_75D408 + 3) = v17;\n  }\n  else\n  {\n    if ( **((_BYTE **)qword_75D408 + 3) != 47 )\n    {\n      v6 = qword_75D408;\n      v6[3] = sub_40A6B3(\"/dev/%s\", *((_QWORD *)qword_75D408 + 3), a3, a4, a5, a6);\n    }\n    close(0);\n    sub_40A295(*((const char **)qword_75D408 + 3), 2050);\n    fchown(0, 0, 0);\n    fchmod(0, 0x190u);\n  }\n  v11 = sub_40941B(*((const char **)qword_75D408 + 3));\n  result = sub_40A6B3(\"getty: %s\", (__int64)v11, v12, v13, v14, v15);\n  ident = result;\n  return result;\n}\n\n\n Revised code:\nstatic void open_tty(void)\n{\n\t/* Set up new standard input, unless we are given an already opened port */\n\tif (NOT_LONE_DASH(G.tty_name)) {\n\t\tif (G.tty_name[0] != '/')\n\t\t\tG.tty_name = xasprintf(\"/dev/%s\", G.tty_name); /* will leak it */\n\n\t\t/* Open the tty as standard input */\n\t\tdebug(\"open(2)\\n\");\n\t\tclose(0);\n\t\txopen(G.tty_name, O_RDWR | O_NONBLOCK); /* uses fd 0 */\n\n\t\t/* Set proper protections and ownership */\n\t\tfchown(0, 0, 0);        /* 0:0 */\n\t\tfchmod(0, 0620);        /* crw--w---- */\n\t} else {\n\t\tchar *n;\n\t\t/*\n\t\t * Standard input should already be connected to an open port.\n\t\t * Make sure it is open for read/write.\n\t\t */\n\t\tif ((fcntl(0, F_GETFL) & (O_RDWR|O_RDONLY|O_WRONLY)) != O_RDWR)\n\t\t\tbb_error_msg_and_die(\"stdin is not open for read/write\");\n\n\t\t/* Try to get real tty name instead of \"-\" */\n\t\tn = xmalloc_ttyname(0);\n\t\tif (n)\n\t\t\tG.tty_name = n;\n\t}\n\tapplet_name = xasprintf(\"getty: %s\", skip_dev_pfx(G.tty_name));\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B52FD(int a1, int a2, unsigned int a3, _QWORD *a4, __int64 a5, unsigned int a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  __int64 v10; // rdx\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  __int64 v13; // r9\n  int v19; // [rsp+2Ch] [rbp-C4h] BYREF\n  int fd[2]; // [rsp+30h] [rbp-C0h] BYREF\n  __int64 v21; // [rsp+38h] [rbp-B8h]\n  __int64 v22; // [rsp+40h] [rbp-B0h]\n  struct stat64 v23; // [rsp+50h] [rbp-A0h] BYREF\n  unsigned int v24; // [rsp+ECh] [rbp-4h]\n\n  v24 = 0;\n  v22 = 0LL;\n  fd[0] = a1;\n  fd[1] = a2;\n  sub_40AAE7(a1, &v23, (__int64)\"can't stat tar file\");\n  if ( a6 )\n    sub_4B51EC(fd[0], a6);\n  v21 = a5;\n  while ( a4 )\n  {\n    if ( !(unsigned int)sub_50752C(a4[1], a3, sub_4B4FB0, sub_4B4FB0, fd, 0LL) )\n      v24 = 1;\n    a4 = (_QWORD *)*a4;\n  }\n  memset(&dest, 0, 0x400uLL);\n  sub_40A4AB(fd[0], (__int64)&dest, 1024LL);\n  close(fd[0]);\n  if ( v24 )\n    sub_409747(\"error exit delayed from previous errors\", (__int64)&dest, v6, v7, v8, v9);\n  if ( a6 )\n  {\n    if ( (unsigned int)sub_409F48(-1, &v19, 0) == -1 )\n    {\n      sub_4091D9((__int64)\"waitpid\", (__int64)&v19, v10, v11, v12, v13);\n    }\n    else if ( (v19 & 0x7F) != 0 || BYTE1(v19) )\n    {\n      return 1;\n    }\n  }\n  return v24;\n}\n\n\n Revised code:\nstatic NOINLINE int writeTarFile(int tar_fd, int verboseFlag,\n\tint recurseFlags, const llist_t *include,\n\tconst llist_t *exclude, int gzip)\n{\n\tint errorFlag = FALSE;\n\tstruct TarBallInfo tbInfo;\n\n\ttbInfo.hlInfoHead = NULL;\n\ttbInfo.tarFd = tar_fd;\n\ttbInfo.verboseFlag = verboseFlag;\n\n\t/* Store the stat info for the tarball's file, so\n\t * can avoid including the tarball into itself....  */\n\txfstat(tbInfo.tarFd, &tbInfo.tarFileStatBuf, \"can't stat tar file\");\n\n#if ENABLE_FEATURE_SEAMLESS_GZ || ENABLE_FEATURE_SEAMLESS_BZ2\n\tif (gzip)\n\t\tvfork_compressor(tbInfo.tarFd, gzip);\n#endif\n\n\ttbInfo.excludeList = exclude;\n\n\t/* Read the directory/files and iterate over them one at a time */\n\twhile (include) {\n\t\tif (!recursive_action(include->data, recurseFlags,\n\t\t\t\twriteFileToTarball, writeFileToTarball, &tbInfo, 0)\n\t\t) {\n\t\t\terrorFlag = TRUE;\n\t\t}\n\t\tinclude = include->link;\n\t}\n\t/* Write two empty blocks to the end of the archive */\n\tmemset(block_buf, 0, 2*TAR_BLOCK_SIZE);\n\txwrite(tbInfo.tarFd, block_buf, 2*TAR_BLOCK_SIZE);\n\n\t/* To be pedantically correct, we would check if the tarball\n\t * is smaller than 20 tar blocks, and pad it if it was smaller,\n\t * but that isn't necessary for GNU tar interoperability, and\n\t * so is considered a waste of space */\n\n\t/* Close so the child process (if any) will exit */\n\tclose(tbInfo.tarFd);\n\n\t/* Hang up the tools, close up shop, head home */\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tfreeHardLinkInfo(&tbInfo.hlInfoHead);\n\n\tif (errorFlag)\n\t\tbb_error_msg(\"error exit delayed from previous errors\");\n\n#if ENABLE_FEATURE_SEAMLESS_GZ || ENABLE_FEATURE_SEAMLESS_BZ2\n\tif (gzip) {\n\t\tint status;\n\t\tif (safe_waitpid(-1, &status, 0) == -1)\n\t\t\tbb_perror_msg(\"waitpid\");\n\t\telse if (!WIFEXITED(status) || WEXITSTATUS(status))\n\t\t\t/* gzip was killed or has exited with nonzero! */\n\t\t\terrorFlag = TRUE;\n\t}\n#endif\n\treturn errorFlag;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_46C370(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 result; // rax\n  __int64 v7; // rdx\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  __int64 v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  __int64 v14; // r9\n\n  result = *(unsigned int *)(a1 + 48);\n  if ( (_DWORD)result != -1 )\n  {\n    if ( *((_DWORD *)qword_75D408 + 2) )\n      sub_409747(\"info: close: %s\", *(_QWORD *)(a1 + 16), a3, a4, a5, a6);\n    close(*(_DWORD *)(a1 + 48));\n    *(_DWORD *)(a1 + 48) = -1;\n    result = *(unsigned int *)(a1 + 52);\n    if ( (_DWORD)result != -1 )\n    {\n      while ( fflush(*(FILE **)(a1 + 56)) || fsync(*(_DWORD *)(a1 + 52)) == -1 )\n        sub_46B2B6((__int64)\"fsync current logfile\", *(_QWORD *)(a1 + 16), v7, v8, v9, v10);\n      while ( fchmod(*(_DWORD *)(a1 + 52), 0x1E4u) == -1 )\n        sub_46B2B6((__int64)\"set mode of current\", *(_QWORD *)(a1 + 16), v11, v12, v13, v14);\n      fclose(*(FILE **)(a1 + 56));\n      *(_DWORD *)(a1 + 52) = -1;\n      result = *(unsigned int *)(a1 + 64);\n      if ( (_DWORD)result != -1 )\n      {\n        close(*(_DWORD *)(a1 + 64));\n        *(_DWORD *)(a1 + 64) = -1;\n        free(*(void **)(a1 + 8));\n        result = a1;\n        *(_QWORD *)(a1 + 8) = 0LL;\n      }\n    }\n  }\n  return result;\n}\n",
        "output": "static void closeFile(int fd, const char *filename)\n{\n    if (fd != -1)\n    {\n        if (verboseFlag)\n            bb_error_msg(\"info: close: %s\", filename);\n        close(fd);\n        fd = -1;\n        if (logFileFd != -1)\n        {\n            while (fflush(logFile) || fsync(logFileFd) == -1)\n                bb_error_msg_and_die(\"fsync current logfile\");\n            while (fchmod(logFileFd, 0644) == -1)\n                bb_error_msg_and_die(\"set mode of current\");\n            fclose(logFile);\n            logFileFd = -1;\n            if (statusFd != -1)\n            {\n                close(statusFd);\n                statusFd = -1;\n                free(statusFilename);\n                statusFilename = NULL;\n            }\n        }\n    }\n}",
        "source_code": "static void logdir_close(struct logdir *ld)\n{\n\tif (ld->fddir == -1)\n\t\treturn;\n\tif (verbose)\n\t\tbb_error_msg(INFO\"close: %s\", ld->name);\n\tclose(ld->fddir);\n\tld->fddir = -1;\n\tif (ld->fdcur == -1)\n\t\treturn; /* impossible */\n\twhile (fflush(ld->filecur) || fsync(ld->fdcur) == -1)\n\t\tpause2cannot(\"fsync current logfile\", ld->name);\n\twhile (fchmod(ld->fdcur, 0744) == -1)\n\t\tpause2cannot(\"set mode of current\", ld->name);\n\t////close(ld->fdcur);\n\tfclose(ld->filecur);\n\tld->fdcur = -1;\n\tif (ld->fdlock == -1)\n\t\treturn; /* impossible */\n\tclose(ld->fdlock);\n\tld->fdlock = -1;\n\tfree(ld->processor);\n\tld->processor = NULL;\n}",
        "parsed_output": "static void closeFile(int fd, const char *filename)\n{\n    if (fd != -1)\n    {\n        if (verboseFlag)\n            bb_error_msg(\"info: close: %s\", filename);\n        close(fd);\n        fd = -1;\n        if (logFileFd != -1)\n        {\n            while (fflush(logFile) || fsync(logFileFd) == -1)\n                bb_error_msg_and_die(\"fsync current logfile\");\n            while (fchmod(logFileFd, 0644) == -1)\n                bb_error_msg_and_die(\"set mode of current\");\n            fclose(logFile);\n            logFileFd = -1;\n            if (statusFd != -1)\n            {\n                close(statusFd);\n                statusFd = -1;\n                free(statusFilename);\n                statusFilename = NULL;\n            }\n        }\n    }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_46C370(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 result; // rax\n  __int64 v7; // rdx\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  __int64 v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  __int64 v14; // r9\n\n  result = *(unsigned int *)(a1 + 48);\n  if ( (_DWORD)result != -1 )\n  {\n    if ( *((_DWORD *)qword_75D408 + 2) )\n      sub_409747(\"info: close: %s\", *(_QWORD *)(a1 + 16), a3, a4, a5, a6);\n    close(*(_DWORD *)(a1 + 48));\n    *(_DWORD *)(a1 + 48) = -1;\n    result = *(unsigned int *)(a1 + 52);\n    if ( (_DWORD)result != -1 )\n    {\n      while ( fflush(*(FILE **)(a1 + 56)) || fsync(*(_DWORD *)(a1 + 52)) == -1 )\n        sub_46B2B6((__int64)\"fsync current logfile\", *(_QWORD *)(a1 + 16), v7, v8, v9, v10);\n      while ( fchmod(*(_DWORD *)(a1 + 52), 0x1E4u) == -1 )\n        sub_46B2B6((__int64)\"set mode of current\", *(_QWORD *)(a1 + 16), v11, v12, v13, v14);\n      fclose(*(FILE **)(a1 + 56));\n      *(_DWORD *)(a1 + 52) = -1;\n      result = *(unsigned int *)(a1 + 64);\n      if ( (_DWORD)result != -1 )\n      {\n        close(*(_DWORD *)(a1 + 64));\n        *(_DWORD *)(a1 + 64) = -1;\n        free(*(void **)(a1 + 8));\n        result = a1;\n        *(_QWORD *)(a1 + 8) = 0LL;\n      }\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl logdir_close(logdir *ld)\n{\n  if ( ld->fddir != -1 )\n  {\n    if ( LODWORD(ptr_to_globals->login) )\n      bb_error_msg(\"info: close: %s\", ld->name);\n    close(ld->fddir);\n    ld->fddir = -1;\n    if ( ld->fdcur != -1 )\n    {\n      while ( fflush(ld->filecur) || fsync(ld->fdcur) == -1 )\n        pause2cannot(\"fsync current logfile\", ld->name);\n      while ( fchmod(ld->fdcur, 0x1E4u) == -1 )\n        pause2cannot(\"set mode of current\", ld->name);\n      fclose(ld->filecur);\n      ld->fdcur = -1;\n      if ( ld->fdlock != -1 )\n      {\n        close(ld->fdlock);\n        ld->fdlock = -1;\n        free(ld->processor);\n        ld->processor = 0LL;\n      }\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.8479397296905518,
        "similarity_score_baseline_stripped": 0.5963568687438965,
        "similarity_score_baseline_debug": 0.9582878947257996
    },
    {
        "func_name": "change_units",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4806DD(int a1)\n{\n  _QWORD *v1; // rbx\n\n  if ( a1 || !*((_QWORD *)qword_75D408 + 14) )\n  {\n    if ( *((char **)qword_75D408 + 14) == \"(unknown)\" )\n      *((_QWORD *)qword_75D408 + 14) = 0LL;\n    v1 = qword_75D408;\n    v1[14] = sub_50BFFD(*((_QWORD *)qword_75D408 + 14));\n    if ( !*((_QWORD *)qword_75D408 + 14) )\n      *((_QWORD *)qword_75D408 + 14) = \"(unknown)\";\n  }\n  return *((_QWORD *)qword_75D408 + 14);\n}\n\n\n Revised code:\nstatic const char *get_cwd(int force)\n{\n\tif (force || G.cwd == NULL) {\n\t\t/* xrealloc_getcwd_or_warn(arg) calls free(arg),\n\t\t * we must not try to free(bb_msg_unknown) */\n\t\tif (G.cwd == bb_msg_unknown)\n\t\t\tG.cwd = NULL;\n\t\tG.cwd = xrealloc_getcwd_or_warn((char *)G.cwd);\n\t\tif (!G.cwd)\n\t\t\tG.cwd = bb_msg_unknown;\n\t}\n\treturn G.cwd;\n}\n\n## Example:\n\n Input code:\nvoid *sub_480FD8()\n{\n  _QWORD *v0; // rbx\n  _QWORD *v1; // rbx\n  void *result; // rax\n\n  v0 = qword_75D408;\n  v0[1] = sub_4807EA(\"PS1\");\n  if ( !*((_QWORD *)qword_75D408 + 1) )\n    *((_QWORD *)qword_75D408 + 1) = \"\\\\w \\\\$ \";\n  v1 = qword_75D408;\n  v1[2] = sub_4807EA(\"PS2\");\n  result = (void *)*((_QWORD *)qword_75D408 + 2);\n  if ( !result )\n  {\n    result = qword_75D408;\n    *((_QWORD *)qword_75D408 + 2) = \"> \";\n  }\n  return result;\n}\n\n\n Revised code:\nif ENABLE_HUSH_INTERACTIVE\n\nstatic void cmdedit_update_prompt(void)\n{\n\tif (ENABLE_FEATURE_EDITING_FANCY_PROMPT) {\n\t\tG.PS1 = get_local_var_value(\"PS1\");\n\t\tif (G.PS1 == NULL)\n\t\t\tG.PS1 = \"\\\\w \\\\$ \";\n\t\tG.PS2 = get_local_var_value(\"PS2\");\n\t} else {\n\t\tG.PS1 = NULL;\n\t}\n\tif (G.PS2 == NULL)\n\t\tG.PS2 = \"> \";\n}\n\n## Example:\n\n Input code:\nvoid sub_4A01E0()\n{\n  unsigned int v0; // eax\n\n  if ( *(_BYTE *)qword_75D408 )\n    v0 = *((_DWORD *)qword_75D408 + 282);\n  else\n    v0 = *((unsigned __int16 *)qword_75D408 + 555);\n  if ( v0 > *((_DWORD *)qword_75D408 + 20) )\n  {\n    signal(14, sub_4A01E0);\n    alarm(5u);\n    if ( *((_DWORD *)qword_75D408 + 20) )\n    {\n      printf(\"%d ...\", *((unsigned int *)qword_75D408 + 20));\n      sub_40A649();\n    }\n  }\n}\n\n\n Revised code:\nstatic void alarm_intr(int alnum UNUSED_PARAM)\n{\n\tif (G.currently_testing >= SB_ZONES)\n\t\treturn;\n\tsignal(SIGALRM, alarm_intr);\n\talarm(5);\n\tif (!G.currently_testing)\n\t\treturn;\n\tprintf(\"%d ...\", G.currently_testing);\n\tfflush_all();\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint sub_4922C0()\n{\n  const char *v0; // rax\n\n  *((_BYTE *)qword_75D408 + 49) = *((_BYTE *)qword_75D408 + 49) == 0;\n  sub_4911A0();\n  v0 = sub_4904DF(0);\n  return printf(\"Changing display/entry units to %s\\n\", v0);\n}\n",
        "output": "static void change_display_entry_units()\n{\n\tif (*((char *)qword_75D408 + 49) == 0)\n\t\t*((char *)qword_75D408 + 49) = 1;\n\telse\n\t\t*((char *)qword_75D408 + 49) = 0;\n\tsub_4911A0();\n\tconst char *units = sub_4904DF(0);\n\tprintf(\"Changing display/entry units to %s\\n\", units);\n}",
        "source_code": "static void\nchange_units(void)\n{\n\tdisplay_in_cyl_units = !display_in_cyl_units;\n\tupdate_units();\n\tprintf(\"Changing display/entry units to %s\\n\",\n\t\tstr_units(PLURAL));\n}",
        "parsed_output": "static void change_display_entry_units()\n{\n\tif (*((char *)qword_75D408 + 49) == 0)\n\t\t*((char *)qword_75D408 + 49) = 1;\n\telse\n\t\t*((char *)qword_75D408 + 49) = 0;\n\tsub_4911A0();\n\tconst char *units = sub_4904DF(0);\n\tprintf(\"Changing display/entry units to %s\\n\", units);\n}",
        "baseline_code_stripped": "int sub_4922C0()\n{\n  const char *v0; // rax\n\n  *((_BYTE *)qword_75D408 + 49) = *((_BYTE *)qword_75D408 + 49) == 0;\n  sub_4911A0();\n  v0 = sub_4904DF(0);\n  return printf(\"Changing display/entry units to %s\\n\", v0);\n}\n",
        "baseline_code_debug": "void __cdecl change_units()\n{\n  const char *v0; // rax\n\n  BYTE1(ptr_to_globals->numspeed) = BYTE1(ptr_to_globals->numspeed) == 0;\n  update_units();\n  v0 = str_units(0);\n  printf(\"Changing display/entry units to %s\\n\", v0);\n}\n",
        "similarity_score_unixcoder": 0.6590246558189392,
        "similarity_score_baseline_stripped": 0.49595174193382263,
        "similarity_score_baseline_debug": 0.6446467638015747
    },
    {
        "func_name": "identify_from_stdin",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 sub_4B357D()\n{\n  __int64 v0; // rdx\n  __int64 v1; // rcx\n  __int64 v2; // r8\n  __int64 v3; // r9\n  int s[3]; // [rsp+0h] [rbp-130h] BYREF\n  int v6; // [rsp+Ch] [rbp-124h]\n  char v7; // [rsp+28h] [rbp-108h]\n\n  memset(s, 0, 0x12CuLL);\n  sub_4B3517((__int64)s, 0LL, v0, v1, v2, v3);\n  s[0] = 4112;\n  s[2] = 2368;\n  s[1] = 8240;\n  v6 = 50331648;\n  if ( (dword_75D450 & 0x8000) == 0 || v7 == 3 )\n  {\n    v6 |= 1u;\n    if ( (dword_75D450 & 0x4000) != 0 )\n      v6 |= 2u;\n  }\n  sub_4B3148((__int64)s);\n  return sub_4B2A74((__int64)s, 0LL);\n}\n\n\n Revised code:\nstatic smallint do_lzo_compress(void)\n{\n\theader_t header;\n\n#define h (&header)\n\tmemset(h, 0, sizeof(*h));\n\n\tlzo_set_method(h);\n\n\th->version = (LZOP_VERSION & 0xffff);\n\th->version_needed_to_extract = 0x0940;\n\th->lib_version = lzo_version() & 0xffff;\n\n\th->flags = (F_OS & F_OS_MASK) | (F_CS & F_CS_MASK);\n\n\tif (!(option_mask32 & OPT_F) || h->method == M_LZO1X_999) {\n\t\th->flags |= F_ADLER32_D;\n\t\tif (option_mask32 & OPT_C)\n\t\t\th->flags |= F_ADLER32_C;\n\t}\n\twrite_header(h);\n\treturn lzo_compress(h);\n#undef h\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_460783(__int64 a1)\n{\n  const char *v1; // rbx\n  const char *v2; // rax\n  char v4; // al\n  char v5; // al\n  unsigned __int64 v6[4]; // [rsp+10h] [rbp-40h] BYREF\n  unsigned __int64 v7; // [rsp+30h] [rbp-20h]\n  int i; // [rsp+3Ch] [rbp-14h]\n\n  v1 = *(const char **)(a1 + 64);\n  v2 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 80);\n  if ( (unsigned int)sub_45FABF(v2, v1, v6, 1LL, 3LL, 9LL, 11LL) )\n    return (void *)sub_45F76C(0xAu);\n  for ( i = 0; i <= 3; ++i )\n  {\n    v7 = *(_QWORD *)(a1 + 8 * (i + 2LL) + 8);\n    if ( v7 > v6[i] )\n      v7 = v6[i];\n    *(_QWORD *)(a1 + 8 * (i + 2LL) + 8) = v6[i];\n    v6[i] -= v7;\n  }\n  if ( v6[1] )\n    v4 = 42;\n  else\n    v4 = 32;\n  sub_45F732(v4);\n  sub_45FE0E(v6[0]);\n  if ( v6[3] )\n    v5 = 42;\n  else\n    v5 = 32;\n  sub_45F732(v5);\n  return sub_45FE0E(v6[2]);\n}\n\n\n Revised code:\nstatic void FAST_FUNC collect_if(if_stat *s)\n{\n\tullong data[4];\n\tint i;\n\n\tif (rdval(get_file(&proc_net_dev), s->device_colon, data, 1, 3, 9, 11)) {\n\t\tput_question_marks(10);\n\t\treturn;\n\t}\n\n\tfor (i=0; i<4; i++) {\n\t\tullong old = s->old[i];\n\t\tif (data[i] < old) old = data[i];\t\t//sanitize\n\t\ts->old[i] = data[i];\n\t\tdata[i] -= old;\n\t}\n\tput_c(data[1] ? '*' : ' ');\n\tscale(data[0]);\n\tput_c(data[3] ? '*' : ' ');\n\tscale(data[2]);\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_4604C4(__int64 a1)\n{\n  const char *v1; // rax\n  const char *v2; // rbx\n  const char *v3; // rax\n  __int64 v4; // r9\n  unsigned __int64 v6; // [rsp+10h] [rbp-30h] BYREF\n  __int64 v7; // [rsp+18h] [rbp-28h]\n  unsigned __int64 v8; // [rsp+20h] [rbp-20h]\n  int i; // [rsp+2Ch] [rbp-14h]\n\n  if ( *((_BYTE *)qword_75D408 + 1) )\n  {\n    v1 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 112);\n    i = sub_45FC43(v1, &v6);\n  }\n  else\n  {\n    v2 = *(const char **)(a1 + 24);\n    v3 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 48);\n    i = sub_45FABF(v3, v2, &v6, 1LL, 2LL, v4);\n    v6 *= 2LL;\n    v7 *= 2LL;\n  }\n  if ( i )\n    return (void *)sub_45F76C(9u);\n  for ( i = 0; i <= 1; ++i )\n  {\n    v8 = *(_QWORD *)(a1 + 8 * (i + 4LL));\n    if ( v8 > *(&v6 + i) )\n      v8 = *(&v6 + i);\n    *(_QWORD *)(a1 + 8 * (i + 4LL)) = *(&v6 + i);\n    *(&v6 + i) -= v8;\n  }\n  sub_45FE0E(v6 << 9);\n  sub_45F732(32);\n  return sub_45FE0E(v7 << 9);\n}\n\n\n Revised code:\nstatic void FAST_FUNC collect_blk(blk_stat *s)\n{\n\tullong data[2];\n\tint i;\n\n\tif (is26) {\n\t\ti = rdval_diskstats(get_file(&proc_diskstats), data);\n\t} else {\n\t\ti = rdval(get_file(&proc_stat), s->lookfor, data, 1, 2);\n\t\t// Linux 2.4 reports bio in Kbytes, convert to sectors:\n\t\tdata[0] *= 2;\n\t\tdata[1] *= 2;\n\t}\n\tif (i) {\n\t\tput_question_marks(9);\n\t\treturn;\n\t}\n\n\tfor (i=0; i<2; i++) {\n\t\tullong old = s->old[i];\n\t\tif (data[i] < old) old = data[i];\t\t//sanitize\n\t\ts->old[i] = data[i];\n\t\tdata[i] -= old;\n\t}\n\tscale(data[0]*512); // TODO: *sectorsize\n\tput_c(' ');\n\tscale(data[1]*512);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __noreturn sub_41B887()\n{\n  __int64 v0; // rcx\n  __int64 v1; // r8\n  __int64 v2; // r9\n  __int16 v3; // bx\n  unsigned __int8 *v4; // rax\n  __int16 v5; // ax\n  char v6[1280]; // [rsp+0h] [rbp-720h] BYREF\n  unsigned __int16 v7[256]; // [rsp+500h] [rbp-220h] BYREF\n  int j; // [rsp+700h] [rbp-20h]\n  int i; // [rsp+704h] [rbp-1Ch]\n  char *v10; // [rsp+708h] [rbp-18h]\n\n  v10 = v6;\n  sub_507452(0LL, v6, 1280LL);\n  for ( i = 0; i <= 255; ++i )\n  {\n    for ( j = 0; j <= 3; ++j )\n    {\n      v3 = 16 * v7[i];\n      v4 = (unsigned __int8 *)v10++;\n      v5 = sub_41B836(*v4, (__int64)v6, (__int64)v10, v0, v1, v2);\n      v7[i] = v3 + v5;\n    }\n  }\n  sub_417DFD(v7, (__int64)v6);\n}\n",
        "output": "static void __noreturn process_data()\n{\n  char buffer[1280];\n  unsigned short table[256];\n  int j, i;\n  char *ptr = buffer;\n\n  initialize_buffer(0LL, buffer, 1280LL);\n\n  for (i = 0; i <= 255; ++i)\n  {\n    for (j = 0; j <= 3; ++j)\n    {\n      unsigned short value = 16 * table[i];\n      unsigned char *byte_ptr = (unsigned char *)ptr++;\n      unsigned short result = process_byte(*byte_ptr, (unsigned long long)buffer, (unsigned long long)ptr);\n      table[i] = value + result;\n    }\n  }\n\n  process_table(table, (unsigned long long)buffer);\n}",
        "source_code": "static void identify_from_stdin(void)\n{\n\tuint16_t sbuf[256];\n\tunsigned char buf[1280];\n\tunsigned char *b = (unsigned char *)buf;\n\tint i;\n\n\txread(STDIN_FILENO, buf, 1280);\n\n\t// Convert the newline-separated hex data into an identify block.\n\n\tfor (i = 0; i < 256; i++) {\n\t\tint j;\n\t\tfor (j = 0; j < 4; j++)\n\t\t\tsbuf[i] = (sbuf[i] << 4) + fromhex(*(b++));\n\t}\n\n\t// Parse the data.\n\n\tidentify(sbuf);\n}",
        "parsed_output": "static void __noreturn process_data()\n{\n  char buffer[1280];\n  unsigned short table[256];\n  int j, i;\n  char *ptr = buffer;\n\n  initialize_buffer(0LL, buffer, 1280LL);\n\n  for (i = 0; i <= 255; ++i)\n  {\n    for (j = 0; j <= 3; ++j)\n    {\n      unsigned short value = 16 * table[i];\n      unsigned char *byte_ptr = (unsigned char *)ptr++;\n      unsigned short result = process_byte(*byte_ptr, (unsigned long long)buffer, (unsigned long long)ptr);\n      table[i] = value + result;\n    }\n  }\n\n  process_table(table, (unsigned long long)buffer);\n}",
        "baseline_code_stripped": "void __noreturn sub_41B887()\n{\n  __int64 v0; // rcx\n  __int64 v1; // r8\n  __int64 v2; // r9\n  __int16 v3; // bx\n  unsigned __int8 *v4; // rax\n  __int16 v5; // ax\n  char v6[1280]; // [rsp+0h] [rbp-720h] BYREF\n  unsigned __int16 v7[256]; // [rsp+500h] [rbp-220h] BYREF\n  int j; // [rsp+700h] [rbp-20h]\n  int i; // [rsp+704h] [rbp-1Ch]\n  char *v10; // [rsp+708h] [rbp-18h]\n\n  v10 = v6;\n  sub_507452(0LL, v6, 1280LL);\n  for ( i = 0; i <= 255; ++i )\n  {\n    for ( j = 0; j <= 3; ++j )\n    {\n      v3 = 16 * v7[i];\n      v4 = (unsigned __int8 *)v10++;\n      v5 = sub_41B836(*v4, (__int64)v6, (__int64)v10, v0, v1, v2);\n      v7[i] = v3 + v5;\n    }\n  }\n  sub_417DFD(v7, (__int64)v6);\n}\n",
        "baseline_code_debug": "void __cdecl __noreturn identify_from_stdin()\n{\n  __int16 v0; // bx\n  unsigned __int8 *v1; // rax\n  __int16 v2; // ax\n  unsigned __int8 buf[1280]; // [rsp+0h] [rbp-720h] BYREF\n  uint16_t sbuf[256]; // [rsp+500h] [rbp-220h] BYREF\n  int j; // [rsp+700h] [rbp-20h]\n  int i; // [rsp+704h] [rbp-1Ch]\n  unsigned __int8 *b; // [rsp+708h] [rbp-18h]\n\n  b = buf;\n  xread(0, buf, 0x500uLL);\n  for ( i = 0; i <= 255; ++i )\n  {\n    for ( j = 0; j <= 3; ++j )\n    {\n      v0 = 16 * sbuf[i];\n      v1 = b++;\n      v2 = fromhex(*v1);\n      sbuf[i] = v0 + v2;\n    }\n  }\n  identify(sbuf);\n}\n",
        "similarity_score_unixcoder": 0.6622546911239624,
        "similarity_score_baseline_stripped": 0.510649561882019,
        "similarity_score_baseline_debug": 0.7752326726913452
    },
    {
        "func_name": "is_in_ino_dev_hashtable",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_QWORD *__fastcall sub_439CE0(__int64 a1)\n{\n  _QWORD *i; // [rsp+10h] [rbp-8h]\n\n  for ( i = (_QWORD *)*((_QWORD *)qword_75D408 + (unsigned int)a1 % 0xD3 + 1); i; i = (_QWORD *)*i )\n  {\n    if ( a1 == i[1] )\n      return i + 2;\n  }\n  return &unk_519F80;\n}\n\n\n Revised code:\nstatic const char *prg_cache_get(long inode)\n{\n\tunsigned hi = PRG_HASHIT(inode);\n\tstruct prg_node *pn;\n\n\tfor (pn = prg_hash[hi]; pn; pn = pn->next)\n\t\tif (pn->inode == inode)\n\t\t\treturn pn->name;\n\treturn \"-\";\n}\n\n## Example:\n\n Input code:\n__int64 *__fastcall sub_451D87(int a1)\n{\n  __int64 *i; // [rsp+Ch] [rbp-8h]\n\n  if ( qword_75B0E0 )\n  {\n    for ( i = *(__int64 **)(8LL * (a1 & 0xF) + qword_75B0E0); i; i = (__int64 *)*i )\n    {\n      if ( a1 == *((_DWORD *)i + 2) )\n        return i;\n    }\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic struct idxmap *find_by_index(int idx)\n{\n\tstruct idxmap *im;\n\n\tif (idxmap)\n\t\tfor (im = idxmap[idx & 0xF]; im; im = im->next)\n\t\t\tif (im->index == idx)\n\t\t\t\treturn im;\n\treturn NULL;\n}\n\n## Example:\n\n Input code:\n_BOOL8 __fastcall sub_4DAFDA(const char *a1, const char *a2)\n{\n  char *v3; // [rsp+10h] [rbp-10h]\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  if ( byte_75B27D )\n    return 0LL;\n  if ( qword_75B2A0 )\n  {\n    if ( !strncmp(*(const char **)(qword_75B2A0 + 24), \"/dev/md\", 7uLL) )\n      return 1LL;\n    a2 = \"/dev/md\";\n    if ( !strncmp(a1, \"/dev/md\", 7uLL) )\n      return 1LL;\n  }\n  v3 = sub_4DA65D(a1, (__int64)a2);\n  if ( !v3 )\n    return qword_75B2A0 != 0;\n  for ( i = qword_75B2A0; i; i = *(_QWORD *)i )\n  {\n    if ( !*(_QWORD *)(i + 32) || !strcmp(v3, *(const char **)(i + 32)) )\n    {\n      free(v3);\n      return 1LL;\n    }\n  }\n  free(v3);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int device_already_active(char *device)\n{\n\tstruct fsck_instance *inst;\n\tchar *base;\n\n\tif (force_all_parallel)\n\t\treturn 0;\n\n#ifdef BASE_MD\n\t/* Don't check a soft raid disk with any other disk */\n\tif (instance_list\n\t && (!strncmp(instance_list->device, BASE_MD, sizeof(BASE_MD)-1)\n\t     || !strncmp(device, BASE_MD, sizeof(BASE_MD)-1))\n\t) {\n\t\treturn 1;\n\t}\n#endif\n\n\tbase = base_device(device);\n\t/*\n\t * If we don't know the base device, assume that the device is\n\t * already active if there are any fsck instances running.\n\t */\n\tif (!base)\n\t\treturn (instance_list != NULL);\n\n\tfor (inst = instance_list; inst; inst = inst->next) {\n\t\tif (!inst->base_device || !strcmp(base, inst->base_device)) {\n\t\t\tfree(base);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfree(base);\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_QWORD *__fastcall sub_4FDC1B(_QWORD *a1)\n{\n  _QWORD *i; // [rsp+10h] [rbp-8h]\n\n  if ( !qword_75B2D0 )\n    return 0LL;\n  for ( i = (_QWORD *)*((_QWORD *)qword_75B2D0 + a1[1] % 0x137uLL); i; i = (_QWORD *)*i )\n  {\n    if ( i[1] == a1[1] && i[2] == *a1 )\n      return i + 3;\n  }\n  return 0LL;\n}\n",
        "output": "static _QWORD *find_match(_QWORD *input)\n{\n\t_QWORD *i;\n\n\tif (!qword_75B2D0)\n\t\treturn NULL;\n\n\tfor (i = (_QWORD *)*((_QWORD *)qword_75B2D0 + input[1] % 0x137uLL); i; i = (_QWORD *)*i)\n\t{\n\t\tif (i[1] == input[1] && i[2] == *input)\n\t\t\treturn i + 3;\n\t}\n\n\treturn NULL;\n}",
        "source_code": "FAST_FUNC is_in_ino_dev_hashtable(const struct stat *statbuf)\n{\n\tino_dev_hashtable_bucket_t *bucket;\n\n\tif (!ino_dev_hashtable)\n\t\treturn NULL;\n\n\tbucket = ino_dev_hashtable[hash_inode(statbuf->st_ino)];\n\twhile (bucket != NULL) {\n\t\tif ((bucket->ino == statbuf->st_ino)\n\t\t && (bucket->dev == statbuf->st_dev)\n\t\t) {\n\t\t\treturn bucket->name;\n\t\t}\n\t\tbucket = bucket->next;\n\t}\n\treturn NULL;\n}",
        "parsed_output": "static _QWORD *find_match(_QWORD *input)\n{\n\t_QWORD *i;\n\n\tif (!qword_75B2D0)\n\t\treturn NULL;\n\n\tfor (i = (_QWORD *)*((_QWORD *)qword_75B2D0 + input[1] % 0x137uLL); i; i = (_QWORD *)*i)\n\t{\n\t\tif (i[1] == input[1] && i[2] == *input)\n\t\t\treturn i + 3;\n\t}\n\n\treturn NULL;\n}",
        "baseline_code_stripped": "_QWORD *__fastcall sub_4FDC1B(_QWORD *a1)\n{\n  _QWORD *i; // [rsp+10h] [rbp-8h]\n\n  if ( !qword_75B2D0 )\n    return 0LL;\n  for ( i = (_QWORD *)*((_QWORD *)qword_75B2D0 + a1[1] % 0x137uLL); i; i = (_QWORD *)*i )\n  {\n    if ( i[1] == a1[1] && i[2] == *a1 )\n      return i + 3;\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "char *__cdecl is_in_ino_dev_hashtable(const stat *statbuf)\n{\n  ino_dev_hashtable_bucket_t *bucket; // [rsp+10h] [rbp-8h]\n\n  if ( !ino_dev_hashtable )\n    return 0LL;\n  for ( bucket = ino_dev_hashtable[statbuf->st_ino % 0x137]; bucket; bucket = bucket->next )\n  {\n    if ( bucket->ino == statbuf->st_ino && bucket->dev == statbuf->st_dev )\n      return bucket->name;\n  }\n  return 0LL;\n}\n",
        "similarity_score_unixcoder": 0.5093370676040649,
        "similarity_score_baseline_stripped": 0.45711764693260193,
        "similarity_score_baseline_debug": 0.8922622799873352
    },
    {
        "func_name": "bb_BLKGETSIZE_sectors",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A558D(unsigned int a1, _QWORD *a2, void **a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  void *v7; // rax\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  __int64 v13; // [rsp+28h] [rbp-18h] BYREF\n  __int64 v14; // [rsp+30h] [rbp-10h]\n  unsigned int v15; // [rsp+3Ch] [rbp-4h]\n\n  v15 = 1;\n  v14 = sub_4A5BC2(a1);\n  if ( ioctl(a1, 0x80081272uLL, &v13) )\n    v13 = 0LL;\n  if ( !(unsigned int)sub_4A5A83(v14, v13) && (*(_BYTE *)(v14 + 48) || *(_BYTE *)(v14 + 113)) )\n  {\n    v7 = sub_40A165((_BYTE *)(v14 + 48), 65LL, v3, v4, v5, v6);\n    *a2 = v7;\n    *a3 = sub_40A165((_BYTE *)(v14 + 113), 37LL, (__int64)v7, v8, v9, v10);\n    v15 = 0;\n  }\n  sub_4A5BEA(v14);\n  return v15;\n}\n\n\n Revised code:\nstatic int\nget_label_uuid(int fd, char **label, char **uuid, const char **type)\n{\n\tint rv = 1;\n\tuint64_t size;\n\tstruct volume_id *vid;\n\n\t/* fd is owned by vid now */\n\tvid = volume_id_open_node(fd);\n\n\tif (ioctl(/*vid->*/fd, BLKGETSIZE64, &size) != 0)\n\t\tsize = 0;\n\n\tif (volume_id_probe_all(vid, /*0,*/ size) != 0)\n\t\tgoto ret;\n\n\tif (vid->label[0] != '\\0' || vid->uuid[0] != '\\0'\n#if ENABLE_FEATURE_BLKID_TYPE\n\t || vid->type != NULL\n#endif\n\t) {\n\t\t*label = xstrndup(vid->label, sizeof(vid->label));\n\t\t*uuid  = xstrndup(vid->uuid, sizeof(vid->uuid));\n#if ENABLE_FEATURE_BLKID_TYPE\n\t\t*type = vid->type;\n\t\tdbg(\"found label '%s', uuid '%s', type '%s'\", *label, *uuid, *type);\n#else\n\t\tdbg(\"found label '%s', uuid '%s'\", *label, *uuid);\n#endif\n\t\trv = 0;\n\t}\n ret:\n\tfree_volume_id(vid); /* also closes fd */\n\treturn rv;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48EF6A(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v7; // eax\n  __int64 *v9; // [rsp+0h] [rbp-30h]\n  __int64 *v10; // [rsp+0h] [rbp-30h]\n  unsigned __int64 v11; // [rsp+10h] [rbp-20h] BYREF\n  int fd; // [rsp+1Ch] [rbp-14h]\n  const char *v13; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v14; // [rsp+28h] [rbp-8h]\n\n  v9 = (__int64 *)(a2 + 8);\n  if ( !*(_QWORD *)(a2 + 8) || !*(_QWORD *)(a2 + 16) )\n    sub_407F64();\n  v13 = sub_48EEFF(*v9);\n  v14 = v13[15];\n  if ( (v13[14] & 4) != 0 )\n  {\n    v9 = (__int64 *)(a2 + 16);\n    v14 = (int)sub_50B306(*(_QWORD *)(a2 + 16));\n  }\n  v10 = v9 + 1;\n  if ( !*v10 || v10[1] )\n    sub_407F64();\n  fd = sub_40A295((const char *)*v10, 0);\n  v11 = v14;\n  v2 = *(unsigned int *)v13;\n  if ( ioctl(fd, v2, &v11) == -1 )\n    sub_409392(*v10, v2, v3, v4, v5, v6);\n  v14 = v11;\n  if ( (v13[14] & 0x10) != 0 )\n    v14 >>= 9;\n  v7 = v13[14] & 0xB;\n  if ( v7 == 2 || v7 == 3 )\n  {\n    printf(\"%llu\\n\", v14);\n  }\n  else if ( v7 == 1 )\n  {\n    printf(\"%lld\\n\", (int)v14);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nint blockdev_main(int argc UNUSED_PARAM, char **argv)\n{\n\tconst struct bdc *bdcmd;\n\tint fd;\n\tuint64_t u64;\n\tunion {\n\t\tint i;\n\t\tunsigned long lu;\n\t\tuint64_t u64;\n\t} ioctl_val_on_stack;\n\n\targv++;\n\tif (!argv[0] || !argv[1]) /* must have at least 2 args */\n\t\tbb_show_usage();\n\n\tbdcmd = find_cmd(*argv);\n\n\tu64 = (int)bdcmd->argval;\n\tif (bdcmd->flags & FL_USRARG)\n\t\tu64 = xatoi_positive(*++argv);\n\n\targv++;\n\tif (!argv[0] || argv[1])\n\t\tbb_show_usage();\n\tfd = xopen(argv[0], O_RDONLY);\n\n\tioctl_val_on_stack.u64 = u64;\n#if BB_BIG_ENDIAN\n\t/* Store data properly wrt data size.\n\t * (1) It's no-op for little-endian.\n\t * (2) it's no-op for 0 and -1. Only --setro uses arg != 0 and != -1,\n\t * and it is ARG_INT. --setbsz USER_VAL is also ARG_INT.\n\t * Thus, we don't need to handle ARG_ULONG.\n\t */\n\tswitch (bdcmd->flags & ARG_MASK) {\n\tcase ARG_INT:\n\t\tioctl_val_on_stack.i = (int)u64;\n\t\tbreak;\n# if 0 /* unused */\n\tcase ARG_ULONG:\n\t\tioctl_val_on_stack.lu = (unsigned long)u64;\n\t\tbreak;\n# endif\n\t}\n#endif\n\n\tif (ioctl(fd, bdcmd->ioc, &ioctl_val_on_stack.u64) == -1)\n\t\tbb_simple_perror_msg_and_die(*argv);\n\n\t/* Fetch it into register(s) */\n\tu64 = ioctl_val_on_stack.u64;\n\n\tif (bdcmd->flags & FL_SCALE512)\n\t\tu64 >>= 9;\n\n\t/* Zero- or one-extend the value if needed, then print */\n\tswitch (bdcmd->flags & (ARG_MASK+FL_NORESULT)) {\n\tcase ARG_INT:\n\t\t/* Smaller code when we use long long\n\t\t * (gcc tail-merges printf call)\n\t\t */\n\t\tprintf(\"%lld\\n\", (long long)(int)u64);\n\t\tbreak;\n\tcase ARG_ULONG:\n\t\tu64 = (unsigned long)u64;\n\t\t/* FALLTHROUGH */\n\tcase ARG_U64:\n\t\tprintf(\"%llu\\n\", (unsigned long long)u64);\n\t\tbreak;\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tclose(fd);\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A586D(const char *a1)\n{\n  void *v2; // r12\n  __int64 v3; // rbx\n  char *v4; // rax\n  __int64 v5; // [rsp+18h] [rbp-28h] BYREF\n  void *v6; // [rsp+20h] [rbp-20h] BYREF\n  int v7; // [rsp+2Ch] [rbp-14h]\n\n  v7 = open64(a1, 0);\n  if ( v7 < 0 )\n    return 0LL;\n  if ( (unsigned int)sub_4A558D(v7, &v5, &v6) )\n    return 0LL;\n  v2 = v6;\n  v3 = v5;\n  v4 = sub_40A11F(a1, (__int64)&v5);\n  sub_4A5664(v4, v3, v2);\n  return 1LL;\n}\n\n\n Revised code:\nint add_to_uuid_cache(const char *device)\n{\n\tchar *uuid = uuid; /* for compiler */\n\tchar *label = label;\n#if ENABLE_FEATURE_BLKID_TYPE\n\tconst char *type = type;\n#endif\n\tint fd;\n\n\tfd = open(device, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\t/* get_label_uuid() closes fd in all cases (success & failure) */\n\tif (get_label_uuid(fd, &label, &uuid, &type) == 0) {\n\t\t/* uuidcache_addentry() takes ownership of all four params */\n\t\tuuidcache_addentry(xstrdup(device), /*ma, mi,*/ label, uuid, type);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4902A5(int a1)\n{\n  __int64 v1; // rsi\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  __int64 v5; // rdx\n  unsigned __int64 v7; // [rsp+18h] [rbp-18h] BYREF\n  unsigned __int64 v8; // [rsp+20h] [rbp-10h] BYREF\n  __off64_t v9; // [rsp+28h] [rbp-8h]\n\n  v1 = 2148012658LL;\n  if ( !ioctl(a1, 0x80081272uLL, &v8) )\n  {\n    v8 >>= 9;\n    v5 = (unsigned int)v8;\n    if ( (unsigned int)v8 == v8 )\n      return v8;\nLABEL_3:\n    sub_409747(\"device has more than 2^32 sectors, can't use all of them\", v1, v5, v2, v3, v4);\n    return 0xFFFFFFFFLL;\n  }\n  v1 = 4704LL;\n  if ( ioctl(a1, 0x1260uLL, &v7) )\n  {\n    v9 = lseek64(a1, 0LL, 2);\n    v7 = 0LL;\n    if ( v9 > 0 )\n      v7 = v9 / (unsigned __int64)*((unsigned int *)qword_75D408 + 6);\n    v1 = 0LL;\n    lseek64(a1, 0LL, 0);\n  }\n  v5 = (unsigned int)v7;\n  if ( (unsigned int)v7 != v7 )\n    goto LABEL_3;\n  return v7;\n}\n",
        "output": "int get_device_sectors(int fd)\n{\n    uint64_t sectors;\n    uint64_t ioctl_val;\n\n    ioctl_val = 2148012658;\n    if (!ioctl(fd, 0x80081272, &ioctl_val))\n    {\n        ioctl_val >>= 9;\n        sectors = (unsigned int)ioctl_val;\n        if ((unsigned int)ioctl_val == ioctl_val)\n            return ioctl_val;\n        else\n        {\n            sub_409747(\"device has more than 2^32 sectors, can't use all of them\", sectors, ioctl_val, 0, 0, 0);\n            return -1;\n        }\n    }\n    else\n    {\n        ioctl_val = 4704;\n        if (ioctl(fd, 0x1260, &sectors))\n        {\n            off64_t offset = lseek64(fd, 0, SEEK_END);\n            sectors = 0;\n            if (offset > 0)\n                sectors = offset / *((unsigned int *)qword_75D408 + 6);\n            lseek64(fd, 0, SEEK_SET);\n        }\n        if ((unsigned int)sectors != sectors)\n            goto LABEL_3;\n        return sectors;\n    }\n}",
        "source_code": "static sector_t bb_BLKGETSIZE_sectors(int fd)\n{\n\tuint64_t v64;\n\tunsigned long longsectors;\n\n\tif (ioctl(fd, BLKGETSIZE64, &v64) == 0) {\n\t\t/* Got bytes, convert to 512 byte sectors */\n\t\tv64 >>= 9;\n\t\tif (v64 != (sector_t)v64) {\n ret_trunc:\n\t\t\t/* Not only DOS, but all other partition tables\n\t\t\t * we support can't record more than 32 bit\n\t\t\t * sector counts or offsets\n\t\t\t */\n\t\t\tbb_error_msg(\"device has more than 2^32 sectors, can't use all of them\");\n\t\t\tv64 = (uint32_t)-1L;\n\t\t}\n\t\treturn v64;\n\t}\n\t/* Needs temp of type long */\n\tif (ioctl(fd, BLKGETSIZE, &longsectors)) {\n\t\t/* Perhaps this is a disk image */\n\t\toff_t sz = lseek(fd, 0, SEEK_END);\n\t\tlongsectors = 0;\n\t\tif (sz > 0)\n\t\t\tlongsectors = (uoff_t)sz / sector_size;\n\t\tlseek(fd, 0, SEEK_SET);\n\t}\n\tif (sizeof(long) > sizeof(sector_t)\n\t && longsectors != (sector_t)longsectors\n\t) {\n\t\tgoto ret_trunc;\n\t}\n\treturn longsectors;\n}",
        "parsed_output": "int get_device_sectors(int fd)\n{\n    uint64_t sectors;\n    uint64_t ioctl_val;\n\n    ioctl_val = 2148012658;\n    if (!ioctl(fd, 0x80081272, &ioctl_val))\n    {\n        ioctl_val >>= 9;\n        sectors = (unsigned int)ioctl_val;\n        if ((unsigned int)ioctl_val == ioctl_val)\n            return ioctl_val;\n        else\n        {\n            sub_409747(\"device has more than 2^32 sectors, can't use all of them\", sectors, ioctl_val, 0, 0, 0);\n            return -1;\n        }\n    }\n    else\n    {\n        ioctl_val = 4704;\n        if (ioctl(fd, 0x1260, &sectors))\n        {\n            off64_t offset = lseek64(fd, 0, SEEK_END);\n            sectors = 0;\n            if (offset > 0)\n                sectors = offset / *((unsigned int *)qword_75D408 + 6);\n            lseek64(fd, 0, SEEK_SET);\n        }\n        if ((unsigned int)sectors != sectors)\n            goto LABEL_3;\n        return sectors;\n    }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4902A5(int a1)\n{\n  __int64 v1; // rsi\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  __int64 v5; // rdx\n  unsigned __int64 v7; // [rsp+18h] [rbp-18h] BYREF\n  unsigned __int64 v8; // [rsp+20h] [rbp-10h] BYREF\n  __off64_t v9; // [rsp+28h] [rbp-8h]\n\n  v1 = 2148012658LL;\n  if ( !ioctl(a1, 0x80081272uLL, &v8) )\n  {\n    v8 >>= 9;\n    v5 = (unsigned int)v8;\n    if ( (unsigned int)v8 == v8 )\n      return v8;\nLABEL_3:\n    sub_409747(\"device has more than 2^32 sectors, can't use all of them\", v1, v5, v2, v3, v4);\n    return 0xFFFFFFFFLL;\n  }\n  v1 = 4704LL;\n  if ( ioctl(a1, 0x1260uLL, &v7) )\n  {\n    v9 = lseek64(a1, 0LL, 2);\n    v7 = 0LL;\n    if ( v9 > 0 )\n      v7 = v9 / (unsigned __int64)*((unsigned int *)qword_75D408 + 6);\n    v1 = 0LL;\n    lseek64(a1, 0LL, 0);\n  }\n  v5 = (unsigned int)v7;\n  if ( (unsigned int)v7 != v7 )\n    goto LABEL_3;\n  return v7;\n}\n",
        "baseline_code_debug": "sector_t __cdecl bb_BLKGETSIZE_sectors(int fd)\n{\n  unsigned __int64 longsectors; // [rsp+18h] [rbp-18h] BYREF\n  uint64_t v64; // [rsp+20h] [rbp-10h] BYREF\n  off_t sz; // [rsp+28h] [rbp-8h]\n\n  if ( !ioctl(fd, 0x80081272uLL, &v64) )\n  {\n    v64 >>= 9;\n    if ( (unsigned int)v64 == v64 )\n      return v64;\nret_trunc:\n    bb_error_msg(\"device has more than 2^32 sectors, can't use all of them\");\n    return 0xFFFFFFFFLL;\n  }\n  if ( ioctl(fd, 0x1260uLL, &longsectors) )\n  {\n    sz = lseek64(fd, 0LL, 2);\n    longsectors = 0LL;\n    if ( sz > 0 )\n      longsectors = sz / (unsigned __int64)LODWORD(ptr_to_globals->tty_name);\n    lseek64(fd, 0LL, 0);\n  }\n  if ( (unsigned int)longsectors != longsectors )\n    goto ret_trunc;\n  return longsectors;\n}\n",
        "similarity_score_unixcoder": 0.7949185967445374,
        "similarity_score_baseline_stripped": 0.6639569401741028,
        "similarity_score_baseline_debug": 0.8839086294174194
    },
    {
        "func_name": "inflate_stored",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4BF3A4(__int64 a1, __int64 a2)\n{\n  int v3; // eax\n  unsigned int v4; // [rsp+1Ch] [rbp-4h]\n\n  do\n  {\n    v4 = sub_4BF007(a1, *(_QWORD *)a2, (unsigned __int64 *)(a2 + 8), *(_QWORD *)(a2 + 16));\n    if ( v4 != 1 )\n    {\n      sub_4BF329(a1, (_QWORD *)a2);\n      return v4;\n    }\n    v3 = *(_DWORD *)(a1 + 120);\n    if ( v3 == 1 )\n    {\n      *(_QWORD *)(a1 + 144) += *(_QWORD *)(a1 + 8);\n      *(_DWORD *)(a1 + 120) = 2;\n    }\n    else if ( v3 )\n    {\n      if ( v3 == 2 )\n      {\n        *(_QWORD *)(a1 + 152) += *(_QWORD *)(a1 + 8);\n        *(_DWORD *)(a1 + 160) = sub_4BBFB7(a1 + 144, 0x18u, *(_DWORD *)(a1 + 160));\n        --*(_QWORD *)(a1 + 136);\n        *(_DWORD *)(a1 + 120) = 1;\n      }\n    }\n    else\n    {\n      *(_QWORD *)(a1 + 136) = *(_QWORD *)(a1 + 8);\n      if ( *(_QWORD *)(a1 + 136) != *(_QWORD *)(a1 + 88) )\n        return 7LL;\n      *(_DWORD *)(a1 + 120) = 1;\n    }\n  }\n  while ( *(_QWORD *)(a1 + 136) );\n  return 1LL;\n}\n\n\n Revised code:\nstatic enum xz_ret XZ_FUNC dec_index(struct xz_dec *s, struct xz_buf *b)\n{\n\tenum xz_ret ret;\n\n\tdo {\n\t\tret = dec_vli(s, b->in, &b->in_pos, b->in_size);\n\t\tif (ret != XZ_STREAM_END) {\n\t\t\tindex_update(s, b);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch (s->index.sequence) {\n\t\tcase SEQ_INDEX_COUNT:\n\t\t\ts->index.count = s->vli;\n\n\t\t\t/*\n\t\t\t * Validate that the Number of Records field\n\t\t\t * indicates the same number of Records as\n\t\t\t * there were Blocks in the Stream.\n\t\t\t */\n\t\t\tif (s->index.count != s->block.count)\n\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\ts->index.sequence = SEQ_INDEX_UNPADDED;\n\t\t\tbreak;\n\n\t\tcase SEQ_INDEX_UNPADDED:\n\t\t\ts->index.hash.unpadded += s->vli;\n\t\t\ts->index.sequence = SEQ_INDEX_UNCOMPRESSED;\n\t\t\tbreak;\n\n\t\tcase SEQ_INDEX_UNCOMPRESSED:\n\t\t\ts->index.hash.uncompressed += s->vli;\n\t\t\ts->index.hash.crc32 = xz_crc32(\n\t\t\t\t\t(const uint8_t *)&s->index.hash,\n\t\t\t\t\tsizeof(s->index.hash),\n\t\t\t\t\ts->index.hash.crc32);\n\t\t\t--s->index.count;\n\t\t\ts->index.sequence = SEQ_INDEX_UNPADDED;\n\t\t\tbreak;\n\t\t}\n\t} while (s->index.count > 0);\n\n\treturn XZ_STREAM_END;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4BA779(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rsi\n  unsigned int v4; // eax\n  __int64 v6; // [rsp+14h] [rbp-Ch]\n  int v7; // [rsp+1Ch] [rbp-4h]\n\n  *(_DWORD *)(a1 + 68) -= *(_DWORD *)(a1 + 64);\n  memmove(\n    *(void **)(a1 + 48),\n    (const void *)(*(_QWORD *)(a1 + 48) + *(unsigned int *)(a1 + 64)),\n    *(unsigned int *)(a1 + 68));\n  *(_DWORD *)(a1 + 64) = 0;\n  if ( !sub_4BA61D(a1, 8) )\n    return 0LL;\n  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + *(unsigned int *)(a1 + 64));\n  *(_DWORD *)(a1 + 64) += 8;\n  if ( (_BYTE)v6 != 8 )\n    return 0LL;\n  if ( (v6 & 0x400) != 0 )\n  {\n    if ( !sub_4BA61D(a1, 2) )\n      return 0LL;\n    v7 = (unsigned __int16)sub_4BA708(a1);\n    if ( !sub_4BA61D(a1, v7) )\n      return 0LL;\n    *(_DWORD *)(a1 + 64) += v7;\n  }\n  if ( (v6 & 0x1800) != 0 )\n  {\n    while ( sub_4BA61D(a1, 1) )\n    {\n      v3 = *(_QWORD *)(a1 + 48);\n      v4 = *(_DWORD *)(a1 + 64);\n      *(_DWORD *)(a1 + 64) = v4 + 1;\n      if ( !*(_BYTE *)(v3 + v4) )\n      {\n        if ( (BYTE1(v6) & 0x18) != 24 )\n          goto LABEL_17;\n        BYTE1(v6) &= 0xE7u;\n      }\n    }\n    return 0LL;\n  }\n  else\n  {\nLABEL_17:\n    if ( a2 )\n      *(_QWORD *)(a2 + 32) = *(unsigned int *)((char *)&v6 + 2);\n    if ( (v6 & 0x200) != 0 )\n    {\n      if ( !sub_4BA61D(a1, 2) )\n        return 0LL;\n      *(_DWORD *)(a1 + 64) += 2;\n    }\n    return 1LL;\n  }\n}\n\n\n Revised code:\nstatic int check_header_gzip(STATE_PARAM transformer_aux_data_t *aux)\n{\n\tunion {\n\t\tunsigned char raw[8];\n\t\tstruct {\n\t\t\tuint8_t gz_method;\n\t\t\tuint8_t flags;\n\t\t\tuint32_t mtime;\n\t\t\tuint8_t xtra_flags_UNUSED;\n\t\t\tuint8_t os_flags_UNUSED;\n\t\t} PACKED formatted;\n\t} header;\n\tstruct BUG_header {\n\t\tchar BUG_header[sizeof(header) == 8 ? 1 : -1];\n\t};\n\n\t/*\n\t * Rewind bytebuffer. We use the beginning because the header has 8\n\t * bytes, leaving enough for unwinding afterwards.\n\t */\n\tbytebuffer_size -= bytebuffer_offset;\n\tmemmove(bytebuffer, &bytebuffer[bytebuffer_offset], bytebuffer_size);\n\tbytebuffer_offset = 0;\n\n\tif (!top_up(PASS_STATE 8))\n\t\treturn 0;\n\tmemcpy(header.raw, &bytebuffer[bytebuffer_offset], 8);\n\tbytebuffer_offset += 8;\n\n\t/* Check the compression method */\n\tif (header.formatted.gz_method != 8) {\n\t\treturn 0;\n\t}\n\n\tif (header.formatted.flags & 0x04) {\n\t\t/* bit 2 set: extra field present */\n\t\tunsigned extra_short;\n\n\t\tif (!top_up(PASS_STATE 2))\n\t\t\treturn 0;\n\t\textra_short = buffer_read_le_u16(PASS_STATE_ONLY);\n\t\tif (!top_up(PASS_STATE extra_short))\n\t\t\treturn 0;\n\t\t/* Ignore extra field */\n\t\tbytebuffer_offset += extra_short;\n\t}\n\n\t/* Discard original name and file comment if any */\n\t/* bit 3 set: original file name present */\n\t/* bit 4 set: file comment present */\n\tif (header.formatted.flags & 0x18) {\n\t\twhile (1) {\n\t\t\tdo {\n\t\t\t\tif (!top_up(PASS_STATE 1))\n\t\t\t\t\treturn 0;\n\t\t\t} while (bytebuffer[bytebuffer_offset++] != 0);\n\t\t\tif ((header.formatted.flags & 0x18) != 0x18)\n\t\t\t\tbreak;\n\t\t\theader.formatted.flags &= ~0x18;\n\t\t}\n\t}\n\n\tif (aux)\n\t\taux->mtime = SWAP_LE32(header.formatted.mtime);\n\n\t/* Read the header checksum */\n\tif (header.formatted.flags & 0x02) {\n\t\tif (!top_up(PASS_STATE 2))\n\t\t\treturn 0;\n\t\tbytebuffer_offset += 2;\n\t}\n\treturn 1;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4BF520(__int64 a1, __int64 *a2)\n{\n  int v3; // esi\n  __int64 v4; // rdi\n  __int64 v5; // rax\n\n  do\n  {\n    if ( a2[1] == a2[2] )\n      return 0LL;\n    v3 = (unsigned __int8)(*(_DWORD *)(a1 + 32) >> *(_DWORD *)(a1 + 4));\n    v4 = *a2;\n    v5 = a2[1];\n    a2[1] = v5 + 1;\n    if ( v3 != *(unsigned __int8 *)(v4 + v5) )\n      return 7LL;\n    *(_DWORD *)(a1 + 4) += 8;\n  }\n  while ( *(_DWORD *)(a1 + 4) <= 0x1Fu );\n  *(_DWORD *)(a1 + 32) = 0;\n  *(_DWORD *)(a1 + 4) = 0;\n  return 1LL;\n}\n\n\n Revised code:\nstatic enum xz_ret XZ_FUNC crc32_validate(struct xz_dec *s, struct xz_buf *b)\n{\n\tdo {\n\t\tif (b->in_pos == b->in_size)\n\t\t\treturn XZ_OK;\n\n\t\tif (((s->crc32 >> s->pos) & 0xFF) != b->in[b->in_pos++])\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\ts->pos += 8;\n\n\t} while (s->pos < 32);\n\n\ts->crc32 = 0;\n\ts->pos = 0;\n\n\treturn XZ_STREAM_END;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4B97F0(__int64 a1)\n{\n  int v1; // edi\n  __int64 v2; // rsi\n  unsigned int v3; // eax\n  int v5; // eax\n\n  while ( 1 )\n  {\n    v5 = *(_DWORD *)(a1 + 132);\n    *(_DWORD *)(a1 + 132) = v5 - 1;\n    if ( !v5 )\n      break;\n    *(_DWORD *)(a1 + 136) = sub_4B88A3(a1, *(_DWORD *)(a1 + 136), (unsigned int *)(a1 + 140), 8u);\n    v1 = *(_DWORD *)(a1 + 136);\n    v2 = *(_QWORD *)(a1 + 24);\n    v3 = *(_DWORD *)(a1 + 144);\n    *(_DWORD *)(a1 + 144) = v3 + 1;\n    *(_BYTE *)(v2 + v3) = v1;\n    if ( *(_DWORD *)(a1 + 144) == 0x8000 )\n    {\n      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 144);\n      *(_DWORD *)(a1 + 144) = 0;\n      *(_DWORD *)(a1 + 136) >>= 8;\n      *(_DWORD *)(a1 + 140) -= 8;\n      return 1LL;\n    }\n    *(_DWORD *)(a1 + 136) >>= 8;\n    *(_DWORD *)(a1 + 140) -= 8;\n  }\n  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 144);\n  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);\n  *(_BYTE *)(a1 + 44) = *(_DWORD *)(a1 + 140);\n  return 0LL;\n}\n",
        "output": "static int process_data(STATE_PARAM transformer_aux_data_t *aux)\n{\n\tint v1;\n\tunsigned int v3;\n\n\twhile (1) {\n\t\tv1 = aux->count;\n\t\taux->count = v1 - 1;\n\t\tif (!v1)\n\t\t\tbreak;\n\n\t\taux->data = sub_4B88A3(aux->data, aux->buffer, &aux->buffer_size, 8);\n\t\tv3 = aux->data;\n\t\taux->data = v3 + 1;\n\t\taux->output[aux->output_size] = v3;\n\n\t\tif (aux->output_size == 0x8000) {\n\t\t\taux->input_size = aux->output_size;\n\t\t\taux->output_size = 0;\n\t\t\taux->data >>= 8;\n\t\t\taux->buffer_size -= 8;\n\t\t\treturn 1;\n\t\t}\n\n\t\taux->data >>= 8;\n\t\taux->buffer_size -= 8;\n\t}\n\n\taux->input_size = aux->output_size;\n\taux->input_data = aux->data;\n\taux->input_buffer_size = aux->buffer_size;\n\n\treturn 0;\n}",
        "source_code": "static int inflate_stored(STATE_PARAM_ONLY)\n{\n\t/* read and output the compressed data */\n\twhile (inflate_stored_n--) {\n\t\tinflate_stored_b = fill_bitbuffer(PASS_STATE inflate_stored_b, &inflate_stored_k, 8);\n\t\tgunzip_window[inflate_stored_w++] = (unsigned char) inflate_stored_b;\n\t\tif (inflate_stored_w == GUNZIP_WSIZE) {\n\t\t\tgunzip_outbuf_count = inflate_stored_w;\n\t\t\t//flush_gunzip_window();\n\t\t\tinflate_stored_w = 0;\n\t\t\tinflate_stored_b >>= 8;\n\t\t\tinflate_stored_k -= 8;\n\t\t\treturn 1; /* We have a block */\n\t\t}\n\t\tinflate_stored_b >>= 8;\n\t\tinflate_stored_k -= 8;\n\t}\n\n\t/* restore the globals from the locals */\n\tgunzip_outbuf_count = inflate_stored_w;\t\t/* restore global gunzip_window pointer */\n\tgunzip_bb = inflate_stored_b;\t/* restore global bit buffer */\n\tgunzip_bk = inflate_stored_k;\n\treturn 0; /* Finished */\n}",
        "parsed_output": "static int process_data(STATE_PARAM transformer_aux_data_t *aux)\n{\n\tint v1;\n\tunsigned int v3;\n\n\twhile (1) {\n\t\tv1 = aux->count;\n\t\taux->count = v1 - 1;\n\t\tif (!v1)\n\t\t\tbreak;\n\n\t\taux->data = sub_4B88A3(aux->data, aux->buffer, &aux->buffer_size, 8);\n\t\tv3 = aux->data;\n\t\taux->data = v3 + 1;\n\t\taux->output[aux->output_size] = v3;\n\n\t\tif (aux->output_size == 0x8000) {\n\t\t\taux->input_size = aux->output_size;\n\t\t\taux->output_size = 0;\n\t\t\taux->data >>= 8;\n\t\t\taux->buffer_size -= 8;\n\t\t\treturn 1;\n\t\t}\n\n\t\taux->data >>= 8;\n\t\taux->buffer_size -= 8;\n\t}\n\n\taux->input_size = aux->output_size;\n\taux->input_data = aux->data;\n\taux->input_buffer_size = aux->buffer_size;\n\n\treturn 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4B97F0(__int64 a1)\n{\n  int v1; // edi\n  __int64 v2; // rsi\n  unsigned int v3; // eax\n  int v5; // eax\n\n  while ( 1 )\n  {\n    v5 = *(_DWORD *)(a1 + 132);\n    *(_DWORD *)(a1 + 132) = v5 - 1;\n    if ( !v5 )\n      break;\n    *(_DWORD *)(a1 + 136) = sub_4B88A3(a1, *(_DWORD *)(a1 + 136), (unsigned int *)(a1 + 140), 8u);\n    v1 = *(_DWORD *)(a1 + 136);\n    v2 = *(_QWORD *)(a1 + 24);\n    v3 = *(_DWORD *)(a1 + 144);\n    *(_DWORD *)(a1 + 144) = v3 + 1;\n    *(_BYTE *)(v2 + v3) = v1;\n    if ( *(_DWORD *)(a1 + 144) == 0x8000 )\n    {\n      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 144);\n      *(_DWORD *)(a1 + 144) = 0;\n      *(_DWORD *)(a1 + 136) >>= 8;\n      *(_DWORD *)(a1 + 140) -= 8;\n      return 1LL;\n    }\n    *(_DWORD *)(a1 + 136) >>= 8;\n    *(_DWORD *)(a1 + 140) -= 8;\n  }\n  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 144);\n  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);\n  *(_BYTE *)(a1 + 44) = *(_DWORD *)(a1 + 140);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl inflate_stored(state_t_0 *state)\n{\n  unsigned int inflate_stored_b; // edi\n  unsigned __int8 *gunzip_window; // rsi\n  unsigned int inflate_stored_w; // eax\n  unsigned int inflate_stored_n; // eax\n\n  while ( 1 )\n  {\n    inflate_stored_n = state->inflate_stored_n;\n    state->inflate_stored_n = inflate_stored_n - 1;\n    if ( !inflate_stored_n )\n      break;\n    state->inflate_stored_b = fill_bitbuffer(state, state->inflate_stored_b, &state->inflate_stored_k, 8u);\n    inflate_stored_b = state->inflate_stored_b;\n    gunzip_window = state->gunzip_window;\n    inflate_stored_w = state->inflate_stored_w;\n    state->inflate_stored_w = inflate_stored_w + 1;\n    gunzip_window[inflate_stored_w] = inflate_stored_b;\n    if ( state->inflate_stored_w == 0x8000 )\n    {\n      state->gunzip_outbuf_count = state->inflate_stored_w;\n      state->inflate_stored_w = 0;\n      state->inflate_stored_b >>= 8;\n      state->inflate_stored_k -= 8;\n      return 1;\n    }\n    state->inflate_stored_b >>= 8;\n    state->inflate_stored_k -= 8;\n  }\n  state->gunzip_outbuf_count = state->inflate_stored_w;\n  state->gunzip_bb = state->inflate_stored_b;\n  state->gunzip_bk = state->inflate_stored_k;\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.5763792395591736,
        "similarity_score_baseline_stripped": 0.5096443891525269,
        "similarity_score_baseline_debug": 0.9176042079925537
    },
    {
        "func_name": "linear2chs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_490FCA(int a1, int a2, unsigned int a3, unsigned int a4, char a5)\n{\n  _BYTE *result; // rax\n  int v8; // [rsp+1Ch] [rbp-Ch]\n  _BYTE *v9; // [rsp+20h] [rbp-8h]\n\n  if ( a2 )\n  {\n    v9 = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * a1 + 314);\n    v8 = *((_DWORD *)qword_75D408 + 22);\n  }\n  else\n  {\n    v9 = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * a1 + 313);\n    v8 = *((_DWORD *)qword_75D408 + 10 * a1 + 630);\n  }\n  *v9 = 0;\n  v9[4] = a5;\n  sub_49091E((__int64)v9, a3 - v8);\n  sub_490945((__int64)v9, a4 - a3 + 1);\n  sub_490DE1(v9, a3, a4);\n  result = (char *)qword_75D408 + 40 * a1 + 2536;\n  *result = 1;\n  return result;\n}\n\n\n Revised code:\nstatic void\nset_partition(int i, int doext, sector_t start, sector_t stop, int sysid)\n{\n\tstruct partition *p;\n\tsector_t offset;\n\n\tif (doext) {\n\t\tp = ptes[i].ext_pointer;\n\t\toffset = extended_offset;\n\t} else {\n\t\tp = ptes[i].part_table;\n\t\toffset = ptes[i].offset_from_dev_start;\n\t}\n\tp->boot_ind = 0;\n\tp->sys_ind = sysid;\n\tset_start_sect(p, start - offset);\n\tset_nr_sects(p, stop - start + 1);\n\tset_hsc_start_end(p, start, stop);\n\tptes[i].changed = 1;\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_480183(__int64 a1, _QWORD *a2)\n{\n  void *result; // rax\n  _QWORD *v3; // [rsp+0h] [rbp-20h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  v3 = a2;\n  *(_QWORD *)a1 = *a2;\n  *(_QWORD *)(a1 + 8) = *((_QWORD *)qword_75D408 + 11);\n  *(_DWORD *)(a1 + 16) = *((_DWORD *)qword_75D408 + 21);\n  *(_BYTE *)(a1 + 20) = *((_BYTE *)qword_75D408 + 80);\n  *a2 = **((_QWORD **)qword_75D408 + 11);\n  *((_QWORD *)qword_75D408 + 11) = a2;\n  *((_BYTE *)qword_75D408 + 80) = 0;\n  for ( i = 1; *++v3; ++i )\n    ;\n  result = qword_75D408;\n  *((_DWORD *)qword_75D408 + 21) = i;\n  return result;\n}\n\n\n Revised code:\nstatic void save_and_replace_G_args(save_arg_t *sv, char **argv)\n{\n\tint n;\n\n\tsv->sv_argv0 = argv[0];\n\tsv->sv_g_argv = G.global_argv;\n\tsv->sv_g_argc = G.global_argc;\n\tsv->sv_g_malloced = G.global_args_malloced;\n\n\targv[0] = G.global_argv[0]; /* retain $0 */\n\tG.global_argv = argv;\n\tG.global_args_malloced = 0;\n\n\tn = 1;\n\twhile (*++argv)\n\t\tn++;\n\tG.global_argc = n;\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_43B939(__int64 a1, __int64 a2)\n{\n  void *result; // rax\n  _QWORD *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40A0E8(0x170uLL, a2);\n  *v3 = sub_50BB2A(a1, 123LL);\n  v3[1] = sub_50BFDE(*v3 + 4LL);\n  *((_DWORD *)v3 + 4) = -1;\n  *((_BYTE *)v3 + 296) = 35;\n  v3[4] = *(_QWORD *)qword_75D408;\n  sub_43B74C((__int64)v3, 2.0);\n  sub_408FD2((_QWORD *)qword_75D408 + 6, (__int64)v3);\n  result = qword_75D408;\n  ++*((_DWORD *)qword_75D408 + 16);\n  return result;\n}\n\n\n Revised code:\nstatic void\nadd_peers(char *s)\n{\n\tpeer_t *p;\n\n\tp = xzalloc(sizeof(*p));\n\tp->p_lsa = xhost2sockaddr(s, 123);\n\tp->p_dotted = xmalloc_sockaddr2dotted_noport(&p->p_lsa->u.sa);\n\tp->p_fd = -1;\n\tp->p_xmt_msg.m_status = MODE_CLIENT | (NTP_VERSION << 3);\n\tp->next_action_time = G.cur_time; /* = set_next(p, 0); */\n\treset_peer_stats(p, 16 * STEP_THRESHOLD);\n\n\tllist_add_to(&G.ntp_peers, p);\n\tG.peer_cnt++;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_DWORD *__fastcall sub_49294D(unsigned int a1, unsigned int *a2, unsigned int *a3, _DWORD *a4)\n{\n  _DWORD *result; // rax\n  unsigned int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = *((_DWORD *)qword_75D408 + 9) * *((_DWORD *)qword_75D408 + 10);\n  *a2 = a1 / v5;\n  *a3 = a1 % v5 / *((_DWORD *)qword_75D408 + 10);\n  result = a4;\n  *a4 = a1 % v5 % *((_DWORD *)qword_75D408 + 10) + 1;\n  return result;\n}\n",
        "output": "static void calculate_indices(unsigned int input, unsigned int *index1, unsigned int *index2, _DWORD *index3)\n{\n  unsigned int temp = *((_DWORD *)qword_75D408 + 9) * *((_DWORD *)qword_75D408 + 10);\n  *index1 = input / temp;\n  *index2 = input % temp / *((_DWORD *)qword_75D408 + 10);\n  *index3 = input % temp % *((_DWORD *)qword_75D408 + 10) + 1;\n}",
        "source_code": "static void\nlinear2chs(unsigned ls, unsigned *c, unsigned *h, unsigned *s)\n{\n\tint spc = g_heads * g_sectors;\n\n\t*c = ls / spc;\n\tls = ls % spc;\n\t*h = ls / g_sectors;\n\t*s = ls % g_sectors + 1;  /* sectors count from 1 */\n}",
        "parsed_output": "static void calculate_indices(unsigned int input, unsigned int *index1, unsigned int *index2, _DWORD *index3)\n{\n  unsigned int temp = *((_DWORD *)qword_75D408 + 9) * *((_DWORD *)qword_75D408 + 10);\n  *index1 = input / temp;\n  *index2 = input % temp / *((_DWORD *)qword_75D408 + 10);\n  *index3 = input % temp % *((_DWORD *)qword_75D408 + 10) + 1;\n}",
        "baseline_code_stripped": "_DWORD *__fastcall sub_49294D(unsigned int a1, unsigned int *a2, unsigned int *a3, _DWORD *a4)\n{\n  _DWORD *result; // rax\n  unsigned int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = *((_DWORD *)qword_75D408 + 9) * *((_DWORD *)qword_75D408 + 10);\n  *a2 = a1 / v5;\n  *a3 = a1 % v5 / *((_DWORD *)qword_75D408 + 10);\n  result = a4;\n  *a4 = a1 % v5 % *((_DWORD *)qword_75D408 + 10) + 1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl linear2chs(unsigned int ls, unsigned int *c, unsigned int *h, unsigned int *s)\n{\n  unsigned int spc; // [rsp+2Ch] [rbp-4h]\n\n  spc = HIDWORD(ptr_to_globals->initstring) * LODWORD(ptr_to_globals->issue);\n  *c = ls / spc;\n  *h = ls % spc / LODWORD(ptr_to_globals->issue);\n  *s = ls % spc % LODWORD(ptr_to_globals->issue) + 1;\n}\n",
        "similarity_score_unixcoder": 0.4965561628341675,
        "similarity_score_baseline_stripped": 0.40268781781196594,
        "similarity_score_baseline_debug": 0.7550632953643799
    },
    {
        "func_name": "check_delayed_sigs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4BFF1C(__int64 a1, __int64 *a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-18h]\n  __int64 v4; // [rsp+20h] [rbp-10h]\n  unsigned int v5; // [rsp+2Ch] [rbp-4h]\n\n  v4 = a2[1];\n  v3 = a2[4];\n  v5 = sub_4BFB0B(a1, a2);\n  if ( !v5 && v4 == a2[1] && v3 == a2[4] )\n  {\n    if ( *(_BYTE *)(a1 + 44) )\n      v5 = 8;\n    *(_BYTE *)(a1 + 44) = 1;\n  }\n  else\n  {\n    *(_BYTE *)(a1 + 44) = 0;\n  }\n  return v5;\n}\n\n\n Revised code:\nXZ_EXTERN enum xz_ret XZ_FUNC xz_dec_run(struct xz_dec *s, struct xz_buf *b)\n{\n\tsize_t in_start;\n\tsize_t out_start;\n\tenum xz_ret ret;\n\n\tif (DEC_IS_SINGLE(s->mode))\n\t\txz_dec_reset(s);\n\n\tin_start = b->in_pos;\n\tout_start = b->out_pos;\n\tret = dec_main(s, b);\n\n\tif (DEC_IS_SINGLE(s->mode)) {\n\t\tif (ret == XZ_OK)\n\t\t\tret = b->in_pos == b->in_size\n\t\t\t\t\t? XZ_DATA_ERROR : XZ_BUF_ERROR;\n\n\t\tif (ret != XZ_STREAM_END) {\n\t\t\tb->in_pos = in_start;\n\t\t\tb->out_pos = out_start;\n\t\t}\n\n\t} else if (ret == XZ_OK && in_start == b->in_pos\n\t\t\t&& out_start == b->out_pos) {\n\t\tif (s->allow_buf_error)\n\t\t\tret = XZ_BUF_ERROR;\n\n\t\ts->allow_buf_error = true;\n\t} else {\n\t\ts->allow_buf_error = false;\n\t}\n\n\treturn ret;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4786F3(__int64 a1, __int64 a2)\n{\n  char v3; // [rsp+4h] [rbp-4Ch]\n  unsigned int v4; // [rsp+4h] [rbp-4Ch]\n  _QWORD v5[4]; // [rsp+10h] [rbp-40h] BYREF\n  __int64 v6; // [rsp+30h] [rbp-20h] BYREF\n  __int64 *v7; // [rsp+38h] [rbp-18h]\n  __int64 j; // [rsp+40h] [rbp-10h]\n  __int64 i; // [rsp+48h] [rbp-8h]\n\n  v3 = a2;\n  sub_46E8A1(v5);\n  v6 = 0LL;\n  v7 = &v6;\n  for ( i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(i + 8) )\n  {\n    a2 = (__int64)&v6;\n    sub_4768BC(i, (__int64)&v6, 35);\n    if ( byte_75B040 )\n      return sub_46E905(v5, a2);\n  }\n  *v7 = 0LL;\n  byte_75AF50 = 0;\n  ++dword_75B04C;\n  v4 = v3 & 2;\n  for ( j = v6; j; j = *(_QWORD *)j )\n  {\n    sub_46F6BF(*(char **)(a1 + 24), *(const char **)(j + 8), 0);\n    a2 = v4;\n    sub_4781FB(*(char **)(a1 + 16), v4);\n    if ( byte_75B040 )\n    {\n      if ( byte_75B040 != 2 || (--dword_75B044, dword_75B044 > 0) )\n      {\n        if ( byte_75B040 == 1 && --dword_75B044 <= 0 )\n          byte_75B040 = 0;\n        break;\n      }\n      byte_75B040 = 0;\n    }\n  }\n  --dword_75B04C;\n  return sub_46E905(v5, a2);\n}\n\n\n Revised code:\nstatic void\nevalfor(union node *n, int flags)\n{\n\tstruct arglist arglist;\n\tunion node *argp;\n\tstruct strlist *sp;\n\tstruct stackmark smark;\n\n\tsetstackmark(&smark);\n\targlist.list = NULL;\n\targlist.lastp = &arglist.list;\n\tfor (argp = n->nfor.args; argp; argp = argp->narg.next) {\n\t\texpandarg(argp, &arglist, EXP_FULL | EXP_TILDE | EXP_RECORD);\n\t\t/* XXX */\n\t\tif (evalskip)\n\t\t\tgoto out;\n\t}\n\t*arglist.lastp = NULL;\n\n\texitstatus = 0;\n\tloopnest++;\n\tflags &= EV_TESTED;\n\tfor (sp = arglist.list; sp; sp = sp->next) {\n\t\tsetvar(n->nfor.var, sp->text, 0);\n\t\tevaltree(n->nfor.body, flags);\n\t\tif (evalskip) {\n\t\t\tif (evalskip == SKIPCONT && --skipcount <= 0) {\n\t\t\t\tevalskip = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (evalskip == SKIPBREAK && --skipcount <= 0)\n\t\t\t\tevalskip = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tloopnest--;\n out:\n\tpopstackmark(&smark);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47B7A8(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  _QWORD *v7; // [rsp+0h] [rbp-20h]\n  __int64 v8; // [rsp+8h] [rbp-18h]\n  int v9; // [rsp+14h] [rbp-Ch]\n  char v10; // [rsp+14h] [rbp-Ch]\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = ((__int64 (*)(void))sub_47B839)(); ; i = (__int64)v7 )\n  {\n    v9 = sub_47DB13(a1);\n    if ( v9 == 6 )\n    {\n      v10 = 5;\n      goto LABEL_7;\n    }\n    if ( v9 != 7 )\n      break;\n    v10 = 6;\nLABEL_7:\n    byte_75B058 = 7;\n    v8 = sub_47B839(a1);\n    a1 = 24LL;\n    v7 = sub_46E7E7(0x18uLL, a2, v3, v4, v5, v6);\n    *(_BYTE *)v7 = v10;\n    v7[1] = i;\n    v7[2] = v8;\n  }\n  byte_75B059 = 1;\n  return i;\n}\n\n\n Revised code:\nstatic union node *\nandor(void)\n{\n\tunion node *n1, *n2, *n3;\n\tint t;\n\n\tn1 = pipeline();\n\tfor (;;) {\n\t\tt = readtoken();\n\t\tif (t == TAND) {\n\t\t\tt = NAND;\n\t\t} else if (t == TOR) {\n\t\t\tt = NOR;\n\t\t} else {\n\t\t\ttokpushback = 1;\n\t\t\treturn n1;\n\t\t}\n\t\tcheckkwd = CHKNL | CHKKWD | CHKALIAS;\n\t\tn2 = pipeline();\n\t\tn3 = stzalloc(sizeof(struct nbinary));\n\t\tn3->type = t;\n\t\tn3->nbinary.ch1 = n1;\n\t\tn3->nbinary.ch2 = n2;\n\t\tn1 = n3;\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4F59B2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  char v7; // [rsp+Bh] [rbp-5h]\n  unsigned int i; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; ; i = 1 )\n  {\n    v7 = byte_75D468;\n    if ( !byte_75D468 )\n      break;\n    byte_75D468 = 0;\n    if ( v7 == 1 )\n      sub_4F5915(a1, a2, a3, a4, a5, a6);\n    if ( v7 == 2 )\n    {\n      a1 = 32LL;\n      sub_4F5345(0x20u);\n    }\n  }\n  return i;\n}\n",
        "output": "static void process_data(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  char flag; // [rsp+Bh] [rbp-5h]\n  unsigned int i; // [rsp+Ch] [rbp-4h]\n\n  for (i = 0; ; i = 1)\n  {\n    flag = byte_75D468;\n    if (!byte_75D468)\n      break;\n    byte_75D468 = 0;\n    if (flag == 1)\n      process_flag1(a1, a2, a3, a4, a5, a6);\n    if (flag == 2)\n    {\n      a1 = 32LL;\n      process_flag2(0x20u);\n    }\n  }\n  return i;\n}",
        "source_code": "endif\n\nstatic int check_delayed_sigs(void)\n{\n\tint sigs_seen = 0;\n\n\twhile (1) {\n\t\tsmallint sig = bb_got_signal;\n\n\t\tif (!sig)\n\t\t\treturn sigs_seen;\n\t\tbb_got_signal = 0;\n\t\tsigs_seen = 1;\n#if ENABLE_FEATURE_USE_INITTAB\n\t\tif (sig == SIGHUP)\n\t\t\treload_inittab();\n#endif\n\t\tif (sig == SIGINT)\n\t\t\trun_actions(CTRLALTDEL);\n\t}\n}",
        "parsed_output": "static void process_data(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  char flag; // [rsp+Bh] [rbp-5h]\n  unsigned int i; // [rsp+Ch] [rbp-4h]\n\n  for (i = 0; ; i = 1)\n  {\n    flag = byte_75D468;\n    if (!byte_75D468)\n      break;\n    byte_75D468 = 0;\n    if (flag == 1)\n      process_flag1(a1, a2, a3, a4, a5, a6);\n    if (flag == 2)\n    {\n      a1 = 32LL;\n      process_flag2(0x20u);\n    }\n  }\n  return i;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4F59B2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  char v7; // [rsp+Bh] [rbp-5h]\n  unsigned int i; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; ; i = 1 )\n  {\n    v7 = byte_75D468;\n    if ( !byte_75D468 )\n      break;\n    byte_75D468 = 0;\n    if ( v7 == 1 )\n      sub_4F5915(a1, a2, a3, a4, a5, a6);\n    if ( v7 == 2 )\n    {\n      a1 = 32LL;\n      sub_4F5345(0x20u);\n    }\n  }\n  return i;\n}\n",
        "baseline_code_debug": "int __cdecl check_delayed_sigs()\n{\n  smallint sig; // [rsp+Bh] [rbp-5h]\n  int sigs_seen; // [rsp+Ch] [rbp-4h]\n\n  for ( sigs_seen = 0; ; sigs_seen = 1 )\n  {\n    sig = bb_got_signal[0];\n    if ( !bb_got_signal[0] )\n      break;\n    bb_got_signal[0] = 0;\n    if ( sig == 1 )\n      reload_inittab();\n    if ( sig == 2 )\n      run_actions(32);\n  }\n  return sigs_seen;\n}\n",
        "similarity_score_unixcoder": 0.5521289110183716,
        "similarity_score_baseline_stripped": 0.5008686780929565,
        "similarity_score_baseline_debug": 0.8497680425643921
    },
    {
        "func_name": "unalias",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4792F7(__int64 a1, __int64 a2)\n{\n  unsigned __int8 **v2; // rax\n  __int64 v4; // [rsp+0h] [rbp-20h]\n\n  v4 = qword_75AF58;\n  while ( 1 )\n  {\n    v2 = (unsigned __int8 **)v4;\n    v4 += 8LL;\n    if ( !*v2 )\n      break;\n    sub_47916A(*v2, a2);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC\nlocalcmd(int argc UNUSED_PARAM, char **argv)\n{\n\tchar *name;\n\n\targv = argptr;\n\twhile ((name = *argv++) != NULL) {\n\t\tmklocal(name);\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_472F50(__int64 a1, __int64 a2)\n{\n  __int64 v3; // [rsp+8h] [rbp-18h]\n  unsigned int v4; // [rsp+1Ch] [rbp-4h]\n\n  v3 = a1;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  while ( !*(_BYTE *)(v3 + 30) )\n  {\n    a2 = v3;\n    a1 = 0LL;\n    sub_4718A4(0, v3);\n  }\n  sub_46E03F(a1, a2);\n  v4 = sub_471EA1(v3);\n  if ( (*(_BYTE *)(v3 + 31) & 2) != 0 )\n  {\n    sub_471133(dword_75AE30, *(_DWORD *)qword_75D418);\n    if ( (*(_BYTE *)(v3 + 31) & 1) != 0 )\n      raise(2);\n  }\n  if ( *(_BYTE *)(v3 + 30) == 2 )\n    sub_47107C(v3);\n  return v4;\n}\n\n\n Revised code:\nstatic int\nwaitforjob(struct job *jp)\n{\n\tint st;\n\n\tTRACE((\"waitforjob(%%%d) called\\n\", jobno(jp)));\n\n\tINT_OFF;\n\twhile (jp->state == JOBRUNNING) {\n\t\t/* In non-interactive shells, we _can_ get\n\t\t * a keyboard signal here and be EINTRed,\n\t\t * but we just loop back, waiting for command to complete.\n\t\t *\n\t\t * man bash:\n\t\t * \"If bash is waiting for a command to complete and receives\n\t\t * a signal for which a trap has been set, the trap\n\t\t * will not be executed until the command completes.\"\n\t\t *\n\t\t * Reality is that even if trap is not set, bash\n\t\t * will not act on the signal until command completes.\n\t\t * Try this. sleep5intoff.c:\n\t\t * #include <signal.h>\n\t\t * #include <unistd.h>\n\t\t * int main() {\n\t\t *         sigset_t set;\n\t\t *         sigemptyset(&set);\n\t\t *         sigaddset(&set, SIGINT);\n\t\t *         sigaddset(&set, SIGQUIT);\n\t\t *         sigprocmask(SIG_BLOCK, &set, NULL);\n\t\t *         sleep(5);\n\t\t *         return 0;\n\t\t * }\n\t\t * $ bash -c './sleep5intoff; echo hi'\n\t\t * ^C^C^C^C <--- pressing ^C once a second\n\t\t * $ _\n\t\t * $ bash -c './sleep5intoff; echo hi'\n\t\t * ^\\^\\^\\^\\hi <--- pressing ^\\ (SIGQUIT)\n\t\t * $ _\n\t\t */\n\t\tdowait(DOWAIT_BLOCK, jp);\n\t}\n\tINT_ON;\n\n\tst = getstatus(jp);\n#if JOBS\n\tif (jp->jobctl) {\n\t\txtcsetpgrp(ttyfd, rootpid);\n\t\t/*\n\t\t * This is truly gross.\n\t\t * If we're doing job control, then we did a TIOCSPGRP which\n\t\t * caused us (the shell) to no longer be in the controlling\n\t\t * session -- so we wouldn't have seen any ^C/SIGINT.  So, we\n\t\t * intuit from the subprocess exit status whether a SIGINT\n\t\t * occurred, and if so interrupt ourselves.  Yuck.  - mycroft\n\t\t */\n\t\tif (jp->sigint) /* TODO: do the same with all signals */\n\t\t\traise(SIGINT); /* ... by raise(jp->sig) instead? */\n\t}\n\tif (jp->state == JOBDONE)\n#endif\n\t\tfreejob(jp);\n\treturn st;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E4DF8(__int64 a1, __int64 a2, __int64 a3)\n{\n  char **v3; // rbx\n  const char *i; // [rsp+28h] [rbp-18h]\n\n  for ( i = (const char *)(*(_QWORD *)a3 + a1); *i == 47; ++i )\n    ;\n  *(_QWORD *)(a3 + 16) = sub_50C0E1(*(_QWORD *)(a3 + 16), 2054LL, *(unsigned int *)(a3 + 12));\n  v3 = (char **)(*(_QWORD *)(a3 + 16) + 8LL * *(int *)(a3 + 12));\n  *v3 = sub_40A11F(i, 2054LL);\n  ++*(_DWORD *)(a3 + 12);\n  return 1LL;\n}\n\n\n Revised code:\nstatic void add_to_dirlist(const char *name, struct dir_list **list)\n{\n\tstruct dir_list *dp;\n\n\tdp = xmalloc(sizeof(struct dir_list));\n\tdp->name = blkid_strdup(name);\n\tdp->next = *list;\n\t*list = dp;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4707B3(const char *a1, __int64 a2)\n{\n  void **v2; // rdi\n  void ***v4; // [rsp+18h] [rbp-8h]\n\n  v4 = (void ***)sub_470562(a1);\n  if ( !*v4 )\n    return 1LL;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  v2 = *v4;\n  *v4 = sub_470668(*v4);\n  sub_46E03F(v2, a2);\n  return 0LL;\n}\n",
        "output": "static int FAST_FUNC\nprocessData(const char *input, int64_t a2)\n{\n\tvoid **v2;\n\tvoid ***v4;\n\n\tv4 = (void ***)sub_470562(input);\n\tif (!*v4)\n\t\treturn 1;\n\t++*(_DWORD *)(qword_75D418 + 48);\n\tv2 = *v4;\n\t*v4 = sub_470668(*v4);\n\tsub_46E03F(v2, a2);\n\treturn 0;\n}",
        "source_code": "static int\nunalias(const char *name)\n{\n\tstruct alias **app;\n\n\tapp = __lookupalias(name);\n\n\tif (*app) {\n\t\tINT_OFF;\n\t\t*app = freealias(*app);\n\t\tINT_ON;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
        "parsed_output": "static int FAST_FUNC\nprocessData(const char *input, int64_t a2)\n{\n\tvoid **v2;\n\tvoid ***v4;\n\n\tv4 = (void ***)sub_470562(input);\n\tif (!*v4)\n\t\treturn 1;\n\t++*(_DWORD *)(qword_75D418 + 48);\n\tv2 = *v4;\n\t*v4 = sub_470668(*v4);\n\tsub_46E03F(v2, a2);\n\treturn 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4707B3(const char *a1, __int64 a2)\n{\n  void **v2; // rdi\n  void ***v4; // [rsp+18h] [rbp-8h]\n\n  v4 = (void ***)sub_470562(a1);\n  if ( !*v4 )\n    return 1LL;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  v2 = *v4;\n  *v4 = sub_470668(*v4);\n  sub_46E03F(v2, a2);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl unalias(const char *name)\n{\n  alias **app; // [rsp+18h] [rbp-8h]\n\n  app = _lookupalias(name);\n  if ( !*app )\n    return 1;\n  ++ash_ptr_to_globals_misc->suppress_int;\n  *app = freealias(*app);\n  int_on();\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.44068199396133423,
        "similarity_score_baseline_stripped": 0.4393694996833801,
        "similarity_score_baseline_debug": 0.7727838754653931
    },
    {
        "func_name": "chksum_and_xwrite",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4D22AA(__int64 a1)\n{\n  unsigned int *v1; // rax\n  __int64 v3; // [rsp+10h] [rbp-18h]\n  int v4; // [rsp+1Ch] [rbp-Ch]\n  unsigned int *v5; // [rsp+20h] [rbp-8h]\n\n  v5 = (unsigned int *)(a1 + 56);\n  v4 = 2;\n  v3 = 0LL;\n  do\n  {\n    v1 = v5++;\n    v3 = (v3 << 32) | *v1;\n    --v4;\n  }\n  while ( v4 );\n  return v3;\n}\n\n\n Revised code:\nstatic unsigned long long get_f_fsid(const struct statfs *statfsbuf)\n{\n\tconst unsigned *p = (const void*) &statfsbuf->f_fsid;\n\tunsigned sz = sizeof(statfsbuf->f_fsid) / sizeof(unsigned);\n\tunsigned long long r = 0;\n\n\tdo\n\t\tr = (r << (sizeof(unsigned)*8)) | *p++;\n\twhile (--sz > 0);\n\treturn r;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B5CAD(int a1, __int64 a2)\n{\n  int v3; // [rsp+Ch] [rbp-14h]\n  unsigned int v4; // [rsp+Ch] [rbp-14h]\n  __off64_t v5; // [rsp+18h] [rbp-8h]\n\n  v3 = a1;\n  v5 = sub_40A557(3, 0LL, 1);\n  if ( !a1 )\n    v3 = sub_4B5B97(3LL, 0LL);\n  sub_40A557(3, (unsigned int)(v3 + 4), 0);\n  sub_507452(3LL, a2, 42LL);\n  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a2 + 12);\n  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a2 + 16);\n  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a2 + 20);\n  *(_WORD *)(a2 + 24) = *(_WORD *)(a2 + 24);\n  *(_WORD *)(a2 + 26) = *(_WORD *)(a2 + 26);\n  *(_WORD *)(a2 + 28) = *(_WORD *)(a2 + 28);\n  *(_WORD *)a2 = *(_WORD *)a2;\n  *(_DWORD *)(a2 + 34) = *(_DWORD *)(a2 + 34);\n  v4 = *(unsigned __int16 *)(a2 + 26) + *(unsigned __int16 *)(a2 + 24) + 46 + *(unsigned __int16 *)(a2 + 28) + v3;\n  sub_40A557(3, v5, 0);\n  return v4;\n}\n\n\n Revised code:\nstatic uint32_t read_next_cdf(uint32_t cdf_offset, cdf_header_t *cdf_ptr)\n{\n\toff_t org;\n\n\torg = xlseek(zip_fd, 0, SEEK_CUR);\n\n\tif (!cdf_offset)\n\t\tcdf_offset = find_cdf_offset();\n\n\txlseek(zip_fd, cdf_offset + 4, SEEK_SET);\n\txread(zip_fd, cdf_ptr->raw, CDF_HEADER_LEN);\n\tFIX_ENDIANNESS_CDF(*cdf_ptr);\n\tcdf_offset += 4 + CDF_HEADER_LEN\n\t\t+ cdf_ptr->formatted.file_name_length\n\t\t+ cdf_ptr->formatted.extra_field_length\n\t\t+ cdf_ptr->formatted.file_comment_length;\n\n\txlseek(zip_fd, org, SEEK_SET);\n\treturn cdf_offset;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_44924D(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  void *v3; // rdx\n  int v4; // [rsp+18h] [rbp-8h]\n  int v5; // [rsp+1Ch] [rbp-4h]\n\n  v5 = *(_DWORD *)(a1 + 44) - 1;\n  while ( v5 >= 0 )\n  {\n    if ( a2 == *(__int16 *)(2LL * v5 + *(_QWORD *)a1) )\n    {\n      sub_44909B(a1, v5--);\n    }\n    else\n    {\n      if ( a2 < *(__int16 *)(2LL * v5 + *(_QWORD *)a1) )\n        --*(_WORD *)(2LL * v5 + *(_QWORD *)a1);\n      --v5;\n    }\n  }\n  v4 = 8 * (--*(_DWORD *)(a1 + 48) - a2);\n  if ( v4 > 0 )\n  {\n    memcpy((void *)(*(_QWORD *)(a1 + 8) + 8LL * a2), (const void *)(*(_QWORD *)(a1 + 8) + 8 * (a2 + 1LL)), v4);\n    if ( *(_DWORD *)(a1 + 40) )\n      memcpy((void *)(*(_QWORD *)(a1 + 16) + 8LL * a2), (const void *)(*(_QWORD *)(a1 + 16) + 8 * (a2 + 1LL)), v4);\n  }\n  *(_QWORD *)(a1 + 8) = sub_40A09E(*(void **)(a1 + 8), 8LL * *(int *)(a1 + 48));\n  result = *(unsigned int *)(a1 + 40);\n  if ( (_DWORD)result )\n  {\n    v3 = sub_40A09E(*(void **)(a1 + 16), 8LL * *(int *)(a1 + 48));\n    result = a1;\n    *(_QWORD *)(a1 + 16) = v3;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void remove_peer(isrv_state_t *state, int peer)\n{\n\tint movesize;\n\tint fd;\n\n\tDPRINTF(\"remove_peer(%d)\", peer);\n\n\tfd = FD_COUNT - 1;\n\twhile (fd >= 0) {\n\t\tif (FD2PEER[fd] == peer) {\n\t\t\tisrv_close_fd(state, fd);\n\t\t\tfd--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (FD2PEER[fd] > peer)\n\t\t\tFD2PEER[fd]--;\n\t\tfd--;\n\t}\n\n\tPEER_COUNT--;\n\tDPRINTF(\"remove_peer: PEER_COUNT %d\", PEER_COUNT);\n\n\tmovesize = (PEER_COUNT - peer) * sizeof(void*);\n\tif (movesize > 0) {\n\t\tmemcpy(&PARAM_TBL[peer], &PARAM_TBL[peer+1], movesize);\n\t\tif (TIMEOUT)\n\t\t\tmemcpy(&TIMEO_TBL[peer], &TIMEO_TBL[peer+1], movesize);\n\t}\n\tPARAM_TBL = xrealloc(PARAM_TBL, PEER_COUNT * sizeof(PARAM_TBL[0]));\n\tif (TIMEOUT)\n\t\tTIMEO_TBL = xrealloc(TIMEO_TBL, PEER_COUNT * sizeof(TIMEO_TBL[0]));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_4B46FF(unsigned int a1, __int64 a2)\n{\n  unsigned __int8 *v2; // rax\n  int v3; // [rsp+10h] [rbp-10h]\n  int v4; // [rsp+14h] [rbp-Ch]\n  unsigned __int8 *v5; // [rsp+18h] [rbp-8h]\n\n  *(_QWORD *)(a2 + 257) = 0x20207261747375LL;\n  memset((void *)(a2 + 148), 32, 8uLL);\n  v5 = (unsigned __int8 *)a2;\n  v4 = 0;\n  v3 = 512;\n  do\n  {\n    v2 = v5++;\n    v4 += *v2;\n    --v3;\n  }\n  while ( v3 );\n  sub_4B468C((void *)(a2 + 148), 7, v4);\n  sub_40A4AB(a1, a2, 512LL);\n}\n",
        "output": "void process_data(unsigned int a1, __int64 a2)\n{\n  unsigned __int8 *data_ptr; // rax\n  int sum = 0; // [rsp+10h] [rbp-10h]\n  int count = 512; // [rsp+14h] [rbp-Ch]\n  unsigned __int8 *ptr = (unsigned __int8 *)a2; // [rsp+18h] [rbp-8h]\n\n  *(_QWORD *)(a2 + 257) = 0x20207261747375LL;\n  memset((void *)(a2 + 148), 32, 8uLL);\n  \n  do\n  {\n    data_ptr = ptr++;\n    sum += *data_ptr;\n    --count;\n  }\n  while ( count );\n  \n  calculate_checksum((void *)(a2 + 148), 7, sum);\n  process_data(a1, a2, 512LL);\n}",
        "source_code": "static void chksum_and_xwrite(int fd, struct tar_header_t* hp)\n{\n\t/* POSIX says that checksum is done on unsigned bytes\n\t * (Sun and HP-UX gets it wrong... more details in\n\t * GNU tar source) */\n\tconst unsigned char *cp;\n\tint chksum, size;\n\n\tstrcpy(hp->magic, \"ustar  \");\n\n\t/* Calculate and store the checksum (i.e., the sum of all of the bytes of\n\t * the header).  The checksum field must be filled with blanks for the\n\t * calculation.  The checksum field is formatted differently from the\n\t * other fields: it has 6 digits, a null, then a space -- rather than\n\t * digits, followed by a null like the other fields... */\n\tmemset(hp->chksum, ' ', sizeof(hp->chksum));\n\tcp = (const unsigned char *) hp;\n\tchksum = 0;\n\tsize = sizeof(*hp);\n\tdo { chksum += *cp++; } while (--size);\n\tputOctal(hp->chksum, sizeof(hp->chksum)-1, chksum);\n\n\t/* Now write the header out to disk */\n\txwrite(fd, hp, sizeof(*hp));\n}",
        "parsed_output": "void process_data(unsigned int a1, __int64 a2)\n{\n  unsigned __int8 *data_ptr; // rax\n  int sum = 0; // [rsp+10h] [rbp-10h]\n  int count = 512; // [rsp+14h] [rbp-Ch]\n  unsigned __int8 *ptr = (unsigned __int8 *)a2; // [rsp+18h] [rbp-8h]\n\n  *(_QWORD *)(a2 + 257) = 0x20207261747375LL;\n  memset((void *)(a2 + 148), 32, 8uLL);\n  \n  do\n  {\n    data_ptr = ptr++;\n    sum += *data_ptr;\n    --count;\n  }\n  while ( count );\n  \n  calculate_checksum((void *)(a2 + 148), 7, sum);\n  process_data(a1, a2, 512LL);\n}",
        "baseline_code_stripped": "void __fastcall sub_4B46FF(unsigned int a1, __int64 a2)\n{\n  unsigned __int8 *v2; // rax\n  int v3; // [rsp+10h] [rbp-10h]\n  int v4; // [rsp+14h] [rbp-Ch]\n  unsigned __int8 *v5; // [rsp+18h] [rbp-8h]\n\n  *(_QWORD *)(a2 + 257) = 0x20207261747375LL;\n  memset((void *)(a2 + 148), 32, 8uLL);\n  v5 = (unsigned __int8 *)a2;\n  v4 = 0;\n  v3 = 512;\n  do\n  {\n    v2 = v5++;\n    v4 += *v2;\n    --v3;\n  }\n  while ( v3 );\n  sub_4B468C((void *)(a2 + 148), 7, v4);\n  sub_40A4AB(a1, a2, 512LL);\n}\n",
        "baseline_code_debug": "void __cdecl chksum_and_xwrite(int fd, tar_header_t *hp)\n{\n  tar_header_t *v2; // rax\n  int size; // [rsp+10h] [rbp-10h]\n  int chksum; // [rsp+14h] [rbp-Ch]\n  tar_header_t *cp; // [rsp+18h] [rbp-8h]\n\n  *(_QWORD *)hp->magic = 0x20207261747375LL;\n  memset(hp->chksum, 32, sizeof(hp->chksum));\n  cp = hp;\n  chksum = 0;\n  size = 512;\n  do\n  {\n    v2 = cp;\n    cp = (tar_header_t *)((char *)cp + 1);\n    chksum += (unsigned __int8)v2->name[0];\n    --size;\n  }\n  while ( size );\n  putOctal(hp->chksum, 7, chksum);\n  xwrite(fd, hp, 0x200uLL);\n}\n",
        "similarity_score_unixcoder": 0.6032274961471558,
        "similarity_score_baseline_stripped": 0.4620927572250366,
        "similarity_score_baseline_debug": 0.8681948184967041
    },
    {
        "func_name": "get_inode_common",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_497D29(__int64 a1, unsigned int a2)\n{\n  int result; // eax\n  const char *v3; // rdx\n  unsigned __int16 *v4; // [rsp+18h] [rbp-18h]\n  char *s2; // [rsp+20h] [rbp-10h]\n  unsigned int v6; // [rsp+28h] [rbp-8h]\n  unsigned int v7; // [rsp+2Ch] [rbp-4h]\n\n  v6 = sub_4964AA(a1, a2 >> 10);\n  sub_496301(v6, (char *)qword_75D408 + 4516);\n  s2 = (char *)qword_75D408 + (a2 & 0x3FF) + 4518;\n  v7 = *(unsigned __int16 *)((char *)qword_75D408 + (a2 & 0x3FF) + 4516);\n  if ( *((unsigned __int16 *)qword_75D408 + 210) < v7 )\n  {\n    printf(\n      \"%s contains a bad inode number for file '%.*s'. \",\n      (const char *)qword_75D408 + 5540,\n      *((char *)qword_75D408 + 5),\n      s2);\n    if ( (unsigned int)sub_49602F((__int64)\"Remove\", 1u) )\n    {\n      *((_WORD *)s2 - 1) = 0;\n      sub_4963B6(v6, (__int64)qword_75D408 + 4516);\n    }\n    v7 = 0;\n  }\n  sub_495F08(s2);\n  v4 = sub_4973B9(v7);\n  sub_495FC0();\n  if ( !a2 )\n  {\n    if ( v4 )\n    {\n      if ( *s2 == 46 )\n      {\n        result = (unsigned __int8)s2[1];\n        if ( !(_BYTE)result )\n          return result;\n      }\n    }\n    printf(\"%s: bad directory: '.' isn't first\\n\", (const char *)qword_75D408 + 5540);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  result = *((char *)qword_75D408 + 4);\n  if ( a2 == result )\n  {\n    if ( v4 )\n    {\n      result = strcmp(\"..\", s2);\n      if ( !result )\n        return result;\n    }\n    printf(\"%s: bad directory: '..' isn't second\\n\", (const char *)qword_75D408 + 5540);\n    result = (int)qword_75D408;\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  if ( v4 )\n  {\n    sub_495F08(s2);\n    if ( (dword_75D450 & 1) != 0 )\n    {\n      if ( (dword_75D450 & 8) != 0 )\n        printf(\"%6d %07o %3d \", v7, *v4, *((unsigned __int8 *)v4 + 13));\n      if ( (*v4 & 0xF000) == 0x4000 )\n        v3 = \":\";\n      else\n        v3 = (const char *)&unk_52F2AE;\n      printf(\"%s%s\\n\", (const char *)qword_75D408 + 5540, v3);\n    }\n    sub_497A94(v7);\n    if ( (*v4 & 0xF000) == 0x4000 )\n      sub_49828D(v7);\n    return sub_495FC0();\n  }\n  return result;\n}\n\n\n Revised code:\nendif\n\nstatic void check_file(struct minix1_inode *dir, unsigned offset)\n{\n\tstruct minix1_inode *inode;\n\tint ino;\n\tchar *name;\n\tint block;\n\n\tblock = map_block(dir, offset / BLOCK_SIZE);\n\tread_block(block, check_file_blk);\n\tname = check_file_blk + (offset % BLOCK_SIZE) + 2;\n\tino = *(uint16_t *) (name - 2);\n\tif (ino > INODES) {\n\t\tprintf(\"%s contains a bad inode number for file '%.*s'. \",\n\t\t\t\tcurrent_name, namelen, name);\n\t\tif (ask(\"Remove\", 1)) {\n\t\t\t*(uint16_t *) (name - 2) = 0;\n\t\t\twrite_block(block, check_file_blk);\n\t\t}\n\t\tino = 0;\n\t}\n\tpush_filename(name);\n\tinode = get_inode(ino);\n\tpop_filename();\n\tif (!offset) {\n\t\tif (inode && LONE_CHAR(name, '.'))\n\t\t\treturn;\n\t\tprintf(\"%s: bad directory: '.' isn't first\\n\", current_name);\n\t\terrors_uncorrected = 1;\n\t}\n\tif (offset == dirsize) {\n\t\tif (inode && strcmp(\"..\", name) == 0)\n\t\t\treturn;\n\t\tprintf(\"%s: bad directory: '..' isn't second\\n\", current_name);\n\t\terrors_uncorrected = 1;\n\t}\n\tif (!inode)\n\t\treturn;\n\tpush_filename(name);\n\tif (OPT_list) {\n\t\tif (OPT_verbose)\n\t\t\tprintf(\"%6d %07o %3d \", ino, inode->i_mode, inode->i_nlinks);\n\t\tprintf(\"%s%s\\n\", current_name, S_ISDIR(inode->i_mode) ? \":\" : \"\");\n\t}\n\tcheck_zones(ino);\n\tif (inode && S_ISDIR(inode->i_mode))\n\t\trecursive_check(ino);\n\tpop_filename();\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_497FDB(unsigned int *a1, unsigned int a2)\n{\n  int result; // eax\n  const char *v3; // rdx\n  unsigned __int16 *v4; // [rsp+18h] [rbp-18h]\n  char *s2; // [rsp+20h] [rbp-10h]\n  unsigned int v6; // [rsp+28h] [rbp-8h]\n  unsigned int v7; // [rsp+2Ch] [rbp-4h]\n\n  v6 = sub_49664E(a1, a2 >> 10);\n  sub_496301(v6, (char *)qword_75D408 + 4516);\n  s2 = (char *)qword_75D408 + (a2 & 0x3FF) + 4518;\n  v7 = *(unsigned __int16 *)((char *)qword_75D408 + (a2 & 0x3FF) + 4516);\n  if ( *((unsigned __int16 *)qword_75D408 + 210) < v7 )\n  {\n    printf(\n      \"%s contains a bad inode number for file '%.*s'. \",\n      (const char *)qword_75D408 + 5540,\n      *((char *)qword_75D408 + 5),\n      s2);\n    if ( (unsigned int)sub_49602F((__int64)\"Remove\", 1u) )\n    {\n      *((_WORD *)s2 - 1) = 0;\n      sub_4963B6(v6, (__int64)qword_75D408 + 4516);\n    }\n    v7 = 0;\n  }\n  sub_495F08(s2);\n  v4 = sub_497422(v7);\n  sub_495FC0();\n  if ( !a2 )\n  {\n    if ( v4 )\n    {\n      if ( *s2 == 46 )\n      {\n        result = (unsigned __int8)s2[1];\n        if ( !(_BYTE)result )\n          return result;\n      }\n    }\n    printf(\"%s: bad directory: '.' isn't first\\n\", (const char *)qword_75D408 + 5540);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  result = *((char *)qword_75D408 + 4);\n  if ( a2 == result )\n  {\n    if ( v4 )\n    {\n      result = strcmp(\"..\", s2);\n      if ( !result )\n        return result;\n    }\n    printf(\"%s: bad directory: '..' isn't second\\n\", (const char *)qword_75D408 + 5540);\n    result = (int)qword_75D408;\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  if ( v4 )\n  {\n    sub_495F08(s2);\n    if ( (dword_75D450 & 1) != 0 )\n    {\n      if ( (dword_75D450 & 8) != 0 )\n        printf(\"%6d %07o %3d \", v7, *v4, v4[1]);\n      if ( (*v4 & 0xF000) == 0x4000 )\n        v3 = \":\";\n      else\n        v3 = (const char *)&unk_52F2AE;\n      printf(\"%s%s\\n\", (const char *)qword_75D408 + 5540, v3);\n    }\n    sub_497BCD(v7);\n    if ( (*v4 & 0xF000) == 0x4000 )\n      sub_498354(v7);\n    return sub_495FC0();\n  }\n  return result;\n}\n\n\n Revised code:\nif ENABLE_FEATURE_MINIX2\nstatic void check_file2(struct minix2_inode *dir, unsigned offset)\n{\n\tstruct minix2_inode *inode;\n\tint ino;\n\tchar *name;\n\tint block;\n\n\tblock = map_block2(dir, offset / BLOCK_SIZE);\n\tread_block(block, check_file_blk);\n\tname = check_file_blk + (offset % BLOCK_SIZE) + 2;\n\tino = *(uint16_t *) (name - 2);\n\tif (ino > INODES) {\n\t\tprintf(\"%s contains a bad inode number for file '%.*s'. \",\n\t\t\t\tcurrent_name, namelen, name);\n\t\tif (ask(\"Remove\", 1)) {\n\t\t\t*(uint16_t *) (name - 2) = 0;\n\t\t\twrite_block(block, check_file_blk);\n\t\t}\n\t\tino = 0;\n\t}\n\tpush_filename(name);\n\tinode = get_inode2(ino);\n\tpop_filename();\n\tif (!offset) {\n\t\tif (inode && LONE_CHAR(name, '.'))\n\t\t\treturn;\n\t\tprintf(\"%s: bad directory: '.' isn't first\\n\", current_name);\n\t\terrors_uncorrected = 1;\n\t}\n\tif (offset == dirsize) {\n\t\tif (inode && strcmp(\"..\", name) == 0)\n\t\t\treturn;\n\t\tprintf(\"%s: bad directory: '..' isn't second\\n\", current_name);\n\t\terrors_uncorrected = 1;\n\t}\n\tif (!inode)\n\t\treturn;\n\tpush_filename(name);\n\tif (OPT_list) {\n\t\tif (OPT_verbose)\n\t\t\tprintf(\"%6d %07o %3d \", ino, inode->i_mode, inode->i_nlinks);\n\t\tprintf(\"%s%s\\n\", current_name, S_ISDIR(inode->i_mode) ? \":\" : \"\");\n\t}\n\tcheck_zones2(ino);\n\tif (inode && S_ISDIR(inode->i_mode))\n\t\trecursive_check2(ino);\n\tpop_filename();\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E7583(int a1, const void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  int v7; // [rsp+8h] [rbp-18h]\n  _QWORD *ptr; // [rsp+10h] [rbp-10h]\n  char *v9; // [rsp+18h] [rbp-8h]\n\n  v7 = a3;\n  if ( a1 <= 0 || a1 > *((_DWORD *)qword_75D408 + 1) + 1 )\n  {\n    sub_409747(\"inserting at bad line number\", (__int64)a2, a3, a4, a5, a6, a2);\n    return 0LL;\n  }\n  ptr = sub_40A05F((int)a3 + 23LL, (__int64)a2);\n  memcpy((char *)ptr + 20, a2, v7);\n  *((_DWORD *)ptr + 4) = v7;\n  if ( a1 <= *((_DWORD *)qword_75D408 + 1) )\n  {\n    v9 = (char *)sub_4E78F6((unsigned int)a1);\n    if ( !v9 )\n    {\n      free(ptr);\n      return 0LL;\n    }\n  }\n  else\n  {\n    v9 = (char *)qword_75D408 + 48;\n  }\n  *ptr = v9;\n  ptr[1] = *((_QWORD *)v9 + 1);\n  **((_QWORD **)v9 + 1) = ptr;\n  *((_QWORD *)v9 + 1) = ptr;\n  ++*((_DWORD *)qword_75D408 + 1);\n  *((_BYTE *)qword_75D408 + 72) = 1;\n  return sub_4E7A44((unsigned int)a1);\n}\n\n\n Revised code:\nstatic int insertLine(int num, const char *data, int len)\n{\n\tLINE *newLp, *lp;\n\n\tif ((num < 1) || (num > lastNum + 1)) {\n\t\tbb_error_msg(\"inserting at bad line number\");\n\t\treturn FALSE;\n\t}\n\n\tnewLp = xmalloc(sizeof(LINE) + len - 1);\n\n\tmemcpy(newLp->data, data, len);\n\tnewLp->len = len;\n\n\tif (num > lastNum)\n\t\tlp = &lines;\n\telse {\n\t\tlp = findLine(num);\n\t\tif (lp == NULL) {\n\t\t\tfree((char *) newLp);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tnewLp->next = lp;\n\tnewLp->prev = lp->prev;\n\tlp->prev->next = newLp;\n\tlp->prev = newLp;\n\n\tlastNum++;\n\tdirty = TRUE;\n\treturn setCurNum(num);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nunsigned __int64 __fastcall sub_49719D(unsigned int a1, unsigned __int16 a2)\n{\n  _BYTE *v2; // rax\n  unsigned __int64 result; // rax\n\n  ++*((_DWORD *)qword_75D408 + 10);\n  if ( *(_BYTE *)(*((_QWORD *)qword_75D408 + 9) + a1) )\n  {\n    ++*((_DWORD *)qword_75D408 + 8);\n  }\n  else\n  {\n    if ( !(unsigned int)sub_495DF1(*((_QWORD *)qword_75D408 + 7), a1) )\n    {\n      printf(\"Inode %d is marked as 'unused', but it is used for file '%s'\\n\", a1, (const char *)qword_75D408 + 5540);\n      if ( (dword_75D450 & 4) != 0 )\n      {\n        if ( (unsigned int)sub_49602F((__int64)\"Mark as 'in use'\", 1u) )\n          sub_495E26(*((_QWORD *)qword_75D408 + 7), a1);\n        else\n          *((_BYTE *)qword_75D408 + 2) = 1;\n      }\n    }\n    switch ( a2 & 0xF000 )\n    {\n      case 16384:\n        ++*((_DWORD *)qword_75D408 + 4);\n        break;\n      case 32768:\n        ++*((_DWORD *)qword_75D408 + 5);\n        break;\n      case 8192:\n        ++*((_DWORD *)qword_75D408 + 7);\n        break;\n      case 24576:\n        ++*((_DWORD *)qword_75D408 + 6);\n        break;\n      case 40960:\n        ++*((_DWORD *)qword_75D408 + 9);\n        break;\n      default:\n        if ( (a2 & 0xF000) != 49152 && (a2 & 0xF000) != 4096 )\n          printf(\"%s has mode %05o\\n\", (const char *)qword_75D408 + 5540, a2);\n        break;\n    }\n  }\n  v2 = (_BYTE *)(*((_QWORD *)qword_75D408 + 9) + a1);\n  result = (unsigned __int8)++*v2;\n  if ( !(_BYTE)result )\n  {\n    puts(\"Warning: inode count too big\");\n    --*(_BYTE *)(*((_QWORD *)qword_75D408 + 9) + a1);\n    result = (unsigned __int64)qword_75D408;\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  return result;\n}\n",
        "output": "static void updateInodeCount(unsigned int inodeNum, unsigned short mode)\n{\n    *((unsigned int *)qword_75D408 + 10)++;\n\n    if (*((unsigned char *)(*((unsigned long long *)qword_75D408 + 9) + inodeNum))) {\n        *((unsigned int *)qword_75D408 + 8)++;\n    } else {\n        if (!sub_495DF1(*((unsigned long long *)qword_75D408 + 7), inodeNum)) {\n            printf(\"Inode %d is marked as 'unused', but it is used for file '%s'\\n\", inodeNum, (const char *)qword_75D408 + 5540);\n            if (dword_75D450 & 4) {\n                if (sub_49602F((__int64)\"Mark as 'in use'\", 1u)) {\n                    sub_495E26(*((unsigned long long *)qword_75D408 + 7), inodeNum);\n                } else {\n                    *((unsigned char *)qword_75D408 + 2) = 1;\n                }\n            }\n        }\n        switch (mode & 0xF000) {\n            case 16384:\n                *((unsigned int *)qword_75D408 + 4)++;\n                break;\n            case 32768:\n                *((unsigned int *)qword_75D408 + 5)++;\n                break;\n            case 8192:\n                *((unsigned int *)qword_75D408 + 7)++;\n                break;\n            case 24576:\n                *((unsigned int *)qword_75D408 + 6)++;\n                break;\n            case 40960:\n                *((unsigned int *)qword_75D408 + 9)++;\n                break;\n            default:\n                if ((mode & 0xF000) != 49152 && (mode & 0xF000) != 4096) {\n                    printf(\"%s has mode %05o\\n\", (const char *)qword_75D408 + 5540, mode);\n                }\n                break;\n        }\n    }\n\n    unsigned char *count = (unsigned char *)(*((unsigned long long *)qword_75D408 + 9) + inodeNum);\n    unsigned char result = ++*count;\n    if (!result) {\n        puts(\"Warning: inode count too big\");\n        --*count;\n        *((unsigned char *)qword_75D408 + 2) = 1;\n    }\n}",
        "source_code": "static void get_inode_common(unsigned nr, uint16_t i_mode)\n{\n\ttotal++;\n\tif (!inode_count[nr]) {\n\t\tif (!inode_in_use(nr)) {\n\t\t\tprintf(\"Inode %d is marked as 'unused', but it is used \"\n\t\t\t\t\t\"for file '%s'\\n\", nr, current_name);\n\t\t\tif (OPT_repair) {\n\t\t\t\tif (ask(\"Mark as 'in use'\", 1))\n\t\t\t\t\tmark_inode(nr);\n\t\t\t\telse\n\t\t\t\t\terrors_uncorrected = 1;\n\t\t\t}\n\t\t}\n\t\tif (S_ISDIR(i_mode))\n\t\t\tdirectory++;\n\t\telse if (S_ISREG(i_mode))\n\t\t\tregular++;\n\t\telse if (S_ISCHR(i_mode))\n\t\t\tchardev++;\n\t\telse if (S_ISBLK(i_mode))\n\t\t\tblockdev++;\n\t\telse if (S_ISLNK(i_mode))\n\t\t\tsymlinks++;\n\t\telse if (S_ISSOCK(i_mode));\n\t\telse if (S_ISFIFO(i_mode));\n\t\telse {\n\t\t\tprintf(\"%s has mode %05o\\n\", current_name, i_mode);\n\t\t}\n\t} else\n\t\tlinks++;\n\tif (!++inode_count[nr]) {\n\t\tprintf(\"Warning: inode count too big\\n\");\n\t\tinode_count[nr]--;\n\t\terrors_uncorrected = 1;\n\t}\n}",
        "parsed_output": "static void updateInodeCount(unsigned int inodeNum, unsigned short mode)\n{\n    *((unsigned int *)qword_75D408 + 10)++;\n\n    if (*((unsigned char *)(*((unsigned long long *)qword_75D408 + 9) + inodeNum))) {\n        *((unsigned int *)qword_75D408 + 8)++;\n    } else {\n        if (!sub_495DF1(*((unsigned long long *)qword_75D408 + 7), inodeNum)) {\n            printf(\"Inode %d is marked as 'unused', but it is used for file '%s'\\n\", inodeNum, (const char *)qword_75D408 + 5540);\n            if (dword_75D450 & 4) {\n                if (sub_49602F((__int64)\"Mark as 'in use'\", 1u)) {\n                    sub_495E26(*((unsigned long long *)qword_75D408 + 7), inodeNum);\n                } else {\n                    *((unsigned char *)qword_75D408 + 2) = 1;\n                }\n            }\n        }\n        switch (mode & 0xF000) {\n            case 16384:\n                *((unsigned int *)qword_75D408 + 4)++;\n                break;\n            case 32768:\n                *((unsigned int *)qword_75D408 + 5)++;\n                break;\n            case 8192:\n                *((unsigned int *)qword_75D408 + 7)++;\n                break;\n            case 24576:\n                *((unsigned int *)qword_75D408 + 6)++;\n                break;\n            case 40960:\n                *((unsigned int *)qword_75D408 + 9)++;\n                break;\n            default:\n                if ((mode & 0xF000) != 49152 && (mode & 0xF000) != 4096) {\n                    printf(\"%s has mode %05o\\n\", (const char *)qword_75D408 + 5540, mode);\n                }\n                break;\n        }\n    }\n\n    unsigned char *count = (unsigned char *)(*((unsigned long long *)qword_75D408 + 9) + inodeNum);\n    unsigned char result = ++*count;\n    if (!result) {\n        puts(\"Warning: inode count too big\");\n        --*count;\n        *((unsigned char *)qword_75D408 + 2) = 1;\n    }\n}",
        "baseline_code_stripped": "unsigned __int64 __fastcall sub_49719D(unsigned int a1, unsigned __int16 a2)\n{\n  _BYTE *v2; // rax\n  unsigned __int64 result; // rax\n\n  ++*((_DWORD *)qword_75D408 + 10);\n  if ( *(_BYTE *)(*((_QWORD *)qword_75D408 + 9) + a1) )\n  {\n    ++*((_DWORD *)qword_75D408 + 8);\n  }\n  else\n  {\n    if ( !(unsigned int)sub_495DF1(*((_QWORD *)qword_75D408 + 7), a1) )\n    {\n      printf(\"Inode %d is marked as 'unused', but it is used for file '%s'\\n\", a1, (const char *)qword_75D408 + 5540);\n      if ( (dword_75D450 & 4) != 0 )\n      {\n        if ( (unsigned int)sub_49602F((__int64)\"Mark as 'in use'\", 1u) )\n          sub_495E26(*((_QWORD *)qword_75D408 + 7), a1);\n        else\n          *((_BYTE *)qword_75D408 + 2) = 1;\n      }\n    }\n    switch ( a2 & 0xF000 )\n    {\n      case 16384:\n        ++*((_DWORD *)qword_75D408 + 4);\n        break;\n      case 32768:\n        ++*((_DWORD *)qword_75D408 + 5);\n        break;\n      case 8192:\n        ++*((_DWORD *)qword_75D408 + 7);\n        break;\n      case 24576:\n        ++*((_DWORD *)qword_75D408 + 6);\n        break;\n      case 40960:\n        ++*((_DWORD *)qword_75D408 + 9);\n        break;\n      default:\n        if ( (a2 & 0xF000) != 49152 && (a2 & 0xF000) != 4096 )\n          printf(\"%s has mode %05o\\n\", (const char *)qword_75D408 + 5540, a2);\n        break;\n    }\n  }\n  v2 = (_BYTE *)(*((_QWORD *)qword_75D408 + 9) + a1);\n  result = (unsigned __int8)++*v2;\n  if ( !(_BYTE)result )\n  {\n    puts(\"Warning: inode count too big\");\n    --*(_BYTE *)(*((_QWORD *)qword_75D408 + 9) + a1);\n    result = (unsigned __int64)qword_75D408;\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl get_inode_common(unsigned int nr, uint16_t i_mode)\n{\n  _BYTE *v2; // rax\n\n  ++LODWORD(ptr_to_globals->issue);\n  if ( *(_BYTE *)(*(_QWORD *)&ptr_to_globals->speeds[5] + nr) )\n  {\n    ++LODWORD(ptr_to_globals->initstring);\n  }\n  else\n  {\n    if ( !minix_bit(*(const char **)&ptr_to_globals->speeds[1], nr) )\n    {\n      printf(\n        \"Inode %d is marked as 'unused', but it is used for file '%s'\\n\",\n        nr,\n        (const char *)&ptr_to_globals[19].speeds[4]);\n      if ( (option_mask32 & 4) != 0 )\n      {\n        if ( ask(\"Mark as 'in use'\", 1) )\n          minix_setbit(*(char **)&ptr_to_globals->speeds[1], nr);\n        else\n          BYTE2(ptr_to_globals->timeout) = 1;\n      }\n    }\n    switch ( i_mode & 0xF000 )\n    {\n      case 16384:\n        ++LODWORD(ptr_to_globals->fakehost);\n        break;\n      case 32768:\n        ++HIDWORD(ptr_to_globals->fakehost);\n        break;\n      case 8192:\n        ++HIDWORD(ptr_to_globals->tty_name);\n        break;\n      case 24576:\n        ++LODWORD(ptr_to_globals->tty_name);\n        break;\n      case 40960:\n        ++HIDWORD(ptr_to_globals->initstring);\n        break;\n      default:\n        if ( (i_mode & 0xF000) != 49152 && (i_mode & 0xF000) != 4096 )\n          printf(\"%s has mode %05o\\n\", (const char *)&ptr_to_globals[19].speeds[4], i_mode);\n        break;\n    }\n  }\n  v2 = (_BYTE *)(*(_QWORD *)&ptr_to_globals->speeds[5] + nr);\n  if ( !++*v2 )\n  {\n    puts(\"Warning: inode count too big\");\n    --*(_BYTE *)(*(_QWORD *)&ptr_to_globals->speeds[5] + nr);\n    BYTE2(ptr_to_globals->timeout) = 1;\n  }\n}\n",
        "similarity_score_unixcoder": 0.7077256441116333,
        "similarity_score_baseline_stripped": 0.4998070001602173,
        "similarity_score_baseline_debug": 0.5987103581428528
    },
    {
        "func_name": "print_selected_addrinfo",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48DACE(__int64 a1)\n{\n  int v2; // [rsp+1Ch] [rbp-4h]\n\n  if ( *(_QWORD *)(a1 + 8) )\n    return sub_40A999(*(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 4LL), 2u, 0);\n  v2 = sub_40BCE2();\n  if ( (unsigned int)(v2 - *(_DWORD *)(a1 + 4)) <= 0x77 )\n    return 0xFFFFFFFFLL;\n  *(_DWORD *)(a1 + 4) = v2;\n  *(_QWORD *)(a1 + 8) = sub_50BB00(*(_QWORD *)(a1 + 16), 514LL);\n  if ( *(_QWORD *)(a1 + 8) )\n    return sub_40A999(*(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 4LL), 2u, 0);\n  else\n    return 0xFFFFFFFFLL;\n}\n\n\n Revised code:\nif ENABLE_FEATURE_REMOTE_LOG\nstatic int try_to_resolve_remote(remoteHost_t *rh)\n{\n\tif (!rh->remoteAddr) {\n\t\tunsigned now = monotonic_sec();\n\n\t\t/* Don't resolve name too often - DNS timeouts can be big */\n\t\tif ((now - rh->last_dns_resolve) < DNS_WAIT_SEC)\n\t\t\treturn -1;\n\t\trh->last_dns_resolve = now;\n\t\trh->remoteAddr = host2sockaddr(rh->remoteHostname, 514);\n\t\tif (!rh->remoteAddr)\n\t\t\treturn -1;\n\t}\n\treturn xsocket(rh->remoteAddr->u.sa.sa_family, SOCK_DGRAM, 0);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4517B7(_DWORD *a1, signed int a2, __int16 a3, int a4)\n{\n  char *v5; // [rsp+14h] [rbp-10h]\n\n  if ( a2 < (int)(((*a1 + 3) & 0xFFFFFFFC) + 8) )\n    return 0xFFFFFFFFLL;\n  v5 = (char *)a1 + ((*a1 + 3) & 0xFFFFFFFC);\n  *((_WORD *)v5 + 1) = a3;\n  *(_WORD *)v5 = 8;\n  *((_DWORD *)v5 + 1) = a4;\n  *a1 = ((*a1 + 3) & 0xFFFFFFFC) + 8;\n  return 0LL;\n}\n\n\n Revised code:\nint FAST_FUNC addattr32(struct nlmsghdr *n, int maxlen, int type, uint32_t data)\n{\n\tint len = RTA_LENGTH(4);\n\tstruct rtattr *rta;\n\n\tif ((int)(NLMSG_ALIGN(n->nlmsg_len) + len) > maxlen) {\n\t\treturn -1;\n\t}\n\trta = (struct rtattr*)(((char*)n) + NLMSG_ALIGN(n->nlmsg_len));\n\trta->rta_type = type;\n\trta->rta_len = len;\n\tmove_to_unaligned32(RTA_DATA(rta), data);\n\tn->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + len;\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4519A9(_WORD *a1, unsigned int a2, __int16 a3, const void *a4, int a5)\n{\n  _WORD *v6; // [rsp+20h] [rbp-10h]\n  __int16 v7; // [rsp+2Ch] [rbp-4h]\n\n  v7 = a5 + 4;\n  if ( a5 + 4 + (((unsigned __int16)*a1 + 3) & 0xFFFFFFFC) > a2 )\n    return 0xFFFFFFFFLL;\n  v6 = (_WORD *)((char *)a1 + (((unsigned __int16)*a1 + 3) & 0xFFFFFFFC));\n  v6[1] = a3;\n  *v6 = v7;\n  memcpy(v6 + 2, a4, a5);\n  *a1 = v7 + ((*a1 + 3) & 0xFFFC);\n  return 0LL;\n}\n\n\n Revised code:\nint FAST_FUNC rta_addattr_l(struct rtattr *rta, int maxlen, int type, void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif (RTA_ALIGN(rta->rta_len) + len > maxlen) {\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + len;\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_44A9F7(int a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  _WORD *v8; // [rsp+18h] [rbp-8h]\n\n  while ( a2 )\n  {\n    v8 = a2 + 1;\n    if ( *((_WORD *)a2 + 6) == 20 )\n    {\n      if ( *(_DWORD *)v8 <= 0x17u )\n        return 0xFFFFFFFFLL;\n      if ( *((_DWORD *)a2 + 7) == a1\n        && (!LOBYTE(dest.c_ispeed) || SLOBYTE(dest.c_ispeed) == *((unsigned __int8 *)a2 + 24)) )\n      {\n        sub_44A1F6(0LL, v8, 0LL, a4, a5, a6);\n      }\n    }\n    a2 = (__int64 *)*a2;\n  }\n  return 0LL;\n}\n",
        "output": "int FAST_FUNC process_data(int a1, struct data_struct *data, int a3, int a4, int a5, int a6)\n{\n    struct data_struct *next_data;\n\n    while (data)\n    {\n        next_data = data->next;\n        if (data->type == 20)\n        {\n            if (data->value <= 0x17)\n                return -1;\n            if (data->id == a1 && (!dest.c_ispeed || dest.c_ispeed == data->speed))\n            {\n                sub_44A1F6(0, next_data, 0, a4, a5, a6);\n            }\n        }\n        data = next_data;\n    }\n    return 0;\n}",
        "source_code": "static int print_selected_addrinfo(int ifindex, struct nlmsg_list *ainfo)\n{\n\tfor (; ainfo; ainfo = ainfo->next) {\n\t\tstruct nlmsghdr *n = &ainfo->h;\n\t\tstruct ifaddrmsg *ifa = NLMSG_DATA(n);\n\n\t\tif (n->nlmsg_type != RTM_NEWADDR)\n\t\t\tcontinue;\n\t\tif (n->nlmsg_len < NLMSG_LENGTH(sizeof(ifa)))\n\t\t\treturn -1;\n\t\tif (ifa->ifa_index != ifindex\n\t\t || (G_filter.family && G_filter.family != ifa->ifa_family)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\t\tprint_addrinfo(NULL, n, NULL);\n\t}\n\treturn 0;\n}",
        "parsed_output": "int FAST_FUNC process_data(int a1, struct data_struct *data, int a3, int a4, int a5, int a6)\n{\n    struct data_struct *next_data;\n\n    while (data)\n    {\n        next_data = data->next;\n        if (data->type == 20)\n        {\n            if (data->value <= 0x17)\n                return -1;\n            if (data->id == a1 && (!dest.c_ispeed || dest.c_ispeed == data->speed))\n            {\n                sub_44A1F6(0, next_data, 0, a4, a5, a6);\n            }\n        }\n        data = next_data;\n    }\n    return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_44A9F7(int a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  _WORD *v8; // [rsp+18h] [rbp-8h]\n\n  while ( a2 )\n  {\n    v8 = a2 + 1;\n    if ( *((_WORD *)a2 + 6) == 20 )\n    {\n      if ( *(_DWORD *)v8 <= 0x17u )\n        return 0xFFFFFFFFLL;\n      if ( *((_DWORD *)a2 + 7) == a1\n        && (!LOBYTE(dest.c_ispeed) || SLOBYTE(dest.c_ispeed) == *((unsigned __int8 *)a2 + 24)) )\n      {\n        sub_44A1F6(0LL, v8, 0LL, a4, a5, a6);\n      }\n    }\n    a2 = (__int64 *)*a2;\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl print_selected_addrinfo(int ifindex, nlmsg_list *ainfo)\n{\n  nlmsghdr *n; // [rsp+18h] [rbp-8h]\n\n  while ( ainfo )\n  {\n    n = &ainfo->h;\n    if ( ainfo->h.nlmsg_type == 20 )\n    {\n      if ( n->nlmsg_len <= 0x17 )\n        return -1;\n      if ( HIDWORD(ainfo[1].next) == ifindex\n        && (!LOBYTE(bb_common_bufsiz1.c_ispeed) || SLOBYTE(bb_common_bufsiz1.c_ispeed) == LOBYTE(ainfo[1].next)) )\n      {\n        print_addrinfo(0LL, n, 0LL);\n      }\n    }\n    ainfo = ainfo->next;\n  }\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.4907485246658325,
        "similarity_score_baseline_stripped": 0.38282331824302673,
        "similarity_score_baseline_debug": 0.8112996220588684
    },
    {
        "func_name": "rollback_token",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nchar *sub_4B11D5()\n{\n  char *result; // rax\n\n  *((_WORD *)qword_75D408 - 7) = 0;\n  result = (char *)qword_75D408 - 88;\n  *((_DWORD *)qword_75D408 - 3) = 0;\n  return result;\n}\n\n\n Revised code:\nstatic void bi_init(void)\n{\n\tG1.bi_buf = 0;\n\tG1.bi_valid = 0;\n#ifdef DEBUG\n\tG1.bits_sent = 0L;\n#endif\n}\n\n## Example:\n\n Input code:\nvoid *sub_4249C8()\n{\n  void *result; // rax\n\n  result = qword_75D408;\n  *((_DWORD *)qword_75D408 + 7) = 0;\n  return result;\n}\n\n\n Revised code:\nstatic void reset_stringbuf(void)\n{\n\tstringbuf_idx = 0;\n}\n\n## Example:\n\n Input code:\nvoid *sub_4EEE98()\n{\n  void *result; // rax\n\n  *((_DWORD *)qword_75D408 + 44) = 26;\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 118) = 0;\n  return result;\n}\n\n\n Revised code:\nstatic void end_cmd_q(void)\n{\n#if ENABLE_FEATURE_VI_YANKMARK\n\tYDreg = 26;\t\t\t// go back to default Yank/Delete reg\n#endif\n\tadding2q = 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *sub_4DD839()\n{\n  char *result; // rax\n\n  result = (char *)qword_75D408 - 208;\n  *((char *)qword_75D408 - 3) = 1;\n  return result;\n}\n",
        "output": "static void initialize_data()\n{\n    data_ptr = (char *)qword_75D408 - 208;\n    *((char *)qword_75D408 - 3) = 1;\n}",
        "source_code": "static void rollback_token(void)\n{\n\tt_rollback = TRUE;\n}",
        "parsed_output": "static void initialize_data()\n{\n    data_ptr = (char *)qword_75D408 - 208;\n    *((char *)qword_75D408 - 3) = 1;\n}",
        "baseline_code_stripped": "char *sub_4DD839()\n{\n  char *result; // rax\n\n  result = (char *)qword_75D408 - 208;\n  *((char *)qword_75D408 - 3) = 1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl rollback_token()\n{\n  ptr_to_globals[-1].line_buf[129] = 1;\n}\n",
        "similarity_score_unixcoder": 0.378207802772522,
        "similarity_score_baseline_stripped": 0.4244038462638855,
        "similarity_score_baseline_debug": 0.6741553544998169
    },
    {
        "func_name": "remove_chunk",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A3D68(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+0h] [rbp-1Ch]\n  int v4; // [rsp+14h] [rbp-8h]\n  unsigned int i; // [rsp+18h] [rbp-4h]\n\n  v3 = a2;\n  if ( a2 )\n  {\n    v3 = a2 - 1;\n    if ( a2 != 1 && *(_DWORD *)(4LL * v3 + a1) == 10 )\n      v3 = a2 - 2;\n  }\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i >= v3 )\n      break;\n    v4 = *(_DWORD *)(4LL * (int)i + a1);\n    *(_DWORD *)(4LL * (int)i + a1) = *(_DWORD *)(4LL * v3 + a1);\n    *(_DWORD *)(a1 + 4LL * v3--) = v4;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void strrev(CHAR_T *s, int len)\n{\n\tint i;\n\n\tif (len != 0) {\n\t\tlen--;\n\t\tif (len != 0 && s[len] == '\\n')\n\t\t\tlen--;\n\t}\n\n\tfor (i = 0; i < len; i++, len--) {\n\t\tCHAR_T c = s[i];\n\t\ts[i] = s[len];\n\t\ts[len] = c;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A8B04(__int64 a1, int a2, int a3, int a4)\n{\n  __int64 result; // rax\n  unsigned int v8; // [rsp+20h] [rbp-4h]\n\n  while ( a4 > 0 )\n  {\n    v8 = *(_DWORD *)(4LL * a2 + a1);\n    *(_DWORD *)(4LL * a2 + a1) = *(_DWORD *)(4LL * a3 + a1);\n    result = v8;\n    *(_DWORD *)(a1 + 4LL * a3) = v8;\n    ++a2;\n    ++a3;\n    --a4;\n  }\n  return result;\n}\n\n\n Revised code:\nvoid mvswap(uint32_t* ptr, int32_t zzp1, int32_t zzp2, int32_t zzn)\n{\n\twhile (zzn > 0) {\n\t\tmswap(ptr[zzp1], ptr[zzp2]);\n\t\tzzp1++;\n\t\tzzp2++;\n\t\tzzn--;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4DF387(int *a1, __int64 a2)\n{\n  int v2; // eax\n  __int64 result; // rax\n  __int64 v4; // [rsp+10h] [rbp-20h]\n  __int64 v5; // [rsp+18h] [rbp-18h]\n  __int64 v6; // [rsp+24h] [rbp-Ch]\n  __int64 i; // [rsp+28h] [rbp-8h]\n\n  if ( (*a1 & 0x800) != 0 )\n  {\n    v5 = *((_QWORD *)a1 + 3);\n  }\n  else\n  {\n    v2 = *a1;\n    BYTE1(v2) = BYTE1(*a1) | 8;\n    *a1 = v2;\n    v5 = 0LL;\n  }\n  *((_QWORD *)a1 + 3) = sub_40A0E8(*(unsigned int *)(a2 + 12) + 33LL, a2);\n  v4 = *((_QWORD *)a1 + 3);\n  *(_QWORD *)v4 = v4 + 24;\n  *(_QWORD *)(v4 + 8) = *(_QWORD *)v4;\n  *(_QWORD *)(v4 + 16) = v5;\n  LODWORD(v6) = 0;\n  while ( 1 )\n  {\n    result = *(unsigned int *)(a2 + 4);\n    if ( (unsigned int)v6 >= (unsigned int)result )\n      break;\n    for ( i = *(_QWORD *)(8LL * (unsigned int)v6 + *(_QWORD *)(a2 + 16)); i; i = *(_QWORD *)(i + 32) )\n    {\n      strcpy(*(char **)v4, (const char *)(i + 40));\n      sub_4DC55F((__int64 *)v4);\n    }\n    v6 = (unsigned int)(v6 + 1);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void hashwalk_init(var *v, xhash *array)\n{\n\thash_item *hi;\n\tunsigned i;\n\twalker_list *w;\n\twalker_list *prev_walker;\n\n\tif (v->type & VF_WALK) {\n\t\tprev_walker = v->x.walker;\n\t} else {\n\t\tv->type |= VF_WALK;\n\t\tprev_walker = NULL;\n\t}\n\tdebug_printf_walker(\"hashwalk_init: prev_walker:%p\\n\", prev_walker);\n\n\tw = v->x.walker = xzalloc(sizeof(*w) + array->glen + 1); /* why + 1? */\n\tdebug_printf_walker(\" walker@%p=%p\\n\", &v->x.walker, w);\n\tw->cur = w->end = w->wbuf;\n\tw->prev = prev_walker;\n\tfor (i = 0; i < array->csize; i++) {\n\t\thi = array->items[i];\n\t\twhile (hi) {\n\t\t\tstrcpy(w->end, hi->name);\n\t\t\tnextword(&w->end);\n\t\t\thi = hi->next;\n\t\t}\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4FEB8C(__int64 a1, unsigned int a2, int a3)\n{\n  __int64 result; // rax\n  _WORD *v4; // rax\n  int v5; // [rsp+0h] [rbp-10h]\n  unsigned int v6; // [rsp+4h] [rbp-Ch]\n\n  v6 = a2;\n  v5 = a3;\n  result = a2;\n  if ( a2 != a3 )\n  {\n    while ( 1 )\n    {\n      v4 = (_WORD *)(2LL * (int)v6 + a1);\n      *v4 = *(_WORD *)(a1 + 2LL * v5);\n      result = (unsigned __int16)*v4;\n      if ( !(_WORD)result )\n        break;\n      ++v6;\n      ++v5;\n    }\n  }\n  return result;\n}\n",
        "output": "static void copy_words(__int16 *dest, __int16 *src, unsigned int len)\n{\n    unsigned int i;\n\n    for (i = 0; i < len; i++) {\n        dest[i] = src[i];\n        if (src[i] == 0)\n            break;\n    }\n}",
        "source_code": "static void remove_chunk(int16_t *int_buf, int beg, int end)\n{\n\t/* beg must be <= end */\n\tif (beg == end)\n\t\treturn;\n\n\twhile ((int_buf[beg] = int_buf[end]) != 0)\n\t\tbeg++, end++;\n\n\tif (dbg_bmp) {\n\t\tint i;\n\t\tfor (i = 0; int_buf[i]; i++)\n\t\t\tbb_putchar((unsigned char)int_buf[i]);\n\t\tbb_putchar('\\n');\n\t}\n}",
        "parsed_output": "static void copy_words(__int16 *dest, __int16 *src, unsigned int len)\n{\n    unsigned int i;\n\n    for (i = 0; i < len; i++) {\n        dest[i] = src[i];\n        if (src[i] == 0)\n            break;\n    }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4FEB8C(__int64 a1, unsigned int a2, int a3)\n{\n  __int64 result; // rax\n  _WORD *v4; // rax\n  int v5; // [rsp+0h] [rbp-10h]\n  unsigned int v6; // [rsp+4h] [rbp-Ch]\n\n  v6 = a2;\n  v5 = a3;\n  result = a2;\n  if ( a2 != a3 )\n  {\n    while ( 1 )\n    {\n      v4 = (_WORD *)(2LL * (int)v6 + a1);\n      *v4 = *(_WORD *)(a1 + 2LL * v5);\n      result = (unsigned __int16)*v4;\n      if ( !(_WORD)result )\n        break;\n      ++v6;\n      ++v5;\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl remove_chunk(int16_t *int_buf, int beg, int end)\n{\n  int16_t *v3; // rax\n  int enda; // [rsp+0h] [rbp-10h]\n  int bega; // [rsp+4h] [rbp-Ch]\n\n  bega = beg;\n  enda = end;\n  if ( beg != end )\n  {\n    while ( 1 )\n    {\n      v3 = &int_buf[bega];\n      *v3 = int_buf[enda];\n      if ( !*v3 )\n        break;\n      ++bega;\n      ++enda;\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.6426445245742798,
        "similarity_score_baseline_stripped": 0.4966309070587158,
        "similarity_score_baseline_debug": 0.7912651896476746
    },
    {
        "func_name": "makejob",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_492E03(int *a1)\n{\n  unsigned int v2; // [rsp+14h] [rbp-24h]\n  int v3; // [rsp+2Ch] [rbp-Ch]\n  unsigned int i; // [rsp+30h] [rbp-8h]\n  unsigned int v5; // [rsp+34h] [rbp-4h]\n\n  v5 = 0;\n  v3 = 0;\n  for ( i = 0; ; ++i )\n  {\n    if ( i >= *((_DWORD *)qword_75D408 + 4) )\n      return 0LL;\n    if ( i == 4 )\n    {\n      v3 = 4;\n      v5 = 0;\n    }\n    if ( *(_BYTE *)(*((_QWORD *)qword_75D408 + 5 * i + 313) + 4LL) )\n      break;\nLABEL_10:\n    ;\n  }\n  v2 = sub_490A13((__int64)qword_75D408 + 40 * i + 2504);\n  if ( v5 <= v2 )\n  {\n    v5 = v2;\n    v3 = i;\n    goto LABEL_10;\n  }\n  if ( a1 )\n    *a1 = v3;\n  return i;\n}\n\n\n Revised code:\nstatic int\nwrong_p_order(int *prev)\n{\n\tconst struct pte *pe;\n\tconst struct partition *p;\n\tsector_t last_p_start_pos = 0, p_start_pos;\n\tunsigned i, last_i = 0;\n\n\tfor (i = 0; i < g_partitions; i++) {\n\t\tif (i == 4) {\n\t\t\tlast_i = 4;\n\t\t\tlast_p_start_pos = 0;\n\t\t}\n\t\tpe = &ptes[i];\n\t\tp = pe->part_table;\n\t\tif (p->sys_ind) {\n\t\t\tp_start_pos = get_partition_start_from_dev_start(pe);\n\n\t\t\tif (last_p_start_pos > p_start_pos) {\n\t\t\t\tif (prev)\n\t\t\t\t\t*prev = last_i;\n\t\t\t\treturn i;\n\t\t\t}\n\n\t\t\tlast_p_start_pos = p_start_pos;\n\t\t\tlast_i = i;\n\t\t}\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47DFAC(int a1, __int64 a2)\n{\n  _QWORD v3[5]; // [rsp+10h] [rbp-40h] BYREF\n  int v4; // [rsp+3Ch] [rbp-14h]\n  char *v5; // [rsp+40h] [rbp-10h]\n  int v6; // [rsp+48h] [rbp-8h]\n  int v7; // [rsp+4Ch] [rbp-4h]\n\n  v6 = 0;\n  while ( 1 )\n  {\n    sub_46E8A1(v3);\n    if ( byte_75AF98 )\n    {\n      a2 = 4LL;\n      sub_471D7E(stderr, 4);\n    }\n    v7 = 0;\n    if ( *(_BYTE *)(qword_75D418 + 60) && a1 )\n      ++v7;\n    v5 = (char *)sub_47DC41(v7);\n    if ( v5 != (char *)-1LL )\n    {\n      if ( !*(_BYTE *)(qword_75D418 + 62) )\n      {\n        *(char *)(qword_75D418 + 748) >>= 1;\n        v6 = 0;\n        a2 = 0LL;\n        sub_4781FB(v5, 0);\n      }\n      goto LABEL_16;\n    }\n    if ( !a1 || v6 > 49 )\n      return 0LL;\n    if ( !(unsigned int)sub_472FFC() )\n    {\n      if ( !*(_BYTE *)(qword_75D418 + 59) )\n        return 0LL;\n      sub_46E2EB(\"\\nUse \\\"exit\\\" to leave shell.\\n\");\n    }\n    ++v6;\nLABEL_16:\n    sub_46E905(v3, a2);\n    v4 = byte_75B040;\n    if ( byte_75B040 )\n    {\n      byte_75B040 = 0;\n      return v4 & 0x10;\n    }\n  }\n}\n\n\n Revised code:\nstatic int\ncmdloop(int top)\n{\n\tunion node *n;\n\tstruct stackmark smark;\n\tint inter;\n\tint numeof = 0;\n\n\tTRACE((\"cmdloop(%d) called\\n\", top));\n\tfor (;;) {\n\t\tint skip;\n\n\t\tsetstackmark(&smark);\n#if JOBS\n\t\tif (doing_jobctl)\n\t\t\tshowjobs(stderr, SHOW_CHANGED);\n#endif\n\t\tinter = 0;\n\t\tif (iflag && top) {\n\t\t\tinter++;\n\t\t\tchkmail();\n\t\t}\n\t\tn = parsecmd(inter);\n#if DEBUG\n\t\tif (DEBUG > 2 && debug && (n != NODE_EOF))\n\t\t\tshowtree(n);\n#endif\n\t\tif (n == NODE_EOF) {\n\t\t\tif (!top || numeof >= 50)\n\t\t\t\tbreak;\n\t\t\tif (!stoppedjobs()) {\n\t\t\t\tif (!Iflag)\n\t\t\t\t\tbreak;\n\t\t\t\tout2str(\"\\nUse \\\"exit\\\" to leave shell.\\n\");\n\t\t\t}\n\t\t\tnumeof++;\n\t\t} else if (nflag == 0) {\n\t\t\t/* job_warning can only be 2,1,0. Here 2->1, 1/0->0 */\n\t\t\tjob_warning >>= 1;\n\t\t\tnumeof = 0;\n\t\t\tevaltree(n, 0);\n\t\t}\n\t\tpopstackmark(&smark);\n\t\tskip = evalskip;\n\n\t\tif (skip) {\n\t\t\tevalskip = 0;\n\t\t\treturn skip & SKIPEVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_478959(__int64 a1, unsigned int a2)\n{\n  __int64 v2; // rsi\n  char *v3; // rdi\n  unsigned int v5; // [rsp+4h] [rbp-1Ch]\n  char *v7; // [rsp+10h] [rbp-10h]\n  int v8; // [rsp+18h] [rbp-8h]\n  char v9; // [rsp+1Ch] [rbp-4h]\n\n  v5 = a2;\n  v8 = *(_BYTE *)a1 == 3;\n  sub_478A54(*(_QWORD *)(a1 + 16));\n  if ( v8 || (a2 & 1) == 0 || *(_BYTE *)(qword_75D418 + 200) )\n  {\n    ++*(_DWORD *)(qword_75D418 + 48);\n    v7 = sub_472265(1);\n    v2 = a1;\n    v3 = v7;\n    if ( (unsigned int)sub_472EC3(v7, (const char *)a1, v8) )\n      goto LABEL_8;\n    sub_46E03F(v7, a1);\n    v5 |= 1u;\n    if ( v8 )\n      v5 &= ~2u;\n  }\n  sub_4735BF(*(_QWORD *)(a1 + 16), 0LL);\n  v2 = v5;\n  v3 = *(char **)(a1 + 8);\n  sub_4781FB(v3, v5);\nLABEL_8:\n  v9 = 0;\n  if ( !v8 )\n  {\n    v3 = v7;\n    v9 = sub_472F50((__int64)v7, v2);\n  }\n  byte_75AF50 = v9;\n  return sub_46E03F(v3, v2);\n}\n\n\n Revised code:\nstatic void\nevalsubshell(union node *n, int flags)\n{\n\tstruct job *jp;\n\tint backgnd = (n->type == NBACKGND);\n\tint status;\n\n\texpredir(n->nredir.redirect);\n\tif (!backgnd && (flags & EV_EXIT) && !may_have_traps)\n\t\tgoto nofork;\n\tINT_OFF;\n\tjp = makejob(/*n,*/ 1);\n\tif (forkshell(jp, n, backgnd) == 0) {\n\t\t/* child */\n\t\tINT_ON;\n\t\tflags |= EV_EXIT;\n\t\tif (backgnd)\n\t\t\tflags &= ~EV_TESTED;\n nofork:\n\t\tredirect(n->nredir.redirect, 0);\n\t\tevaltreenr(n->nredir.n, flags);\n\t\t/* never returns */\n\t}\n\tstatus = 0;\n\tif (!backgnd)\n\t\tstatus = waitforjob(jp);\n\texitstatus = status;\n\tINT_ON;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_472265(int a1)\n{\n  char *s; // [rsp+10h] [rbp-10h]\n  int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = dword_75AFA8;\n  for ( s = (char *)qword_75AFA0; ; s += 40 )\n  {\n    if ( --v3 < 0 )\n    {\n      s = sub_4720F1();\n      goto LABEL_10;\n    }\n    if ( (s[31] & 8) == 0 )\n      goto LABEL_10;\n    if ( s[30] == 2 && (s[31] & 4) != 0 && !byte_75AF98 )\n      break;\n  }\n  sub_47107C((__int64)s);\nLABEL_10:\n  memset(s, 0, 0x28uLL);\n  if ( byte_75AF98 )\n    s[31] |= 2u;\n  *((_QWORD *)s + 4) = qword_75AFB0;\n  qword_75AFB0 = (__int64)s;\n  s[31] |= 8u;\n  *((_QWORD *)s + 2) = s;\n  if ( a1 > 1 )\n    *((_QWORD *)s + 2) = sub_40A05F(16LL * a1, 0LL);\n  return s;\n}\n",
        "output": "static char *\nget_string(int index)\n{\n\tchar *str;\n\tint count = string_count;\n\n\tfor (str = strings; ; str += 40) {\n\t\tif (--count < 0) {\n\t\t\tstr = get_default_string();\n\t\t\tgoto LABEL_10;\n\t\t}\n\t\tif ((str[31] & 8) == 0)\n\t\t\tgoto LABEL_10;\n\t\tif (str[30] == 2 && (str[31] & 4) != 0 && !flag)\n\t\t\tbreak;\n\t}\n\tprocess_string((__int64)str);\nLABEL_10:\n\tmemset(str, 0, 0x28uLL);\n\tif (flag)\n\t\tstr[31] |= 2u;\n\t*((_QWORD *)str + 4) = string_ptr;\n\tstring_ptr = (__int64)str;\n\tstr[31] |= 8u;\n\t*((_QWORD *)str + 2) = str;\n\tif (index > 1)\n\t\t*((_QWORD *)str + 2) = allocate_memory(16LL * index, 0LL);\n\treturn str;\n}",
        "source_code": "static struct job *\nmakejob(/*union node *node,*/ int nprocs)\n{\n\tint i;\n\tstruct job *jp;\n\n\tfor (i = njobs, jp = jobtab; ; jp++) {\n\t\tif (--i < 0) {\n\t\t\tjp = growjobtab();\n\t\t\tbreak;\n\t\t}\n\t\tif (jp->used == 0)\n\t\t\tbreak;\n\t\tif (jp->state != JOBDONE || !jp->waited)\n\t\t\tcontinue;\n#if JOBS\n\t\tif (doing_jobctl)\n\t\t\tcontinue;\n#endif\n\t\tfreejob(jp);\n\t\tbreak;\n\t}\n\tmemset(jp, 0, sizeof(*jp));\n#if JOBS\n\t/* jp->jobctl is a bitfield.\n\t * \"jp->jobctl |= jobctl\" likely to give awful code */\n\tif (doing_jobctl)\n\t\tjp->jobctl = 1;\n#endif\n\tjp->prev_job = curjob;\n\tcurjob = jp;\n\tjp->used = 1;\n\tjp->ps = &jp->ps0;\n\tif (nprocs > 1) {\n\t\tjp->ps = ckmalloc(nprocs * sizeof(struct procstat));\n\t}\n\tTRACE((\"makejob(%d) returns %%%d\\n\", nprocs,\n\t\t\t\tjobno(jp)));\n\treturn jp;\n}",
        "parsed_output": "static char *\nget_string(int index)\n{\n\tchar *str;\n\tint count = string_count;\n\n\tfor (str = strings; ; str += 40) {\n\t\tif (--count < 0) {\n\t\t\tstr = get_default_string();\n\t\t\tgoto LABEL_10;\n\t\t}\n\t\tif ((str[31] & 8) == 0)\n\t\t\tgoto LABEL_10;\n\t\tif (str[30] == 2 && (str[31] & 4) != 0 && !flag)\n\t\t\tbreak;\n\t}\n\tprocess_string((__int64)str);\nLABEL_10:\n\tmemset(str, 0, 0x28uLL);\n\tif (flag)\n\t\tstr[31] |= 2u;\n\t*((_QWORD *)str + 4) = string_ptr;\n\tstring_ptr = (__int64)str;\n\tstr[31] |= 8u;\n\t*((_QWORD *)str + 2) = str;\n\tif (index > 1)\n\t\t*((_QWORD *)str + 2) = allocate_memory(16LL * index, 0LL);\n\treturn str;\n}",
        "baseline_code_stripped": "char *__fastcall sub_472265(int a1)\n{\n  char *s; // [rsp+10h] [rbp-10h]\n  int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = dword_75AFA8;\n  for ( s = (char *)qword_75AFA0; ; s += 40 )\n  {\n    if ( --v3 < 0 )\n    {\n      s = sub_4720F1();\n      goto LABEL_10;\n    }\n    if ( (s[31] & 8) == 0 )\n      goto LABEL_10;\n    if ( s[30] == 2 && (s[31] & 4) != 0 && !byte_75AF98 )\n      break;\n  }\n  sub_47107C((__int64)s);\nLABEL_10:\n  memset(s, 0, 0x28uLL);\n  if ( byte_75AF98 )\n    s[31] |= 2u;\n  *((_QWORD *)s + 4) = qword_75AFB0;\n  qword_75AFB0 = (__int64)s;\n  s[31] |= 8u;\n  *((_QWORD *)s + 2) = s;\n  if ( a1 > 1 )\n    *((_QWORD *)s + 2) = sub_40A05F(16LL * a1, 0LL);\n  return s;\n}\n",
        "baseline_code_debug": "job *__cdecl makejob(int nprocs)\n{\n  job *jp; // [rsp+10h] [rbp-10h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  i = njobs;\n  for ( jp = jobtab; ; ++jp )\n  {\n    if ( --i < 0 )\n    {\n      jp = growjobtab();\n      goto LABEL_10;\n    }\n    if ( (*((_BYTE *)jp + 31) & 8) == 0 )\n      goto LABEL_10;\n    if ( *((_BYTE *)jp + 30) == 2 && (*((_BYTE *)jp + 31) & 4) != 0 && !doing_jobctl[0] )\n      break;\n  }\n  freejob(jp);\nLABEL_10:\n  memset(jp, 0, sizeof(job));\n  if ( doing_jobctl[0] )\n    *((_BYTE *)jp + 31) |= 2u;\n  jp->prev_job = curjob;\n  curjob = jp;\n  *((_BYTE *)jp + 31) |= 8u;\n  jp->ps = &jp->ps0;\n  if ( nprocs > 1 )\n    jp->ps = (procstat *)xmalloc(16LL * nprocs);\n  return jp;\n}\n",
        "similarity_score_unixcoder": 0.5764187574386597,
        "similarity_score_baseline_stripped": 0.5169031023979187,
        "similarity_score_baseline_debug": 0.8894658088684082
    },
    {
        "func_name": "hash_rebuild",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4DF387(int *a1, __int64 a2)\n{\n  int v2; // eax\n  __int64 result; // rax\n  __int64 v4; // [rsp+10h] [rbp-20h]\n  __int64 v5; // [rsp+18h] [rbp-18h]\n  __int64 v6; // [rsp+24h] [rbp-Ch]\n  __int64 i; // [rsp+28h] [rbp-8h]\n\n  if ( (*a1 & 0x800) != 0 )\n  {\n    v5 = *((_QWORD *)a1 + 3);\n  }\n  else\n  {\n    v2 = *a1;\n    BYTE1(v2) = BYTE1(*a1) | 8;\n    *a1 = v2;\n    v5 = 0LL;\n  }\n  *((_QWORD *)a1 + 3) = sub_40A0E8(*(unsigned int *)(a2 + 12) + 33LL, a2);\n  v4 = *((_QWORD *)a1 + 3);\n  *(_QWORD *)v4 = v4 + 24;\n  *(_QWORD *)(v4 + 8) = *(_QWORD *)v4;\n  *(_QWORD *)(v4 + 16) = v5;\n  LODWORD(v6) = 0;\n  while ( 1 )\n  {\n    result = *(unsigned int *)(a2 + 4);\n    if ( (unsigned int)v6 >= (unsigned int)result )\n      break;\n    for ( i = *(_QWORD *)(8LL * (unsigned int)v6 + *(_QWORD *)(a2 + 16)); i; i = *(_QWORD *)(i + 32) )\n    {\n      strcpy(*(char **)v4, (const char *)(i + 40));\n      sub_4DC55F((__int64 *)v4);\n    }\n    v6 = (unsigned int)(v6 + 1);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void hashwalk_init(var *v, xhash *array)\n{\n\thash_item *hi;\n\tunsigned i;\n\twalker_list *w;\n\twalker_list *prev_walker;\n\n\tif (v->type & VF_WALK) {\n\t\tprev_walker = v->x.walker;\n\t} else {\n\t\tv->type |= VF_WALK;\n\t\tprev_walker = NULL;\n\t}\n\tdebug_printf_walker(\"hashwalk_init: prev_walker:%p\\n\", prev_walker);\n\n\tw = v->x.walker = xzalloc(sizeof(*w) + array->glen + 1); /* why + 1? */\n\tdebug_printf_walker(\" walker@%p=%p\\n\", &v->x.walker, w);\n\tw->cur = w->end = w->wbuf;\n\tw->prev = prev_walker;\n\tfor (i = 0; i < array->csize; i++) {\n\t\thi = array->items[i];\n\t\twhile (hi) {\n\t\t\tstrcpy(w->end, hi->name);\n\t\t\tnextword(&w->end);\n\t\t\thi = hi->next;\n\t\t}\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_46F900(unsigned __int8 *a1)\n{\n  __int64 *v1; // rax\n  int v2; // eax\n  int v4; // [rsp+14h] [rbp-1Ch]\n  void *ptr; // [rsp+18h] [rbp-18h]\n  __int64 *v6; // [rsp+20h] [rbp-10h]\n  unsigned int v7; // [rsp+2Ch] [rbp-4h]\n\n  v1 = (__int64 *)sub_46F2C1(a1);\n  v6 = sub_46F3E8(v1, (char *)a1);\n  ptr = (void *)*v6;\n  v7 = 2;\n  if ( *v6 )\n  {\n    v4 = *((_DWORD *)ptr + 2);\n    v7 = 1;\n    if ( (v4 & 2) == 0 )\n    {\n      v2 = *((_DWORD *)ptr + 2);\n      BYTE1(v2) &= ~2u;\n      *((_DWORD *)ptr + 2) = v2;\n      if ( (v4 & 0x20) == 0 )\n      {\n        if ( (v4 & 4) != 0 )\n        {\n          sub_46F6BF((char *)a1, 0LL, 0);\n          *((_DWORD *)ptr + 2) &= ~1u;\n        }\n        else\n        {\n          ++*(_DWORD *)(qword_75D418 + 48);\n          if ( (v4 & 0x18) == 0 )\n            free(*((void **)ptr + 2));\n          *v6 = *(_QWORD *)ptr;\n          free(ptr);\n          sub_46E03F(ptr, a1);\n        }\n      }\n      return 0;\n    }\n  }\n  return v7;\n}\n\n\n Revised code:\nstatic int\nunsetvar(const char *s)\n{\n\tstruct var **vpp;\n\tstruct var *vp;\n\tint retval;\n\n\tvpp = findvar(hashvar(s), s);\n\tvp = *vpp;\n\tretval = 2;\n\tif (vp) {\n\t\tint flags = vp->flags;\n\n\t\tretval = 1;\n\t\tif (flags & VREADONLY)\n\t\t\tgoto out;\n#if ENABLE_ASH_RANDOM_SUPPORT\n\t\tvp->flags &= ~VDYNAMIC;\n#endif\n\t\tif (flags & VUNSET)\n\t\t\tgoto ok;\n\t\tif ((flags & VSTRFIXED) == 0) {\n\t\t\tINT_OFF;\n\t\t\tif ((flags & (VTEXTFIXED|VSTACK)) == 0)\n\t\t\t\tfree((char*)vp->var_text);\n\t\t\t*vpp = vp->next;\n\t\t\tfree(vp);\n\t\t\tINT_ON;\n\t\t} else {\n\t\t\tsetvar(s, 0, 0);\n\t\t\tvp->flags &= ~VEXPORT;\n\t\t}\n ok:\n\t\tretval = 0;\n\t}\n out:\n\treturn retval;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47778E(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  int v4; // [rsp+14h] [rbp-Ch]\n  unsigned int v5; // [rsp+18h] [rbp-8h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  v6 = 1;\n  v5 = 0;\n  v4 = 1;\n  if ( *(_QWORD *)(a2 + 8) && **(_BYTE **)(a2 + 8) == 45 )\n  {\n    v6 = 2;\n    v4 = 0;\n  }\n  while ( *(_QWORD *)(8LL * v6 + a2) )\n  {\n    v2 = v6++;\n    v5 |= sub_47752A(*(const char **)(8LL * v2 + a2), v4);\n  }\n  return v5;\n}\n\n\n Revised code:\nstatic int FAST_FUNC\ntypecmd(int argc UNUSED_PARAM, char **argv)\n{\n\tint i = 1;\n\tint err = 0;\n\tint verbose = 1;\n\n\t/* type -p ... ? (we don't bother checking for 'p') */\n\tif (argv[1] && argv[1][0] == '-') {\n\t\ti++;\n\t\tverbose = 0;\n\t}\n\twhile (argv[i]) {\n\t\terr |= describe_command(argv[i++], verbose);\n\t}\n\treturn err;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4DC1ED(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n  int v3; // eax\n  unsigned int v4; // [rsp+14h] [rbp-2Ch]\n  __int64 v5; // [rsp+18h] [rbp-28h]\n  _QWORD *v6; // [rsp+20h] [rbp-20h]\n  unsigned int v7; // [rsp+2Ch] [rbp-14h]\n  __int64 v8; // [rsp+30h] [rbp-10h]\n  unsigned int i; // [rsp+3Ch] [rbp-4h]\n\n  result = *(unsigned int *)(a1 + 8);\n  if ( (_DWORD)result != 5 )\n  {\n    v3 = *(_DWORD *)(a1 + 8);\n    *(_DWORD *)(a1 + 8) = v3 + 1;\n    v7 = (unsigned __int16)word_524914[v3];\n    v6 = sub_40A0E8(8LL * (unsigned __int16)word_524914[v3], a2);\n    for ( i = 0; i < *(_DWORD *)(a1 + 4); ++i )\n    {\n      v8 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 16));\n      while ( v8 )\n      {\n        v5 = v8;\n        v8 = *(_QWORD *)(v8 + 32);\n        v4 = (unsigned int)sub_4DC0E5((char *)(v5 + 40)) % v7;\n        *(_QWORD *)(v5 + 32) = v6[v4];\n        v6[v4] = v5;\n      }\n    }\n    free(*(void **)(a1 + 16));\n    *(_DWORD *)(a1 + 4) = v7;\n    result = a1;\n    *(_QWORD *)(a1 + 16) = v6;\n  }\n  return result;\n}\n",
        "output": "static void hash_table_init(hash_table *table, int size)\n{\n    table->size = size;\n    table->count = 0;\n    table->buckets = (hash_bucket *)malloc(sizeof(hash_bucket) * size);\n    memset(table->buckets, 0, sizeof(hash_bucket) * size);\n}\n\nstatic void hash_table_insert(hash_table *table, const char *key, void *value)\n{\n    unsigned int hash = hash_function(key) % table->size;\n    hash_bucket *bucket = &table->buckets[hash];\n    hash_entry *entry = (hash_entry *)malloc(sizeof(hash_entry));\n    entry->key = strdup(key);\n    entry->value = value;\n    entry->next = bucket->head;\n    bucket->head = entry;\n    table->count++;\n}\n\nstatic void hash_table_destroy(hash_table *table)\n{\n    for (int i = 0; i < table->size; i++)\n    {\n        hash_bucket *bucket = &table->buckets[i];\n        hash_entry *entry = bucket->head;\n        while (entry != NULL)\n        {\n            hash_entry *next = entry->next;\n            free(entry->key);\n            free(entry);\n            entry = next;\n        }\n    }\n    free(table->buckets);\n}\n\nstatic void hash_table_resize(hash_table *table, int new_size)\n{\n    hash_table new_table;\n    hash_table_init(&new_table, new_size);\n    for (int i = 0; i < table->size; i++)\n    {\n        hash_bucket *bucket = &table->buckets[i];\n        hash_entry *entry = bucket->head;\n        while (entry != NULL)\n        {\n            hash_entry *next = entry->next;\n            hash_table_insert(&new_table, entry->key, entry->value);\n            free(entry);\n            entry = next;\n        }\n    }\n    hash_table_destroy(table);\n    *table = new_table;\n}\n\nstatic void hash_table_rehash(hash_table *table)\n{\n    int new_size = table->size * 2;\n    hash_table_resize(table, new_size);\n}\n\nstatic void hash_table_remove(hash_table *table, const char *key)\n{\n    unsigned int hash = hash_function(key) % table->size;\n    hash_bucket *bucket = &table->buckets[hash];\n    hash_entry *entry = bucket->head;\n    hash_entry *prev = NULL;\n    while (entry != NULL)\n    {\n        if (strcmp(entry->key, key) == 0)\n        {\n            if (prev == NULL)\n            {\n                bucket->head = entry->next;\n            }\n            else\n            {\n                prev->next = entry->next;\n            }\n            free(entry->key);\n            free(entry);\n            table->count--;\n            return;\n        }\n        prev = entry;\n        entry = entry->next;\n    }\n}\n\nstatic void *hash_table_get(hash_table *table, const char *key)\n{\n    unsigned int hash = hash_function(key) % table->size;\n    hash_bucket *bucket = &table->buckets[hash];\n    hash_entry *entry = bucket->head;\n    while (entry != NULL)\n    {\n        if (strcmp(entry->key, key) == 0)\n        {\n            return entry->value;\n        }\n        entry = entry->next;\n    }\n    return NULL;\n}",
        "source_code": "static void hash_rebuild(xhash *hash)\n{\n\tunsigned newsize, i, idx;\n\thash_item **newitems, *hi, *thi;\n\n\tif (hash->nprime == ARRAY_SIZE(PRIMES))\n\t\treturn;\n\n\tnewsize = PRIMES[hash->nprime++];\n\tnewitems = xzalloc(newsize * sizeof(newitems[0]));\n\n\tfor (i = 0; i < hash->csize; i++) {\n\t\thi = hash->items[i];\n\t\twhile (hi) {\n\t\t\tthi = hi;\n\t\t\thi = thi->next;\n\t\t\tidx = hashidx(thi->name) % newsize;\n\t\t\tthi->next = newitems[idx];\n\t\t\tnewitems[idx] = thi;\n\t\t}\n\t}\n\n\tfree(hash->items);\n\thash->csize = newsize;\n\thash->items = newitems;\n}",
        "parsed_output": "static void hash_table_init(hash_table *table, int size)\n{\n    table->size = size;\n    table->count = 0;\n    table->buckets = (hash_bucket *)malloc(sizeof(hash_bucket) * size);\n    memset(table->buckets, 0, sizeof(hash_bucket) * size);\n}\n\nstatic void hash_table_insert(hash_table *table, const char *key, void *value)\n{\n    unsigned int hash = hash_function(key) % table->size;\n    hash_bucket *bucket = &table->buckets[hash];\n    hash_entry *entry = (hash_entry *)malloc(sizeof(hash_entry));\n    entry->key = strdup(key);\n    entry->value = value;\n    entry->next = bucket->head;\n    bucket->head = entry;\n    table->count++;\n}\n\nstatic void hash_table_destroy(hash_table *table)\n{\n    for (int i = 0; i < table->size; i++)\n    {\n        hash_bucket *bucket = &table->buckets[i];\n        hash_entry *entry = bucket->head;\n        while (entry != NULL)\n        {\n            hash_entry *next = entry->next;\n            free(entry->key);\n            free(entry);\n            entry = next;\n        }\n    }\n    free(table->buckets);\n}\n\nstatic void hash_table_resize(hash_table *table, int new_size)\n{\n    hash_table new_table;\n    hash_table_init(&new_table, new_size);\n    for (int i = 0; i < table->size; i++)\n    {\n        hash_bucket *bucket = &table->buckets[i];\n        hash_entry *entry = bucket->head;\n        while (entry != NULL)\n        {\n            hash_entry *next = entry->next;\n            hash_table_insert(&new_table, entry->key, entry->value);\n            free(entry);\n            entry = next;\n        }\n    }\n    hash_table_destroy(table);\n    *table = new_table;\n}\n\nstatic void hash_table_rehash(hash_table *table)\n{\n    int new_size = table->size * 2;\n    hash_table_resize(table, new_size);\n}\n\nstatic void hash_table_remove(hash_table *table, const char *key)\n{\n    unsigned int hash = hash_function(key) % table->size;\n    hash_bucket *bucket = &table->buckets[hash];\n    hash_entry *entry = bucket->head;\n    hash_entry *prev = NULL;\n    while (entry != NULL)\n    {\n        if (strcmp(entry->key, key) == 0)\n        {\n            if (prev == NULL)\n            {\n                bucket->head = entry->next;\n            }\n            else\n            {\n                prev->next = entry->next;\n            }\n            free(entry->key);\n            free(entry);\n            table->count--;\n            return;\n        }\n        prev = entry;\n        entry = entry->next;\n    }\n}\n\nstatic void *hash_table_get(hash_table *table, const char *key)\n{\n    unsigned int hash = hash_function(key) % table->size;\n    hash_bucket *bucket = &table->buckets[hash];\n    hash_entry *entry = bucket->head;\n    while (entry != NULL)\n    {\n        if (strcmp(entry->key, key) == 0)\n        {\n            return entry->value;\n        }\n        entry = entry->next;\n    }\n    return NULL;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4DC1ED(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n  int v3; // eax\n  unsigned int v4; // [rsp+14h] [rbp-2Ch]\n  __int64 v5; // [rsp+18h] [rbp-28h]\n  _QWORD *v6; // [rsp+20h] [rbp-20h]\n  unsigned int v7; // [rsp+2Ch] [rbp-14h]\n  __int64 v8; // [rsp+30h] [rbp-10h]\n  unsigned int i; // [rsp+3Ch] [rbp-4h]\n\n  result = *(unsigned int *)(a1 + 8);\n  if ( (_DWORD)result != 5 )\n  {\n    v3 = *(_DWORD *)(a1 + 8);\n    *(_DWORD *)(a1 + 8) = v3 + 1;\n    v7 = (unsigned __int16)word_524914[v3];\n    v6 = sub_40A0E8(8LL * (unsigned __int16)word_524914[v3], a2);\n    for ( i = 0; i < *(_DWORD *)(a1 + 4); ++i )\n    {\n      v8 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 16));\n      while ( v8 )\n      {\n        v5 = v8;\n        v8 = *(_QWORD *)(v8 + 32);\n        v4 = (unsigned int)sub_4DC0E5((char *)(v5 + 40)) % v7;\n        *(_QWORD *)(v5 + 32) = v6[v4];\n        v6[v4] = v5;\n      }\n    }\n    free(*(void **)(a1 + 16));\n    *(_DWORD *)(a1 + 4) = v7;\n    result = a1;\n    *(_QWORD *)(a1 + 16) = v6;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl hash_rebuild(xhash *hash)\n{\n  unsigned int nprime; // eax\n  unsigned int idx; // [rsp+14h] [rbp-2Ch]\n  hash_item *thi; // [rsp+18h] [rbp-28h]\n  hash_item_s **newitems; // [rsp+20h] [rbp-20h]\n  unsigned int newsize; // [rsp+2Ch] [rbp-14h]\n  hash_item *hi; // [rsp+30h] [rbp-10h]\n  unsigned int i; // [rsp+3Ch] [rbp-4h]\n\n  if ( hash->nprime != 5 )\n  {\n    nprime = hash->nprime;\n    hash->nprime = nprime + 1;\n    newsize = PRIMES[nprime];\n    newitems = (hash_item_s **)xzalloc(8LL * PRIMES[nprime]);\n    for ( i = 0; i < hash->csize; ++i )\n    {\n      hi = hash->items[i];\n      while ( hi )\n      {\n        thi = hi;\n        hi = hi->next;\n        idx = hashidx(thi->name) % newsize;\n        thi->next = newitems[idx];\n        newitems[idx] = thi;\n      }\n    }\n    free(hash->items);\n    hash->csize = newsize;\n    hash->items = newitems;\n  }\n}\n",
        "similarity_score_unixcoder": 0.7609142661094666,
        "similarity_score_baseline_stripped": 0.41412681341171265,
        "similarity_score_baseline_debug": 0.8908737897872925
    },
    {
        "func_name": "pseudo_exec_argv",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48682E(const char *a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-18h]\n  char *v4; // [rsp+20h] [rbp-10h]\n  __int64 v5; // [rsp+28h] [rbp-8h]\n\n  v4 = sub_4867AC(a1);\n  v5 = *(_QWORD *)v4;\n  if ( *(_QWORD *)v4 )\n  {\n    v3 = *(_QWORD *)(v5 + 16);\n    if ( v3 )\n    {\n      **(_QWORD **)(v3 + 32) = *(_QWORD *)(v5 + 8);\n      *(_QWORD *)(v3 + 16) = *(_QWORD *)(v5 + 24);\n    }\n    else\n    {\n      free(*(void **)(v5 + 8));\n      if ( *(_QWORD *)(v5 + 24) )\n        sub_4821B8(*(__int64 **)(v5 + 24));\n    }\n  }\n  else\n  {\n    *(_QWORD *)v4 = sub_40A0E8(0x20uLL, a2);\n    v5 = *(_QWORD *)v4;\n  }\n  *(_QWORD *)(v5 + 8) = a1;\n  return v5;\n}\n\n\n Revised code:\nstatic struct function *new_function(char *name)\n{\n\tstruct function **funcpp = find_function_slot(name);\n\tstruct function *funcp = *funcpp;\n\n\tif (funcp != NULL) {\n\t\tstruct command *cmd = funcp->parent_cmd;\n\t\tdebug_printf_exec(\"func %p parent_cmd %p\\n\", funcp, cmd);\n\t\tif (!cmd) {\n\t\t\tdebug_printf_exec(\"freeing & replacing function '%s'\\n\", funcp->name);\n\t\t\tfree(funcp->name);\n\t\t\t/* Note: if !funcp->body, do not free body_as_string!\n\t\t\t * This is a special case of \"-F name body\" function:\n\t\t\t * body_as_string was not malloced! */\n\t\t\tif (funcp->body) {\n\t\t\t\tfree_pipe_list(funcp->body);\n# if !BB_MMU\n\t\t\t\tfree(funcp->body_as_string);\n# endif\n\t\t\t}\n\t\t} else {\n\t\t\tdebug_printf_exec(\"reinserting in tree & replacing function '%s'\\n\", funcp->name);\n\t\t\tcmd->argv[0] = funcp->name;\n\t\t\tcmd->group = funcp->body;\n# if !BB_MMU\n\t\t\tcmd->group_as_string = funcp->body_as_string;\n# endif\n\t\t}\n\t} else {\n\t\tdebug_printf_exec(\"remembering new function '%s'\\n\", name);\n\t\tfuncp = *funcpp = xzalloc(sizeof(*funcp));\n\t\t/*funcp->next = NULL;*/\n\t}\n\n\tfuncp->name = name;\n\treturn funcp;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_487690(const char ***a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rsi\n  const char **v11; // [rsp+30h] [rbp-10h]\n  unsigned int v12; // [rsp+3Ch] [rbp-4h]\n\n  v12 = sub_4863C6(a3, a4, a4, a4, a5, a6);\n  if ( !v12 )\n  {\n    v6 = *(unsigned int *)(a3 + 4);\n    v11 = (const char **)sub_485C0D(*(_QWORD *)(a3 + 32), v6);\n    *a1 = v11;\n    sub_486BBE((__int64)v11, v6);\n    sub_486BBE(a5, v6);\n    if ( a2 )\n      *a2 = sub_480E9C(v11);\n  }\n  return v12;\n}\n\n\n Revised code:\nendif\nstatic int redirect_and_varexp_helper(char ***new_env_p,\n\t\tstruct variable **old_vars_p,\n\t\tstruct command *command,\n\t\tint squirrel[3],\n\t\tchar **argv_expanded)\n{\n\t/* setup_redirects acts on file descriptors, not FILEs.\n\t * This is perfect for work that comes after exec().\n\t * Is it really safe for inline use?  Experimentally,\n\t * things seem to work. */\n\tint rcode = setup_redirects(command, squirrel);\n\tif (rcode == 0) {\n\t\tchar **new_env = expand_assignments(command->argv, command->assignment_cnt);\n\t\t*new_env_p = new_env;\n\t\tdump_cmd_in_x_mode(new_env);\n\t\tdump_cmd_in_x_mode(argv_expanded);\n\t\tif (old_vars_p)\n\t\t\t*old_vars_p = set_vars_and_save_old(new_env);\n\t}\n\treturn rcode;\n}\n\n## Example:\n\n Input code:\nvoid __fastcall __noreturn sub_4C614C(__int64 a1, __int64 a2)\n{\n  __int64 v2; // [rsp+0h] [rbp-10h]\n\n  if ( !*(_QWORD *)(a2 + 8) )\n    sub_407F64();\n  sub_40A8DC(*(const char **)(a2 + 8));\n  v2 = a2 + 16;\n  if ( !*(_QWORD *)(a2 + 16) )\n  {\n    v2 = a2;\n    *(_QWORD *)a2 = sub_4FA04E();\n    *(_QWORD *)(a2 + 8) = \"-i\";\n  }\n  sub_4F931D(v2);\n}\n\n\n Revised code:\nint chroot_main(int argc UNUSED_PARAM, char **argv)\n{\n\t++argv;\n\tif (!*argv)\n\t\tbb_show_usage();\n\txchroot(*argv);\n\n\t++argv;\n\tif (!*argv) { /* no 2nd param (PROG), use shell */\n\t\targv -= 2;\n\t\targv[0] = (char *) get_shell_name();\n\t\targv[1] = (char *) \"-i\"; /* GNU coreutils 8.4 compat */\n\t\t/*argv[2] = NULL; - already is */\n\t}\n\n\tBB_EXECVP_or_die(argv);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall __noreturn sub_486D04(__int64 a1, unsigned int a2, __int64 a3)\n{\n  const char **v4; // [rsp+18h] [rbp-28h]\n  __int64 v5; // [rsp+28h] [rbp-18h]\n  const char **v6; // [rsp+30h] [rbp-10h]\n  void **ptr; // [rsp+38h] [rbp-8h]\n\n  ptr = (void **)sub_485C0D(a1, a2);\n  sub_486BBE((__int64)ptr, a2);\n  if ( !*(_QWORD *)(8LL * (int)a2 + a1) )\n  {\n    sub_480135(ptr);\n    _exit(0);\n  }\n  sub_480E9C((const char **)ptr);\n  free(ptr);\n  if ( a3 )\n  {\n    v4 = (const char **)a3;\n    sub_486BBE(a3, a2);\n  }\n  else\n  {\n    v4 = (const char **)sub_4859EC((const char **)(8LL * (int)a2 + a1));\n    sub_486BBE((__int64)v4, a2);\n  }\n  if ( !strchr(*v4, 47) )\n  {\n    v6 = sub_48676B(*v4);\n    if ( v6 )\n      sub_486B28((__int64)v6, (__int64)v4);\n    v5 = sub_486809(*v4);\n    if ( v5 )\n      sub_48696C(v5, v4);\n  }\n  sub_486B60(v4);\n}\n",
        "output": "void __fastcall __noreturn process_data(__int64 a1, unsigned int a2, __int64 a3)\n{\n  const char **ptr; // [rsp+18h] [rbp-28h]\n  __int64 v5; // [rsp+28h] [rbp-18h]\n  const char **v6; // [rsp+30h] [rbp-10h]\n  void **data_ptr; // [rsp+38h] [rbp-8h]\n\n  data_ptr = (void **)sub_485C0D(a1, a2);\n  sub_486BBE((__int64)data_ptr, a2);\n  if (!*(_QWORD *)(8LL * (int)a2 + a1))\n  {\n    sub_480135(data_ptr);\n    _exit(0);\n  }\n  sub_480E9C((const char **)data_ptr);\n  free(data_ptr);\n  if (a3)\n  {\n    v4 = (const char **)a3;\n    sub_486BBE(a3, a2);\n  }\n  else\n  {\n    v4 = (const char **)sub_4859EC((const char **)(8LL * (int)a2 + a1));\n    sub_486BBE((__int64)v4, a2);\n  }\n  if (!strchr(*v4, 47))\n  {\n    v6 = sub_48676B(*v4);\n    if (v6)\n      sub_486B28((__int64)v6, (__int64)v4);\n    v5 = sub_486809(*v4);\n    if (v5)\n      sub_48696C(v5, v4);\n  }\n  sub_486B60(v4);\n}",
        "source_code": "static NOINLINE void pseudo_exec_argv(nommu_save_t *nommu_save,\n\t\tchar **argv, int assignment_cnt,\n\t\tchar **argv_expanded)\n{\n\tchar **new_env;\n\n\tnew_env = expand_assignments(argv, assignment_cnt);\n\tdump_cmd_in_x_mode(new_env);\n\n\tif (!argv[assignment_cnt]) {\n\t\t/* Case when we are here: ... | var=val | ...\n\t\t * (note that we do not exit early, i.e., do not optimize out\n\t\t * expand_assignments(): think about ... | var=`sleep 1` | ...\n\t\t */\n\t\tfree_strings(new_env);\n\t\t_exit(EXIT_SUCCESS);\n\t}\n\n#if BB_MMU\n\tset_vars_and_save_old(new_env);\n\tfree(new_env); /* optional */\n\t/* we can also destroy set_vars_and_save_old's return value,\n\t * to save memory */\n#else\n\tnommu_save->new_env = new_env;\n\tnommu_save->old_vars = set_vars_and_save_old(new_env);\n#endif\n\n\tif (argv_expanded) {\n\t\targv = argv_expanded;\n\t} else {\n\t\targv = expand_strvec_to_strvec(argv + assignment_cnt);\n#if !BB_MMU\n\t\tnommu_save->argv = argv;\n#endif\n\t}\n\tdump_cmd_in_x_mode(argv);\n\n#if ENABLE_FEATURE_SH_STANDALONE || BB_MMU\n\tif (strchr(argv[0], '/') != NULL)\n\t\tgoto skip;\n#endif\n\n\t/* Check if the command matches any of the builtins.\n\t * Depending on context, this might be redundant.  But it's\n\t * easier to waste a few CPU cycles than it is to figure out\n\t * if this is one of those cases.\n\t */\n\t{\n\t\t/* On NOMMU, it is more expensive to re-execute shell\n\t\t * just in order to run echo or test builtin.\n\t\t * It's better to skip it here and run corresponding\n\t\t * non-builtin later. */\n\t\tconst struct built_in_command *x;\n\t\tx = BB_MMU ? find_builtin(argv[0]) : find_builtin1(argv[0]);\n\t\tif (x) {\n\t\t\texec_builtin(&nommu_save->argv_from_re_execing, x, argv);\n\t\t}\n\t}\n#if ENABLE_HUSH_FUNCTIONS\n\t/* Check if the command matches any functions */\n\t{\n\t\tconst struct function *funcp = find_function(argv[0]);\n\t\tif (funcp) {\n\t\t\texec_function(&nommu_save->argv_from_re_execing, funcp, argv);\n\t\t}\n\t}\n#endif\n\n#if ENABLE_FEATURE_SH_STANDALONE\n\t/* Check if the command matches any busybox applets */\n\t{\n\t\tint a = find_applet_by_name(argv[0]);\n\t\tif (a >= 0) {\n# if BB_MMU /* see above why on NOMMU it is not allowed */\n\t\t\tif (APPLET_IS_NOEXEC(a)) {\n\t\t\t\tdebug_printf_exec(\"running applet '%s'\\n\", argv[0]);\n\t\t\t\trun_applet_no_and_exit(a, argv);\n\t\t\t}\n# endif\n\t\t\t/* Re-exec ourselves */\n\t\t\tdebug_printf_exec(\"re-execing applet '%s'\\n\", argv[0]);\n\t\t\t/* Don't propagate SIG_IGN to the child */\n\t\t\tif (SPECIAL_JOBSTOP_SIGS != 0)\n\t\t\t\tswitch_off_special_sigs(G.special_sig_mask & SPECIAL_JOBSTOP_SIGS);\n\t\t\texecv(bb_busybox_exec_path, argv);\n\t\t\t/* If they called chroot or otherwise made the binary no longer\n\t\t\t * executable, fall through */\n\t\t}\n\t}\n#endif\n\n#if ENABLE_FEATURE_SH_STANDALONE || BB_MMU\n skip:\n#endif\n\texecvp_or_die(argv);\n}",
        "parsed_output": "void __fastcall __noreturn process_data(__int64 a1, unsigned int a2, __int64 a3)\n{\n  const char **ptr; // [rsp+18h] [rbp-28h]\n  __int64 v5; // [rsp+28h] [rbp-18h]\n  const char **v6; // [rsp+30h] [rbp-10h]\n  void **data_ptr; // [rsp+38h] [rbp-8h]\n\n  data_ptr = (void **)sub_485C0D(a1, a2);\n  sub_486BBE((__int64)data_ptr, a2);\n  if (!*(_QWORD *)(8LL * (int)a2 + a1))\n  {\n    sub_480135(data_ptr);\n    _exit(0);\n  }\n  sub_480E9C((const char **)data_ptr);\n  free(data_ptr);\n  if (a3)\n  {\n    v4 = (const char **)a3;\n    sub_486BBE(a3, a2);\n  }\n  else\n  {\n    v4 = (const char **)sub_4859EC((const char **)(8LL * (int)a2 + a1));\n    sub_486BBE((__int64)v4, a2);\n  }\n  if (!strchr(*v4, 47))\n  {\n    v6 = sub_48676B(*v4);\n    if (v6)\n      sub_486B28((__int64)v6, (__int64)v4);\n    v5 = sub_486809(*v4);\n    if (v5)\n      sub_48696C(v5, v4);\n  }\n  sub_486B60(v4);\n}",
        "baseline_code_stripped": "void __fastcall __noreturn sub_486D04(__int64 a1, unsigned int a2, __int64 a3)\n{\n  const char **v4; // [rsp+18h] [rbp-28h]\n  __int64 v5; // [rsp+28h] [rbp-18h]\n  const char **v6; // [rsp+30h] [rbp-10h]\n  void **ptr; // [rsp+38h] [rbp-8h]\n\n  ptr = (void **)sub_485C0D(a1, a2);\n  sub_486BBE((__int64)ptr, a2);\n  if ( !*(_QWORD *)(8LL * (int)a2 + a1) )\n  {\n    sub_480135(ptr);\n    _exit(0);\n  }\n  sub_480E9C((const char **)ptr);\n  free(ptr);\n  if ( a3 )\n  {\n    v4 = (const char **)a3;\n    sub_486BBE(a3, a2);\n  }\n  else\n  {\n    v4 = (const char **)sub_4859EC((const char **)(8LL * (int)a2 + a1));\n    sub_486BBE((__int64)v4, a2);\n  }\n  if ( !strchr(*v4, 47) )\n  {\n    v6 = sub_48676B(*v4);\n    if ( v6 )\n      sub_486B28((__int64)v6, (__int64)v4);\n    v5 = sub_486809(*v4);\n    if ( v5 )\n      sub_48696C(v5, v4);\n  }\n  sub_486B60(v4);\n}\n",
        "baseline_code_debug": "void __cdecl __noreturn pseudo_exec_argv(char **argv, int assignment_cnt, char **argv_expanded)\n{\n  char **argva; // [rsp+18h] [rbp-28h]\n  const function *funcp; // [rsp+28h] [rbp-18h]\n  const built_in_command *x; // [rsp+30h] [rbp-10h]\n  char **new_env; // [rsp+38h] [rbp-8h]\n\n  new_env = expand_assignments(argv, assignment_cnt);\n  dump_cmd_in_x_mode(new_env);\n  if ( !argv[assignment_cnt] )\n  {\n    free_strings(new_env);\n    _exit(0);\n  }\n  set_vars_and_save_old(new_env);\n  free(new_env);\n  if ( argv_expanded )\n    argva = argv_expanded;\n  else\n    argva = expand_strvec_to_strvec(&argv[assignment_cnt]);\n  dump_cmd_in_x_mode(argva);\n  if ( !strchr(*argva, 47) )\n  {\n    x = find_builtin_0(*argva);\n    if ( x )\n      exec_builtin(x, argva);\n    funcp = find_function(*argva);\n    if ( funcp )\n      exec_function(funcp, argva);\n  }\n  execvp_or_die(argva);\n}\n",
        "similarity_score_unixcoder": 0.5560492277145386,
        "similarity_score_baseline_stripped": 0.5556362867355347,
        "similarity_score_baseline_debug": 0.8146728873252869
    },
    {
        "func_name": "mbstowc_internal",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_50906E(_BYTE *a1, unsigned int a2)\n{\n  int v3; // [rsp+0h] [rbp-1Ch]\n  unsigned int v4; // [rsp+10h] [rbp-Ch]\n  int v5; // [rsp+14h] [rbp-8h]\n  int i; // [rsp+18h] [rbp-4h]\n\n  v3 = a2;\n  v4 = a2;\n  if ( a2 > 0x7F )\n  {\n    for ( i = 2; v4 > 0x7FF && i <= 5; ++i )\n      v4 >>= 5;\n    v5 = i;\n    while ( --v5 )\n    {\n      a1[v5] = v3 & 0x3F | 0x80;\n      v3 >>= 6;\n    }\n    *a1 = v3 | (16128 >> i);\n    return i;\n  }\n  else\n  {\n    *a1 = a2;\n    return 1LL;\n  }\n}\n\n\n Revised code:\nendif\n\nstatic size_t wcrtomb_internal(char *s, wchar_t wc)\n{\n\tint n, i;\n\tuint32_t v = wc;\n\n\tif (v <= 0x7f) {\n\t\t*s = v;\n\t\treturn 1;\n\t}\n\n\t/* RFC 3629 says that Unicode ends at 10FFFF,\n\t * but we cover entire 32 bits */\n\n\t/* 4000000-FFFFFFFF -> 111111tt 10tttttt 10zzzzzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\t/* 200000-3FFFFFF -> 111110tt 10zzzzzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\t/* 10000-1FFFFF -> 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\t/* 800-FFFF -> 1110yyyy 10yyyyxx 10xxxxxx */\n\t/* 80-7FF -> 110yyyxx 10xxxxxx */\n\n\t/* How many bytes do we need? */\n\tn = 2;\n\t/* (0x80000000+ would result in n = 7, limiting n to 6) */\n\twhile (v >= 0x800 && n < 6) {\n\t\tv >>= 5;\n\t\tn++;\n\t}\n\t/* Fill bytes n-1..1 */\n\ti = n;\n\twhile (--i) {\n\t\ts[i] = (wc & 0x3f) | 0x80;\n\t\twc >>= 6;\n\t}\n\t/* Fill byte 0 */\n\ts[0] = wc | (uint8_t)(0x3f00 >> n);\n\treturn n;\n}\n\n## Example:\n\n Input code:\nunsigned __int8 *__fastcall sub_502C28(unsigned __int8 *a1, int a2)\n{\n  unsigned __int8 *v2; // rax\n  unsigned __int8 *v3; // rax\n  unsigned __int8 *v5; // rax\n  unsigned __int8 *v6; // rax\n  unsigned __int8 *v7; // rax\n  unsigned int v8; // [rsp+18h] [rbp-20h]\n  unsigned int v9; // [rsp+18h] [rbp-20h]\n  unsigned __int8 v10; // [rsp+1Fh] [rbp-19h]\n  unsigned __int8 *v11; // [rsp+20h] [rbp-18h]\n  unsigned __int8 *v12; // [rsp+28h] [rbp-10h]\n\n  v12 = a1;\n  v11 = a1;\n  while ( 1 )\n  {\n    v7 = v12++;\n    v10 = *v7;\n    if ( !*v7 )\n      break;\n    if ( a2 || v10 != 43 )\n    {\n      if ( v10 == 37 )\n      {\n        v8 = sub_502BE5(*v12);\n        if ( v8 > 0xF || (v9 = (16 * v8) | sub_502BE5(v12[1]), v9 > 0xFF) )\n        {\n          if ( a2 )\n            return 0LL;\n          v5 = v11++;\n          *v5 = 37;\n        }\n        else\n        {\n          if ( a2 && (v9 == 47 || !v9) )\n            return a1 + 1;\n          v6 = v11++;\n          *v6 = v9;\n          v12 += 2;\n        }\n      }\n      else\n      {\n        v3 = v11++;\n        *v3 = v10;\n      }\n    }\n    else\n    {\n      v2 = v11++;\n      *v2 = 32;\n    }\n  }\n  *v11 = 0;\n  return a1;\n}\n\n\n Revised code:\nFAST_FUNC percent_decode_in_place(char *str, int strict)\n{\n\t/* note that decoded string is always shorter than original */\n\tchar *src = str;\n\tchar *dst = str;\n\tchar c;\n\n\twhile ((c = *src++) != '\\0') {\n\t\tunsigned v;\n\n\t\tif (!strict && c == '+') {\n\t\t\t*dst++ = ' ';\n\t\t\tcontinue;\n\t\t}\n\t\tif (c != '%') {\n\t\t\t*dst++ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tv = hex_to_bin(src[0]);\n\t\tif (v > 15) {\n bad_hex:\n\t\t\tif (strict)\n\t\t\t\treturn NULL;\n\t\t\t*dst++ = '%';\n\t\t\tcontinue;\n\t\t}\n\t\tv = (v * 16) | hex_to_bin(src[1]);\n\t\tif (v > 255)\n\t\t\tgoto bad_hex;\n\t\tif (strict && (v == '/' || v == '\\0')) {\n\t\t\t/* caller takes it as indication of invalid\n\t\t\t * (dangerous wrt exploits) chars */\n\t\t\treturn str + 1;\n\t\t}\n\t\t*dst++ = v;\n\t\tsrc += 2;\n\t}\n\t*dst = '\\0';\n\treturn str;\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_4C5907(_BYTE *a1, unsigned int *a2)\n{\n  unsigned int *v2; // rax\n  _BYTE *s; // [rsp+8h] [rbp-18h]\n  unsigned int v6; // [rsp+18h] [rbp-8h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  s = a1;\n  memset(a1, 32, (unsigned int)(7 * dword_75D450 + 21));\n  for ( i = 0; i <= 6; ++i )\n  {\n    v2 = a2++;\n    v6 = *v2;\n    if ( *v2 == -1 )\n    {\n      s += (unsigned int)(dword_75D450 + 3);\n    }\n    else\n    {\n      if ( dword_75D450 )\n      {\n        ++s;\n        if ( v6 > 0x63 )\n        {\n          *s = 48;\n          *(s - 1) = v6 / 0x64 + 48;\n          v6 %= 0x64u;\n        }\n      }\n      if ( v6 / 0xA )\n        *s = v6 / 0xA + 48;\n      s[1] = v6 % 0xA + 48;\n      s += 3;\n    }\n  }\n  return s;\n}\n\n\n Revised code:\nstatic char *build_row(char *p, unsigned *dp)\n{\n\tunsigned col, val, day;\n\n\tmemset(p, ' ', (julian + DAY_LEN) * 7);\n\n\tcol = 0;\n\tdo {\n\t\tday = *dp++;\n\t\tif (day != SPACE) {\n\t\t\tif (julian) {\n\t\t\t\t++p;\n\t\t\t\tif (day >= 100) {\n\t\t\t\t\t*p = '0';\n\t\t\t\t\tp[-1] = (day / 100) + '0';\n\t\t\t\t\tday %= 100;\n\t\t\t\t}\n\t\t\t}\n\t\t\tval = day / 10;\n\t\t\tif (val > 0) {\n\t\t\t\t*p = val + '0';\n\t\t\t}\n\t\t\t*++p = day % 10 + '0';\n\t\t\tp += 2;\n\t\t} else {\n\t\t\tp += DAY_LEN + julian;\n\t\t}\n\t} while (++col < 7);\n\n\treturn p;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nunsigned __int8 *__fastcall sub_50921C(unsigned int *a1, unsigned __int8 *a2)\n{\n  _BYTE *v3; // [rsp+0h] [rbp-20h]\n  unsigned int v4; // [rsp+18h] [rbp-8h]\n  unsigned int v5; // [rsp+18h] [rbp-8h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  v3 = a2 + 1;\n  v4 = *a2;\n  if ( v4 > 0x7F )\n  {\n    v6 = 0;\n    do\n    {\n      LOBYTE(v4) = 2 * v4;\n      ++v6;\n    }\n    while ( (v4 & 0x80) != 0 && v6 <= 5 );\n    if ( v6 == 1 )\n    {\n      *a1 = -1;\n      return a2 + 1;\n    }\n    else\n    {\n      v5 = (int)(unsigned __int8)v4 >> v6;\n      while ( --v6 )\n      {\n        if ( (*v3 & 0xC0) != 128 )\n        {\n          *a1 = -1;\n          return v3;\n        }\n        v5 = (v5 << 6) + (*v3++ & 0x3F);\n      }\n      if ( v5 > 0x7F )\n        *a1 = v5;\n      else\n        *a1 = -1;\n      return v3;\n    }\n  }\n  else\n  {\n    *a1 = v4;\n    return a2 + 1;\n  }\n}\n",
        "output": "static unsigned char *decode_utf8(unsigned int *output, unsigned char *input)\n{\n\tunsigned char *ptr = input + 1;\n\tunsigned int codepoint = *input;\n\n\tif (codepoint > 0x7F) {\n\t\tint count = 0;\n\t\tdo {\n\t\t\tcodepoint <<= 1;\n\t\t\tcount++;\n\t\t} while ((codepoint & 0x80) != 0 && count <= 5);\n\n\t\tif (count == 1) {\n\t\t\t*output = -1;\n\t\t\treturn input + 1;\n\t\t} else {\n\t\t\tunsigned int value = (unsigned char)codepoint >> count;\n\t\t\twhile (--count) {\n\t\t\t\tif ((*ptr & 0xC0) != 128) {\n\t\t\t\t\t*output = -1;\n\t\t\t\t\treturn ptr;\n\t\t\t\t}\n\t\t\t\tvalue = (value << 6) + (*ptr++ & 0x3F);\n\t\t\t}\n\t\t\tif (value > 0x7F)\n\t\t\t\t*output = value;\n\t\t\telse\n\t\t\t\t*output = -1;\n\t\t\treturn ptr;\n\t\t}\n\t} else {\n\t\t*output = codepoint;\n\t\treturn input + 1;\n\t}\n}",
        "source_code": "static const char *mbstowc_internal(wchar_t *res, const char *src)\n{\n\tint bytes;\n\tunsigned c = (unsigned char) *src++;\n\n\tif (c <= 0x7f) {\n\t\t*res = c;\n\t\treturn src;\n\t}\n\n\t/* 80-7FF -> 110yyyxx 10xxxxxx */\n\t/* 800-FFFF -> 1110yyyy 10yyyyxx 10xxxxxx */\n\t/* 10000-1FFFFF -> 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\t/* 200000-3FFFFFF -> 111110tt 10zzzzzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\t/* 4000000-FFFFFFFF -> 111111tt 10tttttt 10zzzzzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\tbytes = 0;\n\tdo {\n\t\tc <<= 1;\n\t\tbytes++;\n\t} while ((c & 0x80) && bytes < 6);\n\tif (bytes == 1) {\n\t\t/* A bare \"continuation\" byte. Say, 80 */\n\t\t*res = ERROR_WCHAR;\n\t\treturn src;\n\t}\n\tc = (uint8_t)(c) >> bytes;\n\n\twhile (--bytes) {\n\t\tunsigned ch = (unsigned char) *src;\n\t\tif ((ch & 0xc0) != 0x80) {\n\t\t\t/* Missing \"continuation\" byte. Example: e0 80 */\n\t\t\t*res = ERROR_WCHAR;\n\t\t\treturn src;\n\t\t}\n\t\tc = (c << 6) + (ch & 0x3f);\n\t\tsrc++;\n\t}\n\n\t/* TODO */\n\t/* Need to check that c isn't produced by overlong encoding */\n\t/* Example: 11000000 10000000 converts to NUL */\n\t/* 11110000 10000000 10000100 10000000 converts to 0x100 */\n\t/* correct encoding: 11000100 10000000 */\n\tif (c <= 0x7f) { /* crude check */\n\t\t*res = ERROR_WCHAR;\n\t\treturn src;\n\t}\n\n\t*res = c;\n\treturn src;\n}",
        "parsed_output": "static unsigned char *decode_utf8(unsigned int *output, unsigned char *input)\n{\n\tunsigned char *ptr = input + 1;\n\tunsigned int codepoint = *input;\n\n\tif (codepoint > 0x7F) {\n\t\tint count = 0;\n\t\tdo {\n\t\t\tcodepoint <<= 1;\n\t\t\tcount++;\n\t\t} while ((codepoint & 0x80) != 0 && count <= 5);\n\n\t\tif (count == 1) {\n\t\t\t*output = -1;\n\t\t\treturn input + 1;\n\t\t} else {\n\t\t\tunsigned int value = (unsigned char)codepoint >> count;\n\t\t\twhile (--count) {\n\t\t\t\tif ((*ptr & 0xC0) != 128) {\n\t\t\t\t\t*output = -1;\n\t\t\t\t\treturn ptr;\n\t\t\t\t}\n\t\t\t\tvalue = (value << 6) + (*ptr++ & 0x3F);\n\t\t\t}\n\t\t\tif (value > 0x7F)\n\t\t\t\t*output = value;\n\t\t\telse\n\t\t\t\t*output = -1;\n\t\t\treturn ptr;\n\t\t}\n\t} else {\n\t\t*output = codepoint;\n\t\treturn input + 1;\n\t}\n}",
        "baseline_code_stripped": "unsigned __int8 *__fastcall sub_50921C(unsigned int *a1, unsigned __int8 *a2)\n{\n  _BYTE *v3; // [rsp+0h] [rbp-20h]\n  unsigned int v4; // [rsp+18h] [rbp-8h]\n  unsigned int v5; // [rsp+18h] [rbp-8h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  v3 = a2 + 1;\n  v4 = *a2;\n  if ( v4 > 0x7F )\n  {\n    v6 = 0;\n    do\n    {\n      LOBYTE(v4) = 2 * v4;\n      ++v6;\n    }\n    while ( (v4 & 0x80) != 0 && v6 <= 5 );\n    if ( v6 == 1 )\n    {\n      *a1 = -1;\n      return a2 + 1;\n    }\n    else\n    {\n      v5 = (int)(unsigned __int8)v4 >> v6;\n      while ( --v6 )\n      {\n        if ( (*v3 & 0xC0) != 128 )\n        {\n          *a1 = -1;\n          return v3;\n        }\n        v5 = (v5 << 6) + (*v3++ & 0x3F);\n      }\n      if ( v5 > 0x7F )\n        *a1 = v5;\n      else\n        *a1 = -1;\n      return v3;\n    }\n  }\n  else\n  {\n    *a1 = v4;\n    return a2 + 1;\n  }\n}\n",
        "baseline_code_debug": "const char *__cdecl mbstowc_internal(wchar_t *res, const char *src)\n{\n  const char *srca; // [rsp+0h] [rbp-20h]\n  unsigned int c; // [rsp+18h] [rbp-8h]\n  unsigned int ca; // [rsp+18h] [rbp-8h]\n  int bytes; // [rsp+1Ch] [rbp-4h]\n\n  srca = src + 1;\n  c = *(unsigned __int8 *)src;\n  if ( c > 0x7F )\n  {\n    bytes = 0;\n    do\n    {\n      LOBYTE(c) = 2 * c;\n      ++bytes;\n    }\n    while ( (c & 0x80) != 0 && bytes <= 5 );\n    if ( bytes == 1 )\n    {\n      *res = -1;\n      return src + 1;\n    }\n    else\n    {\n      ca = (int)(unsigned __int8)c >> bytes;\n      while ( --bytes )\n      {\n        if ( (*srca & 0xC0) != 128 )\n        {\n          *res = -1;\n          return srca;\n        }\n        ca = (ca << 6) + (*srca++ & 0x3F);\n      }\n      if ( ca > 0x7F )\n        *res = ca;\n      else\n        *res = -1;\n      return srca;\n    }\n  }\n  else\n  {\n    *res = c;\n    return src + 1;\n  }\n}\n",
        "similarity_score_unixcoder": 0.678713858127594,
        "similarity_score_baseline_stripped": 0.6813741326332092,
        "similarity_score_baseline_debug": 0.837479293346405
    },
    {
        "func_name": "free_procps_scan",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __fastcall sub_5024BD(__int64 a1)\n{\n  if ( a1 )\n  {\n    free(*(void **)(a1 + 8));\n    fclose(*(FILE **)a1);\n    free(*(void **)(a1 + 16));\n    free(*(void **)(a1 + 24));\n    free((void *)a1);\n  }\n}\n\n\n Revised code:\nvoid FAST_FUNC config_close(parser_t *parser)\n{\n\tif (parser) {\n\t\tif (PARSE_KEEP_COPY) /* compile-time constant */\n\t\t\tfree(parser->data);\n\t\tfclose(parser->fp);\n\t\tfree(parser->line);\n\t\tfree(parser->nline);\n\t\tfree(parser);\n\t}\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_4A5BEA(int *a1)\n{\n  if ( a1 )\n  {\n    close(*a1);\n    sub_4A8331(a1);\n    free(a1);\n  }\n}\n\n\n Revised code:\nendif\n\nvoid FAST_FUNC free_volume_id(struct volume_id *id)\n{\n\tif (id == NULL)\n\t\treturn;\n\n\t//if (id->fd_close != 0) - always true\n\t\tclose(id->fd);\n\tvolume_id_free_buffer(id);\n#ifdef UNUSED_PARTITION_CODE\n\tfree(id->partitions);\n#endif\n\tfree(id);\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_4B85A5(void **a1)\n{\n  free(a1[8]);\n  free(a1);\n}\n\n\n Revised code:\nvoid FAST_FUNC dealloc_bunzip(bunzip_data *bd)\n{\n\tfree(bd->dbuf);\n\tfree(bd);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_50346D(__int64 a1)\n{\n  closedir(*(DIR **)a1);\n  if ( *(_QWORD *)(a1 + 8) )\n    closedir(*(DIR **)(a1 + 8));\n  free(*(void **)(a1 + 24));\n  free(*(void **)(a1 + 32));\n  free((void *)a1);\n}\n",
        "output": "void FAST_FUNC close_directory(void *dir)\n{\n  closedir(*(DIR **)dir);\n  if (*(_QWORD *)(dir + 8))\n    closedir(*(DIR **)(dir + 8));\n  free(*(void **)(dir + 24));\n  free(*(void **)(dir + 32));\n  free((void *)dir);\n}",
        "source_code": "void FAST_FUNC free_procps_scan(procps_status_t* sp)\n{\n\tclosedir(sp->dir);\n#if ENABLE_FEATURE_SHOW_THREADS\n\tif (sp->task_dir)\n\t\tclosedir(sp->task_dir);\n#endif\n\tfree(sp->argv0);\n\tfree(sp->exe);\n\tIF_SELINUX(free(sp->context);)\n\tfree(sp);\n}",
        "parsed_output": "void FAST_FUNC close_directory(void *dir)\n{\n  closedir(*(DIR **)dir);\n  if (*(_QWORD *)(dir + 8))\n    closedir(*(DIR **)(dir + 8));\n  free(*(void **)(dir + 24));\n  free(*(void **)(dir + 32));\n  free((void *)dir);\n}",
        "baseline_code_stripped": "void __fastcall sub_50346D(__int64 a1)\n{\n  closedir(*(DIR **)a1);\n  if ( *(_QWORD *)(a1 + 8) )\n    closedir(*(DIR **)(a1 + 8));\n  free(*(void **)(a1 + 24));\n  free(*(void **)(a1 + 32));\n  free((void *)a1);\n}\n",
        "baseline_code_debug": "void __cdecl free_procps_scan(procps_status_t_0 *sp_0)\n{\n  closedir(sp_0->dir);\n  if ( sp_0->task_dir )\n    closedir(sp_0->task_dir);\n  free(sp_0->argv0);\n  free(sp_0->exe);\n  free(sp_0);\n}\n",
        "similarity_score_unixcoder": 0.5978577136993408,
        "similarity_score_baseline_stripped": 0.5288193821907043,
        "similarity_score_baseline_debug": 0.9124230742454529
    },
    {
        "func_name": "fb_pixel_value",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nchar *__fastcall sub_4AE836(unsigned __int16 a1, int a2)\n{\n  char *result; // rax\n\n  if ( *((_DWORD *)qword_75D408 - 3) <= 16 - a2 )\n  {\n    *((_WORD *)qword_75D408 - 7) |= a1 << *((_DWORD *)qword_75D408 - 3);\n    result = (char *)qword_75D408 - 88;\n    *((_DWORD *)qword_75D408 - 3) += a2;\n  }\n  else\n  {\n    *((_WORD *)qword_75D408 - 7) |= a1 << *((_DWORD *)qword_75D408 - 3);\n    sub_4AE62D(*((_WORD *)qword_75D408 - 7));\n    *((_WORD *)qword_75D408 - 7) = (int)a1 >> (16 - *((char *)qword_75D408 - 12));\n    result = (char *)qword_75D408 - 88;\n    *((_DWORD *)qword_75D408 - 3) = *((_DWORD *)qword_75D408 - 3) + a2 - 16;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void send_bits(int value, int length)\n{\n#ifdef DEBUG\n\tTracev((stderr, \" l %2d v %4x \", length, value));\n\tAssert(length > 0 && length <= 15, \"invalid length\");\n\tG1.bits_sent += length;\n#endif\n\t/* If not enough room in bi_buf, use (valid) bits from bi_buf and\n\t * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\n\t * unused bits in value.\n\t */\n\tif (G1.bi_valid > (int) BUF_SIZE - length) {\n\t\tG1.bi_buf |= (value << G1.bi_valid);\n\t\tput_16bit(G1.bi_buf);\n\t\tG1.bi_buf = (ush) value >> (BUF_SIZE - G1.bi_valid);\n\t\tG1.bi_valid += length - BUF_SIZE;\n\t} else {\n\t\tG1.bi_buf |= value << G1.bi_valid;\n\t\tG1.bi_valid += length;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40E5E6(__int64 a1, __int64 a2)\n{\n  int v2; // edx\n  int v3; // edx\n\n  v2 = *((_DWORD *)qword_75D408 + 24);\n  BYTE1(v2) |= 0x14u;\n  *((_DWORD *)qword_75D408 + 24) = v2;\n  if ( *((_BYTE *)qword_75D408 + 92) == 13 )\n  {\n    v3 = *((_DWORD *)qword_75D408 + 24);\n    BYTE1(v3) |= 1u;\n    *((_DWORD *)qword_75D408 + 24) = v3;\n  }\n  *((_DWORD *)qword_75D408 + 27) |= 0x83Bu;\n  *((_BYTE *)qword_75D408 + 113) = 3;\n  *((_BYTE *)qword_75D408 + 114) = 28;\n  *((_BYTE *)qword_75D408 + 117) = 4;\n  *((_BYTE *)qword_75D408 + 124) = 10;\n  *((_BYTE *)qword_75D408 + 120) = 0;\n  *((_BYTE *)qword_75D408 + 116) = 21;\n  sub_40E482(a1, a2);\n  return sub_40B38A(1u, (__int64)\"\\n\", 1LL);\n}\n\n\n Revised code:\nstatic void finalize_tty_attrs(void)\n{\n\t/* software flow control on output (stop sending if XOFF is recvd);\n\t * and on input (send XOFF when buffer is full)\n\t */\n\tG.tty_attrs.c_iflag |= IXON | IXOFF;\n\tif (G.eol == '\\r') {\n\t\tG.tty_attrs.c_iflag |= ICRNL; /* map CR on input to NL */\n\t}\n\t/* Other bits in c_iflag:\n\t * IXANY   Any recvd char enables output (any char is also a XON)\n\t * INPCK   Enable parity check\n\t * IGNPAR  Ignore parity errors (drop bad bytes)\n\t * PARMRK  Mark parity errors with 0xff, 0x00 prefix\n\t *         (else bad byte is received as 0x00)\n\t * ISTRIP  Strip parity bit\n\t * IGNBRK  Ignore break condition\n\t * BRKINT  Send SIGINT on break - maybe set this?\n\t * INLCR   Map NL to CR\n\t * IGNCR   Ignore CR\n\t * ICRNL   Map CR to NL\n\t * IUCLC   Map uppercase to lowercase\n\t * IMAXBEL Echo BEL on input line too long\n\t * IUTF8   Appears to affect tty's idea of char widths,\n\t *         observed to improve backspacing through Unicode chars\n\t */\n\n\t/* line buffered input (NL or EOL or EOF chars end a line);\n\t * recognize INT/QUIT/SUSP chars;\n\t * echo input chars;\n\t * echo BS-SP-BS on erase character;\n\t * echo kill char specially, not as ^c (ECHOKE controls how exactly);\n\t * erase all input via BS-SP-BS on kill char (else go to next line)\n\t */\n\tG.tty_attrs.c_lflag |= ICANON | ISIG | ECHO | ECHOE | ECHOK | ECHOKE;\n\t/* Other bits in c_lflag:\n\t * XCASE   Map uppercase to \\lowercase [tried, doesn't work]\n\t * ECHONL  Echo NL even if ECHO is not set\n\t * ECHOCTL Echo ctrl chars as ^c (else don't echo) - maybe set this?\n\t * ECHOPRT On erase, echo erased chars\n\t *         [qwe<BS><BS><BS> input looks like \"qwe\\ewq/\" on screen]\n\t * NOFLSH  Don't flush input buffer after interrupt or quit chars\n\t * IEXTEN  Enable extended functions (??)\n\t *         [glibc says it enables c_cc[LNEXT] \"enter literal char\"\n\t *         and c_cc[VDISCARD] \"toggle discard buffered output\" chars]\n\t * FLUSHO  Output being flushed (c_cc[VDISCARD] is in effect)\n\t * PENDIN  Retype pending input at next read or input char\n\t *         (c_cc[VREPRINT] is being processed)\n\t * TOSTOP  Send SIGTTOU for background output\n\t *         (why \"stty sane\" unsets this bit?)\n\t */\n\n\tG.tty_attrs.c_cc[VINTR] = CTL('C');\n\tG.tty_attrs.c_cc[VQUIT] = CTL('\\\\');\n\tG.tty_attrs.c_cc[VEOF] = CTL('D');\n\tG.tty_attrs.c_cc[VEOL] = '\\n';\n#ifdef VSWTC\n\tG.tty_attrs.c_cc[VSWTC] = 0;\n#endif\n#ifdef VSWTCH\n\tG.tty_attrs.c_cc[VSWTCH] = 0;\n#endif\n\tG.tty_attrs.c_cc[VKILL] = CTL('U');\n\t/* Other control chars:\n\t * VEOL2\n\t * VERASE, VWERASE - (word) erase. we may set VERASE in get_logname\n\t * VREPRINT - reprint current input buffer\n\t * VLNEXT, VDISCARD, VSTATUS\n\t * VSUSP, VDSUSP - send (delayed) SIGTSTP\n\t * VSTART, VSTOP - chars used for IXON/IXOFF\n\t */\n\n\tset_tty_attrs();\n\n\t/* Now the newline character should be properly written */\n\tfull_write(STDOUT_FILENO, \"\\n\", 1);\n}\n\n## Example:\n\n Input code:\nunsigned __int64 __fastcall sub_463D34(unsigned int a1)\n{\n  unsigned __int64 result; // rax\n  _QWORD *v2; // rbx\n  _QWORD *v3; // rbx\n\n  result = a1;\n  if ( *((_DWORD *)qword_75D408 + 2) <= a1 )\n  {\n    *((_DWORD *)qword_75D408 + 2) += 256;\n    v2 = qword_75D408;\n    v2[2] = sub_40A09E(*((void **)qword_75D408 + 2), 4LL * *((unsigned int *)qword_75D408 + 2));\n    v3 = qword_75D408;\n    result = (unsigned __int64)sub_40A09E(*((void **)qword_75D408 + 3), *((unsigned int *)qword_75D408 + 2));\n    v3[3] = result;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void ensure_buffer_capacity(int bufindex)\n{\n\tif (bufindex >= G.capacity) {\n\t\tG.capacity += 0x100;\n\t\tG.width = xrealloc(G.width, G.capacity * sizeof(G.width[0]));\n\t\tG.more = xrealloc(G.more, G.capacity * sizeof(G.more[0]));\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_417020(unsigned int a1, unsigned int a2, unsigned int a3)\n{\n  if ( *((_DWORD *)qword_75D408 + 72) == 1 )\n    return ((a2 >> 3) & 0x1C) + (a1 & 0xE0) + (a3 >> 6);\n  if ( *((_DWORD *)qword_75D408 + 72) == 2 )\n    return (a2 >> *((_DWORD *)qword_75D408 + 74) << *((_DWORD *)qword_75D408 + 23))\n         + (a1 >> *((_DWORD *)qword_75D408 + 73) << *((_DWORD *)qword_75D408 + 20))\n         + (a3 >> *((_DWORD *)qword_75D408 + 75) << *((_DWORD *)qword_75D408 + 26));\n  return a3 + (a2 << 8) + (a1 << 16);\n}\n",
        "output": "static __int64 calculate_value(unsigned int a1, unsigned int a2, unsigned int a3)\n{\n\tif (*((_DWORD *)qword_75D408 + 72) == 1)\n\t{\n\t\treturn ((a2 >> 3) & 0x1C) + (a1 & 0xE0) + (a3 >> 6);\n\t}\n\telse if (*((_DWORD *)qword_75D408 + 72) == 2)\n\t{\n\t\treturn (a2 >> *((_DWORD *)qword_75D408 + 74) << *((_DWORD *)qword_75D408 + 23))\n\t\t\t+ (a1 >> *((_DWORD *)qword_75D408 + 73) << *((_DWORD *)qword_75D408 + 20))\n\t\t\t+ (a3 >> *((_DWORD *)qword_75D408 + 75) << *((_DWORD *)qword_75D408 + 26));\n\t}\n\telse\n\t{\n\t\treturn a3 + (a2 << 8) + (a1 << 16);\n\t}\n}",
        "source_code": "static unsigned fb_pixel_value(unsigned r, unsigned g, unsigned b)\n{\n\t/* We assume that the r,g,b values are <= 255 */\n\n\tif (G.bytes_per_pixel == 1) {\n\t\tr = r        & 0xe0; // 3-bit red\n\t\tg = (g >> 3) & 0x1c; // 3-bit green\n\t\tb =  b >> 6;         // 2-bit blue\n\t\treturn r + g + b;\n\t}\n\tif (G.bytes_per_pixel == 2) {\n\t\t// ARM PL110 on Integrator/CP has RGBA5551 bit arrangement.\n\t\t// We want to support bit locations like that.\n\t\t//\n\t\t// First shift out unused bits\n\t\tr = r >> G.red_shift;\n\t\tg = g >> G.green_shift;\n\t\tb = b >> G.blue_shift;\n\t\t// Then shift the remaining bits to their offset\n\t\treturn (r << G.scr_var.red.offset) +\n\t\t\t(g << G.scr_var.green.offset) +\n\t\t\t(b << G.scr_var.blue.offset);\n\t}\n\t// RGB 888\n\treturn b + (g << 8) + (r << 16);\n}",
        "parsed_output": "static __int64 calculate_value(unsigned int a1, unsigned int a2, unsigned int a3)\n{\n\tif (*((_DWORD *)qword_75D408 + 72) == 1)\n\t{\n\t\treturn ((a2 >> 3) & 0x1C) + (a1 & 0xE0) + (a3 >> 6);\n\t}\n\telse if (*((_DWORD *)qword_75D408 + 72) == 2)\n\t{\n\t\treturn (a2 >> *((_DWORD *)qword_75D408 + 74) << *((_DWORD *)qword_75D408 + 23))\n\t\t\t+ (a1 >> *((_DWORD *)qword_75D408 + 73) << *((_DWORD *)qword_75D408 + 20))\n\t\t\t+ (a3 >> *((_DWORD *)qword_75D408 + 75) << *((_DWORD *)qword_75D408 + 26));\n\t}\n\telse\n\t{\n\t\treturn a3 + (a2 << 8) + (a1 << 16);\n\t}\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_417020(unsigned int a1, unsigned int a2, unsigned int a3)\n{\n  if ( *((_DWORD *)qword_75D408 + 72) == 1 )\n    return ((a2 >> 3) & 0x1C) + (a1 & 0xE0) + (a3 >> 6);\n  if ( *((_DWORD *)qword_75D408 + 72) == 2 )\n    return (a2 >> *((_DWORD *)qword_75D408 + 74) << *((_DWORD *)qword_75D408 + 23))\n         + (a1 >> *((_DWORD *)qword_75D408 + 73) << *((_DWORD *)qword_75D408 + 20))\n         + (a3 >> *((_DWORD *)qword_75D408 + 75) << *((_DWORD *)qword_75D408 + 26));\n  return a3 + (a2 << 8) + (a1 << 16);\n}\n",
        "baseline_code_debug": "unsigned int __cdecl fb_pixel_value(unsigned int r, unsigned int g, unsigned int b)\n{\n  if ( ptr_to_globals[1].timeout == 1 )\n    return ((g >> 3) & 0x1C) + (r & 0xE0) + (b >> 6);\n  if ( ptr_to_globals[1].timeout == 2 )\n    return (g >> LODWORD(ptr_to_globals[1].login) << *(_DWORD *)&ptr_to_globals->eol)\n         + (r >> *(&ptr_to_globals[1].timeout + 1) << ptr_to_globals->speeds[7])\n         + (b >> HIDWORD(ptr_to_globals[1].login) << ptr_to_globals->tty_attrs.c_cflag);\n  return b + (g << 8) + (r << 16);\n}\n",
        "similarity_score_unixcoder": 0.5944492816925049,
        "similarity_score_baseline_stripped": 0.5855668783187866,
        "similarity_score_baseline_debug": 0.6600219011306763
    },
    {
        "func_name": "send_NAK",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4562E0(__int64 a1)\n{\n  int v1; // edx\n  int v2; // ecx\n  int v3; // r8d\n  int v4; // r9d\n  char v6[640]; // [rsp+10h] [rbp-280h] BYREF\n\n  sub_455D51((__int64)v6, a1, 5);\n  sub_455DEC((__int64)v6);\n  return sub_455D15((__int64)v6, 0, v1, v2, v3, v4);\n}\n\n\n Revised code:\nstatic NOINLINE void send_inform(struct dhcp_packet *oldpacket)\n{\n\tstruct dhcp_packet packet;\n\n\t/* \"If a client has obtained a network address through some other means\n\t * (e.g., manual configuration), it may use a DHCPINFORM request message\n\t * to obtain other local configuration parameters.  Servers receiving a\n\t * DHCPINFORM message construct a DHCPACK message with any local\n\t * configuration parameters appropriate for the client without:\n\t * allocating a new address, checking for an existing binding, filling\n\t * in 'yiaddr' or including lease time parameters.  The servers SHOULD\n\t * unicast the DHCPACK reply to the address given in the 'ciaddr' field\n\t * of the DHCPINFORM message.\n\t * ...\n\t * The server responds to a DHCPINFORM message by sending a DHCPACK\n\t * message directly to the address given in the 'ciaddr' field\n\t * of the DHCPINFORM message.  The server MUST NOT send a lease\n\t * expiration time to the client and SHOULD NOT fill in 'yiaddr'.\"\n\t */\n//TODO: do a few sanity checks: is ciaddr set?\n//Better yet: is ciaddr == IP source addr?\n\tinit_packet(&packet, oldpacket, DHCPACK);\n\tadd_server_options(&packet);\n\n\tsend_packet(&packet, /*force_bcast:*/ 0);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_454561(unsigned int a1, unsigned int a2)\n{\n  int v2; // edx\n  int v3; // ecx\n  int v4; // r8d\n  int v5; // r9d\n  char v7[640]; // [rsp+10h] [rbp-280h] BYREF\n\n  sub_454080((__int64)v7, 4);\n  sub_459C35(v7, 50LL, a2);\n  sub_459C35(v7, 54LL, a1);\n  sub_4FDABC((unsigned int)\"Sending decline...\", 54, v2, v3, v4, v5);\n  return sub_45432B((int)v7);\n}\n\n\n Revised code:\nstatic NOINLINE int send_decline(/*uint32_t xid,*/ uint32_t server, uint32_t requested)\n{\n\tstruct dhcp_packet packet;\n\n\t/* Fill in: op, htype, hlen, cookie, chaddr, random xid fields,\n\t * client-id option (unless -C), message type option:\n\t */\n\tinit_packet(&packet, DHCPDECLINE);\n\n#if 0\n\t/* RFC 2131 says DHCPDECLINE's xid is randomly selected by client,\n\t * but in case the server is buggy and wants DHCPDECLINE's xid\n\t * to match the xid which started entire handshake,\n\t * we use the same xid we used in initial DHCPDISCOVER:\n\t */\n\tpacket.xid = xid;\n#endif\n\t/* DHCPDECLINE uses \"requested ip\", not ciaddr, to store offered IP */\n\tudhcp_add_simple_option(&packet, DHCP_REQUESTED_IP, requested);\n\n\tudhcp_add_simple_option(&packet, DHCP_SERVER_ID, server);\n\n\tbb_info_msg(\"Sending decline...\");\n\treturn raw_bcast_from_client_config_ifindex(&packet);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4545E0(unsigned int a1, unsigned int a2)\n{\n  int v2; // edx\n  int v3; // ecx\n  int v4; // r8d\n  int v5; // r9d\n  char v7[12]; // [rsp+10h] [rbp-280h] BYREF\n  unsigned int v8; // [rsp+1Ch] [rbp-274h]\n\n  sub_454080((__int64)v7, 7);\n  v8 = a2;\n  sub_459C35(v7, 54LL, a1);\n  sub_4FDABC((unsigned int)\"Sending release...\", 54, v2, v3, v4, v5);\n  return sub_458D07(v7, a2, 68LL, a1, 67LL);\n}\n\n\n Revised code:\nstatic int send_release(uint32_t server, uint32_t ciaddr)\n{\n\tstruct dhcp_packet packet;\n\n\t/* Fill in: op, htype, hlen, cookie, chaddr, random xid fields,\n\t * client-id option (unless -C), message type option:\n\t */\n\tinit_packet(&packet, DHCPRELEASE);\n\n\t/* DHCPRELEASE uses ciaddr, not \"requested ip\", to store IP being released */\n\tpacket.ciaddr = ciaddr;\n\n\tudhcp_add_simple_option(&packet, DHCP_SERVER_ID, server);\n\n\tbb_info_msg(\"Sending release...\");\n\treturn udhcp_send_kernel_packet(&packet, ciaddr, CLIENT_PORT, server, SERVER_PORT);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_456160(__int64 a1)\n{\n  int v1; // edx\n  int v2; // ecx\n  int v3; // r8d\n  int v4; // r9d\n  char v6[640]; // [rsp+10h] [rbp-280h] BYREF\n\n  sub_455D51((__int64)v6, a1, 6);\n  if ( dword_75D460 )\n    sub_4FDABC((unsigned int)\"Sending NAK\", a1, v1, v2, v3, v4);\n  return sub_455D15((__int64)v6, 1, v1, v2, v3, v4);\n}\n",
        "output": "static NOINLINE void send_nak(struct dhcp_packet *oldpacket)\n{\n\tstruct dhcp_packet packet;\n\n\tinit_packet(&packet, oldpacket, DHCPNAK);\n\n\tif (dword_75D460)\n\t\tbb_info_msg(\"Sending NAK\");\n\n\tsend_packet(&packet, /*force_bcast:*/ 1);\n}",
        "source_code": "static NOINLINE void send_NAK(struct dhcp_packet *oldpacket)\n{\n\tstruct dhcp_packet packet;\n\n\tinit_packet(&packet, oldpacket, DHCPNAK);\n\n\tlog1(\"Sending NAK\");\n\tsend_packet(&packet, /*force_bcast:*/ 1);\n}",
        "parsed_output": "static NOINLINE void send_nak(struct dhcp_packet *oldpacket)\n{\n\tstruct dhcp_packet packet;\n\n\tinit_packet(&packet, oldpacket, DHCPNAK);\n\n\tif (dword_75D460)\n\t\tbb_info_msg(\"Sending NAK\");\n\n\tsend_packet(&packet, /*force_bcast:*/ 1);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_456160(__int64 a1)\n{\n  int v1; // edx\n  int v2; // ecx\n  int v3; // r8d\n  int v4; // r9d\n  char v6[640]; // [rsp+10h] [rbp-280h] BYREF\n\n  sub_455D51((__int64)v6, a1, 6);\n  if ( dword_75D460 )\n    sub_4FDABC((unsigned int)\"Sending NAK\", a1, v1, v2, v3, v4);\n  return sub_455D15((__int64)v6, 1, v1, v2, v3, v4);\n}\n",
        "baseline_code_debug": "void __cdecl send_NAK(dhcp_packet *oldpacket)\n{\n  dhcp_packet packet; // [rsp+10h] [rbp-280h] BYREF\n\n  init_packet_0(&packet, oldpacket, 6);\n  if ( dhcp_verbose )\n    bb_info_msg(\"Sending NAK\");\n  send_packet(&packet, 1);\n}\n",
        "similarity_score_unixcoder": 0.9580737948417664,
        "similarity_score_baseline_stripped": 0.41566652059555054,
        "similarity_score_baseline_debug": 0.8072834610939026
    },
    {
        "func_name": "handle_sigchld",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 sub_435324()\n{\n  __int64 v0; // rcx\n  __int64 v1; // r8\n  __int64 v2; // r9\n  __int64 result; // rax\n  int v4; // [rsp+1Ch] [rbp-14h] BYREF\n  int v5; // [rsp+20h] [rbp-10h]\n  int v6; // [rsp+24h] [rbp-Ch]\n  __int64 i; // [rsp+28h] [rbp-8h]\n\n  v6 = *(_DWORD *)qword_75D400;\nLABEL_2:\n  while ( 1 )\n  {\n    v5 = sub_409F8A(&v4);\n    if ( v5 <= 0 )\n      break;\n    for ( i = *(_QWORD *)&dest.c_cc[7]; i; i = *(_QWORD *)(i + 88) )\n    {\n      if ( v5 == *(_DWORD *)(i + 44) )\n      {\n        if ( (v4 & 0x7F) != 0 || !BYTE1(v4) )\n        {\n          if ( (char)((v4 & 0x7F) + 1) >> 1 > 0 )\n            sub_409747(\"%s: exit signal %u\", *(_QWORD *)(i + 104), v4 & 0x7F, v0, v1, v2);\n        }\n        else\n        {\n          sub_409747(\"%s: exit status %u\", *(_QWORD *)(i + 104), BYTE1(v4), v0, v1, v2);\n        }\n        *(_DWORD *)(i + 44) = 1;\n        sub_433E79(*(_DWORD *)i);\n        goto LABEL_2;\n      }\n    }\n  }\n  result = qword_75D400;\n  *(_DWORD *)qword_75D400 = v6;\n  return result;\n}\n\n\n Revised code:\nstatic void reap_child(int sig UNUSED_PARAM)\n{\n\tpid_t pid;\n\tint status;\n\tservtab_t *sep;\n\tint save_errno = errno;\n\n\tfor (;;) {\n\t\tpid = wait_any_nohang(&status);\n\t\tif (pid <= 0)\n\t\t\tbreak;\n\t\tfor (sep = serv_list; sep; sep = sep->se_next) {\n\t\t\tif (sep->se_wait != pid)\n\t\t\t\tcontinue;\n\t\t\t/* One of our \"wait\" services */\n\t\t\tif (WIFEXITED(status) && WEXITSTATUS(status))\n\t\t\t\tbb_error_msg(\"%s: exit status %u\",\n\t\t\t\t\t\tsep->se_program, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tbb_error_msg(\"%s: exit signal %u\",\n\t\t\t\t\t\tsep->se_program, WTERMSIG(status));\n\t\t\tsep->se_wait = 1;\n\t\t\tadd_fd_to_set(sep->se_fd);\n\t\t\tbreak;\n\t\t}\n\t}\n\terrno = save_errno;\n}\n\n## Example:\n\n Input code:\nvoid sub_433F24()\n{\n  int v0; // [rsp+Ch] [rbp-4h]\n\n  v0 = 0;\n  *(_DWORD *)&dest.c_cc[19] = 0;\n  while ( v0 <= *(_DWORD *)&dest.c_cc[23] )\n  {\n    if ( (qword_75B4D8[v0 / 64] & (1LL << (v0 % 64))) != 0 )\n      *(_DWORD *)&dest.c_cc[19] = v0;\n    ++v0;\n  }\n  *(_DWORD *)&dest.c_cc[23] = *(_DWORD *)&dest.c_cc[19];\n  if ( *(int *)&dest.c_cc[19] > (unsigned __int64)(*(_QWORD *)&dest.c_iflag - 8LL) )\n    sub_433D6A();\n}\n\n\n Revised code:\nstatic void recalculate_maxsock(void)\n{\n\tint fd = 0;\n\n\t/* We may have no services, in this case maxsock should still be >= 0\n\t * (code elsewhere is not happy with maxsock == -1) */\n\tmaxsock = 0;\n\twhile (fd <= prev_maxsock) {\n\t\tif (FD_ISSET(fd, &allsock))\n\t\t\tmaxsock = fd;\n\t\tfd++;\n\t}\n\tdbg(\"recalculated maxsock:%d\\n\", maxsock);\n\tprev_maxsock = maxsock;\n\tif ((rlim_t)maxsock > rlim_ofile_cur - FD_MARGIN)\n\t\tbump_nofile();\n}\n\n## Example:\n\n Input code:\n__int64 sub_43542A()\n{\n  __int64 result; // rax\n  int v1; // [rsp+14h] [rbp-Ch]\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  v1 = *(_DWORD *)qword_75D400;\n  dest.c_cc[31] = 0;\n  for ( i = *(_QWORD *)&dest.c_cc[7]; i; i = *(_QWORD *)(i + 88) )\n  {\n    if ( *(_DWORD *)i == -1 )\n    {\n      sub_433FCC(i);\n      if ( *(_DWORD *)i != -1 )\n      {\n        if ( *(_DWORD *)(i + 36) )\n          sub_433BF2(i);\n      }\n    }\n  }\n  result = qword_75D400;\n  *(_DWORD *)qword_75D400 = v1;\n  return result;\n}\n\n\n Revised code:\nstatic void retry_network_setup(int sig UNUSED_PARAM)\n{\n\tint save_errno = errno;\n\tservtab_t *sep;\n\n\talarm_armed = 0;\n\tfor (sep = serv_list; sep; sep = sep->se_next) {\n\t\tif (sep->se_fd == -1) {\n\t\t\tprepare_socket_fd(sep);\n#if ENABLE_FEATURE_INETD_RPC\n\t\t\tif (sep->se_fd != -1 && is_rpc_service(sep))\n\t\t\t\tregister_rpc(sep);\n#endif\n\t\t}\n\t}\n\terrno = save_errno;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid sub_442FA2()\n{\n  int v0; // [rsp+10h] [rbp-10h]\n  int v1; // [rsp+14h] [rbp-Ch]\n  __int64 *i; // [rsp+18h] [rbp-8h]\n\n  v1 = *(_DWORD *)qword_75D400;\nLABEL_2:\n  while ( 1 )\n  {\n    v0 = sub_409F8A(0LL);\n    if ( v0 <= 0 )\n      break;\n    for ( i = *(__int64 **)&dest.c_iflag; i; i = (__int64 *)*i )\n    {\n      if ( v0 == *((_DWORD *)i + 2) )\n      {\n        *((_DWORD *)i + 2) = -1;\n        sub_509F5C((unsigned int)v0, 8LL, 0LL, 0LL, 0LL);\n        goto LABEL_2;\n      }\n    }\n  }\n  *(_DWORD *)qword_75D400 = v1;\n}\n",
        "output": "static void clear_flags()\n{\n\tint v0;\n\tint v1;\n\t__int64 *i;\n\n\tv1 = *(_DWORD *)qword_75D400;\nLABEL_2:\n\twhile (1)\n\t{\n\t\tv0 = sub_409F8A(0LL);\n\t\tif (v0 <= 0)\n\t\t\tbreak;\n\t\tfor (i = *(__int64 **)&dest.c_iflag; i; i = (__int64 *)*i)\n\t\t{\n\t\t\tif (v0 == *((_DWORD *)i + 2))\n\t\t\t{\n\t\t\t\t*((_DWORD *)i + 2) = -1;\n\t\t\t\tsub_509F5C((unsigned int)v0, 8LL, 0LL, 0LL, 0LL);\n\t\t\t\tgoto LABEL_2;\n\t\t\t}\n\t\t}\n\t}\n\t*(_DWORD *)qword_75D400 = v1;\n}",
        "source_code": "endif\n\nstatic void handle_sigchld(int sig UNUSED_PARAM)\n{\n\tpid_t pid;\n\tstruct tsession *ts;\n\tint save_errno = errno;\n\n\t/* Looping: more than one child may have exited */\n\twhile (1) {\n\t\tpid = wait_any_nohang(NULL);\n\t\tif (pid <= 0)\n\t\t\tbreak;\n\t\tts = G.sessions;\n\t\twhile (ts) {\n\t\t\tif (ts->shell_pid == pid) {\n\t\t\t\tts->shell_pid = -1;\n// man utmp:\n// When init(8) finds that a process has exited, it locates its utmp entry\n// by ut_pid, sets ut_type to DEAD_PROCESS, and clears ut_user, ut_host\n// and ut_time with null bytes.\n// [same applies to other processes which maintain utmp entries, like telnetd]\n//\n// We do not bother actually clearing fields:\n// it might be interesting to know who was logged in and from where\n\t\t\t\tupdate_utmp(pid, DEAD_PROCESS, /*tty_name:*/ NULL, /*username:*/ NULL, /*hostname:*/ NULL);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tts = ts->next;\n\t\t}\n\t}\n\n\terrno = save_errno;\n}",
        "parsed_output": "static void clear_flags()\n{\n\tint v0;\n\tint v1;\n\t__int64 *i;\n\n\tv1 = *(_DWORD *)qword_75D400;\nLABEL_2:\n\twhile (1)\n\t{\n\t\tv0 = sub_409F8A(0LL);\n\t\tif (v0 <= 0)\n\t\t\tbreak;\n\t\tfor (i = *(__int64 **)&dest.c_iflag; i; i = (__int64 *)*i)\n\t\t{\n\t\t\tif (v0 == *((_DWORD *)i + 2))\n\t\t\t{\n\t\t\t\t*((_DWORD *)i + 2) = -1;\n\t\t\t\tsub_509F5C((unsigned int)v0, 8LL, 0LL, 0LL, 0LL);\n\t\t\t\tgoto LABEL_2;\n\t\t\t}\n\t\t}\n\t}\n\t*(_DWORD *)qword_75D400 = v1;\n}",
        "baseline_code_stripped": "void sub_442FA2()\n{\n  int v0; // [rsp+10h] [rbp-10h]\n  int v1; // [rsp+14h] [rbp-Ch]\n  __int64 *i; // [rsp+18h] [rbp-8h]\n\n  v1 = *(_DWORD *)qword_75D400;\nLABEL_2:\n  while ( 1 )\n  {\n    v0 = sub_409F8A(0LL);\n    if ( v0 <= 0 )\n      break;\n    for ( i = *(__int64 **)&dest.c_iflag; i; i = (__int64 *)*i )\n    {\n      if ( v0 == *((_DWORD *)i + 2) )\n      {\n        *((_DWORD *)i + 2) = -1;\n        sub_509F5C((unsigned int)v0, 8LL, 0LL, 0LL, 0LL);\n        goto LABEL_2;\n      }\n    }\n  }\n  *(_DWORD *)qword_75D400 = v1;\n}\n",
        "baseline_code_debug": "void __cdecl handle_sigchld(int sig)\n{\n  int pid; // [rsp+10h] [rbp-10h]\n  int save_errno; // [rsp+14h] [rbp-Ch]\n  tsession *ts; // [rsp+18h] [rbp-8h]\n\n  save_errno = *bb_errno;\nLABEL_2:\n  while ( 1 )\n  {\n    pid = wait_any_nohang(0LL);\n    if ( pid <= 0 )\n      break;\n    for ( ts = *(tsession **)&bb_common_bufsiz1.c_iflag; ts; ts = ts->next )\n    {\n      if ( pid == ts->shell_pid )\n      {\n        ts->shell_pid = -1;\n        update_utmp(pid, 8, 0LL, 0LL, 0LL);\n        goto LABEL_2;\n      }\n    }\n  }\n  *bb_errno = save_errno;\n}\n",
        "similarity_score_unixcoder": 0.42173531651496887,
        "similarity_score_baseline_stripped": 0.3961371183395386,
        "similarity_score_baseline_debug": 0.8248199820518494
    },
    {
        "func_name": "write_superblock",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 sub_498E36()\n{\n  size_t v0; // rax\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n\n  memset(*((void **)qword_75D408 + 9), 0, (unsigned int)*((unsigned __int16 *)qword_75D408 + 210) + 1);\n  if ( *(_BYTE *)qword_75D408 )\n    v0 = *((unsigned int *)qword_75D408 + 110);\n  else\n    v0 = *((unsigned __int16 *)qword_75D408 + 211);\n  memset(*((void **)qword_75D408 + 10), 0, v0);\n  sub_497BCD(1u);\n  sub_498354(1u, 0LL, v1, v2, v3, v4);\n  return sub_4988FF();\n}\n\n\n Revised code:\nif ENABLE_FEATURE_MINIX2\nstatic void check2(void)\n{\n\tmemset(inode_count, 0, (INODES + 1) * sizeof(*inode_count));\n\tmemset(zone_count, 0, ZONES * sizeof(*zone_count));\n\tcheck_zones2(MINIX_ROOT_INO);\n\trecursive_check2(MINIX_ROOT_INO);\n\tcheck_counts2();\n}\n\n## Example:\n\n Input code:\n__int64 sub_496B5E()\n{\n  char *v0; // rsi\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  __int64 v5; // rdx\n  __int64 v6; // rcx\n  int v7; // eax\n  __int64 v8; // rdx\n  __int64 result; // rax\n\n  sub_40A557(3, 1024LL, 0);\n  v0 = (char *)qword_75D408 + 420;\n  if ( sub_40B446(3, (char *)qword_75D408 + 420, 0x400uLL) != 1024 )\n    sub_495EC2((__int64)\"can't read superblock\", (__int64)v0, v1, v2, v3, v4);\n  if ( *((_WORD *)qword_75D408 + 218) != 4991 )\n  {\n    switch ( *((_WORD *)qword_75D408 + 218) )\n    {\n      case 0x138F:\n        *((_BYTE *)qword_75D408 + 5) = 30;\n        *((_BYTE *)qword_75D408 + 4) = 32;\n        break;\n      case 0x2468:\n        *(_BYTE *)qword_75D408 = 1;\n        break;\n      case 0x2478:\n        *((_BYTE *)qword_75D408 + 5) = 30;\n        *((_BYTE *)qword_75D408 + 4) = 32;\n        *(_BYTE *)qword_75D408 = 1;\n        break;\n      default:\n        sub_495EC2((__int64)\"bad magic number in superblock\", (__int64)v0, v1, v2, v3, v4);\n    }\n  }\n  if ( *((_WORD *)qword_75D408 + 215) )\n    sub_495EC2((__int64)\"only 1k blocks/zones supported\", (__int64)v0, v1, v2, v3, v4);\n  v5 = *((unsigned __int16 *)qword_75D408 + 212) << 13;\n  if ( (unsigned int)v5 < (unsigned int)*((unsigned __int16 *)qword_75D408 + 210) + 1 )\n    sub_495EC2((__int64)\"bad s_imap_blocks field in superblock\", (__int64)v0, v5, v2, v3, v4);\n  v6 = *((unsigned __int16 *)qword_75D408 + 213) << 13;\n  if ( *(_BYTE *)qword_75D408 )\n    v7 = *((_DWORD *)qword_75D408 + 110);\n  else\n    v7 = *((unsigned __int16 *)qword_75D408 + 211);\n  v8 = *((unsigned __int16 *)qword_75D408 + 214);\n  result = (unsigned int)(v7 - v8 + 1);\n  if ( (unsigned int)v6 < (unsigned int)result )\n    sub_495EC2((__int64)\"bad s_zmap_blocks field in superblock\", (__int64)v0, v8, v6, v3, v4);\n  return result;\n}\n\n\n Revised code:\nstatic void read_superblock(void)\n{\n\txlseek(dev_fd, BLOCK_SIZE, SEEK_SET);\n\tif (BLOCK_SIZE != full_read(dev_fd, superblock_buffer, BLOCK_SIZE))\n\t\tdie(\"can't read superblock\");\n\t/* already initialized to:\n\tnamelen = 14;\n\tdirsize = 16;\n\tversion2 = 0;\n\t*/\n\tif (MAGIC == MINIX1_SUPER_MAGIC) {\n\t} else if (MAGIC == MINIX1_SUPER_MAGIC2) {\n\t\tnamelen = 30;\n\t\tdirsize = 32;\n#if ENABLE_FEATURE_MINIX2\n\t} else if (MAGIC == MINIX2_SUPER_MAGIC) {\n\t\tversion2 = 1;\n\t} else if (MAGIC == MINIX2_SUPER_MAGIC2) {\n\t\tnamelen = 30;\n\t\tdirsize = 32;\n\t\tversion2 = 1;\n#endif\n\t} else\n\t\tdie(\"bad magic number in superblock\");\n\tif (ZONESIZE != 0 || BLOCK_SIZE != 1024)\n\t\tdie(\"only 1k blocks/zones supported\");\n\tif (IMAPS * BLOCK_SIZE * 8 < INODES + 1)\n\t\tdie(\"bad s_imap_blocks field in superblock\");\n\tif (ZMAPS * BLOCK_SIZE * 8 < ZONES - FIRSTZONE + 1)\n\t\tdie(\"bad s_zmap_blocks field in superblock\");\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_49096C(__int64 a1, __int64 a2)\n{\n  void *v2; // rax\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  char *v6; // rsi\n  __int64 v7; // rdx\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  __int64 result; // rax\n\n  *(_DWORD *)(a1 + 16) = a2;\n  v2 = sub_40A0E8(*((unsigned int *)qword_75D408 + 6), a2);\n  *(_QWORD *)(a1 + 24) = v2;\n  sub_4905B5(a2, a2, (__int64)v2, v3, v4, v5);\n  v6 = *(char **)(a1 + 24);\n  v7 = sub_40B446(3, v6, *((unsigned int *)qword_75D408 + 6));\n  if ( v7 != *((_DWORD *)qword_75D408 + 6) )\n    sub_49055E(\"can't read from %s\", (__int64)v6, v7, v8, v9, v10);\n  *(_BYTE *)(a1 + 32) = 0;\n  *(_QWORD *)(a1 + 8) = 0LL;\n  result = a1;\n  *(_QWORD *)a1 = *(_QWORD *)(a1 + 8);\n  return result;\n}\n\n\n Revised code:\nstatic void\nread_pte(struct pte *pe, sector_t offset)\n{\n\tpe->offset_from_dev_start = offset;\n\tpe->sectorbuffer = xzalloc(sector_size);\n\tseek_sector(offset);\n\t/* xread would make us abort - bad for fdisk -l */\n\tif (full_read(dev_fd, pe->sectorbuffer, sector_size) != sector_size)\n\t\tfdisk_fatal(unable_to_read);\n#if ENABLE_FEATURE_FDISK_WRITABLE\n\tpe->changed = 0;\n#endif\n\tpe->part_table = pe->ext_pointer = NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_4968A5()\n{\n  char *v0; // rsi\n  __int64 result; // rax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n\n  *((_WORD *)qword_75D408 + 219) |= 3u;\n  if ( !*((_BYTE *)qword_75D408 + 2) )\n    *((_WORD *)qword_75D408 + 219) &= ~2u;\n  sub_40A557(3, 1024LL, 0);\n  v0 = (char *)qword_75D408 + 420;\n  result = sub_40B38A(3u, (__int64)qword_75D408 + 420, 1024LL);\n  if ( result != 1024 )\n    sub_495EC2((__int64)\"can't write superblock\", (__int64)v0, v2, v3, v4, v5);\n  return result;\n}\n",
        "output": "static void write_superblock(void)\n{\n\t*((unsigned short *)superblock_buffer + 219) |= 3;\n\tif (!*((unsigned char *)superblock_buffer + 2))\n\t\t*((unsigned short *)superblock_buffer + 219) &= ~2;\n\txlseek(dev_fd, BLOCK_SIZE, SEEK_SET);\n\tif (BLOCK_SIZE != full_write(dev_fd, superblock_buffer, BLOCK_SIZE))\n\t\tdie(\"can't write superblock\");\n}",
        "source_code": "endif\n\nstatic void write_superblock(void)\n{\n\t/*\n\t * Set the state of the filesystem based on whether or not there\n\t * are uncorrected errors.  The filesystem valid flag is\n\t * unconditionally set if we get this far.\n\t */\n\tSuper.s_state |= MINIX_VALID_FS | MINIX_ERROR_FS;\n\tif (!errors_uncorrected)\n\t\tSuper.s_state &= ~MINIX_ERROR_FS;\n\n\txlseek(dev_fd, BLOCK_SIZE, SEEK_SET);\n\tif (BLOCK_SIZE != full_write(dev_fd, superblock_buffer, BLOCK_SIZE))\n\t\tdie(\"can't write superblock\");\n}",
        "parsed_output": "static void write_superblock(void)\n{\n\t*((unsigned short *)superblock_buffer + 219) |= 3;\n\tif (!*((unsigned char *)superblock_buffer + 2))\n\t\t*((unsigned short *)superblock_buffer + 219) &= ~2;\n\txlseek(dev_fd, BLOCK_SIZE, SEEK_SET);\n\tif (BLOCK_SIZE != full_write(dev_fd, superblock_buffer, BLOCK_SIZE))\n\t\tdie(\"can't write superblock\");\n}",
        "baseline_code_stripped": "__int64 sub_4968A5()\n{\n  char *v0; // rsi\n  __int64 result; // rax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n\n  *((_WORD *)qword_75D408 + 219) |= 3u;\n  if ( !*((_BYTE *)qword_75D408 + 2) )\n    *((_WORD *)qword_75D408 + 219) &= ~2u;\n  sub_40A557(3, 1024LL, 0);\n  v0 = (char *)qword_75D408 + 420;\n  result = sub_40B38A(3u, (__int64)qword_75D408 + 420, 1024LL);\n  if ( result != 1024 )\n    sub_495EC2((__int64)\"can't write superblock\", (__int64)v0, v2, v3, v4, v5);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl write_superblock()\n{\n  HIWORD(ptr_to_globals[1].tty_attrs.c_ispeed) |= 3u;\n  if ( !BYTE2(ptr_to_globals->timeout) )\n    HIWORD(ptr_to_globals[1].tty_attrs.c_ispeed) &= ~2u;\n  xlseek(3, 1024LL, 0);\n  if ( full_write(3, &ptr_to_globals[1].tty_attrs.c_cc[19], 0x400uLL) != 1024 )\n    die(\"can't write superblock\");\n}\n",
        "similarity_score_unixcoder": 0.7998217344284058,
        "similarity_score_baseline_stripped": 0.5116351842880249,
        "similarity_score_baseline_debug": 0.5905686020851135
    },
    {
        "func_name": "builtin_unset",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_422816(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  const char **v6; // rax\n  __int64 *v8; // [rsp+0h] [rbp-20h]\n  char v9; // [rsp+1Ch] [rbp-4h]\n\n  qword_75D440 = (__int64)\"-1:b-aG:G-ab:a-bG\";\n  v9 = sub_4FA1EF(a2, (unsigned int)\"bGavzg\", a3, a4, a5, a6);\n  v8 = (__int64 *)(8LL * optind + a2);\n  if ( !v8[1] )\n    v9 |= 0x20u;\n  if ( (v9 & 0x20) == 0 )\n  {\n    sub_4225A4(v8, v9);\n    v8[1] = 0LL;\n  }\n  if ( (v9 & 0x28) != 0 )\n  {\n    do\n    {\n      v6 = (const char **)v8++;\n      sub_42239D(*v6, v9 & 7);\n    }\n    while ( *v8 );\n  }\n  return 0LL;\n}\n\n\n Revised code:\nint setserial_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint opts;\n\n\topt_complementary = \"-1:b-aG:G-ab:a-bG\";\n\topts = getopt32(argv, \"bGavzg\");\n\targv += optind;\n\n\tif (!argv[1]) /* one arg only? */\n\t\topts |= OPT_GET;\n\n\tif (!(opts & OPT_GET)) {\n\t\tserial_set(argv, opts);\n\t\targv[1] = NULL;\n\t}\n\n\tif (opts & (OPT_VERBOSE | OPT_GET)) {\n\t\tdo {\n\t\t\tserial_get(*argv++, opts & OPT_MODE_MASK);\n\t\t} while (*argv);\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47EC20(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  int v7; // [rsp+1Ch] [rbp-14h]\n  char v8; // [rsp+1Ch] [rbp-14h]\n  char v9; // [rsp+20h] [rbp-10h]\n  int v10; // [rsp+24h] [rbp-Ch]\n  unsigned __int8 **i; // [rsp+28h] [rbp-8h]\n\n  v10 = 0;\n  v9 = 0;\n  while ( 1 )\n  {\n    v7 = sub_46F038(\"vf\", a2, a3, a4, a5, a6);\n    if ( !v7 )\n      break;\n    v10 = v7;\n  }\n  for ( i = (unsigned __int8 **)qword_75AF58; *i; ++i )\n  {\n    if ( v10 != 102 )\n    {\n      v8 = sub_46F900(*i);\n      v9 |= v8;\n      if ( (v8 & 2) == 0 )\n        continue;\n    }\n    if ( v10 != 118 )\n      sub_47EBE4((const char *)*i);\n  }\n  return v9 & 1;\n}\n\n\n Revised code:\nstatic int FAST_FUNC\nunsetcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tchar **ap;\n\tint i;\n\tint flag = 0;\n\tint ret = 0;\n\n\twhile ((i = nextopt(\"vf\")) != 0) {\n\t\tflag = i;\n\t}\n\n\tfor (ap = argptr; *ap; ap++) {\n\t\tif (flag != 'f') {\n\t\t\ti = unsetvar(*ap);\n\t\t\tret |= i;\n\t\t\tif (!(i & 2))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (flag != 'v')\n\t\t\tunsetfunc(*ap);\n\t}\n\treturn ret & 1;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_461A9A(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  _QWORD *v6; // rax\n  _QWORD *v8; // [rsp+0h] [rbp-20h]\n  unsigned int v9; // [rsp+14h] [rbp-Ch]\n  unsigned int v10; // [rsp+18h] [rbp-8h]\n  unsigned int v11; // [rsp+1Ch] [rbp-4h]\n\n  v10 = sub_4FA1EF(a2, (unsigned int)\"xq\", a3, a4, a5, a6);\n  v8 = (_QWORD *)(8LL * optind + a2);\n  v11 = 0;\n  while ( *v8 )\n  {\n    v6 = v8++;\n    v9 = sub_50B306(*v6);\n    if ( (unsigned int)sub_46197E(v9, v10) )\n      v11 = 42;\n  }\n  return v11;\n}\n\n\n Revised code:\nint pmap_main(int argc UNUSED_PARAM, char **argv)\n{\n\tunsigned opts;\n\tint ret;\n\n\topts = getopt32(argv, \"xq\");\n\targv += optind;\n\n\tret = 0;\n\twhile (*argv) {\n\t\tpid_t pid = xatoi_positive(*argv++);\n\t\t/* GNU pmap returns 42 if any of the pids failed */\n\t\tif (procps_get_maps(pid, opts) != 0)\n\t\t\tret = 42;\n\t}\n\n\treturn ret;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_48A4B3(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  const char **v11; // [rsp+8h] [rbp-18h]\n  int v12; // [rsp+18h] [rbp-8h]\n  unsigned int v13; // [rsp+1Ch] [rbp-4h]\n\n  v12 = sub_4FA1EF(a1, (unsigned int)\"!+vf\", a3, a4, a5, a6);\n  if ( v12 == -1 )\n    return 1LL;\n  if ( v12 == 3 )\n  {\n    sub_409747(\"unset: -v and -f are exclusive\", (__int64)\"!+vf\", v6, v7, v8, v9);\n    return 1LL;\n  }\n  else\n  {\n    v11 = (const char **)(8LL * optind + a1);\n    v13 = 0;\n    while ( *v11 )\n    {\n      if ( (v12 & 2) != 0 )\n      {\n        sub_4868F4(*v11);\n      }\n      else if ( (unsigned int)sub_480D48(*v11) )\n      {\n        v13 = 1;\n      }\n      ++v11;\n    }\n    return v13;\n  }\n}\n",
        "output": "int unset_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint opts;\n\tconst char **ap;\n\tint ret = 0;\n\n\topts = getopt32(argv, \"!+vf\");\n\targv += optind;\n\n\tif (opts == -1)\n\t\treturn 1;\n\n\tif (opts == 3) {\n\t\tbb_error_msg(\"unset: -v and -f are exclusive\");\n\t\treturn 1;\n\t}\n\n\tap = argptr;\n\twhile (*ap) {\n\t\tif (opts & 2)\n\t\t\tunsetvar(*ap);\n\t\telse if (sub_480D48(*ap))\n\t\t\tret = 1;\n\t\tap++;\n\t}\n\n\treturn ret;\n}",
        "source_code": "static int FAST_FUNC builtin_unset(char **argv)\n{\n\tint ret;\n\tunsigned opts;\n\n\t/* \"!\": do not abort on errors */\n\t/* \"+\": stop at 1st non-option */\n\topts = getopt32(argv, \"!+vf\");\n\tif (opts == (unsigned)-1)\n\t\treturn EXIT_FAILURE;\n\tif (opts == 3) {\n\t\tbb_error_msg(\"unset: -v and -f are exclusive\");\n\t\treturn EXIT_FAILURE;\n\t}\n\targv += optind;\n\n\tret = EXIT_SUCCESS;\n\twhile (*argv) {\n\t\tif (!(opts & 2)) { /* not -f */\n\t\t\tif (unset_local_var(*argv)) {\n\t\t\t\t/* unset <nonexistent_var> doesn't fail.\n\t\t\t\t * Error is when one tries to unset RO var.\n\t\t\t\t * Message was printed by unset_local_var. */\n\t\t\t\tret = EXIT_FAILURE;\n\t\t\t}\n\t\t}\n#if ENABLE_HUSH_FUNCTIONS\n\t\telse {\n\t\t\tunset_func(*argv);\n\t\t}\n#endif\n\t\targv++;\n\t}\n\treturn ret;\n}",
        "parsed_output": "int unset_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint opts;\n\tconst char **ap;\n\tint ret = 0;\n\n\topts = getopt32(argv, \"!+vf\");\n\targv += optind;\n\n\tif (opts == -1)\n\t\treturn 1;\n\n\tif (opts == 3) {\n\t\tbb_error_msg(\"unset: -v and -f are exclusive\");\n\t\treturn 1;\n\t}\n\n\tap = argptr;\n\twhile (*ap) {\n\t\tif (opts & 2)\n\t\t\tunsetvar(*ap);\n\t\telse if (sub_480D48(*ap))\n\t\t\tret = 1;\n\t\tap++;\n\t}\n\n\treturn ret;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_48A4B3(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  const char **v11; // [rsp+8h] [rbp-18h]\n  int v12; // [rsp+18h] [rbp-8h]\n  unsigned int v13; // [rsp+1Ch] [rbp-4h]\n\n  v12 = sub_4FA1EF(a1, (unsigned int)\"!+vf\", a3, a4, a5, a6);\n  if ( v12 == -1 )\n    return 1LL;\n  if ( v12 == 3 )\n  {\n    sub_409747(\"unset: -v and -f are exclusive\", (__int64)\"!+vf\", v6, v7, v8, v9);\n    return 1LL;\n  }\n  else\n  {\n    v11 = (const char **)(8LL * optind + a1);\n    v13 = 0;\n    while ( *v11 )\n    {\n      if ( (v12 & 2) != 0 )\n      {\n        sub_4868F4(*v11);\n      }\n      else if ( (unsigned int)sub_480D48(*v11) )\n      {\n        v13 = 1;\n      }\n      ++v11;\n    }\n    return v13;\n  }\n}\n",
        "baseline_code_debug": "int __cdecl builtin_unset(char **argv)\n{\n  char **argva; // [rsp+8h] [rbp-18h]\n  unsigned int opts; // [rsp+18h] [rbp-8h]\n  int ret; // [rsp+1Ch] [rbp-4h]\n\n  opts = getopt32(argv, \"!+vf\");\n  if ( opts == -1 )\n    return 1;\n  if ( opts == 3 )\n  {\n    bb_error_msg(\"unset: -v and -f are exclusive\");\n    return 1;\n  }\n  else\n  {\n    argva = &argv[optind];\n    ret = 0;\n    while ( *argva )\n    {\n      if ( (opts & 2) != 0 )\n      {\n        unset_func(*argva);\n      }\n      else if ( unset_local_var(*argva) )\n      {\n        ret = 1;\n      }\n      ++argva;\n    }\n    return ret;\n  }\n}\n",
        "similarity_score_unixcoder": 0.8520997762680054,
        "similarity_score_baseline_stripped": 0.6357706785202026,
        "similarity_score_baseline_debug": 0.8957558274269104
    },
    {
        "func_name": "new_partition",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_495008(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  int result; // eax\n  int v7; // [rsp+10h] [rbp-20h]\n  unsigned int v8; // [rsp+14h] [rbp-1Ch]\n  unsigned int v9; // [rsp+18h] [rbp-18h]\n  int v10; // [rsp+1Ch] [rbp-14h]\n  int v11; // [rsp+1Ch] [rbp-14h]\n  _BYTE *v12; // [rsp+20h] [rbp-10h]\n  char *v13; // [rsp+28h] [rbp-8h]\n\n  v13 = (char *)qword_75D408 + 40 * (unsigned int)a1 + 2504;\n  v12 = *(_BYTE **)v13;\n  result = sub_4910F4(a1, a2, (unsigned int)a1, qword_75D408, a5, a6);\n  if ( !result )\n  {\n    v10 = sub_4908E3((__int64)v12);\n    if ( !v12[4] || !v10 || v12[4] == 5 || v12[4] == 15 || v12[4] == 0x85 )\n    {\n      return printf(\"Partition %u has no data area\\n\", (unsigned int)(a1 + 1));\n    }\n    else\n    {\n      v9 = sub_490A13((__int64)v13);\n      v8 = sub_491DF8(0, v9, v9 + v10 - 1, v9, (__int64)\"New beginning of data\");\n      result = v8;\n      if ( v8 != v9 )\n      {\n        v7 = v8 - *((_DWORD *)v13 + 4);\n        v11 = sub_4908C5((__int64)v12) - v7 + v10;\n        sub_49091E((__int64)v12, v7);\n        sub_490945((__int64)v12, v11);\n        sub_49077B((__int64)\"Recalculate C/H/S values? (Y/N): \");\n        if ( (**(_BYTE **)qword_75D408 | 0x20) == 121 )\n          sub_490DE1(v12, v8, v8 + v11 - 1);\n        result = (int)v13;\n        v13[32] = 1;\n      }\n    }\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\nmove_begin(unsigned i)\n{\n\tstruct pte *pe = &ptes[i];\n\tstruct partition *p = pe->part_table;\n\tsector_t new, first, nr_sects;\n\n\tif (warn_geometry())\n\t\treturn;\n\tnr_sects = get_nr_sects(p);\n\tif (!p->sys_ind || !nr_sects || IS_EXTENDED(p->sys_ind)) {\n\t\tprintf(\"Partition %u has no data area\\n\", i + 1);\n\t\treturn;\n\t}\n\tfirst = get_partition_start_from_dev_start(pe); /* == pe->offset_from_dev_start + get_start_sect(p) */\n\tnew = read_int(0 /*was:first*/, first, first + nr_sects - 1, first, \"New beginning of data\");\n\tif (new != first) {\n\t\tsector_t new_relative = new - pe->offset_from_dev_start;\n\t\tnr_sects += (get_start_sect(p) - new_relative);\n\t\tset_start_sect(p, new_relative);\n\t\tset_nr_sects(p, nr_sects);\n\t\tread_nonempty(\"Recalculate C/H/S values? (Y/N): \");\n\t\tif ((line_ptr[0] | 0x20) == 'y')\n\t\t\tset_hsc_start_end(p, new, new + nr_sects - 1);\n\t\tpe->changed = 1;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_489F54(__int64 a1)\n{\n  __int64 v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  _QWORD *v7; // [rsp+8h] [rbp-38h]\n  __int64 **m; // [rsp+18h] [rbp-28h]\n  char *s1; // [rsp+20h] [rbp-20h]\n  _QWORD *v10; // [rsp+28h] [rbp-18h]\n  void **j; // [rsp+30h] [rbp-10h]\n  _QWORD *v12; // [rsp+30h] [rbp-10h]\n  _QWORD *v13; // [rsp+30h] [rbp-10h]\n  int i; // [rsp+3Ch] [rbp-4h]\n  int k; // [rsp+3Ch] [rbp-4h]\n\n  v7 = (_QWORD *)(a1 + 8);\n  s1 = *(char **)(a1 + 8);\n  if ( s1 )\n  {\n    while ( 2 )\n    {\n      v2 = (__int64)\"--\";\n      if ( !strcmp(s1, \"--\") )\n      {\n        ++v7;\n      }\n      else\n      {\n        if ( *s1 == 43 || *s1 == 45 )\n        {\n          for ( i = 1; s1[i]; ++i )\n          {\n            v2 = (unsigned int)s1[i];\n            if ( (unsigned int)sub_488850(*s1 == 45, s1[i], v7[1]) )\n            {\n              sub_409747(\"set: %s: invalid option\", (__int64)s1, v3, v4, v5, v6);\n              return 1LL;\n            }\n            if ( s1[i] == 111 && v7[1] )\n              ++v7;\n          }\n          s1 = (char *)*++v7;\n          if ( *v7 )\n            continue;\n        }\n        if ( !s1 )\n          return 0LL;\n      }\n      break;\n    }\n    v10 = (_QWORD *)*((_QWORD *)qword_75D408 + 11);\n    if ( *((_BYTE *)qword_75D408 + 80) )\n    {\n      for ( j = (void **)*((_QWORD *)qword_75D408 + 11); *++j; free(*j) )\n        ;\n      v10[1] = 0LL;\n    }\n    else\n    {\n      *((_BYTE *)qword_75D408 + 80) = 1;\n      v12 = sub_40A0E8(0x10uLL, v2);\n      *v12 = *v10;\n      v10 = v12;\n    }\n    v13 = sub_47FFDB(v10, v7, 1);\n    *((_QWORD *)qword_75D408 + 11) = v13;\n    for ( k = 1; *++v13; ++k )\n      ;\n    *((_DWORD *)qword_75D408 + 21) = k;\n    return 0LL;\n  }\n  else\n  {\n    for ( m = (__int64 **)*((_QWORD *)qword_75D408 + 15); m; m = (__int64 **)*m )\n      puts((const char *)m[1]);\n    return 0LL;\n  }\n}\n\n\n Revised code:\nstatic int FAST_FUNC builtin_set(char **argv)\n{\n\tint n;\n\tchar **pp, **g_argv;\n\tchar *arg = *++argv;\n\n\tif (arg == NULL) {\n\t\tstruct variable *e;\n\t\tfor (e = G.top_var; e; e = e->next)\n\t\t\tputs(e->varstr);\n\t\treturn EXIT_SUCCESS;\n\t}\n\n\tdo {\n\t\tif (strcmp(arg, \"--\") == 0) {\n\t\t\t++argv;\n\t\t\tgoto set_argv;\n\t\t}\n\t\tif (arg[0] != '+' && arg[0] != '-')\n\t\t\tbreak;\n\t\tfor (n = 1; arg[n]; ++n) {\n\t\t\tif (set_mode((arg[0] == '-'), arg[n], argv[1]))\n\t\t\t\tgoto error;\n\t\t\tif (arg[n] == 'o' && argv[1])\n\t\t\t\targv++;\n\t\t}\n\t} while ((arg = *++argv) != NULL);\n\t/* Now argv[0] is 1st argument */\n\n\tif (arg == NULL)\n\t\treturn EXIT_SUCCESS;\n set_argv:\n\n\t/* NB: G.global_argv[0] ($0) is never freed/changed */\n\tg_argv = G.global_argv;\n\tif (G.global_args_malloced) {\n\t\tpp = g_argv;\n\t\twhile (*++pp)\n\t\t\tfree(*pp);\n\t\tg_argv[1] = NULL;\n\t} else {\n\t\tG.global_args_malloced = 1;\n\t\tpp = xzalloc(sizeof(pp[0]) * 2);\n\t\tpp[0] = g_argv[0]; /* retain $0 */\n\t\tg_argv = pp;\n\t}\n\t/* This realloc's G.global_argv */\n\tG.global_argv = pp = add_strings_to_strings(g_argv, argv, /*dup:*/ 1);\n\n\tn = 1;\n\twhile (*++pp)\n\t\tn++;\n\tG.global_argc = n;\n\n\treturn EXIT_SUCCESS;\n\n\t/* Nothing known, so abort */\n error:\n\tbb_error_msg(\"set: %s: invalid option\", arg);\n\treturn EXIT_FAILURE;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4771AE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  const char *v7; // rdi\n  char v8[16]; // [rsp+10h] [rbp-30h] BYREF\n  const char *v9; // [rsp+20h] [rbp-20h]\n  unsigned int v10; // [rsp+2Ch] [rbp-14h]\n  char *j; // [rsp+30h] [rbp-10h]\n  char **i; // [rsp+38h] [rbp-8h]\n\n  if ( (unsigned int)sub_46F038(\"r\", a2, a3, a4, a5, a6) )\n  {\n    sub_476EEB(0LL, a2);\n    return 0LL;\n  }\n  else if ( *(_QWORD *)qword_75AF58 )\n  {\n    v10 = 0;\n    while ( 1 )\n    {\n      v9 = *(const char **)qword_75AF58;\n      if ( !v9 )\n        break;\n      v7 = v9;\n      j = sub_476FA6(v9, 0);\n      if ( j && (!j[16] || j[16] == 2 && dword_75AE34 >= 0) )\n        sub_4770DD((__int64)v7, 0LL);\n      sub_47E389(v9, v8, 1LL, *(_QWORD *)(qword_75D420 + 400) + 5LL);\n      if ( v8[0] == -1 )\n        v10 = 1;\n      qword_75AF58 += 8LL;\n    }\n    return v10;\n  }\n  else\n  {\n    for ( i = (char **)qword_75B018; (unsigned __int64)i < qword_75B018 + 248; ++i )\n    {\n      for ( j = *i; j; j = *(char **)j )\n      {\n        if ( !j[16] )\n          sub_476E50((__int64)j);\n      }\n    }\n    return 0LL;\n  }\n}\n\n\n Revised code:\nstatic int FAST_FUNC\nhashcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tstruct tblentry **pp;\n\tstruct tblentry *cmdp;\n\tint c;\n\tstruct cmdentry entry;\n\tchar *name;\n\n\tif (nextopt(\"r\") != '\\0') {\n\t\tclearcmdentry(0);\n\t\treturn 0;\n\t}\n\n\tif (*argptr == NULL) {\n\t\tfor (pp = cmdtable; pp < &cmdtable[CMDTABLESIZE]; pp++) {\n\t\t\tfor (cmdp = *pp; cmdp; cmdp = cmdp->next) {\n\t\t\t\tif (cmdp->cmdtype == CMDNORMAL)\n\t\t\t\t\tprintentry(cmdp);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tc = 0;\n\twhile ((name = *argptr) != NULL) {\n\t\tcmdp = cmdlookup(name, 0);\n\t\tif (cmdp != NULL\n\t\t && (cmdp->cmdtype == CMDNORMAL\n\t\t     || (cmdp->cmdtype == CMDBUILTIN && builtinloc >= 0))\n\t\t) {\n\t\t\tdelete_cmd_entry();\n\t\t}\n\t\tfind_command(name, &entry, DO_ERR, pathval());\n\t\tif (entry.cmdtype == CMDUNKNOWN)\n\t\t\tc = 1;\n\t\targptr++;\n\t}\n\treturn c;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_494BE4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  int result; // eax\n  const char *v7; // rdx\n  __int64 v8; // rsi\n  char s[87]; // [rsp+0h] [rbp-60h] BYREF\n  unsigned __int8 v10; // [rsp+57h] [rbp-9h]\n  int i; // [rsp+58h] [rbp-8h]\n  int v12; // [rsp+5Ch] [rbp-4h]\n\n  v12 = 0;\n  result = sub_4910F4(a1, a2, a3, a4, a5, a6);\n  if ( !result )\n  {\n    for ( i = 0; i <= 3; ++i )\n      v12 += *(_BYTE *)(*((_QWORD *)qword_75D408 + 5 * i + 313) + 4LL) == 0;\n    if ( v12 || *((int *)qword_75D408 + 4) <= 59 )\n    {\n      if ( v12 )\n      {\n        if ( *((_DWORD *)qword_75D408 + 22) )\n          v7 = \"l   logical (5 or over)\";\n        else\n          v7 = \"e   extended\";\n        v8 = 80LL;\n        snprintf(s, 0x50uLL, \"Command action\\n   %s\\n   p   primary partition (1-4)\\n\", v7);\n        while ( 1 )\n        {\n          v10 = sub_49077B((__int64)s);\n          if ( (v10 | 0x20) == 112 )\n          {\n            result = sub_4921FA(0, 4u);\n            i = result;\n            if ( result >= 0 )\n              return sub_4940D3(i, 131);\n            return result;\n          }\n          if ( v10 == 108 && *((_DWORD *)qword_75D408 + 22) )\n            return sub_494AF9((__int64)s, v8);\n          if ( v10 == 101 && !*((_DWORD *)qword_75D408 + 22) )\n            break;\n          v8 = (unsigned int)(char)v10;\n          printf(\"Invalid partition number for type '%c'\\n\", v8);\n        }\n        result = sub_4921FA(0, 4u);\n        i = result;\n        if ( result >= 0 )\n          return sub_4940D3(i, 5);\n      }\n      else if ( *((_DWORD *)qword_75D408 + 22) )\n      {\n        return sub_494AF9(a1, a2);\n      }\n      else\n      {\n        return puts(\"You must delete some partition and add an extended partition first\");\n      }\n    }\n    else\n    {\n      return puts(\"The maximum number of partitions has been created\");\n    }\n  }\n  return result;\n}\n",
        "output": "static int FAST_FUNC\npartition_action(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tint result;\n\tconst char *action;\n\t__int64 v8;\n\tchar s[87];\n\tunsigned __int8 v10;\n\tint i;\n\tint num_empty_partitions = 0;\n\n\tresult = check_partition(a1, a2, a3, a4, a5, a6);\n\tif (!result) {\n\t\tfor (i = 0; i <= 3; ++i)\n\t\t\tnum_empty_partitions += *(_BYTE *)(*((_QWORD *)qword_75D408 + 5 * i + 313) + 4LL) == 0;\n\t\tif (num_empty_partitions || *((int *)qword_75D408 + 4) <= 59) {\n\t\t\tif (num_empty_partitions) {\n\t\t\t\tif (*((_DWORD *)qword_75D408 + 22))\n\t\t\t\t\taction = \"l   logical (5 or over)\";\n\t\t\t\telse\n\t\t\t\t\taction = \"e   extended\";\n\t\t\t\tv8 = 80LL;\n\t\t\t\tsnprintf(s, 0x50uLL, \"Command action\\n   %s\\n   p   primary partition (1-4)\\n\", action);\n\t\t\t\twhile (1) {\n\t\t\t\t\tv10 = prompt_user(s);\n\t\t\t\t\tif ((v10 | 0x20) == 112) {\n\t\t\t\t\t\tresult = perform_action(0, 4u);\n\t\t\t\t\t\ti = result;\n\t\t\t\t\t\tif (result >= 0)\n\t\t\t\t\t\t\treturn handle_result(i, 131);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\tif (v10 == 108 && *((_DWORD *)qword_75D408 + 22))\n\t\t\t\t\t\treturn handle_result(s, v8);\n\t\t\t\t\tif (v10 == 101 && !*((_DWORD *)qword_75D408 + 22))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tv8 = (unsigned int)(char)v10;\n\t\t\t\t\tprintf(\"Invalid partition number for type '%c'\\n\", v8);\n\t\t\t\t}\n\t\t\t\tresult = perform_action(0, 4u);\n\t\t\t\ti = result;\n\t\t\t\tif (result >= 0)\n\t\t\t\t\treturn handle_result(i, 5);\n\t\t\t}\n\t\t\telse if (*((_DWORD *)qword_75D408 + 22)) {\n\t\t\t\treturn handle_result(a1, a2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn puts(\"You must delete some partition and add an extended partition first\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn puts(\"The maximum number of partitions has been created\");\n\t\t}\n\t}\n\treturn result;\n}",
        "source_code": "static void\nnew_partition(void)\n{\n\tint i, free_primary = 0;\n\n\tif (warn_geometry())\n\t\treturn;\n\n\tif (LABEL_IS_SUN) {\n\t\tadd_sun_partition(get_partition(0, g_partitions), LINUX_NATIVE);\n\t\treturn;\n\t}\n\tif (LABEL_IS_SGI) {\n\t\tsgi_add_partition(get_partition(0, g_partitions), LINUX_NATIVE);\n\t\treturn;\n\t}\n\tif (LABEL_IS_AIX) {\n\t\tprintf(\"Sorry - this fdisk cannot handle AIX disk labels.\\n\"\n\"If you want to add DOS-type partitions, create a new empty DOS partition\\n\"\n\"table first (use 'o'). This will destroy the present disk contents.\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t\tfree_primary += !ptes[i].part_table->sys_ind;\n\n\tif (!free_primary && g_partitions >= MAXIMUM_PARTS) {\n\t\tprintf(\"The maximum number of partitions has been created\\n\");\n\t\treturn;\n\t}\n\n\tif (!free_primary) {\n\t\tif (extended_offset)\n\t\t\tadd_logical();\n\t\telse\n\t\t\tprintf(\"You must delete some partition and add \"\n\t\t\t\t \"an extended partition first\\n\");\n\t} else {\n\t\tchar c, line[80];\n\t\tsnprintf(line, sizeof(line),\n\t\t\t\"Command action\\n\"\n\t\t\t\"   %s\\n\"\n\t\t\t\"   p   primary partition (1-4)\\n\",\n\t\t\t(extended_offset ?\n\t\t\t\"l   logical (5 or over)\" : \"e   extended\"));\n\t\twhile (1) {\n\t\t\tc = read_nonempty(line);\n\t\t\tif ((c | 0x20) == 'p') {\n\t\t\t\ti = get_nonexisting_partition(0, 4);\n\t\t\t\tif (i >= 0)\n\t\t\t\t\tadd_partition(i, LINUX_NATIVE);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (c == 'l' && extended_offset) {\n\t\t\t\tadd_logical();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (c == 'e' && !extended_offset) {\n\t\t\t\ti = get_nonexisting_partition(0, 4);\n\t\t\t\tif (i >= 0)\n\t\t\t\t\tadd_partition(i, EXTENDED);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tprintf(\"Invalid partition number \"\n\t\t\t\t\t \"for type '%c'\\n\", c);\n\t\t}\n\t}\n}",
        "parsed_output": "static int FAST_FUNC\npartition_action(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tint result;\n\tconst char *action;\n\t__int64 v8;\n\tchar s[87];\n\tunsigned __int8 v10;\n\tint i;\n\tint num_empty_partitions = 0;\n\n\tresult = check_partition(a1, a2, a3, a4, a5, a6);\n\tif (!result) {\n\t\tfor (i = 0; i <= 3; ++i)\n\t\t\tnum_empty_partitions += *(_BYTE *)(*((_QWORD *)qword_75D408 + 5 * i + 313) + 4LL) == 0;\n\t\tif (num_empty_partitions || *((int *)qword_75D408 + 4) <= 59) {\n\t\t\tif (num_empty_partitions) {\n\t\t\t\tif (*((_DWORD *)qword_75D408 + 22))\n\t\t\t\t\taction = \"l   logical (5 or over)\";\n\t\t\t\telse\n\t\t\t\t\taction = \"e   extended\";\n\t\t\t\tv8 = 80LL;\n\t\t\t\tsnprintf(s, 0x50uLL, \"Command action\\n   %s\\n   p   primary partition (1-4)\\n\", action);\n\t\t\t\twhile (1) {\n\t\t\t\t\tv10 = prompt_user(s);\n\t\t\t\t\tif ((v10 | 0x20) == 112) {\n\t\t\t\t\t\tresult = perform_action(0, 4u);\n\t\t\t\t\t\ti = result;\n\t\t\t\t\t\tif (result >= 0)\n\t\t\t\t\t\t\treturn handle_result(i, 131);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\tif (v10 == 108 && *((_DWORD *)qword_75D408 + 22))\n\t\t\t\t\t\treturn handle_result(s, v8);\n\t\t\t\t\tif (v10 == 101 && !*((_DWORD *)qword_75D408 + 22))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tv8 = (unsigned int)(char)v10;\n\t\t\t\t\tprintf(\"Invalid partition number for type '%c'\\n\", v8);\n\t\t\t\t}\n\t\t\t\tresult = perform_action(0, 4u);\n\t\t\t\ti = result;\n\t\t\t\tif (result >= 0)\n\t\t\t\t\treturn handle_result(i, 5);\n\t\t\t}\n\t\t\telse if (*((_DWORD *)qword_75D408 + 22)) {\n\t\t\t\treturn handle_result(a1, a2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn puts(\"You must delete some partition and add an extended partition first\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn puts(\"The maximum number of partitions has been created\");\n\t\t}\n\t}\n\treturn result;\n}",
        "baseline_code_stripped": "int __fastcall sub_494BE4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  int result; // eax\n  const char *v7; // rdx\n  __int64 v8; // rsi\n  char s[87]; // [rsp+0h] [rbp-60h] BYREF\n  unsigned __int8 v10; // [rsp+57h] [rbp-9h]\n  int i; // [rsp+58h] [rbp-8h]\n  int v12; // [rsp+5Ch] [rbp-4h]\n\n  v12 = 0;\n  result = sub_4910F4(a1, a2, a3, a4, a5, a6);\n  if ( !result )\n  {\n    for ( i = 0; i <= 3; ++i )\n      v12 += *(_BYTE *)(*((_QWORD *)qword_75D408 + 5 * i + 313) + 4LL) == 0;\n    if ( v12 || *((int *)qword_75D408 + 4) <= 59 )\n    {\n      if ( v12 )\n      {\n        if ( *((_DWORD *)qword_75D408 + 22) )\n          v7 = \"l   logical (5 or over)\";\n        else\n          v7 = \"e   extended\";\n        v8 = 80LL;\n        snprintf(s, 0x50uLL, \"Command action\\n   %s\\n   p   primary partition (1-4)\\n\", v7);\n        while ( 1 )\n        {\n          v10 = sub_49077B((__int64)s);\n          if ( (v10 | 0x20) == 112 )\n          {\n            result = sub_4921FA(0, 4u);\n            i = result;\n            if ( result >= 0 )\n              return sub_4940D3(i, 131);\n            return result;\n          }\n          if ( v10 == 108 && *((_DWORD *)qword_75D408 + 22) )\n            return sub_494AF9((__int64)s, v8);\n          if ( v10 == 101 && !*((_DWORD *)qword_75D408 + 22) )\n            break;\n          v8 = (unsigned int)(char)v10;\n          printf(\"Invalid partition number for type '%c'\\n\", v8);\n        }\n        result = sub_4921FA(0, 4u);\n        i = result;\n        if ( result >= 0 )\n          return sub_4940D3(i, 5);\n      }\n      else if ( *((_DWORD *)qword_75D408 + 22) )\n      {\n        return sub_494AF9(a1, a2);\n      }\n      else\n      {\n        return puts(\"You must delete some partition and add an extended partition first\");\n      }\n    }\n    else\n    {\n      return puts(\"The maximum number of partitions has been created\");\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl new_partition()\n{\n  const char *v0; // rdx\n  char line[80]; // [rsp+0h] [rbp-60h] BYREF\n  char c; // [rsp+57h] [rbp-9h]\n  int i; // [rsp+58h] [rbp-8h]\n  int free_primary; // [rsp+5Ch] [rbp-4h]\n\n  free_primary = 0;\n  if ( !warn_geometry() )\n  {\n    for ( i = 0; i <= 3; ++i )\n      free_primary += *(_BYTE *)(*(_QWORD *)&ptr_to_globals[8].line_buf[40 * i + 44] + 4LL) == 0;\n    if ( free_primary || SLODWORD(ptr_to_globals->fakehost) <= 59 )\n    {\n      if ( free_primary )\n      {\n        if ( ptr_to_globals->speeds[9] )\n          v0 = \"l   logical (5 or over)\";\n        else\n          v0 = \"e   extended\";\n        snprintf(line, 0x50uLL, \"Command action\\n   %s\\n   p   primary partition (1-4)\\n\", v0);\n        while ( 1 )\n        {\n          c = read_nonempty(line);\n          if ( ((unsigned __int8)c | 0x20) == 112 )\n          {\n            i = get_nonexisting_partition(0, 4u);\n            if ( i >= 0 )\n              add_partition(i, 131);\n            return;\n          }\n          if ( c == 108 && ptr_to_globals->speeds[9] )\n          {\n            add_logical();\n            return;\n          }\n          if ( c == 101 && !ptr_to_globals->speeds[9] )\n            break;\n          printf(\"Invalid partition number for type '%c'\\n\", (unsigned int)c);\n        }\n        i = get_nonexisting_partition(0, 4u);\n        if ( i >= 0 )\n          add_partition(i, 5);\n      }\n      else if ( ptr_to_globals->speeds[9] )\n      {\n        add_logical();\n      }\n      else\n      {\n        puts(\"You must delete some partition and add an extended partition first\");\n      }\n    }\n    else\n    {\n      puts(\"The maximum number of partitions has been created\");\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.8125325441360474,
        "similarity_score_baseline_stripped": 0.6980984210968018,
        "similarity_score_baseline_debug": 0.8361454606056213
    },
    {
        "func_name": "open_trunc_or_warn",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40A2DB(const char *a1, int a2, unsigned int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v8; // [rsp+1Ch] [rbp-4h]\n\n  v8 = open64(a1, a2, a3);\n  if ( v8 < 0 )\n    sub_4091D9((__int64)\"can't open '%s'\", (__int64)a1, v3, v4, v5, v6);\n  return (unsigned int)v8;\n}\n\n\n Revised code:\nint FAST_FUNC open3_or_warn(const char *pathname, int flags, int mode)\n{\n\tint ret;\n\n\tret = open(pathname, flags, mode);\n\tif (ret < 0) {\n\t\tbb_perror_msg(\"can't open '%s'\", pathname);\n\t}\n\treturn ret;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40A246(const char *a1, int a2, unsigned int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v8; // [rsp+1Ch] [rbp-4h]\n\n  v8 = open64(a1, a2, a3);\n  if ( v8 < 0 )\n    sub_4092A2((__int64)\"can't open '%s'\", (__int64)a1, v3, v4, v5, v6);\n  return (unsigned int)v8;\n}\n\n\n Revised code:\nint FAST_FUNC xopen3(const char *pathname, int flags, int mode)\n{\n\tint ret;\n\n\tret = open(pathname, flags, mode);\n\tif (ret < 0) {\n\t\tbb_perror_msg_and_die(\"can't open '%s'\", pathname);\n\t}\n\treturn ret;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4F9CA0(const char *a1)\n{\n  int v2; // [rsp+1Ch] [rbp-4h]\n\n  v2 = open64(a1, 2);\n  if ( v2 < 0 && *(_DWORD *)qword_75D400 == 13 )\n    v2 = open64(a1, 0);\n  if ( v2 < 0 && *(_DWORD *)qword_75D400 == 13 )\n    return (unsigned int)open64(a1, 1);\n  return (unsigned int)v2;\n}\n\n\n Revised code:\nstatic int open_a_console(const char *fnam)\n{\n\tint fd;\n\n\t/* try read-write */\n\tfd = open(fnam, O_RDWR);\n\n\t/* if failed, try read-only */\n\tif (fd < 0 && errno == EACCES)\n\t\tfd = open(fnam, O_RDONLY);\n\n\t/* if failed, try write-only */\n\tif (fd < 0 && errno == EACCES)\n\t\tfd = open(fnam, O_WRONLY);\n\n\treturn fd;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4686C8(const char *a1)\n{\n  __int64 v1; // rcx\n  __int64 v2; // r8\n  __int64 v3; // r9\n  int v5; // [rsp+1Ch] [rbp-4h]\n\n  v5 = open64(a1, 2625, 420LL);\n  if ( v5 < 0 )\n    sub_4091D9((__int64)\"%s: warning: cannot open %s\", *(_QWORD *)&dest.c_cc[7], (__int64)a1, v1, v2, v3);\n  return (unsigned int)v5;\n}\n",
        "output": "int FAST_FUNC open_file(const char *filename)\n{\n\tint fd;\n\n\tfd = open(filename, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n\tif (fd < 0) {\n\t\tbb_perror_msg(\"%s: warning: cannot open %s\", *(_QWORD *)&dest.c_cc[7], filename);\n\t}\n\treturn fd;\n}",
        "source_code": "static int open_trunc_or_warn(const char *name)\n{\n\t/* Why O_NDELAY? */\n\tint fd = open(name, O_WRONLY | O_NDELAY | O_TRUNC | O_CREAT, 0644);\n\tif (fd < 0)\n\t\tbb_perror_msg(\"%s: warning: cannot open %s\",\n\t\t\t\tdir, name);\n\treturn fd;\n}",
        "parsed_output": "int FAST_FUNC open_file(const char *filename)\n{\n\tint fd;\n\n\tfd = open(filename, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n\tif (fd < 0) {\n\t\tbb_perror_msg(\"%s: warning: cannot open %s\", *(_QWORD *)&dest.c_cc[7], filename);\n\t}\n\treturn fd;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4686C8(const char *a1)\n{\n  __int64 v1; // rcx\n  __int64 v2; // r8\n  __int64 v3; // r9\n  int v5; // [rsp+1Ch] [rbp-4h]\n\n  v5 = open64(a1, 2625, 420LL);\n  if ( v5 < 0 )\n    sub_4091D9((__int64)\"%s: warning: cannot open %s\", *(_QWORD *)&dest.c_cc[7], (__int64)a1, v1, v2, v3);\n  return (unsigned int)v5;\n}\n",
        "baseline_code_debug": "int __cdecl open_trunc_or_warn(const char *name)\n{\n  int fd; // [rsp+1Ch] [rbp-4h]\n\n  fd = open64(name, 2625, 420LL);\n  if ( fd < 0 )\n    bb_perror_msg(\"%s: warning: cannot open %s\", *(const char **)&bb_common_bufsiz1.c_cc[7], name);\n  return fd;\n}\n",
        "similarity_score_unixcoder": 0.7624229192733765,
        "similarity_score_baseline_stripped": 0.5351857542991638,
        "similarity_score_baseline_debug": 0.7840598225593567
    },
    {
        "func_name": "hashwalk_next",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_481E8D(__int64 a1, unsigned int a2)\n{\n  __int64 v3; // rbx\n  unsigned int v4; // [rsp+4h] [rbp-2Ch]\n  char *ptr; // [rsp+10h] [rbp-20h]\n  char *v6; // [rsp+18h] [rbp-18h]\n\n  if ( !*(_QWORD *)a1 )\n    return sub_4818B0(a1, a2);\n  v3 = *(_QWORD *)a1;\n  v6 = (char *)(v3 + (int)sub_4819F4((_QWORD *)a1, a2));\n  if ( (unsigned int)sub_481A3B(v6) )\n  {\n    ptr = sub_40A11F(v6, a2);\n    *(_DWORD *)(a1 + 8) = (_DWORD)v6 - *(_DWORD *)a1;\n    v4 = sub_481B55(ptr, a1, a2);\n    free(ptr);\n    return v4;\n  }\n  else\n  {\n    *(_DWORD *)(a1 + 8) = (unsigned int)sub_47FF75(v6) - *(_DWORD *)a1;\n    return sub_4818B0(a1, a2);\n  }\n}\n\n\n Revised code:\nstatic int perform_glob(o_string *o, int n)\n{\n\tchar *pattern, *copy;\n\n\tdebug_printf_glob(\"start perform_glob: n:%d o->data:%p\\n\", n, o->data);\n\tif (!o->data)\n\t\treturn o_save_ptr_helper(o, n);\n\tpattern = o->data + o_get_last_ptr(o, n);\n\tdebug_printf_glob(\"glob pattern '%s'\\n\", pattern);\n\tif (!glob_needed(pattern)) {\n\t\t/* unbackslash last string in o in place, fix length */\n\t\to->length = unbackslash(pattern) - o->data;\n\t\tdebug_printf_glob(\"glob pattern '%s' is literal\\n\", pattern);\n\t\treturn o_save_ptr_helper(o, n);\n\t}\n\n\tcopy = xstrdup(pattern);\n\t/* \"forget\" pattern in o */\n\to->length = pattern - o->data;\n\tn = glob_brace(copy, o, n);\n\tfree(copy);\n\tif (DEBUG_GLOB)\n\t\tdebug_print_list(\"perform_glob returning\", o, n);\n\treturn n;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4F63B5(unsigned int a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40C486(a1, a2);\n  if ( v3 )\n    return *(_QWORD *)v3;\n  else\n    return 0LL;\n}\n\n\n Revised code:\nFAST_FUNC uid2uname(uid_t uid)\n{\n\tstruct passwd *pw = getpwuid(uid);\n\treturn (pw) ? pw->pw_name : NULL;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4D9DFF(char *a1, __int64 a2)\n{\n  char *v3; // rax\n  char *v4; // [rsp+8h] [rbp-18h]\n  char v5; // [rsp+17h] [rbp-9h]\n  _QWORD *v6; // [rsp+18h] [rbp-8h]\n\n  v4 = a1 + 1;\n  v5 = *a1;\n  v6 = (_QWORD *)(a2 + 8);\n  if ( *a1 == 45 )\n  {\n    *(_BYTE *)(a2 + 24) |= 2u;\n    v6 = (_QWORD *)(a2 + 16);\n  }\n  else if ( v5 == 43 )\n  {\n    *(_BYTE *)(a2 + 24) |= 1u;\n  }\n  else\n  {\n    if ( v5 != 61 )\n      return 0LL;\n    *(_BYTE *)(a2 + 24) |= 4u;\n  }\n  while ( *v4 )\n  {\n    v3 = v4++;\n    *v6 |= sub_4D9DB6(*v3);\n  }\n  return 1LL;\n}\n\n\n Revised code:\nstatic int decode_arg(const char *arg, struct globals *gp)\n{\n\tunsigned long *fl;\n\tchar opt = *arg++;\n\n\tfl = &gp->af;\n\tif (opt == '-') {\n\t\tgp->flags |= OPT_REM;\n\t\tfl = &gp->rf;\n\t} else if (opt == '+') {\n\t\tgp->flags |= OPT_ADD;\n\t} else if (opt == '=') {\n\t\tgp->flags |= OPT_SET;\n\t} else\n\t\treturn 0;\n\n\twhile (*arg)\n\t\t*fl |= get_flag(*arg++);\n\n\treturn 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4DF493(__int64 a1)\n{\n  const char *v2; // rax\n  __int64 v3; // [rsp+10h] [rbp-10h]\n  __int64 *ptr; // [rsp+18h] [rbp-8h]\n\n  ptr = *(__int64 **)(a1 + 24);\n  if ( ptr[1] < (unsigned __int64)*ptr )\n  {\n    v2 = (const char *)sub_4DC55F(ptr + 1);\n    sub_4DC927(a1, v2);\n    return 1LL;\n  }\n  else\n  {\n    v3 = ptr[2];\n    free(ptr);\n    *(_QWORD *)(a1 + 24) = v3;\n    return 0LL;\n  }\n}\n",
        "output": "static int process_data(__int64 a1)\n{\n\t__int64 *ptr = *(__int64 **)(a1 + 24);\n\tif (ptr[1] < (unsigned __int64)*ptr)\n\t{\n\t\tconst char *v2 = (const char *)get_data(ptr + 1);\n\t\tprocess_data(a1, v2);\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\t__int64 v3 = ptr[2];\n\t\tfree(ptr);\n\t\t*(_QWORD *)(a1 + 24) = v3;\n\t\treturn 0;\n\t}\n}",
        "source_code": "static int hashwalk_next(var *v)\n{\n\twalker_list *w = v->x.walker;\n\n\tif (w->cur >= w->end) {\n\t\twalker_list *prev_walker = w->prev;\n\n\t\tdebug_printf_walker(\"end of iteration, free(walker@%p:%p), prev_walker:%p\\n\", &v->x.walker, w, prev_walker);\n\t\tfree(w);\n\t\tv->x.walker = prev_walker;\n\t\treturn FALSE;\n\t}\n\n\tsetvar_s(v, nextword(&w->cur));\n\treturn TRUE;\n}",
        "parsed_output": "static int process_data(__int64 a1)\n{\n\t__int64 *ptr = *(__int64 **)(a1 + 24);\n\tif (ptr[1] < (unsigned __int64)*ptr)\n\t{\n\t\tconst char *v2 = (const char *)get_data(ptr + 1);\n\t\tprocess_data(a1, v2);\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\t__int64 v3 = ptr[2];\n\t\tfree(ptr);\n\t\t*(_QWORD *)(a1 + 24) = v3;\n\t\treturn 0;\n\t}\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4DF493(__int64 a1)\n{\n  const char *v2; // rax\n  __int64 v3; // [rsp+10h] [rbp-10h]\n  __int64 *ptr; // [rsp+18h] [rbp-8h]\n\n  ptr = *(__int64 **)(a1 + 24);\n  if ( ptr[1] < (unsigned __int64)*ptr )\n  {\n    v2 = (const char *)sub_4DC55F(ptr + 1);\n    sub_4DC927(a1, v2);\n    return 1LL;\n  }\n  else\n  {\n    v3 = ptr[2];\n    free(ptr);\n    *(_QWORD *)(a1 + 24) = v3;\n    return 0LL;\n  }\n}\n",
        "baseline_code_debug": "int __cdecl hashwalk_next(var_0 *v)\n{\n  char *v2; // rdx\n  xhash_s *prev_walker; // [rsp+10h] [rbp-10h]\n  xhash_s *w; // [rsp+18h] [rbp-8h]\n\n  w = v->x.array;\n  if ( *(_QWORD *)&w->nprime < *(_QWORD *)&w->nel )\n  {\n    v2 = nextword((char **)&w->nprime);\n    setvar_s(v, v2);\n    return 1;\n  }\n  else\n  {\n    prev_walker = (xhash_s *)w->items;\n    free(w);\n    v->x.array = prev_walker;\n    return 0;\n  }\n}\n",
        "similarity_score_unixcoder": 0.5195543169975281,
        "similarity_score_baseline_stripped": 0.4748207926750183,
        "similarity_score_baseline_debug": 0.8126460909843445
    },
    {
        "func_name": "get_partition",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_492134(int a1, unsigned int a2)\n{\n  _BYTE *v3; // [rsp+18h] [rbp-18h]\n  unsigned int i; // [rsp+28h] [rbp-8h]\n  int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = -1;\n  for ( i = 0; i < a2; ++i )\n  {\n    v3 = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * i + 313);\n    if ( v3 && !sub_490BFC(v3) )\n    {\n      if ( v5 >= 0 )\n        return sub_4920A7(a1, a2);\n      v5 = i;\n    }\n  }\n  if ( v5 < 0 )\n  {\n    puts(\"No partition is defined yet!\");\n    return 0xFFFFFFFFLL;\n  }\n  else\n  {\n    printf(\"Selected partition %u\\n\", (unsigned int)(v5 + 1));\n    return (unsigned int)v5;\n  }\n}\n\n\n Revised code:\nstatic int\nget_existing_partition(int warn, unsigned max)\n{\n\tint pno = -1;\n\tunsigned i;\n\n\tfor (i = 0; i < max; i++) {\n\t\tstruct pte *pe = &ptes[i];\n\t\tstruct partition *p = pe->part_table;\n\n\t\tif (p && !is_cleared_partition(p)) {\n\t\t\tif (pno >= 0)\n\t\t\t\tgoto not_unique;\n\t\t\tpno = i;\n\t\t}\n\t}\n\tif (pno >= 0) {\n\t\tprintf(\"Selected partition %u\\n\", pno+1);\n\t\treturn pno;\n\t}\n\tprintf(\"No partition is defined yet!\\n\");\n\treturn -1;\n\n not_unique:\n\treturn get_partition(warn, max);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4921FA(int a1, unsigned int a2)\n{\n  _BYTE *v3; // [rsp+18h] [rbp-18h]\n  unsigned int i; // [rsp+28h] [rbp-8h]\n  int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = -1;\n  for ( i = 0; i < a2; ++i )\n  {\n    v3 = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * i + 313);\n    if ( v3 && sub_490BFC(v3) )\n    {\n      if ( v5 >= 0 )\n        return sub_4920A7(a1, a2);\n      v5 = i;\n    }\n  }\n  if ( v5 < 0 )\n  {\n    puts(\"All primary partitions have been defined already!\");\n    return 0xFFFFFFFFLL;\n  }\n  else\n  {\n    printf(\"Selected partition %u\\n\", (unsigned int)(v5 + 1));\n    return (unsigned int)v5;\n  }\n}\n\n\n Revised code:\nstatic int\nget_nonexisting_partition(int warn, unsigned max)\n{\n\tint pno = -1;\n\tunsigned i;\n\n\tfor (i = 0; i < max; i++) {\n\t\tstruct pte *pe = &ptes[i];\n\t\tstruct partition *p = pe->part_table;\n\n\t\tif (p && is_cleared_partition(p)) {\n\t\t\tif (pno >= 0)\n\t\t\t\tgoto not_unique;\n\t\t\tpno = i;\n\t\t}\n\t}\n\tif (pno >= 0) {\n\t\tprintf(\"Selected partition %u\\n\", pno+1);\n\t\treturn pno;\n\t}\n\tprintf(\"All primary partitions have been defined already!\\n\");\n\treturn -1;\n\n not_unique:\n\treturn get_partition(warn, max);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4FE0EA(__int64 a1, int a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_509131(a1, *((_QWORD *)qword_75D458 + 6), (unsigned int)(a2 - 1));\n  if ( v3 < 0 )\n    v3 = 0LL;\n  *(_BYTE *)(v3 + a1) = 0;\n  return v3;\n}\n\n\n Revised code:\nstatic unsigned save_string(char *dst, unsigned maxsize)\n{\n\tif (unicode_status == UNICODE_ON) {\n# if !ENABLE_UNICODE_PRESERVE_BROKEN\n\t\tssize_t len = wcstombs(dst, command_ps, maxsize - 1);\n\t\tif (len < 0)\n\t\t\tlen = 0;\n\t\tdst[len] = '\\0';\n\t\treturn len;\n# else\n\t\tunsigned dstpos = 0;\n\t\tunsigned srcpos = 0;\n\n\t\tmaxsize--;\n\t\twhile (dstpos < maxsize) {\n\t\t\twchar_t wc;\n\t\t\tint n = srcpos;\n\n\t\t\t/* Convert up to 1st invalid byte (or up to end) */\n\t\t\twhile ((wc = command_ps[srcpos]) != BB_NUL\n\t\t\t    && !unicode_is_raw_byte(wc)\n\t\t\t) {\n\t\t\t\tsrcpos++;\n\t\t\t}\n\t\t\tcommand_ps[srcpos] = BB_NUL;\n\t\t\tn = wcstombs(dst + dstpos, command_ps + n, maxsize - dstpos);\n\t\t\tif (n < 0) /* should not happen */\n\t\t\t\tbreak;\n\t\t\tdstpos += n;\n\t\t\tif (wc == BB_NUL) /* usually is */\n\t\t\t\tbreak;\n\n\t\t\t/* We do have invalid byte here! */\n\t\t\tcommand_ps[srcpos] = wc; /* restore it */\n\t\t\tsrcpos++;\n\t\t\tif (dstpos == maxsize)\n\t\t\t\tbreak;\n\t\t\tdst[dstpos++] = (char) wc;\n\t\t}\n\t\tdst[dstpos] = '\\0';\n\t\treturn dstpos;\n# endif\n\t} else {\n\t\tunsigned i = 0;\n\t\twhile ((dst[i] = command_ps[i]) != 0)\n\t\t\ti++;\n\t\treturn i;\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4920A7(int a1, unsigned int a2)\n{\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_491DF8(1u, 0, a2, 0, (__int64)\"Partition number\") - 1;\n  if ( a1 && !*(_BYTE *)(*((_QWORD *)qword_75D408 + 5 * v3 + 313) + 4LL) )\n    printf(\"Warning: partition %u has empty type\\n\", v3 + 1);\n  return v3;\n}\n",
        "output": "static unsigned int\nget_partition_number(int warn, unsigned int max)\n{\n\tunsigned int pno;\n\n\tpno = get_input(1, 0, max, 0, \"Partition number\") - 1;\n\tif (warn && !is_nonempty_partition(pno)) {\n\t\tprintf(\"Warning: partition %u has empty type\\n\", pno + 1);\n\t}\n\treturn pno;\n}",
        "source_code": "static unsigned\nget_partition(int warn, unsigned max)\n{\n\tstruct pte *pe;\n\tunsigned i;\n\n\ti = read_int(1, 0, max, 0, \"Partition number\") - 1;\n\tpe = &ptes[i];\n\n\tif (warn) {\n\t\tif ((!LABEL_IS_SUN && !LABEL_IS_SGI && !pe->part_table->sys_ind)\n\t\t || (LABEL_IS_SUN && (!sunlabel->partitions[i].num_sectors || !sunlabel->infos[i].id))\n\t\t || (LABEL_IS_SGI && !sgi_get_num_sectors(i))\n\t\t) {\n\t\t\tprintf(\"Warning: partition %u has empty type\\n\", i+1);\n\t\t}\n\t}\n\treturn i;\n}",
        "parsed_output": "static unsigned int\nget_partition_number(int warn, unsigned int max)\n{\n\tunsigned int pno;\n\n\tpno = get_input(1, 0, max, 0, \"Partition number\") - 1;\n\tif (warn && !is_nonempty_partition(pno)) {\n\t\tprintf(\"Warning: partition %u has empty type\\n\", pno + 1);\n\t}\n\treturn pno;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4920A7(int a1, unsigned int a2)\n{\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_491DF8(1u, 0, a2, 0, (__int64)\"Partition number\") - 1;\n  if ( a1 && !*(_BYTE *)(*((_QWORD *)qword_75D408 + 5 * v3 + 313) + 4LL) )\n    printf(\"Warning: partition %u has empty type\\n\", v3 + 1);\n  return v3;\n}\n",
        "baseline_code_debug": "unsigned int __cdecl get_partition(int warn, unsigned int max)\n{\n  sector_t i; // [rsp+1Ch] [rbp-4h]\n\n  i = read_int(1u, 0, max, 0, \"Partition number\") - 1;\n  if ( warn && !*(_BYTE *)(*(_QWORD *)&ptr_to_globals[8].line_buf[40 * i + 44] + 4LL) )\n    printf(\"Warning: partition %u has empty type\\n\", i + 1);\n  return i;\n}\n",
        "similarity_score_unixcoder": 0.7326471209526062,
        "similarity_score_baseline_stripped": 0.5843066573143005,
        "similarity_score_baseline_debug": 0.7476709485054016
    },
    {
        "func_name": "xfork",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_415BB6(__int64 a1, const char *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  int v7; // eax\n  ssize_t v8; // rax\n  char v9; // [rsp+17h] [rbp-9h] BYREF\n  __pid_t v10; // [rsp+18h] [rbp-8h]\n  __pid_t v11; // [rsp+1Ch] [rbp-4h]\n\n  v11 = vfork();\n  if ( v11 < 0 )\n    sub_4092A2((__int64)\"vfork\", (__int64)a2, v2, v3, v4, v5);\n  v10 = v11;\n  if ( !v11 )\n  {\n    sub_4F6569(a1);\n    v7 = sub_40A295(a2, 0);\n    v8 = sub_40B3FF(v7, &v9, 1uLL);\n    _exit(v8 < 0);\n  }\n  if ( (unsigned int)sub_409FAE(v10) )\n    return -1;\n  else\n    return open64(a2, 0);\n}\n\n\n Revised code:\nstatic int open_as_user(const struct passwd *pas, const char *file)\n{\n\tpid_t pid;\n\tchar c;\n\n\tpid = xvfork();\n\tif (pid) { /* PARENT */\n\t\tif (wait4pid(pid) == 0) {\n\t\t\t/* exitcode 0: child says it can read */\n\t\t\treturn open(file, O_RDONLY);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* CHILD */\n\t/* initgroups, setgid, setuid */\n\tchange_identity(pas);\n\t/* We just try to read one byte. If it works, file is readable\n\t * under this user. We signal that by exiting with 0. */\n\t_exit(safe_read(xopen(file, O_RDONLY), &c, 1) < 0);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_50A55F(const char **a1)\n{\n  __pid_t v2; // [rsp+1Ch] [rbp-4h]\n\n  sub_40A649();\n  v2 = vfork();\n  if ( v2 < 0 )\n    return (unsigned int)v2;\n  if ( !v2 )\n  {\n    execvp(*a1, (char *const *)a1);\n    _exit(111);\n  }\n  return (unsigned int)v2;\n}\n\n\n Revised code:\npid_t FAST_FUNC spawn(char **argv)\n{\n\t/* Compiler should not optimize stores here */\n\tvolatile int failed;\n\tpid_t pid;\n\n\tfflush_all();\n\n\t/* Be nice to nommu machines. */\n\tfailed = 0;\n\tpid = vfork();\n\tif (pid < 0) /* error */\n\t\treturn pid;\n\tif (!pid) { /* child */\n\t\t/* This macro is ok - it doesn't do NOEXEC/NOFORK tricks */\n\t\tBB_EXECVP(argv[0], argv);\n\n\t\t/* We are (maybe) sharing a stack with blocked parent,\n\t\t * let parent know we failed and then exit to unblock parent\n\t\t * (but don't run atexit() stuff, which would screw up parent.)\n\t\t */\n\t\tfailed = errno;\n\t\t/* mount, for example, does not want the message */\n\t\t/*bb_perror_msg(\"can't execute '%s'\", argv[0]);*/\n\t\t_exit(111);\n\t}\n\t/* parent */\n\t/* Unfortunately, this is not reliable: according to standards\n\t * vfork() can be equivalent to fork() and we won't see value\n\t * of 'failed'.\n\t * Interested party can wait on pid and learn exit code.\n\t * If 111 - then it (most probably) failed to exec */\n\tif (failed) {\n\t\tsafe_waitpid(pid, NULL, 0); /* prevent zombie */\n\t\terrno = failed;\n\t\treturn -1;\n\t}\n\treturn pid;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_472EC3(const char *a1, const char *a2, int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v9; // [rsp+2Ch] [rbp-4h]\n\n  v9 = fork();\n  if ( v9 < 0 )\n  {\n    if ( a1 )\n      sub_47107C((__int64)a1);\n    sub_46E473(\"can't fork\", (__int64)a2, v3, v4, v5, v6);\n  }\n  if ( v9 )\n  {\n    sub_472D83((__int64)a1, (__int64)a2, a3, v9);\n  }\n  else\n  {\n    *(_DWORD *)(qword_75D418 + 736) = 0;\n    sub_472B1A(a1, a2, a3);\n  }\n  return (unsigned int)v9;\n}\n\n\n Revised code:\nstatic int\nforkshell(struct job *jp, union node *n, int mode)\n{\n\tint pid;\n\n\tTRACE((\"forkshell(%%%d, %p, %d) called\\n\", jobno(jp), n, mode));\n\tpid = fork();\n\tif (pid < 0) {\n\t\tTRACE((\"Fork failed, errno=%d\", errno));\n\t\tif (jp)\n\t\t\tfreejob(jp);\n\t\tash_msg_and_raise_error(\"can't fork\");\n\t}\n\tif (pid == 0) {\n\t\tCLEAR_RANDOM_T(&random_gen); /* or else $RANDOM repeats in child */\n\t\tforkchild(jp, n, mode);\n\t} else {\n\t\tforkparent(jp, n, mode, pid);\n\t}\n\treturn pid;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40AEE6(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __pid_t v7; // [rsp+Ch] [rbp-4h]\n\n  v7 = fork();\n  if ( v7 < 0 )\n    sub_4092A2((__int64)\"fork\", a2, v2, v3, v4, v5);\n  return (unsigned int)v7;\n}\n",
        "output": "static pid_t fork_process(__int64 arg1, __int64 arg2)\n{\n  pid_t pid;\n\n  pid = fork();\n  if (pid < 0)\n    handle_error(\"fork\", arg2, arg1);\n  return pid;\n}",
        "source_code": "if BB_MMU\npid_t FAST_FUNC xfork(void)\n{\n\tpid_t pid;\n\tpid = fork();\n\tif (pid < 0) /* wtf? */\n\t\tbb_perror_msg_and_die(\"vfork\"+1);\n\treturn pid;\n}",
        "parsed_output": "static pid_t fork_process(__int64 arg1, __int64 arg2)\n{\n  pid_t pid;\n\n  pid = fork();\n  if (pid < 0)\n    handle_error(\"fork\", arg2, arg1);\n  return pid;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40AEE6(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __pid_t v7; // [rsp+Ch] [rbp-4h]\n\n  v7 = fork();\n  if ( v7 < 0 )\n    sub_4092A2((__int64)\"fork\", a2, v2, v3, v4, v5);\n  return (unsigned int)v7;\n}\n",
        "baseline_code_debug": "pid_t __cdecl xfork()\n{\n  __pid_t pid; // [rsp+Ch] [rbp-4h]\n\n  pid = fork();\n  if ( pid < 0 )\n    bb_perror_msg_and_die(\"fork\");\n  return pid;\n}\n",
        "similarity_score_unixcoder": 0.8158689737319946,
        "similarity_score_baseline_stripped": 0.6847010850906372,
        "similarity_score_baseline_debug": 0.8005126118659973
    },
    {
        "func_name": "get_uidgid",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47134A(int a1, __int64 a2)\n{\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  void *v5; // rsp\n  __int64 v6; // rdx\n  int v7; // eax\n  __int64 v9; // [rsp+0h] [rbp-40h] BYREF\n  int v10; // [rsp+Ch] [rbp-34h]\n  unsigned int *v11; // [rsp+18h] [rbp-28h]\n  __int64 v12; // [rsp+20h] [rbp-20h]\n  int v13; // [rsp+28h] [rbp-18h]\n  int i; // [rsp+2Ch] [rbp-14h]\n  char *s; // [rsp+30h] [rbp-10h]\n  int v16; // [rsp+3Ch] [rbp-4h]\n\n  v10 = a1;\n  v9 = a2;\n  if ( *(_QWORD *)(a2 + 8) && strcmp(*(const char **)(v9 + 8), \"-l\") )\n  {\n    v16 = 1;\n    do\n    {\n      if ( **(_BYTE **)(8LL * v16 + v9) == 37 )\n      {\n        v12 = sub_470E8F(*(_BYTE **)(8LL * v16 + v9), 0, 8LL * v16, v2, v3, v4);\n        v13 = *(unsigned __int16 *)(v12 + 28);\n        if ( (*(_BYTE *)(v12 + 31) & 2) != 0 )\n          v13 = 1;\n        v2 = 16LL;\n        v5 = alloca(16 * ((16LL * v13 + 23) / 0x10uLL));\n        s = (char *)&v9;\n        *(_QWORD *)(v9 + 8LL * v16) = &v9;\n        for ( i = 0; i < v13; ++i )\n        {\n          v11 = (unsigned int *)(16LL * i + *(_QWORD *)(v12 + 16));\n          if ( v11[1] == -1 || (unsigned __int8)v11[1] == 127 )\n          {\n            v6 = *v11;\n            if ( (*(_BYTE *)(v12 + 31) & 2) != 0 )\n              v7 = sprintf(s, \" -%u\", v6);\n            else\n              v7 = sprintf(s, \" %u\", v6);\n            s += v7;\n          }\n        }\n        *s = 0;\n      }\n      ++v16;\n    }\n    while ( *(_QWORD *)(8LL * v16 + v9) );\n  }\n  return sub_45CB53(v10, v9);\n}\n\n\n Revised code:\nstatic int FAST_FUNC\nkillcmd(int argc, char **argv)\n{\n\tif (argv[1] && strcmp(argv[1], \"-l\") != 0) {\n\t\tint i = 1;\n\t\tdo {\n\t\t\tif (argv[i][0] == '%') {\n\t\t\t\t/*\n\t\t\t\t * \"kill %N\" - job kill\n\t\t\t\t * Converting to pgrp / pid kill\n\t\t\t\t */\n\t\t\t\tstruct job *jp;\n\t\t\t\tchar *dst;\n\t\t\t\tint j, n;\n\n\t\t\t\tjp = getjob(argv[i], 0);\n\t\t\t\t/*\n\t\t\t\t * In jobs started under job control, we signal\n\t\t\t\t * entire process group by kill -PGRP_ID.\n\t\t\t\t * This happens, f.e., in interactive shell.\n\t\t\t\t *\n\t\t\t\t * Otherwise, we signal each child via\n\t\t\t\t * kill PID1 PID2 PID3.\n\t\t\t\t * Testcases:\n\t\t\t\t * sh -c 'sleep 1|sleep 1 & kill %1'\n\t\t\t\t * sh -c 'true|sleep 2 & sleep 1; kill %1'\n\t\t\t\t * sh -c 'true|sleep 1 & sleep 2; kill %1'\n\t\t\t\t */\n\t\t\t\tn = jp->nprocs; /* can't be 0 (I hope) */\n\t\t\t\tif (jp->jobctl)\n\t\t\t\t\tn = 1;\n\t\t\t\tdst = alloca(n * sizeof(int)*4);\n\t\t\t\targv[i] = dst;\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tstruct procstat *ps = &jp->ps[j];\n\t\t\t\t\t/* Skip non-running and not-stopped members\n\t\t\t\t\t * (i.e. dead members) of the job\n\t\t\t\t\t */\n\t\t\t\t\tif (ps->ps_status != -1 && !WIFSTOPPED(ps->ps_status))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t/*\n\t\t\t\t\t * kill_main has matching code to expect\n\t\t\t\t\t * leading space. Needed to not confuse\n\t\t\t\t\t * negative pids with \"kill -SIGNAL_NO\" syntax\n\t\t\t\t\t */\n\t\t\t\t\tdst += sprintf(dst, jp->jobctl ? \" -%u\" : \" %u\", (int)ps->ps_pid);\n\t\t\t\t}\n\t\t\t\t*dst = '\\0';\n\t\t\t}\n\t\t} while (argv[++i]);\n\t}\n\treturn kill_main(argc, argv);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_471AE1(FILE *a1, __int64 a2, char a3)\n{\n  int result; // eax\n  unsigned int v4; // eax\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 v7; // r8\n  __int64 v8; // r9\n  int v9; // eax\n  int v10; // eax\n  const char *v11; // rdi\n  unsigned int v12; // ecx\n  char v15[80]; // [rsp+20h] [rbp-70h] BYREF\n  unsigned int *v16; // [rsp+70h] [rbp-20h]\n  unsigned int v17; // [rsp+7Ch] [rbp-14h]\n  int v18; // [rsp+80h] [rbp-10h]\n  unsigned int v19; // [rsp+84h] [rbp-Ch]\n  unsigned int *v20; // [rsp+88h] [rbp-8h]\n\n  v20 = *(unsigned int **)(a2 + 16);\n  if ( (a3 & 1) != 0 )\n    return fprintf(a1, \"%d\\n\", *v20);\n  v4 = sub_470E5C(a2);\n  v19 = sub_46E1F9(v15, 0x10uLL, \"[%d]   \", v4, v5, v6);\n  v17 = v19;\n  if ( a2 == qword_75AFB0 )\n  {\n    v15[v19 - 3] = 43;\n  }\n  else if ( qword_75AFB0 && a2 == *(_QWORD *)(qword_75AFB0 + 32) )\n  {\n    v15[v19 - 3] = 45;\n  }\n  if ( (a3 & 2) != 0 )\n  {\n    v9 = sub_46E1F9(&v15[v19], 0x10uLL, \"%d \", *v20, v7, v8);\n    v19 += v9;\n  }\n  v16 = &v20[4 * *(unsigned __int16 *)(a2 + 28)];\n  if ( *(_BYTE *)(a2 + 30) )\n  {\n    v18 = *(v16 - 3);\n    if ( *(_BYTE *)(a2 + 30) == 1 )\n      v18 = *(_DWORD *)(a2 + 24);\n    v10 = sub_471762(&v15[v19], v18, 0, (__int64)&v15[v19], v7, v8);\n    v19 += v10;\n  }\n  else\n  {\n    *(_QWORD *)&v15[v19] = 0x676E696E6E7552LL;\n    v19 += 7;\n  }\n  while ( 1 )\n  {\n    if ( v20 == *(unsigned int **)(a2 + 16) )\n      v11 = (const char *)&unk_51CA3E;\n    else\n      v11 = \"| \";\n    v12 = 0;\n    if ( (int)(33 - v19) >= 0 )\n      v12 = 33 - v19;\n    fprintf(a1, \"%s%*c%s%s\", v15, v12, 32LL, v11, *((const char **)v20 + 1));\n    v20 += 4;\n    if ( v20 == v16 )\n      break;\n    v15[0] = 0;\n    v19 = 33;\n    if ( (a3 & 2) != 0 )\n      v19 = sub_46E1F9(v15, 0x30uLL, \"\\n%*c%d \", v17, 32LL, *v20) - 1;\n  }\n  sub_46E0F3(10, a1);\n  *(_BYTE *)(a2 + 31) &= ~0x10u;\n  result = *(unsigned __int8 *)(a2 + 30);\n  if ( (_BYTE)result == 2 )\n    return sub_47107C(a2);\n  return result;\n}\n\n\n Revised code:\nif JOBS\nstatic void\nshowjob(FILE *out, struct job *jp, int mode)\n{\n\tstruct procstat *ps;\n\tstruct procstat *psend;\n\tint col;\n\tint indent_col;\n\tchar s[80];\n\n\tps = jp->ps;\n\n\tif (mode & SHOW_ONLY_PGID) { /* jobs -p */\n\t\t/* just output process (group) id of pipeline */\n\t\tfprintf(out, \"%d\\n\", ps->ps_pid);\n\t\treturn;\n\t}\n\n\tcol = fmtstr(s, 16, \"[%d]   \", jobno(jp));\n\tindent_col = col;\n\n\tif (jp == curjob)\n\t\ts[col - 3] = '+';\n\telse if (curjob && jp == curjob->prev_job)\n\t\ts[col - 3] = '-';\n\n\tif (mode & SHOW_PIDS)\n\t\tcol += fmtstr(s + col, 16, \"%d \", ps->ps_pid);\n\n\tpsend = ps + jp->nprocs;\n\n\tif (jp->state == JOBRUNNING) {\n\t\tstrcpy(s + col, \"Running\");\n\t\tcol += sizeof(\"Running\") - 1;\n\t} else {\n\t\tint status = psend[-1].ps_status;\n\t\tif (jp->state == JOBSTOPPED)\n\t\t\tstatus = jp->stopstatus;\n\t\tcol += sprint_status(s + col, status, 0);\n\t}\n\t/* By now, \"[JOBID]*  [maybe PID] STATUS\" is printed */\n\n\t/* This loop either prints \"<cmd1> | <cmd2> | <cmd3>\" line\n\t * or prints several \"PID             | <cmdN>\" lines,\n\t * depending on SHOW_PIDS bit.\n\t * We do not print status of individual processes\n\t * between PID and <cmdN>. bash does it, but not very well:\n\t * first line shows overall job status, not process status,\n\t * making it impossible to know 1st process status.\n\t */\n\tgoto start;\n\tdo {\n\t\t/* for each process */\n\t\ts[0] = '\\0';\n\t\tcol = 33;\n\t\tif (mode & SHOW_PIDS)\n\t\t\tcol = fmtstr(s, 48, \"\\n%*c%d \", indent_col, ' ', ps->ps_pid) - 1;\n start:\n\t\tfprintf(out, \"%s%*c%s%s\",\n\t\t\t\ts,\n\t\t\t\t33 - col >= 0 ? 33 - col : 0, ' ',\n\t\t\t\tps == jp->ps ? \"\" : \"| \",\n\t\t\t\tps->ps_cmd\n\t\t);\n\t} while (++ps != psend);\n\toutcslow('\\n', out);\n\n\tjp->changed = 0;\n\n\tif (jp->state == JOBDONE) {\n\t\tTRACE((\"showjob: freeing job %d\\n\", jobno(jp)));\n\t\tfreejob(jp);\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_451DE5(__int64 a1, __int64 a2)\n{\n  __int64 v3; // r8\n  __int64 v4; // r9\n  char s[8]; // [rsp+20h] [rbp-1A0h] BYREF\n  unsigned __int16 *v6; // [rsp+28h] [rbp-198h]\n  __int64 v7; // [rsp+38h] [rbp-188h]\n  int v8; // [rsp+19Ch] [rbp-24h]\n  __int64 v9; // [rsp+1A0h] [rbp-20h]\n  int v10; // [rsp+1ACh] [rbp-14h]\n  void **i; // [rsp+1B0h] [rbp-10h]\n  char *v12; // [rsp+1B8h] [rbp-8h]\n\n  v9 = a2 + 16;\n  if ( *(_WORD *)(a2 + 4) != 16 )\n    return 0LL;\n  if ( *(_DWORD *)a2 <= 0x17u )\n    return 0xFFFFFFFFLL;\n  memset(s, 0, 0x178uLL);\n  sub_451A69((__int64)s, 46, (unsigned __int16 *)(v9 + 16), (unsigned int)(*(_DWORD *)a2 - 32), v3, v4);\n  if ( !v7 )\n    return 0LL;\n  if ( !qword_75B0E0 )\n    qword_75B0E0 = (__int64)sub_40A0E8(0x80uLL, 46LL);\n  v8 = *(_DWORD *)(v9 + 4) & 0xF;\n  for ( i = (void **)(8LL * v8 + qword_75B0E0); ; i = (void **)v12 )\n  {\n    v12 = (char *)*i;\n    if ( !v12 )\n      break;\n    if ( *((_DWORD *)v12 + 2) == *(_DWORD *)(v9 + 4) )\n      goto LABEL_14;\n  }\n  v12 = (char *)sub_40A05F(0x30uLL, 46LL);\n  *(_QWORD *)v12 = *i;\n  *((_DWORD *)v12 + 2) = *(_DWORD *)(v9 + 4);\n  *i = v12;\nLABEL_14:\n  *((_DWORD *)v12 + 3) = *(unsigned __int16 *)(v9 + 2);\n  *((_DWORD *)v12 + 5) = *(_DWORD *)(v9 + 8);\n  if ( v6 )\n  {\n    v10 = *v6 - 4;\n    *((_DWORD *)v12 + 4) = v10;\n    if ( v10 > 8 )\n      v10 = 8;\n    memcpy(v12 + 24, v6 + 2, v10);\n  }\n  else\n  {\n    *((_DWORD *)v12 + 4) = 0;\n    memset(v12 + 24, 0, 8uLL);\n  }\n  strcpy(v12 + 32, (const char *)(v7 + 4));\n  return 0LL;\n}\n\n\n Revised code:\nint FAST_FUNC ll_remember_index(const struct sockaddr_nl *who UNUSED_PARAM,\n\t\tstruct nlmsghdr *n,\n\t\tvoid *arg UNUSED_PARAM)\n{\n\tint h;\n\tstruct ifinfomsg *ifi = NLMSG_DATA(n);\n\tstruct idxmap *im, **imp;\n\tstruct rtattr *tb[IFLA_MAX+1];\n\n\tif (n->nlmsg_type != RTM_NEWLINK)\n\t\treturn 0;\n\n\tif (n->nlmsg_len < NLMSG_LENGTH(sizeof(ifi)))\n\t\treturn -1;\n\n\tmemset(tb, 0, sizeof(tb));\n\tparse_rtattr(tb, IFLA_MAX, IFLA_RTA(ifi), IFLA_PAYLOAD(n));\n\tif (tb[IFLA_IFNAME] == NULL)\n\t\treturn 0;\n\n\tif (!idxmap)\n\t\tidxmap = xzalloc(sizeof(idxmap[0]) * 16);\n\n\th = ifi->ifi_index & 0xF;\n\tfor (imp = &idxmap[h]; (im = *imp) != NULL; imp = &im->next)\n\t\tif (im->index == ifi->ifi_index)\n\t\t\tgoto found;\n\n\tim = xmalloc(sizeof(*im));\n\tim->next = *imp;\n\tim->index = ifi->ifi_index;\n\t*imp = im;\n found:\n\tim->type = ifi->ifi_type;\n\tim->flags = ifi->ifi_flags;\n\tif (tb[IFLA_ADDRESS]) {\n\t\tint alen;\n\t\tim->alen = alen = RTA_PAYLOAD(tb[IFLA_ADDRESS]);\n\t\tif (alen > (int)sizeof(im->addr))\n\t\t\talen = sizeof(im->addr);\n\t\tmemcpy(im->addr, RTA_DATA(tb[IFLA_ADDRESS]), alen);\n\t} else {\n\t\tim->alen = 0;\n\t\tmemset(im->addr, 0, sizeof(im->addr));\n\t}\n\tstrcpy(im->name, RTA_DATA(tb[IFLA_IFNAME]));\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40CF1F(unsigned int *a1, char *a2, int a3)\n{\n  __int64 v4; // rsi\n  void *v5; // rsp\n  unsigned int v6; // eax\n  _BYTE v8[12]; // [rsp+0h] [rbp-50h] BYREF\n  int v9; // [rsp+Ch] [rbp-44h]\n  char *s; // [rsp+10h] [rbp-40h]\n  unsigned int *v11; // [rsp+18h] [rbp-38h]\n  const char **v12; // [rsp+28h] [rbp-28h]\n  __int64 v13; // [rsp+30h] [rbp-20h]\n  unsigned int v14; // [rsp+38h] [rbp-18h]\n  int v15; // [rsp+3Ch] [rbp-14h]\n  char *v16; // [rsp+40h] [rbp-10h]\n  char *v17; // [rsp+48h] [rbp-8h]\n\n  v11 = a1;\n  s = a2;\n  v9 = a3;\n  v17 = a2;\n  v4 = 58LL;\n  v16 = strchr(a2, 58);\n  if ( v16 )\n  {\n    v15 = (_DWORD)++v16 - (_DWORD)s;\n    v5 = alloca(16 * (((int)v16 - (int)s + 23LL) / 0x10uLL));\n    v17 = v8;\n    v4 = (__int64)s;\n    sub_507FC0(v8, s, (int)v16 - (int)s);\n  }\n  if ( !v9 || (v4 = 0LL, v14 = sub_40BECF(v17, 0LL, 10), *(_DWORD *)qword_75D400) )\n  {\n    v13 = (__int64)sub_40C524(v17, v4);\n    if ( !v13 )\n      return 0LL;\n    *v11 = *(_DWORD *)(v13 + 16);\n    v11[1] = *(_DWORD *)(v13 + 20);\n  }\n  else\n  {\n    *v11 = v14;\n    v13 = sub_40C486(v14, 0LL);\n    if ( v13 )\n      v6 = *(_DWORD *)(v13 + 20);\n    else\n      v6 = v14;\n    v11[1] = v6;\n  }\n  if ( v16 )\n  {\n    if ( v9 )\n    {\n      v4 = 0LL;\n      v14 = sub_40BECF(v16, 0LL, 10);\n      if ( !*(_DWORD *)qword_75D400 )\n      {\n        v11[1] = v14;\n        return 1LL;\n      }\n    }\n    v12 = sub_40C573(v16, v4);\n    if ( !v12 )\n      return 0LL;\n    v11[1] = *((_DWORD *)v12 + 4);\n  }\n  return 1LL;\n}\n",
        "output": "static int FAST_FUNC process_input(unsigned int *input, char *string, int flag)\n{\n  void *stack_ptr;\n  unsigned int length;\n  _BYTE buffer[12];\n  int result;\n  char *s;\n  unsigned int *ptr;\n  const char **ptr2;\n  __int64 v13;\n  unsigned int v14;\n  int v15;\n  char *v16;\n  char *v17;\n\n  ptr = input;\n  s = string;\n  v15 = flag;\n  v17 = string;\n  v16 = strchr(string, ':');\n  if (v16)\n  {\n    length = (_DWORD)++v16 - (_DWORD)s;\n    stack_ptr = alloca(16 * (((int)v16 - (int)s + 23LL) / 0x10uLL));\n    v17 = buffer;\n    sub_507FC0(buffer, s, (int)v16 - (int)s);\n  }\n  if (!v15 || (length = sub_40BECF(v17, 0LL, 10), *(_DWORD *)qword_75D400))\n  {\n    v13 = (__int64)sub_40C524(v17, 0LL);\n    if (!v13)\n      return 0;\n    *ptr = *(_DWORD *)(v13 + 16);\n    ptr[1] = *(_DWORD *)(v13 + 20);\n  }\n  else\n  {\n    *ptr = length;\n    v13 = sub_40C486(length, 0LL);\n    if (v13)\n      result = *(_DWORD *)(v13 + 20);\n    else\n      result = length;\n    ptr[1] = result;\n  }\n  if (v16)\n  {\n    if (v15)\n    {\n      length = 0LL;\n      v14 = sub_40BECF(v16, 0LL, 10);\n      if (!*(_DWORD *)qword_75D400)\n      {\n        ptr[1] = v14;\n        return 1;\n      }\n    }\n    ptr2 = sub_40C573(v16, length);\n    if (!ptr2)\n      return 0;\n    ptr[1] = *((_DWORD *)ptr2 + 4);\n  }\n  return 1;\n}",
        "source_code": "int FAST_FUNC get_uidgid(struct bb_uidgid_t *u, const char *ug, int numeric_ok)\n{\n\tstruct passwd *pwd;\n\tstruct group *gr;\n\tchar *user, *group;\n\tunsigned n;\n\n\tuser = (char*)ug;\n\tgroup = strchr(ug, ':');\n\tif (group) {\n\t\tint sz = (++group) - ug;\n\t\tuser = alloca(sz);\n\t\t/* copies sz-1 bytes, stores terminating '\\0' */\n\t\tsafe_strncpy(user, ug, sz);\n\t}\n\tif (numeric_ok) {\n\t\tn = bb_strtou(user, NULL, 10);\n\t\tif (!errno) {\n\t\t\tu->uid = n;\n\t\t\tpwd = getpwuid(n);\n\t\t\t/* If we have e.g. \"500\" string without user */\n\t\t\t/* with uid 500 in /etc/passwd, we set gid == uid */\n\t\t\tu->gid = pwd ? pwd->pw_gid : n;\n\t\t\tgoto skip;\n\t\t}\n\t}\n\t/* Either it is not numeric, or caller disallows numeric username */\n\tpwd = getpwnam(user);\n\tif (!pwd)\n\t\treturn 0;\n\tu->uid = pwd->pw_uid;\n\tu->gid = pwd->pw_gid;\n\n skip:\n\tif (group) {\n\t\tif (numeric_ok) {\n\t\t\tn = bb_strtou(group, NULL, 10);\n\t\t\tif (!errno) {\n\t\t\t\tu->gid = n;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tgr = getgrnam(group);\n\t\tif (!gr)\n\t\t\treturn 0;\n\t\tu->gid = gr->gr_gid;\n\t}\n\treturn 1;\n}",
        "parsed_output": "static int FAST_FUNC process_input(unsigned int *input, char *string, int flag)\n{\n  void *stack_ptr;\n  unsigned int length;\n  _BYTE buffer[12];\n  int result;\n  char *s;\n  unsigned int *ptr;\n  const char **ptr2;\n  __int64 v13;\n  unsigned int v14;\n  int v15;\n  char *v16;\n  char *v17;\n\n  ptr = input;\n  s = string;\n  v15 = flag;\n  v17 = string;\n  v16 = strchr(string, ':');\n  if (v16)\n  {\n    length = (_DWORD)++v16 - (_DWORD)s;\n    stack_ptr = alloca(16 * (((int)v16 - (int)s + 23LL) / 0x10uLL));\n    v17 = buffer;\n    sub_507FC0(buffer, s, (int)v16 - (int)s);\n  }\n  if (!v15 || (length = sub_40BECF(v17, 0LL, 10), *(_DWORD *)qword_75D400))\n  {\n    v13 = (__int64)sub_40C524(v17, 0LL);\n    if (!v13)\n      return 0;\n    *ptr = *(_DWORD *)(v13 + 16);\n    ptr[1] = *(_DWORD *)(v13 + 20);\n  }\n  else\n  {\n    *ptr = length;\n    v13 = sub_40C486(length, 0LL);\n    if (v13)\n      result = *(_DWORD *)(v13 + 20);\n    else\n      result = length;\n    ptr[1] = result;\n  }\n  if (v16)\n  {\n    if (v15)\n    {\n      length = 0LL;\n      v14 = sub_40BECF(v16, 0LL, 10);\n      if (!*(_DWORD *)qword_75D400)\n      {\n        ptr[1] = v14;\n        return 1;\n      }\n    }\n    ptr2 = sub_40C573(v16, length);\n    if (!ptr2)\n      return 0;\n    ptr[1] = *((_DWORD *)ptr2 + 4);\n  }\n  return 1;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40CF1F(unsigned int *a1, char *a2, int a3)\n{\n  __int64 v4; // rsi\n  void *v5; // rsp\n  unsigned int v6; // eax\n  _BYTE v8[12]; // [rsp+0h] [rbp-50h] BYREF\n  int v9; // [rsp+Ch] [rbp-44h]\n  char *s; // [rsp+10h] [rbp-40h]\n  unsigned int *v11; // [rsp+18h] [rbp-38h]\n  const char **v12; // [rsp+28h] [rbp-28h]\n  __int64 v13; // [rsp+30h] [rbp-20h]\n  unsigned int v14; // [rsp+38h] [rbp-18h]\n  int v15; // [rsp+3Ch] [rbp-14h]\n  char *v16; // [rsp+40h] [rbp-10h]\n  char *v17; // [rsp+48h] [rbp-8h]\n\n  v11 = a1;\n  s = a2;\n  v9 = a3;\n  v17 = a2;\n  v4 = 58LL;\n  v16 = strchr(a2, 58);\n  if ( v16 )\n  {\n    v15 = (_DWORD)++v16 - (_DWORD)s;\n    v5 = alloca(16 * (((int)v16 - (int)s + 23LL) / 0x10uLL));\n    v17 = v8;\n    v4 = (__int64)s;\n    sub_507FC0(v8, s, (int)v16 - (int)s);\n  }\n  if ( !v9 || (v4 = 0LL, v14 = sub_40BECF(v17, 0LL, 10), *(_DWORD *)qword_75D400) )\n  {\n    v13 = (__int64)sub_40C524(v17, v4);\n    if ( !v13 )\n      return 0LL;\n    *v11 = *(_DWORD *)(v13 + 16);\n    v11[1] = *(_DWORD *)(v13 + 20);\n  }\n  else\n  {\n    *v11 = v14;\n    v13 = sub_40C486(v14, 0LL);\n    if ( v13 )\n      v6 = *(_DWORD *)(v13 + 20);\n    else\n      v6 = v14;\n    v11[1] = v6;\n  }\n  if ( v16 )\n  {\n    if ( v9 )\n    {\n      v4 = 0LL;\n      v14 = sub_40BECF(v16, 0LL, 10);\n      if ( !*(_DWORD *)qword_75D400 )\n      {\n        v11[1] = v14;\n        return 1LL;\n      }\n    }\n    v12 = sub_40C573(v16, v4);\n    if ( !v12 )\n      return 0LL;\n    v11[1] = *((_DWORD *)v12 + 4);\n  }\n  return 1LL;\n}\n",
        "baseline_code_debug": "int __cdecl get_uidgid(bb_uidgid_t *u, const char *ug, int numeric_ok)\n{\n  void *v3; // rsp\n  __gid_t pw_gid; // eax\n  char v6[12]; // [rsp+0h] [rbp-50h] BYREF\n  int numeric_oka; // [rsp+Ch] [rbp-44h]\n  const char *uga; // [rsp+10h] [rbp-40h]\n  bb_uidgid_t *ua; // [rsp+18h] [rbp-38h]\n  group *gr; // [rsp+28h] [rbp-28h]\n  passwd *pwd; // [rsp+30h] [rbp-20h]\n  unsigned int n; // [rsp+38h] [rbp-18h]\n  int sz; // [rsp+3Ch] [rbp-14h]\n  char *group; // [rsp+40h] [rbp-10h]\n  char *user; // [rsp+48h] [rbp-8h]\n\n  ua = u;\n  uga = ug;\n  numeric_oka = numeric_ok;\n  user = (char *)ug;\n  group = strchr(ug, 58);\n  if ( group )\n  {\n    sz = (_DWORD)++group - (_DWORD)uga;\n    v3 = alloca(16 * (((int)group - (int)uga + 23LL) / 0x10uLL));\n    user = v6;\n    safe_strncpy(v6, uga, (int)group - (int)uga);\n  }\n  if ( !numeric_oka || (n = bb_strtou(user, 0LL, 10), *bb_errno) )\n  {\n    pwd = bb_internal_getpwnam(user);\n    if ( !pwd )\n      return 0;\n    ua->uid = pwd->pw_uid;\n    ua->gid = pwd->pw_gid;\n  }\n  else\n  {\n    ua->uid = n;\n    pwd = bb_internal_getpwuid(n);\n    if ( pwd )\n      pw_gid = pwd->pw_gid;\n    else\n      pw_gid = n;\n    ua->gid = pw_gid;\n  }\n  if ( group )\n  {\n    if ( numeric_oka )\n    {\n      n = bb_strtou(group, 0LL, 10);\n      if ( !*bb_errno )\n      {\n        ua->gid = n;\n        return 1;\n      }\n    }\n    gr = bb_internal_getgrnam(group);\n    if ( !gr )\n      return 0;\n    ua->gid = gr->gr_gid;\n  }\n  return 1;\n}\n",
        "similarity_score_unixcoder": 0.5167366862297058,
        "similarity_score_baseline_stripped": 0.45698288083076477,
        "similarity_score_baseline_debug": 0.8146843314170837
    },
    {
        "func_name": "chmod_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_46FB8F(_QWORD *a1, const char *a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // rax\n  __int64 v8; // rdx\n  __int64 v9; // rcx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  unsigned __int64 v12; // [rsp+10h] [rbp-30h]\n  _BYTE *src; // [rsp+18h] [rbp-28h]\n  char *dest; // [rsp+20h] [rbp-20h]\n  _BYTE *i; // [rsp+28h] [rbp-18h]\n\n  if ( !*a1 )\n    return 0LL;\n  src = (_BYTE *)*a1;\n  for ( i = (_BYTE *)*a1; *i && *i != 58 && *i != 37; ++i )\n    ;\n  v12 = i - src + strlen(a2) + 2;\n  while ( v12 > *(_QWORD *)(qword_75D428 + 32) )\n    sub_46E9D5((__int64)a2, (__int64)a2, v3, v4, v5, v6);\n  dest = *(char **)(qword_75D428 + 16);\n  if ( i != src )\n  {\n    memcpy(dest, src, i - src);\n    v7 = &dest[i - src];\n    dest = v7 + 1;\n    *v7 = 47;\n  }\n  strcpy(dest, a2);\n  qword_75AF70 = 0LL;\n  if ( *i == 37 )\n  {\n    qword_75AF70 = (__int64)++i;\n    while ( *i && *i != 58 )\n      ++i;\n  }\n  if ( *i == 58 )\n  {\n    v8 = (__int64)(i + 1);\n    *a1 = i + 1;\n  }\n  else\n  {\n    *a1 = 0LL;\n  }\n  return sub_46E6A8(v12, (__int64)a2, v8, v9, v10, v11);\n}\n\n\n Revised code:\nstatic char *\npath_advance(const char **path, const char *name)\n{\n\tconst char *p;\n\tchar *q;\n\tconst char *start;\n\tsize_t len;\n\n\tif (*path == NULL)\n\t\treturn NULL;\n\tstart = *path;\n\tfor (p = start; *p && *p != ':' && *p != '%'; p++)\n\t\tcontinue;\n\tlen = p - start + strlen(name) + 2;     /* \"2\" is for '/' and '\\0' */\n\twhile (stackblocksize() < len)\n\t\tgrowstackblock();\n\tq = stackblock();\n\tif (p != start) {\n\t\tmemcpy(q, start, p - start);\n\t\tq += p - start;\n\t\t*q++ = '/';\n\t}\n\tstrcpy(q, name);\n\tpathopt = NULL;\n\tif (*p == '%') {\n\t\tpathopt = ++p;\n\t\twhile (*p && *p != ':')\n\t\t\tp++;\n\t}\n\tif (*p == ':')\n\t\t*path = p + 1;\n\telse\n\t\t*path = NULL;\n\treturn stalloc(len);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4C63E2(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  __int64 v6; // rax\n  _BOOL4 v7; // edx\n  int v8; // eax\n  int v9; // edx\n  __int64 v11; // [rsp+0h] [rbp-40h]\n  __int64 v12[2]; // [rsp+10h] [rbp-30h]\n  void *ptr; // [rsp+20h] [rbp-20h]\n  char *s2; // [rsp+28h] [rbp-18h]\n  void *v15; // [rsp+30h] [rbp-10h]\n  int v16; // [rsp+38h] [rbp-8h]\n  int i; // [rsp+3Ch] [rbp-4h]\n\n  qword_75D440 = (__int64)\"=2\";\n  sub_4FA1EF(a2, (unsigned int)\"123\", a3, a4, a5, a6);\n  v11 = 8LL * optind + a2;\n  for ( i = 0; i <= 1; ++i )\n  {\n    v6 = sub_50A7F5(*(_QWORD *)(8LL * i + v11));\n    v12[i] = v6;\n  }\n  v16 = 0;\n  ptr = 0LL;\n  s2 = 0LL;\n  while ( 1 )\n  {\n    if ( v16 <= 0 )\n    {\n      free(ptr);\n      ptr = (void *)sub_4F9FF1(v12[0]);\n    }\n    if ( v16 >= 0 )\n    {\n      free(s2);\n      s2 = (char *)sub_4F9FF1(v12[1]);\n    }\n    v7 = ptr == 0LL;\n    v8 = s2 ? 0 : 2;\n    i = v7 + v8;\n    if ( v7 + v8 )\n      break;\n    v16 = strcmp((const char *)ptr, s2);\n    if ( v16 < 0 )\n    {\n      sub_4C634C((const char *)ptr, 0);\n    }\n    else\n    {\n      if ( v16 )\n        v9 = 1;\n      else\n        v9 = 2;\n      sub_4C634C(s2, v9);\n    }\n  }\n  i &= 1u;\n  if ( *(&ptr + i) )\n  {\n    v15 = *(&ptr + i);\n    sub_4C634C((const char *)v15, i);\n    while ( 1 )\n    {\n      free(v15);\n      v15 = (void *)sub_4F9FF1(v12[i]);\n      if ( !v15 )\n        break;\n      sub_4C634C((const char *)v15, i);\n    }\n  }\n  return 0LL;\n}\n\n\n Revised code:\nint comm_main(int argc UNUSED_PARAM, char **argv)\n{\n\tchar *thisline[2];\n\tFILE *stream[2];\n\tint i;\n\tint order;\n\n\topt_complementary = \"=2\";\n\tgetopt32(argv, \"123\");\n\targv += optind;\n\n\tfor (i = 0; i < 2; ++i) {\n\t\tstream[i] = xfopen_stdin(argv[i]);\n\t}\n\n\torder = 0;\n\tthisline[1] = thisline[0] = NULL;\n\twhile (1) {\n\t\tif (order <= 0) {\n\t\t\tfree(thisline[0]);\n\t\t\tthisline[0] = xmalloc_fgetline(stream[0]);\n\t\t}\n\t\tif (order >= 0) {\n\t\t\tfree(thisline[1]);\n\t\t\tthisline[1] = xmalloc_fgetline(stream[1]);\n\t\t}\n\n\t\ti = !thisline[0] + (!thisline[1] << 1);\n\t\tif (i)\n\t\t\tbreak;\n\t\torder = strcmp(thisline[0], thisline[1]);\n\n\t\tif (order >= 0)\n\t\t\twriteline(thisline[1], order ? 1 : 2);\n\t\telse\n\t\t\twriteline(thisline[0], 0);\n\t}\n\n\t/* EOF at least on one of the streams */\n\ti &= 1;\n\tif (thisline[i]) {\n\t\t/* stream[i] is not at EOF yet */\n\t\t/* we did not print thisline[i] yet */\n\t\tchar *p = thisline[i];\n\t\twriteline(p, i);\n\t\twhile (1) {\n\t\t\tfree(p);\n\t\t\tp = xmalloc_fgetline(stream[i]);\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\t\t\twriteline(p, i);\n\t\t}\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP) {\n\t\tfclose(stream[0]);\n\t\tfclose(stream[1]);\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_473F3A(unsigned __int8 *a1, unsigned __int64 a2, char a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  unsigned __int64 v6; // rax\n  unsigned __int8 *v7; // rax\n  _BYTE *v8; // rax\n  unsigned __int8 *v9; // rax\n  __int64 result; // rax\n  int v12; // [rsp+8h] [rbp-28h]\n  unsigned __int64 v14; // [rsp+10h] [rbp-20h]\n  int v16; // [rsp+20h] [rbp-10h]\n  unsigned __int8 v17; // [rsp+27h] [rbp-9h]\n  __int64 v18; // [rsp+28h] [rbp-8h]\n\n  v14 = a2;\n  v12 = a4;\n  if ( (_DWORD)a4 )\n    v6 = 2 * a2;\n  else\n    v6 = a2;\n  v18 = sub_46ECB9(v6, qword_75AFC8, qword_75AFC8, a4, a5, a6);\n  while ( v14-- )\n  {\n    v7 = a1++;\n    v17 = *v7;\n    if ( *v7 )\n    {\n      if ( v12 )\n      {\n        v16 = sub_4704BD(v17, a3);\n        if ( v16 == 12 || v16 == 2 )\n        {\n          v8 = (_BYTE *)v18++;\n          *v8 = -127;\n        }\n      }\n      v9 = (unsigned __int8 *)v18++;\n      *v9 = v17;\n    }\n  }\n  result = v18;\n  qword_75AFC8 = v18;\n  return result;\n}\n\n\n Revised code:\nstatic void\nmemtodest(const char *p, size_t len, int syntax, int quotes)\n{\n\tchar *q = expdest;\n\n\tq = makestrspace(quotes ? len * 2 : len, q);\n\n\twhile (len--) {\n\t\tunsigned char c = *p++;\n\t\tif (c == '\\0')\n\t\t\tcontinue;\n\t\tif (quotes) {\n\t\t\tint n = SIT(c, syntax);\n\t\t\tif (n == CCTL || n == CBACK)\n\t\t\t\tUSTPUTC(CTLESC, q);\n\t\t}\n\t\tUSTPUTC(c, q);\n\t}\n\n\texpdest = q;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4C5E24(__int64 a1, _BYTE **a2, __int64 a3, int a4, int a5, int a6)\n{\n  __int64 *v6; // rax\n  __int64 v8; // [rsp+0h] [rbp-30h]\n  __int64 *v9; // [rsp+0h] [rbp-30h]\n  _QWORD *v10; // [rsp+0h] [rbp-30h]\n  __int64 v11; // [rsp+10h] [rbp-20h]\n  _BYTE **v12; // [rsp+18h] [rbp-18h]\n  _BYTE *v13; // [rsp+20h] [rbp-10h]\n  unsigned int v14; // [rsp+2Ch] [rbp-4h]\n\n  v14 = 0;\n  v12 = a2;\n  while ( 1 )\n  {\n    v13 = *++v12;\n    if ( !*v12 )\n      break;\n    if ( *v13 != 45 )\n    {\n      v13 = 0LL;\n      break;\n    }\n    if ( v13[1] && !strchr(\"-Rvcf\", (char)v13[1]) )\n    {\n      *v13 = 97;\n      break;\n    }\n  }\n  qword_75D440 = (__int64)\"-2\";\n  sub_4FA1EF((_DWORD)a2, 5447004, 5447004, a4, a5, a6, a2);\n  v9 = (__int64 *)(8LL * optind + v8);\n  if ( v13 )\n    *v13 = 45;\n  v6 = v9;\n  v10 = v9 + 1;\n  v11 = *v6;\n  do\n  {\n    if ( !(unsigned int)sub_50752C(*v10, dword_75D450 & 1, sub_4C5D04, sub_4C5D04, v11, 0LL) )\n      v14 = 1;\n    ++v10;\n  }\n  while ( *v10 );\n  return v14;\n}\n",
        "output": "static int process_args(int argc, char **argv) {\n    int i;\n    char *arg;\n\n    for (i = 1; i < argc; i++) {\n        arg = argv[i];\n        if (*arg != '-') {\n            arg = NULL;\n            break;\n        }\n        if (arg[1] && !strchr(\"-Rvcf\", arg[1])) {\n            *arg = 'a';\n            break;\n        }\n    }\n\n    opt_complementary = \"-2\";\n    getopt32(argv, \"abc\");\n    argv += optind;\n\n    for (i = 0; argv[i]; i++) {\n        if (!sub_50752C(argv[i], (dword_75D450 & 1), sub_4C5D04, sub_4C5D04, v11, 0LL)) {\n            return 1;\n        }\n    }\n\n    return 0;\n}",
        "source_code": "int chmod_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint retval = EXIT_SUCCESS;\n\tchar *arg, **argp;\n\tchar *smode;\n\n\t/* Convert first encountered -r into ar, -w into aw etc\n\t * so that getopt would not eat it */\n\targp = argv;\n\twhile ((arg = *++argp)) {\n\t\t/* Mode spec must be the first arg (sans -R etc) */\n\t\t/* (protect against mishandling e.g. \"chmod 644 -r\") */\n\t\tif (arg[0] != '-') {\n\t\t\targ = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/* An option. Not a -- or valid option? */\n\t\tif (arg[1] && !strchr(\"-\"OPT_STR, arg[1])) {\n\t\t\targ[0] = 'a';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Parse options */\n\topt_complementary = \"-2\";\n\tgetopt32(argv, (\"-\"OPT_STR) + 1); /* Reuse string */\n\targv += optind;\n\n\t/* Restore option-like mode if needed */\n\tif (arg) arg[0] = '-';\n\n\t/* Ok, ready to do the deed now */\n\tsmode = *argv++;\n\tdo {\n\t\tif (!recursive_action(*argv,\n\t\t\tOPT_RECURSE,    // recurse\n\t\t\tfileAction,     // file action\n\t\t\tfileAction,     // dir action\n\t\t\tsmode,          // user data\n\t\t\t0)              // depth\n\t\t) {\n\t\t\tretval = EXIT_FAILURE;\n\t\t}\n\t} while (*++argv);\n\n\treturn retval;\n}",
        "parsed_output": "static int process_args(int argc, char **argv) {\n    int i;\n    char *arg;\n\n    for (i = 1; i < argc; i++) {\n        arg = argv[i];\n        if (*arg != '-') {\n            arg = NULL;\n            break;\n        }\n        if (arg[1] && !strchr(\"-Rvcf\", arg[1])) {\n            *arg = 'a';\n            break;\n        }\n    }\n\n    opt_complementary = \"-2\";\n    getopt32(argv, \"abc\");\n    argv += optind;\n\n    for (i = 0; argv[i]; i++) {\n        if (!sub_50752C(argv[i], (dword_75D450 & 1), sub_4C5D04, sub_4C5D04, v11, 0LL)) {\n            return 1;\n        }\n    }\n\n    return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4C5E24(__int64 a1, _BYTE **a2, __int64 a3, int a4, int a5, int a6)\n{\n  __int64 *v6; // rax\n  __int64 v8; // [rsp+0h] [rbp-30h]\n  __int64 *v9; // [rsp+0h] [rbp-30h]\n  _QWORD *v10; // [rsp+0h] [rbp-30h]\n  __int64 v11; // [rsp+10h] [rbp-20h]\n  _BYTE **v12; // [rsp+18h] [rbp-18h]\n  _BYTE *v13; // [rsp+20h] [rbp-10h]\n  unsigned int v14; // [rsp+2Ch] [rbp-4h]\n\n  v14 = 0;\n  v12 = a2;\n  while ( 1 )\n  {\n    v13 = *++v12;\n    if ( !*v12 )\n      break;\n    if ( *v13 != 45 )\n    {\n      v13 = 0LL;\n      break;\n    }\n    if ( v13[1] && !strchr(\"-Rvcf\", (char)v13[1]) )\n    {\n      *v13 = 97;\n      break;\n    }\n  }\n  qword_75D440 = (__int64)\"-2\";\n  sub_4FA1EF((_DWORD)a2, 5447004, 5447004, a4, a5, a6, a2);\n  v9 = (__int64 *)(8LL * optind + v8);\n  if ( v13 )\n    *v13 = 45;\n  v6 = v9;\n  v10 = v9 + 1;\n  v11 = *v6;\n  do\n  {\n    if ( !(unsigned int)sub_50752C(*v10, dword_75D450 & 1, sub_4C5D04, sub_4C5D04, v11, 0LL) )\n      v14 = 1;\n    ++v10;\n  }\n  while ( *v10 );\n  return v14;\n}\n",
        "baseline_code_debug": "int __cdecl chmod_main(int argc, char **argv)\n{\n  char **v2; // rax\n  char **argva; // [rsp+0h] [rbp-30h]\n  char **argvb; // [rsp+0h] [rbp-30h]\n  char *smode; // [rsp+10h] [rbp-20h]\n  char **argp; // [rsp+18h] [rbp-18h]\n  char *arg; // [rsp+20h] [rbp-10h]\n  int retval; // [rsp+2Ch] [rbp-4h]\n\n  retval = 0;\n  argp = argv;\n  while ( 1 )\n  {\n    arg = *++argp;\n    if ( !*argp )\n      break;\n    if ( *arg != 45 )\n    {\n      arg = 0LL;\n      break;\n    }\n    if ( arg[1] && !strchr(\"-Rvcf\", arg[1]) )\n    {\n      *arg = 97;\n      break;\n    }\n  }\n  opt_complementary = \"-2\";\n  getopt32(argv, \"Rvcf\");\n  argva = &argv[optind];\n  if ( arg )\n    *arg = 45;\n  v2 = argva;\n  argvb = argva + 1;\n  smode = *v2;\n  do\n  {\n    if ( !recursive_action(\n            *argvb,\n            option_mask32 & 1,\n            (int (*)(const char *, stat *, void *, int))fileAction_3,\n            (int (*)(const char *, stat *, void *, int))fileAction_3,\n            smode,\n            0) )\n      retval = 1;\n    ++argvb;\n  }\n  while ( *argvb );\n  return retval;\n}\n",
        "similarity_score_unixcoder": 0.7939414381980896,
        "similarity_score_baseline_stripped": 0.49007394909858704,
        "similarity_score_baseline_debug": 0.8206008672714233
    },
    {
        "func_name": "out1fmt",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 sub_46E1F9(char *a1, size_t a2, const char *a3, __int64 a4, __int64 a5, __int64 a6, ...)\n{\n  gcc_va_list arg; // [rsp+20h] [rbp-D0h] BYREF\n  unsigned int v8; // [rsp+3Ch] [rbp-B4h]\n  __int64 v9; // [rsp+58h] [rbp-98h]\n  __int64 v10; // [rsp+60h] [rbp-90h]\n  __int64 v11; // [rsp+68h] [rbp-88h]\n\n  va_start(arg, a6);\n  v9 = a4;\n  v10 = a5;\n  v11 = a6;\n  arg[0].gp_offset = 24;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  v8 = vsnprintf(a1, a2, a3, arg);\n  sub_46E03F(a1, a2);\n  return v8;\n}\n\n\n Revised code:\nstatic int\nfmtstr(char *outbuf, size_t length, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tINT_OFF;\n\tret = vsnprintf(outbuf, length, fmt, ap);\n\tva_end(ap);\n\tINT_ON;\n\treturn ret;\n}\n\n## Example:\n\n Input code:\n__int64 sub_46E5D9(const char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)\n{\n  gcc_va_list va; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v8; // [rsp+38h] [rbp-A8h]\n  __int64 v9; // [rsp+40h] [rbp-A0h]\n  __int64 v10; // [rsp+48h] [rbp-98h]\n  __int64 v11; // [rsp+50h] [rbp-90h]\n  __int64 v12; // [rsp+58h] [rbp-88h]\n\n  va_start(va, a6);\n  v8 = a2;\n  v9 = a3;\n  v10 = a4;\n  v11 = a5;\n  v12 = a6;\n  va[0].gp_offset = 8;\n  return sub_46E350(a1, va);\n}\n\n\n Revised code:\nstatic void\nash_msg(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tash_vmsg(fmt, ap);\n\tva_end(ap);\n}\n\n## Example:\n\n Input code:\nvoid __noreturn sub_46E473(const char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)\n{\n  gcc_va_list va; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(va, a6);\n  v7 = a2;\n  v8 = a3;\n  v9 = a4;\n  v10 = a5;\n  v11 = a6;\n  va[0].gp_offset = 8;\n  sub_46E43E(1, a1, va);\n}\n\n\n Revised code:\nstatic void\nash_msg_and_raise_error(const char *msg, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, msg);\n\tash_vmsg_and_raise(EXERROR, msg, ap);\n\t/* NOTREACHED */\n\tva_end(ap);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_46E137(const char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)\n{\n  gcc_va_list arg; // [rsp+10h] [rbp-D0h] BYREF\n  unsigned int v8; // [rsp+2Ch] [rbp-B4h]\n  __int64 v9; // [rsp+38h] [rbp-A8h]\n  __int64 v10; // [rsp+40h] [rbp-A0h]\n  __int64 v11; // [rsp+48h] [rbp-98h]\n  __int64 v12; // [rsp+50h] [rbp-90h]\n  __int64 v13; // [rsp+58h] [rbp-88h]\n\n  va_start(arg, a6);\n  v9 = a2;\n  v10 = a3;\n  v11 = a4;\n  v12 = a5;\n  v13 = a6;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  arg[0].gp_offset = 8;\n  v8 = vprintf(a1, arg);\n  sub_46E03F(a1, arg);\n  return v8;\n}\n",
        "output": "static int\nprint_and_count(const char *format, ...)\n{\n\tva_list args;\n\tint count;\n\n\tva_start(args, format);\n\tcount = vprintf(format, args);\n\tva_end(args);\n\n\treturn count;\n}",
        "source_code": "static int\nout1fmt(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tINT_OFF;\n\tva_start(ap, fmt);\n\tr = vprintf(fmt, ap);\n\tva_end(ap);\n\tINT_ON;\n\treturn r;\n}",
        "parsed_output": "static int\nprint_and_count(const char *format, ...)\n{\n\tva_list args;\n\tint count;\n\n\tva_start(args, format);\n\tcount = vprintf(format, args);\n\tva_end(args);\n\n\treturn count;\n}",
        "baseline_code_stripped": "__int64 sub_46E137(const char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)\n{\n  gcc_va_list arg; // [rsp+10h] [rbp-D0h] BYREF\n  unsigned int v8; // [rsp+2Ch] [rbp-B4h]\n  __int64 v9; // [rsp+38h] [rbp-A8h]\n  __int64 v10; // [rsp+40h] [rbp-A0h]\n  __int64 v11; // [rsp+48h] [rbp-98h]\n  __int64 v12; // [rsp+50h] [rbp-90h]\n  __int64 v13; // [rsp+58h] [rbp-88h]\n\n  va_start(arg, a6);\n  v9 = a2;\n  v10 = a3;\n  v11 = a4;\n  v12 = a5;\n  v13 = a6;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  arg[0].gp_offset = 8;\n  v8 = vprintf(a1, arg);\n  sub_46E03F(a1, arg);\n  return v8;\n}\n",
        "baseline_code_debug": "int out1fmt(const char *fmt, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+10h] [rbp-D0h] BYREF\n  int r; // [rsp+2Ch] [rbp-B4h]\n  __int64 v9; // [rsp+38h] [rbp-A8h]\n  __int64 v10; // [rsp+40h] [rbp-A0h]\n  __int64 v11; // [rsp+48h] [rbp-98h]\n  __int64 v12; // [rsp+50h] [rbp-90h]\n  __int64 v13; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmt);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v9 = v3;\n  v10 = v1;\n  v11 = v2;\n  v12 = v4;\n  v13 = v5;\n  ++ash_ptr_to_globals_misc->suppress_int;\n  ap[0].gp_offset = 8;\n  r = vprintf(fmt, ap);\n  int_on();\n  return r;\n}\n",
        "similarity_score_unixcoder": 0.8181241750717163,
        "similarity_score_baseline_stripped": 0.5872856378555298,
        "similarity_score_baseline_debug": 0.681557297706604
    },
    {
        "func_name": "localcmd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4707B3(const char *a1, __int64 a2)\n{\n  void **v2; // rdi\n  void ***v4; // [rsp+18h] [rbp-8h]\n\n  v4 = (void ***)sub_470562(a1);\n  if ( !*v4 )\n    return 1LL;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  v2 = *v4;\n  *v4 = sub_470668(*v4);\n  sub_46E03F(v2, a2);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int\nunalias(const char *name)\n{\n\tstruct alias **app;\n\n\tapp = __lookupalias(name);\n\n\tif (*app) {\n\t\tINT_OFF;\n\t\t*app = freealias(*app);\n\t\tINT_ON;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_46FA1E(_QWORD *a1, unsigned int a2)\n{\n  __int64 result; // rax\n  unsigned __int8 *v3; // rdi\n  _QWORD *v4; // [rsp+18h] [rbp-8h]\n\n  result = (__int64)a1;\n  v4 = a1;\n  if ( a1 )\n  {\n    ++*(_DWORD *)(qword_75D418 + 48);\n    do\n    {\n      v3 = (unsigned __int8 *)v4[1];\n      sub_46F51C(v3, a2);\n      v4 = (_QWORD *)*v4;\n    }\n    while ( v4 );\n    return sub_46E03F(v3, a2);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\nlistsetvar(struct strlist *list_set_var, int flags)\n{\n\tstruct strlist *lp = list_set_var;\n\n\tif (!lp)\n\t\treturn;\n\tINT_OFF;\n\tdo {\n\t\tsetvareq(lp->text, flags);\n\t\tlp = lp->next;\n\t} while (lp);\n\tINT_ON;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_453547(unsigned __int8 *a1)\n{\n  unsigned __int8 *v3; // [rsp+0h] [rbp-8h]\n\n  while ( 1 )\n  {\n    v3 = sub_4534CD(a1);\n    if ( !v3 )\n      return 0LL;\n    if ( !*v3 )\n      break;\n    a1 = v3 + 1;\n  }\n  return 1LL;\n}\n\n\n Revised code:\nstatic int good_hostname(const char *name)\n{\n\t//const char *start = name;\n\n\tfor (;;) {\n\t\tname = valid_domain_label(name);\n\t\tif (!name)\n\t\t\treturn 0;\n\t\tif (!name[0])\n\t\t\treturn 1;\n\t\t\t//Do we want this?\n\t\t\t//return ((name - start) < 1025); /* NS_MAXDNAME */\n\t\tname++;\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4792F7(__int64 a1, __int64 a2)\n{\n  unsigned __int8 **v2; // rax\n  __int64 v4; // [rsp+0h] [rbp-20h]\n\n  v4 = qword_75AF58;\n  while ( 1 )\n  {\n    v2 = (unsigned __int8 **)v4;\n    v4 += 8LL;\n    if ( !*v2 )\n      break;\n    sub_47916A(*v2, a2);\n  }\n  return 0LL;\n}\n",
        "output": "static int process_data(__int64 data1, __int64 data2)\n{\n\tunsigned __int8 **ptr = (unsigned __int8 **)data1;\n\t__int64 temp = qword_75AF58;\n\n\twhile (1)\n\t{\n\t\tptr = (unsigned __int8 **)temp;\n\t\ttemp += 8LL;\n\t\tif (!*ptr)\n\t\t\tbreak;\n\t\tprocess_data(*ptr, data2);\n\t}\n\treturn 0;\n}",
        "source_code": "static int FAST_FUNC\nlocalcmd(int argc UNUSED_PARAM, char **argv)\n{\n\tchar *name;\n\n\targv = argptr;\n\twhile ((name = *argv++) != NULL) {\n\t\tmklocal(name);\n\t}\n\treturn 0;\n}",
        "parsed_output": "static int process_data(__int64 data1, __int64 data2)\n{\n\tunsigned __int8 **ptr = (unsigned __int8 **)data1;\n\t__int64 temp = qword_75AF58;\n\n\twhile (1)\n\t{\n\t\tptr = (unsigned __int8 **)temp;\n\t\ttemp += 8LL;\n\t\tif (!*ptr)\n\t\t\tbreak;\n\t\tprocess_data(*ptr, data2);\n\t}\n\treturn 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4792F7(__int64 a1, __int64 a2)\n{\n  unsigned __int8 **v2; // rax\n  __int64 v4; // [rsp+0h] [rbp-20h]\n\n  v4 = qword_75AF58;\n  while ( 1 )\n  {\n    v2 = (unsigned __int8 **)v4;\n    v4 += 8LL;\n    if ( !*v2 )\n      break;\n    sub_47916A(*v2, a2);\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl localcmd(int argc, char **argv)\n{\n  char **v2; // rax\n  char **argva; // [rsp+0h] [rbp-20h]\n\n  argva = argptr;\n  while ( 1 )\n  {\n    v2 = argva++;\n    if ( !*v2 )\n      break;\n    mklocal(*v2);\n  }\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.5113850831985474,
        "similarity_score_baseline_stripped": 0.4459397792816162,
        "similarity_score_baseline_debug": 0.707247257232666
    },
    {
        "func_name": "undot",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A3D68(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+0h] [rbp-1Ch]\n  int v4; // [rsp+14h] [rbp-8h]\n  unsigned int i; // [rsp+18h] [rbp-4h]\n\n  v3 = a2;\n  if ( a2 )\n  {\n    v3 = a2 - 1;\n    if ( a2 != 1 && *(_DWORD *)(4LL * v3 + a1) == 10 )\n      v3 = a2 - 2;\n  }\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i >= v3 )\n      break;\n    v4 = *(_DWORD *)(4LL * (int)i + a1);\n    *(_DWORD *)(4LL * (int)i + a1) = *(_DWORD *)(4LL * v3 + a1);\n    *(_DWORD *)(a1 + 4LL * v3--) = v4;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void strrev(CHAR_T *s, int len)\n{\n\tint i;\n\n\tif (len != 0) {\n\t\tlen--;\n\t\tif (len != 0 && s[len] == '\\n')\n\t\t\tlen--;\n\t}\n\n\tfor (i = 0; i < len; i++, len--) {\n\t\tCHAR_T c = s[i];\n\t\ts[i] = s[len];\n\t\ts[len] = c;\n\t}\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_50A164(_BYTE *a1, _BYTE *a2, int a3, __int64 a4)\n{\n  _BYTE *v4; // rax\n  _BYTE *result; // rax\n  unsigned int v8; // [rsp+20h] [rbp-10h]\n  unsigned int v9; // [rsp+24h] [rbp-Ch]\n\n  while ( a3 > 0 )\n  {\n    v8 = 0;\n    v9 = 0;\n    a3 -= 3;\n    if ( a3 >= -1 )\n    {\n      v9 = (unsigned __int8)a2[1];\n      if ( a3 >= 0 )\n        v8 = (unsigned __int8)a2[2];\n    }\n    *a1 = *(_BYTE *)((*a2 >> 2) + a4);\n    a1[1] = *(_BYTE *)(((16 * *a2) & 0x30) + (v9 >> 4) + a4);\n    a1[2] = *(_BYTE *)(((4 * (_BYTE)v9) & 0x3C) + (v8 >> 6) + a4);\n    v4 = a1 + 3;\n    a1 += 4;\n    *v4 = *(_BYTE *)((v8 & 0x3F) + a4);\n    a2 += 3;\n  }\n  result = a1;\n  *a1 = 0;\n  while ( a3 )\n  {\n    result = --a1;\n    *a1 = *(_BYTE *)(a4 + 64);\n    ++a3;\n  }\n  return result;\n}\n\n\n Revised code:\nvoid FAST_FUNC bb_uuencode(char *p, const void *src, int length, const char *tbl)\n{\n\tconst unsigned char *s = src;\n\n\t/* Transform the 3x8 bits to 4x6 bits */\n\twhile (length > 0) {\n\t\tunsigned s1, s2;\n\n\t\t/* Are s[1], s[2] valid or should be assumed 0? */\n\t\ts1 = s2 = 0;\n\t\tlength -= 3; /* can be >=0, -1, -2 */\n\t\tif (length >= -1) {\n\t\t\ts1 = s[1];\n\t\t\tif (length >= 0)\n\t\t\t\ts2 = s[2];\n\t\t}\n\t\t*p++ = tbl[s[0] >> 2];\n\t\t*p++ = tbl[((s[0] & 3) << 4) + (s1 >> 4)];\n\t\t*p++ = tbl[((s1 & 0xf) << 2) + (s2 >> 6)];\n\t\t*p++ = tbl[s2 & 0x3f];\n\t\ts += 3;\n\t}\n\t/* Zero-terminate */\n\t*p = '\\0';\n\t/* If length is -2 or -1, pad last char or two */\n\twhile (length) {\n\t\t*--p = tbl[64];\n\t\tlength++;\n\t}\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_481AB7(__int64 a1)\n{\n  _BYTE *v2; // rax\n  _BYTE *v4; // [rsp+0h] [rbp-18h]\n  int v5; // [rsp+14h] [rbp-4h]\n\n  v5 = 0;\n  v4 = (_BYTE *)(a1 + 1);\n  while ( *v4 )\n  {\n    if ( *v4 == 92 )\n    {\n      if ( !*++v4 )\n        break;\n      ++v4;\n    }\n    else\n    {\n      if ( *v4 == 125 && !v5-- )\n        break;\n      if ( *v4 == 44 && !v5 )\n        break;\n      v2 = v4++;\n      if ( *v2 == 123 )\n        ++v5;\n    }\n  }\n  if ( *v4 )\n    return v4;\n  else\n    return 0LL;\n}\n\n\n Revised code:\nstatic const char *next_brace_sub(const char *cp)\n{\n\tunsigned depth = 0;\n\tcp++;\n\twhile (*cp != '\\0') {\n\t\tif (*cp == '\\\\') {\n\t\t\tif (*++cp == '\\0')\n\t\t\t\tbreak;\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((*cp == '}' && depth-- == 0) || (*cp == ',' && depth == 0))\n\t\t\tbreak;\n\t\tif (*cp++ == '{')\n\t\t\tdepth++;\n\t}\n\n\treturn *cp != '\\0' ? cp : NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_4285AE(__int64 a1)\n{\n  _BYTE *result; // rax\n  char v2; // [rsp+10h] [rbp-8h]\n  int v3; // [rsp+14h] [rbp-4h]\n  int i; // [rsp+14h] [rbp-4h]\n\n  v3 = 0;\n  v2 = 0;\n  while ( 1 )\n  {\n    result = (_BYTE *)*(unsigned __int8 *)(v3 + a1);\n    if ( !(_BYTE)result )\n      break;\n    ++v3;\n  }\n  for ( i = v3 - 1; i >= 0; --i )\n  {\n    result = (_BYTE *)*(unsigned __int8 *)(i + a1);\n    if ( (_BYTE)result == 46 )\n    {\n      result = (_BYTE *)(i + a1);\n      *result = v2;\n      v2 = 0;\n    }\n    else\n    {\n      ++v2;\n    }\n  }\n  return result;\n}\n",
        "output": "static void remove_dots(char *s)\n{\n\tint len = strlen(s);\n\tint i;\n\tchar prev = 0;\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tchar c = s[i];\n\t\tif (c == '.') {\n\t\t\ts[i] = prev;\n\t\t\tprev = 0;\n\t\t} else {\n\t\t\tprev++;\n\t\t}\n\t}\n}",
        "source_code": "static void undot(char *rip)\n{\n\tint i = 0;\n\tint s = 0;\n\n\twhile (rip[i])\n\t\ti++;\n\tfor (--i; i >= 0; i--) {\n\t\tif (rip[i] == '.') {\n\t\t\trip[i] = s;\n\t\t\ts = 0;\n\t\t} else {\n\t\t\ts++;\n\t\t}\n\t}\n}",
        "parsed_output": "static void remove_dots(char *s)\n{\n\tint len = strlen(s);\n\tint i;\n\tchar prev = 0;\n\n\tfor (i = len - 1; i >= 0; i--) {\n\t\tchar c = s[i];\n\t\tif (c == '.') {\n\t\t\ts[i] = prev;\n\t\t\tprev = 0;\n\t\t} else {\n\t\t\tprev++;\n\t\t}\n\t}\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_4285AE(__int64 a1)\n{\n  _BYTE *result; // rax\n  char v2; // [rsp+10h] [rbp-8h]\n  int v3; // [rsp+14h] [rbp-4h]\n  int i; // [rsp+14h] [rbp-4h]\n\n  v3 = 0;\n  v2 = 0;\n  while ( 1 )\n  {\n    result = (_BYTE *)*(unsigned __int8 *)(v3 + a1);\n    if ( !(_BYTE)result )\n      break;\n    ++v3;\n  }\n  for ( i = v3 - 1; i >= 0; --i )\n  {\n    result = (_BYTE *)*(unsigned __int8 *)(i + a1);\n    if ( (_BYTE)result == 46 )\n    {\n      result = (_BYTE *)(i + a1);\n      *result = v2;\n      v2 = 0;\n    }\n    else\n    {\n      ++v2;\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl undot(char *rip_0)\n{\n  char s; // [rsp+10h] [rbp-8h]\n  int i; // [rsp+14h] [rbp-4h]\n  int ia; // [rsp+14h] [rbp-4h]\n\n  i = 0;\n  s = 0;\n  while ( rip_0[i] )\n    ++i;\n  for ( ia = i - 1; ia >= 0; --ia )\n  {\n    if ( rip_0[ia] == 46 )\n    {\n      rip_0[ia] = s;\n      s = 0;\n    }\n    else\n    {\n      ++s;\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.6700540781021118,
        "similarity_score_baseline_stripped": 0.5407038927078247,
        "similarity_score_baseline_debug": 0.6795222163200378
    },
    {
        "func_name": "uart_type",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_421FB0(const char *a1)\n{\n  return sub_421F51(\"unknown\", a1);\n}\n\n\n Revised code:\nstatic int uart_id(const char *name)\n{\n\treturn index_in_strings_case_insensitive(serial_types, name);\n}\n\n## Example:\n\n Input code:\nconst char *__fastcall sub_43094C(int a1)\n{\n  if ( a1 == -1 )\n    return \"error\";\n  else\n    return (const char *)(5 * a1 + 5342710LL);\n}\n\n\n Revised code:\nstatic const char *strstatus(int status)\n{\n\tif (status == IFSTATUS_ERR)\n\t\treturn \"error\";\n\treturn \"down\\0up\" + (status * 5);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_49574A(unsigned int a1)\n{\n  return printf(\"%c: unknown command\\n\", a1);\n}\n\n\n Revised code:\nif ENABLE_FEATURE_FDISK_WRITABLE\nstatic void\nunknown_command(int c)\n{\n\tprintf(\"%c: unknown command\\n\", c);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_421F28(int a1)\n{\n  if ( a1 <= 19 )\n    return (const char *)sub_4F676B(\"unknown\", (unsigned int)a1);\n  else\n    return \"undefined\";\n}\n",
        "output": "static const char *get_status(int a1)\n{\n\tif (a1 <= 19)\n\t\treturn (const char *)get_value(\"unknown\", (unsigned int)a1);\n\telse\n\t\treturn \"undefined\";\n}",
        "source_code": "static const char *uart_type(int type)\n{\n\tif (type > MAX_SERIAL_TYPE)\n\t\treturn \"undefined\";\n\n\treturn nth_string(serial_types, type);\n}",
        "parsed_output": "static const char *get_status(int a1)\n{\n\tif (a1 <= 19)\n\t\treturn (const char *)get_value(\"unknown\", (unsigned int)a1);\n\telse\n\t\treturn \"undefined\";\n}",
        "baseline_code_stripped": "const char *__fastcall sub_421F28(int a1)\n{\n  if ( a1 <= 19 )\n    return (const char *)sub_4F676B(\"unknown\", (unsigned int)a1);\n  else\n    return \"undefined\";\n}\n",
        "baseline_code_debug": "const char *__cdecl uart_type(int type)\n{\n  if ( type <= 19 )\n    return nth_string(serial_types, type);\n  else\n    return \"undefined\";\n}\n",
        "similarity_score_unixcoder": 0.6738603115081787,
        "similarity_score_baseline_stripped": 0.5015565156936646,
        "similarity_score_baseline_debug": 0.8662095069885254
    },
    {
        "func_name": "finalize_tty_attrs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E5BFF(__int64 a1, __int64 a2)\n{\n  _QWORD *v2; // rbx\n  _QWORD *v3; // rbx\n\n  qword_75D408 = sub_40A0E8(0xB8uLL, a2);\n  *((_DWORD *)qword_75D408 + 3) = 1024;\n  v2 = qword_75D408;\n  v2[3] = sub_40A05F(*((int *)qword_75D408 + 3), a2);\n  *((_QWORD *)qword_75D408 + 4) = *((_QWORD *)qword_75D408 + 3);\n  *((_QWORD *)qword_75D408 + 6) = (char *)qword_75D408 + 48;\n  *((_QWORD *)qword_75D408 + 7) = (char *)qword_75D408 + 48;\n  if ( *(_QWORD *)(a2 + 8) )\n  {\n    v3 = qword_75D408;\n    v3[5] = sub_40A11F(*(const char **)(a2 + 8), a2);\n    if ( !(unsigned int)sub_4E6EF4(*((_QWORD *)qword_75D408 + 5), 1LL) )\n      return 0LL;\n    if ( *((_DWORD *)qword_75D408 + 1) )\n      sub_4E7A44(1LL);\n    *((_BYTE *)qword_75D408 + 72) = 0;\n  }\n  sub_4E5D15();\n  return 0LL;\n}\n\n\n Revised code:\nint ed_main(int argc UNUSED_PARAM, char **argv)\n{\n\tINIT_G();\n\n\tbufSize = INITBUF_SIZE;\n\tbufBase = xmalloc(bufSize);\n\tbufPtr = bufBase;\n\tlines.next = &lines;\n\tlines.prev = &lines;\n\n\tif (argv[1]) {\n\t\tfileName = xstrdup(argv[1]);\n\t\tif (!readLines(fileName, 1)) {\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t\tif (lastNum)\n\t\t\tsetCurNum(1);\n\t\tdirty = FALSE;\n\t}\n\n\tdoCommands();\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B08F1(char *a1, unsigned int a2, int a3)\n{\n  unsigned int v5; // [rsp+14h] [rbp-Ch]\n  int v6; // [rsp+18h] [rbp-8h]\n  unsigned int v7; // [rsp+1Ch] [rbp-4h]\n\n  *((_BYTE *)qword_75D408 + *((unsigned int *)qword_75D408 + 1971) + 6852) = *((_BYTE *)qword_75D408 + 7888);\n  sub_4AF92B((__int64)qword_75D408 + 5120);\n  sub_4AF92B((__int64)qword_75D408 + 5160);\n  v6 = sub_4B01A5();\n  v7 = (unsigned int)(*((_DWORD *)qword_75D408 + 1973) + 10) >> 3;\n  v5 = (unsigned int)(*((_DWORD *)qword_75D408 + 1974) + 10) >> 3;\n  if ( v5 <= v7 )\n    v7 = (unsigned int)(*((_DWORD *)qword_75D408 + 1974) + 10) >> 3;\n  if ( v7 >= a2 + 4 && a1 )\n  {\n    sub_4AE836(a3, 3);\n    *((_DWORD *)qword_75D408 + 1975) = (*((_DWORD *)qword_75D408 + 1975) + 10) & 0xFFFFFFF8;\n    *((_DWORD *)qword_75D408 + 1975) += 8 * (a2 + 4);\n    sub_4AEA5F(a1, a2, 1);\n  }\n  else if ( v5 == v7 )\n  {\n    sub_4AE836(a3 + 2, 3);\n    sub_4B0650((__int64)qword_75D408 + 3692, (__int64)qword_75D408 + 4844);\n    *((_DWORD *)qword_75D408 + 1975) += *((_DWORD *)qword_75D408 + 1974) + 3;\n  }\n  else\n  {\n    sub_4AE836(a3 + 4, 3);\n    sub_4B027E(*((_DWORD *)qword_75D408 + 1289) + 1, *((_DWORD *)qword_75D408 + 1299) + 1, v6 + 1);\n    sub_4B0650((__int64)qword_75D408 + 1156, (__int64)qword_75D408 + 3448);\n    *((_DWORD *)qword_75D408 + 1975) += *((_DWORD *)qword_75D408 + 1973) + 3;\n  }\n  sub_4AF093();\n  if ( a3 )\n  {\n    sub_4AE9A0();\n    *((_DWORD *)qword_75D408 + 1975) += 7;\n  }\n  return *((_DWORD *)qword_75D408 + 1975) >> 3;\n}\n\n\n Revised code:\nstatic ulg flush_block(char *buf, ulg stored_len, int eof)\n{\n\tulg opt_lenb, static_lenb;      /* opt_len and static_len in bytes */\n\tint max_blindex;                /* index of last bit length code of non zero freq */\n\n\tG2.flag_buf[G2.last_flags] = G2.flags;   /* Save the flags for the last 8 items */\n\n\t/* Construct the literal and distance trees */\n\tbuild_tree(&G2.l_desc);\n\tTracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", G2.opt_len, G2.static_len));\n\n\tbuild_tree(&G2.d_desc);\n\tTracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", G2.opt_len, G2.static_len));\n\t/* At this point, opt_len and static_len are the total bit lengths of\n\t * the compressed block data, excluding the tree representations.\n\t */\n\n\t/* Build the bit length tree for the above two trees, and get the index\n\t * in bl_order of the last bit length code to send.\n\t */\n\tmax_blindex = build_bl_tree();\n\n\t/* Determine the best encoding. Compute first the block length in bytes */\n\topt_lenb = (G2.opt_len + 3 + 7) >> 3;\n\tstatic_lenb = (G2.static_len + 3 + 7) >> 3;\n\n\tTrace((stderr,\n\t\t\t\"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u \",\n\t\t\topt_lenb, G2.opt_len, static_lenb, G2.static_len, stored_len,\n\t\t\tG2.last_lit, G2.last_dist));\n\n\tif (static_lenb <= opt_lenb)\n\t\topt_lenb = static_lenb;\n\n\t/* If compression failed and this is the first and last block,\n\t * and if the zip file can be seeked (to rewrite the local header),\n\t * the whole file is transformed into a stored file:\n\t */\n\tif (stored_len <= opt_lenb && eof && G2.compressed_len == 0L && seekable()) {\n\t\t/* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */\n\t\tif (buf == NULL)\n\t\t\tbb_error_msg(\"block vanished\");\n\n\t\tcopy_block(buf, (unsigned) stored_len, 0);\t/* without header */\n\t\tG2.compressed_len = stored_len << 3;\n\n\t} else if (stored_len + 4 <= opt_lenb && buf != NULL) {\n\t\t/* 4: two words for the lengths */\n\t\t/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n\t\t * Otherwise we can't have processed more than WSIZE input bytes since\n\t\t * the last block flush, because compression would have been\n\t\t * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n\t\t * transform a block into a stored block.\n\t\t */\n\t\tsend_bits((STORED_BLOCK << 1) + eof, 3);\t/* send block type */\n\t\tG2.compressed_len = (G2.compressed_len + 3 + 7) & ~7L;\n\t\tG2.compressed_len += (stored_len + 4) << 3;\n\n\t\tcopy_block(buf, (unsigned) stored_len, 1);\t/* with header */\n\n\t} else if (static_lenb == opt_lenb) {\n\t\tsend_bits((STATIC_TREES << 1) + eof, 3);\n\t\tcompress_block((ct_data *) G2.static_ltree, (ct_data *) G2.static_dtree);\n\t\tG2.compressed_len += 3 + G2.static_len;\n\t} else {\n\t\tsend_bits((DYN_TREES << 1) + eof, 3);\n\t\tsend_all_trees(G2.l_desc.max_code + 1, G2.d_desc.max_code + 1,\n\t\t\t\t\tmax_blindex + 1);\n\t\tcompress_block((ct_data *) G2.dyn_ltree, (ct_data *) G2.dyn_dtree);\n\t\tG2.compressed_len += 3 + G2.opt_len;\n\t}\n\tAssert(G2.compressed_len == G1.bits_sent, \"bad compressed size\");\n\tinit_block();\n\n\tif (eof) {\n\t\tbi_windup();\n\t\tG2.compressed_len += 7;\t/* align on byte boundary */\n\t}\n\tTracev((stderr, \"\\ncomprlen %lu(%lu) \", G2.compressed_len >> 3,\n\t\t\tG2.compressed_len - 7 * eof));\n\n\treturn G2.compressed_len >> 3;\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_4B16C5(int a1)\n{\n  char v1; // di\n  __int64 v2; // rsi\n  unsigned int v3; // edx\n  __int64 v4; // rsi\n  unsigned int v5; // edx\n  __int16 v7; // [rsp+1Eh] [rbp-2h] BYREF\n\n  v7 = 0;\n  *((_DWORD *)qword_75D408 - 5) = 0;\n  sub_4AE754(559903);\n  sub_4AE754(a1);\n  *((_DWORD *)qword_75D408 - 2) = -1;\n  sub_4B11D5();\n  sub_4B138E();\n  sub_4B11FF(&v7);\n  v1 = v7;\n  v2 = *((_QWORD *)qword_75D408 - 6);\n  v3 = *((_DWORD *)qword_75D408 - 5);\n  *((_DWORD *)qword_75D408 - 5) = v3 + 1;\n  *(_BYTE *)(v2 + v3) = v1;\n  if ( *((_DWORD *)qword_75D408 - 5) == 0x2000 )\n    sub_4AE5D4();\n  v4 = *((_QWORD *)qword_75D408 - 6);\n  v5 = *((_DWORD *)qword_75D408 - 5);\n  *((_DWORD *)qword_75D408 - 5) = v5 + 1;\n  *(_BYTE *)(v4 + v5) = 3;\n  if ( *((_DWORD *)qword_75D408 - 5) == 0x2000 )\n    sub_4AE5D4();\n  sub_4B0B62();\n  sub_4AE754(~*((_DWORD *)qword_75D408 - 2));\n  sub_4AE754(*((_DWORD *)qword_75D408 - 6));\n  return sub_4AE5D4();\n}\n\n\n Revised code:\nstatic void zip(ulg time_stamp)\n{\n\tush deflate_flags = 0;  /* pkzip -es, -en or -ex equivalent */\n\n\tG1.outcnt = 0;\n\n\t/* Write the header to the gzip file. See algorithm.doc for the format */\n\t/* magic header for gzip files: 1F 8B */\n\t/* compression method: 8 (DEFLATED) */\n\t/* general flags: 0 */\n\tput_32bit(0x00088b1f);\n\tput_32bit(time_stamp);\n\n\t/* Write deflated file to zip file */\n\tG1.crc = ~0;\n\n\tbi_init();\n\tct_init();\n\tlm_init(&deflate_flags);\n\n\tput_8bit(deflate_flags);\t/* extra flags */\n\tput_8bit(3);\t/* OS identifier = 3 (Unix) */\n\n\tdeflate();\n\n\t/* Write the crc and uncompressed size */\n\tput_32bit(~G1.crc);\n\tput_32bit(G1.isize);\n\n\tflush_outbuf();\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40E5E6(__int64 a1, __int64 a2)\n{\n  int v2; // edx\n  int v3; // edx\n\n  v2 = *((_DWORD *)qword_75D408 + 24);\n  BYTE1(v2) |= 0x14u;\n  *((_DWORD *)qword_75D408 + 24) = v2;\n  if ( *((_BYTE *)qword_75D408 + 92) == 13 )\n  {\n    v3 = *((_DWORD *)qword_75D408 + 24);\n    BYTE1(v3) |= 1u;\n    *((_DWORD *)qword_75D408 + 24) = v3;\n  }\n  *((_DWORD *)qword_75D408 + 27) |= 0x83Bu;\n  *((_BYTE *)qword_75D408 + 113) = 3;\n  *((_BYTE *)qword_75D408 + 114) = 28;\n  *((_BYTE *)qword_75D408 + 117) = 4;\n  *((_BYTE *)qword_75D408 + 124) = 10;\n  *((_BYTE *)qword_75D408 + 120) = 0;\n  *((_BYTE *)qword_75D408 + 116) = 21;\n  sub_40E482(a1, a2);\n  return sub_40B38A(1u, (__int64)\"\\n\", 1LL);\n}\n",
        "output": "int process_data(int a1, int a2)\n{\n  int v2 = *((_DWORD *)qword_75D408 + 24);\n  BYTE1(v2) |= 0x14u;\n  *((_DWORD *)qword_75D408 + 24) = v2;\n  \n  if (*((_BYTE *)qword_75D408 + 92) == 13)\n  {\n    int v3 = *((_DWORD *)qword_75D408 + 24);\n    BYTE1(v3) |= 1u;\n    *((_DWORD *)qword_75D408 + 24) = v3;\n  }\n  \n  *((_DWORD *)qword_75D408 + 27) |= 0x83Bu;\n  *((_BYTE *)qword_75D408 + 113) = 3;\n  *((_BYTE *)qword_75D408 + 114) = 28;\n  *((_BYTE *)qword_75D408 + 117) = 4;\n  *((_BYTE *)qword_75D408 + 124) = 10;\n  *((_BYTE *)qword_75D408 + 120) = 0;\n  *((_BYTE *)qword_75D408 + 116) = 21;\n  \n  sub_40E482(a1, a2);\n  return sub_40B38A(1u, (__int64)\"\\n\", 1LL);\n}",
        "source_code": "static void finalize_tty_attrs(void)\n{\n\t/* software flow control on output (stop sending if XOFF is recvd);\n\t * and on input (send XOFF when buffer is full)\n\t */\n\tG.tty_attrs.c_iflag |= IXON | IXOFF;\n\tif (G.eol == '\\r') {\n\t\tG.tty_attrs.c_iflag |= ICRNL; /* map CR on input to NL */\n\t}\n\t/* Other bits in c_iflag:\n\t * IXANY   Any recvd char enables output (any char is also a XON)\n\t * INPCK   Enable parity check\n\t * IGNPAR  Ignore parity errors (drop bad bytes)\n\t * PARMRK  Mark parity errors with 0xff, 0x00 prefix\n\t *         (else bad byte is received as 0x00)\n\t * ISTRIP  Strip parity bit\n\t * IGNBRK  Ignore break condition\n\t * BRKINT  Send SIGINT on break - maybe set this?\n\t * INLCR   Map NL to CR\n\t * IGNCR   Ignore CR\n\t * ICRNL   Map CR to NL\n\t * IUCLC   Map uppercase to lowercase\n\t * IMAXBEL Echo BEL on input line too long\n\t * IUTF8   Appears to affect tty's idea of char widths,\n\t *         observed to improve backspacing through Unicode chars\n\t */\n\n\t/* line buffered input (NL or EOL or EOF chars end a line);\n\t * recognize INT/QUIT/SUSP chars;\n\t * echo input chars;\n\t * echo BS-SP-BS on erase character;\n\t * echo kill char specially, not as ^c (ECHOKE controls how exactly);\n\t * erase all input via BS-SP-BS on kill char (else go to next line)\n\t */\n\tG.tty_attrs.c_lflag |= ICANON | ISIG | ECHO | ECHOE | ECHOK | ECHOKE;\n\t/* Other bits in c_lflag:\n\t * XCASE   Map uppercase to \\lowercase [tried, doesn't work]\n\t * ECHONL  Echo NL even if ECHO is not set\n\t * ECHOCTL Echo ctrl chars as ^c (else don't echo) - maybe set this?\n\t * ECHOPRT On erase, echo erased chars\n\t *         [qwe<BS><BS><BS> input looks like \"qwe\\ewq/\" on screen]\n\t * NOFLSH  Don't flush input buffer after interrupt or quit chars\n\t * IEXTEN  Enable extended functions (??)\n\t *         [glibc says it enables c_cc[LNEXT] \"enter literal char\"\n\t *         and c_cc[VDISCARD] \"toggle discard buffered output\" chars]\n\t * FLUSHO  Output being flushed (c_cc[VDISCARD] is in effect)\n\t * PENDIN  Retype pending input at next read or input char\n\t *         (c_cc[VREPRINT] is being processed)\n\t * TOSTOP  Send SIGTTOU for background output\n\t *         (why \"stty sane\" unsets this bit?)\n\t */\n\n\tG.tty_attrs.c_cc[VINTR] = CTL('C');\n\tG.tty_attrs.c_cc[VQUIT] = CTL('\\\\');\n\tG.tty_attrs.c_cc[VEOF] = CTL('D');\n\tG.tty_attrs.c_cc[VEOL] = '\\n';\n#ifdef VSWTC\n\tG.tty_attrs.c_cc[VSWTC] = 0;\n#endif\n#ifdef VSWTCH\n\tG.tty_attrs.c_cc[VSWTCH] = 0;\n#endif\n\tG.tty_attrs.c_cc[VKILL] = CTL('U');\n\t/* Other control chars:\n\t * VEOL2\n\t * VERASE, VWERASE - (word) erase. we may set VERASE in get_logname\n\t * VREPRINT - reprint current input buffer\n\t * VLNEXT, VDISCARD, VSTATUS\n\t * VSUSP, VDSUSP - send (delayed) SIGTSTP\n\t * VSTART, VSTOP - chars used for IXON/IXOFF\n\t */\n\n\tset_tty_attrs();\n\n\t/* Now the newline character should be properly written */\n\tfull_write(STDOUT_FILENO, \"\\n\", 1);\n}",
        "parsed_output": "int process_data(int a1, int a2)\n{\n  int v2 = *((_DWORD *)qword_75D408 + 24);\n  BYTE1(v2) |= 0x14u;\n  *((_DWORD *)qword_75D408 + 24) = v2;\n  \n  if (*((_BYTE *)qword_75D408 + 92) == 13)\n  {\n    int v3 = *((_DWORD *)qword_75D408 + 24);\n    BYTE1(v3) |= 1u;\n    *((_DWORD *)qword_75D408 + 24) = v3;\n  }\n  \n  *((_DWORD *)qword_75D408 + 27) |= 0x83Bu;\n  *((_BYTE *)qword_75D408 + 113) = 3;\n  *((_BYTE *)qword_75D408 + 114) = 28;\n  *((_BYTE *)qword_75D408 + 117) = 4;\n  *((_BYTE *)qword_75D408 + 124) = 10;\n  *((_BYTE *)qword_75D408 + 120) = 0;\n  *((_BYTE *)qword_75D408 + 116) = 21;\n  \n  sub_40E482(a1, a2);\n  return sub_40B38A(1u, (__int64)\"\\n\", 1LL);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40E5E6(__int64 a1, __int64 a2)\n{\n  int v2; // edx\n  int v3; // edx\n\n  v2 = *((_DWORD *)qword_75D408 + 24);\n  BYTE1(v2) |= 0x14u;\n  *((_DWORD *)qword_75D408 + 24) = v2;\n  if ( *((_BYTE *)qword_75D408 + 92) == 13 )\n  {\n    v3 = *((_DWORD *)qword_75D408 + 24);\n    BYTE1(v3) |= 1u;\n    *((_DWORD *)qword_75D408 + 24) = v3;\n  }\n  *((_DWORD *)qword_75D408 + 27) |= 0x83Bu;\n  *((_BYTE *)qword_75D408 + 113) = 3;\n  *((_BYTE *)qword_75D408 + 114) = 28;\n  *((_BYTE *)qword_75D408 + 117) = 4;\n  *((_BYTE *)qword_75D408 + 124) = 10;\n  *((_BYTE *)qword_75D408 + 120) = 0;\n  *((_BYTE *)qword_75D408 + 116) = 21;\n  sub_40E482(a1, a2);\n  return sub_40B38A(1u, (__int64)\"\\n\", 1LL);\n}\n",
        "baseline_code_debug": "void __cdecl finalize_tty_attrs()\n{\n  tcflag_t c_iflag; // edx\n  tcflag_t v1; // edx\n\n  c_iflag = ptr_to_globals->tty_attrs.c_iflag;\n  BYTE1(c_iflag) |= 0x14u;\n  ptr_to_globals->tty_attrs.c_iflag = c_iflag;\n  if ( ptr_to_globals->eol == 13 )\n  {\n    v1 = ptr_to_globals->tty_attrs.c_iflag;\n    BYTE1(v1) |= 1u;\n    ptr_to_globals->tty_attrs.c_iflag = v1;\n  }\n  ptr_to_globals->tty_attrs.c_lflag |= 0x83Bu;\n  ptr_to_globals->tty_attrs.c_cc[0] = 3;\n  ptr_to_globals->tty_attrs.c_cc[1] = 28;\n  ptr_to_globals->tty_attrs.c_cc[4] = 4;\n  ptr_to_globals->tty_attrs.c_cc[11] = 10;\n  ptr_to_globals->tty_attrs.c_cc[7] = 0;\n  ptr_to_globals->tty_attrs.c_cc[3] = 21;\n  set_tty_attrs();\n  full_write(1, \"\\n\", 1uLL);\n}\n",
        "similarity_score_unixcoder": 0.39342835545539856,
        "similarity_score_baseline_stripped": 0.3966674208641052,
        "similarity_score_baseline_debug": 0.6933220624923706
    },
    {
        "func_name": "process_command_subs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B54AE(_QWORD *a1)\n{\n  __int64 v1; // rax\n  _QWORD *v3; // [rsp+8h] [rbp-28h] BYREF\n  __int64 v4; // [rsp+10h] [rbp-20h] BYREF\n  char *v5; // [rsp+18h] [rbp-18h]\n  char *v6; // [rsp+20h] [rbp-10h]\n  FILE *stream; // [rsp+28h] [rbp-8h]\n\n  v3 = a1;\n  v4 = 0LL;\n  while ( v3 )\n  {\n    v1 = sub_409067(&v3);\n    stream = (FILE *)sub_50A7F5(v1);\n    while ( 1 )\n    {\n      v6 = (char *)sub_4F9FF1(stream);\n      if ( !v6 )\n        break;\n      v5 = sub_408F79(v6, 47);\n      if ( v5 > v6 )\n        *v5 = 0;\n      sub_408FD2(&v4, (__int64)v6);\n    }\n    fclose(stream);\n  }\n  return v4;\n}\n\n\n Revised code:\nif ENABLE_FEATURE_TAR_FROM\nstatic llist_t *append_file_list_to_list(llist_t *list)\n{\n\tFILE *src_stream;\n\tchar *line;\n\tllist_t *newlist = NULL;\n\n\twhile (list) {\n\t\tsrc_stream = xfopen_stdin(llist_pop(&list));\n\t\twhile ((line = xmalloc_fgetline(src_stream)) != NULL) {\n\t\t\t/* kill trailing '/' unless the string is just \"/\" */\n\t\t\tchar *cp = last_char_is(line, '/');\n\t\t\tif (cp > line)\n\t\t\t\t*cp = '\\0';\n\t\t\tllist_add_to(&newlist, line);\n\t\t}\n\t\tfclose(src_stream);\n\t}\n\treturn newlist;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48A2BD(__int64 a1)\n{\n  int v2; // eax\n  char **v3; // [rsp+8h] [rbp-48h]\n  char v4[39]; // [rsp+10h] [rbp-40h] BYREF\n  char v5; // [rsp+37h] [rbp-19h]\n  FILE *stream; // [rsp+38h] [rbp-18h]\n  char *s; // [rsp+40h] [rbp-10h]\n  void *ptr; // [rsp+48h] [rbp-8h]\n\n  v3 = (char **)sub_48914D(a1);\n  s = *v3;\n  if ( !s )\n    return 2LL;\n  ptr = 0LL;\n  if ( !strchr(s, 47) )\n  {\n    ptr = sub_486617(s);\n    if ( ptr )\n      s = (char *)ptr;\n  }\n  stream = sub_4097EE(s, \"r\");\n  free(ptr);\n  if ( !stream )\n    return 1LL;\n  v2 = fileno(stream);\n  sub_409A2B(v2);\n  v5 = *((_BYTE *)qword_75D408 + 77);\n  *((_BYTE *)qword_75D408 + 77) = -1;\n  sub_480183((__int64)v4, v3);\n  sub_48600B((__int64)stream);\n  fclose(stream);\n  sub_480232((__int64)v4, v3);\n  *((_BYTE *)qword_75D408 + 77) = v5;\n  return *((unsigned __int8 *)qword_75D408 + 79);\n}\n\n\n Revised code:\nstatic int FAST_FUNC builtin_source(char **argv)\n{\n\tchar *arg_path, *filename;\n\tFILE *input;\n\tsave_arg_t sv;\n#if ENABLE_HUSH_FUNCTIONS\n\tsmallint sv_flg;\n#endif\n\n\targv = skip_dash_dash(argv);\n\tfilename = argv[0];\n\tif (!filename) {\n\t\t/* bash says: \"bash: .: filename argument required\" */\n\t\treturn 2; /* bash compat */\n\t}\n\targ_path = NULL;\n\tif (!strchr(filename, '/')) {\n\t\targ_path = find_in_path(filename);\n\t\tif (arg_path)\n\t\t\tfilename = arg_path;\n\t}\n\tinput = fopen_or_warn(filename, \"r\");\n\tfree(arg_path);\n\tif (!input) {\n\t\t/* bb_perror_msg(\"%s\", *argv); - done by fopen_or_warn */\n\t\treturn EXIT_FAILURE;\n\t}\n\tclose_on_exec_on(fileno(input));\n\n#if ENABLE_HUSH_FUNCTIONS\n\tsv_flg = G.flag_return_in_progress;\n\t/* \"we are inside sourced file, ok to use return\" */\n\tG.flag_return_in_progress = -1;\n#endif\n\tsave_and_replace_G_args(&sv, argv);\n\n\tparse_and_run_file(input);\n\tfclose(input);\n\n\trestore_G_args(&sv, argv);\n#if ENABLE_HUSH_FUNCTIONS\n\tG.flag_return_in_progress = sv_flg;\n#endif\n\n\treturn G.last_exitcode;\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_43328F(const char *a1, __int64 a2)\n{\n  size_t v2; // rax\n  char *v3; // rax\n  int v6; // [rsp+1Ch] [rbp-44h] BYREF\n  FILE *v7; // [rsp+20h] [rbp-40h] BYREF\n  FILE *stream; // [rsp+28h] [rbp-38h] BYREF\n  unsigned __int8 v9; // [rsp+37h] [rbp-29h]\n  char *s; // [rsp+38h] [rbp-28h]\n  __pid_t v11; // [rsp+44h] [rbp-1Ch]\n  char *v12; // [rsp+48h] [rbp-18h]\n  void *ptr; // [rsp+50h] [rbp-10h]\n  int i; // [rsp+5Ch] [rbp-4h]\n\n  ptr = sub_40A11F(a1, a2);\n  v11 = sub_43319A(&stream, &v7, *(_QWORD *)(a2 + 24), (__int64)a1);\n  for ( i = 0; i < *(_DWORD *)(a2 + 32); ++i )\n    fprintf(stream, \"%s\\n\", *(const char **)(8LL * i + *(_QWORD *)(a2 + 40)));\n  fclose(stream);\n  sub_409F48(v11, &v6, 0);\n  if ( (v6 & 0x7F) == 0 && !BYTE1(v6) )\n  {\n    s = (char *)sub_4F9FF1(v7);\n    if ( s )\n    {\n      v2 = strlen(s);\n      v12 = &s[v2 - 1];\n      while ( v12 >= s )\n      {\n        v9 = *v12 - 9;\n        if ( v9 != 23 && v9 > 4u )\n          break;\n        v3 = v12--;\n        *v3 = 0;\n      }\n      free(ptr);\n      ptr = s;\n    }\n  }\n  fclose(v7);\n  return ptr;\n}\n\n\n Revised code:\nstatic char *run_mapping(char *physical, struct mapping_defn_t *map)\n{\n\tFILE *in, *out;\n\tint i, status;\n\tpid_t pid;\n\n\tchar *logical = xstrdup(physical);\n\n\t/* Run the mapping script. Never fails. */\n\tpid = popen2(&in, &out, map->script, physical);\n\n\t/* Write mappings to stdin of mapping script. */\n\tfor (i = 0; i < map->n_mappings; i++) {\n\t\tfprintf(in, \"%s\\n\", map->mapping[i]);\n\t}\n\tfclose(in);\n\tsafe_waitpid(pid, &status, 0);\n\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t/* If the mapping script exited successfully, try to\n\t\t * grab a line of output and use that as the name of the\n\t\t * logical interface. */\n\t\tchar *new_logical = xmalloc_fgetline(out);\n\n\t\tif (new_logical) {\n\t\t\t/* If we are able to read a line of output from the script,\n\t\t\t * remove any trailing whitespace and use this value\n\t\t\t * as the name of the logical interface. */\n\t\t\tchar *pch = new_logical + strlen(new_logical) - 1;\n\n\t\t\twhile (pch >= new_logical && isspace(*pch))\n\t\t\t\t*(pch--) = '\\0';\n\n\t\t\tfree(logical);\n\t\t\tlogical = new_logical;\n\t\t}\n\t}\n\n\tfclose(out);\n\n\treturn logical;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_486168(__int64 a1, _BYTE *a2)\n{\n  int v3; // [rsp+18h] [rbp-48h] BYREF\n  __pid_t v4; // [rsp+1Ch] [rbp-44h] BYREF\n  _QWORD v5[5]; // [rsp+20h] [rbp-40h] BYREF\n  int v6; // [rsp+4Ch] [rbp-14h]\n  FILE *stream; // [rsp+50h] [rbp-10h]\n  int v8; // [rsp+5Ch] [rbp-4h]\n\n  stream = sub_48603E(a2, &v4);\n  sub_4812CC(v5, (__int64)stream);\n  v8 = 0;\n  while ( 1 )\n  {\n    v6 = ((__int64 (__fastcall *)(_QWORD *))v5[3])(v5);\n    if ( v6 == -1 )\n      break;\n    if ( v6 == 10 )\n    {\n      ++v8;\n    }\n    else\n    {\n      while ( v8 )\n      {\n        sub_481463(a1, 10);\n        --v8;\n      }\n      sub_48165D(a1, v6);\n    }\n  }\n  fclose(stream);\n  sub_409F48(v4, &v3, 0);\n  return BYTE1(v3);\n}\n",
        "output": "static int process_input(_BYTE *input, int *output)\n{\n  int newline_count = 0;\n  __pid_t pid;\n  _QWORD v5[5];\n  FILE *stream;\n\n  stream = open_file(input, &pid);\n  get_file_contents(v5, (__int64)stream);\n  *output = 0;\n  while (1)\n  {\n    int character = ((__int64 (__fastcall *)(_QWORD *))v5[3])(v5);\n    if (character == -1)\n      break;\n    if (character == 10)\n    {\n      ++newline_count;\n    }\n    else\n    {\n      while (newline_count)\n      {\n        add_character(output, 10);\n        --newline_count;\n      }\n      add_character(output, character);\n    }\n  }\n  close_file(stream);\n  get_process_status(pid, &status, 0);\n  return BYTE1(status);\n}",
        "source_code": "static int process_command_subs(o_string *dest, const char *s)\n{\n\tFILE *fp;\n\tstruct in_str pipe_str;\n\tpid_t pid;\n\tint status, ch, eol_cnt;\n\n\tfp = generate_stream_from_string(s, &pid);\n\n\t/* Now send results of command back into original context */\n\tsetup_file_in_str(&pipe_str, fp);\n\teol_cnt = 0;\n\twhile ((ch = i_getch(&pipe_str)) != EOF) {\n\t\tif (ch == '\\n') {\n\t\t\teol_cnt++;\n\t\t\tcontinue;\n\t\t}\n\t\twhile (eol_cnt) {\n\t\t\to_addchr(dest, '\\n');\n\t\t\teol_cnt--;\n\t\t}\n\t\to_addQchr(dest, ch);\n\t}\n\n\tdebug_printf(\"done reading from `cmd` pipe, closing it\\n\");\n\tfclose(fp);\n\t/* We need to extract exitcode. Test case\n\t * \"true; echo `sleep 1; false` $?\"\n\t * should print 1 */\n\tsafe_waitpid(pid, &status, 0);\n\tdebug_printf(\"child exited. returning its exitcode:%d\\n\", WEXITSTATUS(status));\n\treturn WEXITSTATUS(status);\n}",
        "parsed_output": "static int process_input(_BYTE *input, int *output)\n{\n  int newline_count = 0;\n  __pid_t pid;\n  _QWORD v5[5];\n  FILE *stream;\n\n  stream = open_file(input, &pid);\n  get_file_contents(v5, (__int64)stream);\n  *output = 0;\n  while (1)\n  {\n    int character = ((__int64 (__fastcall *)(_QWORD *))v5[3])(v5);\n    if (character == -1)\n      break;\n    if (character == 10)\n    {\n      ++newline_count;\n    }\n    else\n    {\n      while (newline_count)\n      {\n        add_character(output, 10);\n        --newline_count;\n      }\n      add_character(output, character);\n    }\n  }\n  close_file(stream);\n  get_process_status(pid, &status, 0);\n  return BYTE1(status);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_486168(__int64 a1, _BYTE *a2)\n{\n  int v3; // [rsp+18h] [rbp-48h] BYREF\n  __pid_t v4; // [rsp+1Ch] [rbp-44h] BYREF\n  _QWORD v5[5]; // [rsp+20h] [rbp-40h] BYREF\n  int v6; // [rsp+4Ch] [rbp-14h]\n  FILE *stream; // [rsp+50h] [rbp-10h]\n  int v8; // [rsp+5Ch] [rbp-4h]\n\n  stream = sub_48603E(a2, &v4);\n  sub_4812CC(v5, (__int64)stream);\n  v8 = 0;\n  while ( 1 )\n  {\n    v6 = ((__int64 (__fastcall *)(_QWORD *))v5[3])(v5);\n    if ( v6 == -1 )\n      break;\n    if ( v6 == 10 )\n    {\n      ++v8;\n    }\n    else\n    {\n      while ( v8 )\n      {\n        sub_481463(a1, 10);\n        --v8;\n      }\n      sub_48165D(a1, v6);\n    }\n  }\n  fclose(stream);\n  sub_409F48(v4, &v3, 0);\n  return BYTE1(v3);\n}\n",
        "baseline_code_debug": "int __cdecl process_command_subs(o_string_0 *dest, const char *s)\n{\n  int status; // [rsp+18h] [rbp-48h] BYREF\n  pid_t pid; // [rsp+1Ch] [rbp-44h] BYREF\n  in_str pipe_str; // [rsp+20h] [rbp-40h] BYREF\n  int ch_0; // [rsp+4Ch] [rbp-14h]\n  FILE *fp; // [rsp+50h] [rbp-10h]\n  int eol_cnt; // [rsp+5Ch] [rbp-4h]\n\n  fp = generate_stream_from_string(s, &pid);\n  setup_file_in_str(&pipe_str, fp);\n  eol_cnt = 0;\n  while ( 1 )\n  {\n    ch_0 = pipe_str.get(&pipe_str);\n    if ( ch_0 == -1 )\n      break;\n    if ( ch_0 == 10 )\n    {\n      ++eol_cnt;\n    }\n    else\n    {\n      while ( eol_cnt )\n      {\n        o_addchr(dest, 10);\n        --eol_cnt;\n      }\n      o_addQchr(dest, ch_0);\n    }\n  }\n  fclose(fp);\n  safe_waitpid(pid, &status, 0);\n  return BYTE1(status);\n}\n",
        "similarity_score_unixcoder": 0.6658247709274292,
        "similarity_score_baseline_stripped": 0.5693318247795105,
        "similarity_score_baseline_debug": 0.8272271156311035
    },
    {
        "func_name": "display_files",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4AFD56(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+10h] [rbp-1Ch]\n  int v4; // [rsp+14h] [rbp-18h]\n  int v5; // [rsp+18h] [rbp-14h]\n  int v6; // [rsp+1Ch] [rbp-10h]\n  int v7; // [rsp+20h] [rbp-Ch]\n  int v8; // [rsp+24h] [rbp-8h]\n  unsigned int i; // [rsp+28h] [rbp-4h]\n\n  v8 = -1;\n  v7 = *(unsigned __int16 *)(a1 + 2);\n  v6 = 0;\n  v5 = 7;\n  v4 = 4;\n  if ( !*(_WORD *)(a1 + 2) )\n  {\n    v5 = 138;\n    v4 = 3;\n  }\n  *(_WORD *)(4 * (a2 + 1LL) + a1 + 2) = -1;\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i > a2 )\n      break;\n    v3 = v7;\n    v7 = *(unsigned __int16 *)(4 * ((int)i + 1LL) + a1 + 2);\n    if ( ++v6 >= v5 || v3 != v7 )\n    {\n      if ( v6 >= v4 )\n      {\n        if ( v3 )\n        {\n          if ( v3 != v8 )\n            ++*((_WORD *)qword_75D408 + 2 * v3 + 2482);\n          ++*((_WORD *)qword_75D408 + 2514);\n        }\n        else if ( v6 > 10 )\n        {\n          ++*((_WORD *)qword_75D408 + 2518);\n        }\n        else\n        {\n          ++*((_WORD *)qword_75D408 + 2516);\n        }\n      }\n      else\n      {\n        *((_WORD *)qword_75D408 + 2 * v3 + 2482) += v6;\n      }\n      v6 = 0;\n      v8 = v3;\n      v5 = 7;\n      v4 = 4;\n      if ( v7 )\n      {\n        if ( v3 == v7 )\n        {\n          v5 = 6;\n          v4 = 3;\n        }\n      }\n      else\n      {\n        v5 = 138;\n        v4 = 3;\n      }\n    }\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void scan_tree(ct_data * tree, int max_code)\n{\n\tint n;\t\t\t\t/* iterates over all tree elements */\n\tint prevlen = -1;\t/* last emitted length */\n\tint curlen;\t\t\t/* length of current code */\n\tint nextlen = tree[0].Len;\t/* length of next code */\n\tint count = 0;\t\t/* repeat count of the current code */\n\tint max_count = 7;\t/* max repeat count */\n\tint min_count = 4;\t/* min repeat count */\n\n\tif (nextlen == 0) {\n\t\tmax_count = 138;\n\t\tmin_count = 3;\n\t}\n\ttree[max_code + 1].Len = 0xffff; /* guard */\n\n\tfor (n = 0; n <= max_code; n++) {\n\t\tcurlen = nextlen;\n\t\tnextlen = tree[n + 1].Len;\n\t\tif (++count < max_count && curlen == nextlen)\n\t\t\tcontinue;\n\n\t\tif (count < min_count) {\n\t\t\tG2.bl_tree[curlen].Freq += count;\n\t\t} else if (curlen != 0) {\n\t\t\tif (curlen != prevlen)\n\t\t\t\tG2.bl_tree[curlen].Freq++;\n\t\t\tG2.bl_tree[REP_3_6].Freq++;\n\t\t} else if (count <= 10) {\n\t\t\tG2.bl_tree[REPZ_3_10].Freq++;\n\t\t} else {\n\t\t\tG2.bl_tree[REPZ_11_138].Freq++;\n\t\t}\n\t\tcount = 0;\n\t\tprevlen = curlen;\n\n\t\tmax_count = 7;\n\t\tmin_count = 4;\n\t\tif (nextlen == 0) {\n\t\t\tmax_count = 138;\n\t\t\tmin_count = 3;\n\t\t} else if (curlen == nextlen) {\n\t\t\tmax_count = 6;\n\t\t\tmin_count = 3;\n\t\t}\n\t}\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_4F73F6(int *a1, __int64 a2)\n{\n  int v2; // eax\n  int v3; // eax\n  int v4; // eax\n  int v5; // eax\n  int *v6; // rax\n  int *v8; // [rsp+8h] [rbp-18h]\n  int v9; // [rsp+10h] [rbp-10h]\n  int j; // [rsp+14h] [rbp-Ch]\n  int i; // [rsp+18h] [rbp-8h]\n  int v12; // [rsp+1Ch] [rbp-4h]\n\n  v8 = a1;\n  if ( (_DWORD)a2 )\n    v2 = 79764919;\n  else\n    v2 = -306674912;\n  v9 = v2;\n  if ( !a1 )\n    v8 = (int *)sub_40A05F(0x400uLL, a2);\n  for ( i = 0; i <= 255; ++i )\n  {\n    if ( (_DWORD)a2 )\n      v3 = i << 24;\n    else\n      v3 = i;\n    v12 = v3;\n    for ( j = 8; j; --j )\n    {\n      if ( (_DWORD)a2 )\n      {\n        if ( v12 >= 0 )\n          v4 = 2 * v12;\n        else\n          v4 = v9 ^ (2 * v12);\n        v12 = v4;\n      }\n      else\n      {\n        if ( (v12 & 1) != 0 )\n          v5 = v9 ^ ((unsigned int)v12 >> 1);\n        else\n          v5 = (unsigned int)v12 >> 1;\n        v12 = v5;\n      }\n    }\n    v6 = v8++;\n    *v6 = v12;\n  }\n  return (char *)(v8 - 256);\n}\n\n\n Revised code:\nFAST_FUNC crc32_filltable(uint32_t *crc_table, int endian)\n{\n\tuint32_t polynomial = endian ? 0x04c11db7 : 0xedb88320;\n\tuint32_t c;\n\tint i, j;\n\n\tif (!crc_table)\n\t\tcrc_table = xmalloc(256 * sizeof(uint32_t));\n\n\tfor (i = 0; i < 256; i++) {\n\t\tc = endian ? (i << 24) : i;\n\t\tfor (j = 8; j; j--) {\n\t\t\tif (endian)\n\t\t\t\tc = (c&0x80000000) ? ((c << 1) ^ polynomial) : (c << 1);\n\t\t\telse\n\t\t\t\tc = (c&1) ? ((c >> 1) ^ polynomial) : (c >> 1);\n\t\t}\n\t\t*crc_table++ = c;\n\t}\n\n\treturn crc_table - 256;\n}\n\n## Example:\n\n Input code:\nvoid __fastcall __noreturn sub_4C61C0(__int64 a1, __int64 a2)\n{\n  int v2; // edx\n  int v3; // ecx\n  int v4; // r8d\n  int v5; // r9d\n  const char *v6; // rax\n  const char **v7; // [rsp+0h] [rbp-40h]\n  __int64 v8; // [rsp+10h] [rbp-30h]\n  int v9; // [rsp+18h] [rbp-28h]\n  int fd; // [rsp+1Ch] [rbp-24h]\n  __int64 v11; // [rsp+20h] [rbp-20h]\n  unsigned int v12; // [rsp+2Ch] [rbp-14h]\n  unsigned __int64 v13; // [rsp+30h] [rbp-10h]\n  unsigned int v14; // [rsp+3Ch] [rbp-4h]\n  unsigned int v15; // [rsp+3Ch] [rbp-4h]\n\n  v11 = sub_4F73F6(0LL, 1LL);\n  v12 = 0;\n  sub_4FA1EF(a2, (unsigned int)&unk_536AD1, v2, v3, v4, v5);\n  v7 = (const char **)(8LL * optind + a2);\n  while ( 1 )\n  {\n    if ( *v7 )\n      v6 = *v7;\n    else\n      v6 = \"standard input\";\n    fd = sub_50A825(v6);\n    if ( fd >= 0 )\n    {\n      v14 = 0;\n      v13 = 0LL;\n      while ( 1 )\n      {\n        v9 = sub_40B3FF(fd, &dest, 0x2001uLL);\n        if ( v9 <= 0 )\n          break;\n        v13 += v9;\n        v14 = sub_4F74CA(v14, &dest, (unsigned int)v9, v11);\n      }\n      close(fd);\n      v8 = v13;\n      while ( v13 )\n      {\n        v14 = (v14 << 8) ^ *(_DWORD *)(4LL * (unsigned __int8)(HIBYTE(v14) ^ v13) + v11);\n        v13 >>= 8;\n      }\n      v15 = ~v14;\n      if ( *v7 )\n        printf(\"%u %li %s\\n\", v15, v8, *v7);\n      else\n        printf(\"%u %li\\n\", v15, v8);\n    }\n    else\n    {\n      v12 = 1;\n    }\n    if ( *v7 )\n    {\n      if ( *++v7 )\n        continue;\n    }\n    sub_4F93C9(v12);\n  }\n}\n\n\n Revised code:\nint cksum_main(int argc UNUSED_PARAM, char **argv)\n{\n\tuint32_t *crc32_table = crc32_filltable(NULL, 1);\n\tuint32_t crc;\n\toff_t length, filesize;\n\tint bytes_read;\n\tint exit_code = EXIT_SUCCESS;\n\n#if ENABLE_DESKTOP\n\tgetopt32(argv, \"\"); /* coreutils 6.9 compat */\n\targv += optind;\n#else\n\targv++;\n#endif\n\n\tdo {\n\t\tint fd = open_or_warn_stdin(*argv ? *argv : bb_msg_standard_input);\n\n\t\tif (fd < 0) {\n\t\t\texit_code = EXIT_FAILURE;\n\t\t\tcontinue;\n\t\t}\n\t\tcrc = 0;\n\t\tlength = 0;\n\n#define read_buf bb_common_bufsiz1\n\t\twhile ((bytes_read = safe_read(fd, read_buf, sizeof(read_buf))) > 0) {\n\t\t\tlength += bytes_read;\n\t\t\tcrc = crc32_block_endian1(crc, read_buf, bytes_read, crc32_table);\n\t\t}\n\t\tclose(fd);\n\n\t\tfilesize = length;\n\n\t\twhile (length) {\n\t\t\tcrc = (crc << 8) ^ crc32_table[(uint8_t)(crc >> 24) ^ (uint8_t)length];\n\t\t\t/* must ensure that shift is unsigned! */\n\t\t\tif (sizeof(length) <= sizeof(unsigned))\n\t\t\t\tlength = (unsigned)length >> 8;\n\t\t\telse if (sizeof(length) <= sizeof(unsigned long))\n\t\t\t\tlength = (unsigned long)length >> 8;\n\t\t\telse\n\t\t\t\tlength = (unsigned long long)length >> 8;\n\t\t}\n\t\tcrc = ~crc;\n\n\t\tprintf((*argv ? \"%\"PRIu32\" %\"OFF_FMT\"i %s\\n\" : \"%\"PRIu32\" %\"OFF_FMT\"i\\n\"),\n\t\t\t\tcrc, filesize, *argv);\n\t} while (*argv && *++argv);\n\n\tfflush_stdout_and_exit(exit_code);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4CBC66(__int64 a1, unsigned int a2)\n{\n  int v2; // eax\n  __int64 result; // rax\n  unsigned int v4; // [rsp+1Ch] [rbp-24h]\n  unsigned int v5; // [rsp+20h] [rbp-20h]\n  int v6; // [rsp+24h] [rbp-1Ch]\n  int v7; // [rsp+24h] [rbp-1Ch]\n  int v8; // [rsp+28h] [rbp-18h]\n  tcflag_t k; // [rsp+2Ch] [rbp-14h]\n  unsigned int j; // [rsp+30h] [rbp-10h]\n  unsigned int v11; // [rsp+34h] [rbp-Ch]\n  tcflag_t v12; // [rsp+38h] [rbp-8h]\n  unsigned int i; // [rsp+3Ch] [rbp-4h]\n  unsigned int v14; // [rsp+3Ch] [rbp-4h]\n\n  v5 = 0;\n  if ( (dest.c_oflag & 0x100000) != 0 )\n  {\n    v12 = 1;\n  }\n  else\n  {\n    for ( i = 0; *(_QWORD *)(8LL * i + a1); ++i )\n    {\n      v4 = sub_4CB548(**(_QWORD **)(8LL * i + a1));\n      if ( v5 < v4 )\n        v5 = v4;\n    }\n    if ( (dest.c_oflag & 2) != 0 )\n      v2 = 5;\n    else\n      v2 = 0;\n    v5 += ((8 * (unsigned __int8)dest.c_oflag) & 8) + 1 + v2;\n    v12 = dest.c_cflag / v5;\n  }\n  if ( v12 <= 1 )\n  {\n    v11 = a2;\n    v12 = 1;\n  }\n  else\n  {\n    v11 = a2 / v12;\n    if ( a2 > v12 * (a2 / v12) )\n      ++v11;\n  }\n  v8 = 0;\n  v6 = 0;\n  for ( j = 0; ; ++j )\n  {\n    result = j;\n    if ( j >= v11 )\n      break;\n    for ( k = 0; k < v12; ++k )\n    {\n      if ( (dest.c_oflag & 0x40000) != 0 )\n        v14 = v12 * j + k;\n      else\n        v14 = v11 * k + j;\n      if ( v14 < a2 )\n      {\n        if ( v8 )\n        {\n          v7 = v6 - v8;\n          printf(\"%*s \", v7, (const char *)&unk_522D1B);\n          v8 += v7 + 1;\n        }\n        v6 = v8 + v5;\n        v8 += sub_4CB66F(*(_QWORD *)(8LL * v14 + a1));\n      }\n    }\n    putchar_unlocked(10);\n    v8 = 0;\n  }\n  return result;\n}\n",
        "output": "static void print_output(__int64 a1, unsigned int a2)\n{\n  unsigned int max_length = 0;\n  tcflag_t flag; \n  unsigned int num_rows; \n  unsigned int num_cols; \n  tcflag_t divisor; \n  unsigned int i; \n  unsigned int j; \n  unsigned int index; \n\n  if ((dest.c_oflag & 0x100000) != 0)\n  {\n    divisor = 1;\n  }\n  else\n  {\n    for (i = 0; *(_QWORD *)(8LL * i + a1); ++i)\n    {\n      unsigned int length = sub_4CB548(**(_QWORD **)(8LL * i + a1));\n      if (max_length < length)\n        max_length = length;\n    }\n    if ((dest.c_oflag & 2) != 0)\n      flag = 5;\n    else\n      flag = 0;\n    max_length += ((8 * (unsigned __int8)dest.c_oflag) & 8) + 1 + flag;\n    divisor = dest.c_cflag / max_length;\n  }\n  if (divisor <= 1)\n  {\n    num_rows = a2;\n    divisor = 1;\n  }\n  else\n  {\n    num_rows = a2 / divisor;\n    if (a2 > divisor * (a2 / divisor))\n      ++num_rows;\n  }\n  unsigned int current_length = 0;\n  unsigned int current_index = 0;\n  for (j = 0; ; ++j)\n  {\n    if (j >= num_rows)\n      break;\n    for (index = 0; index < divisor; ++index)\n    {\n      if ((dest.c_oflag & 0x40000) != 0)\n        current_index = divisor * j + index;\n      else\n        current_index = num_rows * index + j;\n      if (current_index < a2)\n      {\n        if (current_length)\n        {\n          unsigned int num_spaces = current_length - current_index;\n          printf(\"%*s \", num_spaces, (const char *)&unk_522D1B);\n          current_length += num_spaces + 1;\n        }\n        current_length = current_index + max_length;\n        current_length += sub_4CB66F(*(_QWORD *)(8LL * current_index + a1));\n      }\n    }\n    putchar_unlocked(10);\n    current_length = 0;\n  }\n}",
        "source_code": "static void display_files(struct dnode **dn, unsigned nfiles)\n{\n\tunsigned i, ncols, nrows, row, nc;\n\tunsigned column;\n\tunsigned nexttab;\n\tunsigned column_width = 0; /* used only by STYLE_COLUMNAR */\n\n\tif (G.all_fmt & STYLE_LONG) { /* STYLE_LONG or STYLE_SINGLE */\n\t\tncols = 1;\n\t} else {\n\t\t/* find the longest file name, use that as the column width */\n\t\tfor (i = 0; dn[i]; i++) {\n\t\t\tint len = calc_name_len(dn[i]->name);\n\t\t\tif (column_width < len)\n\t\t\t\tcolumn_width = len;\n\t\t}\n\t\tcolumn_width += 1 +\n\t\t\tIF_SELINUX( ((G.all_fmt & LIST_CONTEXT) ? 33 : 0) + )\n\t\t\t\t((G.all_fmt & LIST_INO) ? 8 : 0) +\n\t\t\t\t((G.all_fmt & LIST_BLOCKS) ? 5 : 0);\n\t\tncols = (unsigned)G_terminal_width / column_width;\n\t}\n\n\tif (ncols > 1) {\n\t\tnrows = nfiles / ncols;\n\t\tif (nrows * ncols < nfiles)\n\t\t\tnrows++;                /* round up fractionals */\n\t} else {\n\t\tnrows = nfiles;\n\t\tncols = 1;\n\t}\n\n\tcolumn = 0;\n\tnexttab = 0;\n\tfor (row = 0; row < nrows; row++) {\n\t\tfor (nc = 0; nc < ncols; nc++) {\n\t\t\t/* reach into the array based on the column and row */\n\t\t\tif (G.all_fmt & DISP_ROWS)\n\t\t\t\ti = (row * ncols) + nc;\t/* display across row */\n\t\t\telse\n\t\t\t\ti = (nc * nrows) + row;\t/* display by column */\n\t\t\tif (i < nfiles) {\n\t\t\t\tif (column > 0) {\n\t\t\t\t\tnexttab -= column;\n\t\t\t\t\tprintf(\"%*s \", nexttab, \"\");\n\t\t\t\t\tcolumn += nexttab + 1;\n\t\t\t\t}\n\t\t\t\tnexttab = column + column_width;\n\t\t\t\tcolumn += display_single(dn[i]);\n\t\t\t}\n\t\t}\n\t\tputchar('\\n');\n\t\tcolumn = 0;\n\t}\n}",
        "parsed_output": "static void print_output(__int64 a1, unsigned int a2)\n{\n  unsigned int max_length = 0;\n  tcflag_t flag; \n  unsigned int num_rows; \n  unsigned int num_cols; \n  tcflag_t divisor; \n  unsigned int i; \n  unsigned int j; \n  unsigned int index; \n\n  if ((dest.c_oflag & 0x100000) != 0)\n  {\n    divisor = 1;\n  }\n  else\n  {\n    for (i = 0; *(_QWORD *)(8LL * i + a1); ++i)\n    {\n      unsigned int length = sub_4CB548(**(_QWORD **)(8LL * i + a1));\n      if (max_length < length)\n        max_length = length;\n    }\n    if ((dest.c_oflag & 2) != 0)\n      flag = 5;\n    else\n      flag = 0;\n    max_length += ((8 * (unsigned __int8)dest.c_oflag) & 8) + 1 + flag;\n    divisor = dest.c_cflag / max_length;\n  }\n  if (divisor <= 1)\n  {\n    num_rows = a2;\n    divisor = 1;\n  }\n  else\n  {\n    num_rows = a2 / divisor;\n    if (a2 > divisor * (a2 / divisor))\n      ++num_rows;\n  }\n  unsigned int current_length = 0;\n  unsigned int current_index = 0;\n  for (j = 0; ; ++j)\n  {\n    if (j >= num_rows)\n      break;\n    for (index = 0; index < divisor; ++index)\n    {\n      if ((dest.c_oflag & 0x40000) != 0)\n        current_index = divisor * j + index;\n      else\n        current_index = num_rows * index + j;\n      if (current_index < a2)\n      {\n        if (current_length)\n        {\n          unsigned int num_spaces = current_length - current_index;\n          printf(\"%*s \", num_spaces, (const char *)&unk_522D1B);\n          current_length += num_spaces + 1;\n        }\n        current_length = current_index + max_length;\n        current_length += sub_4CB66F(*(_QWORD *)(8LL * current_index + a1));\n      }\n    }\n    putchar_unlocked(10);\n    current_length = 0;\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4CBC66(__int64 a1, unsigned int a2)\n{\n  int v2; // eax\n  __int64 result; // rax\n  unsigned int v4; // [rsp+1Ch] [rbp-24h]\n  unsigned int v5; // [rsp+20h] [rbp-20h]\n  int v6; // [rsp+24h] [rbp-1Ch]\n  int v7; // [rsp+24h] [rbp-1Ch]\n  int v8; // [rsp+28h] [rbp-18h]\n  tcflag_t k; // [rsp+2Ch] [rbp-14h]\n  unsigned int j; // [rsp+30h] [rbp-10h]\n  unsigned int v11; // [rsp+34h] [rbp-Ch]\n  tcflag_t v12; // [rsp+38h] [rbp-8h]\n  unsigned int i; // [rsp+3Ch] [rbp-4h]\n  unsigned int v14; // [rsp+3Ch] [rbp-4h]\n\n  v5 = 0;\n  if ( (dest.c_oflag & 0x100000) != 0 )\n  {\n    v12 = 1;\n  }\n  else\n  {\n    for ( i = 0; *(_QWORD *)(8LL * i + a1); ++i )\n    {\n      v4 = sub_4CB548(**(_QWORD **)(8LL * i + a1));\n      if ( v5 < v4 )\n        v5 = v4;\n    }\n    if ( (dest.c_oflag & 2) != 0 )\n      v2 = 5;\n    else\n      v2 = 0;\n    v5 += ((8 * (unsigned __int8)dest.c_oflag) & 8) + 1 + v2;\n    v12 = dest.c_cflag / v5;\n  }\n  if ( v12 <= 1 )\n  {\n    v11 = a2;\n    v12 = 1;\n  }\n  else\n  {\n    v11 = a2 / v12;\n    if ( a2 > v12 * (a2 / v12) )\n      ++v11;\n  }\n  v8 = 0;\n  v6 = 0;\n  for ( j = 0; ; ++j )\n  {\n    result = j;\n    if ( j >= v11 )\n      break;\n    for ( k = 0; k < v12; ++k )\n    {\n      if ( (dest.c_oflag & 0x40000) != 0 )\n        v14 = v12 * j + k;\n      else\n        v14 = v11 * k + j;\n      if ( v14 < a2 )\n      {\n        if ( v8 )\n        {\n          v7 = v6 - v8;\n          printf(\"%*s \", v7, (const char *)&unk_522D1B);\n          v8 += v7 + 1;\n        }\n        v6 = v8 + v5;\n        v8 += sub_4CB66F(*(_QWORD *)(8LL * v14 + a1));\n      }\n    }\n    putchar_unlocked(10);\n    v8 = 0;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl display_files(dnode **dn, unsigned int nfiles)\n{\n  int v2; // eax\n  unsigned int len; // [rsp+1Ch] [rbp-24h]\n  unsigned int column_width; // [rsp+20h] [rbp-20h]\n  unsigned int nexttab; // [rsp+24h] [rbp-1Ch]\n  unsigned int nexttaba; // [rsp+24h] [rbp-1Ch]\n  unsigned int column; // [rsp+28h] [rbp-18h]\n  unsigned int nc; // [rsp+2Ch] [rbp-14h]\n  unsigned int row; // [rsp+30h] [rbp-10h]\n  unsigned int nrows; // [rsp+34h] [rbp-Ch]\n  unsigned int ncols; // [rsp+38h] [rbp-8h]\n  unsigned int i; // [rsp+3Ch] [rbp-4h]\n  unsigned int ia; // [rsp+3Ch] [rbp-4h]\n\n  column_width = 0;\n  if ( (bb_common_bufsiz1.c_oflag & 0x100000) != 0 )\n  {\n    ncols = 1;\n  }\n  else\n  {\n    for ( i = 0; dn[i]; ++i )\n    {\n      len = calc_name_len(dn[i]->name);\n      if ( column_width < len )\n        column_width = len;\n    }\n    if ( (bb_common_bufsiz1.c_oflag & 2) != 0 )\n      v2 = 5;\n    else\n      v2 = 0;\n    column_width += ((8 * (unsigned __int8)bb_common_bufsiz1.c_oflag) & 8) + 1 + v2;\n    ncols = bb_common_bufsiz1.c_cflag / column_width;\n  }\n  if ( ncols <= 1 )\n  {\n    nrows = nfiles;\n    ncols = 1;\n  }\n  else\n  {\n    nrows = nfiles / ncols;\n    if ( nfiles > ncols * (nfiles / ncols) )\n      ++nrows;\n  }\n  column = 0;\n  nexttab = 0;\n  for ( row = 0; row < nrows; ++row )\n  {\n    for ( nc = 0; nc < ncols; ++nc )\n    {\n      if ( (bb_common_bufsiz1.c_oflag & 0x40000) != 0 )\n        ia = ncols * row + nc;\n      else\n        ia = nrows * nc + row;\n      if ( ia < nfiles )\n      {\n        if ( column )\n        {\n          nexttaba = nexttab - column;\n          printf(\"%*s \", nexttaba, (const char *)&unk_522D1B);\n          column += nexttaba + 1;\n        }\n        nexttab = column + column_width;\n        column += display_single(dn[ia]);\n      }\n    }\n    putchar_unlocked(10);\n    column = 0;\n  }\n}\n",
        "similarity_score_unixcoder": 0.7606500387191772,
        "similarity_score_baseline_stripped": 0.5198941230773926,
        "similarity_score_baseline_debug": 0.8243902921676636
    },
    {
        "func_name": "write_and_stats",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_4638F6(__int64 a1, __int64 a2)\n{\n  void *result; // rax\n  int v3; // [rsp+8h] [rbp-18h]\n  signed int i; // [rsp+Ch] [rbp-14h]\n\n  v3 = 0;\n  for ( i = 0; i < (signed int)dest.c_cflag; ++i )\n  {\n    *(_DWORD *)&dest.c_line |= *(_DWORD *)(32LL * i + *(_QWORD *)&dest.c_iflag + 24);\n    if ( **(_BYTE **)(32LL * i + *(_QWORD *)&dest.c_iflag + 8) )\n      dest.c_lflag = 1;\n    v3 += *(unsigned __int16 *)(32LL * i + *(_QWORD *)&dest.c_iflag) + 1;\n    if ( v3 - *(_DWORD *)&dest.c_cc[15] > 0 )\n    {\n      dest.c_cflag = i + 1;\n      break;\n    }\n  }\n  result = sub_40A05F(v3 + 1, a2);\n  *(_QWORD *)&dest.c_cc[7] = result;\n  return result;\n}\n\n\n Revised code:\nstatic void alloc_line_buffer(void)\n{\n\tint i;\n\tint width = 0;\n\tfor (i = 0; i < out_cnt; i++) {\n\t\tneed_flags |= out[i].ps_flags;\n\t\tif (out[i].header[0]) {\n\t\t\tprint_header = 1;\n\t\t}\n\t\twidth += out[i].width + 1; /* \"FIELD \" */\n\t\tif ((int)(width - terminal_width) > 0) {\n\t\t\t/* The rest does not fit on the screen */\n\t\t\t//out[i].width -= (width - terminal_width - 1);\n\t\t\tout_cnt = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n#if ENABLE_SELINUX\n\tif (!is_selinux_enabled())\n\t\tneed_flags &= ~PSSCAN_CONTEXT;\n#endif\n\tbuffer = xmalloc(width + 1); /* for trailing \\0 */\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_45B51E(_QWORD *a1)\n{\n  _QWORD *i; // [rsp+10h] [rbp-8h]\n\n  for ( i = *(_QWORD **)&dest.c_cflag; i; i = (_QWORD *)*i )\n  {\n    if ( i[2] == *a1 )\n    {\n      if ( (dword_75D450 & 1) != 0 )\n        return 1LL;\n      if ( i[1] == a1[1] )\n        return 1LL;\n    }\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic smallint search_dev_inode(const struct stat *st)\n{\n\tinode_list *ilist = G.inode_list_head;\n\n\twhile (ilist) {\n\t\tif (ilist->dev == st->st_dev) {\n\t\t\tif (option_mask32 & OPT_MOUNT)\n\t\t\t\treturn 1;\n\t\t\tif (ilist->inode == st->st_ino)\n\t\t\t\treturn 1;\n\t\t}\n\t\tilist = ilist->next;\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\nvoid **__fastcall sub_4C9EFF(const char *a1, void **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rcx\n  __int64 v7; // r8\n  __int64 v8; // r9\n  void **v10; // [rsp+0h] [rbp-10h]\n  void **v11; // [rsp+8h] [rbp-8h]\n\n  v11 = sub_4C9E6C(a1, a2, a3, a4, a5, a6);\n  while ( (unsigned int)sub_4C947A(\"|\") )\n  {\n    *(_QWORD *)&dest.c_iflag += 8LL;\n    v10 = sub_4C9E6C(\"|\", a2, *(__int64 *)&dest.c_iflag, v6, v7, v8);\n    if ( sub_4C934B((__int64)v11) )\n    {\n      sub_4C9315(v11);\n      v11 = v10;\n    }\n    else\n    {\n      sub_4C9315(v10);\n    }\n  }\n  return v11;\n}\n\n\n Revised code:\nstatic VALUE *eval(void)\n{\n\tVALUE *l, *r;\n\n\tl = eval1();\n\twhile (nextarg(\"|\")) {\n\t\tG.args++;\n\t\tr = eval1();\n\t\tif (null(l)) {\n\t\t\tfreev(l);\n\t\t\tl = r;\n\t\t} else\n\t\t\tfreev(r);\n\t}\n\treturn l;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4C760C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v6 = sub_4C75BC(a1, a2, a4);\n  if ( v6 < 0 )\n    return 1LL;\n  if ( v6 == a3 )\n  {\n    ++*(_QWORD *)&dest.c_iflag;\n  }\n  else if ( v6 )\n  {\n    ++*(_QWORD *)&dest.c_cflag;\n  }\n  *(_QWORD *)&dest.c_cc[15] += v6;\n  return 0LL;\n}\n",
        "output": "static int process_data(__int64 a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  int result; // rax\n\n  result = sub_4C75BC(a1, a2, a4);\n  if (result < 0)\n    return 1;\n  if (result == a3)\n  {\n    dest.c_iflag++;\n  }\n  else if (result)\n  {\n    dest.c_cflag++;\n  }\n  dest.c_cc[15] += result;\n  return 0;\n}",
        "source_code": "static bool write_and_stats(const void *buf, size_t len, size_t obs,\n\tconst char *filename)\n{\n\tssize_t n = full_write_or_warn(buf, len, filename);\n\tif (n < 0)\n\t\treturn 1;\n\tif ((size_t)n == obs)\n\t\tG.out_full++;\n\telse if (n) /* > 0 */\n\t\tG.out_part++;\n#if ENABLE_FEATURE_DD_THIRD_STATUS_LINE\n\tG.total_bytes += n;\n#endif\n\treturn 0;\n}",
        "parsed_output": "static int process_data(__int64 a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  int result; // rax\n\n  result = sub_4C75BC(a1, a2, a4);\n  if (result < 0)\n    return 1;\n  if (result == a3)\n  {\n    dest.c_iflag++;\n  }\n  else if (result)\n  {\n    dest.c_cflag++;\n  }\n  dest.c_cc[15] += result;\n  return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4C760C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v6 = sub_4C75BC(a1, a2, a4);\n  if ( v6 < 0 )\n    return 1LL;\n  if ( v6 == a3 )\n  {\n    ++*(_QWORD *)&dest.c_iflag;\n  }\n  else if ( v6 )\n  {\n    ++*(_QWORD *)&dest.c_cflag;\n  }\n  *(_QWORD *)&dest.c_cc[15] += v6;\n  return 0LL;\n}\n",
        "baseline_code_debug": "bool __cdecl write_and_stats(const void *buf, size_t len, size_t obs, const char *filename)\n{\n  __int64 n; // [rsp+28h] [rbp-8h]\n\n  n = full_write_or_warn(buf, len, filename);\n  if ( n < 0 )\n    return 1;\n  if ( n == obs )\n  {\n    ++*(_QWORD *)&bb_common_bufsiz1.c_iflag;\n  }\n  else if ( n )\n  {\n    ++*(_QWORD *)&bb_common_bufsiz1.c_cflag;\n  }\n  *(_QWORD *)&bb_common_bufsiz1.c_cc[15] += n;\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.5094164609909058,
        "similarity_score_baseline_stripped": 0.48002612590789795,
        "similarity_score_baseline_debug": 0.823329508304596
    },
    {
        "func_name": "read32",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nuint32_t sub_4B2988()\n{\n  uint32_t netlong; // [rsp+Ch] [rbp-4h] BYREF\n\n  sub_4B28A8((unsigned __int8 *)&netlong, 4);\n  return ntohl(netlong);\n}\n\n\n Revised code:\nstatic uint32_t f_read32(void)\n{\n\tuint32_t v;\n\tf_read(&v, 4);\n\treturn ntohl(v);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B2954(uint16_t a1)\n{\n  uint16_t v2; // [rsp+Ch] [rbp-4h] BYREF\n\n  v2 = htons(a1);\n  return sub_4B2868((unsigned __int8 *)&v2, 2);\n}\n\n\n Revised code:\nstatic void f_write16(uint16_t v)\n{\n\tv = htons(v);\n\tf_write(&v, 2);\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_4B2837(uint32_t a1)\n{\n  uint32_t hostlong; // [rsp+Ch] [rbp-4h] BYREF\n\n  hostlong = htonl(a1);\n  sub_40A4AB(1u, (__int64)&hostlong, 4LL);\n}\n\n\n Revised code:\nstatic void write32(uint32_t v)\n{\n\tv = htonl(v);\n\txwrite(1, &v, 4);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nuint32_t sub_4B280D()\n{\n  uint32_t netlong; // [rsp+Ch] [rbp-4h] BYREF\n\n  sub_507452(0LL, &netlong, 4LL);\n  return ntohl(netlong);\n}\n",
        "output": "static uint32_t read32(void)\n{\n\tuint32_t v;\n\tread(&v, 4);\n\treturn ntohl(v);\n}",
        "source_code": "static uint32_t read32(void)\n{\n\tuint32_t v;\n\txread(0, &v, 4);\n\treturn ntohl(v);\n}",
        "parsed_output": "static uint32_t read32(void)\n{\n\tuint32_t v;\n\tread(&v, 4);\n\treturn ntohl(v);\n}",
        "baseline_code_stripped": "uint32_t sub_4B280D()\n{\n  uint32_t netlong; // [rsp+Ch] [rbp-4h] BYREF\n\n  sub_507452(0LL, &netlong, 4LL);\n  return ntohl(netlong);\n}\n",
        "baseline_code_debug": "uint32_t __cdecl read32()\n{\n  uint32_t v; // [rsp+Ch] [rbp-4h] BYREF\n\n  xread(0, &v, 4uLL);\n  return ntohl(v);\n}\n",
        "similarity_score_unixcoder": 0.9701547622680664,
        "similarity_score_baseline_stripped": 0.585269570350647,
        "similarity_score_baseline_debug": 0.793999969959259
    },
    {
        "func_name": "change_user",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_40A8A7(const char *a1)\n{\n  int result; // eax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n\n  result = chdir(a1);\n  if ( result )\n    sub_4092A2((__int64)\"can't change directory to '%s'\", (__int64)a1, v2, v3, v4, v5);\n  return result;\n}\n\n\n Revised code:\nvoid FAST_FUNC xchdir(const char *path)\n{\n\tif (chdir(path))\n\t\tbb_perror_msg_and_die(\"can't change directory to '%s'\", path);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_489210(__int64 a1)\n{\n  const char *v1; // rax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  char *v7; // [rsp+10h] [rbp-10h]\n  char *path; // [rsp+18h] [rbp-8h]\n\n  path = *(char **)sub_48914D(a1);\n  if ( !path )\n  {\n    v7 = sub_4807EA(\"HOME\");\n    if ( v7 )\n      v1 = v7;\n    else\n      v1 = \"/\";\n    path = (char *)v1;\n  }\n  if ( chdir(path) )\n  {\n    sub_4091D9((__int64)\"cd: %s\", (__int64)path, v2, v3, v4, v5);\n    return 1LL;\n  }\n  else\n  {\n    sub_480BCB(0);\n    return 0LL;\n  }\n}\n\n\n Revised code:\nstatic int FAST_FUNC builtin_cd(char **argv)\n{\n\tconst char *newdir;\n\n\targv = skip_dash_dash(argv);\n\tnewdir = argv[0];\n\tif (newdir == NULL) {\n\t\t/* bash does nothing (exitcode 0) if HOME is \"\"; if it's unset,\n\t\t * bash says \"bash: cd: HOME not set\" and does nothing\n\t\t * (exitcode 1)\n\t\t */\n\t\tconst char *home = get_local_var_value(\"HOME\");\n\t\tnewdir = home ? home : \"/\";\n\t}\n\tif (chdir(newdir)) {\n\t\t/* Mimic bash message exactly */\n\t\tbb_perror_msg(\"cd: %s\", newdir);\n\t\treturn EXIT_FAILURE;\n\t}\n\t/* Read current dir (get_cwd(1) is inside) and set PWD.\n\t * Note: do not enforce exporting. If PWD was unset or unexported,\n\t * set it again, but do not export. bash does the same.\n\t */\n\tset_pwd_var(/*exp:*/ 0);\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_415BB6(__int64 a1, const char *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  int v7; // eax\n  ssize_t v8; // rax\n  char v9; // [rsp+17h] [rbp-9h] BYREF\n  __pid_t v10; // [rsp+18h] [rbp-8h]\n  __pid_t v11; // [rsp+1Ch] [rbp-4h]\n\n  v11 = vfork();\n  if ( v11 < 0 )\n    sub_4092A2((__int64)\"vfork\", (__int64)a2, v2, v3, v4, v5);\n  v10 = v11;\n  if ( !v11 )\n  {\n    sub_4F6569(a1);\n    v7 = sub_40A295(a2, 0);\n    v8 = sub_40B3FF(v7, &v9, 1uLL);\n    _exit(v8 < 0);\n  }\n  if ( (unsigned int)sub_409FAE(v10) )\n    return -1;\n  else\n    return open64(a2, 0);\n}\n\n\n Revised code:\nstatic int open_as_user(const struct passwd *pas, const char *file)\n{\n\tpid_t pid;\n\tchar c;\n\n\tpid = xvfork();\n\tif (pid) { /* PARENT */\n\t\tif (wait4pid(pid) == 0) {\n\t\t\t/* exitcode 0: child says it can read */\n\t\t\treturn open(file, O_RDONLY);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* CHILD */\n\t/* initgroups, setgid, setuid */\n\tchange_identity(pas);\n\t/* We just try to read one byte. If it works, file is readable\n\t * under this user. We signal that by exiting with 0. */\n\t_exit(safe_read(xopen(file, O_RDONLY), &c, 1) < 0);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_414F2F(__int64 a1)\n{\n  int result; // eax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n\n  sub_4F6569(a1);\n  result = chdir(*(const char **)(a1 + 32));\n  if ( result < 0 )\n  {\n    sub_414377(\"Ichdir(%s)\", *(_QWORD *)(a1 + 32), v2, v3, v4, v5);\n    result = chdir(\"/var/spool/cron\");\n    if ( result < 0 )\n      return sub_414377(byte_528D20, (__int64)\"/var/spool/cron\", v6, v7, v8, v9);\n  }\n  return result;\n}\n",
        "output": "void FAST_FUNC sub_414F2F(__int64 a1)\n{\n    sub_4F6569(a1);\n    const char* path = *(const char**)(a1 + 32);\n    if (chdir(path) < 0)\n    {\n        sub_414377(\"Ichdir(%s)\", path);\n        if (chdir(\"/var/spool/cron\") < 0)\n            sub_414377(byte_528D20, \"/var/spool/cron\");\n    }\n}",
        "source_code": "static void change_user(struct passwd *pas)\n{\n\t/* careful: we're after vfork! */\n\tchange_identity(pas); /* - initgroups, setgid, setuid */\n\tif (chdir(pas->pw_dir) < 0) {\n\t\tcrondlog(WARN9 \"chdir(%s)\", pas->pw_dir);\n\t\tif (chdir(TMPDIR) < 0) {\n\t\t\tcrondlog(DIE9 \"chdir(%s)\", TMPDIR); /* exits */\n\t\t}\n\t}\n}",
        "parsed_output": "void FAST_FUNC sub_414F2F(__int64 a1)\n{\n    sub_4F6569(a1);\n    const char* path = *(const char**)(a1 + 32);\n    if (chdir(path) < 0)\n    {\n        sub_414377(\"Ichdir(%s)\", path);\n        if (chdir(\"/var/spool/cron\") < 0)\n            sub_414377(byte_528D20, \"/var/spool/cron\");\n    }\n}",
        "baseline_code_stripped": "int __fastcall sub_414F2F(__int64 a1)\n{\n  int result; // eax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n\n  sub_4F6569(a1);\n  result = chdir(*(const char **)(a1 + 32));\n  if ( result < 0 )\n  {\n    sub_414377(\"Ichdir(%s)\", *(_QWORD *)(a1 + 32), v2, v3, v4, v5);\n    result = chdir(\"/var/spool/cron\");\n    if ( result < 0 )\n      return sub_414377(byte_528D20, (__int64)\"/var/spool/cron\", v6, v7, v8, v9);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl change_user(passwd *pas)\n{\n  change_identity(pas);\n  if ( chdir(pas->pw_dir) < 0 )\n  {\n    crondlog(\"Ichdir(%s)\", pas->pw_dir);\n    if ( chdir(\"/var/spool/cron\") < 0 )\n      crondlog(&byte_528D20, \"/var/spool/cron\");\n  }\n}\n",
        "similarity_score_unixcoder": 0.6306262016296387,
        "similarity_score_baseline_stripped": 0.5718674063682556,
        "similarity_score_baseline_debug": 0.8898484110832214
    },
    {
        "func_name": "print_perms",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_486EB5(__int64 a1, __int64 a2)\n{\n  char *v3; // rax\n  int v4; // [rsp+1Ch] [rbp-14h]\n  int v5; // [rsp+1Ch] [rbp-14h]\n  char *dest; // [rsp+20h] [rbp-10h]\n  const char **v7; // [rsp+28h] [rbp-8h]\n  const char **v8; // [rsp+28h] [rbp-8h]\n\n  if ( *(_QWORD *)(a1 + 32) )\n    return *(_QWORD *)(a1 + 32);\n  v7 = *(const char ***)(*(_QWORD *)(a1 + 40) + 32LL);\n  if ( v7 && *v7 )\n  {\n    v4 = 0;\n    do\n      v4 += strlen(*v7++) + 1;\n    while ( *v7 );\n    dest = (char *)sub_40A05F(v4, a2);\n    *(_QWORD *)(a1 + 32) = dest;\n    v8 = *(const char ***)(*(_QWORD *)(a1 + 40) + 32LL);\n    do\n    {\n      v5 = strlen(*v8);\n      memcpy(dest, *v8, v5);\n      v3 = &dest[v5];\n      dest = v3 + 1;\n      *v3 = 32;\n      ++v8;\n    }\n    while ( *v8 );\n    *v3 = 0;\n    return *(_QWORD *)(a1 + 32);\n  }\n  else\n  {\n    *(_QWORD *)(a1 + 32) = sub_40A0E8(1uLL, a2);\n    return *(_QWORD *)(a1 + 32);\n  }\n}\n\n\n Revised code:\nif ENABLE_HUSH_JOB\nstatic const char *get_cmdtext(struct pipe *pi)\n{\n\tchar **argv;\n\tchar *p;\n\tint len;\n\n\t/* This is subtle. ->cmdtext is created only on first backgrounding.\n\t * (Think \"cat, <ctrl-z>, fg, <ctrl-z>, fg, <ctrl-z>....\" here...)\n\t * On subsequent bg argv is trashed, but we won't use it */\n\tif (pi->cmdtext)\n\t\treturn pi->cmdtext;\n\targv = pi->cmds[0].argv;\n\tif (!argv || !argv[0]) {\n\t\tpi->cmdtext = xzalloc(1);\n\t\treturn pi->cmdtext;\n\t}\n\n\tlen = 0;\n\tdo {\n\t\tlen += strlen(*argv) + 1;\n\t} while (*++argv);\n\tp = xmalloc(len);\n\tpi->cmdtext = p;\n\targv = pi->cmds[0].argv;\n\tdo {\n\t\tlen = strlen(*argv);\n\t\tmemcpy(p, *argv, len);\n\t\tp += len;\n\t\t*p++ = ' ';\n\t} while (*++argv);\n\tp[-1] = '\\0';\n\treturn pi->cmdtext;\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_471AE1(FILE *a1, __int64 a2, char a3)\n{\n  int result; // eax\n  unsigned int v4; // eax\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 v7; // r8\n  __int64 v8; // r9\n  int v9; // eax\n  int v10; // eax\n  const char *v11; // rdi\n  unsigned int v12; // ecx\n  char v15[80]; // [rsp+20h] [rbp-70h] BYREF\n  unsigned int *v16; // [rsp+70h] [rbp-20h]\n  unsigned int v17; // [rsp+7Ch] [rbp-14h]\n  int v18; // [rsp+80h] [rbp-10h]\n  unsigned int v19; // [rsp+84h] [rbp-Ch]\n  unsigned int *v20; // [rsp+88h] [rbp-8h]\n\n  v20 = *(unsigned int **)(a2 + 16);\n  if ( (a3 & 1) != 0 )\n    return fprintf(a1, \"%d\\n\", *v20);\n  v4 = sub_470E5C(a2);\n  v19 = sub_46E1F9(v15, 0x10uLL, \"[%d]   \", v4, v5, v6);\n  v17 = v19;\n  if ( a2 == qword_75AFB0 )\n  {\n    v15[v19 - 3] = 43;\n  }\n  else if ( qword_75AFB0 && a2 == *(_QWORD *)(qword_75AFB0 + 32) )\n  {\n    v15[v19 - 3] = 45;\n  }\n  if ( (a3 & 2) != 0 )\n  {\n    v9 = sub_46E1F9(&v15[v19], 0x10uLL, \"%d \", *v20, v7, v8);\n    v19 += v9;\n  }\n  v16 = &v20[4 * *(unsigned __int16 *)(a2 + 28)];\n  if ( *(_BYTE *)(a2 + 30) )\n  {\n    v18 = *(v16 - 3);\n    if ( *(_BYTE *)(a2 + 30) == 1 )\n      v18 = *(_DWORD *)(a2 + 24);\n    v10 = sub_471762(&v15[v19], v18, 0, (__int64)&v15[v19], v7, v8);\n    v19 += v10;\n  }\n  else\n  {\n    *(_QWORD *)&v15[v19] = 0x676E696E6E7552LL;\n    v19 += 7;\n  }\n  while ( 1 )\n  {\n    if ( v20 == *(unsigned int **)(a2 + 16) )\n      v11 = (const char *)&unk_51CA3E;\n    else\n      v11 = \"| \";\n    v12 = 0;\n    if ( (int)(33 - v19) >= 0 )\n      v12 = 33 - v19;\n    fprintf(a1, \"%s%*c%s%s\", v15, v12, 32LL, v11, *((const char **)v20 + 1));\n    v20 += 4;\n    if ( v20 == v16 )\n      break;\n    v15[0] = 0;\n    v19 = 33;\n    if ( (a3 & 2) != 0 )\n      v19 = sub_46E1F9(v15, 0x30uLL, \"\\n%*c%d \", v17, 32LL, *v20) - 1;\n  }\n  sub_46E0F3(10, a1);\n  *(_BYTE *)(a2 + 31) &= ~0x10u;\n  result = *(unsigned __int8 *)(a2 + 30);\n  if ( (_BYTE)result == 2 )\n    return sub_47107C(a2);\n  return result;\n}\n\n\n Revised code:\nif JOBS\nstatic void\nshowjob(FILE *out, struct job *jp, int mode)\n{\n\tstruct procstat *ps;\n\tstruct procstat *psend;\n\tint col;\n\tint indent_col;\n\tchar s[80];\n\n\tps = jp->ps;\n\n\tif (mode & SHOW_ONLY_PGID) { /* jobs -p */\n\t\t/* just output process (group) id of pipeline */\n\t\tfprintf(out, \"%d\\n\", ps->ps_pid);\n\t\treturn;\n\t}\n\n\tcol = fmtstr(s, 16, \"[%d]   \", jobno(jp));\n\tindent_col = col;\n\n\tif (jp == curjob)\n\t\ts[col - 3] = '+';\n\telse if (curjob && jp == curjob->prev_job)\n\t\ts[col - 3] = '-';\n\n\tif (mode & SHOW_PIDS)\n\t\tcol += fmtstr(s + col, 16, \"%d \", ps->ps_pid);\n\n\tpsend = ps + jp->nprocs;\n\n\tif (jp->state == JOBRUNNING) {\n\t\tstrcpy(s + col, \"Running\");\n\t\tcol += sizeof(\"Running\") - 1;\n\t} else {\n\t\tint status = psend[-1].ps_status;\n\t\tif (jp->state == JOBSTOPPED)\n\t\t\tstatus = jp->stopstatus;\n\t\tcol += sprint_status(s + col, status, 0);\n\t}\n\t/* By now, \"[JOBID]*  [maybe PID] STATUS\" is printed */\n\n\t/* This loop either prints \"<cmd1> | <cmd2> | <cmd3>\" line\n\t * or prints several \"PID             | <cmdN>\" lines,\n\t * depending on SHOW_PIDS bit.\n\t * We do not print status of individual processes\n\t * between PID and <cmdN>. bash does it, but not very well:\n\t * first line shows overall job status, not process status,\n\t * making it impossible to know 1st process status.\n\t */\n\tgoto start;\n\tdo {\n\t\t/* for each process */\n\t\ts[0] = '\\0';\n\t\tcol = 33;\n\t\tif (mode & SHOW_PIDS)\n\t\t\tcol = fmtstr(s, 48, \"\\n%*c%d \", indent_col, ' ', ps->ps_pid) - 1;\n start:\n\t\tfprintf(out, \"%s%*c%s%s\",\n\t\t\t\ts,\n\t\t\t\t33 - col >= 0 ? 33 - col : 0, ' ',\n\t\t\t\tps == jp->ps ? \"\" : \"| \",\n\t\t\t\tps->ps_cmd\n\t\t);\n\t} while (++ps != psend);\n\toutcslow('\\n', out);\n\n\tjp->changed = 0;\n\n\tif (jp->state == JOBDONE) {\n\t\tTRACE((\"showjob: freeing job %d\\n\", jobno(jp)));\n\t\tfreejob(jp);\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48682E(const char *a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-18h]\n  char *v4; // [rsp+20h] [rbp-10h]\n  __int64 v5; // [rsp+28h] [rbp-8h]\n\n  v4 = sub_4867AC(a1);\n  v5 = *(_QWORD *)v4;\n  if ( *(_QWORD *)v4 )\n  {\n    v3 = *(_QWORD *)(v5 + 16);\n    if ( v3 )\n    {\n      **(_QWORD **)(v3 + 32) = *(_QWORD *)(v5 + 8);\n      *(_QWORD *)(v3 + 16) = *(_QWORD *)(v5 + 24);\n    }\n    else\n    {\n      free(*(void **)(v5 + 8));\n      if ( *(_QWORD *)(v5 + 24) )\n        sub_4821B8(*(__int64 **)(v5 + 24));\n    }\n  }\n  else\n  {\n    *(_QWORD *)v4 = sub_40A0E8(0x20uLL, a2);\n    v5 = *(_QWORD *)v4;\n  }\n  *(_QWORD *)(v5 + 8) = a1;\n  return v5;\n}\n\n\n Revised code:\nstatic struct function *new_function(char *name)\n{\n\tstruct function **funcpp = find_function_slot(name);\n\tstruct function *funcp = *funcpp;\n\n\tif (funcp != NULL) {\n\t\tstruct command *cmd = funcp->parent_cmd;\n\t\tdebug_printf_exec(\"func %p parent_cmd %p\\n\", funcp, cmd);\n\t\tif (!cmd) {\n\t\t\tdebug_printf_exec(\"freeing & replacing function '%s'\\n\", funcp->name);\n\t\t\tfree(funcp->name);\n\t\t\t/* Note: if !funcp->body, do not free body_as_string!\n\t\t\t * This is a special case of \"-F name body\" function:\n\t\t\t * body_as_string was not malloced! */\n\t\t\tif (funcp->body) {\n\t\t\t\tfree_pipe_list(funcp->body);\n# if !BB_MMU\n\t\t\t\tfree(funcp->body_as_string);\n# endif\n\t\t\t}\n\t\t} else {\n\t\t\tdebug_printf_exec(\"reinserting in tree & replacing function '%s'\\n\", funcp->name);\n\t\t\tcmd->argv[0] = funcp->name;\n\t\t\tcmd->group = funcp->body;\n# if !BB_MMU\n\t\t\tcmd->group_as_string = funcp->body_as_string;\n# endif\n\t\t}\n\t} else {\n\t\tdebug_printf_exec(\"remembering new function '%s'\\n\", name);\n\t\tfuncp = *funcpp = xzalloc(sizeof(*funcp));\n\t\t/*funcp->next = NULL;*/\n\t}\n\n\tfuncp->name = name;\n\treturn funcp;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_49AAC8(unsigned int a1, __int64 a2)\n{\n  __int64 v2; // rsi\n  __int64 v3; // rsi\n  __int64 v4; // rsi\n  const char **v7; // [rsp+10h] [rbp-10h]\n  const char **v8; // [rsp+10h] [rbp-10h]\n  const char **v9; // [rsp+18h] [rbp-8h]\n  const char **v10; // [rsp+18h] [rbp-8h]\n\n  printf(\"%-10d %-10o\", a1, *(_WORD *)(a2 + 20) & 0x1FF);\n  v9 = (const char **)sub_40C486(*(unsigned int *)(a2 + 12), a1);\n  if ( v9 )\n  {\n    v2 = (__int64)*v9;\n    printf(\" %-10s\", *v9);\n  }\n  else\n  {\n    v2 = *(unsigned int *)(a2 + 12);\n    printf(\" %-10d\", v2);\n  }\n  v7 = (const char **)sub_40C4D2(*(unsigned int *)(a2 + 16), v2);\n  if ( v7 )\n  {\n    v3 = (__int64)*v7;\n    printf(\" %-10s\", *v7);\n  }\n  else\n  {\n    v3 = *(unsigned int *)(a2 + 16);\n    printf(\" %-10d\", v3);\n  }\n  v10 = (const char **)sub_40C486(*(unsigned int *)(a2 + 4), v3);\n  if ( v10 )\n  {\n    v4 = (__int64)*v10;\n    printf(\" %-10s\", *v10);\n  }\n  else\n  {\n    v4 = *(unsigned int *)(a2 + 4);\n    printf(\" %-10d\", v4);\n  }\n  v8 = (const char **)sub_40C4D2(*(unsigned int *)(a2 + 8), v4);\n  if ( v8 )\n    return printf(\" %-10s\\n\", *v8);\n  else\n    return printf(\" %-10d\\n\", *(unsigned int *)(a2 + 8));\n}\n",
        "output": "if ENABLE_FEATURE_LS_TIMESTAMPS\nstatic void print_time(unsigned int t)\n{\n\ttime_t tt = t;\n\tstruct tm *ptm;\n\tchar buf[80];\n\n\tptm = localtime(&tt);\n\tstrftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", ptm);\n\tprintf(\"%s \", buf);\n}\n#endif\n\nint print_entry(unsigned int a1, __int64 a2)\n{\n\tunsigned int v2;\n\tunsigned int v3;\n\tunsigned int v4;\n\tconst char **v7;\n\tconst char **v8;\n\tconst char **v9;\n\tconst char **v10;\n\n\tprintf(\"%-10d %-10o\", a1, *(_WORD *)(a2 + 20) & 0x1FF);\n\n\tv9 = (const char **)sub_40C486(*(unsigned int *)(a2 + 12), a1);\n\tif (v9) {\n\t\tv2 = (__int64)*v9;\n\t\tprintf(\" %-10s\", *v9);\n\t} else {\n\t\tv2 = *(unsigned int *)(a2 + 12);\n\t\tprintf(\" %-10d\", v2);\n\t}\n\n\tv7 = (const char **)sub_40C4D2(*(unsigned int *)(a2 + 16), v2);\n\tif (v7) {\n\t\tv3 = (__int64)*v7;\n\t\tprintf(\" %-10s\", *v7);\n\t} else {\n\t\tv3 = *(unsigned int *)(a2 + 16);\n\t\tprintf(\" %-10d\", v3);\n\t}\n\n\tv10 = (const char **)sub_40C486(*(unsigned int *)(a2 + 4), v3);\n\tif (v10) {\n\t\tv4 = (__int64)*v10;\n\t\tprintf(\" %-10s\", *v10);\n\t} else {\n\t\tv4 = *(unsigned int *)(a2 + 4);\n\t\tprintf(\" %-10d\", v4);\n\t}\n\n\tv8 = (const char **)sub_40C4D2(*(unsigned int *)(a2 + 8), v4);\n\tif (v8)\n\t\treturn printf(\" %-10s\\n\", *v8);\n\telse\n\t\treturn printf(\" %-10d\\n\", *(unsigned int *)(a2 + 8));\n}",
        "source_code": "static void print_perms(int id, struct ipc_perm *ipcp)\n{\n\tstruct passwd *pw;\n\tstruct group *gr;\n\n\tprintf(\"%-10d %-10o\", id, ipcp->mode & 0777);\n\n\tpw = getpwuid(ipcp->cuid);\n\tif (pw)\tprintf(\" %-10s\", pw->pw_name);\n\telse\tprintf(\" %-10d\", ipcp->cuid);\n\tgr = getgrgid(ipcp->cgid);\n\tif (gr)\tprintf(\" %-10s\", gr->gr_name);\n\telse\tprintf(\" %-10d\", ipcp->cgid);\n\n\tpw = getpwuid(ipcp->uid);\n\tif (pw)\tprintf(\" %-10s\", pw->pw_name);\n\telse\tprintf(\" %-10d\", ipcp->uid);\n\tgr = getgrgid(ipcp->gid);\n\tif (gr)\tprintf(\" %-10s\\n\", gr->gr_name);\n\telse\tprintf(\" %-10d\\n\", ipcp->gid);\n}",
        "parsed_output": "if ENABLE_FEATURE_LS_TIMESTAMPS\nstatic void print_time(unsigned int t)\n{\n\ttime_t tt = t;\n\tstruct tm *ptm;\n\tchar buf[80];\n\n\tptm = localtime(&tt);\n\tstrftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", ptm);\n\tprintf(\"%s \", buf);\n}\n#endif\n\nint print_entry(unsigned int a1, __int64 a2)\n{\n\tunsigned int v2;\n\tunsigned int v3;\n\tunsigned int v4;\n\tconst char **v7;\n\tconst char **v8;\n\tconst char **v9;\n\tconst char **v10;\n\n\tprintf(\"%-10d %-10o\", a1, *(_WORD *)(a2 + 20) & 0x1FF);\n\n\tv9 = (const char **)sub_40C486(*(unsigned int *)(a2 + 12), a1);\n\tif (v9) {\n\t\tv2 = (__int64)*v9;\n\t\tprintf(\" %-10s\", *v9);\n\t} else {\n\t\tv2 = *(unsigned int *)(a2 + 12);\n\t\tprintf(\" %-10d\", v2);\n\t}\n\n\tv7 = (const char **)sub_40C4D2(*(unsigned int *)(a2 + 16), v2);\n\tif (v7) {\n\t\tv3 = (__int64)*v7;\n\t\tprintf(\" %-10s\", *v7);\n\t} else {\n\t\tv3 = *(unsigned int *)(a2 + 16);\n\t\tprintf(\" %-10d\", v3);\n\t}\n\n\tv10 = (const char **)sub_40C486(*(unsigned int *)(a2 + 4), v3);\n\tif (v10) {\n\t\tv4 = (__int64)*v10;\n\t\tprintf(\" %-10s\", *v10);\n\t} else {\n\t\tv4 = *(unsigned int *)(a2 + 4);\n\t\tprintf(\" %-10d\", v4);\n\t}\n\n\tv8 = (const char **)sub_40C4D2(*(unsigned int *)(a2 + 8), v4);\n\tif (v8)\n\t\treturn printf(\" %-10s\\n\", *v8);\n\telse\n\t\treturn printf(\" %-10d\\n\", *(unsigned int *)(a2 + 8));\n}",
        "baseline_code_stripped": "int __fastcall sub_49AAC8(unsigned int a1, __int64 a2)\n{\n  __int64 v2; // rsi\n  __int64 v3; // rsi\n  __int64 v4; // rsi\n  const char **v7; // [rsp+10h] [rbp-10h]\n  const char **v8; // [rsp+10h] [rbp-10h]\n  const char **v9; // [rsp+18h] [rbp-8h]\n  const char **v10; // [rsp+18h] [rbp-8h]\n\n  printf(\"%-10d %-10o\", a1, *(_WORD *)(a2 + 20) & 0x1FF);\n  v9 = (const char **)sub_40C486(*(unsigned int *)(a2 + 12), a1);\n  if ( v9 )\n  {\n    v2 = (__int64)*v9;\n    printf(\" %-10s\", *v9);\n  }\n  else\n  {\n    v2 = *(unsigned int *)(a2 + 12);\n    printf(\" %-10d\", v2);\n  }\n  v7 = (const char **)sub_40C4D2(*(unsigned int *)(a2 + 16), v2);\n  if ( v7 )\n  {\n    v3 = (__int64)*v7;\n    printf(\" %-10s\", *v7);\n  }\n  else\n  {\n    v3 = *(unsigned int *)(a2 + 16);\n    printf(\" %-10d\", v3);\n  }\n  v10 = (const char **)sub_40C486(*(unsigned int *)(a2 + 4), v3);\n  if ( v10 )\n  {\n    v4 = (__int64)*v10;\n    printf(\" %-10s\", *v10);\n  }\n  else\n  {\n    v4 = *(unsigned int *)(a2 + 4);\n    printf(\" %-10d\", v4);\n  }\n  v8 = (const char **)sub_40C4D2(*(unsigned int *)(a2 + 8), v4);\n  if ( v8 )\n    return printf(\" %-10s\\n\", *v8);\n  else\n    return printf(\" %-10d\\n\", *(unsigned int *)(a2 + 8));\n}\n",
        "baseline_code_debug": "void __cdecl print_perms(int id, ipc_perm *ipcp)\n{\n  group *gr; // [rsp+10h] [rbp-10h]\n  group *gra; // [rsp+10h] [rbp-10h]\n  passwd *pw; // [rsp+18h] [rbp-8h]\n  passwd *pwa; // [rsp+18h] [rbp-8h]\n\n  printf(\"%-10d %-10o\", (unsigned int)id, ipcp->mode & 0x1FF);\n  pw = bb_internal_getpwuid(ipcp->cuid);\n  if ( pw )\n    printf(\" %-10s\", pw->pw_name);\n  else\n    printf(\" %-10d\", ipcp->cuid);\n  gr = bb_internal_getgrgid(ipcp->cgid);\n  if ( gr )\n    printf(\" %-10s\", gr->gr_name);\n  else\n    printf(\" %-10d\", ipcp->cgid);\n  pwa = bb_internal_getpwuid(ipcp->uid);\n  if ( pwa )\n    printf(\" %-10s\", pwa->pw_name);\n  else\n    printf(\" %-10d\", ipcp->uid);\n  gra = bb_internal_getgrgid(ipcp->gid);\n  if ( gra )\n    printf(\" %-10s\\n\", gra->gr_name);\n  else\n    printf(\" %-10d\\n\", ipcp->gid);\n}\n",
        "similarity_score_unixcoder": 0.5418615341186523,
        "similarity_score_baseline_stripped": 0.4404148459434509,
        "similarity_score_baseline_debug": 0.9198364615440369
    },
    {
        "func_name": "xmkstemp",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40A2DB(const char *a1, int a2, unsigned int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v8; // [rsp+1Ch] [rbp-4h]\n\n  v8 = open64(a1, a2, a3);\n  if ( v8 < 0 )\n    sub_4091D9((__int64)\"can't open '%s'\", (__int64)a1, v3, v4, v5, v6);\n  return (unsigned int)v8;\n}\n\n\n Revised code:\nint FAST_FUNC open3_or_warn(const char *pathname, int flags, int mode)\n{\n\tint ret;\n\n\tret = open(pathname, flags, mode);\n\tif (ret < 0) {\n\t\tbb_perror_msg(\"can't open '%s'\", pathname);\n\t}\n\treturn ret;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40A246(const char *a1, int a2, unsigned int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v8; // [rsp+1Ch] [rbp-4h]\n\n  v8 = open64(a1, a2, a3);\n  if ( v8 < 0 )\n    sub_4092A2((__int64)\"can't open '%s'\", (__int64)a1, v3, v4, v5, v6);\n  return (unsigned int)v8;\n}\n\n\n Revised code:\nint FAST_FUNC xopen3(const char *pathname, int flags, int mode)\n{\n\tint ret;\n\n\tret = open(pathname, flags, mode);\n\tif (ret < 0) {\n\t\tbb_perror_msg_and_die(\"can't open '%s'\", pathname);\n\t}\n\treturn ret;\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_40A11F(const char *a1, __int64 a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // [rsp+18h] [rbp-8h]\n\n  if ( !a1 )\n    return 0LL;\n  v7 = strdup(a1);\n  if ( !v7 )\n    sub_40969E(\"out of memory\", a2, v3, v4, v5, v6);\n  return v7;\n}\n\n\n Revised code:\nFAST_FUNC xstrdup(const char *s)\n{\n\tchar *t;\n\n\tif (s == NULL)\n\t\treturn NULL;\n\n\tt = strdup(s);\n\n\tif (t == NULL)\n\t\tbb_error_msg_and_die(bb_msg_memory_exhausted);\n\n\treturn t;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40A5B9(char *a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  v6 = mkstemp64(a1);\n  if ( v6 < 0 )\n    sub_4092A2((__int64)\"can't create temp file '%s'\", (__int64)a1, v1, v2, v3, v4);\n  return (unsigned int)v6;\n}\n",
        "output": "int FAST_FUNC create_temp_file(char *filename)\n{\n\tint fd;\n\n\tfd = mkstemp(filename);\n\tif (fd < 0) {\n\t\tbb_perror_msg_and_die(\"can't create temp file '%s'\", filename);\n\t}\n\treturn fd;\n}",
        "source_code": "int FAST_FUNC xmkstemp(char *template)\n{\n\tint fd = mkstemp(template);\n\tif (fd < 0)\n\t\tbb_perror_msg_and_die(\"can't create temp file '%s'\", template);\n\treturn fd;\n}",
        "parsed_output": "int FAST_FUNC create_temp_file(char *filename)\n{\n\tint fd;\n\n\tfd = mkstemp(filename);\n\tif (fd < 0) {\n\t\tbb_perror_msg_and_die(\"can't create temp file '%s'\", filename);\n\t}\n\treturn fd;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40A5B9(char *a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  v6 = mkstemp64(a1);\n  if ( v6 < 0 )\n    sub_4092A2((__int64)\"can't create temp file '%s'\", (__int64)a1, v1, v2, v3, v4);\n  return (unsigned int)v6;\n}\n",
        "baseline_code_debug": "int __cdecl xmkstemp(char *a1)\n{\n  int fd; // [rsp+1Ch] [rbp-4h]\n\n  fd = mkstemp64(a1);\n  if ( fd < 0 )\n    bb_perror_msg_and_die(\"can't create temp file '%s'\", a1);\n  return fd;\n}\n",
        "similarity_score_unixcoder": 0.9046502709388733,
        "similarity_score_baseline_stripped": 0.6441338062286377,
        "similarity_score_baseline_debug": 0.7688182592391968
    },
    {
        "func_name": "print_flag",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_4633DC(char *a1, int a2, __int64 a3)\n{\n  int result; // eax\n\n  *a1 = 63;\n  a1[1] = 0;\n  result = *(_DWORD *)(a3 + 124);\n  if ( result )\n    return snprintf(a1, a2 + 1, \"%u,%u\", *(unsigned int *)(a3 + 124), *(unsigned int *)(a3 + 128));\n  return result;\n}\n\n\n Revised code:\nstatic void func_tty(char *buf, int size, const procps_status_t *ps)\n{\n\tbuf[0] = '?';\n\tbuf[1] = '\\0';\n\tif (ps->tty_major) /* tty field of \"0\" means \"no tty\" */\n\t\tsnprintf(buf, size+1, \"%u,%u\", ps->tty_major, ps->tty_minor);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_417BE4(int a1, const char *a2, __int64 a3)\n{\n  int result; // eax\n  int v4; // [rsp+8h] [rbp-18h]\n\n  v4 = a3;\n  if ( a1 )\n  {\n    printf(\" setting %s to %ld\", a2, a3);\n    return sub_417BBC(v4);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void print_flag_on_off(int get_arg, const char *s, unsigned long arg)\n{\n\tif (get_arg) {\n\t\tprintf(\" setting %s to %ld\", s, arg);\n\t\ton_off(arg);\n\t}\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_413241(int a1, int a2)\n{\n  int result; // eax\n\n  if ( *((_DWORD *)qword_75D408 + 15) != a1 || (result = a2, *((_DWORD *)qword_75D408 + 16) != a2) )\n  {\n    *((_DWORD *)qword_75D408 + 15) = a1;\n    *((_DWORD *)qword_75D408 + 16) = a2;\n    return printf(\"\\x1B[%u;%uH\", (unsigned int)(a2 + 1), (unsigned int)(a1 + 1));\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void gotoxy(int col, int line)\n{\n\tif (G.col != col || G.line != line) {\n\t\tG.col = col;\n\t\tG.line = line;\n\t\tprintf(ESC\"[%u;%uH\", line + 1, col + 1);\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_41A75D(int a1, const char *a2, __int64 a3)\n{\n  int result; // eax\n\n  if ( a1 )\n    return printf(\" setting %s to %ld\\n\", a2, a3);\n  return result;\n}\n",
        "output": "static void set_value(int flag, const char *name, unsigned long value)\n{\n\tif (flag) {\n\t\tprintf(\" setting %s to %ld\\n\", name, value);\n\t}\n}",
        "source_code": "static void print_flag(int flag, const char *s, unsigned long value)\n{\n\tif (flag)\n\t\tprintf(\" setting %s to %ld\\n\", s, value);\n}",
        "parsed_output": "static void set_value(int flag, const char *name, unsigned long value)\n{\n\tif (flag) {\n\t\tprintf(\" setting %s to %ld\\n\", name, value);\n\t}\n}",
        "baseline_code_stripped": "int __fastcall sub_41A75D(int a1, const char *a2, __int64 a3)\n{\n  int result; // eax\n\n  if ( a1 )\n    return printf(\" setting %s to %ld\\n\", a2, a3);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl print_flag(int flag, const char *s, unsigned __int64 value)\n{\n  if ( flag )\n    printf(\" setting %s to %ld\\n\", s, value);\n}\n",
        "similarity_score_unixcoder": 0.917944610118866,
        "similarity_score_baseline_stripped": 0.5765817165374756,
        "similarity_score_baseline_debug": 0.9371410608291626
    },
    {
        "func_name": "xzalloc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nssize_t __fastcall sub_40B4C5(int a1, char *a2, size_t a3)\n{\n  ssize_t v4; // [rsp+8h] [rbp-18h]\n\n  v4 = sub_40B446(a1, a2, a3);\n  close(a1);\n  return v4;\n}\n\n\n Revised code:\nssize_t FAST_FUNC read_close(int fd, void *buf, size_t size)\n{\n\t/*int e;*/\n\tsize = full_read(fd, buf, size);\n\t/*e = errno;*/\n\tclose(fd);\n\t/*errno = e;*/\n\treturn size;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4D9ED3(__int64 a1, __int64 a2, __int64 a3)\n{\n  void *ptr; // [rsp+28h] [rbp-8h]\n\n  ptr = (void *)sub_4F67A0(a1, a2 + 19);\n  if ( ptr )\n  {\n    sub_4D9F2F(ptr, a3);\n    free(ptr);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC chattr_dir_proc(const char *dir_name, struct dirent *de, void *gp)\n{\n\tchar *path = concat_subpath_file(dir_name, de->d_name);\n\t/* path is NULL if de->d_name is \".\" or \"..\", else... */\n\tif (path) {\n\t\tchange_attributes(path, gp);\n\t\tfree(path);\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4F63E5(unsigned int a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40C4D2(a1, a2);\n  if ( v3 )\n    return *(_QWORD *)v3;\n  else\n    return 0LL;\n}\n\n\n Revised code:\nFAST_FUNC gid2group(gid_t gid)\n{\n\tstruct group *gr = getgrgid(gid);\n\treturn (gr) ? gr->gr_name : NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_40A0E8(size_t a1, __int64 a2)\n{\n  void *s; // [rsp+18h] [rbp-8h]\n\n  s = sub_40A05F(a1, a2);\n  memset(s, 0, a1);\n  return s;\n}\n",
        "output": "void *allocate_and_initialize(size_t size, __int64 value)\n{\n  void *ptr; // [rsp+18h] [rbp-8h]\n\n  ptr = allocate_memory(size, value);\n  memset(ptr, 0, size);\n  return ptr;\n}",
        "source_code": "FAST_FUNC xzalloc(size_t size)\n{\n\tvoid *ptr = xmalloc(size);\n\tmemset(ptr, 0, size);\n\treturn ptr;\n}",
        "parsed_output": "void *allocate_and_initialize(size_t size, __int64 value)\n{\n  void *ptr; // [rsp+18h] [rbp-8h]\n\n  ptr = allocate_memory(size, value);\n  memset(ptr, 0, size);\n  return ptr;\n}",
        "baseline_code_stripped": "void *__fastcall sub_40A0E8(size_t a1, __int64 a2)\n{\n  void *s; // [rsp+18h] [rbp-8h]\n\n  s = sub_40A05F(a1, a2);\n  memset(s, 0, a1);\n  return s;\n}\n",
        "baseline_code_debug": "void *__cdecl xzalloc(size_t size)\n{\n  void *ptr; // [rsp+18h] [rbp-8h]\n\n  ptr = xmalloc(size);\n  memset(ptr, 0, size);\n  return ptr;\n}\n",
        "similarity_score_unixcoder": 0.6918089389801025,
        "similarity_score_baseline_stripped": 0.5535888075828552,
        "similarity_score_baseline_debug": 0.7735924124717712
    },
    {
        "func_name": "iamarray",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4D12FE(__int64 a1, __int64 a2)\n{\n  __int64 *i; // [rsp+8h] [rbp-8h]\n\n  for ( i = &qword_75B250; *i; i = (__int64 *)*i )\n    ;\n  *i = (__int64)sub_40A0E8(0x20uLL, a2);\n  return *i;\n}\n\n\n Revised code:\nstatic struct sort_key *add_key(void)\n{\n\tstruct sort_key **pkey = &key_list;\n\twhile (*pkey)\n\t\tpkey = &((*pkey)->next_key);\n\treturn *pkey = xzalloc(sizeof(struct sort_key));\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4FB084(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  size_t n_4; // [rsp+20h] [rbp-10h]\n  unsigned int v4; // [rsp+2Ch] [rbp-4h]\n\n  v4 = (*(_QWORD *)(a1 + 72) & 0x3F) + 1;\n  *(_BYTE *)(a1 + (*(_DWORD *)(a1 + 72) & 0x3F)) = 0x80;\n  while ( 1 )\n  {\n    memset((void *)(v4 + a1), 0, 64 - v4);\n    if ( 64 - v4 > 7 )\n    {\n      n_4 = 8LL * *(_QWORD *)(a1 + 72);\n      if ( a2 )\n        n_4 = sub_4FAF66(n_4);\n      *(_QWORD *)(a1 + 56) = n_4;\n    }\n    result = (*(__int64 (__fastcall **)(__int64))(a1 + 64))(a1);\n    if ( 64 - v4 > 7 )\n      break;\n    v4 = 0;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void FAST_FUNC common64_end(md5_ctx_t *ctx, int swap_needed)\n{\n\tunsigned bufpos = ctx->total64 & 63;\n\t/* Pad the buffer to the next 64-byte boundary with 0x80,0,0,0... */\n\tctx->wbuffer[bufpos++] = 0x80;\n\n\t/* This loop iterates either once or twice, no more, no less */\n\twhile (1) {\n\t\tunsigned remaining = 64 - bufpos;\n\t\tmemset(ctx->wbuffer + bufpos, 0, remaining);\n\t\t/* Do we have enough space for the length count? */\n\t\tif (remaining >= 8) {\n\t\t\t/* Store the 64-bit counter of bits in the buffer */\n\t\t\tuint64_t t = ctx->total64 << 3;\n\t\t\tif (swap_needed)\n\t\t\t\tt = bb_bswap_64(t);\n\t\t\t/* wbuffer is suitably aligned for this */\n\t\t\t*(uint64_t *) (&ctx->wbuffer[64 - 8]) = t;\n\t\t}\n\t\tctx->process_block(ctx);\n\t\tif (remaining >= 8)\n\t\t\tbreak;\n\t\tbufpos = 0;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E4DF8(__int64 a1, __int64 a2, __int64 a3)\n{\n  char **v3; // rbx\n  const char *i; // [rsp+28h] [rbp-18h]\n\n  for ( i = (const char *)(*(_QWORD *)a3 + a1); *i == 47; ++i )\n    ;\n  *(_QWORD *)(a3 + 16) = sub_50C0E1(*(_QWORD *)(a3 + 16), 2054LL, *(unsigned int *)(a3 + 12));\n  v3 = (char **)(*(_QWORD *)(a3 + 16) + 8LL * *(int *)(a3 + 12));\n  *v3 = sub_40A11F(i, 2054LL);\n  ++*(_DWORD *)(a3 + 12);\n  return 1LL;\n}\n\n\n Revised code:\nstatic void add_to_dirlist(const char *name, struct dir_list **list)\n{\n\tstruct dir_list *dp;\n\n\tdp = xmalloc(sizeof(struct dir_list));\n\tdp->name = blkid_strdup(name);\n\tdp->next = *list;\n\t*list = dp;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4DC779(__int64 a1, __int64 a2)\n{\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = a1; (*(_DWORD *)i & 0x2000) != 0; i = *(_QWORD *)(i + 24) )\n    ;\n  if ( (*(_DWORD *)i & 2) == 0 )\n  {\n    *(_DWORD *)i |= 2u;\n    *(_QWORD *)(i + 24) = sub_4DC126(a1, a2);\n  }\n  return *(_QWORD *)(i + 24);\n}\n",
        "output": "static __int64 find_and_execute(__int64 a1, __int64 a2)\n{\n  __int64 current = a1;\n\n  while ((*(_DWORD *)current & 0x2000) != 0)\n  {\n    current = *(_QWORD *)(current + 24);\n  }\n\n  if ((*(_DWORD *)current & 2) == 0)\n  {\n    *(_DWORD *)current |= 2u;\n    *(_QWORD *)(current + 24) = sub_4DC126(a1, a2);\n  }\n\n  return *(_QWORD *)(current + 24);\n}",
        "source_code": "static xhash *iamarray(var *v)\n{\n\tvar *a = v;\n\n\twhile (a->type & VF_CHILD)\n\t\ta = a->x.parent;\n\n\tif (!(a->type & VF_ARRAY)) {\n\t\ta->type |= VF_ARRAY;\n\t\ta->x.array = hash_init();\n\t}\n\treturn a->x.array;\n}",
        "parsed_output": "static __int64 find_and_execute(__int64 a1, __int64 a2)\n{\n  __int64 current = a1;\n\n  while ((*(_DWORD *)current & 0x2000) != 0)\n  {\n    current = *(_QWORD *)(current + 24);\n  }\n\n  if ((*(_DWORD *)current & 2) == 0)\n  {\n    *(_DWORD *)current |= 2u;\n    *(_QWORD *)(current + 24) = sub_4DC126(a1, a2);\n  }\n\n  return *(_QWORD *)(current + 24);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4DC779(__int64 a1, __int64 a2)\n{\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = a1; (*(_DWORD *)i & 0x2000) != 0; i = *(_QWORD *)(i + 24) )\n    ;\n  if ( (*(_DWORD *)i & 2) == 0 )\n  {\n    *(_DWORD *)i |= 2u;\n    *(_QWORD *)(i + 24) = sub_4DC126(a1, a2);\n  }\n  return *(_QWORD *)(i + 24);\n}\n",
        "baseline_code_debug": "xhash *__cdecl iamarray(var_0 *v)\n{\n  while ( (v->type & 0x2000) != 0 )\n    v = v->x.parent;\n  if ( (v->type & 2) == 0 )\n  {\n    v->type |= 2u;\n    v->x.array = hash_init();\n  }\n  return v->x.array;\n}\n",
        "similarity_score_unixcoder": 0.46785062551498413,
        "similarity_score_baseline_stripped": 0.4438897967338562,
        "similarity_score_baseline_debug": 0.806994616985321
    },
    {
        "func_name": "ip_parse_common_args",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4375C0(char *a1, _WORD *a2)\n{\n  char *v2; // rax\n  _BYTE *v4; // rax\n  char v6; // [rsp+1Fh] [rbp-11h]\n  unsigned int v7; // [rsp+20h] [rbp-10h]\n  unsigned int v8; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+24h] [rbp-Ch]\n  _WORD *v10; // [rsp+28h] [rbp-8h]\n\n  *a2 = 1;\n  v10 = a2 + 1;\n  for ( i = 0; *a1 && i <= 5; ++i )\n  {\n    v2 = a1++;\n    v7 = 16 * sub_437583(*v2);\n    if ( v7 > 0xFF )\n    {\n      *(_DWORD *)qword_75D400 = 22;\n      return 0xFFFFFFFFLL;\n    }\n    v6 = *a1;\n    if ( *a1 != 58 && v6 )\n    {\n      v8 = sub_437583(v6) | v7;\n      if ( v8 > 0xFF )\n      {\n        *(_DWORD *)qword_75D400 = 22;\n        return 0xFFFFFFFFLL;\n      }\n    }\n    else\n    {\n      v8 = v7 >> 4;\n    }\n    if ( v6 )\n      ++a1;\n    v4 = v10;\n    v10 = (_WORD *)((char *)v10 + 1);\n    *v4 = v8;\n    if ( *a1 == 58 )\n      ++a1;\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC ether_input(const char *bufp, struct sockaddr *sap)\n{\n\tunsigned char *ptr;\n\tchar c;\n\tint i;\n\tunsigned val;\n\n\tsap->sa_family = ether_hwtype.type;\n\tptr = (unsigned char*) sap->sa_data;\n\n\ti = 0;\n\twhile ((*bufp != '\\0') && (i < ETH_ALEN)) {\n\t\tval = hexchar2int(*bufp++) * 0x10;\n\t\tif (val > 0xff) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tc = *bufp;\n\t\tif (c == ':' || c == 0)\n\t\t\tval >>= 4;\n\t\telse {\n\t\t\tval |= hexchar2int(c);\n\t\t\tif (val > 0xff) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (c != 0)\n\t\t\tbufp++;\n\t\t*ptr++ = (unsigned char) val;\n\t\ti++;\n\n\t\t/* We might get a semicolon here - not required. */\n\t\tif (*bufp == ':') {\n\t\t\tbufp++;\n\t\t}\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 sub_47DB13()\n{\n  __int64 v1; // [rsp+8h] [rbp-18h]\n  _BYTE *v2; // [rsp+10h] [rbp-10h]\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n\n  while ( 1 )\n  {\n    v3 = sub_47D959();\n    if ( (byte_75B058 & 4) != 0 )\n    {\n      while ( v3 == 1 )\n      {\n        sub_47DCB7();\n        v3 = sub_47D959();\n      }\n    }\n    if ( v3 != 3 || byte_75B05B )\n      break;\n    if ( (byte_75B058 & 2) != 0 )\n    {\n      v2 = sub_4774FB(qword_75B068);\n      if ( v2 )\n      {\n        v3 = (v2 - (_BYTE *)&off_51D220) >> 3;\n        byte_75B05C = (v2 - (_BYTE *)&off_51D220) >> 3;\n        break;\n      }\n    }\n    if ( (byte_75B058 & 1) == 0 )\n      break;\n    v1 = sub_47061E(qword_75B068, 1);\n    if ( !v1 )\n      break;\n    if ( **(_BYTE **)(v1 + 16) )\n      sub_479F0F(*(_QWORD *)(v1 + 16), v1);\n  }\n  byte_75B058 = 0;\n  return v3;\n}\n\n\n Revised code:\nstatic int\nreadtoken(void)\n{\n\tint t;\n#if DEBUG\n\tsmallint alreadyseen = tokpushback;\n#endif\n\n#if ENABLE_ASH_ALIAS\n top:\n#endif\n\n\tt = xxreadtoken();\n\n\t/*\n\t * eat newlines\n\t */\n\tif (checkkwd & CHKNL) {\n\t\twhile (t == TNL) {\n\t\t\tparseheredoc();\n\t\t\tt = xxreadtoken();\n\t\t}\n\t}\n\n\tif (t != TWORD || quoteflag) {\n\t\tgoto out;\n\t}\n\n\t/*\n\t * check for keywords\n\t */\n\tif (checkkwd & CHKKWD) {\n\t\tconst char *const *pp;\n\n\t\tpp = findkwd(wordtext);\n\t\tif (pp) {\n\t\t\tlasttoken = t = pp - tokname_array;\n\t\t\tTRACE((\"keyword '%s' recognized\\n\", tokname_array[t] + 1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (checkkwd & CHKALIAS) {\n#if ENABLE_ASH_ALIAS\n\t\tstruct alias *ap;\n\t\tap = lookupalias(wordtext, 1);\n\t\tif (ap != NULL) {\n\t\t\tif (*ap->val) {\n\t\t\t\tpushstring(ap->val, ap);\n\t\t\t}\n\t\t\tgoto top;\n\t\t}\n#endif\n\t}\n out:\n\tcheckkwd = 0;\n#if DEBUG\n\tif (!alreadyseen)\n\t\tTRACE((\"token '%s' %s\\n\", tokname_array[t] + 1, t == TWORD ? wordtext : \"\"));\n\telse\n\t\tTRACE((\"reread token '%s' %s\\n\", tokname_array[t] + 1, t == TWORD ? wordtext : \"\"));\n#endif\n\treturn t;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4704BD(int a1, char a2)\n{\n  char *v3; // [rsp+10h] [rbp-10h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  if ( a1 == 256 )\n    return 11LL;\n  if ( a1 == 257 )\n  {\n    v4 = 0;\n  }\n  else\n  {\n    if ( (unsigned __int8)a1 > 0x80u && (unsigned __int8)a1 <= 0x88u )\n      return 12LL;\n    v3 = strchrnul(\"\\t\\n !\\\"$&'()*-/:;<=>?[\\\\]`|}~\", a1);\n    if ( !*v3 )\n      return 0LL;\n    v4 = (unsigned __int8)byte_51DEA8[v3 - \"\\t\\n !\\\"$&'()*-/:;<=>?[\\\\]`|}~\"];\n  }\n  return ((int)(unsigned __int16)word_51C830[v4] >> (4 * a2)) & 0xF;\n}\n\n\n Revised code:\nif USE_SIT_FUNCTION\n\nstatic int\nSIT(int c, int syntax)\n{\n\tstatic const char spec_symbls[] ALIGN1 = \"\\t\\n !\\\"$&'()*-/:;<=>?[\\\\]`|}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_QWORD *__fastcall sub_449AD5(_QWORD *a1)\n{\n  char v1; // al\n  _BYTE *v4; // [rsp+10h] [rbp-10h]\n  int v5; // [rsp+1Ch] [rbp-4h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  while ( *a1 && *(_BYTE *)*a1 == 45 )\n  {\n    v4 = (_BYTE *)(*a1 + 1LL);\n    if ( *v4 == 45 )\n    {\n      v4 = (_BYTE *)(*a1 + 2LL);\n      if ( !*v4 )\n      {\n        ++a1;\n        break;\n      }\n    }\n    v5 = sub_4F66C5(\"oneline\", v4);\n    if ( v5 < 0 )\n      sub_407F64();\n    if ( v5 )\n    {\n      if ( v5 == 1 )\n      {\n        if ( !*++a1 )\n          sub_407F64();\n        v6 = sub_4F6666(\"inet\", *a1);\n        if ( v6 < 0 )\n          sub_453293(*a1, \"protocol family\");\n      }\n      else\n      {\n        v6 = v5 - 2;\n      }\n      byte_75B2FC = byte_535E72[v6];\n      ++a1;\n    }\n    else\n    {\n      byte_75D466 = 1;\n      ++a1;\n    }\n  }\n  if ( byte_75D466 )\n    v1 = 92;\n  else\n    v1 = 10;\n  byte_75D465 = v1;\n  return a1;\n}\n",
        "output": "static _QWORD* sub_449AD5(_QWORD* a1)\n{\n    char v1;\n    _BYTE* v4;\n    int v5;\n    int v6;\n\n    while (*a1 && *(_BYTE*)*a1 == 45)\n    {\n        v4 = (_BYTE*)(*a1 + 1LL);\n        if (*v4 == 45)\n        {\n            v4 = (_BYTE*)(*a1 + 2LL);\n            if (!*v4)\n            {\n                ++a1;\n                break;\n            }\n        }\n        v5 = sub_4F66C5(\"oneline\", v4);\n        if (v5 < 0)\n            sub_407F64();\n        if (v5)\n        {\n            if (v5 == 1)\n            {\n                if (!*++a1)\n                    sub_407F64();\n                v6 = sub_4F6666(\"inet\", *a1);\n                if (v6 < 0)\n                    sub_453293(*a1, \"protocol family\");\n            }\n            else\n            {\n                v6 = v5 - 2;\n            }\n            byte_75B2FC = byte_535E72[v6];\n            ++a1;\n        }\n        else\n        {\n            byte_75D466 = 1;\n            ++a1;\n        }\n    }\n    if (byte_75D466)\n        v1 = 92;\n    else\n        v1 = 10;\n    byte_75D465 = v1;\n    return a1;\n}",
        "source_code": "FAST_FUNC ip_parse_common_args(char **argv)\n{\n\tstatic const char ip_common_commands[] ALIGN1 =\n\t\t\"oneline\" \"\\0\"\n\t\t\"family\" \"\\0\"\n\t\t\"4\" \"\\0\"\n\t\t\"6\" \"\\0\"\n\t\t\"0\" \"\\0\"\n\t\t;\n\tenum {\n\t\tARG_oneline,\n\t\tARG_family,\n\t\tARG_IPv4,\n\t\tARG_IPv6,\n\t\tARG_packet,\n\t};\n\tstatic const family_t af_numbers[] = { AF_INET, AF_INET6, AF_PACKET };\n\tint arg;\n\n\twhile (*argv) {\n\t\tchar *opt = *argv;\n\n\t\tif (opt[0] != '-')\n\t\t\tbreak;\n\t\topt++;\n\t\tif (opt[0] == '-') {\n\t\t\topt++;\n\t\t\tif (!opt[0]) { /* \"--\" */\n\t\t\t\targv++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\targ = index_in_substrings(ip_common_commands, opt);\n\t\tif (arg < 0)\n\t\t\tbb_show_usage();\n\t\tif (arg == ARG_oneline) {\n\t\t\toneline = 1;\n\t\t\targv++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (arg == ARG_family) {\n\t\t\tstatic const char families[] ALIGN1 =\n\t\t\t\t\"inet\" \"\\0\" \"inet6\" \"\\0\" \"link\" \"\\0\";\n\t\t\targv++;\n\t\t\tif (!*argv)\n\t\t\t\tbb_show_usage();\n\t\t\targ = index_in_strings(families, *argv);\n\t\t\tif (arg < 0)\n\t\t\t\tinvarg(*argv, \"protocol family\");\n\t\t\t/* now arg == 0, 1 or 2 */\n\t\t} else {\n\t\t\targ -= ARG_IPv4;\n\t\t\t/* now arg == 0, 1 or 2 */\n\t\t}\n\t\tpreferred_family = af_numbers[arg];\n\t\targv++;\n\t}\n\t_SL_ = oneline ? '\\\\' : '\\n';\n\treturn argv;\n}",
        "parsed_output": "static _QWORD* sub_449AD5(_QWORD* a1)\n{\n    char v1;\n    _BYTE* v4;\n    int v5;\n    int v6;\n\n    while (*a1 && *(_BYTE*)*a1 == 45)\n    {\n        v4 = (_BYTE*)(*a1 + 1LL);\n        if (*v4 == 45)\n        {\n            v4 = (_BYTE*)(*a1 + 2LL);\n            if (!*v4)\n            {\n                ++a1;\n                break;\n            }\n        }\n        v5 = sub_4F66C5(\"oneline\", v4);\n        if (v5 < 0)\n            sub_407F64();\n        if (v5)\n        {\n            if (v5 == 1)\n            {\n                if (!*++a1)\n                    sub_407F64();\n                v6 = sub_4F6666(\"inet\", *a1);\n                if (v6 < 0)\n                    sub_453293(*a1, \"protocol family\");\n            }\n            else\n            {\n                v6 = v5 - 2;\n            }\n            byte_75B2FC = byte_535E72[v6];\n            ++a1;\n        }\n        else\n        {\n            byte_75D466 = 1;\n            ++a1;\n        }\n    }\n    if (byte_75D466)\n        v1 = 92;\n    else\n        v1 = 10;\n    byte_75D465 = v1;\n    return a1;\n}",
        "baseline_code_stripped": "_QWORD *__fastcall sub_449AD5(_QWORD *a1)\n{\n  char v1; // al\n  _BYTE *v4; // [rsp+10h] [rbp-10h]\n  int v5; // [rsp+1Ch] [rbp-4h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  while ( *a1 && *(_BYTE *)*a1 == 45 )\n  {\n    v4 = (_BYTE *)(*a1 + 1LL);\n    if ( *v4 == 45 )\n    {\n      v4 = (_BYTE *)(*a1 + 2LL);\n      if ( !*v4 )\n      {\n        ++a1;\n        break;\n      }\n    }\n    v5 = sub_4F66C5(\"oneline\", v4);\n    if ( v5 < 0 )\n      sub_407F64();\n    if ( v5 )\n    {\n      if ( v5 == 1 )\n      {\n        if ( !*++a1 )\n          sub_407F64();\n        v6 = sub_4F6666(\"inet\", *a1);\n        if ( v6 < 0 )\n          sub_453293(*a1, \"protocol family\");\n      }\n      else\n      {\n        v6 = v5 - 2;\n      }\n      byte_75B2FC = byte_535E72[v6];\n      ++a1;\n    }\n    else\n    {\n      byte_75D466 = 1;\n      ++a1;\n    }\n  }\n  if ( byte_75D466 )\n    v1 = 92;\n  else\n    v1 = 10;\n  byte_75D465 = v1;\n  return a1;\n}\n",
        "baseline_code_debug": "char **__cdecl ip_parse_common_args(char **argv)\n{\n  char v1; // al\n  char *opt; // [rsp+10h] [rbp-10h]\n  int arg; // [rsp+1Ch] [rbp-4h]\n  int arga; // [rsp+1Ch] [rbp-4h]\n\n  while ( *argv && **argv == 45 )\n  {\n    opt = *argv + 1;\n    if ( *opt == 45 )\n    {\n      opt = *argv + 2;\n      if ( !*opt )\n      {\n        ++argv;\n        break;\n      }\n    }\n    arg = index_in_substrings(ip_common_commands_9388, opt);\n    if ( arg < 0 )\n      bb_show_usage();\n    if ( arg )\n    {\n      if ( arg == 1 )\n      {\n        if ( !*++argv )\n          bb_show_usage();\n        arga = index_in_strings(families_9400, *argv);\n        if ( arga < 0 )\n          invarg(*argv, \"protocol family\");\n      }\n      else\n      {\n        arga = arg - 2;\n      }\n      preferred_family = af_numbers_9395[arga];\n      ++argv;\n    }\n    else\n    {\n      oneline = 1;\n      ++argv;\n    }\n  }\n  if ( oneline )\n    v1 = 92;\n  else\n    v1 = 10;\n  SL_ = v1;\n  return argv;\n}\n",
        "similarity_score_unixcoder": 0.6547891497612,
        "similarity_score_baseline_stripped": 0.6258670091629028,
        "similarity_score_baseline_debug": 0.8772838115692139
    },
    {
        "func_name": "o_addstr",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_481571(__int64 a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  return sub_4814C5(a1, a2, v2 + 1);\n}\n\n\n Revised code:\nendif\n\nstatic void o_addstr_with_NUL(o_string *o, const char *str)\n{\n\to_addblock(o, str, strlen(str) + 1);\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_48187C(__int64 a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  return sub_48182B(a1, a2, v2);\n}\n\n\n Revised code:\nstatic void o_addQstr(o_string *o, const char *str)\n{\n\to_addQblock(o, str, strlen(str));\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_480D48(const char *a1)\n{\n  int v1; // eax\n\n  v1 = strlen(a1);\n  return sub_480C0A(a1, v1);\n}\n\n\n Revised code:\nstatic int unset_local_var(const char *name)\n{\n\treturn unset_local_var_len(name, strlen(name));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_48153D(__int64 a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  return sub_4814C5(a1, a2, v2);\n}\n",
        "output": "static void o_addstr(o_string *o, const char *str)\n{\n\to_addblock(o, str, strlen(str));\n}",
        "source_code": "static void o_addstr(o_string *o, const char *str)\n{\n\to_addblock(o, str, strlen(str));\n}",
        "parsed_output": "static void o_addstr(o_string *o, const char *str)\n{\n\to_addblock(o, str, strlen(str));\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_48153D(__int64 a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  return sub_4814C5(a1, a2, v2);\n}\n",
        "baseline_code_debug": "void __cdecl o_addstr(o_string_0 *o, const char *str)\n{\n  int v2; // edx\n\n  v2 = strlen(str);\n  o_addblock(o, str, v2);\n}\n",
        "similarity_score_unixcoder": 1.0000001192092896,
        "similarity_score_baseline_stripped": 0.4697158932685852,
        "similarity_score_baseline_debug": 0.8722692131996155
    },
    {
        "func_name": "file_write",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B4FB0(const char *a1, __int64 a2, __int64 a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 v8; // rdx\n  size_t n; // [rsp+20h] [rbp-20h]\n  const char *v10; // [rsp+28h] [rbp-18h]\n  int fd; // [rsp+3Ch] [rbp-4h]\n\n  fd = -1;\n  v10 = (const char *)sub_4C0C5F(a1);\n  if ( !*v10 )\n    return 1LL;\n  if ( (*(_DWORD *)(a2 + 24) & 0xF000) == 49152 )\n  {\n    sub_409747(\"%s: socket ignored\", (__int64)a1, v3, v4, v5, v6);\n    return 1LL;\n  }\n  else\n  {\n    *(_QWORD *)(a3 + 24) = 0LL;\n    if ( (*(_DWORD *)(a2 + 24) & 0xF000) != 0x4000 && *(_QWORD *)(a2 + 16) > 1uLL )\n    {\n      *(_QWORD *)(a3 + 24) = sub_4B463A(*(_QWORD **)(a3 + 16), (_QWORD *)a2);\n      if ( !*(_QWORD *)(a3 + 24) )\n        sub_4B4564((_QWORD *)(a3 + 16), (_QWORD *)a2, v10);\n    }\n    if ( *(_QWORD *)(a3 + 32) == *(_QWORD *)a2 && (v8 = *(_QWORD *)(a3 + 40), v8 == *(_QWORD *)(a2 + 8)) )\n    {\n      sub_409747(\"%s: file is the archive; skipping\", (__int64)a1, v8, v4, v5, v6);\n      return 1LL;\n    }\n    else if ( (unsigned int)sub_4B4EE0(*(__int64 ***)(a3 + 8), v10) )\n    {\n      return 2LL;\n    }\n    else if ( *(_QWORD *)(a3 + 24) || (*(_DWORD *)(a2 + 24) & 0xF000) != 0x8000 || (fd = sub_40A32A(a1, 0), fd >= 0) )\n    {\n      if ( (unsigned int)sub_4B492A(a3, v10, a1, a2) )\n      {\n        if ( fd >= 0 )\n        {\n          sub_40B309(fd, *(_DWORD *)a3, *(_QWORD *)(a2 + 48));\n          close(fd);\n          n = -(int)*(_QWORD *)(a2 + 48) & 0x1FF;\n          memset(&dest, 0, n);\n          sub_40A4AB(*(_DWORD *)a3, (__int64)&dest, n);\n        }\n        return 1LL;\n      }\n      else\n      {\n        return 0LL;\n      }\n    }\n    else\n    {\n      return 0LL;\n    }\n  }\n}\n\n\n Revised code:\nendif\n\nstatic int FAST_FUNC writeFileToTarball(const char *fileName, struct stat *statbuf,\n\t\t\tvoid *userData, int depth UNUSED_PARAM)\n{\n\tstruct TarBallInfo *tbInfo = (struct TarBallInfo *) userData;\n\tconst char *header_name;\n\tint inputFileFd = -1;\n\n\tDBG(\"writeFileToTarball('%s')\", fileName);\n\n\t/* Strip leading '/' and such (must be before memorizing hardlink's name) */\n\theader_name = strip_unsafe_prefix(fileName);\n\n\tif (header_name[0] == '\\0')\n\t\treturn TRUE;\n\n\t/* It is against the rules to archive a socket */\n\tif (S_ISSOCK(statbuf->st_mode)) {\n\t\tbb_error_msg(\"%s: socket ignored\", fileName);\n\t\treturn TRUE;\n\t}\n\n\t/*\n\t * Check to see if we are dealing with a hard link.\n\t * If so -\n\t * Treat the first occurance of a given dev/inode as a file while\n\t * treating any additional occurances as hard links.  This is done\n\t * by adding the file information to the HardLinkInfo linked list.\n\t */\n\ttbInfo->hlInfo = NULL;\n\tif (!S_ISDIR(statbuf->st_mode) && statbuf->st_nlink > 1) {\n\t\tDBG(\"'%s': st_nlink > 1\", header_name);\n\t\ttbInfo->hlInfo = findHardLinkInfo(tbInfo->hlInfoHead, statbuf);\n\t\tif (tbInfo->hlInfo == NULL) {\n\t\t\tDBG(\"'%s': addHardLinkInfo\", header_name);\n\t\t\taddHardLinkInfo(&tbInfo->hlInfoHead, statbuf, header_name);\n\t\t}\n\t}\n\n\t/* It is a bad idea to store the archive we are in the process of creating,\n\t * so check the device and inode to be sure that this particular file isn't\n\t * the new tarball */\n\tif (tbInfo->tarFileStatBuf.st_dev == statbuf->st_dev\n\t && tbInfo->tarFileStatBuf.st_ino == statbuf->st_ino\n\t) {\n\t\tbb_error_msg(\"%s: file is the archive; skipping\", fileName);\n\t\treturn TRUE;\n\t}\n\n\tif (exclude_file(tbInfo->excludeList, header_name))\n\t\treturn SKIP;\n\n#if !ENABLE_FEATURE_TAR_GNU_EXTENSIONS\n\tif (strlen(header_name) >= NAME_SIZE) {\n\t\tbb_error_msg(\"names longer than \"NAME_SIZE_STR\" chars not supported\");\n\t\treturn TRUE;\n\t}\n#endif\n\n\t/* Is this a regular file? */\n\tif (tbInfo->hlInfo == NULL && S_ISREG(statbuf->st_mode)) {\n\t\t/* open the file we want to archive, and make sure all is well */\n\t\tinputFileFd = open_or_warn(fileName, O_RDONLY);\n\t\tif (inputFileFd < 0) {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* Add an entry to the tarball */\n\tif (writeTarHeader(tbInfo, header_name, fileName, statbuf) == FALSE) {\n\t\treturn FALSE;\n\t}\n\n\t/* If it was a regular file, write out the body */\n\tif (inputFileFd >= 0) {\n\t\tsize_t readSize;\n\t\t/* Write the file to the archive. */\n\t\t/* We record size into header first, */\n\t\t/* and then write out file. If file shrinks in between, */\n\t\t/* tar will be corrupted. So we don't allow for that. */\n\t\t/* NB: GNU tar 1.16 warns and pads with zeroes */\n\t\t/* or even seeks back and updates header */\n\t\tbb_copyfd_exact_size(inputFileFd, tbInfo->tarFd, statbuf->st_size);\n\t\t////off_t readSize;\n\t\t////readSize = bb_copyfd_size(inputFileFd, tbInfo->tarFd, statbuf->st_size);\n\t\t////if (readSize != statbuf->st_size && readSize >= 0) {\n\t\t////\tbb_error_msg_and_die(\"short read from %s, aborting\", fileName);\n\t\t////}\n\n\t\t/* Check that file did not grow in between? */\n\t\t/* if (safe_read(inputFileFd, 1) == 1) warn but continue? */\n\n\t\tclose(inputFileFd);\n\n\t\t/* Pad the file up to the tar block size */\n\t\t/* (a few tricks here in the name of code size) */\n\t\treadSize = (-(int)statbuf->st_size) & (TAR_BLOCK_SIZE-1);\n\t\tmemset(block_buf, 0, readSize);\n\t\txwrite(tbInfo->tarFd, block_buf, readSize);\n\t}\n\n\treturn TRUE;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47A754(__int64 a1, char a2)\n{\n  __int64 v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 v7; // rdx\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  int v13; // [rsp+18h] [rbp-8h]\n  int fd; // [rsp+1Ch] [rbp-4h]\n\n  ++*(_DWORD *)(qword_75D418 + 48);\n  v2 = 0LL;\n  fd = open64((const char *)a1, 0);\n  if ( fd >= 0 )\n  {\n    if ( fd <= 9 )\n    {\n      v13 = sub_473441(fd, 10);\n      close(fd);\n      if ( v13 < 0 )\n        sub_46E473(\"out of file descriptors\", 10LL, v7, v8, v9, v10);\n      fd = v13;\n    }\n    v2 = a2 & 1;\n    a1 = (unsigned int)fd;\n    sub_47A6BD(fd, v2);\n  }\n  else if ( (a2 & 2) == 0 )\n  {\n    sub_46E473(\"can't open '%s'\", a1, v3, v4, v5, v6);\n  }\n  sub_46E03F(a1, v2);\n  return (unsigned int)fd;\n}\n\n\n Revised code:\nstatic int\nsetinputfile(const char *fname, int flags)\n{\n\tint fd;\n\tint fd2;\n\n\tINT_OFF;\n\tfd = open(fname, O_RDONLY);\n\tif (fd < 0) {\n\t\tif (flags & INPUT_NOFILE_OK)\n\t\t\tgoto out;\n\t\tash_msg_and_raise_error(\"can't open '%s'\", fname);\n\t}\n\tif (fd < 10) {\n\t\tfd2 = copyfd(fd, 10);\n\t\tclose(fd);\n\t\tif (fd2 < 0)\n\t\t\tash_msg_and_raise_error(\"out of file descriptors\");\n\t\tfd = fd2;\n\t}\n\tsetinputfd(fd, flags & INPUT_PUSH_FILE);\n out:\n\tINT_ON;\n\treturn fd;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E72BF(const char *a1, int a2, int a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v7; // rsi\n  __int64 v8; // rdx\n  __int64 v9; // rcx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  int v16; // eax\n  unsigned int v18; // [rsp+4h] [rbp-2Ch]\n  int fd; // [rsp+1Ch] [rbp-14h]\n  unsigned int v20; // [rsp+20h] [rbp-10h]\n  unsigned int v21; // [rsp+24h] [rbp-Ch]\n  __int64 v22; // [rsp+28h] [rbp-8h]\n\n  v18 = a2;\n  if ( (unsigned int)sub_4E5B71(a2, a3, (__int64)\"write\", (unsigned int)a3, a5, a6) )\n    return 0LL;\n  v21 = 0;\n  v20 = 0;\n  v7 = 438LL;\n  fd = creat64(a1, 0x1B6u);\n  if ( fd < 0 )\n    goto LABEL_4;\n  v7 = (__int64)a1;\n  printf(\"\\\"%s\\\", \", a1);\n  sub_40A649();\n  v22 = sub_4E78F6(v18);\n  if ( v22 )\n  {\n    while ( 1 )\n    {\n      v16 = v18++;\n      if ( a3 < v16 )\n        break;\n      v7 = v22 + 20;\n      v12 = sub_40B38A(fd, v22 + 20, *(int *)(v22 + 16));\n      if ( v12 != *(_DWORD *)(v22 + 16) )\n      {\n        sub_40936D((__int64)a1, v7, v12, v13, v14, v15);\n        close(fd);\n        return 0LL;\n      }\n      v20 += *(_DWORD *)(v22 + 16);\n      ++v21;\n      v22 = *(_QWORD *)v22;\n    }\n    if ( close(fd) < 0 )\n    {\nLABEL_4:\n      sub_40936D((__int64)a1, v7, v8, v9, v10, v11);\n      return 0LL;\n    }\n    printf(\"%d lines, %d chars\\n\", v21, v20);\n    return 1LL;\n  }\n  else\n  {\n    close(fd);\n    return 0LL;\n  }\n}\n\n\n Revised code:\nstatic int writeLines(const char *file, int num1, int num2)\n{\n\tLINE *lp;\n\tint fd, lineCount, charCount;\n\n\tif (bad_nums(num1, num2, \"write\"))\n\t\treturn FALSE;\n\n\tlineCount = 0;\n\tcharCount = 0;\n\n\tfd = creat(file, 0666);\n\tif (fd < 0) {\n\t\tbb_simple_perror_msg(file);\n\t\treturn FALSE;\n\t}\n\n\tprintf(\"\\\"%s\\\", \", file);\n\tfflush_all();\n\n\tlp = findLine(num1);\n\tif (lp == NULL) {\n\t\tclose(fd);\n\t\treturn FALSE;\n\t}\n\n\twhile (num1++ <= num2) {\n\t\tif (full_write(fd, lp->data, lp->len) != lp->len) {\n\t\t\tbb_simple_perror_msg(file);\n\t\t\tclose(fd);\n\t\t\treturn FALSE;\n\t\t}\n\t\tcharCount += lp->len;\n\t\tlineCount++;\n\t\tlp = lp->next;\n\t}\n\n\tif (close(fd) < 0) {\n\t\tbb_simple_perror_msg(file);\n\t\treturn FALSE;\n\t}\n\n\tprintf(\"%d lines, %d chars\\n\", lineCount, charCount);\n\treturn TRUE;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4EFAD3(const char *a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int fd; // [rsp+28h] [rbp-8h]\n  unsigned int v9; // [rsp+2Ch] [rbp-4h]\n\n  if ( a1 )\n  {\n    fd = open64(a1, 65, 438LL);\n    if ( fd >= 0 )\n    {\n      v9 = sub_40B38A(fd, a2, a3 - (int)a2 + 1);\n      ftruncate64(fd, (int)v9);\n      if ( v9 != a3 - (_DWORD)a2 + 1 )\n        v9 = 0;\n      close(fd);\n      return v9;\n    }\n    else\n    {\n      return 0xFFFFFFFFLL;\n    }\n  }\n  else\n  {\n    sub_4EFE97((unsigned int)\"No current filename\", a2, a3, a4, a5, a6);\n    return 4294967294LL;\n  }\n}\n",
        "output": "static unsigned int writeFile(const char *filename, unsigned int start, int end, int a4, int a5, int a6)\n{\n\tint fd;\n\tunsigned int result;\n\n\tif (filename) {\n\t\tfd = open(filename, O_RDWR | O_CREAT | O_TRUNC, 0666);\n\t\tif (fd >= 0) {\n\t\t\tresult = sub_40B38A(fd, start, end - start + 1);\n\t\t\tftruncate(fd, result);\n\t\t\tif (result != end - start + 1)\n\t\t\t\tresult = 0;\n\t\t\tclose(fd);\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn 0xFFFFFFFF;\n\t\t}\n\t} else {\n\t\tsub_4EFE97(\"No current filename\", start, end, a4, a5, a6);\n\t\treturn 4294967294;\n\t}\n}",
        "source_code": "static int file_write(char *fn, char *first, char *last)\n{\n\tint fd, cnt, charcnt;\n\n\tif (fn == 0) {\n\t\tstatus_line_bold(\"No current filename\");\n\t\treturn -2;\n\t}\n\t/* By popular request we do not open file with O_TRUNC,\n\t * but instead ftruncate() it _after_ successful write.\n\t * Might reduce amount of data lost on power fail etc.\n\t */\n\tfd = open(fn, (O_WRONLY | O_CREAT), 0666);\n\tif (fd < 0)\n\t\treturn -1;\n\tcnt = last - first + 1;\n\tcharcnt = full_write(fd, first, cnt);\n\tftruncate(fd, charcnt);\n\tif (charcnt == cnt) {\n\t\t// good write\n\t\t//file_modified = FALSE;\n\t} else {\n\t\tcharcnt = 0;\n\t}\n\tclose(fd);\n\treturn charcnt;\n}",
        "parsed_output": "static unsigned int writeFile(const char *filename, unsigned int start, int end, int a4, int a5, int a6)\n{\n\tint fd;\n\tunsigned int result;\n\n\tif (filename) {\n\t\tfd = open(filename, O_RDWR | O_CREAT | O_TRUNC, 0666);\n\t\tif (fd >= 0) {\n\t\t\tresult = sub_40B38A(fd, start, end - start + 1);\n\t\t\tftruncate(fd, result);\n\t\t\tif (result != end - start + 1)\n\t\t\t\tresult = 0;\n\t\t\tclose(fd);\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn 0xFFFFFFFF;\n\t\t}\n\t} else {\n\t\tsub_4EFE97(\"No current filename\", start, end, a4, a5, a6);\n\t\treturn 4294967294;\n\t}\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4EFAD3(const char *a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int fd; // [rsp+28h] [rbp-8h]\n  unsigned int v9; // [rsp+2Ch] [rbp-4h]\n\n  if ( a1 )\n  {\n    fd = open64(a1, 65, 438LL);\n    if ( fd >= 0 )\n    {\n      v9 = sub_40B38A(fd, a2, a3 - (int)a2 + 1);\n      ftruncate64(fd, (int)v9);\n      if ( v9 != a3 - (_DWORD)a2 + 1 )\n        v9 = 0;\n      close(fd);\n      return v9;\n    }\n    else\n    {\n      return 0xFFFFFFFFLL;\n    }\n  }\n  else\n  {\n    sub_4EFE97((unsigned int)\"No current filename\", a2, a3, a4, a5, a6);\n    return 4294967294LL;\n  }\n}\n",
        "baseline_code_debug": "int __cdecl file_write(char *fn, char *first, char *last)\n{\n  int lasta; // [rsp+8h] [rbp-28h]\n  int fd; // [rsp+28h] [rbp-8h]\n  int charcnt; // [rsp+2Ch] [rbp-4h]\n\n  lasta = (int)last;\n  if ( fn )\n  {\n    fd = open64(fn, 65, 438LL);\n    if ( fd >= 0 )\n    {\n      charcnt = full_write(fd, first, lasta - (int)first + 1);\n      ftruncate64(fd, charcnt);\n      if ( charcnt != lasta - (_DWORD)first + 1 )\n        charcnt = 0;\n      close(fd);\n      return charcnt;\n    }\n    else\n    {\n      return -1;\n    }\n  }\n  else\n  {\n    status_line_bold(\"No current filename\");\n    return -2;\n  }\n}\n",
        "similarity_score_unixcoder": 0.784743070602417,
        "similarity_score_baseline_stripped": 0.6463940143585205,
        "similarity_score_baseline_debug": 0.8827787637710571
    },
    {
        "func_name": "in_ether",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_50A2A6(__int64 *a1, char *a2)\n{\n  _BYTE *v2; // rax\n  _BYTE *v3; // rax\n  _BYTE *v4; // rax\n  char v7; // [rsp+1Ch] [rbp-24h]\n  unsigned __int8 v8; // [rsp+1Dh] [rbp-23h]\n  unsigned __int8 v9; // [rsp+1Eh] [rbp-22h]\n  char v10; // [rsp+1Fh] [rbp-21h]\n  char *v11; // [rsp+20h] [rbp-20h]\n  int c; // [rsp+28h] [rbp-18h]\n  int v13; // [rsp+2Ch] [rbp-14h]\n  char *v14; // [rsp+30h] [rbp-10h]\n  _BYTE *v15; // [rsp+38h] [rbp-8h]\n\n  v15 = (_BYTE *)*a1;\n  while ( 1 )\n  {\n    v13 = 0;\n    v14 = a2;\nLABEL_9:\n    if ( v13 <= 3 )\n      break;\nLABEL_10:\n    if ( v13 > 1 )\n    {\n      v2 = v15++;\n      *v2 = (v8 >> 4) | (4 * v7);\n    }\n    if ( v13 > 2 )\n    {\n      v3 = v15++;\n      *v3 = (v9 >> 2) | (16 * v8);\n    }\n    if ( v13 > 3 )\n    {\n      v4 = v15++;\n      *v4 = v10 | (v9 << 6);\n    }\n  }\n  while ( 1 )\n  {\n    c = *a2;\n    if ( !c )\n      break;\n    ++a2;\n    v11 = strchr(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", c);\n    if ( v11 )\n    {\n      c = v11 - \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      if ( c == 64 )\n        goto LABEL_10;\n      *(&v7 + v13++) = c;\n      goto LABEL_9;\n    }\n  }\n  if ( !v13 )\n    v14 = a2;\n  *a1 = (__int64)v15;\n  return (__int64)v14;\n}\n\n\n Revised code:\nFAST_FUNC decode_base64(char **pp_dst, const char *src)\n{\n\tchar *dst = *pp_dst;\n\tconst char *src_tail;\n\n\twhile (1) {\n\t\tunsigned char six_bit[4];\n\t\tint count = 0;\n\n\t\t/* Fetch up to four 6-bit values */\n\t\tsrc_tail = src;\n\t\twhile (count < 4) {\n\t\t\tchar *table_ptr;\n\t\t\tint ch;\n\n\t\t\t/* Get next _valid_ character.\n\t\t\t * bb_uuenc_tbl_base64[] contains this string:\n\t\t\t *  0         1         2         3         4         5         6\n\t\t\t *  01234567890123456789012345678901234567890123456789012345678901234\n\t\t\t * \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tch = *src;\n\t\t\t\tif (ch == '\\0') {\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\t/* Example:\n\t\t\t\t\t\t * If we decode \"QUJD <NUL>\", we want\n\t\t\t\t\t\t * to return ptr to NUL, not to ' ',\n\t\t\t\t\t\t * because we did fully decode\n\t\t\t\t\t\t * the string (to \"ABC\").\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsrc_tail = src;\n\t\t\t\t\t}\n\t\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\t\tsrc++;\n\t\t\t\ttable_ptr = strchr(bb_uuenc_tbl_base64, ch);\n//TODO: add BASE64_FLAG_foo to die on bad char?\n\t\t\t} while (!table_ptr);\n\n\t\t\t/* Convert encoded character to decimal */\n\t\t\tch = table_ptr - bb_uuenc_tbl_base64;\n\n\t\t\t/* ch is 64 if char was '=', otherwise 0..63 */\n\t\t\tif (ch == 64)\n\t\t\t\tbreak;\n\t\t\tsix_bit[count] = ch;\n\t\t\tcount++;\n\t\t}\n\n\t\t/* Transform 6-bit values to 8-bit ones.\n\t\t * count can be < 4 when we decode the tail:\n\t\t * \"eQ==\" -> \"y\", not \"y NUL NUL\".\n\t\t * Note that (count > 1) is always true,\n\t\t * \"x===\" encoding is not valid:\n\t\t * even a single zero byte encodes as \"AA==\".\n\t\t * However, with current logic we come here with count == 1\n\t\t * when we decode \"==\" tail.\n\t\t */\n\t\tif (count > 1)\n\t\t\t*dst++ = six_bit[0] << 2 | six_bit[1] >> 4;\n\t\tif (count > 2)\n\t\t\t*dst++ = six_bit[1] << 4 | six_bit[2] >> 2;\n\t\tif (count > 3)\n\t\t\t*dst++ = six_bit[2] << 6 | six_bit[3];\n\t\t/* Note that if we decode \"AA==\" and ate first '=',\n\t\t * we just decoded one char (count == 2) and now we'll\n\t\t * do the loop once more to decode second '='.\n\t\t */\n\t} /* while (1) */\n ret:\n\t*pp_dst = dst;\n\treturn src_tail;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_50308A(_BYTE **a1)\n{\n  const char *v2; // [rsp+18h] [rbp-20h]\n  unsigned int v3; // [rsp+20h] [rbp-18h]\n  unsigned int v4; // [rsp+24h] [rbp-14h]\n  unsigned int v5; // [rsp+28h] [rbp-10h]\n  int v6; // [rsp+2Ch] [rbp-Ch]\n  _BYTE *v7; // [rsp+30h] [rbp-8h]\n\n  v5 = 0;\n  v6 = 0;\n  v4 = 8;\n  v7 = *a1;\n  if ( **a1 == 120 )\n  {\n    ++v7;\n    v4 = 16;\n    v6 = 1;\n  }\n  while ( 1 )\n  {\n    v3 = (*v7 | 0x20) - 48;\n    if ( v3 > 9 )\n      v3 = (*v7 | 0x20) - 87;\n    if ( v3 >= v4 )\n      break;\n    if ( v4 * v5 + v3 <= 0xFF )\n    {\n      v5 = v4 * v5 + v3;\n      ++v7;\n      if ( (unsigned int)++v6 <= 2 )\n        continue;\n    }\n    goto LABEL_11;\n  }\n  if ( v4 == 16 && !--v6 )\n    return 92LL;\nLABEL_11:\n  if ( !v6 )\n  {\n    v2 = \"abefnrtv\\\\\";\n    while ( *v2 != *v7 )\n    {\n      if ( !*++v2 )\n        goto LABEL_16;\n    }\n    ++v7;\nLABEL_16:\n    v5 = v2[10];\n  }\n  *a1 = v7;\n  return v5;\n}\n\n\n Revised code:\nchar FAST_FUNC bb_process_escape_sequence(const char **ptr)\n{\n\tconst char *q;\n\tunsigned num_digits;\n\tunsigned n;\n\tunsigned base;\n\n\tnum_digits = n = 0;\n\tbase = 8;\n\tq = *ptr;\n\n\tif (WANT_HEX_ESCAPES && *q == 'x') {\n\t\t++q;\n\t\tbase = 16;\n\t\t++num_digits;\n\t}\n\n\t/* bash requires leading 0 in octal escapes:\n\t * \\02 works, \\2 does not (prints \\ and 2).\n\t * We treat \\2 as a valid octal escape sequence. */\n\tdo {\n\t\tunsigned r;\n#if !WANT_HEX_ESCAPES\n\t\tunsigned d = (unsigned char)(*q) - '0';\n#else\n\t\tunsigned d = (unsigned char)_tolower(*q) - '0';\n\t\tif (d >= 10)\n\t\t\td += ('0' - 'a' + 10);\n#endif\n\t\tif (d >= base) {\n\t\t\tif (WANT_HEX_ESCAPES && base == 16) {\n\t\t\t\t--num_digits;\n\t\t\t\tif (num_digits == 0) {\n\t\t\t\t\t/* \\x<bad_char>: return '\\',\n\t\t\t\t\t * leave ptr pointing to x */\n\t\t\t\t\treturn '\\\\';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tr = n * base + d;\n\t\tif (r > UCHAR_MAX) {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = r;\n\t\t++q;\n\t} while (++num_digits < 3);\n\n\tif (num_digits == 0) {\n\t\t/* Not octal or hex escape sequence.\n\t\t * Is it one-letter one? */\n\n\t\t/* bash builtin \"echo -e '\\ec'\" interprets \\e as ESC,\n\t\t * but coreutils \"/bin/echo -e '\\ec'\" does not.\n\t\t * Manpages tend to support coreutils way.\n\t\t * Update: coreutils added support for \\e on 28 Oct 2009. */\n\t\tstatic const char charmap[] ALIGN1 = {\n\t\t\t'a',  'b', 'e', 'f',  'n',  'r',  't',  'v',  '\\\\', '\\0',\n\t\t\t'\\a', '\\b', 27, '\\f', '\\n', '\\r', '\\t', '\\v', '\\\\', '\\\\',\n\t\t};\n\t\tconst char *p = charmap;\n\t\tdo {\n\t\t\tif (*p == *q) {\n\t\t\t\tq++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (*++p != '\\0');\n\t\t/* p points to found escape char or NUL,\n\t\t * advance it and find what it translates to.\n\t\t * Note that \\NUL and unrecognized sequence \\z return '\\'\n\t\t * and leave ptr pointing to NUL or z. */\n\t\tn = p[sizeof(charmap) / 2];\n\t}\n\n\t*ptr = q;\n\n\treturn (char) n;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E8C0A(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  unsigned int v7; // [rsp+Ch] [rbp-14h]\n  char v8; // [rsp+13h] [rbp-Dh]\n  int v9; // [rsp+14h] [rbp-Ch]\n  int v10; // [rsp+18h] [rbp-8h]\n  int v11; // [rsp+1Ch] [rbp-4h]\n\n  v7 = a1;\n  v11 = -1;\n  v10 = 0;\n  v9 = 0;\n  if ( a1 < 0 )\n  {\n    v11 = -2;\n    v7 = -a1;\n  }\n  while ( 1 )\n  {\n    v8 = *(_BYTE *)(v9 + a2);\n    if ( !v8 )\n      sub_40969E(\"unmatched '%c'\", v7, v9, a4, a5, a6);\n    if ( v11 >= 0 )\n    {\n      if ( v8 == 93 && v11 != v9 - 1 && (v11 != v9 - 2 || *(_BYTE *)(v9 - 1LL + a2) != 94) )\n        v11 = -1;\n      goto LABEL_18;\n    }\n    if ( v10 )\n    {\n      v10 = 0;\n      goto LABEL_18;\n    }\n    if ( v8 == 92 )\n    {\n      v10 = 1;\n      goto LABEL_18;\n    }\n    if ( v11 == -1 && v8 == 91 )\n    {\n      v11 = v9;\n      goto LABEL_18;\n    }\n    if ( v7 == v8 )\n      return (unsigned int)v9;\nLABEL_18:\n    ++v9;\n  }\n}\n\n\n Revised code:\nstatic int index_of_next_unescaped_regexp_delim(int delimiter, const char *str)\n{\n\tint bracket = -1;\n\tint escaped = 0;\n\tint idx = 0;\n\tchar ch;\n\n\tif (delimiter < 0) {\n\t\tbracket--;\n\t\tdelimiter = -delimiter;\n\t}\n\n\tfor (; (ch = str[idx]) != '\\0'; idx++) {\n\t\tif (bracket >= 0) {\n\t\t\tif (ch == ']'\n\t\t\t && !(bracket == idx - 1 || (bracket == idx - 2 && str[idx - 1] == '^'))\n\t\t\t) {\n\t\t\t\tbracket = -1;\n\t\t\t}\n\t\t} else if (escaped)\n\t\t\tescaped = 0;\n\t\telse if (ch == '\\\\')\n\t\t\tescaped = 1;\n\t\telse if (bracket == -1 && ch == '[')\n\t\t\tbracket = idx;\n\t\telse if (ch == delimiter)\n\t\t\treturn idx;\n\t}\n\n\t/* if we make it to here, we've hit the end of the string */\n\tbb_error_msg_and_die(\"unmatched '%c'\", delimiter);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_42F1F5(char *a1, _WORD *a2)\n{\n  _BYTE *v3; // rax\n  char v5; // [rsp+1Eh] [rbp-12h]\n  char v6; // [rsp+1Eh] [rbp-12h]\n  char v7; // [rsp+1Fh] [rbp-11h]\n  int v8; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+24h] [rbp-Ch]\n  _WORD *v10; // [rsp+28h] [rbp-8h]\n\n  *a2 = 1;\n  v10 = a2 + 1;\n  for ( i = 0; i <= 5; ++i )\n  {\n    v7 = 0;\n    v8 = 0;\n    if ( i && *a1 == 58 )\n      ++a1;\n    while ( 1 )\n    {\n      v5 = *a1;\n      if ( (unsigned __int8)(*a1 - 48) > 9u )\n        break;\n      v6 = v5 - 48;\nLABEL_13:\n      ++a1;\n      v7 = v6 + 16 * v7;\n      if ( ++v8 > 1 )\n        goto LABEL_14;\n    }\n    if ( (unsigned __int8)((v5 | 0x20) - 97) <= 5u )\n    {\n      v6 = (v5 | 0x20) - 87;\n      goto LABEL_13;\n    }\n    if ( !v8 || v5 != 58 && v5 )\n      return 0xFFFFFFFFLL;\nLABEL_14:\n    v3 = v10;\n    v10 = (_WORD *)((char *)v10 + 1);\n    *v3 = v7;\n  }\n  return (unsigned int)*a1;\n}\n",
        "output": "Revised code:\nint parse_ipv6_address(const char *str, uint16_t *addr)\n{\n    *addr = 1;\n    addr++;\n    for (int i = 0; i <= 5; ++i)\n    {\n        uint8_t high = 0;\n        uint8_t low = 0;\n        if (i && *str == ':')\n            ++str;\n        while (1)\n        {\n            char ch = *str;\n            if ((uint8_t)(ch - '0') > 9u)\n                break;\n            uint8_t digit = ch - '0';\n        LABEL_13:\n            ++str;\n            high = digit + 16 * high;\n            if (++low > 1)\n                goto LABEL_14;\n        }\n        if ((uint8_t)((ch | 0x20) - 'a') <= 5u)\n        {\n            uint8_t digit = (ch | 0x20) - 'a' + 10;\n            goto LABEL_13;\n        }\n        if (!low || ch != ':' && ch)\n            return -1;\n    LABEL_14:\n        *addr = high;\n        addr++;\n    }\n    return (unsigned int)*str;\n}",
        "source_code": "static int in_ether(const char *bufp, struct sockaddr *sap)\n{\n\tchar *ptr;\n\tint i, j;\n\tunsigned char val;\n\tunsigned char c;\n\n\tsap->sa_family = ARPHRD_ETHER;\n\tptr = (char *) sap->sa_data;\n\n\ti = 0;\n\tdo {\n\t\tj = val = 0;\n\n\t\t/* We might get a semicolon here - not required. */\n\t\tif (i && (*bufp == ':')) {\n\t\t\tbufp++;\n\t\t}\n\n\t\tdo {\n\t\t\tc = *bufp;\n\t\t\tif (((unsigned char)(c - '0')) <= 9) {\n\t\t\t\tc -= '0';\n\t\t\t} else if ((unsigned char)((c|0x20) - 'a') <= 5) {\n\t\t\t\tc = (unsigned char)((c|0x20) - 'a') + 10;\n\t\t\t} else if (j && (c == ':' || c == 0)) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t++bufp;\n\t\t\tval <<= 4;\n\t\t\tval += c;\n\t\t} while (++j < 2);\n\t\t*ptr++ = val;\n\t} while (++i < ETH_ALEN);\n\n\treturn *bufp; /* Error if we don't end at end of string. */\n}",
        "parsed_output": "Revised code:\nint parse_ipv6_address(const char *str, uint16_t *addr)\n{\n    *addr = 1;\n    addr++;\n    for (int i = 0; i <= 5; ++i)\n    {\n        uint8_t high = 0;\n        uint8_t low = 0;\n        if (i && *str == ':')\n            ++str;\n        while (1)\n        {\n            char ch = *str;\n            if ((uint8_t)(ch - '0') > 9u)\n                break;\n            uint8_t digit = ch - '0';\n        LABEL_13:\n            ++str;\n            high = digit + 16 * high;\n            if (++low > 1)\n                goto LABEL_14;\n        }\n        if ((uint8_t)((ch | 0x20) - 'a') <= 5u)\n        {\n            uint8_t digit = (ch | 0x20) - 'a' + 10;\n            goto LABEL_13;\n        }\n        if (!low || ch != ':' && ch)\n            return -1;\n    LABEL_14:\n        *addr = high;\n        addr++;\n    }\n    return (unsigned int)*str;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_42F1F5(char *a1, _WORD *a2)\n{\n  _BYTE *v3; // rax\n  char v5; // [rsp+1Eh] [rbp-12h]\n  char v6; // [rsp+1Eh] [rbp-12h]\n  char v7; // [rsp+1Fh] [rbp-11h]\n  int v8; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+24h] [rbp-Ch]\n  _WORD *v10; // [rsp+28h] [rbp-8h]\n\n  *a2 = 1;\n  v10 = a2 + 1;\n  for ( i = 0; i <= 5; ++i )\n  {\n    v7 = 0;\n    v8 = 0;\n    if ( i && *a1 == 58 )\n      ++a1;\n    while ( 1 )\n    {\n      v5 = *a1;\n      if ( (unsigned __int8)(*a1 - 48) > 9u )\n        break;\n      v6 = v5 - 48;\nLABEL_13:\n      ++a1;\n      v7 = v6 + 16 * v7;\n      if ( ++v8 > 1 )\n        goto LABEL_14;\n    }\n    if ( (unsigned __int8)((v5 | 0x20) - 97) <= 5u )\n    {\n      v6 = (v5 | 0x20) - 87;\n      goto LABEL_13;\n    }\n    if ( !v8 || v5 != 58 && v5 )\n      return 0xFFFFFFFFLL;\nLABEL_14:\n    v3 = v10;\n    v10 = (_WORD *)((char *)v10 + 1);\n    *v3 = v7;\n  }\n  return (unsigned int)*a1;\n}\n",
        "baseline_code_debug": "int __cdecl in_ether(const char *bufp, sockaddr *sap)\n{\n  unsigned __int8 *v3; // rax\n  unsigned __int8 c; // [rsp+1Eh] [rbp-12h]\n  unsigned __int8 ca; // [rsp+1Eh] [rbp-12h]\n  unsigned __int8 val; // [rsp+1Fh] [rbp-11h]\n  int j; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+24h] [rbp-Ch]\n  char *ptr; // [rsp+28h] [rbp-8h]\n\n  sap->sa_family = 1;\n  ptr = sap->sa_data;\n  for ( i = 0; i <= 5; ++i )\n  {\n    val = 0;\n    j = 0;\n    if ( i && *bufp == 58 )\n      ++bufp;\n    while ( 1 )\n    {\n      c = *bufp;\n      if ( (unsigned __int8)(*bufp - 48) > 9u )\n        break;\n      ca = c - 48;\nLABEL_13:\n      ++bufp;\n      val = ca + 16 * val;\n      if ( ++j > 1 )\n        goto LABEL_14;\n    }\n    if ( (unsigned __int8)((c | 0x20) - 97) <= 5u )\n    {\n      ca = (c | 0x20) - 87;\n      goto LABEL_13;\n    }\n    if ( !j || c != 58 && c )\n      return -1;\nLABEL_14:\n    v3 = (unsigned __int8 *)ptr++;\n    *v3 = val;\n  }\n  return *bufp;\n}\n",
        "similarity_score_unixcoder": 0.7559238076210022,
        "similarity_score_baseline_stripped": 0.5886122584342957,
        "similarity_score_baseline_debug": 0.8319883346557617
    },
    {
        "func_name": "die_if_nologin",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_BOOL8 sub_4F3AAF()\n{\n  int v1; // [rsp+Ch] [rbp-14h]\n  FILE *stream; // [rsp+10h] [rbp-10h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  stream = (FILE *)sub_40984D((__int64)\"/dev/tty\");\n  fwrite_unlocked(\" ?...\", 1uLL, 5uLL, stderr);\n  sub_40A649();\n  v1 = getc_unlocked(stream);\n  for ( i = v1; i != -1 && i != 10; i = getc_unlocked(stream) )\n    ;\n  fclose(stream);\n  return v1 == 121 || v1 == 89;\n}\n\n\n Revised code:\nstatic int xargs_ask_confirmation(void)\n{\n\tFILE *tty_stream;\n\tint c, savec;\n\n\ttty_stream = xfopen_for_read(CURRENT_TTY);\n\tfputs(\" ?...\", stderr);\n\tfflush_all();\n\tc = savec = getc(tty_stream);\n\twhile (c != EOF && c != '\\n')\n\t\tc = getc(tty_stream);\n\tfclose(tty_stream);\n\treturn (savec == 'y' || savec == 'Y');\n}\n\n## Example:\n\n Input code:\n__int64 sub_4F9E45()\n{\n  int v1; // [rsp+Ch] [rbp-114h] BYREF\n  char s[3]; // [rsp+10h] [rbp-110h] BYREF\n  char v3[253]; // [rsp+13h] [rbp-10Dh] BYREF\n  FILE *stream; // [rsp+110h] [rbp-10h]\n  int v5; // [rsp+11Ch] [rbp-4h]\n\n  v5 = -1;\n  stream = (FILE *)sub_40984D((__int64)\"/proc/stat\");\n  while ( fgets_unlocked(s, 256, stream) )\n  {\n    if ( sub_4F9E00(s) )\n    {\n      if ( v3[0] != 32 && sscanf(v3, \"%u\", &v1) == 1 && v5 < v1 )\n        v5 = v1;\n    }\n    else if ( v5 >= 0 )\n    {\n      break;\n    }\n  }\n  fclose(stream);\n  return (unsigned int)(v5 + 1);\n}\n\n\n Revised code:\nunsigned FAST_FUNC get_cpu_count(void)\n{\n\tFILE *fp;\n\tchar line[256];\n\tint proc_nr = -1;\n\n\tfp = xfopen_for_read(\"/proc/stat\");\n\twhile (fgets(line, sizeof(line), fp)) {\n\t\tif (!starts_with_cpu(line)) {\n\t\t\tif (proc_nr >= 0)\n\t\t\t\tbreak; /* we are past \"cpuN...\" lines */\n\t\t\tcontinue;\n\t\t}\n\t\tif (line[3] != ' ') { /* \"cpuN\" */\n\t\t\tint num_proc;\n\t\t\tif (sscanf(line + 3, \"%u\", &num_proc) == 1\n\t\t\t && num_proc > proc_nr\n\t\t\t) {\n\t\t\t\tproc_nr = num_proc;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn proc_nr + 1;\n}\n\n## Example:\n\n Input code:\n__int64 sub_46A465()\n{\n  int v1; // [rsp+8h] [rbp-8h]\n  int fd; // [rsp+Ch] [rbp-4h]\n  int fda; // [rsp+Ch] [rbp-4h]\n\n  fd = open64(\"supervise/ok\", 2049);\n  if ( fd == -1 )\n  {\n    if ( *(_DWORD *)qword_75D400 == 19 )\n    {\n      if ( **(_BYTE **)&dest.c_iflag == 120 )\n        sub_46A438(\"runsv not running\");\n      else\n        sub_46A3E2(\"runsv not running\");\n      return 0LL;\n    }\n    else\n    {\n      sub_46A40A(\"can't open supervise/ok\");\n      return 0xFFFFFFFFLL;\n    }\n  }\n  else\n  {\n    close(fd);\n    fda = open64(\"supervise/status\", 2048);\n    if ( fda == -1 )\n    {\n      sub_46A40A(\"can't open supervise/status\");\n      return 0xFFFFFFFFLL;\n    }\n    else\n    {\n      v1 = read(fda, &dest.c_cc[23], 0x14uLL);\n      close(fda);\n      if ( v1 == -1 )\n      {\n        sub_46A40A(\"can't read supervise/status\");\n        return 0xFFFFFFFFLL;\n      }\n      else if ( v1 == 20 )\n      {\n        return 1LL;\n      }\n      else\n      {\n        *(_DWORD *)qword_75D400 = 0;\n        sub_46A40A(\"can't read supervise/status: bad format\");\n        return 0xFFFFFFFFLL;\n      }\n    }\n  }\n}\n\n\n Revised code:\nstatic int svstatus_get(void)\n{\n\tint fd, r;\n\n\tfd = open(\"supervise/ok\", O_WRONLY|O_NDELAY);\n\tif (fd == -1) {\n\t\tif (errno == ENODEV) {\n\t\t\t*acts == 'x' ? ok(\"runsv not running\")\n\t\t\t             : failx(\"runsv not running\");\n\t\t\treturn 0;\n\t\t}\n\t\twarn(\"can't open supervise/ok\");\n\t\treturn -1;\n\t}\n\tclose(fd);\n\tfd = open(\"supervise/status\", O_RDONLY|O_NDELAY);\n\tif (fd == -1) {\n\t\twarn(\"can't open supervise/status\");\n\t\treturn -1;\n\t}\n\tr = read(fd, &svstatus, 20);\n\tclose(fd);\n\tswitch (r) {\n\tcase 20:\n\t\tbreak;\n\tcase -1:\n\t\twarn(\"can't read supervise/status\");\n\t\treturn -1;\n\tdefault:\n\t\terrno = 0;\n\t\twarn(\"can't read supervise/status: bad format\");\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nFILE *sub_40EDC4()\n{\n  FILE *result; // rax\n  int v1; // [rsp+Ch] [rbp-14h]\n  FILE *stream; // [rsp+10h] [rbp-10h]\n  int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = 1;\n  result = sub_40982E(\"/etc/nologin\");\n  stream = result;\n  if ( result )\n  {\n    while ( 1 )\n    {\n      v1 = getc_unlocked(stream);\n      if ( v1 == -1 )\n        break;\n      if ( v1 == 10 )\n        sub_40A659(13);\n      sub_40A659(v1);\n      v3 = 0;\n    }\n    if ( v3 )\n      puts(\"\\r\\nSystem closed for routine maintenance\\r\");\n    fclose(stream);\n    sub_40A649();\n    tcdrain(1);\n    exit(1);\n  }\n  return result;\n}\n",
        "output": "static FILE *check_nologin_file()\n{\n\tFILE *stream;\n\tint c;\n\tint flag = 1;\n\n\tstream = fopen(\"/etc/nologin\", \"r\");\n\tif (stream)\n\t{\n\t\twhile (1)\n\t\t{\n\t\t\tc = getc(stream);\n\t\t\tif (c == EOF)\n\t\t\t\tbreak;\n\t\t\tif (c == '\\n')\n\t\t\t\tputchar('\\r');\n\t\t\tputchar(c);\n\t\t\tflag = 0;\n\t\t}\n\t\tif (flag)\n\t\t\tputs(\"\\r\\nSystem closed for routine maintenance\\r\");\n\t\tfclose(stream);\n\t\tfflush_all();\n\t\ttcdrain(1);\n\t\texit(1);\n\t}\n\treturn stream;\n}",
        "source_code": "if ENABLE_FEATURE_NOLOGIN\nstatic void die_if_nologin(void)\n{\n\tFILE *fp;\n\tint c;\n\tint empty = 1;\n\n\tfp = fopen_for_read(\"/etc/nologin\");\n\tif (!fp) /* assuming it does not exist */\n\t\treturn;\n\n\twhile ((c = getc(fp)) != EOF) {\n\t\tif (c == '\\n')\n\t\t\tbb_putchar('\\r');\n\t\tbb_putchar(c);\n\t\tempty = 0;\n\t}\n\tif (empty)\n\t\tputs(\"\\r\\nSystem closed for routine maintenance\\r\");\n\n\tfclose(fp);\n\tfflush_all();\n\t/* Users say that they do need this prior to exit: */\n\ttcdrain(STDOUT_FILENO);\n\texit(EXIT_FAILURE);\n}",
        "parsed_output": "static FILE *check_nologin_file()\n{\n\tFILE *stream;\n\tint c;\n\tint flag = 1;\n\n\tstream = fopen(\"/etc/nologin\", \"r\");\n\tif (stream)\n\t{\n\t\twhile (1)\n\t\t{\n\t\t\tc = getc(stream);\n\t\t\tif (c == EOF)\n\t\t\t\tbreak;\n\t\t\tif (c == '\\n')\n\t\t\t\tputchar('\\r');\n\t\t\tputchar(c);\n\t\t\tflag = 0;\n\t\t}\n\t\tif (flag)\n\t\t\tputs(\"\\r\\nSystem closed for routine maintenance\\r\");\n\t\tfclose(stream);\n\t\tfflush_all();\n\t\ttcdrain(1);\n\t\texit(1);\n\t}\n\treturn stream;\n}",
        "baseline_code_stripped": "FILE *sub_40EDC4()\n{\n  FILE *result; // rax\n  int v1; // [rsp+Ch] [rbp-14h]\n  FILE *stream; // [rsp+10h] [rbp-10h]\n  int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = 1;\n  result = sub_40982E(\"/etc/nologin\");\n  stream = result;\n  if ( result )\n  {\n    while ( 1 )\n    {\n      v1 = getc_unlocked(stream);\n      if ( v1 == -1 )\n        break;\n      if ( v1 == 10 )\n        sub_40A659(13);\n      sub_40A659(v1);\n      v3 = 0;\n    }\n    if ( v3 )\n      puts(\"\\r\\nSystem closed for routine maintenance\\r\");\n    fclose(stream);\n    sub_40A649();\n    tcdrain(1);\n    exit(1);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl die_if_nologin()\n{\n  int c; // [rsp+Ch] [rbp-14h]\n  FILE *fp; // [rsp+10h] [rbp-10h]\n  int empty; // [rsp+1Ch] [rbp-4h]\n\n  empty = 1;\n  fp = fopen_for_read(\"/etc/nologin\");\n  if ( fp )\n  {\n    while ( 1 )\n    {\n      c = getc_unlocked(fp);\n      if ( c == -1 )\n        break;\n      if ( c == 10 )\n        bb_putchar(13);\n      bb_putchar(c);\n      empty = 0;\n    }\n    if ( empty )\n      puts(\"\\r\\nSystem closed for routine maintenance\\r\");\n    fclose(fp);\n    fflush_all();\n    tcdrain(1);\n    exit(1);\n  }\n}\n",
        "similarity_score_unixcoder": 0.8483191728591919,
        "similarity_score_baseline_stripped": 0.6104728579521179,
        "similarity_score_baseline_debug": 0.849102795124054
    },
    {
        "func_name": "huft_free_all",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4FB84B(__int64 a1, _QWORD *a2)\n{\n  __int64 v2; // rdx\n  __int64 result; // rax\n\n  sub_4FB084(a1, 0);\n  v2 = *(_QWORD *)(a1 + 88);\n  result = *(_QWORD *)(a1 + 80);\n  *a2 = result;\n  a2[1] = v2;\n  return result;\n}\n\n\n Revised code:\nvoid FAST_FUNC md5_end(void *digest, md5_ctx_t *context)\n{\n\tunsigned idx, padLen;\n\tunsigned char bits[8];\n\tunsigned char padding[64];\n\n\t/* Add padding followed by original length. */\n\tmemset(padding, 0, sizeof(padding));\n\tpadding[0] = 0x80;\n\t/* save number of bits */\n\tmemcpy32_cpu2le(bits, context->count, 8);\n\t/* pad out to 56 mod 64 */\n\tidx = (context->count[0] >> 3) & 0x3f;\n\tpadLen = (idx < 56) ? (56 - idx) : (120 - idx);\n\tmd5_hash(padding, padLen, context);\n\t/* append length (before padding) */\n\tmd5_hash(bits, 8, context);\n\n\t/* Store state in digest */\n\tmemcpy32_cpu2le(digest, context->state, 16);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4BA259(__int64 a1)\n{\n  __int64 result; // rax\n\n  *(_DWORD *)(a1 + 8) = sub_4F7534(\n                          *(unsigned int *)(a1 + 8),\n                          *(_QWORD *)(a1 + 24),\n                          *(unsigned int *)(a1 + 16),\n                          *(_QWORD *)(a1 + 32));\n  result = a1;\n  *(_QWORD *)a1 += *(unsigned int *)(a1 + 16);\n  return result;\n}\n\n\n Revised code:\nstatic void calculate_gunzip_crc(STATE_PARAM_ONLY)\n{\n\tgunzip_crc = crc32_block_endian0(gunzip_crc, gunzip_window, gunzip_outbuf_count, gunzip_crc_table);\n\tgunzip_bytes_out += gunzip_outbuf_count;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4FB7CE(__int64 a1)\n{\n  __int64 result; // rax\n\n  *(_DWORD *)(a1 + 80) = 1732584193;\n  *(_DWORD *)(a1 + 84) = -271733879;\n  *(_DWORD *)(a1 + 88) = -1732584194;\n  *(_DWORD *)(a1 + 92) = 271733878;\n  *(_QWORD *)(a1 + 72) = 0LL;\n  result = a1;\n  *(_QWORD *)(a1 + 64) = sub_4FB13E;\n  return result;\n}\n\n\n Revised code:\nvoid FAST_FUNC md5_begin(md5_ctx_t *context)\n{\n\tcontext->count[0] = context->count[1] = 0;\n\t/* Load magic initialization constants.  */\n\tcontext->state[0] = 0x67452301;\n\tcontext->state[1] = 0xefcdab89;\n\tcontext->state[2] = 0x98badcfe;\n\tcontext->state[3] = 0x10325476;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4B882D(__int64 a1)\n{\n  __int64 result; // rax\n\n  sub_4B87F0(*(_QWORD *)(a1 + 96));\n  sub_4B87F0(*(_QWORD *)(a1 + 104));\n  *(_QWORD *)(a1 + 96) = 0LL;\n  result = a1;\n  *(_QWORD *)(a1 + 104) = 0LL;\n  return result;\n}\n",
        "output": "void reset_values(__int64 a1)\n{\n  sub_4B87F0(*(_QWORD *)(a1 + 96));\n  sub_4B87F0(*(_QWORD *)(a1 + 104));\n  *(_QWORD *)(a1 + 96) = 0LL;\n  *(_QWORD *)(a1 + 104) = 0LL;\n}",
        "source_code": "static void huft_free_all(STATE_PARAM_ONLY)\n{\n\thuft_free(inflate_codes_tl);\n\thuft_free(inflate_codes_td);\n\tinflate_codes_tl = NULL;\n\tinflate_codes_td = NULL;\n}",
        "parsed_output": "void reset_values(__int64 a1)\n{\n  sub_4B87F0(*(_QWORD *)(a1 + 96));\n  sub_4B87F0(*(_QWORD *)(a1 + 104));\n  *(_QWORD *)(a1 + 96) = 0LL;\n  *(_QWORD *)(a1 + 104) = 0LL;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4B882D(__int64 a1)\n{\n  __int64 result; // rax\n\n  sub_4B87F0(*(_QWORD *)(a1 + 96));\n  sub_4B87F0(*(_QWORD *)(a1 + 104));\n  *(_QWORD *)(a1 + 96) = 0LL;\n  result = a1;\n  *(_QWORD *)(a1 + 104) = 0LL;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl huft_free_all(state_t_0 *state)\n{\n  huft_free(state->inflate_codes_tl);\n  huft_free(state->inflate_codes_td);\n  state->inflate_codes_tl = 0LL;\n  state->inflate_codes_td = 0LL;\n}\n",
        "similarity_score_unixcoder": 0.3289335072040558,
        "similarity_score_baseline_stripped": 0.25724396109580994,
        "similarity_score_baseline_debug": 0.8830578923225403
    },
    {
        "func_name": "get_fill",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_50906E(_BYTE *a1, unsigned int a2)\n{\n  int v3; // [rsp+0h] [rbp-1Ch]\n  unsigned int v4; // [rsp+10h] [rbp-Ch]\n  int v5; // [rsp+14h] [rbp-8h]\n  int i; // [rsp+18h] [rbp-4h]\n\n  v3 = a2;\n  v4 = a2;\n  if ( a2 > 0x7F )\n  {\n    for ( i = 2; v4 > 0x7FF && i <= 5; ++i )\n      v4 >>= 5;\n    v5 = i;\n    while ( --v5 )\n    {\n      a1[v5] = v3 & 0x3F | 0x80;\n      v3 >>= 6;\n    }\n    *a1 = v3 | (16128 >> i);\n    return i;\n  }\n  else\n  {\n    *a1 = a2;\n    return 1LL;\n  }\n}\n\n\n Revised code:\nendif\n\nstatic size_t wcrtomb_internal(char *s, wchar_t wc)\n{\n\tint n, i;\n\tuint32_t v = wc;\n\n\tif (v <= 0x7f) {\n\t\t*s = v;\n\t\treturn 1;\n\t}\n\n\t/* RFC 3629 says that Unicode ends at 10FFFF,\n\t * but we cover entire 32 bits */\n\n\t/* 4000000-FFFFFFFF -> 111111tt 10tttttt 10zzzzzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\t/* 200000-3FFFFFF -> 111110tt 10zzzzzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\t/* 10000-1FFFFF -> 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\t/* 800-FFFF -> 1110yyyy 10yyyyxx 10xxxxxx */\n\t/* 80-7FF -> 110yyyxx 10xxxxxx */\n\n\t/* How many bytes do we need? */\n\tn = 2;\n\t/* (0x80000000+ would result in n = 7, limiting n to 6) */\n\twhile (v >= 0x800 && n < 6) {\n\t\tv >>= 5;\n\t\tn++;\n\t}\n\t/* Fill bytes n-1..1 */\n\ti = n;\n\twhile (--i) {\n\t\ts[i] = (wc & 0x3f) | 0x80;\n\t\twc >>= 6;\n\t}\n\t/* Fill byte 0 */\n\ts[0] = wc | (uint8_t)(0x3f00 >> n);\n\treturn n;\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_45845B(const void *a1, int a2, int a3, __int64 a4, int a5)\n{\n  unsigned int v7; // [rsp+4h] [rbp-2Ch]\n  char *s; // [rsp+20h] [rbp-10h]\n  char *i; // [rsp+28h] [rbp-8h]\n\n  sub_458394(a1, a2);\n  s = (char *)sub_4582F6();\n  if ( s )\n  {\n    memset(s, 0, 0x24uLL);\n    if ( a4 )\n    {\n      v7 = a5 + 1;\n      if ( v7 > 0x14 )\n        v7 = 20;\n      for ( i = (char *)sub_507FC0(s + 14, a4, (int)v7); *i; ++i )\n      {\n        if ( *i <= 31 || *i == 127 )\n          *i = 94;\n      }\n    }\n    if ( a1 )\n      memcpy(s + 8, a1, 6uLL);\n    *((_DWORD *)s + 1) = a2;\n    *(_DWORD *)s = a3 + time(0LL);\n  }\n  return s;\n}\n\n\n Revised code:\nFAST_FUNC add_lease(\n\t\tconst uint8_t *chaddr, uint32_t yiaddr,\n\t\tleasetime_t leasetime,\n\t\tconst char *hostname, int hostname_len)\n{\n\tstruct dyn_lease *oldest;\n\n\t/* clean out any old ones */\n\tclear_leases(chaddr, yiaddr);\n\n\toldest = oldest_expired_lease();\n\n\tif (oldest) {\n\t\tmemset(oldest, 0, sizeof(*oldest));\n\t\tif (hostname) {\n\t\t\tchar *p;\n\n\t\t\thostname_len++; /* include NUL */\n\t\t\tif (hostname_len > sizeof(oldest->hostname))\n\t\t\t\thostname_len = sizeof(oldest->hostname);\n\t\t\tp = safe_strncpy(oldest->hostname, hostname, hostname_len);\n\t\t\t/* sanitization (s/non-ASCII/^/g) */\n\t\t\twhile (*p) {\n\t\t\t\tif (*p < ' ' || *p > 126)\n\t\t\t\t\t*p = '^';\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tif (chaddr)\n\t\t\tmemcpy(oldest->lease_mac, chaddr, 6);\n\t\toldest->lease_nip = yiaddr;\n\t\toldest->expires = time(NULL) + leasetime;\n\t}\n\n\treturn oldest;\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_4DA65D(const char *a1, __int64 a2)\n{\n  char *ptr; // [rsp+10h] [rbp-10h]\n  char *s1; // [rsp+18h] [rbp-8h]\n  char *s1a; // [rsp+18h] [rbp-8h]\n  char *s1b; // [rsp+18h] [rbp-8h]\n\n  ptr = sub_40A11F(a1, a2);\n  s1 = sub_40941B(ptr);\n  if ( s1 != ptr )\n  {\n    if ( *s1 == 109 && s1[1] == 100 )\n    {\n      s1[2] = 0;\n      return ptr;\n    }\n    if ( !strncmp(s1, \"rd/\", 3uLL) )\n    {\n      s1a = s1 + 3;\n      if ( *s1a == 99 && (unsigned __int8)(s1a[1] - 48) <= 9u && s1a[2] == 100 && (unsigned __int8)(s1a[3] - 48) <= 9u )\n      {\n        s1a[4] = 0;\n        return ptr;\n      }\n    }\n    else if ( (*s1 == 104 || *s1 == 115) && s1[1] == 100 )\n    {\n      s1b = s1 + 2;\n      if ( (unsigned __int8)(*s1b - 48) <= 9u )\n        ++s1b;\n      if ( (unsigned __int8)((*s1b | 0x20) - 97) <= 0x19u )\n      {\n        s1b[1] = 0;\n        return ptr;\n      }\n    }\n  }\n  free(ptr);\n  return 0LL;\n}\n\n\n Revised code:\nendif\n\nstatic char *base_device(const char *device)\n{\n\tchar *str, *cp;\n#if ENABLE_FEATURE_DEVFS\n\tconst char *const *hier;\n\tconst char *disk;\n\tint len;\n#endif\n\tstr = xstrdup(device);\n\n\t/* Skip over \"/dev/\"; if it's not present, give up */\n\tcp = skip_dev_pfx(str);\n\tif (cp == str)\n\t\tgoto errout;\n\n\t/*\n\t * For md devices, we treat them all as if they were all\n\t * on one disk, since we don't know how to parallelize them.\n\t */\n\tif (cp[0] == 'm' && cp[1] == 'd') {\n\t\tcp[2] = 0;\n\t\treturn str;\n\t}\n\n\t/* Handle DAC 960 devices */\n\tif (strncmp(cp, \"rd/\", 3) == 0) {\n\t\tcp += 3;\n\t\tif (cp[0] != 'c' || !isdigit(cp[1])\n\t\t || cp[2] != 'd' || !isdigit(cp[3]))\n\t\t\tgoto errout;\n\t\tcp[4] = 0;\n\t\treturn str;\n\t}\n\n\t/* Now let's handle /dev/hd* and /dev/sd* devices.... */\n\tif ((cp[0] == 'h' || cp[0] == 's') && cp[1] == 'd') {\n\t\tcp += 2;\n\t\t/* If there's a single number after /dev/hd, skip it */\n\t\tif (isdigit(*cp))\n\t\t\tcp++;\n\t\t/* What follows must be an alpha char, or give up */\n\t\tif (!isalpha(*cp))\n\t\t\tgoto errout;\n\t\tcp[1] = 0;\n\t\treturn str;\n\t}\n\n#if ENABLE_FEATURE_DEVFS\n\t/* Now let's handle devfs (ugh) names */\n\tlen = 0;\n\tif (strncmp(cp, \"ide/\", 4) == 0)\n\t\tlen = 4;\n\tif (strncmp(cp, \"scsi/\", 5) == 0)\n\t\tlen = 5;\n\tif (len) {\n\t\tcp += len;\n\t\t/*\n\t\t * Now we proceed down the expected devfs hierarchy.\n\t\t * i.e., .../host1/bus2/target3/lun4/...\n\t\t * If we don't find the expected token, followed by\n\t\t * some number of digits at each level, abort.\n\t\t */\n\t\tfor (hier = devfs_hier; *hier; hier++) {\n\t\t\tlen = strlen(*hier);\n\t\t\tif (strncmp(cp, *hier, len) != 0)\n\t\t\t\tgoto errout;\n\t\t\tcp += len;\n\t\t\twhile (*cp != '/' && *cp != 0) {\n\t\t\t\tif (!isdigit(*cp))\n\t\t\t\t\tgoto errout;\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tcp++;\n\t\t}\n\t\tcp[-1] = 0;\n\t\treturn str;\n\t}\n\n\t/* Now handle devfs /dev/disc or /dev/disk names */\n\tdisk = 0;\n\tif (strncmp(cp, \"discs/\", 6) == 0)\n\t\tdisk = \"disc\";\n\telse if (strncmp(cp, \"disks/\", 6) == 0)\n\t\tdisk = \"disk\";\n\tif (disk) {\n\t\tcp += 6;\n\t\tif (strncmp(cp, disk, 4) != 0)\n\t\t\tgoto errout;\n\t\tcp += 4;\n\t\twhile (*cp != '/' && *cp != 0) {\n\t\t\tif (!isdigit(*cp))\n\t\t\t\tgoto errout;\n\t\t\tcp++;\n\t\t}\n\t\t*cp = 0;\n\t\treturn str;\n\t}\n#endif\n errout:\n\tfree(str);\n\treturn NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_428EE6(char *a1, const void *a2, int a3)\n{\n  char *s; // [rsp+18h] [rbp-18h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  memset(a1, 255, 6uLL);\n  if ( !a3 )\n    memcpy(a1, a2, 6uLL);\n  memcpy(a1 + 6, a2, 6uLL);\n  a1[12] = 8;\n  s = a1 + 14;\n  a1[13] = 66;\n  memset(a1 + 14, 255, 6uLL);\n  for ( i = 0; i <= 15; ++i )\n  {\n    s += 6;\n    memcpy(s, a2, 6uLL);\n  }\n  return 116LL;\n}\n",
        "output": "static void initialize_array(char *array, const void *data, int size)\n{\n    memset(array, 255, 6);\n    if (!size)\n        memcpy(array, data, 6);\n    memcpy(array + 6, data, 6);\n    array[12] = 8;\n    char *s = array + 14;\n    array[13] = 66;\n    memset(array + 14, 255, 6);\n    for (int i = 0; i <= 15; ++i)\n    {\n        s += 6;\n        memcpy(s, data, 6);\n    }\n}",
        "source_code": "static int get_fill(unsigned char *pkt, struct ether_addr *eaddr, int broadcast)\n{\n\tint i;\n\tunsigned char *station_addr = eaddr->ether_addr_octet;\n\n\tmemset(pkt, 0xff, 6);\n\tif (!broadcast)\n\t\tmemcpy(pkt, station_addr, 6);\n\tpkt += 6;\n\n\tmemcpy(pkt, station_addr, 6); /* 6 */\n\tpkt += 6;\n\n\t*pkt++ = 0x08; /* 12 */ /* Or 0x0806 for ARP, 0x8035 for RARP */\n\t*pkt++ = 0x42; /* 13 */\n\n\tmemset(pkt, 0xff, 6); /* 14 */\n\n\tfor (i = 0; i < 16; ++i) {\n\t\tpkt += 6;\n\t\tmemcpy(pkt, station_addr, 6); /* 20,26,32,... */\n\t}\n\n\treturn 20 + 16*6; /* length of packet */\n}",
        "parsed_output": "static void initialize_array(char *array, const void *data, int size)\n{\n    memset(array, 255, 6);\n    if (!size)\n        memcpy(array, data, 6);\n    memcpy(array + 6, data, 6);\n    array[12] = 8;\n    char *s = array + 14;\n    array[13] = 66;\n    memset(array + 14, 255, 6);\n    for (int i = 0; i <= 15; ++i)\n    {\n        s += 6;\n        memcpy(s, data, 6);\n    }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_428EE6(char *a1, const void *a2, int a3)\n{\n  char *s; // [rsp+18h] [rbp-18h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  memset(a1, 255, 6uLL);\n  if ( !a3 )\n    memcpy(a1, a2, 6uLL);\n  memcpy(a1 + 6, a2, 6uLL);\n  a1[12] = 8;\n  s = a1 + 14;\n  a1[13] = 66;\n  memset(a1 + 14, 255, 6uLL);\n  for ( i = 0; i <= 15; ++i )\n  {\n    s += 6;\n    memcpy(s, a2, 6uLL);\n  }\n  return 116LL;\n}\n",
        "baseline_code_debug": "int __cdecl get_fill(unsigned __int8 *pkt, ether_addr *eaddr, int broadcast)\n{\n  unsigned __int8 *pkta; // [rsp+18h] [rbp-18h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  memset(pkt, 255, 6uLL);\n  if ( !broadcast )\n    memcpy(pkt, eaddr, 6uLL);\n  memcpy(pkt + 6, eaddr, 6uLL);\n  pkt[12] = 8;\n  pkta = pkt + 14;\n  pkt[13] = 66;\n  memset(pkt + 14, 255, 6uLL);\n  for ( i = 0; i <= 15; ++i )\n  {\n    pkta += 6;\n    memcpy(pkta, eaddr, 6uLL);\n  }\n  return 116;\n}\n",
        "similarity_score_unixcoder": 0.650918185710907,
        "similarity_score_baseline_stripped": 0.617342472076416,
        "similarity_score_baseline_debug": 0.8470082879066467
    },
    {
        "func_name": "rtnl_send",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_42FB55(const char *a1, int a2)\n{\n  char v3[16]; // [rsp+10h] [rbp-30h] BYREF\n  int v4; // [rsp+20h] [rbp-20h]\n\n  v4 = a2;\n  return sub_42FA47(0x8922u, v3, a1);\n}\n\n\n Revised code:\nstatic int set_mtu(char *ifname, int mtu)\n{\n\tstruct ifreq ifr;\n\n\tifr.ifr_mtu = mtu;\n\treturn set_ifrname_and_do_ioctl(SIOCSIFMTU, &ifr, ifname);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_42FB81(const char *a1, __int16 a2)\n{\n  char v3[16]; // [rsp+10h] [rbp-30h] BYREF\n  __int16 v4; // [rsp+20h] [rbp-20h]\n\n  v4 = a2;\n  return sub_42FA47(0x8914u, v3, a1);\n}\n\n\n Revised code:\nstatic int set_if_flags(char *ifname, int flags)\n{\n\tstruct ifreq ifr;\n\n\tifr.ifr_flags = flags;\n\treturn set_ifrname_and_do_ioctl(SIOCSIFFLAGS, &ifr, ifname);\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_464629(const char *a1, unsigned int a2, unsigned int a3, int a4)\n{\n  char s[32]; // [rsp+20h] [rbp-20h] BYREF\n\n  sprintf(s, \"{%.*s}\", 14, a1);\n  return sub_463FF0(s, a2, a3, a4);\n}\n\n\n Revised code:\nif ENABLE_FEATURE_SHOW_THREADS\nstatic void handle_thread(const char *comm, pid_t pid, pid_t ppid, uid_t uid)\n{\n\tchar threadname[COMM_LEN + 2];\n\tsprintf(threadname, \"{%.*s}\", COMM_LEN - 2, comm);\n\tadd_proc(threadname, pid, ppid, uid/*, 1*/);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nssize_t __fastcall sub_450FC2(int *a1, const void *a2, int a3)\n{\n  __int16 s[6]; // [rsp+24h] [rbp-Ch] BYREF\n\n  memset(s, 0, sizeof(s));\n  s[0] = 16;\n  return sub_40AA48(*a1, a2, a3, (const struct sockaddr *)s, 0xCu);\n}\n",
        "output": "static ssize_t send_data(int *socket, const void *data, int length)\n{\n  __int16 buffer[6]; // [rsp+24h] [rbp-Ch] BYREF\n\n  memset(buffer, 0, sizeof(buffer));\n  buffer[0] = 16;\n  return send_packet(*socket, data, length, (const struct sockaddr *)buffer, 0xCu);\n}",
        "source_code": "int FAST_FUNC rtnl_send(struct rtnl_handle *rth, char *buf, int len)\n{\n\tstruct sockaddr_nl nladdr;\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tnladdr.nl_family = AF_NETLINK;\n\n\treturn xsendto(rth->fd, buf, len, (struct sockaddr*)&nladdr, sizeof(nladdr));\n}",
        "parsed_output": "static ssize_t send_data(int *socket, const void *data, int length)\n{\n  __int16 buffer[6]; // [rsp+24h] [rbp-Ch] BYREF\n\n  memset(buffer, 0, sizeof(buffer));\n  buffer[0] = 16;\n  return send_packet(*socket, data, length, (const struct sockaddr *)buffer, 0xCu);\n}",
        "baseline_code_stripped": "ssize_t __fastcall sub_450FC2(int *a1, const void *a2, int a3)\n{\n  __int16 s[6]; // [rsp+24h] [rbp-Ch] BYREF\n\n  memset(s, 0, sizeof(s));\n  s[0] = 16;\n  return sub_40AA48(*a1, a2, a3, (const struct sockaddr *)s, 0xCu);\n}\n",
        "baseline_code_debug": "int __cdecl rtnl_send(rtnl_handle *rth, char *buf, int len)\n{\n  sockaddr_nl nladdr; // [rsp+24h] [rbp-Ch] BYREF\n\n  memset(&nladdr, 0, sizeof(nladdr));\n  nladdr.nl_family = 16;\n  return xsendto(rth->fd, buf, len, (const sockaddr *)&nladdr, 0xCu);\n}\n",
        "similarity_score_unixcoder": 0.5832493305206299,
        "similarity_score_baseline_stripped": 0.5425524115562439,
        "similarity_score_baseline_debug": 0.8844311833381653
    },
    {
        "func_name": "act",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_46328D(char *a1, int a2, __int64 a3)\n{\n  return sprintf(a1, \"%*u\", a2, *(unsigned int *)(a3 + 88));\n}\n\n\n Revised code:\nstatic void func_pid(char *buf, int size, const procps_status_t *ps)\n{\n\tsprintf(buf, \"%*u\", size, ps->pid);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_4632F9(char *a1, int a2, __int64 a3)\n{\n  return sprintf(a1, \"%*u\", a2, *(unsigned int *)(a3 + 96));\n}\n\n\n Revised code:\nstatic void func_pgid(char *buf, int size, const procps_status_t *ps)\n{\n\tsprintf(buf, \"%*u\", size, ps->pgid);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_4634D4(char *a1, int a2, __int64 a3)\n{\n  return sprintf(a1, \"%*d\", a2, *(unsigned int *)(a3 + 120));\n}\n\n\n Revised code:\nstatic void func_nice(char *buf, int size, const procps_status_t *ps)\n{\n\tsprintf(buf, \"%*d\", size, ps->niceness);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_461320(unsigned int a1, const char *a2, int a3)\n{\n  if ( ident[1] != 103 )\n    return kill(a1, a3);\n  if ( (dword_75D450 & 2) != 0 )\n    return printf(\"%d %s\\n\", a1, a2);\n  return printf(\"%d\\n\", a1);\n}\n",
        "output": "static void handle_process(unsigned int pid, const char *message, int signal)\n{\n  if (ident[1] != 103)\n    kill(pid, signal);\n  else if (dword_75D450 & 2)\n    printf(\"%d %s\\n\", pid, message);\n  else\n    printf(\"%d\\n\", pid);\n}",
        "source_code": "static int FAST_FUNC act(const char *file, struct stat *statbuf, void *args UNUSED_PARAM, int depth)\n{\n\tif (depth == 1)\n\t\treturn TRUE;\n\n\tif (depth == 2\n\t && (  !(statbuf->st_mode & (S_IFREG | S_IFLNK))\n\t    || invalid_name(file)\n\t    || (!list_mode && access(file, X_OK) != 0))\n\t) {\n\t\treturn SKIP;\n\t}\n\n\tnames = xrealloc_vector(names, 4, cur);\n\tnames[cur++] = xstrdup(file);\n\t/*names[cur] = NULL; - xrealloc_vector did it */\n\n\treturn TRUE;\n}",
        "parsed_output": "static void handle_process(unsigned int pid, const char *message, int signal)\n{\n  if (ident[1] != 103)\n    kill(pid, signal);\n  else if (dword_75D450 & 2)\n    printf(\"%d %s\\n\", pid, message);\n  else\n    printf(\"%d\\n\", pid);\n}",
        "baseline_code_stripped": "int __fastcall sub_461320(unsigned int a1, const char *a2, int a3)\n{\n  if ( ident[1] != 103 )\n    return kill(a1, a3);\n  if ( (dword_75D450 & 2) != 0 )\n    return printf(\"%d %s\\n\", a1, a2);\n  return printf(\"%d\\n\", a1);\n}\n",
        "baseline_code_debug": "void __cdecl act(unsigned int pid, char *cmd, int signo)\n{\n  if ( applet_name[1] == 103 )\n  {\n    if ( (option_mask32 & 2) != 0 )\n      printf(\"%d %s\\n\", pid, cmd);\n    else\n      printf(\"%d\\n\", pid);\n  }\n  else\n  {\n    kill(pid, signo);\n  }\n}\n",
        "similarity_score_unixcoder": 0.47874361276626587,
        "similarity_score_baseline_stripped": 0.5310578942298889,
        "similarity_score_baseline_debug": 0.571358859539032
    },
    {
        "func_name": "read_staticlease",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_43A44B(const char *a1)\n{\n  char s[4]; // [rsp+10h] [rbp-60h] BYREF\n  int v3; // [rsp+14h] [rbp-5Ch]\n  int v4; // [rsp+18h] [rbp-58h]\n\n  memset(s, 0, 0x60uLL);\n  if ( (unsigned int)sub_43A1E5((__int64)s, a1) )\n    return 1LL;\n  sub_43A2EA((__int64)s, (const char *)*(&off_519F20 + v4), \"tcp\", v3);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC tcp_do_one(char *line)\n{\n\tstruct inet_params param;\n\n\tmemset(&param, 0, sizeof(param));\n\tif (scan_inet_proc_line(&param, line))\n\t\treturn 1;\n\n\tprint_inet_line(&param, tcp_state[param.state], \"tcp\", param.rem_port);\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_450D10(const char **a1)\n{\n  const char *v1; // rax\n  uint32_t v3[10]; // [rsp+10h] [rbp-40h] BYREF\n  char v4; // [rsp+39h] [rbp-17h]\n\n  sub_44F8E2(a1, 35312, v3);\n  switch ( v4 )\n  {\n    case 41:\n      if ( LOBYTE(v3[0]) )\n        v1 = (const char *)v3;\n      else\n        v1 = \"sit0\";\n      break;\n    case 47:\n      if ( LOBYTE(v3[0]) )\n        v1 = (const char *)v3;\n      else\n        v1 = \"gre0\";\n      break;\n    case 4:\n      if ( LOBYTE(v3[0]) )\n        v1 = (const char *)v3;\n      else\n        v1 = \"tunl0\";\n      break;\n    default:\n      sub_450A1E((__int64)v3);\n      return 0LL;\n  }\n  if ( (unsigned int)sub_44F731(v1, (__int64)v3) )\n    return 0xFFFFFFFFLL;\n  sub_450589((__int64)v3);\n  sub_40A659(10);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int do_show(char **argv)\n{\n\tint err;\n\tstruct ip_tunnel_parm p;\n\n\tparse_args(argv, SIOCGETTUNNEL, &p);\n\n\tswitch (p.iph.protocol) {\n\tcase IPPROTO_IPIP:\n\t\terr = do_get_ioctl(p.name[0] ? p.name : \"tunl0\", &p);\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\terr = do_get_ioctl(p.name[0] ? p.name : \"gre0\", &p);\n\t\tbreak;\n\tcase IPPROTO_IPV6:\n\t\terr = do_get_ioctl(p.name[0] ? p.name : \"sit0\", &p);\n\t\tbreak;\n\tdefault:\n\t\tdo_tunnels_list(&p);\n\t\treturn 0;\n\t}\n\tif (err)\n\t\treturn -1;\n\n\tprint_tunnel(&p);\n\tbb_putchar('\\n');\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4318BD(const char *a1)\n{\n  uint32_t v2; // eax\n  struct in_addr inp; // [rsp+14h] [rbp-Ch] BYREF\n  unsigned int v4; // [rsp+18h] [rbp-8h]\n  unsigned int v5; // [rsp+1Ch] [rbp-4h]\n\n  if ( !inet_aton(a1, &inp) )\n    return 0xFFFFFFFFLL;\n  v2 = ntohl(inp.s_addr);\n  v4 = ~v2;\n  if ( (~v2 & -v2) != 0 )\n    return 0xFFFFFFFFLL;\n  v5 = 32;\n  while ( v4 )\n  {\n    v4 >>= 1;\n    --v5;\n  }\n  return v5;\n}\n\n\n Revised code:\nif ENABLE_FEATURE_IFUPDOWN_IP\nstatic int count_netmask_bits(const char *dotted_quad)\n{\n//\tint result;\n//\tunsigned a, b, c, d;\n//\t/* Found a netmask...  Check if it is dotted quad */\n//\tif (sscanf(dotted_quad, \"%u.%u.%u.%u\", &a, &b, &c, &d) != 4)\n//\t\treturn -1;\n//\tif ((a|b|c|d) >> 8)\n//\t\treturn -1; /* one of numbers is >= 256 */\n//\td |= (a << 24) | (b << 16) | (c << 8); /* IP */\n//\td = ~d; /* 11110000 -> 00001111 */\n\n\t/* Shorter version */\n\tint result;\n\tstruct in_addr ip;\n\tunsigned d;\n\n\tif (inet_aton(dotted_quad, &ip) == 0)\n\t\treturn -1; /* malformed dotted IP */\n\td = ntohl(ip.s_addr); /* IP in host order */\n\td = ~d; /* 11110000 -> 00001111 */\n\tif (d & (d+1)) /* check that it is in 00001111 form */\n\t\treturn -1; /* no it is not */\n\tresult = 32;\n\twhile (d) {\n\t\td >>= 1;\n\t\tresult--;\n\t}\n\treturn result;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_457D21(char *a1, __int64 a2)\n{\n  unsigned int v3; // [rsp+1Ch] [rbp-24h] BYREF\n  struct ether_addr addr; // [rsp+22h] [rbp-1Eh] BYREF\n  char *s; // [rsp+28h] [rbp-18h] BYREF\n  char *v6; // [rsp+30h] [rbp-10h]\n  char *asc; // [rsp+38h] [rbp-8h]\n\n  s = a1;\n  asc = strtok_r(a1, \" \\t\", &s);\n  if ( !asc || !ether_aton_r(asc, &addr) )\n    return 0LL;\n  v6 = strtok_r(0LL, \" \\t\", &s);\n  if ( !v6 || !(unsigned int)sub_459D25(v6, &v3) )\n    return 0LL;\n  sub_4593BC(a2, &addr, v3);\n  sub_4594BA(a2);\n  return 1LL;\n}\n",
        "output": "static int process_input(char *input, int64_t param)\n{\n\tunsigned int v3;\n\tstruct ether_addr addr;\n\tchar *s;\n\tchar *v6;\n\tchar *asc;\n\n\ts = input;\n\tasc = strtok_r(input, \" \\t\", &s);\n\tif (!asc || !ether_aton_r(asc, &addr))\n\t\treturn 0;\n\tv6 = strtok_r(0, \" \\t\", &s);\n\tif (!v6 || !process_v6(v6, &v3))\n\t\treturn 0;\n\tprocess_addr(param, &addr, v3);\n\tprocess_v4(param);\n\treturn 1;\n}",
        "source_code": "static int FAST_FUNC read_staticlease(const char *const_line, void *arg)\n{\n\tchar *line;\n\tchar *mac_string;\n\tchar *ip_string;\n\tstruct ether_addr mac_bytes; /* it's \"struct { uint8_t mac[6]; }\" */\n\tuint32_t nip;\n\n\t/* Read mac */\n\tline = (char *) const_line;\n\tmac_string = strtok_r(line, \" \\t\", &line);\n\tif (!mac_string || !ether_aton_r(mac_string, &mac_bytes))\n\t\treturn 0;\n\n\t/* Read ip */\n\tip_string = strtok_r(NULL, \" \\t\", &line);\n\tif (!ip_string || !udhcp_str2nip(ip_string, &nip))\n\t\treturn 0;\n\n\tadd_static_lease(arg, (uint8_t*) &mac_bytes, nip);\n\n\tlog_static_leases(arg);\n\n\treturn 1;\n}",
        "parsed_output": "static int process_input(char *input, int64_t param)\n{\n\tunsigned int v3;\n\tstruct ether_addr addr;\n\tchar *s;\n\tchar *v6;\n\tchar *asc;\n\n\ts = input;\n\tasc = strtok_r(input, \" \\t\", &s);\n\tif (!asc || !ether_aton_r(asc, &addr))\n\t\treturn 0;\n\tv6 = strtok_r(0, \" \\t\", &s);\n\tif (!v6 || !process_v6(v6, &v3))\n\t\treturn 0;\n\tprocess_addr(param, &addr, v3);\n\tprocess_v4(param);\n\treturn 1;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_457D21(char *a1, __int64 a2)\n{\n  unsigned int v3; // [rsp+1Ch] [rbp-24h] BYREF\n  struct ether_addr addr; // [rsp+22h] [rbp-1Eh] BYREF\n  char *s; // [rsp+28h] [rbp-18h] BYREF\n  char *v6; // [rsp+30h] [rbp-10h]\n  char *asc; // [rsp+38h] [rbp-8h]\n\n  s = a1;\n  asc = strtok_r(a1, \" \\t\", &s);\n  if ( !asc || !ether_aton_r(asc, &addr) )\n    return 0LL;\n  v6 = strtok_r(0LL, \" \\t\", &s);\n  if ( !v6 || !(unsigned int)sub_459D25(v6, &v3) )\n    return 0LL;\n  sub_4593BC(a2, &addr, v3);\n  sub_4594BA(a2);\n  return 1LL;\n}\n",
        "baseline_code_debug": "int __cdecl read_staticlease(const char *const_line, void *arg)\n{\n  uint32_t nip; // [rsp+1Ch] [rbp-24h] BYREF\n  ether_addr mac_bytes; // [rsp+22h] [rbp-1Eh] BYREF\n  char *line; // [rsp+28h] [rbp-18h] BYREF\n  char *ip_string; // [rsp+30h] [rbp-10h]\n  char *mac_string; // [rsp+38h] [rbp-8h]\n\n  line = (char *)const_line;\n  mac_string = strtok_r((char *)const_line, \" \\t\", &line);\n  if ( !mac_string || !ether_aton_r(mac_string, &mac_bytes) )\n    return 0;\n  ip_string = strtok_r(0LL, \" \\t\", &line);\n  if ( !ip_string || !udhcp_str2nip(ip_string, &nip) )\n    return 0;\n  add_static_lease((static_lease **)arg, mac_bytes.ether_addr_octet, nip);\n  log_static_leases((static_lease **)arg);\n  return 1;\n}\n",
        "similarity_score_unixcoder": 0.5993533730506897,
        "similarity_score_baseline_stripped": 0.5703656673431396,
        "similarity_score_baseline_debug": 0.8890446424484253
    },
    {
        "func_name": "decode_format_string",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47A87E(const char **a1, __int64 a2)\n{\n  const char **v2; // rax\n  char **v3; // rbx\n  __int64 result; // rax\n  const char **v5; // [rsp+8h] [rbp-38h]\n  char **v6; // [rsp+18h] [rbp-28h]\n  int i; // [rsp+24h] [rbp-1Ch]\n  char **v8; // [rsp+28h] [rbp-18h]\n\n  v5 = a1;\n  for ( i = 0; a1[i]; ++i )\n    ;\n  v6 = (char **)sub_40A05F(8LL * (i + 1), a2);\n  v8 = v6;\n  while ( *v5 )\n  {\n    v2 = v5++;\n    v3 = v8++;\n    *v3 = sub_40A11F(*v2, a2);\n  }\n  *v8 = 0LL;\n  sub_46F1BA(qword_75D420);\n  *(_BYTE *)(qword_75D420 + 12) = 1;\n  *(_DWORD *)qword_75D420 = i;\n  *(_QWORD *)(qword_75D420 + 16) = v6;\n  *(_DWORD *)(qword_75D420 + 4) = 1;\n  result = qword_75D420;\n  *(_DWORD *)(qword_75D420 + 8) = -1;\n  return result;\n}\n\n\n Revised code:\nstatic void\nsetparam(char **argv)\n{\n\tchar **newparam;\n\tchar **ap;\n\tint nparam;\n\n\tfor (nparam = 0; argv[nparam]; nparam++)\n\t\tcontinue;\n\tap = newparam = ckmalloc((nparam + 1) * sizeof(*ap));\n\twhile (*argv) {\n\t\t*ap++ = ckstrdup(*argv++);\n\t}\n\t*ap = NULL;\n\tfreeparam(&shellparam);\n\tshellparam.malloced = 1;\n\tshellparam.nparam = nparam;\n\tshellparam.p = newparam;\n#if ENABLE_ASH_GETOPTS\n\tshellparam.optind = 1;\n\tshellparam.optoff = -1;\n#endif\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47DDA0(char *a1, __int64 a2)\n{\n  char *v2; // rbx\n  unsigned __int64 v3; // rdi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  char v7[8]; // [rsp+10h] [rbp-40h] BYREF\n  __int64 v8; // [rsp+18h] [rbp-38h]\n  char *v9; // [rsp+20h] [rbp-30h]\n  __int64 v10; // [rsp+28h] [rbp-28h]\n\n  sub_47A810(a1, a2);\n  v2 = (char *)(qword_75D418 + 56);\n  v3 = (unsigned int)sub_47A4AE(a1, a2);\n  sub_47C5D6(v3, 4LL, v2, 0LL, v4, v5);\n  sub_47A5E5(v3, 4LL);\n  v7[0] = 15;\n  v8 = 0LL;\n  v9 = qword_75B068;\n  v10 = qword_75B070;\n  sub_4768BC((__int64)v7, 0LL, 0);\n  return *(_QWORD *)(qword_75D428 + 16);\n}\n\n\n Revised code:\nif ENABLE_ASH_EXPAND_PRMT\nstatic const char *\nexpandstr(const char *ps)\n{\n\tunion node n;\n\n\t/* XXX Fix (char *) cast. It _is_ a bug. ps is variable's value,\n\t * and token processing _can_ alter it (delete NULs etc). */\n\tsetinputstring((char *)ps);\n\treadtoken1(pgetc(), PSSYNTAX, nullstr, 0);\n\tpopfile();\n\n\tn.narg.type = NARG;\n\tn.narg.next = NULL;\n\tn.narg.text = wordtext;\n\tn.narg.backquote = backquotelist;\n\n\texpandarg(&n, NULL, 0);\n\treturn stackblock();\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_473F3A(unsigned __int8 *a1, unsigned __int64 a2, char a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  unsigned __int64 v6; // rax\n  unsigned __int8 *v7; // rax\n  _BYTE *v8; // rax\n  unsigned __int8 *v9; // rax\n  __int64 result; // rax\n  int v12; // [rsp+8h] [rbp-28h]\n  unsigned __int64 v14; // [rsp+10h] [rbp-20h]\n  int v16; // [rsp+20h] [rbp-10h]\n  unsigned __int8 v17; // [rsp+27h] [rbp-9h]\n  __int64 v18; // [rsp+28h] [rbp-8h]\n\n  v14 = a2;\n  v12 = a4;\n  if ( (_DWORD)a4 )\n    v6 = 2 * a2;\n  else\n    v6 = a2;\n  v18 = sub_46ECB9(v6, qword_75AFC8, qword_75AFC8, a4, a5, a6);\n  while ( v14-- )\n  {\n    v7 = a1++;\n    v17 = *v7;\n    if ( *v7 )\n    {\n      if ( v12 )\n      {\n        v16 = sub_4704BD(v17, a3);\n        if ( v16 == 12 || v16 == 2 )\n        {\n          v8 = (_BYTE *)v18++;\n          *v8 = -127;\n        }\n      }\n      v9 = (unsigned __int8 *)v18++;\n      *v9 = v17;\n    }\n  }\n  result = v18;\n  qword_75AFC8 = v18;\n  return result;\n}\n\n\n Revised code:\nstatic void\nmemtodest(const char *p, size_t len, int syntax, int quotes)\n{\n\tchar *q = expdest;\n\n\tq = makestrspace(quotes ? len * 2 : len, q);\n\n\twhile (len--) {\n\t\tunsigned char c = *p++;\n\t\tif (c == '\\0')\n\t\t\tcontinue;\n\t\tif (quotes) {\n\t\t\tint n = SIT(c, syntax);\n\t\t\tif (n == CCTL || n == CBACK)\n\t\t\t\tUSTPUTC(CTLESC, q);\n\t\t}\n\t\tUSTPUTC(c, q);\n\t}\n\n\texpdest = q;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4CE68B(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 result; // rax\n  char *v7; // [rsp+8h] [rbp-38h]\n  char src[32]; // [rsp+10h] [rbp-30h] BYREF\n  const char *v9; // [rsp+30h] [rbp-10h]\n  __int64 v10; // [rsp+38h] [rbp-8h]\n\n  v7 = (char *)a1;\n  v10 = a1;\n  while ( 1 )\n  {\n    result = (unsigned __int8)*v7;\n    if ( !(_BYTE)result )\n      break;\n    v9 = sub_4CE217(v10, v7, (__int64)src, (__int64)v7, a5, a6);\n    v7 = (char *)v9;\n    qword_75B218 = sub_50C0E1(qword_75B218, 8196LL, (unsigned int)qword_75B210);\n    memcpy((void *)(qword_75B218 + 32 * qword_75B210), src, 0x20uLL);\n    ++qword_75B210;\n  }\n  return result;\n}\n",
        "output": "static void\nprocessData(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n\tchar *data = (char *)a1;\n\t__int64 temp = a1;\n\twhile (1) {\n\t\tunsigned __int8 byte = *data;\n\t\tif (!byte)\n\t\t\tbreak;\n\t\tconst char *result = sub_4CE217(temp, data, (__int64)src, (__int64)data, a5, a6);\n\t\tdata = (char *)result;\n\t\tqword_75B218 = sub_50C0E1(qword_75B218, 8196LL, (unsigned int)qword_75B210);\n\t\tmemcpy((void *)(qword_75B218 + 32 * qword_75B210), src, 0x20uLL);\n\t\t++qword_75B210;\n\t}\n\treturn result;\n}",
        "source_code": "static void\ndecode_format_string(const char *s)\n{\n\tconst char *s_orig = s;\n\n\twhile (*s != '\\0') {\n\t\tstruct tspec tspec;\n\t\tconst char *next;\n\n\t\tnext = decode_one_format(s_orig, s, &tspec);\n\n\t\tassert(s != next);\n\t\ts = next;\n\t\tspec = xrealloc_vector(spec, 4, n_specs);\n\t\tmemcpy(&spec[n_specs], &tspec, sizeof(spec[0]));\n\t\tn_specs++;\n\t}\n}",
        "parsed_output": "static void\nprocessData(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n\tchar *data = (char *)a1;\n\t__int64 temp = a1;\n\twhile (1) {\n\t\tunsigned __int8 byte = *data;\n\t\tif (!byte)\n\t\t\tbreak;\n\t\tconst char *result = sub_4CE217(temp, data, (__int64)src, (__int64)data, a5, a6);\n\t\tdata = (char *)result;\n\t\tqword_75B218 = sub_50C0E1(qword_75B218, 8196LL, (unsigned int)qword_75B210);\n\t\tmemcpy((void *)(qword_75B218 + 32 * qword_75B210), src, 0x20uLL);\n\t\t++qword_75B210;\n\t}\n\treturn result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4CE68B(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 result; // rax\n  char *v7; // [rsp+8h] [rbp-38h]\n  char src[32]; // [rsp+10h] [rbp-30h] BYREF\n  const char *v9; // [rsp+30h] [rbp-10h]\n  __int64 v10; // [rsp+38h] [rbp-8h]\n\n  v7 = (char *)a1;\n  v10 = a1;\n  while ( 1 )\n  {\n    result = (unsigned __int8)*v7;\n    if ( !(_BYTE)result )\n      break;\n    v9 = sub_4CE217(v10, v7, (__int64)src, (__int64)v7, a5, a6);\n    v7 = (char *)v9;\n    qword_75B218 = sub_50C0E1(qword_75B218, 8196LL, (unsigned int)qword_75B210);\n    memcpy((void *)(qword_75B218 + 32 * qword_75B210), src, 0x20uLL);\n    ++qword_75B210;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl decode_format_string(const char *s)\n{\n  const char *sa; // [rsp+8h] [rbp-38h]\n  tspec tspec; // [rsp+10h] [rbp-30h] BYREF\n  const char *next; // [rsp+30h] [rbp-10h]\n  const char *s_orig; // [rsp+38h] [rbp-8h]\n\n  sa = s;\n  s_orig = s;\n  while ( *sa )\n  {\n    next = decode_one_format(s_orig, sa, &tspec);\n    sa = next;\n    spec = (tspec *)xrealloc_vector_helper(spec, 0x2004u, n_specs);\n    memcpy(&spec[n_specs], &tspec, sizeof(tspec));\n    ++n_specs;\n  }\n}\n",
        "similarity_score_unixcoder": 0.4312199354171753,
        "similarity_score_baseline_stripped": 0.4229307174682617,
        "similarity_score_baseline_debug": 0.8417642116546631
    },
    {
        "func_name": "var_end",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_503608(_BYTE *a1, int a2)\n{\n  _BYTE *v2; // rax\n\n  do\n  {\n    do\n      v2 = a1++;\n    while ( *v2 != 32 );\n    --a2;\n  }\n  while ( a2 );\n  return a1;\n}\n\n\n Revised code:\nendif\n\nstatic char *skip_fields(char *str, int count)\n{\n\tdo {\n\t\twhile (*str++ != ' ')\n\t\t\tcontinue;\n\t\t/* we found a space char, str points after it */\n\t} while (--count);\n\treturn str;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_424AE9(_BYTE *a1, char a2, char a3)\n{\n  __int64 result; // rax\n\n  while ( 1 )\n  {\n    result = (unsigned __int8)*a1;\n    if ( !(_BYTE)result )\n      break;\n    if ( a2 == *a1 )\n      *a1 = a3;\n    ++a1;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void replace(char *s, char what, char with)\n{\n\twhile (*s) {\n\t\tif (what == *s)\n\t\t\t*s = with;\n\t\t++s;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_408145(unsigned __int64 a1, _BYTE *a2)\n{\n  _BYTE *v3; // rax\n\n  do\n  {\n    v3 = a2--;\n    if ( a1 >= (unsigned __int64)v3 )\n      break;\n  }\n  while ( *a2 == 32 || (unsigned __int8)(*a2 - 9) <= 4u );\n  a2[1] = 0;\n  return sub_4093B4(a1);\n}\n\n\n Revised code:\nstatic char *get_trimmed_slice(char *s, char *e)\n{\n\t/* First, consider the value at e to be nul and back up until we\n\t * reach a non-space char.  Set the char after that (possibly at\n\t * the original e) to nul. */\n\twhile (e-- > s) {\n\t\tif (!isspace(*e)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\te[1] = '\\0';\n\n\t/* Next, advance past all leading space and return a ptr to the\n\t * first non-space char; possibly the terminating nul. */\n\treturn skip_whitespace(s);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_46DF3E(_BYTE *a1)\n{\n  _BYTE *v1; // rax\n\n  do\n  {\n    if ( !*a1 )\n      break;\n    v1 = a1++;\n  }\n  while ( *v1 != 61 );\n  return a1;\n}\n",
        "output": "static char *find_equal_sign(char *str)\n{\n\tdo {\n\t\tif (!*str)\n\t\t\tbreak;\n\t} while (*str++ != '=');\n\treturn str;\n}",
        "source_code": "static const char *var_end(const char *var)\n{\n\twhile (*var)\n\t\tif (*var++ == '=')\n\t\t\tbreak;\n\treturn var;\n}",
        "parsed_output": "static char *find_equal_sign(char *str)\n{\n\tdo {\n\t\tif (!*str)\n\t\t\tbreak;\n\t} while (*str++ != '=');\n\treturn str;\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_46DF3E(_BYTE *a1)\n{\n  _BYTE *v1; // rax\n\n  do\n  {\n    if ( !*a1 )\n      break;\n    v1 = a1++;\n  }\n  while ( *v1 != 61 );\n  return a1;\n}\n",
        "baseline_code_debug": "const char *__cdecl var_end(const char *var)\n{\n  const char *v1; // rax\n\n  do\n  {\n    if ( !*var )\n      break;\n    v1 = var++;\n  }\n  while ( *v1 != 61 );\n  return var;\n}\n",
        "similarity_score_unixcoder": 0.8041467666625977,
        "similarity_score_baseline_stripped": 0.5443148612976074,
        "similarity_score_baseline_debug": 0.7625296711921692
    },
    {
        "func_name": "convert_dname",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_50308A(_BYTE **a1)\n{\n  const char *v2; // [rsp+18h] [rbp-20h]\n  unsigned int v3; // [rsp+20h] [rbp-18h]\n  unsigned int v4; // [rsp+24h] [rbp-14h]\n  unsigned int v5; // [rsp+28h] [rbp-10h]\n  int v6; // [rsp+2Ch] [rbp-Ch]\n  _BYTE *v7; // [rsp+30h] [rbp-8h]\n\n  v5 = 0;\n  v6 = 0;\n  v4 = 8;\n  v7 = *a1;\n  if ( **a1 == 120 )\n  {\n    ++v7;\n    v4 = 16;\n    v6 = 1;\n  }\n  while ( 1 )\n  {\n    v3 = (*v7 | 0x20) - 48;\n    if ( v3 > 9 )\n      v3 = (*v7 | 0x20) - 87;\n    if ( v3 >= v4 )\n      break;\n    if ( v4 * v5 + v3 <= 0xFF )\n    {\n      v5 = v4 * v5 + v3;\n      ++v7;\n      if ( (unsigned int)++v6 <= 2 )\n        continue;\n    }\n    goto LABEL_11;\n  }\n  if ( v4 == 16 && !--v6 )\n    return 92LL;\nLABEL_11:\n  if ( !v6 )\n  {\n    v2 = \"abefnrtv\\\\\";\n    while ( *v2 != *v7 )\n    {\n      if ( !*++v2 )\n        goto LABEL_16;\n    }\n    ++v7;\nLABEL_16:\n    v5 = v2[10];\n  }\n  *a1 = v7;\n  return v5;\n}\n\n\n Revised code:\nchar FAST_FUNC bb_process_escape_sequence(const char **ptr)\n{\n\tconst char *q;\n\tunsigned num_digits;\n\tunsigned n;\n\tunsigned base;\n\n\tnum_digits = n = 0;\n\tbase = 8;\n\tq = *ptr;\n\n\tif (WANT_HEX_ESCAPES && *q == 'x') {\n\t\t++q;\n\t\tbase = 16;\n\t\t++num_digits;\n\t}\n\n\t/* bash requires leading 0 in octal escapes:\n\t * \\02 works, \\2 does not (prints \\ and 2).\n\t * We treat \\2 as a valid octal escape sequence. */\n\tdo {\n\t\tunsigned r;\n#if !WANT_HEX_ESCAPES\n\t\tunsigned d = (unsigned char)(*q) - '0';\n#else\n\t\tunsigned d = (unsigned char)_tolower(*q) - '0';\n\t\tif (d >= 10)\n\t\t\td += ('0' - 'a' + 10);\n#endif\n\t\tif (d >= base) {\n\t\t\tif (WANT_HEX_ESCAPES && base == 16) {\n\t\t\t\t--num_digits;\n\t\t\t\tif (num_digits == 0) {\n\t\t\t\t\t/* \\x<bad_char>: return '\\',\n\t\t\t\t\t * leave ptr pointing to x */\n\t\t\t\t\treturn '\\\\';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tr = n * base + d;\n\t\tif (r > UCHAR_MAX) {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = r;\n\t\t++q;\n\t} while (++num_digits < 3);\n\n\tif (num_digits == 0) {\n\t\t/* Not octal or hex escape sequence.\n\t\t * Is it one-letter one? */\n\n\t\t/* bash builtin \"echo -e '\\ec'\" interprets \\e as ESC,\n\t\t * but coreutils \"/bin/echo -e '\\ec'\" does not.\n\t\t * Manpages tend to support coreutils way.\n\t\t * Update: coreutils added support for \\e on 28 Oct 2009. */\n\t\tstatic const char charmap[] ALIGN1 = {\n\t\t\t'a',  'b', 'e', 'f',  'n',  'r',  't',  'v',  '\\\\', '\\0',\n\t\t\t'\\a', '\\b', 27, '\\f', '\\n', '\\r', '\\t', '\\v', '\\\\', '\\\\',\n\t\t};\n\t\tconst char *p = charmap;\n\t\tdo {\n\t\t\tif (*p == *q) {\n\t\t\t\tq++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (*++p != '\\0');\n\t\t/* p points to found escape char or NUL,\n\t\t * advance it and find what it translates to.\n\t\t * Note that \\NUL and unrecognized sequence \\z return '\\'\n\t\t * and leave ptr pointing to NUL or z. */\n\t\tn = p[sizeof(charmap) / 2];\n\t}\n\n\t*ptr = q;\n\n\treturn (char) n;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_42F1F5(char *a1, _WORD *a2)\n{\n  _BYTE *v3; // rax\n  char v5; // [rsp+1Eh] [rbp-12h]\n  char v6; // [rsp+1Eh] [rbp-12h]\n  char v7; // [rsp+1Fh] [rbp-11h]\n  int v8; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+24h] [rbp-Ch]\n  _WORD *v10; // [rsp+28h] [rbp-8h]\n\n  *a2 = 1;\n  v10 = a2 + 1;\n  for ( i = 0; i <= 5; ++i )\n  {\n    v7 = 0;\n    v8 = 0;\n    if ( i && *a1 == 58 )\n      ++a1;\n    while ( 1 )\n    {\n      v5 = *a1;\n      if ( (unsigned __int8)(*a1 - 48) > 9u )\n        break;\n      v6 = v5 - 48;\nLABEL_13:\n      ++a1;\n      v7 = v6 + 16 * v7;\n      if ( ++v8 > 1 )\n        goto LABEL_14;\n    }\n    if ( (unsigned __int8)((v5 | 0x20) - 97) <= 5u )\n    {\n      v6 = (v5 | 0x20) - 87;\n      goto LABEL_13;\n    }\n    if ( !v8 || v5 != 58 && v5 )\n      return 0xFFFFFFFFLL;\nLABEL_14:\n    v3 = v10;\n    v10 = (_WORD *)((char *)v10 + 1);\n    *v3 = v7;\n  }\n  return (unsigned int)*a1;\n}\n\n\n Revised code:\nstatic int in_ether(const char *bufp, struct sockaddr *sap)\n{\n\tchar *ptr;\n\tint i, j;\n\tunsigned char val;\n\tunsigned char c;\n\n\tsap->sa_family = ARPHRD_ETHER;\n\tptr = (char *) sap->sa_data;\n\n\ti = 0;\n\tdo {\n\t\tj = val = 0;\n\n\t\t/* We might get a semicolon here - not required. */\n\t\tif (i && (*bufp == ':')) {\n\t\t\tbufp++;\n\t\t}\n\n\t\tdo {\n\t\t\tc = *bufp;\n\t\t\tif (((unsigned char)(c - '0')) <= 9) {\n\t\t\t\tc -= '0';\n\t\t\t} else if ((unsigned char)((c|0x20) - 'a') <= 5) {\n\t\t\t\tc = (unsigned char)((c|0x20) - 'a') + 10;\n\t\t\t} else if (j && (c == ':' || c == 0)) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t++bufp;\n\t\t\tval <<= 4;\n\t\t\tval += c;\n\t\t} while (++j < 2);\n\t\t*ptr++ = val;\n\t} while (++i < ETH_ALEN);\n\n\treturn *bufp; /* Error if we don't end at end of string. */\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_42C232(const char *a1, __int64 a2)\n{\n  unsigned __int8 *v2; // rax\n  unsigned __int8 *v3; // rax\n  char *s; // [rsp+8h] [rbp-28h]\n  unsigned __int8 v6; // [rsp+17h] [rbp-19h]\n  char *v7; // [rsp+18h] [rbp-18h]\n  int v8; // [rsp+24h] [rbp-Ch]\n  char *v9; // [rsp+28h] [rbp-8h]\n\n  s = (char *)a1;\n  v8 = strlen(a1);\n  v7 = (char *)sub_40A05F(6 * v8 + 1, a2);\n  v9 = v7;\n  while ( 1 )\n  {\n    v3 = (unsigned __int8 *)s++;\n    v6 = *v3;\n    if ( !*v3 )\n      break;\n    if ( sub_42B68A(v6) )\n    {\n      v2 = (unsigned __int8 *)v9++;\n      *v2 = v6;\n    }\n    else\n    {\n      v9 += sprintf(v9, \"&#%d;\", v6);\n    }\n  }\n  *v9 = 0;\n  return v7;\n}\n\n\n Revised code:\nstatic char *encodeString(const char *string)\n{\n\t/* take the simple route and encode everything */\n\t/* could possibly scan once to get length.     */\n\tint len = strlen(string);\n\tchar *out = xmalloc(len * 6 + 1);\n\tchar *p = out;\n\tchar ch;\n\n\twhile ((ch = *string++) != '\\0') {\n\t\t/* very simple check for what to encode */\n\t\tif (isalnum(ch))\n\t\t\t*p++ = ch;\n\t\telse\n\t\t\tp += sprintf(p, \"&#%d;\", (unsigned char) ch);\n\t}\n\t*p = '\\0';\n\treturn out;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_45763B(const char *a1, __int64 a2)\n{\n  size_t v2; // rax\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  char *s; // [rsp+8h] [rbp-38h]\n  int v8; // [rsp+1Ch] [rbp-24h]\n  char *ptr; // [rsp+20h] [rbp-20h]\n  char *i; // [rsp+28h] [rbp-18h]\n  char *v11; // [rsp+30h] [rbp-10h]\n  char v12; // [rsp+3Fh] [rbp-1h]\n\n  s = (char *)a1;\n  v2 = strlen(a1);\n  ptr = (char *)sub_40A05F(v2 + 2, a2);\n  v11 = ptr;\n  for ( i = ptr + 1; ; ++i )\n  {\n    while ( 1 )\n    {\n      v3 = s++;\n      v12 = *v3;\n      if ( *v3 == 46 || !v12 )\n        break;\n      if ( (unsigned __int8)v12 > 0x40u && (unsigned __int8)v12 <= 0x5Au )\n        v12 += 32;\n      v5 = i++;\n      *v5 = v12;\n    }\n    v8 = (_DWORD)i - (_DWORD)v11 - 1;\n    if ( v8 > 63 || (_DWORD)i - (_DWORD)v11 == 1 || v12 == 46 && *s == 46 )\n      goto LABEL_17;\n    *v11 = v8;\n    if ( !v12 || !*s )\n      break;\n    v4 = i;\n    v11 = v4;\n  }\n  if ( i - ptr > 254 )\n  {\nLABEL_17:\n    free(ptr);\n    return 0LL;\n  }\n  *i = 0;\n  return ptr;\n}\n",
        "output": "static char *processString(const char *input, __int64 a2)\n{\n\tsize_t len = strlen(input);\n\tchar *output = (char *)sub_40A05F(len + 2, a2);\n\tchar *ptr = output;\n\tchar *i = ptr + 1;\n\tchar *s = (char *)input;\n\tchar ch;\n\n\twhile (1) {\n\t\twhile (1) {\n\t\t\tch = *s++;\n\t\t\tif (ch == '.' || ch == '\\0')\n\t\t\t\tbreak;\n\t\t\tif ((unsigned char)ch > 0x40u && (unsigned char)ch <= 0x5Au)\n\t\t\t\tch += 32;\n\t\t\t*i++ = ch;\n\t\t}\n\t\tint v8 = (int)(i - ptr - 1);\n\t\tif (v8 > 63 || (int)(i - ptr) == 1 || ch == '.' && *s == '.')\n\t\t\tgoto LABEL_17;\n\t\t*ptr = v8;\n\t\tif (!ch || !*s)\n\t\t\tbreak;\n\t\tptr = i;\n\t}\n\tif (i - output > 254) {\n\tLABEL_17:\n\t\tfree(output);\n\t\treturn 0;\n\t}\n\t*i = 0;\n\treturn output;\n}",
        "source_code": "static uint8_t *convert_dname(const char *src)\n{\n\tuint8_t c, *res, *lenptr, *dst;\n\tint len;\n\n\tres = xmalloc(strlen(src) + 2);\n\tdst = lenptr = res;\n\tdst++;\n\n\tfor (;;) {\n\t\tc = (uint8_t)*src++;\n\t\tif (c == '.' || c == '\\0') {  /* end of label */\n\t\t\tlen = dst - lenptr - 1;\n\t\t\t/* label too long, too short, or two '.'s in a row? abort */\n\t\t\tif (len > NS_MAXLABEL || len == 0 || (c == '.' && *src == '.')) {\n\t\t\t\tfree(res);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\t*lenptr = len;\n\t\t\tif (c == '\\0' || *src == '\\0')\t/* \"\" or \".\": end of src */\n\t\t\t\tbreak;\n\t\t\tlenptr = dst++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c >= 'A' && c <= 'Z')  /* uppercase? convert to lower */\n\t\t\tc += ('a' - 'A');\n\t\t*dst++ = c;\n\t}\n\n\tif (dst - res >= NS_MAXCDNAME) {  /* dname too long? abort */\n\t\tfree(res);\n\t\treturn NULL;\n\t}\n\n\t*dst = 0;\n\treturn res;\n}",
        "parsed_output": "static char *processString(const char *input, __int64 a2)\n{\n\tsize_t len = strlen(input);\n\tchar *output = (char *)sub_40A05F(len + 2, a2);\n\tchar *ptr = output;\n\tchar *i = ptr + 1;\n\tchar *s = (char *)input;\n\tchar ch;\n\n\twhile (1) {\n\t\twhile (1) {\n\t\t\tch = *s++;\n\t\t\tif (ch == '.' || ch == '\\0')\n\t\t\t\tbreak;\n\t\t\tif ((unsigned char)ch > 0x40u && (unsigned char)ch <= 0x5Au)\n\t\t\t\tch += 32;\n\t\t\t*i++ = ch;\n\t\t}\n\t\tint v8 = (int)(i - ptr - 1);\n\t\tif (v8 > 63 || (int)(i - ptr) == 1 || ch == '.' && *s == '.')\n\t\t\tgoto LABEL_17;\n\t\t*ptr = v8;\n\t\tif (!ch || !*s)\n\t\t\tbreak;\n\t\tptr = i;\n\t}\n\tif (i - output > 254) {\n\tLABEL_17:\n\t\tfree(output);\n\t\treturn 0;\n\t}\n\t*i = 0;\n\treturn output;\n}",
        "baseline_code_stripped": "char *__fastcall sub_45763B(const char *a1, __int64 a2)\n{\n  size_t v2; // rax\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  char *s; // [rsp+8h] [rbp-38h]\n  int v8; // [rsp+1Ch] [rbp-24h]\n  char *ptr; // [rsp+20h] [rbp-20h]\n  char *i; // [rsp+28h] [rbp-18h]\n  char *v11; // [rsp+30h] [rbp-10h]\n  char v12; // [rsp+3Fh] [rbp-1h]\n\n  s = (char *)a1;\n  v2 = strlen(a1);\n  ptr = (char *)sub_40A05F(v2 + 2, a2);\n  v11 = ptr;\n  for ( i = ptr + 1; ; ++i )\n  {\n    while ( 1 )\n    {\n      v3 = s++;\n      v12 = *v3;\n      if ( *v3 == 46 || !v12 )\n        break;\n      if ( (unsigned __int8)v12 > 0x40u && (unsigned __int8)v12 <= 0x5Au )\n        v12 += 32;\n      v5 = i++;\n      *v5 = v12;\n    }\n    v8 = (_DWORD)i - (_DWORD)v11 - 1;\n    if ( v8 > 63 || (_DWORD)i - (_DWORD)v11 == 1 || v12 == 46 && *s == 46 )\n      goto LABEL_17;\n    *v11 = v8;\n    if ( !v12 || !*s )\n      break;\n    v4 = i;\n    v11 = v4;\n  }\n  if ( i - ptr > 254 )\n  {\nLABEL_17:\n    free(ptr);\n    return 0LL;\n  }\n  *i = 0;\n  return ptr;\n}\n",
        "baseline_code_debug": "uint8_t *__cdecl convert_dname(const char *src)\n{\n  size_t v1; // rax\n  uint8_t *v2; // rax\n  uint8_t *v3; // rax\n  uint8_t *v4; // rax\n  const char *srca; // [rsp+8h] [rbp-38h]\n  int len; // [rsp+1Ch] [rbp-24h]\n  uint8_t *res; // [rsp+20h] [rbp-20h]\n  uint8_t *dst; // [rsp+28h] [rbp-18h]\n  uint8_t *lenptr; // [rsp+30h] [rbp-10h]\n  uint8_t c; // [rsp+3Fh] [rbp-1h]\n\n  srca = src;\n  v1 = strlen(src);\n  res = (uint8_t *)xmalloc(v1 + 2);\n  lenptr = res;\n  for ( dst = res + 1; ; ++dst )\n  {\n    while ( 1 )\n    {\n      v2 = (uint8_t *)srca++;\n      c = *v2;\n      if ( *v2 == 46 || !c )\n        break;\n      if ( c > 0x40u && c <= 0x5Au )\n        c += 32;\n      v4 = dst++;\n      *v4 = c;\n    }\n    len = (_DWORD)dst - (_DWORD)lenptr - 1;\n    if ( len > 63 || (_DWORD)dst - (_DWORD)lenptr == 1 || c == 46 && *srca == 46 )\n      goto LABEL_17;\n    *lenptr = len;\n    if ( !c || !*srca )\n      break;\n    v3 = dst;\n    lenptr = v3;\n  }\n  if ( dst - res > 254 )\n  {\nLABEL_17:\n    free(res);\n    return 0LL;\n  }\n  *dst = 0;\n  return res;\n}\n",
        "similarity_score_unixcoder": 0.6743963956832886,
        "similarity_score_baseline_stripped": 0.5965253114700317,
        "similarity_score_baseline_debug": 0.7938170433044434
    },
    {
        "func_name": "volume_id_probe_romfs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E6ABA(__int64 a1, char *a2, int a3, int a4)\n{\n  char *v6; // [rsp+28h] [rbp-18h]\n  void *s; // [rsp+30h] [rbp-10h]\n  int i; // [rsp+3Ch] [rbp-4h]\n  int v9; // [rsp+3Ch] [rbp-4h]\n\n  s = (void *)(a4 + 16LL + a1 + 4);\n  for ( i = *(_DWORD *)(a1 + 16) - a4; i >= a3; i = v9 - 1 )\n  {\n    v6 = (char *)memchr(s, *a2, i);\n    if ( !v6 )\n      return 0xFFFFFFFFLL;\n    v9 = i - ((_DWORD)v6 - (_DWORD)s);\n    if ( v9 < a3 )\n      return 0xFFFFFFFFLL;\n    if ( !memcmp(v6, a2, a3) )\n      return (__int64)&v6[-a1 - 20];\n    s = v6 + 1;\n  }\n  return 0xFFFFFFFFLL;\n}\n\n\n Revised code:\nstatic int findString(const LINE *lp, const char *str, int len, int offset)\n{\n\tint left;\n\tconst char *cp, *ncp;\n\n\tcp = &lp->data[offset];\n\tleft = lp->len - offset;\n\n\twhile (left >= len) {\n\t\tncp = memchr(cp, *str, left);\n\t\tif (ncp == NULL)\n\t\t\treturn -1;\n\t\tleft -= (ncp - cp);\n\t\tif (left < len)\n\t\t\treturn -1;\n\t\tcp = ncp;\n\t\tif (memcmp(cp, str, len) == 0)\n\t\t\treturn (cp - lp->data);\n\t\tcp++;\n\t\tleft--;\n\t}\n\n\treturn -1;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_42FA80(const char *a1, char *a2)\n{\n  int v3; // [rsp+1Ch] [rbp-4h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_42FA47(0x8921u, a2, a1);\n  v4 = sub_42FA47(0x8913u, a2 + 40, a1) | v3;\n  return sub_42FA47(0x8927u, a2 + 80, a1) | (unsigned int)v4;\n}\n\n\n Revised code:\nstatic int get_if_settings(char *ifname, struct dev_data *dd)\n{\n\tint res;\n\n\tres = set_ifrname_and_do_ioctl(SIOCGIFMTU, &dd->mtu, ifname);\n\tres |= set_ifrname_and_do_ioctl(SIOCGIFFLAGS, &dd->flags, ifname);\n\tres |= set_ifrname_and_do_ioctl(SIOCGIFHWADDR, &dd->hwaddr, ifname);\n\n\treturn res;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_50BD71(char *a1, unsigned int a2)\n{\n  unsigned int v3; // [rsp+14h] [rbp-Ch]\n  char *ptr; // [rsp+18h] [rbp-8h]\n\n  ptr = sub_50BB2A(a1, a2);\n  v3 = sub_40A999(*((unsigned __int16 *)ptr + 2), 1u, 0);\n  sub_50B34E(v3);\n  sub_50B4DD(v3, (__int64)(ptr + 4), *(_DWORD *)ptr);\n  free(ptr);\n  return v3;\n}\n\n\n Revised code:\nint FAST_FUNC create_and_connect_stream_or_die(const char *peer, int port)\n{\n\tint fd;\n\tlen_and_sockaddr *lsa;\n\n\tlsa = xhost2sockaddr(peer, port);\n\tfd = xsocket(lsa->u.sa.sa_family, SOCK_STREAM, 0);\n\tsetsockopt_reuseaddr(fd);\n\txconnect(fd, &lsa->u.sa, lsa->len);\n\tfree(lsa);\n\treturn fd;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4A76D1(__int64 a1)\n{\n  size_t v2; // [rsp+10h] [rbp-10h]\n  const char *s1; // [rsp+18h] [rbp-8h]\n\n  s1 = (const char *)sub_4A8163(a1, 0LL, 512LL);\n  if ( !s1 )\n    return 0xFFFFFFFFLL;\n  if ( memcmp(s1, \"-rom1fs-\", 4uLL) )\n    return 0xFFFFFFFFLL;\n  v2 = strlen(s1 + 16);\n  if ( v2 )\n    sub_4A7DA2(a1, s1 + 16, v2);\n  return 0LL;\n}\n",
        "output": "static void process_data(__int64 data)\n{\n  size_t length;\n  const char *str;\n\n  str = (const char *)get_data(data, 0LL, 512LL);\n  if (!str)\n    return;\n  if (memcmp(str, \"-rom1fs-\", 4uLL))\n    return;\n  length = strlen(str + 16);\n  if (length)\n    process_subdata(data, str + 16, length);\n  return;\n}",
        "source_code": "int FAST_FUNC volume_id_probe_romfs(struct volume_id *id /*,uint64_t off*/)\n{\n#define off ((uint64_t)0)\n\tstruct romfs_super *rfs;\n\n\tdbg(\"probing at offset 0x%llx\", (unsigned long long) off);\n\n\trfs = volume_id_get_buffer(id, off, 0x200);\n\tif (rfs == NULL)\n\t\treturn -1;\n\n\tif (memcmp(rfs->magic, \"-rom1fs-\", 4) == 0) {\n\t\tsize_t len = strlen((char *)rfs->name);\n\n\t\tif (len) {\n//\t\t\tvolume_id_set_label_raw(id, rfs->name, len);\n\t\t\tvolume_id_set_label_string(id, rfs->name, len);\n\t\t}\n\n//\t\tvolume_id_set_usage(id, VOLUME_ID_FILESYSTEM);\n\t\tIF_FEATURE_BLKID_TYPE(id->type = \"romfs\";)\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}",
        "parsed_output": "static void process_data(__int64 data)\n{\n  size_t length;\n  const char *str;\n\n  str = (const char *)get_data(data, 0LL, 512LL);\n  if (!str)\n    return;\n  if (memcmp(str, \"-rom1fs-\", 4uLL))\n    return;\n  length = strlen(str + 16);\n  if (length)\n    process_subdata(data, str + 16, length);\n  return;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4A76D1(__int64 a1)\n{\n  size_t v2; // [rsp+10h] [rbp-10h]\n  const char *s1; // [rsp+18h] [rbp-8h]\n\n  s1 = (const char *)sub_4A8163(a1, 0LL, 512LL);\n  if ( !s1 )\n    return 0xFFFFFFFFLL;\n  if ( memcmp(s1, \"-rom1fs-\", 4uLL) )\n    return 0xFFFFFFFFLL;\n  v2 = strlen(s1 + 16);\n  if ( v2 )\n    sub_4A7DA2(a1, s1 + 16, v2);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl volume_id_probe_romfs(volume_id *id)\n{\n  size_t len; // [rsp+10h] [rbp-10h]\n  romfs_super *rfs; // [rsp+18h] [rbp-8h]\n\n  rfs = (romfs_super *)volume_id_get_buffer(id, 0LL, 0x200uLL);\n  if ( !rfs )\n    return -1;\n  if ( memcmp(rfs, \"-rom1fs-\", 4uLL) )\n    return -1;\n  len = strlen((const char *)rfs->name);\n  if ( len )\n    volume_id_set_label_string(id, rfs->name, len);\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.6531410813331604,
        "similarity_score_baseline_stripped": 0.5926123261451721,
        "similarity_score_baseline_debug": 0.8627429604530334
    },
    {
        "func_name": "rearm_alarm",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint sub_4FE61B()\n{\n  int result; // eax\n\n  result = *((_DWORD *)qword_75D458 + 9);\n  if ( result )\n  {\n    sub_4FE38C(1u);\n    return sub_4FE55C();\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void input_backspace(void)\n{\n\tif (cursor > 0) {\n\t\tinput_backward(1);\n\t\tinput_delete(0);\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4421EB(char a1)\n{\n  __int64 result; // rax\n\n  if ( BYTE1(dest.c_oflag) == 0xFB )\n    return sub_441E67(254, a1);\n  result = BYTE1(dest.c_oflag);\n  if ( (_BYTE)result == 0xFD )\n    return sub_441E67(252, a1);\n  return result;\n}\n\n\n Revised code:\nstatic void to_notsup(char c)\n{\n\tif (G.telwish == WILL)\n\t\tput_iac2(DONT, c);\n\telse if (G.telwish == DO)\n\t\tput_iac2(WONT, c);\n}\n\n## Example:\n\n Input code:\nint sub_4FE2D5()\n{\n  int result; // eax\n\n  sub_4FE2AF();\n  result = *((_DWORD *)qword_75D458 + 6);\n  if ( result )\n    return sub_40A659(10);\n  return result;\n}\n\n\n Revised code:\nstatic void goto_new_line(void)\n{\n\tput_till_end_and_adv_cursor();\n\tif (cmdedit_x != 0)\n\t\tbb_putchar('\\n');\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nunsigned int sub_433B43()\n{\n  unsigned int result; // eax\n\n  result = dest.c_cc[31];\n  if ( !(_BYTE)result )\n  {\n    dest.c_cc[31] = 1;\n    return alarm(0x3Cu);\n  }\n  return result;\n}\n",
        "output": "static void set_alarm(void)\n{\n\tif (dest.c_cc[31] == 0)\n\t{\n\t\tdest.c_cc[31] = 1;\n\t\talarm(60);\n\t}\n}",
        "source_code": "static void rearm_alarm(void)\n{\n\tif (!alarm_armed) {\n\t\talarm_armed = 1;\n\t\talarm(RETRYTIME);\n\t}\n}",
        "parsed_output": "static void set_alarm(void)\n{\n\tif (dest.c_cc[31] == 0)\n\t{\n\t\tdest.c_cc[31] = 1;\n\t\talarm(60);\n\t}\n}",
        "baseline_code_stripped": "unsigned int sub_433B43()\n{\n  unsigned int result; // eax\n\n  result = dest.c_cc[31];\n  if ( !(_BYTE)result )\n  {\n    dest.c_cc[31] = 1;\n    return alarm(0x3Cu);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl rearm_alarm()\n{\n  if ( !bb_common_bufsiz1.c_cc[31] )\n  {\n    bb_common_bufsiz1.c_cc[31] = 1;\n    alarm(0x3Cu);\n  }\n}\n",
        "similarity_score_unixcoder": 0.682405412197113,
        "similarity_score_baseline_stripped": 0.5159430503845215,
        "similarity_score_baseline_debug": 0.6506780385971069
    },
    {
        "func_name": "udhcp_recv_kernel_packet",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_495D5B(__int64 a1, __int64 a2)\n{\n  const char *v2; // rax\n  __int64 v3; // r9\n  unsigned int v4; // esi\n  int v7; // [rsp+1Ch] [rbp-4h]\n\n  v2 = (const char *)sub_5085F9(a2);\n  v7 = sub_40A295(v2, 2);\n  if ( ident[1] == 114 )\n    v4 = 4705;\n  else\n    v4 = 587;\n  sub_40AB31(v7, v4, 0LL, \"%s\", *(_QWORD *)(a2 + 8), v3, a2);\n  return 0LL;\n}\n\n\n Revised code:\nint freeramdisk_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint fd;\n\n\tfd = xopen(single_argv(argv), O_RDWR);\n\n\t// Act like freeramdisk, fdflush, or both depending on configuration.\n\tioctl_or_perror_and_die(fd, (ENABLE_FREERAMDISK && applet_name[1] == 'r')\n\t\t\t|| !ENABLE_FDFLUSH ? BLKFLSBUF : FDFLUSH, NULL, \"%s\", argv[1]);\n\n\tif (ENABLE_FEATURE_CLEAN_UP) close(fd);\n\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40D112(unsigned int *a1, char *a2)\n{\n  unsigned int v2; // edx\n  __int64 result; // rax\n  unsigned int v4; // edx\n  char *v5; // [rsp+18h] [rbp-8h]\n\n  v5 = strchr(a2, 46);\n  if ( v5 )\n    *v5 = 58;\n  else\n    v5 = strchr(a2, 58);\n  if ( v5 )\n  {\n    if ( v5 == a2 )\n    {\n      v4 = sub_4F64C7(v5 + 1, sub_4F64A0);\n      result = (__int64)a1;\n      a1[1] = v4;\n    }\n    else\n    {\n      if ( !v5[1] )\n        *v5 = 0;\n      return sub_40D0CD(a1, a2);\n    }\n  }\n  else\n  {\n    v2 = sub_4F64C7(a2, sub_4F6479);\n    result = (__int64)a1;\n    *a1 = v2;\n  }\n  return result;\n}\n\n\n Revised code:\nvoid FAST_FUNC parse_chown_usergroup_or_die(struct bb_uidgid_t *u, char *user_group)\n{\n\tchar *group;\n\n\t/* Check if there is a group name */\n\tgroup = strchr(user_group, '.'); /* deprecated? */\n\tif (!group)\n\t\tgroup = strchr(user_group, ':');\n\telse\n\t\t*group = ':'; /* replace '.' with ':' */\n\n\t/* Parse \"user[:[group]]\" */\n\tif (!group) { /* \"user\" */\n\t\tu->uid = get_ug_id(user_group, xuname2uid);\n\t} else if (group == user_group) { /* \":group\" */\n\t\tu->gid = get_ug_id(group + 1, xgroup2gid);\n\t} else {\n\t\tif (!group[1]) /* \"user:\" */\n\t\t\t*group = '\\0';\n\t\txget_uidgid(u, user_group);\n\t}\n}\n\n## Example:\n\n Input code:\n_DWORD *__fastcall sub_4F9895(const char *a1, __int64 a2)\n{\n  const char *v2; // rax\n  const char *v3; // rax\n  int v4; // eax\n  __int64 v6; // [rsp+18h] [rbp-18h]\n  unsigned int v7; // [rsp+24h] [rbp-Ch]\n  _DWORD *v8; // [rsp+28h] [rbp-8h]\n\n  v7 = 0;\n  v6 = 0LL;\n  v8 = sub_40A0E8(4uLL, a2);\n  while ( 1 )\n  {\n    v6 = sub_503C0E(v6, 65825LL);\n    if ( !v6 )\n      break;\n    if ( !sub_4F97BA(v6, a1) )\n    {\n      if ( !*(_QWORD *)(v6 + 24) || (v2 = sub_408E94(*(const char **)(v6 + 24)), strcmp(v2, a1)) )\n      {\n        if ( !*(_QWORD *)(v6 + 32) )\n          continue;\n        v3 = sub_408E94(*(const char **)(v6 + 32));\n        if ( strcmp(v3, a1) )\n          continue;\n      }\n    }\n    v8 = (_DWORD *)sub_50C0E1(v8, 1026LL, v7);\n    v4 = v7++;\n    v8[v4] = *(_DWORD *)(v6 + 88);\n  }\n  v8[v7] = 0;\n  return v8;\n}\n\n\n Revised code:\nFAST_FUNC find_pid_by_name(const char *procName)\n{\n\tpid_t* pidList;\n\tint i = 0;\n\tprocps_status_t* p = NULL;\n\n\tpidList = xzalloc(sizeof(*pidList));\n\twhile ((p = procps_scan(p, PSSCAN_PID|PSSCAN_COMM|PSSCAN_ARGVN|PSSCAN_EXE))) {\n\t\tif (comm_match(p, procName)\n\t\t/* or we require argv0 to match (essential for matching reexeced /proc/self/exe)*/\n\t\t || (p->argv0 && strcmp(bb_basename(p->argv0), procName) == 0)\n\t\t/* or we require /proc/PID/exe link to match */\n\t\t || (p->exe && strcmp(bb_basename(p->exe), procName) == 0)\n\t\t) {\n\t\t\tpidList = xrealloc_vector(pidList, 2, i);\n\t\t\tpidList[i++] = p->pid;\n\t\t}\n\t}\n\n\tpidList[i] = 0;\n\treturn pidList;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_45897C(_DWORD *a1, int a2)\n{\n  int v2; // edx\n  int v3; // ecx\n  int v4; // r8d\n  int v5; // r9d\n  int v7; // ebx\n  unsigned int v8; // [rsp+1Ch] [rbp-14h]\n\n  memset(a1, 0, 0x274uLL);\n  v8 = sub_40B3FF(a2, a1, 0x274uLL);\n  if ( (v8 & 0x80000000) == 0 )\n  {\n    if ( v8 > 0xEF && (v7 = a1[59], v7 == htonl(0x63825363u)) )\n    {\n      if ( dword_75D460 )\n        sub_4FDABC((unsigned int)\"Received a packet\", (_DWORD)a1, v2, v3, v4, v5);\n      sub_4588D8((__int64)a1);\n      return v8;\n    }\n    else\n    {\n      sub_4FDABC((unsigned int)\"Packet with bad magic, ignoring\", (_DWORD)a1, v2, v3, v4, v5);\n      return 4294967294LL;\n    }\n  }\n  else\n  {\n    if ( dword_75D460 )\n      sub_4FDABC((unsigned int)\"Packet read error, ignoring\", (_DWORD)a1, v2, v3, v4, v5);\n    return v8;\n  }\n}\n",
        "output": "void process_packet(_DWORD *packet, int size)\n{\n  int v2;\n  int v3;\n  int v4;\n  int v5;\n  int v7;\n  unsigned int v8;\n\n  memset(packet, 0, 0x274uLL);\n  v8 = read_packet(size, packet, 0x274uLL);\n  if ((v8 & 0x80000000) == 0)\n  {\n    if (v8 > 0xEF && (v7 = packet[59], v7 == htonl(0x63825363u)))\n    {\n      if (dword_75D460)\n        log_message((unsigned int)\"Received a packet\", (_DWORD)packet, v2, v3, v4, v5);\n      process_valid_packet((__int64)packet);\n      return v8;\n    }\n    else\n    {\n      log_message((unsigned int)\"Packet with bad magic, ignoring\", (_DWORD)packet, v2, v3, v4, v5);\n      return 4294967294LL;\n    }\n  }\n  else\n  {\n    if (dword_75D460)\n      log_message((unsigned int)\"Packet read error, ignoring\", (_DWORD)packet, v2, v3, v4, v5);\n    return v8;\n  }\n}",
        "source_code": "int FAST_FUNC udhcp_recv_kernel_packet(struct dhcp_packet *packet, int fd)\n{\n\tint bytes;\n\n\tmemset(packet, 0, sizeof(*packet));\n\tbytes = safe_read(fd, packet, sizeof(*packet));\n\tif (bytes < 0) {\n\t\tlog1(\"Packet read error, ignoring\");\n\t\treturn bytes; /* returns -1 */\n\t}\n\n\tif (bytes < offsetof(struct dhcp_packet, options)\n\t || packet->cookie != htonl(DHCP_MAGIC)\n\t) {\n\t\tbb_info_msg(\"Packet with bad magic, ignoring\");\n\t\treturn -2;\n\t}\n\tlog1(\"Received a packet\");\n\tudhcp_dump_packet(packet);\n\n\treturn bytes;\n}",
        "parsed_output": "void process_packet(_DWORD *packet, int size)\n{\n  int v2;\n  int v3;\n  int v4;\n  int v5;\n  int v7;\n  unsigned int v8;\n\n  memset(packet, 0, 0x274uLL);\n  v8 = read_packet(size, packet, 0x274uLL);\n  if ((v8 & 0x80000000) == 0)\n  {\n    if (v8 > 0xEF && (v7 = packet[59], v7 == htonl(0x63825363u)))\n    {\n      if (dword_75D460)\n        log_message((unsigned int)\"Received a packet\", (_DWORD)packet, v2, v3, v4, v5);\n      process_valid_packet((__int64)packet);\n      return v8;\n    }\n    else\n    {\n      log_message((unsigned int)\"Packet with bad magic, ignoring\", (_DWORD)packet, v2, v3, v4, v5);\n      return 4294967294LL;\n    }\n  }\n  else\n  {\n    if (dword_75D460)\n      log_message((unsigned int)\"Packet read error, ignoring\", (_DWORD)packet, v2, v3, v4, v5);\n    return v8;\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_45897C(_DWORD *a1, int a2)\n{\n  int v2; // edx\n  int v3; // ecx\n  int v4; // r8d\n  int v5; // r9d\n  int v7; // ebx\n  unsigned int v8; // [rsp+1Ch] [rbp-14h]\n\n  memset(a1, 0, 0x274uLL);\n  v8 = sub_40B3FF(a2, a1, 0x274uLL);\n  if ( (v8 & 0x80000000) == 0 )\n  {\n    if ( v8 > 0xEF && (v7 = a1[59], v7 == htonl(0x63825363u)) )\n    {\n      if ( dword_75D460 )\n        sub_4FDABC((unsigned int)\"Received a packet\", (_DWORD)a1, v2, v3, v4, v5);\n      sub_4588D8((__int64)a1);\n      return v8;\n    }\n    else\n    {\n      sub_4FDABC((unsigned int)\"Packet with bad magic, ignoring\", (_DWORD)a1, v2, v3, v4, v5);\n      return 4294967294LL;\n    }\n  }\n  else\n  {\n    if ( dword_75D460 )\n      sub_4FDABC((unsigned int)\"Packet read error, ignoring\", (_DWORD)a1, v2, v3, v4, v5);\n    return v8;\n  }\n}\n",
        "baseline_code_debug": "int __cdecl udhcp_recv_kernel_packet(dhcp_packet *packet, int fd)\n{\n  uint32_t cookie; // ebx\n  int bytes; // [rsp+1Ch] [rbp-14h]\n\n  memset(packet, 0, sizeof(dhcp_packet));\n  bytes = safe_read(fd, packet, 0x274uLL);\n  if ( bytes >= 0 )\n  {\n    if ( (unsigned int)bytes > 0xEF && (cookie = packet->cookie, cookie == htonl(0x63825363u)) )\n    {\n      if ( dhcp_verbose )\n        bb_info_msg(\"Received a packet\");\n      udhcp_dump_packet(packet);\n      return bytes;\n    }\n    else\n    {\n      bb_info_msg(\"Packet with bad magic, ignoring\");\n      return -2;\n    }\n  }\n  else\n  {\n    if ( dhcp_verbose )\n      bb_info_msg(\"Packet read error, ignoring\");\n    return bytes;\n  }\n}\n",
        "similarity_score_unixcoder": 0.701524019241333,
        "similarity_score_baseline_stripped": 0.5748022198677063,
        "similarity_score_baseline_debug": 0.9289586544036865
    },
    {
        "func_name": "builtin_shift",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47AD4B(char *a1, __int64 a2)\n{\n  void **v2; // rdx\n  void **v3; // rax\n  void **v5; // [rsp+18h] [rbp-18h]\n  void **i; // [rsp+20h] [rbp-10h]\n  int v7; // [rsp+2Ch] [rbp-4h]\n\n  v7 = 1;\n  if ( *(_QWORD *)(a2 + 8) )\n  {\n    a1 = *(char **)(a2 + 8);\n    v7 = sub_46EE78(a1);\n  }\n  if ( v7 > *(_DWORD *)qword_75D420 )\n    v7 = 0;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  *(_DWORD *)qword_75D420 -= v7;\n  for ( i = *(void ***)(qword_75D420 + 16); --v7 >= 0; ++i )\n  {\n    if ( *(_BYTE *)(qword_75D420 + 12) )\n    {\n      a1 = (char *)*i;\n      free(*i);\n    }\n  }\n  v5 = *(void ***)(qword_75D420 + 16);\n  do\n  {\n    v2 = i++;\n    v3 = v5++;\n    *v3 = *v2;\n  }\n  while ( *v3 );\n  *(_DWORD *)(qword_75D420 + 4) = 1;\n  *(_DWORD *)(qword_75D420 + 8) = -1;\n  sub_46E03F(a1, a2);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC\nshiftcmd(int argc UNUSED_PARAM, char **argv)\n{\n\tint n;\n\tchar **ap1, **ap2;\n\n\tn = 1;\n\tif (argv[1])\n\t\tn = number(argv[1]);\n\tif (n > shellparam.nparam)\n\t\tn = 0; /* bash compat, was = shellparam.nparam; */\n\tINT_OFF;\n\tshellparam.nparam -= n;\n\tfor (ap1 = shellparam.p; --n >= 0; ap1++) {\n\t\tif (shellparam.malloced)\n\t\t\tfree(*ap1);\n\t}\n\tap2 = shellparam.p;\n\twhile ((*ap2++ = *ap1++) != NULL)\n\t\tcontinue;\n#if ENABLE_ASH_GETOPTS\n\tshellparam.optind = 1;\n\tshellparam.optoff = -1;\n#endif\n\tINT_ON;\n\treturn 0;\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_486BBE(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  int v3; // eax\n  char *v4; // [rsp+18h] [rbp-18h]\n  int i; // [rsp+20h] [rbp-10h]\n  int j; // [rsp+20h] [rbp-10h]\n  int v7; // [rsp+24h] [rbp-Ch]\n  char *s; // [rsp+28h] [rbp-8h]\n\n  if ( *((_BYTE *)qword_75D408 + 74) && a1 )\n  {\n    v7 = 3;\n    for ( i = 0; *(_QWORD *)(8LL * i + a1); ++i )\n    {\n      v2 = i;\n      v7 += strlen(*(const char **)(8LL * v2 + a1)) + 1;\n    }\n    v4 = (char *)sub_40A05F(v7, a2);\n    *v4 = 43;\n    s = v4 + 1;\n    for ( j = 0; *(_QWORD *)(8LL * j + a1); ++j )\n    {\n      v3 = j;\n      s += sprintf(s, \" %s\", *(const char **)(8LL * v3 + a1));\n    }\n    *s = 10;\n    s[1] = 0;\n    fputs_unlocked(v4, stderr);\n    free(v4);\n  }\n}\n\n\n Revised code:\nif ENABLE_HUSH_MODE_X\nstatic void dump_cmd_in_x_mode(char **argv)\n{\n\tif (G_x_mode && argv) {\n\t\t/* We want to output the line in one write op */\n\t\tchar *buf, *p;\n\t\tint len;\n\t\tint n;\n\n\t\tlen = 3;\n\t\tn = 0;\n\t\twhile (argv[n])\n\t\t\tlen += strlen(argv[n++]) + 1;\n\t\tbuf = xmalloc(len);\n\t\tbuf[0] = '+';\n\t\tp = buf + 1;\n\t\tn = 0;\n\t\twhile (argv[n])\n\t\t\tp += sprintf(p, \" %s\", argv[n++]);\n\t\t*p++ = '\\n';\n\t\t*p = '\\0';\n\t\tfputs(buf, stderr);\n\t\tfree(buf);\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4DE999(unsigned int a1)\n{\n  char *v1; // rbx\n  __int64 result; // rax\n  int v3; // [rsp+1Ch] [rbp-14h]\n  int i; // [rsp+1Ch] [rbp-14h]\n\n  if ( (signed int)a1 >= *((_DWORD *)qword_75D408 - 12) )\n  {\n    v3 = *((_DWORD *)qword_75D408 - 12);\n    *((_DWORD *)qword_75D408 - 12) = a1 + 16;\n    v1 = (char *)qword_75D408 - 208;\n    *((_QWORD *)v1 + 21) = sub_40A09E(*((void **)qword_75D408 - 5), 32LL * *((int *)qword_75D408 - 12));\n    while ( v3 < *((_DWORD *)qword_75D408 - 12) )\n    {\n      *(_DWORD *)(32LL * v3 + *((_QWORD *)qword_75D408 - 5)) = 1024;\n      *(_QWORD *)(32LL * v3++ + *((_QWORD *)qword_75D408 - 5) + 16) = 0LL;\n    }\n  }\n  for ( i = a1; i < *((_DWORD *)qword_75D408 - 13); ++i )\n    sub_4DC88C((int *)(32LL * i + *((_QWORD *)qword_75D408 - 5)));\n  result = a1;\n  *((_DWORD *)qword_75D408 - 13) = a1;\n  return result;\n}\n\n\n Revised code:\nstatic void fsrealloc(int size)\n{\n\tint i;\n\n\tif (size >= maxfields) {\n\t\ti = maxfields;\n\t\tmaxfields = size + 16;\n\t\tFields = xrealloc(Fields, maxfields * sizeof(Fields[0]));\n\t\tfor (; i < maxfields; i++) {\n\t\t\tFields[i].type = VF_SPECIAL;\n\t\t\tFields[i].string = NULL;\n\t\t}\n\t}\n\t/* if size < nfields, clear extra field variables */\n\tfor (i = size; i < nfields; i++) {\n\t\tclrvar(Fields + i);\n\t}\n\tnfields = size;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_48A1A8(__int64 a1)\n{\n  int v1; // eax\n  const char **v3; // [rsp+8h] [rbp-18h]\n  int i; // [rsp+18h] [rbp-8h]\n  int v5; // [rsp+1Ch] [rbp-4h]\n\n  v5 = 1;\n  v3 = (const char **)sub_48914D(a1);\n  if ( *v3 )\n    v5 = atoi(*v3);\n  if ( v5 < 0 || v5 >= *((_DWORD *)qword_75D408 + 21) )\n    return 1LL;\n  if ( *((_BYTE *)qword_75D408 + 80) )\n  {\n    for ( i = 1; i <= v5; ++i )\n    {\n      v1 = i;\n      free(*(void **)(*((_QWORD *)qword_75D408 + 11) + 8LL * v1));\n    }\n  }\n  *((_DWORD *)qword_75D408 + 21) -= v5;\n  memmove(\n    (void *)(*((_QWORD *)qword_75D408 + 11) + 8LL),\n    (const void *)(*((_QWORD *)qword_75D408 + 11) + 8 * (v5 + 1LL)),\n    8LL * *((int *)qword_75D408 + 21));\n  return 0LL;\n}\n",
        "output": "static int FAST_FUNC remove_entry(__int64 a1)\n{\n\tint v1;\n\tconst char **v3;\n\tint i;\n\tint v5;\n\n\tv5 = 1;\n\tv3 = (const char **)get_entries(a1);\n\tif (*v3)\n\t\tv5 = atoi(*v3);\n\tif (v5 < 0 || v5 >= num_entries)\n\t\treturn 1;\n\tif (delete_flag)\n\t{\n\t\tfor (i = 1; i <= v5; ++i)\n\t\t{\n\t\t\tv1 = i;\n\t\t\tfree(*(void **)(entries_ptr + 8LL * v1));\n\t\t}\n\t}\n\tnum_entries -= v5;\n\tmemmove(\n\t\t(void *)(entries_ptr + 8LL),\n\t\t(const void *)(entries_ptr + 8 * (v5 + 1LL)),\n\t\t8LL * num_entries);\n\treturn 0;\n}",
        "source_code": "static int FAST_FUNC builtin_shift(char **argv)\n{\n\tint n = 1;\n\targv = skip_dash_dash(argv);\n\tif (argv[0]) {\n\t\tn = atoi(argv[0]);\n\t}\n\tif (n >= 0 && n < G.global_argc) {\n\t\tif (G.global_args_malloced) {\n\t\t\tint m = 1;\n\t\t\twhile (m <= n)\n\t\t\t\tfree(G.global_argv[m++]);\n\t\t}\n\t\tG.global_argc -= n;\n\t\tmemmove(&G.global_argv[1], &G.global_argv[n+1],\n\t\t\t\tG.global_argc * sizeof(G.global_argv[0]));\n\t\treturn EXIT_SUCCESS;\n\t}\n\treturn EXIT_FAILURE;\n}",
        "parsed_output": "static int FAST_FUNC remove_entry(__int64 a1)\n{\n\tint v1;\n\tconst char **v3;\n\tint i;\n\tint v5;\n\n\tv5 = 1;\n\tv3 = (const char **)get_entries(a1);\n\tif (*v3)\n\t\tv5 = atoi(*v3);\n\tif (v5 < 0 || v5 >= num_entries)\n\t\treturn 1;\n\tif (delete_flag)\n\t{\n\t\tfor (i = 1; i <= v5; ++i)\n\t\t{\n\t\t\tv1 = i;\n\t\t\tfree(*(void **)(entries_ptr + 8LL * v1));\n\t\t}\n\t}\n\tnum_entries -= v5;\n\tmemmove(\n\t\t(void *)(entries_ptr + 8LL),\n\t\t(const void *)(entries_ptr + 8 * (v5 + 1LL)),\n\t\t8LL * num_entries);\n\treturn 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_48A1A8(__int64 a1)\n{\n  int v1; // eax\n  const char **v3; // [rsp+8h] [rbp-18h]\n  int i; // [rsp+18h] [rbp-8h]\n  int v5; // [rsp+1Ch] [rbp-4h]\n\n  v5 = 1;\n  v3 = (const char **)sub_48914D(a1);\n  if ( *v3 )\n    v5 = atoi(*v3);\n  if ( v5 < 0 || v5 >= *((_DWORD *)qword_75D408 + 21) )\n    return 1LL;\n  if ( *((_BYTE *)qword_75D408 + 80) )\n  {\n    for ( i = 1; i <= v5; ++i )\n    {\n      v1 = i;\n      free(*(void **)(*((_QWORD *)qword_75D408 + 11) + 8LL * v1));\n    }\n  }\n  *((_DWORD *)qword_75D408 + 21) -= v5;\n  memmove(\n    (void *)(*((_QWORD *)qword_75D408 + 11) + 8LL),\n    (const void *)(*((_QWORD *)qword_75D408 + 11) + 8 * (v5 + 1LL)),\n    8LL * *((int *)qword_75D408 + 21));\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl builtin_shift(char **argv)\n{\n  int v1; // eax\n  char **argva; // [rsp+8h] [rbp-18h]\n  int m; // [rsp+18h] [rbp-8h]\n  int n; // [rsp+1Ch] [rbp-4h]\n\n  n = 1;\n  argva = skip_dash_dash(argv);\n  if ( *argva )\n    n = atoi(*argva);\n  if ( n < 0 || n >= ptr_to_globals->speeds[8] )\n    return 1;\n  if ( LOBYTE(ptr_to_globals->speeds[7]) )\n  {\n    for ( m = 1; m <= n; ++m )\n    {\n      v1 = m;\n      free(*(void **)(*(_QWORD *)&ptr_to_globals->speeds[9] + 8LL * v1));\n    }\n  }\n  ptr_to_globals->speeds[8] -= n;\n  memmove(\n    (void *)(*(_QWORD *)&ptr_to_globals->speeds[9] + 8LL),\n    (const void *)(*(_QWORD *)&ptr_to_globals->speeds[9] + 8 * (n + 1LL)),\n    8LL * ptr_to_globals->speeds[8]);\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.6290952563285828,
        "similarity_score_baseline_stripped": 0.5189699530601501,
        "similarity_score_baseline_debug": 0.7304554581642151
    },
    {
        "func_name": "fast_strtoul_16",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4375C0(char *a1, _WORD *a2)\n{\n  char *v2; // rax\n  _BYTE *v4; // rax\n  char v6; // [rsp+1Fh] [rbp-11h]\n  unsigned int v7; // [rsp+20h] [rbp-10h]\n  unsigned int v8; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+24h] [rbp-Ch]\n  _WORD *v10; // [rsp+28h] [rbp-8h]\n\n  *a2 = 1;\n  v10 = a2 + 1;\n  for ( i = 0; *a1 && i <= 5; ++i )\n  {\n    v2 = a1++;\n    v7 = 16 * sub_437583(*v2);\n    if ( v7 > 0xFF )\n    {\n      *(_DWORD *)qword_75D400 = 22;\n      return 0xFFFFFFFFLL;\n    }\n    v6 = *a1;\n    if ( *a1 != 58 && v6 )\n    {\n      v8 = sub_437583(v6) | v7;\n      if ( v8 > 0xFF )\n      {\n        *(_DWORD *)qword_75D400 = 22;\n        return 0xFFFFFFFFLL;\n      }\n    }\n    else\n    {\n      v8 = v7 >> 4;\n    }\n    if ( v6 )\n      ++a1;\n    v4 = v10;\n    v10 = (_WORD *)((char *)v10 + 1);\n    *v4 = v8;\n    if ( *a1 == 58 )\n      ++a1;\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC ether_input(const char *bufp, struct sockaddr *sap)\n{\n\tunsigned char *ptr;\n\tchar c;\n\tint i;\n\tunsigned val;\n\n\tsap->sa_family = ether_hwtype.type;\n\tptr = (unsigned char*) sap->sa_data;\n\n\ti = 0;\n\twhile ((*bufp != '\\0') && (i < ETH_ALEN)) {\n\t\tval = hexchar2int(*bufp++) * 0x10;\n\t\tif (val > 0xff) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tc = *bufp;\n\t\tif (c == ':' || c == 0)\n\t\t\tval >>= 4;\n\t\telse {\n\t\t\tval |= hexchar2int(c);\n\t\t\tif (val > 0xff) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (c != 0)\n\t\t\tbufp++;\n\t\t*ptr++ = (unsigned char) val;\n\t\ti++;\n\n\t\t/* We might get a semicolon here - not required. */\n\t\tif (*bufp == ':') {\n\t\t\tbufp++;\n\t\t}\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_4C5907(_BYTE *a1, unsigned int *a2)\n{\n  unsigned int *v2; // rax\n  _BYTE *s; // [rsp+8h] [rbp-18h]\n  unsigned int v6; // [rsp+18h] [rbp-8h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  s = a1;\n  memset(a1, 32, (unsigned int)(7 * dword_75D450 + 21));\n  for ( i = 0; i <= 6; ++i )\n  {\n    v2 = a2++;\n    v6 = *v2;\n    if ( *v2 == -1 )\n    {\n      s += (unsigned int)(dword_75D450 + 3);\n    }\n    else\n    {\n      if ( dword_75D450 )\n      {\n        ++s;\n        if ( v6 > 0x63 )\n        {\n          *s = 48;\n          *(s - 1) = v6 / 0x64 + 48;\n          v6 %= 0x64u;\n        }\n      }\n      if ( v6 / 0xA )\n        *s = v6 / 0xA + 48;\n      s[1] = v6 % 0xA + 48;\n      s += 3;\n    }\n  }\n  return s;\n}\n\n\n Revised code:\nstatic char *build_row(char *p, unsigned *dp)\n{\n\tunsigned col, val, day;\n\n\tmemset(p, ' ', (julian + DAY_LEN) * 7);\n\n\tcol = 0;\n\tdo {\n\t\tday = *dp++;\n\t\tif (day != SPACE) {\n\t\t\tif (julian) {\n\t\t\t\t++p;\n\t\t\t\tif (day >= 100) {\n\t\t\t\t\t*p = '0';\n\t\t\t\t\tp[-1] = (day / 100) + '0';\n\t\t\t\t\tday %= 100;\n\t\t\t\t}\n\t\t\t}\n\t\t\tval = day / 10;\n\t\t\tif (val > 0) {\n\t\t\t\t*p = val + '0';\n\t\t\t}\n\t\t\t*++p = day % 10 + '0';\n\t\t\tp += 2;\n\t\t} else {\n\t\t\tp += DAY_LEN + julian;\n\t\t}\n\t} while (++col < 7);\n\n\treturn p;\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_481AB7(__int64 a1)\n{\n  _BYTE *v2; // rax\n  _BYTE *v4; // [rsp+0h] [rbp-18h]\n  int v5; // [rsp+14h] [rbp-4h]\n\n  v5 = 0;\n  v4 = (_BYTE *)(a1 + 1);\n  while ( *v4 )\n  {\n    if ( *v4 == 92 )\n    {\n      if ( !*++v4 )\n        break;\n      ++v4;\n    }\n    else\n    {\n      if ( *v4 == 125 && !v5-- )\n        break;\n      if ( *v4 == 44 && !v5 )\n        break;\n      v2 = v4++;\n      if ( *v2 == 123 )\n        ++v5;\n    }\n  }\n  if ( *v4 )\n    return v4;\n  else\n    return 0LL;\n}\n\n\n Revised code:\nstatic const char *next_brace_sub(const char *cp)\n{\n\tunsigned depth = 0;\n\tcp++;\n\twhile (*cp != '\\0') {\n\t\tif (*cp == '\\\\') {\n\t\t\tif (*++cp == '\\0')\n\t\t\t\tbreak;\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((*cp == '}' && depth-- == 0) || (*cp == ',' && depth == 0))\n\t\t\tbreak;\n\t\tif (*cp++ == '{')\n\t\t\tdepth++;\n\t}\n\n\treturn *cp != '\\0' ? cp : NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_5034D4(_QWORD *a1)\n{\n  _BYTE *v1; // rax\n  __int64 i; // [rsp+10h] [rbp-18h]\n  _BYTE *v4; // [rsp+18h] [rbp-10h]\n  unsigned __int8 v5; // [rsp+27h] [rbp-1h]\n\n  v4 = (_BYTE *)*a1;\n  for ( i = 0LL; ; i = 16 * i + v5 )\n  {\n    v1 = v4++;\n    if ( *v1 <= 0x20u )\n      break;\n    v5 = (*v1 | 0x20) - 48;\n    if ( v5 > 9u )\n      v5 = (*v1 | 0x20) - 87;\n  }\n  *a1 = v4;\n  return i;\n}\n",
        "output": "static unsigned long parse_hex(_QWORD *ptr)\n{\n\tunsigned char *p = (unsigned char *)*ptr;\n\tunsigned long result = 0;\n\tunsigned char val;\n\n\tfor (;;) {\n\t\tunsigned char c = *p++;\n\t\tif (c <= ' ') {\n\t\t\tbreak;\n\t\t}\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tval = c - '0';\n\t\t} else {\n\t\t\tval = (c | 0x20) - 'a' + 10;\n\t\t}\n\t\tresult = (result << 4) + val;\n\t}\n\n\t*ptr = (_QWORD)p;\n\treturn result;\n}",
        "source_code": "ENABLE_PMAP\nstatic unsigned long fast_strtoul_16(char **endptr)\n{\n\tunsigned char c;\n\tchar *str = *endptr;\n\tunsigned long n = 0;\n\n\t/* Need to stop on both ' ' and '\\n' */\n\twhile ((c = *str++) > ' ') {\n\t\tc = ((c|0x20) - '0');\n\t\tif (c > 9)\n\t\t\t/* c = c + '0' - 'a' + 10: */\n\t\t\tc = c - ('a' - '0' - 10);\n\t\tn = n*16 + c;\n\t}\n\t*endptr = str; /* We skip trailing space! */\n\treturn n;\n}",
        "parsed_output": "static unsigned long parse_hex(_QWORD *ptr)\n{\n\tunsigned char *p = (unsigned char *)*ptr;\n\tunsigned long result = 0;\n\tunsigned char val;\n\n\tfor (;;) {\n\t\tunsigned char c = *p++;\n\t\tif (c <= ' ') {\n\t\t\tbreak;\n\t\t}\n\t\tif (c >= '0' && c <= '9') {\n\t\t\tval = c - '0';\n\t\t} else {\n\t\t\tval = (c | 0x20) - 'a' + 10;\n\t\t}\n\t\tresult = (result << 4) + val;\n\t}\n\n\t*ptr = (_QWORD)p;\n\treturn result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_5034D4(_QWORD *a1)\n{\n  _BYTE *v1; // rax\n  __int64 i; // [rsp+10h] [rbp-18h]\n  _BYTE *v4; // [rsp+18h] [rbp-10h]\n  unsigned __int8 v5; // [rsp+27h] [rbp-1h]\n\n  v4 = (_BYTE *)*a1;\n  for ( i = 0LL; ; i = 16 * i + v5 )\n  {\n    v1 = v4++;\n    if ( *v1 <= 0x20u )\n      break;\n    v5 = (*v1 | 0x20) - 48;\n    if ( v5 > 9u )\n      v5 = (*v1 | 0x20) - 87;\n  }\n  *a1 = v4;\n  return i;\n}\n",
        "baseline_code_debug": "unsigned __int64 __cdecl fast_strtoul_16(char **endptr)\n{\n  char *v1; // rax\n  __int64 n; // [rsp+10h] [rbp-18h]\n  char *str; // [rsp+18h] [rbp-10h]\n  unsigned __int8 c; // [rsp+27h] [rbp-1h]\n\n  str = *endptr;\n  for ( n = 0LL; ; n = 16 * n + c )\n  {\n    v1 = str++;\n    if ( (unsigned __int8)*v1 <= 0x20u )\n      break;\n    c = (*v1 | 0x20) - 48;\n    if ( c > 9u )\n      c = (*v1 | 0x20) - 87;\n  }\n  *endptr = str;\n  return n;\n}\n",
        "similarity_score_unixcoder": 0.8005308508872986,
        "similarity_score_baseline_stripped": 0.5518255829811096,
        "similarity_score_baseline_debug": 0.825080931186676
    },
    {
        "func_name": "uname_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_424645(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  int v6; // eax\n  __int64 v7; // r8\n  __int64 v8; // r9\n  char *v9; // rax\n  __int64 v11; // [rsp+0h] [rbp-2E0h]\n  const char *v12; // [rsp+10h] [rbp-2D0h] BYREF\n  struct utsname name; // [rsp+20h] [rbp-2C0h] BYREF\n  char v14[256]; // [rsp+1B0h] [rbp-130h] BYREF\n  __int64 v15; // [rsp+2B0h] [rbp-30h] BYREF\n  int v16; // [rsp+2B8h] [rbp-28h]\n  char *v17; // [rsp+2C8h] [rbp-18h]\n  __int64 v18; // [rsp+2D0h] [rbp-10h]\n  int v19; // [rsp+2D8h] [rbp-8h]\n  unsigned int i; // [rsp+2DCh] [rbp-4h]\n\n  v15 = 0LL;\n  qword_75D440 = (__int64)\"-1\";\n  v19 = sub_4FA1EF(a2, (unsigned int)\"nladvAsDumpF:0\", (unsigned int)&v15, a4, a5, a6);\n  if ( (v19 & 0xFFF) != 0 )\n    v6 = v19 & 0xFFF;\n  else\n    v6 = 4095;\n  v16 = v6;\n  v11 = 8LL * optind + a2;\n  uname(&name);\n  v9 = sub_40A6B3(\"%s/%s/%s\", (__int64)\"/lib/modules\", (__int64)name.release, (__int64)\"modules.dep\", v7, v8);\n  v18 = sub_502450(v9, sub_40984D);\n  while ( (unsigned int)sub_50269B(v18, &v12, 4653314LL, \"# \\t\") )\n  {\n    v17 = sub_408F79(v12, 58);\n    if ( v17 )\n    {\n      *v17 = 0;\n      sub_425F4E(v12, v14);\n      for ( i = 0; *(_QWORD *)(8LL * i + v11); ++i )\n      {\n        if ( !fnmatch(*(const char **)(8LL * i + v11), v14, 0) )\n        {\n          sub_4243F5(v12, (__int64)name.release, (__int64)&v15);\n          *(_QWORD *)(8LL * i + v11) = &unk_51783D;\n        }\n      }\n    }\n  }\n  for ( i = 0; *(_QWORD *)(8LL * i + v11); ++i )\n  {\n    if ( **(_BYTE **)(8LL * i + v11) )\n      sub_4243F5(*(const char **)(8LL * i + v11), (__int64)name.release, (__int64)&v15);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nint modinfo_main(int argc UNUSED_PARAM, char **argv)\n{\n\tstruct modinfo_env env;\n\tchar name[MODULE_NAME_LEN];\n\tstruct utsname uts;\n\tparser_t *parser;\n\tchar *colon, *tokens[2];\n\tunsigned opts;\n\tunsigned i;\n\n\tenv.field = NULL;\n\topt_complementary = \"-1\"; /* minimum one param */\n\topts = getopt32(argv, \"nladvAsDumpF:0\", &env.field);\n\tenv.tags = opts & OPT_TAGS ? opts & OPT_TAGS : OPT_TAGS;\n\targv += optind;\n\n\tuname(&uts);\n\tparser = config_open2(\n\t\txasprintf(\"%s/%s/%s\", CONFIG_DEFAULT_MODULES_DIR, uts.release, CONFIG_DEFAULT_DEPMOD_FILE),\n\t\txfopen_for_read\n\t);\n\n\twhile (config_read(parser, tokens, 2, 1, \"# \\t\", PARSE_NORMAL)) {\n\t\tcolon = last_char_is(tokens[0], ':');\n\t\tif (colon == NULL)\n\t\t\tcontinue;\n\t\t*colon = '\\0';\n\t\tfilename2modname(tokens[0], name);\n\t\tfor (i = 0; argv[i]; i++) {\n\t\t\tif (fnmatch(argv[i], name, 0) == 0) {\n\t\t\t\tmodinfo(tokens[0], uts.release, &env);\n\t\t\t\targv[i] = (char *) \"\";\n\t\t\t}\n\t\t}\n\t}\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tconfig_close(parser);\n\n\tfor (i = 0; argv[i]; i++) {\n\t\tif (argv[i][0]) {\n\t\t\tmodinfo(argv[i], uts.release, &env);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_42B489(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  char *v6; // rdx\n  char **v8; // [rsp+0h] [rbp-40h]\n  char *v9; // [rsp+10h] [rbp-30h] BYREF\n  char *v10; // [rsp+18h] [rbp-28h]\n  __int64 v11; // [rsp+20h] [rbp-20h]\n  char *s; // [rsp+28h] [rbp-18h]\n  __int64 i; // [rsp+30h] [rbp-10h]\n  int v14; // [rsp+3Ch] [rbp-4h]\n\n  qword_75D448 = (__int64)\"domain\";\n  v14 = sub_4FA1EF(a2, (unsigned int)\"dfisF:v\", (unsigned int)&v9, a4, a5, a6);\n  v8 = (char **)(8LL * optind + a2);\n  s = (char *)sub_507F01();\n  if ( *ident == 100 )\n    v14 = 1;\n  if ( (v14 & 0xF) != 0 )\n  {\n    v11 = sub_50C0A2(s);\n    v10 = strchrnul(*(const char **)v11, 46);\n    if ( (v14 & 2) != 0 )\n    {\n      puts(*(const char **)v11);\n    }\n    else if ( (v14 & 8) != 0 )\n    {\n      *v10 = 0;\n      puts(*(const char **)v11);\n    }\n    else if ( (v14 & 1) != 0 )\n    {\n      if ( *v10 )\n        puts(v10 + 1);\n    }\n    else if ( *(_DWORD *)(v11 + 20) == 4 )\n    {\n      for ( i = *(_QWORD *)(v11 + 24); *(_QWORD *)i; i += 8LL )\n      {\n        v6 = inet_ntoa((struct in_addr)(*(struct in_addr **)i)->s_addr);\n        if ( *(_QWORD *)(i + 8) )\n          printf(\"%s \", v6);\n        else\n          printf(\"%s\", v6);\n      }\n      sub_40A659(10);\n    }\n  }\n  else if ( (v14 & 0x10) != 0 )\n  {\n    sub_42B3F8(v9, 1);\n  }\n  else if ( *v8 )\n  {\n    sub_42B3F8(*v8, 0);\n  }\n  else\n  {\n    puts(s);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nint hostname_main(int argc UNUSED_PARAM, char **argv)\n{\n\tenum {\n\t\tOPT_d = 0x1,\n\t\tOPT_f = 0x2,\n\t\tOPT_i = 0x4,\n\t\tOPT_s = 0x8,\n\t\tOPT_F = 0x10,\n\t\tOPT_dfis = 0xf,\n\t};\n\n\tunsigned opts;\n\tchar *buf;\n\tchar *hostname_str;\n\n#if ENABLE_LONG_OPTS\n\tapplet_long_options =\n\t\t\"domain\\0\"     No_argument \"d\"\n\t\t\"fqdn\\0\"       No_argument \"f\"\n\t//Enable if seen in active use in some distro:\n\t//\t\"long\\0\"       No_argument \"f\"\n\t//\t\"ip-address\\0\" No_argument \"i\"\n\t//\t\"short\\0\"      No_argument \"s\"\n\t//\t\"verbose\\0\"    No_argument \"v\"\n\t\t\"file\\0\"       No_argument \"F\"\n\t\t;\n\n#endif\n\t/* dnsdomainname from net-tools 1.60, hostname 1.100 (2001-04-14),\n\t * supports hostname's options too (not just -v as manpage says) */\n\topts = getopt32(argv, \"dfisF:v\", &hostname_str);\n\targv += optind;\n\tbuf = safe_gethostname();\n\tif (applet_name[0] == 'd') /* dnsdomainname? */\n\t\topts = OPT_d;\n\n\tif (opts & OPT_dfis) {\n\t\t/* Cases when we need full hostname (or its part) */\n\t\tstruct hostent *hp;\n\t\tchar *p;\n\n\t\thp = xgethostbyname(buf);\n\t\tp = strchrnul(hp->h_name, '.');\n\t\tif (opts & OPT_f) {\n\t\t\tputs(hp->h_name);\n\t\t} else if (opts & OPT_s) {\n\t\t\t*p = '\\0';\n\t\t\tputs(hp->h_name);\n\t\t} else if (opts & OPT_d) {\n\t\t\tif (*p)\n\t\t\t\tputs(p + 1);\n\t\t} else /*if (opts & OPT_i)*/ {\n\t\t\tif (hp->h_length == sizeof(struct in_addr)) {\n\t\t\t\tstruct in_addr **h_addr_list = (struct in_addr **)hp->h_addr_list;\n\t\t\t\twhile (*h_addr_list) {\n\t\t\t\t\tprintf(h_addr_list[1] ? \"%s \" : \"%s\", inet_ntoa(**h_addr_list));\n\t\t\t\t\th_addr_list++;\n\t\t\t\t}\n\t\t\t\tbb_putchar('\\n');\n\t\t\t}\n\t\t}\n\t} else if (opts & OPT_F) {\n\t\t/* Set the hostname */\n\t\tdo_sethostname(hostname_str, 1);\n\t} else if (argv[0]) {\n\t\t/* Set the hostname */\n\t\tdo_sethostname(argv[0], 0);\n\t} else {\n\t\t/* Just print the current hostname */\n\t\tputs(buf);\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tfree(buf);\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_444637(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6)\n{\n  char *v7; // rax\n  _QWORD *v8; // [rsp+0h] [rbp-50h]\n  const char *v9; // [rsp+10h] [rbp-40h] BYREF\n  char *s; // [rsp+18h] [rbp-38h] BYREF\n  char *name; // [rsp+20h] [rbp-30h] BYREF\n  unsigned int v12; // [rsp+2Ch] [rbp-24h]\n  unsigned int *v13; // [rsp+30h] [rbp-20h]\n  unsigned int v14; // [rsp+3Ch] [rbp-14h]\n  char *v15; // [rsp+40h] [rbp-10h]\n  signed int v16; // [rsp+48h] [rbp-8h]\n  int v17; // [rsp+4Ch] [rbp-4h]\n\n  name = 0LL;\n  s = 0LL;\n  v9 = \"512\";\n  qword_75D440 = (__int64)\"g:p:g--p:p--g:\";\n  v17 = sub_4FA1EF(a2, (unsigned int)\"gpl:r:b:\", (unsigned int)&name, (unsigned int)&s, (unsigned int)&v9, a6);\n  v8 = (_QWORD *)(8LL * optind + a2);\n  v16 = sub_443B44(v9, 0x1001Cu);\n  if ( v16 < 0 )\n    return 1LL;\n  if ( s )\n  {\n    if ( !name )\n    {\n      v15 = strrchr(s, 47);\n      if ( v15 )\n        v7 = v15 + 1;\n      else\n        v7 = s;\n      name = v7;\n    }\n  }\n  else\n  {\n    s = name;\n  }\n  if ( !s || !*v8 )\n    sub_407F64();\n  v14 = sub_50B54B(v8[1], \"udp\", 69LL);\n  v13 = (unsigned int *)sub_50BB2A(*v8, v14);\n  *((_QWORD *)&dest + 72) = s;\n  v12 = sub_443C53(0LL, v13, (__int64)name, s, 1, v16);\n  sub_443B02();\n  if ( v12 && (*name != 45 || name[1]) && (v17 & 1) != 0 )\n    unlink(name);\n  return v12;\n}\n\n\n Revised code:\nint tftp_main(int argc UNUSED_PARAM, char **argv)\n{\n\tlen_and_sockaddr *peer_lsa;\n\tconst char *local_file = NULL;\n\tconst char *remote_file = NULL;\n# if ENABLE_FEATURE_TFTP_BLOCKSIZE\n\tconst char *blksize_str = TFTP_BLKSIZE_DEFAULT_STR;\n\tint blksize;\n# endif\n\tint result;\n\tint port;\n\tIF_GETPUT(int opt;)\n\n\tINIT_G();\n\n\t/* -p or -g is mandatory, and they are mutually exclusive */\n\topt_complementary = \"\" IF_FEATURE_TFTP_GET(\"g:\") IF_FEATURE_TFTP_PUT(\"p:\")\n\t\t\tIF_GETPUT(\"g--p:p--g:\");\n\n\tIF_GETPUT(opt =) getopt32(argv,\n\t\t\tIF_FEATURE_TFTP_GET(\"g\") IF_FEATURE_TFTP_PUT(\"p\")\n\t\t\t\t\"l:r:\" IF_FEATURE_TFTP_BLOCKSIZE(\"b:\"),\n\t\t\t&local_file, &remote_file\n\t\t\tIF_FEATURE_TFTP_BLOCKSIZE(, &blksize_str));\n\targv += optind;\n\n# if ENABLE_FEATURE_TFTP_BLOCKSIZE\n\t/* Check if the blksize is valid:\n\t * RFC2348 says between 8 and 65464 */\n\tblksize = tftp_blksize_check(blksize_str, 65564);\n\tif (blksize < 0) {\n\t\t//bb_error_msg(\"bad block size\");\n\t\treturn EXIT_FAILURE;\n\t}\n# endif\n\n\tif (remote_file) {\n\t\tif (!local_file) {\n\t\t\tconst char *slash = strrchr(remote_file, '/');\n\t\t\tlocal_file = slash ? slash + 1 : remote_file;\n\t\t}\n\t} else {\n\t\tremote_file = local_file;\n\t}\n\n\t/* Error if filename or host is not known */\n\tif (!remote_file || !argv[0])\n\t\tbb_show_usage();\n\n\tport = bb_lookup_port(argv[1], \"udp\", 69);\n\tpeer_lsa = xhost2sockaddr(argv[0], port);\n\n# if ENABLE_TFTP_DEBUG\n\tfprintf(stderr, \"using server '%s', remote_file '%s', local_file '%s'\\n\",\n\t\t\txmalloc_sockaddr2dotted(&peer_lsa->u.sa),\n\t\t\tremote_file, local_file);\n# endif\n\n# if ENABLE_FEATURE_TFTP_PROGRESS_BAR\n\tG.file = remote_file;\n# endif\n\tresult = tftp_protocol(\n\t\tNULL /*our_lsa*/, peer_lsa,\n\t\tlocal_file, remote_file\n\t\tIF_FEATURE_TFTP_BLOCKSIZE(, 1 /* want_transfer_size */)\n\t\tIF_FEATURE_TFTP_BLOCKSIZE(, blksize)\n\t);\n\ttftp_progress_done();\n\n\tif (result != EXIT_SUCCESS && NOT_LONE_DASH(local_file) && CMD_GET(opt)) {\n\t\tunlink(local_file);\n\t}\n\treturn result;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall __noreturn sub_4D78BE(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  struct utsname name; // [rsp+10h] [rbp-240h] BYREF\n  char v7[65]; // [rsp+196h] [rbp-BAh] BYREF\n  char v8[65]; // [rsp+1D7h] [rbp-79h] BYREF\n  char v9[16]; // [rsp+218h] [rbp-38h] BYREF\n  char *v10; // [rsp+228h] [rbp-28h]\n  unsigned int v11; // [rsp+234h] [rbp-1Ch]\n  unsigned __int16 *v12; // [rsp+238h] [rbp-18h]\n  char *format; // [rsp+240h] [rbp-10h]\n  char *src; // [rsp+248h] [rbp-8h]\n\n  src = \"unknown\";\n  qword_75D448 = (__int64)\"all\";\n  v11 = sub_4FA1EF(a2, (unsigned int)\"snrvmpioa\", a3, a4, a5, a6);\n  if ( *(_QWORD *)(8LL * optind + a2) )\n    sub_407F64();\n  if ( (v11 & 0x100) != 0 )\n  {\n    v11 = 255;\n    src = (char *)&unk_526D98;\n  }\n  if ( !v11 )\n    v11 = 1;\n  uname(&name);\n  strcpy(v7, src);\n  strcpy(v8, src);\n  strcpy(v9, \"GNU/Linux\");\n  v12 = (unsigned __int16 *)&unk_526D80;\n  format = \"%s\";\n  while ( 1 )\n  {\n    if ( (v11 & 1) != 0 )\n    {\n      v10 = &name.sysname[*v12];\n      if ( *v10 )\n      {\n        printf(format, v10);\n        format = \" %s\";\n      }\n    }\n    ++v12;\n    v11 >>= 1;\n    if ( !v11 )\n    {\n      sub_40A659(10);\n      sub_4F93C9(0LL);\n    }\n  }\n}\n",
        "output": "void print_os_info() {\n  struct utsname name;\n  char os_name[65];\n  char os_version[65];\n  char os_release[16];\n  char *format;\n  unsigned int flags;\n  unsigned __int16 *flag_ptr;\n\n  char *default_os_name = \"unknown\";\n  qword_75D448 = (__int64)\"all\";\n  flags = sub_4FA1EF(a2, (unsigned int)\"snrvmpioa\", a3, a4, a5, a6);\n  if (*(_QWORD *)(8LL * optind + a2)) {\n    sub_407F64();\n  }\n  if ((flags & 0x100) != 0) {\n    flags = 255;\n    default_os_name = (char *)&unk_526D98;\n  }\n  if (!flags) {\n    flags = 1;\n  }\n  uname(&name);\n  strcpy(os_name, default_os_name);\n  strcpy(os_version, default_os_name);\n  strcpy(os_release, \"GNU/Linux\");\n  flag_ptr = (unsigned __int16 *)&unk_526D80;\n  format = \"%s\";\n  while (1) {\n    if ((flags & 1) != 0) {\n      char *current_flag = &name.sysname[*flag_ptr];\n      if (*current_flag) {\n        printf(format, current_flag);\n        format = \" %s\";\n      }\n    }\n    ++flag_ptr;\n    flags >>= 1;\n    if (!flags) {\n      sub_40A659(10);\n      sub_4F93C9(0LL);\n    }\n  }\n}",
        "source_code": "int uname_main(int argc UNUSED_PARAM, char **argv)\n{\n#if ENABLE_LONG_OPTS\n\tstatic const char uname_longopts[] ALIGN1 =\n\t\t/* name, has_arg, val */\n\t\t\"all\\0\"               No_argument       \"a\"\n\t\t\"kernel-name\\0\"       No_argument       \"s\"\n\t\t\"nodename\\0\"          No_argument       \"n\"\n\t\t\"kernel-release\\0\"    No_argument       \"r\"\n\t\t\"release\\0\"           No_argument       \"r\"\n\t\t\"kernel-version\\0\"    No_argument       \"v\"\n\t\t\"machine\\0\"           No_argument       \"m\"\n\t\t\"processor\\0\"         No_argument       \"p\"\n\t\t\"hardware-platform\\0\" No_argument       \"i\"\n\t\t\"operating-system\\0\"  No_argument       \"o\"\n\t;\n#endif\n\tuname_info_t uname_info;\n#if defined(__sparc__) && defined(__linux__)\n\tchar *fake_sparc = getenv(\"FAKE_SPARC\");\n#endif\n\tconst char *unknown_str = \"unknown\";\n\tconst char *fmt;\n\tconst unsigned short *delta;\n\tunsigned toprint;\n\n\tIF_LONG_OPTS(applet_long_options = uname_longopts);\n\ttoprint = getopt32(argv, options);\n\n\tif (argv[optind]) { /* coreutils-6.9 compat */\n\t\tbb_show_usage();\n\t}\n\n\tif (toprint & (1 << 8)) { /* -a => all opts on */\n\t\ttoprint = (1 << 8) - 1;\n\t\tunknown_str = \"\"; /* -a does not print unknown fields */\n\t}\n\n\tif (toprint == 0) { /* no opts => -s (sysname) */\n\t\ttoprint = 1;\n\t}\n\n\tuname(&uname_info.name); /* never fails */\n\n#if defined(__sparc__) && defined(__linux__)\n\tif (fake_sparc && (fake_sparc[0] | 0x20) == 'y') {\n\t\tstrcpy(uname_info.name.machine, \"sparc\");\n\t}\n#endif\n\tstrcpy(uname_info.processor, unknown_str);\n\tstrcpy(uname_info.platform, unknown_str);\n\tstrcpy(uname_info.os, \"GNU/Linux\");\n#if 0\n\t/* Fedora does something like this */\n\tstrcpy(uname_info.processor, uname_info.name.machine);\n\tstrcpy(uname_info.platform, uname_info.name.machine);\n\tif (uname_info.platform[0] == 'i'\n\t && uname_info.platform[1]\n\t && uname_info.platform[2] == '8'\n\t && uname_info.platform[3] == '6'\n\t) {\n\t\tuname_info.platform[1] = '3';\n\t}\n#endif\n\n\tdelta = utsname_offset;\n\tfmt = \" %s\" + 1;\n\tdo {\n\t\tif (toprint & 1) {\n\t\t\tconst char *p = (char *)(&uname_info) + *delta;\n\t\t\tif (p[0]) {\n\t\t\t\tprintf(fmt, p);\n\t\t\t\tfmt = \" %s\";\n\t\t\t}\n\t\t}\n\t\t++delta;\n\t} while (toprint >>= 1);\n\tbb_putchar('\\n');\n\n\tfflush_stdout_and_exit(EXIT_SUCCESS); /* coreutils-6.9 compat */\n}",
        "parsed_output": "void print_os_info() {\n  struct utsname name;\n  char os_name[65];\n  char os_version[65];\n  char os_release[16];\n  char *format;\n  unsigned int flags;\n  unsigned __int16 *flag_ptr;\n\n  char *default_os_name = \"unknown\";\n  qword_75D448 = (__int64)\"all\";\n  flags = sub_4FA1EF(a2, (unsigned int)\"snrvmpioa\", a3, a4, a5, a6);\n  if (*(_QWORD *)(8LL * optind + a2)) {\n    sub_407F64();\n  }\n  if ((flags & 0x100) != 0) {\n    flags = 255;\n    default_os_name = (char *)&unk_526D98;\n  }\n  if (!flags) {\n    flags = 1;\n  }\n  uname(&name);\n  strcpy(os_name, default_os_name);\n  strcpy(os_version, default_os_name);\n  strcpy(os_release, \"GNU/Linux\");\n  flag_ptr = (unsigned __int16 *)&unk_526D80;\n  format = \"%s\";\n  while (1) {\n    if ((flags & 1) != 0) {\n      char *current_flag = &name.sysname[*flag_ptr];\n      if (*current_flag) {\n        printf(format, current_flag);\n        format = \" %s\";\n      }\n    }\n    ++flag_ptr;\n    flags >>= 1;\n    if (!flags) {\n      sub_40A659(10);\n      sub_4F93C9(0LL);\n    }\n  }\n}",
        "baseline_code_stripped": "void __fastcall __noreturn sub_4D78BE(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  struct utsname name; // [rsp+10h] [rbp-240h] BYREF\n  char v7[65]; // [rsp+196h] [rbp-BAh] BYREF\n  char v8[65]; // [rsp+1D7h] [rbp-79h] BYREF\n  char v9[16]; // [rsp+218h] [rbp-38h] BYREF\n  char *v10; // [rsp+228h] [rbp-28h]\n  unsigned int v11; // [rsp+234h] [rbp-1Ch]\n  unsigned __int16 *v12; // [rsp+238h] [rbp-18h]\n  char *format; // [rsp+240h] [rbp-10h]\n  char *src; // [rsp+248h] [rbp-8h]\n\n  src = \"unknown\";\n  qword_75D448 = (__int64)\"all\";\n  v11 = sub_4FA1EF(a2, (unsigned int)\"snrvmpioa\", a3, a4, a5, a6);\n  if ( *(_QWORD *)(8LL * optind + a2) )\n    sub_407F64();\n  if ( (v11 & 0x100) != 0 )\n  {\n    v11 = 255;\n    src = (char *)&unk_526D98;\n  }\n  if ( !v11 )\n    v11 = 1;\n  uname(&name);\n  strcpy(v7, src);\n  strcpy(v8, src);\n  strcpy(v9, \"GNU/Linux\");\n  v12 = (unsigned __int16 *)&unk_526D80;\n  format = \"%s\";\n  while ( 1 )\n  {\n    if ( (v11 & 1) != 0 )\n    {\n      v10 = &name.sysname[*v12];\n      if ( *v10 )\n      {\n        printf(format, v10);\n        format = \" %s\";\n      }\n    }\n    ++v12;\n    v11 >>= 1;\n    if ( !v11 )\n    {\n      sub_40A659(10);\n      sub_4F93C9(0LL);\n    }\n  }\n}\n",
        "baseline_code_debug": "int __cdecl __noreturn uname_main(int argc, char **argv)\n{\n  uname_info_t uname_info; // [rsp+10h] [rbp-240h] BYREF\n  const char *p; // [rsp+228h] [rbp-28h]\n  unsigned int toprint; // [rsp+234h] [rbp-1Ch]\n  const unsigned __int16 *delta; // [rsp+238h] [rbp-18h]\n  const char *fmt; // [rsp+240h] [rbp-10h]\n  const char *unknown_str; // [rsp+248h] [rbp-8h]\n\n  unknown_str = \"unknown\";\n  applet_long_options = uname_longopts_8125;\n  toprint = getopt32(argv, \"snrvmpioa\");\n  if ( argv[optind] )\n    bb_show_usage();\n  if ( (toprint & 0x100) != 0 )\n  {\n    toprint = 255;\n    unknown_str = (const char *)&unk_526D98;\n  }\n  if ( !toprint )\n    toprint = 1;\n  uname(&uname_info.name);\n  strcpy(uname_info.processor, unknown_str);\n  strcpy(uname_info.platform, unknown_str);\n  strcpy(uname_info.os, \"GNU/Linux\");\n  delta = utsname_offset;\n  fmt = \"%s\";\n  while ( 1 )\n  {\n    if ( (toprint & 1) != 0 )\n    {\n      p = &uname_info.name.sysname[*delta];\n      if ( *p )\n      {\n        printf(fmt, p);\n        fmt = \" %s\";\n      }\n    }\n    ++delta;\n    toprint >>= 1;\n    if ( !toprint )\n    {\n      bb_putchar(10);\n      fflush_stdout_and_exit(0);\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.7508249878883362,
        "similarity_score_baseline_stripped": 0.7161283493041992,
        "similarity_score_baseline_debug": 0.8463064432144165
    },
    {
        "func_name": "strrev",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A8B04(__int64 a1, int a2, int a3, int a4)\n{\n  __int64 result; // rax\n  unsigned int v8; // [rsp+20h] [rbp-4h]\n\n  while ( a4 > 0 )\n  {\n    v8 = *(_DWORD *)(4LL * a2 + a1);\n    *(_DWORD *)(4LL * a2 + a1) = *(_DWORD *)(4LL * a3 + a1);\n    result = v8;\n    *(_DWORD *)(a1 + 4LL * a3) = v8;\n    ++a2;\n    ++a3;\n    --a4;\n  }\n  return result;\n}\n\n\n Revised code:\nvoid mvswap(uint32_t* ptr, int32_t zzp1, int32_t zzp2, int32_t zzn)\n{\n\twhile (zzn > 0) {\n\t\tmswap(ptr[zzp1], ptr[zzp2]);\n\t\tzzp1++;\n\t\tzzp2++;\n\t\tzzn--;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4FEB8C(__int64 a1, unsigned int a2, int a3)\n{\n  __int64 result; // rax\n  _WORD *v4; // rax\n  int v5; // [rsp+0h] [rbp-10h]\n  unsigned int v6; // [rsp+4h] [rbp-Ch]\n\n  v6 = a2;\n  v5 = a3;\n  result = a2;\n  if ( a2 != a3 )\n  {\n    while ( 1 )\n    {\n      v4 = (_WORD *)(2LL * (int)v6 + a1);\n      *v4 = *(_WORD *)(a1 + 2LL * v5);\n      result = (unsigned __int16)*v4;\n      if ( !(_WORD)result )\n        break;\n      ++v6;\n      ++v5;\n    }\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void remove_chunk(int16_t *int_buf, int beg, int end)\n{\n\t/* beg must be <= end */\n\tif (beg == end)\n\t\treturn;\n\n\twhile ((int_buf[beg] = int_buf[end]) != 0)\n\t\tbeg++, end++;\n\n\tif (dbg_bmp) {\n\t\tint i;\n\t\tfor (i = 0; int_buf[i]; i++)\n\t\t\tbb_putchar((unsigned char)int_buf[i]);\n\t\tbb_putchar('\\n');\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_505297(__int64 a1, unsigned int a2)\n{\n  __int64 result; // rax\n  int i; // [rsp+10h] [rbp-Ch]\n  int v4; // [rsp+14h] [rbp-8h]\n  unsigned int v5; // [rsp+18h] [rbp-4h]\n\n  result = a1;\n  *(_DWORD *)(a1 + 8) = 0;\n  v4 = 1;\n  v5 = 0x800000;\n  for ( i = 0; i <= 23; ++i )\n  {\n    result = v4 & a2;\n    if ( (_DWORD)result )\n    {\n      result = a1;\n      *(_DWORD *)(a1 + 8) |= v5;\n    }\n    v4 *= 2;\n    v5 >>= 1;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\nsetup_salt(struct des_ctx *ctx, uint32_t salt)\n{\n\tuint32_t obit, saltbit;\n\tint i;\n\n#if USE_REPETITIVE_SPEEDUP\n\tif (salt == old_salt)\n\t\treturn;\n\told_salt = salt;\n#endif\n\n\tsaltbits = 0;\n\tsaltbit = 1;\n\tobit = 0x800000;\n\tfor (i = 0; i < 24; i++) {\n\t\tif (salt & saltbit)\n\t\t\tsaltbits |= obit;\n\t\tsaltbit <<= 1;\n\t\tobit >>= 1;\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4A3D68(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+0h] [rbp-1Ch]\n  int v4; // [rsp+14h] [rbp-8h]\n  unsigned int i; // [rsp+18h] [rbp-4h]\n\n  v3 = a2;\n  if ( a2 )\n  {\n    v3 = a2 - 1;\n    if ( a2 != 1 && *(_DWORD *)(4LL * v3 + a1) == 10 )\n      v3 = a2 - 2;\n  }\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i >= v3 )\n      break;\n    v4 = *(_DWORD *)(4LL * (int)i + a1);\n    *(_DWORD *)(4LL * (int)i + a1) = *(_DWORD *)(4LL * v3 + a1);\n    *(_DWORD *)(a1 + 4LL * v3--) = v4;\n  }\n  return result;\n}\n",
        "output": "void swap_elements(__int64* arr, int size)\n{\n  int last_index = size;\n  if (size > 0)\n  {\n    last_index = size - 1;\n    if (size != 1 && arr[4 * last_index] == 10)\n      last_index = size - 2;\n  }\n  for (unsigned int i = 0; ; ++i)\n  {\n    if ((int)i >= last_index)\n      break;\n    int temp = arr[4 * i];\n    arr[4 * i] = arr[4 * last_index];\n    arr[last_index * 4] = temp;\n    last_index--;\n  }\n}",
        "source_code": "static void strrev(CHAR_T *s, int len)\n{\n\tint i;\n\n\tif (len != 0) {\n\t\tlen--;\n\t\tif (len != 0 && s[len] == '\\n')\n\t\t\tlen--;\n\t}\n\n\tfor (i = 0; i < len; i++, len--) {\n\t\tCHAR_T c = s[i];\n\t\ts[i] = s[len];\n\t\ts[len] = c;\n\t}\n}",
        "parsed_output": "void swap_elements(__int64* arr, int size)\n{\n  int last_index = size;\n  if (size > 0)\n  {\n    last_index = size - 1;\n    if (size != 1 && arr[4 * last_index] == 10)\n      last_index = size - 2;\n  }\n  for (unsigned int i = 0; ; ++i)\n  {\n    if ((int)i >= last_index)\n      break;\n    int temp = arr[4 * i];\n    arr[4 * i] = arr[4 * last_index];\n    arr[last_index * 4] = temp;\n    last_index--;\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4A3D68(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+0h] [rbp-1Ch]\n  int v4; // [rsp+14h] [rbp-8h]\n  unsigned int i; // [rsp+18h] [rbp-4h]\n\n  v3 = a2;\n  if ( a2 )\n  {\n    v3 = a2 - 1;\n    if ( a2 != 1 && *(_DWORD *)(4LL * v3 + a1) == 10 )\n      v3 = a2 - 2;\n  }\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i >= v3 )\n      break;\n    v4 = *(_DWORD *)(4LL * (int)i + a1);\n    *(_DWORD *)(4LL * (int)i + a1) = *(_DWORD *)(4LL * v3 + a1);\n    *(_DWORD *)(a1 + 4LL * v3--) = v4;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl strrev(wchar_t *s, int len)\n{\n  int lena; // [rsp+0h] [rbp-1Ch]\n  wchar_t c; // [rsp+14h] [rbp-8h]\n  int i; // [rsp+18h] [rbp-4h]\n\n  lena = len;\n  if ( len )\n  {\n    lena = len - 1;\n    if ( len != 1 && s[lena] == 10 )\n      lena = len - 2;\n  }\n  for ( i = 0; i < lena; ++i )\n  {\n    c = s[i];\n    s[i] = s[lena];\n    s[lena--] = c;\n  }\n}\n",
        "similarity_score_unixcoder": 0.5630995035171509,
        "similarity_score_baseline_stripped": 0.48265665769577026,
        "similarity_score_baseline_debug": 0.8269227743148804
    },
    {
        "func_name": "clearredir",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_471D7E(FILE *a1, char a2)\n{\n  __int64 result; // rax\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  while ( (int)sub_4718A4(1, 0LL) > 0 )\n    ;\n  result = qword_75AFB0;\n  for ( i = qword_75AFB0; i; i = result )\n  {\n    if ( (a2 & 4) == 0 || (*(_BYTE *)(i + 31) & 0x10) != 0 )\n      sub_471AE1(a1, i, a2);\n    result = *(_QWORD *)(i + 32);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\nshowjobs(FILE *out, int mode)\n{\n\tstruct job *jp;\n\n\tTRACE((\"showjobs(0x%x) called\\n\", mode));\n\n\t/* Handle all finished jobs */\n\twhile (dowait(DOWAIT_NONBLOCK, NULL) > 0)\n\t\tcontinue;\n\n\tfor (jp = curjob; jp; jp = jp->prev_job) {\n\t\tif (!(mode & SHOW_CHANGED) || jp->changed) {\n\t\t\tshowjob(out, jp, mode);\n\t\t}\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47EBE4(const char *a1)\n{\n  __int64 result; // rax\n\n  result = (__int64)sub_476FA6(a1, 0);\n  if ( result )\n  {\n    result = *(unsigned __int8 *)(result + 16);\n    if ( (_BYTE)result == 1 )\n      return sub_4770DD((__int64)a1, 0LL);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\nunsetfunc(const char *name)\n{\n\tstruct tblentry *cmdp;\n\n\tcmdp = cmdlookup(name, 0);\n\tif (cmdp != NULL && cmdp->cmdtype == CMDFUNCTION)\n\t\tdelete_cmd_entry();\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_45F76C(unsigned int a1)\n{\n  __int64 result; // rax\n\n  while ( 1 )\n  {\n    result = a1--;\n    if ( !(_DWORD)result )\n      break;\n    sub_45F732(63);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void put_question_marks(int count)\n{\n\twhile (count--)\n\t\tput_c('?');\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_473AA2(int a1)\n{\n  __int64 result; // rax\n\n  while ( 1 )\n  {\n    *(_DWORD *)(qword_75D420 + 32) = 0;\n    result = *(_QWORD *)(qword_75D420 + 24);\n    if ( !result )\n      break;\n    sub_473973(a1, 0LL);\n  }\n  return result;\n}\n",
        "output": "static void clearData(int a1)\n{\n\twhile (1)\n\t{\n\t\t*(_DWORD *)(qword_75D420 + 32) = 0;\n\t\tresult = *(_QWORD *)(qword_75D420 + 24);\n\t\tif (!result)\n\t\t\tbreak;\n\t\tsub_473973(a1, 0LL);\n\t}\n\treturn result;\n}",
        "source_code": "static void\nclearredir(int drop)\n{\n\tfor (;;) {\n\t\tg_nullredirs = 0;\n\t\tif (!redirlist)\n\t\t\tbreak;\n\t\tpopredir(drop, /*restore:*/ 0);\n\t}\n}",
        "parsed_output": "static void clearData(int a1)\n{\n\twhile (1)\n\t{\n\t\t*(_DWORD *)(qword_75D420 + 32) = 0;\n\t\tresult = *(_QWORD *)(qword_75D420 + 24);\n\t\tif (!result)\n\t\t\tbreak;\n\t\tsub_473973(a1, 0LL);\n\t}\n\treturn result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_473AA2(int a1)\n{\n  __int64 result; // rax\n\n  while ( 1 )\n  {\n    *(_DWORD *)(qword_75D420 + 32) = 0;\n    result = *(_QWORD *)(qword_75D420 + 24);\n    if ( !result )\n      break;\n    sub_473973(a1, 0LL);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl clearredir(int drop)\n{\n  while ( 1 )\n  {\n    ash_ptr_to_globals_var->g_nullredirs = 0;\n    if ( !ash_ptr_to_globals_var->redirlist )\n      break;\n    popredir(drop, 0);\n  }\n}\n",
        "similarity_score_unixcoder": 0.4557695686817169,
        "similarity_score_baseline_stripped": 0.38169553875923157,
        "similarity_score_baseline_debug": 0.8097824454307556
    },
    {
        "func_name": "tail_read",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_4DBEE4(char *a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  struct stat64 stat_buf; // [rsp+10h] [rbp-90h] BYREF\n\n  if ( sub_407E10(a1, &stat_buf) == -1 )\n    return sub_4091D9((__int64)\"stat %s\", (__int64)a1, v1, v2, v3, v4);\n  if ( (stat_buf.st_mode & 0xF000) != 0x4000 || (dword_75D450 & 4) != 0 )\n    return sub_4DBC96(a1);\n  return sub_4DA317(a1, (void (__fastcall *)(const char *, struct dirent64 *, __int64))sub_4DBD9E, 0LL);\n}\n\n\n Revised code:\nstatic void lsattr_args(const char *name)\n{\n\tstruct stat st;\n\n\tif (lstat(name, &st) == -1) {\n\t\tbb_perror_msg(\"stat %s\", name);\n\t} else if (S_ISDIR(st.st_mode) && !(option_mask32 & OPT_DIRS_OPT)) {\n\t\titerate_on_dir(name, lsattr_dir_proc, NULL);\n\t} else {\n\t\tlist_attributes(name);\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4DBD9E(void *a1, _BYTE *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  struct stat64 stat_buf; // [rsp+20h] [rbp-A0h] BYREF\n  void *ptr; // [rsp+B8h] [rbp-8h]\n\n  ptr = (void *)sub_408E19(a1, a2 + 19);\n  if ( sub_407E10((char *)ptr, &stat_buf) )\n  {\n    sub_4091D9((__int64)\"stat %s\", (__int64)ptr, v2, v3, v4, v5);\n  }\n  else if ( a2[19] != 46 || (dword_75D450 & 2) != 0 )\n  {\n    sub_4DBC96((char *)ptr);\n    if ( (stat_buf.st_mode & 0xF000) == 0x4000\n      && (dword_75D450 & 1) != 0\n      && (a2[19] != 46 || a2[20] && (a2[20] != 46 || a2[21])) )\n    {\n      printf(\"\\n%s:\\n\", (const char *)ptr);\n      sub_4DA317((const char *)ptr, (void (__fastcall *)(const char *, struct dirent64 *, __int64))sub_4DBD9E, 0LL);\n      sub_40A659(10);\n    }\n  }\n  free(ptr);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC lsattr_dir_proc(const char *dir_name,\n\t\tstruct dirent *de,\n\t\tvoid *private UNUSED_PARAM)\n{\n\tstruct stat st;\n\tchar *path;\n\n\tpath = concat_path_file(dir_name, de->d_name);\n\n\tif (lstat(path, &st) != 0)\n\t\tbb_perror_msg(\"stat %s\", path);\n\telse if (de->d_name[0] != '.' || (option_mask32 & OPT_ALL)) {\n\t\tlist_attributes(path);\n\t\tif (S_ISDIR(st.st_mode) && (option_mask32 & OPT_RECUR)\n\t\t && !DOT_OR_DOTDOT(de->d_name)\n\t\t) {\n\t\t\tprintf(\"\\n%s:\\n\", path);\n\t\t\titerate_on_dir(path, lsattr_dir_proc, NULL);\n\t\t\tbb_putchar('\\n');\n\t\t}\n\t}\n\n\tfree(path);\n\treturn 0;\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_4B41FE(char *a1, unsigned int a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  struct stat64 stat_buf; // [rsp+10h] [rbp-A0h] BYREF\n  void *ptr; // [rsp+A0h] [rbp-10h]\n  int v8; // [rsp+ACh] [rbp-4h]\n\n  if ( (sub_4B4104(1037, a2) & 1) != 0 )\n  {\n    v8 = sub_407E10(a1, &stat_buf);\n    if ( !v8 && (stat_buf.st_mode & 0xF000) == 0x8000 )\n    {\n      ptr = sub_40A6B3(\"%s.rpmorig\", (__int64)a1, v2, v3, v4, v5);\n      sub_4F68A4(a1, ptr, 5LL);\n      sub_507831(a1, 12LL);\n      free(ptr);\n    }\n  }\n}\n\n\n Revised code:\nstatic void fileaction_dobackup(char *filename, int fileref)\n{\n\tstruct stat oldfile;\n\tint stat_res;\n\tchar *newname;\n\tif (rpm_getint(TAG_FILEFLAGS, fileref) & RPMFILE_CONFIG) {\n\t\t/* Only need to backup config files */\n\t\tstat_res = lstat(filename, &oldfile);\n\t\tif (stat_res == 0 && S_ISREG(oldfile.st_mode)) {\n\t\t\t/* File already exists  - really should check MD5's etc to see if different */\n\t\t\tnewname = xasprintf(\"%s.rpmorig\", filename);\n\t\t\tcopy_file(filename, newname, FILEUTILS_RECUR | FILEUTILS_PRESERVE_STATUS);\n\t\t\tremove_file(filename, FILEUTILS_RECUR | FILEUTILS_FORCE);\n\t\t\tfree(newname);\n\t\t}\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nssize_t __fastcall sub_4D5282(int a1, char *a2, size_t a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  struct stat64 stat_buf; // [rsp+20h] [rbp-A0h] BYREF\n  ssize_t v10; // [rsp+B0h] [rbp-10h]\n  __off64_t v11; // [rsp+B8h] [rbp-8h]\n\n  if ( !sub_407E00(a1, &stat_buf) && stat_buf.st_size > 0 )\n  {\n    v11 = lseek64(a1, 0LL, 1);\n    if ( v11 > stat_buf.st_size )\n      sub_40A557(a1, 0LL, 0);\n  }\n  v10 = sub_40B446(a1, a2, a3);\n  if ( v10 < 0 )\n  {\n    sub_4091D9((__int64)\"read error\", (__int64)a2, v3, v4, v5, v6);\n    BYTE1(dest.c_iflag) = 1;\n  }\n  return v10;\n}\n",
        "output": "static ssize_t read_file(int file_descriptor, char *buffer, size_t buffer_size)\n{\n\tstruct stat file_stat;\n\tssize_t bytes_read;\n\n\tif (!sub_407E00(file_descriptor, &file_stat) && file_stat.st_size > 0) {\n\t\toff64_t current_offset = lseek64(file_descriptor, 0LL, SEEK_CUR);\n\t\tif (current_offset > file_stat.st_size)\n\t\t\tsub_40A557(file_descriptor, 0LL, 0);\n\t}\n\n\tbytes_read = sub_40B446(file_descriptor, buffer, buffer_size);\n\tif (bytes_read < 0) {\n\t\tsub_4091D9((__int64)\"read error\", (__int64)buffer, v3, v4, v5, v6);\n\t\tBYTE1(dest.c_iflag) = 1;\n\t}\n\n\treturn bytes_read;\n}",
        "source_code": "static ssize_t tail_read(int fd, char *buf, size_t count)\n{\n\tssize_t r;\n\toff_t current;\n\tstruct stat sbuf;\n\n\t/* /proc files report zero st_size, don't lseek them. */\n\tif (fstat(fd, &sbuf) == 0 && sbuf.st_size > 0) {\n\t\tcurrent = lseek(fd, 0, SEEK_CUR);\n\t\tif (sbuf.st_size < current)\n\t\t\txlseek(fd, 0, SEEK_SET);\n\t}\n\n\tr = full_read(fd, buf, count);\n\tif (r < 0) {\n\t\tbb_perror_msg(bb_msg_read_error);\n\t\tG.exitcode = EXIT_FAILURE;\n\t}\n\n\treturn r;\n}",
        "parsed_output": "static ssize_t read_file(int file_descriptor, char *buffer, size_t buffer_size)\n{\n\tstruct stat file_stat;\n\tssize_t bytes_read;\n\n\tif (!sub_407E00(file_descriptor, &file_stat) && file_stat.st_size > 0) {\n\t\toff64_t current_offset = lseek64(file_descriptor, 0LL, SEEK_CUR);\n\t\tif (current_offset > file_stat.st_size)\n\t\t\tsub_40A557(file_descriptor, 0LL, 0);\n\t}\n\n\tbytes_read = sub_40B446(file_descriptor, buffer, buffer_size);\n\tif (bytes_read < 0) {\n\t\tsub_4091D9((__int64)\"read error\", (__int64)buffer, v3, v4, v5, v6);\n\t\tBYTE1(dest.c_iflag) = 1;\n\t}\n\n\treturn bytes_read;\n}",
        "baseline_code_stripped": "ssize_t __fastcall sub_4D5282(int a1, char *a2, size_t a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  struct stat64 stat_buf; // [rsp+20h] [rbp-A0h] BYREF\n  ssize_t v10; // [rsp+B0h] [rbp-10h]\n  __off64_t v11; // [rsp+B8h] [rbp-8h]\n\n  if ( !sub_407E00(a1, &stat_buf) && stat_buf.st_size > 0 )\n  {\n    v11 = lseek64(a1, 0LL, 1);\n    if ( v11 > stat_buf.st_size )\n      sub_40A557(a1, 0LL, 0);\n  }\n  v10 = sub_40B446(a1, a2, a3);\n  if ( v10 < 0 )\n  {\n    sub_4091D9((__int64)\"read error\", (__int64)a2, v3, v4, v5, v6);\n    BYTE1(dest.c_iflag) = 1;\n  }\n  return v10;\n}\n",
        "baseline_code_debug": "ssize_t __cdecl tail_read(int fd, char *buf, size_t count)\n{\n  stat sbuf; // [rsp+20h] [rbp-A0h] BYREF\n  ssize_t r; // [rsp+B0h] [rbp-10h]\n  off_t current; // [rsp+B8h] [rbp-8h]\n\n  if ( !fstat64(fd, (stat64 *)&sbuf) && sbuf.st_size > 0 )\n  {\n    current = lseek64(fd, 0LL, 1);\n    if ( current > sbuf.st_size )\n      xlseek(fd, 0LL, 0);\n  }\n  r = full_read(fd, buf, count);\n  if ( r < 0 )\n  {\n    bb_perror_msg(\"read error\");\n    BYTE1(bb_common_bufsiz1.c_iflag) = 1;\n  }\n  return r;\n}\n",
        "similarity_score_unixcoder": 0.7143036127090454,
        "similarity_score_baseline_stripped": 0.6023973822593689,
        "similarity_score_baseline_debug": 0.8180274963378906
    },
    {
        "func_name": "recordregion",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4740C5(int a1, __int64 a2)\n{\n  __int64 result; // rax\n  void *v3; // rdi\n  __int64 v4; // rdi\n  __int64 v6; // [rsp+10h] [rbp-10h]\n  void *v7; // [rsp+18h] [rbp-8h]\n\n  result = qword_75AFF8;\n  if ( qword_75AFF8 )\n  {\n    if ( a1 >= dword_75AFEC )\n    {\n      for ( qword_75AFF8 = (__int64)&qword_75AFE0;\n            *(_QWORD *)qword_75AFF8 && a1 > *(_DWORD *)(*(_QWORD *)qword_75AFF8 + 8LL);\n            qword_75AFF8 = *(_QWORD *)qword_75AFF8 )\n      {\n        ;\n      }\n      while ( *(_QWORD *)qword_75AFF8 )\n      {\n        ++*(_DWORD *)(qword_75D418 + 48);\n        v6 = **(_QWORD **)qword_75AFF8;\n        v4 = *(_QWORD *)qword_75AFF8;\n        free(*(void **)qword_75AFF8);\n        *(_QWORD *)qword_75AFF8 = v6;\n        sub_46E03F(v4, a2);\n      }\n      result = *(unsigned int *)(qword_75AFF8 + 12);\n      if ( a1 < (int)result )\n      {\n        result = qword_75AFF8;\n        *(_DWORD *)(qword_75AFF8 + 12) = a1;\n      }\n    }\n    else\n    {\n      while ( qword_75AFE0 )\n      {\n        ++*(_DWORD *)(qword_75D418 + 48);\n        v7 = *(void **)qword_75AFE0;\n        v3 = qword_75AFE0;\n        free(qword_75AFE0);\n        qword_75AFE0 = v7;\n        sub_46E03F(v3, a2);\n      }\n      result = (unsigned int)dword_75AFE8;\n      if ( a1 >= dword_75AFE8 )\n      {\n        qword_75AFF8 = (__int64)&qword_75AFE0;\n        result = (unsigned int)a1;\n        dword_75AFEC = a1;\n      }\n      else\n      {\n        qword_75AFF8 = 0LL;\n      }\n    }\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\nremoverecordregions(int endoff)\n{\n\tif (ifslastp == NULL)\n\t\treturn;\n\n\tif (ifsfirst.endoff > endoff) {\n\t\twhile (ifsfirst.next) {\n\t\t\tstruct ifsregion *ifsp;\n\t\t\tINT_OFF;\n\t\t\tifsp = ifsfirst.next->next;\n\t\t\tfree(ifsfirst.next);\n\t\t\tifsfirst.next = ifsp;\n\t\t\tINT_ON;\n\t\t}\n\t\tif (ifsfirst.begoff > endoff) {\n\t\t\tifslastp = NULL;\n\t\t} else {\n\t\t\tifslastp = &ifsfirst;\n\t\t\tifsfirst.endoff = endoff;\n\t\t}\n\t\treturn;\n\t}\n\n\tifslastp = &ifsfirst;\n\twhile (ifslastp->next && ifslastp->next->begoff < endoff)\n\t\tifslastp = ifslastp->next;\n\twhile (ifslastp->next) {\n\t\tstruct ifsregion *ifsp;\n\t\tINT_OFF;\n\t\tifsp = ifslastp->next->next;\n\t\tfree(ifslastp->next);\n\t\tifslastp->next = ifsp;\n\t\tINT_ON;\n\t}\n\tif (ifslastp->endoff > endoff)\n\t\tifslastp->endoff = endoff;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47A87E(const char **a1, __int64 a2)\n{\n  const char **v2; // rax\n  char **v3; // rbx\n  __int64 result; // rax\n  const char **v5; // [rsp+8h] [rbp-38h]\n  char **v6; // [rsp+18h] [rbp-28h]\n  int i; // [rsp+24h] [rbp-1Ch]\n  char **v8; // [rsp+28h] [rbp-18h]\n\n  v5 = a1;\n  for ( i = 0; a1[i]; ++i )\n    ;\n  v6 = (char **)sub_40A05F(8LL * (i + 1), a2);\n  v8 = v6;\n  while ( *v5 )\n  {\n    v2 = v5++;\n    v3 = v8++;\n    *v3 = sub_40A11F(*v2, a2);\n  }\n  *v8 = 0LL;\n  sub_46F1BA(qword_75D420);\n  *(_BYTE *)(qword_75D420 + 12) = 1;\n  *(_DWORD *)qword_75D420 = i;\n  *(_QWORD *)(qword_75D420 + 16) = v6;\n  *(_DWORD *)(qword_75D420 + 4) = 1;\n  result = qword_75D420;\n  *(_DWORD *)(qword_75D420 + 8) = -1;\n  return result;\n}\n\n\n Revised code:\nstatic void\nsetparam(char **argv)\n{\n\tchar **newparam;\n\tchar **ap;\n\tint nparam;\n\n\tfor (nparam = 0; argv[nparam]; nparam++)\n\t\tcontinue;\n\tap = newparam = ckmalloc((nparam + 1) * sizeof(*ap));\n\twhile (*argv) {\n\t\t*ap++ = ckstrdup(*argv++);\n\t}\n\t*ap = NULL;\n\tfreeparam(&shellparam);\n\tshellparam.malloced = 1;\n\tshellparam.nparam = nparam;\n\tshellparam.p = newparam;\n#if ENABLE_ASH_GETOPTS\n\tshellparam.optind = 1;\n\tshellparam.optoff = -1;\n#endif\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_43B939(__int64 a1, __int64 a2)\n{\n  void *result; // rax\n  _QWORD *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40A0E8(0x170uLL, a2);\n  *v3 = sub_50BB2A(a1, 123LL);\n  v3[1] = sub_50BFDE(*v3 + 4LL);\n  *((_DWORD *)v3 + 4) = -1;\n  *((_BYTE *)v3 + 296) = 35;\n  v3[4] = *(_QWORD *)qword_75D408;\n  sub_43B74C((__int64)v3, 2.0);\n  sub_408FD2((_QWORD *)qword_75D408 + 6, (__int64)v3);\n  result = qword_75D408;\n  ++*((_DWORD *)qword_75D408 + 16);\n  return result;\n}\n\n\n Revised code:\nstatic void\nadd_peers(char *s)\n{\n\tpeer_t *p;\n\n\tp = xzalloc(sizeof(*p));\n\tp->p_lsa = xhost2sockaddr(s, 123);\n\tp->p_dotted = xmalloc_sockaddr2dotted_noport(&p->p_lsa->u.sa);\n\tp->p_fd = -1;\n\tp->p_xmt_msg.m_status = MODE_CLIENT | (NTP_VERSION << 3);\n\tp->next_action_time = G.cur_time; /* = set_next(p, 0); */\n\treset_peer_stats(p, 16 * STEP_THRESHOLD);\n\n\tllist_add_to(&G.ntp_peers, p);\n\tG.peer_cnt++;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_474038(int a1, __int64 a2, int a3)\n{\n  __int64 result; // rax\n  void **v5; // [rsp+18h] [rbp-8h]\n\n  if ( qword_75AFF8 )\n  {\n    ++*(_DWORD *)(qword_75D418 + 48);\n    v5 = (void **)sub_40A0E8(0x18uLL, a2);\n    *(_QWORD *)qword_75AFF8 = v5;\n    sub_46E03F(24LL, a2);\n  }\n  else\n  {\n    v5 = &qword_75AFE0;\n  }\n  qword_75AFF8 = (__int64)v5;\n  *((_DWORD *)v5 + 2) = a1;\n  *(_DWORD *)(qword_75AFF8 + 12) = a2;\n  result = qword_75AFF8;\n  *(_DWORD *)(qword_75AFF8 + 16) = a3;\n  return result;\n}\n",
        "output": "static void\nset_data(int a1, int a2, int a3)\n{\n\tif (qword_75AFF8) {\n\t\t++*(_DWORD *)(qword_75D418 + 48);\n\t\tvoid **v5 = (void **)sub_40A0E8(0x18uLL, a2);\n\t\t*(_QWORD *)qword_75AFF8 = v5;\n\t\tsub_46E03F(24LL, a2);\n\t} else {\n\t\tvoid **v5 = &qword_75AFE0;\n\t}\n\tqword_75AFF8 = (__int64)v5;\n\t*((_DWORD *)v5 + 2) = a1;\n\t*(_DWORD *)(qword_75AFF8 + 12) = a2;\n\t*(_DWORD *)(qword_75AFF8 + 16) = a3;\n}",
        "source_code": "static void\nrecordregion(int start, int end, int nulonly)\n{\n\tstruct ifsregion *ifsp;\n\n\tif (ifslastp == NULL) {\n\t\tifsp = &ifsfirst;\n\t} else {\n\t\tINT_OFF;\n\t\tifsp = ckzalloc(sizeof(*ifsp));\n\t\t/*ifsp->next = NULL; - ckzalloc did it */\n\t\tifslastp->next = ifsp;\n\t\tINT_ON;\n\t}\n\tifslastp = ifsp;\n\tifslastp->begoff = start;\n\tifslastp->endoff = end;\n\tifslastp->nulonly = nulonly;\n}",
        "parsed_output": "static void\nset_data(int a1, int a2, int a3)\n{\n\tif (qword_75AFF8) {\n\t\t++*(_DWORD *)(qword_75D418 + 48);\n\t\tvoid **v5 = (void **)sub_40A0E8(0x18uLL, a2);\n\t\t*(_QWORD *)qword_75AFF8 = v5;\n\t\tsub_46E03F(24LL, a2);\n\t} else {\n\t\tvoid **v5 = &qword_75AFE0;\n\t}\n\tqword_75AFF8 = (__int64)v5;\n\t*((_DWORD *)v5 + 2) = a1;\n\t*(_DWORD *)(qword_75AFF8 + 12) = a2;\n\t*(_DWORD *)(qword_75AFF8 + 16) = a3;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_474038(int a1, __int64 a2, int a3)\n{\n  __int64 result; // rax\n  void **v5; // [rsp+18h] [rbp-8h]\n\n  if ( qword_75AFF8 )\n  {\n    ++*(_DWORD *)(qword_75D418 + 48);\n    v5 = (void **)sub_40A0E8(0x18uLL, a2);\n    *(_QWORD *)qword_75AFF8 = v5;\n    sub_46E03F(24LL, a2);\n  }\n  else\n  {\n    v5 = &qword_75AFE0;\n  }\n  qword_75AFF8 = (__int64)v5;\n  *((_DWORD *)v5 + 2) = a1;\n  *(_DWORD *)(qword_75AFF8 + 12) = a2;\n  result = qword_75AFF8;\n  *(_DWORD *)(qword_75AFF8 + 16) = a3;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl recordregion(int start, int end, int nulonly)\n{\n  ifsregion *ifsp; // [rsp+18h] [rbp-8h]\n\n  if ( ifslastp )\n  {\n    ++ash_ptr_to_globals_misc->suppress_int;\n    ifsp = (ifsregion *)xzalloc(0x18uLL);\n    ifslastp->next = ifsp;\n    int_on();\n  }\n  else\n  {\n    ifsp = &ifsfirst;\n  }\n  ifslastp = ifsp;\n  ifsp->begoff = start;\n  ifslastp->endoff = end;\n  ifslastp->nulonly = nulonly;\n}\n",
        "similarity_score_unixcoder": 0.46375909447669983,
        "similarity_score_baseline_stripped": 0.42085450887680054,
        "similarity_score_baseline_debug": 0.8764182329177856
    },
    {
        "func_name": "popen_ls",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __fastcall sub_453FA6(unsigned __int8 *a1, __int64 a2)\n{\n  int v2; // ecx\n  int v3; // r8d\n  int v4; // r9d\n  int v5; // edx\n  int v6; // ecx\n  int v7; // r8d\n  int v8; // r9d\n  __int64 v9[4]; // [rsp+10h] [rbp-30h] BYREF\n  void *ptr; // [rsp+30h] [rbp-10h]\n  char **i; // [rsp+38h] [rbp-8h]\n\n  ptr = sub_453AE3(a1);\n  if ( dword_75D460 )\n    sub_4FDABC((unsigned int)\"Executing %s %s\", *((_QWORD *)&unk_75C3F8 + 8), a2, v2, v3, v4);\n  v9[0] = *((_QWORD *)&unk_75C3F8 + 8);\n  v9[1] = a2;\n  v9[2] = 0LL;\n  sub_50A624(v9);\n  for ( i = (char **)ptr; *i; ++i )\n  {\n    if ( (unsigned int)dword_75D460 > 1 )\n      sub_4FDABC((unsigned int)\" %s\", (unsigned int)*i, v5, v6, v7, v8);\n    sub_40A82A(*i);\n  }\n  free(ptr);\n}\n\n\n Revised code:\nstatic void udhcp_run_script(struct dhcp_packet *packet, const char *name)\n{\n\tchar **envp, **curr;\n\tchar *argv[3];\n\n\tenvp = fill_envp(packet);\n\n\t/* call script */\n\tlog1(\"Executing %s %s\", client_config.script, name);\n\targv[0] = (char*) client_config.script;\n\targv[1] = (char*) name;\n\targv[2] = NULL;\n\tspawn_and_wait(argv);\n\n\tfor (curr = envp; *curr; curr++) {\n\t\tlog2(\" %s\", *curr);\n\t\tbb_unsetenv_and_free(*curr);\n\t}\n\tfree(envp);\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_42948E(int a1, const char *a2)\n{\n  signed int v2; // eax\n  int v3; // [rsp+Ch] [rbp-14h] BYREF\n  int v4; // [rsp+14h] [rbp-Ch]\n  void *ptr; // [rsp+18h] [rbp-8h]\n\n  v3 = a1;\n  ptr = sub_4292FC((const char *)&v3, a2, 0xFF0Du);\n  v2 = (unsigned int)sub_429408(ptr, 10, 0);\n  v4 = v2 + 1;\n  *((_BYTE *)ptr + v2) = 10;\n  sub_40A4AB(1u, (__int64)ptr, v4);\n  if ( *(_DWORD *)&dest.c_line > 1u )\n    sub_429454((const char *)ptr);\n  free(ptr);\n}\n\n\n Revised code:\nstatic void\ncmdio_write(uint32_t status_str, const char *str)\n{\n\tchar *response;\n\tint len;\n\n\t/* FTP uses telnet protocol for command link.\n\t * In telnet, 0xff is an escape char, and needs to be escaped: */\n\tresponse = escape_text((char *) &status_str, str, (0xff << 8) + '\\r');\n\n\t/* FTP sends embedded LFs as NULs */\n\tlen = replace_char(response, '\\n', '\\0');\n\n\tresponse[len++] = '\\n'; /* tack on trailing '\\n' */\n\txwrite(STDOUT_FILENO, response, len);\n\tif (G.verbose > 1)\n\t\tverbose_log(response);\n\tfree(response);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48EF6A(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v7; // eax\n  __int64 *v9; // [rsp+0h] [rbp-30h]\n  __int64 *v10; // [rsp+0h] [rbp-30h]\n  unsigned __int64 v11; // [rsp+10h] [rbp-20h] BYREF\n  int fd; // [rsp+1Ch] [rbp-14h]\n  const char *v13; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v14; // [rsp+28h] [rbp-8h]\n\n  v9 = (__int64 *)(a2 + 8);\n  if ( !*(_QWORD *)(a2 + 8) || !*(_QWORD *)(a2 + 16) )\n    sub_407F64();\n  v13 = sub_48EEFF(*v9);\n  v14 = v13[15];\n  if ( (v13[14] & 4) != 0 )\n  {\n    v9 = (__int64 *)(a2 + 16);\n    v14 = (int)sub_50B306(*(_QWORD *)(a2 + 16));\n  }\n  v10 = v9 + 1;\n  if ( !*v10 || v10[1] )\n    sub_407F64();\n  fd = sub_40A295((const char *)*v10, 0);\n  v11 = v14;\n  v2 = *(unsigned int *)v13;\n  if ( ioctl(fd, v2, &v11) == -1 )\n    sub_409392(*v10, v2, v3, v4, v5, v6);\n  v14 = v11;\n  if ( (v13[14] & 0x10) != 0 )\n    v14 >>= 9;\n  v7 = v13[14] & 0xB;\n  if ( v7 == 2 || v7 == 3 )\n  {\n    printf(\"%llu\\n\", v14);\n  }\n  else if ( v7 == 1 )\n  {\n    printf(\"%lld\\n\", (int)v14);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nint blockdev_main(int argc UNUSED_PARAM, char **argv)\n{\n\tconst struct bdc *bdcmd;\n\tint fd;\n\tuint64_t u64;\n\tunion {\n\t\tint i;\n\t\tunsigned long lu;\n\t\tuint64_t u64;\n\t} ioctl_val_on_stack;\n\n\targv++;\n\tif (!argv[0] || !argv[1]) /* must have at least 2 args */\n\t\tbb_show_usage();\n\n\tbdcmd = find_cmd(*argv);\n\n\tu64 = (int)bdcmd->argval;\n\tif (bdcmd->flags & FL_USRARG)\n\t\tu64 = xatoi_positive(*++argv);\n\n\targv++;\n\tif (!argv[0] || argv[1])\n\t\tbb_show_usage();\n\tfd = xopen(argv[0], O_RDONLY);\n\n\tioctl_val_on_stack.u64 = u64;\n#if BB_BIG_ENDIAN\n\t/* Store data properly wrt data size.\n\t * (1) It's no-op for little-endian.\n\t * (2) it's no-op for 0 and -1. Only --setro uses arg != 0 and != -1,\n\t * and it is ARG_INT. --setbsz USER_VAL is also ARG_INT.\n\t * Thus, we don't need to handle ARG_ULONG.\n\t */\n\tswitch (bdcmd->flags & ARG_MASK) {\n\tcase ARG_INT:\n\t\tioctl_val_on_stack.i = (int)u64;\n\t\tbreak;\n# if 0 /* unused */\n\tcase ARG_ULONG:\n\t\tioctl_val_on_stack.lu = (unsigned long)u64;\n\t\tbreak;\n# endif\n\t}\n#endif\n\n\tif (ioctl(fd, bdcmd->ioc, &ioctl_val_on_stack.u64) == -1)\n\t\tbb_simple_perror_msg_and_die(*argv);\n\n\t/* Fetch it into register(s) */\n\tu64 = ioctl_val_on_stack.u64;\n\n\tif (bdcmd->flags & FL_SCALE512)\n\t\tu64 >>= 9;\n\n\t/* Zero- or one-extend the value if needed, then print */\n\tswitch (bdcmd->flags & (ARG_MASK+FL_NORESULT)) {\n\tcase ARG_INT:\n\t\t/* Smaller code when we use long long\n\t\t * (gcc tail-merges printf call)\n\t\t */\n\t\tprintf(\"%lld\\n\", (long long)(int)u64);\n\t\tbreak;\n\tcase ARG_ULONG:\n\t\tu64 = (unsigned long)u64;\n\t\t/* FALLTHROUGH */\n\tcase ARG_U64:\n\t\tprintf(\"%llu\\n\", (unsigned long long)u64);\n\t\tbreak;\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tclose(fd);\n\treturn EXIT_SUCCESS;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_429E00(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  int fd; // [rsp+18h] [rbp-48h] BYREF\n  int v5; // [rsp+1Ch] [rbp-44h]\n  __int64 v6[3]; // [rsp+20h] [rbp-40h] BYREF\n  char *v7; // [rsp+38h] [rbp-28h]\n  __int64 v8; // [rsp+40h] [rbp-20h]\n  char *v10; // [rsp+58h] [rbp-8h]\n\n  v6[0] = (__int64)\"ftpd\";\n  v6[1] = a1;\n  v6[2] = (__int64)\"--\";\n  v7 = (char *)*((_QWORD *)&dest + 8);\n  v8 = 0LL;\n  if ( *((_QWORD *)&dest + 8) && **((_BYTE **)&dest + 8) == 45 )\n  {\n    a2 = 32LL;\n    v10 = strchr(*((const char **)&dest + 8), 32);\n    if ( v10 )\n      ++v10;\n    v7 = v10;\n  }\n  sub_40A415(&fd, a2);\n  if ( !(unsigned int)sub_40AEE6((__int64)&fd, a2) )\n  {\n    close(fd);\n    sub_40A477(v5, 1u);\n    close(0);\n    dup(1);\n    v2 = sub_4CC866(4LL, v6);\n    exit(v2);\n  }\n  close(v5);\n  return (unsigned int)fd;\n}\n",
        "output": "static int ftpd_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint fd;\n\tint ret;\n\tchar *arg;\n\tchar *ftpd_args[4];\n\n\targv++;\n\tif (!argv[0] || !argv[1]) /* must have at least 2 args */\n\t\tbb_show_usage();\n\n\targ = *argv;\n\tif (*arg == '-') {\n\t\targ++;\n\t\targv++;\n\t} else {\n\t\targ = NULL;\n\t}\n\n\tfd = xopen(argv[0], O_RDONLY);\n\tret = ftpd_accept(fd, arg);\n\tclose(fd);\n\n\treturn ret;\n}",
        "source_code": "static int\npopen_ls(const char *opt)\n{\n\tconst char *argv[5];\n\tstruct fd_pair outfd;\n\tpid_t pid;\n\n\targv[0] = \"ftpd\";\n\targv[1] = opt; /* \"-l\" or \"-1\" */\n#if BB_MMU\n\targv[2] = \"--\";\n#else\n\t/* NOMMU ftpd ls helper chdirs to argv[2],\n\t * preventing peer from seeing real root. */\n\targv[2] = xrealloc_getcwd_or_warn(NULL);\n#endif\n\targv[3] = G.ftp_arg;\n\targv[4] = NULL;\n\n\t/* Improve compatibility with non-RFC conforming FTP clients\n\t * which send e.g. \"LIST -l\", \"LIST -la\", \"LIST -aL\".\n\t * See https://bugs.kde.org/show_bug.cgi?id=195578 */\n\tif (ENABLE_FEATURE_FTPD_ACCEPT_BROKEN_LIST\n\t && G.ftp_arg && G.ftp_arg[0] == '-'\n\t) {\n\t\tconst char *tmp = strchr(G.ftp_arg, ' ');\n\t\tif (tmp) /* skip the space */\n\t\t\ttmp++;\n\t\targv[3] = tmp;\n\t}\n\n\txpiped_pair(outfd);\n\n\t/*fflush_all(); - so far we dont use stdio on output */\n\tpid = BB_MMU ? xfork() : xvfork();\n\tif (pid == 0) {\n\t\t/* child */\n#if !BB_MMU\n\t\t/* On NOMMU, we want to execute a child - copy of ourself.\n\t\t * In chroot we usually can't do it. Thus we chdir\n\t\t * out of the chroot back to original root,\n\t\t * and (see later below) execute bb_busybox_exec_path\n\t\t * relative to current directory */\n\t\tif (fchdir(G.root_fd) != 0)\n\t\t\t_exit(127);\n\t\t/*close(G.root_fd); - close_on_exec_on() took care of this */\n#endif\n\t\t/* NB: close _first_, then move fd! */\n\t\tclose(outfd.rd);\n\t\txmove_fd(outfd.wr, STDOUT_FILENO);\n\t\t/* Opening /dev/null in chroot is hard.\n\t\t * Just making sure STDIN_FILENO is opened\n\t\t * to something harmless. Paranoia,\n\t\t * ls won't read it anyway */\n\t\tclose(STDIN_FILENO);\n\t\tdup(STDOUT_FILENO); /* copy will become STDIN_FILENO */\n#if BB_MMU\n\t\t/* memset(&G, 0, sizeof(G)); - ls_main does it */\n\t\texit(ls_main(ARRAY_SIZE(argv) - 1, (char**) argv));\n#else\n\t\t/* + 1: we must use relative path here if in chroot.\n\t\t * For example, execv(\"/proc/self/exe\") will fail, since\n\t\t * it looks for \"/proc/self/exe\" _relative to chroot!_ */\n\t\texecv(bb_busybox_exec_path + 1, (char**) argv);\n\t\t_exit(127);\n#endif\n\t}\n\n\t/* parent */\n\tclose(outfd.wr);\n#if !BB_MMU\n\tfree((char*)argv[2]);\n#endif\n\treturn outfd.rd;\n}",
        "parsed_output": "static int ftpd_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint fd;\n\tint ret;\n\tchar *arg;\n\tchar *ftpd_args[4];\n\n\targv++;\n\tif (!argv[0] || !argv[1]) /* must have at least 2 args */\n\t\tbb_show_usage();\n\n\targ = *argv;\n\tif (*arg == '-') {\n\t\targ++;\n\t\targv++;\n\t} else {\n\t\targ = NULL;\n\t}\n\n\tfd = xopen(argv[0], O_RDONLY);\n\tret = ftpd_accept(fd, arg);\n\tclose(fd);\n\n\treturn ret;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_429E00(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  int fd; // [rsp+18h] [rbp-48h] BYREF\n  int v5; // [rsp+1Ch] [rbp-44h]\n  __int64 v6[3]; // [rsp+20h] [rbp-40h] BYREF\n  char *v7; // [rsp+38h] [rbp-28h]\n  __int64 v8; // [rsp+40h] [rbp-20h]\n  char *v10; // [rsp+58h] [rbp-8h]\n\n  v6[0] = (__int64)\"ftpd\";\n  v6[1] = a1;\n  v6[2] = (__int64)\"--\";\n  v7 = (char *)*((_QWORD *)&dest + 8);\n  v8 = 0LL;\n  if ( *((_QWORD *)&dest + 8) && **((_BYTE **)&dest + 8) == 45 )\n  {\n    a2 = 32LL;\n    v10 = strchr(*((const char **)&dest + 8), 32);\n    if ( v10 )\n      ++v10;\n    v7 = v10;\n  }\n  sub_40A415(&fd, a2);\n  if ( !(unsigned int)sub_40AEE6((__int64)&fd, a2) )\n  {\n    close(fd);\n    sub_40A477(v5, 1u);\n    close(0);\n    dup(1);\n    v2 = sub_4CC866(4LL, v6);\n    exit(v2);\n  }\n  close(v5);\n  return (unsigned int)fd;\n}\n",
        "baseline_code_debug": "int __cdecl popen_ls(const char *opt)\n{\n  int v1; // eax\n  fd_pair outfd; // [rsp+18h] [rbp-48h] BYREF\n  const char *argv[5]; // [rsp+20h] [rbp-40h] BYREF\n  const char *tmp; // [rsp+58h] [rbp-8h]\n\n  argv[0] = \"ftpd\";\n  argv[1] = opt;\n  argv[2] = \"--\";\n  argv[3] = *((const char **)&bb_common_bufsiz1 + 8);\n  argv[4] = 0LL;\n  if ( *((_QWORD *)&bb_common_bufsiz1 + 8) && **((_BYTE **)&bb_common_bufsiz1 + 8) == 45 )\n  {\n    tmp = strchr(*((const char **)&bb_common_bufsiz1 + 8), 32);\n    if ( tmp )\n      ++tmp;\n    argv[3] = tmp;\n  }\n  xpipe((int *)&outfd);\n  if ( !xfork() )\n  {\n    close(outfd.rd);\n    xmove_fd(outfd.wr, 1);\n    close(0);\n    dup(1);\n    v1 = ls_main(4, (char **)argv);\n    exit(v1);\n  }\n  close(outfd.wr);\n  return outfd.rd;\n}\n",
        "similarity_score_unixcoder": 0.6833454370498657,
        "similarity_score_baseline_stripped": 0.6002610921859741,
        "similarity_score_baseline_debug": 0.8081517815589905
    },
    {
        "func_name": "collect_thread_nr",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_46031C(__int64 a1)\n{\n  unsigned int v1; // ebx\n  const char *v2; // rax\n  __int64 v3; // r8\n  __int64 v4; // r9\n  unsigned __int64 v6; // [rsp+10h] [rbp-20h] BYREF\n  unsigned __int64 v7; // [rsp+18h] [rbp-18h]\n\n  v1 = *(_DWORD *)(a1 + 32);\n  v2 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 48);\n  if ( (unsigned int)sub_45FABF(v2, \"intr\", &v6, v1, v3, v4) )\n    return (void *)sub_45F76C(4u);\n  v7 = *(_QWORD *)(a1 + 24);\n  if ( v7 > v6 )\n    v7 = v6;\n  *(_QWORD *)(a1 + 24) = v6;\n  return sub_45FE0E(v6 - v7);\n}\n\n\n Revised code:\nstatic void FAST_FUNC collect_int(int_stat *s)\n{\n\tullong data[1];\n\tullong old;\n\n\tif (rdval(get_file(&proc_stat), \"intr\", data, s->no)) {\n\t\tput_question_marks(4);\n\t\treturn;\n\t}\n\n\told = s->old;\n\tif (data[0] < old) old = data[0];\t\t//sanitize\n\ts->old = data[0];\n\tscale(data[0] - old);\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_46040F(__int64 a1)\n{\n  const char *v1; // rax\n  __int64 v2; // r8\n  __int64 v3; // r9\n  unsigned __int64 v5; // [rsp+10h] [rbp-10h] BYREF\n  unsigned __int64 v6; // [rsp+18h] [rbp-8h]\n\n  v1 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 48);\n  if ( (unsigned int)sub_45FABF(v1, \"ctxt\", &v5, 1LL, v2, v3) )\n    return (void *)sub_45F76C(4u);\n  v6 = *(_QWORD *)(a1 + 24);\n  if ( v6 > v5 )\n    v6 = v5;\n  *(_QWORD *)(a1 + 24) = v5;\n  return sub_45FE0E(v5 - v6);\n}\n\n\n Revised code:\nstatic void FAST_FUNC collect_ctx(ctx_stat *s)\n{\n\tullong data[1];\n\tullong old;\n\n\tif (rdval(get_file(&proc_stat), \"ctxt\", data, 1)) {\n\t\tput_question_marks(4);\n\t\treturn;\n\t}\n\n\told = s->old;\n\tif (data[0] < old) old = data[0];\t\t//sanitize\n\ts->old = data[0];\n\tscale(data[0] - old);\n}\n\n## Example:\n\n Input code:\n__int64 sub_4FF998()\n{\n  __int64 result; // rax\n  __int64 v1; // rbx\n  char *v2; // rdx\n  char v3[1036]; // [rsp+0h] [rbp-420h] BYREF\n  int v4; // [rsp+40Ch] [rbp-14h]\n\n  result = **((unsigned int **)qword_75D458 + 6);\n  if ( (_DWORD)result )\n  {\n    v4 = *(_DWORD *)(*(_QWORD *)qword_75D458 + 20LL);\n    free(*(void **)(*(_QWORD *)qword_75D458 + 8 * (v4 + 4LL) + 8));\n    sub_4FE0EA((__int64)v3, 1024);\n    v1 = *(_QWORD *)qword_75D458;\n    v2 = sub_40A11F(v3, 1024LL);\n    result = v4 + 4LL;\n    *(_QWORD *)(v1 + 8 * result + 8) = v2;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void save_command_ps_at_cur_history(void)\n{\n\tif (command_ps[0] != BB_NUL) {\n\t\tint cur = state->cur_history;\n\t\tfree(state->history[cur]);\n\n# if ENABLE_UNICODE_SUPPORT\n\t\t{\n\t\t\tchar tbuf[MAX_LINELEN];\n\t\t\tsave_string(tbuf, sizeof(tbuf));\n\t\t\tstate->history[cur] = xstrdup(tbuf);\n\t\t}\n# else\n\t\tstate->history[cur] = xstrdup(command_ps);\n# endif\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *sub_46065C()\n{\n  const char *v0; // rax\n  __int64 v1; // r8\n  __int64 v2; // r9\n  __int64 v4; // [rsp+18h] [rbp-8h] BYREF\n\n  v0 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 64);\n  if ( (unsigned int)sub_45FB82(v0, (unsigned __int64 *)&v4, 4LL, (__int64)v0, v1, v2) )\n    return (void *)sub_45F76C(4u);\n  else\n    return sub_45FE0E(v4);\n}\n",
        "output": "static void FAST_FUNC collect_data(data_stat *s)\n{\n\tullong data[1];\n\n\tif (rdval(get_file(&proc_stat), \"data\", data, 4)) {\n\t\tput_question_marks(4);\n\t\treturn;\n\t}\n\n\tscale(data[0]);\n}",
        "source_code": "static void FAST_FUNC collect_thread_nr(fork_stat *s UNUSED_PARAM)\n{\n\tullong data[1];\n\n\tif (rdval_loadavg(get_file(&proc_loadavg), data, 4)) {\n\t\tput_question_marks(4);\n\t\treturn;\n\t}\n\tscale(data[0]);\n}",
        "parsed_output": "static void FAST_FUNC collect_data(data_stat *s)\n{\n\tullong data[1];\n\n\tif (rdval(get_file(&proc_stat), \"data\", data, 4)) {\n\t\tput_question_marks(4);\n\t\treturn;\n\t}\n\n\tscale(data[0]);\n}",
        "baseline_code_stripped": "void *sub_46065C()\n{\n  const char *v0; // rax\n  __int64 v1; // r8\n  __int64 v2; // r9\n  __int64 v4; // [rsp+18h] [rbp-8h] BYREF\n\n  v0 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 64);\n  if ( (unsigned int)sub_45FB82(v0, (unsigned __int64 *)&v4, 4LL, (__int64)v0, v1, v2) )\n    return (void *)sub_45F76C(4u);\n  else\n    return sub_45FE0E(v4);\n}\n",
        "baseline_code_debug": "void __cdecl collect_thread_nr(fork_stat_0 *s)\n{\n  const char *file; // rax\n  ullong data[1]; // [rsp+18h] [rbp-8h] BYREF\n\n  file = get_file((proc_file_0 *)&ptr_to_globals->speeds[3]);\n  if ( rdval_loadavg(file, data, 4LL) )\n    put_question_marks(4);\n  else\n    scale_0(data[0]);\n}\n",
        "similarity_score_unixcoder": 0.8451607823371887,
        "similarity_score_baseline_stripped": 0.44523313641548157,
        "similarity_score_baseline_debug": 0.8146576285362244
    },
    {
        "func_name": "move_to_col",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_4EED30(_BYTE *a1, _BYTE *a2, int a3, int a4)\n{\n  unsigned __int64 v6; // [rsp+10h] [rbp-20h]\n  _BYTE *v7; // [rsp+18h] [rbp-18h]\n  _BYTE *v8; // [rsp+28h] [rbp-8h]\n  _BYTE *v9; // [rsp+28h] [rbp-8h]\n\n  v7 = a1;\n  v6 = (unsigned __int64)a2;\n  if ( a1 > a2 )\n  {\n    v7 = a2;\n    v6 = (unsigned __int64)a1;\n  }\n  if ( a3 <= 0 )\n  {\n    v8 = v7;\n    if ( *v7 == 10 )\n      return v7;\n    while ( v6 >= (unsigned __int64)(v8 + 1) )\n    {\n      if ( v8[1] == 10 )\n      {\n        v6 = (unsigned __int64)v8;\n        break;\n      }\n      ++v8;\n    }\n  }\n  v9 = v7;\n  sub_4EEF5D(v7, v6, *((unsigned int *)qword_75D408 + 44));\n  if ( a4 == 1 )\n    return sub_4EEBB4((unsigned __int64)v7, v6);\n  return v9;\n}\n\n\n Revised code:\nstatic char *yank_delete(char *start, char *stop, int dist, int yf)\n{\n\tchar *p;\n\n\t// make sure start <= stop\n\tif (start > stop) {\n\t\t// they are backwards, reverse them\n\t\tp = start;\n\t\tstart = stop;\n\t\tstop = p;\n\t}\n\tif (dist <= 0) {\n\t\t// we cannot cross NL boundaries\n\t\tp = start;\n\t\tif (*p == '\\n')\n\t\t\treturn p;\n\t\t// dont go past a NewLine\n\t\tfor (; p + 1 <= stop; p++) {\n\t\t\tif (p[1] == '\\n') {\n\t\t\t\tstop = p;\t// \"stop\" just before NewLine\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tp = start;\n#if ENABLE_FEATURE_VI_YANKMARK\n\ttext_yank(start, stop, YDreg);\n#endif\n\tif (yf == YANKDEL) {\n\t\tp = text_hole_delete(start, stop);\n\t}\t\t\t\t\t// delete lines\n\treturn p;\n}\n\n## Example:\n\n Input code:\nconst char *__fastcall sub_4EDEC7(char *a1, const char *a2, int a3, int a4)\n{\n  int v7; // [rsp+2Ch] [rbp-14h]\n  const char *v8; // [rsp+30h] [rbp-10h]\n  char *v9; // [rsp+30h] [rbp-10h]\n  const char *i; // [rsp+38h] [rbp-8h]\n  const char *j; // [rsp+38h] [rbp-8h]\n\n  v7 = strlen(a2);\n  if ( a3 == 1 )\n  {\n    v8 = (const char *)(*((_QWORD *)qword_75D408 + 1) - 1LL);\n    if ( !a4 )\n      v8 = sub_4ED888(a1);\n    for ( i = a1; i < v8; ++i )\n    {\n      if ( !sub_4EDE69(i, a2, v7) )\n        return i;\n    }\n  }\n  else if ( a3 == -1 )\n  {\n    v9 = *(char **)qword_75D408;\n    if ( !a4 )\n      v9 = sub_4ED832((unsigned __int64)a1);\n    for ( j = &a1[-v7]; j >= v9; --j )\n    {\n      if ( !sub_4EDE69(j, a2, v7) )\n        return j;\n    }\n  }\n  return 0LL;\n}\n\n\n Revised code:\nsearch for pattern starting at p\nstatic char *char_search(char *p, const char *pat, int dir, int range)\n{\n\tchar *q;\n\tstruct re_pattern_buffer preg;\n\tint i;\n\tint size;\n\n\tre_syntax_options = RE_SYNTAX_POSIX_EXTENDED;\n\tpreg.translate = 0;\n\tpreg.fastmap = 0;\n\tpreg.buffer = 0;\n\tpreg.allocated = 0;\n\n\t// assume a LIMITED forward search\n\tq = next_line(p);\n\tq = end_line(q);\n\tq = end - 1;\n\tif (dir == BACK) {\n\t\tq = prev_line(p);\n\t\tq = text;\n\t}\n\t// count the number of chars to search over, forward or backward\n\tsize = q - p;\n\tif (size < 0)\n\t\tsize = p - q;\n\t// RANGE could be negative if we are searching backwards\n\trange = q - p;\n\n\tq = (char *)re_compile_pattern(pat, strlen(pat), (struct re_pattern_buffer *)&preg);\n\tif (q != 0) {\n\t\t// The pattern was not compiled\n\t\tstatus_line_bold(\"bad search pattern: \\\"%s\\\": %s\", pat, q);\n\t\ti = 0;\t\t\t// return p if pattern not compiled\n\t\tgoto cs1;\n\t}\n\n\tq = p;\n\tif (range < 0) {\n\t\tq = p - size;\n\t\tif (q < text)\n\t\t\tq = text;\n\t}\n\t// search for the compiled pattern, preg, in p[]\n\t// range < 0-  search backward\n\t// range > 0-  search forward\n\t// 0 < start < size\n\t// re_search() < 0  not found or error\n\t// re_search() > 0  index of found pattern\n\t//            struct pattern    char     int    int    int     struct reg\n\t// re_search (*pattern_buffer,  *string, size,  start, range,  *regs)\n\ti = re_search(&preg, q, size, 0, range, 0);\n\tif (i == -1) {\n\t\tp = 0;\n\t\ti = 0;\t\t\t// return NULL if pattern not found\n\t}\n cs1:\n\tif (dir == FORWARD) {\n\t\tp = p + i;\n\t} else {\n\t\tp = p - i;\n\t}\n\treturn p;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4EDBDE(int a1, int a2)\n{\n  _QWORD *v2; // rbx\n  _QWORD *v3; // rbx\n  unsigned __int64 v6; // [rsp+18h] [rbp-18h]\n\n  while ( a1 > 0 )\n  {\n    v2 = qword_75D408;\n    if ( a2 >= 0 )\n      v2[11] = sub_4ED888(*((void **)qword_75D408 + 11));\n    else\n      v2[11] = sub_4ED832(*((_QWORD *)qword_75D408 + 11));\n    --a1;\n  }\n  if ( *((_QWORD *)qword_75D408 + 2) < *((_QWORD *)qword_75D408 + 11) )\n    *((_QWORD *)qword_75D408 + 2) = *((_QWORD *)qword_75D408 + 11);\n  v6 = sub_4ED8CF();\n  if ( v6 < *((_QWORD *)qword_75D408 + 2) )\n  {\n    v3 = qword_75D408;\n    v3[2] = sub_4ED70A(v6);\n  }\n  return sub_4EDCAC();\n}\n\n\n Revised code:\nstatic void dot_scroll(int cnt, int dir)\n{\n\tchar *q;\n\n\tfor (; cnt > 0; cnt--) {\n\t\tif (dir < 0) {\n\t\t\t// scroll Backwards\n\t\t\t// ctrl-Y scroll up one line\n\t\t\tscreenbegin = prev_line(screenbegin);\n\t\t} else {\n\t\t\t// scroll Forwards\n\t\t\t// ctrl-E scroll down one line\n\t\t\tscreenbegin = next_line(screenbegin);\n\t\t}\n\t}\n\t// make sure \"dot\" stays on the screen so we dont scroll off\n\tif (dot < screenbegin)\n\t\tdot = screenbegin;\n\tq = end_screen();\t// find new bottom line\n\tif (dot > q)\n\t\tdot = begin_line(q);\t// is dot is below bottom line?\n\tdot_skip_over_ws();\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_4EDAEE(unsigned __int64 a1, int a2)\n{\n  char *v3; // [rsp+8h] [rbp-18h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_4ED70A(a1);\n  for ( i = 0; i < a2 && (unsigned __int64)v3 < *((_QWORD *)qword_75D408 + 1) && *v3 != 10; ++i )\n  {\n    if ( *v3 == 9 )\n    {\n      i = sub_4ED405(i);\n    }\n    else if ( *v3 <= 31 || *v3 == 127 )\n    {\n      ++i;\n    }\n    ++v3;\n  }\n  return v3;\n}\n",
        "output": "static char *process_data(unsigned long long a1, int a2)\n{\n\tchar *v3;\n\tint i;\n\n\tv3 = get_data(a1);\n\tfor (i = 0; i < a2 && (unsigned long long)v3 < *((unsigned long long *)qword_75D408 + 1) && *v3 != '\\n'; ++i) {\n\t\tif (*v3 == '\\t') {\n\t\t\ti = process_tab(i);\n\t\t} else if (*v3 <= 31 || *v3 == 127) {\n\t\t\t++i;\n\t\t}\n\t\t++v3;\n\t}\n\treturn v3;\n}",
        "source_code": "static char *move_to_col(char *p, int l)\n{\n\tint co;\n\n\tp = begin_line(p);\n\tco = 0;\n\twhile (co < l && p < end) {\n\t\tif (*p == '\\n') //vda || *p == '\\0')\n\t\t\tbreak;\n\t\tif (*p == '\\t') {\n\t\t\tco = next_tabstop(co);\n\t\t} else if (*p < ' ' || *p == 127) {\n\t\t\tco++; // display as ^X, use 2 columns\n\t\t}\n\t\tco++;\n\t\tp++;\n\t}\n\treturn p;\n}",
        "parsed_output": "static char *process_data(unsigned long long a1, int a2)\n{\n\tchar *v3;\n\tint i;\n\n\tv3 = get_data(a1);\n\tfor (i = 0; i < a2 && (unsigned long long)v3 < *((unsigned long long *)qword_75D408 + 1) && *v3 != '\\n'; ++i) {\n\t\tif (*v3 == '\\t') {\n\t\t\ti = process_tab(i);\n\t\t} else if (*v3 <= 31 || *v3 == 127) {\n\t\t\t++i;\n\t\t}\n\t\t++v3;\n\t}\n\treturn v3;\n}",
        "baseline_code_stripped": "char *__fastcall sub_4EDAEE(unsigned __int64 a1, int a2)\n{\n  char *v3; // [rsp+8h] [rbp-18h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_4ED70A(a1);\n  for ( i = 0; i < a2 && (unsigned __int64)v3 < *((_QWORD *)qword_75D408 + 1) && *v3 != 10; ++i )\n  {\n    if ( *v3 == 9 )\n    {\n      i = sub_4ED405(i);\n    }\n    else if ( *v3 <= 31 || *v3 == 127 )\n    {\n      ++i;\n    }\n    ++v3;\n  }\n  return v3;\n}\n",
        "baseline_code_debug": "char *__cdecl move_to_col(char *p, int l)\n{\n  char *pa; // [rsp+8h] [rbp-18h]\n  int co; // [rsp+1Ch] [rbp-4h]\n\n  pa = begin_line(p);\n  for ( co = 0; co < l && pa < ptr_to_globals->login && *pa != 10; ++co )\n  {\n    if ( *pa == 9 )\n    {\n      co = next_tabstop(co);\n    }\n    else if ( *pa <= 31 || *pa == 127 )\n    {\n      ++co;\n    }\n    ++pa;\n  }\n  return pa;\n}\n",
        "similarity_score_unixcoder": 0.7477509379386902,
        "similarity_score_baseline_stripped": 0.5130550861358643,
        "similarity_score_baseline_debug": 0.8243781924247742
    },
    {
        "func_name": "time_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48EF6A(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v7; // eax\n  __int64 *v9; // [rsp+0h] [rbp-30h]\n  __int64 *v10; // [rsp+0h] [rbp-30h]\n  unsigned __int64 v11; // [rsp+10h] [rbp-20h] BYREF\n  int fd; // [rsp+1Ch] [rbp-14h]\n  const char *v13; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v14; // [rsp+28h] [rbp-8h]\n\n  v9 = (__int64 *)(a2 + 8);\n  if ( !*(_QWORD *)(a2 + 8) || !*(_QWORD *)(a2 + 16) )\n    sub_407F64();\n  v13 = sub_48EEFF(*v9);\n  v14 = v13[15];\n  if ( (v13[14] & 4) != 0 )\n  {\n    v9 = (__int64 *)(a2 + 16);\n    v14 = (int)sub_50B306(*(_QWORD *)(a2 + 16));\n  }\n  v10 = v9 + 1;\n  if ( !*v10 || v10[1] )\n    sub_407F64();\n  fd = sub_40A295((const char *)*v10, 0);\n  v11 = v14;\n  v2 = *(unsigned int *)v13;\n  if ( ioctl(fd, v2, &v11) == -1 )\n    sub_409392(*v10, v2, v3, v4, v5, v6);\n  v14 = v11;\n  if ( (v13[14] & 0x10) != 0 )\n    v14 >>= 9;\n  v7 = v13[14] & 0xB;\n  if ( v7 == 2 || v7 == 3 )\n  {\n    printf(\"%llu\\n\", v14);\n  }\n  else if ( v7 == 1 )\n  {\n    printf(\"%lld\\n\", (int)v14);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nint blockdev_main(int argc UNUSED_PARAM, char **argv)\n{\n\tconst struct bdc *bdcmd;\n\tint fd;\n\tuint64_t u64;\n\tunion {\n\t\tint i;\n\t\tunsigned long lu;\n\t\tuint64_t u64;\n\t} ioctl_val_on_stack;\n\n\targv++;\n\tif (!argv[0] || !argv[1]) /* must have at least 2 args */\n\t\tbb_show_usage();\n\n\tbdcmd = find_cmd(*argv);\n\n\tu64 = (int)bdcmd->argval;\n\tif (bdcmd->flags & FL_USRARG)\n\t\tu64 = xatoi_positive(*++argv);\n\n\targv++;\n\tif (!argv[0] || argv[1])\n\t\tbb_show_usage();\n\tfd = xopen(argv[0], O_RDONLY);\n\n\tioctl_val_on_stack.u64 = u64;\n#if BB_BIG_ENDIAN\n\t/* Store data properly wrt data size.\n\t * (1) It's no-op for little-endian.\n\t * (2) it's no-op for 0 and -1. Only --setro uses arg != 0 and != -1,\n\t * and it is ARG_INT. --setbsz USER_VAL is also ARG_INT.\n\t * Thus, we don't need to handle ARG_ULONG.\n\t */\n\tswitch (bdcmd->flags & ARG_MASK) {\n\tcase ARG_INT:\n\t\tioctl_val_on_stack.i = (int)u64;\n\t\tbreak;\n# if 0 /* unused */\n\tcase ARG_ULONG:\n\t\tioctl_val_on_stack.lu = (unsigned long)u64;\n\t\tbreak;\n# endif\n\t}\n#endif\n\n\tif (ioctl(fd, bdcmd->ioc, &ioctl_val_on_stack.u64) == -1)\n\t\tbb_simple_perror_msg_and_die(*argv);\n\n\t/* Fetch it into register(s) */\n\tu64 = ioctl_val_on_stack.u64;\n\n\tif (bdcmd->flags & FL_SCALE512)\n\t\tu64 >>= 9;\n\n\t/* Zero- or one-extend the value if needed, then print */\n\tswitch (bdcmd->flags & (ARG_MASK+FL_NORESULT)) {\n\tcase ARG_INT:\n\t\t/* Smaller code when we use long long\n\t\t * (gcc tail-merges printf call)\n\t\t */\n\t\tprintf(\"%lld\\n\", (long long)(int)u64);\n\t\tbreak;\n\tcase ARG_ULONG:\n\t\tu64 = (unsigned long)u64;\n\t\t/* FALLTHROUGH */\n\tcase ARG_U64:\n\t\tprintf(\"%llu\\n\", (unsigned long long)u64);\n\t\tbreak;\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tclose(fd);\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4C44CB(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  _QWORD *v7; // [rsp+0h] [rbp-40h]\n  __int64 v8; // [rsp+10h] [rbp-30h] BYREF\n  unsigned __int16 v9; // [rsp+1Ah] [rbp-26h] BYREF\n  char s[24]; // [rsp+20h] [rbp-20h] BYREF\n  int v11; // [rsp+38h] [rbp-8h]\n  unsigned int v12; // [rsp+3Ch] [rbp-4h]\n\n  v11 = sub_4FA1EF(a2, (unsigned int)\"+c:wslfv\", (unsigned int)&v8, a4, a5, a6);\n  v7 = (_QWORD *)(8LL * optind + a2);\n  if ( (v11 & 1) != 0 )\n    v12 = sub_50B09C(v8, 1LL, 63LL);\n  else\n    v12 = sub_4C4435();\n  sprintf(s, \"/dev/tty%d\", v12);\n  sub_50A64B(12LL);\n  close(0);\n  sub_40A295(s, 2);\n  sub_40AD51(0, 0x5603u, (__int64)&v9, (__int64)\"VT_GETSTATE\");\n  if ( (v11 & 4) != 0 )\n    sub_4F9DB7(0LL, v12);\n  if ( !*v7 )\n    *--v7 = sub_4FA04E();\n  sub_40A443(0, 1u);\n  sub_40A443(0, 2u);\n  sub_4C4489((__int64)v7);\n  if ( (v11 & 2) != 0 )\n  {\n    sub_409F48(-1, 0LL, 0);\n    if ( (v11 & 4) != 0 )\n    {\n      sub_4F9DB7(0LL, v9);\n      sub_40AD51(0, 0x5608u, (int)v12, (__int64)\"VT_DISALLOCATE\");\n    }\n  }\n  return 0LL;\n}\n\n\n Revised code:\nint openvt_main(int argc UNUSED_PARAM, char **argv)\n{\n\tchar vtname[sizeof(VC_FORMAT) + sizeof(int)*3];\n\tstruct vt_stat vtstat;\n\tchar *str_c;\n\tint vtno;\n\tint flags;\n\tenum {\n\t\tOPT_c = (1 << 0),\n\t\tOPT_w = (1 << 1),\n\t\tOPT_s = (1 << 2),\n\t\tOPT_l = (1 << 3),\n\t\tOPT_f = (1 << 4),\n\t\tOPT_v = (1 << 5),\n\t};\n\n\t/* \"+\" - stop on first non-option */\n\tflags = getopt32(argv, \"+c:wslfv\", &str_c);\n\targv += optind;\n\n\tif (flags & OPT_c) {\n\t\t/* Check for illegal vt number: < 1 or > 63 */\n\t\tvtno = xatou_range(str_c, 1, 63);\n\t} else {\n\t\tvtno = find_free_vtno();\n\t}\n\n\t/* Grab new VT */\n\tsprintf(vtname, VC_FORMAT, vtno);\n\t/* (Try to) clean up stray open fds above fd 2 */\n\tbb_daemonize_or_rexec(DAEMON_CLOSE_EXTRA_FDS | DAEMON_ONLY_SANITIZE, NULL);\n\tclose(STDIN_FILENO);\n\t/*setsid(); - BAD IDEA: after we exit, child is SIGHUPed... */\n\txopen(vtname, O_RDWR);\n\txioctl(STDIN_FILENO, VT_GETSTATE, &vtstat);\n\n\tif (flags & OPT_s) {\n\t\tconsole_make_active(STDIN_FILENO, vtno);\n\t}\n\n\tif (!argv[0]) {\n\t\targv--;\n\t\targv[0] = (char *) get_shell_name();\n\t\t/*argv[1] = NULL; - already is */\n\t}\n\n\txdup2(STDIN_FILENO, STDOUT_FILENO);\n\txdup2(STDIN_FILENO, STDERR_FILENO);\n\n#ifdef BLOAT\n\t{\n\t/* Handle -l (login shell) option */\n\tconst char *prog = argv[0];\n\tif (flags & OPT_l)\n\t\targv[0] = xasprintf(\"-%s\", argv[0]);\n\t}\n#endif\n\n\tvfork_child(argv);\n\tif (flags & OPT_w) {\n\t\t/* We have only one child, wait for it */\n\t\tsafe_waitpid(-1, NULL, 0); /* loops on EINTR */\n\t\tif (flags & OPT_s) {\n\t\t\tconsole_make_active(STDIN_FILENO, vtstat.v_active);\n\t\t\t// Compat: even with -c N (try to) disallocate:\n\t\t\t// # /usr/app/kbd-1.12/bin/openvt -f -c 9 -ws sleep 5\n\t\t\t// openvt: could not deallocate console 9\n\t\t\txioctl(STDIN_FILENO, VT_DISALLOCATE, (void*)(ptrdiff_t)vtno);\n\t\t}\n\t}\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\nvoid __fastcall __noreturn sub_424227(int a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6)\n{\n  int v6; // eax\n  __int64 v7; // [rsp+10h] [rbp-20h] BYREF\n  __int64 v8; // [rsp+18h] [rbp-18h] BYREF\n  unsigned int v9; // [rsp+24h] [rbp-Ch] BYREF\n  int v10; // [rsp+28h] [rbp-8h]\n  unsigned int v11; // [rsp+2Ch] [rbp-4h]\n\n  v9 = 60000;\n  qword_75D440 = (__int64)\"=1\";\n  v10 = sub_4FA1EF(a2, (unsigned int)\"Ft:T:\", (unsigned int)&v8, (unsigned int)&v7, a5, a6);\n  if ( (v10 & 1) == 0 )\n    sub_50A64B(1LL);\n  if ( (v10 & 4) != 0 )\n    v9 = sub_50B0CD(v7, \"ms\");\n  v11 = v9 >> 1;\n  if ( (v10 & 2) != 0 )\n    v11 = sub_50B0CD(v8, \"ms\");\n  sub_508201(117503054LL, sub_4241E9);\n  v6 = sub_40A295(*(const char **)(8LL * a1 - 8 + a2), 1);\n  sub_40A477(v6, 3u);\n  v9 /= 0x3E8u;\n  sub_40AD08(3, 0x80045704, (__int64)&unk_525848, (__int64)\"WDIOC_SETOPTIONS\");\n  sub_40AD08(3, 0xC0045706, (__int64)&v9, (__int64)\"WDIOC_SETTIMEOUT\");\n  sub_502D6A(\"/var/run/watchdog.pid\");\n  while ( 1 )\n  {\n    write(3, &unk_525821, 1uLL);\n    usleep(1000 * v11);\n  }\n}\n\n\n Revised code:\nint watchdog_main(int argc, char **argv)\n{\n\tstatic const struct suffix_mult suffixes[] = {\n\t\t{ \"ms\", 1 },\n\t\t{ \"\", 1000 },\n\t\t{ \"\", 0 }\n\t};\n\n\tunsigned opts;\n\tunsigned stimer_duration; /* how often to restart */\n\tunsigned htimer_duration = 60000; /* reboots after N ms if not restarted */\n\tchar *st_arg;\n\tchar *ht_arg;\n\n\topt_complementary = \"=1\"; /* must have exactly 1 argument */\n\topts = getopt32(argv, \"Ft:T:\", &st_arg, &ht_arg);\n\n\t/* We need to daemonize *before* opening the watchdog as many drivers\n\t * will only allow one process at a time to do so.  Since daemonizing\n\t * is not perfect (child may run before parent finishes exiting), we\n\t * can't rely on parent exiting before us (let alone *cleanly* releasing\n\t * the watchdog fd -- something else that may not even be allowed).\n\t */\n\tif (!(opts & OPT_FOREGROUND))\n\t\tbb_daemonize_or_rexec(DAEMON_CHDIR_ROOT, argv);\n\n\tif (opts & OPT_HTIMER)\n\t\thtimer_duration = xatou_sfx(ht_arg, suffixes);\n\tstimer_duration = htimer_duration / 2;\n\tif (opts & OPT_STIMER)\n\t\tstimer_duration = xatou_sfx(st_arg, suffixes);\n\n\tbb_signals(BB_FATAL_SIGS, watchdog_shutdown);\n\n\t/* Use known fd # - avoid needing global 'int fd' */\n\txmove_fd(xopen(argv[argc - 1], O_WRONLY), 3);\n\n\t/* WDIOC_SETTIMEOUT takes seconds, not milliseconds */\n\thtimer_duration = htimer_duration / 1000;\n#ifndef WDIOC_SETTIMEOUT\n# error WDIOC_SETTIMEOUT is not defined, cannot compile watchdog applet\n#else\n# if defined WDIOC_SETOPTIONS && defined WDIOS_ENABLECARD\n\t{\n\t\tstatic const int enable = WDIOS_ENABLECARD;\n\t\tioctl_or_warn(3, WDIOC_SETOPTIONS, (void*) &enable);\n\t}\n# endif\n\tioctl_or_warn(3, WDIOC_SETTIMEOUT, &htimer_duration);\n#endif\n\n#if 0\n\tioctl_or_warn(3, WDIOC_GETTIMEOUT, &htimer_duration);\n\tprintf(\"watchdog: SW timer is %dms, HW timer is %ds\\n\",\n\t\tstimer_duration, htimer_duration * 1000);\n#endif\n\n\twrite_pidfile(CONFIG_PID_FILE_PATH \"/watchdog.pid\");\n\n\twhile (1) {\n\t\t/*\n\t\t * Make sure we clear the counter before sleeping,\n\t\t * as the counter value is undefined at this point -- PFM\n\t\t */\n\t\twrite(3, \"\", 1); /* write zero byte */\n\t\tusleep(stimer_duration * 1000L);\n\t}\n\treturn EXIT_SUCCESS; /* - not reached, but gcc 4.2.1 is too dumb! */\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_423704(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  _QWORD *v7; // [rsp+0h] [rbp-C0h]\n  char v8; // [rsp+10h] [rbp-B0h] BYREF\n  unsigned __int8 v9; // [rsp+11h] [rbp-AFh]\n  int v10; // [rsp+B4h] [rbp-Ch]\n  const char *v11; // [rsp+B8h] [rbp-8h]\n\n  v11 = \"real\\t%E\\nuser\\t%u\\nsys\\t%T\";\n  qword_75D440 = (__int64)\"-1\";\n  v10 = sub_4FA1EF(a2, (unsigned int)\"+vp\", a3, a4, a5, a6);\n  v7 = (_QWORD *)(8LL * optind + a2);\n  if ( (v10 & 1) != 0 )\n    v11 = \"\\tCommand being timed: \\\"%C\\\"\\n\"\n          \"\\tUser time (seconds): %U\\n\"\n          \"\\tSystem time (seconds): %S\\n\"\n          \"\\tPercent of CPU this job got: %P\\n\"\n          \"\\tElapsed (wall clock) time (h:mm:ss or m:ss): %E\\n\"\n          \"\\tAverage shared text size (kbytes): %X\\n\"\n          \"\\tAverage unshared data size (kbytes): %D\\n\"\n          \"\\tAverage stack size (kbytes): %p\\n\"\n          \"\\tAverage total size (kbytes): %K\\n\"\n          \"\\tMaximum resident set size (kbytes): %M\\n\"\n          \"\\tAverage resident set size (kbytes): %t\\n\"\n          \"\\tMajor (requiring I/O) page faults: %F\\n\"\n          \"\\tMinor (reclaiming a frame) page faults: %R\\n\"\n          \"\\tVoluntary context switches: %w\\n\"\n          \"\\tInvoluntary context switches: %c\\n\"\n          \"\\tSwaps: %W\\n\"\n          \"\\tFile system inputs: %I\\n\"\n          \"\\tFile system outputs: %O\\n\"\n          \"\\tSocket messages sent: %s\\n\"\n          \"\\tSocket messages received: %r\\n\"\n          \"\\tSignals delivered: %k\\n\"\n          \"\\tPage size (bytes): %Z\\n\"\n          \"\\tExit status: %x\";\n  if ( (v10 & 2) != 0 )\n    v11 = \"real %e\\nuser %U\\nsys %S\";\n  sub_423652((__int64)v7, (__int64)&v8);\n  sub_40A443(2, 1u);\n  sub_422C37(v11, v7, (__int64)&v8);\n  if ( v8 == 127 )\n    return v9;\n  if ( (char)((v8 & 0x7F) + 1) >> 1 > 0 )\n    return v8 & 0x7F;\n  if ( (v8 & 0x7F) != 0 )\n    sub_4F93C9(0LL);\n  return v9;\n}\n",
        "output": "int time_main(int argc UNUSED_PARAM, char **argv)\n{\n\tconst char *format = \"real\\t%E\\nuser\\t%u\\nsys\\t%T\";\n\tint status;\n\tunion {\n\t\tint i;\n\t\tunsigned char uc;\n\t} exit_status;\n\n\texit_status.i = -1;\n\n\topt_complementary = \"=1\"; /* must have exactly 1 argument */\n\tstatus = getopt32(argv, \"+vp\", &format);\n\targv += optind;\n\n\tif (status & 1)\n\t\tformat = \"\\tCommand being timed: \\\"%C\\\"\\n\"\n\t\t         \"\\tUser time (seconds): %U\\n\"\n\t\t         \"\\tSystem time (seconds): %S\\n\"\n\t\t         \"\\tPercent of CPU this job got: %P\\n\"\n\t\t         \"\\tElapsed (wall clock) time (h:mm:ss or m:ss): %E\\n\"\n\t\t         \"\\tAverage shared text size (kbytes): %X\\n\"\n\t\t         \"\\tAverage unshared data size (kbytes): %D\\n\"\n\t\t         \"\\tAverage stack size (kbytes): %p\\n\"\n\t\t         \"\\tAverage total size (kbytes): %K\\n\"\n\t\t         \"\\tMaximum resident set size (kbytes): %M\\n\"\n\t\t         \"\\tAverage resident set size (kbytes): %t\\n\"\n\t\t         \"\\tMajor (requiring I/O) page faults: %F\\n\"\n\t\t         \"\\tMinor (reclaiming a frame) page faults: %R\\n\"\n\t\t         \"\\tVoluntary context switches: %w\\n\"\n\t\t         \"\\tInvoluntary context switches: %c\\n\"\n\t\t         \"\\tSwaps: %W\\n\"\n\t\t         \"\\tFile system inputs: %I\\n\"\n\t\t         \"\\tFile system outputs: %O\\n\"\n\t\t         \"\\tSocket messages sent: %s\\n\"\n\t\t         \"\\tSocket messages received: %r\\n\"\n\t\t         \"\\tSignals delivered: %k\\n\"\n\t\t         \"\\tPage size (bytes): %Z\\n\"\n\t\t         \"\\tExit status: %x\";\n\tif (status & 2)\n\t\tformat = \"real %e\\nuser %U\\nsys %S\";\n\n\tsub_423652((__int64)v7, (__int64)&exit_status.uc);\n\tsub_40A443(2, 1u);\n\tsub_422C37(format, v7, (__int64)&exit_status.uc);\n\n\tif (exit_status.uc == 127)\n\t\treturn exit_status.i;\n\tif (((exit_status.uc & 0x7F) + 1) >> 1 > 0)\n\t\treturn exit_status.uc & 0x7F;\n\tif ((exit_status.uc & 0x7F) != 0)\n\t\tsub_4F93C9(0LL);\n\n\treturn exit_status.i;\n}",
        "source_code": "int time_main(int argc UNUSED_PARAM, char **argv)\n{\n\tresource_t res;\n\tconst char *output_format = default_format;\n\tint opt;\n\n\topt_complementary = \"-1\"; /* at least one arg */\n\t/* \"+\": stop on first non-option */\n\topt = getopt32(argv, \"+vp\");\n\targv += optind;\n\tif (opt & 1)\n\t\toutput_format = long_format;\n\tif (opt & 2)\n\t\toutput_format = posix_format;\n\n\trun_command(argv, &res);\n\n\t/* Cheat. printf's are shorter :) */\n\txdup2(STDERR_FILENO, STDOUT_FILENO);\n\tsummarize(output_format, argv, &res);\n\n\tif (WIFSTOPPED(res.waitstatus))\n\t\treturn WSTOPSIG(res.waitstatus);\n\tif (WIFSIGNALED(res.waitstatus))\n\t\treturn WTERMSIG(res.waitstatus);\n\tif (WIFEXITED(res.waitstatus))\n\t\treturn WEXITSTATUS(res.waitstatus);\n\tfflush_stdout_and_exit(EXIT_SUCCESS);\n}",
        "parsed_output": "int time_main(int argc UNUSED_PARAM, char **argv)\n{\n\tconst char *format = \"real\\t%E\\nuser\\t%u\\nsys\\t%T\";\n\tint status;\n\tunion {\n\t\tint i;\n\t\tunsigned char uc;\n\t} exit_status;\n\n\texit_status.i = -1;\n\n\topt_complementary = \"=1\"; /* must have exactly 1 argument */\n\tstatus = getopt32(argv, \"+vp\", &format);\n\targv += optind;\n\n\tif (status & 1)\n\t\tformat = \"\\tCommand being timed: \\\"%C\\\"\\n\"\n\t\t         \"\\tUser time (seconds): %U\\n\"\n\t\t         \"\\tSystem time (seconds): %S\\n\"\n\t\t         \"\\tPercent of CPU this job got: %P\\n\"\n\t\t         \"\\tElapsed (wall clock) time (h:mm:ss or m:ss): %E\\n\"\n\t\t         \"\\tAverage shared text size (kbytes): %X\\n\"\n\t\t         \"\\tAverage unshared data size (kbytes): %D\\n\"\n\t\t         \"\\tAverage stack size (kbytes): %p\\n\"\n\t\t         \"\\tAverage total size (kbytes): %K\\n\"\n\t\t         \"\\tMaximum resident set size (kbytes): %M\\n\"\n\t\t         \"\\tAverage resident set size (kbytes): %t\\n\"\n\t\t         \"\\tMajor (requiring I/O) page faults: %F\\n\"\n\t\t         \"\\tMinor (reclaiming a frame) page faults: %R\\n\"\n\t\t         \"\\tVoluntary context switches: %w\\n\"\n\t\t         \"\\tInvoluntary context switches: %c\\n\"\n\t\t         \"\\tSwaps: %W\\n\"\n\t\t         \"\\tFile system inputs: %I\\n\"\n\t\t         \"\\tFile system outputs: %O\\n\"\n\t\t         \"\\tSocket messages sent: %s\\n\"\n\t\t         \"\\tSocket messages received: %r\\n\"\n\t\t         \"\\tSignals delivered: %k\\n\"\n\t\t         \"\\tPage size (bytes): %Z\\n\"\n\t\t         \"\\tExit status: %x\";\n\tif (status & 2)\n\t\tformat = \"real %e\\nuser %U\\nsys %S\";\n\n\tsub_423652((__int64)v7, (__int64)&exit_status.uc);\n\tsub_40A443(2, 1u);\n\tsub_422C37(format, v7, (__int64)&exit_status.uc);\n\n\tif (exit_status.uc == 127)\n\t\treturn exit_status.i;\n\tif (((exit_status.uc & 0x7F) + 1) >> 1 > 0)\n\t\treturn exit_status.uc & 0x7F;\n\tif ((exit_status.uc & 0x7F) != 0)\n\t\tsub_4F93C9(0LL);\n\n\treturn exit_status.i;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_423704(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  _QWORD *v7; // [rsp+0h] [rbp-C0h]\n  char v8; // [rsp+10h] [rbp-B0h] BYREF\n  unsigned __int8 v9; // [rsp+11h] [rbp-AFh]\n  int v10; // [rsp+B4h] [rbp-Ch]\n  const char *v11; // [rsp+B8h] [rbp-8h]\n\n  v11 = \"real\\t%E\\nuser\\t%u\\nsys\\t%T\";\n  qword_75D440 = (__int64)\"-1\";\n  v10 = sub_4FA1EF(a2, (unsigned int)\"+vp\", a3, a4, a5, a6);\n  v7 = (_QWORD *)(8LL * optind + a2);\n  if ( (v10 & 1) != 0 )\n    v11 = \"\\tCommand being timed: \\\"%C\\\"\\n\"\n          \"\\tUser time (seconds): %U\\n\"\n          \"\\tSystem time (seconds): %S\\n\"\n          \"\\tPercent of CPU this job got: %P\\n\"\n          \"\\tElapsed (wall clock) time (h:mm:ss or m:ss): %E\\n\"\n          \"\\tAverage shared text size (kbytes): %X\\n\"\n          \"\\tAverage unshared data size (kbytes): %D\\n\"\n          \"\\tAverage stack size (kbytes): %p\\n\"\n          \"\\tAverage total size (kbytes): %K\\n\"\n          \"\\tMaximum resident set size (kbytes): %M\\n\"\n          \"\\tAverage resident set size (kbytes): %t\\n\"\n          \"\\tMajor (requiring I/O) page faults: %F\\n\"\n          \"\\tMinor (reclaiming a frame) page faults: %R\\n\"\n          \"\\tVoluntary context switches: %w\\n\"\n          \"\\tInvoluntary context switches: %c\\n\"\n          \"\\tSwaps: %W\\n\"\n          \"\\tFile system inputs: %I\\n\"\n          \"\\tFile system outputs: %O\\n\"\n          \"\\tSocket messages sent: %s\\n\"\n          \"\\tSocket messages received: %r\\n\"\n          \"\\tSignals delivered: %k\\n\"\n          \"\\tPage size (bytes): %Z\\n\"\n          \"\\tExit status: %x\";\n  if ( (v10 & 2) != 0 )\n    v11 = \"real %e\\nuser %U\\nsys %S\";\n  sub_423652((__int64)v7, (__int64)&v8);\n  sub_40A443(2, 1u);\n  sub_422C37(v11, v7, (__int64)&v8);\n  if ( v8 == 127 )\n    return v9;\n  if ( (char)((v8 & 0x7F) + 1) >> 1 > 0 )\n    return v8 & 0x7F;\n  if ( (v8 & 0x7F) != 0 )\n    sub_4F93C9(0LL);\n  return v9;\n}\n",
        "baseline_code_debug": "int __cdecl time_main(int argc, char **argv)\n{\n  char **argva; // [rsp+0h] [rbp-C0h]\n  resource_t res; // [rsp+10h] [rbp-B0h] BYREF\n  int opt; // [rsp+B4h] [rbp-Ch]\n  const char *output_format; // [rsp+B8h] [rbp-8h]\n\n  output_format = \"real\\t%E\\nuser\\t%u\\nsys\\t%T\";\n  opt_complementary = \"-1\";\n  opt = getopt32(argv, \"+vp\");\n  argva = &argv[optind];\n  if ( (opt & 1) != 0 )\n    output_format = \"\\tCommand being timed: \\\"%C\\\"\\n\"\n                    \"\\tUser time (seconds): %U\\n\"\n                    \"\\tSystem time (seconds): %S\\n\"\n                    \"\\tPercent of CPU this job got: %P\\n\"\n                    \"\\tElapsed (wall clock) time (h:mm:ss or m:ss): %E\\n\"\n                    \"\\tAverage shared text size (kbytes): %X\\n\"\n                    \"\\tAverage unshared data size (kbytes): %D\\n\"\n                    \"\\tAverage stack size (kbytes): %p\\n\"\n                    \"\\tAverage total size (kbytes): %K\\n\"\n                    \"\\tMaximum resident set size (kbytes): %M\\n\"\n                    \"\\tAverage resident set size (kbytes): %t\\n\"\n                    \"\\tMajor (requiring I/O) page faults: %F\\n\"\n                    \"\\tMinor (reclaiming a frame) page faults: %R\\n\"\n                    \"\\tVoluntary context switches: %w\\n\"\n                    \"\\tInvoluntary context switches: %c\\n\"\n                    \"\\tSwaps: %W\\n\"\n                    \"\\tFile system inputs: %I\\n\"\n                    \"\\tFile system outputs: %O\\n\"\n                    \"\\tSocket messages sent: %s\\n\"\n                    \"\\tSocket messages received: %r\\n\"\n                    \"\\tSignals delivered: %k\\n\"\n                    \"\\tPage size (bytes): %Z\\n\"\n                    \"\\tExit status: %x\";\n  if ( (opt & 2) != 0 )\n    output_format = \"real %e\\nuser %U\\nsys %S\";\n  run_command(argva, &res);\n  xdup2(2, 1);\n  summarize(output_format, argva, &res);\n  if ( LOBYTE(res.waitstatus) == 127 )\n    return BYTE1(res.waitstatus);\n  if ( (char)((res.waitstatus & 0x7F) + 1) >> 1 > 0 )\n    return res.waitstatus & 0x7F;\n  if ( (res.waitstatus & 0x7F) != 0 )\n    fflush_stdout_and_exit(0);\n  return BYTE1(res.waitstatus);\n}\n",
        "similarity_score_unixcoder": 0.644558310508728,
        "similarity_score_baseline_stripped": 0.5336705446243286,
        "similarity_score_baseline_debug": 0.6776934862136841
    },
    {
        "func_name": "func_etime",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_4635CC(char *a1, int a2, __int64 a3)\n{\n  unsigned __int64 v3; // rbx\n  unsigned int v4; // eax\n\n  v3 = *(_QWORD *)(a3 + 72) + *(_QWORD *)(a3 + 64);\n  v4 = sub_4630E3();\n  return snprintf(a1, a2 + 1, \"%3lu:%02u\", v3 / v4 / 0x3C, v3 / v4 % 0x3C);\n}\n\n\n Revised code:\nstatic void func_time(char *buf, int size, const procps_status_t *ps)\n{\n\t/* cumulative time [[dd-]hh:]mm:ss; here only mm:ss */\n\tunsigned long mm;\n\tunsigned ss;\n\n\tmm = (ps->utime + ps->stime) / get_kernel_HZ();\n\tss = mm % 60;\n\tmm /= 60;\n\tsnprintf(buf, size+1, \"%3lu:%02u\", mm, ss);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4317A8(const char *a1, const char *a2, size_t a3)\n{\n  unsigned int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = strncmp(a1, a2, a3);\n  if ( v5 )\n    return v5;\n  else\n    return (unsigned int)-(unsigned __int8)a2[a3];\n}\n\n\n Revised code:\nstatic int strncmpz(const char *l, const char *r, size_t llen)\n{\n\tint i = strncmp(l, r, llen);\n\n\tif (i == 0)\n\t\treturn - (unsigned char)r[llen];\n\treturn i;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_481E8D(__int64 a1, unsigned int a2)\n{\n  __int64 v3; // rbx\n  unsigned int v4; // [rsp+4h] [rbp-2Ch]\n  char *ptr; // [rsp+10h] [rbp-20h]\n  char *v6; // [rsp+18h] [rbp-18h]\n\n  if ( !*(_QWORD *)a1 )\n    return sub_4818B0(a1, a2);\n  v3 = *(_QWORD *)a1;\n  v6 = (char *)(v3 + (int)sub_4819F4((_QWORD *)a1, a2));\n  if ( (unsigned int)sub_481A3B(v6) )\n  {\n    ptr = sub_40A11F(v6, a2);\n    *(_DWORD *)(a1 + 8) = (_DWORD)v6 - *(_DWORD *)a1;\n    v4 = sub_481B55(ptr, a1, a2);\n    free(ptr);\n    return v4;\n  }\n  else\n  {\n    *(_DWORD *)(a1 + 8) = (unsigned int)sub_47FF75(v6) - *(_DWORD *)a1;\n    return sub_4818B0(a1, a2);\n  }\n}\n\n\n Revised code:\nstatic int perform_glob(o_string *o, int n)\n{\n\tchar *pattern, *copy;\n\n\tdebug_printf_glob(\"start perform_glob: n:%d o->data:%p\\n\", n, o->data);\n\tif (!o->data)\n\t\treturn o_save_ptr_helper(o, n);\n\tpattern = o->data + o_get_last_ptr(o, n);\n\tdebug_printf_glob(\"glob pattern '%s'\\n\", pattern);\n\tif (!glob_needed(pattern)) {\n\t\t/* unbackslash last string in o in place, fix length */\n\t\to->length = unbackslash(pattern) - o->data;\n\t\tdebug_printf_glob(\"glob pattern '%s' is literal\\n\", pattern);\n\t\treturn o_save_ptr_helper(o, n);\n\t}\n\n\tcopy = xstrdup(pattern);\n\t/* \"forget\" pattern in o */\n\to->length = pattern - o->data;\n\tn = glob_brace(copy, o, n);\n\tfree(copy);\n\tif (DEBUG_GLOB)\n\t\tdebug_print_list(\"perform_glob returning\", o, n);\n\treturn n;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_46350A(char *a1, int a2, __int64 a3)\n{\n  unsigned __int64 v3; // rbx\n  unsigned __int64 v5; // [rsp+28h] [rbp-18h]\n\n  v3 = *(_QWORD *)(a3 + 80);\n  v5 = *(_QWORD *)&dest.c_cc[23] - v3 / (unsigned int)sub_4630E3();\n  return snprintf(a1, a2 + 1, \"%3lu:%02u\", v5 / 0x3C, v5 % 0x3C);\n}\n",
        "output": "static void func_time(char *buf, int size, const procps_status_t *ps)\n{\n\t/* cumulative time [[dd-]hh:]mm:ss; here only mm:ss */\n\tunsigned long mm;\n\tunsigned ss;\n\n\tmm = (ps->utime + ps->stime) / get_kernel_HZ();\n\tss = mm % 60;\n\tmm /= 60;\n\tsnprintf(buf, size+1, \"%3lu:%02u\", mm, ss);\n}",
        "source_code": "if ENABLE_FEATURE_PS_TIME\n\nstatic void func_etime(char *buf, int size, const procps_status_t *ps)\n{\n\t/* elapsed time [[dd-]hh:]mm:ss; here only mm:ss */\n\tunsigned long mm;\n\tunsigned ss;\n\n\tmm = ps->start_time / get_kernel_HZ();\n\t/* must be after get_kernel_HZ()! */\n\tmm = seconds_since_boot - mm;\n\tss = mm % 60;\n\tmm /= 60;\n\tsnprintf(buf, size+1, \"%3lu:%02u\", mm, ss);\n}",
        "parsed_output": "static void func_time(char *buf, int size, const procps_status_t *ps)\n{\n\t/* cumulative time [[dd-]hh:]mm:ss; here only mm:ss */\n\tunsigned long mm;\n\tunsigned ss;\n\n\tmm = (ps->utime + ps->stime) / get_kernel_HZ();\n\tss = mm % 60;\n\tmm /= 60;\n\tsnprintf(buf, size+1, \"%3lu:%02u\", mm, ss);\n}",
        "baseline_code_stripped": "int __fastcall sub_46350A(char *a1, int a2, __int64 a3)\n{\n  unsigned __int64 v3; // rbx\n  unsigned __int64 v5; // [rsp+28h] [rbp-18h]\n\n  v3 = *(_QWORD *)(a3 + 80);\n  v5 = *(_QWORD *)&dest.c_cc[23] - v3 / (unsigned int)sub_4630E3();\n  return snprintf(a1, a2 + 1, \"%3lu:%02u\", v5 / 0x3C, v5 % 0x3C);\n}\n",
        "baseline_code_debug": "void __cdecl func_etime(char *buf, int size, const procps_status_t_0 *ps)\n{\n  unsigned __int64 start_time; // rbx\n  unsigned __int64 mm; // [rsp+28h] [rbp-18h]\n\n  start_time = ps->start_time;\n  mm = *(_QWORD *)&bb_common_bufsiz1.c_cc[23] - start_time / get_kernel_HZ();\n  snprintf(buf, size + 1, \"%3lu:%02u\", mm / 0x3C, mm % 0x3C);\n}\n",
        "similarity_score_unixcoder": 0.9142987728118896,
        "similarity_score_baseline_stripped": 0.45053529739379883,
        "similarity_score_baseline_debug": 0.833077609539032
    },
    {
        "func_name": "remove_ids",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_49BC7F(unsigned int a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  char *v6; // r10\n  char *v7; // rax\n  __int64 v8; // rsi\n  __int64 v9; // rdx\n  __int64 v10; // rcx\n  __int64 v11; // r8\n  __int64 v12; // r9\n  char *v13; // [rsp+18h] [rbp-98h]\n  char v14[48]; // [rsp+20h] [rbp-90h] BYREF\n  time_t v15; // [rsp+50h] [rbp-60h] BYREF\n  time_t v16; // [rsp+60h] [rbp-50h] BYREF\n  unsigned __int64 v17; // [rsp+70h] [rbp-40h]\n  int v18; // [rsp+90h] [rbp-20h]\n  int v19; // [rsp+94h] [rbp-1Ch]\n  int v20; // [rsp+98h] [rbp-18h]\n  int v21; // [rsp+9Ch] [rbp-14h]\n  char *v22; // [rsp+A0h] [rbp-10h]\n  int semnum; // [rsp+ACh] [rbp-4h]\n\n  v22 = v14;\n  v13 = v14;\n  if ( semctl(a1, 0, 2, v14) )\n    return sub_4091D9((__int64)\"semctl\", 0LL, v1, v2, v3, v4);\n  if ( v15 )\n    v6 = ctime(&v15);\n  else\n    v6 = \"Not set\";\n  printf(\n    \"\\n\"\n    \"Semaphore Array semid=%d\\n\"\n    \"uid=%d\\t gid=%d\\t cuid=%d\\t cgid=%d\\n\"\n    \"mode=%#o, access_perms=%#o\\n\"\n    \"nsems = %ld\\n\"\n    \"otime = %-26.24s\\n\",\n    a1,\n    *((unsigned int *)v22 + 1),\n    *((unsigned int *)v22 + 2),\n    *((unsigned int *)v22 + 3),\n    *((unsigned int *)v22 + 4),\n    *((unsigned __int16 *)v22 + 10),\n    *((_WORD *)v22 + 10) & 0x1FF,\n    v17,\n    v6);\n  v7 = ctime(&v16);\n  printf(\"ctime = %-26.24s\\n%-10s %-10s %-10s %-10s %-10s\\n\", v7, \"semnum\", \"value\", \"ncount\", \"zcount\", \"pid\");\n  LODWORD(v13) = 0;\n  for ( semnum = 0; (unsigned int)semnum < v17; ++semnum )\n  {\n    v21 = semctl(a1, semnum, 12, v13);\n    v20 = semctl(a1, semnum, 14, v13);\n    v19 = semctl(a1, semnum, 15, v13);\n    v8 = (unsigned int)semnum;\n    v18 = semctl(a1, semnum, 11, v13);\n    if ( v21 < 0 || v20 < 0 || v19 < 0 || v18 < 0 )\n      sub_4092A2((__int64)\"semctl\", v8, v9, v10, v11, v12);\n    printf(\n      \"%-10d %-10d %-10d %-10d %-10d\\n\",\n      (unsigned int)semnum,\n      (unsigned int)v21,\n      (unsigned int)v20,\n      (unsigned int)v19,\n      (unsigned int)v18);\n  }\n  return sub_40A659(10);\n}\n\n\n Revised code:\nstatic void print_sem(int semid)\n{\n\tstruct semid_ds semds;\n\tstruct ipc_perm *ipcp = &semds.sem_perm;\n\tunion semun arg;\n\tunsigned int i;\n\n\targ.buf = &semds;\n\tif (semctl(semid, 0, IPC_STAT, arg)) {\n\t\tbb_perror_msg(\"semctl\");\n\t\treturn;\n\t}\n\n\tprintf(\"\\nSemaphore Array semid=%d\\n\"\n\t\t\t\"uid=%d\\t gid=%d\\t cuid=%d\\t cgid=%d\\n\"\n\t\t\t\"mode=%#o, access_perms=%#o\\n\"\n\t\t\t\"nsems = %ld\\n\"\n\t\t\t\"otime = %-26.24s\\n\",\n\t\t\tsemid,\n\t\t\tipcp->uid, ipcp->gid, ipcp->cuid, ipcp->cgid,\n\t\t\tipcp->mode, ipcp->mode & 0777,\n\t\t\t(long) semds.sem_nsems,\n\t\t\tsemds.sem_otime ? ctime(&semds.sem_otime) : \"Not set\");\n\tprintf(\"ctime = %-26.24s\\n\"\n\t\t\t\"%-10s %-10s %-10s %-10s %-10s\\n\",\n\t\t\tctime(&semds.sem_ctime),\n\t\t\t\"semnum\", \"value\", \"ncount\", \"zcount\", \"pid\");\n\n\targ.val = 0;\n\tfor (i = 0; i < semds.sem_nsems; i++) {\n\t\tint val, ncnt, zcnt, pid;\n\n\t\tval = semctl(semid, i, GETVAL, arg);\n\t\tncnt = semctl(semid, i, GETNCNT, arg);\n\t\tzcnt = semctl(semid, i, GETZCNT, arg);\n\t\tpid = semctl(semid, i, GETPID, arg);\n\t\tif (val < 0 || ncnt < 0 || zcnt < 0 || pid < 0) {\n\t\t\tbb_perror_msg_and_die(\"semctl\");\n\t\t}\n\t\tprintf(\"%-10d %-10d %-10d %-10d %-10d\\n\", i, val, ncnt, zcnt, pid);\n\t}\n\tbb_putchar('\\n');\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4715A3(__int64 a1, __int64 a2)\n{\n  unsigned int v2; // eax\n  int v4; // [rsp+4h] [rbp-2Ch]\n  __int64 v5; // [rsp+8h] [rbp-28h]\n  unsigned int v6; // [rsp+1Ch] [rbp-14h]\n  unsigned int pgrp; // [rsp+20h] [rbp-10h]\n  int v8; // [rsp+24h] [rbp-Ch]\n  __int64 v9; // [rsp+28h] [rbp-8h]\n\n  v5 = a1;\n  v4 = a2;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  if ( *(_BYTE *)(a1 + 30) != 2 )\n  {\n    *(_BYTE *)(a1 + 30) = 0;\n    pgrp = **(_DWORD **)(a1 + 16);\n    if ( !(_DWORD)a2 )\n      sub_471133(dword_75AE30, pgrp);\n    a2 = 18LL;\n    a1 = pgrp;\n    killpg(pgrp, 18);\n    v9 = *(_QWORD *)(v5 + 16);\n    v8 = *(unsigned __int16 *)(v5 + 28);\n    do\n    {\n      if ( (unsigned __int8)*(_DWORD *)(v9 + 4) == 127 )\n        *(_DWORD *)(v9 + 4) = -1;\n      v9 += 16LL;\n      --v8;\n    }\n    while ( v8 );\n  }\n  if ( v4 )\n  {\n    v2 = 0;\n  }\n  else\n  {\n    a1 = v5;\n    v2 = sub_472F50(v5);\n  }\n  v6 = v2;\n  sub_46E03F(a1, a2);\n  return v6;\n}\n\n\n Revised code:\nstatic int\nrestartjob(struct job *jp, int mode)\n{\n\tstruct procstat *ps;\n\tint i;\n\tint status;\n\tpid_t pgid;\n\n\tINT_OFF;\n\tif (jp->state == JOBDONE)\n\t\tgoto out;\n\tjp->state = JOBRUNNING;\n\tpgid = jp->ps[0].ps_pid;\n\tif (mode == FORK_FG)\n\t\txtcsetpgrp(ttyfd, pgid);\n\tkillpg(pgid, SIGCONT);\n\tps = jp->ps;\n\ti = jp->nprocs;\n\tdo {\n\t\tif (WIFSTOPPED(ps->ps_status)) {\n\t\t\tps->ps_status = -1;\n\t\t}\n\t\tps++;\n\t} while (--i);\n out:\n\tstatus = (mode == FORK_FG) ? waitforjob(jp) : 0;\n\tINT_ON;\n\treturn status;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A21A0(__int64 *a1, __int64 a2, const void *a3)\n{\n  const char *v3; // rsi\n  __int64 v4; // rdx\n  __int64 v5; // rcx\n  __int64 v6; // r8\n  __int64 v7; // r9\n  unsigned __int64 v10; // [rsp+10h] [rbp-60h]\n  unsigned int v11; // [rsp+6Ch] [rbp-4h]\n\n  v10 = a2;\n  v11 = 0;\n  if ( (dword_75D450 & 0x40) != 0 )\n  {\n    if ( dest.c_iflag > 1 )\n      sub_409747(\"would do mount('%s','%s','%s',0x%08lx,'%s')\", *a1, a1[1], a1[2], a2, (__int64)a3);\n  }\n  else\n  {\n    while ( 1 )\n    {\n      *(_DWORD *)qword_75D400 = 0;\n      v3 = (const char *)a1[1];\n      v11 = sub_4A1CAF((const char *)*a1, v3, (const char *)a1[2], v10, a3);\n      if ( !v11 || (v10 & 1) != 0 || *(_DWORD *)qword_75D400 != 13 && *(_DWORD *)qword_75D400 != 30 )\n        break;\n      if ( (v10 & 0x8000) == 0 )\n        sub_409747(\"%s is write-protected, mounting read-only\", *a1, v4, v5, v6, v7);\n      v10 |= 1uLL;\n    }\n    if ( v11 && *(_DWORD *)qword_75D400 == 1 )\n      sub_40969E(\"permission denied (are you root?)\", (__int64)v3, v4, v5, v6, v7);\n  }\n  return v11;\n}\n\n\n Revised code:\nxxx fields may be trashed on exit\nstatic int mount_it_now(struct mntent *mp, unsigned long vfsflags, char *filteropts)\n{\n\tint rc = 0;\n\n\tif (FAKE_IT) {\n\t\tif (verbose >= 2)\n\t\t\tbb_error_msg(\"would do mount('%s','%s','%s',0x%08lx,'%s')\",\n\t\t\t\tmp->mnt_fsname, mp->mnt_dir, mp->mnt_type,\n\t\t\t\tvfsflags, filteropts);\n\t\tgoto mtab;\n\t}\n\n\t// Mount, with fallback to read-only if necessary.\n\tfor (;;) {\n\t\terrno = 0;\n\t\trc = verbose_mount(mp->mnt_fsname, mp->mnt_dir, mp->mnt_type,\n\t\t\t\tvfsflags, filteropts);\n\n\t\t// If mount failed, try\n\t\t// helper program mount.<mnt_type>\n\t\tif (HELPERS_ALLOWED && rc && mp->mnt_type) {\n\t\t\tchar *args[8];\n\t\t\tint errno_save = errno;\n\t\t\targs[0] = xasprintf(\"mount.%s\", mp->mnt_type);\n\t\t\trc = 1;\n\t\t\tif (FAKE_IT)\n\t\t\t\targs[rc++] = (char *)\"-f\";\n\t\t\tif (ENABLE_FEATURE_MTAB_SUPPORT && !USE_MTAB)\n\t\t\t\targs[rc++] = (char *)\"-n\";\n\t\t\targs[rc++] = mp->mnt_fsname;\n\t\t\targs[rc++] = mp->mnt_dir;\n\t\t\tif (filteropts) {\n\t\t\t\targs[rc++] = (char *)\"-o\";\n\t\t\t\targs[rc++] = filteropts;\n\t\t\t}\n\t\t\targs[rc] = NULL;\n\t\t\trc = spawn_and_wait(args);\n\t\t\tfree(args[0]);\n\t\t\tif (!rc)\n\t\t\t\tbreak;\n\t\t\terrno = errno_save;\n\t\t}\n\n\t\tif (!rc || (vfsflags & MS_RDONLY) || (errno != EACCES && errno != EROFS))\n\t\t\tbreak;\n\t\tif (!(vfsflags & MS_SILENT))\n\t\t\tbb_error_msg(\"%s is write-protected, mounting read-only\",\n\t\t\t\t\t\tmp->mnt_fsname);\n\t\tvfsflags |= MS_RDONLY;\n\t}\n\n\t// Abort entirely if permission denied.\n\n\tif (rc && errno == EPERM)\n\t\tbb_error_msg_and_die(bb_msg_perm_denied_are_you_root);\n\n\t// If the mount was successful, and we're maintaining an old-style\n\t// mtab file by hand, add the new entry to it now.\n mtab:\n\tif (USE_MTAB && !rc && !(vfsflags & MS_REMOUNT)) {\n\t\tchar *fsname;\n\t\tFILE *mountTable = setmntent(bb_path_mtab_file, \"a+\");\n\t\tconst char *option_str = mount_option_str;\n\t\tint i;\n\n\t\tif (!mountTable) {\n\t\t\tbb_perror_msg(bb_path_mtab_file);\n\t\t\tgoto ret;\n\t\t}\n\n\t\t// Add vfs string flags\n\t\tfor (i = 0; mount_options[i] != MS_REMOUNT; i++) {\n\t\t\tif (mount_options[i] > 0 && (mount_options[i] & vfsflags))\n\t\t\t\tappend_mount_options(&(mp->mnt_opts), option_str);\n\t\t\toption_str += strlen(option_str) + 1;\n\t\t}\n\n\t\t// Remove trailing / (if any) from directory we mounted on\n\t\ti = strlen(mp->mnt_dir) - 1;\n\t\twhile (i > 0 && mp->mnt_dir[i] == '/')\n\t\t\tmp->mnt_dir[i--] = '\\0';\n\n\t\t// Convert to canonical pathnames as needed\n\t\tmp->mnt_dir = bb_simplify_path(mp->mnt_dir);\n\t\tfsname = NULL;\n\t\tif (!mp->mnt_type || !*mp->mnt_type) { // bind mount\n\t\t\tmp->mnt_fsname = fsname = bb_simplify_path(mp->mnt_fsname);\n\t\t\tmp->mnt_type = (char*)\"bind\";\n\t\t}\n\t\tmp->mnt_freq = mp->mnt_passno = 0;\n\n\t\t// Write and close\n#if ENABLE_FEATURE_MTAB_SUPPORT\n\t\tif (vfsflags & MS_MOVE)\n\t\t\tupdate_mtab_entry_on_move(mp);\n\t\telse\n#endif\n\t\t\taddmntent(mountTable, mp);\n\t\tendmntent(mountTable);\n\n\t\tif (ENABLE_FEATURE_CLEAN_UP) {\n\t\t\tfree(mp->mnt_dir);\n\t\t\tfree(fsname);\n\t\t}\n\t}\n ret:\n\treturn rc;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_49A5BC(int a1, const char **a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  const char **v7; // [rsp+0h] [rbp-30h]\n  unsigned __int64 semid; // [rsp+20h] [rbp-10h]\n  int v9; // [rsp+28h] [rbp-8h]\n  unsigned int v10; // [rsp+2Ch] [rbp-4h]\n\n  v7 = a2;\n  v10 = 0;\n  while ( *v7 )\n  {\n    semid = sub_49A56E(*v7, 0LL, 10);\n    if ( *(_DWORD *)qword_75D400 || semid > 0x7FFFFFFF )\n    {\n      sub_409747(\"invalid id: %s\", (__int64)*v7, v2, v3, v4, v5, v7);\n      ++v10;\n    }\n    else\n    {\n      v9 = 0;\n      switch ( a1 )\n      {\n        case 1:\n          v9 = semctl(semid, 0, 0, 0);\n          break;\n        case 2:\n          v9 = msgctl(semid, 0, 0LL);\n          break;\n        case 0:\n          v9 = shmctl(semid, 0, 0LL);\n          break;\n      }\n      if ( v9 )\n      {\n        sub_4091D9((__int64)\"can't remove id %s\", (__int64)*v7, v2, v3, v4, v5);\n        ++v10;\n      }\n    }\n    ++v7;\n  }\n  return v10;\n}\n",
        "output": "static int remove_semaphores(int a1, const char **a2)\n{\n\tint count = 0;\n\tconst char **v7 = a2;\n\tunsigned long semid;\n\tint v9;\n\n\twhile (*v7) {\n\t\tsemid = get_sem_id(*v7, 0, 10);\n\t\tif (*(_DWORD *)qword_75D400 || semid > 0x7FFFFFFF) {\n\t\t\tbb_error_msg(\"invalid id: %s\", *v7);\n\t\t\tcount++;\n\t\t} else {\n\t\t\tv9 = 0;\n\t\t\tswitch (a1) {\n\t\t\t\tcase 1:\n\t\t\t\t\tv9 = semctl(semid, 0, 0, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tv9 = msgctl(semid, 0, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\t\tv9 = shmctl(semid, 0, 0);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v9) {\n\t\t\t\tbb_error_msg(\"can't remove id %s\", *v7);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tv7++;\n\t}\n\treturn count;\n}",
        "source_code": "static int remove_ids(type_id type, char **argv)\n{\n\tunsigned long id;\n\tint nb_errors = 0;\n\tunion semun arg;\n\n\targ.val = 0;\n\n\twhile (argv[0]) {\n\t\tid = bb_strtoul(argv[0], NULL, 10);\n\t\tif (errno || id > INT_MAX) {\n\t\t\tbb_error_msg(\"invalid id: %s\", argv[0]);\n\t\t\tnb_errors++;\n\t\t} else {\n\t\t\tint ret = 0;\n\t\t\tif (type == SEM)\n\t\t\t\tret = semctl(id, 0, IPC_RMID, arg);\n\t\t\telse if (type == MSG)\n\t\t\t\tret = msgctl(id, IPC_RMID, NULL);\n\t\t\telse if (type ==  SHM)\n\t\t\t\tret = shmctl(id, IPC_RMID, NULL);\n\n\t\t\tif (ret) {\n\t\t\t\tbb_perror_msg(\"can't remove id %s\", argv[0]);\n\t\t\t\tnb_errors++;\n\t\t\t}\n\t\t}\n\t\targv++;\n\t}\n\n\treturn nb_errors;\n}",
        "parsed_output": "static int remove_semaphores(int a1, const char **a2)\n{\n\tint count = 0;\n\tconst char **v7 = a2;\n\tunsigned long semid;\n\tint v9;\n\n\twhile (*v7) {\n\t\tsemid = get_sem_id(*v7, 0, 10);\n\t\tif (*(_DWORD *)qword_75D400 || semid > 0x7FFFFFFF) {\n\t\t\tbb_error_msg(\"invalid id: %s\", *v7);\n\t\t\tcount++;\n\t\t} else {\n\t\t\tv9 = 0;\n\t\t\tswitch (a1) {\n\t\t\t\tcase 1:\n\t\t\t\t\tv9 = semctl(semid, 0, 0, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tv9 = msgctl(semid, 0, 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\t\tv9 = shmctl(semid, 0, 0);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (v9) {\n\t\t\t\tbb_error_msg(\"can't remove id %s\", *v7);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tv7++;\n\t}\n\treturn count;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_49A5BC(int a1, const char **a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  const char **v7; // [rsp+0h] [rbp-30h]\n  unsigned __int64 semid; // [rsp+20h] [rbp-10h]\n  int v9; // [rsp+28h] [rbp-8h]\n  unsigned int v10; // [rsp+2Ch] [rbp-4h]\n\n  v7 = a2;\n  v10 = 0;\n  while ( *v7 )\n  {\n    semid = sub_49A56E(*v7, 0LL, 10);\n    if ( *(_DWORD *)qword_75D400 || semid > 0x7FFFFFFF )\n    {\n      sub_409747(\"invalid id: %s\", (__int64)*v7, v2, v3, v4, v5, v7);\n      ++v10;\n    }\n    else\n    {\n      v9 = 0;\n      switch ( a1 )\n      {\n        case 1:\n          v9 = semctl(semid, 0, 0, 0);\n          break;\n        case 2:\n          v9 = msgctl(semid, 0, 0LL);\n          break;\n        case 0:\n          v9 = shmctl(semid, 0, 0LL);\n          break;\n      }\n      if ( v9 )\n      {\n        sub_4091D9((__int64)\"can't remove id %s\", (__int64)*v7, v2, v3, v4, v5);\n        ++v10;\n      }\n    }\n    ++v7;\n  }\n  return v10;\n}\n",
        "baseline_code_debug": "int __cdecl remove_ids(type_id_0 type, char **argv)\n{\n  unsigned __int64 id; // [rsp+20h] [rbp-10h]\n  int ret; // [rsp+28h] [rbp-8h]\n  int nb_errors; // [rsp+2Ch] [rbp-4h]\n\n  nb_errors = 0;\n  while ( *argv )\n  {\n    id = bb_strtoul_5(*argv, 0LL, 10);\n    if ( *bb_errno || id > 0x7FFFFFFF )\n    {\n      bb_error_msg(\"invalid id: %s\", *argv);\n      ++nb_errors;\n    }\n    else\n    {\n      ret = 0;\n      switch ( type )\n      {\n        case SEM:\n          ret = semctl(id, 0, 0, 0);\n          break;\n        case MSG:\n          ret = msgctl(id, 0, 0LL);\n          break;\n        case SHM:\n          ret = shmctl(id, 0, 0LL);\n          break;\n      }\n      if ( ret )\n      {\n        bb_perror_msg(\"can't remove id %s\", *argv);\n        ++nb_errors;\n      }\n    }\n    ++argv;\n  }\n  return nb_errors;\n}\n",
        "similarity_score_unixcoder": 0.8179864883422852,
        "similarity_score_baseline_stripped": 0.6693554520606995,
        "similarity_score_baseline_debug": 0.8840855360031128
    },
    {
        "func_name": "ftp_send",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47167A(__int64 a1, _BYTE **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  unsigned int v10; // eax\n  _BYTE **v12; // [rsp+0h] [rbp-30h]\n  unsigned int v13; // [rsp+1Ch] [rbp-14h]\n  __int64 v14; // [rsp+20h] [rbp-10h]\n  _BOOL4 v15; // [rsp+2Ch] [rbp-4h]\n\n  v15 = **a2 != 102;\n  sub_46F038((_BYTE *)(qword_75D418 + 56), (__int64)a2, a3, a4, a5, a6);\n  v12 = (_BYTE **)qword_75AF58;\n  do\n  {\n    v14 = sub_470E8F(*v12, 1, v6, v7, v8, v9);\n    if ( v15 )\n    {\n      sub_470DAE(v14, 1);\n      v10 = sub_470E5C(v14);\n      printf(\"[%d] \", v10);\n    }\n    sub_46E2C6(*(const char **)(*(_QWORD *)(v14 + 16) + 8LL));\n    sub_471522(v14);\n    v13 = sub_4715A3(v14, v15);\n    if ( !*v12 )\n      break;\n    ++v12;\n  }\n  while ( *v12 );\n  return v13;\n}\n\n\n Revised code:\nstatic int FAST_FUNC\nfg_bgcmd(int argc UNUSED_PARAM, char **argv)\n{\n\tstruct job *jp;\n\tint mode;\n\tint retval;\n\n\tmode = (**argv == 'f') ? FORK_FG : FORK_BG;\n\tnextopt(nullstr);\n\targv = argptr;\n\tdo {\n\t\tjp = getjob(*argv, 1);\n\t\tif (mode == FORK_BG) {\n\t\t\tset_curjob(jp, CUR_RUNNING);\n\t\t\tprintf(\"[%d] \", jobno(jp));\n\t\t}\n\t\tout1str(jp->ps[0].ps_cmd);\n\t\tshowpipe(jp /*, stdout*/);\n\t\tretval = restartjob(jp, mode);\n\t} while (*argv && *++argv);\n\treturn retval;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_470439(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  char *v11; // [rsp+18h] [rbp-8h]\n\n  v11 = *(char **)(qword_75D418 + 16);\n  if ( (unsigned int)sub_46FDFE(a1, a2, a3, a4, a5, a6) )\n  {\n    v6 = qword_75D418 + 56;\n    if ( *(_QWORD *)(qword_75D418 + 24) == qword_75D418 + 56 )\n      sub_470099(v11, 0LL);\n    v11 = *(char **)(qword_75D418 + 24);\n  }\n  sub_46E137(\"%s\\n\", (__int64)v11, v6, v7, v8, v9, a2);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC\npwdcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tint flags;\n\tconst char *dir = curdir;\n\n\tflags = cdopt();\n\tif (flags) {\n\t\tif (physdir == nullstr)\n\t\t\tsetpwd(dir, 0);\n\t\tdir = physdir;\n\t}\n\tout1fmt(\"%s\\n\", dir);\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_42FBAE(const char *a1, __int16 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  unsigned int v7; // [rsp+1Ch] [rbp-4h]\n\n  v7 = sub_42FB81(a1, a2 | 1);\n  if ( v7 )\n    sub_4091D9((__int64)\"%s: can't up\", (__int64)a1, v2, v3, v4, v5);\n  return v7;\n}\n\n\n Revised code:\nstatic int set_if_up(char *ifname, int flags)\n{\n\tint res = set_if_flags(ifname, flags | IFF_UP);\n\tif (res)\n\t\tbb_perror_msg(\"%s: can't up\", ifname);\n\treturn res;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_42B203(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  __int64 v10; // rdx\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  __int64 v13; // r9\n  int v15; // [rsp+14h] [rbp-Ch]\n  int v16; // [rsp+18h] [rbp-8h]\n  int v17; // [rsp+1Ch] [rbp-4h]\n\n  v16 = sub_42AEF9(a1, a2, a3, a4, a5, a6);\n  v17 = 0;\n  if ( *(_BYTE *)a2 != 45 || *(_BYTE *)(a2 + 1) )\n    v17 = sub_40A295((const char *)a2, 0);\n  v15 = sub_42AD2D((__int64)\"STOR\", a1, v6, v7, v8, v9);\n  if ( v15 != 125 && v15 != 150 )\n    sub_42ACB6(\"STOR\", a1, v10, v11, v12, v13);\n  return sub_42AFF7(v17, v16);\n}\n",
        "output": "static int FAST_FUNC\nstorecmd(int argc UNUSED_PARAM, char **argv)\n{\n\tint retval;\n\tint mode;\n\tint status;\n\n\tmode = getmode(argv[0]);\n\tif (mode == MODE_ASCII || mode == MODE_BINARY) {\n\t\tstatus = ftpcmd(\"STOR\", argv[1], mode);\n\t\tif (status != 125 && status != 150)\n\t\t\tftperr(\"STOR\", argv[1]);\n\t\tretval = status;\n\t} else {\n\t\tbb_error_msg_and_die(\"unknown mode '%s'\", argv[0]);\n\t}\n\treturn retval;\n}",
        "source_code": "else\nstatic\nint ftp_send(const char *server_path, char *local_path)\n{\n\tint fd_data;\n\tint fd_local;\n\tint response;\n\n\t/* connect to the data socket */\n\tfd_data = xconnect_ftpdata();\n\n\t/* get the local file */\n\tfd_local = STDIN_FILENO;\n\tif (NOT_LONE_DASH(local_path))\n\t\tfd_local = xopen(local_path, O_RDONLY);\n\n\tresponse = ftpcmd(\"STOR\", server_path);\n\tswitch (response) {\n\tcase 125:\n\tcase 150:\n\t\tbreak;\n\tdefault:\n\t\tftp_die(\"STOR\");\n\t}\n\n\treturn pump_data_and_QUIT(fd_local, fd_data);\n}",
        "parsed_output": "static int FAST_FUNC\nstorecmd(int argc UNUSED_PARAM, char **argv)\n{\n\tint retval;\n\tint mode;\n\tint status;\n\n\tmode = getmode(argv[0]);\n\tif (mode == MODE_ASCII || mode == MODE_BINARY) {\n\t\tstatus = ftpcmd(\"STOR\", argv[1], mode);\n\t\tif (status != 125 && status != 150)\n\t\t\tftperr(\"STOR\", argv[1]);\n\t\tretval = status;\n\t} else {\n\t\tbb_error_msg_and_die(\"unknown mode '%s'\", argv[0]);\n\t}\n\treturn retval;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_42B203(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  __int64 v10; // rdx\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  __int64 v13; // r9\n  int v15; // [rsp+14h] [rbp-Ch]\n  int v16; // [rsp+18h] [rbp-8h]\n  int v17; // [rsp+1Ch] [rbp-4h]\n\n  v16 = sub_42AEF9(a1, a2, a3, a4, a5, a6);\n  v17 = 0;\n  if ( *(_BYTE *)a2 != 45 || *(_BYTE *)(a2 + 1) )\n    v17 = sub_40A295((const char *)a2, 0);\n  v15 = sub_42AD2D((__int64)\"STOR\", a1, v6, v7, v8, v9);\n  if ( v15 != 125 && v15 != 150 )\n    sub_42ACB6(\"STOR\", a1, v10, v11, v12, v13);\n  return sub_42AFF7(v17, v16);\n}\n",
        "baseline_code_debug": "int __cdecl ftp_send(const char *server_path, char *local_path)\n{\n  int response; // [rsp+14h] [rbp-Ch]\n  int fd_data; // [rsp+18h] [rbp-8h]\n  int fd_local; // [rsp+1Ch] [rbp-4h]\n\n  fd_data = xconnect_ftpdata();\n  fd_local = 0;\n  if ( *local_path != 45 || local_path[1] )\n    fd_local = xopen(local_path, 0);\n  response = ftpcmd(\"STOR\", server_path);\n  if ( response != 125 && response != 150 )\n    ftp_die(\"STOR\");\n  return pump_data_and_QUIT(fd_local, fd_data);\n}\n",
        "similarity_score_unixcoder": 0.6722759008407593,
        "similarity_score_baseline_stripped": 0.4301674962043762,
        "similarity_score_baseline_debug": 0.8952116966247559
    },
    {
        "func_name": "xstrdup",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_40A020(size_t a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  void *v7; // [rsp+18h] [rbp-8h]\n\n  v7 = malloc(a1);\n  if ( !v7 && a1 )\n    sub_409747(\"out of memory\", a2, v2, v3, v4, v5);\n  return v7;\n}\n\n\n Revised code:\nFAST_FUNC malloc_or_warn(size_t size)\n{\n\tvoid *ptr = malloc(size);\n\tif (ptr == NULL && size != 0)\n\t\tbb_error_msg(bb_msg_memory_exhausted);\n\treturn ptr;\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_40A05F(size_t a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  void *v7; // [rsp+18h] [rbp-8h]\n\n  v7 = malloc(a1);\n  if ( !v7 && a1 )\n    sub_40969E(\"out of memory\", a2, v2, v3, v4, v5);\n  return v7;\n}\n\n\n Revised code:\nFAST_FUNC xmalloc(size_t size)\n{\n\tvoid *ptr = malloc(size);\n\tif (ptr == NULL && size != 0)\n\t\tbb_error_msg_and_die(bb_msg_memory_exhausted);\n\treturn ptr;\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_5074C8(const char *a1, unsigned __int64 *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  void *v7; // [rsp+18h] [rbp-8h]\n\n  v7 = sub_5073F7(a1, a2);\n  if ( !v7 )\n    sub_4092A2((__int64)\"can't read '%s'\", (__int64)a1, v2, v3, v4, v5, a2);\n  return v7;\n}\n\n\n Revised code:\nFAST_FUNC xmalloc_xopen_read_close(const char *filename, size_t *maxsz_p)\n{\n\tvoid *buf = xmalloc_open_read_close(filename, maxsz_p);\n\tif (!buf)\n\t\tbb_perror_msg_and_die(\"can't read '%s'\", filename);\n\treturn buf;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_40A11F(const char *a1, __int64 a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // [rsp+18h] [rbp-8h]\n\n  if ( !a1 )\n    return 0LL;\n  v7 = strdup(a1);\n  if ( !v7 )\n    sub_40969E(\"out of memory\", a2, v3, v4, v5, v6);\n  return v7;\n}\n",
        "output": "FAST_FUNC xstrdup(const char *str)\n{\n\tif (!str)\n\t\treturn NULL;\n\tchar *dup_str = strdup(str);\n\tif (!dup_str)\n\t\tbb_error_msg_and_die(bb_msg_memory_exhausted);\n\treturn dup_str;\n}",
        "source_code": "FAST_FUNC xstrdup(const char *s)\n{\n\tchar *t;\n\n\tif (s == NULL)\n\t\treturn NULL;\n\n\tt = strdup(s);\n\n\tif (t == NULL)\n\t\tbb_error_msg_and_die(bb_msg_memory_exhausted);\n\n\treturn t;\n}",
        "parsed_output": "FAST_FUNC xstrdup(const char *str)\n{\n\tif (!str)\n\t\treturn NULL;\n\tchar *dup_str = strdup(str);\n\tif (!dup_str)\n\t\tbb_error_msg_and_die(bb_msg_memory_exhausted);\n\treturn dup_str;\n}",
        "baseline_code_stripped": "char *__fastcall sub_40A11F(const char *a1, __int64 a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // [rsp+18h] [rbp-8h]\n\n  if ( !a1 )\n    return 0LL;\n  v7 = strdup(a1);\n  if ( !v7 )\n    sub_40969E(\"out of memory\", a2, v3, v4, v5, v6);\n  return v7;\n}\n",
        "baseline_code_debug": "char *__cdecl xstrdup(const char *s)\n{\n  char *t; // [rsp+18h] [rbp-8h]\n\n  if ( !s )\n    return 0LL;\n  t = strdup(s);\n  if ( !t )\n    bb_error_msg_and_die(\"out of memory\");\n  return t;\n}\n",
        "similarity_score_unixcoder": 0.8887166380882263,
        "similarity_score_baseline_stripped": 0.5678436756134033,
        "similarity_score_baseline_debug": 0.7883061170578003
    },
    {
        "func_name": "setsignal",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_471AE1(FILE *a1, __int64 a2, char a3)\n{\n  int result; // eax\n  unsigned int v4; // eax\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 v7; // r8\n  __int64 v8; // r9\n  int v9; // eax\n  int v10; // eax\n  const char *v11; // rdi\n  unsigned int v12; // ecx\n  char v15[80]; // [rsp+20h] [rbp-70h] BYREF\n  unsigned int *v16; // [rsp+70h] [rbp-20h]\n  unsigned int v17; // [rsp+7Ch] [rbp-14h]\n  int v18; // [rsp+80h] [rbp-10h]\n  unsigned int v19; // [rsp+84h] [rbp-Ch]\n  unsigned int *v20; // [rsp+88h] [rbp-8h]\n\n  v20 = *(unsigned int **)(a2 + 16);\n  if ( (a3 & 1) != 0 )\n    return fprintf(a1, \"%d\\n\", *v20);\n  v4 = sub_470E5C(a2);\n  v19 = sub_46E1F9(v15, 0x10uLL, \"[%d]   \", v4, v5, v6);\n  v17 = v19;\n  if ( a2 == qword_75AFB0 )\n  {\n    v15[v19 - 3] = 43;\n  }\n  else if ( qword_75AFB0 && a2 == *(_QWORD *)(qword_75AFB0 + 32) )\n  {\n    v15[v19 - 3] = 45;\n  }\n  if ( (a3 & 2) != 0 )\n  {\n    v9 = sub_46E1F9(&v15[v19], 0x10uLL, \"%d \", *v20, v7, v8);\n    v19 += v9;\n  }\n  v16 = &v20[4 * *(unsigned __int16 *)(a2 + 28)];\n  if ( *(_BYTE *)(a2 + 30) )\n  {\n    v18 = *(v16 - 3);\n    if ( *(_BYTE *)(a2 + 30) == 1 )\n      v18 = *(_DWORD *)(a2 + 24);\n    v10 = sub_471762(&v15[v19], v18, 0, (__int64)&v15[v19], v7, v8);\n    v19 += v10;\n  }\n  else\n  {\n    *(_QWORD *)&v15[v19] = 0x676E696E6E7552LL;\n    v19 += 7;\n  }\n  while ( 1 )\n  {\n    if ( v20 == *(unsigned int **)(a2 + 16) )\n      v11 = (const char *)&unk_51CA3E;\n    else\n      v11 = \"| \";\n    v12 = 0;\n    if ( (int)(33 - v19) >= 0 )\n      v12 = 33 - v19;\n    fprintf(a1, \"%s%*c%s%s\", v15, v12, 32LL, v11, *((const char **)v20 + 1));\n    v20 += 4;\n    if ( v20 == v16 )\n      break;\n    v15[0] = 0;\n    v19 = 33;\n    if ( (a3 & 2) != 0 )\n      v19 = sub_46E1F9(v15, 0x30uLL, \"\\n%*c%d \", v17, 32LL, *v20) - 1;\n  }\n  sub_46E0F3(10, a1);\n  *(_BYTE *)(a2 + 31) &= ~0x10u;\n  result = *(unsigned __int8 *)(a2 + 30);\n  if ( (_BYTE)result == 2 )\n    return sub_47107C(a2);\n  return result;\n}\n\n\n Revised code:\nif JOBS\nstatic void\nshowjob(FILE *out, struct job *jp, int mode)\n{\n\tstruct procstat *ps;\n\tstruct procstat *psend;\n\tint col;\n\tint indent_col;\n\tchar s[80];\n\n\tps = jp->ps;\n\n\tif (mode & SHOW_ONLY_PGID) { /* jobs -p */\n\t\t/* just output process (group) id of pipeline */\n\t\tfprintf(out, \"%d\\n\", ps->ps_pid);\n\t\treturn;\n\t}\n\n\tcol = fmtstr(s, 16, \"[%d]   \", jobno(jp));\n\tindent_col = col;\n\n\tif (jp == curjob)\n\t\ts[col - 3] = '+';\n\telse if (curjob && jp == curjob->prev_job)\n\t\ts[col - 3] = '-';\n\n\tif (mode & SHOW_PIDS)\n\t\tcol += fmtstr(s + col, 16, \"%d \", ps->ps_pid);\n\n\tpsend = ps + jp->nprocs;\n\n\tif (jp->state == JOBRUNNING) {\n\t\tstrcpy(s + col, \"Running\");\n\t\tcol += sizeof(\"Running\") - 1;\n\t} else {\n\t\tint status = psend[-1].ps_status;\n\t\tif (jp->state == JOBSTOPPED)\n\t\t\tstatus = jp->stopstatus;\n\t\tcol += sprint_status(s + col, status, 0);\n\t}\n\t/* By now, \"[JOBID]*  [maybe PID] STATUS\" is printed */\n\n\t/* This loop either prints \"<cmd1> | <cmd2> | <cmd3>\" line\n\t * or prints several \"PID             | <cmdN>\" lines,\n\t * depending on SHOW_PIDS bit.\n\t * We do not print status of individual processes\n\t * between PID and <cmdN>. bash does it, but not very well:\n\t * first line shows overall job status, not process status,\n\t * making it impossible to know 1st process status.\n\t */\n\tgoto start;\n\tdo {\n\t\t/* for each process */\n\t\ts[0] = '\\0';\n\t\tcol = 33;\n\t\tif (mode & SHOW_PIDS)\n\t\t\tcol = fmtstr(s, 48, \"\\n%*c%d \", indent_col, ' ', ps->ps_pid) - 1;\n start:\n\t\tfprintf(out, \"%s%*c%s%s\",\n\t\t\t\ts,\n\t\t\t\t33 - col >= 0 ? 33 - col : 0, ' ',\n\t\t\t\tps == jp->ps ? \"\" : \"| \",\n\t\t\t\tps->ps_cmd\n\t\t);\n\t} while (++ps != psend);\n\toutcslow('\\n', out);\n\n\tjp->changed = 0;\n\n\tif (jp->state == JOBDONE) {\n\t\tTRACE((\"showjob: freeing job %d\\n\", jobno(jp)));\n\t\tfreejob(jp);\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_46F900(unsigned __int8 *a1)\n{\n  __int64 *v1; // rax\n  int v2; // eax\n  int v4; // [rsp+14h] [rbp-1Ch]\n  void *ptr; // [rsp+18h] [rbp-18h]\n  __int64 *v6; // [rsp+20h] [rbp-10h]\n  unsigned int v7; // [rsp+2Ch] [rbp-4h]\n\n  v1 = (__int64 *)sub_46F2C1(a1);\n  v6 = sub_46F3E8(v1, (char *)a1);\n  ptr = (void *)*v6;\n  v7 = 2;\n  if ( *v6 )\n  {\n    v4 = *((_DWORD *)ptr + 2);\n    v7 = 1;\n    if ( (v4 & 2) == 0 )\n    {\n      v2 = *((_DWORD *)ptr + 2);\n      BYTE1(v2) &= ~2u;\n      *((_DWORD *)ptr + 2) = v2;\n      if ( (v4 & 0x20) == 0 )\n      {\n        if ( (v4 & 4) != 0 )\n        {\n          sub_46F6BF((char *)a1, 0LL, 0);\n          *((_DWORD *)ptr + 2) &= ~1u;\n        }\n        else\n        {\n          ++*(_DWORD *)(qword_75D418 + 48);\n          if ( (v4 & 0x18) == 0 )\n            free(*((void **)ptr + 2));\n          *v6 = *(_QWORD *)ptr;\n          free(ptr);\n          sub_46E03F(ptr, a1);\n        }\n      }\n      return 0;\n    }\n  }\n  return v7;\n}\n\n\n Revised code:\nstatic int\nunsetvar(const char *s)\n{\n\tstruct var **vpp;\n\tstruct var *vp;\n\tint retval;\n\n\tvpp = findvar(hashvar(s), s);\n\tvp = *vpp;\n\tretval = 2;\n\tif (vp) {\n\t\tint flags = vp->flags;\n\n\t\tretval = 1;\n\t\tif (flags & VREADONLY)\n\t\t\tgoto out;\n#if ENABLE_ASH_RANDOM_SUPPORT\n\t\tvp->flags &= ~VDYNAMIC;\n#endif\n\t\tif (flags & VUNSET)\n\t\t\tgoto ok;\n\t\tif ((flags & VSTRFIXED) == 0) {\n\t\t\tINT_OFF;\n\t\t\tif ((flags & (VTEXTFIXED|VSTACK)) == 0)\n\t\t\t\tfree((char*)vp->var_text);\n\t\t\t*vpp = vp->next;\n\t\t\tfree(vp);\n\t\t\tINT_ON;\n\t\t} else {\n\t\t\tsetvar(s, 0, 0);\n\t\t\tvp->flags &= ~VEXPORT;\n\t\t}\n ok:\n\t\tretval = 0;\n\t}\n out:\n\treturn retval;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48EF6A(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v7; // eax\n  __int64 *v9; // [rsp+0h] [rbp-30h]\n  __int64 *v10; // [rsp+0h] [rbp-30h]\n  unsigned __int64 v11; // [rsp+10h] [rbp-20h] BYREF\n  int fd; // [rsp+1Ch] [rbp-14h]\n  const char *v13; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v14; // [rsp+28h] [rbp-8h]\n\n  v9 = (__int64 *)(a2 + 8);\n  if ( !*(_QWORD *)(a2 + 8) || !*(_QWORD *)(a2 + 16) )\n    sub_407F64();\n  v13 = sub_48EEFF(*v9);\n  v14 = v13[15];\n  if ( (v13[14] & 4) != 0 )\n  {\n    v9 = (__int64 *)(a2 + 16);\n    v14 = (int)sub_50B306(*(_QWORD *)(a2 + 16));\n  }\n  v10 = v9 + 1;\n  if ( !*v10 || v10[1] )\n    sub_407F64();\n  fd = sub_40A295((const char *)*v10, 0);\n  v11 = v14;\n  v2 = *(unsigned int *)v13;\n  if ( ioctl(fd, v2, &v11) == -1 )\n    sub_409392(*v10, v2, v3, v4, v5, v6);\n  v14 = v11;\n  if ( (v13[14] & 0x10) != 0 )\n    v14 >>= 9;\n  v7 = v13[14] & 0xB;\n  if ( v7 == 2 || v7 == 3 )\n  {\n    printf(\"%llu\\n\", v14);\n  }\n  else if ( v7 == 1 )\n  {\n    printf(\"%lld\\n\", (int)v14);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nint blockdev_main(int argc UNUSED_PARAM, char **argv)\n{\n\tconst struct bdc *bdcmd;\n\tint fd;\n\tuint64_t u64;\n\tunion {\n\t\tint i;\n\t\tunsigned long lu;\n\t\tuint64_t u64;\n\t} ioctl_val_on_stack;\n\n\targv++;\n\tif (!argv[0] || !argv[1]) /* must have at least 2 args */\n\t\tbb_show_usage();\n\n\tbdcmd = find_cmd(*argv);\n\n\tu64 = (int)bdcmd->argval;\n\tif (bdcmd->flags & FL_USRARG)\n\t\tu64 = xatoi_positive(*++argv);\n\n\targv++;\n\tif (!argv[0] || argv[1])\n\t\tbb_show_usage();\n\tfd = xopen(argv[0], O_RDONLY);\n\n\tioctl_val_on_stack.u64 = u64;\n#if BB_BIG_ENDIAN\n\t/* Store data properly wrt data size.\n\t * (1) It's no-op for little-endian.\n\t * (2) it's no-op for 0 and -1. Only --setro uses arg != 0 and != -1,\n\t * and it is ARG_INT. --setbsz USER_VAL is also ARG_INT.\n\t * Thus, we don't need to handle ARG_ULONG.\n\t */\n\tswitch (bdcmd->flags & ARG_MASK) {\n\tcase ARG_INT:\n\t\tioctl_val_on_stack.i = (int)u64;\n\t\tbreak;\n# if 0 /* unused */\n\tcase ARG_ULONG:\n\t\tioctl_val_on_stack.lu = (unsigned long)u64;\n\t\tbreak;\n# endif\n\t}\n#endif\n\n\tif (ioctl(fd, bdcmd->ioc, &ioctl_val_on_stack.u64) == -1)\n\t\tbb_simple_perror_msg_and_die(*argv);\n\n\t/* Fetch it into register(s) */\n\tu64 = ioctl_val_on_stack.u64;\n\n\tif (bdcmd->flags & FL_SCALE512)\n\t\tu64 >>= 9;\n\n\t/* Zero- or one-extend the value if needed, then print */\n\tswitch (bdcmd->flags & (ARG_MASK+FL_NORESULT)) {\n\tcase ARG_INT:\n\t\t/* Smaller code when we use long long\n\t\t * (gcc tail-merges printf call)\n\t\t */\n\t\tprintf(\"%lld\\n\", (long long)(int)u64);\n\t\tbreak;\n\tcase ARG_ULONG:\n\t\tu64 = (unsigned long)u64;\n\t\t/* FALLTHROUGH */\n\tcase ARG_U64:\n\t\tprintf(\"%llu\\n\", (unsigned long long)u64);\n\t\tbreak;\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tclose(fd);\n\treturn EXIT_SUCCESS;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_470BAC(int a1)\n{\n  int result; // eax\n  struct sigaction v2; // [rsp+10h] [rbp-B0h] BYREF\n  unsigned __int8 *v3; // [rsp+B0h] [rbp-10h]\n  unsigned __int8 v4; // [rsp+BEh] [rbp-2h]\n  unsigned __int8 v5; // [rsp+BFh] [rbp-1h]\n\n  v3 = *(unsigned __int8 **)(qword_75D418 + 8 * (a1 + 26LL));\n  v4 = 1;\n  if ( v3 )\n  {\n    v4 = 2;\n    if ( !*v3 )\n      v4 = 3;\n  }\n  if ( !*(_DWORD *)(qword_75D418 + 4) && v4 == 1 )\n  {\n    switch ( a1 )\n    {\n      case 2:\n        if ( *(_BYTE *)(qword_75D418 + 60) || *(_QWORD *)(qword_75D418 + 8) || !*(_BYTE *)(qword_75D418 + 63) )\n          v4 = 2;\n        break;\n      case 3:\n        v4 = 3;\n        break;\n      case 15:\n        if ( *(_BYTE *)(qword_75D418 + 60) )\n          v4 = 3;\n        break;\n      case 20:\n      case 22:\n        if ( *(_BYTE *)(qword_75D418 + 61) )\n          v4 = 3;\n        break;\n      default:\n        break;\n    }\n  }\n  v3 = (unsigned __int8 *)(a1 - 1 + 64LL + qword_75D418 + 8);\n  result = *v3;\n  v5 = *v3;\n  if ( !v5 )\n  {\n    result = sigaction(a1, 0LL, &v2);\n    if ( result )\n      return result;\n    result = (int)v2.sa_handler;\n    if ( v2.sa_handler == (__sighandler_t)1 )\n    {\n      v5 = 4;\n      result = *(unsigned __int8 *)(qword_75D418 + 61);\n      if ( (_BYTE)result )\n      {\n        if ( a1 == 20 || a1 == 21 || a1 == 22 )\n          v5 = 3;\n      }\n    }\n  }\n  if ( v5 != 4 )\n  {\n    result = v5;\n    if ( v5 != v4 )\n    {\n      v2.sa_handler = 0LL;\n      if ( v4 == 2 )\n      {\n        v2.sa_handler = (__sighandler_t)sub_470B36;\n      }\n      else if ( v4 == 3 )\n      {\n        v2.sa_handler = (__sighandler_t)1;\n      }\n      v2.sa_flags = 0;\n      sigfillset(&v2.sa_mask);\n      sub_5081A2((unsigned int)a1, &v2);\n      result = (int)v3;\n      *v3 = v4;\n    }\n  }\n  return result;\n}\n",
        "output": "static int checkSignal(int signal)\n{\n    int result;\n    struct sigaction sa;\n    unsigned char *status = *(unsigned char **)(qword_75D418 + 8 * (signal + 26LL));\n    unsigned char statusFlag = 1;\n\n    if (status) {\n        statusFlag = 2;\n        if (!*status)\n            statusFlag = 3;\n    }\n\n    if (!*(_DWORD *)(qword_75D418 + 4) && statusFlag == 1) {\n        switch (signal) {\n            case 2:\n                if (*(_BYTE *)(qword_75D418 + 60) || *(_QWORD *)(qword_75D418 + 8) || !*(_BYTE *)(qword_75D418 + 63))\n                    statusFlag = 2;\n                break;\n            case 3:\n                statusFlag = 3;\n                break;\n            case 15:\n                if (*(_BYTE *)(qword_75D418 + 60))\n                    statusFlag = 3;\n                break;\n            case 20:\n            case 22:\n                if (*(_BYTE *)(qword_75D418 + 61))\n                    statusFlag = 3;\n                break;\n            default:\n                break;\n        }\n    }\n\n    status = (unsigned char *)(signal - 1 + 64LL + qword_75D418 + 8);\n    result = *status;\n    unsigned char currentStatus = *status;\n    if (!currentStatus) {\n        result = sigaction(signal, 0LL, &sa);\n        if (result)\n            return result;\n        result = (int)sa.sa_handler;\n        if (sa.sa_handler == (__sighandler_t)1) {\n            currentStatus = 4;\n            result = *(unsigned char *)(qword_75D418 + 61);\n            if ((unsigned char)result) {\n                if (signal == 20 || signal == 21 || signal == 22)\n                    currentStatus = 3;\n            }\n        }\n    }\n\n    if (currentStatus != 4) {\n        result = currentStatus;\n        if (currentStatus != statusFlag) {\n            sa.sa_handler = 0LL;\n            if (statusFlag == 2) {\n                sa.sa_handler = (__sighandler_t)sub_470B36;\n            } else if (statusFlag == 3) {\n                sa.sa_handler = (__sighandler_t)1;\n            }\n            sa.sa_flags = 0;\n            sigfillset(&sa.sa_mask);\n            sub_5081A2((unsigned int)signal, &sa);\n            result = (int)status;\n            *status = statusFlag;\n        }\n    }\n\n    return result;\n}",
        "source_code": "static void\nsetsignal(int signo)\n{\n\tchar *t;\n\tchar cur_act, new_act;\n\tstruct sigaction act;\n\n\tt = trap[signo];\n\tnew_act = S_DFL;\n\tif (t != NULL) { /* trap for this sig is set */\n\t\tnew_act = S_CATCH;\n\t\tif (t[0] == '\\0') /* trap is \"\": ignore this sig */\n\t\t\tnew_act = S_IGN;\n\t}\n\n\tif (rootshell && new_act == S_DFL) {\n\t\tswitch (signo) {\n\t\tcase SIGINT:\n\t\t\tif (iflag || minusc || sflag == 0)\n\t\t\t\tnew_act = S_CATCH;\n\t\t\tbreak;\n\t\tcase SIGQUIT:\n#if DEBUG\n\t\t\tif (debug)\n\t\t\t\tbreak;\n#endif\n\t\t\t/* man bash:\n\t\t\t * \"In all cases, bash ignores SIGQUIT. Non-builtin\n\t\t\t * commands run by bash have signal handlers\n\t\t\t * set to the values inherited by the shell\n\t\t\t * from its parent\". */\n\t\t\tnew_act = S_IGN;\n\t\t\tbreak;\n\t\tcase SIGTERM:\n\t\t\tif (iflag)\n\t\t\t\tnew_act = S_IGN;\n\t\t\tbreak;\n#if JOBS\n\t\tcase SIGTSTP:\n\t\tcase SIGTTOU:\n\t\t\tif (mflag)\n\t\t\t\tnew_act = S_IGN;\n\t\t\tbreak;\n#endif\n\t\t}\n\t}\n//TODO: if !rootshell, we reset SIGQUIT to DFL,\n//whereas we have to restore it to what shell got on entry\n//from the parent. See comment above\n\n\tt = &sigmode[signo - 1];\n\tcur_act = *t;\n\tif (cur_act == 0) {\n\t\t/* current setting is not yet known */\n\t\tif (sigaction(signo, NULL, &act)) {\n\t\t\t/* pretend it worked; maybe we should give a warning,\n\t\t\t * but other shells don't. We don't alter sigmode,\n\t\t\t * so we retry every time.\n\t\t\t * btw, in Linux it never fails. --vda */\n\t\t\treturn;\n\t\t}\n\t\tif (act.sa_handler == SIG_IGN) {\n\t\t\tcur_act = S_HARD_IGN;\n\t\t\tif (mflag\n\t\t\t && (signo == SIGTSTP || signo == SIGTTIN || signo == SIGTTOU)\n\t\t\t) {\n\t\t\t\tcur_act = S_IGN;   /* don't hard ignore these */\n\t\t\t}\n\t\t}\n\t}\n\tif (cur_act == S_HARD_IGN || cur_act == new_act)\n\t\treturn;\n\n\tact.sa_handler = SIG_DFL;\n\tswitch (new_act) {\n\tcase S_CATCH:\n\t\tact.sa_handler = signal_handler;\n\t\tbreak;\n\tcase S_IGN:\n\t\tact.sa_handler = SIG_IGN;\n\t\tbreak;\n\t}\n\n\t/* flags and mask matter only if !DFL and !IGN, but we do it\n\t * for all cases for more deterministic behavior:\n\t */\n\tact.sa_flags = 0;\n\tsigfillset(&act.sa_mask);\n\n\tsigaction_set(signo, &act);\n\n\t*t = new_act;\n}",
        "parsed_output": "static int checkSignal(int signal)\n{\n    int result;\n    struct sigaction sa;\n    unsigned char *status = *(unsigned char **)(qword_75D418 + 8 * (signal + 26LL));\n    unsigned char statusFlag = 1;\n\n    if (status) {\n        statusFlag = 2;\n        if (!*status)\n            statusFlag = 3;\n    }\n\n    if (!*(_DWORD *)(qword_75D418 + 4) && statusFlag == 1) {\n        switch (signal) {\n            case 2:\n                if (*(_BYTE *)(qword_75D418 + 60) || *(_QWORD *)(qword_75D418 + 8) || !*(_BYTE *)(qword_75D418 + 63))\n                    statusFlag = 2;\n                break;\n            case 3:\n                statusFlag = 3;\n                break;\n            case 15:\n                if (*(_BYTE *)(qword_75D418 + 60))\n                    statusFlag = 3;\n                break;\n            case 20:\n            case 22:\n                if (*(_BYTE *)(qword_75D418 + 61))\n                    statusFlag = 3;\n                break;\n            default:\n                break;\n        }\n    }\n\n    status = (unsigned char *)(signal - 1 + 64LL + qword_75D418 + 8);\n    result = *status;\n    unsigned char currentStatus = *status;\n    if (!currentStatus) {\n        result = sigaction(signal, 0LL, &sa);\n        if (result)\n            return result;\n        result = (int)sa.sa_handler;\n        if (sa.sa_handler == (__sighandler_t)1) {\n            currentStatus = 4;\n            result = *(unsigned char *)(qword_75D418 + 61);\n            if ((unsigned char)result) {\n                if (signal == 20 || signal == 21 || signal == 22)\n                    currentStatus = 3;\n            }\n        }\n    }\n\n    if (currentStatus != 4) {\n        result = currentStatus;\n        if (currentStatus != statusFlag) {\n            sa.sa_handler = 0LL;\n            if (statusFlag == 2) {\n                sa.sa_handler = (__sighandler_t)sub_470B36;\n            } else if (statusFlag == 3) {\n                sa.sa_handler = (__sighandler_t)1;\n            }\n            sa.sa_flags = 0;\n            sigfillset(&sa.sa_mask);\n            sub_5081A2((unsigned int)signal, &sa);\n            result = (int)status;\n            *status = statusFlag;\n        }\n    }\n\n    return result;\n}",
        "baseline_code_stripped": "int __fastcall sub_470BAC(int a1)\n{\n  int result; // eax\n  struct sigaction v2; // [rsp+10h] [rbp-B0h] BYREF\n  unsigned __int8 *v3; // [rsp+B0h] [rbp-10h]\n  unsigned __int8 v4; // [rsp+BEh] [rbp-2h]\n  unsigned __int8 v5; // [rsp+BFh] [rbp-1h]\n\n  v3 = *(unsigned __int8 **)(qword_75D418 + 8 * (a1 + 26LL));\n  v4 = 1;\n  if ( v3 )\n  {\n    v4 = 2;\n    if ( !*v3 )\n      v4 = 3;\n  }\n  if ( !*(_DWORD *)(qword_75D418 + 4) && v4 == 1 )\n  {\n    switch ( a1 )\n    {\n      case 2:\n        if ( *(_BYTE *)(qword_75D418 + 60) || *(_QWORD *)(qword_75D418 + 8) || !*(_BYTE *)(qword_75D418 + 63) )\n          v4 = 2;\n        break;\n      case 3:\n        v4 = 3;\n        break;\n      case 15:\n        if ( *(_BYTE *)(qword_75D418 + 60) )\n          v4 = 3;\n        break;\n      case 20:\n      case 22:\n        if ( *(_BYTE *)(qword_75D418 + 61) )\n          v4 = 3;\n        break;\n      default:\n        break;\n    }\n  }\n  v3 = (unsigned __int8 *)(a1 - 1 + 64LL + qword_75D418 + 8);\n  result = *v3;\n  v5 = *v3;\n  if ( !v5 )\n  {\n    result = sigaction(a1, 0LL, &v2);\n    if ( result )\n      return result;\n    result = (int)v2.sa_handler;\n    if ( v2.sa_handler == (__sighandler_t)1 )\n    {\n      v5 = 4;\n      result = *(unsigned __int8 *)(qword_75D418 + 61);\n      if ( (_BYTE)result )\n      {\n        if ( a1 == 20 || a1 == 21 || a1 == 22 )\n          v5 = 3;\n      }\n    }\n  }\n  if ( v5 != 4 )\n  {\n    result = v5;\n    if ( v5 != v4 )\n    {\n      v2.sa_handler = 0LL;\n      if ( v4 == 2 )\n      {\n        v2.sa_handler = (__sighandler_t)sub_470B36;\n      }\n      else if ( v4 == 3 )\n      {\n        v2.sa_handler = (__sighandler_t)1;\n      }\n      v2.sa_flags = 0;\n      sigfillset(&v2.sa_mask);\n      sub_5081A2((unsigned int)a1, &v2);\n      result = (int)v3;\n      *v3 = v4;\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl setsignal(int signo)\n{\n  sigaction act; // [rsp+10h] [rbp-B0h] BYREF\n  char *t; // [rsp+B0h] [rbp-10h]\n  char new_act; // [rsp+BEh] [rbp-2h]\n  char cur_act; // [rsp+BFh] [rbp-1h]\n\n  t = ash_ptr_to_globals_misc->trap[signo];\n  new_act = 1;\n  if ( t )\n  {\n    new_act = 2;\n    if ( !*t )\n      new_act = 3;\n  }\n  if ( !ash_ptr_to_globals_misc->shlvl && new_act == 1 )\n  {\n    switch ( signo )\n    {\n      case 2:\n        if ( ash_ptr_to_globals_misc->optlist[3]\n          || ash_ptr_to_globals_misc->minusc\n          || !ash_ptr_to_globals_misc->optlist[6] )\n        {\n          new_act = 2;\n        }\n        break;\n      case 3:\n        new_act = 3;\n        break;\n      case 15:\n        if ( ash_ptr_to_globals_misc->optlist[3] )\n          new_act = 3;\n        break;\n      case 20:\n      case 22:\n        if ( ash_ptr_to_globals_misc->optlist[4] )\n          new_act = 3;\n        break;\n      default:\n        break;\n    }\n  }\n  t = &ash_ptr_to_globals_misc->optlist[signo + 14];\n  cur_act = *t;\n  if ( !cur_act )\n  {\n    if ( sigaction(signo, 0LL, &act) )\n      return;\n    if ( act.sa_handler == (__sighandler_t)1 )\n    {\n      cur_act = 4;\n      if ( ash_ptr_to_globals_misc->optlist[4] )\n      {\n        if ( signo == 20 || signo == 21 || signo == 22 )\n          cur_act = 3;\n      }\n    }\n  }\n  if ( cur_act != 4 && cur_act != new_act )\n  {\n    act.sa_handler = 0LL;\n    if ( new_act == 2 )\n    {\n      act.sa_handler = (__sighandler_t)signal_handler_2;\n    }\n    else if ( new_act == 3 )\n    {\n      act.sa_handler = (__sighandler_t)1;\n    }\n    act.sa_flags = 0;\n    sigfillset(&act.sa_mask);\n    sigaction_set(signo, &act);\n    *t = new_act;\n  }\n}\n",
        "similarity_score_unixcoder": 0.7479771375656128,
        "similarity_score_baseline_stripped": 0.6435101628303528,
        "similarity_score_baseline_debug": 0.8308956027030945
    },
    {
        "func_name": "hashcd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 sub_413733()\n{\n  __int64 result; // rax\n  int v1; // [rsp+10h] [rbp-20h]\n  int v2; // [rsp+14h] [rbp-1Ch]\n  unsigned __int8 *v3; // [rsp+18h] [rbp-18h]\n  int j; // [rsp+24h] [rbp-Ch]\n  unsigned int i; // [rsp+28h] [rbp-8h]\n  int v6; // [rsp+2Ch] [rbp-4h]\n\n  v1 = *((unsigned __int8 *)qword_75D408 + 82) - *((_DWORD *)qword_75D408 + 4);\n  v3 = (unsigned __int8 *)(*(_QWORD *)qword_75D408 + *((int *)qword_75D408 + 10) + (__int64)*((int *)qword_75D408 + 11));\n  v6 = 0;\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i >= v1 )\n      break;\n    result = i;\n    if ( *((_DWORD *)qword_75D408 + 14) <= i )\n      break;\n    v2 = 0;\n    for ( j = 0; j < *((unsigned __int8 *)qword_75D408 + 83); ++j )\n    {\n      if ( (unsigned int)(j - *((_DWORD *)qword_75D408 + 3)) < *((_DWORD *)qword_75D408 + 13) )\n      {\n        ++v2;\n        if ( (dword_75D450 & 0x10) == 0 || *v3 != 32 )\n        {\n          while ( v6 )\n          {\n            sub_40A659(10);\n            --v6;\n          }\n          while ( --v2 )\n            sub_40A659(32);\n          sub_413510(v3);\n        }\n      }\n      v3 += 2;\n    }\n    ++v6;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void screen_dump(void)\n{\n\tint linefeed_cnt;\n\tint line, col;\n\tint linecnt = G.remote.lines - G.y;\n\tchar *data = G.data + G.current + G.first_line_offset;\n\n\tlinefeed_cnt = 0;\n\tfor (line = 0; line < linecnt && line < G.height; line++) {\n\t\tint space_cnt = 0;\n\t\tfor (col = 0; col < G.remote.cols; col++, NEXT(data)) {\n\t\t\tunsigned tty_col = col - G.x; // if will catch col < G.x too\n\n\t\t\tif (tty_col >= G.width)\n\t\t\t\tcontinue;\n\t\t\tspace_cnt++;\n\t\t\tif (BW && CHAR(data) == ' ')\n\t\t\t\tcontinue;\n\t\t\twhile (linefeed_cnt != 0) {\n\t\t\t\t//bb_putchar('\\r'); - tty driver does it for us\n\t\t\t\tbb_putchar('\\n');\n\t\t\t\tlinefeed_cnt--;\n\t\t\t}\n\t\t\twhile (--space_cnt)\n\t\t\t\tbb_putchar(' ');\n\t\t\tscreen_char(data);\n\t\t}\n\t\tlinefeed_cnt++;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_44199F(int a1)\n{\n  __int64 result; // rax\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; ; ++i )\n  {\n    result = (unsigned int)dword_75B1B0;\n    if ( i >= dword_75B1B0 )\n      break;\n    if ( a1 == *(_DWORD *)(16LL * i + qword_75B1A8 + 8) )\n    {\n      free(*(void **)(16LL * i + qword_75B1A8));\n      *(_QWORD *)(16LL * i + qword_75B1A8) = 0LL;\n      result = 16LL * i + qword_75B1A8;\n      *(_DWORD *)(result + 8) = 0;\n      return result;\n    }\n  }\n  return result;\n}\n\n\n Revised code:\nvoid ipsvd_perhost_remove(int pid)\n{\n\tunsigned i;\n\tfor (i = 0; i < cclen; ++i) {\n\t\tif (cc[i].pid == pid) {\n\t\t\tfree(cc[i].ip);\n\t\t\tcc[i].ip = NULL;\n\t\t\tcc[i].pid = 0;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 sub_4DAA06()\n{\n  __int64 result; // rax\n  __int64 i; // [rsp+8h] [rbp-8h]\n\n  result = (unsigned __int8)byte_75D468;\n  if ( byte_75D468 )\n  {\n    result = (unsigned __int8)byte_75B2A8;\n    if ( !byte_75B2A8 )\n    {\n      result = qword_75B2A0;\n      for ( i = qword_75B2A0; i; i = *(_QWORD *)i )\n      {\n        if ( (*(_DWORD *)(i + 12) & 1) == 0 )\n          kill(*(_DWORD *)(i + 8), 15);\n        result = *(_QWORD *)i;\n      }\n      byte_75B2A8 = 1;\n    }\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void kill_all_if_got_signal(void)\n{\n\tstatic smallint kill_sent;\n\n\tstruct fsck_instance *inst;\n\n\tif (!bb_got_signal || kill_sent)\n\t\treturn;\n\n\tfor (inst = instance_list; inst; inst = inst->next) {\n\t\tif (inst->flags & FLAG_DONE)\n\t\t\tcontinue;\n\t\tkill(inst->pid, SIGTERM);\n\t}\n\tkill_sent = 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_477313()\n{\n  __int64 result; // rax\n  __int64 *j; // [rsp+0h] [rbp-10h]\n  __int64 **i; // [rsp+8h] [rbp-8h]\n\n  for ( i = (__int64 **)qword_75B018; ; ++i )\n  {\n    result = qword_75B018 + 248;\n    if ( (unsigned __int64)i >= qword_75B018 + 248 )\n      break;\n    for ( j = *i; j; j = (__int64 *)*j )\n    {\n      if ( !*((_BYTE *)j + 16) || *((_BYTE *)j + 16) == 2 && (**(_BYTE **)j[1] & 2) == 0 && dword_75AE34 > 0 )\n        *((_BYTE *)j + 17) = 1;\n    }\n  }\n  return result;\n}\n",
        "output": "static void update_flags()\n{\n    __int64 **i;\n    __int64 *j;\n\n    for (i = (__int64 **)qword_75B018; (unsigned __int64)i < qword_75B018 + 248; ++i)\n    {\n        for (j = *i; j; j = (__int64 *)*j)\n        {\n            if (!*((_BYTE *)j + 16) || (*((_BYTE *)j + 16) == 2 && (**(_BYTE **)j[1] & 2) == 0 && dword_75AE34 > 0))\n            {\n                *((_BYTE *)j + 17) = 1;\n            }\n        }\n    }\n}",
        "source_code": "static void\nhashcd(void)\n{\n\tstruct tblentry **pp;\n\tstruct tblentry *cmdp;\n\n\tfor (pp = cmdtable; pp < &cmdtable[CMDTABLESIZE]; pp++) {\n\t\tfor (cmdp = *pp; cmdp; cmdp = cmdp->next) {\n\t\t\tif (cmdp->cmdtype == CMDNORMAL\n\t\t\t || (cmdp->cmdtype == CMDBUILTIN\n\t\t\t     && !IS_BUILTIN_REGULAR(cmdp->param.cmd)\n\t\t\t     && builtinloc > 0)\n\t\t\t) {\n\t\t\t\tcmdp->rehash = 1;\n\t\t\t}\n\t\t}\n\t}\n}",
        "parsed_output": "static void update_flags()\n{\n    __int64 **i;\n    __int64 *j;\n\n    for (i = (__int64 **)qword_75B018; (unsigned __int64)i < qword_75B018 + 248; ++i)\n    {\n        for (j = *i; j; j = (__int64 *)*j)\n        {\n            if (!*((_BYTE *)j + 16) || (*((_BYTE *)j + 16) == 2 && (**(_BYTE **)j[1] & 2) == 0 && dword_75AE34 > 0))\n            {\n                *((_BYTE *)j + 17) = 1;\n            }\n        }\n    }\n}",
        "baseline_code_stripped": "__int64 sub_477313()\n{\n  __int64 result; // rax\n  __int64 *j; // [rsp+0h] [rbp-10h]\n  __int64 **i; // [rsp+8h] [rbp-8h]\n\n  for ( i = (__int64 **)qword_75B018; ; ++i )\n  {\n    result = qword_75B018 + 248;\n    if ( (unsigned __int64)i >= qword_75B018 + 248 )\n      break;\n    for ( j = *i; j; j = (__int64 *)*j )\n    {\n      if ( !*((_BYTE *)j + 16) || *((_BYTE *)j + 16) == 2 && (**(_BYTE **)j[1] & 2) == 0 && dword_75AE34 > 0 )\n        *((_BYTE *)j + 17) = 1;\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl hashcd()\n{\n  tblentry *cmdp; // [rsp+0h] [rbp-10h]\n  tblentry **pp; // [rsp+8h] [rbp-8h]\n\n  for ( pp = cmdtable; pp < cmdtable + 31; ++pp )\n  {\n    for ( cmdp = *pp; cmdp; cmdp = cmdp->next )\n    {\n      if ( !cmdp->cmdtype || cmdp->cmdtype == 2 && (*cmdp->param.cmd->name & 2) == 0 && builtinloc > 0 )\n        cmdp->rehash = 1;\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.4979498088359833,
        "similarity_score_baseline_stripped": 0.44606465101242065,
        "similarity_score_baseline_debug": 0.8715247511863708
    }
]
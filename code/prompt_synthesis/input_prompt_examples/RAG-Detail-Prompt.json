[
    {
        "func_name": "flash",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4F5F81(__int64 a1)\n{\n  return sub_4F5FA5(0LL, 0LL, a1);\n}\n\n\n Revised code:\nFAST_FUNC bb_ask_stdin(const char *prompt)\n{\n\treturn bb_ask(STDIN_FILENO, 0, prompt);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A88F7(__int64 a1)\n{\n  return sub_4B85D0(a1, 0LL, 1LL);\n}\n\n\n Revised code:\nint FAST_FUNC unpack_bunzip2(transformer_aux_data_t *aux)\n{\n\treturn unpack_bz2_stream(aux, STDIN_FILENO, STDOUT_FILENO);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A898E(__int64 a1)\n{\n  return sub_4BB637(a1, 0LL, 1LL);\n}\n\n\n Revised code:\nint FAST_FUNC unpack_unlzma(transformer_aux_data_t *aux)\n{\n\treturn unpack_lzma_stream(aux, STDIN_FILENO, STDOUT_FILENO);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4EFC8F(int a1)\n{\n  sub_4EFC6D();\n  sub_4F03A4(1LL);\n  sub_4EF515(a1);\n  sub_4EFC7E();\n  return sub_4F03A4(1LL);\n}\n"
    },
    {
        "func_name": "collect_info",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_DWORD *__fastcall sub_461F0C(const char *a1, int a2)\n{\n  _DWORD *result; // rax\n  _QWORD *v3; // rbx\n  char **v4; // rbx\n  int i; // [rsp+1Ch] [rbp-14h]\n\n  for ( i = 0; i < *((_DWORD *)qword_75D408 + 2); ++i )\n  {\n    if ( !strcmp(a1, *(const char **)(16LL * i + *(_QWORD *)qword_75D408)) )\n    {\n      result = (_DWORD *)(16LL * i + *(_QWORD *)qword_75D408);\n      result[2] += a2;\n      return result;\n    }\n  }\n  v3 = qword_75D408;\n  *v3 = sub_50C0E1(*(_QWORD *)qword_75D408, 4100LL, *((unsigned int *)qword_75D408 + 2));\n  v4 = (char **)(*(_QWORD *)qword_75D408 + 16LL * *((int *)qword_75D408 + 2));\n  *v4 = sub_40A11F(a1, 4100LL);\n  *(_DWORD *)(16LL * *((int *)qword_75D408 + 2) + *(_QWORD *)qword_75D408 + 8) = a2;\n  result = qword_75D408;\n  ++*((_DWORD *)qword_75D408 + 2);\n  return result;\n}\n\n\n Revised code:\nstatic void save_line(const char *string, int count)\n{\n\tint i;\n\tfor (i = 0; i < G.lines_cnt; i++) {\n\t\tif (strcmp(string, G.lines[i].string) == 0) {\n\t\t\t/* It's already there, only update count */\n\t\t\tG.lines[i].count += count;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Add new line */\n\tG.lines = xrealloc_vector(G.lines, 4, G.lines_cnt);\n\tG.lines[G.lines_cnt].string = xstrdup(string);\n\tG.lines[G.lines_cnt].count = count;\n\t/*G.lines[G.lines_cnt].disk_count = 0;*/\n\tG.lines_cnt++;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_46E905(_QWORD *a1, __int64 a2)\n{\n  __int64 result; // rax\n  _QWORD *v3; // [rsp+8h] [rbp-18h]\n  _QWORD *ptr; // [rsp+18h] [rbp-8h]\n\n  v3 = a1;\n  result = *a1;\n  if ( *a1 )\n  {\n    ++*(_DWORD *)(qword_75D418 + 48);\n    *(_QWORD *)(qword_75D428 + 8) = a1[3];\n    while ( *(_QWORD *)qword_75D428 != *v3 )\n    {\n      ptr = *(_QWORD **)qword_75D428;\n      *(_QWORD *)qword_75D428 = **(_QWORD **)qword_75D428;\n      a1 = ptr;\n      free(ptr);\n    }\n    *(_QWORD *)(qword_75D428 + 16) = v3[1];\n    *(_QWORD *)(qword_75D428 + 32) = v3[2];\n    *(_QWORD *)(qword_75D428 + 24) = v3[1] + v3[2];\n    return sub_46E03F(a1, a2);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\npopstackmark(struct stackmark *mark)\n{\n\tstruct stack_block *sp;\n\n\tif (!mark->stackp)\n\t\treturn;\n\n\tINT_OFF;\n\tmarkp = mark->marknext;\n\twhile (g_stackp != mark->stackp) {\n\t\tsp = g_stackp;\n\t\tg_stackp = sp->prev;\n\t\tfree(sp);\n\t}\n\tg_stacknxt = mark->stacknxt;\n\tg_stacknleft = mark->stacknleft;\n\tsstrend = mark->stacknxt + mark->stacknleft;\n\tINT_ON;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_49077B(__int64 a1)\n{\n  while ( !(unsigned int)sub_490609(a1) )\n    ;\n  return **(unsigned __int8 **)qword_75D408;\n}\n\n\n Revised code:\nstatic char\nread_nonempty(const char *mesg)\n{\n\twhile (!read_line(mesg))\n\t\tcontinue;\n\treturn *line_ptr;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_460DE5(char *a1)\n{\n  const char *result; // rax\n\n  result = (const char *)qword_75D408;\n  *(_BYTE *)qword_75D408 ^= 1u;\n  while ( a1 )\n  {\n    sub_45F69B(*((const char **)a1 + 2));\n    (*((void (__fastcall **)(char *))a1 + 1))(a1);\n    result = *(const char **)a1;\n    a1 = *(char **)a1;\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "crc32_block_endian0",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4F74CA(unsigned int a1, unsigned __int8 *a2, int a3, __int64 a4)\n{\n  unsigned __int8 *i; // [rsp+8h] [rbp-20h]\n\n  for ( i = a2; i != &a2[a3]; ++i )\n    a1 = (a1 << 8) ^ *(_DWORD *)(4LL * (HIBYTE(a1) ^ *i) + a4);\n  return a1;\n}\n\n\n Revised code:\nuint32_t FAST_FUNC crc32_block_endian1(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table)\n{\n\tconst void *end = (uint8_t*)buf + len;\n\n\twhile (buf != end) {\n\t\tval = (val << 8) ^ crc_table[(val >> 24) ^ *(uint8_t*)buf];\n\t\tbuf = (uint8_t*)buf + 1;\n\t}\n\treturn val;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4FCBB9(__int64 a1, _BYTE *a2, unsigned __int64 a3)\n{\n  _BYTE *v3; // rax\n  __int64 result; // rax\n  unsigned int v6; // [rsp+28h] [rbp-10h]\n  unsigned int v7; // [rsp+2Ch] [rbp-Ch]\n\n  v7 = *(_DWORD *)(a1 + 200);\n  while ( 1 )\n  {\n    v6 = 72 - v7;\n    if ( a3 < 72 - v7 )\n      v6 = a3;\n    a3 -= v6;\n    while ( v6 )\n    {\n      v3 = a2++;\n      *(_BYTE *)(v7++ + a1) ^= *v3;\n      --v6;\n    }\n    v7 -= 72;\n    if ( v7 )\n      break;\n    sub_4FC67E((_QWORD *)a1);\n  }\n  result = a1;\n  *(_DWORD *)(a1 + 200) = v7 + 72;\n  return result;\n}\n\n\n Revised code:\nvoid FAST_FUNC sha3_hash(sha3_ctx_t *ctx, const void *buffer, size_t len)\n{\n#if SHA3_SMALL\n\tconst uint8_t *data = buffer;\n\tunsigned bufpos = ctx->bytes_queued;\n\n\twhile (1) {\n\t\tunsigned remaining = SHA3_IBLK_BYTES - bufpos;\n\t\tif (remaining > len)\n\t\t\tremaining = len;\n\t\tlen -= remaining;\n\t\t/* XOR data into buffer */\n\t\twhile (remaining != 0) {\n\t\t\tuint8_t *buf = (uint8_t*)ctx->state;\n\t\t\tbuf[bufpos] ^= *data++;\n\t\t\tbufpos++;\n\t\t\tremaining--;\n\t\t}\n\t\t/* Clever way to do \"if (bufpos != N) break; ... ; bufpos = 0;\" */\n\t\tbufpos -= SHA3_IBLK_BYTES;\n\t\tif (bufpos != 0)\n\t\t\tbreak;\n\t\t/* Buffer is filled up, process it */\n\t\tsha3_process_block72(ctx->state);\n\t\t/*bufpos = 0; - already is */\n\t}\n\tctx->bytes_queued = bufpos + SHA3_IBLK_BYTES;\n#else\n\t/* +50 bytes code size, but a bit faster because of long-sized XORs */\n\tconst uint8_t *data = buffer;\n\tunsigned bufpos = ctx->bytes_queued;\n\n\t/* If already data in queue, continue queuing first */\n\twhile (len != 0 && bufpos != 0) {\n\t\tuint8_t *buf = (uint8_t*)ctx->state;\n\t\tbuf[bufpos] ^= *data++;\n\t\tlen--;\n\t\tbufpos++;\n\t\tif (bufpos == SHA3_IBLK_BYTES) {\n\t\t\tbufpos = 0;\n\t\t\tgoto do_block;\n\t\t}\n\t}\n\n\t/* Absorb complete blocks */\n\twhile (len >= SHA3_IBLK_BYTES) {\n\t\t/* XOR data onto beginning of state[].\n\t\t * We try to be efficient - operate one word at a time, not byte.\n\t\t * Careful wrt unaligned access: can't just use \"*(long*)data\"!\n\t\t */\n\t\tunsigned count = SHA3_IBLK_BYTES / sizeof(long);\n\t\tlong *buf = (long*)ctx->state;\n\t\tdo {\n\t\t\tlong v;\n\t\t\tmove_from_unaligned_long(v, (long*)data);\n\t\t\t*buf++ ^= v;\n\t\t\tdata += sizeof(long);\n\t\t} while (--count);\n\t\tlen -= SHA3_IBLK_BYTES;\n do_block:\n\t\tsha3_process_block72(ctx->state);\n\t}\n\n\t/* Queue remaining data bytes */\n\twhile (len != 0) {\n\t\tuint8_t *buf = (uint8_t*)ctx->state;\n\t\tbuf[bufpos] ^= *data++;\n\t\tbufpos++;\n\t\tlen--;\n\t}\n\n\tctx->bytes_queued = bufpos;\n#endif\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_459B24(__int64 a1)\n{\n  unsigned int i; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; *(_BYTE *)((int)i + a1) != 0xFF; ++i )\n  {\n    if ( *(_BYTE *)((int)i + a1) )\n      i += *(unsigned __int8 *)((int)i + 1LL + a1) + 1;\n  }\n  return i;\n}\n\n\n Revised code:\nint FAST_FUNC udhcp_end_option(uint8_t *optionptr)\n{\n\tint i = 0;\n\n\twhile (optionptr[i] != DHCP_END) {\n\t\tif (optionptr[i] != DHCP_PADDING)\n\t\t\ti += optionptr[i + OPT_LEN] + OPT_DATA-1;\n\t\ti++;\n\t}\n\treturn i;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4F7534(unsigned int a1, _BYTE *a2, int a3, __int64 a4)\n{\n  _BYTE *i; // [rsp+8h] [rbp-20h]\n\n  for ( i = a2; i != &a2[a3]; ++i )\n    a1 = (a1 >> 8) ^ *(_DWORD *)(4LL * (unsigned __int8)(a1 ^ *i) + a4);\n  return a1;\n}\n"
    },
    {
        "func_name": "chain_node",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4DDFDB(__int64 a1, __int64 a2)\n{\n  char *v2; // rbx\n  char *v3; // rbx\n  __int64 v4; // rax\n  __int64 v6; // [rsp+18h] [rbp-28h]\n  __int64 v7; // [rsp+20h] [rbp-20h]\n  __int64 v8; // [rsp+28h] [rbp-18h]\n\n  v8 = *((_QWORD *)qword_75D408 - 15);\n  v7 = *((_QWORD *)qword_75D408 - 14);\n  v6 = sub_4DDE4A(67328, a2);\n  v2 = (char *)qword_75D408 - 208;\n  *((_QWORD *)v2 + 12) = sub_4DD854(512, a2);\n  v3 = (char *)qword_75D408 - 208;\n  *((_QWORD *)v3 + 11) = sub_4DD854(512, a2);\n  sub_4DE10D();\n  v4 = sub_4DDE4A(66048, a2);\n  *(_QWORD *)(v4 + 8) = a1;\n  *(_QWORD *)(v4 + 24) = v6;\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 14) + 24LL) = v4;\n  *(_QWORD *)(v6 + 16) = *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 8LL);\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 15) + 24LL) = *(_QWORD *)(v6 + 16);\n  *((_QWORD *)qword_75D408 - 14) = v7;\n  *((_QWORD *)qword_75D408 - 15) = v8;\n  return v6;\n}\n\n\n Revised code:\nstatic node *chain_loop(node *nn)\n{\n\tnode *n, *n2, *save_brk, *save_cont;\n\n\tsave_brk = break_ptr;\n\tsave_cont = continue_ptr;\n\n\tn = chain_node(OC_BR | Vx);\n\tcontinue_ptr = new_node(OC_EXEC);\n\tbreak_ptr = new_node(OC_EXEC);\n\tchain_group();\n\tn2 = chain_node(OC_EXEC | Vx);\n\tn2->l.n = nn;\n\tn2->a.n = n;\n\tcontinue_ptr->a.n = n2;\n\tbreak_ptr->a.n = n->r.n = seq->last;\n\n\tcontinue_ptr = save_cont;\n\tbreak_ptr = save_brk;\n\n\treturn n;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_46E6A8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v7; // [rsp+18h] [rbp-28h]\n  _QWORD *v8; // [rsp+20h] [rbp-20h]\n  size_t v9; // [rsp+28h] [rbp-18h]\n  unsigned __int64 v10; // [rsp+30h] [rbp-10h]\n  unsigned __int64 v11; // [rsp+38h] [rbp-8h]\n\n  v10 = (a1 + 7) & 0xFFFFFFFFFFFFFFF8LL;\n  if ( v10 > *(_QWORD *)(qword_75D428 + 32) )\n  {\n    v11 = (a1 + 7) & 0xFFFFFFFFFFFFFFF8LL;\n    if ( v10 <= 0x1F7 )\n      v11 = 504LL;\n    v9 = v11 + 8;\n    if ( v11 + 8 < v11 )\n      sub_46E473(\"out of memory\", a2, a3, a4, a5, a6);\n    ++*(_DWORD *)(qword_75D418 + 48);\n    v8 = sub_40A05F(v9, a2);\n    *v8 = *(_QWORD *)qword_75D428;\n    *(_QWORD *)(qword_75D428 + 16) = v8 + 1;\n    *(_QWORD *)(qword_75D428 + 32) = v11;\n    *(_QWORD *)(qword_75D428 + 24) = *(_QWORD *)(qword_75D428 + 16) + v11;\n    *(_QWORD *)qword_75D428 = v8;\n    sub_46E03F(v9, a2);\n  }\n  v7 = *(_QWORD *)(qword_75D428 + 16);\n  *(_QWORD *)(qword_75D428 + 16) = v7 + v10;\n  *(_QWORD *)(qword_75D428 + 32) -= v10;\n  return v7;\n}\n\n\n Revised code:\nstatic void *\nstalloc(size_t nbytes)\n{\n\tchar *p;\n\tsize_t aligned;\n\n\taligned = SHELL_ALIGN(nbytes);\n\tif (aligned > g_stacknleft) {\n\t\tsize_t len;\n\t\tsize_t blocksize;\n\t\tstruct stack_block *sp;\n\n\t\tblocksize = aligned;\n\t\tif (blocksize < MINSIZE)\n\t\t\tblocksize = MINSIZE;\n\t\tlen = sizeof(struct stack_block) - MINSIZE + blocksize;\n\t\tif (len < blocksize)\n\t\t\tash_msg_and_raise_error(bb_msg_memory_exhausted);\n\t\tINT_OFF;\n\t\tsp = ckmalloc(len);\n\t\tsp->prev = g_stackp;\n\t\tg_stacknxt = sp->space;\n\t\tg_stacknleft = blocksize;\n\t\tsstrend = g_stacknxt + blocksize;\n\t\tg_stackp = sp;\n\t\tINT_ON;\n\t}\n\tp = g_stacknxt;\n\tg_stacknxt += aligned;\n\tg_stacknleft -= aligned;\n\treturn p;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4EB4EC(const char *a1, __int64 a2)\n{\n  void **v2; // rbx\n  _QWORD *v3; // rdx\n  _QWORD *v4; // rax\n  _QWORD *v5; // rbx\n  int v7; // [rsp+18h] [rbp-18h]\n  unsigned int v8; // [rsp+1Ch] [rbp-14h]\n\n  v7 = sub_4EF7EE(a1);\n  free(*(void **)qword_75D408);\n  *((_DWORD *)qword_75D408 + 6) = v7 + 10240;\n  v2 = (void **)qword_75D408;\n  *v2 = sub_40A0E8(*((int *)qword_75D408 + 6), a2);\n  v3 = qword_75D408;\n  *((_QWORD *)qword_75D408 + 1) = *v2;\n  v4 = qword_75D408;\n  *((_QWORD *)qword_75D408 + 2) = v3[1];\n  *((_QWORD *)qword_75D408 + 11) = v4[2];\n  if ( a1 != *((const char **)qword_75D408 + 10) )\n  {\n    free(*((void **)qword_75D408 + 10));\n    v5 = qword_75D408;\n    v5[10] = sub_40A11F(a1, a2);\n  }\n  if ( v7 >= 0 )\n  {\n    v8 = sub_4EF83A(a1, *(_QWORD *)qword_75D408, 1LL);\n  }\n  else\n  {\n    sub_4EDFD1(*(_QWORD *)qword_75D408, 10LL);\n    v8 = 0;\n  }\n  *((_DWORD *)qword_75D408 + 8) = 0;\n  *((_DWORD *)qword_75D408 + 9) = -1;\n  memset((char *)qword_75D408 + 408, 0, 0xE0uLL);\n  return v8;\n}\n\n\n Revised code:\nstatic int init_text_buffer(char *fn)\n{\n\tint rc;\n\tint size = file_size(fn);\t// file size. -1 means does not exist.\n\n\t/* allocate/reallocate text buffer */\n\tfree(text);\n\ttext_size = size + 10240;\n\tscreenbegin = dot = end = text = xzalloc(text_size);\n\n\tif (fn != current_filename) {\n\t\tfree(current_filename);\n\t\tcurrent_filename = xstrdup(fn);\n\t}\n\tif (size < 0) {\n\t\t// file dont exist. Start empty buf with dummy line\n\t\tchar_insert(text, '\\n');\n\t\trc = 0;\n\t} else {\n\t\trc = file_insert(fn, text, 1);\n\t}\n\tfile_modified = 0;\n\tlast_file_modified = -1;\n#if ENABLE_FEATURE_VI_YANKMARK\n\t/* init the marks. */\n\tmemset(mark, 0, sizeof(mark));\n#endif\n\treturn rc;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4DDE4A(int a1, __int64 a2)\n{\n  __int64 v2; // rbx\n  __int64 v4; // [rsp+18h] [rbp-18h]\n  __int64 v5; // [rsp+18h] [rbp-18h]\n\n  if ( !**((_QWORD **)qword_75D408 - 16) )\n  {\n    v2 = *((_QWORD *)qword_75D408 - 16);\n    *(_QWORD *)(v2 + 8) = sub_4DD854(0, a2);\n    **((_QWORD **)qword_75D408 - 16) = *(_QWORD *)(v2 + 8);\n  }\n  if ( *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 16LL) != *((_QWORD *)qword_75D408 - 8) )\n  {\n    *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 16LL) = *((_QWORD *)qword_75D408 - 8);\n    v4 = sub_4DDE4A(768LL);\n    *(_QWORD *)(v4 + 8) = sub_40A11F(*((const char **)qword_75D408 - 8), a2);\n  }\n  v5 = *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 8LL);\n  *(_DWORD *)v5 = a1;\n  *(_QWORD *)(v5 + 24) = sub_4DD854(10240, a2);\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 8LL) = *(_QWORD *)(v5 + 24);\n  return v5;\n}\n"
    },
    {
        "func_name": "stat_main",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4CD235(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  _QWORD *v11; // [rsp+0h] [rbp-40h]\n  unsigned int v12; // [rsp+1Ch] [rbp-24h] BYREF\n  __int64 v13; // [rsp+20h] [rbp-20h] BYREF\n  int v14; // [rsp+2Ch] [rbp-14h]\n  unsigned int v15; // [rsp+30h] [rbp-10h]\n  unsigned int v16; // [rsp+34h] [rbp-Ch]\n  __int64 v17; // [rsp+38h] [rbp-8h]\n\n  v17 = -1LL;\n  v16 = 0;\n  v15 = 0;\n  qword_75D448 = (__int64)\"mode\";\n  v14 = sub_4FA1EF(a2, (unsigned int)\"m:pv\", (unsigned int)&v13, a4, a5, a6);\n  if ( (v14 & 1) != 0 )\n  {\n    v12 = 511;\n    if ( !(unsigned int)sub_50291C(v13, &v12) )\n      sub_40969E(\"invalid mode '%s'\", v13, v6, v7, v8, v9);\n    v17 = v12;\n  }\n  if ( (v14 & 2) != 0 )\n    v15 |= 4u;\n  v11 = (_QWORD *)(8LL * optind + a2);\n  if ( !*v11 )\n    sub_407F64();\n  do\n  {\n    if ( (unsigned int)sub_501CD0(*v11, v17, v15) )\n      v16 = 1;\n    ++v11;\n  }\n  while ( *v11 );\n  return v16;\n}\n\n\n Revised code:\nint mkdir_main(int argc UNUSED_PARAM, char **argv)\n{\n\tlong mode = -1;\n\tint status = EXIT_SUCCESS;\n\tint flags = 0;\n\tunsigned opt;\n\tchar *smode;\n#if ENABLE_SELINUX\n\tsecurity_context_t scontext;\n#endif\n\n#if ENABLE_FEATURE_MKDIR_LONG_OPTIONS\n\tapplet_long_options = mkdir_longopts;\n#endif\n\topt = getopt32(argv, \"m:p\" IF_SELINUX(\"Z:\") \"v\", &smode IF_SELINUX(,&scontext));\n\tif (opt & 1) {\n\t\tmode_t mmode = 0777;\n\t\tif (!bb_parse_mode(smode, &mmode)) {\n\t\t\tbb_error_msg_and_die(\"invalid mode '%s'\", smode);\n\t\t}\n\t\tmode = mmode;\n\t}\n\tif (opt & 2)\n\t\tflags |= FILEUTILS_RECUR;\n#if ENABLE_SELINUX\n\tif (opt & 4) {\n\t\tselinux_or_die();\n\t\tsetfscreatecon_or_die(scontext);\n\t}\n#endif\n\n\targv += optind;\n\tif (!argv[0])\n\t\tbb_show_usage();\n\n\tdo {\n\t\tif (bb_make_directory(*argv, mode, flags)) {\n\t\t\tstatus = EXIT_FAILURE;\n\t\t}\n\t} while (*++argv);\n\n\treturn status;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4C6031(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  char **v7; // [rsp+0h] [rbp-30h]\n  unsigned int v8[2]; // [rsp+10h] [rbp-20h] BYREF\n  int (*v9)(const char *, __uid_t, __gid_t); // [rsp+18h] [rbp-18h]\n  int v10; // [rsp+24h] [rbp-Ch]\n  unsigned int v11; // [rsp+28h] [rbp-8h]\n  unsigned int v12; // [rsp+2Ch] [rbp-4h]\n\n  v12 = 0;\n  v8[0] = -1;\n  v8[1] = -1;\n  qword_75D448 = (__int64)\"recursive\";\n  qword_75D440 = (__int64)\"-2\";\n  v10 = sub_4FA1EF(a2, (unsigned int)\"RhvcfLHP\", a3, a4, a5, a6);\n  v7 = (char **)(8LL * optind + a2);\n  v9 = chown;\n  if ( (v10 & 2) != 0 || (v10 & 0x61) == 1 )\n    v9 = lchown;\n  v11 = 8;\n  if ( (v10 & 1) != 0 )\n    v11 |= 1u;\n  if ( (v10 & 0x60) != 0 )\n    v11 |= 4u;\n  if ( (v10 & 0x20) != 0 )\n    v11 |= 2u;\n  sub_40D112(v8, *v7);\n  while ( *++v7 )\n  {\n    if ( !(unsigned int)sub_50752C(*v7, v11, sub_4C5F4E, sub_4C5F4E, v8, 0LL) )\n      v12 = 1;\n  }\n  return v12;\n}\n\n\n Revised code:\nint chown_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint retval = EXIT_SUCCESS;\n\tint opt, flags;\n\tstruct param_t param;\n\n\t/* Just -1 might not work: uid_t may be unsigned long */\n\tparam.ugid.uid = -1L;\n\tparam.ugid.gid = -1L;\n\n#if ENABLE_FEATURE_CHOWN_LONG_OPTIONS\n\tapplet_long_options = chown_longopts;\n#endif\n\topt_complementary = \"-2\";\n\topt = getopt32(argv, OPT_STR);\n\targv += optind;\n\n\t/* This matches coreutils behavior (almost - see below) */\n\tparam.chown_func = chown;\n\tif (OPT_NODEREF\n\t/* || (OPT_RECURSE && !OPT_TRAVERSE_TOP): */\n\tIF_DESKTOP( || (opt & (BIT_RECURSE|BIT_TRAVERSE_TOP)) == BIT_RECURSE)\n\t) {\n\t\tparam.chown_func = lchown;\n\t}\n\n\tflags = ACTION_DEPTHFIRST; /* match coreutils order */\n\tif (OPT_RECURSE)\n\t\tflags |= ACTION_RECURSE;\n\tif (OPT_TRAVERSE_TOP)\n\t\tflags |= ACTION_FOLLOWLINKS_L0; /* -H/-L: follow links on depth 0 */\n\tif (OPT_TRAVERSE)\n\t\tflags |= ACTION_FOLLOWLINKS; /* follow links if -L */\n\n\tparse_chown_usergroup_or_die(&param.ugid, argv[0]);\n\n\t/* Ok, ready to do the deed now */\n\twhile (*++argv) {\n\t\tif (!recursive_action(*argv,\n\t\t\t\tflags,          /* flags */\n\t\t\t\tfileAction,     /* file action */\n\t\t\t\tfileAction,     /* dir action */\n\t\t\t\t&param,         /* user data */\n\t\t\t\t0)              /* depth */\n\t\t) {\n\t\t\tretval = EXIT_FAILURE;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4C5E24(__int64 a1, _BYTE **a2, __int64 a3, int a4, int a5, int a6)\n{\n  __int64 *v6; // rax\n  __int64 v8; // [rsp+0h] [rbp-30h]\n  __int64 *v9; // [rsp+0h] [rbp-30h]\n  _QWORD *v10; // [rsp+0h] [rbp-30h]\n  __int64 v11; // [rsp+10h] [rbp-20h]\n  _BYTE **v12; // [rsp+18h] [rbp-18h]\n  _BYTE *v13; // [rsp+20h] [rbp-10h]\n  unsigned int v14; // [rsp+2Ch] [rbp-4h]\n\n  v14 = 0;\n  v12 = a2;\n  while ( 1 )\n  {\n    v13 = *++v12;\n    if ( !*v12 )\n      break;\n    if ( *v13 != 45 )\n    {\n      v13 = 0LL;\n      break;\n    }\n    if ( v13[1] && !strchr(\"-Rvcf\", (char)v13[1]) )\n    {\n      *v13 = 97;\n      break;\n    }\n  }\n  qword_75D440 = (__int64)\"-2\";\n  sub_4FA1EF((_DWORD)a2, 5447004, 5447004, a4, a5, a6, a2);\n  v9 = (__int64 *)(8LL * optind + v8);\n  if ( v13 )\n    *v13 = 45;\n  v6 = v9;\n  v10 = v9 + 1;\n  v11 = *v6;\n  do\n  {\n    if ( !(unsigned int)sub_50752C(*v10, dword_75D450 & 1, sub_4C5D04, sub_4C5D04, v11, 0LL) )\n      v14 = 1;\n    ++v10;\n  }\n  while ( *v10 );\n  return v14;\n}\n\n\n Revised code:\nint chmod_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint retval = EXIT_SUCCESS;\n\tchar *arg, **argp;\n\tchar *smode;\n\n\t/* Convert first encountered -r into ar, -w into aw etc\n\t * so that getopt would not eat it */\n\targp = argv;\n\twhile ((arg = *++argp)) {\n\t\t/* Mode spec must be the first arg (sans -R etc) */\n\t\t/* (protect against mishandling e.g. \"chmod 644 -r\") */\n\t\tif (arg[0] != '-') {\n\t\t\targ = NULL;\n\t\t\tbreak;\n\t\t}\n\t\t/* An option. Not a -- or valid option? */\n\t\tif (arg[1] && !strchr(\"-\"OPT_STR, arg[1])) {\n\t\t\targ[0] = 'a';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Parse options */\n\topt_complementary = \"-2\";\n\tgetopt32(argv, (\"-\"OPT_STR) + 1); /* Reuse string */\n\targv += optind;\n\n\t/* Restore option-like mode if needed */\n\tif (arg) arg[0] = '-';\n\n\t/* Ok, ready to do the deed now */\n\tsmode = *argv++;\n\tdo {\n\t\tif (!recursive_action(*argv,\n\t\t\tOPT_RECURSE,    // recurse\n\t\t\tfileAction,     // file action\n\t\t\tfileAction,     // dir action\n\t\t\tsmode,          // user data\n\t\t\t0)              // depth\n\t\t) {\n\t\t\tretval = EXIT_FAILURE;\n\t\t}\n\t} while (*++argv);\n\n\treturn retval;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BOOL8 __fastcall sub_4D3284(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  char v6; // al\n  __int64 v8; // [rsp+0h] [rbp-30h]\n  __int64 v9; // [rsp+10h] [rbp-20h] BYREF\n  int v10; // [rsp+1Ch] [rbp-14h]\n  __int64 (__fastcall *v11)(_QWORD, __int64); // [rsp+20h] [rbp-10h]\n  int v12; // [rsp+28h] [rbp-8h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  v9 = 0LL;\n  v11 = (__int64 (__fastcall *)(_QWORD, __int64))sub_4D318F;\n  qword_75D440 = (__int64)\"-1\";\n  v10 = sub_4FA1EF(a2, (unsigned int)\"ftLc:\", (unsigned int)&v9, a4, a5, a6);\n  if ( (v10 & 1) != 0 )\n    v11 = (__int64 (__fastcall *)(_QWORD, __int64))sub_4D30E9;\n  v12 = 1;\n  v8 = 8LL * optind + a2;\n  for ( i = 0; *(_QWORD *)(8LL * i + v8); ++i )\n  {\n    v6 = v11(*(_QWORD *)(8LL * i + v8), v9);\n    v12 = (unsigned __int8)(v6 & v12);\n  }\n  return v12 == 0;\n}\n"
    },
    {
        "func_name": "remove_iacs",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47134A(int a1, __int64 a2)\n{\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  void *v5; // rsp\n  __int64 v6; // rdx\n  int v7; // eax\n  __int64 v9; // [rsp+0h] [rbp-40h] BYREF\n  int v10; // [rsp+Ch] [rbp-34h]\n  unsigned int *v11; // [rsp+18h] [rbp-28h]\n  __int64 v12; // [rsp+20h] [rbp-20h]\n  int v13; // [rsp+28h] [rbp-18h]\n  int i; // [rsp+2Ch] [rbp-14h]\n  char *s; // [rsp+30h] [rbp-10h]\n  int v16; // [rsp+3Ch] [rbp-4h]\n\n  v10 = a1;\n  v9 = a2;\n  if ( *(_QWORD *)(a2 + 8) && strcmp(*(const char **)(v9 + 8), \"-l\") )\n  {\n    v16 = 1;\n    do\n    {\n      if ( **(_BYTE **)(8LL * v16 + v9) == 37 )\n      {\n        v12 = sub_470E8F(*(_BYTE **)(8LL * v16 + v9), 0, 8LL * v16, v2, v3, v4);\n        v13 = *(unsigned __int16 *)(v12 + 28);\n        if ( (*(_BYTE *)(v12 + 31) & 2) != 0 )\n          v13 = 1;\n        v2 = 16LL;\n        v5 = alloca(16 * ((16LL * v13 + 23) / 0x10uLL));\n        s = (char *)&v9;\n        *(_QWORD *)(v9 + 8LL * v16) = &v9;\n        for ( i = 0; i < v13; ++i )\n        {\n          v11 = (unsigned int *)(16LL * i + *(_QWORD *)(v12 + 16));\n          if ( v11[1] == -1 || (unsigned __int8)v11[1] == 127 )\n          {\n            v6 = *v11;\n            if ( (*(_BYTE *)(v12 + 31) & 2) != 0 )\n              v7 = sprintf(s, \" -%u\", v6);\n            else\n              v7 = sprintf(s, \" %u\", v6);\n            s += v7;\n          }\n        }\n        *s = 0;\n      }\n      ++v16;\n    }\n    while ( *(_QWORD *)(8LL * v16 + v9) );\n  }\n  return sub_45CB53(v10, v9);\n}\n\n\n Revised code:\nstatic int FAST_FUNC\nkillcmd(int argc, char **argv)\n{\n\tif (argv[1] && strcmp(argv[1], \"-l\") != 0) {\n\t\tint i = 1;\n\t\tdo {\n\t\t\tif (argv[i][0] == '%') {\n\t\t\t\t/*\n\t\t\t\t * \"kill %N\" - job kill\n\t\t\t\t * Converting to pgrp / pid kill\n\t\t\t\t */\n\t\t\t\tstruct job *jp;\n\t\t\t\tchar *dst;\n\t\t\t\tint j, n;\n\n\t\t\t\tjp = getjob(argv[i], 0);\n\t\t\t\t/*\n\t\t\t\t * In jobs started under job control, we signal\n\t\t\t\t * entire process group by kill -PGRP_ID.\n\t\t\t\t * This happens, f.e., in interactive shell.\n\t\t\t\t *\n\t\t\t\t * Otherwise, we signal each child via\n\t\t\t\t * kill PID1 PID2 PID3.\n\t\t\t\t * Testcases:\n\t\t\t\t * sh -c 'sleep 1|sleep 1 & kill %1'\n\t\t\t\t * sh -c 'true|sleep 2 & sleep 1; kill %1'\n\t\t\t\t * sh -c 'true|sleep 1 & sleep 2; kill %1'\n\t\t\t\t */\n\t\t\t\tn = jp->nprocs; /* can't be 0 (I hope) */\n\t\t\t\tif (jp->jobctl)\n\t\t\t\t\tn = 1;\n\t\t\t\tdst = alloca(n * sizeof(int)*4);\n\t\t\t\targv[i] = dst;\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tstruct procstat *ps = &jp->ps[j];\n\t\t\t\t\t/* Skip non-running and not-stopped members\n\t\t\t\t\t * (i.e. dead members) of the job\n\t\t\t\t\t */\n\t\t\t\t\tif (ps->ps_status != -1 && !WIFSTOPPED(ps->ps_status))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t/*\n\t\t\t\t\t * kill_main has matching code to expect\n\t\t\t\t\t * leading space. Needed to not confuse\n\t\t\t\t\t * negative pids with \"kill -SIGNAL_NO\" syntax\n\t\t\t\t\t */\n\t\t\t\t\tdst += sprintf(dst, jp->jobctl ? \" -%u\" : \" %u\", (int)ps->ps_pid);\n\t\t\t\t}\n\t\t\t\t*dst = '\\0';\n\t\t\t}\n\t\t} while (argv[++i]);\n\t}\n\treturn kill_main(argc, argv);\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_4F73F6(int *a1, __int64 a2)\n{\n  int v2; // eax\n  int v3; // eax\n  int v4; // eax\n  int v5; // eax\n  int *v6; // rax\n  int *v8; // [rsp+8h] [rbp-18h]\n  int v9; // [rsp+10h] [rbp-10h]\n  int j; // [rsp+14h] [rbp-Ch]\n  int i; // [rsp+18h] [rbp-8h]\n  int v12; // [rsp+1Ch] [rbp-4h]\n\n  v8 = a1;\n  if ( (_DWORD)a2 )\n    v2 = 79764919;\n  else\n    v2 = -306674912;\n  v9 = v2;\n  if ( !a1 )\n    v8 = (int *)sub_40A05F(0x400uLL, a2);\n  for ( i = 0; i <= 255; ++i )\n  {\n    if ( (_DWORD)a2 )\n      v3 = i << 24;\n    else\n      v3 = i;\n    v12 = v3;\n    for ( j = 8; j; --j )\n    {\n      if ( (_DWORD)a2 )\n      {\n        if ( v12 >= 0 )\n          v4 = 2 * v12;\n        else\n          v4 = v9 ^ (2 * v12);\n        v12 = v4;\n      }\n      else\n      {\n        if ( (v12 & 1) != 0 )\n          v5 = v9 ^ ((unsigned int)v12 >> 1);\n        else\n          v5 = (unsigned int)v12 >> 1;\n        v12 = v5;\n      }\n    }\n    v6 = v8++;\n    *v6 = v12;\n  }\n  return (char *)(v8 - 256);\n}\n\n\n Revised code:\nFAST_FUNC crc32_filltable(uint32_t *crc_table, int endian)\n{\n\tuint32_t polynomial = endian ? 0x04c11db7 : 0xedb88320;\n\tuint32_t c;\n\tint i, j;\n\n\tif (!crc_table)\n\t\tcrc_table = xmalloc(256 * sizeof(uint32_t));\n\n\tfor (i = 0; i < 256; i++) {\n\t\tc = endian ? (i << 24) : i;\n\t\tfor (j = 8; j; j--) {\n\t\t\tif (endian)\n\t\t\t\tc = (c&0x80000000) ? ((c << 1) ^ polynomial) : (c << 1);\n\t\t\telse\n\t\t\t\tc = (c&1) ? ((c >> 1) ^ polynomial) : (c >> 1);\n\t\t}\n\t\t*crc_table++ = c;\n\t}\n\n\treturn crc_table - 256;\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_4C5599(unsigned int a1, unsigned int a2, char *a3)\n{\n  char *result; // rax\n  unsigned int v4; // esi\n  unsigned int v5; // eax\n  unsigned int v6; // esi\n  unsigned int v7; // eax\n  __int64 v8; // rdx\n  __int64 v9; // rdx\n  int v10; // edx\n  unsigned __int64 v13; // [rsp+18h] [rbp-28h]\n  int v14; // [rsp+24h] [rbp-1Ch]\n  unsigned __int64 i; // [rsp+28h] [rbp-18h]\n  int v16; // [rsp+30h] [rbp-10h]\n  int v17; // [rsp+34h] [rbp-Ch]\n  unsigned int v18; // [rsp+38h] [rbp-8h]\n  unsigned int j; // [rsp+3Ch] [rbp-4h]\n\n  memset(a3, -1, 0xA8uLL);\n  if ( a1 == 9 && a2 == 1752 )\n  {\n    v14 = 244 * dword_75D450;\n    for ( i = 0LL; i <= 0x12; ++i )\n    {\n      result = &a3[4 * i + 8];\n      *(_DWORD *)result = *(unsigned __int8 *)(i + 5466736) + v14;\n    }\n  }\n  else\n  {\n    v18 = 1;\n    if ( a1 > 2 && sub_4C4F6A(a2) )\n      v18 = 2;\n    for ( j = a1; j; v18 += (unsigned __int8)byte_536A63[j] )\n      --j;\n    v4 = (a2 - 1) >> 2;\n    if ( a2 - 1 <= 0x6A4 )\n      v5 = 0;\n    else\n      v5 = (a2 - 1) / 0x64 - 17;\n    v6 = v4 - v5;\n    if ( a2 - 1 <= 0x640 )\n      v7 = 0;\n    else\n      v7 = (a2 - 1601) / 0x190;\n    v13 = 365LL * (a2 - 1) + v6 + v7 + v18;\n    if ( v13 > 0x9C32A )\n    {\n      v9 = (0x2492492492492493LL * (unsigned __int128)(v13 - 6)) >> 64;\n      v17 = v13 - 6 - 7 * ((v9 + ((v13 - 6 - v9) >> 1)) >> 2);\n    }\n    else\n    {\n      v8 = (0x2492492492492493LL * (unsigned __int128)(v13 + 5)) >> 64;\n      v17 = v13 + 5 - 7 * ((v8 + ((v13 + 5 - v8) >> 1)) >> 2);\n    }\n    if ( !dword_75D450 )\n      v18 = 1;\n    v16 = (unsigned __int8)byte_536A63[a1];\n    if ( a1 == 2 && sub_4C4F6A(a2) )\n      ++v16;\n    do\n    {\n      result = (char *)v18++;\n      v10 = v17++;\n      *(_DWORD *)&a3[4 * v10] = (_DWORD)result;\n      --v16;\n    }\n    while ( v16 );\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void day_array(unsigned month, unsigned year, unsigned *days)\n{\n\tunsigned long temp;\n\tunsigned i;\n\tunsigned day, dw, dm;\n\n\tmemset(days, SPACE, MAXDAYS * sizeof(int));\n\n\tif ((month == 9) && (year == 1752)) {\n\t\t/* Assumes the Gregorian reformation eliminates\n\t\t * 3 Sep. 1752 through 13 Sep. 1752.\n\t\t */\n\t\tunsigned j_offset = julian * 244;\n\t\tsize_t oday = 0;\n\n\t\tdo {\n\t\t\tdays[oday+2] = sep1752[oday] + j_offset;\n\t\t} while (++oday < sizeof(sep1752));\n\n\t\treturn;\n\t}\n\n\t/* day_in_year\n\t * return the 1 based day number within the year\n\t */\n\tday = 1;\n\tif ((month > 2) && leap_year(year)) {\n\t\t++day;\n\t}\n\n\ti = month;\n\twhile (i) {\n\t\tday += days_in_month[--i];\n\t}\n\n\t/* day_in_week\n\t * return the 0 based day number for any date from 1 Jan. 1 to\n\t * 31 Dec. 9999.  Assumes the Gregorian reformation eliminates\n\t * 3 Sep. 1752 through 13 Sep. 1752.  Returns Thursday for all\n\t * missing days.\n\t */\n\ttemp = (long)(year - 1) * 365 + leap_years_since_year_1(year - 1) + day;\n\tif (temp < FIRST_MISSING_DAY) {\n\t\tdw = ((temp - 1 + SATURDAY) % 7);\n\t} else {\n\t\tdw = (((temp - 1 + SATURDAY) - NUMBER_MISSING_DAYS) % 7);\n\t}\n\n\tif (!julian) {\n\t\tday = 1;\n\t}\n\n\tdm = days_in_month[month];\n\tif ((month == 2) && leap_year(year)) {\n\t\t++dm;\n\t}\n\n\tdo {\n\t\tdays[dw++] = day++;\n\t} while (--dm);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_44283A(int *a1, _DWORD *a2)\n{\n  int v2; // eax\n  char *v3; // rax\n  char *v4; // rax\n  __int16 v6[4]; // [rsp+10h] [rbp-30h] BYREF\n  int v7; // [rsp+18h] [rbp-28h]\n  char v8; // [rsp+1Fh] [rbp-21h]\n  unsigned __int64 v9; // [rsp+20h] [rbp-20h]\n  void *src; // [rsp+28h] [rbp-18h]\n  char *v11; // [rsp+30h] [rbp-10h]\n  char *v12; // [rsp+38h] [rbp-8h]\n\n  src = (char *)a1 + a1[7] + 48;\n  v12 = (char *)src;\n  v11 = (char *)src;\n  v2 = a1[8];\n  if ( v2 > 2024 - a1[7] )\n    v2 = 2024 - a1[7];\n  v9 = (unsigned __int64)&v12[v2];\n  while ( (unsigned __int64)v12 < v9 )\n  {\n    if ( *v12 == -1 )\n    {\n      if ( v9 <= (unsigned __int64)(v12 + 1) )\n        break;\n      if ( v12[1] == -15 )\n      {\n        v12 += 2;\n      }\n      else if ( v12[1] == -1 )\n      {\n        v4 = v11++;\n        *v4 = v12[1];\n        v12 += 2;\n      }\n      else\n      {\n        if ( v9 <= (unsigned __int64)(v12 + 2) )\n          break;\n        if ( v12[1] == -6 && v12[2] == 31 )\n        {\n          if ( v9 <= (unsigned __int64)(v12 + 8) )\n            break;\n          v6[1] = _byteswap_ushort(*(_WORD *)(v12 + 3));\n          v6[0] = _byteswap_ushort(*(_WORD *)(v12 + 5));\n          ioctl(a1[5], 0x5414uLL, v6);\n          v12 += 9;\n        }\n        else\n        {\n          v12 += 3;\n        }\n      }\n    }\n    else\n    {\n      v8 = *v12;\n      v3 = v11++;\n      *v3 = v8;\n      ++v12;\n      if ( v8 == 13 && (unsigned __int64)v12 < v9 && (*v12 == 10 || !*v12) )\n        ++v12;\n    }\n  }\n  v7 = (_DWORD)v11 - (_DWORD)src;\n  *a2 = (_DWORD)v11 - (_DWORD)src;\n  if ( v12 == v11 )\n    return src;\n  a1[7] += (_DWORD)v12 - (_DWORD)v11;\n  a1[8] -= (_DWORD)v12 - (_DWORD)v11;\n  return memmove(&v12[-v7], src, v7);\n}\n"
    },
    {
        "func_name": "interpret_xfermode",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_449BFB(int a1, int a2)\n{\n  unsigned int v3; // [rsp+Ch] [rbp-4h]\n\n  sub_40A659(60);\n  if ( (a1 & 1) != 0 && (a1 & 0x40) == 0 )\n    printf(\"NO-CARRIER,\");\n  v3 = sub_502E59(\"\\b\", \"LOOPBACK\", a1 & 0xFFFFFFBF, \",\");\n  if ( v3 )\n    printf(\"%x\", v3);\n  if ( a2 )\n    printf(\",M-DOWN\");\n  return printf(\"> \");\n}\n\n\n Revised code:\nstatic void print_link_flags(unsigned flags, unsigned mdown)\n{\n\tstatic const int flag_masks[] = {\n\t\tIFF_LOOPBACK, IFF_BROADCAST, IFF_POINTOPOINT,\n\t\tIFF_MULTICAST, IFF_NOARP, IFF_UP, IFF_LOWER_UP };\n\tstatic const char flag_labels[] ALIGN1 =\n\t\t\"LOOPBACK\\0\"\"BROADCAST\\0\"\"POINTOPOINT\\0\"\n\t\t\"MULTICAST\\0\"\"NOARP\\0\"\"UP\\0\"\"LOWER_UP\\0\";\n\n\tbb_putchar('<');\n\tif (flags & IFF_UP && !(flags & IFF_RUNNING))\n\t\tprintf(\"NO-CARRIER,\");\n\tflags &= ~IFF_RUNNING;\n#if 0\n\t_PF(ALLMULTI);\n\t_PF(PROMISC);\n\t_PF(MASTER);\n\t_PF(SLAVE);\n\t_PF(DEBUG);\n\t_PF(DYNAMIC);\n\t_PF(AUTOMEDIA);\n\t_PF(PORTSEL);\n\t_PF(NOTRAILERS);\n#endif\n\tflags = print_flags_separated(flag_masks, flag_labels, flags, \",\");\n\tif (flags)\n\t\tprintf(\"%x\", flags);\n\tif (mdown)\n\t\tprintf(\",M-DOWN\");\n\tprintf(\"> \");\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_417D58(unsigned __int16 a1, unsigned __int16 a2, unsigned int a3, _BYTE *a4)\n{\n  unsigned __int8 v9; // [rsp+2Dh] [rbp-3h]\n  unsigned __int16 i; // [rsp+2Eh] [rbp-2h]\n\n  v9 = 0;\n  for ( i = 0; i <= 7u; ++i )\n  {\n    if ( (a2 & 1) != 0 )\n    {\n      printf(\"*%cdma%u \", a3, i);\n      if ( *a4 )\n        v9 = 1;\n      *a4 = 1;\n    }\n    else if ( (a1 & 1) != 0 )\n    {\n      printf(\"%cdma%u \", a3, i);\n    }\n    a1 >>= 1;\n    a2 >>= 1;\n  }\n  return v9;\n}\n\n\n Revised code:\nstatic uint8_t mode_loop(uint16_t mode_sup, uint16_t mode_sel, int cc, uint8_t *have_mode)\n{\n\tuint16_t ii;\n\tuint8_t err_dma = 0;\n\n\tfor (ii = 0; ii <= MODE_MAX; ii++) {\n\t\tif (mode_sel & 0x0001) {\n\t\t\tprintf(\"*%cdma%u \", cc, ii);\n\t\t\tif (*have_mode)\n\t\t\t\terr_dma = 1;\n\t\t\t*have_mode = 1;\n\t\t} else if (mode_sup & 0x0001)\n\t\t\tprintf(\"%cdma%u \", cc, ii);\n\n\t\tmode_sup >>= 1;\n\t\tmode_sel >>= 1;\n\t}\n\treturn err_dma;\n}\n\n## Example:\n\n Input code:\nconst char *__fastcall sub_4D213C(__int64 a1)\n{\n  switch ( *(_DWORD *)(a1 + 24) & 0xF000 )\n  {\n    case 32768:\n      if ( *(_QWORD *)(a1 + 48) )\n        return \"regular file\";\n      else\n        return \"regular empty file\";\n    case 16384:\n      return \"directory\";\n    case 24576:\n      return \"block special file\";\n    case 8192:\n      return \"character special file\";\n    case 4096:\n      return \"fifo\";\n    case 40960:\n      return \"symbolic link\";\n    case 49152:\n      return \"socket\";\n    default:\n      return \"weird file\";\n  }\n}\n\n\n Revised code:\nendif\n\nstatic const char *file_type(const struct stat *st)\n{\n\t/* See POSIX 1003.1-2001 XCU Table 4-8 lines 17093-17107\n\t * for some of these formats.\n\t * To keep diagnostics grammatical in English, the\n\t * returned string must start with a consonant.\n\t */\n\tif (S_ISREG(st->st_mode))  return st->st_size == 0 ? \"regular empty file\" : \"regular file\";\n\tif (S_ISDIR(st->st_mode))  return \"directory\";\n\tif (S_ISBLK(st->st_mode))  return \"block special file\";\n\tif (S_ISCHR(st->st_mode))  return \"character special file\";\n\tif (S_ISFIFO(st->st_mode)) return \"fifo\";\n\tif (S_ISLNK(st->st_mode))  return \"symbolic link\";\n\tif (S_ISSOCK(st->st_mode)) return \"socket\";\n#ifdef S_TYPEISMQ\n\tif (S_TYPEISMQ(st))        return \"message queue\";\n#endif\n#ifdef S_TYPEISSEM\n\tif (S_TYPEISSEM(st))       return \"semaphore\";\n#endif\n#ifdef S_TYPEISSHM\n\tif (S_TYPEISSHM(st))       return \"shared memory object\";\n#endif\n#ifdef S_TYPEISTMO\n\tif (S_TYPEISTMO(st))       return \"typed memory object\";\n#endif\n\treturn \"weird file\";\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_41A65F(unsigned int a1)\n{\n  printf(\" (\");\n  if ( a1 )\n  {\n    if ( a1 == 1 )\n    {\n      printf(\"default PIO mode, disable IORDY\");\n    }\n    else if ( a1 <= 7 || a1 > 0xF )\n    {\n      if ( a1 <= 0xF || a1 > 0x17 )\n      {\n        if ( a1 <= 0x1F || a1 > 0x27 )\n        {\n          if ( a1 <= 0x3F || a1 > 0x47 )\n            printf(\"unknown\");\n          else\n            printf(\"UltraDMA mode%u\", a1 - 64);\n        }\n        else\n        {\n          printf(\"multiword DMA mode%u\", a1 - 32);\n        }\n      }\n      else\n      {\n        printf(\"singleword DMA mode%u\", a1 - 16);\n      }\n    }\n    else\n    {\n      printf(\"PIO flow control mode%u\", a1 - 8);\n    }\n  }\n  else\n  {\n    printf(\"default PIO mode\");\n  }\n  return puts(\")\");\n}\n"
    },
    {
        "func_name": "do_subst_w_backrefs",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4DF387(int *a1, __int64 a2)\n{\n  int v2; // eax\n  __int64 result; // rax\n  __int64 v4; // [rsp+10h] [rbp-20h]\n  __int64 v5; // [rsp+18h] [rbp-18h]\n  __int64 v6; // [rsp+24h] [rbp-Ch]\n  __int64 i; // [rsp+28h] [rbp-8h]\n\n  if ( (*a1 & 0x800) != 0 )\n  {\n    v5 = *((_QWORD *)a1 + 3);\n  }\n  else\n  {\n    v2 = *a1;\n    BYTE1(v2) = BYTE1(*a1) | 8;\n    *a1 = v2;\n    v5 = 0LL;\n  }\n  *((_QWORD *)a1 + 3) = sub_40A0E8(*(unsigned int *)(a2 + 12) + 33LL, a2);\n  v4 = *((_QWORD *)a1 + 3);\n  *(_QWORD *)v4 = v4 + 24;\n  *(_QWORD *)(v4 + 8) = *(_QWORD *)v4;\n  *(_QWORD *)(v4 + 16) = v5;\n  LODWORD(v6) = 0;\n  while ( 1 )\n  {\n    result = *(unsigned int *)(a2 + 4);\n    if ( (unsigned int)v6 >= (unsigned int)result )\n      break;\n    for ( i = *(_QWORD *)(8LL * (unsigned int)v6 + *(_QWORD *)(a2 + 16)); i; i = *(_QWORD *)(i + 32) )\n    {\n      strcpy(*(char **)v4, (const char *)(i + 40));\n      sub_4DC55F((__int64 *)v4);\n    }\n    v6 = (unsigned int)(v6 + 1);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void hashwalk_init(var *v, xhash *array)\n{\n\thash_item *hi;\n\tunsigned i;\n\twalker_list *w;\n\twalker_list *prev_walker;\n\n\tif (v->type & VF_WALK) {\n\t\tprev_walker = v->x.walker;\n\t} else {\n\t\tv->type |= VF_WALK;\n\t\tprev_walker = NULL;\n\t}\n\tdebug_printf_walker(\"hashwalk_init: prev_walker:%p\\n\", prev_walker);\n\n\tw = v->x.walker = xzalloc(sizeof(*w) + array->glen + 1); /* why + 1? */\n\tdebug_printf_walker(\" walker@%p=%p\\n\", &v->x.walker, w);\n\tw->cur = w->end = w->wbuf;\n\tw->prev = prev_walker;\n\tfor (i = 0; i < array->csize; i++) {\n\t\thi = array->items[i];\n\t\twhile (hi) {\n\t\t\tstrcpy(w->end, hi->name);\n\t\t\tnextword(&w->end);\n\t\t\thi = hi->next;\n\t\t}\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_493918(__int64 a1, __int64 a2)\n{\n  int v2; // ebx\n  __int64 result; // rax\n  __int64 v4; // [rsp+18h] [rbp-20h]\n  char *v5; // [rsp+20h] [rbp-18h]\n  unsigned int i; // [rsp+2Ch] [rbp-Ch]\n\n  v5 = (char *)qword_75D408 + 2504;\n  for ( i = 0; ; ++i )\n  {\n    result = *((unsigned int *)qword_75D408 + 4);\n    if ( i >= (unsigned int)result )\n      break;\n    v4 = *(_QWORD *)v5;\n    if ( !*(_BYTE *)(*(_QWORD *)v5 + 4LL)\n      || *(_BYTE *)(v4 + 4) == 5\n      || *(_BYTE *)(v4 + 4) == 15\n      || *(_BYTE *)(v4 + 4) == 0x85 )\n    {\n      *(_DWORD *)(4LL * i + a1) = -1;\n      *(_DWORD *)(4LL * i + a2) = 0;\n    }\n    else\n    {\n      *(_DWORD *)(4LL * i + a1) = sub_490A13((__int64)v5);\n      v2 = *(_DWORD *)(4LL * i + a1);\n      *(_DWORD *)(4LL * i + a2) = v2 + sub_4908E3(v4) - 1;\n    }\n    v5 += 40;\n  }\n  return result;\n}\n\n\n Revised code:\nif ENABLE_FEATURE_FDISK_WRITABLE\nstatic void\nfill_bounds(sector_t *first, sector_t *last)\n{\n\tunsigned i;\n\tconst struct pte *pe = &ptes[0];\n\tconst struct partition *p;\n\n\tfor (i = 0; i < g_partitions; pe++,i++) {\n\t\tp = pe->part_table;\n\t\tif (!p->sys_ind || IS_EXTENDED(p->sys_ind)) {\n\t\t\tfirst[i] = 0xffffffff;\n\t\t\tlast[i] = 0;\n\t\t} else {\n\t\t\tfirst[i] = get_partition_start_from_dev_start(pe);\n\t\t\tlast[i] = first[i] + get_nr_sects(p) - 1;\n\t\t}\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4AF84C(__int64 a1, signed int a2)\n{\n  unsigned __int16 v2; // ax\n  __int64 result; // rax\n  __int16 v4[16]; // [rsp+10h] [rbp-30h]\n  int v5; // [rsp+30h] [rbp-10h]\n  unsigned int j; // [rsp+34h] [rbp-Ch]\n  int i; // [rsp+38h] [rbp-8h]\n  __int16 v8; // [rsp+3Eh] [rbp-2h]\n\n  v8 = 0;\n  for ( i = 1; i <= 15; ++i )\n  {\n    v8 = 2 * (*((_WORD *)qword_75D408 + i + 2619) + v8);\n    v4[i] = v8;\n  }\n  for ( j = 0; ; ++j )\n  {\n    result = j;\n    if ( (int)j > a2 )\n      break;\n    v5 = *(unsigned __int16 *)(4LL * (int)j + a1 + 2);\n    if ( v5 )\n    {\n      v2 = v4[v5];\n      v4[v5] = v2 + 1;\n      *(_WORD *)(4LL * (int)j + a1) = sub_4AE96D(v2, v5);\n    }\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void gen_codes(ct_data * tree, int max_code)\n{\n\tush next_code[MAX_BITS + 1];\t/* next code value for each bit length */\n\tush code = 0;\t\t/* running code value */\n\tint bits;\t\t\t/* bit index */\n\tint n;\t\t\t\t/* code index */\n\n\t/* The distribution counts are first used to generate the code values\n\t * without bit reversal.\n\t */\n\tfor (bits = 1; bits <= MAX_BITS; bits++) {\n\t\tnext_code[bits] = code = (code + G2.bl_count[bits - 1]) << 1;\n\t}\n\t/* Check that the bit counts in bl_count are consistent. The last code\n\t * must be all ones.\n\t */\n\tAssert(code + G2.bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,\n\t\t\t\"inconsistent bit counts\");\n\tTracev((stderr, \"\\ngen_codes: max_code %d \", max_code));\n\n\tfor (n = 0; n <= max_code; n++) {\n\t\tint len = tree[n].Len;\n\n\t\tif (len == 0)\n\t\t\tcontinue;\n\t\t/* Now reverse the bits */\n\t\ttree[n].Code = bi_reverse(next_code[len]++, len);\n\n\t\tTracec(tree != G2.static_ltree,\n\t\t\t   (stderr, \"\\nn %3d %c l %2d c %4x (%x) \", n,\n\t\t\t\t(n > ' ' ? n : ' '), len, tree[n].Code,\n\t\t\t\tnext_code[len] - 1));\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4E99A1(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  signed int v3; // eax\n  __int64 result; // rax\n  unsigned int v5; // [rsp+14h] [rbp-Ch]\n  int j; // [rsp+18h] [rbp-8h]\n  signed int k; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; ; ++i )\n  {\n    result = *(unsigned __int8 *)(i + a2);\n    if ( !(_BYTE)result )\n      break;\n    if ( *(_BYTE *)(i + a2) == 92 )\n    {\n      v5 = *(char *)(++i + a2) - 48;\n      if ( v5 > 9 )\n        goto LABEL_15;\n      if ( *(_DWORD *)&dest.c_cc[8 * v5 + 31] != -1 )\n      {\n        for ( j = *(_DWORD *)&dest.c_cc[8 * v5 + 31]; j < *(_DWORD *)&dest.c_cc[8 * v5 + 35]; ++j )\n        {\n          v2 = j;\n          sub_4E98F8(*(_BYTE *)(v2 + a1));\n        }\n      }\n    }\n    else\n    {\n      if ( *(_BYTE *)(i + a2) != 38 )\n      {\nLABEL_15:\n        sub_4E98F8(*(_BYTE *)(i + a2));\n        continue;\n      }\n      for ( k = *(_DWORD *)&dest.c_cc[31]; k < (signed int)dest.c_ispeed; ++k )\n      {\n        v3 = k;\n        sub_4E98F8(*(_BYTE *)(v3 + a1));\n      }\n    }\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "xsocket_type",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4ED92D(void *a1, void *a2)\n{\n  void *v3; // [rsp+0h] [rbp-20h]\n  unsigned __int64 v4; // [rsp+0h] [rbp-20h]\n  void *v5; // [rsp+8h] [rbp-18h]\n  _BYTE *v6; // [rsp+8h] [rbp-18h]\n  unsigned int v7; // [rsp+1Ch] [rbp-4h]\n\n  v5 = a1;\n  v3 = a2;\n  if ( a2 < a1 )\n  {\n    v5 = a2;\n    v3 = a1;\n  }\n  v7 = 0;\n  v4 = sub_4ED77B(v3);\n  while ( (unsigned __int64)v5 <= v4 && (unsigned __int64)v5 <= *((_QWORD *)qword_75D408 + 1) - 1LL )\n  {\n    v6 = (_BYTE *)sub_4ED77B(v5);\n    if ( *v6 == 10 )\n      ++v7;\n    v5 = v6 + 1;\n  }\n  return v7;\n}\n\n\n Revised code:\ncount line from start to stop\nstatic int count_lines(char *start, char *stop)\n{\n\tchar *q;\n\tint cnt;\n\n\tif (stop < start) { // start and stop are backwards- reverse them\n\t\tq = start;\n\t\tstart = stop;\n\t\tstop = q;\n\t}\n\tcnt = 0;\n\tstop = end_line(stop);\n\twhile (start <= stop && start <= end - 1) {\n\t\tstart = end_line(start);\n\t\tif (*start == '\\n')\n\t\t\tcnt++;\n\t\tstart++;\n\t}\n\treturn cnt;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47B991(__int64 a1, __int64 a2, int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 result; // rax\n  _QWORD *v8; // rdx\n  int v10; // [rsp+2Ch] [rbp-4h]\n\n  if ( !a3 )\n    *(_QWORD *)(a1 + 24) = 0LL;\n  v10 = sub_40BECF((const char *)a2, 0LL, 10);\n  if ( *(_DWORD *)qword_75D400 || v10 < 0 )\n  {\n    if ( *(_BYTE *)a2 != 45 || *(_BYTE *)(a2 + 1) )\n    {\n      if ( a3 )\n        sub_46E514((__int64)\"bad fd number\", 0LL, v3, v4, v5, v6);\n      v8 = sub_47B950(a2, 0LL, v3, v4, v5, v6);\n      result = a1;\n      *(_QWORD *)(a1 + 24) = v8;\n    }\n    else\n    {\n      result = a1;\n      *(_DWORD *)(a1 + 20) = -1;\n    }\n  }\n  else\n  {\n    result = a1;\n    *(_DWORD *)(a1 + 20) = v10;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\nfixredir(union node *n, const char *text, int err)\n{\n\tint fd;\n\n\tTRACE((\"Fix redir %s %d\\n\", text, err));\n\tif (!err)\n\t\tn->ndup.vname = NULL;\n\n\tfd = bb_strtou(text, NULL, 10);\n\tif (!errno && fd >= 0)\n\t\tn->ndup.dupfd = fd;\n\telse if (LONE_DASH(text))\n\t\tn->ndup.dupfd = -1;\n\telse {\n\t\tif (err)\n\t\t\traise_error_syntax(\"bad fd number\");\n\t\tn->ndup.vname = makename();\n\t}\n}\n\n## Example:\n\n Input code:\nvoid __fastcall __noreturn sub_4CD85D(int a1, _QWORD *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  _QWORD *v6; // [rsp+0h] [rbp-20h]\n  int v7; // [rsp+Ch] [rbp-14h]\n  unsigned int v8; // [rsp+18h] [rbp-8h]\n  int v9; // [rsp+1Ch] [rbp-4h]\n\n  v7 = a1;\n  v8 = getpriority(PRIO_PROCESS, 0);\n  v6 = a2 + 1;\n  if ( !a2[1] )\n  {\n    printf(\"%d\\n\", v8);\n    sub_4F93C9(0LL);\n  }\n  v9 = 10;\n  if ( *(_BYTE *)*v6 == 45 )\n  {\n    if ( *(_BYTE *)(*v6 + 1LL) == 110 )\n    {\n      if ( *(_BYTE *)(*v6 + 2LL) )\n      {\n        *v6 += 2LL;\n        v6 = a2;\n        v7 = a1 + 1;\n      }\n    }\n    else\n    {\n      ++*v6;\n      v6 = a2;\n      v7 = a1 + 1;\n    }\n    if ( v7 <= 3 )\n      sub_407F64();\n    v9 = sub_50B272(v6[1], 3221225472LL, 0x3FFFFFFFLL);\n    v6 += 2;\n  }\n  if ( setpriority(PRIO_PROCESS, 0, v8 + v9) < 0 )\n    sub_4092A2((__int64)\"setpriority(%d)\", v8 + v9, v2, v3, v4, v5);\n  sub_4F931D(v6);\n}\n\n\n Revised code:\nint nice_main(int argc, char **argv)\n{\n\tint old_priority, adjustment;\n\n\told_priority = getpriority(PRIO_PROCESS, 0);\n\n\tif (!*++argv) { /* No args, so (GNU) output current nice value. */\n\t\tprintf(\"%d\\n\", old_priority);\n\t\tfflush_stdout_and_exit(EXIT_SUCCESS);\n\t}\n\n\tadjustment = 10;  /* Set default adjustment. */\n\n\tif (argv[0][0] == '-') {\n\t\tif (argv[0][1] == 'n') { /* -n */\n\t\t\tif (argv[0][2]) { /* -nNNNN (w/o space) */\n\t\t\t\targv[0] += 2; argv--; argc++;\n\t\t\t}\n\t\t} else { /* -NNN (NNN may be negative) == -n NNN */\n\t\t\targv[0] += 1; argv--; argc++;\n\t\t}\n\t\tif (argc < 4) {  /* Missing priority and/or utility! */\n\t\t\tbb_show_usage();\n\t\t}\n\t\tadjustment = xatoi_range(argv[1], INT_MIN/2, INT_MAX/2);\n\t\targv += 2;\n\t}\n\n\t{  /* Set our priority. */\n\t\tint prio = old_priority + adjustment;\n\n\t\tif (setpriority(PRIO_PROCESS, 0, prio) < 0) {\n\t\t\tbb_perror_msg_and_die(\"setpriority(%d)\", prio);\n\t\t}\n\t}\n\n\tBB_EXECVP_or_die(argv);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_50BB7E(_QWORD *a1, int a2, unsigned int a3)\n{\n  __int64 v3; // rsi\n  _WORD *v4; // rax\n  int v7; // [rsp+4h] [rbp-1Ch]\n  int v8; // [rsp+18h] [rbp-8h]\n  int v9; // [rsp+1Ch] [rbp-4h]\n\n  v7 = a2;\n  if ( !a2 )\n  {\n    v3 = a3;\n    v9 = socket(10, a3, 0);\n    if ( v9 >= 0 )\n    {\n      LOWORD(v7) = 10;\nLABEL_8:\n      v8 = 28;\n      goto LABEL_9;\n    }\n    v7 = 2;\n  }\n  v3 = a3;\n  v9 = sub_40A999(v7, a3, 0);\n  v8 = 16;\n  if ( v7 == 1 )\n    v8 = 110;\n  if ( v7 == 10 )\n    goto LABEL_8;\nLABEL_9:\n  v4 = sub_40A0E8(v8 + 4, v3);\n  *(_DWORD *)v4 = v8;\n  v4[2] = v7;\n  *a1 = v4;\n  return (unsigned int)v9;\n}\n"
    },
    {
        "func_name": "o_addstr_with_NUL",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_48153D(__int64 a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  return sub_4814C5(a1, a2, v2);\n}\n\n\n Revised code:\nstatic void o_addstr(o_string *o, const char *str)\n{\n\to_addblock(o, str, strlen(str));\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_48187C(__int64 a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  return sub_48182B(a1, a2, v2);\n}\n\n\n Revised code:\nstatic void o_addQstr(o_string *o, const char *str)\n{\n\to_addQblock(o, str, strlen(str));\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_480D48(const char *a1)\n{\n  int v1; // eax\n\n  v1 = strlen(a1);\n  return sub_480C0A(a1, v1);\n}\n\n\n Revised code:\nstatic int unset_local_var(const char *name)\n{\n\treturn unset_local_var_len(name, strlen(name));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_481571(__int64 a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  return sub_4814C5(a1, a2, v2 + 1);\n}\n"
    },
    {
        "func_name": "addgroup_wrapper",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40D471(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v7; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v8; // [rsp+20h] [rbp-20h]\n  char *v9; // [rsp+38h] [rbp-8h]\n\n  v8 = a2;\n  v7 = a1;\n  sub_40D371((__int64)&v7, a2);\n  v9 = sub_40A6B3(\"x:%u:\", v8, v2, v3, v4, v5);\n  if ( (int)sub_50967B(\"/etc/group\", a1, v9, 0LL) < 0 )\n    exit(1);\n  return sub_50967B(\"/etc/gshadow\", a1, \"!::\", 0LL);\n}\n\n\n Revised code:\nstatic void new_group(char *group, gid_t gid)\n{\n\tstruct group gr;\n\tchar *p;\n\n\t/* make sure gid and group haven't already been allocated */\n\tgr.gr_gid = gid;\n\tgr.gr_name = group;\n\txgroup_study(&gr);\n\n\t/* add entry to group */\n\tp = xasprintf(\"x:%u:\", (unsigned) gr.gr_gid);\n\tif (update_passwd(bb_path_group_file, group, p, NULL) < 0)\n\t\texit(EXIT_FAILURE);\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tfree(p);\n#if ENABLE_FEATURE_SHADOWPASSWDS\n\t/* /etc/gshadow fields:\n\t * 1. Group name.\n\t * 2. Encrypted password.\n\t *    If set, non-members of the group can join the group\n\t *    by typing the password for that group using the newgrp command.\n\t *    If the value is of this field ! then no user is allowed\n\t *    to access the group using the newgrp command. A value of !!\n\t *    is treated the same as a value of ! only it indicates\n\t *    that a password has never been set before. If the value is null,\n\t *    only group members can log into the group.\n\t * 3. Group administrators (comma delimited list).\n\t *    Group members listed here can add or remove group members\n\t *    using the gpasswd command.\n\t * 4. Group members (comma delimited list).\n\t */\n\t/* Ignore errors: if file is missing we assume admin doesn't want it */\n\tupdate_passwd(bb_path_gshadow_file, group, \"!::\", NULL);\n#endif\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_43A1E5(__int64 a1, const char *a2)\n{\n  char v3[48]; // [rsp+10h] [rbp-70h] BYREF\n  char v4[44]; // [rsp+40h] [rbp-40h] BYREF\n  int v5; // [rsp+6Ch] [rbp-14h]\n\n  v5 = sscanf(\n         a2,\n         \"%*d: %32[0-9A-Fa-f]:%X %32[0-9A-Fa-f]:%X %X %lX:%lX %*X:%*X %*X %d %*d %ld \",\n         v4,\n         a1,\n         v3,\n         a1 + 4,\n         a1 + 8,\n         a1 + 80,\n         a1 + 72,\n         a1 + 12,\n         a1 + 88);\n  if ( v5 <= 8 )\n    return 1LL;\n  if ( strlen(v4) <= 8 )\n  {\n    sub_43A0BE(v4, (_WORD *)(a1 + 16));\n    sub_43A0BE(v3, (_WORD *)(a1 + 44));\n  }\n  else\n  {\n    sub_43A037(v4, (_WORD *)(a1 + 16));\n    sub_43A037(v3, (_WORD *)(a1 + 44));\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic int scan_inet_proc_line(struct inet_params *param, char *line)\n{\n\tint num;\n\t/* IPv6 /proc files use 32-char hex representation\n\t * of IPv6 address, followed by :PORT_IN_HEX\n\t */\n\tchar local_addr[33], rem_addr[33]; /* 32 + 1 for NUL */\n\n\tnum = sscanf(line,\n\t\t\t\"%*d: %32[0-9A-Fa-f]:%X \"\n\t\t\t\"%32[0-9A-Fa-f]:%X %X \"\n\t\t\t\"%lX:%lX %*X:%*X \"\n\t\t\t\"%*X %d %*d %ld \",\n\t\t\tlocal_addr, &param->local_port,\n\t\t\trem_addr, &param->rem_port, &param->state,\n\t\t\t&param->txq, &param->rxq,\n\t\t\t&param->uid, &param->inode);\n\tif (num < 9) {\n\t\treturn 1; /* error */\n\t}\n\n\tif (strlen(local_addr) > 8) {\n#if ENABLE_FEATURE_IPV6\n\t\tbuild_ipv6_addr(local_addr, &param->localaddr.sin6);\n\t\tbuild_ipv6_addr(rem_addr, &param->remaddr.sin6);\n#endif\n\t} else {\n\t\tbuild_ipv4_addr(local_addr, &param->localaddr.sin);\n\t\tbuild_ipv4_addr(rem_addr, &param->remaddr.sin);\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_43A583(const char *a1)\n{\n  _BOOL4 v2; // eax\n  const char *v3; // rax\n  char v4[8]; // [rsp+10h] [rbp-70h] BYREF\n  int v5; // [rsp+18h] [rbp-68h]\n  __int16 v6; // [rsp+3Ch] [rbp-44h]\n  int v7; // [rsp+40h] [rbp-40h]\n  int v8; // [rsp+44h] [rbp-3Ch]\n  int v9; // [rsp+48h] [rbp-38h]\n  int v10; // [rsp+4Ch] [rbp-34h]\n  int v11; // [rsp+50h] [rbp-30h]\n  int v12; // [rsp+7Ch] [rbp-4h]\n\n  if ( (unsigned int)sub_43A1E5((__int64)v4, a1) )\n    return 1LL;\n  v2 = v6 == 10 && v10 | v9 | v8 | v11 || v6 == 2 && v7;\n  v12 = v2;\n  v3 = sub_409B8C(v5);\n  sub_43A2EA((__int64)v4, v3, \"raw\", v12);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC raw_do_one(char *line)\n{\n\tint have_remaddr;\n\tstruct inet_params param;\n\n\tif (scan_inet_proc_line(&param, line))\n\t\treturn 1;\n\n\thave_remaddr = NOT_NULL_ADDR(param.remaddr);\n\tprint_inet_line(&param, itoa(param.state), \"raw\", have_remaddr);\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40D7F2(__int64 a1, const char *a2)\n{\n  const char *v3; // [rsp+10h] [rbp-30h] BYREF\n  const char *v4; // [rsp+18h] [rbp-28h]\n  _BYTE *v5; // [rsp+20h] [rbp-20h]\n  const char *v6; // [rsp+28h] [rbp-18h]\n  _BYTE *v7; // [rsp+30h] [rbp-10h]\n  __int64 v8; // [rsp+38h] [rbp-8h]\n\n  v3 = \"addgroup\";\n  if ( a2 )\n  {\n    v4 = \"--\";\n    v5 = *(_BYTE **)a1;\n    v6 = a2;\n    v7 = 0LL;\n  }\n  else\n  {\n    v4 = \"--gid\";\n    v5 = sub_409B63(*(_DWORD *)(a1 + 20));\n    v6 = \"--\";\n    v7 = *(_BYTE **)a1;\n    v8 = 0LL;\n  }\n  return sub_50A624(&v3);\n}\n"
    },
    {
        "func_name": "recover_mode",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_451C40(_DWORD *a1, int a2, const char *a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 v8; // rdx\n  __int64 v9; // rcx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  char *s; // [rsp+8h] [rbp-58h]\n  unsigned int v13; // [rsp+2Ch] [rbp-34h] BYREF\n  char v14[4]; // [rsp+30h] [rbp-30h] BYREF\n  int v15; // [rsp+34h] [rbp-2Ch]\n  char *v16; // [rsp+50h] [rbp-10h]\n  int i; // [rsp+5Ch] [rbp-4h]\n\n  s = (char *)a3;\n  if ( strchr(a3, 46) )\n  {\n    if ( (unsigned int)sub_452DAB(v14, s, 2LL) )\n    {\n      sub_409747(\"\\\"%s\\\" is invalid lladdr\", (__int64)s, v3, v4, v5, v6);\n      return 0xFFFFFFFFLL;\n    }\n    else if ( a2 > 3 )\n    {\n      *a1 = v15;\n      return 4LL;\n    }\n    else\n    {\n      return 0xFFFFFFFFLL;\n    }\n  }\n  else\n  {\n    for ( i = 0; i < a2; ++i )\n    {\n      v16 = strchr(s, 58);\n      if ( v16 )\n        *v16++ = 0;\n      if ( sscanf(s, \"%x\", &v13) != 1 || v13 >= 0x100 )\n      {\n        sub_409747(\"\\\"%s\\\" is invalid lladdr\", (__int64)s, v8, v9, v10, v11);\n        return 0xFFFFFFFFLL;\n      }\n      *((_BYTE *)a1 + i) = v13;\n      if ( !v16 )\n        break;\n      s = v16;\n    }\n    return (unsigned int)(i + 1);\n  }\n}\n\n\n Revised code:\nint FAST_FUNC ll_addr_a2n(unsigned char *lladdr, int len, char *arg)\n{\n\tint i;\n\n\tif (strchr(arg, '.')) {\n\t\tinet_prefix pfx;\n\t\tif (get_addr_1(&pfx, arg, AF_INET)) {\n\t\t\tbb_error_msg(\"\\\"%s\\\" is invalid lladdr\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tif (len < 4) {\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(lladdr, pfx.data, 4);\n\t\treturn 4;\n\t}\n\n\tfor (i = 0; i < len; i++) {\n\t\tint temp;\n\t\tchar *cp = strchr(arg, ':');\n\t\tif (cp) {\n\t\t\t*cp = 0;\n\t\t\tcp++;\n\t\t}\n\t\tif (sscanf(arg, \"%x\", &temp) != 1 || (temp < 0 || temp > 255)) {\n\t\t\tbb_error_msg(\"\\\"%s\\\" is invalid lladdr\", arg);\n\t\t\treturn -1;\n\t\t}\n\t\tlladdr[i] = temp;\n\t\tif (!cp) {\n\t\t\tbreak;\n\t\t}\n\t\targ = cp;\n\t}\n\treturn i+1;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_428FC2(const char *a1, __int64 a2)\n{\n  const char *v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v9; // [rsp+10h] [rbp-20h] BYREF\n  char v10; // [rsp+14h] [rbp-1Ch] BYREF\n  char v11; // [rsp+18h] [rbp-18h] BYREF\n  char v12; // [rsp+1Ch] [rbp-14h] BYREF\n  char v13; // [rsp+20h] [rbp-10h] BYREF\n  char v14; // [rsp+24h] [rbp-Ch] BYREF\n  int i; // [rsp+28h] [rbp-8h]\n  int v16; // [rsp+2Ch] [rbp-4h]\n\n  v2 = \"%2x:%2x:%2x:%2x:%2x:%2x\";\n  v16 = sscanf(a1, \"%2x:%2x:%2x:%2x:%2x:%2x\", &v9, &v10, &v11, &v12, &v13, &v14);\n  if ( v16 <= 3 )\n  {\n    v2 = \"%u.%u.%u.%u\";\n    v16 = sscanf(a1, \"%u.%u.%u.%u\", &v9, &v10, &v11, &v12);\n  }\n  if ( v16 > 3 )\n  {\n    for ( i = 0; i < v16; ++i )\n      *(_BYTE *)(i + a2) = *(&v9 + i);\n    return (unsigned int)v16;\n  }\n  else\n  {\n    sub_409747(\"can't read Wake-On-LAN pass\", (__int64)v2, v3, v4, v5, v6);\n    return 0LL;\n  }\n}\n\n\n Revised code:\nstatic int get_wol_pw(const char *ethoptarg, unsigned char *wol_passwd)\n{\n\tunsigned passwd[6];\n\tint byte_cnt, i;\n\n\t/* handle MAC format */\n\tbyte_cnt = sscanf(ethoptarg, \"%2x:%2x:%2x:%2x:%2x:%2x\",\n\t                  &passwd[0], &passwd[1], &passwd[2],\n\t                  &passwd[3], &passwd[4], &passwd[5]);\n\t/* handle IP format */\n// FIXME: why < 4?? should it be < 6?\n\tif (byte_cnt < 4)\n\t\tbyte_cnt = sscanf(ethoptarg, \"%u.%u.%u.%u\",\n\t\t                  &passwd[0], &passwd[1], &passwd[2], &passwd[3]);\n\tif (byte_cnt < 4) {\n\t\tbb_error_msg(\"can't read Wake-On-LAN pass\");\n\t\treturn 0;\n\t}\n// TODO: check invalid numbers >255??\n\tfor (i = 0; i < byte_cnt; ++i)\n\t\twol_passwd[i] = passwd[i];\n\n\tbb_debug_msg(\"password: %2.2x %2.2x %2.2x %2.2x (%d)\\n\\n\",\n\t             wol_passwd[0], wol_passwd[1], wol_passwd[2], wol_passwd[3],\n\t             byte_cnt);\n\n\treturn byte_cnt;\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_464C09(const char *a1, __int64 a2, char a3)\n{\n  char s[100]; // [rsp+20h] [rbp-210h] BYREF\n  char v5[8]; // [rsp+84h] [rbp-1ACh] BYREF\n  char v6[8]; // [rsp+8Ch] [rbp-1A4h] BYREF\n  char v7[8]; // [rsp+94h] [rbp-19Ch] BYREF\n  char v8[12]; // [rsp+9Ch] [rbp-194h] BYREF\n  char v9[12]; // [rsp+A8h] [rbp-188h] BYREF\n  char v10[109]; // [rsp+B4h] [rbp-17Ch] BYREF\n  __int64 v11; // [rsp+121h] [rbp-10Fh]\n  unsigned int v12; // [rsp+228h] [rbp-8h]\n  int i; // [rsp+22Ch] [rbp-4h]\n\n  memset(s, 0, 0x200uLL);\n  strcpy(s, a1);\n  sprintf(v5, \"%o\", *(_DWORD *)(a2 + 24) & 0x1FF);\n  sprintf(v6, \"%o\", *(_DWORD *)(a2 + 28) & 0x1FFFFF);\n  sprintf(v7, \"%o\", *(_DWORD *)(a2 + 32) & 0x1FFFFF);\n  sprintf(v8, \"%o\", (unsigned int)*(_QWORD *)(a2 + 48));\n  sprintf(v9, \"%llo\", *(_QWORD *)(a2 + 88) & 0x1FFFFFFFFLL);\n  v10[8] = a3;\n  v11 = 0x20207261747375LL;\n  v10[7] = 32;\n  v12 = 224;\n  for ( i = 0; i <= 511; ++i )\n    v12 += (unsigned __int8)s[i];\n  sprintf(v10, \"%06o\", v12);\n  sub_40A4AB(1u, (__int64)s, 512LL);\n}\n\n\n Revised code:\nstatic void writeheader(const char *path, struct stat *sb, int type)\n{\n\tstruct tar_header_t header;\n\tint i, sum;\n\n\tmemset(&header, 0, TAR_BLOCK_SIZE);\n\tstrcpy(header.name, path);\n\tsprintf(header.mode, \"%o\", sb->st_mode & 0777);\n\t/* careful to not overflow fields! */\n\tsprintf(header.uid, \"%o\", sb->st_uid & 07777777);\n\tsprintf(header.gid, \"%o\", sb->st_gid & 07777777);\n\tsprintf(header.size, \"%o\", (unsigned)sb->st_size);\n\tsprintf(header.mtime, \"%llo\", sb->st_mtime & 077777777777LL);\n\theader.typeflag = type;\n\tstrcpy(header.magic, \"ustar  \"); /* like GNU tar */\n\n\t/* Calculate and store the checksum (the sum of all of the bytes of\n\t * the header). The checksum field must be filled with blanks for the\n\t * calculation. The checksum field is formatted differently from the\n\t * other fields: it has 6 digits, a NUL, then a space -- rather than\n\t * digits, followed by a NUL like the other fields... */\n\theader.chksum[7] = ' ';\n\tsum = ' ' * 7;\n\tfor (i = 0; i < TAR_BLOCK_SIZE; i++)\n\t\tsum += ((unsigned char*)&header)[i];\n\tsprintf(header.chksum, \"%06o\", sum);\n\n\txwrite(STDOUT_FILENO, &header, TAR_BLOCK_SIZE);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BOOL8 __fastcall sub_4D38D9(const char *a1, _DWORD *a2)\n{\n  char *s; // [rsp+10h] [rbp-38h]\n  __int64 v4; // [rsp+18h] [rbp-30h] BYREF\n  __int64 v5; // [rsp+20h] [rbp-28h] BYREF\n  __int64 v6; // [rsp+28h] [rbp-20h] BYREF\n  __int64 v7; // [rsp+30h] [rbp-18h] BYREF\n  int v8; // [rsp+3Ch] [rbp-Ch] BYREF\n  int v9; // [rsp+40h] [rbp-8h] BYREF\n  int i; // [rsp+44h] [rbp-4h]\n\n  if ( sscanf(a1, \"%lx:%lx:%lx:%lx%n\", &v7, &v6, &v5, &v4, &v9) != 4 )\n    return 0LL;\n  *a2 = v7;\n  a2[1] = v6;\n  a2[2] = v5;\n  a2[3] = v4;\n  s = (char *)&a1[v9];\n  for ( i = 0; i <= 31; ++i )\n  {\n    if ( sscanf(s, \":%x%n\", &v8, &v9) != 1 )\n      return 0LL;\n    *((_BYTE *)a2 + i + 17) = v8;\n    s += v9;\n  }\n  return *s == 0;\n}\n"
    },
    {
        "func_name": "redraw",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_4CE92F(__int64 a1, char a2)\n{\n  sub_4CE8BB(a1, 32);\n  return sub_4CE8EF(qword_75B228 + a1, a2);\n}\n\n\n Revised code:\nstatic void\nformat_address_label(off_t address, char c)\n{\n\tformat_address_std(address, ' ');\n\tformat_address_paren(address + pseudo_offset, c);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4EFC8F(int a1)\n{\n  sub_4EFC6D();\n  sub_4F03A4(1LL);\n  sub_4EF515(a1);\n  sub_4EFC7E();\n  return sub_4F03A4(1LL);\n}\n\n\n Revised code:\nstatic void flash(int h)\n{\n\tstandout_start();\n\tredraw(TRUE);\n\tmysleep(h);\n\tstandout_end();\n\tredraw(TRUE);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_46A3E2(const char *a1)\n{\n  *(_DWORD *)qword_75D400 = 0;\n  return sub_46A3B4(a1);\n}\n\n\n Revised code:\nstatic void failx(const char *m1)\n{\n\terrno = 0;\n\tfail(m1);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_4F03A4(unsigned int a1)\n{\n  sub_4EFB8B(0, 0);\n  sub_4EFC5C();\n  sub_4EFCF7();\n  *((_DWORD *)qword_75D408 + 19) = 0;\n  sub_4F05FB(a1);\n  return sub_4EFD6C();\n}\n"
    },
    {
        "func_name": "bb_init_module",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_500804(__int64 a1, unsigned int a2)\n{\n  int v2; // eax\n  int v5; // [rsp+18h] [rbp-18h] BYREF\n  char v6[7]; // [rsp+1Dh] [rbp-13h] BYREF\n  char v7[7]; // [rsp+1Eh] [rbp-12h] BYREF\n  int v8; // [rsp+24h] [rbp-Ch]\n  __int64 v9; // [rsp+28h] [rbp-8h]\n\n  v8 = 0;\n  while ( 1 )\n  {\n    v9 = sub_506C17(0LL, a1, a2);\n    if ( *(_DWORD *)qword_75D400 )\n      break;\n    if ( (int)v9 < 0 )\n      return v9;\n    v2 = v8++;\n    v6[v2] = v9;\n    v6[v8] = 0;\n    if ( sub_509315(&v5, v6, 1LL) == 1 )\n      return v5;\n    if ( v8 > 5 )\n      goto LABEL_10;\n    a2 = 50;\n  }\n  if ( *(_DWORD *)qword_75D400 == 11 && v8 )\n  {\nLABEL_10:\n    sub_507024(a1, v7, (unsigned int)(v8 - 1));\n    return 63LL;\n  }\n  return v9;\n}\n\n\n Revised code:\nstatic int lineedit_read_key(char *read_key_buffer, int timeout)\n{\n\tint64_t ic;\n#if ENABLE_UNICODE_SUPPORT\n\tchar unicode_buf[MB_CUR_MAX + 1];\n\tint unicode_idx = 0;\n#endif\n\n\twhile (1) {\n\t\t/* Wait for input. TIMEOUT = -1 makes read_key wait even\n\t\t * on nonblocking stdin, TIMEOUT = 50 makes sure we won't\n\t\t * insist on full MB_CUR_MAX buffer to declare input like\n\t\t * \"\\xff\\n\",pause,\"ls\\n\" invalid and thus won't lose \"ls\".\n\t\t *\n\t\t * Note: read_key sets errno to 0 on success.\n\t\t */\n\t\tic = read_key(STDIN_FILENO, read_key_buffer, timeout);\n\t\tif (errno) {\n#if ENABLE_UNICODE_SUPPORT\n\t\t\tif (errno == EAGAIN && unicode_idx != 0)\n\t\t\t\tgoto pushback;\n#endif\n\t\t\tbreak;\n\t\t}\n\n#if ENABLE_FEATURE_EDITING_ASK_TERMINAL\n\t\tif ((int32_t)ic == KEYCODE_CURSOR_POS\n\t\t && S.sent_ESC_br6n\n\t\t) {\n\t\t\tS.sent_ESC_br6n = 0;\n\t\t\tif (cursor == 0) { /* otherwise it may be bogus */\n\t\t\t\tint col = ((ic >> 32) & 0x7fff) - 1;\n\t\t\t\tif (col > cmdedit_prmt_len) {\n\t\t\t\t\tcmdedit_x += (col - cmdedit_prmt_len);\n\t\t\t\t\twhile (cmdedit_x >= cmdedit_termw) {\n\t\t\t\t\t\tcmdedit_x -= cmdedit_termw;\n\t\t\t\t\t\tcmdedit_y++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n#endif\n\n#if ENABLE_UNICODE_SUPPORT\n\t\tif (unicode_status == UNICODE_ON) {\n\t\t\twchar_t wc;\n\n\t\t\tif ((int32_t)ic < 0) /* KEYCODE_xxx */\n\t\t\t\tbreak;\n\t\t\t// TODO: imagine sequence like: 0xff,<left-arrow>: we are currently losing 0xff...\n\n\t\t\tunicode_buf[unicode_idx++] = ic;\n\t\t\tunicode_buf[unicode_idx] = '\\0';\n\t\t\tif (mbstowcs(&wc, unicode_buf, 1) != 1) {\n\t\t\t\t/* Not (yet?) a valid unicode char */\n\t\t\t\tif (unicode_idx < MB_CUR_MAX) {\n\t\t\t\t\ttimeout = 50;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n pushback:\n\t\t\t\t/* Invalid sequence. Save all \"bad bytes\" except first */\n\t\t\t\tread_key_ungets(read_key_buffer, unicode_buf + 1, unicode_idx - 1);\n# if !ENABLE_UNICODE_PRESERVE_BROKEN\n\t\t\t\tic = CONFIG_SUBST_WCHAR;\n# else\n\t\t\t\tic = unicode_mark_raw_byte(unicode_buf[0]);\n# endif\n\t\t\t} else {\n\t\t\t\t/* Valid unicode char, return its code */\n\t\t\t\tic = wc;\n\t\t\t}\n\t\t}\n#endif\n\t\tbreak;\n\t}\n\n\treturn ic;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4CB5B9(__int64 a1)\n{\n  char *s; // [rsp+8h] [rbp-18h]\n  char v3[8]; // [rsp+10h] [rbp-10h] BYREF\n  unsigned int v4; // [rsp+18h] [rbp-8h]\n  unsigned int v5; // [rsp+1Ch] [rbp-4h]\n\n  s = (char *)sub_502FB1(v3, a1);\n  if ( (dword_75D450 & 0x400) != 0 )\n  {\n    v5 = v4 + 2;\n    putchar_unlocked(34);\n    while ( *s )\n    {\n      if ( *s == 34 || *s == 92 )\n      {\n        putchar_unlocked(92);\n        ++v5;\n      }\n      putchar_unlocked(*s++);\n    }\n    putchar_unlocked(34);\n    return v5;\n  }\n  else\n  {\n    fputs_unlocked(s, stdout);\n    return v4;\n  }\n}\n\n\n Revised code:\nstatic unsigned print_name(const char *name)\n{\n\tunsigned len;\n\tuni_stat_t uni_stat;\n\n\t// TODO: quote tab as \\t, etc, if -Q\n\tname = printable_string(&uni_stat, name);\n\n\tif (!(option_mask32 & OPT_Q)) {\n\t\tfputs(name, stdout);\n\t\treturn uni_stat.unicode_width;\n\t}\n\n\tlen = 2 + uni_stat.unicode_width;\n\tputchar('\"');\n\twhile (*name) {\n\t\tif (*name == '\"' || *name == '\\\\') {\n\t\t\tputchar('\\\\');\n\t\t\tlen++;\n\t\t}\n\t\tputchar(*name);\n\t\tname++;\n\t}\n\tputchar('\"');\n\treturn len;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40C9C5(__int64 a1, const char *a2)\n{\n  char *v3; // rax\n  char *sa; // [rsp+0h] [rbp-30h]\n  char *endptr; // [rsp+10h] [rbp-20h] BYREF\n  unsigned __int64 v7; // [rsp+18h] [rbp-18h]\n  _DWORD *v8; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  for ( i = 0; ; ++i )\n  {\n    v8 = (_DWORD *)((unsigned __int8)byte_5350A7[i] + a1);\n    if ( i <= 1 || i > 3 )\n      break;\n    v7 = strtoul(a2, &endptr, 10);\n    if ( a2 == endptr || *endptr != 58 )\n      return 0xFFFFFFFFLL;\n    sa = endptr;\n    *v8 = v7;\nLABEL_11:\n    v3 = sa;\n    a2 = sa + 1;\n    *v3 = 0;\n  }\n  *(_QWORD *)v8 = a2;\n  if ( i == 6 )\n    return 0LL;\n  sa = strchr(a2, 58);\n  if ( sa )\n    goto LABEL_11;\n  return 0xFFFFFFFFLL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC bb__parsepwent(void *data, char *line)\n{\n\tchar *endptr;\n\tchar *p;\n\tint i;\n\n\ti = 0;\n\twhile (1) {\n\t\tp = (char *) data + pw_off[i];\n\n\t\tif (i < 2 || i > 3) {\n\t\t\t*((char **) p) = line;\n\t\t\tif (i == 6) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* NOTE: glibc difference - glibc allows omission of\n\t\t\t * ':' seperators after the gid field if all remaining\n\t\t\t * entries are empty.  We require all separators. */\n\t\t\tline = strchr(line, ':');\n\t\t\tif (!line) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned long t = strtoul(line, &endptr, 10);\n\t\t\t/* Make sure we had at least one digit, and that the\n\t\t\t * failing char is the next field seperator ':'.  See\n\t\t\t * glibc difference note above. */\n\t\t\t/* TODO: Also check for leading whitespace? */\n\t\t\tif ((endptr == line) || (*endptr != ':')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tline = endptr;\n\t\t\tif (i & 1) {\t\t/* i == 3 -- gid */\n\t\t\t\t*((gid_t *) p) = t;\n\t\t\t} else {\t\t\t/* i == 2 -- uid */\n\t\t\t\t*((uid_t *) p) = t;\n\t\t\t}\n\t\t}\n\n\t\t*line++ = '\\0';\n\t\ti++;\n\t} /* while (1) */\n\n\treturn -1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_426133(__int64 a1, void *a2)\n{\n  void *v3; // [rsp+0h] [rbp-30h]\n  size_t len; // [rsp+18h] [rbp-18h] BYREF\n  unsigned int v5; // [rsp+20h] [rbp-10h]\n  char v6; // [rsp+27h] [rbp-9h]\n  void *addr; // [rsp+28h] [rbp-8h]\n\n  v3 = a2;\n  if ( !a2 )\n    v3 = &unk_52AA22;\n  len = 2147479552LL;\n  v6 = 0;\n  addr = 0LL;\n  *(_DWORD *)qword_75D400 = 12;\n  addr = (void *)sub_4C33AC(a1, &len);\n  if ( !addr )\n    return (unsigned int)-*(_DWORD *)qword_75D400;\n  *(_DWORD *)qword_75D400 = 0;\n  syscall(175LL, addr, len, v3);\n  v5 = *(_DWORD *)qword_75D400;\n  if ( v6 )\n    munmap(addr, len);\n  else\n    free(addr);\n  return v5;\n}\n"
    },
    {
        "func_name": "initialize_context",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_4821E0(__int64 a1, __int64 a2)\n{\n  return sub_40A0E8(0x38uLL, a2);\n}\n\n\n Revised code:\nstatic struct pipe *new_pipe(void)\n{\n\tstruct pipe *pi;\n\tpi = xzalloc(sizeof(struct pipe));\n\t/*pi->followup = 0; - deliberately invalid value */\n\t/*pi->res_word = RES_NONE; - RES_NONE is 0 anyway */\n\treturn pi;\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_4A7E3F(__int64 a1, __int64 a2, int a3, unsigned __int64 a4)\n{\n  return sub_4A7C1E(a1 + 48, 0x41uLL, a2, a3, a4);\n}\n\n\n Revised code:\nvoid volume_id_set_label_unicode16(struct volume_id *id, const uint8_t *buf, enum endian endianess, size_t count)\n{\n\tvolume_id_set_unicode16(id->label, sizeof(id->label), buf, endianess, count);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_436830(__int64 a1, __int64 a2)\n{\n  return sub_4FD5B8(a1, a2, 0LL);\n}\n\n\n Revised code:\nendif\n\nstatic int FAST_FUNC INET_input(/*int type,*/ const char *bufp, struct sockaddr *sap)\n{\n\treturn INET_resolve(bufp, (struct sockaddr_in *) sap, 0);\n/*\n\tswitch (type) {\n\tcase 1:\n\t\treturn (INET_getsock(bufp, sap));\n\tcase 256:\n\t\treturn (INET_resolve(bufp, (struct sockaddr_in *) sap, 1));\n\tdefault:\n\t\treturn (INET_resolve(bufp, (struct sockaddr_in *) sap, 0));\n\t}\n*/\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_482419(void **a1)\n{\n  memset(a1, 0, 0x30uLL);\n  *a1 = sub_4821E0((__int64)a1, 0LL);\n  a1[1] = *a1;\n  return sub_4821FC((__int64)a1);\n}\n"
    },
    {
        "func_name": "crc32_block_endian1",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4F7534(unsigned int a1, _BYTE *a2, int a3, __int64 a4)\n{\n  _BYTE *i; // [rsp+8h] [rbp-20h]\n\n  for ( i = a2; i != &a2[a3]; ++i )\n    a1 = (a1 >> 8) ^ *(_DWORD *)(4LL * (unsigned __int8)(a1 ^ *i) + a4);\n  return a1;\n}\n\n\n Revised code:\nuint32_t FAST_FUNC crc32_block_endian0(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table)\n{\n\tconst void *end = (uint8_t*)buf + len;\n\n\twhile (buf != end) {\n\t\tval = crc_table[(uint8_t)val ^ *(uint8_t*)buf] ^ (val >> 8);\n\t\tbuf = (uint8_t*)buf + 1;\n\t}\n\treturn val;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A8B04(__int64 a1, int a2, int a3, int a4)\n{\n  __int64 result; // rax\n  unsigned int v8; // [rsp+20h] [rbp-4h]\n\n  while ( a4 > 0 )\n  {\n    v8 = *(_DWORD *)(4LL * a2 + a1);\n    *(_DWORD *)(4LL * a2 + a1) = *(_DWORD *)(4LL * a3 + a1);\n    result = v8;\n    *(_DWORD *)(a1 + 4LL * a3) = v8;\n    ++a2;\n    ++a3;\n    --a4;\n  }\n  return result;\n}\n\n\n Revised code:\nvoid mvswap(uint32_t* ptr, int32_t zzp1, int32_t zzp2, int32_t zzn)\n{\n\twhile (zzn > 0) {\n\t\tmswap(ptr[zzp1], ptr[zzp2]);\n\t\tzzp1++;\n\t\tzzp2++;\n\t\tzzn--;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_459B24(__int64 a1)\n{\n  unsigned int i; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; *(_BYTE *)((int)i + a1) != 0xFF; ++i )\n  {\n    if ( *(_BYTE *)((int)i + a1) )\n      i += *(unsigned __int8 *)((int)i + 1LL + a1) + 1;\n  }\n  return i;\n}\n\n\n Revised code:\nint FAST_FUNC udhcp_end_option(uint8_t *optionptr)\n{\n\tint i = 0;\n\n\twhile (optionptr[i] != DHCP_END) {\n\t\tif (optionptr[i] != DHCP_PADDING)\n\t\t\ti += optionptr[i + OPT_LEN] + OPT_DATA-1;\n\t\ti++;\n\t}\n\treturn i;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4F74CA(unsigned int a1, unsigned __int8 *a2, int a3, __int64 a4)\n{\n  unsigned __int8 *i; // [rsp+8h] [rbp-20h]\n\n  for ( i = a2; i != &a2[a3]; ++i )\n    a1 = (a1 << 8) ^ *(_DWORD *)(4LL * (HIBYTE(a1) ^ *i) + a4);\n  return a1;\n}\n"
    },
    {
        "func_name": "sprint_nip6",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_BOOL8 __fastcall sub_4D38D9(const char *a1, _DWORD *a2)\n{\n  char *s; // [rsp+10h] [rbp-38h]\n  __int64 v4; // [rsp+18h] [rbp-30h] BYREF\n  __int64 v5; // [rsp+20h] [rbp-28h] BYREF\n  __int64 v6; // [rsp+28h] [rbp-20h] BYREF\n  __int64 v7; // [rsp+30h] [rbp-18h] BYREF\n  int v8; // [rsp+3Ch] [rbp-Ch] BYREF\n  int v9; // [rsp+40h] [rbp-8h] BYREF\n  int i; // [rsp+44h] [rbp-4h]\n\n  if ( sscanf(a1, \"%lx:%lx:%lx:%lx%n\", &v7, &v6, &v5, &v4, &v9) != 4 )\n    return 0LL;\n  *a2 = v7;\n  a2[1] = v6;\n  a2[2] = v5;\n  a2[3] = v4;\n  s = (char *)&a1[v9];\n  for ( i = 0; i <= 31; ++i )\n  {\n    if ( sscanf(s, \":%x%n\", &v8, &v9) != 1 )\n      return 0LL;\n    *((_BYTE *)a2 + i + 17) = v8;\n    s += v9;\n  }\n  return *s == 0;\n}\n\n\n Revised code:\nstatic int recover_mode(const char *arg, struct termios *mode)\n{\n\tint i, n;\n\tunsigned chr;\n\tunsigned long iflag, oflag, cflag, lflag;\n\n\t/* Scan into temporaries since it is too much trouble to figure out\n\t   the right format for 'tcflag_t' */\n\tif (sscanf(arg, \"%lx:%lx:%lx:%lx%n\",\n\t\t\t   &iflag, &oflag, &cflag, &lflag, &n) != 4)\n\t\treturn 0;\n\tmode->c_iflag = iflag;\n\tmode->c_oflag = oflag;\n\tmode->c_cflag = cflag;\n\tmode->c_lflag = lflag;\n\targ += n;\n\tfor (i = 0; i < NCCS; ++i) {\n\t\tif (sscanf(arg, \":%x%n\", &chr, &n) != 1)\n\t\t\treturn 0;\n\t\tmode->c_cc[i] = chr;\n\t\targ += n;\n\t}\n\n\t/* Fail if there are too many fields */\n\tif (*arg != '\\0')\n\t\treturn 0;\n\n\treturn 1;\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_464C09(const char *a1, __int64 a2, char a3)\n{\n  char s[100]; // [rsp+20h] [rbp-210h] BYREF\n  char v5[8]; // [rsp+84h] [rbp-1ACh] BYREF\n  char v6[8]; // [rsp+8Ch] [rbp-1A4h] BYREF\n  char v7[8]; // [rsp+94h] [rbp-19Ch] BYREF\n  char v8[12]; // [rsp+9Ch] [rbp-194h] BYREF\n  char v9[12]; // [rsp+A8h] [rbp-188h] BYREF\n  char v10[109]; // [rsp+B4h] [rbp-17Ch] BYREF\n  __int64 v11; // [rsp+121h] [rbp-10Fh]\n  unsigned int v12; // [rsp+228h] [rbp-8h]\n  int i; // [rsp+22Ch] [rbp-4h]\n\n  memset(s, 0, 0x200uLL);\n  strcpy(s, a1);\n  sprintf(v5, \"%o\", *(_DWORD *)(a2 + 24) & 0x1FF);\n  sprintf(v6, \"%o\", *(_DWORD *)(a2 + 28) & 0x1FFFFF);\n  sprintf(v7, \"%o\", *(_DWORD *)(a2 + 32) & 0x1FFFFF);\n  sprintf(v8, \"%o\", (unsigned int)*(_QWORD *)(a2 + 48));\n  sprintf(v9, \"%llo\", *(_QWORD *)(a2 + 88) & 0x1FFFFFFFFLL);\n  v10[8] = a3;\n  v11 = 0x20207261747375LL;\n  v10[7] = 32;\n  v12 = 224;\n  for ( i = 0; i <= 511; ++i )\n    v12 += (unsigned __int8)s[i];\n  sprintf(v10, \"%06o\", v12);\n  sub_40A4AB(1u, (__int64)s, 512LL);\n}\n\n\n Revised code:\nstatic void writeheader(const char *path, struct stat *sb, int type)\n{\n\tstruct tar_header_t header;\n\tint i, sum;\n\n\tmemset(&header, 0, TAR_BLOCK_SIZE);\n\tstrcpy(header.name, path);\n\tsprintf(header.mode, \"%o\", sb->st_mode & 0777);\n\t/* careful to not overflow fields! */\n\tsprintf(header.uid, \"%o\", sb->st_uid & 07777777);\n\tsprintf(header.gid, \"%o\", sb->st_gid & 07777777);\n\tsprintf(header.size, \"%o\", (unsigned)sb->st_size);\n\tsprintf(header.mtime, \"%llo\", sb->st_mtime & 077777777777LL);\n\theader.typeflag = type;\n\tstrcpy(header.magic, \"ustar  \"); /* like GNU tar */\n\n\t/* Calculate and store the checksum (the sum of all of the bytes of\n\t * the header). The checksum field must be filled with blanks for the\n\t * calculation. The checksum field is formatted differently from the\n\t * other fields: it has 6 digits, a NUL, then a space -- rather than\n\t * digits, followed by a NUL like the other fields... */\n\theader.chksum[7] = ' ';\n\tsum = ' ' * 7;\n\tfor (i = 0; i < TAR_BLOCK_SIZE; i++)\n\t\tsum += ((unsigned char*)&header)[i];\n\tsprintf(header.chksum, \"%06o\", sum);\n\n\txwrite(STDOUT_FILENO, &header, TAR_BLOCK_SIZE);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_42FB55(const char *a1, int a2)\n{\n  char v3[16]; // [rsp+10h] [rbp-30h] BYREF\n  int v4; // [rsp+20h] [rbp-20h]\n\n  v4 = a2;\n  return sub_42FA47(0x8922u, v3, a1);\n}\n\n\n Revised code:\nstatic int set_mtu(char *ifname, int mtu)\n{\n\tstruct ifreq ifr;\n\n\tifr.ifr_mtu = mtu;\n\treturn set_ifrname_and_do_ioctl(SIOCSIFMTU, &ifr, ifname);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_45A51D(char *a1, char *a2)\n{\n  char v3[4]; // [rsp+10h] [rbp-20h] BYREF\n  char v4[4]; // [rsp+14h] [rbp-1Ch] BYREF\n  char v5[4]; // [rsp+18h] [rbp-18h] BYREF\n  char v6[4]; // [rsp+1Ch] [rbp-14h] BYREF\n  char v7[4]; // [rsp+20h] [rbp-10h] BYREF\n  char v8[4]; // [rsp+24h] [rbp-Ch] BYREF\n  char v9[4]; // [rsp+28h] [rbp-8h] BYREF\n  char v10[4]; // [rsp+2Ch] [rbp-4h] BYREF\n\n  sub_409BB5(v3, a2, 16);\n  return sprintf(a1, \"%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s:%.4s\", v3, v4, v5, v6, v7, v8, v9, v10);\n}\n"
    },
    {
        "func_name": "blocking_wait_with_raise_on_sig",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 sub_43708E()\n{\n  unsigned int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_436F0A(0LL);\n  if ( !v1 )\n    return (unsigned int)sub_436DF6();\n  return v1;\n}\n\n\n Revised code:\nstatic int if_readlist(void)\n{\n\tint err = if_readlist_proc(NULL);\n\t/* Needed in order to get ethN:M aliases */\n\tif (!err)\n\t\terr = if_readconf();\n\treturn err;\n}\n\n## Example:\n\n Input code:\n__int64 sub_47813F()\n{\n  unsigned int v1; // [rsp+4h] [rbp-1Ch]\n  __int64 v2; // [rsp+8h] [rbp-18h]\n  char v3; // [rsp+13h] [rbp-Dh]\n  int v4; // [rsp+14h] [rbp-Ch]\n  _BYTE *v5; // [rsp+18h] [rbp-8h]\n\n  v3 = byte_75AF50;\n  *(_BYTE *)(qword_75D418 + 53) = 0;\n  v4 = 1;\n  v5 = (_BYTE *)(qword_75D418 + 136);\n  while ( v4 <= 64 )\n  {\n    if ( *v5 )\n    {\n      v2 = *(_QWORD *)(qword_75D418 + 8 * (v4 + 26LL));\n      if ( v4 != 2 || v2 )\n      {\n        *v5 = 0;\n        if ( v2 )\n        {\n          v1 = sub_47DE2C(v2, 16LL);\n          byte_75AF50 = v3;\n          if ( v1 )\n            return v1;\n        }\n      }\n    }\n    ++v4;\n    ++v5;\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic int\ndotrap(void)\n{\n\tuint8_t *g;\n\tint sig;\n\tuint8_t savestatus;\n\n\tsavestatus = exitstatus;\n\tpending_sig = 0;\n\txbarrier();\n\n\tTRACE((\"dotrap entered\\n\"));\n\tfor (sig = 1, g = gotsig; sig < NSIG; sig++, g++) {\n\t\tint want_exexit;\n\t\tchar *t;\n\n\t\tif (*g == 0)\n\t\t\tcontinue;\n\t\tt = trap[sig];\n\t\t/* non-trapped SIGINT is handled separately by raise_interrupt,\n\t\t * don't upset it by resetting gotsig[SIGINT-1] */\n\t\tif (sig == SIGINT && !t)\n\t\t\tcontinue;\n\n\t\tTRACE((\"sig %d is active, will run handler '%s'\\n\", sig, t));\n\t\t*g = 0;\n\t\tif (!t)\n\t\t\tcontinue;\n\t\twant_exexit = evalstring(t, SKIPEVAL);\n\t\texitstatus = savestatus;\n\t\tif (want_exexit) {\n\t\t\tTRACE((\"dotrap returns %d\\n\", want_exexit));\n\t\t\treturn want_exexit;\n\t\t}\n\t}\n\n\tTRACE((\"dotrap returns 0\\n\"));\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 sub_47DC18()\n{\n  int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_47DB13();\n  byte_75B059 = 1;\n  return *(unsigned __int8 *)*(&off_51D220 + v1);\n}\n\n\n Revised code:\nstatic char\npeektoken(void)\n{\n\tint t;\n\n\tt = readtoken();\n\ttokpushback = 1;\n\treturn tokname_array[t][0];\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_471AA3()\n{\n  int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_4718A4(0, 0LL);\n  if ( v1 <= 0 && *(_BYTE *)(qword_75D418 + 53) )\n    sub_46DF6F(5);\n  return (unsigned int)v1;\n}\n"
    },
    {
        "func_name": "fgcolor",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4CB48C(unsigned __int16 a1)\n{\n  if ( (a1 & 0xF000) == 0x8000 && (a1 & 0x49) != 0 )\n    return 1LL;\n  else\n    return (unsigned __int8)byte_522C75[a1 >> 12];\n}\n\n\n Revised code:\nstatic char bold(mode_t mode)\n{\n\tif (S_ISREG(mode) && (mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n\t\treturn ATTR(0xF000);\t/* File is executable ... */\n\treturn ATTR(mode);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4CB4C7(unsigned __int16 a1)\n{\n  if ( (dest.c_oflag & 0x800) == 0 )\n    return 0LL;\n  if ( (a1 & 0xF000) == 0x4000 )\n    return 47LL;\n  if ( (dest.c_oflag & 0x1000) == 0 )\n    return 0LL;\n  if ( (a1 & 0xF000) == 0x8000 && (a1 & 0x49) != 0 )\n    return 42LL;\n  return (unsigned __int8)byte_522C86[a1 >> 12];\n}\n\n\n Revised code:\nif ENABLE_FEATURE_LS_FILETYPES\nstatic char append_char(mode_t mode)\n{\n\tif (!(G.all_fmt & LIST_FILETYPE))\n\t\treturn '\\0';\n\tif (S_ISDIR(mode))\n\t\treturn '/';\n\tif (!(G.all_fmt & LIST_CLASSIFY))\n\t\treturn '\\0';\n\tif (S_ISREG(mode) && (mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n\t\treturn '*';\n\treturn APPCHAR(mode);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4D3466(unsigned int a1, __int64 a2)\n{\n  if ( a1 > 3 )\n    return 0LL;\n  else\n    return (unsigned __int8)byte_524194[a1] + a2;\n}\n\n\n Revised code:\nstatic tcflag_t *mode_type_flag(unsigned type, const struct termios *mode)\n{\n\tstatic const uint8_t tcflag_offsets[] ALIGN1 = {\n\t\toffsetof(struct termios, c_cflag), /* control */\n\t\toffsetof(struct termios, c_iflag), /* input */\n\t\toffsetof(struct termios, c_oflag), /* output */\n\t\toffsetof(struct termios, c_lflag)  /* local */\n\t};\n\n\tif (type <= local) {\n\t\treturn (tcflag_t*) (((char*)mode) + tcflag_offsets[type]);\n\t}\n\treturn NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4CB451(unsigned __int16 a1)\n{\n  if ( (a1 & 0xF000) == 0x8000 && (a1 & 0x49) != 0 )\n    return 32LL;\n  else\n    return (unsigned __int8)byte_522C64[a1 >> 12];\n}\n"
    },
    {
        "func_name": "xrealloc_getcwd_or_warn",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_489210(__int64 a1)\n{\n  const char *v1; // rax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  char *v7; // [rsp+10h] [rbp-10h]\n  char *path; // [rsp+18h] [rbp-8h]\n\n  path = *(char **)sub_48914D(a1);\n  if ( !path )\n  {\n    v7 = sub_4807EA(\"HOME\");\n    if ( v7 )\n      v1 = v7;\n    else\n      v1 = \"/\";\n    path = (char *)v1;\n  }\n  if ( chdir(path) )\n  {\n    sub_4091D9((__int64)\"cd: %s\", (__int64)path, v2, v3, v4, v5);\n    return 1LL;\n  }\n  else\n  {\n    sub_480BCB(0);\n    return 0LL;\n  }\n}\n\n\n Revised code:\nstatic int FAST_FUNC builtin_cd(char **argv)\n{\n\tconst char *newdir;\n\n\targv = skip_dash_dash(argv);\n\tnewdir = argv[0];\n\tif (newdir == NULL) {\n\t\t/* bash does nothing (exitcode 0) if HOME is \"\"; if it's unset,\n\t\t * bash says \"bash: cd: HOME not set\" and does nothing\n\t\t * (exitcode 1)\n\t\t */\n\t\tconst char *home = get_local_var_value(\"HOME\");\n\t\tnewdir = home ? home : \"/\";\n\t}\n\tif (chdir(newdir)) {\n\t\t/* Mimic bash message exactly */\n\t\tbb_perror_msg(\"cd: %s\", newdir);\n\t\treturn EXIT_FAILURE;\n\t}\n\t/* Read current dir (get_cwd(1) is inside) and set PWD.\n\t * Note: do not enforce exporting. If PWD was unset or unexported,\n\t * set it again, but do not export. bash does the same.\n\t */\n\tset_pwd_var(/*exp:*/ 0);\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4F680B(const char *a1, char a2)\n{\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  unsigned int v6; // [rsp+1Ch] [rbp-4h]\n\n  v6 = *(_DWORD *)qword_75D400;\n  if ( (a2 & 0x10) != 0 )\n  {\n    fprintf(stderr, \"%s: overwrite '%s'? \", ident, a1);\n    if ( !sub_4F5F18() )\n      return 0LL;\n  }\n  if ( unlink(a1) >= 0 )\n    return 1LL;\n  *(_DWORD *)qword_75D400 = v6;\n  sub_4091D9((__int64)\"can't create '%s'\", (__int64)a1, v6, v3, v4, v5);\n  return 0xFFFFFFFFLL;\n}\n\n\n Revised code:\nstatic int ask_and_unlink(const char *dest, int flags)\n{\n\tint e = errno;\n\n#if !ENABLE_FEATURE_NON_POSIX_CP\n\tif (!(flags & (FILEUTILS_FORCE|FILEUTILS_INTERACTIVE))) {\n\t\t/* Either it exists, or the *path* doesnt exist */\n\t\tbb_perror_msg(\"can't create '%s'\", dest);\n\t\treturn -1;\n\t}\n#endif\n\t// else: act as if -f is always in effect.\n\t// We don't want \"can't create\" msg, we want unlink to be done\n\t// (silently unless -i). Why? POSIX cp usually succeeds with\n\t// O_TRUNC open of existing file, and user is left ignorantly happy.\n\t// With above block unconditionally enabled, non-POSIX cp\n\t// will complain a lot more than POSIX one.\n\n\t/* TODO: maybe we should do it only if ctty is present? */\n\tif (flags & FILEUTILS_INTERACTIVE) {\n\t\t// We would not do POSIX insanity. -i asks,\n\t\t// then _unlinks_ the offender. Presto.\n\t\t// (No \"opening without O_EXCL\", no \"unlink only if -f\")\n\t\t// Or else we will end up having 3 open()s!\n\t\tfprintf(stderr, \"%s: overwrite '%s'? \", applet_name, dest);\n\t\tif (!bb_ask_confirmation())\n\t\t\treturn 0; /* not allowed to overwrite */\n\t}\n\tif (unlink(dest) < 0) {\n#if ENABLE_FEATURE_VERBOSE_CP_MESSAGE\n\t\tif (e == errno && e == ENOENT) {\n\t\t\t/* e == ENOTDIR is similar: path has non-dir component,\n\t\t\t * but in this case we don't even reach copy_file() */\n\t\t\tbb_error_msg(\"can't create '%s': Path does not exist\", dest);\n\t\t\treturn -1; /* error */\n\t\t}\n#endif\n\t\terrno = e; /* do not use errno from unlink */\n\t\tbb_perror_msg(\"can't create '%s'\", dest);\n\t\treturn -1; /* error */\n\t}\n\treturn 1; /* ok (to try again) */\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_408E19(void *a1, _BYTE *a2)\n{\n  int v2; // r8d\n  int v3; // r9d\n  const char *v4; // rsi\n  void *v7; // [rsp+8h] [rbp-18h]\n  __int64 v8; // [rsp+18h] [rbp-8h]\n\n  v7 = a1;\n  if ( !a1 )\n    v7 = &unk_534FA3;\n  v8 = sub_408F79(v7, 47LL);\n  while ( *a2 == 47 )\n    ++a2;\n  if ( v8 )\n    v4 = (const char *)&unk_534FA3;\n  else\n    v4 = \"/\";\n  return sub_40A6B3((unsigned int)\"%s%s%s\", (_DWORD)v7, (_DWORD)v4, (_DWORD)a2, v2, v3);\n}\n\n\n Revised code:\nFAST_FUNC concat_path_file(const char *path, const char *filename)\n{\n\tchar *lc;\n\n\tif (!path)\n\t\tpath = \"\";\n\tlc = last_char_is(path, '/');\n\twhile (*filename == '/')\n\t\tfilename++;\n\treturn xasprintf(\"%s%s%s\", path, (lc==NULL ? \"/\" : \"\"), filename);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_50BFFD(void *a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  size_t v6; // rax\n  unsigned int size; // [rsp+1Ch] [rbp-4h]\n\n  size = 128;\n  while ( 1 )\n  {\n    size += 64;\n    a1 = sub_40A09E(a1, size);\n    if ( getcwd((char *)a1, size) )\n      break;\n    if ( *(_DWORD *)qword_75D400 != 34 )\n    {\n      free(a1);\n      sub_4091D9((__int64)\"getcwd\", size, v1, v2, v3, v4);\n      return 0LL;\n    }\n  }\n  v6 = strlen((const char *)a1);\n  return sub_40A09E(a1, v6 + 1);\n}\n"
    },
    {
        "func_name": "logdir_close",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E7583(int a1, const void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  int v7; // [rsp+8h] [rbp-18h]\n  _QWORD *ptr; // [rsp+10h] [rbp-10h]\n  char *v9; // [rsp+18h] [rbp-8h]\n\n  v7 = a3;\n  if ( a1 <= 0 || a1 > *((_DWORD *)qword_75D408 + 1) + 1 )\n  {\n    sub_409747(\"inserting at bad line number\", (__int64)a2, a3, a4, a5, a6, a2);\n    return 0LL;\n  }\n  ptr = sub_40A05F((int)a3 + 23LL, (__int64)a2);\n  memcpy((char *)ptr + 20, a2, v7);\n  *((_DWORD *)ptr + 4) = v7;\n  if ( a1 <= *((_DWORD *)qword_75D408 + 1) )\n  {\n    v9 = (char *)sub_4E78F6((unsigned int)a1);\n    if ( !v9 )\n    {\n      free(ptr);\n      return 0LL;\n    }\n  }\n  else\n  {\n    v9 = (char *)qword_75D408 + 48;\n  }\n  *ptr = v9;\n  ptr[1] = *((_QWORD *)v9 + 1);\n  **((_QWORD **)v9 + 1) = ptr;\n  *((_QWORD *)v9 + 1) = ptr;\n  ++*((_DWORD *)qword_75D408 + 1);\n  *((_BYTE *)qword_75D408 + 72) = 1;\n  return sub_4E7A44((unsigned int)a1);\n}\n\n\n Revised code:\nstatic int insertLine(int num, const char *data, int len)\n{\n\tLINE *newLp, *lp;\n\n\tif ((num < 1) || (num > lastNum + 1)) {\n\t\tbb_error_msg(\"inserting at bad line number\");\n\t\treturn FALSE;\n\t}\n\n\tnewLp = xmalloc(sizeof(LINE) + len - 1);\n\n\tmemcpy(newLp->data, data, len);\n\tnewLp->len = len;\n\n\tif (num > lastNum)\n\t\tlp = &lines;\n\telse {\n\t\tlp = findLine(num);\n\t\tif (lp == NULL) {\n\t\t\tfree((char *) newLp);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tnewLp->next = lp;\n\tnewLp->prev = lp->prev;\n\tlp->prev->next = newLp;\n\tlp->prev = newLp;\n\n\tlastNum++;\n\tdirty = TRUE;\n\treturn setCurNum(num);\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_40E349(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  _QWORD *v6; // rbx\n  __int64 v7; // rdx\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  char *v11; // rax\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  char *result; // rax\n  char *v17; // [rsp+8h] [rbp-18h]\n\n  if ( **((_BYTE **)qword_75D408 + 3) == 45 && !*(_BYTE *)(*((_QWORD *)qword_75D408 + 3) + 1LL) )\n  {\n    if ( (fcntl(0, 3) & 3) != 2 )\n      sub_40969E(\"stdin is not open for read/write\", 3LL, v7, v8, v9, v10);\n    v17 = sub_40AD9A(0, 3LL);\n    if ( v17 )\n      *((_QWORD *)qword_75D408 + 3) = v17;\n  }\n  else\n  {\n    if ( **((_BYTE **)qword_75D408 + 3) != 47 )\n    {\n      v6 = qword_75D408;\n      v6[3] = sub_40A6B3(\"/dev/%s\", *((_QWORD *)qword_75D408 + 3), a3, a4, a5, a6);\n    }\n    close(0);\n    sub_40A295(*((const char **)qword_75D408 + 3), 2050);\n    fchown(0, 0, 0);\n    fchmod(0, 0x190u);\n  }\n  v11 = sub_40941B(*((const char **)qword_75D408 + 3));\n  result = sub_40A6B3(\"getty: %s\", (__int64)v11, v12, v13, v14, v15);\n  ident = result;\n  return result;\n}\n\n\n Revised code:\nstatic void open_tty(void)\n{\n\t/* Set up new standard input, unless we are given an already opened port */\n\tif (NOT_LONE_DASH(G.tty_name)) {\n\t\tif (G.tty_name[0] != '/')\n\t\t\tG.tty_name = xasprintf(\"/dev/%s\", G.tty_name); /* will leak it */\n\n\t\t/* Open the tty as standard input */\n\t\tdebug(\"open(2)\\n\");\n\t\tclose(0);\n\t\txopen(G.tty_name, O_RDWR | O_NONBLOCK); /* uses fd 0 */\n\n\t\t/* Set proper protections and ownership */\n\t\tfchown(0, 0, 0);        /* 0:0 */\n\t\tfchmod(0, 0620);        /* crw--w---- */\n\t} else {\n\t\tchar *n;\n\t\t/*\n\t\t * Standard input should already be connected to an open port.\n\t\t * Make sure it is open for read/write.\n\t\t */\n\t\tif ((fcntl(0, F_GETFL) & (O_RDWR|O_RDONLY|O_WRONLY)) != O_RDWR)\n\t\t\tbb_error_msg_and_die(\"stdin is not open for read/write\");\n\n\t\t/* Try to get real tty name instead of \"-\" */\n\t\tn = xmalloc_ttyname(0);\n\t\tif (n)\n\t\t\tG.tty_name = n;\n\t}\n\tapplet_name = xasprintf(\"getty: %s\", skip_dev_pfx(G.tty_name));\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B52FD(int a1, int a2, unsigned int a3, _QWORD *a4, __int64 a5, unsigned int a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  __int64 v10; // rdx\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  __int64 v13; // r9\n  int v19; // [rsp+2Ch] [rbp-C4h] BYREF\n  int fd[2]; // [rsp+30h] [rbp-C0h] BYREF\n  __int64 v21; // [rsp+38h] [rbp-B8h]\n  __int64 v22; // [rsp+40h] [rbp-B0h]\n  struct stat64 v23; // [rsp+50h] [rbp-A0h] BYREF\n  unsigned int v24; // [rsp+ECh] [rbp-4h]\n\n  v24 = 0;\n  v22 = 0LL;\n  fd[0] = a1;\n  fd[1] = a2;\n  sub_40AAE7(a1, &v23, (__int64)\"can't stat tar file\");\n  if ( a6 )\n    sub_4B51EC(fd[0], a6);\n  v21 = a5;\n  while ( a4 )\n  {\n    if ( !(unsigned int)sub_50752C(a4[1], a3, sub_4B4FB0, sub_4B4FB0, fd, 0LL) )\n      v24 = 1;\n    a4 = (_QWORD *)*a4;\n  }\n  memset(&dest, 0, 0x400uLL);\n  sub_40A4AB(fd[0], (__int64)&dest, 1024LL);\n  close(fd[0]);\n  if ( v24 )\n    sub_409747(\"error exit delayed from previous errors\", (__int64)&dest, v6, v7, v8, v9);\n  if ( a6 )\n  {\n    if ( (unsigned int)sub_409F48(-1, &v19, 0) == -1 )\n    {\n      sub_4091D9((__int64)\"waitpid\", (__int64)&v19, v10, v11, v12, v13);\n    }\n    else if ( (v19 & 0x7F) != 0 || BYTE1(v19) )\n    {\n      return 1;\n    }\n  }\n  return v24;\n}\n\n\n Revised code:\nstatic NOINLINE int writeTarFile(int tar_fd, int verboseFlag,\n\tint recurseFlags, const llist_t *include,\n\tconst llist_t *exclude, int gzip)\n{\n\tint errorFlag = FALSE;\n\tstruct TarBallInfo tbInfo;\n\n\ttbInfo.hlInfoHead = NULL;\n\ttbInfo.tarFd = tar_fd;\n\ttbInfo.verboseFlag = verboseFlag;\n\n\t/* Store the stat info for the tarball's file, so\n\t * can avoid including the tarball into itself....  */\n\txfstat(tbInfo.tarFd, &tbInfo.tarFileStatBuf, \"can't stat tar file\");\n\n#if ENABLE_FEATURE_SEAMLESS_GZ || ENABLE_FEATURE_SEAMLESS_BZ2\n\tif (gzip)\n\t\tvfork_compressor(tbInfo.tarFd, gzip);\n#endif\n\n\ttbInfo.excludeList = exclude;\n\n\t/* Read the directory/files and iterate over them one at a time */\n\twhile (include) {\n\t\tif (!recursive_action(include->data, recurseFlags,\n\t\t\t\twriteFileToTarball, writeFileToTarball, &tbInfo, 0)\n\t\t) {\n\t\t\terrorFlag = TRUE;\n\t\t}\n\t\tinclude = include->link;\n\t}\n\t/* Write two empty blocks to the end of the archive */\n\tmemset(block_buf, 0, 2*TAR_BLOCK_SIZE);\n\txwrite(tbInfo.tarFd, block_buf, 2*TAR_BLOCK_SIZE);\n\n\t/* To be pedantically correct, we would check if the tarball\n\t * is smaller than 20 tar blocks, and pad it if it was smaller,\n\t * but that isn't necessary for GNU tar interoperability, and\n\t * so is considered a waste of space */\n\n\t/* Close so the child process (if any) will exit */\n\tclose(tbInfo.tarFd);\n\n\t/* Hang up the tools, close up shop, head home */\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tfreeHardLinkInfo(&tbInfo.hlInfoHead);\n\n\tif (errorFlag)\n\t\tbb_error_msg(\"error exit delayed from previous errors\");\n\n#if ENABLE_FEATURE_SEAMLESS_GZ || ENABLE_FEATURE_SEAMLESS_BZ2\n\tif (gzip) {\n\t\tint status;\n\t\tif (safe_waitpid(-1, &status, 0) == -1)\n\t\t\tbb_perror_msg(\"waitpid\");\n\t\telse if (!WIFEXITED(status) || WEXITSTATUS(status))\n\t\t\t/* gzip was killed or has exited with nonzero! */\n\t\t\terrorFlag = TRUE;\n\t}\n#endif\n\treturn errorFlag;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_46C370(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 result; // rax\n  __int64 v7; // rdx\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  __int64 v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  __int64 v14; // r9\n\n  result = *(unsigned int *)(a1 + 48);\n  if ( (_DWORD)result != -1 )\n  {\n    if ( *((_DWORD *)qword_75D408 + 2) )\n      sub_409747(\"info: close: %s\", *(_QWORD *)(a1 + 16), a3, a4, a5, a6);\n    close(*(_DWORD *)(a1 + 48));\n    *(_DWORD *)(a1 + 48) = -1;\n    result = *(unsigned int *)(a1 + 52);\n    if ( (_DWORD)result != -1 )\n    {\n      while ( fflush(*(FILE **)(a1 + 56)) || fsync(*(_DWORD *)(a1 + 52)) == -1 )\n        sub_46B2B6((__int64)\"fsync current logfile\", *(_QWORD *)(a1 + 16), v7, v8, v9, v10);\n      while ( fchmod(*(_DWORD *)(a1 + 52), 0x1E4u) == -1 )\n        sub_46B2B6((__int64)\"set mode of current\", *(_QWORD *)(a1 + 16), v11, v12, v13, v14);\n      fclose(*(FILE **)(a1 + 56));\n      *(_DWORD *)(a1 + 52) = -1;\n      result = *(unsigned int *)(a1 + 64);\n      if ( (_DWORD)result != -1 )\n      {\n        close(*(_DWORD *)(a1 + 64));\n        *(_DWORD *)(a1 + 64) = -1;\n        free(*(void **)(a1 + 8));\n        result = a1;\n        *(_QWORD *)(a1 + 8) = 0LL;\n      }\n    }\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "change_units",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4806DD(int a1)\n{\n  _QWORD *v1; // rbx\n\n  if ( a1 || !*((_QWORD *)qword_75D408 + 14) )\n  {\n    if ( *((char **)qword_75D408 + 14) == \"(unknown)\" )\n      *((_QWORD *)qword_75D408 + 14) = 0LL;\n    v1 = qword_75D408;\n    v1[14] = sub_50BFFD(*((_QWORD *)qword_75D408 + 14));\n    if ( !*((_QWORD *)qword_75D408 + 14) )\n      *((_QWORD *)qword_75D408 + 14) = \"(unknown)\";\n  }\n  return *((_QWORD *)qword_75D408 + 14);\n}\n\n\n Revised code:\nstatic const char *get_cwd(int force)\n{\n\tif (force || G.cwd == NULL) {\n\t\t/* xrealloc_getcwd_or_warn(arg) calls free(arg),\n\t\t * we must not try to free(bb_msg_unknown) */\n\t\tif (G.cwd == bb_msg_unknown)\n\t\t\tG.cwd = NULL;\n\t\tG.cwd = xrealloc_getcwd_or_warn((char *)G.cwd);\n\t\tif (!G.cwd)\n\t\t\tG.cwd = bb_msg_unknown;\n\t}\n\treturn G.cwd;\n}\n\n## Example:\n\n Input code:\nvoid *sub_480FD8()\n{\n  _QWORD *v0; // rbx\n  _QWORD *v1; // rbx\n  void *result; // rax\n\n  v0 = qword_75D408;\n  v0[1] = sub_4807EA(\"PS1\");\n  if ( !*((_QWORD *)qword_75D408 + 1) )\n    *((_QWORD *)qword_75D408 + 1) = \"\\\\w \\\\$ \";\n  v1 = qword_75D408;\n  v1[2] = sub_4807EA(\"PS2\");\n  result = (void *)*((_QWORD *)qword_75D408 + 2);\n  if ( !result )\n  {\n    result = qword_75D408;\n    *((_QWORD *)qword_75D408 + 2) = \"> \";\n  }\n  return result;\n}\n\n\n Revised code:\nif ENABLE_HUSH_INTERACTIVE\n\nstatic void cmdedit_update_prompt(void)\n{\n\tif (ENABLE_FEATURE_EDITING_FANCY_PROMPT) {\n\t\tG.PS1 = get_local_var_value(\"PS1\");\n\t\tif (G.PS1 == NULL)\n\t\t\tG.PS1 = \"\\\\w \\\\$ \";\n\t\tG.PS2 = get_local_var_value(\"PS2\");\n\t} else {\n\t\tG.PS1 = NULL;\n\t}\n\tif (G.PS2 == NULL)\n\t\tG.PS2 = \"> \";\n}\n\n## Example:\n\n Input code:\nvoid sub_4A01E0()\n{\n  unsigned int v0; // eax\n\n  if ( *(_BYTE *)qword_75D408 )\n    v0 = *((_DWORD *)qword_75D408 + 282);\n  else\n    v0 = *((unsigned __int16 *)qword_75D408 + 555);\n  if ( v0 > *((_DWORD *)qword_75D408 + 20) )\n  {\n    signal(14, sub_4A01E0);\n    alarm(5u);\n    if ( *((_DWORD *)qword_75D408 + 20) )\n    {\n      printf(\"%d ...\", *((unsigned int *)qword_75D408 + 20));\n      sub_40A649();\n    }\n  }\n}\n\n\n Revised code:\nstatic void alarm_intr(int alnum UNUSED_PARAM)\n{\n\tif (G.currently_testing >= SB_ZONES)\n\t\treturn;\n\tsignal(SIGALRM, alarm_intr);\n\talarm(5);\n\tif (!G.currently_testing)\n\t\treturn;\n\tprintf(\"%d ...\", G.currently_testing);\n\tfflush_all();\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint sub_4922C0()\n{\n  const char *v0; // rax\n\n  *((_BYTE *)qword_75D408 + 49) = *((_BYTE *)qword_75D408 + 49) == 0;\n  sub_4911A0();\n  v0 = sub_4904DF(0);\n  return printf(\"Changing display/entry units to %s\\n\", v0);\n}\n"
    },
    {
        "func_name": "identify_from_stdin",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 sub_4B357D()\n{\n  __int64 v0; // rdx\n  __int64 v1; // rcx\n  __int64 v2; // r8\n  __int64 v3; // r9\n  int s[3]; // [rsp+0h] [rbp-130h] BYREF\n  int v6; // [rsp+Ch] [rbp-124h]\n  char v7; // [rsp+28h] [rbp-108h]\n\n  memset(s, 0, 0x12CuLL);\n  sub_4B3517((__int64)s, 0LL, v0, v1, v2, v3);\n  s[0] = 4112;\n  s[2] = 2368;\n  s[1] = 8240;\n  v6 = 50331648;\n  if ( (dword_75D450 & 0x8000) == 0 || v7 == 3 )\n  {\n    v6 |= 1u;\n    if ( (dword_75D450 & 0x4000) != 0 )\n      v6 |= 2u;\n  }\n  sub_4B3148((__int64)s);\n  return sub_4B2A74((__int64)s, 0LL);\n}\n\n\n Revised code:\nstatic smallint do_lzo_compress(void)\n{\n\theader_t header;\n\n#define h (&header)\n\tmemset(h, 0, sizeof(*h));\n\n\tlzo_set_method(h);\n\n\th->version = (LZOP_VERSION & 0xffff);\n\th->version_needed_to_extract = 0x0940;\n\th->lib_version = lzo_version() & 0xffff;\n\n\th->flags = (F_OS & F_OS_MASK) | (F_CS & F_CS_MASK);\n\n\tif (!(option_mask32 & OPT_F) || h->method == M_LZO1X_999) {\n\t\th->flags |= F_ADLER32_D;\n\t\tif (option_mask32 & OPT_C)\n\t\t\th->flags |= F_ADLER32_C;\n\t}\n\twrite_header(h);\n\treturn lzo_compress(h);\n#undef h\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_460783(__int64 a1)\n{\n  const char *v1; // rbx\n  const char *v2; // rax\n  char v4; // al\n  char v5; // al\n  unsigned __int64 v6[4]; // [rsp+10h] [rbp-40h] BYREF\n  unsigned __int64 v7; // [rsp+30h] [rbp-20h]\n  int i; // [rsp+3Ch] [rbp-14h]\n\n  v1 = *(const char **)(a1 + 64);\n  v2 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 80);\n  if ( (unsigned int)sub_45FABF(v2, v1, v6, 1LL, 3LL, 9LL, 11LL) )\n    return (void *)sub_45F76C(0xAu);\n  for ( i = 0; i <= 3; ++i )\n  {\n    v7 = *(_QWORD *)(a1 + 8 * (i + 2LL) + 8);\n    if ( v7 > v6[i] )\n      v7 = v6[i];\n    *(_QWORD *)(a1 + 8 * (i + 2LL) + 8) = v6[i];\n    v6[i] -= v7;\n  }\n  if ( v6[1] )\n    v4 = 42;\n  else\n    v4 = 32;\n  sub_45F732(v4);\n  sub_45FE0E(v6[0]);\n  if ( v6[3] )\n    v5 = 42;\n  else\n    v5 = 32;\n  sub_45F732(v5);\n  return sub_45FE0E(v6[2]);\n}\n\n\n Revised code:\nstatic void FAST_FUNC collect_if(if_stat *s)\n{\n\tullong data[4];\n\tint i;\n\n\tif (rdval(get_file(&proc_net_dev), s->device_colon, data, 1, 3, 9, 11)) {\n\t\tput_question_marks(10);\n\t\treturn;\n\t}\n\n\tfor (i=0; i<4; i++) {\n\t\tullong old = s->old[i];\n\t\tif (data[i] < old) old = data[i];\t\t//sanitize\n\t\ts->old[i] = data[i];\n\t\tdata[i] -= old;\n\t}\n\tput_c(data[1] ? '*' : ' ');\n\tscale(data[0]);\n\tput_c(data[3] ? '*' : ' ');\n\tscale(data[2]);\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_4604C4(__int64 a1)\n{\n  const char *v1; // rax\n  const char *v2; // rbx\n  const char *v3; // rax\n  __int64 v4; // r9\n  unsigned __int64 v6; // [rsp+10h] [rbp-30h] BYREF\n  __int64 v7; // [rsp+18h] [rbp-28h]\n  unsigned __int64 v8; // [rsp+20h] [rbp-20h]\n  int i; // [rsp+2Ch] [rbp-14h]\n\n  if ( *((_BYTE *)qword_75D408 + 1) )\n  {\n    v1 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 112);\n    i = sub_45FC43(v1, &v6);\n  }\n  else\n  {\n    v2 = *(const char **)(a1 + 24);\n    v3 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 48);\n    i = sub_45FABF(v3, v2, &v6, 1LL, 2LL, v4);\n    v6 *= 2LL;\n    v7 *= 2LL;\n  }\n  if ( i )\n    return (void *)sub_45F76C(9u);\n  for ( i = 0; i <= 1; ++i )\n  {\n    v8 = *(_QWORD *)(a1 + 8 * (i + 4LL));\n    if ( v8 > *(&v6 + i) )\n      v8 = *(&v6 + i);\n    *(_QWORD *)(a1 + 8 * (i + 4LL)) = *(&v6 + i);\n    *(&v6 + i) -= v8;\n  }\n  sub_45FE0E(v6 << 9);\n  sub_45F732(32);\n  return sub_45FE0E(v7 << 9);\n}\n\n\n Revised code:\nstatic void FAST_FUNC collect_blk(blk_stat *s)\n{\n\tullong data[2];\n\tint i;\n\n\tif (is26) {\n\t\ti = rdval_diskstats(get_file(&proc_diskstats), data);\n\t} else {\n\t\ti = rdval(get_file(&proc_stat), s->lookfor, data, 1, 2);\n\t\t// Linux 2.4 reports bio in Kbytes, convert to sectors:\n\t\tdata[0] *= 2;\n\t\tdata[1] *= 2;\n\t}\n\tif (i) {\n\t\tput_question_marks(9);\n\t\treturn;\n\t}\n\n\tfor (i=0; i<2; i++) {\n\t\tullong old = s->old[i];\n\t\tif (data[i] < old) old = data[i];\t\t//sanitize\n\t\ts->old[i] = data[i];\n\t\tdata[i] -= old;\n\t}\n\tscale(data[0]*512); // TODO: *sectorsize\n\tput_c(' ');\n\tscale(data[1]*512);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __noreturn sub_41B887()\n{\n  __int64 v0; // rcx\n  __int64 v1; // r8\n  __int64 v2; // r9\n  __int16 v3; // bx\n  unsigned __int8 *v4; // rax\n  __int16 v5; // ax\n  char v6[1280]; // [rsp+0h] [rbp-720h] BYREF\n  unsigned __int16 v7[256]; // [rsp+500h] [rbp-220h] BYREF\n  int j; // [rsp+700h] [rbp-20h]\n  int i; // [rsp+704h] [rbp-1Ch]\n  char *v10; // [rsp+708h] [rbp-18h]\n\n  v10 = v6;\n  sub_507452(0LL, v6, 1280LL);\n  for ( i = 0; i <= 255; ++i )\n  {\n    for ( j = 0; j <= 3; ++j )\n    {\n      v3 = 16 * v7[i];\n      v4 = (unsigned __int8 *)v10++;\n      v5 = sub_41B836(*v4, (__int64)v6, (__int64)v10, v0, v1, v2);\n      v7[i] = v3 + v5;\n    }\n  }\n  sub_417DFD(v7, (__int64)v6);\n}\n"
    },
    {
        "func_name": "is_in_ino_dev_hashtable",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_QWORD *__fastcall sub_439CE0(__int64 a1)\n{\n  _QWORD *i; // [rsp+10h] [rbp-8h]\n\n  for ( i = (_QWORD *)*((_QWORD *)qword_75D408 + (unsigned int)a1 % 0xD3 + 1); i; i = (_QWORD *)*i )\n  {\n    if ( a1 == i[1] )\n      return i + 2;\n  }\n  return &unk_519F80;\n}\n\n\n Revised code:\nstatic const char *prg_cache_get(long inode)\n{\n\tunsigned hi = PRG_HASHIT(inode);\n\tstruct prg_node *pn;\n\n\tfor (pn = prg_hash[hi]; pn; pn = pn->next)\n\t\tif (pn->inode == inode)\n\t\t\treturn pn->name;\n\treturn \"-\";\n}\n\n## Example:\n\n Input code:\n__int64 *__fastcall sub_451D87(int a1)\n{\n  __int64 *i; // [rsp+Ch] [rbp-8h]\n\n  if ( qword_75B0E0 )\n  {\n    for ( i = *(__int64 **)(8LL * (a1 & 0xF) + qword_75B0E0); i; i = (__int64 *)*i )\n    {\n      if ( a1 == *((_DWORD *)i + 2) )\n        return i;\n    }\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic struct idxmap *find_by_index(int idx)\n{\n\tstruct idxmap *im;\n\n\tif (idxmap)\n\t\tfor (im = idxmap[idx & 0xF]; im; im = im->next)\n\t\t\tif (im->index == idx)\n\t\t\t\treturn im;\n\treturn NULL;\n}\n\n## Example:\n\n Input code:\n_BOOL8 __fastcall sub_4DAFDA(const char *a1, const char *a2)\n{\n  char *v3; // [rsp+10h] [rbp-10h]\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  if ( byte_75B27D )\n    return 0LL;\n  if ( qword_75B2A0 )\n  {\n    if ( !strncmp(*(const char **)(qword_75B2A0 + 24), \"/dev/md\", 7uLL) )\n      return 1LL;\n    a2 = \"/dev/md\";\n    if ( !strncmp(a1, \"/dev/md\", 7uLL) )\n      return 1LL;\n  }\n  v3 = sub_4DA65D(a1, (__int64)a2);\n  if ( !v3 )\n    return qword_75B2A0 != 0;\n  for ( i = qword_75B2A0; i; i = *(_QWORD *)i )\n  {\n    if ( !*(_QWORD *)(i + 32) || !strcmp(v3, *(const char **)(i + 32)) )\n    {\n      free(v3);\n      return 1LL;\n    }\n  }\n  free(v3);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int device_already_active(char *device)\n{\n\tstruct fsck_instance *inst;\n\tchar *base;\n\n\tif (force_all_parallel)\n\t\treturn 0;\n\n#ifdef BASE_MD\n\t/* Don't check a soft raid disk with any other disk */\n\tif (instance_list\n\t && (!strncmp(instance_list->device, BASE_MD, sizeof(BASE_MD)-1)\n\t     || !strncmp(device, BASE_MD, sizeof(BASE_MD)-1))\n\t) {\n\t\treturn 1;\n\t}\n#endif\n\n\tbase = base_device(device);\n\t/*\n\t * If we don't know the base device, assume that the device is\n\t * already active if there are any fsck instances running.\n\t */\n\tif (!base)\n\t\treturn (instance_list != NULL);\n\n\tfor (inst = instance_list; inst; inst = inst->next) {\n\t\tif (!inst->base_device || !strcmp(base, inst->base_device)) {\n\t\t\tfree(base);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tfree(base);\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_QWORD *__fastcall sub_4FDC1B(_QWORD *a1)\n{\n  _QWORD *i; // [rsp+10h] [rbp-8h]\n\n  if ( !qword_75B2D0 )\n    return 0LL;\n  for ( i = (_QWORD *)*((_QWORD *)qword_75B2D0 + a1[1] % 0x137uLL); i; i = (_QWORD *)*i )\n  {\n    if ( i[1] == a1[1] && i[2] == *a1 )\n      return i + 3;\n  }\n  return 0LL;\n}\n"
    },
    {
        "func_name": "bb_BLKGETSIZE_sectors",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A558D(unsigned int a1, _QWORD *a2, void **a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  void *v7; // rax\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  __int64 v13; // [rsp+28h] [rbp-18h] BYREF\n  __int64 v14; // [rsp+30h] [rbp-10h]\n  unsigned int v15; // [rsp+3Ch] [rbp-4h]\n\n  v15 = 1;\n  v14 = sub_4A5BC2(a1);\n  if ( ioctl(a1, 0x80081272uLL, &v13) )\n    v13 = 0LL;\n  if ( !(unsigned int)sub_4A5A83(v14, v13) && (*(_BYTE *)(v14 + 48) || *(_BYTE *)(v14 + 113)) )\n  {\n    v7 = sub_40A165((_BYTE *)(v14 + 48), 65LL, v3, v4, v5, v6);\n    *a2 = v7;\n    *a3 = sub_40A165((_BYTE *)(v14 + 113), 37LL, (__int64)v7, v8, v9, v10);\n    v15 = 0;\n  }\n  sub_4A5BEA(v14);\n  return v15;\n}\n\n\n Revised code:\nstatic int\nget_label_uuid(int fd, char **label, char **uuid, const char **type)\n{\n\tint rv = 1;\n\tuint64_t size;\n\tstruct volume_id *vid;\n\n\t/* fd is owned by vid now */\n\tvid = volume_id_open_node(fd);\n\n\tif (ioctl(/*vid->*/fd, BLKGETSIZE64, &size) != 0)\n\t\tsize = 0;\n\n\tif (volume_id_probe_all(vid, /*0,*/ size) != 0)\n\t\tgoto ret;\n\n\tif (vid->label[0] != '\\0' || vid->uuid[0] != '\\0'\n#if ENABLE_FEATURE_BLKID_TYPE\n\t || vid->type != NULL\n#endif\n\t) {\n\t\t*label = xstrndup(vid->label, sizeof(vid->label));\n\t\t*uuid  = xstrndup(vid->uuid, sizeof(vid->uuid));\n#if ENABLE_FEATURE_BLKID_TYPE\n\t\t*type = vid->type;\n\t\tdbg(\"found label '%s', uuid '%s', type '%s'\", *label, *uuid, *type);\n#else\n\t\tdbg(\"found label '%s', uuid '%s'\", *label, *uuid);\n#endif\n\t\trv = 0;\n\t}\n ret:\n\tfree_volume_id(vid); /* also closes fd */\n\treturn rv;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48EF6A(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v7; // eax\n  __int64 *v9; // [rsp+0h] [rbp-30h]\n  __int64 *v10; // [rsp+0h] [rbp-30h]\n  unsigned __int64 v11; // [rsp+10h] [rbp-20h] BYREF\n  int fd; // [rsp+1Ch] [rbp-14h]\n  const char *v13; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v14; // [rsp+28h] [rbp-8h]\n\n  v9 = (__int64 *)(a2 + 8);\n  if ( !*(_QWORD *)(a2 + 8) || !*(_QWORD *)(a2 + 16) )\n    sub_407F64();\n  v13 = sub_48EEFF(*v9);\n  v14 = v13[15];\n  if ( (v13[14] & 4) != 0 )\n  {\n    v9 = (__int64 *)(a2 + 16);\n    v14 = (int)sub_50B306(*(_QWORD *)(a2 + 16));\n  }\n  v10 = v9 + 1;\n  if ( !*v10 || v10[1] )\n    sub_407F64();\n  fd = sub_40A295((const char *)*v10, 0);\n  v11 = v14;\n  v2 = *(unsigned int *)v13;\n  if ( ioctl(fd, v2, &v11) == -1 )\n    sub_409392(*v10, v2, v3, v4, v5, v6);\n  v14 = v11;\n  if ( (v13[14] & 0x10) != 0 )\n    v14 >>= 9;\n  v7 = v13[14] & 0xB;\n  if ( v7 == 2 || v7 == 3 )\n  {\n    printf(\"%llu\\n\", v14);\n  }\n  else if ( v7 == 1 )\n  {\n    printf(\"%lld\\n\", (int)v14);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nint blockdev_main(int argc UNUSED_PARAM, char **argv)\n{\n\tconst struct bdc *bdcmd;\n\tint fd;\n\tuint64_t u64;\n\tunion {\n\t\tint i;\n\t\tunsigned long lu;\n\t\tuint64_t u64;\n\t} ioctl_val_on_stack;\n\n\targv++;\n\tif (!argv[0] || !argv[1]) /* must have at least 2 args */\n\t\tbb_show_usage();\n\n\tbdcmd = find_cmd(*argv);\n\n\tu64 = (int)bdcmd->argval;\n\tif (bdcmd->flags & FL_USRARG)\n\t\tu64 = xatoi_positive(*++argv);\n\n\targv++;\n\tif (!argv[0] || argv[1])\n\t\tbb_show_usage();\n\tfd = xopen(argv[0], O_RDONLY);\n\n\tioctl_val_on_stack.u64 = u64;\n#if BB_BIG_ENDIAN\n\t/* Store data properly wrt data size.\n\t * (1) It's no-op for little-endian.\n\t * (2) it's no-op for 0 and -1. Only --setro uses arg != 0 and != -1,\n\t * and it is ARG_INT. --setbsz USER_VAL is also ARG_INT.\n\t * Thus, we don't need to handle ARG_ULONG.\n\t */\n\tswitch (bdcmd->flags & ARG_MASK) {\n\tcase ARG_INT:\n\t\tioctl_val_on_stack.i = (int)u64;\n\t\tbreak;\n# if 0 /* unused */\n\tcase ARG_ULONG:\n\t\tioctl_val_on_stack.lu = (unsigned long)u64;\n\t\tbreak;\n# endif\n\t}\n#endif\n\n\tif (ioctl(fd, bdcmd->ioc, &ioctl_val_on_stack.u64) == -1)\n\t\tbb_simple_perror_msg_and_die(*argv);\n\n\t/* Fetch it into register(s) */\n\tu64 = ioctl_val_on_stack.u64;\n\n\tif (bdcmd->flags & FL_SCALE512)\n\t\tu64 >>= 9;\n\n\t/* Zero- or one-extend the value if needed, then print */\n\tswitch (bdcmd->flags & (ARG_MASK+FL_NORESULT)) {\n\tcase ARG_INT:\n\t\t/* Smaller code when we use long long\n\t\t * (gcc tail-merges printf call)\n\t\t */\n\t\tprintf(\"%lld\\n\", (long long)(int)u64);\n\t\tbreak;\n\tcase ARG_ULONG:\n\t\tu64 = (unsigned long)u64;\n\t\t/* FALLTHROUGH */\n\tcase ARG_U64:\n\t\tprintf(\"%llu\\n\", (unsigned long long)u64);\n\t\tbreak;\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tclose(fd);\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A586D(const char *a1)\n{\n  void *v2; // r12\n  __int64 v3; // rbx\n  char *v4; // rax\n  __int64 v5; // [rsp+18h] [rbp-28h] BYREF\n  void *v6; // [rsp+20h] [rbp-20h] BYREF\n  int v7; // [rsp+2Ch] [rbp-14h]\n\n  v7 = open64(a1, 0);\n  if ( v7 < 0 )\n    return 0LL;\n  if ( (unsigned int)sub_4A558D(v7, &v5, &v6) )\n    return 0LL;\n  v2 = v6;\n  v3 = v5;\n  v4 = sub_40A11F(a1, (__int64)&v5);\n  sub_4A5664(v4, v3, v2);\n  return 1LL;\n}\n\n\n Revised code:\nint add_to_uuid_cache(const char *device)\n{\n\tchar *uuid = uuid; /* for compiler */\n\tchar *label = label;\n#if ENABLE_FEATURE_BLKID_TYPE\n\tconst char *type = type;\n#endif\n\tint fd;\n\n\tfd = open(device, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\t/* get_label_uuid() closes fd in all cases (success & failure) */\n\tif (get_label_uuid(fd, &label, &uuid, &type) == 0) {\n\t\t/* uuidcache_addentry() takes ownership of all four params */\n\t\tuuidcache_addentry(xstrdup(device), /*ma, mi,*/ label, uuid, type);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4902A5(int a1)\n{\n  __int64 v1; // rsi\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  __int64 v5; // rdx\n  unsigned __int64 v7; // [rsp+18h] [rbp-18h] BYREF\n  unsigned __int64 v8; // [rsp+20h] [rbp-10h] BYREF\n  __off64_t v9; // [rsp+28h] [rbp-8h]\n\n  v1 = 2148012658LL;\n  if ( !ioctl(a1, 0x80081272uLL, &v8) )\n  {\n    v8 >>= 9;\n    v5 = (unsigned int)v8;\n    if ( (unsigned int)v8 == v8 )\n      return v8;\nLABEL_3:\n    sub_409747(\"device has more than 2^32 sectors, can't use all of them\", v1, v5, v2, v3, v4);\n    return 0xFFFFFFFFLL;\n  }\n  v1 = 4704LL;\n  if ( ioctl(a1, 0x1260uLL, &v7) )\n  {\n    v9 = lseek64(a1, 0LL, 2);\n    v7 = 0LL;\n    if ( v9 > 0 )\n      v7 = v9 / (unsigned __int64)*((unsigned int *)qword_75D408 + 6);\n    v1 = 0LL;\n    lseek64(a1, 0LL, 0);\n  }\n  v5 = (unsigned int)v7;\n  if ( (unsigned int)v7 != v7 )\n    goto LABEL_3;\n  return v7;\n}\n"
    },
    {
        "func_name": "inflate_stored",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4BF3A4(__int64 a1, __int64 a2)\n{\n  int v3; // eax\n  unsigned int v4; // [rsp+1Ch] [rbp-4h]\n\n  do\n  {\n    v4 = sub_4BF007(a1, *(_QWORD *)a2, (unsigned __int64 *)(a2 + 8), *(_QWORD *)(a2 + 16));\n    if ( v4 != 1 )\n    {\n      sub_4BF329(a1, (_QWORD *)a2);\n      return v4;\n    }\n    v3 = *(_DWORD *)(a1 + 120);\n    if ( v3 == 1 )\n    {\n      *(_QWORD *)(a1 + 144) += *(_QWORD *)(a1 + 8);\n      *(_DWORD *)(a1 + 120) = 2;\n    }\n    else if ( v3 )\n    {\n      if ( v3 == 2 )\n      {\n        *(_QWORD *)(a1 + 152) += *(_QWORD *)(a1 + 8);\n        *(_DWORD *)(a1 + 160) = sub_4BBFB7(a1 + 144, 0x18u, *(_DWORD *)(a1 + 160));\n        --*(_QWORD *)(a1 + 136);\n        *(_DWORD *)(a1 + 120) = 1;\n      }\n    }\n    else\n    {\n      *(_QWORD *)(a1 + 136) = *(_QWORD *)(a1 + 8);\n      if ( *(_QWORD *)(a1 + 136) != *(_QWORD *)(a1 + 88) )\n        return 7LL;\n      *(_DWORD *)(a1 + 120) = 1;\n    }\n  }\n  while ( *(_QWORD *)(a1 + 136) );\n  return 1LL;\n}\n\n\n Revised code:\nstatic enum xz_ret XZ_FUNC dec_index(struct xz_dec *s, struct xz_buf *b)\n{\n\tenum xz_ret ret;\n\n\tdo {\n\t\tret = dec_vli(s, b->in, &b->in_pos, b->in_size);\n\t\tif (ret != XZ_STREAM_END) {\n\t\t\tindex_update(s, b);\n\t\t\treturn ret;\n\t\t}\n\n\t\tswitch (s->index.sequence) {\n\t\tcase SEQ_INDEX_COUNT:\n\t\t\ts->index.count = s->vli;\n\n\t\t\t/*\n\t\t\t * Validate that the Number of Records field\n\t\t\t * indicates the same number of Records as\n\t\t\t * there were Blocks in the Stream.\n\t\t\t */\n\t\t\tif (s->index.count != s->block.count)\n\t\t\t\treturn XZ_DATA_ERROR;\n\n\t\t\ts->index.sequence = SEQ_INDEX_UNPADDED;\n\t\t\tbreak;\n\n\t\tcase SEQ_INDEX_UNPADDED:\n\t\t\ts->index.hash.unpadded += s->vli;\n\t\t\ts->index.sequence = SEQ_INDEX_UNCOMPRESSED;\n\t\t\tbreak;\n\n\t\tcase SEQ_INDEX_UNCOMPRESSED:\n\t\t\ts->index.hash.uncompressed += s->vli;\n\t\t\ts->index.hash.crc32 = xz_crc32(\n\t\t\t\t\t(const uint8_t *)&s->index.hash,\n\t\t\t\t\tsizeof(s->index.hash),\n\t\t\t\t\ts->index.hash.crc32);\n\t\t\t--s->index.count;\n\t\t\ts->index.sequence = SEQ_INDEX_UNPADDED;\n\t\t\tbreak;\n\t\t}\n\t} while (s->index.count > 0);\n\n\treturn XZ_STREAM_END;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4BA779(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rsi\n  unsigned int v4; // eax\n  __int64 v6; // [rsp+14h] [rbp-Ch]\n  int v7; // [rsp+1Ch] [rbp-4h]\n\n  *(_DWORD *)(a1 + 68) -= *(_DWORD *)(a1 + 64);\n  memmove(\n    *(void **)(a1 + 48),\n    (const void *)(*(_QWORD *)(a1 + 48) + *(unsigned int *)(a1 + 64)),\n    *(unsigned int *)(a1 + 68));\n  *(_DWORD *)(a1 + 64) = 0;\n  if ( !sub_4BA61D(a1, 8) )\n    return 0LL;\n  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + *(unsigned int *)(a1 + 64));\n  *(_DWORD *)(a1 + 64) += 8;\n  if ( (_BYTE)v6 != 8 )\n    return 0LL;\n  if ( (v6 & 0x400) != 0 )\n  {\n    if ( !sub_4BA61D(a1, 2) )\n      return 0LL;\n    v7 = (unsigned __int16)sub_4BA708(a1);\n    if ( !sub_4BA61D(a1, v7) )\n      return 0LL;\n    *(_DWORD *)(a1 + 64) += v7;\n  }\n  if ( (v6 & 0x1800) != 0 )\n  {\n    while ( sub_4BA61D(a1, 1) )\n    {\n      v3 = *(_QWORD *)(a1 + 48);\n      v4 = *(_DWORD *)(a1 + 64);\n      *(_DWORD *)(a1 + 64) = v4 + 1;\n      if ( !*(_BYTE *)(v3 + v4) )\n      {\n        if ( (BYTE1(v6) & 0x18) != 24 )\n          goto LABEL_17;\n        BYTE1(v6) &= 0xE7u;\n      }\n    }\n    return 0LL;\n  }\n  else\n  {\nLABEL_17:\n    if ( a2 )\n      *(_QWORD *)(a2 + 32) = *(unsigned int *)((char *)&v6 + 2);\n    if ( (v6 & 0x200) != 0 )\n    {\n      if ( !sub_4BA61D(a1, 2) )\n        return 0LL;\n      *(_DWORD *)(a1 + 64) += 2;\n    }\n    return 1LL;\n  }\n}\n\n\n Revised code:\nstatic int check_header_gzip(STATE_PARAM transformer_aux_data_t *aux)\n{\n\tunion {\n\t\tunsigned char raw[8];\n\t\tstruct {\n\t\t\tuint8_t gz_method;\n\t\t\tuint8_t flags;\n\t\t\tuint32_t mtime;\n\t\t\tuint8_t xtra_flags_UNUSED;\n\t\t\tuint8_t os_flags_UNUSED;\n\t\t} PACKED formatted;\n\t} header;\n\tstruct BUG_header {\n\t\tchar BUG_header[sizeof(header) == 8 ? 1 : -1];\n\t};\n\n\t/*\n\t * Rewind bytebuffer. We use the beginning because the header has 8\n\t * bytes, leaving enough for unwinding afterwards.\n\t */\n\tbytebuffer_size -= bytebuffer_offset;\n\tmemmove(bytebuffer, &bytebuffer[bytebuffer_offset], bytebuffer_size);\n\tbytebuffer_offset = 0;\n\n\tif (!top_up(PASS_STATE 8))\n\t\treturn 0;\n\tmemcpy(header.raw, &bytebuffer[bytebuffer_offset], 8);\n\tbytebuffer_offset += 8;\n\n\t/* Check the compression method */\n\tif (header.formatted.gz_method != 8) {\n\t\treturn 0;\n\t}\n\n\tif (header.formatted.flags & 0x04) {\n\t\t/* bit 2 set: extra field present */\n\t\tunsigned extra_short;\n\n\t\tif (!top_up(PASS_STATE 2))\n\t\t\treturn 0;\n\t\textra_short = buffer_read_le_u16(PASS_STATE_ONLY);\n\t\tif (!top_up(PASS_STATE extra_short))\n\t\t\treturn 0;\n\t\t/* Ignore extra field */\n\t\tbytebuffer_offset += extra_short;\n\t}\n\n\t/* Discard original name and file comment if any */\n\t/* bit 3 set: original file name present */\n\t/* bit 4 set: file comment present */\n\tif (header.formatted.flags & 0x18) {\n\t\twhile (1) {\n\t\t\tdo {\n\t\t\t\tif (!top_up(PASS_STATE 1))\n\t\t\t\t\treturn 0;\n\t\t\t} while (bytebuffer[bytebuffer_offset++] != 0);\n\t\t\tif ((header.formatted.flags & 0x18) != 0x18)\n\t\t\t\tbreak;\n\t\t\theader.formatted.flags &= ~0x18;\n\t\t}\n\t}\n\n\tif (aux)\n\t\taux->mtime = SWAP_LE32(header.formatted.mtime);\n\n\t/* Read the header checksum */\n\tif (header.formatted.flags & 0x02) {\n\t\tif (!top_up(PASS_STATE 2))\n\t\t\treturn 0;\n\t\tbytebuffer_offset += 2;\n\t}\n\treturn 1;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4BF520(__int64 a1, __int64 *a2)\n{\n  int v3; // esi\n  __int64 v4; // rdi\n  __int64 v5; // rax\n\n  do\n  {\n    if ( a2[1] == a2[2] )\n      return 0LL;\n    v3 = (unsigned __int8)(*(_DWORD *)(a1 + 32) >> *(_DWORD *)(a1 + 4));\n    v4 = *a2;\n    v5 = a2[1];\n    a2[1] = v5 + 1;\n    if ( v3 != *(unsigned __int8 *)(v4 + v5) )\n      return 7LL;\n    *(_DWORD *)(a1 + 4) += 8;\n  }\n  while ( *(_DWORD *)(a1 + 4) <= 0x1Fu );\n  *(_DWORD *)(a1 + 32) = 0;\n  *(_DWORD *)(a1 + 4) = 0;\n  return 1LL;\n}\n\n\n Revised code:\nstatic enum xz_ret XZ_FUNC crc32_validate(struct xz_dec *s, struct xz_buf *b)\n{\n\tdo {\n\t\tif (b->in_pos == b->in_size)\n\t\t\treturn XZ_OK;\n\n\t\tif (((s->crc32 >> s->pos) & 0xFF) != b->in[b->in_pos++])\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\ts->pos += 8;\n\n\t} while (s->pos < 32);\n\n\ts->crc32 = 0;\n\ts->pos = 0;\n\n\treturn XZ_STREAM_END;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4B97F0(__int64 a1)\n{\n  int v1; // edi\n  __int64 v2; // rsi\n  unsigned int v3; // eax\n  int v5; // eax\n\n  while ( 1 )\n  {\n    v5 = *(_DWORD *)(a1 + 132);\n    *(_DWORD *)(a1 + 132) = v5 - 1;\n    if ( !v5 )\n      break;\n    *(_DWORD *)(a1 + 136) = sub_4B88A3(a1, *(_DWORD *)(a1 + 136), (unsigned int *)(a1 + 140), 8u);\n    v1 = *(_DWORD *)(a1 + 136);\n    v2 = *(_QWORD *)(a1 + 24);\n    v3 = *(_DWORD *)(a1 + 144);\n    *(_DWORD *)(a1 + 144) = v3 + 1;\n    *(_BYTE *)(v2 + v3) = v1;\n    if ( *(_DWORD *)(a1 + 144) == 0x8000 )\n    {\n      *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 144);\n      *(_DWORD *)(a1 + 144) = 0;\n      *(_DWORD *)(a1 + 136) >>= 8;\n      *(_DWORD *)(a1 + 140) -= 8;\n      return 1LL;\n    }\n    *(_DWORD *)(a1 + 136) >>= 8;\n    *(_DWORD *)(a1 + 140) -= 8;\n  }\n  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a1 + 144);\n  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 136);\n  *(_BYTE *)(a1 + 44) = *(_DWORD *)(a1 + 140);\n  return 0LL;\n}\n"
    },
    {
        "func_name": "linear2chs",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_490FCA(int a1, int a2, unsigned int a3, unsigned int a4, char a5)\n{\n  _BYTE *result; // rax\n  int v8; // [rsp+1Ch] [rbp-Ch]\n  _BYTE *v9; // [rsp+20h] [rbp-8h]\n\n  if ( a2 )\n  {\n    v9 = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * a1 + 314);\n    v8 = *((_DWORD *)qword_75D408 + 22);\n  }\n  else\n  {\n    v9 = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * a1 + 313);\n    v8 = *((_DWORD *)qword_75D408 + 10 * a1 + 630);\n  }\n  *v9 = 0;\n  v9[4] = a5;\n  sub_49091E((__int64)v9, a3 - v8);\n  sub_490945((__int64)v9, a4 - a3 + 1);\n  sub_490DE1(v9, a3, a4);\n  result = (char *)qword_75D408 + 40 * a1 + 2536;\n  *result = 1;\n  return result;\n}\n\n\n Revised code:\nstatic void\nset_partition(int i, int doext, sector_t start, sector_t stop, int sysid)\n{\n\tstruct partition *p;\n\tsector_t offset;\n\n\tif (doext) {\n\t\tp = ptes[i].ext_pointer;\n\t\toffset = extended_offset;\n\t} else {\n\t\tp = ptes[i].part_table;\n\t\toffset = ptes[i].offset_from_dev_start;\n\t}\n\tp->boot_ind = 0;\n\tp->sys_ind = sysid;\n\tset_start_sect(p, start - offset);\n\tset_nr_sects(p, stop - start + 1);\n\tset_hsc_start_end(p, start, stop);\n\tptes[i].changed = 1;\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_480183(__int64 a1, _QWORD *a2)\n{\n  void *result; // rax\n  _QWORD *v3; // [rsp+0h] [rbp-20h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  v3 = a2;\n  *(_QWORD *)a1 = *a2;\n  *(_QWORD *)(a1 + 8) = *((_QWORD *)qword_75D408 + 11);\n  *(_DWORD *)(a1 + 16) = *((_DWORD *)qword_75D408 + 21);\n  *(_BYTE *)(a1 + 20) = *((_BYTE *)qword_75D408 + 80);\n  *a2 = **((_QWORD **)qword_75D408 + 11);\n  *((_QWORD *)qword_75D408 + 11) = a2;\n  *((_BYTE *)qword_75D408 + 80) = 0;\n  for ( i = 1; *++v3; ++i )\n    ;\n  result = qword_75D408;\n  *((_DWORD *)qword_75D408 + 21) = i;\n  return result;\n}\n\n\n Revised code:\nstatic void save_and_replace_G_args(save_arg_t *sv, char **argv)\n{\n\tint n;\n\n\tsv->sv_argv0 = argv[0];\n\tsv->sv_g_argv = G.global_argv;\n\tsv->sv_g_argc = G.global_argc;\n\tsv->sv_g_malloced = G.global_args_malloced;\n\n\targv[0] = G.global_argv[0]; /* retain $0 */\n\tG.global_argv = argv;\n\tG.global_args_malloced = 0;\n\n\tn = 1;\n\twhile (*++argv)\n\t\tn++;\n\tG.global_argc = n;\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_43B939(__int64 a1, __int64 a2)\n{\n  void *result; // rax\n  _QWORD *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40A0E8(0x170uLL, a2);\n  *v3 = sub_50BB2A(a1, 123LL);\n  v3[1] = sub_50BFDE(*v3 + 4LL);\n  *((_DWORD *)v3 + 4) = -1;\n  *((_BYTE *)v3 + 296) = 35;\n  v3[4] = *(_QWORD *)qword_75D408;\n  sub_43B74C((__int64)v3, 2.0);\n  sub_408FD2((_QWORD *)qword_75D408 + 6, (__int64)v3);\n  result = qword_75D408;\n  ++*((_DWORD *)qword_75D408 + 16);\n  return result;\n}\n\n\n Revised code:\nstatic void\nadd_peers(char *s)\n{\n\tpeer_t *p;\n\n\tp = xzalloc(sizeof(*p));\n\tp->p_lsa = xhost2sockaddr(s, 123);\n\tp->p_dotted = xmalloc_sockaddr2dotted_noport(&p->p_lsa->u.sa);\n\tp->p_fd = -1;\n\tp->p_xmt_msg.m_status = MODE_CLIENT | (NTP_VERSION << 3);\n\tp->next_action_time = G.cur_time; /* = set_next(p, 0); */\n\treset_peer_stats(p, 16 * STEP_THRESHOLD);\n\n\tllist_add_to(&G.ntp_peers, p);\n\tG.peer_cnt++;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_DWORD *__fastcall sub_49294D(unsigned int a1, unsigned int *a2, unsigned int *a3, _DWORD *a4)\n{\n  _DWORD *result; // rax\n  unsigned int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = *((_DWORD *)qword_75D408 + 9) * *((_DWORD *)qword_75D408 + 10);\n  *a2 = a1 / v5;\n  *a3 = a1 % v5 / *((_DWORD *)qword_75D408 + 10);\n  result = a4;\n  *a4 = a1 % v5 % *((_DWORD *)qword_75D408 + 10) + 1;\n  return result;\n}\n"
    },
    {
        "func_name": "check_delayed_sigs",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4BFF1C(__int64 a1, __int64 *a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-18h]\n  __int64 v4; // [rsp+20h] [rbp-10h]\n  unsigned int v5; // [rsp+2Ch] [rbp-4h]\n\n  v4 = a2[1];\n  v3 = a2[4];\n  v5 = sub_4BFB0B(a1, a2);\n  if ( !v5 && v4 == a2[1] && v3 == a2[4] )\n  {\n    if ( *(_BYTE *)(a1 + 44) )\n      v5 = 8;\n    *(_BYTE *)(a1 + 44) = 1;\n  }\n  else\n  {\n    *(_BYTE *)(a1 + 44) = 0;\n  }\n  return v5;\n}\n\n\n Revised code:\nXZ_EXTERN enum xz_ret XZ_FUNC xz_dec_run(struct xz_dec *s, struct xz_buf *b)\n{\n\tsize_t in_start;\n\tsize_t out_start;\n\tenum xz_ret ret;\n\n\tif (DEC_IS_SINGLE(s->mode))\n\t\txz_dec_reset(s);\n\n\tin_start = b->in_pos;\n\tout_start = b->out_pos;\n\tret = dec_main(s, b);\n\n\tif (DEC_IS_SINGLE(s->mode)) {\n\t\tif (ret == XZ_OK)\n\t\t\tret = b->in_pos == b->in_size\n\t\t\t\t\t? XZ_DATA_ERROR : XZ_BUF_ERROR;\n\n\t\tif (ret != XZ_STREAM_END) {\n\t\t\tb->in_pos = in_start;\n\t\t\tb->out_pos = out_start;\n\t\t}\n\n\t} else if (ret == XZ_OK && in_start == b->in_pos\n\t\t\t&& out_start == b->out_pos) {\n\t\tif (s->allow_buf_error)\n\t\t\tret = XZ_BUF_ERROR;\n\n\t\ts->allow_buf_error = true;\n\t} else {\n\t\ts->allow_buf_error = false;\n\t}\n\n\treturn ret;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4786F3(__int64 a1, __int64 a2)\n{\n  char v3; // [rsp+4h] [rbp-4Ch]\n  unsigned int v4; // [rsp+4h] [rbp-4Ch]\n  _QWORD v5[4]; // [rsp+10h] [rbp-40h] BYREF\n  __int64 v6; // [rsp+30h] [rbp-20h] BYREF\n  __int64 *v7; // [rsp+38h] [rbp-18h]\n  __int64 j; // [rsp+40h] [rbp-10h]\n  __int64 i; // [rsp+48h] [rbp-8h]\n\n  v3 = a2;\n  sub_46E8A1(v5);\n  v6 = 0LL;\n  v7 = &v6;\n  for ( i = *(_QWORD *)(a1 + 8); i; i = *(_QWORD *)(i + 8) )\n  {\n    a2 = (__int64)&v6;\n    sub_4768BC(i, (__int64)&v6, 35);\n    if ( byte_75B040 )\n      return sub_46E905(v5, a2);\n  }\n  *v7 = 0LL;\n  byte_75AF50 = 0;\n  ++dword_75B04C;\n  v4 = v3 & 2;\n  for ( j = v6; j; j = *(_QWORD *)j )\n  {\n    sub_46F6BF(*(char **)(a1 + 24), *(const char **)(j + 8), 0);\n    a2 = v4;\n    sub_4781FB(*(char **)(a1 + 16), v4);\n    if ( byte_75B040 )\n    {\n      if ( byte_75B040 != 2 || (--dword_75B044, dword_75B044 > 0) )\n      {\n        if ( byte_75B040 == 1 && --dword_75B044 <= 0 )\n          byte_75B040 = 0;\n        break;\n      }\n      byte_75B040 = 0;\n    }\n  }\n  --dword_75B04C;\n  return sub_46E905(v5, a2);\n}\n\n\n Revised code:\nstatic void\nevalfor(union node *n, int flags)\n{\n\tstruct arglist arglist;\n\tunion node *argp;\n\tstruct strlist *sp;\n\tstruct stackmark smark;\n\n\tsetstackmark(&smark);\n\targlist.list = NULL;\n\targlist.lastp = &arglist.list;\n\tfor (argp = n->nfor.args; argp; argp = argp->narg.next) {\n\t\texpandarg(argp, &arglist, EXP_FULL | EXP_TILDE | EXP_RECORD);\n\t\t/* XXX */\n\t\tif (evalskip)\n\t\t\tgoto out;\n\t}\n\t*arglist.lastp = NULL;\n\n\texitstatus = 0;\n\tloopnest++;\n\tflags &= EV_TESTED;\n\tfor (sp = arglist.list; sp; sp = sp->next) {\n\t\tsetvar(n->nfor.var, sp->text, 0);\n\t\tevaltree(n->nfor.body, flags);\n\t\tif (evalskip) {\n\t\t\tif (evalskip == SKIPCONT && --skipcount <= 0) {\n\t\t\t\tevalskip = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (evalskip == SKIPBREAK && --skipcount <= 0)\n\t\t\t\tevalskip = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tloopnest--;\n out:\n\tpopstackmark(&smark);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47B7A8(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  _QWORD *v7; // [rsp+0h] [rbp-20h]\n  __int64 v8; // [rsp+8h] [rbp-18h]\n  int v9; // [rsp+14h] [rbp-Ch]\n  char v10; // [rsp+14h] [rbp-Ch]\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = ((__int64 (*)(void))sub_47B839)(); ; i = (__int64)v7 )\n  {\n    v9 = sub_47DB13(a1);\n    if ( v9 == 6 )\n    {\n      v10 = 5;\n      goto LABEL_7;\n    }\n    if ( v9 != 7 )\n      break;\n    v10 = 6;\nLABEL_7:\n    byte_75B058 = 7;\n    v8 = sub_47B839(a1);\n    a1 = 24LL;\n    v7 = sub_46E7E7(0x18uLL, a2, v3, v4, v5, v6);\n    *(_BYTE *)v7 = v10;\n    v7[1] = i;\n    v7[2] = v8;\n  }\n  byte_75B059 = 1;\n  return i;\n}\n\n\n Revised code:\nstatic union node *\nandor(void)\n{\n\tunion node *n1, *n2, *n3;\n\tint t;\n\n\tn1 = pipeline();\n\tfor (;;) {\n\t\tt = readtoken();\n\t\tif (t == TAND) {\n\t\t\tt = NAND;\n\t\t} else if (t == TOR) {\n\t\t\tt = NOR;\n\t\t} else {\n\t\t\ttokpushback = 1;\n\t\t\treturn n1;\n\t\t}\n\t\tcheckkwd = CHKNL | CHKKWD | CHKALIAS;\n\t\tn2 = pipeline();\n\t\tn3 = stzalloc(sizeof(struct nbinary));\n\t\tn3->type = t;\n\t\tn3->nbinary.ch1 = n1;\n\t\tn3->nbinary.ch2 = n2;\n\t\tn1 = n3;\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4F59B2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  char v7; // [rsp+Bh] [rbp-5h]\n  unsigned int i; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; ; i = 1 )\n  {\n    v7 = byte_75D468;\n    if ( !byte_75D468 )\n      break;\n    byte_75D468 = 0;\n    if ( v7 == 1 )\n      sub_4F5915(a1, a2, a3, a4, a5, a6);\n    if ( v7 == 2 )\n    {\n      a1 = 32LL;\n      sub_4F5345(0x20u);\n    }\n  }\n  return i;\n}\n"
    },
    {
        "func_name": "unalias",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4792F7(__int64 a1, __int64 a2)\n{\n  unsigned __int8 **v2; // rax\n  __int64 v4; // [rsp+0h] [rbp-20h]\n\n  v4 = qword_75AF58;\n  while ( 1 )\n  {\n    v2 = (unsigned __int8 **)v4;\n    v4 += 8LL;\n    if ( !*v2 )\n      break;\n    sub_47916A(*v2, a2);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC\nlocalcmd(int argc UNUSED_PARAM, char **argv)\n{\n\tchar *name;\n\n\targv = argptr;\n\twhile ((name = *argv++) != NULL) {\n\t\tmklocal(name);\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_472F50(__int64 a1, __int64 a2)\n{\n  __int64 v3; // [rsp+8h] [rbp-18h]\n  unsigned int v4; // [rsp+1Ch] [rbp-4h]\n\n  v3 = a1;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  while ( !*(_BYTE *)(v3 + 30) )\n  {\n    a2 = v3;\n    a1 = 0LL;\n    sub_4718A4(0, v3);\n  }\n  sub_46E03F(a1, a2);\n  v4 = sub_471EA1(v3);\n  if ( (*(_BYTE *)(v3 + 31) & 2) != 0 )\n  {\n    sub_471133(dword_75AE30, *(_DWORD *)qword_75D418);\n    if ( (*(_BYTE *)(v3 + 31) & 1) != 0 )\n      raise(2);\n  }\n  if ( *(_BYTE *)(v3 + 30) == 2 )\n    sub_47107C(v3);\n  return v4;\n}\n\n\n Revised code:\nstatic int\nwaitforjob(struct job *jp)\n{\n\tint st;\n\n\tTRACE((\"waitforjob(%%%d) called\\n\", jobno(jp)));\n\n\tINT_OFF;\n\twhile (jp->state == JOBRUNNING) {\n\t\t/* In non-interactive shells, we _can_ get\n\t\t * a keyboard signal here and be EINTRed,\n\t\t * but we just loop back, waiting for command to complete.\n\t\t *\n\t\t * man bash:\n\t\t * \"If bash is waiting for a command to complete and receives\n\t\t * a signal for which a trap has been set, the trap\n\t\t * will not be executed until the command completes.\"\n\t\t *\n\t\t * Reality is that even if trap is not set, bash\n\t\t * will not act on the signal until command completes.\n\t\t * Try this. sleep5intoff.c:\n\t\t * #include <signal.h>\n\t\t * #include <unistd.h>\n\t\t * int main() {\n\t\t *         sigset_t set;\n\t\t *         sigemptyset(&set);\n\t\t *         sigaddset(&set, SIGINT);\n\t\t *         sigaddset(&set, SIGQUIT);\n\t\t *         sigprocmask(SIG_BLOCK, &set, NULL);\n\t\t *         sleep(5);\n\t\t *         return 0;\n\t\t * }\n\t\t * $ bash -c './sleep5intoff; echo hi'\n\t\t * ^C^C^C^C <--- pressing ^C once a second\n\t\t * $ _\n\t\t * $ bash -c './sleep5intoff; echo hi'\n\t\t * ^\\^\\^\\^\\hi <--- pressing ^\\ (SIGQUIT)\n\t\t * $ _\n\t\t */\n\t\tdowait(DOWAIT_BLOCK, jp);\n\t}\n\tINT_ON;\n\n\tst = getstatus(jp);\n#if JOBS\n\tif (jp->jobctl) {\n\t\txtcsetpgrp(ttyfd, rootpid);\n\t\t/*\n\t\t * This is truly gross.\n\t\t * If we're doing job control, then we did a TIOCSPGRP which\n\t\t * caused us (the shell) to no longer be in the controlling\n\t\t * session -- so we wouldn't have seen any ^C/SIGINT.  So, we\n\t\t * intuit from the subprocess exit status whether a SIGINT\n\t\t * occurred, and if so interrupt ourselves.  Yuck.  - mycroft\n\t\t */\n\t\tif (jp->sigint) /* TODO: do the same with all signals */\n\t\t\traise(SIGINT); /* ... by raise(jp->sig) instead? */\n\t}\n\tif (jp->state == JOBDONE)\n#endif\n\t\tfreejob(jp);\n\treturn st;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E4DF8(__int64 a1, __int64 a2, __int64 a3)\n{\n  char **v3; // rbx\n  const char *i; // [rsp+28h] [rbp-18h]\n\n  for ( i = (const char *)(*(_QWORD *)a3 + a1); *i == 47; ++i )\n    ;\n  *(_QWORD *)(a3 + 16) = sub_50C0E1(*(_QWORD *)(a3 + 16), 2054LL, *(unsigned int *)(a3 + 12));\n  v3 = (char **)(*(_QWORD *)(a3 + 16) + 8LL * *(int *)(a3 + 12));\n  *v3 = sub_40A11F(i, 2054LL);\n  ++*(_DWORD *)(a3 + 12);\n  return 1LL;\n}\n\n\n Revised code:\nstatic void add_to_dirlist(const char *name, struct dir_list **list)\n{\n\tstruct dir_list *dp;\n\n\tdp = xmalloc(sizeof(struct dir_list));\n\tdp->name = blkid_strdup(name);\n\tdp->next = *list;\n\t*list = dp;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4707B3(const char *a1, __int64 a2)\n{\n  void **v2; // rdi\n  void ***v4; // [rsp+18h] [rbp-8h]\n\n  v4 = (void ***)sub_470562(a1);\n  if ( !*v4 )\n    return 1LL;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  v2 = *v4;\n  *v4 = sub_470668(*v4);\n  sub_46E03F(v2, a2);\n  return 0LL;\n}\n"
    },
    {
        "func_name": "chksum_and_xwrite",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4D22AA(__int64 a1)\n{\n  unsigned int *v1; // rax\n  __int64 v3; // [rsp+10h] [rbp-18h]\n  int v4; // [rsp+1Ch] [rbp-Ch]\n  unsigned int *v5; // [rsp+20h] [rbp-8h]\n\n  v5 = (unsigned int *)(a1 + 56);\n  v4 = 2;\n  v3 = 0LL;\n  do\n  {\n    v1 = v5++;\n    v3 = (v3 << 32) | *v1;\n    --v4;\n  }\n  while ( v4 );\n  return v3;\n}\n\n\n Revised code:\nstatic unsigned long long get_f_fsid(const struct statfs *statfsbuf)\n{\n\tconst unsigned *p = (const void*) &statfsbuf->f_fsid;\n\tunsigned sz = sizeof(statfsbuf->f_fsid) / sizeof(unsigned);\n\tunsigned long long r = 0;\n\n\tdo\n\t\tr = (r << (sizeof(unsigned)*8)) | *p++;\n\twhile (--sz > 0);\n\treturn r;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B5CAD(int a1, __int64 a2)\n{\n  int v3; // [rsp+Ch] [rbp-14h]\n  unsigned int v4; // [rsp+Ch] [rbp-14h]\n  __off64_t v5; // [rsp+18h] [rbp-8h]\n\n  v3 = a1;\n  v5 = sub_40A557(3, 0LL, 1);\n  if ( !a1 )\n    v3 = sub_4B5B97(3LL, 0LL);\n  sub_40A557(3, (unsigned int)(v3 + 4), 0);\n  sub_507452(3LL, a2, 42LL);\n  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a2 + 12);\n  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a2 + 16);\n  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a2 + 20);\n  *(_WORD *)(a2 + 24) = *(_WORD *)(a2 + 24);\n  *(_WORD *)(a2 + 26) = *(_WORD *)(a2 + 26);\n  *(_WORD *)(a2 + 28) = *(_WORD *)(a2 + 28);\n  *(_WORD *)a2 = *(_WORD *)a2;\n  *(_DWORD *)(a2 + 34) = *(_DWORD *)(a2 + 34);\n  v4 = *(unsigned __int16 *)(a2 + 26) + *(unsigned __int16 *)(a2 + 24) + 46 + *(unsigned __int16 *)(a2 + 28) + v3;\n  sub_40A557(3, v5, 0);\n  return v4;\n}\n\n\n Revised code:\nstatic uint32_t read_next_cdf(uint32_t cdf_offset, cdf_header_t *cdf_ptr)\n{\n\toff_t org;\n\n\torg = xlseek(zip_fd, 0, SEEK_CUR);\n\n\tif (!cdf_offset)\n\t\tcdf_offset = find_cdf_offset();\n\n\txlseek(zip_fd, cdf_offset + 4, SEEK_SET);\n\txread(zip_fd, cdf_ptr->raw, CDF_HEADER_LEN);\n\tFIX_ENDIANNESS_CDF(*cdf_ptr);\n\tcdf_offset += 4 + CDF_HEADER_LEN\n\t\t+ cdf_ptr->formatted.file_name_length\n\t\t+ cdf_ptr->formatted.extra_field_length\n\t\t+ cdf_ptr->formatted.file_comment_length;\n\n\txlseek(zip_fd, org, SEEK_SET);\n\treturn cdf_offset;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_44924D(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  void *v3; // rdx\n  int v4; // [rsp+18h] [rbp-8h]\n  int v5; // [rsp+1Ch] [rbp-4h]\n\n  v5 = *(_DWORD *)(a1 + 44) - 1;\n  while ( v5 >= 0 )\n  {\n    if ( a2 == *(__int16 *)(2LL * v5 + *(_QWORD *)a1) )\n    {\n      sub_44909B(a1, v5--);\n    }\n    else\n    {\n      if ( a2 < *(__int16 *)(2LL * v5 + *(_QWORD *)a1) )\n        --*(_WORD *)(2LL * v5 + *(_QWORD *)a1);\n      --v5;\n    }\n  }\n  v4 = 8 * (--*(_DWORD *)(a1 + 48) - a2);\n  if ( v4 > 0 )\n  {\n    memcpy((void *)(*(_QWORD *)(a1 + 8) + 8LL * a2), (const void *)(*(_QWORD *)(a1 + 8) + 8 * (a2 + 1LL)), v4);\n    if ( *(_DWORD *)(a1 + 40) )\n      memcpy((void *)(*(_QWORD *)(a1 + 16) + 8LL * a2), (const void *)(*(_QWORD *)(a1 + 16) + 8 * (a2 + 1LL)), v4);\n  }\n  *(_QWORD *)(a1 + 8) = sub_40A09E(*(void **)(a1 + 8), 8LL * *(int *)(a1 + 48));\n  result = *(unsigned int *)(a1 + 40);\n  if ( (_DWORD)result )\n  {\n    v3 = sub_40A09E(*(void **)(a1 + 16), 8LL * *(int *)(a1 + 48));\n    result = a1;\n    *(_QWORD *)(a1 + 16) = v3;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void remove_peer(isrv_state_t *state, int peer)\n{\n\tint movesize;\n\tint fd;\n\n\tDPRINTF(\"remove_peer(%d)\", peer);\n\n\tfd = FD_COUNT - 1;\n\twhile (fd >= 0) {\n\t\tif (FD2PEER[fd] == peer) {\n\t\t\tisrv_close_fd(state, fd);\n\t\t\tfd--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (FD2PEER[fd] > peer)\n\t\t\tFD2PEER[fd]--;\n\t\tfd--;\n\t}\n\n\tPEER_COUNT--;\n\tDPRINTF(\"remove_peer: PEER_COUNT %d\", PEER_COUNT);\n\n\tmovesize = (PEER_COUNT - peer) * sizeof(void*);\n\tif (movesize > 0) {\n\t\tmemcpy(&PARAM_TBL[peer], &PARAM_TBL[peer+1], movesize);\n\t\tif (TIMEOUT)\n\t\t\tmemcpy(&TIMEO_TBL[peer], &TIMEO_TBL[peer+1], movesize);\n\t}\n\tPARAM_TBL = xrealloc(PARAM_TBL, PEER_COUNT * sizeof(PARAM_TBL[0]));\n\tif (TIMEOUT)\n\t\tTIMEO_TBL = xrealloc(TIMEO_TBL, PEER_COUNT * sizeof(TIMEO_TBL[0]));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_4B46FF(unsigned int a1, __int64 a2)\n{\n  unsigned __int8 *v2; // rax\n  int v3; // [rsp+10h] [rbp-10h]\n  int v4; // [rsp+14h] [rbp-Ch]\n  unsigned __int8 *v5; // [rsp+18h] [rbp-8h]\n\n  *(_QWORD *)(a2 + 257) = 0x20207261747375LL;\n  memset((void *)(a2 + 148), 32, 8uLL);\n  v5 = (unsigned __int8 *)a2;\n  v4 = 0;\n  v3 = 512;\n  do\n  {\n    v2 = v5++;\n    v4 += *v2;\n    --v3;\n  }\n  while ( v3 );\n  sub_4B468C((void *)(a2 + 148), 7, v4);\n  sub_40A4AB(a1, a2, 512LL);\n}\n"
    },
    {
        "func_name": "get_inode_common",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_497D29(__int64 a1, unsigned int a2)\n{\n  int result; // eax\n  const char *v3; // rdx\n  unsigned __int16 *v4; // [rsp+18h] [rbp-18h]\n  char *s2; // [rsp+20h] [rbp-10h]\n  unsigned int v6; // [rsp+28h] [rbp-8h]\n  unsigned int v7; // [rsp+2Ch] [rbp-4h]\n\n  v6 = sub_4964AA(a1, a2 >> 10);\n  sub_496301(v6, (char *)qword_75D408 + 4516);\n  s2 = (char *)qword_75D408 + (a2 & 0x3FF) + 4518;\n  v7 = *(unsigned __int16 *)((char *)qword_75D408 + (a2 & 0x3FF) + 4516);\n  if ( *((unsigned __int16 *)qword_75D408 + 210) < v7 )\n  {\n    printf(\n      \"%s contains a bad inode number for file '%.*s'. \",\n      (const char *)qword_75D408 + 5540,\n      *((char *)qword_75D408 + 5),\n      s2);\n    if ( (unsigned int)sub_49602F((__int64)\"Remove\", 1u) )\n    {\n      *((_WORD *)s2 - 1) = 0;\n      sub_4963B6(v6, (__int64)qword_75D408 + 4516);\n    }\n    v7 = 0;\n  }\n  sub_495F08(s2);\n  v4 = sub_4973B9(v7);\n  sub_495FC0();\n  if ( !a2 )\n  {\n    if ( v4 )\n    {\n      if ( *s2 == 46 )\n      {\n        result = (unsigned __int8)s2[1];\n        if ( !(_BYTE)result )\n          return result;\n      }\n    }\n    printf(\"%s: bad directory: '.' isn't first\\n\", (const char *)qword_75D408 + 5540);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  result = *((char *)qword_75D408 + 4);\n  if ( a2 == result )\n  {\n    if ( v4 )\n    {\n      result = strcmp(\"..\", s2);\n      if ( !result )\n        return result;\n    }\n    printf(\"%s: bad directory: '..' isn't second\\n\", (const char *)qword_75D408 + 5540);\n    result = (int)qword_75D408;\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  if ( v4 )\n  {\n    sub_495F08(s2);\n    if ( (dword_75D450 & 1) != 0 )\n    {\n      if ( (dword_75D450 & 8) != 0 )\n        printf(\"%6d %07o %3d \", v7, *v4, *((unsigned __int8 *)v4 + 13));\n      if ( (*v4 & 0xF000) == 0x4000 )\n        v3 = \":\";\n      else\n        v3 = (const char *)&unk_52F2AE;\n      printf(\"%s%s\\n\", (const char *)qword_75D408 + 5540, v3);\n    }\n    sub_497A94(v7);\n    if ( (*v4 & 0xF000) == 0x4000 )\n      sub_49828D(v7);\n    return sub_495FC0();\n  }\n  return result;\n}\n\n\n Revised code:\nendif\n\nstatic void check_file(struct minix1_inode *dir, unsigned offset)\n{\n\tstruct minix1_inode *inode;\n\tint ino;\n\tchar *name;\n\tint block;\n\n\tblock = map_block(dir, offset / BLOCK_SIZE);\n\tread_block(block, check_file_blk);\n\tname = check_file_blk + (offset % BLOCK_SIZE) + 2;\n\tino = *(uint16_t *) (name - 2);\n\tif (ino > INODES) {\n\t\tprintf(\"%s contains a bad inode number for file '%.*s'. \",\n\t\t\t\tcurrent_name, namelen, name);\n\t\tif (ask(\"Remove\", 1)) {\n\t\t\t*(uint16_t *) (name - 2) = 0;\n\t\t\twrite_block(block, check_file_blk);\n\t\t}\n\t\tino = 0;\n\t}\n\tpush_filename(name);\n\tinode = get_inode(ino);\n\tpop_filename();\n\tif (!offset) {\n\t\tif (inode && LONE_CHAR(name, '.'))\n\t\t\treturn;\n\t\tprintf(\"%s: bad directory: '.' isn't first\\n\", current_name);\n\t\terrors_uncorrected = 1;\n\t}\n\tif (offset == dirsize) {\n\t\tif (inode && strcmp(\"..\", name) == 0)\n\t\t\treturn;\n\t\tprintf(\"%s: bad directory: '..' isn't second\\n\", current_name);\n\t\terrors_uncorrected = 1;\n\t}\n\tif (!inode)\n\t\treturn;\n\tpush_filename(name);\n\tif (OPT_list) {\n\t\tif (OPT_verbose)\n\t\t\tprintf(\"%6d %07o %3d \", ino, inode->i_mode, inode->i_nlinks);\n\t\tprintf(\"%s%s\\n\", current_name, S_ISDIR(inode->i_mode) ? \":\" : \"\");\n\t}\n\tcheck_zones(ino);\n\tif (inode && S_ISDIR(inode->i_mode))\n\t\trecursive_check(ino);\n\tpop_filename();\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_497FDB(unsigned int *a1, unsigned int a2)\n{\n  int result; // eax\n  const char *v3; // rdx\n  unsigned __int16 *v4; // [rsp+18h] [rbp-18h]\n  char *s2; // [rsp+20h] [rbp-10h]\n  unsigned int v6; // [rsp+28h] [rbp-8h]\n  unsigned int v7; // [rsp+2Ch] [rbp-4h]\n\n  v6 = sub_49664E(a1, a2 >> 10);\n  sub_496301(v6, (char *)qword_75D408 + 4516);\n  s2 = (char *)qword_75D408 + (a2 & 0x3FF) + 4518;\n  v7 = *(unsigned __int16 *)((char *)qword_75D408 + (a2 & 0x3FF) + 4516);\n  if ( *((unsigned __int16 *)qword_75D408 + 210) < v7 )\n  {\n    printf(\n      \"%s contains a bad inode number for file '%.*s'. \",\n      (const char *)qword_75D408 + 5540,\n      *((char *)qword_75D408 + 5),\n      s2);\n    if ( (unsigned int)sub_49602F((__int64)\"Remove\", 1u) )\n    {\n      *((_WORD *)s2 - 1) = 0;\n      sub_4963B6(v6, (__int64)qword_75D408 + 4516);\n    }\n    v7 = 0;\n  }\n  sub_495F08(s2);\n  v4 = sub_497422(v7);\n  sub_495FC0();\n  if ( !a2 )\n  {\n    if ( v4 )\n    {\n      if ( *s2 == 46 )\n      {\n        result = (unsigned __int8)s2[1];\n        if ( !(_BYTE)result )\n          return result;\n      }\n    }\n    printf(\"%s: bad directory: '.' isn't first\\n\", (const char *)qword_75D408 + 5540);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  result = *((char *)qword_75D408 + 4);\n  if ( a2 == result )\n  {\n    if ( v4 )\n    {\n      result = strcmp(\"..\", s2);\n      if ( !result )\n        return result;\n    }\n    printf(\"%s: bad directory: '..' isn't second\\n\", (const char *)qword_75D408 + 5540);\n    result = (int)qword_75D408;\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  if ( v4 )\n  {\n    sub_495F08(s2);\n    if ( (dword_75D450 & 1) != 0 )\n    {\n      if ( (dword_75D450 & 8) != 0 )\n        printf(\"%6d %07o %3d \", v7, *v4, v4[1]);\n      if ( (*v4 & 0xF000) == 0x4000 )\n        v3 = \":\";\n      else\n        v3 = (const char *)&unk_52F2AE;\n      printf(\"%s%s\\n\", (const char *)qword_75D408 + 5540, v3);\n    }\n    sub_497BCD(v7);\n    if ( (*v4 & 0xF000) == 0x4000 )\n      sub_498354(v7);\n    return sub_495FC0();\n  }\n  return result;\n}\n\n\n Revised code:\nif ENABLE_FEATURE_MINIX2\nstatic void check_file2(struct minix2_inode *dir, unsigned offset)\n{\n\tstruct minix2_inode *inode;\n\tint ino;\n\tchar *name;\n\tint block;\n\n\tblock = map_block2(dir, offset / BLOCK_SIZE);\n\tread_block(block, check_file_blk);\n\tname = check_file_blk + (offset % BLOCK_SIZE) + 2;\n\tino = *(uint16_t *) (name - 2);\n\tif (ino > INODES) {\n\t\tprintf(\"%s contains a bad inode number for file '%.*s'. \",\n\t\t\t\tcurrent_name, namelen, name);\n\t\tif (ask(\"Remove\", 1)) {\n\t\t\t*(uint16_t *) (name - 2) = 0;\n\t\t\twrite_block(block, check_file_blk);\n\t\t}\n\t\tino = 0;\n\t}\n\tpush_filename(name);\n\tinode = get_inode2(ino);\n\tpop_filename();\n\tif (!offset) {\n\t\tif (inode && LONE_CHAR(name, '.'))\n\t\t\treturn;\n\t\tprintf(\"%s: bad directory: '.' isn't first\\n\", current_name);\n\t\terrors_uncorrected = 1;\n\t}\n\tif (offset == dirsize) {\n\t\tif (inode && strcmp(\"..\", name) == 0)\n\t\t\treturn;\n\t\tprintf(\"%s: bad directory: '..' isn't second\\n\", current_name);\n\t\terrors_uncorrected = 1;\n\t}\n\tif (!inode)\n\t\treturn;\n\tpush_filename(name);\n\tif (OPT_list) {\n\t\tif (OPT_verbose)\n\t\t\tprintf(\"%6d %07o %3d \", ino, inode->i_mode, inode->i_nlinks);\n\t\tprintf(\"%s%s\\n\", current_name, S_ISDIR(inode->i_mode) ? \":\" : \"\");\n\t}\n\tcheck_zones2(ino);\n\tif (inode && S_ISDIR(inode->i_mode))\n\t\trecursive_check2(ino);\n\tpop_filename();\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E7583(int a1, const void *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  int v7; // [rsp+8h] [rbp-18h]\n  _QWORD *ptr; // [rsp+10h] [rbp-10h]\n  char *v9; // [rsp+18h] [rbp-8h]\n\n  v7 = a3;\n  if ( a1 <= 0 || a1 > *((_DWORD *)qword_75D408 + 1) + 1 )\n  {\n    sub_409747(\"inserting at bad line number\", (__int64)a2, a3, a4, a5, a6, a2);\n    return 0LL;\n  }\n  ptr = sub_40A05F((int)a3 + 23LL, (__int64)a2);\n  memcpy((char *)ptr + 20, a2, v7);\n  *((_DWORD *)ptr + 4) = v7;\n  if ( a1 <= *((_DWORD *)qword_75D408 + 1) )\n  {\n    v9 = (char *)sub_4E78F6((unsigned int)a1);\n    if ( !v9 )\n    {\n      free(ptr);\n      return 0LL;\n    }\n  }\n  else\n  {\n    v9 = (char *)qword_75D408 + 48;\n  }\n  *ptr = v9;\n  ptr[1] = *((_QWORD *)v9 + 1);\n  **((_QWORD **)v9 + 1) = ptr;\n  *((_QWORD *)v9 + 1) = ptr;\n  ++*((_DWORD *)qword_75D408 + 1);\n  *((_BYTE *)qword_75D408 + 72) = 1;\n  return sub_4E7A44((unsigned int)a1);\n}\n\n\n Revised code:\nstatic int insertLine(int num, const char *data, int len)\n{\n\tLINE *newLp, *lp;\n\n\tif ((num < 1) || (num > lastNum + 1)) {\n\t\tbb_error_msg(\"inserting at bad line number\");\n\t\treturn FALSE;\n\t}\n\n\tnewLp = xmalloc(sizeof(LINE) + len - 1);\n\n\tmemcpy(newLp->data, data, len);\n\tnewLp->len = len;\n\n\tif (num > lastNum)\n\t\tlp = &lines;\n\telse {\n\t\tlp = findLine(num);\n\t\tif (lp == NULL) {\n\t\t\tfree((char *) newLp);\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tnewLp->next = lp;\n\tnewLp->prev = lp->prev;\n\tlp->prev->next = newLp;\n\tlp->prev = newLp;\n\n\tlastNum++;\n\tdirty = TRUE;\n\treturn setCurNum(num);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nunsigned __int64 __fastcall sub_49719D(unsigned int a1, unsigned __int16 a2)\n{\n  _BYTE *v2; // rax\n  unsigned __int64 result; // rax\n\n  ++*((_DWORD *)qword_75D408 + 10);\n  if ( *(_BYTE *)(*((_QWORD *)qword_75D408 + 9) + a1) )\n  {\n    ++*((_DWORD *)qword_75D408 + 8);\n  }\n  else\n  {\n    if ( !(unsigned int)sub_495DF1(*((_QWORD *)qword_75D408 + 7), a1) )\n    {\n      printf(\"Inode %d is marked as 'unused', but it is used for file '%s'\\n\", a1, (const char *)qword_75D408 + 5540);\n      if ( (dword_75D450 & 4) != 0 )\n      {\n        if ( (unsigned int)sub_49602F((__int64)\"Mark as 'in use'\", 1u) )\n          sub_495E26(*((_QWORD *)qword_75D408 + 7), a1);\n        else\n          *((_BYTE *)qword_75D408 + 2) = 1;\n      }\n    }\n    switch ( a2 & 0xF000 )\n    {\n      case 16384:\n        ++*((_DWORD *)qword_75D408 + 4);\n        break;\n      case 32768:\n        ++*((_DWORD *)qword_75D408 + 5);\n        break;\n      case 8192:\n        ++*((_DWORD *)qword_75D408 + 7);\n        break;\n      case 24576:\n        ++*((_DWORD *)qword_75D408 + 6);\n        break;\n      case 40960:\n        ++*((_DWORD *)qword_75D408 + 9);\n        break;\n      default:\n        if ( (a2 & 0xF000) != 49152 && (a2 & 0xF000) != 4096 )\n          printf(\"%s has mode %05o\\n\", (const char *)qword_75D408 + 5540, a2);\n        break;\n    }\n  }\n  v2 = (_BYTE *)(*((_QWORD *)qword_75D408 + 9) + a1);\n  result = (unsigned __int8)++*v2;\n  if ( !(_BYTE)result )\n  {\n    puts(\"Warning: inode count too big\");\n    --*(_BYTE *)(*((_QWORD *)qword_75D408 + 9) + a1);\n    result = (unsigned __int64)qword_75D408;\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "print_selected_addrinfo",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48DACE(__int64 a1)\n{\n  int v2; // [rsp+1Ch] [rbp-4h]\n\n  if ( *(_QWORD *)(a1 + 8) )\n    return sub_40A999(*(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 4LL), 2u, 0);\n  v2 = sub_40BCE2();\n  if ( (unsigned int)(v2 - *(_DWORD *)(a1 + 4)) <= 0x77 )\n    return 0xFFFFFFFFLL;\n  *(_DWORD *)(a1 + 4) = v2;\n  *(_QWORD *)(a1 + 8) = sub_50BB00(*(_QWORD *)(a1 + 16), 514LL);\n  if ( *(_QWORD *)(a1 + 8) )\n    return sub_40A999(*(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 4LL), 2u, 0);\n  else\n    return 0xFFFFFFFFLL;\n}\n\n\n Revised code:\nif ENABLE_FEATURE_REMOTE_LOG\nstatic int try_to_resolve_remote(remoteHost_t *rh)\n{\n\tif (!rh->remoteAddr) {\n\t\tunsigned now = monotonic_sec();\n\n\t\t/* Don't resolve name too often - DNS timeouts can be big */\n\t\tif ((now - rh->last_dns_resolve) < DNS_WAIT_SEC)\n\t\t\treturn -1;\n\t\trh->last_dns_resolve = now;\n\t\trh->remoteAddr = host2sockaddr(rh->remoteHostname, 514);\n\t\tif (!rh->remoteAddr)\n\t\t\treturn -1;\n\t}\n\treturn xsocket(rh->remoteAddr->u.sa.sa_family, SOCK_DGRAM, 0);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4517B7(_DWORD *a1, signed int a2, __int16 a3, int a4)\n{\n  char *v5; // [rsp+14h] [rbp-10h]\n\n  if ( a2 < (int)(((*a1 + 3) & 0xFFFFFFFC) + 8) )\n    return 0xFFFFFFFFLL;\n  v5 = (char *)a1 + ((*a1 + 3) & 0xFFFFFFFC);\n  *((_WORD *)v5 + 1) = a3;\n  *(_WORD *)v5 = 8;\n  *((_DWORD *)v5 + 1) = a4;\n  *a1 = ((*a1 + 3) & 0xFFFFFFFC) + 8;\n  return 0LL;\n}\n\n\n Revised code:\nint FAST_FUNC addattr32(struct nlmsghdr *n, int maxlen, int type, uint32_t data)\n{\n\tint len = RTA_LENGTH(4);\n\tstruct rtattr *rta;\n\n\tif ((int)(NLMSG_ALIGN(n->nlmsg_len) + len) > maxlen) {\n\t\treturn -1;\n\t}\n\trta = (struct rtattr*)(((char*)n) + NLMSG_ALIGN(n->nlmsg_len));\n\trta->rta_type = type;\n\trta->rta_len = len;\n\tmove_to_unaligned32(RTA_DATA(rta), data);\n\tn->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + len;\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4519A9(_WORD *a1, unsigned int a2, __int16 a3, const void *a4, int a5)\n{\n  _WORD *v6; // [rsp+20h] [rbp-10h]\n  __int16 v7; // [rsp+2Ch] [rbp-4h]\n\n  v7 = a5 + 4;\n  if ( a5 + 4 + (((unsigned __int16)*a1 + 3) & 0xFFFFFFFC) > a2 )\n    return 0xFFFFFFFFLL;\n  v6 = (_WORD *)((char *)a1 + (((unsigned __int16)*a1 + 3) & 0xFFFFFFFC));\n  v6[1] = a3;\n  *v6 = v7;\n  memcpy(v6 + 2, a4, a5);\n  *a1 = v7 + ((*a1 + 3) & 0xFFFC);\n  return 0LL;\n}\n\n\n Revised code:\nint FAST_FUNC rta_addattr_l(struct rtattr *rta, int maxlen, int type, void *data, int alen)\n{\n\tstruct rtattr *subrta;\n\tint len = RTA_LENGTH(alen);\n\n\tif (RTA_ALIGN(rta->rta_len) + len > maxlen) {\n\t\treturn -1;\n\t}\n\tsubrta = (struct rtattr*)(((char*)rta) + RTA_ALIGN(rta->rta_len));\n\tsubrta->rta_type = type;\n\tsubrta->rta_len = len;\n\tmemcpy(RTA_DATA(subrta), data, alen);\n\trta->rta_len = NLMSG_ALIGN(rta->rta_len) + len;\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_44A9F7(int a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  _WORD *v8; // [rsp+18h] [rbp-8h]\n\n  while ( a2 )\n  {\n    v8 = a2 + 1;\n    if ( *((_WORD *)a2 + 6) == 20 )\n    {\n      if ( *(_DWORD *)v8 <= 0x17u )\n        return 0xFFFFFFFFLL;\n      if ( *((_DWORD *)a2 + 7) == a1\n        && (!LOBYTE(dest.c_ispeed) || SLOBYTE(dest.c_ispeed) == *((unsigned __int8 *)a2 + 24)) )\n      {\n        sub_44A1F6(0LL, v8, 0LL, a4, a5, a6);\n      }\n    }\n    a2 = (__int64 *)*a2;\n  }\n  return 0LL;\n}\n"
    },
    {
        "func_name": "rollback_token",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nchar *sub_4B11D5()\n{\n  char *result; // rax\n\n  *((_WORD *)qword_75D408 - 7) = 0;\n  result = (char *)qword_75D408 - 88;\n  *((_DWORD *)qword_75D408 - 3) = 0;\n  return result;\n}\n\n\n Revised code:\nstatic void bi_init(void)\n{\n\tG1.bi_buf = 0;\n\tG1.bi_valid = 0;\n#ifdef DEBUG\n\tG1.bits_sent = 0L;\n#endif\n}\n\n## Example:\n\n Input code:\nvoid *sub_4249C8()\n{\n  void *result; // rax\n\n  result = qword_75D408;\n  *((_DWORD *)qword_75D408 + 7) = 0;\n  return result;\n}\n\n\n Revised code:\nstatic void reset_stringbuf(void)\n{\n\tstringbuf_idx = 0;\n}\n\n## Example:\n\n Input code:\nvoid *sub_4EEE98()\n{\n  void *result; // rax\n\n  *((_DWORD *)qword_75D408 + 44) = 26;\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 118) = 0;\n  return result;\n}\n\n\n Revised code:\nstatic void end_cmd_q(void)\n{\n#if ENABLE_FEATURE_VI_YANKMARK\n\tYDreg = 26;\t\t\t// go back to default Yank/Delete reg\n#endif\n\tadding2q = 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *sub_4DD839()\n{\n  char *result; // rax\n\n  result = (char *)qword_75D408 - 208;\n  *((char *)qword_75D408 - 3) = 1;\n  return result;\n}\n"
    },
    {
        "func_name": "remove_chunk",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A3D68(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+0h] [rbp-1Ch]\n  int v4; // [rsp+14h] [rbp-8h]\n  unsigned int i; // [rsp+18h] [rbp-4h]\n\n  v3 = a2;\n  if ( a2 )\n  {\n    v3 = a2 - 1;\n    if ( a2 != 1 && *(_DWORD *)(4LL * v3 + a1) == 10 )\n      v3 = a2 - 2;\n  }\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i >= v3 )\n      break;\n    v4 = *(_DWORD *)(4LL * (int)i + a1);\n    *(_DWORD *)(4LL * (int)i + a1) = *(_DWORD *)(4LL * v3 + a1);\n    *(_DWORD *)(a1 + 4LL * v3--) = v4;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void strrev(CHAR_T *s, int len)\n{\n\tint i;\n\n\tif (len != 0) {\n\t\tlen--;\n\t\tif (len != 0 && s[len] == '\\n')\n\t\t\tlen--;\n\t}\n\n\tfor (i = 0; i < len; i++, len--) {\n\t\tCHAR_T c = s[i];\n\t\ts[i] = s[len];\n\t\ts[len] = c;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A8B04(__int64 a1, int a2, int a3, int a4)\n{\n  __int64 result; // rax\n  unsigned int v8; // [rsp+20h] [rbp-4h]\n\n  while ( a4 > 0 )\n  {\n    v8 = *(_DWORD *)(4LL * a2 + a1);\n    *(_DWORD *)(4LL * a2 + a1) = *(_DWORD *)(4LL * a3 + a1);\n    result = v8;\n    *(_DWORD *)(a1 + 4LL * a3) = v8;\n    ++a2;\n    ++a3;\n    --a4;\n  }\n  return result;\n}\n\n\n Revised code:\nvoid mvswap(uint32_t* ptr, int32_t zzp1, int32_t zzp2, int32_t zzn)\n{\n\twhile (zzn > 0) {\n\t\tmswap(ptr[zzp1], ptr[zzp2]);\n\t\tzzp1++;\n\t\tzzp2++;\n\t\tzzn--;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4DF387(int *a1, __int64 a2)\n{\n  int v2; // eax\n  __int64 result; // rax\n  __int64 v4; // [rsp+10h] [rbp-20h]\n  __int64 v5; // [rsp+18h] [rbp-18h]\n  __int64 v6; // [rsp+24h] [rbp-Ch]\n  __int64 i; // [rsp+28h] [rbp-8h]\n\n  if ( (*a1 & 0x800) != 0 )\n  {\n    v5 = *((_QWORD *)a1 + 3);\n  }\n  else\n  {\n    v2 = *a1;\n    BYTE1(v2) = BYTE1(*a1) | 8;\n    *a1 = v2;\n    v5 = 0LL;\n  }\n  *((_QWORD *)a1 + 3) = sub_40A0E8(*(unsigned int *)(a2 + 12) + 33LL, a2);\n  v4 = *((_QWORD *)a1 + 3);\n  *(_QWORD *)v4 = v4 + 24;\n  *(_QWORD *)(v4 + 8) = *(_QWORD *)v4;\n  *(_QWORD *)(v4 + 16) = v5;\n  LODWORD(v6) = 0;\n  while ( 1 )\n  {\n    result = *(unsigned int *)(a2 + 4);\n    if ( (unsigned int)v6 >= (unsigned int)result )\n      break;\n    for ( i = *(_QWORD *)(8LL * (unsigned int)v6 + *(_QWORD *)(a2 + 16)); i; i = *(_QWORD *)(i + 32) )\n    {\n      strcpy(*(char **)v4, (const char *)(i + 40));\n      sub_4DC55F((__int64 *)v4);\n    }\n    v6 = (unsigned int)(v6 + 1);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void hashwalk_init(var *v, xhash *array)\n{\n\thash_item *hi;\n\tunsigned i;\n\twalker_list *w;\n\twalker_list *prev_walker;\n\n\tif (v->type & VF_WALK) {\n\t\tprev_walker = v->x.walker;\n\t} else {\n\t\tv->type |= VF_WALK;\n\t\tprev_walker = NULL;\n\t}\n\tdebug_printf_walker(\"hashwalk_init: prev_walker:%p\\n\", prev_walker);\n\n\tw = v->x.walker = xzalloc(sizeof(*w) + array->glen + 1); /* why + 1? */\n\tdebug_printf_walker(\" walker@%p=%p\\n\", &v->x.walker, w);\n\tw->cur = w->end = w->wbuf;\n\tw->prev = prev_walker;\n\tfor (i = 0; i < array->csize; i++) {\n\t\thi = array->items[i];\n\t\twhile (hi) {\n\t\t\tstrcpy(w->end, hi->name);\n\t\t\tnextword(&w->end);\n\t\t\thi = hi->next;\n\t\t}\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4FEB8C(__int64 a1, unsigned int a2, int a3)\n{\n  __int64 result; // rax\n  _WORD *v4; // rax\n  int v5; // [rsp+0h] [rbp-10h]\n  unsigned int v6; // [rsp+4h] [rbp-Ch]\n\n  v6 = a2;\n  v5 = a3;\n  result = a2;\n  if ( a2 != a3 )\n  {\n    while ( 1 )\n    {\n      v4 = (_WORD *)(2LL * (int)v6 + a1);\n      *v4 = *(_WORD *)(a1 + 2LL * v5);\n      result = (unsigned __int16)*v4;\n      if ( !(_WORD)result )\n        break;\n      ++v6;\n      ++v5;\n    }\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "makejob",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_492E03(int *a1)\n{\n  unsigned int v2; // [rsp+14h] [rbp-24h]\n  int v3; // [rsp+2Ch] [rbp-Ch]\n  unsigned int i; // [rsp+30h] [rbp-8h]\n  unsigned int v5; // [rsp+34h] [rbp-4h]\n\n  v5 = 0;\n  v3 = 0;\n  for ( i = 0; ; ++i )\n  {\n    if ( i >= *((_DWORD *)qword_75D408 + 4) )\n      return 0LL;\n    if ( i == 4 )\n    {\n      v3 = 4;\n      v5 = 0;\n    }\n    if ( *(_BYTE *)(*((_QWORD *)qword_75D408 + 5 * i + 313) + 4LL) )\n      break;\nLABEL_10:\n    ;\n  }\n  v2 = sub_490A13((__int64)qword_75D408 + 40 * i + 2504);\n  if ( v5 <= v2 )\n  {\n    v5 = v2;\n    v3 = i;\n    goto LABEL_10;\n  }\n  if ( a1 )\n    *a1 = v3;\n  return i;\n}\n\n\n Revised code:\nstatic int\nwrong_p_order(int *prev)\n{\n\tconst struct pte *pe;\n\tconst struct partition *p;\n\tsector_t last_p_start_pos = 0, p_start_pos;\n\tunsigned i, last_i = 0;\n\n\tfor (i = 0; i < g_partitions; i++) {\n\t\tif (i == 4) {\n\t\t\tlast_i = 4;\n\t\t\tlast_p_start_pos = 0;\n\t\t}\n\t\tpe = &ptes[i];\n\t\tp = pe->part_table;\n\t\tif (p->sys_ind) {\n\t\t\tp_start_pos = get_partition_start_from_dev_start(pe);\n\n\t\t\tif (last_p_start_pos > p_start_pos) {\n\t\t\t\tif (prev)\n\t\t\t\t\t*prev = last_i;\n\t\t\t\treturn i;\n\t\t\t}\n\n\t\t\tlast_p_start_pos = p_start_pos;\n\t\t\tlast_i = i;\n\t\t}\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47DFAC(int a1, __int64 a2)\n{\n  _QWORD v3[5]; // [rsp+10h] [rbp-40h] BYREF\n  int v4; // [rsp+3Ch] [rbp-14h]\n  char *v5; // [rsp+40h] [rbp-10h]\n  int v6; // [rsp+48h] [rbp-8h]\n  int v7; // [rsp+4Ch] [rbp-4h]\n\n  v6 = 0;\n  while ( 1 )\n  {\n    sub_46E8A1(v3);\n    if ( byte_75AF98 )\n    {\n      a2 = 4LL;\n      sub_471D7E(stderr, 4);\n    }\n    v7 = 0;\n    if ( *(_BYTE *)(qword_75D418 + 60) && a1 )\n      ++v7;\n    v5 = (char *)sub_47DC41(v7);\n    if ( v5 != (char *)-1LL )\n    {\n      if ( !*(_BYTE *)(qword_75D418 + 62) )\n      {\n        *(char *)(qword_75D418 + 748) >>= 1;\n        v6 = 0;\n        a2 = 0LL;\n        sub_4781FB(v5, 0);\n      }\n      goto LABEL_16;\n    }\n    if ( !a1 || v6 > 49 )\n      return 0LL;\n    if ( !(unsigned int)sub_472FFC() )\n    {\n      if ( !*(_BYTE *)(qword_75D418 + 59) )\n        return 0LL;\n      sub_46E2EB(\"\\nUse \\\"exit\\\" to leave shell.\\n\");\n    }\n    ++v6;\nLABEL_16:\n    sub_46E905(v3, a2);\n    v4 = byte_75B040;\n    if ( byte_75B040 )\n    {\n      byte_75B040 = 0;\n      return v4 & 0x10;\n    }\n  }\n}\n\n\n Revised code:\nstatic int\ncmdloop(int top)\n{\n\tunion node *n;\n\tstruct stackmark smark;\n\tint inter;\n\tint numeof = 0;\n\n\tTRACE((\"cmdloop(%d) called\\n\", top));\n\tfor (;;) {\n\t\tint skip;\n\n\t\tsetstackmark(&smark);\n#if JOBS\n\t\tif (doing_jobctl)\n\t\t\tshowjobs(stderr, SHOW_CHANGED);\n#endif\n\t\tinter = 0;\n\t\tif (iflag && top) {\n\t\t\tinter++;\n\t\t\tchkmail();\n\t\t}\n\t\tn = parsecmd(inter);\n#if DEBUG\n\t\tif (DEBUG > 2 && debug && (n != NODE_EOF))\n\t\t\tshowtree(n);\n#endif\n\t\tif (n == NODE_EOF) {\n\t\t\tif (!top || numeof >= 50)\n\t\t\t\tbreak;\n\t\t\tif (!stoppedjobs()) {\n\t\t\t\tif (!Iflag)\n\t\t\t\t\tbreak;\n\t\t\t\tout2str(\"\\nUse \\\"exit\\\" to leave shell.\\n\");\n\t\t\t}\n\t\t\tnumeof++;\n\t\t} else if (nflag == 0) {\n\t\t\t/* job_warning can only be 2,1,0. Here 2->1, 1/0->0 */\n\t\t\tjob_warning >>= 1;\n\t\t\tnumeof = 0;\n\t\t\tevaltree(n, 0);\n\t\t}\n\t\tpopstackmark(&smark);\n\t\tskip = evalskip;\n\n\t\tif (skip) {\n\t\t\tevalskip = 0;\n\t\t\treturn skip & SKIPEVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_478959(__int64 a1, unsigned int a2)\n{\n  __int64 v2; // rsi\n  char *v3; // rdi\n  unsigned int v5; // [rsp+4h] [rbp-1Ch]\n  char *v7; // [rsp+10h] [rbp-10h]\n  int v8; // [rsp+18h] [rbp-8h]\n  char v9; // [rsp+1Ch] [rbp-4h]\n\n  v5 = a2;\n  v8 = *(_BYTE *)a1 == 3;\n  sub_478A54(*(_QWORD *)(a1 + 16));\n  if ( v8 || (a2 & 1) == 0 || *(_BYTE *)(qword_75D418 + 200) )\n  {\n    ++*(_DWORD *)(qword_75D418 + 48);\n    v7 = sub_472265(1);\n    v2 = a1;\n    v3 = v7;\n    if ( (unsigned int)sub_472EC3(v7, (const char *)a1, v8) )\n      goto LABEL_8;\n    sub_46E03F(v7, a1);\n    v5 |= 1u;\n    if ( v8 )\n      v5 &= ~2u;\n  }\n  sub_4735BF(*(_QWORD *)(a1 + 16), 0LL);\n  v2 = v5;\n  v3 = *(char **)(a1 + 8);\n  sub_4781FB(v3, v5);\nLABEL_8:\n  v9 = 0;\n  if ( !v8 )\n  {\n    v3 = v7;\n    v9 = sub_472F50((__int64)v7, v2);\n  }\n  byte_75AF50 = v9;\n  return sub_46E03F(v3, v2);\n}\n\n\n Revised code:\nstatic void\nevalsubshell(union node *n, int flags)\n{\n\tstruct job *jp;\n\tint backgnd = (n->type == NBACKGND);\n\tint status;\n\n\texpredir(n->nredir.redirect);\n\tif (!backgnd && (flags & EV_EXIT) && !may_have_traps)\n\t\tgoto nofork;\n\tINT_OFF;\n\tjp = makejob(/*n,*/ 1);\n\tif (forkshell(jp, n, backgnd) == 0) {\n\t\t/* child */\n\t\tINT_ON;\n\t\tflags |= EV_EXIT;\n\t\tif (backgnd)\n\t\t\tflags &= ~EV_TESTED;\n nofork:\n\t\tredirect(n->nredir.redirect, 0);\n\t\tevaltreenr(n->nredir.n, flags);\n\t\t/* never returns */\n\t}\n\tstatus = 0;\n\tif (!backgnd)\n\t\tstatus = waitforjob(jp);\n\texitstatus = status;\n\tINT_ON;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_472265(int a1)\n{\n  char *s; // [rsp+10h] [rbp-10h]\n  int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = dword_75AFA8;\n  for ( s = (char *)qword_75AFA0; ; s += 40 )\n  {\n    if ( --v3 < 0 )\n    {\n      s = sub_4720F1();\n      goto LABEL_10;\n    }\n    if ( (s[31] & 8) == 0 )\n      goto LABEL_10;\n    if ( s[30] == 2 && (s[31] & 4) != 0 && !byte_75AF98 )\n      break;\n  }\n  sub_47107C((__int64)s);\nLABEL_10:\n  memset(s, 0, 0x28uLL);\n  if ( byte_75AF98 )\n    s[31] |= 2u;\n  *((_QWORD *)s + 4) = qword_75AFB0;\n  qword_75AFB0 = (__int64)s;\n  s[31] |= 8u;\n  *((_QWORD *)s + 2) = s;\n  if ( a1 > 1 )\n    *((_QWORD *)s + 2) = sub_40A05F(16LL * a1, 0LL);\n  return s;\n}\n"
    },
    {
        "func_name": "hash_rebuild",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4DF387(int *a1, __int64 a2)\n{\n  int v2; // eax\n  __int64 result; // rax\n  __int64 v4; // [rsp+10h] [rbp-20h]\n  __int64 v5; // [rsp+18h] [rbp-18h]\n  __int64 v6; // [rsp+24h] [rbp-Ch]\n  __int64 i; // [rsp+28h] [rbp-8h]\n\n  if ( (*a1 & 0x800) != 0 )\n  {\n    v5 = *((_QWORD *)a1 + 3);\n  }\n  else\n  {\n    v2 = *a1;\n    BYTE1(v2) = BYTE1(*a1) | 8;\n    *a1 = v2;\n    v5 = 0LL;\n  }\n  *((_QWORD *)a1 + 3) = sub_40A0E8(*(unsigned int *)(a2 + 12) + 33LL, a2);\n  v4 = *((_QWORD *)a1 + 3);\n  *(_QWORD *)v4 = v4 + 24;\n  *(_QWORD *)(v4 + 8) = *(_QWORD *)v4;\n  *(_QWORD *)(v4 + 16) = v5;\n  LODWORD(v6) = 0;\n  while ( 1 )\n  {\n    result = *(unsigned int *)(a2 + 4);\n    if ( (unsigned int)v6 >= (unsigned int)result )\n      break;\n    for ( i = *(_QWORD *)(8LL * (unsigned int)v6 + *(_QWORD *)(a2 + 16)); i; i = *(_QWORD *)(i + 32) )\n    {\n      strcpy(*(char **)v4, (const char *)(i + 40));\n      sub_4DC55F((__int64 *)v4);\n    }\n    v6 = (unsigned int)(v6 + 1);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void hashwalk_init(var *v, xhash *array)\n{\n\thash_item *hi;\n\tunsigned i;\n\twalker_list *w;\n\twalker_list *prev_walker;\n\n\tif (v->type & VF_WALK) {\n\t\tprev_walker = v->x.walker;\n\t} else {\n\t\tv->type |= VF_WALK;\n\t\tprev_walker = NULL;\n\t}\n\tdebug_printf_walker(\"hashwalk_init: prev_walker:%p\\n\", prev_walker);\n\n\tw = v->x.walker = xzalloc(sizeof(*w) + array->glen + 1); /* why + 1? */\n\tdebug_printf_walker(\" walker@%p=%p\\n\", &v->x.walker, w);\n\tw->cur = w->end = w->wbuf;\n\tw->prev = prev_walker;\n\tfor (i = 0; i < array->csize; i++) {\n\t\thi = array->items[i];\n\t\twhile (hi) {\n\t\t\tstrcpy(w->end, hi->name);\n\t\t\tnextword(&w->end);\n\t\t\thi = hi->next;\n\t\t}\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_46F900(unsigned __int8 *a1)\n{\n  __int64 *v1; // rax\n  int v2; // eax\n  int v4; // [rsp+14h] [rbp-1Ch]\n  void *ptr; // [rsp+18h] [rbp-18h]\n  __int64 *v6; // [rsp+20h] [rbp-10h]\n  unsigned int v7; // [rsp+2Ch] [rbp-4h]\n\n  v1 = (__int64 *)sub_46F2C1(a1);\n  v6 = sub_46F3E8(v1, (char *)a1);\n  ptr = (void *)*v6;\n  v7 = 2;\n  if ( *v6 )\n  {\n    v4 = *((_DWORD *)ptr + 2);\n    v7 = 1;\n    if ( (v4 & 2) == 0 )\n    {\n      v2 = *((_DWORD *)ptr + 2);\n      BYTE1(v2) &= ~2u;\n      *((_DWORD *)ptr + 2) = v2;\n      if ( (v4 & 0x20) == 0 )\n      {\n        if ( (v4 & 4) != 0 )\n        {\n          sub_46F6BF((char *)a1, 0LL, 0);\n          *((_DWORD *)ptr + 2) &= ~1u;\n        }\n        else\n        {\n          ++*(_DWORD *)(qword_75D418 + 48);\n          if ( (v4 & 0x18) == 0 )\n            free(*((void **)ptr + 2));\n          *v6 = *(_QWORD *)ptr;\n          free(ptr);\n          sub_46E03F(ptr, a1);\n        }\n      }\n      return 0;\n    }\n  }\n  return v7;\n}\n\n\n Revised code:\nstatic int\nunsetvar(const char *s)\n{\n\tstruct var **vpp;\n\tstruct var *vp;\n\tint retval;\n\n\tvpp = findvar(hashvar(s), s);\n\tvp = *vpp;\n\tretval = 2;\n\tif (vp) {\n\t\tint flags = vp->flags;\n\n\t\tretval = 1;\n\t\tif (flags & VREADONLY)\n\t\t\tgoto out;\n#if ENABLE_ASH_RANDOM_SUPPORT\n\t\tvp->flags &= ~VDYNAMIC;\n#endif\n\t\tif (flags & VUNSET)\n\t\t\tgoto ok;\n\t\tif ((flags & VSTRFIXED) == 0) {\n\t\t\tINT_OFF;\n\t\t\tif ((flags & (VTEXTFIXED|VSTACK)) == 0)\n\t\t\t\tfree((char*)vp->var_text);\n\t\t\t*vpp = vp->next;\n\t\t\tfree(vp);\n\t\t\tINT_ON;\n\t\t} else {\n\t\t\tsetvar(s, 0, 0);\n\t\t\tvp->flags &= ~VEXPORT;\n\t\t}\n ok:\n\t\tretval = 0;\n\t}\n out:\n\treturn retval;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47778E(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  int v4; // [rsp+14h] [rbp-Ch]\n  unsigned int v5; // [rsp+18h] [rbp-8h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  v6 = 1;\n  v5 = 0;\n  v4 = 1;\n  if ( *(_QWORD *)(a2 + 8) && **(_BYTE **)(a2 + 8) == 45 )\n  {\n    v6 = 2;\n    v4 = 0;\n  }\n  while ( *(_QWORD *)(8LL * v6 + a2) )\n  {\n    v2 = v6++;\n    v5 |= sub_47752A(*(const char **)(8LL * v2 + a2), v4);\n  }\n  return v5;\n}\n\n\n Revised code:\nstatic int FAST_FUNC\ntypecmd(int argc UNUSED_PARAM, char **argv)\n{\n\tint i = 1;\n\tint err = 0;\n\tint verbose = 1;\n\n\t/* type -p ... ? (we don't bother checking for 'p') */\n\tif (argv[1] && argv[1][0] == '-') {\n\t\ti++;\n\t\tverbose = 0;\n\t}\n\twhile (argv[i]) {\n\t\terr |= describe_command(argv[i++], verbose);\n\t}\n\treturn err;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4DC1ED(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n  int v3; // eax\n  unsigned int v4; // [rsp+14h] [rbp-2Ch]\n  __int64 v5; // [rsp+18h] [rbp-28h]\n  _QWORD *v6; // [rsp+20h] [rbp-20h]\n  unsigned int v7; // [rsp+2Ch] [rbp-14h]\n  __int64 v8; // [rsp+30h] [rbp-10h]\n  unsigned int i; // [rsp+3Ch] [rbp-4h]\n\n  result = *(unsigned int *)(a1 + 8);\n  if ( (_DWORD)result != 5 )\n  {\n    v3 = *(_DWORD *)(a1 + 8);\n    *(_DWORD *)(a1 + 8) = v3 + 1;\n    v7 = (unsigned __int16)word_524914[v3];\n    v6 = sub_40A0E8(8LL * (unsigned __int16)word_524914[v3], a2);\n    for ( i = 0; i < *(_DWORD *)(a1 + 4); ++i )\n    {\n      v8 = *(_QWORD *)(8LL * i + *(_QWORD *)(a1 + 16));\n      while ( v8 )\n      {\n        v5 = v8;\n        v8 = *(_QWORD *)(v8 + 32);\n        v4 = (unsigned int)sub_4DC0E5((char *)(v5 + 40)) % v7;\n        *(_QWORD *)(v5 + 32) = v6[v4];\n        v6[v4] = v5;\n      }\n    }\n    free(*(void **)(a1 + 16));\n    *(_DWORD *)(a1 + 4) = v7;\n    result = a1;\n    *(_QWORD *)(a1 + 16) = v6;\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "pseudo_exec_argv",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48682E(const char *a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-18h]\n  char *v4; // [rsp+20h] [rbp-10h]\n  __int64 v5; // [rsp+28h] [rbp-8h]\n\n  v4 = sub_4867AC(a1);\n  v5 = *(_QWORD *)v4;\n  if ( *(_QWORD *)v4 )\n  {\n    v3 = *(_QWORD *)(v5 + 16);\n    if ( v3 )\n    {\n      **(_QWORD **)(v3 + 32) = *(_QWORD *)(v5 + 8);\n      *(_QWORD *)(v3 + 16) = *(_QWORD *)(v5 + 24);\n    }\n    else\n    {\n      free(*(void **)(v5 + 8));\n      if ( *(_QWORD *)(v5 + 24) )\n        sub_4821B8(*(__int64 **)(v5 + 24));\n    }\n  }\n  else\n  {\n    *(_QWORD *)v4 = sub_40A0E8(0x20uLL, a2);\n    v5 = *(_QWORD *)v4;\n  }\n  *(_QWORD *)(v5 + 8) = a1;\n  return v5;\n}\n\n\n Revised code:\nstatic struct function *new_function(char *name)\n{\n\tstruct function **funcpp = find_function_slot(name);\n\tstruct function *funcp = *funcpp;\n\n\tif (funcp != NULL) {\n\t\tstruct command *cmd = funcp->parent_cmd;\n\t\tdebug_printf_exec(\"func %p parent_cmd %p\\n\", funcp, cmd);\n\t\tif (!cmd) {\n\t\t\tdebug_printf_exec(\"freeing & replacing function '%s'\\n\", funcp->name);\n\t\t\tfree(funcp->name);\n\t\t\t/* Note: if !funcp->body, do not free body_as_string!\n\t\t\t * This is a special case of \"-F name body\" function:\n\t\t\t * body_as_string was not malloced! */\n\t\t\tif (funcp->body) {\n\t\t\t\tfree_pipe_list(funcp->body);\n# if !BB_MMU\n\t\t\t\tfree(funcp->body_as_string);\n# endif\n\t\t\t}\n\t\t} else {\n\t\t\tdebug_printf_exec(\"reinserting in tree & replacing function '%s'\\n\", funcp->name);\n\t\t\tcmd->argv[0] = funcp->name;\n\t\t\tcmd->group = funcp->body;\n# if !BB_MMU\n\t\t\tcmd->group_as_string = funcp->body_as_string;\n# endif\n\t\t}\n\t} else {\n\t\tdebug_printf_exec(\"remembering new function '%s'\\n\", name);\n\t\tfuncp = *funcpp = xzalloc(sizeof(*funcp));\n\t\t/*funcp->next = NULL;*/\n\t}\n\n\tfuncp->name = name;\n\treturn funcp;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_487690(const char ***a1, _QWORD *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rsi\n  const char **v11; // [rsp+30h] [rbp-10h]\n  unsigned int v12; // [rsp+3Ch] [rbp-4h]\n\n  v12 = sub_4863C6(a3, a4, a4, a4, a5, a6);\n  if ( !v12 )\n  {\n    v6 = *(unsigned int *)(a3 + 4);\n    v11 = (const char **)sub_485C0D(*(_QWORD *)(a3 + 32), v6);\n    *a1 = v11;\n    sub_486BBE((__int64)v11, v6);\n    sub_486BBE(a5, v6);\n    if ( a2 )\n      *a2 = sub_480E9C(v11);\n  }\n  return v12;\n}\n\n\n Revised code:\nendif\nstatic int redirect_and_varexp_helper(char ***new_env_p,\n\t\tstruct variable **old_vars_p,\n\t\tstruct command *command,\n\t\tint squirrel[3],\n\t\tchar **argv_expanded)\n{\n\t/* setup_redirects acts on file descriptors, not FILEs.\n\t * This is perfect for work that comes after exec().\n\t * Is it really safe for inline use?  Experimentally,\n\t * things seem to work. */\n\tint rcode = setup_redirects(command, squirrel);\n\tif (rcode == 0) {\n\t\tchar **new_env = expand_assignments(command->argv, command->assignment_cnt);\n\t\t*new_env_p = new_env;\n\t\tdump_cmd_in_x_mode(new_env);\n\t\tdump_cmd_in_x_mode(argv_expanded);\n\t\tif (old_vars_p)\n\t\t\t*old_vars_p = set_vars_and_save_old(new_env);\n\t}\n\treturn rcode;\n}\n\n## Example:\n\n Input code:\nvoid __fastcall __noreturn sub_4C614C(__int64 a1, __int64 a2)\n{\n  __int64 v2; // [rsp+0h] [rbp-10h]\n\n  if ( !*(_QWORD *)(a2 + 8) )\n    sub_407F64();\n  sub_40A8DC(*(const char **)(a2 + 8));\n  v2 = a2 + 16;\n  if ( !*(_QWORD *)(a2 + 16) )\n  {\n    v2 = a2;\n    *(_QWORD *)a2 = sub_4FA04E();\n    *(_QWORD *)(a2 + 8) = \"-i\";\n  }\n  sub_4F931D(v2);\n}\n\n\n Revised code:\nint chroot_main(int argc UNUSED_PARAM, char **argv)\n{\n\t++argv;\n\tif (!*argv)\n\t\tbb_show_usage();\n\txchroot(*argv);\n\n\t++argv;\n\tif (!*argv) { /* no 2nd param (PROG), use shell */\n\t\targv -= 2;\n\t\targv[0] = (char *) get_shell_name();\n\t\targv[1] = (char *) \"-i\"; /* GNU coreutils 8.4 compat */\n\t\t/*argv[2] = NULL; - already is */\n\t}\n\n\tBB_EXECVP_or_die(argv);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall __noreturn sub_486D04(__int64 a1, unsigned int a2, __int64 a3)\n{\n  const char **v4; // [rsp+18h] [rbp-28h]\n  __int64 v5; // [rsp+28h] [rbp-18h]\n  const char **v6; // [rsp+30h] [rbp-10h]\n  void **ptr; // [rsp+38h] [rbp-8h]\n\n  ptr = (void **)sub_485C0D(a1, a2);\n  sub_486BBE((__int64)ptr, a2);\n  if ( !*(_QWORD *)(8LL * (int)a2 + a1) )\n  {\n    sub_480135(ptr);\n    _exit(0);\n  }\n  sub_480E9C((const char **)ptr);\n  free(ptr);\n  if ( a3 )\n  {\n    v4 = (const char **)a3;\n    sub_486BBE(a3, a2);\n  }\n  else\n  {\n    v4 = (const char **)sub_4859EC((const char **)(8LL * (int)a2 + a1));\n    sub_486BBE((__int64)v4, a2);\n  }\n  if ( !strchr(*v4, 47) )\n  {\n    v6 = sub_48676B(*v4);\n    if ( v6 )\n      sub_486B28((__int64)v6, (__int64)v4);\n    v5 = sub_486809(*v4);\n    if ( v5 )\n      sub_48696C(v5, v4);\n  }\n  sub_486B60(v4);\n}\n"
    },
    {
        "func_name": "mbstowc_internal",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_50906E(_BYTE *a1, unsigned int a2)\n{\n  int v3; // [rsp+0h] [rbp-1Ch]\n  unsigned int v4; // [rsp+10h] [rbp-Ch]\n  int v5; // [rsp+14h] [rbp-8h]\n  int i; // [rsp+18h] [rbp-4h]\n\n  v3 = a2;\n  v4 = a2;\n  if ( a2 > 0x7F )\n  {\n    for ( i = 2; v4 > 0x7FF && i <= 5; ++i )\n      v4 >>= 5;\n    v5 = i;\n    while ( --v5 )\n    {\n      a1[v5] = v3 & 0x3F | 0x80;\n      v3 >>= 6;\n    }\n    *a1 = v3 | (16128 >> i);\n    return i;\n  }\n  else\n  {\n    *a1 = a2;\n    return 1LL;\n  }\n}\n\n\n Revised code:\nendif\n\nstatic size_t wcrtomb_internal(char *s, wchar_t wc)\n{\n\tint n, i;\n\tuint32_t v = wc;\n\n\tif (v <= 0x7f) {\n\t\t*s = v;\n\t\treturn 1;\n\t}\n\n\t/* RFC 3629 says that Unicode ends at 10FFFF,\n\t * but we cover entire 32 bits */\n\n\t/* 4000000-FFFFFFFF -> 111111tt 10tttttt 10zzzzzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\t/* 200000-3FFFFFF -> 111110tt 10zzzzzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\t/* 10000-1FFFFF -> 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\t/* 800-FFFF -> 1110yyyy 10yyyyxx 10xxxxxx */\n\t/* 80-7FF -> 110yyyxx 10xxxxxx */\n\n\t/* How many bytes do we need? */\n\tn = 2;\n\t/* (0x80000000+ would result in n = 7, limiting n to 6) */\n\twhile (v >= 0x800 && n < 6) {\n\t\tv >>= 5;\n\t\tn++;\n\t}\n\t/* Fill bytes n-1..1 */\n\ti = n;\n\twhile (--i) {\n\t\ts[i] = (wc & 0x3f) | 0x80;\n\t\twc >>= 6;\n\t}\n\t/* Fill byte 0 */\n\ts[0] = wc | (uint8_t)(0x3f00 >> n);\n\treturn n;\n}\n\n## Example:\n\n Input code:\nunsigned __int8 *__fastcall sub_502C28(unsigned __int8 *a1, int a2)\n{\n  unsigned __int8 *v2; // rax\n  unsigned __int8 *v3; // rax\n  unsigned __int8 *v5; // rax\n  unsigned __int8 *v6; // rax\n  unsigned __int8 *v7; // rax\n  unsigned int v8; // [rsp+18h] [rbp-20h]\n  unsigned int v9; // [rsp+18h] [rbp-20h]\n  unsigned __int8 v10; // [rsp+1Fh] [rbp-19h]\n  unsigned __int8 *v11; // [rsp+20h] [rbp-18h]\n  unsigned __int8 *v12; // [rsp+28h] [rbp-10h]\n\n  v12 = a1;\n  v11 = a1;\n  while ( 1 )\n  {\n    v7 = v12++;\n    v10 = *v7;\n    if ( !*v7 )\n      break;\n    if ( a2 || v10 != 43 )\n    {\n      if ( v10 == 37 )\n      {\n        v8 = sub_502BE5(*v12);\n        if ( v8 > 0xF || (v9 = (16 * v8) | sub_502BE5(v12[1]), v9 > 0xFF) )\n        {\n          if ( a2 )\n            return 0LL;\n          v5 = v11++;\n          *v5 = 37;\n        }\n        else\n        {\n          if ( a2 && (v9 == 47 || !v9) )\n            return a1 + 1;\n          v6 = v11++;\n          *v6 = v9;\n          v12 += 2;\n        }\n      }\n      else\n      {\n        v3 = v11++;\n        *v3 = v10;\n      }\n    }\n    else\n    {\n      v2 = v11++;\n      *v2 = 32;\n    }\n  }\n  *v11 = 0;\n  return a1;\n}\n\n\n Revised code:\nFAST_FUNC percent_decode_in_place(char *str, int strict)\n{\n\t/* note that decoded string is always shorter than original */\n\tchar *src = str;\n\tchar *dst = str;\n\tchar c;\n\n\twhile ((c = *src++) != '\\0') {\n\t\tunsigned v;\n\n\t\tif (!strict && c == '+') {\n\t\t\t*dst++ = ' ';\n\t\t\tcontinue;\n\t\t}\n\t\tif (c != '%') {\n\t\t\t*dst++ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tv = hex_to_bin(src[0]);\n\t\tif (v > 15) {\n bad_hex:\n\t\t\tif (strict)\n\t\t\t\treturn NULL;\n\t\t\t*dst++ = '%';\n\t\t\tcontinue;\n\t\t}\n\t\tv = (v * 16) | hex_to_bin(src[1]);\n\t\tif (v > 255)\n\t\t\tgoto bad_hex;\n\t\tif (strict && (v == '/' || v == '\\0')) {\n\t\t\t/* caller takes it as indication of invalid\n\t\t\t * (dangerous wrt exploits) chars */\n\t\t\treturn str + 1;\n\t\t}\n\t\t*dst++ = v;\n\t\tsrc += 2;\n\t}\n\t*dst = '\\0';\n\treturn str;\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_4C5907(_BYTE *a1, unsigned int *a2)\n{\n  unsigned int *v2; // rax\n  _BYTE *s; // [rsp+8h] [rbp-18h]\n  unsigned int v6; // [rsp+18h] [rbp-8h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  s = a1;\n  memset(a1, 32, (unsigned int)(7 * dword_75D450 + 21));\n  for ( i = 0; i <= 6; ++i )\n  {\n    v2 = a2++;\n    v6 = *v2;\n    if ( *v2 == -1 )\n    {\n      s += (unsigned int)(dword_75D450 + 3);\n    }\n    else\n    {\n      if ( dword_75D450 )\n      {\n        ++s;\n        if ( v6 > 0x63 )\n        {\n          *s = 48;\n          *(s - 1) = v6 / 0x64 + 48;\n          v6 %= 0x64u;\n        }\n      }\n      if ( v6 / 0xA )\n        *s = v6 / 0xA + 48;\n      s[1] = v6 % 0xA + 48;\n      s += 3;\n    }\n  }\n  return s;\n}\n\n\n Revised code:\nstatic char *build_row(char *p, unsigned *dp)\n{\n\tunsigned col, val, day;\n\n\tmemset(p, ' ', (julian + DAY_LEN) * 7);\n\n\tcol = 0;\n\tdo {\n\t\tday = *dp++;\n\t\tif (day != SPACE) {\n\t\t\tif (julian) {\n\t\t\t\t++p;\n\t\t\t\tif (day >= 100) {\n\t\t\t\t\t*p = '0';\n\t\t\t\t\tp[-1] = (day / 100) + '0';\n\t\t\t\t\tday %= 100;\n\t\t\t\t}\n\t\t\t}\n\t\t\tval = day / 10;\n\t\t\tif (val > 0) {\n\t\t\t\t*p = val + '0';\n\t\t\t}\n\t\t\t*++p = day % 10 + '0';\n\t\t\tp += 2;\n\t\t} else {\n\t\t\tp += DAY_LEN + julian;\n\t\t}\n\t} while (++col < 7);\n\n\treturn p;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nunsigned __int8 *__fastcall sub_50921C(unsigned int *a1, unsigned __int8 *a2)\n{\n  _BYTE *v3; // [rsp+0h] [rbp-20h]\n  unsigned int v4; // [rsp+18h] [rbp-8h]\n  unsigned int v5; // [rsp+18h] [rbp-8h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  v3 = a2 + 1;\n  v4 = *a2;\n  if ( v4 > 0x7F )\n  {\n    v6 = 0;\n    do\n    {\n      LOBYTE(v4) = 2 * v4;\n      ++v6;\n    }\n    while ( (v4 & 0x80) != 0 && v6 <= 5 );\n    if ( v6 == 1 )\n    {\n      *a1 = -1;\n      return a2 + 1;\n    }\n    else\n    {\n      v5 = (int)(unsigned __int8)v4 >> v6;\n      while ( --v6 )\n      {\n        if ( (*v3 & 0xC0) != 128 )\n        {\n          *a1 = -1;\n          return v3;\n        }\n        v5 = (v5 << 6) + (*v3++ & 0x3F);\n      }\n      if ( v5 > 0x7F )\n        *a1 = v5;\n      else\n        *a1 = -1;\n      return v3;\n    }\n  }\n  else\n  {\n    *a1 = v4;\n    return a2 + 1;\n  }\n}\n"
    },
    {
        "func_name": "free_procps_scan",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __fastcall sub_5024BD(__int64 a1)\n{\n  if ( a1 )\n  {\n    free(*(void **)(a1 + 8));\n    fclose(*(FILE **)a1);\n    free(*(void **)(a1 + 16));\n    free(*(void **)(a1 + 24));\n    free((void *)a1);\n  }\n}\n\n\n Revised code:\nvoid FAST_FUNC config_close(parser_t *parser)\n{\n\tif (parser) {\n\t\tif (PARSE_KEEP_COPY) /* compile-time constant */\n\t\t\tfree(parser->data);\n\t\tfclose(parser->fp);\n\t\tfree(parser->line);\n\t\tfree(parser->nline);\n\t\tfree(parser);\n\t}\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_4A5BEA(int *a1)\n{\n  if ( a1 )\n  {\n    close(*a1);\n    sub_4A8331(a1);\n    free(a1);\n  }\n}\n\n\n Revised code:\nendif\n\nvoid FAST_FUNC free_volume_id(struct volume_id *id)\n{\n\tif (id == NULL)\n\t\treturn;\n\n\t//if (id->fd_close != 0) - always true\n\t\tclose(id->fd);\n\tvolume_id_free_buffer(id);\n#ifdef UNUSED_PARTITION_CODE\n\tfree(id->partitions);\n#endif\n\tfree(id);\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_4B85A5(void **a1)\n{\n  free(a1[8]);\n  free(a1);\n}\n\n\n Revised code:\nvoid FAST_FUNC dealloc_bunzip(bunzip_data *bd)\n{\n\tfree(bd->dbuf);\n\tfree(bd);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_50346D(__int64 a1)\n{\n  closedir(*(DIR **)a1);\n  if ( *(_QWORD *)(a1 + 8) )\n    closedir(*(DIR **)(a1 + 8));\n  free(*(void **)(a1 + 24));\n  free(*(void **)(a1 + 32));\n  free((void *)a1);\n}\n"
    },
    {
        "func_name": "fb_pixel_value",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nchar *__fastcall sub_4AE836(unsigned __int16 a1, int a2)\n{\n  char *result; // rax\n\n  if ( *((_DWORD *)qword_75D408 - 3) <= 16 - a2 )\n  {\n    *((_WORD *)qword_75D408 - 7) |= a1 << *((_DWORD *)qword_75D408 - 3);\n    result = (char *)qword_75D408 - 88;\n    *((_DWORD *)qword_75D408 - 3) += a2;\n  }\n  else\n  {\n    *((_WORD *)qword_75D408 - 7) |= a1 << *((_DWORD *)qword_75D408 - 3);\n    sub_4AE62D(*((_WORD *)qword_75D408 - 7));\n    *((_WORD *)qword_75D408 - 7) = (int)a1 >> (16 - *((char *)qword_75D408 - 12));\n    result = (char *)qword_75D408 - 88;\n    *((_DWORD *)qword_75D408 - 3) = *((_DWORD *)qword_75D408 - 3) + a2 - 16;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void send_bits(int value, int length)\n{\n#ifdef DEBUG\n\tTracev((stderr, \" l %2d v %4x \", length, value));\n\tAssert(length > 0 && length <= 15, \"invalid length\");\n\tG1.bits_sent += length;\n#endif\n\t/* If not enough room in bi_buf, use (valid) bits from bi_buf and\n\t * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))\n\t * unused bits in value.\n\t */\n\tif (G1.bi_valid > (int) BUF_SIZE - length) {\n\t\tG1.bi_buf |= (value << G1.bi_valid);\n\t\tput_16bit(G1.bi_buf);\n\t\tG1.bi_buf = (ush) value >> (BUF_SIZE - G1.bi_valid);\n\t\tG1.bi_valid += length - BUF_SIZE;\n\t} else {\n\t\tG1.bi_buf |= value << G1.bi_valid;\n\t\tG1.bi_valid += length;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40E5E6(__int64 a1, __int64 a2)\n{\n  int v2; // edx\n  int v3; // edx\n\n  v2 = *((_DWORD *)qword_75D408 + 24);\n  BYTE1(v2) |= 0x14u;\n  *((_DWORD *)qword_75D408 + 24) = v2;\n  if ( *((_BYTE *)qword_75D408 + 92) == 13 )\n  {\n    v3 = *((_DWORD *)qword_75D408 + 24);\n    BYTE1(v3) |= 1u;\n    *((_DWORD *)qword_75D408 + 24) = v3;\n  }\n  *((_DWORD *)qword_75D408 + 27) |= 0x83Bu;\n  *((_BYTE *)qword_75D408 + 113) = 3;\n  *((_BYTE *)qword_75D408 + 114) = 28;\n  *((_BYTE *)qword_75D408 + 117) = 4;\n  *((_BYTE *)qword_75D408 + 124) = 10;\n  *((_BYTE *)qword_75D408 + 120) = 0;\n  *((_BYTE *)qword_75D408 + 116) = 21;\n  sub_40E482(a1, a2);\n  return sub_40B38A(1u, (__int64)\"\\n\", 1LL);\n}\n\n\n Revised code:\nstatic void finalize_tty_attrs(void)\n{\n\t/* software flow control on output (stop sending if XOFF is recvd);\n\t * and on input (send XOFF when buffer is full)\n\t */\n\tG.tty_attrs.c_iflag |= IXON | IXOFF;\n\tif (G.eol == '\\r') {\n\t\tG.tty_attrs.c_iflag |= ICRNL; /* map CR on input to NL */\n\t}\n\t/* Other bits in c_iflag:\n\t * IXANY   Any recvd char enables output (any char is also a XON)\n\t * INPCK   Enable parity check\n\t * IGNPAR  Ignore parity errors (drop bad bytes)\n\t * PARMRK  Mark parity errors with 0xff, 0x00 prefix\n\t *         (else bad byte is received as 0x00)\n\t * ISTRIP  Strip parity bit\n\t * IGNBRK  Ignore break condition\n\t * BRKINT  Send SIGINT on break - maybe set this?\n\t * INLCR   Map NL to CR\n\t * IGNCR   Ignore CR\n\t * ICRNL   Map CR to NL\n\t * IUCLC   Map uppercase to lowercase\n\t * IMAXBEL Echo BEL on input line too long\n\t * IUTF8   Appears to affect tty's idea of char widths,\n\t *         observed to improve backspacing through Unicode chars\n\t */\n\n\t/* line buffered input (NL or EOL or EOF chars end a line);\n\t * recognize INT/QUIT/SUSP chars;\n\t * echo input chars;\n\t * echo BS-SP-BS on erase character;\n\t * echo kill char specially, not as ^c (ECHOKE controls how exactly);\n\t * erase all input via BS-SP-BS on kill char (else go to next line)\n\t */\n\tG.tty_attrs.c_lflag |= ICANON | ISIG | ECHO | ECHOE | ECHOK | ECHOKE;\n\t/* Other bits in c_lflag:\n\t * XCASE   Map uppercase to \\lowercase [tried, doesn't work]\n\t * ECHONL  Echo NL even if ECHO is not set\n\t * ECHOCTL Echo ctrl chars as ^c (else don't echo) - maybe set this?\n\t * ECHOPRT On erase, echo erased chars\n\t *         [qwe<BS><BS><BS> input looks like \"qwe\\ewq/\" on screen]\n\t * NOFLSH  Don't flush input buffer after interrupt or quit chars\n\t * IEXTEN  Enable extended functions (??)\n\t *         [glibc says it enables c_cc[LNEXT] \"enter literal char\"\n\t *         and c_cc[VDISCARD] \"toggle discard buffered output\" chars]\n\t * FLUSHO  Output being flushed (c_cc[VDISCARD] is in effect)\n\t * PENDIN  Retype pending input at next read or input char\n\t *         (c_cc[VREPRINT] is being processed)\n\t * TOSTOP  Send SIGTTOU for background output\n\t *         (why \"stty sane\" unsets this bit?)\n\t */\n\n\tG.tty_attrs.c_cc[VINTR] = CTL('C');\n\tG.tty_attrs.c_cc[VQUIT] = CTL('\\\\');\n\tG.tty_attrs.c_cc[VEOF] = CTL('D');\n\tG.tty_attrs.c_cc[VEOL] = '\\n';\n#ifdef VSWTC\n\tG.tty_attrs.c_cc[VSWTC] = 0;\n#endif\n#ifdef VSWTCH\n\tG.tty_attrs.c_cc[VSWTCH] = 0;\n#endif\n\tG.tty_attrs.c_cc[VKILL] = CTL('U');\n\t/* Other control chars:\n\t * VEOL2\n\t * VERASE, VWERASE - (word) erase. we may set VERASE in get_logname\n\t * VREPRINT - reprint current input buffer\n\t * VLNEXT, VDISCARD, VSTATUS\n\t * VSUSP, VDSUSP - send (delayed) SIGTSTP\n\t * VSTART, VSTOP - chars used for IXON/IXOFF\n\t */\n\n\tset_tty_attrs();\n\n\t/* Now the newline character should be properly written */\n\tfull_write(STDOUT_FILENO, \"\\n\", 1);\n}\n\n## Example:\n\n Input code:\nunsigned __int64 __fastcall sub_463D34(unsigned int a1)\n{\n  unsigned __int64 result; // rax\n  _QWORD *v2; // rbx\n  _QWORD *v3; // rbx\n\n  result = a1;\n  if ( *((_DWORD *)qword_75D408 + 2) <= a1 )\n  {\n    *((_DWORD *)qword_75D408 + 2) += 256;\n    v2 = qword_75D408;\n    v2[2] = sub_40A09E(*((void **)qword_75D408 + 2), 4LL * *((unsigned int *)qword_75D408 + 2));\n    v3 = qword_75D408;\n    result = (unsigned __int64)sub_40A09E(*((void **)qword_75D408 + 3), *((unsigned int *)qword_75D408 + 2));\n    v3[3] = result;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void ensure_buffer_capacity(int bufindex)\n{\n\tif (bufindex >= G.capacity) {\n\t\tG.capacity += 0x100;\n\t\tG.width = xrealloc(G.width, G.capacity * sizeof(G.width[0]));\n\t\tG.more = xrealloc(G.more, G.capacity * sizeof(G.more[0]));\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_417020(unsigned int a1, unsigned int a2, unsigned int a3)\n{\n  if ( *((_DWORD *)qword_75D408 + 72) == 1 )\n    return ((a2 >> 3) & 0x1C) + (a1 & 0xE0) + (a3 >> 6);\n  if ( *((_DWORD *)qword_75D408 + 72) == 2 )\n    return (a2 >> *((_DWORD *)qword_75D408 + 74) << *((_DWORD *)qword_75D408 + 23))\n         + (a1 >> *((_DWORD *)qword_75D408 + 73) << *((_DWORD *)qword_75D408 + 20))\n         + (a3 >> *((_DWORD *)qword_75D408 + 75) << *((_DWORD *)qword_75D408 + 26));\n  return a3 + (a2 << 8) + (a1 << 16);\n}\n"
    },
    {
        "func_name": "send_NAK",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4562E0(__int64 a1)\n{\n  int v1; // edx\n  int v2; // ecx\n  int v3; // r8d\n  int v4; // r9d\n  char v6[640]; // [rsp+10h] [rbp-280h] BYREF\n\n  sub_455D51((__int64)v6, a1, 5);\n  sub_455DEC((__int64)v6);\n  return sub_455D15((__int64)v6, 0, v1, v2, v3, v4);\n}\n\n\n Revised code:\nstatic NOINLINE void send_inform(struct dhcp_packet *oldpacket)\n{\n\tstruct dhcp_packet packet;\n\n\t/* \"If a client has obtained a network address through some other means\n\t * (e.g., manual configuration), it may use a DHCPINFORM request message\n\t * to obtain other local configuration parameters.  Servers receiving a\n\t * DHCPINFORM message construct a DHCPACK message with any local\n\t * configuration parameters appropriate for the client without:\n\t * allocating a new address, checking for an existing binding, filling\n\t * in 'yiaddr' or including lease time parameters.  The servers SHOULD\n\t * unicast the DHCPACK reply to the address given in the 'ciaddr' field\n\t * of the DHCPINFORM message.\n\t * ...\n\t * The server responds to a DHCPINFORM message by sending a DHCPACK\n\t * message directly to the address given in the 'ciaddr' field\n\t * of the DHCPINFORM message.  The server MUST NOT send a lease\n\t * expiration time to the client and SHOULD NOT fill in 'yiaddr'.\"\n\t */\n//TODO: do a few sanity checks: is ciaddr set?\n//Better yet: is ciaddr == IP source addr?\n\tinit_packet(&packet, oldpacket, DHCPACK);\n\tadd_server_options(&packet);\n\n\tsend_packet(&packet, /*force_bcast:*/ 0);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_454561(unsigned int a1, unsigned int a2)\n{\n  int v2; // edx\n  int v3; // ecx\n  int v4; // r8d\n  int v5; // r9d\n  char v7[640]; // [rsp+10h] [rbp-280h] BYREF\n\n  sub_454080((__int64)v7, 4);\n  sub_459C35(v7, 50LL, a2);\n  sub_459C35(v7, 54LL, a1);\n  sub_4FDABC((unsigned int)\"Sending decline...\", 54, v2, v3, v4, v5);\n  return sub_45432B((int)v7);\n}\n\n\n Revised code:\nstatic NOINLINE int send_decline(/*uint32_t xid,*/ uint32_t server, uint32_t requested)\n{\n\tstruct dhcp_packet packet;\n\n\t/* Fill in: op, htype, hlen, cookie, chaddr, random xid fields,\n\t * client-id option (unless -C), message type option:\n\t */\n\tinit_packet(&packet, DHCPDECLINE);\n\n#if 0\n\t/* RFC 2131 says DHCPDECLINE's xid is randomly selected by client,\n\t * but in case the server is buggy and wants DHCPDECLINE's xid\n\t * to match the xid which started entire handshake,\n\t * we use the same xid we used in initial DHCPDISCOVER:\n\t */\n\tpacket.xid = xid;\n#endif\n\t/* DHCPDECLINE uses \"requested ip\", not ciaddr, to store offered IP */\n\tudhcp_add_simple_option(&packet, DHCP_REQUESTED_IP, requested);\n\n\tudhcp_add_simple_option(&packet, DHCP_SERVER_ID, server);\n\n\tbb_info_msg(\"Sending decline...\");\n\treturn raw_bcast_from_client_config_ifindex(&packet);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4545E0(unsigned int a1, unsigned int a2)\n{\n  int v2; // edx\n  int v3; // ecx\n  int v4; // r8d\n  int v5; // r9d\n  char v7[12]; // [rsp+10h] [rbp-280h] BYREF\n  unsigned int v8; // [rsp+1Ch] [rbp-274h]\n\n  sub_454080((__int64)v7, 7);\n  v8 = a2;\n  sub_459C35(v7, 54LL, a1);\n  sub_4FDABC((unsigned int)\"Sending release...\", 54, v2, v3, v4, v5);\n  return sub_458D07(v7, a2, 68LL, a1, 67LL);\n}\n\n\n Revised code:\nstatic int send_release(uint32_t server, uint32_t ciaddr)\n{\n\tstruct dhcp_packet packet;\n\n\t/* Fill in: op, htype, hlen, cookie, chaddr, random xid fields,\n\t * client-id option (unless -C), message type option:\n\t */\n\tinit_packet(&packet, DHCPRELEASE);\n\n\t/* DHCPRELEASE uses ciaddr, not \"requested ip\", to store IP being released */\n\tpacket.ciaddr = ciaddr;\n\n\tudhcp_add_simple_option(&packet, DHCP_SERVER_ID, server);\n\n\tbb_info_msg(\"Sending release...\");\n\treturn udhcp_send_kernel_packet(&packet, ciaddr, CLIENT_PORT, server, SERVER_PORT);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_456160(__int64 a1)\n{\n  int v1; // edx\n  int v2; // ecx\n  int v3; // r8d\n  int v4; // r9d\n  char v6[640]; // [rsp+10h] [rbp-280h] BYREF\n\n  sub_455D51((__int64)v6, a1, 6);\n  if ( dword_75D460 )\n    sub_4FDABC((unsigned int)\"Sending NAK\", a1, v1, v2, v3, v4);\n  return sub_455D15((__int64)v6, 1, v1, v2, v3, v4);\n}\n"
    },
    {
        "func_name": "handle_sigchld",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 sub_435324()\n{\n  __int64 v0; // rcx\n  __int64 v1; // r8\n  __int64 v2; // r9\n  __int64 result; // rax\n  int v4; // [rsp+1Ch] [rbp-14h] BYREF\n  int v5; // [rsp+20h] [rbp-10h]\n  int v6; // [rsp+24h] [rbp-Ch]\n  __int64 i; // [rsp+28h] [rbp-8h]\n\n  v6 = *(_DWORD *)qword_75D400;\nLABEL_2:\n  while ( 1 )\n  {\n    v5 = sub_409F8A(&v4);\n    if ( v5 <= 0 )\n      break;\n    for ( i = *(_QWORD *)&dest.c_cc[7]; i; i = *(_QWORD *)(i + 88) )\n    {\n      if ( v5 == *(_DWORD *)(i + 44) )\n      {\n        if ( (v4 & 0x7F) != 0 || !BYTE1(v4) )\n        {\n          if ( (char)((v4 & 0x7F) + 1) >> 1 > 0 )\n            sub_409747(\"%s: exit signal %u\", *(_QWORD *)(i + 104), v4 & 0x7F, v0, v1, v2);\n        }\n        else\n        {\n          sub_409747(\"%s: exit status %u\", *(_QWORD *)(i + 104), BYTE1(v4), v0, v1, v2);\n        }\n        *(_DWORD *)(i + 44) = 1;\n        sub_433E79(*(_DWORD *)i);\n        goto LABEL_2;\n      }\n    }\n  }\n  result = qword_75D400;\n  *(_DWORD *)qword_75D400 = v6;\n  return result;\n}\n\n\n Revised code:\nstatic void reap_child(int sig UNUSED_PARAM)\n{\n\tpid_t pid;\n\tint status;\n\tservtab_t *sep;\n\tint save_errno = errno;\n\n\tfor (;;) {\n\t\tpid = wait_any_nohang(&status);\n\t\tif (pid <= 0)\n\t\t\tbreak;\n\t\tfor (sep = serv_list; sep; sep = sep->se_next) {\n\t\t\tif (sep->se_wait != pid)\n\t\t\t\tcontinue;\n\t\t\t/* One of our \"wait\" services */\n\t\t\tif (WIFEXITED(status) && WEXITSTATUS(status))\n\t\t\t\tbb_error_msg(\"%s: exit status %u\",\n\t\t\t\t\t\tsep->se_program, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tbb_error_msg(\"%s: exit signal %u\",\n\t\t\t\t\t\tsep->se_program, WTERMSIG(status));\n\t\t\tsep->se_wait = 1;\n\t\t\tadd_fd_to_set(sep->se_fd);\n\t\t\tbreak;\n\t\t}\n\t}\n\terrno = save_errno;\n}\n\n## Example:\n\n Input code:\nvoid sub_433F24()\n{\n  int v0; // [rsp+Ch] [rbp-4h]\n\n  v0 = 0;\n  *(_DWORD *)&dest.c_cc[19] = 0;\n  while ( v0 <= *(_DWORD *)&dest.c_cc[23] )\n  {\n    if ( (qword_75B4D8[v0 / 64] & (1LL << (v0 % 64))) != 0 )\n      *(_DWORD *)&dest.c_cc[19] = v0;\n    ++v0;\n  }\n  *(_DWORD *)&dest.c_cc[23] = *(_DWORD *)&dest.c_cc[19];\n  if ( *(int *)&dest.c_cc[19] > (unsigned __int64)(*(_QWORD *)&dest.c_iflag - 8LL) )\n    sub_433D6A();\n}\n\n\n Revised code:\nstatic void recalculate_maxsock(void)\n{\n\tint fd = 0;\n\n\t/* We may have no services, in this case maxsock should still be >= 0\n\t * (code elsewhere is not happy with maxsock == -1) */\n\tmaxsock = 0;\n\twhile (fd <= prev_maxsock) {\n\t\tif (FD_ISSET(fd, &allsock))\n\t\t\tmaxsock = fd;\n\t\tfd++;\n\t}\n\tdbg(\"recalculated maxsock:%d\\n\", maxsock);\n\tprev_maxsock = maxsock;\n\tif ((rlim_t)maxsock > rlim_ofile_cur - FD_MARGIN)\n\t\tbump_nofile();\n}\n\n## Example:\n\n Input code:\n__int64 sub_43542A()\n{\n  __int64 result; // rax\n  int v1; // [rsp+14h] [rbp-Ch]\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  v1 = *(_DWORD *)qword_75D400;\n  dest.c_cc[31] = 0;\n  for ( i = *(_QWORD *)&dest.c_cc[7]; i; i = *(_QWORD *)(i + 88) )\n  {\n    if ( *(_DWORD *)i == -1 )\n    {\n      sub_433FCC(i);\n      if ( *(_DWORD *)i != -1 )\n      {\n        if ( *(_DWORD *)(i + 36) )\n          sub_433BF2(i);\n      }\n    }\n  }\n  result = qword_75D400;\n  *(_DWORD *)qword_75D400 = v1;\n  return result;\n}\n\n\n Revised code:\nstatic void retry_network_setup(int sig UNUSED_PARAM)\n{\n\tint save_errno = errno;\n\tservtab_t *sep;\n\n\talarm_armed = 0;\n\tfor (sep = serv_list; sep; sep = sep->se_next) {\n\t\tif (sep->se_fd == -1) {\n\t\t\tprepare_socket_fd(sep);\n#if ENABLE_FEATURE_INETD_RPC\n\t\t\tif (sep->se_fd != -1 && is_rpc_service(sep))\n\t\t\t\tregister_rpc(sep);\n#endif\n\t\t}\n\t}\n\terrno = save_errno;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid sub_442FA2()\n{\n  int v0; // [rsp+10h] [rbp-10h]\n  int v1; // [rsp+14h] [rbp-Ch]\n  __int64 *i; // [rsp+18h] [rbp-8h]\n\n  v1 = *(_DWORD *)qword_75D400;\nLABEL_2:\n  while ( 1 )\n  {\n    v0 = sub_409F8A(0LL);\n    if ( v0 <= 0 )\n      break;\n    for ( i = *(__int64 **)&dest.c_iflag; i; i = (__int64 *)*i )\n    {\n      if ( v0 == *((_DWORD *)i + 2) )\n      {\n        *((_DWORD *)i + 2) = -1;\n        sub_509F5C((unsigned int)v0, 8LL, 0LL, 0LL, 0LL);\n        goto LABEL_2;\n      }\n    }\n  }\n  *(_DWORD *)qword_75D400 = v1;\n}\n"
    },
    {
        "func_name": "write_superblock",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 sub_498E36()\n{\n  size_t v0; // rax\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n\n  memset(*((void **)qword_75D408 + 9), 0, (unsigned int)*((unsigned __int16 *)qword_75D408 + 210) + 1);\n  if ( *(_BYTE *)qword_75D408 )\n    v0 = *((unsigned int *)qword_75D408 + 110);\n  else\n    v0 = *((unsigned __int16 *)qword_75D408 + 211);\n  memset(*((void **)qword_75D408 + 10), 0, v0);\n  sub_497BCD(1u);\n  sub_498354(1u, 0LL, v1, v2, v3, v4);\n  return sub_4988FF();\n}\n\n\n Revised code:\nif ENABLE_FEATURE_MINIX2\nstatic void check2(void)\n{\n\tmemset(inode_count, 0, (INODES + 1) * sizeof(*inode_count));\n\tmemset(zone_count, 0, ZONES * sizeof(*zone_count));\n\tcheck_zones2(MINIX_ROOT_INO);\n\trecursive_check2(MINIX_ROOT_INO);\n\tcheck_counts2();\n}\n\n## Example:\n\n Input code:\n__int64 sub_496B5E()\n{\n  char *v0; // rsi\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  __int64 v5; // rdx\n  __int64 v6; // rcx\n  int v7; // eax\n  __int64 v8; // rdx\n  __int64 result; // rax\n\n  sub_40A557(3, 1024LL, 0);\n  v0 = (char *)qword_75D408 + 420;\n  if ( sub_40B446(3, (char *)qword_75D408 + 420, 0x400uLL) != 1024 )\n    sub_495EC2((__int64)\"can't read superblock\", (__int64)v0, v1, v2, v3, v4);\n  if ( *((_WORD *)qword_75D408 + 218) != 4991 )\n  {\n    switch ( *((_WORD *)qword_75D408 + 218) )\n    {\n      case 0x138F:\n        *((_BYTE *)qword_75D408 + 5) = 30;\n        *((_BYTE *)qword_75D408 + 4) = 32;\n        break;\n      case 0x2468:\n        *(_BYTE *)qword_75D408 = 1;\n        break;\n      case 0x2478:\n        *((_BYTE *)qword_75D408 + 5) = 30;\n        *((_BYTE *)qword_75D408 + 4) = 32;\n        *(_BYTE *)qword_75D408 = 1;\n        break;\n      default:\n        sub_495EC2((__int64)\"bad magic number in superblock\", (__int64)v0, v1, v2, v3, v4);\n    }\n  }\n  if ( *((_WORD *)qword_75D408 + 215) )\n    sub_495EC2((__int64)\"only 1k blocks/zones supported\", (__int64)v0, v1, v2, v3, v4);\n  v5 = *((unsigned __int16 *)qword_75D408 + 212) << 13;\n  if ( (unsigned int)v5 < (unsigned int)*((unsigned __int16 *)qword_75D408 + 210) + 1 )\n    sub_495EC2((__int64)\"bad s_imap_blocks field in superblock\", (__int64)v0, v5, v2, v3, v4);\n  v6 = *((unsigned __int16 *)qword_75D408 + 213) << 13;\n  if ( *(_BYTE *)qword_75D408 )\n    v7 = *((_DWORD *)qword_75D408 + 110);\n  else\n    v7 = *((unsigned __int16 *)qword_75D408 + 211);\n  v8 = *((unsigned __int16 *)qword_75D408 + 214);\n  result = (unsigned int)(v7 - v8 + 1);\n  if ( (unsigned int)v6 < (unsigned int)result )\n    sub_495EC2((__int64)\"bad s_zmap_blocks field in superblock\", (__int64)v0, v8, v6, v3, v4);\n  return result;\n}\n\n\n Revised code:\nstatic void read_superblock(void)\n{\n\txlseek(dev_fd, BLOCK_SIZE, SEEK_SET);\n\tif (BLOCK_SIZE != full_read(dev_fd, superblock_buffer, BLOCK_SIZE))\n\t\tdie(\"can't read superblock\");\n\t/* already initialized to:\n\tnamelen = 14;\n\tdirsize = 16;\n\tversion2 = 0;\n\t*/\n\tif (MAGIC == MINIX1_SUPER_MAGIC) {\n\t} else if (MAGIC == MINIX1_SUPER_MAGIC2) {\n\t\tnamelen = 30;\n\t\tdirsize = 32;\n#if ENABLE_FEATURE_MINIX2\n\t} else if (MAGIC == MINIX2_SUPER_MAGIC) {\n\t\tversion2 = 1;\n\t} else if (MAGIC == MINIX2_SUPER_MAGIC2) {\n\t\tnamelen = 30;\n\t\tdirsize = 32;\n\t\tversion2 = 1;\n#endif\n\t} else\n\t\tdie(\"bad magic number in superblock\");\n\tif (ZONESIZE != 0 || BLOCK_SIZE != 1024)\n\t\tdie(\"only 1k blocks/zones supported\");\n\tif (IMAPS * BLOCK_SIZE * 8 < INODES + 1)\n\t\tdie(\"bad s_imap_blocks field in superblock\");\n\tif (ZMAPS * BLOCK_SIZE * 8 < ZONES - FIRSTZONE + 1)\n\t\tdie(\"bad s_zmap_blocks field in superblock\");\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_49096C(__int64 a1, __int64 a2)\n{\n  void *v2; // rax\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  char *v6; // rsi\n  __int64 v7; // rdx\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  __int64 result; // rax\n\n  *(_DWORD *)(a1 + 16) = a2;\n  v2 = sub_40A0E8(*((unsigned int *)qword_75D408 + 6), a2);\n  *(_QWORD *)(a1 + 24) = v2;\n  sub_4905B5(a2, a2, (__int64)v2, v3, v4, v5);\n  v6 = *(char **)(a1 + 24);\n  v7 = sub_40B446(3, v6, *((unsigned int *)qword_75D408 + 6));\n  if ( v7 != *((_DWORD *)qword_75D408 + 6) )\n    sub_49055E(\"can't read from %s\", (__int64)v6, v7, v8, v9, v10);\n  *(_BYTE *)(a1 + 32) = 0;\n  *(_QWORD *)(a1 + 8) = 0LL;\n  result = a1;\n  *(_QWORD *)a1 = *(_QWORD *)(a1 + 8);\n  return result;\n}\n\n\n Revised code:\nstatic void\nread_pte(struct pte *pe, sector_t offset)\n{\n\tpe->offset_from_dev_start = offset;\n\tpe->sectorbuffer = xzalloc(sector_size);\n\tseek_sector(offset);\n\t/* xread would make us abort - bad for fdisk -l */\n\tif (full_read(dev_fd, pe->sectorbuffer, sector_size) != sector_size)\n\t\tfdisk_fatal(unable_to_read);\n#if ENABLE_FEATURE_FDISK_WRITABLE\n\tpe->changed = 0;\n#endif\n\tpe->part_table = pe->ext_pointer = NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_4968A5()\n{\n  char *v0; // rsi\n  __int64 result; // rax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n\n  *((_WORD *)qword_75D408 + 219) |= 3u;\n  if ( !*((_BYTE *)qword_75D408 + 2) )\n    *((_WORD *)qword_75D408 + 219) &= ~2u;\n  sub_40A557(3, 1024LL, 0);\n  v0 = (char *)qword_75D408 + 420;\n  result = sub_40B38A(3u, (__int64)qword_75D408 + 420, 1024LL);\n  if ( result != 1024 )\n    sub_495EC2((__int64)\"can't write superblock\", (__int64)v0, v2, v3, v4, v5);\n  return result;\n}\n"
    },
    {
        "func_name": "builtin_unset",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_422816(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  const char **v6; // rax\n  __int64 *v8; // [rsp+0h] [rbp-20h]\n  char v9; // [rsp+1Ch] [rbp-4h]\n\n  qword_75D440 = (__int64)\"-1:b-aG:G-ab:a-bG\";\n  v9 = sub_4FA1EF(a2, (unsigned int)\"bGavzg\", a3, a4, a5, a6);\n  v8 = (__int64 *)(8LL * optind + a2);\n  if ( !v8[1] )\n    v9 |= 0x20u;\n  if ( (v9 & 0x20) == 0 )\n  {\n    sub_4225A4(v8, v9);\n    v8[1] = 0LL;\n  }\n  if ( (v9 & 0x28) != 0 )\n  {\n    do\n    {\n      v6 = (const char **)v8++;\n      sub_42239D(*v6, v9 & 7);\n    }\n    while ( *v8 );\n  }\n  return 0LL;\n}\n\n\n Revised code:\nint setserial_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint opts;\n\n\topt_complementary = \"-1:b-aG:G-ab:a-bG\";\n\topts = getopt32(argv, \"bGavzg\");\n\targv += optind;\n\n\tif (!argv[1]) /* one arg only? */\n\t\topts |= OPT_GET;\n\n\tif (!(opts & OPT_GET)) {\n\t\tserial_set(argv, opts);\n\t\targv[1] = NULL;\n\t}\n\n\tif (opts & (OPT_VERBOSE | OPT_GET)) {\n\t\tdo {\n\t\t\tserial_get(*argv++, opts & OPT_MODE_MASK);\n\t\t} while (*argv);\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47EC20(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  int v7; // [rsp+1Ch] [rbp-14h]\n  char v8; // [rsp+1Ch] [rbp-14h]\n  char v9; // [rsp+20h] [rbp-10h]\n  int v10; // [rsp+24h] [rbp-Ch]\n  unsigned __int8 **i; // [rsp+28h] [rbp-8h]\n\n  v10 = 0;\n  v9 = 0;\n  while ( 1 )\n  {\n    v7 = sub_46F038(\"vf\", a2, a3, a4, a5, a6);\n    if ( !v7 )\n      break;\n    v10 = v7;\n  }\n  for ( i = (unsigned __int8 **)qword_75AF58; *i; ++i )\n  {\n    if ( v10 != 102 )\n    {\n      v8 = sub_46F900(*i);\n      v9 |= v8;\n      if ( (v8 & 2) == 0 )\n        continue;\n    }\n    if ( v10 != 118 )\n      sub_47EBE4((const char *)*i);\n  }\n  return v9 & 1;\n}\n\n\n Revised code:\nstatic int FAST_FUNC\nunsetcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tchar **ap;\n\tint i;\n\tint flag = 0;\n\tint ret = 0;\n\n\twhile ((i = nextopt(\"vf\")) != 0) {\n\t\tflag = i;\n\t}\n\n\tfor (ap = argptr; *ap; ap++) {\n\t\tif (flag != 'f') {\n\t\t\ti = unsetvar(*ap);\n\t\t\tret |= i;\n\t\t\tif (!(i & 2))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (flag != 'v')\n\t\t\tunsetfunc(*ap);\n\t}\n\treturn ret & 1;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_461A9A(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  _QWORD *v6; // rax\n  _QWORD *v8; // [rsp+0h] [rbp-20h]\n  unsigned int v9; // [rsp+14h] [rbp-Ch]\n  unsigned int v10; // [rsp+18h] [rbp-8h]\n  unsigned int v11; // [rsp+1Ch] [rbp-4h]\n\n  v10 = sub_4FA1EF(a2, (unsigned int)\"xq\", a3, a4, a5, a6);\n  v8 = (_QWORD *)(8LL * optind + a2);\n  v11 = 0;\n  while ( *v8 )\n  {\n    v6 = v8++;\n    v9 = sub_50B306(*v6);\n    if ( (unsigned int)sub_46197E(v9, v10) )\n      v11 = 42;\n  }\n  return v11;\n}\n\n\n Revised code:\nint pmap_main(int argc UNUSED_PARAM, char **argv)\n{\n\tunsigned opts;\n\tint ret;\n\n\topts = getopt32(argv, \"xq\");\n\targv += optind;\n\n\tret = 0;\n\twhile (*argv) {\n\t\tpid_t pid = xatoi_positive(*argv++);\n\t\t/* GNU pmap returns 42 if any of the pids failed */\n\t\tif (procps_get_maps(pid, opts) != 0)\n\t\t\tret = 42;\n\t}\n\n\treturn ret;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_48A4B3(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  const char **v11; // [rsp+8h] [rbp-18h]\n  int v12; // [rsp+18h] [rbp-8h]\n  unsigned int v13; // [rsp+1Ch] [rbp-4h]\n\n  v12 = sub_4FA1EF(a1, (unsigned int)\"!+vf\", a3, a4, a5, a6);\n  if ( v12 == -1 )\n    return 1LL;\n  if ( v12 == 3 )\n  {\n    sub_409747(\"unset: -v and -f are exclusive\", (__int64)\"!+vf\", v6, v7, v8, v9);\n    return 1LL;\n  }\n  else\n  {\n    v11 = (const char **)(8LL * optind + a1);\n    v13 = 0;\n    while ( *v11 )\n    {\n      if ( (v12 & 2) != 0 )\n      {\n        sub_4868F4(*v11);\n      }\n      else if ( (unsigned int)sub_480D48(*v11) )\n      {\n        v13 = 1;\n      }\n      ++v11;\n    }\n    return v13;\n  }\n}\n"
    },
    {
        "func_name": "new_partition",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_495008(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  int result; // eax\n  int v7; // [rsp+10h] [rbp-20h]\n  unsigned int v8; // [rsp+14h] [rbp-1Ch]\n  unsigned int v9; // [rsp+18h] [rbp-18h]\n  int v10; // [rsp+1Ch] [rbp-14h]\n  int v11; // [rsp+1Ch] [rbp-14h]\n  _BYTE *v12; // [rsp+20h] [rbp-10h]\n  char *v13; // [rsp+28h] [rbp-8h]\n\n  v13 = (char *)qword_75D408 + 40 * (unsigned int)a1 + 2504;\n  v12 = *(_BYTE **)v13;\n  result = sub_4910F4(a1, a2, (unsigned int)a1, qword_75D408, a5, a6);\n  if ( !result )\n  {\n    v10 = sub_4908E3((__int64)v12);\n    if ( !v12[4] || !v10 || v12[4] == 5 || v12[4] == 15 || v12[4] == 0x85 )\n    {\n      return printf(\"Partition %u has no data area\\n\", (unsigned int)(a1 + 1));\n    }\n    else\n    {\n      v9 = sub_490A13((__int64)v13);\n      v8 = sub_491DF8(0, v9, v9 + v10 - 1, v9, (__int64)\"New beginning of data\");\n      result = v8;\n      if ( v8 != v9 )\n      {\n        v7 = v8 - *((_DWORD *)v13 + 4);\n        v11 = sub_4908C5((__int64)v12) - v7 + v10;\n        sub_49091E((__int64)v12, v7);\n        sub_490945((__int64)v12, v11);\n        sub_49077B((__int64)\"Recalculate C/H/S values? (Y/N): \");\n        if ( (**(_BYTE **)qword_75D408 | 0x20) == 121 )\n          sub_490DE1(v12, v8, v8 + v11 - 1);\n        result = (int)v13;\n        v13[32] = 1;\n      }\n    }\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\nmove_begin(unsigned i)\n{\n\tstruct pte *pe = &ptes[i];\n\tstruct partition *p = pe->part_table;\n\tsector_t new, first, nr_sects;\n\n\tif (warn_geometry())\n\t\treturn;\n\tnr_sects = get_nr_sects(p);\n\tif (!p->sys_ind || !nr_sects || IS_EXTENDED(p->sys_ind)) {\n\t\tprintf(\"Partition %u has no data area\\n\", i + 1);\n\t\treturn;\n\t}\n\tfirst = get_partition_start_from_dev_start(pe); /* == pe->offset_from_dev_start + get_start_sect(p) */\n\tnew = read_int(0 /*was:first*/, first, first + nr_sects - 1, first, \"New beginning of data\");\n\tif (new != first) {\n\t\tsector_t new_relative = new - pe->offset_from_dev_start;\n\t\tnr_sects += (get_start_sect(p) - new_relative);\n\t\tset_start_sect(p, new_relative);\n\t\tset_nr_sects(p, nr_sects);\n\t\tread_nonempty(\"Recalculate C/H/S values? (Y/N): \");\n\t\tif ((line_ptr[0] | 0x20) == 'y')\n\t\t\tset_hsc_start_end(p, new, new + nr_sects - 1);\n\t\tpe->changed = 1;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_489F54(__int64 a1)\n{\n  __int64 v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  _QWORD *v7; // [rsp+8h] [rbp-38h]\n  __int64 **m; // [rsp+18h] [rbp-28h]\n  char *s1; // [rsp+20h] [rbp-20h]\n  _QWORD *v10; // [rsp+28h] [rbp-18h]\n  void **j; // [rsp+30h] [rbp-10h]\n  _QWORD *v12; // [rsp+30h] [rbp-10h]\n  _QWORD *v13; // [rsp+30h] [rbp-10h]\n  int i; // [rsp+3Ch] [rbp-4h]\n  int k; // [rsp+3Ch] [rbp-4h]\n\n  v7 = (_QWORD *)(a1 + 8);\n  s1 = *(char **)(a1 + 8);\n  if ( s1 )\n  {\n    while ( 2 )\n    {\n      v2 = (__int64)\"--\";\n      if ( !strcmp(s1, \"--\") )\n      {\n        ++v7;\n      }\n      else\n      {\n        if ( *s1 == 43 || *s1 == 45 )\n        {\n          for ( i = 1; s1[i]; ++i )\n          {\n            v2 = (unsigned int)s1[i];\n            if ( (unsigned int)sub_488850(*s1 == 45, s1[i], v7[1]) )\n            {\n              sub_409747(\"set: %s: invalid option\", (__int64)s1, v3, v4, v5, v6);\n              return 1LL;\n            }\n            if ( s1[i] == 111 && v7[1] )\n              ++v7;\n          }\n          s1 = (char *)*++v7;\n          if ( *v7 )\n            continue;\n        }\n        if ( !s1 )\n          return 0LL;\n      }\n      break;\n    }\n    v10 = (_QWORD *)*((_QWORD *)qword_75D408 + 11);\n    if ( *((_BYTE *)qword_75D408 + 80) )\n    {\n      for ( j = (void **)*((_QWORD *)qword_75D408 + 11); *++j; free(*j) )\n        ;\n      v10[1] = 0LL;\n    }\n    else\n    {\n      *((_BYTE *)qword_75D408 + 80) = 1;\n      v12 = sub_40A0E8(0x10uLL, v2);\n      *v12 = *v10;\n      v10 = v12;\n    }\n    v13 = sub_47FFDB(v10, v7, 1);\n    *((_QWORD *)qword_75D408 + 11) = v13;\n    for ( k = 1; *++v13; ++k )\n      ;\n    *((_DWORD *)qword_75D408 + 21) = k;\n    return 0LL;\n  }\n  else\n  {\n    for ( m = (__int64 **)*((_QWORD *)qword_75D408 + 15); m; m = (__int64 **)*m )\n      puts((const char *)m[1]);\n    return 0LL;\n  }\n}\n\n\n Revised code:\nstatic int FAST_FUNC builtin_set(char **argv)\n{\n\tint n;\n\tchar **pp, **g_argv;\n\tchar *arg = *++argv;\n\n\tif (arg == NULL) {\n\t\tstruct variable *e;\n\t\tfor (e = G.top_var; e; e = e->next)\n\t\t\tputs(e->varstr);\n\t\treturn EXIT_SUCCESS;\n\t}\n\n\tdo {\n\t\tif (strcmp(arg, \"--\") == 0) {\n\t\t\t++argv;\n\t\t\tgoto set_argv;\n\t\t}\n\t\tif (arg[0] != '+' && arg[0] != '-')\n\t\t\tbreak;\n\t\tfor (n = 1; arg[n]; ++n) {\n\t\t\tif (set_mode((arg[0] == '-'), arg[n], argv[1]))\n\t\t\t\tgoto error;\n\t\t\tif (arg[n] == 'o' && argv[1])\n\t\t\t\targv++;\n\t\t}\n\t} while ((arg = *++argv) != NULL);\n\t/* Now argv[0] is 1st argument */\n\n\tif (arg == NULL)\n\t\treturn EXIT_SUCCESS;\n set_argv:\n\n\t/* NB: G.global_argv[0] ($0) is never freed/changed */\n\tg_argv = G.global_argv;\n\tif (G.global_args_malloced) {\n\t\tpp = g_argv;\n\t\twhile (*++pp)\n\t\t\tfree(*pp);\n\t\tg_argv[1] = NULL;\n\t} else {\n\t\tG.global_args_malloced = 1;\n\t\tpp = xzalloc(sizeof(pp[0]) * 2);\n\t\tpp[0] = g_argv[0]; /* retain $0 */\n\t\tg_argv = pp;\n\t}\n\t/* This realloc's G.global_argv */\n\tG.global_argv = pp = add_strings_to_strings(g_argv, argv, /*dup:*/ 1);\n\n\tn = 1;\n\twhile (*++pp)\n\t\tn++;\n\tG.global_argc = n;\n\n\treturn EXIT_SUCCESS;\n\n\t/* Nothing known, so abort */\n error:\n\tbb_error_msg(\"set: %s: invalid option\", arg);\n\treturn EXIT_FAILURE;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4771AE(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  const char *v7; // rdi\n  char v8[16]; // [rsp+10h] [rbp-30h] BYREF\n  const char *v9; // [rsp+20h] [rbp-20h]\n  unsigned int v10; // [rsp+2Ch] [rbp-14h]\n  char *j; // [rsp+30h] [rbp-10h]\n  char **i; // [rsp+38h] [rbp-8h]\n\n  if ( (unsigned int)sub_46F038(\"r\", a2, a3, a4, a5, a6) )\n  {\n    sub_476EEB(0LL, a2);\n    return 0LL;\n  }\n  else if ( *(_QWORD *)qword_75AF58 )\n  {\n    v10 = 0;\n    while ( 1 )\n    {\n      v9 = *(const char **)qword_75AF58;\n      if ( !v9 )\n        break;\n      v7 = v9;\n      j = sub_476FA6(v9, 0);\n      if ( j && (!j[16] || j[16] == 2 && dword_75AE34 >= 0) )\n        sub_4770DD((__int64)v7, 0LL);\n      sub_47E389(v9, v8, 1LL, *(_QWORD *)(qword_75D420 + 400) + 5LL);\n      if ( v8[0] == -1 )\n        v10 = 1;\n      qword_75AF58 += 8LL;\n    }\n    return v10;\n  }\n  else\n  {\n    for ( i = (char **)qword_75B018; (unsigned __int64)i < qword_75B018 + 248; ++i )\n    {\n      for ( j = *i; j; j = *(char **)j )\n      {\n        if ( !j[16] )\n          sub_476E50((__int64)j);\n      }\n    }\n    return 0LL;\n  }\n}\n\n\n Revised code:\nstatic int FAST_FUNC\nhashcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tstruct tblentry **pp;\n\tstruct tblentry *cmdp;\n\tint c;\n\tstruct cmdentry entry;\n\tchar *name;\n\n\tif (nextopt(\"r\") != '\\0') {\n\t\tclearcmdentry(0);\n\t\treturn 0;\n\t}\n\n\tif (*argptr == NULL) {\n\t\tfor (pp = cmdtable; pp < &cmdtable[CMDTABLESIZE]; pp++) {\n\t\t\tfor (cmdp = *pp; cmdp; cmdp = cmdp->next) {\n\t\t\t\tif (cmdp->cmdtype == CMDNORMAL)\n\t\t\t\t\tprintentry(cmdp);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tc = 0;\n\twhile ((name = *argptr) != NULL) {\n\t\tcmdp = cmdlookup(name, 0);\n\t\tif (cmdp != NULL\n\t\t && (cmdp->cmdtype == CMDNORMAL\n\t\t     || (cmdp->cmdtype == CMDBUILTIN && builtinloc >= 0))\n\t\t) {\n\t\t\tdelete_cmd_entry();\n\t\t}\n\t\tfind_command(name, &entry, DO_ERR, pathval());\n\t\tif (entry.cmdtype == CMDUNKNOWN)\n\t\t\tc = 1;\n\t\targptr++;\n\t}\n\treturn c;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_494BE4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  int result; // eax\n  const char *v7; // rdx\n  __int64 v8; // rsi\n  char s[87]; // [rsp+0h] [rbp-60h] BYREF\n  unsigned __int8 v10; // [rsp+57h] [rbp-9h]\n  int i; // [rsp+58h] [rbp-8h]\n  int v12; // [rsp+5Ch] [rbp-4h]\n\n  v12 = 0;\n  result = sub_4910F4(a1, a2, a3, a4, a5, a6);\n  if ( !result )\n  {\n    for ( i = 0; i <= 3; ++i )\n      v12 += *(_BYTE *)(*((_QWORD *)qword_75D408 + 5 * i + 313) + 4LL) == 0;\n    if ( v12 || *((int *)qword_75D408 + 4) <= 59 )\n    {\n      if ( v12 )\n      {\n        if ( *((_DWORD *)qword_75D408 + 22) )\n          v7 = \"l   logical (5 or over)\";\n        else\n          v7 = \"e   extended\";\n        v8 = 80LL;\n        snprintf(s, 0x50uLL, \"Command action\\n   %s\\n   p   primary partition (1-4)\\n\", v7);\n        while ( 1 )\n        {\n          v10 = sub_49077B((__int64)s);\n          if ( (v10 | 0x20) == 112 )\n          {\n            result = sub_4921FA(0, 4u);\n            i = result;\n            if ( result >= 0 )\n              return sub_4940D3(i, 131);\n            return result;\n          }\n          if ( v10 == 108 && *((_DWORD *)qword_75D408 + 22) )\n            return sub_494AF9((__int64)s, v8);\n          if ( v10 == 101 && !*((_DWORD *)qword_75D408 + 22) )\n            break;\n          v8 = (unsigned int)(char)v10;\n          printf(\"Invalid partition number for type '%c'\\n\", v8);\n        }\n        result = sub_4921FA(0, 4u);\n        i = result;\n        if ( result >= 0 )\n          return sub_4940D3(i, 5);\n      }\n      else if ( *((_DWORD *)qword_75D408 + 22) )\n      {\n        return sub_494AF9(a1, a2);\n      }\n      else\n      {\n        return puts(\"You must delete some partition and add an extended partition first\");\n      }\n    }\n    else\n    {\n      return puts(\"The maximum number of partitions has been created\");\n    }\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "open_trunc_or_warn",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40A2DB(const char *a1, int a2, unsigned int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v8; // [rsp+1Ch] [rbp-4h]\n\n  v8 = open64(a1, a2, a3);\n  if ( v8 < 0 )\n    sub_4091D9((__int64)\"can't open '%s'\", (__int64)a1, v3, v4, v5, v6);\n  return (unsigned int)v8;\n}\n\n\n Revised code:\nint FAST_FUNC open3_or_warn(const char *pathname, int flags, int mode)\n{\n\tint ret;\n\n\tret = open(pathname, flags, mode);\n\tif (ret < 0) {\n\t\tbb_perror_msg(\"can't open '%s'\", pathname);\n\t}\n\treturn ret;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40A246(const char *a1, int a2, unsigned int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v8; // [rsp+1Ch] [rbp-4h]\n\n  v8 = open64(a1, a2, a3);\n  if ( v8 < 0 )\n    sub_4092A2((__int64)\"can't open '%s'\", (__int64)a1, v3, v4, v5, v6);\n  return (unsigned int)v8;\n}\n\n\n Revised code:\nint FAST_FUNC xopen3(const char *pathname, int flags, int mode)\n{\n\tint ret;\n\n\tret = open(pathname, flags, mode);\n\tif (ret < 0) {\n\t\tbb_perror_msg_and_die(\"can't open '%s'\", pathname);\n\t}\n\treturn ret;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4F9CA0(const char *a1)\n{\n  int v2; // [rsp+1Ch] [rbp-4h]\n\n  v2 = open64(a1, 2);\n  if ( v2 < 0 && *(_DWORD *)qword_75D400 == 13 )\n    v2 = open64(a1, 0);\n  if ( v2 < 0 && *(_DWORD *)qword_75D400 == 13 )\n    return (unsigned int)open64(a1, 1);\n  return (unsigned int)v2;\n}\n\n\n Revised code:\nstatic int open_a_console(const char *fnam)\n{\n\tint fd;\n\n\t/* try read-write */\n\tfd = open(fnam, O_RDWR);\n\n\t/* if failed, try read-only */\n\tif (fd < 0 && errno == EACCES)\n\t\tfd = open(fnam, O_RDONLY);\n\n\t/* if failed, try write-only */\n\tif (fd < 0 && errno == EACCES)\n\t\tfd = open(fnam, O_WRONLY);\n\n\treturn fd;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4686C8(const char *a1)\n{\n  __int64 v1; // rcx\n  __int64 v2; // r8\n  __int64 v3; // r9\n  int v5; // [rsp+1Ch] [rbp-4h]\n\n  v5 = open64(a1, 2625, 420LL);\n  if ( v5 < 0 )\n    sub_4091D9((__int64)\"%s: warning: cannot open %s\", *(_QWORD *)&dest.c_cc[7], (__int64)a1, v1, v2, v3);\n  return (unsigned int)v5;\n}\n"
    },
    {
        "func_name": "hashwalk_next",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_481E8D(__int64 a1, unsigned int a2)\n{\n  __int64 v3; // rbx\n  unsigned int v4; // [rsp+4h] [rbp-2Ch]\n  char *ptr; // [rsp+10h] [rbp-20h]\n  char *v6; // [rsp+18h] [rbp-18h]\n\n  if ( !*(_QWORD *)a1 )\n    return sub_4818B0(a1, a2);\n  v3 = *(_QWORD *)a1;\n  v6 = (char *)(v3 + (int)sub_4819F4((_QWORD *)a1, a2));\n  if ( (unsigned int)sub_481A3B(v6) )\n  {\n    ptr = sub_40A11F(v6, a2);\n    *(_DWORD *)(a1 + 8) = (_DWORD)v6 - *(_DWORD *)a1;\n    v4 = sub_481B55(ptr, a1, a2);\n    free(ptr);\n    return v4;\n  }\n  else\n  {\n    *(_DWORD *)(a1 + 8) = (unsigned int)sub_47FF75(v6) - *(_DWORD *)a1;\n    return sub_4818B0(a1, a2);\n  }\n}\n\n\n Revised code:\nstatic int perform_glob(o_string *o, int n)\n{\n\tchar *pattern, *copy;\n\n\tdebug_printf_glob(\"start perform_glob: n:%d o->data:%p\\n\", n, o->data);\n\tif (!o->data)\n\t\treturn o_save_ptr_helper(o, n);\n\tpattern = o->data + o_get_last_ptr(o, n);\n\tdebug_printf_glob(\"glob pattern '%s'\\n\", pattern);\n\tif (!glob_needed(pattern)) {\n\t\t/* unbackslash last string in o in place, fix length */\n\t\to->length = unbackslash(pattern) - o->data;\n\t\tdebug_printf_glob(\"glob pattern '%s' is literal\\n\", pattern);\n\t\treturn o_save_ptr_helper(o, n);\n\t}\n\n\tcopy = xstrdup(pattern);\n\t/* \"forget\" pattern in o */\n\to->length = pattern - o->data;\n\tn = glob_brace(copy, o, n);\n\tfree(copy);\n\tif (DEBUG_GLOB)\n\t\tdebug_print_list(\"perform_glob returning\", o, n);\n\treturn n;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4F63B5(unsigned int a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40C486(a1, a2);\n  if ( v3 )\n    return *(_QWORD *)v3;\n  else\n    return 0LL;\n}\n\n\n Revised code:\nFAST_FUNC uid2uname(uid_t uid)\n{\n\tstruct passwd *pw = getpwuid(uid);\n\treturn (pw) ? pw->pw_name : NULL;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4D9DFF(char *a1, __int64 a2)\n{\n  char *v3; // rax\n  char *v4; // [rsp+8h] [rbp-18h]\n  char v5; // [rsp+17h] [rbp-9h]\n  _QWORD *v6; // [rsp+18h] [rbp-8h]\n\n  v4 = a1 + 1;\n  v5 = *a1;\n  v6 = (_QWORD *)(a2 + 8);\n  if ( *a1 == 45 )\n  {\n    *(_BYTE *)(a2 + 24) |= 2u;\n    v6 = (_QWORD *)(a2 + 16);\n  }\n  else if ( v5 == 43 )\n  {\n    *(_BYTE *)(a2 + 24) |= 1u;\n  }\n  else\n  {\n    if ( v5 != 61 )\n      return 0LL;\n    *(_BYTE *)(a2 + 24) |= 4u;\n  }\n  while ( *v4 )\n  {\n    v3 = v4++;\n    *v6 |= sub_4D9DB6(*v3);\n  }\n  return 1LL;\n}\n\n\n Revised code:\nstatic int decode_arg(const char *arg, struct globals *gp)\n{\n\tunsigned long *fl;\n\tchar opt = *arg++;\n\n\tfl = &gp->af;\n\tif (opt == '-') {\n\t\tgp->flags |= OPT_REM;\n\t\tfl = &gp->rf;\n\t} else if (opt == '+') {\n\t\tgp->flags |= OPT_ADD;\n\t} else if (opt == '=') {\n\t\tgp->flags |= OPT_SET;\n\t} else\n\t\treturn 0;\n\n\twhile (*arg)\n\t\t*fl |= get_flag(*arg++);\n\n\treturn 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4DF493(__int64 a1)\n{\n  const char *v2; // rax\n  __int64 v3; // [rsp+10h] [rbp-10h]\n  __int64 *ptr; // [rsp+18h] [rbp-8h]\n\n  ptr = *(__int64 **)(a1 + 24);\n  if ( ptr[1] < (unsigned __int64)*ptr )\n  {\n    v2 = (const char *)sub_4DC55F(ptr + 1);\n    sub_4DC927(a1, v2);\n    return 1LL;\n  }\n  else\n  {\n    v3 = ptr[2];\n    free(ptr);\n    *(_QWORD *)(a1 + 24) = v3;\n    return 0LL;\n  }\n}\n"
    },
    {
        "func_name": "get_partition",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_492134(int a1, unsigned int a2)\n{\n  _BYTE *v3; // [rsp+18h] [rbp-18h]\n  unsigned int i; // [rsp+28h] [rbp-8h]\n  int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = -1;\n  for ( i = 0; i < a2; ++i )\n  {\n    v3 = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * i + 313);\n    if ( v3 && !sub_490BFC(v3) )\n    {\n      if ( v5 >= 0 )\n        return sub_4920A7(a1, a2);\n      v5 = i;\n    }\n  }\n  if ( v5 < 0 )\n  {\n    puts(\"No partition is defined yet!\");\n    return 0xFFFFFFFFLL;\n  }\n  else\n  {\n    printf(\"Selected partition %u\\n\", (unsigned int)(v5 + 1));\n    return (unsigned int)v5;\n  }\n}\n\n\n Revised code:\nstatic int\nget_existing_partition(int warn, unsigned max)\n{\n\tint pno = -1;\n\tunsigned i;\n\n\tfor (i = 0; i < max; i++) {\n\t\tstruct pte *pe = &ptes[i];\n\t\tstruct partition *p = pe->part_table;\n\n\t\tif (p && !is_cleared_partition(p)) {\n\t\t\tif (pno >= 0)\n\t\t\t\tgoto not_unique;\n\t\t\tpno = i;\n\t\t}\n\t}\n\tif (pno >= 0) {\n\t\tprintf(\"Selected partition %u\\n\", pno+1);\n\t\treturn pno;\n\t}\n\tprintf(\"No partition is defined yet!\\n\");\n\treturn -1;\n\n not_unique:\n\treturn get_partition(warn, max);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4921FA(int a1, unsigned int a2)\n{\n  _BYTE *v3; // [rsp+18h] [rbp-18h]\n  unsigned int i; // [rsp+28h] [rbp-8h]\n  int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = -1;\n  for ( i = 0; i < a2; ++i )\n  {\n    v3 = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * i + 313);\n    if ( v3 && sub_490BFC(v3) )\n    {\n      if ( v5 >= 0 )\n        return sub_4920A7(a1, a2);\n      v5 = i;\n    }\n  }\n  if ( v5 < 0 )\n  {\n    puts(\"All primary partitions have been defined already!\");\n    return 0xFFFFFFFFLL;\n  }\n  else\n  {\n    printf(\"Selected partition %u\\n\", (unsigned int)(v5 + 1));\n    return (unsigned int)v5;\n  }\n}\n\n\n Revised code:\nstatic int\nget_nonexisting_partition(int warn, unsigned max)\n{\n\tint pno = -1;\n\tunsigned i;\n\n\tfor (i = 0; i < max; i++) {\n\t\tstruct pte *pe = &ptes[i];\n\t\tstruct partition *p = pe->part_table;\n\n\t\tif (p && is_cleared_partition(p)) {\n\t\t\tif (pno >= 0)\n\t\t\t\tgoto not_unique;\n\t\t\tpno = i;\n\t\t}\n\t}\n\tif (pno >= 0) {\n\t\tprintf(\"Selected partition %u\\n\", pno+1);\n\t\treturn pno;\n\t}\n\tprintf(\"All primary partitions have been defined already!\\n\");\n\treturn -1;\n\n not_unique:\n\treturn get_partition(warn, max);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4FE0EA(__int64 a1, int a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_509131(a1, *((_QWORD *)qword_75D458 + 6), (unsigned int)(a2 - 1));\n  if ( v3 < 0 )\n    v3 = 0LL;\n  *(_BYTE *)(v3 + a1) = 0;\n  return v3;\n}\n\n\n Revised code:\nstatic unsigned save_string(char *dst, unsigned maxsize)\n{\n\tif (unicode_status == UNICODE_ON) {\n# if !ENABLE_UNICODE_PRESERVE_BROKEN\n\t\tssize_t len = wcstombs(dst, command_ps, maxsize - 1);\n\t\tif (len < 0)\n\t\t\tlen = 0;\n\t\tdst[len] = '\\0';\n\t\treturn len;\n# else\n\t\tunsigned dstpos = 0;\n\t\tunsigned srcpos = 0;\n\n\t\tmaxsize--;\n\t\twhile (dstpos < maxsize) {\n\t\t\twchar_t wc;\n\t\t\tint n = srcpos;\n\n\t\t\t/* Convert up to 1st invalid byte (or up to end) */\n\t\t\twhile ((wc = command_ps[srcpos]) != BB_NUL\n\t\t\t    && !unicode_is_raw_byte(wc)\n\t\t\t) {\n\t\t\t\tsrcpos++;\n\t\t\t}\n\t\t\tcommand_ps[srcpos] = BB_NUL;\n\t\t\tn = wcstombs(dst + dstpos, command_ps + n, maxsize - dstpos);\n\t\t\tif (n < 0) /* should not happen */\n\t\t\t\tbreak;\n\t\t\tdstpos += n;\n\t\t\tif (wc == BB_NUL) /* usually is */\n\t\t\t\tbreak;\n\n\t\t\t/* We do have invalid byte here! */\n\t\t\tcommand_ps[srcpos] = wc; /* restore it */\n\t\t\tsrcpos++;\n\t\t\tif (dstpos == maxsize)\n\t\t\t\tbreak;\n\t\t\tdst[dstpos++] = (char) wc;\n\t\t}\n\t\tdst[dstpos] = '\\0';\n\t\treturn dstpos;\n# endif\n\t} else {\n\t\tunsigned i = 0;\n\t\twhile ((dst[i] = command_ps[i]) != 0)\n\t\t\ti++;\n\t\treturn i;\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4920A7(int a1, unsigned int a2)\n{\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_491DF8(1u, 0, a2, 0, (__int64)\"Partition number\") - 1;\n  if ( a1 && !*(_BYTE *)(*((_QWORD *)qword_75D408 + 5 * v3 + 313) + 4LL) )\n    printf(\"Warning: partition %u has empty type\\n\", v3 + 1);\n  return v3;\n}\n"
    },
    {
        "func_name": "xfork",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_415BB6(__int64 a1, const char *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  int v7; // eax\n  ssize_t v8; // rax\n  char v9; // [rsp+17h] [rbp-9h] BYREF\n  __pid_t v10; // [rsp+18h] [rbp-8h]\n  __pid_t v11; // [rsp+1Ch] [rbp-4h]\n\n  v11 = vfork();\n  if ( v11 < 0 )\n    sub_4092A2((__int64)\"vfork\", (__int64)a2, v2, v3, v4, v5);\n  v10 = v11;\n  if ( !v11 )\n  {\n    sub_4F6569(a1);\n    v7 = sub_40A295(a2, 0);\n    v8 = sub_40B3FF(v7, &v9, 1uLL);\n    _exit(v8 < 0);\n  }\n  if ( (unsigned int)sub_409FAE(v10) )\n    return -1;\n  else\n    return open64(a2, 0);\n}\n\n\n Revised code:\nstatic int open_as_user(const struct passwd *pas, const char *file)\n{\n\tpid_t pid;\n\tchar c;\n\n\tpid = xvfork();\n\tif (pid) { /* PARENT */\n\t\tif (wait4pid(pid) == 0) {\n\t\t\t/* exitcode 0: child says it can read */\n\t\t\treturn open(file, O_RDONLY);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* CHILD */\n\t/* initgroups, setgid, setuid */\n\tchange_identity(pas);\n\t/* We just try to read one byte. If it works, file is readable\n\t * under this user. We signal that by exiting with 0. */\n\t_exit(safe_read(xopen(file, O_RDONLY), &c, 1) < 0);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_50A55F(const char **a1)\n{\n  __pid_t v2; // [rsp+1Ch] [rbp-4h]\n\n  sub_40A649();\n  v2 = vfork();\n  if ( v2 < 0 )\n    return (unsigned int)v2;\n  if ( !v2 )\n  {\n    execvp(*a1, (char *const *)a1);\n    _exit(111);\n  }\n  return (unsigned int)v2;\n}\n\n\n Revised code:\npid_t FAST_FUNC spawn(char **argv)\n{\n\t/* Compiler should not optimize stores here */\n\tvolatile int failed;\n\tpid_t pid;\n\n\tfflush_all();\n\n\t/* Be nice to nommu machines. */\n\tfailed = 0;\n\tpid = vfork();\n\tif (pid < 0) /* error */\n\t\treturn pid;\n\tif (!pid) { /* child */\n\t\t/* This macro is ok - it doesn't do NOEXEC/NOFORK tricks */\n\t\tBB_EXECVP(argv[0], argv);\n\n\t\t/* We are (maybe) sharing a stack with blocked parent,\n\t\t * let parent know we failed and then exit to unblock parent\n\t\t * (but don't run atexit() stuff, which would screw up parent.)\n\t\t */\n\t\tfailed = errno;\n\t\t/* mount, for example, does not want the message */\n\t\t/*bb_perror_msg(\"can't execute '%s'\", argv[0]);*/\n\t\t_exit(111);\n\t}\n\t/* parent */\n\t/* Unfortunately, this is not reliable: according to standards\n\t * vfork() can be equivalent to fork() and we won't see value\n\t * of 'failed'.\n\t * Interested party can wait on pid and learn exit code.\n\t * If 111 - then it (most probably) failed to exec */\n\tif (failed) {\n\t\tsafe_waitpid(pid, NULL, 0); /* prevent zombie */\n\t\terrno = failed;\n\t\treturn -1;\n\t}\n\treturn pid;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_472EC3(const char *a1, const char *a2, int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v9; // [rsp+2Ch] [rbp-4h]\n\n  v9 = fork();\n  if ( v9 < 0 )\n  {\n    if ( a1 )\n      sub_47107C((__int64)a1);\n    sub_46E473(\"can't fork\", (__int64)a2, v3, v4, v5, v6);\n  }\n  if ( v9 )\n  {\n    sub_472D83((__int64)a1, (__int64)a2, a3, v9);\n  }\n  else\n  {\n    *(_DWORD *)(qword_75D418 + 736) = 0;\n    sub_472B1A(a1, a2, a3);\n  }\n  return (unsigned int)v9;\n}\n\n\n Revised code:\nstatic int\nforkshell(struct job *jp, union node *n, int mode)\n{\n\tint pid;\n\n\tTRACE((\"forkshell(%%%d, %p, %d) called\\n\", jobno(jp), n, mode));\n\tpid = fork();\n\tif (pid < 0) {\n\t\tTRACE((\"Fork failed, errno=%d\", errno));\n\t\tif (jp)\n\t\t\tfreejob(jp);\n\t\tash_msg_and_raise_error(\"can't fork\");\n\t}\n\tif (pid == 0) {\n\t\tCLEAR_RANDOM_T(&random_gen); /* or else $RANDOM repeats in child */\n\t\tforkchild(jp, n, mode);\n\t} else {\n\t\tforkparent(jp, n, mode, pid);\n\t}\n\treturn pid;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40AEE6(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __pid_t v7; // [rsp+Ch] [rbp-4h]\n\n  v7 = fork();\n  if ( v7 < 0 )\n    sub_4092A2((__int64)\"fork\", a2, v2, v3, v4, v5);\n  return (unsigned int)v7;\n}\n"
    },
    {
        "func_name": "chmod_main",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_46FB8F(_QWORD *a1, const char *a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // rax\n  __int64 v8; // rdx\n  __int64 v9; // rcx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  unsigned __int64 v12; // [rsp+10h] [rbp-30h]\n  _BYTE *src; // [rsp+18h] [rbp-28h]\n  char *dest; // [rsp+20h] [rbp-20h]\n  _BYTE *i; // [rsp+28h] [rbp-18h]\n\n  if ( !*a1 )\n    return 0LL;\n  src = (_BYTE *)*a1;\n  for ( i = (_BYTE *)*a1; *i && *i != 58 && *i != 37; ++i )\n    ;\n  v12 = i - src + strlen(a2) + 2;\n  while ( v12 > *(_QWORD *)(qword_75D428 + 32) )\n    sub_46E9D5((__int64)a2, (__int64)a2, v3, v4, v5, v6);\n  dest = *(char **)(qword_75D428 + 16);\n  if ( i != src )\n  {\n    memcpy(dest, src, i - src);\n    v7 = &dest[i - src];\n    dest = v7 + 1;\n    *v7 = 47;\n  }\n  strcpy(dest, a2);\n  qword_75AF70 = 0LL;\n  if ( *i == 37 )\n  {\n    qword_75AF70 = (__int64)++i;\n    while ( *i && *i != 58 )\n      ++i;\n  }\n  if ( *i == 58 )\n  {\n    v8 = (__int64)(i + 1);\n    *a1 = i + 1;\n  }\n  else\n  {\n    *a1 = 0LL;\n  }\n  return sub_46E6A8(v12, (__int64)a2, v8, v9, v10, v11);\n}\n\n\n Revised code:\nstatic char *\npath_advance(const char **path, const char *name)\n{\n\tconst char *p;\n\tchar *q;\n\tconst char *start;\n\tsize_t len;\n\n\tif (*path == NULL)\n\t\treturn NULL;\n\tstart = *path;\n\tfor (p = start; *p && *p != ':' && *p != '%'; p++)\n\t\tcontinue;\n\tlen = p - start + strlen(name) + 2;     /* \"2\" is for '/' and '\\0' */\n\twhile (stackblocksize() < len)\n\t\tgrowstackblock();\n\tq = stackblock();\n\tif (p != start) {\n\t\tmemcpy(q, start, p - start);\n\t\tq += p - start;\n\t\t*q++ = '/';\n\t}\n\tstrcpy(q, name);\n\tpathopt = NULL;\n\tif (*p == '%') {\n\t\tpathopt = ++p;\n\t\twhile (*p && *p != ':')\n\t\t\tp++;\n\t}\n\tif (*p == ':')\n\t\t*path = p + 1;\n\telse\n\t\t*path = NULL;\n\treturn stalloc(len);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4C63E2(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  __int64 v6; // rax\n  _BOOL4 v7; // edx\n  int v8; // eax\n  int v9; // edx\n  __int64 v11; // [rsp+0h] [rbp-40h]\n  __int64 v12[2]; // [rsp+10h] [rbp-30h]\n  void *ptr; // [rsp+20h] [rbp-20h]\n  char *s2; // [rsp+28h] [rbp-18h]\n  void *v15; // [rsp+30h] [rbp-10h]\n  int v16; // [rsp+38h] [rbp-8h]\n  int i; // [rsp+3Ch] [rbp-4h]\n\n  qword_75D440 = (__int64)\"=2\";\n  sub_4FA1EF(a2, (unsigned int)\"123\", a3, a4, a5, a6);\n  v11 = 8LL * optind + a2;\n  for ( i = 0; i <= 1; ++i )\n  {\n    v6 = sub_50A7F5(*(_QWORD *)(8LL * i + v11));\n    v12[i] = v6;\n  }\n  v16 = 0;\n  ptr = 0LL;\n  s2 = 0LL;\n  while ( 1 )\n  {\n    if ( v16 <= 0 )\n    {\n      free(ptr);\n      ptr = (void *)sub_4F9FF1(v12[0]);\n    }\n    if ( v16 >= 0 )\n    {\n      free(s2);\n      s2 = (char *)sub_4F9FF1(v12[1]);\n    }\n    v7 = ptr == 0LL;\n    v8 = s2 ? 0 : 2;\n    i = v7 + v8;\n    if ( v7 + v8 )\n      break;\n    v16 = strcmp((const char *)ptr, s2);\n    if ( v16 < 0 )\n    {\n      sub_4C634C((const char *)ptr, 0);\n    }\n    else\n    {\n      if ( v16 )\n        v9 = 1;\n      else\n        v9 = 2;\n      sub_4C634C(s2, v9);\n    }\n  }\n  i &= 1u;\n  if ( *(&ptr + i) )\n  {\n    v15 = *(&ptr + i);\n    sub_4C634C((const char *)v15, i);\n    while ( 1 )\n    {\n      free(v15);\n      v15 = (void *)sub_4F9FF1(v12[i]);\n      if ( !v15 )\n        break;\n      sub_4C634C((const char *)v15, i);\n    }\n  }\n  return 0LL;\n}\n\n\n Revised code:\nint comm_main(int argc UNUSED_PARAM, char **argv)\n{\n\tchar *thisline[2];\n\tFILE *stream[2];\n\tint i;\n\tint order;\n\n\topt_complementary = \"=2\";\n\tgetopt32(argv, \"123\");\n\targv += optind;\n\n\tfor (i = 0; i < 2; ++i) {\n\t\tstream[i] = xfopen_stdin(argv[i]);\n\t}\n\n\torder = 0;\n\tthisline[1] = thisline[0] = NULL;\n\twhile (1) {\n\t\tif (order <= 0) {\n\t\t\tfree(thisline[0]);\n\t\t\tthisline[0] = xmalloc_fgetline(stream[0]);\n\t\t}\n\t\tif (order >= 0) {\n\t\t\tfree(thisline[1]);\n\t\t\tthisline[1] = xmalloc_fgetline(stream[1]);\n\t\t}\n\n\t\ti = !thisline[0] + (!thisline[1] << 1);\n\t\tif (i)\n\t\t\tbreak;\n\t\torder = strcmp(thisline[0], thisline[1]);\n\n\t\tif (order >= 0)\n\t\t\twriteline(thisline[1], order ? 1 : 2);\n\t\telse\n\t\t\twriteline(thisline[0], 0);\n\t}\n\n\t/* EOF at least on one of the streams */\n\ti &= 1;\n\tif (thisline[i]) {\n\t\t/* stream[i] is not at EOF yet */\n\t\t/* we did not print thisline[i] yet */\n\t\tchar *p = thisline[i];\n\t\twriteline(p, i);\n\t\twhile (1) {\n\t\t\tfree(p);\n\t\t\tp = xmalloc_fgetline(stream[i]);\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\t\t\twriteline(p, i);\n\t\t}\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP) {\n\t\tfclose(stream[0]);\n\t\tfclose(stream[1]);\n\t}\n\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_473F3A(unsigned __int8 *a1, unsigned __int64 a2, char a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  unsigned __int64 v6; // rax\n  unsigned __int8 *v7; // rax\n  _BYTE *v8; // rax\n  unsigned __int8 *v9; // rax\n  __int64 result; // rax\n  int v12; // [rsp+8h] [rbp-28h]\n  unsigned __int64 v14; // [rsp+10h] [rbp-20h]\n  int v16; // [rsp+20h] [rbp-10h]\n  unsigned __int8 v17; // [rsp+27h] [rbp-9h]\n  __int64 v18; // [rsp+28h] [rbp-8h]\n\n  v14 = a2;\n  v12 = a4;\n  if ( (_DWORD)a4 )\n    v6 = 2 * a2;\n  else\n    v6 = a2;\n  v18 = sub_46ECB9(v6, qword_75AFC8, qword_75AFC8, a4, a5, a6);\n  while ( v14-- )\n  {\n    v7 = a1++;\n    v17 = *v7;\n    if ( *v7 )\n    {\n      if ( v12 )\n      {\n        v16 = sub_4704BD(v17, a3);\n        if ( v16 == 12 || v16 == 2 )\n        {\n          v8 = (_BYTE *)v18++;\n          *v8 = -127;\n        }\n      }\n      v9 = (unsigned __int8 *)v18++;\n      *v9 = v17;\n    }\n  }\n  result = v18;\n  qword_75AFC8 = v18;\n  return result;\n}\n\n\n Revised code:\nstatic void\nmemtodest(const char *p, size_t len, int syntax, int quotes)\n{\n\tchar *q = expdest;\n\n\tq = makestrspace(quotes ? len * 2 : len, q);\n\n\twhile (len--) {\n\t\tunsigned char c = *p++;\n\t\tif (c == '\\0')\n\t\t\tcontinue;\n\t\tif (quotes) {\n\t\t\tint n = SIT(c, syntax);\n\t\t\tif (n == CCTL || n == CBACK)\n\t\t\t\tUSTPUTC(CTLESC, q);\n\t\t}\n\t\tUSTPUTC(c, q);\n\t}\n\n\texpdest = q;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4C5E24(__int64 a1, _BYTE **a2, __int64 a3, int a4, int a5, int a6)\n{\n  __int64 *v6; // rax\n  __int64 v8; // [rsp+0h] [rbp-30h]\n  __int64 *v9; // [rsp+0h] [rbp-30h]\n  _QWORD *v10; // [rsp+0h] [rbp-30h]\n  __int64 v11; // [rsp+10h] [rbp-20h]\n  _BYTE **v12; // [rsp+18h] [rbp-18h]\n  _BYTE *v13; // [rsp+20h] [rbp-10h]\n  unsigned int v14; // [rsp+2Ch] [rbp-4h]\n\n  v14 = 0;\n  v12 = a2;\n  while ( 1 )\n  {\n    v13 = *++v12;\n    if ( !*v12 )\n      break;\n    if ( *v13 != 45 )\n    {\n      v13 = 0LL;\n      break;\n    }\n    if ( v13[1] && !strchr(\"-Rvcf\", (char)v13[1]) )\n    {\n      *v13 = 97;\n      break;\n    }\n  }\n  qword_75D440 = (__int64)\"-2\";\n  sub_4FA1EF((_DWORD)a2, 5447004, 5447004, a4, a5, a6, a2);\n  v9 = (__int64 *)(8LL * optind + v8);\n  if ( v13 )\n    *v13 = 45;\n  v6 = v9;\n  v10 = v9 + 1;\n  v11 = *v6;\n  do\n  {\n    if ( !(unsigned int)sub_50752C(*v10, dword_75D450 & 1, sub_4C5D04, sub_4C5D04, v11, 0LL) )\n      v14 = 1;\n    ++v10;\n  }\n  while ( *v10 );\n  return v14;\n}\n"
    },
    {
        "func_name": "out1fmt",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 sub_46E1F9(char *a1, size_t a2, const char *a3, __int64 a4, __int64 a5, __int64 a6, ...)\n{\n  gcc_va_list arg; // [rsp+20h] [rbp-D0h] BYREF\n  unsigned int v8; // [rsp+3Ch] [rbp-B4h]\n  __int64 v9; // [rsp+58h] [rbp-98h]\n  __int64 v10; // [rsp+60h] [rbp-90h]\n  __int64 v11; // [rsp+68h] [rbp-88h]\n\n  va_start(arg, a6);\n  v9 = a4;\n  v10 = a5;\n  v11 = a6;\n  arg[0].gp_offset = 24;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  v8 = vsnprintf(a1, a2, a3, arg);\n  sub_46E03F(a1, a2);\n  return v8;\n}\n\n\n Revised code:\nstatic int\nfmtstr(char *outbuf, size_t length, const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\n\tva_start(ap, fmt);\n\tINT_OFF;\n\tret = vsnprintf(outbuf, length, fmt, ap);\n\tva_end(ap);\n\tINT_ON;\n\treturn ret;\n}\n\n## Example:\n\n Input code:\n__int64 sub_46E5D9(const char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)\n{\n  gcc_va_list va; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v8; // [rsp+38h] [rbp-A8h]\n  __int64 v9; // [rsp+40h] [rbp-A0h]\n  __int64 v10; // [rsp+48h] [rbp-98h]\n  __int64 v11; // [rsp+50h] [rbp-90h]\n  __int64 v12; // [rsp+58h] [rbp-88h]\n\n  va_start(va, a6);\n  v8 = a2;\n  v9 = a3;\n  v10 = a4;\n  v11 = a5;\n  v12 = a6;\n  va[0].gp_offset = 8;\n  return sub_46E350(a1, va);\n}\n\n\n Revised code:\nstatic void\nash_msg(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tash_vmsg(fmt, ap);\n\tva_end(ap);\n}\n\n## Example:\n\n Input code:\nvoid __noreturn sub_46E473(const char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)\n{\n  gcc_va_list va; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(va, a6);\n  v7 = a2;\n  v8 = a3;\n  v9 = a4;\n  v10 = a5;\n  v11 = a6;\n  va[0].gp_offset = 8;\n  sub_46E43E(1, a1, va);\n}\n\n\n Revised code:\nstatic void\nash_msg_and_raise_error(const char *msg, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, msg);\n\tash_vmsg_and_raise(EXERROR, msg, ap);\n\t/* NOTREACHED */\n\tva_end(ap);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_46E137(const char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)\n{\n  gcc_va_list arg; // [rsp+10h] [rbp-D0h] BYREF\n  unsigned int v8; // [rsp+2Ch] [rbp-B4h]\n  __int64 v9; // [rsp+38h] [rbp-A8h]\n  __int64 v10; // [rsp+40h] [rbp-A0h]\n  __int64 v11; // [rsp+48h] [rbp-98h]\n  __int64 v12; // [rsp+50h] [rbp-90h]\n  __int64 v13; // [rsp+58h] [rbp-88h]\n\n  va_start(arg, a6);\n  v9 = a2;\n  v10 = a3;\n  v11 = a4;\n  v12 = a5;\n  v13 = a6;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  arg[0].gp_offset = 8;\n  v8 = vprintf(a1, arg);\n  sub_46E03F(a1, arg);\n  return v8;\n}\n"
    },
    {
        "func_name": "localcmd",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4707B3(const char *a1, __int64 a2)\n{\n  void **v2; // rdi\n  void ***v4; // [rsp+18h] [rbp-8h]\n\n  v4 = (void ***)sub_470562(a1);\n  if ( !*v4 )\n    return 1LL;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  v2 = *v4;\n  *v4 = sub_470668(*v4);\n  sub_46E03F(v2, a2);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int\nunalias(const char *name)\n{\n\tstruct alias **app;\n\n\tapp = __lookupalias(name);\n\n\tif (*app) {\n\t\tINT_OFF;\n\t\t*app = freealias(*app);\n\t\tINT_ON;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_46FA1E(_QWORD *a1, unsigned int a2)\n{\n  __int64 result; // rax\n  unsigned __int8 *v3; // rdi\n  _QWORD *v4; // [rsp+18h] [rbp-8h]\n\n  result = (__int64)a1;\n  v4 = a1;\n  if ( a1 )\n  {\n    ++*(_DWORD *)(qword_75D418 + 48);\n    do\n    {\n      v3 = (unsigned __int8 *)v4[1];\n      sub_46F51C(v3, a2);\n      v4 = (_QWORD *)*v4;\n    }\n    while ( v4 );\n    return sub_46E03F(v3, a2);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\nlistsetvar(struct strlist *list_set_var, int flags)\n{\n\tstruct strlist *lp = list_set_var;\n\n\tif (!lp)\n\t\treturn;\n\tINT_OFF;\n\tdo {\n\t\tsetvareq(lp->text, flags);\n\t\tlp = lp->next;\n\t} while (lp);\n\tINT_ON;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_453547(unsigned __int8 *a1)\n{\n  unsigned __int8 *v3; // [rsp+0h] [rbp-8h]\n\n  while ( 1 )\n  {\n    v3 = sub_4534CD(a1);\n    if ( !v3 )\n      return 0LL;\n    if ( !*v3 )\n      break;\n    a1 = v3 + 1;\n  }\n  return 1LL;\n}\n\n\n Revised code:\nstatic int good_hostname(const char *name)\n{\n\t//const char *start = name;\n\n\tfor (;;) {\n\t\tname = valid_domain_label(name);\n\t\tif (!name)\n\t\t\treturn 0;\n\t\tif (!name[0])\n\t\t\treturn 1;\n\t\t\t//Do we want this?\n\t\t\t//return ((name - start) < 1025); /* NS_MAXDNAME */\n\t\tname++;\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4792F7(__int64 a1, __int64 a2)\n{\n  unsigned __int8 **v2; // rax\n  __int64 v4; // [rsp+0h] [rbp-20h]\n\n  v4 = qword_75AF58;\n  while ( 1 )\n  {\n    v2 = (unsigned __int8 **)v4;\n    v4 += 8LL;\n    if ( !*v2 )\n      break;\n    sub_47916A(*v2, a2);\n  }\n  return 0LL;\n}\n"
    },
    {
        "func_name": "undot",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A3D68(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+0h] [rbp-1Ch]\n  int v4; // [rsp+14h] [rbp-8h]\n  unsigned int i; // [rsp+18h] [rbp-4h]\n\n  v3 = a2;\n  if ( a2 )\n  {\n    v3 = a2 - 1;\n    if ( a2 != 1 && *(_DWORD *)(4LL * v3 + a1) == 10 )\n      v3 = a2 - 2;\n  }\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i >= v3 )\n      break;\n    v4 = *(_DWORD *)(4LL * (int)i + a1);\n    *(_DWORD *)(4LL * (int)i + a1) = *(_DWORD *)(4LL * v3 + a1);\n    *(_DWORD *)(a1 + 4LL * v3--) = v4;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void strrev(CHAR_T *s, int len)\n{\n\tint i;\n\n\tif (len != 0) {\n\t\tlen--;\n\t\tif (len != 0 && s[len] == '\\n')\n\t\t\tlen--;\n\t}\n\n\tfor (i = 0; i < len; i++, len--) {\n\t\tCHAR_T c = s[i];\n\t\ts[i] = s[len];\n\t\ts[len] = c;\n\t}\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_50A164(_BYTE *a1, _BYTE *a2, int a3, __int64 a4)\n{\n  _BYTE *v4; // rax\n  _BYTE *result; // rax\n  unsigned int v8; // [rsp+20h] [rbp-10h]\n  unsigned int v9; // [rsp+24h] [rbp-Ch]\n\n  while ( a3 > 0 )\n  {\n    v8 = 0;\n    v9 = 0;\n    a3 -= 3;\n    if ( a3 >= -1 )\n    {\n      v9 = (unsigned __int8)a2[1];\n      if ( a3 >= 0 )\n        v8 = (unsigned __int8)a2[2];\n    }\n    *a1 = *(_BYTE *)((*a2 >> 2) + a4);\n    a1[1] = *(_BYTE *)(((16 * *a2) & 0x30) + (v9 >> 4) + a4);\n    a1[2] = *(_BYTE *)(((4 * (_BYTE)v9) & 0x3C) + (v8 >> 6) + a4);\n    v4 = a1 + 3;\n    a1 += 4;\n    *v4 = *(_BYTE *)((v8 & 0x3F) + a4);\n    a2 += 3;\n  }\n  result = a1;\n  *a1 = 0;\n  while ( a3 )\n  {\n    result = --a1;\n    *a1 = *(_BYTE *)(a4 + 64);\n    ++a3;\n  }\n  return result;\n}\n\n\n Revised code:\nvoid FAST_FUNC bb_uuencode(char *p, const void *src, int length, const char *tbl)\n{\n\tconst unsigned char *s = src;\n\n\t/* Transform the 3x8 bits to 4x6 bits */\n\twhile (length > 0) {\n\t\tunsigned s1, s2;\n\n\t\t/* Are s[1], s[2] valid or should be assumed 0? */\n\t\ts1 = s2 = 0;\n\t\tlength -= 3; /* can be >=0, -1, -2 */\n\t\tif (length >= -1) {\n\t\t\ts1 = s[1];\n\t\t\tif (length >= 0)\n\t\t\t\ts2 = s[2];\n\t\t}\n\t\t*p++ = tbl[s[0] >> 2];\n\t\t*p++ = tbl[((s[0] & 3) << 4) + (s1 >> 4)];\n\t\t*p++ = tbl[((s1 & 0xf) << 2) + (s2 >> 6)];\n\t\t*p++ = tbl[s2 & 0x3f];\n\t\ts += 3;\n\t}\n\t/* Zero-terminate */\n\t*p = '\\0';\n\t/* If length is -2 or -1, pad last char or two */\n\twhile (length) {\n\t\t*--p = tbl[64];\n\t\tlength++;\n\t}\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_481AB7(__int64 a1)\n{\n  _BYTE *v2; // rax\n  _BYTE *v4; // [rsp+0h] [rbp-18h]\n  int v5; // [rsp+14h] [rbp-4h]\n\n  v5 = 0;\n  v4 = (_BYTE *)(a1 + 1);\n  while ( *v4 )\n  {\n    if ( *v4 == 92 )\n    {\n      if ( !*++v4 )\n        break;\n      ++v4;\n    }\n    else\n    {\n      if ( *v4 == 125 && !v5-- )\n        break;\n      if ( *v4 == 44 && !v5 )\n        break;\n      v2 = v4++;\n      if ( *v2 == 123 )\n        ++v5;\n    }\n  }\n  if ( *v4 )\n    return v4;\n  else\n    return 0LL;\n}\n\n\n Revised code:\nstatic const char *next_brace_sub(const char *cp)\n{\n\tunsigned depth = 0;\n\tcp++;\n\twhile (*cp != '\\0') {\n\t\tif (*cp == '\\\\') {\n\t\t\tif (*++cp == '\\0')\n\t\t\t\tbreak;\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((*cp == '}' && depth-- == 0) || (*cp == ',' && depth == 0))\n\t\t\tbreak;\n\t\tif (*cp++ == '{')\n\t\t\tdepth++;\n\t}\n\n\treturn *cp != '\\0' ? cp : NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_4285AE(__int64 a1)\n{\n  _BYTE *result; // rax\n  char v2; // [rsp+10h] [rbp-8h]\n  int v3; // [rsp+14h] [rbp-4h]\n  int i; // [rsp+14h] [rbp-4h]\n\n  v3 = 0;\n  v2 = 0;\n  while ( 1 )\n  {\n    result = (_BYTE *)*(unsigned __int8 *)(v3 + a1);\n    if ( !(_BYTE)result )\n      break;\n    ++v3;\n  }\n  for ( i = v3 - 1; i >= 0; --i )\n  {\n    result = (_BYTE *)*(unsigned __int8 *)(i + a1);\n    if ( (_BYTE)result == 46 )\n    {\n      result = (_BYTE *)(i + a1);\n      *result = v2;\n      v2 = 0;\n    }\n    else\n    {\n      ++v2;\n    }\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "uart_type",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_421FB0(const char *a1)\n{\n  return sub_421F51(\"unknown\", a1);\n}\n\n\n Revised code:\nstatic int uart_id(const char *name)\n{\n\treturn index_in_strings_case_insensitive(serial_types, name);\n}\n\n## Example:\n\n Input code:\nconst char *__fastcall sub_43094C(int a1)\n{\n  if ( a1 == -1 )\n    return \"error\";\n  else\n    return (const char *)(5 * a1 + 5342710LL);\n}\n\n\n Revised code:\nstatic const char *strstatus(int status)\n{\n\tif (status == IFSTATUS_ERR)\n\t\treturn \"error\";\n\treturn \"down\\0up\" + (status * 5);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_49574A(unsigned int a1)\n{\n  return printf(\"%c: unknown command\\n\", a1);\n}\n\n\n Revised code:\nif ENABLE_FEATURE_FDISK_WRITABLE\nstatic void\nunknown_command(int c)\n{\n\tprintf(\"%c: unknown command\\n\", c);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_421F28(int a1)\n{\n  if ( a1 <= 19 )\n    return (const char *)sub_4F676B(\"unknown\", (unsigned int)a1);\n  else\n    return \"undefined\";\n}\n"
    },
    {
        "func_name": "finalize_tty_attrs",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E5BFF(__int64 a1, __int64 a2)\n{\n  _QWORD *v2; // rbx\n  _QWORD *v3; // rbx\n\n  qword_75D408 = sub_40A0E8(0xB8uLL, a2);\n  *((_DWORD *)qword_75D408 + 3) = 1024;\n  v2 = qword_75D408;\n  v2[3] = sub_40A05F(*((int *)qword_75D408 + 3), a2);\n  *((_QWORD *)qword_75D408 + 4) = *((_QWORD *)qword_75D408 + 3);\n  *((_QWORD *)qword_75D408 + 6) = (char *)qword_75D408 + 48;\n  *((_QWORD *)qword_75D408 + 7) = (char *)qword_75D408 + 48;\n  if ( *(_QWORD *)(a2 + 8) )\n  {\n    v3 = qword_75D408;\n    v3[5] = sub_40A11F(*(const char **)(a2 + 8), a2);\n    if ( !(unsigned int)sub_4E6EF4(*((_QWORD *)qword_75D408 + 5), 1LL) )\n      return 0LL;\n    if ( *((_DWORD *)qword_75D408 + 1) )\n      sub_4E7A44(1LL);\n    *((_BYTE *)qword_75D408 + 72) = 0;\n  }\n  sub_4E5D15();\n  return 0LL;\n}\n\n\n Revised code:\nint ed_main(int argc UNUSED_PARAM, char **argv)\n{\n\tINIT_G();\n\n\tbufSize = INITBUF_SIZE;\n\tbufBase = xmalloc(bufSize);\n\tbufPtr = bufBase;\n\tlines.next = &lines;\n\tlines.prev = &lines;\n\n\tif (argv[1]) {\n\t\tfileName = xstrdup(argv[1]);\n\t\tif (!readLines(fileName, 1)) {\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\t\tif (lastNum)\n\t\t\tsetCurNum(1);\n\t\tdirty = FALSE;\n\t}\n\n\tdoCommands();\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B08F1(char *a1, unsigned int a2, int a3)\n{\n  unsigned int v5; // [rsp+14h] [rbp-Ch]\n  int v6; // [rsp+18h] [rbp-8h]\n  unsigned int v7; // [rsp+1Ch] [rbp-4h]\n\n  *((_BYTE *)qword_75D408 + *((unsigned int *)qword_75D408 + 1971) + 6852) = *((_BYTE *)qword_75D408 + 7888);\n  sub_4AF92B((__int64)qword_75D408 + 5120);\n  sub_4AF92B((__int64)qword_75D408 + 5160);\n  v6 = sub_4B01A5();\n  v7 = (unsigned int)(*((_DWORD *)qword_75D408 + 1973) + 10) >> 3;\n  v5 = (unsigned int)(*((_DWORD *)qword_75D408 + 1974) + 10) >> 3;\n  if ( v5 <= v7 )\n    v7 = (unsigned int)(*((_DWORD *)qword_75D408 + 1974) + 10) >> 3;\n  if ( v7 >= a2 + 4 && a1 )\n  {\n    sub_4AE836(a3, 3);\n    *((_DWORD *)qword_75D408 + 1975) = (*((_DWORD *)qword_75D408 + 1975) + 10) & 0xFFFFFFF8;\n    *((_DWORD *)qword_75D408 + 1975) += 8 * (a2 + 4);\n    sub_4AEA5F(a1, a2, 1);\n  }\n  else if ( v5 == v7 )\n  {\n    sub_4AE836(a3 + 2, 3);\n    sub_4B0650((__int64)qword_75D408 + 3692, (__int64)qword_75D408 + 4844);\n    *((_DWORD *)qword_75D408 + 1975) += *((_DWORD *)qword_75D408 + 1974) + 3;\n  }\n  else\n  {\n    sub_4AE836(a3 + 4, 3);\n    sub_4B027E(*((_DWORD *)qword_75D408 + 1289) + 1, *((_DWORD *)qword_75D408 + 1299) + 1, v6 + 1);\n    sub_4B0650((__int64)qword_75D408 + 1156, (__int64)qword_75D408 + 3448);\n    *((_DWORD *)qword_75D408 + 1975) += *((_DWORD *)qword_75D408 + 1973) + 3;\n  }\n  sub_4AF093();\n  if ( a3 )\n  {\n    sub_4AE9A0();\n    *((_DWORD *)qword_75D408 + 1975) += 7;\n  }\n  return *((_DWORD *)qword_75D408 + 1975) >> 3;\n}\n\n\n Revised code:\nstatic ulg flush_block(char *buf, ulg stored_len, int eof)\n{\n\tulg opt_lenb, static_lenb;      /* opt_len and static_len in bytes */\n\tint max_blindex;                /* index of last bit length code of non zero freq */\n\n\tG2.flag_buf[G2.last_flags] = G2.flags;   /* Save the flags for the last 8 items */\n\n\t/* Construct the literal and distance trees */\n\tbuild_tree(&G2.l_desc);\n\tTracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", G2.opt_len, G2.static_len));\n\n\tbuild_tree(&G2.d_desc);\n\tTracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", G2.opt_len, G2.static_len));\n\t/* At this point, opt_len and static_len are the total bit lengths of\n\t * the compressed block data, excluding the tree representations.\n\t */\n\n\t/* Build the bit length tree for the above two trees, and get the index\n\t * in bl_order of the last bit length code to send.\n\t */\n\tmax_blindex = build_bl_tree();\n\n\t/* Determine the best encoding. Compute first the block length in bytes */\n\topt_lenb = (G2.opt_len + 3 + 7) >> 3;\n\tstatic_lenb = (G2.static_len + 3 + 7) >> 3;\n\n\tTrace((stderr,\n\t\t\t\"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u \",\n\t\t\topt_lenb, G2.opt_len, static_lenb, G2.static_len, stored_len,\n\t\t\tG2.last_lit, G2.last_dist));\n\n\tif (static_lenb <= opt_lenb)\n\t\topt_lenb = static_lenb;\n\n\t/* If compression failed and this is the first and last block,\n\t * and if the zip file can be seeked (to rewrite the local header),\n\t * the whole file is transformed into a stored file:\n\t */\n\tif (stored_len <= opt_lenb && eof && G2.compressed_len == 0L && seekable()) {\n\t\t/* Since LIT_BUFSIZE <= 2*WSIZE, the input data must be there: */\n\t\tif (buf == NULL)\n\t\t\tbb_error_msg(\"block vanished\");\n\n\t\tcopy_block(buf, (unsigned) stored_len, 0);\t/* without header */\n\t\tG2.compressed_len = stored_len << 3;\n\n\t} else if (stored_len + 4 <= opt_lenb && buf != NULL) {\n\t\t/* 4: two words for the lengths */\n\t\t/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n\t\t * Otherwise we can't have processed more than WSIZE input bytes since\n\t\t * the last block flush, because compression would have been\n\t\t * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n\t\t * transform a block into a stored block.\n\t\t */\n\t\tsend_bits((STORED_BLOCK << 1) + eof, 3);\t/* send block type */\n\t\tG2.compressed_len = (G2.compressed_len + 3 + 7) & ~7L;\n\t\tG2.compressed_len += (stored_len + 4) << 3;\n\n\t\tcopy_block(buf, (unsigned) stored_len, 1);\t/* with header */\n\n\t} else if (static_lenb == opt_lenb) {\n\t\tsend_bits((STATIC_TREES << 1) + eof, 3);\n\t\tcompress_block((ct_data *) G2.static_ltree, (ct_data *) G2.static_dtree);\n\t\tG2.compressed_len += 3 + G2.static_len;\n\t} else {\n\t\tsend_bits((DYN_TREES << 1) + eof, 3);\n\t\tsend_all_trees(G2.l_desc.max_code + 1, G2.d_desc.max_code + 1,\n\t\t\t\t\tmax_blindex + 1);\n\t\tcompress_block((ct_data *) G2.dyn_ltree, (ct_data *) G2.dyn_dtree);\n\t\tG2.compressed_len += 3 + G2.opt_len;\n\t}\n\tAssert(G2.compressed_len == G1.bits_sent, \"bad compressed size\");\n\tinit_block();\n\n\tif (eof) {\n\t\tbi_windup();\n\t\tG2.compressed_len += 7;\t/* align on byte boundary */\n\t}\n\tTracev((stderr, \"\\ncomprlen %lu(%lu) \", G2.compressed_len >> 3,\n\t\t\tG2.compressed_len - 7 * eof));\n\n\treturn G2.compressed_len >> 3;\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_4B16C5(int a1)\n{\n  char v1; // di\n  __int64 v2; // rsi\n  unsigned int v3; // edx\n  __int64 v4; // rsi\n  unsigned int v5; // edx\n  __int16 v7; // [rsp+1Eh] [rbp-2h] BYREF\n\n  v7 = 0;\n  *((_DWORD *)qword_75D408 - 5) = 0;\n  sub_4AE754(559903);\n  sub_4AE754(a1);\n  *((_DWORD *)qword_75D408 - 2) = -1;\n  sub_4B11D5();\n  sub_4B138E();\n  sub_4B11FF(&v7);\n  v1 = v7;\n  v2 = *((_QWORD *)qword_75D408 - 6);\n  v3 = *((_DWORD *)qword_75D408 - 5);\n  *((_DWORD *)qword_75D408 - 5) = v3 + 1;\n  *(_BYTE *)(v2 + v3) = v1;\n  if ( *((_DWORD *)qword_75D408 - 5) == 0x2000 )\n    sub_4AE5D4();\n  v4 = *((_QWORD *)qword_75D408 - 6);\n  v5 = *((_DWORD *)qword_75D408 - 5);\n  *((_DWORD *)qword_75D408 - 5) = v5 + 1;\n  *(_BYTE *)(v4 + v5) = 3;\n  if ( *((_DWORD *)qword_75D408 - 5) == 0x2000 )\n    sub_4AE5D4();\n  sub_4B0B62();\n  sub_4AE754(~*((_DWORD *)qword_75D408 - 2));\n  sub_4AE754(*((_DWORD *)qword_75D408 - 6));\n  return sub_4AE5D4();\n}\n\n\n Revised code:\nstatic void zip(ulg time_stamp)\n{\n\tush deflate_flags = 0;  /* pkzip -es, -en or -ex equivalent */\n\n\tG1.outcnt = 0;\n\n\t/* Write the header to the gzip file. See algorithm.doc for the format */\n\t/* magic header for gzip files: 1F 8B */\n\t/* compression method: 8 (DEFLATED) */\n\t/* general flags: 0 */\n\tput_32bit(0x00088b1f);\n\tput_32bit(time_stamp);\n\n\t/* Write deflated file to zip file */\n\tG1.crc = ~0;\n\n\tbi_init();\n\tct_init();\n\tlm_init(&deflate_flags);\n\n\tput_8bit(deflate_flags);\t/* extra flags */\n\tput_8bit(3);\t/* OS identifier = 3 (Unix) */\n\n\tdeflate();\n\n\t/* Write the crc and uncompressed size */\n\tput_32bit(~G1.crc);\n\tput_32bit(G1.isize);\n\n\tflush_outbuf();\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40E5E6(__int64 a1, __int64 a2)\n{\n  int v2; // edx\n  int v3; // edx\n\n  v2 = *((_DWORD *)qword_75D408 + 24);\n  BYTE1(v2) |= 0x14u;\n  *((_DWORD *)qword_75D408 + 24) = v2;\n  if ( *((_BYTE *)qword_75D408 + 92) == 13 )\n  {\n    v3 = *((_DWORD *)qword_75D408 + 24);\n    BYTE1(v3) |= 1u;\n    *((_DWORD *)qword_75D408 + 24) = v3;\n  }\n  *((_DWORD *)qword_75D408 + 27) |= 0x83Bu;\n  *((_BYTE *)qword_75D408 + 113) = 3;\n  *((_BYTE *)qword_75D408 + 114) = 28;\n  *((_BYTE *)qword_75D408 + 117) = 4;\n  *((_BYTE *)qword_75D408 + 124) = 10;\n  *((_BYTE *)qword_75D408 + 120) = 0;\n  *((_BYTE *)qword_75D408 + 116) = 21;\n  sub_40E482(a1, a2);\n  return sub_40B38A(1u, (__int64)\"\\n\", 1LL);\n}\n"
    },
    {
        "func_name": "process_command_subs",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B54AE(_QWORD *a1)\n{\n  __int64 v1; // rax\n  _QWORD *v3; // [rsp+8h] [rbp-28h] BYREF\n  __int64 v4; // [rsp+10h] [rbp-20h] BYREF\n  char *v5; // [rsp+18h] [rbp-18h]\n  char *v6; // [rsp+20h] [rbp-10h]\n  FILE *stream; // [rsp+28h] [rbp-8h]\n\n  v3 = a1;\n  v4 = 0LL;\n  while ( v3 )\n  {\n    v1 = sub_409067(&v3);\n    stream = (FILE *)sub_50A7F5(v1);\n    while ( 1 )\n    {\n      v6 = (char *)sub_4F9FF1(stream);\n      if ( !v6 )\n        break;\n      v5 = sub_408F79(v6, 47);\n      if ( v5 > v6 )\n        *v5 = 0;\n      sub_408FD2(&v4, (__int64)v6);\n    }\n    fclose(stream);\n  }\n  return v4;\n}\n\n\n Revised code:\nif ENABLE_FEATURE_TAR_FROM\nstatic llist_t *append_file_list_to_list(llist_t *list)\n{\n\tFILE *src_stream;\n\tchar *line;\n\tllist_t *newlist = NULL;\n\n\twhile (list) {\n\t\tsrc_stream = xfopen_stdin(llist_pop(&list));\n\t\twhile ((line = xmalloc_fgetline(src_stream)) != NULL) {\n\t\t\t/* kill trailing '/' unless the string is just \"/\" */\n\t\t\tchar *cp = last_char_is(line, '/');\n\t\t\tif (cp > line)\n\t\t\t\t*cp = '\\0';\n\t\t\tllist_add_to(&newlist, line);\n\t\t}\n\t\tfclose(src_stream);\n\t}\n\treturn newlist;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48A2BD(__int64 a1)\n{\n  int v2; // eax\n  char **v3; // [rsp+8h] [rbp-48h]\n  char v4[39]; // [rsp+10h] [rbp-40h] BYREF\n  char v5; // [rsp+37h] [rbp-19h]\n  FILE *stream; // [rsp+38h] [rbp-18h]\n  char *s; // [rsp+40h] [rbp-10h]\n  void *ptr; // [rsp+48h] [rbp-8h]\n\n  v3 = (char **)sub_48914D(a1);\n  s = *v3;\n  if ( !s )\n    return 2LL;\n  ptr = 0LL;\n  if ( !strchr(s, 47) )\n  {\n    ptr = sub_486617(s);\n    if ( ptr )\n      s = (char *)ptr;\n  }\n  stream = sub_4097EE(s, \"r\");\n  free(ptr);\n  if ( !stream )\n    return 1LL;\n  v2 = fileno(stream);\n  sub_409A2B(v2);\n  v5 = *((_BYTE *)qword_75D408 + 77);\n  *((_BYTE *)qword_75D408 + 77) = -1;\n  sub_480183((__int64)v4, v3);\n  sub_48600B((__int64)stream);\n  fclose(stream);\n  sub_480232((__int64)v4, v3);\n  *((_BYTE *)qword_75D408 + 77) = v5;\n  return *((unsigned __int8 *)qword_75D408 + 79);\n}\n\n\n Revised code:\nstatic int FAST_FUNC builtin_source(char **argv)\n{\n\tchar *arg_path, *filename;\n\tFILE *input;\n\tsave_arg_t sv;\n#if ENABLE_HUSH_FUNCTIONS\n\tsmallint sv_flg;\n#endif\n\n\targv = skip_dash_dash(argv);\n\tfilename = argv[0];\n\tif (!filename) {\n\t\t/* bash says: \"bash: .: filename argument required\" */\n\t\treturn 2; /* bash compat */\n\t}\n\targ_path = NULL;\n\tif (!strchr(filename, '/')) {\n\t\targ_path = find_in_path(filename);\n\t\tif (arg_path)\n\t\t\tfilename = arg_path;\n\t}\n\tinput = fopen_or_warn(filename, \"r\");\n\tfree(arg_path);\n\tif (!input) {\n\t\t/* bb_perror_msg(\"%s\", *argv); - done by fopen_or_warn */\n\t\treturn EXIT_FAILURE;\n\t}\n\tclose_on_exec_on(fileno(input));\n\n#if ENABLE_HUSH_FUNCTIONS\n\tsv_flg = G.flag_return_in_progress;\n\t/* \"we are inside sourced file, ok to use return\" */\n\tG.flag_return_in_progress = -1;\n#endif\n\tsave_and_replace_G_args(&sv, argv);\n\n\tparse_and_run_file(input);\n\tfclose(input);\n\n\trestore_G_args(&sv, argv);\n#if ENABLE_HUSH_FUNCTIONS\n\tG.flag_return_in_progress = sv_flg;\n#endif\n\n\treturn G.last_exitcode;\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_43328F(const char *a1, __int64 a2)\n{\n  size_t v2; // rax\n  char *v3; // rax\n  int v6; // [rsp+1Ch] [rbp-44h] BYREF\n  FILE *v7; // [rsp+20h] [rbp-40h] BYREF\n  FILE *stream; // [rsp+28h] [rbp-38h] BYREF\n  unsigned __int8 v9; // [rsp+37h] [rbp-29h]\n  char *s; // [rsp+38h] [rbp-28h]\n  __pid_t v11; // [rsp+44h] [rbp-1Ch]\n  char *v12; // [rsp+48h] [rbp-18h]\n  void *ptr; // [rsp+50h] [rbp-10h]\n  int i; // [rsp+5Ch] [rbp-4h]\n\n  ptr = sub_40A11F(a1, a2);\n  v11 = sub_43319A(&stream, &v7, *(_QWORD *)(a2 + 24), (__int64)a1);\n  for ( i = 0; i < *(_DWORD *)(a2 + 32); ++i )\n    fprintf(stream, \"%s\\n\", *(const char **)(8LL * i + *(_QWORD *)(a2 + 40)));\n  fclose(stream);\n  sub_409F48(v11, &v6, 0);\n  if ( (v6 & 0x7F) == 0 && !BYTE1(v6) )\n  {\n    s = (char *)sub_4F9FF1(v7);\n    if ( s )\n    {\n      v2 = strlen(s);\n      v12 = &s[v2 - 1];\n      while ( v12 >= s )\n      {\n        v9 = *v12 - 9;\n        if ( v9 != 23 && v9 > 4u )\n          break;\n        v3 = v12--;\n        *v3 = 0;\n      }\n      free(ptr);\n      ptr = s;\n    }\n  }\n  fclose(v7);\n  return ptr;\n}\n\n\n Revised code:\nstatic char *run_mapping(char *physical, struct mapping_defn_t *map)\n{\n\tFILE *in, *out;\n\tint i, status;\n\tpid_t pid;\n\n\tchar *logical = xstrdup(physical);\n\n\t/* Run the mapping script. Never fails. */\n\tpid = popen2(&in, &out, map->script, physical);\n\n\t/* Write mappings to stdin of mapping script. */\n\tfor (i = 0; i < map->n_mappings; i++) {\n\t\tfprintf(in, \"%s\\n\", map->mapping[i]);\n\t}\n\tfclose(in);\n\tsafe_waitpid(pid, &status, 0);\n\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t/* If the mapping script exited successfully, try to\n\t\t * grab a line of output and use that as the name of the\n\t\t * logical interface. */\n\t\tchar *new_logical = xmalloc_fgetline(out);\n\n\t\tif (new_logical) {\n\t\t\t/* If we are able to read a line of output from the script,\n\t\t\t * remove any trailing whitespace and use this value\n\t\t\t * as the name of the logical interface. */\n\t\t\tchar *pch = new_logical + strlen(new_logical) - 1;\n\n\t\t\twhile (pch >= new_logical && isspace(*pch))\n\t\t\t\t*(pch--) = '\\0';\n\n\t\t\tfree(logical);\n\t\t\tlogical = new_logical;\n\t\t}\n\t}\n\n\tfclose(out);\n\n\treturn logical;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_486168(__int64 a1, _BYTE *a2)\n{\n  int v3; // [rsp+18h] [rbp-48h] BYREF\n  __pid_t v4; // [rsp+1Ch] [rbp-44h] BYREF\n  _QWORD v5[5]; // [rsp+20h] [rbp-40h] BYREF\n  int v6; // [rsp+4Ch] [rbp-14h]\n  FILE *stream; // [rsp+50h] [rbp-10h]\n  int v8; // [rsp+5Ch] [rbp-4h]\n\n  stream = sub_48603E(a2, &v4);\n  sub_4812CC(v5, (__int64)stream);\n  v8 = 0;\n  while ( 1 )\n  {\n    v6 = ((__int64 (__fastcall *)(_QWORD *))v5[3])(v5);\n    if ( v6 == -1 )\n      break;\n    if ( v6 == 10 )\n    {\n      ++v8;\n    }\n    else\n    {\n      while ( v8 )\n      {\n        sub_481463(a1, 10);\n        --v8;\n      }\n      sub_48165D(a1, v6);\n    }\n  }\n  fclose(stream);\n  sub_409F48(v4, &v3, 0);\n  return BYTE1(v3);\n}\n"
    },
    {
        "func_name": "display_files",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4AFD56(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+10h] [rbp-1Ch]\n  int v4; // [rsp+14h] [rbp-18h]\n  int v5; // [rsp+18h] [rbp-14h]\n  int v6; // [rsp+1Ch] [rbp-10h]\n  int v7; // [rsp+20h] [rbp-Ch]\n  int v8; // [rsp+24h] [rbp-8h]\n  unsigned int i; // [rsp+28h] [rbp-4h]\n\n  v8 = -1;\n  v7 = *(unsigned __int16 *)(a1 + 2);\n  v6 = 0;\n  v5 = 7;\n  v4 = 4;\n  if ( !*(_WORD *)(a1 + 2) )\n  {\n    v5 = 138;\n    v4 = 3;\n  }\n  *(_WORD *)(4 * (a2 + 1LL) + a1 + 2) = -1;\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i > a2 )\n      break;\n    v3 = v7;\n    v7 = *(unsigned __int16 *)(4 * ((int)i + 1LL) + a1 + 2);\n    if ( ++v6 >= v5 || v3 != v7 )\n    {\n      if ( v6 >= v4 )\n      {\n        if ( v3 )\n        {\n          if ( v3 != v8 )\n            ++*((_WORD *)qword_75D408 + 2 * v3 + 2482);\n          ++*((_WORD *)qword_75D408 + 2514);\n        }\n        else if ( v6 > 10 )\n        {\n          ++*((_WORD *)qword_75D408 + 2518);\n        }\n        else\n        {\n          ++*((_WORD *)qword_75D408 + 2516);\n        }\n      }\n      else\n      {\n        *((_WORD *)qword_75D408 + 2 * v3 + 2482) += v6;\n      }\n      v6 = 0;\n      v8 = v3;\n      v5 = 7;\n      v4 = 4;\n      if ( v7 )\n      {\n        if ( v3 == v7 )\n        {\n          v5 = 6;\n          v4 = 3;\n        }\n      }\n      else\n      {\n        v5 = 138;\n        v4 = 3;\n      }\n    }\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void scan_tree(ct_data * tree, int max_code)\n{\n\tint n;\t\t\t\t/* iterates over all tree elements */\n\tint prevlen = -1;\t/* last emitted length */\n\tint curlen;\t\t\t/* length of current code */\n\tint nextlen = tree[0].Len;\t/* length of next code */\n\tint count = 0;\t\t/* repeat count of the current code */\n\tint max_count = 7;\t/* max repeat count */\n\tint min_count = 4;\t/* min repeat count */\n\n\tif (nextlen == 0) {\n\t\tmax_count = 138;\n\t\tmin_count = 3;\n\t}\n\ttree[max_code + 1].Len = 0xffff; /* guard */\n\n\tfor (n = 0; n <= max_code; n++) {\n\t\tcurlen = nextlen;\n\t\tnextlen = tree[n + 1].Len;\n\t\tif (++count < max_count && curlen == nextlen)\n\t\t\tcontinue;\n\n\t\tif (count < min_count) {\n\t\t\tG2.bl_tree[curlen].Freq += count;\n\t\t} else if (curlen != 0) {\n\t\t\tif (curlen != prevlen)\n\t\t\t\tG2.bl_tree[curlen].Freq++;\n\t\t\tG2.bl_tree[REP_3_6].Freq++;\n\t\t} else if (count <= 10) {\n\t\t\tG2.bl_tree[REPZ_3_10].Freq++;\n\t\t} else {\n\t\t\tG2.bl_tree[REPZ_11_138].Freq++;\n\t\t}\n\t\tcount = 0;\n\t\tprevlen = curlen;\n\n\t\tmax_count = 7;\n\t\tmin_count = 4;\n\t\tif (nextlen == 0) {\n\t\t\tmax_count = 138;\n\t\t\tmin_count = 3;\n\t\t} else if (curlen == nextlen) {\n\t\t\tmax_count = 6;\n\t\t\tmin_count = 3;\n\t\t}\n\t}\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_4F73F6(int *a1, __int64 a2)\n{\n  int v2; // eax\n  int v3; // eax\n  int v4; // eax\n  int v5; // eax\n  int *v6; // rax\n  int *v8; // [rsp+8h] [rbp-18h]\n  int v9; // [rsp+10h] [rbp-10h]\n  int j; // [rsp+14h] [rbp-Ch]\n  int i; // [rsp+18h] [rbp-8h]\n  int v12; // [rsp+1Ch] [rbp-4h]\n\n  v8 = a1;\n  if ( (_DWORD)a2 )\n    v2 = 79764919;\n  else\n    v2 = -306674912;\n  v9 = v2;\n  if ( !a1 )\n    v8 = (int *)sub_40A05F(0x400uLL, a2);\n  for ( i = 0; i <= 255; ++i )\n  {\n    if ( (_DWORD)a2 )\n      v3 = i << 24;\n    else\n      v3 = i;\n    v12 = v3;\n    for ( j = 8; j; --j )\n    {\n      if ( (_DWORD)a2 )\n      {\n        if ( v12 >= 0 )\n          v4 = 2 * v12;\n        else\n          v4 = v9 ^ (2 * v12);\n        v12 = v4;\n      }\n      else\n      {\n        if ( (v12 & 1) != 0 )\n          v5 = v9 ^ ((unsigned int)v12 >> 1);\n        else\n          v5 = (unsigned int)v12 >> 1;\n        v12 = v5;\n      }\n    }\n    v6 = v8++;\n    *v6 = v12;\n  }\n  return (char *)(v8 - 256);\n}\n\n\n Revised code:\nFAST_FUNC crc32_filltable(uint32_t *crc_table, int endian)\n{\n\tuint32_t polynomial = endian ? 0x04c11db7 : 0xedb88320;\n\tuint32_t c;\n\tint i, j;\n\n\tif (!crc_table)\n\t\tcrc_table = xmalloc(256 * sizeof(uint32_t));\n\n\tfor (i = 0; i < 256; i++) {\n\t\tc = endian ? (i << 24) : i;\n\t\tfor (j = 8; j; j--) {\n\t\t\tif (endian)\n\t\t\t\tc = (c&0x80000000) ? ((c << 1) ^ polynomial) : (c << 1);\n\t\t\telse\n\t\t\t\tc = (c&1) ? ((c >> 1) ^ polynomial) : (c >> 1);\n\t\t}\n\t\t*crc_table++ = c;\n\t}\n\n\treturn crc_table - 256;\n}\n\n## Example:\n\n Input code:\nvoid __fastcall __noreturn sub_4C61C0(__int64 a1, __int64 a2)\n{\n  int v2; // edx\n  int v3; // ecx\n  int v4; // r8d\n  int v5; // r9d\n  const char *v6; // rax\n  const char **v7; // [rsp+0h] [rbp-40h]\n  __int64 v8; // [rsp+10h] [rbp-30h]\n  int v9; // [rsp+18h] [rbp-28h]\n  int fd; // [rsp+1Ch] [rbp-24h]\n  __int64 v11; // [rsp+20h] [rbp-20h]\n  unsigned int v12; // [rsp+2Ch] [rbp-14h]\n  unsigned __int64 v13; // [rsp+30h] [rbp-10h]\n  unsigned int v14; // [rsp+3Ch] [rbp-4h]\n  unsigned int v15; // [rsp+3Ch] [rbp-4h]\n\n  v11 = sub_4F73F6(0LL, 1LL);\n  v12 = 0;\n  sub_4FA1EF(a2, (unsigned int)&unk_536AD1, v2, v3, v4, v5);\n  v7 = (const char **)(8LL * optind + a2);\n  while ( 1 )\n  {\n    if ( *v7 )\n      v6 = *v7;\n    else\n      v6 = \"standard input\";\n    fd = sub_50A825(v6);\n    if ( fd >= 0 )\n    {\n      v14 = 0;\n      v13 = 0LL;\n      while ( 1 )\n      {\n        v9 = sub_40B3FF(fd, &dest, 0x2001uLL);\n        if ( v9 <= 0 )\n          break;\n        v13 += v9;\n        v14 = sub_4F74CA(v14, &dest, (unsigned int)v9, v11);\n      }\n      close(fd);\n      v8 = v13;\n      while ( v13 )\n      {\n        v14 = (v14 << 8) ^ *(_DWORD *)(4LL * (unsigned __int8)(HIBYTE(v14) ^ v13) + v11);\n        v13 >>= 8;\n      }\n      v15 = ~v14;\n      if ( *v7 )\n        printf(\"%u %li %s\\n\", v15, v8, *v7);\n      else\n        printf(\"%u %li\\n\", v15, v8);\n    }\n    else\n    {\n      v12 = 1;\n    }\n    if ( *v7 )\n    {\n      if ( *++v7 )\n        continue;\n    }\n    sub_4F93C9(v12);\n  }\n}\n\n\n Revised code:\nint cksum_main(int argc UNUSED_PARAM, char **argv)\n{\n\tuint32_t *crc32_table = crc32_filltable(NULL, 1);\n\tuint32_t crc;\n\toff_t length, filesize;\n\tint bytes_read;\n\tint exit_code = EXIT_SUCCESS;\n\n#if ENABLE_DESKTOP\n\tgetopt32(argv, \"\"); /* coreutils 6.9 compat */\n\targv += optind;\n#else\n\targv++;\n#endif\n\n\tdo {\n\t\tint fd = open_or_warn_stdin(*argv ? *argv : bb_msg_standard_input);\n\n\t\tif (fd < 0) {\n\t\t\texit_code = EXIT_FAILURE;\n\t\t\tcontinue;\n\t\t}\n\t\tcrc = 0;\n\t\tlength = 0;\n\n#define read_buf bb_common_bufsiz1\n\t\twhile ((bytes_read = safe_read(fd, read_buf, sizeof(read_buf))) > 0) {\n\t\t\tlength += bytes_read;\n\t\t\tcrc = crc32_block_endian1(crc, read_buf, bytes_read, crc32_table);\n\t\t}\n\t\tclose(fd);\n\n\t\tfilesize = length;\n\n\t\twhile (length) {\n\t\t\tcrc = (crc << 8) ^ crc32_table[(uint8_t)(crc >> 24) ^ (uint8_t)length];\n\t\t\t/* must ensure that shift is unsigned! */\n\t\t\tif (sizeof(length) <= sizeof(unsigned))\n\t\t\t\tlength = (unsigned)length >> 8;\n\t\t\telse if (sizeof(length) <= sizeof(unsigned long))\n\t\t\t\tlength = (unsigned long)length >> 8;\n\t\t\telse\n\t\t\t\tlength = (unsigned long long)length >> 8;\n\t\t}\n\t\tcrc = ~crc;\n\n\t\tprintf((*argv ? \"%\"PRIu32\" %\"OFF_FMT\"i %s\\n\" : \"%\"PRIu32\" %\"OFF_FMT\"i\\n\"),\n\t\t\t\tcrc, filesize, *argv);\n\t} while (*argv && *++argv);\n\n\tfflush_stdout_and_exit(exit_code);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4CBC66(__int64 a1, unsigned int a2)\n{\n  int v2; // eax\n  __int64 result; // rax\n  unsigned int v4; // [rsp+1Ch] [rbp-24h]\n  unsigned int v5; // [rsp+20h] [rbp-20h]\n  int v6; // [rsp+24h] [rbp-1Ch]\n  int v7; // [rsp+24h] [rbp-1Ch]\n  int v8; // [rsp+28h] [rbp-18h]\n  tcflag_t k; // [rsp+2Ch] [rbp-14h]\n  unsigned int j; // [rsp+30h] [rbp-10h]\n  unsigned int v11; // [rsp+34h] [rbp-Ch]\n  tcflag_t v12; // [rsp+38h] [rbp-8h]\n  unsigned int i; // [rsp+3Ch] [rbp-4h]\n  unsigned int v14; // [rsp+3Ch] [rbp-4h]\n\n  v5 = 0;\n  if ( (dest.c_oflag & 0x100000) != 0 )\n  {\n    v12 = 1;\n  }\n  else\n  {\n    for ( i = 0; *(_QWORD *)(8LL * i + a1); ++i )\n    {\n      v4 = sub_4CB548(**(_QWORD **)(8LL * i + a1));\n      if ( v5 < v4 )\n        v5 = v4;\n    }\n    if ( (dest.c_oflag & 2) != 0 )\n      v2 = 5;\n    else\n      v2 = 0;\n    v5 += ((8 * (unsigned __int8)dest.c_oflag) & 8) + 1 + v2;\n    v12 = dest.c_cflag / v5;\n  }\n  if ( v12 <= 1 )\n  {\n    v11 = a2;\n    v12 = 1;\n  }\n  else\n  {\n    v11 = a2 / v12;\n    if ( a2 > v12 * (a2 / v12) )\n      ++v11;\n  }\n  v8 = 0;\n  v6 = 0;\n  for ( j = 0; ; ++j )\n  {\n    result = j;\n    if ( j >= v11 )\n      break;\n    for ( k = 0; k < v12; ++k )\n    {\n      if ( (dest.c_oflag & 0x40000) != 0 )\n        v14 = v12 * j + k;\n      else\n        v14 = v11 * k + j;\n      if ( v14 < a2 )\n      {\n        if ( v8 )\n        {\n          v7 = v6 - v8;\n          printf(\"%*s \", v7, (const char *)&unk_522D1B);\n          v8 += v7 + 1;\n        }\n        v6 = v8 + v5;\n        v8 += sub_4CB66F(*(_QWORD *)(8LL * v14 + a1));\n      }\n    }\n    putchar_unlocked(10);\n    v8 = 0;\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "write_and_stats",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_4638F6(__int64 a1, __int64 a2)\n{\n  void *result; // rax\n  int v3; // [rsp+8h] [rbp-18h]\n  signed int i; // [rsp+Ch] [rbp-14h]\n\n  v3 = 0;\n  for ( i = 0; i < (signed int)dest.c_cflag; ++i )\n  {\n    *(_DWORD *)&dest.c_line |= *(_DWORD *)(32LL * i + *(_QWORD *)&dest.c_iflag + 24);\n    if ( **(_BYTE **)(32LL * i + *(_QWORD *)&dest.c_iflag + 8) )\n      dest.c_lflag = 1;\n    v3 += *(unsigned __int16 *)(32LL * i + *(_QWORD *)&dest.c_iflag) + 1;\n    if ( v3 - *(_DWORD *)&dest.c_cc[15] > 0 )\n    {\n      dest.c_cflag = i + 1;\n      break;\n    }\n  }\n  result = sub_40A05F(v3 + 1, a2);\n  *(_QWORD *)&dest.c_cc[7] = result;\n  return result;\n}\n\n\n Revised code:\nstatic void alloc_line_buffer(void)\n{\n\tint i;\n\tint width = 0;\n\tfor (i = 0; i < out_cnt; i++) {\n\t\tneed_flags |= out[i].ps_flags;\n\t\tif (out[i].header[0]) {\n\t\t\tprint_header = 1;\n\t\t}\n\t\twidth += out[i].width + 1; /* \"FIELD \" */\n\t\tif ((int)(width - terminal_width) > 0) {\n\t\t\t/* The rest does not fit on the screen */\n\t\t\t//out[i].width -= (width - terminal_width - 1);\n\t\t\tout_cnt = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n#if ENABLE_SELINUX\n\tif (!is_selinux_enabled())\n\t\tneed_flags &= ~PSSCAN_CONTEXT;\n#endif\n\tbuffer = xmalloc(width + 1); /* for trailing \\0 */\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_45B51E(_QWORD *a1)\n{\n  _QWORD *i; // [rsp+10h] [rbp-8h]\n\n  for ( i = *(_QWORD **)&dest.c_cflag; i; i = (_QWORD *)*i )\n  {\n    if ( i[2] == *a1 )\n    {\n      if ( (dword_75D450 & 1) != 0 )\n        return 1LL;\n      if ( i[1] == a1[1] )\n        return 1LL;\n    }\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic smallint search_dev_inode(const struct stat *st)\n{\n\tinode_list *ilist = G.inode_list_head;\n\n\twhile (ilist) {\n\t\tif (ilist->dev == st->st_dev) {\n\t\t\tif (option_mask32 & OPT_MOUNT)\n\t\t\t\treturn 1;\n\t\t\tif (ilist->inode == st->st_ino)\n\t\t\t\treturn 1;\n\t\t}\n\t\tilist = ilist->next;\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\nvoid **__fastcall sub_4C9EFF(const char *a1, void **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rcx\n  __int64 v7; // r8\n  __int64 v8; // r9\n  void **v10; // [rsp+0h] [rbp-10h]\n  void **v11; // [rsp+8h] [rbp-8h]\n\n  v11 = sub_4C9E6C(a1, a2, a3, a4, a5, a6);\n  while ( (unsigned int)sub_4C947A(\"|\") )\n  {\n    *(_QWORD *)&dest.c_iflag += 8LL;\n    v10 = sub_4C9E6C(\"|\", a2, *(__int64 *)&dest.c_iflag, v6, v7, v8);\n    if ( sub_4C934B((__int64)v11) )\n    {\n      sub_4C9315(v11);\n      v11 = v10;\n    }\n    else\n    {\n      sub_4C9315(v10);\n    }\n  }\n  return v11;\n}\n\n\n Revised code:\nstatic VALUE *eval(void)\n{\n\tVALUE *l, *r;\n\n\tl = eval1();\n\twhile (nextarg(\"|\")) {\n\t\tG.args++;\n\t\tr = eval1();\n\t\tif (null(l)) {\n\t\t\tfreev(l);\n\t\t\tl = r;\n\t\t} else\n\t\t\tfreev(r);\n\t}\n\treturn l;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4C760C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v6 = sub_4C75BC(a1, a2, a4);\n  if ( v6 < 0 )\n    return 1LL;\n  if ( v6 == a3 )\n  {\n    ++*(_QWORD *)&dest.c_iflag;\n  }\n  else if ( v6 )\n  {\n    ++*(_QWORD *)&dest.c_cflag;\n  }\n  *(_QWORD *)&dest.c_cc[15] += v6;\n  return 0LL;\n}\n"
    },
    {
        "func_name": "read32",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nuint32_t sub_4B2988()\n{\n  uint32_t netlong; // [rsp+Ch] [rbp-4h] BYREF\n\n  sub_4B28A8((unsigned __int8 *)&netlong, 4);\n  return ntohl(netlong);\n}\n\n\n Revised code:\nstatic uint32_t f_read32(void)\n{\n\tuint32_t v;\n\tf_read(&v, 4);\n\treturn ntohl(v);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B2954(uint16_t a1)\n{\n  uint16_t v2; // [rsp+Ch] [rbp-4h] BYREF\n\n  v2 = htons(a1);\n  return sub_4B2868((unsigned __int8 *)&v2, 2);\n}\n\n\n Revised code:\nstatic void f_write16(uint16_t v)\n{\n\tv = htons(v);\n\tf_write(&v, 2);\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_4B2837(uint32_t a1)\n{\n  uint32_t hostlong; // [rsp+Ch] [rbp-4h] BYREF\n\n  hostlong = htonl(a1);\n  sub_40A4AB(1u, (__int64)&hostlong, 4LL);\n}\n\n\n Revised code:\nstatic void write32(uint32_t v)\n{\n\tv = htonl(v);\n\txwrite(1, &v, 4);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nuint32_t sub_4B280D()\n{\n  uint32_t netlong; // [rsp+Ch] [rbp-4h] BYREF\n\n  sub_507452(0LL, &netlong, 4LL);\n  return ntohl(netlong);\n}\n"
    },
    {
        "func_name": "change_user",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_40A8A7(const char *a1)\n{\n  int result; // eax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n\n  result = chdir(a1);\n  if ( result )\n    sub_4092A2((__int64)\"can't change directory to '%s'\", (__int64)a1, v2, v3, v4, v5);\n  return result;\n}\n\n\n Revised code:\nvoid FAST_FUNC xchdir(const char *path)\n{\n\tif (chdir(path))\n\t\tbb_perror_msg_and_die(\"can't change directory to '%s'\", path);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_489210(__int64 a1)\n{\n  const char *v1; // rax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  char *v7; // [rsp+10h] [rbp-10h]\n  char *path; // [rsp+18h] [rbp-8h]\n\n  path = *(char **)sub_48914D(a1);\n  if ( !path )\n  {\n    v7 = sub_4807EA(\"HOME\");\n    if ( v7 )\n      v1 = v7;\n    else\n      v1 = \"/\";\n    path = (char *)v1;\n  }\n  if ( chdir(path) )\n  {\n    sub_4091D9((__int64)\"cd: %s\", (__int64)path, v2, v3, v4, v5);\n    return 1LL;\n  }\n  else\n  {\n    sub_480BCB(0);\n    return 0LL;\n  }\n}\n\n\n Revised code:\nstatic int FAST_FUNC builtin_cd(char **argv)\n{\n\tconst char *newdir;\n\n\targv = skip_dash_dash(argv);\n\tnewdir = argv[0];\n\tif (newdir == NULL) {\n\t\t/* bash does nothing (exitcode 0) if HOME is \"\"; if it's unset,\n\t\t * bash says \"bash: cd: HOME not set\" and does nothing\n\t\t * (exitcode 1)\n\t\t */\n\t\tconst char *home = get_local_var_value(\"HOME\");\n\t\tnewdir = home ? home : \"/\";\n\t}\n\tif (chdir(newdir)) {\n\t\t/* Mimic bash message exactly */\n\t\tbb_perror_msg(\"cd: %s\", newdir);\n\t\treturn EXIT_FAILURE;\n\t}\n\t/* Read current dir (get_cwd(1) is inside) and set PWD.\n\t * Note: do not enforce exporting. If PWD was unset or unexported,\n\t * set it again, but do not export. bash does the same.\n\t */\n\tset_pwd_var(/*exp:*/ 0);\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_415BB6(__int64 a1, const char *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  int v7; // eax\n  ssize_t v8; // rax\n  char v9; // [rsp+17h] [rbp-9h] BYREF\n  __pid_t v10; // [rsp+18h] [rbp-8h]\n  __pid_t v11; // [rsp+1Ch] [rbp-4h]\n\n  v11 = vfork();\n  if ( v11 < 0 )\n    sub_4092A2((__int64)\"vfork\", (__int64)a2, v2, v3, v4, v5);\n  v10 = v11;\n  if ( !v11 )\n  {\n    sub_4F6569(a1);\n    v7 = sub_40A295(a2, 0);\n    v8 = sub_40B3FF(v7, &v9, 1uLL);\n    _exit(v8 < 0);\n  }\n  if ( (unsigned int)sub_409FAE(v10) )\n    return -1;\n  else\n    return open64(a2, 0);\n}\n\n\n Revised code:\nstatic int open_as_user(const struct passwd *pas, const char *file)\n{\n\tpid_t pid;\n\tchar c;\n\n\tpid = xvfork();\n\tif (pid) { /* PARENT */\n\t\tif (wait4pid(pid) == 0) {\n\t\t\t/* exitcode 0: child says it can read */\n\t\t\treturn open(file, O_RDONLY);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* CHILD */\n\t/* initgroups, setgid, setuid */\n\tchange_identity(pas);\n\t/* We just try to read one byte. If it works, file is readable\n\t * under this user. We signal that by exiting with 0. */\n\t_exit(safe_read(xopen(file, O_RDONLY), &c, 1) < 0);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_414F2F(__int64 a1)\n{\n  int result; // eax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n\n  sub_4F6569(a1);\n  result = chdir(*(const char **)(a1 + 32));\n  if ( result < 0 )\n  {\n    sub_414377(\"Ichdir(%s)\", *(_QWORD *)(a1 + 32), v2, v3, v4, v5);\n    result = chdir(\"/var/spool/cron\");\n    if ( result < 0 )\n      return sub_414377(byte_528D20, (__int64)\"/var/spool/cron\", v6, v7, v8, v9);\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "print_perms",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_486EB5(__int64 a1, __int64 a2)\n{\n  char *v3; // rax\n  int v4; // [rsp+1Ch] [rbp-14h]\n  int v5; // [rsp+1Ch] [rbp-14h]\n  char *dest; // [rsp+20h] [rbp-10h]\n  const char **v7; // [rsp+28h] [rbp-8h]\n  const char **v8; // [rsp+28h] [rbp-8h]\n\n  if ( *(_QWORD *)(a1 + 32) )\n    return *(_QWORD *)(a1 + 32);\n  v7 = *(const char ***)(*(_QWORD *)(a1 + 40) + 32LL);\n  if ( v7 && *v7 )\n  {\n    v4 = 0;\n    do\n      v4 += strlen(*v7++) + 1;\n    while ( *v7 );\n    dest = (char *)sub_40A05F(v4, a2);\n    *(_QWORD *)(a1 + 32) = dest;\n    v8 = *(const char ***)(*(_QWORD *)(a1 + 40) + 32LL);\n    do\n    {\n      v5 = strlen(*v8);\n      memcpy(dest, *v8, v5);\n      v3 = &dest[v5];\n      dest = v3 + 1;\n      *v3 = 32;\n      ++v8;\n    }\n    while ( *v8 );\n    *v3 = 0;\n    return *(_QWORD *)(a1 + 32);\n  }\n  else\n  {\n    *(_QWORD *)(a1 + 32) = sub_40A0E8(1uLL, a2);\n    return *(_QWORD *)(a1 + 32);\n  }\n}\n\n\n Revised code:\nif ENABLE_HUSH_JOB\nstatic const char *get_cmdtext(struct pipe *pi)\n{\n\tchar **argv;\n\tchar *p;\n\tint len;\n\n\t/* This is subtle. ->cmdtext is created only on first backgrounding.\n\t * (Think \"cat, <ctrl-z>, fg, <ctrl-z>, fg, <ctrl-z>....\" here...)\n\t * On subsequent bg argv is trashed, but we won't use it */\n\tif (pi->cmdtext)\n\t\treturn pi->cmdtext;\n\targv = pi->cmds[0].argv;\n\tif (!argv || !argv[0]) {\n\t\tpi->cmdtext = xzalloc(1);\n\t\treturn pi->cmdtext;\n\t}\n\n\tlen = 0;\n\tdo {\n\t\tlen += strlen(*argv) + 1;\n\t} while (*++argv);\n\tp = xmalloc(len);\n\tpi->cmdtext = p;\n\targv = pi->cmds[0].argv;\n\tdo {\n\t\tlen = strlen(*argv);\n\t\tmemcpy(p, *argv, len);\n\t\tp += len;\n\t\t*p++ = ' ';\n\t} while (*++argv);\n\tp[-1] = '\\0';\n\treturn pi->cmdtext;\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_471AE1(FILE *a1, __int64 a2, char a3)\n{\n  int result; // eax\n  unsigned int v4; // eax\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 v7; // r8\n  __int64 v8; // r9\n  int v9; // eax\n  int v10; // eax\n  const char *v11; // rdi\n  unsigned int v12; // ecx\n  char v15[80]; // [rsp+20h] [rbp-70h] BYREF\n  unsigned int *v16; // [rsp+70h] [rbp-20h]\n  unsigned int v17; // [rsp+7Ch] [rbp-14h]\n  int v18; // [rsp+80h] [rbp-10h]\n  unsigned int v19; // [rsp+84h] [rbp-Ch]\n  unsigned int *v20; // [rsp+88h] [rbp-8h]\n\n  v20 = *(unsigned int **)(a2 + 16);\n  if ( (a3 & 1) != 0 )\n    return fprintf(a1, \"%d\\n\", *v20);\n  v4 = sub_470E5C(a2);\n  v19 = sub_46E1F9(v15, 0x10uLL, \"[%d]   \", v4, v5, v6);\n  v17 = v19;\n  if ( a2 == qword_75AFB0 )\n  {\n    v15[v19 - 3] = 43;\n  }\n  else if ( qword_75AFB0 && a2 == *(_QWORD *)(qword_75AFB0 + 32) )\n  {\n    v15[v19 - 3] = 45;\n  }\n  if ( (a3 & 2) != 0 )\n  {\n    v9 = sub_46E1F9(&v15[v19], 0x10uLL, \"%d \", *v20, v7, v8);\n    v19 += v9;\n  }\n  v16 = &v20[4 * *(unsigned __int16 *)(a2 + 28)];\n  if ( *(_BYTE *)(a2 + 30) )\n  {\n    v18 = *(v16 - 3);\n    if ( *(_BYTE *)(a2 + 30) == 1 )\n      v18 = *(_DWORD *)(a2 + 24);\n    v10 = sub_471762(&v15[v19], v18, 0, (__int64)&v15[v19], v7, v8);\n    v19 += v10;\n  }\n  else\n  {\n    *(_QWORD *)&v15[v19] = 0x676E696E6E7552LL;\n    v19 += 7;\n  }\n  while ( 1 )\n  {\n    if ( v20 == *(unsigned int **)(a2 + 16) )\n      v11 = (const char *)&unk_51CA3E;\n    else\n      v11 = \"| \";\n    v12 = 0;\n    if ( (int)(33 - v19) >= 0 )\n      v12 = 33 - v19;\n    fprintf(a1, \"%s%*c%s%s\", v15, v12, 32LL, v11, *((const char **)v20 + 1));\n    v20 += 4;\n    if ( v20 == v16 )\n      break;\n    v15[0] = 0;\n    v19 = 33;\n    if ( (a3 & 2) != 0 )\n      v19 = sub_46E1F9(v15, 0x30uLL, \"\\n%*c%d \", v17, 32LL, *v20) - 1;\n  }\n  sub_46E0F3(10, a1);\n  *(_BYTE *)(a2 + 31) &= ~0x10u;\n  result = *(unsigned __int8 *)(a2 + 30);\n  if ( (_BYTE)result == 2 )\n    return sub_47107C(a2);\n  return result;\n}\n\n\n Revised code:\nif JOBS\nstatic void\nshowjob(FILE *out, struct job *jp, int mode)\n{\n\tstruct procstat *ps;\n\tstruct procstat *psend;\n\tint col;\n\tint indent_col;\n\tchar s[80];\n\n\tps = jp->ps;\n\n\tif (mode & SHOW_ONLY_PGID) { /* jobs -p */\n\t\t/* just output process (group) id of pipeline */\n\t\tfprintf(out, \"%d\\n\", ps->ps_pid);\n\t\treturn;\n\t}\n\n\tcol = fmtstr(s, 16, \"[%d]   \", jobno(jp));\n\tindent_col = col;\n\n\tif (jp == curjob)\n\t\ts[col - 3] = '+';\n\telse if (curjob && jp == curjob->prev_job)\n\t\ts[col - 3] = '-';\n\n\tif (mode & SHOW_PIDS)\n\t\tcol += fmtstr(s + col, 16, \"%d \", ps->ps_pid);\n\n\tpsend = ps + jp->nprocs;\n\n\tif (jp->state == JOBRUNNING) {\n\t\tstrcpy(s + col, \"Running\");\n\t\tcol += sizeof(\"Running\") - 1;\n\t} else {\n\t\tint status = psend[-1].ps_status;\n\t\tif (jp->state == JOBSTOPPED)\n\t\t\tstatus = jp->stopstatus;\n\t\tcol += sprint_status(s + col, status, 0);\n\t}\n\t/* By now, \"[JOBID]*  [maybe PID] STATUS\" is printed */\n\n\t/* This loop either prints \"<cmd1> | <cmd2> | <cmd3>\" line\n\t * or prints several \"PID             | <cmdN>\" lines,\n\t * depending on SHOW_PIDS bit.\n\t * We do not print status of individual processes\n\t * between PID and <cmdN>. bash does it, but not very well:\n\t * first line shows overall job status, not process status,\n\t * making it impossible to know 1st process status.\n\t */\n\tgoto start;\n\tdo {\n\t\t/* for each process */\n\t\ts[0] = '\\0';\n\t\tcol = 33;\n\t\tif (mode & SHOW_PIDS)\n\t\t\tcol = fmtstr(s, 48, \"\\n%*c%d \", indent_col, ' ', ps->ps_pid) - 1;\n start:\n\t\tfprintf(out, \"%s%*c%s%s\",\n\t\t\t\ts,\n\t\t\t\t33 - col >= 0 ? 33 - col : 0, ' ',\n\t\t\t\tps == jp->ps ? \"\" : \"| \",\n\t\t\t\tps->ps_cmd\n\t\t);\n\t} while (++ps != psend);\n\toutcslow('\\n', out);\n\n\tjp->changed = 0;\n\n\tif (jp->state == JOBDONE) {\n\t\tTRACE((\"showjob: freeing job %d\\n\", jobno(jp)));\n\t\tfreejob(jp);\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48682E(const char *a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-18h]\n  char *v4; // [rsp+20h] [rbp-10h]\n  __int64 v5; // [rsp+28h] [rbp-8h]\n\n  v4 = sub_4867AC(a1);\n  v5 = *(_QWORD *)v4;\n  if ( *(_QWORD *)v4 )\n  {\n    v3 = *(_QWORD *)(v5 + 16);\n    if ( v3 )\n    {\n      **(_QWORD **)(v3 + 32) = *(_QWORD *)(v5 + 8);\n      *(_QWORD *)(v3 + 16) = *(_QWORD *)(v5 + 24);\n    }\n    else\n    {\n      free(*(void **)(v5 + 8));\n      if ( *(_QWORD *)(v5 + 24) )\n        sub_4821B8(*(__int64 **)(v5 + 24));\n    }\n  }\n  else\n  {\n    *(_QWORD *)v4 = sub_40A0E8(0x20uLL, a2);\n    v5 = *(_QWORD *)v4;\n  }\n  *(_QWORD *)(v5 + 8) = a1;\n  return v5;\n}\n\n\n Revised code:\nstatic struct function *new_function(char *name)\n{\n\tstruct function **funcpp = find_function_slot(name);\n\tstruct function *funcp = *funcpp;\n\n\tif (funcp != NULL) {\n\t\tstruct command *cmd = funcp->parent_cmd;\n\t\tdebug_printf_exec(\"func %p parent_cmd %p\\n\", funcp, cmd);\n\t\tif (!cmd) {\n\t\t\tdebug_printf_exec(\"freeing & replacing function '%s'\\n\", funcp->name);\n\t\t\tfree(funcp->name);\n\t\t\t/* Note: if !funcp->body, do not free body_as_string!\n\t\t\t * This is a special case of \"-F name body\" function:\n\t\t\t * body_as_string was not malloced! */\n\t\t\tif (funcp->body) {\n\t\t\t\tfree_pipe_list(funcp->body);\n# if !BB_MMU\n\t\t\t\tfree(funcp->body_as_string);\n# endif\n\t\t\t}\n\t\t} else {\n\t\t\tdebug_printf_exec(\"reinserting in tree & replacing function '%s'\\n\", funcp->name);\n\t\t\tcmd->argv[0] = funcp->name;\n\t\t\tcmd->group = funcp->body;\n# if !BB_MMU\n\t\t\tcmd->group_as_string = funcp->body_as_string;\n# endif\n\t\t}\n\t} else {\n\t\tdebug_printf_exec(\"remembering new function '%s'\\n\", name);\n\t\tfuncp = *funcpp = xzalloc(sizeof(*funcp));\n\t\t/*funcp->next = NULL;*/\n\t}\n\n\tfuncp->name = name;\n\treturn funcp;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_49AAC8(unsigned int a1, __int64 a2)\n{\n  __int64 v2; // rsi\n  __int64 v3; // rsi\n  __int64 v4; // rsi\n  const char **v7; // [rsp+10h] [rbp-10h]\n  const char **v8; // [rsp+10h] [rbp-10h]\n  const char **v9; // [rsp+18h] [rbp-8h]\n  const char **v10; // [rsp+18h] [rbp-8h]\n\n  printf(\"%-10d %-10o\", a1, *(_WORD *)(a2 + 20) & 0x1FF);\n  v9 = (const char **)sub_40C486(*(unsigned int *)(a2 + 12), a1);\n  if ( v9 )\n  {\n    v2 = (__int64)*v9;\n    printf(\" %-10s\", *v9);\n  }\n  else\n  {\n    v2 = *(unsigned int *)(a2 + 12);\n    printf(\" %-10d\", v2);\n  }\n  v7 = (const char **)sub_40C4D2(*(unsigned int *)(a2 + 16), v2);\n  if ( v7 )\n  {\n    v3 = (__int64)*v7;\n    printf(\" %-10s\", *v7);\n  }\n  else\n  {\n    v3 = *(unsigned int *)(a2 + 16);\n    printf(\" %-10d\", v3);\n  }\n  v10 = (const char **)sub_40C486(*(unsigned int *)(a2 + 4), v3);\n  if ( v10 )\n  {\n    v4 = (__int64)*v10;\n    printf(\" %-10s\", *v10);\n  }\n  else\n  {\n    v4 = *(unsigned int *)(a2 + 4);\n    printf(\" %-10d\", v4);\n  }\n  v8 = (const char **)sub_40C4D2(*(unsigned int *)(a2 + 8), v4);\n  if ( v8 )\n    return printf(\" %-10s\\n\", *v8);\n  else\n    return printf(\" %-10d\\n\", *(unsigned int *)(a2 + 8));\n}\n"
    },
    {
        "func_name": "xmkstemp",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40A2DB(const char *a1, int a2, unsigned int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v8; // [rsp+1Ch] [rbp-4h]\n\n  v8 = open64(a1, a2, a3);\n  if ( v8 < 0 )\n    sub_4091D9((__int64)\"can't open '%s'\", (__int64)a1, v3, v4, v5, v6);\n  return (unsigned int)v8;\n}\n\n\n Revised code:\nint FAST_FUNC open3_or_warn(const char *pathname, int flags, int mode)\n{\n\tint ret;\n\n\tret = open(pathname, flags, mode);\n\tif (ret < 0) {\n\t\tbb_perror_msg(\"can't open '%s'\", pathname);\n\t}\n\treturn ret;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40A246(const char *a1, int a2, unsigned int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v8; // [rsp+1Ch] [rbp-4h]\n\n  v8 = open64(a1, a2, a3);\n  if ( v8 < 0 )\n    sub_4092A2((__int64)\"can't open '%s'\", (__int64)a1, v3, v4, v5, v6);\n  return (unsigned int)v8;\n}\n\n\n Revised code:\nint FAST_FUNC xopen3(const char *pathname, int flags, int mode)\n{\n\tint ret;\n\n\tret = open(pathname, flags, mode);\n\tif (ret < 0) {\n\t\tbb_perror_msg_and_die(\"can't open '%s'\", pathname);\n\t}\n\treturn ret;\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_40A11F(const char *a1, __int64 a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // [rsp+18h] [rbp-8h]\n\n  if ( !a1 )\n    return 0LL;\n  v7 = strdup(a1);\n  if ( !v7 )\n    sub_40969E(\"out of memory\", a2, v3, v4, v5, v6);\n  return v7;\n}\n\n\n Revised code:\nFAST_FUNC xstrdup(const char *s)\n{\n\tchar *t;\n\n\tif (s == NULL)\n\t\treturn NULL;\n\n\tt = strdup(s);\n\n\tif (t == NULL)\n\t\tbb_error_msg_and_die(bb_msg_memory_exhausted);\n\n\treturn t;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40A5B9(char *a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  v6 = mkstemp64(a1);\n  if ( v6 < 0 )\n    sub_4092A2((__int64)\"can't create temp file '%s'\", (__int64)a1, v1, v2, v3, v4);\n  return (unsigned int)v6;\n}\n"
    },
    {
        "func_name": "print_flag",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_4633DC(char *a1, int a2, __int64 a3)\n{\n  int result; // eax\n\n  *a1 = 63;\n  a1[1] = 0;\n  result = *(_DWORD *)(a3 + 124);\n  if ( result )\n    return snprintf(a1, a2 + 1, \"%u,%u\", *(unsigned int *)(a3 + 124), *(unsigned int *)(a3 + 128));\n  return result;\n}\n\n\n Revised code:\nstatic void func_tty(char *buf, int size, const procps_status_t *ps)\n{\n\tbuf[0] = '?';\n\tbuf[1] = '\\0';\n\tif (ps->tty_major) /* tty field of \"0\" means \"no tty\" */\n\t\tsnprintf(buf, size+1, \"%u,%u\", ps->tty_major, ps->tty_minor);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_417BE4(int a1, const char *a2, __int64 a3)\n{\n  int result; // eax\n  int v4; // [rsp+8h] [rbp-18h]\n\n  v4 = a3;\n  if ( a1 )\n  {\n    printf(\" setting %s to %ld\", a2, a3);\n    return sub_417BBC(v4);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void print_flag_on_off(int get_arg, const char *s, unsigned long arg)\n{\n\tif (get_arg) {\n\t\tprintf(\" setting %s to %ld\", s, arg);\n\t\ton_off(arg);\n\t}\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_413241(int a1, int a2)\n{\n  int result; // eax\n\n  if ( *((_DWORD *)qword_75D408 + 15) != a1 || (result = a2, *((_DWORD *)qword_75D408 + 16) != a2) )\n  {\n    *((_DWORD *)qword_75D408 + 15) = a1;\n    *((_DWORD *)qword_75D408 + 16) = a2;\n    return printf(\"\\x1B[%u;%uH\", (unsigned int)(a2 + 1), (unsigned int)(a1 + 1));\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void gotoxy(int col, int line)\n{\n\tif (G.col != col || G.line != line) {\n\t\tG.col = col;\n\t\tG.line = line;\n\t\tprintf(ESC\"[%u;%uH\", line + 1, col + 1);\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_41A75D(int a1, const char *a2, __int64 a3)\n{\n  int result; // eax\n\n  if ( a1 )\n    return printf(\" setting %s to %ld\\n\", a2, a3);\n  return result;\n}\n"
    },
    {
        "func_name": "xzalloc",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nssize_t __fastcall sub_40B4C5(int a1, char *a2, size_t a3)\n{\n  ssize_t v4; // [rsp+8h] [rbp-18h]\n\n  v4 = sub_40B446(a1, a2, a3);\n  close(a1);\n  return v4;\n}\n\n\n Revised code:\nssize_t FAST_FUNC read_close(int fd, void *buf, size_t size)\n{\n\t/*int e;*/\n\tsize = full_read(fd, buf, size);\n\t/*e = errno;*/\n\tclose(fd);\n\t/*errno = e;*/\n\treturn size;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4D9ED3(__int64 a1, __int64 a2, __int64 a3)\n{\n  void *ptr; // [rsp+28h] [rbp-8h]\n\n  ptr = (void *)sub_4F67A0(a1, a2 + 19);\n  if ( ptr )\n  {\n    sub_4D9F2F(ptr, a3);\n    free(ptr);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC chattr_dir_proc(const char *dir_name, struct dirent *de, void *gp)\n{\n\tchar *path = concat_subpath_file(dir_name, de->d_name);\n\t/* path is NULL if de->d_name is \".\" or \"..\", else... */\n\tif (path) {\n\t\tchange_attributes(path, gp);\n\t\tfree(path);\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4F63E5(unsigned int a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40C4D2(a1, a2);\n  if ( v3 )\n    return *(_QWORD *)v3;\n  else\n    return 0LL;\n}\n\n\n Revised code:\nFAST_FUNC gid2group(gid_t gid)\n{\n\tstruct group *gr = getgrgid(gid);\n\treturn (gr) ? gr->gr_name : NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_40A0E8(size_t a1, __int64 a2)\n{\n  void *s; // [rsp+18h] [rbp-8h]\n\n  s = sub_40A05F(a1, a2);\n  memset(s, 0, a1);\n  return s;\n}\n"
    },
    {
        "func_name": "iamarray",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4D12FE(__int64 a1, __int64 a2)\n{\n  __int64 *i; // [rsp+8h] [rbp-8h]\n\n  for ( i = &qword_75B250; *i; i = (__int64 *)*i )\n    ;\n  *i = (__int64)sub_40A0E8(0x20uLL, a2);\n  return *i;\n}\n\n\n Revised code:\nstatic struct sort_key *add_key(void)\n{\n\tstruct sort_key **pkey = &key_list;\n\twhile (*pkey)\n\t\tpkey = &((*pkey)->next_key);\n\treturn *pkey = xzalloc(sizeof(struct sort_key));\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4FB084(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  size_t n_4; // [rsp+20h] [rbp-10h]\n  unsigned int v4; // [rsp+2Ch] [rbp-4h]\n\n  v4 = (*(_QWORD *)(a1 + 72) & 0x3F) + 1;\n  *(_BYTE *)(a1 + (*(_DWORD *)(a1 + 72) & 0x3F)) = 0x80;\n  while ( 1 )\n  {\n    memset((void *)(v4 + a1), 0, 64 - v4);\n    if ( 64 - v4 > 7 )\n    {\n      n_4 = 8LL * *(_QWORD *)(a1 + 72);\n      if ( a2 )\n        n_4 = sub_4FAF66(n_4);\n      *(_QWORD *)(a1 + 56) = n_4;\n    }\n    result = (*(__int64 (__fastcall **)(__int64))(a1 + 64))(a1);\n    if ( 64 - v4 > 7 )\n      break;\n    v4 = 0;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void FAST_FUNC common64_end(md5_ctx_t *ctx, int swap_needed)\n{\n\tunsigned bufpos = ctx->total64 & 63;\n\t/* Pad the buffer to the next 64-byte boundary with 0x80,0,0,0... */\n\tctx->wbuffer[bufpos++] = 0x80;\n\n\t/* This loop iterates either once or twice, no more, no less */\n\twhile (1) {\n\t\tunsigned remaining = 64 - bufpos;\n\t\tmemset(ctx->wbuffer + bufpos, 0, remaining);\n\t\t/* Do we have enough space for the length count? */\n\t\tif (remaining >= 8) {\n\t\t\t/* Store the 64-bit counter of bits in the buffer */\n\t\t\tuint64_t t = ctx->total64 << 3;\n\t\t\tif (swap_needed)\n\t\t\t\tt = bb_bswap_64(t);\n\t\t\t/* wbuffer is suitably aligned for this */\n\t\t\t*(uint64_t *) (&ctx->wbuffer[64 - 8]) = t;\n\t\t}\n\t\tctx->process_block(ctx);\n\t\tif (remaining >= 8)\n\t\t\tbreak;\n\t\tbufpos = 0;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E4DF8(__int64 a1, __int64 a2, __int64 a3)\n{\n  char **v3; // rbx\n  const char *i; // [rsp+28h] [rbp-18h]\n\n  for ( i = (const char *)(*(_QWORD *)a3 + a1); *i == 47; ++i )\n    ;\n  *(_QWORD *)(a3 + 16) = sub_50C0E1(*(_QWORD *)(a3 + 16), 2054LL, *(unsigned int *)(a3 + 12));\n  v3 = (char **)(*(_QWORD *)(a3 + 16) + 8LL * *(int *)(a3 + 12));\n  *v3 = sub_40A11F(i, 2054LL);\n  ++*(_DWORD *)(a3 + 12);\n  return 1LL;\n}\n\n\n Revised code:\nstatic void add_to_dirlist(const char *name, struct dir_list **list)\n{\n\tstruct dir_list *dp;\n\n\tdp = xmalloc(sizeof(struct dir_list));\n\tdp->name = blkid_strdup(name);\n\tdp->next = *list;\n\t*list = dp;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4DC779(__int64 a1, __int64 a2)\n{\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = a1; (*(_DWORD *)i & 0x2000) != 0; i = *(_QWORD *)(i + 24) )\n    ;\n  if ( (*(_DWORD *)i & 2) == 0 )\n  {\n    *(_DWORD *)i |= 2u;\n    *(_QWORD *)(i + 24) = sub_4DC126(a1, a2);\n  }\n  return *(_QWORD *)(i + 24);\n}\n"
    },
    {
        "func_name": "ip_parse_common_args",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4375C0(char *a1, _WORD *a2)\n{\n  char *v2; // rax\n  _BYTE *v4; // rax\n  char v6; // [rsp+1Fh] [rbp-11h]\n  unsigned int v7; // [rsp+20h] [rbp-10h]\n  unsigned int v8; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+24h] [rbp-Ch]\n  _WORD *v10; // [rsp+28h] [rbp-8h]\n\n  *a2 = 1;\n  v10 = a2 + 1;\n  for ( i = 0; *a1 && i <= 5; ++i )\n  {\n    v2 = a1++;\n    v7 = 16 * sub_437583(*v2);\n    if ( v7 > 0xFF )\n    {\n      *(_DWORD *)qword_75D400 = 22;\n      return 0xFFFFFFFFLL;\n    }\n    v6 = *a1;\n    if ( *a1 != 58 && v6 )\n    {\n      v8 = sub_437583(v6) | v7;\n      if ( v8 > 0xFF )\n      {\n        *(_DWORD *)qword_75D400 = 22;\n        return 0xFFFFFFFFLL;\n      }\n    }\n    else\n    {\n      v8 = v7 >> 4;\n    }\n    if ( v6 )\n      ++a1;\n    v4 = v10;\n    v10 = (_WORD *)((char *)v10 + 1);\n    *v4 = v8;\n    if ( *a1 == 58 )\n      ++a1;\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC ether_input(const char *bufp, struct sockaddr *sap)\n{\n\tunsigned char *ptr;\n\tchar c;\n\tint i;\n\tunsigned val;\n\n\tsap->sa_family = ether_hwtype.type;\n\tptr = (unsigned char*) sap->sa_data;\n\n\ti = 0;\n\twhile ((*bufp != '\\0') && (i < ETH_ALEN)) {\n\t\tval = hexchar2int(*bufp++) * 0x10;\n\t\tif (val > 0xff) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tc = *bufp;\n\t\tif (c == ':' || c == 0)\n\t\t\tval >>= 4;\n\t\telse {\n\t\t\tval |= hexchar2int(c);\n\t\t\tif (val > 0xff) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (c != 0)\n\t\t\tbufp++;\n\t\t*ptr++ = (unsigned char) val;\n\t\ti++;\n\n\t\t/* We might get a semicolon here - not required. */\n\t\tif (*bufp == ':') {\n\t\t\tbufp++;\n\t\t}\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 sub_47DB13()\n{\n  __int64 v1; // [rsp+8h] [rbp-18h]\n  _BYTE *v2; // [rsp+10h] [rbp-10h]\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n\n  while ( 1 )\n  {\n    v3 = sub_47D959();\n    if ( (byte_75B058 & 4) != 0 )\n    {\n      while ( v3 == 1 )\n      {\n        sub_47DCB7();\n        v3 = sub_47D959();\n      }\n    }\n    if ( v3 != 3 || byte_75B05B )\n      break;\n    if ( (byte_75B058 & 2) != 0 )\n    {\n      v2 = sub_4774FB(qword_75B068);\n      if ( v2 )\n      {\n        v3 = (v2 - (_BYTE *)&off_51D220) >> 3;\n        byte_75B05C = (v2 - (_BYTE *)&off_51D220) >> 3;\n        break;\n      }\n    }\n    if ( (byte_75B058 & 1) == 0 )\n      break;\n    v1 = sub_47061E(qword_75B068, 1);\n    if ( !v1 )\n      break;\n    if ( **(_BYTE **)(v1 + 16) )\n      sub_479F0F(*(_QWORD *)(v1 + 16), v1);\n  }\n  byte_75B058 = 0;\n  return v3;\n}\n\n\n Revised code:\nstatic int\nreadtoken(void)\n{\n\tint t;\n#if DEBUG\n\tsmallint alreadyseen = tokpushback;\n#endif\n\n#if ENABLE_ASH_ALIAS\n top:\n#endif\n\n\tt = xxreadtoken();\n\n\t/*\n\t * eat newlines\n\t */\n\tif (checkkwd & CHKNL) {\n\t\twhile (t == TNL) {\n\t\t\tparseheredoc();\n\t\t\tt = xxreadtoken();\n\t\t}\n\t}\n\n\tif (t != TWORD || quoteflag) {\n\t\tgoto out;\n\t}\n\n\t/*\n\t * check for keywords\n\t */\n\tif (checkkwd & CHKKWD) {\n\t\tconst char *const *pp;\n\n\t\tpp = findkwd(wordtext);\n\t\tif (pp) {\n\t\t\tlasttoken = t = pp - tokname_array;\n\t\t\tTRACE((\"keyword '%s' recognized\\n\", tokname_array[t] + 1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (checkkwd & CHKALIAS) {\n#if ENABLE_ASH_ALIAS\n\t\tstruct alias *ap;\n\t\tap = lookupalias(wordtext, 1);\n\t\tif (ap != NULL) {\n\t\t\tif (*ap->val) {\n\t\t\t\tpushstring(ap->val, ap);\n\t\t\t}\n\t\t\tgoto top;\n\t\t}\n#endif\n\t}\n out:\n\tcheckkwd = 0;\n#if DEBUG\n\tif (!alreadyseen)\n\t\tTRACE((\"token '%s' %s\\n\", tokname_array[t] + 1, t == TWORD ? wordtext : \"\"));\n\telse\n\t\tTRACE((\"reread token '%s' %s\\n\", tokname_array[t] + 1, t == TWORD ? wordtext : \"\"));\n#endif\n\treturn t;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4704BD(int a1, char a2)\n{\n  char *v3; // [rsp+10h] [rbp-10h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  if ( a1 == 256 )\n    return 11LL;\n  if ( a1 == 257 )\n  {\n    v4 = 0;\n  }\n  else\n  {\n    if ( (unsigned __int8)a1 > 0x80u && (unsigned __int8)a1 <= 0x88u )\n      return 12LL;\n    v3 = strchrnul(\"\\t\\n !\\\"$&'()*-/:;<=>?[\\\\]`|}~\", a1);\n    if ( !*v3 )\n      return 0LL;\n    v4 = (unsigned __int8)byte_51DEA8[v3 - \"\\t\\n !\\\"$&'()*-/:;<=>?[\\\\]`|}~\"];\n  }\n  return ((int)(unsigned __int16)word_51C830[v4] >> (4 * a2)) & 0xF;\n}\n\n\n Revised code:\nif USE_SIT_FUNCTION\n\nstatic int\nSIT(int c, int syntax)\n{\n\tstatic const char spec_symbls[] ALIGN1 = \"\\t\\n !\\\"$&'()*-/:;<=>?[\\\\]`|}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_QWORD *__fastcall sub_449AD5(_QWORD *a1)\n{\n  char v1; // al\n  _BYTE *v4; // [rsp+10h] [rbp-10h]\n  int v5; // [rsp+1Ch] [rbp-4h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  while ( *a1 && *(_BYTE *)*a1 == 45 )\n  {\n    v4 = (_BYTE *)(*a1 + 1LL);\n    if ( *v4 == 45 )\n    {\n      v4 = (_BYTE *)(*a1 + 2LL);\n      if ( !*v4 )\n      {\n        ++a1;\n        break;\n      }\n    }\n    v5 = sub_4F66C5(\"oneline\", v4);\n    if ( v5 < 0 )\n      sub_407F64();\n    if ( v5 )\n    {\n      if ( v5 == 1 )\n      {\n        if ( !*++a1 )\n          sub_407F64();\n        v6 = sub_4F6666(\"inet\", *a1);\n        if ( v6 < 0 )\n          sub_453293(*a1, \"protocol family\");\n      }\n      else\n      {\n        v6 = v5 - 2;\n      }\n      byte_75B2FC = byte_535E72[v6];\n      ++a1;\n    }\n    else\n    {\n      byte_75D466 = 1;\n      ++a1;\n    }\n  }\n  if ( byte_75D466 )\n    v1 = 92;\n  else\n    v1 = 10;\n  byte_75D465 = v1;\n  return a1;\n}\n"
    },
    {
        "func_name": "o_addstr",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_481571(__int64 a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  return sub_4814C5(a1, a2, v2 + 1);\n}\n\n\n Revised code:\nendif\n\nstatic void o_addstr_with_NUL(o_string *o, const char *str)\n{\n\to_addblock(o, str, strlen(str) + 1);\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_48187C(__int64 a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  return sub_48182B(a1, a2, v2);\n}\n\n\n Revised code:\nstatic void o_addQstr(o_string *o, const char *str)\n{\n\to_addQblock(o, str, strlen(str));\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_480D48(const char *a1)\n{\n  int v1; // eax\n\n  v1 = strlen(a1);\n  return sub_480C0A(a1, v1);\n}\n\n\n Revised code:\nstatic int unset_local_var(const char *name)\n{\n\treturn unset_local_var_len(name, strlen(name));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_48153D(__int64 a1, const char *a2)\n{\n  int v2; // eax\n\n  v2 = strlen(a2);\n  return sub_4814C5(a1, a2, v2);\n}\n"
    },
    {
        "func_name": "file_write",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B4FB0(const char *a1, __int64 a2, __int64 a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 v8; // rdx\n  size_t n; // [rsp+20h] [rbp-20h]\n  const char *v10; // [rsp+28h] [rbp-18h]\n  int fd; // [rsp+3Ch] [rbp-4h]\n\n  fd = -1;\n  v10 = (const char *)sub_4C0C5F(a1);\n  if ( !*v10 )\n    return 1LL;\n  if ( (*(_DWORD *)(a2 + 24) & 0xF000) == 49152 )\n  {\n    sub_409747(\"%s: socket ignored\", (__int64)a1, v3, v4, v5, v6);\n    return 1LL;\n  }\n  else\n  {\n    *(_QWORD *)(a3 + 24) = 0LL;\n    if ( (*(_DWORD *)(a2 + 24) & 0xF000) != 0x4000 && *(_QWORD *)(a2 + 16) > 1uLL )\n    {\n      *(_QWORD *)(a3 + 24) = sub_4B463A(*(_QWORD **)(a3 + 16), (_QWORD *)a2);\n      if ( !*(_QWORD *)(a3 + 24) )\n        sub_4B4564((_QWORD *)(a3 + 16), (_QWORD *)a2, v10);\n    }\n    if ( *(_QWORD *)(a3 + 32) == *(_QWORD *)a2 && (v8 = *(_QWORD *)(a3 + 40), v8 == *(_QWORD *)(a2 + 8)) )\n    {\n      sub_409747(\"%s: file is the archive; skipping\", (__int64)a1, v8, v4, v5, v6);\n      return 1LL;\n    }\n    else if ( (unsigned int)sub_4B4EE0(*(__int64 ***)(a3 + 8), v10) )\n    {\n      return 2LL;\n    }\n    else if ( *(_QWORD *)(a3 + 24) || (*(_DWORD *)(a2 + 24) & 0xF000) != 0x8000 || (fd = sub_40A32A(a1, 0), fd >= 0) )\n    {\n      if ( (unsigned int)sub_4B492A(a3, v10, a1, a2) )\n      {\n        if ( fd >= 0 )\n        {\n          sub_40B309(fd, *(_DWORD *)a3, *(_QWORD *)(a2 + 48));\n          close(fd);\n          n = -(int)*(_QWORD *)(a2 + 48) & 0x1FF;\n          memset(&dest, 0, n);\n          sub_40A4AB(*(_DWORD *)a3, (__int64)&dest, n);\n        }\n        return 1LL;\n      }\n      else\n      {\n        return 0LL;\n      }\n    }\n    else\n    {\n      return 0LL;\n    }\n  }\n}\n\n\n Revised code:\nendif\n\nstatic int FAST_FUNC writeFileToTarball(const char *fileName, struct stat *statbuf,\n\t\t\tvoid *userData, int depth UNUSED_PARAM)\n{\n\tstruct TarBallInfo *tbInfo = (struct TarBallInfo *) userData;\n\tconst char *header_name;\n\tint inputFileFd = -1;\n\n\tDBG(\"writeFileToTarball('%s')\", fileName);\n\n\t/* Strip leading '/' and such (must be before memorizing hardlink's name) */\n\theader_name = strip_unsafe_prefix(fileName);\n\n\tif (header_name[0] == '\\0')\n\t\treturn TRUE;\n\n\t/* It is against the rules to archive a socket */\n\tif (S_ISSOCK(statbuf->st_mode)) {\n\t\tbb_error_msg(\"%s: socket ignored\", fileName);\n\t\treturn TRUE;\n\t}\n\n\t/*\n\t * Check to see if we are dealing with a hard link.\n\t * If so -\n\t * Treat the first occurance of a given dev/inode as a file while\n\t * treating any additional occurances as hard links.  This is done\n\t * by adding the file information to the HardLinkInfo linked list.\n\t */\n\ttbInfo->hlInfo = NULL;\n\tif (!S_ISDIR(statbuf->st_mode) && statbuf->st_nlink > 1) {\n\t\tDBG(\"'%s': st_nlink > 1\", header_name);\n\t\ttbInfo->hlInfo = findHardLinkInfo(tbInfo->hlInfoHead, statbuf);\n\t\tif (tbInfo->hlInfo == NULL) {\n\t\t\tDBG(\"'%s': addHardLinkInfo\", header_name);\n\t\t\taddHardLinkInfo(&tbInfo->hlInfoHead, statbuf, header_name);\n\t\t}\n\t}\n\n\t/* It is a bad idea to store the archive we are in the process of creating,\n\t * so check the device and inode to be sure that this particular file isn't\n\t * the new tarball */\n\tif (tbInfo->tarFileStatBuf.st_dev == statbuf->st_dev\n\t && tbInfo->tarFileStatBuf.st_ino == statbuf->st_ino\n\t) {\n\t\tbb_error_msg(\"%s: file is the archive; skipping\", fileName);\n\t\treturn TRUE;\n\t}\n\n\tif (exclude_file(tbInfo->excludeList, header_name))\n\t\treturn SKIP;\n\n#if !ENABLE_FEATURE_TAR_GNU_EXTENSIONS\n\tif (strlen(header_name) >= NAME_SIZE) {\n\t\tbb_error_msg(\"names longer than \"NAME_SIZE_STR\" chars not supported\");\n\t\treturn TRUE;\n\t}\n#endif\n\n\t/* Is this a regular file? */\n\tif (tbInfo->hlInfo == NULL && S_ISREG(statbuf->st_mode)) {\n\t\t/* open the file we want to archive, and make sure all is well */\n\t\tinputFileFd = open_or_warn(fileName, O_RDONLY);\n\t\tif (inputFileFd < 0) {\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\t/* Add an entry to the tarball */\n\tif (writeTarHeader(tbInfo, header_name, fileName, statbuf) == FALSE) {\n\t\treturn FALSE;\n\t}\n\n\t/* If it was a regular file, write out the body */\n\tif (inputFileFd >= 0) {\n\t\tsize_t readSize;\n\t\t/* Write the file to the archive. */\n\t\t/* We record size into header first, */\n\t\t/* and then write out file. If file shrinks in between, */\n\t\t/* tar will be corrupted. So we don't allow for that. */\n\t\t/* NB: GNU tar 1.16 warns and pads with zeroes */\n\t\t/* or even seeks back and updates header */\n\t\tbb_copyfd_exact_size(inputFileFd, tbInfo->tarFd, statbuf->st_size);\n\t\t////off_t readSize;\n\t\t////readSize = bb_copyfd_size(inputFileFd, tbInfo->tarFd, statbuf->st_size);\n\t\t////if (readSize != statbuf->st_size && readSize >= 0) {\n\t\t////\tbb_error_msg_and_die(\"short read from %s, aborting\", fileName);\n\t\t////}\n\n\t\t/* Check that file did not grow in between? */\n\t\t/* if (safe_read(inputFileFd, 1) == 1) warn but continue? */\n\n\t\tclose(inputFileFd);\n\n\t\t/* Pad the file up to the tar block size */\n\t\t/* (a few tricks here in the name of code size) */\n\t\treadSize = (-(int)statbuf->st_size) & (TAR_BLOCK_SIZE-1);\n\t\tmemset(block_buf, 0, readSize);\n\t\txwrite(tbInfo->tarFd, block_buf, readSize);\n\t}\n\n\treturn TRUE;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47A754(__int64 a1, char a2)\n{\n  __int64 v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 v7; // rdx\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  int v13; // [rsp+18h] [rbp-8h]\n  int fd; // [rsp+1Ch] [rbp-4h]\n\n  ++*(_DWORD *)(qword_75D418 + 48);\n  v2 = 0LL;\n  fd = open64((const char *)a1, 0);\n  if ( fd >= 0 )\n  {\n    if ( fd <= 9 )\n    {\n      v13 = sub_473441(fd, 10);\n      close(fd);\n      if ( v13 < 0 )\n        sub_46E473(\"out of file descriptors\", 10LL, v7, v8, v9, v10);\n      fd = v13;\n    }\n    v2 = a2 & 1;\n    a1 = (unsigned int)fd;\n    sub_47A6BD(fd, v2);\n  }\n  else if ( (a2 & 2) == 0 )\n  {\n    sub_46E473(\"can't open '%s'\", a1, v3, v4, v5, v6);\n  }\n  sub_46E03F(a1, v2);\n  return (unsigned int)fd;\n}\n\n\n Revised code:\nstatic int\nsetinputfile(const char *fname, int flags)\n{\n\tint fd;\n\tint fd2;\n\n\tINT_OFF;\n\tfd = open(fname, O_RDONLY);\n\tif (fd < 0) {\n\t\tif (flags & INPUT_NOFILE_OK)\n\t\t\tgoto out;\n\t\tash_msg_and_raise_error(\"can't open '%s'\", fname);\n\t}\n\tif (fd < 10) {\n\t\tfd2 = copyfd(fd, 10);\n\t\tclose(fd);\n\t\tif (fd2 < 0)\n\t\t\tash_msg_and_raise_error(\"out of file descriptors\");\n\t\tfd = fd2;\n\t}\n\tsetinputfd(fd, flags & INPUT_PUSH_FILE);\n out:\n\tINT_ON;\n\treturn fd;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E72BF(const char *a1, int a2, int a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v7; // rsi\n  __int64 v8; // rdx\n  __int64 v9; // rcx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  int v16; // eax\n  unsigned int v18; // [rsp+4h] [rbp-2Ch]\n  int fd; // [rsp+1Ch] [rbp-14h]\n  unsigned int v20; // [rsp+20h] [rbp-10h]\n  unsigned int v21; // [rsp+24h] [rbp-Ch]\n  __int64 v22; // [rsp+28h] [rbp-8h]\n\n  v18 = a2;\n  if ( (unsigned int)sub_4E5B71(a2, a3, (__int64)\"write\", (unsigned int)a3, a5, a6) )\n    return 0LL;\n  v21 = 0;\n  v20 = 0;\n  v7 = 438LL;\n  fd = creat64(a1, 0x1B6u);\n  if ( fd < 0 )\n    goto LABEL_4;\n  v7 = (__int64)a1;\n  printf(\"\\\"%s\\\", \", a1);\n  sub_40A649();\n  v22 = sub_4E78F6(v18);\n  if ( v22 )\n  {\n    while ( 1 )\n    {\n      v16 = v18++;\n      if ( a3 < v16 )\n        break;\n      v7 = v22 + 20;\n      v12 = sub_40B38A(fd, v22 + 20, *(int *)(v22 + 16));\n      if ( v12 != *(_DWORD *)(v22 + 16) )\n      {\n        sub_40936D((__int64)a1, v7, v12, v13, v14, v15);\n        close(fd);\n        return 0LL;\n      }\n      v20 += *(_DWORD *)(v22 + 16);\n      ++v21;\n      v22 = *(_QWORD *)v22;\n    }\n    if ( close(fd) < 0 )\n    {\nLABEL_4:\n      sub_40936D((__int64)a1, v7, v8, v9, v10, v11);\n      return 0LL;\n    }\n    printf(\"%d lines, %d chars\\n\", v21, v20);\n    return 1LL;\n  }\n  else\n  {\n    close(fd);\n    return 0LL;\n  }\n}\n\n\n Revised code:\nstatic int writeLines(const char *file, int num1, int num2)\n{\n\tLINE *lp;\n\tint fd, lineCount, charCount;\n\n\tif (bad_nums(num1, num2, \"write\"))\n\t\treturn FALSE;\n\n\tlineCount = 0;\n\tcharCount = 0;\n\n\tfd = creat(file, 0666);\n\tif (fd < 0) {\n\t\tbb_simple_perror_msg(file);\n\t\treturn FALSE;\n\t}\n\n\tprintf(\"\\\"%s\\\", \", file);\n\tfflush_all();\n\n\tlp = findLine(num1);\n\tif (lp == NULL) {\n\t\tclose(fd);\n\t\treturn FALSE;\n\t}\n\n\twhile (num1++ <= num2) {\n\t\tif (full_write(fd, lp->data, lp->len) != lp->len) {\n\t\t\tbb_simple_perror_msg(file);\n\t\t\tclose(fd);\n\t\t\treturn FALSE;\n\t\t}\n\t\tcharCount += lp->len;\n\t\tlineCount++;\n\t\tlp = lp->next;\n\t}\n\n\tif (close(fd) < 0) {\n\t\tbb_simple_perror_msg(file);\n\t\treturn FALSE;\n\t}\n\n\tprintf(\"%d lines, %d chars\\n\", lineCount, charCount);\n\treturn TRUE;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4EFAD3(const char *a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int fd; // [rsp+28h] [rbp-8h]\n  unsigned int v9; // [rsp+2Ch] [rbp-4h]\n\n  if ( a1 )\n  {\n    fd = open64(a1, 65, 438LL);\n    if ( fd >= 0 )\n    {\n      v9 = sub_40B38A(fd, a2, a3 - (int)a2 + 1);\n      ftruncate64(fd, (int)v9);\n      if ( v9 != a3 - (_DWORD)a2 + 1 )\n        v9 = 0;\n      close(fd);\n      return v9;\n    }\n    else\n    {\n      return 0xFFFFFFFFLL;\n    }\n  }\n  else\n  {\n    sub_4EFE97((unsigned int)\"No current filename\", a2, a3, a4, a5, a6);\n    return 4294967294LL;\n  }\n}\n"
    },
    {
        "func_name": "in_ether",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_50A2A6(__int64 *a1, char *a2)\n{\n  _BYTE *v2; // rax\n  _BYTE *v3; // rax\n  _BYTE *v4; // rax\n  char v7; // [rsp+1Ch] [rbp-24h]\n  unsigned __int8 v8; // [rsp+1Dh] [rbp-23h]\n  unsigned __int8 v9; // [rsp+1Eh] [rbp-22h]\n  char v10; // [rsp+1Fh] [rbp-21h]\n  char *v11; // [rsp+20h] [rbp-20h]\n  int c; // [rsp+28h] [rbp-18h]\n  int v13; // [rsp+2Ch] [rbp-14h]\n  char *v14; // [rsp+30h] [rbp-10h]\n  _BYTE *v15; // [rsp+38h] [rbp-8h]\n\n  v15 = (_BYTE *)*a1;\n  while ( 1 )\n  {\n    v13 = 0;\n    v14 = a2;\nLABEL_9:\n    if ( v13 <= 3 )\n      break;\nLABEL_10:\n    if ( v13 > 1 )\n    {\n      v2 = v15++;\n      *v2 = (v8 >> 4) | (4 * v7);\n    }\n    if ( v13 > 2 )\n    {\n      v3 = v15++;\n      *v3 = (v9 >> 2) | (16 * v8);\n    }\n    if ( v13 > 3 )\n    {\n      v4 = v15++;\n      *v4 = v10 | (v9 << 6);\n    }\n  }\n  while ( 1 )\n  {\n    c = *a2;\n    if ( !c )\n      break;\n    ++a2;\n    v11 = strchr(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\", c);\n    if ( v11 )\n    {\n      c = v11 - \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      if ( c == 64 )\n        goto LABEL_10;\n      *(&v7 + v13++) = c;\n      goto LABEL_9;\n    }\n  }\n  if ( !v13 )\n    v14 = a2;\n  *a1 = (__int64)v15;\n  return (__int64)v14;\n}\n\n\n Revised code:\nFAST_FUNC decode_base64(char **pp_dst, const char *src)\n{\n\tchar *dst = *pp_dst;\n\tconst char *src_tail;\n\n\twhile (1) {\n\t\tunsigned char six_bit[4];\n\t\tint count = 0;\n\n\t\t/* Fetch up to four 6-bit values */\n\t\tsrc_tail = src;\n\t\twhile (count < 4) {\n\t\t\tchar *table_ptr;\n\t\t\tint ch;\n\n\t\t\t/* Get next _valid_ character.\n\t\t\t * bb_uuenc_tbl_base64[] contains this string:\n\t\t\t *  0         1         2         3         4         5         6\n\t\t\t *  01234567890123456789012345678901234567890123456789012345678901234\n\t\t\t * \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n\t\t\t */\n\t\t\tdo {\n\t\t\t\tch = *src;\n\t\t\t\tif (ch == '\\0') {\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\t/* Example:\n\t\t\t\t\t\t * If we decode \"QUJD <NUL>\", we want\n\t\t\t\t\t\t * to return ptr to NUL, not to ' ',\n\t\t\t\t\t\t * because we did fully decode\n\t\t\t\t\t\t * the string (to \"ABC\").\n\t\t\t\t\t\t */\n\t\t\t\t\t\tsrc_tail = src;\n\t\t\t\t\t}\n\t\t\t\t\tgoto ret;\n\t\t\t\t}\n\t\t\t\tsrc++;\n\t\t\t\ttable_ptr = strchr(bb_uuenc_tbl_base64, ch);\n//TODO: add BASE64_FLAG_foo to die on bad char?\n\t\t\t} while (!table_ptr);\n\n\t\t\t/* Convert encoded character to decimal */\n\t\t\tch = table_ptr - bb_uuenc_tbl_base64;\n\n\t\t\t/* ch is 64 if char was '=', otherwise 0..63 */\n\t\t\tif (ch == 64)\n\t\t\t\tbreak;\n\t\t\tsix_bit[count] = ch;\n\t\t\tcount++;\n\t\t}\n\n\t\t/* Transform 6-bit values to 8-bit ones.\n\t\t * count can be < 4 when we decode the tail:\n\t\t * \"eQ==\" -> \"y\", not \"y NUL NUL\".\n\t\t * Note that (count > 1) is always true,\n\t\t * \"x===\" encoding is not valid:\n\t\t * even a single zero byte encodes as \"AA==\".\n\t\t * However, with current logic we come here with count == 1\n\t\t * when we decode \"==\" tail.\n\t\t */\n\t\tif (count > 1)\n\t\t\t*dst++ = six_bit[0] << 2 | six_bit[1] >> 4;\n\t\tif (count > 2)\n\t\t\t*dst++ = six_bit[1] << 4 | six_bit[2] >> 2;\n\t\tif (count > 3)\n\t\t\t*dst++ = six_bit[2] << 6 | six_bit[3];\n\t\t/* Note that if we decode \"AA==\" and ate first '=',\n\t\t * we just decoded one char (count == 2) and now we'll\n\t\t * do the loop once more to decode second '='.\n\t\t */\n\t} /* while (1) */\n ret:\n\t*pp_dst = dst;\n\treturn src_tail;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_50308A(_BYTE **a1)\n{\n  const char *v2; // [rsp+18h] [rbp-20h]\n  unsigned int v3; // [rsp+20h] [rbp-18h]\n  unsigned int v4; // [rsp+24h] [rbp-14h]\n  unsigned int v5; // [rsp+28h] [rbp-10h]\n  int v6; // [rsp+2Ch] [rbp-Ch]\n  _BYTE *v7; // [rsp+30h] [rbp-8h]\n\n  v5 = 0;\n  v6 = 0;\n  v4 = 8;\n  v7 = *a1;\n  if ( **a1 == 120 )\n  {\n    ++v7;\n    v4 = 16;\n    v6 = 1;\n  }\n  while ( 1 )\n  {\n    v3 = (*v7 | 0x20) - 48;\n    if ( v3 > 9 )\n      v3 = (*v7 | 0x20) - 87;\n    if ( v3 >= v4 )\n      break;\n    if ( v4 * v5 + v3 <= 0xFF )\n    {\n      v5 = v4 * v5 + v3;\n      ++v7;\n      if ( (unsigned int)++v6 <= 2 )\n        continue;\n    }\n    goto LABEL_11;\n  }\n  if ( v4 == 16 && !--v6 )\n    return 92LL;\nLABEL_11:\n  if ( !v6 )\n  {\n    v2 = \"abefnrtv\\\\\";\n    while ( *v2 != *v7 )\n    {\n      if ( !*++v2 )\n        goto LABEL_16;\n    }\n    ++v7;\nLABEL_16:\n    v5 = v2[10];\n  }\n  *a1 = v7;\n  return v5;\n}\n\n\n Revised code:\nchar FAST_FUNC bb_process_escape_sequence(const char **ptr)\n{\n\tconst char *q;\n\tunsigned num_digits;\n\tunsigned n;\n\tunsigned base;\n\n\tnum_digits = n = 0;\n\tbase = 8;\n\tq = *ptr;\n\n\tif (WANT_HEX_ESCAPES && *q == 'x') {\n\t\t++q;\n\t\tbase = 16;\n\t\t++num_digits;\n\t}\n\n\t/* bash requires leading 0 in octal escapes:\n\t * \\02 works, \\2 does not (prints \\ and 2).\n\t * We treat \\2 as a valid octal escape sequence. */\n\tdo {\n\t\tunsigned r;\n#if !WANT_HEX_ESCAPES\n\t\tunsigned d = (unsigned char)(*q) - '0';\n#else\n\t\tunsigned d = (unsigned char)_tolower(*q) - '0';\n\t\tif (d >= 10)\n\t\t\td += ('0' - 'a' + 10);\n#endif\n\t\tif (d >= base) {\n\t\t\tif (WANT_HEX_ESCAPES && base == 16) {\n\t\t\t\t--num_digits;\n\t\t\t\tif (num_digits == 0) {\n\t\t\t\t\t/* \\x<bad_char>: return '\\',\n\t\t\t\t\t * leave ptr pointing to x */\n\t\t\t\t\treturn '\\\\';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tr = n * base + d;\n\t\tif (r > UCHAR_MAX) {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = r;\n\t\t++q;\n\t} while (++num_digits < 3);\n\n\tif (num_digits == 0) {\n\t\t/* Not octal or hex escape sequence.\n\t\t * Is it one-letter one? */\n\n\t\t/* bash builtin \"echo -e '\\ec'\" interprets \\e as ESC,\n\t\t * but coreutils \"/bin/echo -e '\\ec'\" does not.\n\t\t * Manpages tend to support coreutils way.\n\t\t * Update: coreutils added support for \\e on 28 Oct 2009. */\n\t\tstatic const char charmap[] ALIGN1 = {\n\t\t\t'a',  'b', 'e', 'f',  'n',  'r',  't',  'v',  '\\\\', '\\0',\n\t\t\t'\\a', '\\b', 27, '\\f', '\\n', '\\r', '\\t', '\\v', '\\\\', '\\\\',\n\t\t};\n\t\tconst char *p = charmap;\n\t\tdo {\n\t\t\tif (*p == *q) {\n\t\t\t\tq++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (*++p != '\\0');\n\t\t/* p points to found escape char or NUL,\n\t\t * advance it and find what it translates to.\n\t\t * Note that \\NUL and unrecognized sequence \\z return '\\'\n\t\t * and leave ptr pointing to NUL or z. */\n\t\tn = p[sizeof(charmap) / 2];\n\t}\n\n\t*ptr = q;\n\n\treturn (char) n;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E8C0A(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  unsigned int v7; // [rsp+Ch] [rbp-14h]\n  char v8; // [rsp+13h] [rbp-Dh]\n  int v9; // [rsp+14h] [rbp-Ch]\n  int v10; // [rsp+18h] [rbp-8h]\n  int v11; // [rsp+1Ch] [rbp-4h]\n\n  v7 = a1;\n  v11 = -1;\n  v10 = 0;\n  v9 = 0;\n  if ( a1 < 0 )\n  {\n    v11 = -2;\n    v7 = -a1;\n  }\n  while ( 1 )\n  {\n    v8 = *(_BYTE *)(v9 + a2);\n    if ( !v8 )\n      sub_40969E(\"unmatched '%c'\", v7, v9, a4, a5, a6);\n    if ( v11 >= 0 )\n    {\n      if ( v8 == 93 && v11 != v9 - 1 && (v11 != v9 - 2 || *(_BYTE *)(v9 - 1LL + a2) != 94) )\n        v11 = -1;\n      goto LABEL_18;\n    }\n    if ( v10 )\n    {\n      v10 = 0;\n      goto LABEL_18;\n    }\n    if ( v8 == 92 )\n    {\n      v10 = 1;\n      goto LABEL_18;\n    }\n    if ( v11 == -1 && v8 == 91 )\n    {\n      v11 = v9;\n      goto LABEL_18;\n    }\n    if ( v7 == v8 )\n      return (unsigned int)v9;\nLABEL_18:\n    ++v9;\n  }\n}\n\n\n Revised code:\nstatic int index_of_next_unescaped_regexp_delim(int delimiter, const char *str)\n{\n\tint bracket = -1;\n\tint escaped = 0;\n\tint idx = 0;\n\tchar ch;\n\n\tif (delimiter < 0) {\n\t\tbracket--;\n\t\tdelimiter = -delimiter;\n\t}\n\n\tfor (; (ch = str[idx]) != '\\0'; idx++) {\n\t\tif (bracket >= 0) {\n\t\t\tif (ch == ']'\n\t\t\t && !(bracket == idx - 1 || (bracket == idx - 2 && str[idx - 1] == '^'))\n\t\t\t) {\n\t\t\t\tbracket = -1;\n\t\t\t}\n\t\t} else if (escaped)\n\t\t\tescaped = 0;\n\t\telse if (ch == '\\\\')\n\t\t\tescaped = 1;\n\t\telse if (bracket == -1 && ch == '[')\n\t\t\tbracket = idx;\n\t\telse if (ch == delimiter)\n\t\t\treturn idx;\n\t}\n\n\t/* if we make it to here, we've hit the end of the string */\n\tbb_error_msg_and_die(\"unmatched '%c'\", delimiter);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_42F1F5(char *a1, _WORD *a2)\n{\n  _BYTE *v3; // rax\n  char v5; // [rsp+1Eh] [rbp-12h]\n  char v6; // [rsp+1Eh] [rbp-12h]\n  char v7; // [rsp+1Fh] [rbp-11h]\n  int v8; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+24h] [rbp-Ch]\n  _WORD *v10; // [rsp+28h] [rbp-8h]\n\n  *a2 = 1;\n  v10 = a2 + 1;\n  for ( i = 0; i <= 5; ++i )\n  {\n    v7 = 0;\n    v8 = 0;\n    if ( i && *a1 == 58 )\n      ++a1;\n    while ( 1 )\n    {\n      v5 = *a1;\n      if ( (unsigned __int8)(*a1 - 48) > 9u )\n        break;\n      v6 = v5 - 48;\nLABEL_13:\n      ++a1;\n      v7 = v6 + 16 * v7;\n      if ( ++v8 > 1 )\n        goto LABEL_14;\n    }\n    if ( (unsigned __int8)((v5 | 0x20) - 97) <= 5u )\n    {\n      v6 = (v5 | 0x20) - 87;\n      goto LABEL_13;\n    }\n    if ( !v8 || v5 != 58 && v5 )\n      return 0xFFFFFFFFLL;\nLABEL_14:\n    v3 = v10;\n    v10 = (_WORD *)((char *)v10 + 1);\n    *v3 = v7;\n  }\n  return (unsigned int)*a1;\n}\n"
    },
    {
        "func_name": "die_if_nologin",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_BOOL8 sub_4F3AAF()\n{\n  int v1; // [rsp+Ch] [rbp-14h]\n  FILE *stream; // [rsp+10h] [rbp-10h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  stream = (FILE *)sub_40984D((__int64)\"/dev/tty\");\n  fwrite_unlocked(\" ?...\", 1uLL, 5uLL, stderr);\n  sub_40A649();\n  v1 = getc_unlocked(stream);\n  for ( i = v1; i != -1 && i != 10; i = getc_unlocked(stream) )\n    ;\n  fclose(stream);\n  return v1 == 121 || v1 == 89;\n}\n\n\n Revised code:\nstatic int xargs_ask_confirmation(void)\n{\n\tFILE *tty_stream;\n\tint c, savec;\n\n\ttty_stream = xfopen_for_read(CURRENT_TTY);\n\tfputs(\" ?...\", stderr);\n\tfflush_all();\n\tc = savec = getc(tty_stream);\n\twhile (c != EOF && c != '\\n')\n\t\tc = getc(tty_stream);\n\tfclose(tty_stream);\n\treturn (savec == 'y' || savec == 'Y');\n}\n\n## Example:\n\n Input code:\n__int64 sub_4F9E45()\n{\n  int v1; // [rsp+Ch] [rbp-114h] BYREF\n  char s[3]; // [rsp+10h] [rbp-110h] BYREF\n  char v3[253]; // [rsp+13h] [rbp-10Dh] BYREF\n  FILE *stream; // [rsp+110h] [rbp-10h]\n  int v5; // [rsp+11Ch] [rbp-4h]\n\n  v5 = -1;\n  stream = (FILE *)sub_40984D((__int64)\"/proc/stat\");\n  while ( fgets_unlocked(s, 256, stream) )\n  {\n    if ( sub_4F9E00(s) )\n    {\n      if ( v3[0] != 32 && sscanf(v3, \"%u\", &v1) == 1 && v5 < v1 )\n        v5 = v1;\n    }\n    else if ( v5 >= 0 )\n    {\n      break;\n    }\n  }\n  fclose(stream);\n  return (unsigned int)(v5 + 1);\n}\n\n\n Revised code:\nunsigned FAST_FUNC get_cpu_count(void)\n{\n\tFILE *fp;\n\tchar line[256];\n\tint proc_nr = -1;\n\n\tfp = xfopen_for_read(\"/proc/stat\");\n\twhile (fgets(line, sizeof(line), fp)) {\n\t\tif (!starts_with_cpu(line)) {\n\t\t\tif (proc_nr >= 0)\n\t\t\t\tbreak; /* we are past \"cpuN...\" lines */\n\t\t\tcontinue;\n\t\t}\n\t\tif (line[3] != ' ') { /* \"cpuN\" */\n\t\t\tint num_proc;\n\t\t\tif (sscanf(line + 3, \"%u\", &num_proc) == 1\n\t\t\t && num_proc > proc_nr\n\t\t\t) {\n\t\t\t\tproc_nr = num_proc;\n\t\t\t}\n\t\t}\n\t}\n\n\tfclose(fp);\n\treturn proc_nr + 1;\n}\n\n## Example:\n\n Input code:\n__int64 sub_46A465()\n{\n  int v1; // [rsp+8h] [rbp-8h]\n  int fd; // [rsp+Ch] [rbp-4h]\n  int fda; // [rsp+Ch] [rbp-4h]\n\n  fd = open64(\"supervise/ok\", 2049);\n  if ( fd == -1 )\n  {\n    if ( *(_DWORD *)qword_75D400 == 19 )\n    {\n      if ( **(_BYTE **)&dest.c_iflag == 120 )\n        sub_46A438(\"runsv not running\");\n      else\n        sub_46A3E2(\"runsv not running\");\n      return 0LL;\n    }\n    else\n    {\n      sub_46A40A(\"can't open supervise/ok\");\n      return 0xFFFFFFFFLL;\n    }\n  }\n  else\n  {\n    close(fd);\n    fda = open64(\"supervise/status\", 2048);\n    if ( fda == -1 )\n    {\n      sub_46A40A(\"can't open supervise/status\");\n      return 0xFFFFFFFFLL;\n    }\n    else\n    {\n      v1 = read(fda, &dest.c_cc[23], 0x14uLL);\n      close(fda);\n      if ( v1 == -1 )\n      {\n        sub_46A40A(\"can't read supervise/status\");\n        return 0xFFFFFFFFLL;\n      }\n      else if ( v1 == 20 )\n      {\n        return 1LL;\n      }\n      else\n      {\n        *(_DWORD *)qword_75D400 = 0;\n        sub_46A40A(\"can't read supervise/status: bad format\");\n        return 0xFFFFFFFFLL;\n      }\n    }\n  }\n}\n\n\n Revised code:\nstatic int svstatus_get(void)\n{\n\tint fd, r;\n\n\tfd = open(\"supervise/ok\", O_WRONLY|O_NDELAY);\n\tif (fd == -1) {\n\t\tif (errno == ENODEV) {\n\t\t\t*acts == 'x' ? ok(\"runsv not running\")\n\t\t\t             : failx(\"runsv not running\");\n\t\t\treturn 0;\n\t\t}\n\t\twarn(\"can't open supervise/ok\");\n\t\treturn -1;\n\t}\n\tclose(fd);\n\tfd = open(\"supervise/status\", O_RDONLY|O_NDELAY);\n\tif (fd == -1) {\n\t\twarn(\"can't open supervise/status\");\n\t\treturn -1;\n\t}\n\tr = read(fd, &svstatus, 20);\n\tclose(fd);\n\tswitch (r) {\n\tcase 20:\n\t\tbreak;\n\tcase -1:\n\t\twarn(\"can't read supervise/status\");\n\t\treturn -1;\n\tdefault:\n\t\terrno = 0;\n\t\twarn(\"can't read supervise/status: bad format\");\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nFILE *sub_40EDC4()\n{\n  FILE *result; // rax\n  int v1; // [rsp+Ch] [rbp-14h]\n  FILE *stream; // [rsp+10h] [rbp-10h]\n  int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = 1;\n  result = sub_40982E(\"/etc/nologin\");\n  stream = result;\n  if ( result )\n  {\n    while ( 1 )\n    {\n      v1 = getc_unlocked(stream);\n      if ( v1 == -1 )\n        break;\n      if ( v1 == 10 )\n        sub_40A659(13);\n      sub_40A659(v1);\n      v3 = 0;\n    }\n    if ( v3 )\n      puts(\"\\r\\nSystem closed for routine maintenance\\r\");\n    fclose(stream);\n    sub_40A649();\n    tcdrain(1);\n    exit(1);\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "huft_free_all",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4FB84B(__int64 a1, _QWORD *a2)\n{\n  __int64 v2; // rdx\n  __int64 result; // rax\n\n  sub_4FB084(a1, 0);\n  v2 = *(_QWORD *)(a1 + 88);\n  result = *(_QWORD *)(a1 + 80);\n  *a2 = result;\n  a2[1] = v2;\n  return result;\n}\n\n\n Revised code:\nvoid FAST_FUNC md5_end(void *digest, md5_ctx_t *context)\n{\n\tunsigned idx, padLen;\n\tunsigned char bits[8];\n\tunsigned char padding[64];\n\n\t/* Add padding followed by original length. */\n\tmemset(padding, 0, sizeof(padding));\n\tpadding[0] = 0x80;\n\t/* save number of bits */\n\tmemcpy32_cpu2le(bits, context->count, 8);\n\t/* pad out to 56 mod 64 */\n\tidx = (context->count[0] >> 3) & 0x3f;\n\tpadLen = (idx < 56) ? (56 - idx) : (120 - idx);\n\tmd5_hash(padding, padLen, context);\n\t/* append length (before padding) */\n\tmd5_hash(bits, 8, context);\n\n\t/* Store state in digest */\n\tmemcpy32_cpu2le(digest, context->state, 16);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4BA259(__int64 a1)\n{\n  __int64 result; // rax\n\n  *(_DWORD *)(a1 + 8) = sub_4F7534(\n                          *(unsigned int *)(a1 + 8),\n                          *(_QWORD *)(a1 + 24),\n                          *(unsigned int *)(a1 + 16),\n                          *(_QWORD *)(a1 + 32));\n  result = a1;\n  *(_QWORD *)a1 += *(unsigned int *)(a1 + 16);\n  return result;\n}\n\n\n Revised code:\nstatic void calculate_gunzip_crc(STATE_PARAM_ONLY)\n{\n\tgunzip_crc = crc32_block_endian0(gunzip_crc, gunzip_window, gunzip_outbuf_count, gunzip_crc_table);\n\tgunzip_bytes_out += gunzip_outbuf_count;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4FB7CE(__int64 a1)\n{\n  __int64 result; // rax\n\n  *(_DWORD *)(a1 + 80) = 1732584193;\n  *(_DWORD *)(a1 + 84) = -271733879;\n  *(_DWORD *)(a1 + 88) = -1732584194;\n  *(_DWORD *)(a1 + 92) = 271733878;\n  *(_QWORD *)(a1 + 72) = 0LL;\n  result = a1;\n  *(_QWORD *)(a1 + 64) = sub_4FB13E;\n  return result;\n}\n\n\n Revised code:\nvoid FAST_FUNC md5_begin(md5_ctx_t *context)\n{\n\tcontext->count[0] = context->count[1] = 0;\n\t/* Load magic initialization constants.  */\n\tcontext->state[0] = 0x67452301;\n\tcontext->state[1] = 0xefcdab89;\n\tcontext->state[2] = 0x98badcfe;\n\tcontext->state[3] = 0x10325476;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4B882D(__int64 a1)\n{\n  __int64 result; // rax\n\n  sub_4B87F0(*(_QWORD *)(a1 + 96));\n  sub_4B87F0(*(_QWORD *)(a1 + 104));\n  *(_QWORD *)(a1 + 96) = 0LL;\n  result = a1;\n  *(_QWORD *)(a1 + 104) = 0LL;\n  return result;\n}\n"
    },
    {
        "func_name": "get_fill",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_50906E(_BYTE *a1, unsigned int a2)\n{\n  int v3; // [rsp+0h] [rbp-1Ch]\n  unsigned int v4; // [rsp+10h] [rbp-Ch]\n  int v5; // [rsp+14h] [rbp-8h]\n  int i; // [rsp+18h] [rbp-4h]\n\n  v3 = a2;\n  v4 = a2;\n  if ( a2 > 0x7F )\n  {\n    for ( i = 2; v4 > 0x7FF && i <= 5; ++i )\n      v4 >>= 5;\n    v5 = i;\n    while ( --v5 )\n    {\n      a1[v5] = v3 & 0x3F | 0x80;\n      v3 >>= 6;\n    }\n    *a1 = v3 | (16128 >> i);\n    return i;\n  }\n  else\n  {\n    *a1 = a2;\n    return 1LL;\n  }\n}\n\n\n Revised code:\nendif\n\nstatic size_t wcrtomb_internal(char *s, wchar_t wc)\n{\n\tint n, i;\n\tuint32_t v = wc;\n\n\tif (v <= 0x7f) {\n\t\t*s = v;\n\t\treturn 1;\n\t}\n\n\t/* RFC 3629 says that Unicode ends at 10FFFF,\n\t * but we cover entire 32 bits */\n\n\t/* 4000000-FFFFFFFF -> 111111tt 10tttttt 10zzzzzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\t/* 200000-3FFFFFF -> 111110tt 10zzzzzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\t/* 10000-1FFFFF -> 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx */\n\t/* 800-FFFF -> 1110yyyy 10yyyyxx 10xxxxxx */\n\t/* 80-7FF -> 110yyyxx 10xxxxxx */\n\n\t/* How many bytes do we need? */\n\tn = 2;\n\t/* (0x80000000+ would result in n = 7, limiting n to 6) */\n\twhile (v >= 0x800 && n < 6) {\n\t\tv >>= 5;\n\t\tn++;\n\t}\n\t/* Fill bytes n-1..1 */\n\ti = n;\n\twhile (--i) {\n\t\ts[i] = (wc & 0x3f) | 0x80;\n\t\twc >>= 6;\n\t}\n\t/* Fill byte 0 */\n\ts[0] = wc | (uint8_t)(0x3f00 >> n);\n\treturn n;\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_45845B(const void *a1, int a2, int a3, __int64 a4, int a5)\n{\n  unsigned int v7; // [rsp+4h] [rbp-2Ch]\n  char *s; // [rsp+20h] [rbp-10h]\n  char *i; // [rsp+28h] [rbp-8h]\n\n  sub_458394(a1, a2);\n  s = (char *)sub_4582F6();\n  if ( s )\n  {\n    memset(s, 0, 0x24uLL);\n    if ( a4 )\n    {\n      v7 = a5 + 1;\n      if ( v7 > 0x14 )\n        v7 = 20;\n      for ( i = (char *)sub_507FC0(s + 14, a4, (int)v7); *i; ++i )\n      {\n        if ( *i <= 31 || *i == 127 )\n          *i = 94;\n      }\n    }\n    if ( a1 )\n      memcpy(s + 8, a1, 6uLL);\n    *((_DWORD *)s + 1) = a2;\n    *(_DWORD *)s = a3 + time(0LL);\n  }\n  return s;\n}\n\n\n Revised code:\nFAST_FUNC add_lease(\n\t\tconst uint8_t *chaddr, uint32_t yiaddr,\n\t\tleasetime_t leasetime,\n\t\tconst char *hostname, int hostname_len)\n{\n\tstruct dyn_lease *oldest;\n\n\t/* clean out any old ones */\n\tclear_leases(chaddr, yiaddr);\n\n\toldest = oldest_expired_lease();\n\n\tif (oldest) {\n\t\tmemset(oldest, 0, sizeof(*oldest));\n\t\tif (hostname) {\n\t\t\tchar *p;\n\n\t\t\thostname_len++; /* include NUL */\n\t\t\tif (hostname_len > sizeof(oldest->hostname))\n\t\t\t\thostname_len = sizeof(oldest->hostname);\n\t\t\tp = safe_strncpy(oldest->hostname, hostname, hostname_len);\n\t\t\t/* sanitization (s/non-ASCII/^/g) */\n\t\t\twhile (*p) {\n\t\t\t\tif (*p < ' ' || *p > 126)\n\t\t\t\t\t*p = '^';\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\t\tif (chaddr)\n\t\t\tmemcpy(oldest->lease_mac, chaddr, 6);\n\t\toldest->lease_nip = yiaddr;\n\t\toldest->expires = time(NULL) + leasetime;\n\t}\n\n\treturn oldest;\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_4DA65D(const char *a1, __int64 a2)\n{\n  char *ptr; // [rsp+10h] [rbp-10h]\n  char *s1; // [rsp+18h] [rbp-8h]\n  char *s1a; // [rsp+18h] [rbp-8h]\n  char *s1b; // [rsp+18h] [rbp-8h]\n\n  ptr = sub_40A11F(a1, a2);\n  s1 = sub_40941B(ptr);\n  if ( s1 != ptr )\n  {\n    if ( *s1 == 109 && s1[1] == 100 )\n    {\n      s1[2] = 0;\n      return ptr;\n    }\n    if ( !strncmp(s1, \"rd/\", 3uLL) )\n    {\n      s1a = s1 + 3;\n      if ( *s1a == 99 && (unsigned __int8)(s1a[1] - 48) <= 9u && s1a[2] == 100 && (unsigned __int8)(s1a[3] - 48) <= 9u )\n      {\n        s1a[4] = 0;\n        return ptr;\n      }\n    }\n    else if ( (*s1 == 104 || *s1 == 115) && s1[1] == 100 )\n    {\n      s1b = s1 + 2;\n      if ( (unsigned __int8)(*s1b - 48) <= 9u )\n        ++s1b;\n      if ( (unsigned __int8)((*s1b | 0x20) - 97) <= 0x19u )\n      {\n        s1b[1] = 0;\n        return ptr;\n      }\n    }\n  }\n  free(ptr);\n  return 0LL;\n}\n\n\n Revised code:\nendif\n\nstatic char *base_device(const char *device)\n{\n\tchar *str, *cp;\n#if ENABLE_FEATURE_DEVFS\n\tconst char *const *hier;\n\tconst char *disk;\n\tint len;\n#endif\n\tstr = xstrdup(device);\n\n\t/* Skip over \"/dev/\"; if it's not present, give up */\n\tcp = skip_dev_pfx(str);\n\tif (cp == str)\n\t\tgoto errout;\n\n\t/*\n\t * For md devices, we treat them all as if they were all\n\t * on one disk, since we don't know how to parallelize them.\n\t */\n\tif (cp[0] == 'm' && cp[1] == 'd') {\n\t\tcp[2] = 0;\n\t\treturn str;\n\t}\n\n\t/* Handle DAC 960 devices */\n\tif (strncmp(cp, \"rd/\", 3) == 0) {\n\t\tcp += 3;\n\t\tif (cp[0] != 'c' || !isdigit(cp[1])\n\t\t || cp[2] != 'd' || !isdigit(cp[3]))\n\t\t\tgoto errout;\n\t\tcp[4] = 0;\n\t\treturn str;\n\t}\n\n\t/* Now let's handle /dev/hd* and /dev/sd* devices.... */\n\tif ((cp[0] == 'h' || cp[0] == 's') && cp[1] == 'd') {\n\t\tcp += 2;\n\t\t/* If there's a single number after /dev/hd, skip it */\n\t\tif (isdigit(*cp))\n\t\t\tcp++;\n\t\t/* What follows must be an alpha char, or give up */\n\t\tif (!isalpha(*cp))\n\t\t\tgoto errout;\n\t\tcp[1] = 0;\n\t\treturn str;\n\t}\n\n#if ENABLE_FEATURE_DEVFS\n\t/* Now let's handle devfs (ugh) names */\n\tlen = 0;\n\tif (strncmp(cp, \"ide/\", 4) == 0)\n\t\tlen = 4;\n\tif (strncmp(cp, \"scsi/\", 5) == 0)\n\t\tlen = 5;\n\tif (len) {\n\t\tcp += len;\n\t\t/*\n\t\t * Now we proceed down the expected devfs hierarchy.\n\t\t * i.e., .../host1/bus2/target3/lun4/...\n\t\t * If we don't find the expected token, followed by\n\t\t * some number of digits at each level, abort.\n\t\t */\n\t\tfor (hier = devfs_hier; *hier; hier++) {\n\t\t\tlen = strlen(*hier);\n\t\t\tif (strncmp(cp, *hier, len) != 0)\n\t\t\t\tgoto errout;\n\t\t\tcp += len;\n\t\t\twhile (*cp != '/' && *cp != 0) {\n\t\t\t\tif (!isdigit(*cp))\n\t\t\t\t\tgoto errout;\n\t\t\t\tcp++;\n\t\t\t}\n\t\t\tcp++;\n\t\t}\n\t\tcp[-1] = 0;\n\t\treturn str;\n\t}\n\n\t/* Now handle devfs /dev/disc or /dev/disk names */\n\tdisk = 0;\n\tif (strncmp(cp, \"discs/\", 6) == 0)\n\t\tdisk = \"disc\";\n\telse if (strncmp(cp, \"disks/\", 6) == 0)\n\t\tdisk = \"disk\";\n\tif (disk) {\n\t\tcp += 6;\n\t\tif (strncmp(cp, disk, 4) != 0)\n\t\t\tgoto errout;\n\t\tcp += 4;\n\t\twhile (*cp != '/' && *cp != 0) {\n\t\t\tif (!isdigit(*cp))\n\t\t\t\tgoto errout;\n\t\t\tcp++;\n\t\t}\n\t\t*cp = 0;\n\t\treturn str;\n\t}\n#endif\n errout:\n\tfree(str);\n\treturn NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_428EE6(char *a1, const void *a2, int a3)\n{\n  char *s; // [rsp+18h] [rbp-18h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  memset(a1, 255, 6uLL);\n  if ( !a3 )\n    memcpy(a1, a2, 6uLL);\n  memcpy(a1 + 6, a2, 6uLL);\n  a1[12] = 8;\n  s = a1 + 14;\n  a1[13] = 66;\n  memset(a1 + 14, 255, 6uLL);\n  for ( i = 0; i <= 15; ++i )\n  {\n    s += 6;\n    memcpy(s, a2, 6uLL);\n  }\n  return 116LL;\n}\n"
    },
    {
        "func_name": "rtnl_send",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_42FB55(const char *a1, int a2)\n{\n  char v3[16]; // [rsp+10h] [rbp-30h] BYREF\n  int v4; // [rsp+20h] [rbp-20h]\n\n  v4 = a2;\n  return sub_42FA47(0x8922u, v3, a1);\n}\n\n\n Revised code:\nstatic int set_mtu(char *ifname, int mtu)\n{\n\tstruct ifreq ifr;\n\n\tifr.ifr_mtu = mtu;\n\treturn set_ifrname_and_do_ioctl(SIOCSIFMTU, &ifr, ifname);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_42FB81(const char *a1, __int16 a2)\n{\n  char v3[16]; // [rsp+10h] [rbp-30h] BYREF\n  __int16 v4; // [rsp+20h] [rbp-20h]\n\n  v4 = a2;\n  return sub_42FA47(0x8914u, v3, a1);\n}\n\n\n Revised code:\nstatic int set_if_flags(char *ifname, int flags)\n{\n\tstruct ifreq ifr;\n\n\tifr.ifr_flags = flags;\n\treturn set_ifrname_and_do_ioctl(SIOCSIFFLAGS, &ifr, ifname);\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_464629(const char *a1, unsigned int a2, unsigned int a3, int a4)\n{\n  char s[32]; // [rsp+20h] [rbp-20h] BYREF\n\n  sprintf(s, \"{%.*s}\", 14, a1);\n  return sub_463FF0(s, a2, a3, a4);\n}\n\n\n Revised code:\nif ENABLE_FEATURE_SHOW_THREADS\nstatic void handle_thread(const char *comm, pid_t pid, pid_t ppid, uid_t uid)\n{\n\tchar threadname[COMM_LEN + 2];\n\tsprintf(threadname, \"{%.*s}\", COMM_LEN - 2, comm);\n\tadd_proc(threadname, pid, ppid, uid/*, 1*/);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nssize_t __fastcall sub_450FC2(int *a1, const void *a2, int a3)\n{\n  __int16 s[6]; // [rsp+24h] [rbp-Ch] BYREF\n\n  memset(s, 0, sizeof(s));\n  s[0] = 16;\n  return sub_40AA48(*a1, a2, a3, (const struct sockaddr *)s, 0xCu);\n}\n"
    },
    {
        "func_name": "act",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_46328D(char *a1, int a2, __int64 a3)\n{\n  return sprintf(a1, \"%*u\", a2, *(unsigned int *)(a3 + 88));\n}\n\n\n Revised code:\nstatic void func_pid(char *buf, int size, const procps_status_t *ps)\n{\n\tsprintf(buf, \"%*u\", size, ps->pid);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_4632F9(char *a1, int a2, __int64 a3)\n{\n  return sprintf(a1, \"%*u\", a2, *(unsigned int *)(a3 + 96));\n}\n\n\n Revised code:\nstatic void func_pgid(char *buf, int size, const procps_status_t *ps)\n{\n\tsprintf(buf, \"%*u\", size, ps->pgid);\n}\n\n## Example:\n\n Input code:\nint __fastcall sub_4634D4(char *a1, int a2, __int64 a3)\n{\n  return sprintf(a1, \"%*d\", a2, *(unsigned int *)(a3 + 120));\n}\n\n\n Revised code:\nstatic void func_nice(char *buf, int size, const procps_status_t *ps)\n{\n\tsprintf(buf, \"%*d\", size, ps->niceness);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_461320(unsigned int a1, const char *a2, int a3)\n{\n  if ( ident[1] != 103 )\n    return kill(a1, a3);\n  if ( (dword_75D450 & 2) != 0 )\n    return printf(\"%d %s\\n\", a1, a2);\n  return printf(\"%d\\n\", a1);\n}\n"
    },
    {
        "func_name": "read_staticlease",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_43A44B(const char *a1)\n{\n  char s[4]; // [rsp+10h] [rbp-60h] BYREF\n  int v3; // [rsp+14h] [rbp-5Ch]\n  int v4; // [rsp+18h] [rbp-58h]\n\n  memset(s, 0, 0x60uLL);\n  if ( (unsigned int)sub_43A1E5((__int64)s, a1) )\n    return 1LL;\n  sub_43A2EA((__int64)s, (const char *)*(&off_519F20 + v4), \"tcp\", v3);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC tcp_do_one(char *line)\n{\n\tstruct inet_params param;\n\n\tmemset(&param, 0, sizeof(param));\n\tif (scan_inet_proc_line(&param, line))\n\t\treturn 1;\n\n\tprint_inet_line(&param, tcp_state[param.state], \"tcp\", param.rem_port);\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_450D10(const char **a1)\n{\n  const char *v1; // rax\n  uint32_t v3[10]; // [rsp+10h] [rbp-40h] BYREF\n  char v4; // [rsp+39h] [rbp-17h]\n\n  sub_44F8E2(a1, 35312, v3);\n  switch ( v4 )\n  {\n    case 41:\n      if ( LOBYTE(v3[0]) )\n        v1 = (const char *)v3;\n      else\n        v1 = \"sit0\";\n      break;\n    case 47:\n      if ( LOBYTE(v3[0]) )\n        v1 = (const char *)v3;\n      else\n        v1 = \"gre0\";\n      break;\n    case 4:\n      if ( LOBYTE(v3[0]) )\n        v1 = (const char *)v3;\n      else\n        v1 = \"tunl0\";\n      break;\n    default:\n      sub_450A1E((__int64)v3);\n      return 0LL;\n  }\n  if ( (unsigned int)sub_44F731(v1, (__int64)v3) )\n    return 0xFFFFFFFFLL;\n  sub_450589((__int64)v3);\n  sub_40A659(10);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int do_show(char **argv)\n{\n\tint err;\n\tstruct ip_tunnel_parm p;\n\n\tparse_args(argv, SIOCGETTUNNEL, &p);\n\n\tswitch (p.iph.protocol) {\n\tcase IPPROTO_IPIP:\n\t\terr = do_get_ioctl(p.name[0] ? p.name : \"tunl0\", &p);\n\t\tbreak;\n\tcase IPPROTO_GRE:\n\t\terr = do_get_ioctl(p.name[0] ? p.name : \"gre0\", &p);\n\t\tbreak;\n\tcase IPPROTO_IPV6:\n\t\terr = do_get_ioctl(p.name[0] ? p.name : \"sit0\", &p);\n\t\tbreak;\n\tdefault:\n\t\tdo_tunnels_list(&p);\n\t\treturn 0;\n\t}\n\tif (err)\n\t\treturn -1;\n\n\tprint_tunnel(&p);\n\tbb_putchar('\\n');\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4318BD(const char *a1)\n{\n  uint32_t v2; // eax\n  struct in_addr inp; // [rsp+14h] [rbp-Ch] BYREF\n  unsigned int v4; // [rsp+18h] [rbp-8h]\n  unsigned int v5; // [rsp+1Ch] [rbp-4h]\n\n  if ( !inet_aton(a1, &inp) )\n    return 0xFFFFFFFFLL;\n  v2 = ntohl(inp.s_addr);\n  v4 = ~v2;\n  if ( (~v2 & -v2) != 0 )\n    return 0xFFFFFFFFLL;\n  v5 = 32;\n  while ( v4 )\n  {\n    v4 >>= 1;\n    --v5;\n  }\n  return v5;\n}\n\n\n Revised code:\nif ENABLE_FEATURE_IFUPDOWN_IP\nstatic int count_netmask_bits(const char *dotted_quad)\n{\n//\tint result;\n//\tunsigned a, b, c, d;\n//\t/* Found a netmask...  Check if it is dotted quad */\n//\tif (sscanf(dotted_quad, \"%u.%u.%u.%u\", &a, &b, &c, &d) != 4)\n//\t\treturn -1;\n//\tif ((a|b|c|d) >> 8)\n//\t\treturn -1; /* one of numbers is >= 256 */\n//\td |= (a << 24) | (b << 16) | (c << 8); /* IP */\n//\td = ~d; /* 11110000 -> 00001111 */\n\n\t/* Shorter version */\n\tint result;\n\tstruct in_addr ip;\n\tunsigned d;\n\n\tif (inet_aton(dotted_quad, &ip) == 0)\n\t\treturn -1; /* malformed dotted IP */\n\td = ntohl(ip.s_addr); /* IP in host order */\n\td = ~d; /* 11110000 -> 00001111 */\n\tif (d & (d+1)) /* check that it is in 00001111 form */\n\t\treturn -1; /* no it is not */\n\tresult = 32;\n\twhile (d) {\n\t\td >>= 1;\n\t\tresult--;\n\t}\n\treturn result;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_457D21(char *a1, __int64 a2)\n{\n  unsigned int v3; // [rsp+1Ch] [rbp-24h] BYREF\n  struct ether_addr addr; // [rsp+22h] [rbp-1Eh] BYREF\n  char *s; // [rsp+28h] [rbp-18h] BYREF\n  char *v6; // [rsp+30h] [rbp-10h]\n  char *asc; // [rsp+38h] [rbp-8h]\n\n  s = a1;\n  asc = strtok_r(a1, \" \\t\", &s);\n  if ( !asc || !ether_aton_r(asc, &addr) )\n    return 0LL;\n  v6 = strtok_r(0LL, \" \\t\", &s);\n  if ( !v6 || !(unsigned int)sub_459D25(v6, &v3) )\n    return 0LL;\n  sub_4593BC(a2, &addr, v3);\n  sub_4594BA(a2);\n  return 1LL;\n}\n"
    },
    {
        "func_name": "decode_format_string",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47A87E(const char **a1, __int64 a2)\n{\n  const char **v2; // rax\n  char **v3; // rbx\n  __int64 result; // rax\n  const char **v5; // [rsp+8h] [rbp-38h]\n  char **v6; // [rsp+18h] [rbp-28h]\n  int i; // [rsp+24h] [rbp-1Ch]\n  char **v8; // [rsp+28h] [rbp-18h]\n\n  v5 = a1;\n  for ( i = 0; a1[i]; ++i )\n    ;\n  v6 = (char **)sub_40A05F(8LL * (i + 1), a2);\n  v8 = v6;\n  while ( *v5 )\n  {\n    v2 = v5++;\n    v3 = v8++;\n    *v3 = sub_40A11F(*v2, a2);\n  }\n  *v8 = 0LL;\n  sub_46F1BA(qword_75D420);\n  *(_BYTE *)(qword_75D420 + 12) = 1;\n  *(_DWORD *)qword_75D420 = i;\n  *(_QWORD *)(qword_75D420 + 16) = v6;\n  *(_DWORD *)(qword_75D420 + 4) = 1;\n  result = qword_75D420;\n  *(_DWORD *)(qword_75D420 + 8) = -1;\n  return result;\n}\n\n\n Revised code:\nstatic void\nsetparam(char **argv)\n{\n\tchar **newparam;\n\tchar **ap;\n\tint nparam;\n\n\tfor (nparam = 0; argv[nparam]; nparam++)\n\t\tcontinue;\n\tap = newparam = ckmalloc((nparam + 1) * sizeof(*ap));\n\twhile (*argv) {\n\t\t*ap++ = ckstrdup(*argv++);\n\t}\n\t*ap = NULL;\n\tfreeparam(&shellparam);\n\tshellparam.malloced = 1;\n\tshellparam.nparam = nparam;\n\tshellparam.p = newparam;\n#if ENABLE_ASH_GETOPTS\n\tshellparam.optind = 1;\n\tshellparam.optoff = -1;\n#endif\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47DDA0(char *a1, __int64 a2)\n{\n  char *v2; // rbx\n  unsigned __int64 v3; // rdi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  char v7[8]; // [rsp+10h] [rbp-40h] BYREF\n  __int64 v8; // [rsp+18h] [rbp-38h]\n  char *v9; // [rsp+20h] [rbp-30h]\n  __int64 v10; // [rsp+28h] [rbp-28h]\n\n  sub_47A810(a1, a2);\n  v2 = (char *)(qword_75D418 + 56);\n  v3 = (unsigned int)sub_47A4AE(a1, a2);\n  sub_47C5D6(v3, 4LL, v2, 0LL, v4, v5);\n  sub_47A5E5(v3, 4LL);\n  v7[0] = 15;\n  v8 = 0LL;\n  v9 = qword_75B068;\n  v10 = qword_75B070;\n  sub_4768BC((__int64)v7, 0LL, 0);\n  return *(_QWORD *)(qword_75D428 + 16);\n}\n\n\n Revised code:\nif ENABLE_ASH_EXPAND_PRMT\nstatic const char *\nexpandstr(const char *ps)\n{\n\tunion node n;\n\n\t/* XXX Fix (char *) cast. It _is_ a bug. ps is variable's value,\n\t * and token processing _can_ alter it (delete NULs etc). */\n\tsetinputstring((char *)ps);\n\treadtoken1(pgetc(), PSSYNTAX, nullstr, 0);\n\tpopfile();\n\n\tn.narg.type = NARG;\n\tn.narg.next = NULL;\n\tn.narg.text = wordtext;\n\tn.narg.backquote = backquotelist;\n\n\texpandarg(&n, NULL, 0);\n\treturn stackblock();\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_473F3A(unsigned __int8 *a1, unsigned __int64 a2, char a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  unsigned __int64 v6; // rax\n  unsigned __int8 *v7; // rax\n  _BYTE *v8; // rax\n  unsigned __int8 *v9; // rax\n  __int64 result; // rax\n  int v12; // [rsp+8h] [rbp-28h]\n  unsigned __int64 v14; // [rsp+10h] [rbp-20h]\n  int v16; // [rsp+20h] [rbp-10h]\n  unsigned __int8 v17; // [rsp+27h] [rbp-9h]\n  __int64 v18; // [rsp+28h] [rbp-8h]\n\n  v14 = a2;\n  v12 = a4;\n  if ( (_DWORD)a4 )\n    v6 = 2 * a2;\n  else\n    v6 = a2;\n  v18 = sub_46ECB9(v6, qword_75AFC8, qword_75AFC8, a4, a5, a6);\n  while ( v14-- )\n  {\n    v7 = a1++;\n    v17 = *v7;\n    if ( *v7 )\n    {\n      if ( v12 )\n      {\n        v16 = sub_4704BD(v17, a3);\n        if ( v16 == 12 || v16 == 2 )\n        {\n          v8 = (_BYTE *)v18++;\n          *v8 = -127;\n        }\n      }\n      v9 = (unsigned __int8 *)v18++;\n      *v9 = v17;\n    }\n  }\n  result = v18;\n  qword_75AFC8 = v18;\n  return result;\n}\n\n\n Revised code:\nstatic void\nmemtodest(const char *p, size_t len, int syntax, int quotes)\n{\n\tchar *q = expdest;\n\n\tq = makestrspace(quotes ? len * 2 : len, q);\n\n\twhile (len--) {\n\t\tunsigned char c = *p++;\n\t\tif (c == '\\0')\n\t\t\tcontinue;\n\t\tif (quotes) {\n\t\t\tint n = SIT(c, syntax);\n\t\t\tif (n == CCTL || n == CBACK)\n\t\t\t\tUSTPUTC(CTLESC, q);\n\t\t}\n\t\tUSTPUTC(c, q);\n\t}\n\n\texpdest = q;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4CE68B(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 result; // rax\n  char *v7; // [rsp+8h] [rbp-38h]\n  char src[32]; // [rsp+10h] [rbp-30h] BYREF\n  const char *v9; // [rsp+30h] [rbp-10h]\n  __int64 v10; // [rsp+38h] [rbp-8h]\n\n  v7 = (char *)a1;\n  v10 = a1;\n  while ( 1 )\n  {\n    result = (unsigned __int8)*v7;\n    if ( !(_BYTE)result )\n      break;\n    v9 = sub_4CE217(v10, v7, (__int64)src, (__int64)v7, a5, a6);\n    v7 = (char *)v9;\n    qword_75B218 = sub_50C0E1(qword_75B218, 8196LL, (unsigned int)qword_75B210);\n    memcpy((void *)(qword_75B218 + 32 * qword_75B210), src, 0x20uLL);\n    ++qword_75B210;\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "var_end",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_503608(_BYTE *a1, int a2)\n{\n  _BYTE *v2; // rax\n\n  do\n  {\n    do\n      v2 = a1++;\n    while ( *v2 != 32 );\n    --a2;\n  }\n  while ( a2 );\n  return a1;\n}\n\n\n Revised code:\nendif\n\nstatic char *skip_fields(char *str, int count)\n{\n\tdo {\n\t\twhile (*str++ != ' ')\n\t\t\tcontinue;\n\t\t/* we found a space char, str points after it */\n\t} while (--count);\n\treturn str;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_424AE9(_BYTE *a1, char a2, char a3)\n{\n  __int64 result; // rax\n\n  while ( 1 )\n  {\n    result = (unsigned __int8)*a1;\n    if ( !(_BYTE)result )\n      break;\n    if ( a2 == *a1 )\n      *a1 = a3;\n    ++a1;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void replace(char *s, char what, char with)\n{\n\twhile (*s) {\n\t\tif (what == *s)\n\t\t\t*s = with;\n\t\t++s;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_408145(unsigned __int64 a1, _BYTE *a2)\n{\n  _BYTE *v3; // rax\n\n  do\n  {\n    v3 = a2--;\n    if ( a1 >= (unsigned __int64)v3 )\n      break;\n  }\n  while ( *a2 == 32 || (unsigned __int8)(*a2 - 9) <= 4u );\n  a2[1] = 0;\n  return sub_4093B4(a1);\n}\n\n\n Revised code:\nstatic char *get_trimmed_slice(char *s, char *e)\n{\n\t/* First, consider the value at e to be nul and back up until we\n\t * reach a non-space char.  Set the char after that (possibly at\n\t * the original e) to nul. */\n\twhile (e-- > s) {\n\t\tif (!isspace(*e)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\te[1] = '\\0';\n\n\t/* Next, advance past all leading space and return a ptr to the\n\t * first non-space char; possibly the terminating nul. */\n\treturn skip_whitespace(s);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_46DF3E(_BYTE *a1)\n{\n  _BYTE *v1; // rax\n\n  do\n  {\n    if ( !*a1 )\n      break;\n    v1 = a1++;\n  }\n  while ( *v1 != 61 );\n  return a1;\n}\n"
    },
    {
        "func_name": "convert_dname",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_50308A(_BYTE **a1)\n{\n  const char *v2; // [rsp+18h] [rbp-20h]\n  unsigned int v3; // [rsp+20h] [rbp-18h]\n  unsigned int v4; // [rsp+24h] [rbp-14h]\n  unsigned int v5; // [rsp+28h] [rbp-10h]\n  int v6; // [rsp+2Ch] [rbp-Ch]\n  _BYTE *v7; // [rsp+30h] [rbp-8h]\n\n  v5 = 0;\n  v6 = 0;\n  v4 = 8;\n  v7 = *a1;\n  if ( **a1 == 120 )\n  {\n    ++v7;\n    v4 = 16;\n    v6 = 1;\n  }\n  while ( 1 )\n  {\n    v3 = (*v7 | 0x20) - 48;\n    if ( v3 > 9 )\n      v3 = (*v7 | 0x20) - 87;\n    if ( v3 >= v4 )\n      break;\n    if ( v4 * v5 + v3 <= 0xFF )\n    {\n      v5 = v4 * v5 + v3;\n      ++v7;\n      if ( (unsigned int)++v6 <= 2 )\n        continue;\n    }\n    goto LABEL_11;\n  }\n  if ( v4 == 16 && !--v6 )\n    return 92LL;\nLABEL_11:\n  if ( !v6 )\n  {\n    v2 = \"abefnrtv\\\\\";\n    while ( *v2 != *v7 )\n    {\n      if ( !*++v2 )\n        goto LABEL_16;\n    }\n    ++v7;\nLABEL_16:\n    v5 = v2[10];\n  }\n  *a1 = v7;\n  return v5;\n}\n\n\n Revised code:\nchar FAST_FUNC bb_process_escape_sequence(const char **ptr)\n{\n\tconst char *q;\n\tunsigned num_digits;\n\tunsigned n;\n\tunsigned base;\n\n\tnum_digits = n = 0;\n\tbase = 8;\n\tq = *ptr;\n\n\tif (WANT_HEX_ESCAPES && *q == 'x') {\n\t\t++q;\n\t\tbase = 16;\n\t\t++num_digits;\n\t}\n\n\t/* bash requires leading 0 in octal escapes:\n\t * \\02 works, \\2 does not (prints \\ and 2).\n\t * We treat \\2 as a valid octal escape sequence. */\n\tdo {\n\t\tunsigned r;\n#if !WANT_HEX_ESCAPES\n\t\tunsigned d = (unsigned char)(*q) - '0';\n#else\n\t\tunsigned d = (unsigned char)_tolower(*q) - '0';\n\t\tif (d >= 10)\n\t\t\td += ('0' - 'a' + 10);\n#endif\n\t\tif (d >= base) {\n\t\t\tif (WANT_HEX_ESCAPES && base == 16) {\n\t\t\t\t--num_digits;\n\t\t\t\tif (num_digits == 0) {\n\t\t\t\t\t/* \\x<bad_char>: return '\\',\n\t\t\t\t\t * leave ptr pointing to x */\n\t\t\t\t\treturn '\\\\';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tr = n * base + d;\n\t\tif (r > UCHAR_MAX) {\n\t\t\tbreak;\n\t\t}\n\n\t\tn = r;\n\t\t++q;\n\t} while (++num_digits < 3);\n\n\tif (num_digits == 0) {\n\t\t/* Not octal or hex escape sequence.\n\t\t * Is it one-letter one? */\n\n\t\t/* bash builtin \"echo -e '\\ec'\" interprets \\e as ESC,\n\t\t * but coreutils \"/bin/echo -e '\\ec'\" does not.\n\t\t * Manpages tend to support coreutils way.\n\t\t * Update: coreutils added support for \\e on 28 Oct 2009. */\n\t\tstatic const char charmap[] ALIGN1 = {\n\t\t\t'a',  'b', 'e', 'f',  'n',  'r',  't',  'v',  '\\\\', '\\0',\n\t\t\t'\\a', '\\b', 27, '\\f', '\\n', '\\r', '\\t', '\\v', '\\\\', '\\\\',\n\t\t};\n\t\tconst char *p = charmap;\n\t\tdo {\n\t\t\tif (*p == *q) {\n\t\t\t\tq++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (*++p != '\\0');\n\t\t/* p points to found escape char or NUL,\n\t\t * advance it and find what it translates to.\n\t\t * Note that \\NUL and unrecognized sequence \\z return '\\'\n\t\t * and leave ptr pointing to NUL or z. */\n\t\tn = p[sizeof(charmap) / 2];\n\t}\n\n\t*ptr = q;\n\n\treturn (char) n;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_42F1F5(char *a1, _WORD *a2)\n{\n  _BYTE *v3; // rax\n  char v5; // [rsp+1Eh] [rbp-12h]\n  char v6; // [rsp+1Eh] [rbp-12h]\n  char v7; // [rsp+1Fh] [rbp-11h]\n  int v8; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+24h] [rbp-Ch]\n  _WORD *v10; // [rsp+28h] [rbp-8h]\n\n  *a2 = 1;\n  v10 = a2 + 1;\n  for ( i = 0; i <= 5; ++i )\n  {\n    v7 = 0;\n    v8 = 0;\n    if ( i && *a1 == 58 )\n      ++a1;\n    while ( 1 )\n    {\n      v5 = *a1;\n      if ( (unsigned __int8)(*a1 - 48) > 9u )\n        break;\n      v6 = v5 - 48;\nLABEL_13:\n      ++a1;\n      v7 = v6 + 16 * v7;\n      if ( ++v8 > 1 )\n        goto LABEL_14;\n    }\n    if ( (unsigned __int8)((v5 | 0x20) - 97) <= 5u )\n    {\n      v6 = (v5 | 0x20) - 87;\n      goto LABEL_13;\n    }\n    if ( !v8 || v5 != 58 && v5 )\n      return 0xFFFFFFFFLL;\nLABEL_14:\n    v3 = v10;\n    v10 = (_WORD *)((char *)v10 + 1);\n    *v3 = v7;\n  }\n  return (unsigned int)*a1;\n}\n\n\n Revised code:\nstatic int in_ether(const char *bufp, struct sockaddr *sap)\n{\n\tchar *ptr;\n\tint i, j;\n\tunsigned char val;\n\tunsigned char c;\n\n\tsap->sa_family = ARPHRD_ETHER;\n\tptr = (char *) sap->sa_data;\n\n\ti = 0;\n\tdo {\n\t\tj = val = 0;\n\n\t\t/* We might get a semicolon here - not required. */\n\t\tif (i && (*bufp == ':')) {\n\t\t\tbufp++;\n\t\t}\n\n\t\tdo {\n\t\t\tc = *bufp;\n\t\t\tif (((unsigned char)(c - '0')) <= 9) {\n\t\t\t\tc -= '0';\n\t\t\t} else if ((unsigned char)((c|0x20) - 'a') <= 5) {\n\t\t\t\tc = (unsigned char)((c|0x20) - 'a') + 10;\n\t\t\t} else if (j && (c == ':' || c == 0)) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t++bufp;\n\t\t\tval <<= 4;\n\t\t\tval += c;\n\t\t} while (++j < 2);\n\t\t*ptr++ = val;\n\t} while (++i < ETH_ALEN);\n\n\treturn *bufp; /* Error if we don't end at end of string. */\n}\n\n## Example:\n\n Input code:\nchar *__fastcall sub_42C232(const char *a1, __int64 a2)\n{\n  unsigned __int8 *v2; // rax\n  unsigned __int8 *v3; // rax\n  char *s; // [rsp+8h] [rbp-28h]\n  unsigned __int8 v6; // [rsp+17h] [rbp-19h]\n  char *v7; // [rsp+18h] [rbp-18h]\n  int v8; // [rsp+24h] [rbp-Ch]\n  char *v9; // [rsp+28h] [rbp-8h]\n\n  s = (char *)a1;\n  v8 = strlen(a1);\n  v7 = (char *)sub_40A05F(6 * v8 + 1, a2);\n  v9 = v7;\n  while ( 1 )\n  {\n    v3 = (unsigned __int8 *)s++;\n    v6 = *v3;\n    if ( !*v3 )\n      break;\n    if ( sub_42B68A(v6) )\n    {\n      v2 = (unsigned __int8 *)v9++;\n      *v2 = v6;\n    }\n    else\n    {\n      v9 += sprintf(v9, \"&#%d;\", v6);\n    }\n  }\n  *v9 = 0;\n  return v7;\n}\n\n\n Revised code:\nstatic char *encodeString(const char *string)\n{\n\t/* take the simple route and encode everything */\n\t/* could possibly scan once to get length.     */\n\tint len = strlen(string);\n\tchar *out = xmalloc(len * 6 + 1);\n\tchar *p = out;\n\tchar ch;\n\n\twhile ((ch = *string++) != '\\0') {\n\t\t/* very simple check for what to encode */\n\t\tif (isalnum(ch))\n\t\t\t*p++ = ch;\n\t\telse\n\t\t\tp += sprintf(p, \"&#%d;\", (unsigned char) ch);\n\t}\n\t*p = '\\0';\n\treturn out;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_45763B(const char *a1, __int64 a2)\n{\n  size_t v2; // rax\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  char *s; // [rsp+8h] [rbp-38h]\n  int v8; // [rsp+1Ch] [rbp-24h]\n  char *ptr; // [rsp+20h] [rbp-20h]\n  char *i; // [rsp+28h] [rbp-18h]\n  char *v11; // [rsp+30h] [rbp-10h]\n  char v12; // [rsp+3Fh] [rbp-1h]\n\n  s = (char *)a1;\n  v2 = strlen(a1);\n  ptr = (char *)sub_40A05F(v2 + 2, a2);\n  v11 = ptr;\n  for ( i = ptr + 1; ; ++i )\n  {\n    while ( 1 )\n    {\n      v3 = s++;\n      v12 = *v3;\n      if ( *v3 == 46 || !v12 )\n        break;\n      if ( (unsigned __int8)v12 > 0x40u && (unsigned __int8)v12 <= 0x5Au )\n        v12 += 32;\n      v5 = i++;\n      *v5 = v12;\n    }\n    v8 = (_DWORD)i - (_DWORD)v11 - 1;\n    if ( v8 > 63 || (_DWORD)i - (_DWORD)v11 == 1 || v12 == 46 && *s == 46 )\n      goto LABEL_17;\n    *v11 = v8;\n    if ( !v12 || !*s )\n      break;\n    v4 = i;\n    v11 = v4;\n  }\n  if ( i - ptr > 254 )\n  {\nLABEL_17:\n    free(ptr);\n    return 0LL;\n  }\n  *i = 0;\n  return ptr;\n}\n"
    },
    {
        "func_name": "volume_id_probe_romfs",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4E6ABA(__int64 a1, char *a2, int a3, int a4)\n{\n  char *v6; // [rsp+28h] [rbp-18h]\n  void *s; // [rsp+30h] [rbp-10h]\n  int i; // [rsp+3Ch] [rbp-4h]\n  int v9; // [rsp+3Ch] [rbp-4h]\n\n  s = (void *)(a4 + 16LL + a1 + 4);\n  for ( i = *(_DWORD *)(a1 + 16) - a4; i >= a3; i = v9 - 1 )\n  {\n    v6 = (char *)memchr(s, *a2, i);\n    if ( !v6 )\n      return 0xFFFFFFFFLL;\n    v9 = i - ((_DWORD)v6 - (_DWORD)s);\n    if ( v9 < a3 )\n      return 0xFFFFFFFFLL;\n    if ( !memcmp(v6, a2, a3) )\n      return (__int64)&v6[-a1 - 20];\n    s = v6 + 1;\n  }\n  return 0xFFFFFFFFLL;\n}\n\n\n Revised code:\nstatic int findString(const LINE *lp, const char *str, int len, int offset)\n{\n\tint left;\n\tconst char *cp, *ncp;\n\n\tcp = &lp->data[offset];\n\tleft = lp->len - offset;\n\n\twhile (left >= len) {\n\t\tncp = memchr(cp, *str, left);\n\t\tif (ncp == NULL)\n\t\t\treturn -1;\n\t\tleft -= (ncp - cp);\n\t\tif (left < len)\n\t\t\treturn -1;\n\t\tcp = ncp;\n\t\tif (memcmp(cp, str, len) == 0)\n\t\t\treturn (cp - lp->data);\n\t\tcp++;\n\t\tleft--;\n\t}\n\n\treturn -1;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_42FA80(const char *a1, char *a2)\n{\n  int v3; // [rsp+1Ch] [rbp-4h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_42FA47(0x8921u, a2, a1);\n  v4 = sub_42FA47(0x8913u, a2 + 40, a1) | v3;\n  return sub_42FA47(0x8927u, a2 + 80, a1) | (unsigned int)v4;\n}\n\n\n Revised code:\nstatic int get_if_settings(char *ifname, struct dev_data *dd)\n{\n\tint res;\n\n\tres = set_ifrname_and_do_ioctl(SIOCGIFMTU, &dd->mtu, ifname);\n\tres |= set_ifrname_and_do_ioctl(SIOCGIFFLAGS, &dd->flags, ifname);\n\tres |= set_ifrname_and_do_ioctl(SIOCGIFHWADDR, &dd->hwaddr, ifname);\n\n\treturn res;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_50BD71(char *a1, unsigned int a2)\n{\n  unsigned int v3; // [rsp+14h] [rbp-Ch]\n  char *ptr; // [rsp+18h] [rbp-8h]\n\n  ptr = sub_50BB2A(a1, a2);\n  v3 = sub_40A999(*((unsigned __int16 *)ptr + 2), 1u, 0);\n  sub_50B34E(v3);\n  sub_50B4DD(v3, (__int64)(ptr + 4), *(_DWORD *)ptr);\n  free(ptr);\n  return v3;\n}\n\n\n Revised code:\nint FAST_FUNC create_and_connect_stream_or_die(const char *peer, int port)\n{\n\tint fd;\n\tlen_and_sockaddr *lsa;\n\n\tlsa = xhost2sockaddr(peer, port);\n\tfd = xsocket(lsa->u.sa.sa_family, SOCK_STREAM, 0);\n\tsetsockopt_reuseaddr(fd);\n\txconnect(fd, &lsa->u.sa, lsa->len);\n\tfree(lsa);\n\treturn fd;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4A76D1(__int64 a1)\n{\n  size_t v2; // [rsp+10h] [rbp-10h]\n  const char *s1; // [rsp+18h] [rbp-8h]\n\n  s1 = (const char *)sub_4A8163(a1, 0LL, 512LL);\n  if ( !s1 )\n    return 0xFFFFFFFFLL;\n  if ( memcmp(s1, \"-rom1fs-\", 4uLL) )\n    return 0xFFFFFFFFLL;\n  v2 = strlen(s1 + 16);\n  if ( v2 )\n    sub_4A7DA2(a1, s1 + 16, v2);\n  return 0LL;\n}\n"
    },
    {
        "func_name": "rearm_alarm",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint sub_4FE61B()\n{\n  int result; // eax\n\n  result = *((_DWORD *)qword_75D458 + 9);\n  if ( result )\n  {\n    sub_4FE38C(1u);\n    return sub_4FE55C();\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void input_backspace(void)\n{\n\tif (cursor > 0) {\n\t\tinput_backward(1);\n\t\tinput_delete(0);\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4421EB(char a1)\n{\n  __int64 result; // rax\n\n  if ( BYTE1(dest.c_oflag) == 0xFB )\n    return sub_441E67(254, a1);\n  result = BYTE1(dest.c_oflag);\n  if ( (_BYTE)result == 0xFD )\n    return sub_441E67(252, a1);\n  return result;\n}\n\n\n Revised code:\nstatic void to_notsup(char c)\n{\n\tif (G.telwish == WILL)\n\t\tput_iac2(DONT, c);\n\telse if (G.telwish == DO)\n\t\tput_iac2(WONT, c);\n}\n\n## Example:\n\n Input code:\nint sub_4FE2D5()\n{\n  int result; // eax\n\n  sub_4FE2AF();\n  result = *((_DWORD *)qword_75D458 + 6);\n  if ( result )\n    return sub_40A659(10);\n  return result;\n}\n\n\n Revised code:\nstatic void goto_new_line(void)\n{\n\tput_till_end_and_adv_cursor();\n\tif (cmdedit_x != 0)\n\t\tbb_putchar('\\n');\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nunsigned int sub_433B43()\n{\n  unsigned int result; // eax\n\n  result = dest.c_cc[31];\n  if ( !(_BYTE)result )\n  {\n    dest.c_cc[31] = 1;\n    return alarm(0x3Cu);\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "udhcp_recv_kernel_packet",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_495D5B(__int64 a1, __int64 a2)\n{\n  const char *v2; // rax\n  __int64 v3; // r9\n  unsigned int v4; // esi\n  int v7; // [rsp+1Ch] [rbp-4h]\n\n  v2 = (const char *)sub_5085F9(a2);\n  v7 = sub_40A295(v2, 2);\n  if ( ident[1] == 114 )\n    v4 = 4705;\n  else\n    v4 = 587;\n  sub_40AB31(v7, v4, 0LL, \"%s\", *(_QWORD *)(a2 + 8), v3, a2);\n  return 0LL;\n}\n\n\n Revised code:\nint freeramdisk_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint fd;\n\n\tfd = xopen(single_argv(argv), O_RDWR);\n\n\t// Act like freeramdisk, fdflush, or both depending on configuration.\n\tioctl_or_perror_and_die(fd, (ENABLE_FREERAMDISK && applet_name[1] == 'r')\n\t\t\t|| !ENABLE_FDFLUSH ? BLKFLSBUF : FDFLUSH, NULL, \"%s\", argv[1]);\n\n\tif (ENABLE_FEATURE_CLEAN_UP) close(fd);\n\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_40D112(unsigned int *a1, char *a2)\n{\n  unsigned int v2; // edx\n  __int64 result; // rax\n  unsigned int v4; // edx\n  char *v5; // [rsp+18h] [rbp-8h]\n\n  v5 = strchr(a2, 46);\n  if ( v5 )\n    *v5 = 58;\n  else\n    v5 = strchr(a2, 58);\n  if ( v5 )\n  {\n    if ( v5 == a2 )\n    {\n      v4 = sub_4F64C7(v5 + 1, sub_4F64A0);\n      result = (__int64)a1;\n      a1[1] = v4;\n    }\n    else\n    {\n      if ( !v5[1] )\n        *v5 = 0;\n      return sub_40D0CD(a1, a2);\n    }\n  }\n  else\n  {\n    v2 = sub_4F64C7(a2, sub_4F6479);\n    result = (__int64)a1;\n    *a1 = v2;\n  }\n  return result;\n}\n\n\n Revised code:\nvoid FAST_FUNC parse_chown_usergroup_or_die(struct bb_uidgid_t *u, char *user_group)\n{\n\tchar *group;\n\n\t/* Check if there is a group name */\n\tgroup = strchr(user_group, '.'); /* deprecated? */\n\tif (!group)\n\t\tgroup = strchr(user_group, ':');\n\telse\n\t\t*group = ':'; /* replace '.' with ':' */\n\n\t/* Parse \"user[:[group]]\" */\n\tif (!group) { /* \"user\" */\n\t\tu->uid = get_ug_id(user_group, xuname2uid);\n\t} else if (group == user_group) { /* \":group\" */\n\t\tu->gid = get_ug_id(group + 1, xgroup2gid);\n\t} else {\n\t\tif (!group[1]) /* \"user:\" */\n\t\t\t*group = '\\0';\n\t\txget_uidgid(u, user_group);\n\t}\n}\n\n## Example:\n\n Input code:\n_DWORD *__fastcall sub_4F9895(const char *a1, __int64 a2)\n{\n  const char *v2; // rax\n  const char *v3; // rax\n  int v4; // eax\n  __int64 v6; // [rsp+18h] [rbp-18h]\n  unsigned int v7; // [rsp+24h] [rbp-Ch]\n  _DWORD *v8; // [rsp+28h] [rbp-8h]\n\n  v7 = 0;\n  v6 = 0LL;\n  v8 = sub_40A0E8(4uLL, a2);\n  while ( 1 )\n  {\n    v6 = sub_503C0E(v6, 65825LL);\n    if ( !v6 )\n      break;\n    if ( !sub_4F97BA(v6, a1) )\n    {\n      if ( !*(_QWORD *)(v6 + 24) || (v2 = sub_408E94(*(const char **)(v6 + 24)), strcmp(v2, a1)) )\n      {\n        if ( !*(_QWORD *)(v6 + 32) )\n          continue;\n        v3 = sub_408E94(*(const char **)(v6 + 32));\n        if ( strcmp(v3, a1) )\n          continue;\n      }\n    }\n    v8 = (_DWORD *)sub_50C0E1(v8, 1026LL, v7);\n    v4 = v7++;\n    v8[v4] = *(_DWORD *)(v6 + 88);\n  }\n  v8[v7] = 0;\n  return v8;\n}\n\n\n Revised code:\nFAST_FUNC find_pid_by_name(const char *procName)\n{\n\tpid_t* pidList;\n\tint i = 0;\n\tprocps_status_t* p = NULL;\n\n\tpidList = xzalloc(sizeof(*pidList));\n\twhile ((p = procps_scan(p, PSSCAN_PID|PSSCAN_COMM|PSSCAN_ARGVN|PSSCAN_EXE))) {\n\t\tif (comm_match(p, procName)\n\t\t/* or we require argv0 to match (essential for matching reexeced /proc/self/exe)*/\n\t\t || (p->argv0 && strcmp(bb_basename(p->argv0), procName) == 0)\n\t\t/* or we require /proc/PID/exe link to match */\n\t\t || (p->exe && strcmp(bb_basename(p->exe), procName) == 0)\n\t\t) {\n\t\t\tpidList = xrealloc_vector(pidList, 2, i);\n\t\t\tpidList[i++] = p->pid;\n\t\t}\n\t}\n\n\tpidList[i] = 0;\n\treturn pidList;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_45897C(_DWORD *a1, int a2)\n{\n  int v2; // edx\n  int v3; // ecx\n  int v4; // r8d\n  int v5; // r9d\n  int v7; // ebx\n  unsigned int v8; // [rsp+1Ch] [rbp-14h]\n\n  memset(a1, 0, 0x274uLL);\n  v8 = sub_40B3FF(a2, a1, 0x274uLL);\n  if ( (v8 & 0x80000000) == 0 )\n  {\n    if ( v8 > 0xEF && (v7 = a1[59], v7 == htonl(0x63825363u)) )\n    {\n      if ( dword_75D460 )\n        sub_4FDABC((unsigned int)\"Received a packet\", (_DWORD)a1, v2, v3, v4, v5);\n      sub_4588D8((__int64)a1);\n      return v8;\n    }\n    else\n    {\n      sub_4FDABC((unsigned int)\"Packet with bad magic, ignoring\", (_DWORD)a1, v2, v3, v4, v5);\n      return 4294967294LL;\n    }\n  }\n  else\n  {\n    if ( dword_75D460 )\n      sub_4FDABC((unsigned int)\"Packet read error, ignoring\", (_DWORD)a1, v2, v3, v4, v5);\n    return v8;\n  }\n}\n"
    },
    {
        "func_name": "builtin_shift",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47AD4B(char *a1, __int64 a2)\n{\n  void **v2; // rdx\n  void **v3; // rax\n  void **v5; // [rsp+18h] [rbp-18h]\n  void **i; // [rsp+20h] [rbp-10h]\n  int v7; // [rsp+2Ch] [rbp-4h]\n\n  v7 = 1;\n  if ( *(_QWORD *)(a2 + 8) )\n  {\n    a1 = *(char **)(a2 + 8);\n    v7 = sub_46EE78(a1);\n  }\n  if ( v7 > *(_DWORD *)qword_75D420 )\n    v7 = 0;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  *(_DWORD *)qword_75D420 -= v7;\n  for ( i = *(void ***)(qword_75D420 + 16); --v7 >= 0; ++i )\n  {\n    if ( *(_BYTE *)(qword_75D420 + 12) )\n    {\n      a1 = (char *)*i;\n      free(*i);\n    }\n  }\n  v5 = *(void ***)(qword_75D420 + 16);\n  do\n  {\n    v2 = i++;\n    v3 = v5++;\n    *v3 = *v2;\n  }\n  while ( *v3 );\n  *(_DWORD *)(qword_75D420 + 4) = 1;\n  *(_DWORD *)(qword_75D420 + 8) = -1;\n  sub_46E03F(a1, a2);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC\nshiftcmd(int argc UNUSED_PARAM, char **argv)\n{\n\tint n;\n\tchar **ap1, **ap2;\n\n\tn = 1;\n\tif (argv[1])\n\t\tn = number(argv[1]);\n\tif (n > shellparam.nparam)\n\t\tn = 0; /* bash compat, was = shellparam.nparam; */\n\tINT_OFF;\n\tshellparam.nparam -= n;\n\tfor (ap1 = shellparam.p; --n >= 0; ap1++) {\n\t\tif (shellparam.malloced)\n\t\t\tfree(*ap1);\n\t}\n\tap2 = shellparam.p;\n\twhile ((*ap2++ = *ap1++) != NULL)\n\t\tcontinue;\n#if ENABLE_ASH_GETOPTS\n\tshellparam.optind = 1;\n\tshellparam.optoff = -1;\n#endif\n\tINT_ON;\n\treturn 0;\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_486BBE(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  int v3; // eax\n  char *v4; // [rsp+18h] [rbp-18h]\n  int i; // [rsp+20h] [rbp-10h]\n  int j; // [rsp+20h] [rbp-10h]\n  int v7; // [rsp+24h] [rbp-Ch]\n  char *s; // [rsp+28h] [rbp-8h]\n\n  if ( *((_BYTE *)qword_75D408 + 74) && a1 )\n  {\n    v7 = 3;\n    for ( i = 0; *(_QWORD *)(8LL * i + a1); ++i )\n    {\n      v2 = i;\n      v7 += strlen(*(const char **)(8LL * v2 + a1)) + 1;\n    }\n    v4 = (char *)sub_40A05F(v7, a2);\n    *v4 = 43;\n    s = v4 + 1;\n    for ( j = 0; *(_QWORD *)(8LL * j + a1); ++j )\n    {\n      v3 = j;\n      s += sprintf(s, \" %s\", *(const char **)(8LL * v3 + a1));\n    }\n    *s = 10;\n    s[1] = 0;\n    fputs_unlocked(v4, stderr);\n    free(v4);\n  }\n}\n\n\n Revised code:\nif ENABLE_HUSH_MODE_X\nstatic void dump_cmd_in_x_mode(char **argv)\n{\n\tif (G_x_mode && argv) {\n\t\t/* We want to output the line in one write op */\n\t\tchar *buf, *p;\n\t\tint len;\n\t\tint n;\n\n\t\tlen = 3;\n\t\tn = 0;\n\t\twhile (argv[n])\n\t\t\tlen += strlen(argv[n++]) + 1;\n\t\tbuf = xmalloc(len);\n\t\tbuf[0] = '+';\n\t\tp = buf + 1;\n\t\tn = 0;\n\t\twhile (argv[n])\n\t\t\tp += sprintf(p, \" %s\", argv[n++]);\n\t\t*p++ = '\\n';\n\t\t*p = '\\0';\n\t\tfputs(buf, stderr);\n\t\tfree(buf);\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4DE999(unsigned int a1)\n{\n  char *v1; // rbx\n  __int64 result; // rax\n  int v3; // [rsp+1Ch] [rbp-14h]\n  int i; // [rsp+1Ch] [rbp-14h]\n\n  if ( (signed int)a1 >= *((_DWORD *)qword_75D408 - 12) )\n  {\n    v3 = *((_DWORD *)qword_75D408 - 12);\n    *((_DWORD *)qword_75D408 - 12) = a1 + 16;\n    v1 = (char *)qword_75D408 - 208;\n    *((_QWORD *)v1 + 21) = sub_40A09E(*((void **)qword_75D408 - 5), 32LL * *((int *)qword_75D408 - 12));\n    while ( v3 < *((_DWORD *)qword_75D408 - 12) )\n    {\n      *(_DWORD *)(32LL * v3 + *((_QWORD *)qword_75D408 - 5)) = 1024;\n      *(_QWORD *)(32LL * v3++ + *((_QWORD *)qword_75D408 - 5) + 16) = 0LL;\n    }\n  }\n  for ( i = a1; i < *((_DWORD *)qword_75D408 - 13); ++i )\n    sub_4DC88C((int *)(32LL * i + *((_QWORD *)qword_75D408 - 5)));\n  result = a1;\n  *((_DWORD *)qword_75D408 - 13) = a1;\n  return result;\n}\n\n\n Revised code:\nstatic void fsrealloc(int size)\n{\n\tint i;\n\n\tif (size >= maxfields) {\n\t\ti = maxfields;\n\t\tmaxfields = size + 16;\n\t\tFields = xrealloc(Fields, maxfields * sizeof(Fields[0]));\n\t\tfor (; i < maxfields; i++) {\n\t\t\tFields[i].type = VF_SPECIAL;\n\t\t\tFields[i].string = NULL;\n\t\t}\n\t}\n\t/* if size < nfields, clear extra field variables */\n\tfor (i = size; i < nfields; i++) {\n\t\tclrvar(Fields + i);\n\t}\n\tnfields = size;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_48A1A8(__int64 a1)\n{\n  int v1; // eax\n  const char **v3; // [rsp+8h] [rbp-18h]\n  int i; // [rsp+18h] [rbp-8h]\n  int v5; // [rsp+1Ch] [rbp-4h]\n\n  v5 = 1;\n  v3 = (const char **)sub_48914D(a1);\n  if ( *v3 )\n    v5 = atoi(*v3);\n  if ( v5 < 0 || v5 >= *((_DWORD *)qword_75D408 + 21) )\n    return 1LL;\n  if ( *((_BYTE *)qword_75D408 + 80) )\n  {\n    for ( i = 1; i <= v5; ++i )\n    {\n      v1 = i;\n      free(*(void **)(*((_QWORD *)qword_75D408 + 11) + 8LL * v1));\n    }\n  }\n  *((_DWORD *)qword_75D408 + 21) -= v5;\n  memmove(\n    (void *)(*((_QWORD *)qword_75D408 + 11) + 8LL),\n    (const void *)(*((_QWORD *)qword_75D408 + 11) + 8 * (v5 + 1LL)),\n    8LL * *((int *)qword_75D408 + 21));\n  return 0LL;\n}\n"
    },
    {
        "func_name": "fast_strtoul_16",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4375C0(char *a1, _WORD *a2)\n{\n  char *v2; // rax\n  _BYTE *v4; // rax\n  char v6; // [rsp+1Fh] [rbp-11h]\n  unsigned int v7; // [rsp+20h] [rbp-10h]\n  unsigned int v8; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+24h] [rbp-Ch]\n  _WORD *v10; // [rsp+28h] [rbp-8h]\n\n  *a2 = 1;\n  v10 = a2 + 1;\n  for ( i = 0; *a1 && i <= 5; ++i )\n  {\n    v2 = a1++;\n    v7 = 16 * sub_437583(*v2);\n    if ( v7 > 0xFF )\n    {\n      *(_DWORD *)qword_75D400 = 22;\n      return 0xFFFFFFFFLL;\n    }\n    v6 = *a1;\n    if ( *a1 != 58 && v6 )\n    {\n      v8 = sub_437583(v6) | v7;\n      if ( v8 > 0xFF )\n      {\n        *(_DWORD *)qword_75D400 = 22;\n        return 0xFFFFFFFFLL;\n      }\n    }\n    else\n    {\n      v8 = v7 >> 4;\n    }\n    if ( v6 )\n      ++a1;\n    v4 = v10;\n    v10 = (_WORD *)((char *)v10 + 1);\n    *v4 = v8;\n    if ( *a1 == 58 )\n      ++a1;\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC ether_input(const char *bufp, struct sockaddr *sap)\n{\n\tunsigned char *ptr;\n\tchar c;\n\tint i;\n\tunsigned val;\n\n\tsap->sa_family = ether_hwtype.type;\n\tptr = (unsigned char*) sap->sa_data;\n\n\ti = 0;\n\twhile ((*bufp != '\\0') && (i < ETH_ALEN)) {\n\t\tval = hexchar2int(*bufp++) * 0x10;\n\t\tif (val > 0xff) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tc = *bufp;\n\t\tif (c == ':' || c == 0)\n\t\t\tval >>= 4;\n\t\telse {\n\t\t\tval |= hexchar2int(c);\n\t\t\tif (val > 0xff) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (c != 0)\n\t\t\tbufp++;\n\t\t*ptr++ = (unsigned char) val;\n\t\ti++;\n\n\t\t/* We might get a semicolon here - not required. */\n\t\tif (*bufp == ':') {\n\t\t\tbufp++;\n\t\t}\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_4C5907(_BYTE *a1, unsigned int *a2)\n{\n  unsigned int *v2; // rax\n  _BYTE *s; // [rsp+8h] [rbp-18h]\n  unsigned int v6; // [rsp+18h] [rbp-8h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  s = a1;\n  memset(a1, 32, (unsigned int)(7 * dword_75D450 + 21));\n  for ( i = 0; i <= 6; ++i )\n  {\n    v2 = a2++;\n    v6 = *v2;\n    if ( *v2 == -1 )\n    {\n      s += (unsigned int)(dword_75D450 + 3);\n    }\n    else\n    {\n      if ( dword_75D450 )\n      {\n        ++s;\n        if ( v6 > 0x63 )\n        {\n          *s = 48;\n          *(s - 1) = v6 / 0x64 + 48;\n          v6 %= 0x64u;\n        }\n      }\n      if ( v6 / 0xA )\n        *s = v6 / 0xA + 48;\n      s[1] = v6 % 0xA + 48;\n      s += 3;\n    }\n  }\n  return s;\n}\n\n\n Revised code:\nstatic char *build_row(char *p, unsigned *dp)\n{\n\tunsigned col, val, day;\n\n\tmemset(p, ' ', (julian + DAY_LEN) * 7);\n\n\tcol = 0;\n\tdo {\n\t\tday = *dp++;\n\t\tif (day != SPACE) {\n\t\t\tif (julian) {\n\t\t\t\t++p;\n\t\t\t\tif (day >= 100) {\n\t\t\t\t\t*p = '0';\n\t\t\t\t\tp[-1] = (day / 100) + '0';\n\t\t\t\t\tday %= 100;\n\t\t\t\t}\n\t\t\t}\n\t\t\tval = day / 10;\n\t\t\tif (val > 0) {\n\t\t\t\t*p = val + '0';\n\t\t\t}\n\t\t\t*++p = day % 10 + '0';\n\t\t\tp += 2;\n\t\t} else {\n\t\t\tp += DAY_LEN + julian;\n\t\t}\n\t} while (++col < 7);\n\n\treturn p;\n}\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_481AB7(__int64 a1)\n{\n  _BYTE *v2; // rax\n  _BYTE *v4; // [rsp+0h] [rbp-18h]\n  int v5; // [rsp+14h] [rbp-4h]\n\n  v5 = 0;\n  v4 = (_BYTE *)(a1 + 1);\n  while ( *v4 )\n  {\n    if ( *v4 == 92 )\n    {\n      if ( !*++v4 )\n        break;\n      ++v4;\n    }\n    else\n    {\n      if ( *v4 == 125 && !v5-- )\n        break;\n      if ( *v4 == 44 && !v5 )\n        break;\n      v2 = v4++;\n      if ( *v2 == 123 )\n        ++v5;\n    }\n  }\n  if ( *v4 )\n    return v4;\n  else\n    return 0LL;\n}\n\n\n Revised code:\nstatic const char *next_brace_sub(const char *cp)\n{\n\tunsigned depth = 0;\n\tcp++;\n\twhile (*cp != '\\0') {\n\t\tif (*cp == '\\\\') {\n\t\t\tif (*++cp == '\\0')\n\t\t\t\tbreak;\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((*cp == '}' && depth-- == 0) || (*cp == ',' && depth == 0))\n\t\t\tbreak;\n\t\tif (*cp++ == '{')\n\t\t\tdepth++;\n\t}\n\n\treturn *cp != '\\0' ? cp : NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_5034D4(_QWORD *a1)\n{\n  _BYTE *v1; // rax\n  __int64 i; // [rsp+10h] [rbp-18h]\n  _BYTE *v4; // [rsp+18h] [rbp-10h]\n  unsigned __int8 v5; // [rsp+27h] [rbp-1h]\n\n  v4 = (_BYTE *)*a1;\n  for ( i = 0LL; ; i = 16 * i + v5 )\n  {\n    v1 = v4++;\n    if ( *v1 <= 0x20u )\n      break;\n    v5 = (*v1 | 0x20) - 48;\n    if ( v5 > 9u )\n      v5 = (*v1 | 0x20) - 87;\n  }\n  *a1 = v4;\n  return i;\n}\n"
    },
    {
        "func_name": "strrev",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A8B04(__int64 a1, int a2, int a3, int a4)\n{\n  __int64 result; // rax\n  unsigned int v8; // [rsp+20h] [rbp-4h]\n\n  while ( a4 > 0 )\n  {\n    v8 = *(_DWORD *)(4LL * a2 + a1);\n    *(_DWORD *)(4LL * a2 + a1) = *(_DWORD *)(4LL * a3 + a1);\n    result = v8;\n    *(_DWORD *)(a1 + 4LL * a3) = v8;\n    ++a2;\n    ++a3;\n    --a4;\n  }\n  return result;\n}\n\n\n Revised code:\nvoid mvswap(uint32_t* ptr, int32_t zzp1, int32_t zzp2, int32_t zzn)\n{\n\twhile (zzn > 0) {\n\t\tmswap(ptr[zzp1], ptr[zzp2]);\n\t\tzzp1++;\n\t\tzzp2++;\n\t\tzzn--;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4FEB8C(__int64 a1, unsigned int a2, int a3)\n{\n  __int64 result; // rax\n  _WORD *v4; // rax\n  int v5; // [rsp+0h] [rbp-10h]\n  unsigned int v6; // [rsp+4h] [rbp-Ch]\n\n  v6 = a2;\n  v5 = a3;\n  result = a2;\n  if ( a2 != a3 )\n  {\n    while ( 1 )\n    {\n      v4 = (_WORD *)(2LL * (int)v6 + a1);\n      *v4 = *(_WORD *)(a1 + 2LL * v5);\n      result = (unsigned __int16)*v4;\n      if ( !(_WORD)result )\n        break;\n      ++v6;\n      ++v5;\n    }\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void remove_chunk(int16_t *int_buf, int beg, int end)\n{\n\t/* beg must be <= end */\n\tif (beg == end)\n\t\treturn;\n\n\twhile ((int_buf[beg] = int_buf[end]) != 0)\n\t\tbeg++, end++;\n\n\tif (dbg_bmp) {\n\t\tint i;\n\t\tfor (i = 0; int_buf[i]; i++)\n\t\t\tbb_putchar((unsigned char)int_buf[i]);\n\t\tbb_putchar('\\n');\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_505297(__int64 a1, unsigned int a2)\n{\n  __int64 result; // rax\n  int i; // [rsp+10h] [rbp-Ch]\n  int v4; // [rsp+14h] [rbp-8h]\n  unsigned int v5; // [rsp+18h] [rbp-4h]\n\n  result = a1;\n  *(_DWORD *)(a1 + 8) = 0;\n  v4 = 1;\n  v5 = 0x800000;\n  for ( i = 0; i <= 23; ++i )\n  {\n    result = v4 & a2;\n    if ( (_DWORD)result )\n    {\n      result = a1;\n      *(_DWORD *)(a1 + 8) |= v5;\n    }\n    v4 *= 2;\n    v5 >>= 1;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\nsetup_salt(struct des_ctx *ctx, uint32_t salt)\n{\n\tuint32_t obit, saltbit;\n\tint i;\n\n#if USE_REPETITIVE_SPEEDUP\n\tif (salt == old_salt)\n\t\treturn;\n\told_salt = salt;\n#endif\n\n\tsaltbits = 0;\n\tsaltbit = 1;\n\tobit = 0x800000;\n\tfor (i = 0; i < 24; i++) {\n\t\tif (salt & saltbit)\n\t\t\tsaltbits |= obit;\n\t\tsaltbit <<= 1;\n\t\tobit >>= 1;\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4A3D68(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+0h] [rbp-1Ch]\n  int v4; // [rsp+14h] [rbp-8h]\n  unsigned int i; // [rsp+18h] [rbp-4h]\n\n  v3 = a2;\n  if ( a2 )\n  {\n    v3 = a2 - 1;\n    if ( a2 != 1 && *(_DWORD *)(4LL * v3 + a1) == 10 )\n      v3 = a2 - 2;\n  }\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i >= v3 )\n      break;\n    v4 = *(_DWORD *)(4LL * (int)i + a1);\n    *(_DWORD *)(4LL * (int)i + a1) = *(_DWORD *)(4LL * v3 + a1);\n    *(_DWORD *)(a1 + 4LL * v3--) = v4;\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "clearredir",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_471D7E(FILE *a1, char a2)\n{\n  __int64 result; // rax\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  while ( (int)sub_4718A4(1, 0LL) > 0 )\n    ;\n  result = qword_75AFB0;\n  for ( i = qword_75AFB0; i; i = result )\n  {\n    if ( (a2 & 4) == 0 || (*(_BYTE *)(i + 31) & 0x10) != 0 )\n      sub_471AE1(a1, i, a2);\n    result = *(_QWORD *)(i + 32);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\nshowjobs(FILE *out, int mode)\n{\n\tstruct job *jp;\n\n\tTRACE((\"showjobs(0x%x) called\\n\", mode));\n\n\t/* Handle all finished jobs */\n\twhile (dowait(DOWAIT_NONBLOCK, NULL) > 0)\n\t\tcontinue;\n\n\tfor (jp = curjob; jp; jp = jp->prev_job) {\n\t\tif (!(mode & SHOW_CHANGED) || jp->changed) {\n\t\t\tshowjob(out, jp, mode);\n\t\t}\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47EBE4(const char *a1)\n{\n  __int64 result; // rax\n\n  result = (__int64)sub_476FA6(a1, 0);\n  if ( result )\n  {\n    result = *(unsigned __int8 *)(result + 16);\n    if ( (_BYTE)result == 1 )\n      return sub_4770DD((__int64)a1, 0LL);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\nunsetfunc(const char *name)\n{\n\tstruct tblentry *cmdp;\n\n\tcmdp = cmdlookup(name, 0);\n\tif (cmdp != NULL && cmdp->cmdtype == CMDFUNCTION)\n\t\tdelete_cmd_entry();\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_45F76C(unsigned int a1)\n{\n  __int64 result; // rax\n\n  while ( 1 )\n  {\n    result = a1--;\n    if ( !(_DWORD)result )\n      break;\n    sub_45F732(63);\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void put_question_marks(int count)\n{\n\twhile (count--)\n\t\tput_c('?');\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_473AA2(int a1)\n{\n  __int64 result; // rax\n\n  while ( 1 )\n  {\n    *(_DWORD *)(qword_75D420 + 32) = 0;\n    result = *(_QWORD *)(qword_75D420 + 24);\n    if ( !result )\n      break;\n    sub_473973(a1, 0LL);\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "tail_read",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_4DBEE4(char *a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  struct stat64 stat_buf; // [rsp+10h] [rbp-90h] BYREF\n\n  if ( sub_407E10(a1, &stat_buf) == -1 )\n    return sub_4091D9((__int64)\"stat %s\", (__int64)a1, v1, v2, v3, v4);\n  if ( (stat_buf.st_mode & 0xF000) != 0x4000 || (dword_75D450 & 4) != 0 )\n    return sub_4DBC96(a1);\n  return sub_4DA317(a1, (void (__fastcall *)(const char *, struct dirent64 *, __int64))sub_4DBD9E, 0LL);\n}\n\n\n Revised code:\nstatic void lsattr_args(const char *name)\n{\n\tstruct stat st;\n\n\tif (lstat(name, &st) == -1) {\n\t\tbb_perror_msg(\"stat %s\", name);\n\t} else if (S_ISDIR(st.st_mode) && !(option_mask32 & OPT_DIRS_OPT)) {\n\t\titerate_on_dir(name, lsattr_dir_proc, NULL);\n\t} else {\n\t\tlist_attributes(name);\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4DBD9E(void *a1, _BYTE *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  struct stat64 stat_buf; // [rsp+20h] [rbp-A0h] BYREF\n  void *ptr; // [rsp+B8h] [rbp-8h]\n\n  ptr = (void *)sub_408E19(a1, a2 + 19);\n  if ( sub_407E10((char *)ptr, &stat_buf) )\n  {\n    sub_4091D9((__int64)\"stat %s\", (__int64)ptr, v2, v3, v4, v5);\n  }\n  else if ( a2[19] != 46 || (dword_75D450 & 2) != 0 )\n  {\n    sub_4DBC96((char *)ptr);\n    if ( (stat_buf.st_mode & 0xF000) == 0x4000\n      && (dword_75D450 & 1) != 0\n      && (a2[19] != 46 || a2[20] && (a2[20] != 46 || a2[21])) )\n    {\n      printf(\"\\n%s:\\n\", (const char *)ptr);\n      sub_4DA317((const char *)ptr, (void (__fastcall *)(const char *, struct dirent64 *, __int64))sub_4DBD9E, 0LL);\n      sub_40A659(10);\n    }\n  }\n  free(ptr);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC lsattr_dir_proc(const char *dir_name,\n\t\tstruct dirent *de,\n\t\tvoid *private UNUSED_PARAM)\n{\n\tstruct stat st;\n\tchar *path;\n\n\tpath = concat_path_file(dir_name, de->d_name);\n\n\tif (lstat(path, &st) != 0)\n\t\tbb_perror_msg(\"stat %s\", path);\n\telse if (de->d_name[0] != '.' || (option_mask32 & OPT_ALL)) {\n\t\tlist_attributes(path);\n\t\tif (S_ISDIR(st.st_mode) && (option_mask32 & OPT_RECUR)\n\t\t && !DOT_OR_DOTDOT(de->d_name)\n\t\t) {\n\t\t\tprintf(\"\\n%s:\\n\", path);\n\t\t\titerate_on_dir(path, lsattr_dir_proc, NULL);\n\t\t\tbb_putchar('\\n');\n\t\t}\n\t}\n\n\tfree(path);\n\treturn 0;\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_4B41FE(char *a1, unsigned int a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  struct stat64 stat_buf; // [rsp+10h] [rbp-A0h] BYREF\n  void *ptr; // [rsp+A0h] [rbp-10h]\n  int v8; // [rsp+ACh] [rbp-4h]\n\n  if ( (sub_4B4104(1037, a2) & 1) != 0 )\n  {\n    v8 = sub_407E10(a1, &stat_buf);\n    if ( !v8 && (stat_buf.st_mode & 0xF000) == 0x8000 )\n    {\n      ptr = sub_40A6B3(\"%s.rpmorig\", (__int64)a1, v2, v3, v4, v5);\n      sub_4F68A4(a1, ptr, 5LL);\n      sub_507831(a1, 12LL);\n      free(ptr);\n    }\n  }\n}\n\n\n Revised code:\nstatic void fileaction_dobackup(char *filename, int fileref)\n{\n\tstruct stat oldfile;\n\tint stat_res;\n\tchar *newname;\n\tif (rpm_getint(TAG_FILEFLAGS, fileref) & RPMFILE_CONFIG) {\n\t\t/* Only need to backup config files */\n\t\tstat_res = lstat(filename, &oldfile);\n\t\tif (stat_res == 0 && S_ISREG(oldfile.st_mode)) {\n\t\t\t/* File already exists  - really should check MD5's etc to see if different */\n\t\t\tnewname = xasprintf(\"%s.rpmorig\", filename);\n\t\t\tcopy_file(filename, newname, FILEUTILS_RECUR | FILEUTILS_PRESERVE_STATUS);\n\t\t\tremove_file(filename, FILEUTILS_RECUR | FILEUTILS_FORCE);\n\t\t\tfree(newname);\n\t\t}\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nssize_t __fastcall sub_4D5282(int a1, char *a2, size_t a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  struct stat64 stat_buf; // [rsp+20h] [rbp-A0h] BYREF\n  ssize_t v10; // [rsp+B0h] [rbp-10h]\n  __off64_t v11; // [rsp+B8h] [rbp-8h]\n\n  if ( !sub_407E00(a1, &stat_buf) && stat_buf.st_size > 0 )\n  {\n    v11 = lseek64(a1, 0LL, 1);\n    if ( v11 > stat_buf.st_size )\n      sub_40A557(a1, 0LL, 0);\n  }\n  v10 = sub_40B446(a1, a2, a3);\n  if ( v10 < 0 )\n  {\n    sub_4091D9((__int64)\"read error\", (__int64)a2, v3, v4, v5, v6);\n    BYTE1(dest.c_iflag) = 1;\n  }\n  return v10;\n}\n"
    },
    {
        "func_name": "recordregion",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4740C5(int a1, __int64 a2)\n{\n  __int64 result; // rax\n  void *v3; // rdi\n  __int64 v4; // rdi\n  __int64 v6; // [rsp+10h] [rbp-10h]\n  void *v7; // [rsp+18h] [rbp-8h]\n\n  result = qword_75AFF8;\n  if ( qword_75AFF8 )\n  {\n    if ( a1 >= dword_75AFEC )\n    {\n      for ( qword_75AFF8 = (__int64)&qword_75AFE0;\n            *(_QWORD *)qword_75AFF8 && a1 > *(_DWORD *)(*(_QWORD *)qword_75AFF8 + 8LL);\n            qword_75AFF8 = *(_QWORD *)qword_75AFF8 )\n      {\n        ;\n      }\n      while ( *(_QWORD *)qword_75AFF8 )\n      {\n        ++*(_DWORD *)(qword_75D418 + 48);\n        v6 = **(_QWORD **)qword_75AFF8;\n        v4 = *(_QWORD *)qword_75AFF8;\n        free(*(void **)qword_75AFF8);\n        *(_QWORD *)qword_75AFF8 = v6;\n        sub_46E03F(v4, a2);\n      }\n      result = *(unsigned int *)(qword_75AFF8 + 12);\n      if ( a1 < (int)result )\n      {\n        result = qword_75AFF8;\n        *(_DWORD *)(qword_75AFF8 + 12) = a1;\n      }\n    }\n    else\n    {\n      while ( qword_75AFE0 )\n      {\n        ++*(_DWORD *)(qword_75D418 + 48);\n        v7 = *(void **)qword_75AFE0;\n        v3 = qword_75AFE0;\n        free(qword_75AFE0);\n        qword_75AFE0 = v7;\n        sub_46E03F(v3, a2);\n      }\n      result = (unsigned int)dword_75AFE8;\n      if ( a1 >= dword_75AFE8 )\n      {\n        qword_75AFF8 = (__int64)&qword_75AFE0;\n        result = (unsigned int)a1;\n        dword_75AFEC = a1;\n      }\n      else\n      {\n        qword_75AFF8 = 0LL;\n      }\n    }\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void\nremoverecordregions(int endoff)\n{\n\tif (ifslastp == NULL)\n\t\treturn;\n\n\tif (ifsfirst.endoff > endoff) {\n\t\twhile (ifsfirst.next) {\n\t\t\tstruct ifsregion *ifsp;\n\t\t\tINT_OFF;\n\t\t\tifsp = ifsfirst.next->next;\n\t\t\tfree(ifsfirst.next);\n\t\t\tifsfirst.next = ifsp;\n\t\t\tINT_ON;\n\t\t}\n\t\tif (ifsfirst.begoff > endoff) {\n\t\t\tifslastp = NULL;\n\t\t} else {\n\t\t\tifslastp = &ifsfirst;\n\t\t\tifsfirst.endoff = endoff;\n\t\t}\n\t\treturn;\n\t}\n\n\tifslastp = &ifsfirst;\n\twhile (ifslastp->next && ifslastp->next->begoff < endoff)\n\t\tifslastp = ifslastp->next;\n\twhile (ifslastp->next) {\n\t\tstruct ifsregion *ifsp;\n\t\tINT_OFF;\n\t\tifsp = ifslastp->next->next;\n\t\tfree(ifslastp->next);\n\t\tifslastp->next = ifsp;\n\t\tINT_ON;\n\t}\n\tif (ifslastp->endoff > endoff)\n\t\tifslastp->endoff = endoff;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47A87E(const char **a1, __int64 a2)\n{\n  const char **v2; // rax\n  char **v3; // rbx\n  __int64 result; // rax\n  const char **v5; // [rsp+8h] [rbp-38h]\n  char **v6; // [rsp+18h] [rbp-28h]\n  int i; // [rsp+24h] [rbp-1Ch]\n  char **v8; // [rsp+28h] [rbp-18h]\n\n  v5 = a1;\n  for ( i = 0; a1[i]; ++i )\n    ;\n  v6 = (char **)sub_40A05F(8LL * (i + 1), a2);\n  v8 = v6;\n  while ( *v5 )\n  {\n    v2 = v5++;\n    v3 = v8++;\n    *v3 = sub_40A11F(*v2, a2);\n  }\n  *v8 = 0LL;\n  sub_46F1BA(qword_75D420);\n  *(_BYTE *)(qword_75D420 + 12) = 1;\n  *(_DWORD *)qword_75D420 = i;\n  *(_QWORD *)(qword_75D420 + 16) = v6;\n  *(_DWORD *)(qword_75D420 + 4) = 1;\n  result = qword_75D420;\n  *(_DWORD *)(qword_75D420 + 8) = -1;\n  return result;\n}\n\n\n Revised code:\nstatic void\nsetparam(char **argv)\n{\n\tchar **newparam;\n\tchar **ap;\n\tint nparam;\n\n\tfor (nparam = 0; argv[nparam]; nparam++)\n\t\tcontinue;\n\tap = newparam = ckmalloc((nparam + 1) * sizeof(*ap));\n\twhile (*argv) {\n\t\t*ap++ = ckstrdup(*argv++);\n\t}\n\t*ap = NULL;\n\tfreeparam(&shellparam);\n\tshellparam.malloced = 1;\n\tshellparam.nparam = nparam;\n\tshellparam.p = newparam;\n#if ENABLE_ASH_GETOPTS\n\tshellparam.optind = 1;\n\tshellparam.optoff = -1;\n#endif\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_43B939(__int64 a1, __int64 a2)\n{\n  void *result; // rax\n  _QWORD *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40A0E8(0x170uLL, a2);\n  *v3 = sub_50BB2A(a1, 123LL);\n  v3[1] = sub_50BFDE(*v3 + 4LL);\n  *((_DWORD *)v3 + 4) = -1;\n  *((_BYTE *)v3 + 296) = 35;\n  v3[4] = *(_QWORD *)qword_75D408;\n  sub_43B74C((__int64)v3, 2.0);\n  sub_408FD2((_QWORD *)qword_75D408 + 6, (__int64)v3);\n  result = qword_75D408;\n  ++*((_DWORD *)qword_75D408 + 16);\n  return result;\n}\n\n\n Revised code:\nstatic void\nadd_peers(char *s)\n{\n\tpeer_t *p;\n\n\tp = xzalloc(sizeof(*p));\n\tp->p_lsa = xhost2sockaddr(s, 123);\n\tp->p_dotted = xmalloc_sockaddr2dotted_noport(&p->p_lsa->u.sa);\n\tp->p_fd = -1;\n\tp->p_xmt_msg.m_status = MODE_CLIENT | (NTP_VERSION << 3);\n\tp->next_action_time = G.cur_time; /* = set_next(p, 0); */\n\treset_peer_stats(p, 16 * STEP_THRESHOLD);\n\n\tllist_add_to(&G.ntp_peers, p);\n\tG.peer_cnt++;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_474038(int a1, __int64 a2, int a3)\n{\n  __int64 result; // rax\n  void **v5; // [rsp+18h] [rbp-8h]\n\n  if ( qword_75AFF8 )\n  {\n    ++*(_DWORD *)(qword_75D418 + 48);\n    v5 = (void **)sub_40A0E8(0x18uLL, a2);\n    *(_QWORD *)qword_75AFF8 = v5;\n    sub_46E03F(24LL, a2);\n  }\n  else\n  {\n    v5 = &qword_75AFE0;\n  }\n  qword_75AFF8 = (__int64)v5;\n  *((_DWORD *)v5 + 2) = a1;\n  *(_DWORD *)(qword_75AFF8 + 12) = a2;\n  result = qword_75AFF8;\n  *(_DWORD *)(qword_75AFF8 + 16) = a3;\n  return result;\n}\n"
    },
    {
        "func_name": "popen_ls",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __fastcall sub_453FA6(unsigned __int8 *a1, __int64 a2)\n{\n  int v2; // ecx\n  int v3; // r8d\n  int v4; // r9d\n  int v5; // edx\n  int v6; // ecx\n  int v7; // r8d\n  int v8; // r9d\n  __int64 v9[4]; // [rsp+10h] [rbp-30h] BYREF\n  void *ptr; // [rsp+30h] [rbp-10h]\n  char **i; // [rsp+38h] [rbp-8h]\n\n  ptr = sub_453AE3(a1);\n  if ( dword_75D460 )\n    sub_4FDABC((unsigned int)\"Executing %s %s\", *((_QWORD *)&unk_75C3F8 + 8), a2, v2, v3, v4);\n  v9[0] = *((_QWORD *)&unk_75C3F8 + 8);\n  v9[1] = a2;\n  v9[2] = 0LL;\n  sub_50A624(v9);\n  for ( i = (char **)ptr; *i; ++i )\n  {\n    if ( (unsigned int)dword_75D460 > 1 )\n      sub_4FDABC((unsigned int)\" %s\", (unsigned int)*i, v5, v6, v7, v8);\n    sub_40A82A(*i);\n  }\n  free(ptr);\n}\n\n\n Revised code:\nstatic void udhcp_run_script(struct dhcp_packet *packet, const char *name)\n{\n\tchar **envp, **curr;\n\tchar *argv[3];\n\n\tenvp = fill_envp(packet);\n\n\t/* call script */\n\tlog1(\"Executing %s %s\", client_config.script, name);\n\targv[0] = (char*) client_config.script;\n\targv[1] = (char*) name;\n\targv[2] = NULL;\n\tspawn_and_wait(argv);\n\n\tfor (curr = envp; *curr; curr++) {\n\t\tlog2(\" %s\", *curr);\n\t\tbb_unsetenv_and_free(*curr);\n\t}\n\tfree(envp);\n}\n\n## Example:\n\n Input code:\nvoid __fastcall sub_42948E(int a1, const char *a2)\n{\n  signed int v2; // eax\n  int v3; // [rsp+Ch] [rbp-14h] BYREF\n  int v4; // [rsp+14h] [rbp-Ch]\n  void *ptr; // [rsp+18h] [rbp-8h]\n\n  v3 = a1;\n  ptr = sub_4292FC((const char *)&v3, a2, 0xFF0Du);\n  v2 = (unsigned int)sub_429408(ptr, 10, 0);\n  v4 = v2 + 1;\n  *((_BYTE *)ptr + v2) = 10;\n  sub_40A4AB(1u, (__int64)ptr, v4);\n  if ( *(_DWORD *)&dest.c_line > 1u )\n    sub_429454((const char *)ptr);\n  free(ptr);\n}\n\n\n Revised code:\nstatic void\ncmdio_write(uint32_t status_str, const char *str)\n{\n\tchar *response;\n\tint len;\n\n\t/* FTP uses telnet protocol for command link.\n\t * In telnet, 0xff is an escape char, and needs to be escaped: */\n\tresponse = escape_text((char *) &status_str, str, (0xff << 8) + '\\r');\n\n\t/* FTP sends embedded LFs as NULs */\n\tlen = replace_char(response, '\\n', '\\0');\n\n\tresponse[len++] = '\\n'; /* tack on trailing '\\n' */\n\txwrite(STDOUT_FILENO, response, len);\n\tif (G.verbose > 1)\n\t\tverbose_log(response);\n\tfree(response);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48EF6A(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v7; // eax\n  __int64 *v9; // [rsp+0h] [rbp-30h]\n  __int64 *v10; // [rsp+0h] [rbp-30h]\n  unsigned __int64 v11; // [rsp+10h] [rbp-20h] BYREF\n  int fd; // [rsp+1Ch] [rbp-14h]\n  const char *v13; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v14; // [rsp+28h] [rbp-8h]\n\n  v9 = (__int64 *)(a2 + 8);\n  if ( !*(_QWORD *)(a2 + 8) || !*(_QWORD *)(a2 + 16) )\n    sub_407F64();\n  v13 = sub_48EEFF(*v9);\n  v14 = v13[15];\n  if ( (v13[14] & 4) != 0 )\n  {\n    v9 = (__int64 *)(a2 + 16);\n    v14 = (int)sub_50B306(*(_QWORD *)(a2 + 16));\n  }\n  v10 = v9 + 1;\n  if ( !*v10 || v10[1] )\n    sub_407F64();\n  fd = sub_40A295((const char *)*v10, 0);\n  v11 = v14;\n  v2 = *(unsigned int *)v13;\n  if ( ioctl(fd, v2, &v11) == -1 )\n    sub_409392(*v10, v2, v3, v4, v5, v6);\n  v14 = v11;\n  if ( (v13[14] & 0x10) != 0 )\n    v14 >>= 9;\n  v7 = v13[14] & 0xB;\n  if ( v7 == 2 || v7 == 3 )\n  {\n    printf(\"%llu\\n\", v14);\n  }\n  else if ( v7 == 1 )\n  {\n    printf(\"%lld\\n\", (int)v14);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nint blockdev_main(int argc UNUSED_PARAM, char **argv)\n{\n\tconst struct bdc *bdcmd;\n\tint fd;\n\tuint64_t u64;\n\tunion {\n\t\tint i;\n\t\tunsigned long lu;\n\t\tuint64_t u64;\n\t} ioctl_val_on_stack;\n\n\targv++;\n\tif (!argv[0] || !argv[1]) /* must have at least 2 args */\n\t\tbb_show_usage();\n\n\tbdcmd = find_cmd(*argv);\n\n\tu64 = (int)bdcmd->argval;\n\tif (bdcmd->flags & FL_USRARG)\n\t\tu64 = xatoi_positive(*++argv);\n\n\targv++;\n\tif (!argv[0] || argv[1])\n\t\tbb_show_usage();\n\tfd = xopen(argv[0], O_RDONLY);\n\n\tioctl_val_on_stack.u64 = u64;\n#if BB_BIG_ENDIAN\n\t/* Store data properly wrt data size.\n\t * (1) It's no-op for little-endian.\n\t * (2) it's no-op for 0 and -1. Only --setro uses arg != 0 and != -1,\n\t * and it is ARG_INT. --setbsz USER_VAL is also ARG_INT.\n\t * Thus, we don't need to handle ARG_ULONG.\n\t */\n\tswitch (bdcmd->flags & ARG_MASK) {\n\tcase ARG_INT:\n\t\tioctl_val_on_stack.i = (int)u64;\n\t\tbreak;\n# if 0 /* unused */\n\tcase ARG_ULONG:\n\t\tioctl_val_on_stack.lu = (unsigned long)u64;\n\t\tbreak;\n# endif\n\t}\n#endif\n\n\tif (ioctl(fd, bdcmd->ioc, &ioctl_val_on_stack.u64) == -1)\n\t\tbb_simple_perror_msg_and_die(*argv);\n\n\t/* Fetch it into register(s) */\n\tu64 = ioctl_val_on_stack.u64;\n\n\tif (bdcmd->flags & FL_SCALE512)\n\t\tu64 >>= 9;\n\n\t/* Zero- or one-extend the value if needed, then print */\n\tswitch (bdcmd->flags & (ARG_MASK+FL_NORESULT)) {\n\tcase ARG_INT:\n\t\t/* Smaller code when we use long long\n\t\t * (gcc tail-merges printf call)\n\t\t */\n\t\tprintf(\"%lld\\n\", (long long)(int)u64);\n\t\tbreak;\n\tcase ARG_ULONG:\n\t\tu64 = (unsigned long)u64;\n\t\t/* FALLTHROUGH */\n\tcase ARG_U64:\n\t\tprintf(\"%llu\\n\", (unsigned long long)u64);\n\t\tbreak;\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tclose(fd);\n\treturn EXIT_SUCCESS;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_429E00(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  int fd; // [rsp+18h] [rbp-48h] BYREF\n  int v5; // [rsp+1Ch] [rbp-44h]\n  __int64 v6[3]; // [rsp+20h] [rbp-40h] BYREF\n  char *v7; // [rsp+38h] [rbp-28h]\n  __int64 v8; // [rsp+40h] [rbp-20h]\n  char *v10; // [rsp+58h] [rbp-8h]\n\n  v6[0] = (__int64)\"ftpd\";\n  v6[1] = a1;\n  v6[2] = (__int64)\"--\";\n  v7 = (char *)*((_QWORD *)&dest + 8);\n  v8 = 0LL;\n  if ( *((_QWORD *)&dest + 8) && **((_BYTE **)&dest + 8) == 45 )\n  {\n    a2 = 32LL;\n    v10 = strchr(*((const char **)&dest + 8), 32);\n    if ( v10 )\n      ++v10;\n    v7 = v10;\n  }\n  sub_40A415(&fd, a2);\n  if ( !(unsigned int)sub_40AEE6((__int64)&fd, a2) )\n  {\n    close(fd);\n    sub_40A477(v5, 1u);\n    close(0);\n    dup(1);\n    v2 = sub_4CC866(4LL, v6);\n    exit(v2);\n  }\n  close(v5);\n  return (unsigned int)fd;\n}\n"
    },
    {
        "func_name": "collect_thread_nr",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_46031C(__int64 a1)\n{\n  unsigned int v1; // ebx\n  const char *v2; // rax\n  __int64 v3; // r8\n  __int64 v4; // r9\n  unsigned __int64 v6; // [rsp+10h] [rbp-20h] BYREF\n  unsigned __int64 v7; // [rsp+18h] [rbp-18h]\n\n  v1 = *(_DWORD *)(a1 + 32);\n  v2 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 48);\n  if ( (unsigned int)sub_45FABF(v2, \"intr\", &v6, v1, v3, v4) )\n    return (void *)sub_45F76C(4u);\n  v7 = *(_QWORD *)(a1 + 24);\n  if ( v7 > v6 )\n    v7 = v6;\n  *(_QWORD *)(a1 + 24) = v6;\n  return sub_45FE0E(v6 - v7);\n}\n\n\n Revised code:\nstatic void FAST_FUNC collect_int(int_stat *s)\n{\n\tullong data[1];\n\tullong old;\n\n\tif (rdval(get_file(&proc_stat), \"intr\", data, s->no)) {\n\t\tput_question_marks(4);\n\t\treturn;\n\t}\n\n\told = s->old;\n\tif (data[0] < old) old = data[0];\t\t//sanitize\n\ts->old = data[0];\n\tscale(data[0] - old);\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_46040F(__int64 a1)\n{\n  const char *v1; // rax\n  __int64 v2; // r8\n  __int64 v3; // r9\n  unsigned __int64 v5; // [rsp+10h] [rbp-10h] BYREF\n  unsigned __int64 v6; // [rsp+18h] [rbp-8h]\n\n  v1 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 48);\n  if ( (unsigned int)sub_45FABF(v1, \"ctxt\", &v5, 1LL, v2, v3) )\n    return (void *)sub_45F76C(4u);\n  v6 = *(_QWORD *)(a1 + 24);\n  if ( v6 > v5 )\n    v6 = v5;\n  *(_QWORD *)(a1 + 24) = v5;\n  return sub_45FE0E(v5 - v6);\n}\n\n\n Revised code:\nstatic void FAST_FUNC collect_ctx(ctx_stat *s)\n{\n\tullong data[1];\n\tullong old;\n\n\tif (rdval(get_file(&proc_stat), \"ctxt\", data, 1)) {\n\t\tput_question_marks(4);\n\t\treturn;\n\t}\n\n\told = s->old;\n\tif (data[0] < old) old = data[0];\t\t//sanitize\n\ts->old = data[0];\n\tscale(data[0] - old);\n}\n\n## Example:\n\n Input code:\n__int64 sub_4FF998()\n{\n  __int64 result; // rax\n  __int64 v1; // rbx\n  char *v2; // rdx\n  char v3[1036]; // [rsp+0h] [rbp-420h] BYREF\n  int v4; // [rsp+40Ch] [rbp-14h]\n\n  result = **((unsigned int **)qword_75D458 + 6);\n  if ( (_DWORD)result )\n  {\n    v4 = *(_DWORD *)(*(_QWORD *)qword_75D458 + 20LL);\n    free(*(void **)(*(_QWORD *)qword_75D458 + 8 * (v4 + 4LL) + 8));\n    sub_4FE0EA((__int64)v3, 1024);\n    v1 = *(_QWORD *)qword_75D458;\n    v2 = sub_40A11F(v3, 1024LL);\n    result = v4 + 4LL;\n    *(_QWORD *)(v1 + 8 * result + 8) = v2;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void save_command_ps_at_cur_history(void)\n{\n\tif (command_ps[0] != BB_NUL) {\n\t\tint cur = state->cur_history;\n\t\tfree(state->history[cur]);\n\n# if ENABLE_UNICODE_SUPPORT\n\t\t{\n\t\t\tchar tbuf[MAX_LINELEN];\n\t\t\tsave_string(tbuf, sizeof(tbuf));\n\t\t\tstate->history[cur] = xstrdup(tbuf);\n\t\t}\n# else\n\t\tstate->history[cur] = xstrdup(command_ps);\n# endif\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *sub_46065C()\n{\n  const char *v0; // rax\n  __int64 v1; // r8\n  __int64 v2; // r9\n  __int64 v4; // [rsp+18h] [rbp-8h] BYREF\n\n  v0 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 64);\n  if ( (unsigned int)sub_45FB82(v0, (unsigned __int64 *)&v4, 4LL, (__int64)v0, v1, v2) )\n    return (void *)sub_45F76C(4u);\n  else\n    return sub_45FE0E(v4);\n}\n"
    },
    {
        "func_name": "move_to_col",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n_BYTE *__fastcall sub_4EED30(_BYTE *a1, _BYTE *a2, int a3, int a4)\n{\n  unsigned __int64 v6; // [rsp+10h] [rbp-20h]\n  _BYTE *v7; // [rsp+18h] [rbp-18h]\n  _BYTE *v8; // [rsp+28h] [rbp-8h]\n  _BYTE *v9; // [rsp+28h] [rbp-8h]\n\n  v7 = a1;\n  v6 = (unsigned __int64)a2;\n  if ( a1 > a2 )\n  {\n    v7 = a2;\n    v6 = (unsigned __int64)a1;\n  }\n  if ( a3 <= 0 )\n  {\n    v8 = v7;\n    if ( *v7 == 10 )\n      return v7;\n    while ( v6 >= (unsigned __int64)(v8 + 1) )\n    {\n      if ( v8[1] == 10 )\n      {\n        v6 = (unsigned __int64)v8;\n        break;\n      }\n      ++v8;\n    }\n  }\n  v9 = v7;\n  sub_4EEF5D(v7, v6, *((unsigned int *)qword_75D408 + 44));\n  if ( a4 == 1 )\n    return sub_4EEBB4((unsigned __int64)v7, v6);\n  return v9;\n}\n\n\n Revised code:\nstatic char *yank_delete(char *start, char *stop, int dist, int yf)\n{\n\tchar *p;\n\n\t// make sure start <= stop\n\tif (start > stop) {\n\t\t// they are backwards, reverse them\n\t\tp = start;\n\t\tstart = stop;\n\t\tstop = p;\n\t}\n\tif (dist <= 0) {\n\t\t// we cannot cross NL boundaries\n\t\tp = start;\n\t\tif (*p == '\\n')\n\t\t\treturn p;\n\t\t// dont go past a NewLine\n\t\tfor (; p + 1 <= stop; p++) {\n\t\t\tif (p[1] == '\\n') {\n\t\t\t\tstop = p;\t// \"stop\" just before NewLine\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tp = start;\n#if ENABLE_FEATURE_VI_YANKMARK\n\ttext_yank(start, stop, YDreg);\n#endif\n\tif (yf == YANKDEL) {\n\t\tp = text_hole_delete(start, stop);\n\t}\t\t\t\t\t// delete lines\n\treturn p;\n}\n\n## Example:\n\n Input code:\nconst char *__fastcall sub_4EDEC7(char *a1, const char *a2, int a3, int a4)\n{\n  int v7; // [rsp+2Ch] [rbp-14h]\n  const char *v8; // [rsp+30h] [rbp-10h]\n  char *v9; // [rsp+30h] [rbp-10h]\n  const char *i; // [rsp+38h] [rbp-8h]\n  const char *j; // [rsp+38h] [rbp-8h]\n\n  v7 = strlen(a2);\n  if ( a3 == 1 )\n  {\n    v8 = (const char *)(*((_QWORD *)qword_75D408 + 1) - 1LL);\n    if ( !a4 )\n      v8 = sub_4ED888(a1);\n    for ( i = a1; i < v8; ++i )\n    {\n      if ( !sub_4EDE69(i, a2, v7) )\n        return i;\n    }\n  }\n  else if ( a3 == -1 )\n  {\n    v9 = *(char **)qword_75D408;\n    if ( !a4 )\n      v9 = sub_4ED832((unsigned __int64)a1);\n    for ( j = &a1[-v7]; j >= v9; --j )\n    {\n      if ( !sub_4EDE69(j, a2, v7) )\n        return j;\n    }\n  }\n  return 0LL;\n}\n\n\n Revised code:\nsearch for pattern starting at p\nstatic char *char_search(char *p, const char *pat, int dir, int range)\n{\n\tchar *q;\n\tstruct re_pattern_buffer preg;\n\tint i;\n\tint size;\n\n\tre_syntax_options = RE_SYNTAX_POSIX_EXTENDED;\n\tpreg.translate = 0;\n\tpreg.fastmap = 0;\n\tpreg.buffer = 0;\n\tpreg.allocated = 0;\n\n\t// assume a LIMITED forward search\n\tq = next_line(p);\n\tq = end_line(q);\n\tq = end - 1;\n\tif (dir == BACK) {\n\t\tq = prev_line(p);\n\t\tq = text;\n\t}\n\t// count the number of chars to search over, forward or backward\n\tsize = q - p;\n\tif (size < 0)\n\t\tsize = p - q;\n\t// RANGE could be negative if we are searching backwards\n\trange = q - p;\n\n\tq = (char *)re_compile_pattern(pat, strlen(pat), (struct re_pattern_buffer *)&preg);\n\tif (q != 0) {\n\t\t// The pattern was not compiled\n\t\tstatus_line_bold(\"bad search pattern: \\\"%s\\\": %s\", pat, q);\n\t\ti = 0;\t\t\t// return p if pattern not compiled\n\t\tgoto cs1;\n\t}\n\n\tq = p;\n\tif (range < 0) {\n\t\tq = p - size;\n\t\tif (q < text)\n\t\t\tq = text;\n\t}\n\t// search for the compiled pattern, preg, in p[]\n\t// range < 0-  search backward\n\t// range > 0-  search forward\n\t// 0 < start < size\n\t// re_search() < 0  not found or error\n\t// re_search() > 0  index of found pattern\n\t//            struct pattern    char     int    int    int     struct reg\n\t// re_search (*pattern_buffer,  *string, size,  start, range,  *regs)\n\ti = re_search(&preg, q, size, 0, range, 0);\n\tif (i == -1) {\n\t\tp = 0;\n\t\ti = 0;\t\t\t// return NULL if pattern not found\n\t}\n cs1:\n\tif (dir == FORWARD) {\n\t\tp = p + i;\n\t} else {\n\t\tp = p - i;\n\t}\n\treturn p;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4EDBDE(int a1, int a2)\n{\n  _QWORD *v2; // rbx\n  _QWORD *v3; // rbx\n  unsigned __int64 v6; // [rsp+18h] [rbp-18h]\n\n  while ( a1 > 0 )\n  {\n    v2 = qword_75D408;\n    if ( a2 >= 0 )\n      v2[11] = sub_4ED888(*((void **)qword_75D408 + 11));\n    else\n      v2[11] = sub_4ED832(*((_QWORD *)qword_75D408 + 11));\n    --a1;\n  }\n  if ( *((_QWORD *)qword_75D408 + 2) < *((_QWORD *)qword_75D408 + 11) )\n    *((_QWORD *)qword_75D408 + 2) = *((_QWORD *)qword_75D408 + 11);\n  v6 = sub_4ED8CF();\n  if ( v6 < *((_QWORD *)qword_75D408 + 2) )\n  {\n    v3 = qword_75D408;\n    v3[2] = sub_4ED70A(v6);\n  }\n  return sub_4EDCAC();\n}\n\n\n Revised code:\nstatic void dot_scroll(int cnt, int dir)\n{\n\tchar *q;\n\n\tfor (; cnt > 0; cnt--) {\n\t\tif (dir < 0) {\n\t\t\t// scroll Backwards\n\t\t\t// ctrl-Y scroll up one line\n\t\t\tscreenbegin = prev_line(screenbegin);\n\t\t} else {\n\t\t\t// scroll Forwards\n\t\t\t// ctrl-E scroll down one line\n\t\t\tscreenbegin = next_line(screenbegin);\n\t\t}\n\t}\n\t// make sure \"dot\" stays on the screen so we dont scroll off\n\tif (dot < screenbegin)\n\t\tdot = screenbegin;\n\tq = end_screen();\t// find new bottom line\n\tif (dot > q)\n\t\tdot = begin_line(q);\t// is dot is below bottom line?\n\tdot_skip_over_ws();\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_4EDAEE(unsigned __int64 a1, int a2)\n{\n  char *v3; // [rsp+8h] [rbp-18h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_4ED70A(a1);\n  for ( i = 0; i < a2 && (unsigned __int64)v3 < *((_QWORD *)qword_75D408 + 1) && *v3 != 10; ++i )\n  {\n    if ( *v3 == 9 )\n    {\n      i = sub_4ED405(i);\n    }\n    else if ( *v3 <= 31 || *v3 == 127 )\n    {\n      ++i;\n    }\n    ++v3;\n  }\n  return v3;\n}\n"
    },
    {
        "func_name": "func_etime",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_4635CC(char *a1, int a2, __int64 a3)\n{\n  unsigned __int64 v3; // rbx\n  unsigned int v4; // eax\n\n  v3 = *(_QWORD *)(a3 + 72) + *(_QWORD *)(a3 + 64);\n  v4 = sub_4630E3();\n  return snprintf(a1, a2 + 1, \"%3lu:%02u\", v3 / v4 / 0x3C, v3 / v4 % 0x3C);\n}\n\n\n Revised code:\nstatic void func_time(char *buf, int size, const procps_status_t *ps)\n{\n\t/* cumulative time [[dd-]hh:]mm:ss; here only mm:ss */\n\tunsigned long mm;\n\tunsigned ss;\n\n\tmm = (ps->utime + ps->stime) / get_kernel_HZ();\n\tss = mm % 60;\n\tmm /= 60;\n\tsnprintf(buf, size+1, \"%3lu:%02u\", mm, ss);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4317A8(const char *a1, const char *a2, size_t a3)\n{\n  unsigned int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = strncmp(a1, a2, a3);\n  if ( v5 )\n    return v5;\n  else\n    return (unsigned int)-(unsigned __int8)a2[a3];\n}\n\n\n Revised code:\nstatic int strncmpz(const char *l, const char *r, size_t llen)\n{\n\tint i = strncmp(l, r, llen);\n\n\tif (i == 0)\n\t\treturn - (unsigned char)r[llen];\n\treturn i;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_481E8D(__int64 a1, unsigned int a2)\n{\n  __int64 v3; // rbx\n  unsigned int v4; // [rsp+4h] [rbp-2Ch]\n  char *ptr; // [rsp+10h] [rbp-20h]\n  char *v6; // [rsp+18h] [rbp-18h]\n\n  if ( !*(_QWORD *)a1 )\n    return sub_4818B0(a1, a2);\n  v3 = *(_QWORD *)a1;\n  v6 = (char *)(v3 + (int)sub_4819F4((_QWORD *)a1, a2));\n  if ( (unsigned int)sub_481A3B(v6) )\n  {\n    ptr = sub_40A11F(v6, a2);\n    *(_DWORD *)(a1 + 8) = (_DWORD)v6 - *(_DWORD *)a1;\n    v4 = sub_481B55(ptr, a1, a2);\n    free(ptr);\n    return v4;\n  }\n  else\n  {\n    *(_DWORD *)(a1 + 8) = (unsigned int)sub_47FF75(v6) - *(_DWORD *)a1;\n    return sub_4818B0(a1, a2);\n  }\n}\n\n\n Revised code:\nstatic int perform_glob(o_string *o, int n)\n{\n\tchar *pattern, *copy;\n\n\tdebug_printf_glob(\"start perform_glob: n:%d o->data:%p\\n\", n, o->data);\n\tif (!o->data)\n\t\treturn o_save_ptr_helper(o, n);\n\tpattern = o->data + o_get_last_ptr(o, n);\n\tdebug_printf_glob(\"glob pattern '%s'\\n\", pattern);\n\tif (!glob_needed(pattern)) {\n\t\t/* unbackslash last string in o in place, fix length */\n\t\to->length = unbackslash(pattern) - o->data;\n\t\tdebug_printf_glob(\"glob pattern '%s' is literal\\n\", pattern);\n\t\treturn o_save_ptr_helper(o, n);\n\t}\n\n\tcopy = xstrdup(pattern);\n\t/* \"forget\" pattern in o */\n\to->length = pattern - o->data;\n\tn = glob_brace(copy, o, n);\n\tfree(copy);\n\tif (DEBUG_GLOB)\n\t\tdebug_print_list(\"perform_glob returning\", o, n);\n\treturn n;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_46350A(char *a1, int a2, __int64 a3)\n{\n  unsigned __int64 v3; // rbx\n  unsigned __int64 v5; // [rsp+28h] [rbp-18h]\n\n  v3 = *(_QWORD *)(a3 + 80);\n  v5 = *(_QWORD *)&dest.c_cc[23] - v3 / (unsigned int)sub_4630E3();\n  return snprintf(a1, a2 + 1, \"%3lu:%02u\", v5 / 0x3C, v5 % 0x3C);\n}\n"
    },
    {
        "func_name": "remove_ids",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_49BC7F(unsigned int a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  char *v6; // r10\n  char *v7; // rax\n  __int64 v8; // rsi\n  __int64 v9; // rdx\n  __int64 v10; // rcx\n  __int64 v11; // r8\n  __int64 v12; // r9\n  char *v13; // [rsp+18h] [rbp-98h]\n  char v14[48]; // [rsp+20h] [rbp-90h] BYREF\n  time_t v15; // [rsp+50h] [rbp-60h] BYREF\n  time_t v16; // [rsp+60h] [rbp-50h] BYREF\n  unsigned __int64 v17; // [rsp+70h] [rbp-40h]\n  int v18; // [rsp+90h] [rbp-20h]\n  int v19; // [rsp+94h] [rbp-1Ch]\n  int v20; // [rsp+98h] [rbp-18h]\n  int v21; // [rsp+9Ch] [rbp-14h]\n  char *v22; // [rsp+A0h] [rbp-10h]\n  int semnum; // [rsp+ACh] [rbp-4h]\n\n  v22 = v14;\n  v13 = v14;\n  if ( semctl(a1, 0, 2, v14) )\n    return sub_4091D9((__int64)\"semctl\", 0LL, v1, v2, v3, v4);\n  if ( v15 )\n    v6 = ctime(&v15);\n  else\n    v6 = \"Not set\";\n  printf(\n    \"\\n\"\n    \"Semaphore Array semid=%d\\n\"\n    \"uid=%d\\t gid=%d\\t cuid=%d\\t cgid=%d\\n\"\n    \"mode=%#o, access_perms=%#o\\n\"\n    \"nsems = %ld\\n\"\n    \"otime = %-26.24s\\n\",\n    a1,\n    *((unsigned int *)v22 + 1),\n    *((unsigned int *)v22 + 2),\n    *((unsigned int *)v22 + 3),\n    *((unsigned int *)v22 + 4),\n    *((unsigned __int16 *)v22 + 10),\n    *((_WORD *)v22 + 10) & 0x1FF,\n    v17,\n    v6);\n  v7 = ctime(&v16);\n  printf(\"ctime = %-26.24s\\n%-10s %-10s %-10s %-10s %-10s\\n\", v7, \"semnum\", \"value\", \"ncount\", \"zcount\", \"pid\");\n  LODWORD(v13) = 0;\n  for ( semnum = 0; (unsigned int)semnum < v17; ++semnum )\n  {\n    v21 = semctl(a1, semnum, 12, v13);\n    v20 = semctl(a1, semnum, 14, v13);\n    v19 = semctl(a1, semnum, 15, v13);\n    v8 = (unsigned int)semnum;\n    v18 = semctl(a1, semnum, 11, v13);\n    if ( v21 < 0 || v20 < 0 || v19 < 0 || v18 < 0 )\n      sub_4092A2((__int64)\"semctl\", v8, v9, v10, v11, v12);\n    printf(\n      \"%-10d %-10d %-10d %-10d %-10d\\n\",\n      (unsigned int)semnum,\n      (unsigned int)v21,\n      (unsigned int)v20,\n      (unsigned int)v19,\n      (unsigned int)v18);\n  }\n  return sub_40A659(10);\n}\n\n\n Revised code:\nstatic void print_sem(int semid)\n{\n\tstruct semid_ds semds;\n\tstruct ipc_perm *ipcp = &semds.sem_perm;\n\tunion semun arg;\n\tunsigned int i;\n\n\targ.buf = &semds;\n\tif (semctl(semid, 0, IPC_STAT, arg)) {\n\t\tbb_perror_msg(\"semctl\");\n\t\treturn;\n\t}\n\n\tprintf(\"\\nSemaphore Array semid=%d\\n\"\n\t\t\t\"uid=%d\\t gid=%d\\t cuid=%d\\t cgid=%d\\n\"\n\t\t\t\"mode=%#o, access_perms=%#o\\n\"\n\t\t\t\"nsems = %ld\\n\"\n\t\t\t\"otime = %-26.24s\\n\",\n\t\t\tsemid,\n\t\t\tipcp->uid, ipcp->gid, ipcp->cuid, ipcp->cgid,\n\t\t\tipcp->mode, ipcp->mode & 0777,\n\t\t\t(long) semds.sem_nsems,\n\t\t\tsemds.sem_otime ? ctime(&semds.sem_otime) : \"Not set\");\n\tprintf(\"ctime = %-26.24s\\n\"\n\t\t\t\"%-10s %-10s %-10s %-10s %-10s\\n\",\n\t\t\tctime(&semds.sem_ctime),\n\t\t\t\"semnum\", \"value\", \"ncount\", \"zcount\", \"pid\");\n\n\targ.val = 0;\n\tfor (i = 0; i < semds.sem_nsems; i++) {\n\t\tint val, ncnt, zcnt, pid;\n\n\t\tval = semctl(semid, i, GETVAL, arg);\n\t\tncnt = semctl(semid, i, GETNCNT, arg);\n\t\tzcnt = semctl(semid, i, GETZCNT, arg);\n\t\tpid = semctl(semid, i, GETPID, arg);\n\t\tif (val < 0 || ncnt < 0 || zcnt < 0 || pid < 0) {\n\t\t\tbb_perror_msg_and_die(\"semctl\");\n\t\t}\n\t\tprintf(\"%-10d %-10d %-10d %-10d %-10d\\n\", i, val, ncnt, zcnt, pid);\n\t}\n\tbb_putchar('\\n');\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4715A3(__int64 a1, __int64 a2)\n{\n  unsigned int v2; // eax\n  int v4; // [rsp+4h] [rbp-2Ch]\n  __int64 v5; // [rsp+8h] [rbp-28h]\n  unsigned int v6; // [rsp+1Ch] [rbp-14h]\n  unsigned int pgrp; // [rsp+20h] [rbp-10h]\n  int v8; // [rsp+24h] [rbp-Ch]\n  __int64 v9; // [rsp+28h] [rbp-8h]\n\n  v5 = a1;\n  v4 = a2;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  if ( *(_BYTE *)(a1 + 30) != 2 )\n  {\n    *(_BYTE *)(a1 + 30) = 0;\n    pgrp = **(_DWORD **)(a1 + 16);\n    if ( !(_DWORD)a2 )\n      sub_471133(dword_75AE30, pgrp);\n    a2 = 18LL;\n    a1 = pgrp;\n    killpg(pgrp, 18);\n    v9 = *(_QWORD *)(v5 + 16);\n    v8 = *(unsigned __int16 *)(v5 + 28);\n    do\n    {\n      if ( (unsigned __int8)*(_DWORD *)(v9 + 4) == 127 )\n        *(_DWORD *)(v9 + 4) = -1;\n      v9 += 16LL;\n      --v8;\n    }\n    while ( v8 );\n  }\n  if ( v4 )\n  {\n    v2 = 0;\n  }\n  else\n  {\n    a1 = v5;\n    v2 = sub_472F50(v5);\n  }\n  v6 = v2;\n  sub_46E03F(a1, a2);\n  return v6;\n}\n\n\n Revised code:\nstatic int\nrestartjob(struct job *jp, int mode)\n{\n\tstruct procstat *ps;\n\tint i;\n\tint status;\n\tpid_t pgid;\n\n\tINT_OFF;\n\tif (jp->state == JOBDONE)\n\t\tgoto out;\n\tjp->state = JOBRUNNING;\n\tpgid = jp->ps[0].ps_pid;\n\tif (mode == FORK_FG)\n\t\txtcsetpgrp(ttyfd, pgid);\n\tkillpg(pgid, SIGCONT);\n\tps = jp->ps;\n\ti = jp->nprocs;\n\tdo {\n\t\tif (WIFSTOPPED(ps->ps_status)) {\n\t\t\tps->ps_status = -1;\n\t\t}\n\t\tps++;\n\t} while (--i);\n out:\n\tstatus = (mode == FORK_FG) ? waitforjob(jp) : 0;\n\tINT_ON;\n\treturn status;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4A21A0(__int64 *a1, __int64 a2, const void *a3)\n{\n  const char *v3; // rsi\n  __int64 v4; // rdx\n  __int64 v5; // rcx\n  __int64 v6; // r8\n  __int64 v7; // r9\n  unsigned __int64 v10; // [rsp+10h] [rbp-60h]\n  unsigned int v11; // [rsp+6Ch] [rbp-4h]\n\n  v10 = a2;\n  v11 = 0;\n  if ( (dword_75D450 & 0x40) != 0 )\n  {\n    if ( dest.c_iflag > 1 )\n      sub_409747(\"would do mount('%s','%s','%s',0x%08lx,'%s')\", *a1, a1[1], a1[2], a2, (__int64)a3);\n  }\n  else\n  {\n    while ( 1 )\n    {\n      *(_DWORD *)qword_75D400 = 0;\n      v3 = (const char *)a1[1];\n      v11 = sub_4A1CAF((const char *)*a1, v3, (const char *)a1[2], v10, a3);\n      if ( !v11 || (v10 & 1) != 0 || *(_DWORD *)qword_75D400 != 13 && *(_DWORD *)qword_75D400 != 30 )\n        break;\n      if ( (v10 & 0x8000) == 0 )\n        sub_409747(\"%s is write-protected, mounting read-only\", *a1, v4, v5, v6, v7);\n      v10 |= 1uLL;\n    }\n    if ( v11 && *(_DWORD *)qword_75D400 == 1 )\n      sub_40969E(\"permission denied (are you root?)\", (__int64)v3, v4, v5, v6, v7);\n  }\n  return v11;\n}\n\n\n Revised code:\nxxx fields may be trashed on exit\nstatic int mount_it_now(struct mntent *mp, unsigned long vfsflags, char *filteropts)\n{\n\tint rc = 0;\n\n\tif (FAKE_IT) {\n\t\tif (verbose >= 2)\n\t\t\tbb_error_msg(\"would do mount('%s','%s','%s',0x%08lx,'%s')\",\n\t\t\t\tmp->mnt_fsname, mp->mnt_dir, mp->mnt_type,\n\t\t\t\tvfsflags, filteropts);\n\t\tgoto mtab;\n\t}\n\n\t// Mount, with fallback to read-only if necessary.\n\tfor (;;) {\n\t\terrno = 0;\n\t\trc = verbose_mount(mp->mnt_fsname, mp->mnt_dir, mp->mnt_type,\n\t\t\t\tvfsflags, filteropts);\n\n\t\t// If mount failed, try\n\t\t// helper program mount.<mnt_type>\n\t\tif (HELPERS_ALLOWED && rc && mp->mnt_type) {\n\t\t\tchar *args[8];\n\t\t\tint errno_save = errno;\n\t\t\targs[0] = xasprintf(\"mount.%s\", mp->mnt_type);\n\t\t\trc = 1;\n\t\t\tif (FAKE_IT)\n\t\t\t\targs[rc++] = (char *)\"-f\";\n\t\t\tif (ENABLE_FEATURE_MTAB_SUPPORT && !USE_MTAB)\n\t\t\t\targs[rc++] = (char *)\"-n\";\n\t\t\targs[rc++] = mp->mnt_fsname;\n\t\t\targs[rc++] = mp->mnt_dir;\n\t\t\tif (filteropts) {\n\t\t\t\targs[rc++] = (char *)\"-o\";\n\t\t\t\targs[rc++] = filteropts;\n\t\t\t}\n\t\t\targs[rc] = NULL;\n\t\t\trc = spawn_and_wait(args);\n\t\t\tfree(args[0]);\n\t\t\tif (!rc)\n\t\t\t\tbreak;\n\t\t\terrno = errno_save;\n\t\t}\n\n\t\tif (!rc || (vfsflags & MS_RDONLY) || (errno != EACCES && errno != EROFS))\n\t\t\tbreak;\n\t\tif (!(vfsflags & MS_SILENT))\n\t\t\tbb_error_msg(\"%s is write-protected, mounting read-only\",\n\t\t\t\t\t\tmp->mnt_fsname);\n\t\tvfsflags |= MS_RDONLY;\n\t}\n\n\t// Abort entirely if permission denied.\n\n\tif (rc && errno == EPERM)\n\t\tbb_error_msg_and_die(bb_msg_perm_denied_are_you_root);\n\n\t// If the mount was successful, and we're maintaining an old-style\n\t// mtab file by hand, add the new entry to it now.\n mtab:\n\tif (USE_MTAB && !rc && !(vfsflags & MS_REMOUNT)) {\n\t\tchar *fsname;\n\t\tFILE *mountTable = setmntent(bb_path_mtab_file, \"a+\");\n\t\tconst char *option_str = mount_option_str;\n\t\tint i;\n\n\t\tif (!mountTable) {\n\t\t\tbb_perror_msg(bb_path_mtab_file);\n\t\t\tgoto ret;\n\t\t}\n\n\t\t// Add vfs string flags\n\t\tfor (i = 0; mount_options[i] != MS_REMOUNT; i++) {\n\t\t\tif (mount_options[i] > 0 && (mount_options[i] & vfsflags))\n\t\t\t\tappend_mount_options(&(mp->mnt_opts), option_str);\n\t\t\toption_str += strlen(option_str) + 1;\n\t\t}\n\n\t\t// Remove trailing / (if any) from directory we mounted on\n\t\ti = strlen(mp->mnt_dir) - 1;\n\t\twhile (i > 0 && mp->mnt_dir[i] == '/')\n\t\t\tmp->mnt_dir[i--] = '\\0';\n\n\t\t// Convert to canonical pathnames as needed\n\t\tmp->mnt_dir = bb_simplify_path(mp->mnt_dir);\n\t\tfsname = NULL;\n\t\tif (!mp->mnt_type || !*mp->mnt_type) { // bind mount\n\t\t\tmp->mnt_fsname = fsname = bb_simplify_path(mp->mnt_fsname);\n\t\t\tmp->mnt_type = (char*)\"bind\";\n\t\t}\n\t\tmp->mnt_freq = mp->mnt_passno = 0;\n\n\t\t// Write and close\n#if ENABLE_FEATURE_MTAB_SUPPORT\n\t\tif (vfsflags & MS_MOVE)\n\t\t\tupdate_mtab_entry_on_move(mp);\n\t\telse\n#endif\n\t\t\taddmntent(mountTable, mp);\n\t\tendmntent(mountTable);\n\n\t\tif (ENABLE_FEATURE_CLEAN_UP) {\n\t\t\tfree(mp->mnt_dir);\n\t\t\tfree(fsname);\n\t\t}\n\t}\n ret:\n\treturn rc;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_49A5BC(int a1, const char **a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  const char **v7; // [rsp+0h] [rbp-30h]\n  unsigned __int64 semid; // [rsp+20h] [rbp-10h]\n  int v9; // [rsp+28h] [rbp-8h]\n  unsigned int v10; // [rsp+2Ch] [rbp-4h]\n\n  v7 = a2;\n  v10 = 0;\n  while ( *v7 )\n  {\n    semid = sub_49A56E(*v7, 0LL, 10);\n    if ( *(_DWORD *)qword_75D400 || semid > 0x7FFFFFFF )\n    {\n      sub_409747(\"invalid id: %s\", (__int64)*v7, v2, v3, v4, v5, v7);\n      ++v10;\n    }\n    else\n    {\n      v9 = 0;\n      switch ( a1 )\n      {\n        case 1:\n          v9 = semctl(semid, 0, 0, 0);\n          break;\n        case 2:\n          v9 = msgctl(semid, 0, 0LL);\n          break;\n        case 0:\n          v9 = shmctl(semid, 0, 0LL);\n          break;\n      }\n      if ( v9 )\n      {\n        sub_4091D9((__int64)\"can't remove id %s\", (__int64)*v7, v2, v3, v4, v5);\n        ++v10;\n      }\n    }\n    ++v7;\n  }\n  return v10;\n}\n"
    },
    {
        "func_name": "ftp_send",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_47167A(__int64 a1, _BYTE **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  unsigned int v10; // eax\n  _BYTE **v12; // [rsp+0h] [rbp-30h]\n  unsigned int v13; // [rsp+1Ch] [rbp-14h]\n  __int64 v14; // [rsp+20h] [rbp-10h]\n  _BOOL4 v15; // [rsp+2Ch] [rbp-4h]\n\n  v15 = **a2 != 102;\n  sub_46F038((_BYTE *)(qword_75D418 + 56), (__int64)a2, a3, a4, a5, a6);\n  v12 = (_BYTE **)qword_75AF58;\n  do\n  {\n    v14 = sub_470E8F(*v12, 1, v6, v7, v8, v9);\n    if ( v15 )\n    {\n      sub_470DAE(v14, 1);\n      v10 = sub_470E5C(v14);\n      printf(\"[%d] \", v10);\n    }\n    sub_46E2C6(*(const char **)(*(_QWORD *)(v14 + 16) + 8LL));\n    sub_471522(v14);\n    v13 = sub_4715A3(v14, v15);\n    if ( !*v12 )\n      break;\n    ++v12;\n  }\n  while ( *v12 );\n  return v13;\n}\n\n\n Revised code:\nstatic int FAST_FUNC\nfg_bgcmd(int argc UNUSED_PARAM, char **argv)\n{\n\tstruct job *jp;\n\tint mode;\n\tint retval;\n\n\tmode = (**argv == 'f') ? FORK_FG : FORK_BG;\n\tnextopt(nullstr);\n\targv = argptr;\n\tdo {\n\t\tjp = getjob(*argv, 1);\n\t\tif (mode == FORK_BG) {\n\t\t\tset_curjob(jp, CUR_RUNNING);\n\t\t\tprintf(\"[%d] \", jobno(jp));\n\t\t}\n\t\tout1str(jp->ps[0].ps_cmd);\n\t\tshowpipe(jp /*, stdout*/);\n\t\tretval = restartjob(jp, mode);\n\t} while (*argv && *++argv);\n\treturn retval;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_470439(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  char *v11; // [rsp+18h] [rbp-8h]\n\n  v11 = *(char **)(qword_75D418 + 16);\n  if ( (unsigned int)sub_46FDFE(a1, a2, a3, a4, a5, a6) )\n  {\n    v6 = qword_75D418 + 56;\n    if ( *(_QWORD *)(qword_75D418 + 24) == qword_75D418 + 56 )\n      sub_470099(v11, 0LL);\n    v11 = *(char **)(qword_75D418 + 24);\n  }\n  sub_46E137(\"%s\\n\", (__int64)v11, v6, v7, v8, v9, a2);\n  return 0LL;\n}\n\n\n Revised code:\nstatic int FAST_FUNC\npwdcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tint flags;\n\tconst char *dir = curdir;\n\n\tflags = cdopt();\n\tif (flags) {\n\t\tif (physdir == nullstr)\n\t\t\tsetpwd(dir, 0);\n\t\tdir = physdir;\n\t}\n\tout1fmt(\"%s\\n\", dir);\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_42FBAE(const char *a1, __int16 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  unsigned int v7; // [rsp+1Ch] [rbp-4h]\n\n  v7 = sub_42FB81(a1, a2 | 1);\n  if ( v7 )\n    sub_4091D9((__int64)\"%s: can't up\", (__int64)a1, v2, v3, v4, v5);\n  return v7;\n}\n\n\n Revised code:\nstatic int set_if_up(char *ifname, int flags)\n{\n\tint res = set_if_flags(ifname, flags | IFF_UP);\n\tif (res)\n\t\tbb_perror_msg(\"%s: can't up\", ifname);\n\treturn res;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_42B203(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  __int64 v10; // rdx\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  __int64 v13; // r9\n  int v15; // [rsp+14h] [rbp-Ch]\n  int v16; // [rsp+18h] [rbp-8h]\n  int v17; // [rsp+1Ch] [rbp-4h]\n\n  v16 = sub_42AEF9(a1, a2, a3, a4, a5, a6);\n  v17 = 0;\n  if ( *(_BYTE *)a2 != 45 || *(_BYTE *)(a2 + 1) )\n    v17 = sub_40A295((const char *)a2, 0);\n  v15 = sub_42AD2D((__int64)\"STOR\", a1, v6, v7, v8, v9);\n  if ( v15 != 125 && v15 != 150 )\n    sub_42ACB6(\"STOR\", a1, v10, v11, v12, v13);\n  return sub_42AFF7(v17, v16);\n}\n"
    },
    {
        "func_name": "xstrdup",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_40A020(size_t a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  void *v7; // [rsp+18h] [rbp-8h]\n\n  v7 = malloc(a1);\n  if ( !v7 && a1 )\n    sub_409747(\"out of memory\", a2, v2, v3, v4, v5);\n  return v7;\n}\n\n\n Revised code:\nFAST_FUNC malloc_or_warn(size_t size)\n{\n\tvoid *ptr = malloc(size);\n\tif (ptr == NULL && size != 0)\n\t\tbb_error_msg(bb_msg_memory_exhausted);\n\treturn ptr;\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_40A05F(size_t a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  void *v7; // [rsp+18h] [rbp-8h]\n\n  v7 = malloc(a1);\n  if ( !v7 && a1 )\n    sub_40969E(\"out of memory\", a2, v2, v3, v4, v5);\n  return v7;\n}\n\n\n Revised code:\nFAST_FUNC xmalloc(size_t size)\n{\n\tvoid *ptr = malloc(size);\n\tif (ptr == NULL && size != 0)\n\t\tbb_error_msg_and_die(bb_msg_memory_exhausted);\n\treturn ptr;\n}\n\n## Example:\n\n Input code:\nvoid *__fastcall sub_5074C8(const char *a1, unsigned __int64 *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  void *v7; // [rsp+18h] [rbp-8h]\n\n  v7 = sub_5073F7(a1, a2);\n  if ( !v7 )\n    sub_4092A2((__int64)\"can't read '%s'\", (__int64)a1, v2, v3, v4, v5, a2);\n  return v7;\n}\n\n\n Revised code:\nFAST_FUNC xmalloc_xopen_read_close(const char *filename, size_t *maxsz_p)\n{\n\tvoid *buf = xmalloc_open_read_close(filename, maxsz_p);\n\tif (!buf)\n\t\tbb_perror_msg_and_die(\"can't read '%s'\", filename);\n\treturn buf;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_40A11F(const char *a1, __int64 a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // [rsp+18h] [rbp-8h]\n\n  if ( !a1 )\n    return 0LL;\n  v7 = strdup(a1);\n  if ( !v7 )\n    sub_40969E(\"out of memory\", a2, v3, v4, v5, v6);\n  return v7;\n}\n"
    },
    {
        "func_name": "setsignal",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __fastcall sub_471AE1(FILE *a1, __int64 a2, char a3)\n{\n  int result; // eax\n  unsigned int v4; // eax\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 v7; // r8\n  __int64 v8; // r9\n  int v9; // eax\n  int v10; // eax\n  const char *v11; // rdi\n  unsigned int v12; // ecx\n  char v15[80]; // [rsp+20h] [rbp-70h] BYREF\n  unsigned int *v16; // [rsp+70h] [rbp-20h]\n  unsigned int v17; // [rsp+7Ch] [rbp-14h]\n  int v18; // [rsp+80h] [rbp-10h]\n  unsigned int v19; // [rsp+84h] [rbp-Ch]\n  unsigned int *v20; // [rsp+88h] [rbp-8h]\n\n  v20 = *(unsigned int **)(a2 + 16);\n  if ( (a3 & 1) != 0 )\n    return fprintf(a1, \"%d\\n\", *v20);\n  v4 = sub_470E5C(a2);\n  v19 = sub_46E1F9(v15, 0x10uLL, \"[%d]   \", v4, v5, v6);\n  v17 = v19;\n  if ( a2 == qword_75AFB0 )\n  {\n    v15[v19 - 3] = 43;\n  }\n  else if ( qword_75AFB0 && a2 == *(_QWORD *)(qword_75AFB0 + 32) )\n  {\n    v15[v19 - 3] = 45;\n  }\n  if ( (a3 & 2) != 0 )\n  {\n    v9 = sub_46E1F9(&v15[v19], 0x10uLL, \"%d \", *v20, v7, v8);\n    v19 += v9;\n  }\n  v16 = &v20[4 * *(unsigned __int16 *)(a2 + 28)];\n  if ( *(_BYTE *)(a2 + 30) )\n  {\n    v18 = *(v16 - 3);\n    if ( *(_BYTE *)(a2 + 30) == 1 )\n      v18 = *(_DWORD *)(a2 + 24);\n    v10 = sub_471762(&v15[v19], v18, 0, (__int64)&v15[v19], v7, v8);\n    v19 += v10;\n  }\n  else\n  {\n    *(_QWORD *)&v15[v19] = 0x676E696E6E7552LL;\n    v19 += 7;\n  }\n  while ( 1 )\n  {\n    if ( v20 == *(unsigned int **)(a2 + 16) )\n      v11 = (const char *)&unk_51CA3E;\n    else\n      v11 = \"| \";\n    v12 = 0;\n    if ( (int)(33 - v19) >= 0 )\n      v12 = 33 - v19;\n    fprintf(a1, \"%s%*c%s%s\", v15, v12, 32LL, v11, *((const char **)v20 + 1));\n    v20 += 4;\n    if ( v20 == v16 )\n      break;\n    v15[0] = 0;\n    v19 = 33;\n    if ( (a3 & 2) != 0 )\n      v19 = sub_46E1F9(v15, 0x30uLL, \"\\n%*c%d \", v17, 32LL, *v20) - 1;\n  }\n  sub_46E0F3(10, a1);\n  *(_BYTE *)(a2 + 31) &= ~0x10u;\n  result = *(unsigned __int8 *)(a2 + 30);\n  if ( (_BYTE)result == 2 )\n    return sub_47107C(a2);\n  return result;\n}\n\n\n Revised code:\nif JOBS\nstatic void\nshowjob(FILE *out, struct job *jp, int mode)\n{\n\tstruct procstat *ps;\n\tstruct procstat *psend;\n\tint col;\n\tint indent_col;\n\tchar s[80];\n\n\tps = jp->ps;\n\n\tif (mode & SHOW_ONLY_PGID) { /* jobs -p */\n\t\t/* just output process (group) id of pipeline */\n\t\tfprintf(out, \"%d\\n\", ps->ps_pid);\n\t\treturn;\n\t}\n\n\tcol = fmtstr(s, 16, \"[%d]   \", jobno(jp));\n\tindent_col = col;\n\n\tif (jp == curjob)\n\t\ts[col - 3] = '+';\n\telse if (curjob && jp == curjob->prev_job)\n\t\ts[col - 3] = '-';\n\n\tif (mode & SHOW_PIDS)\n\t\tcol += fmtstr(s + col, 16, \"%d \", ps->ps_pid);\n\n\tpsend = ps + jp->nprocs;\n\n\tif (jp->state == JOBRUNNING) {\n\t\tstrcpy(s + col, \"Running\");\n\t\tcol += sizeof(\"Running\") - 1;\n\t} else {\n\t\tint status = psend[-1].ps_status;\n\t\tif (jp->state == JOBSTOPPED)\n\t\t\tstatus = jp->stopstatus;\n\t\tcol += sprint_status(s + col, status, 0);\n\t}\n\t/* By now, \"[JOBID]*  [maybe PID] STATUS\" is printed */\n\n\t/* This loop either prints \"<cmd1> | <cmd2> | <cmd3>\" line\n\t * or prints several \"PID             | <cmdN>\" lines,\n\t * depending on SHOW_PIDS bit.\n\t * We do not print status of individual processes\n\t * between PID and <cmdN>. bash does it, but not very well:\n\t * first line shows overall job status, not process status,\n\t * making it impossible to know 1st process status.\n\t */\n\tgoto start;\n\tdo {\n\t\t/* for each process */\n\t\ts[0] = '\\0';\n\t\tcol = 33;\n\t\tif (mode & SHOW_PIDS)\n\t\t\tcol = fmtstr(s, 48, \"\\n%*c%d \", indent_col, ' ', ps->ps_pid) - 1;\n start:\n\t\tfprintf(out, \"%s%*c%s%s\",\n\t\t\t\ts,\n\t\t\t\t33 - col >= 0 ? 33 - col : 0, ' ',\n\t\t\t\tps == jp->ps ? \"\" : \"| \",\n\t\t\t\tps->ps_cmd\n\t\t);\n\t} while (++ps != psend);\n\toutcslow('\\n', out);\n\n\tjp->changed = 0;\n\n\tif (jp->state == JOBDONE) {\n\t\tTRACE((\"showjob: freeing job %d\\n\", jobno(jp)));\n\t\tfreejob(jp);\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_46F900(unsigned __int8 *a1)\n{\n  __int64 *v1; // rax\n  int v2; // eax\n  int v4; // [rsp+14h] [rbp-1Ch]\n  void *ptr; // [rsp+18h] [rbp-18h]\n  __int64 *v6; // [rsp+20h] [rbp-10h]\n  unsigned int v7; // [rsp+2Ch] [rbp-4h]\n\n  v1 = (__int64 *)sub_46F2C1(a1);\n  v6 = sub_46F3E8(v1, (char *)a1);\n  ptr = (void *)*v6;\n  v7 = 2;\n  if ( *v6 )\n  {\n    v4 = *((_DWORD *)ptr + 2);\n    v7 = 1;\n    if ( (v4 & 2) == 0 )\n    {\n      v2 = *((_DWORD *)ptr + 2);\n      BYTE1(v2) &= ~2u;\n      *((_DWORD *)ptr + 2) = v2;\n      if ( (v4 & 0x20) == 0 )\n      {\n        if ( (v4 & 4) != 0 )\n        {\n          sub_46F6BF((char *)a1, 0LL, 0);\n          *((_DWORD *)ptr + 2) &= ~1u;\n        }\n        else\n        {\n          ++*(_DWORD *)(qword_75D418 + 48);\n          if ( (v4 & 0x18) == 0 )\n            free(*((void **)ptr + 2));\n          *v6 = *(_QWORD *)ptr;\n          free(ptr);\n          sub_46E03F(ptr, a1);\n        }\n      }\n      return 0;\n    }\n  }\n  return v7;\n}\n\n\n Revised code:\nstatic int\nunsetvar(const char *s)\n{\n\tstruct var **vpp;\n\tstruct var *vp;\n\tint retval;\n\n\tvpp = findvar(hashvar(s), s);\n\tvp = *vpp;\n\tretval = 2;\n\tif (vp) {\n\t\tint flags = vp->flags;\n\n\t\tretval = 1;\n\t\tif (flags & VREADONLY)\n\t\t\tgoto out;\n#if ENABLE_ASH_RANDOM_SUPPORT\n\t\tvp->flags &= ~VDYNAMIC;\n#endif\n\t\tif (flags & VUNSET)\n\t\t\tgoto ok;\n\t\tif ((flags & VSTRFIXED) == 0) {\n\t\t\tINT_OFF;\n\t\t\tif ((flags & (VTEXTFIXED|VSTACK)) == 0)\n\t\t\t\tfree((char*)vp->var_text);\n\t\t\t*vpp = vp->next;\n\t\t\tfree(vp);\n\t\t\tINT_ON;\n\t\t} else {\n\t\t\tsetvar(s, 0, 0);\n\t\t\tvp->flags &= ~VEXPORT;\n\t\t}\n ok:\n\t\tretval = 0;\n\t}\n out:\n\treturn retval;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_48EF6A(__int64 a1, __int64 a2)\n{\n  unsigned __int64 v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v7; // eax\n  __int64 *v9; // [rsp+0h] [rbp-30h]\n  __int64 *v10; // [rsp+0h] [rbp-30h]\n  unsigned __int64 v11; // [rsp+10h] [rbp-20h] BYREF\n  int fd; // [rsp+1Ch] [rbp-14h]\n  const char *v13; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v14; // [rsp+28h] [rbp-8h]\n\n  v9 = (__int64 *)(a2 + 8);\n  if ( !*(_QWORD *)(a2 + 8) || !*(_QWORD *)(a2 + 16) )\n    sub_407F64();\n  v13 = sub_48EEFF(*v9);\n  v14 = v13[15];\n  if ( (v13[14] & 4) != 0 )\n  {\n    v9 = (__int64 *)(a2 + 16);\n    v14 = (int)sub_50B306(*(_QWORD *)(a2 + 16));\n  }\n  v10 = v9 + 1;\n  if ( !*v10 || v10[1] )\n    sub_407F64();\n  fd = sub_40A295((const char *)*v10, 0);\n  v11 = v14;\n  v2 = *(unsigned int *)v13;\n  if ( ioctl(fd, v2, &v11) == -1 )\n    sub_409392(*v10, v2, v3, v4, v5, v6);\n  v14 = v11;\n  if ( (v13[14] & 0x10) != 0 )\n    v14 >>= 9;\n  v7 = v13[14] & 0xB;\n  if ( v7 == 2 || v7 == 3 )\n  {\n    printf(\"%llu\\n\", v14);\n  }\n  else if ( v7 == 1 )\n  {\n    printf(\"%lld\\n\", (int)v14);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nint blockdev_main(int argc UNUSED_PARAM, char **argv)\n{\n\tconst struct bdc *bdcmd;\n\tint fd;\n\tuint64_t u64;\n\tunion {\n\t\tint i;\n\t\tunsigned long lu;\n\t\tuint64_t u64;\n\t} ioctl_val_on_stack;\n\n\targv++;\n\tif (!argv[0] || !argv[1]) /* must have at least 2 args */\n\t\tbb_show_usage();\n\n\tbdcmd = find_cmd(*argv);\n\n\tu64 = (int)bdcmd->argval;\n\tif (bdcmd->flags & FL_USRARG)\n\t\tu64 = xatoi_positive(*++argv);\n\n\targv++;\n\tif (!argv[0] || argv[1])\n\t\tbb_show_usage();\n\tfd = xopen(argv[0], O_RDONLY);\n\n\tioctl_val_on_stack.u64 = u64;\n#if BB_BIG_ENDIAN\n\t/* Store data properly wrt data size.\n\t * (1) It's no-op for little-endian.\n\t * (2) it's no-op for 0 and -1. Only --setro uses arg != 0 and != -1,\n\t * and it is ARG_INT. --setbsz USER_VAL is also ARG_INT.\n\t * Thus, we don't need to handle ARG_ULONG.\n\t */\n\tswitch (bdcmd->flags & ARG_MASK) {\n\tcase ARG_INT:\n\t\tioctl_val_on_stack.i = (int)u64;\n\t\tbreak;\n# if 0 /* unused */\n\tcase ARG_ULONG:\n\t\tioctl_val_on_stack.lu = (unsigned long)u64;\n\t\tbreak;\n# endif\n\t}\n#endif\n\n\tif (ioctl(fd, bdcmd->ioc, &ioctl_val_on_stack.u64) == -1)\n\t\tbb_simple_perror_msg_and_die(*argv);\n\n\t/* Fetch it into register(s) */\n\tu64 = ioctl_val_on_stack.u64;\n\n\tif (bdcmd->flags & FL_SCALE512)\n\t\tu64 >>= 9;\n\n\t/* Zero- or one-extend the value if needed, then print */\n\tswitch (bdcmd->flags & (ARG_MASK+FL_NORESULT)) {\n\tcase ARG_INT:\n\t\t/* Smaller code when we use long long\n\t\t * (gcc tail-merges printf call)\n\t\t */\n\t\tprintf(\"%lld\\n\", (long long)(int)u64);\n\t\tbreak;\n\tcase ARG_ULONG:\n\t\tu64 = (unsigned long)u64;\n\t\t/* FALLTHROUGH */\n\tcase ARG_U64:\n\t\tprintf(\"%llu\\n\", (unsigned long long)u64);\n\t\tbreak;\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tclose(fd);\n\treturn EXIT_SUCCESS;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_470BAC(int a1)\n{\n  int result; // eax\n  struct sigaction v2; // [rsp+10h] [rbp-B0h] BYREF\n  unsigned __int8 *v3; // [rsp+B0h] [rbp-10h]\n  unsigned __int8 v4; // [rsp+BEh] [rbp-2h]\n  unsigned __int8 v5; // [rsp+BFh] [rbp-1h]\n\n  v3 = *(unsigned __int8 **)(qword_75D418 + 8 * (a1 + 26LL));\n  v4 = 1;\n  if ( v3 )\n  {\n    v4 = 2;\n    if ( !*v3 )\n      v4 = 3;\n  }\n  if ( !*(_DWORD *)(qword_75D418 + 4) && v4 == 1 )\n  {\n    switch ( a1 )\n    {\n      case 2:\n        if ( *(_BYTE *)(qword_75D418 + 60) || *(_QWORD *)(qword_75D418 + 8) || !*(_BYTE *)(qword_75D418 + 63) )\n          v4 = 2;\n        break;\n      case 3:\n        v4 = 3;\n        break;\n      case 15:\n        if ( *(_BYTE *)(qword_75D418 + 60) )\n          v4 = 3;\n        break;\n      case 20:\n      case 22:\n        if ( *(_BYTE *)(qword_75D418 + 61) )\n          v4 = 3;\n        break;\n      default:\n        break;\n    }\n  }\n  v3 = (unsigned __int8 *)(a1 - 1 + 64LL + qword_75D418 + 8);\n  result = *v3;\n  v5 = *v3;\n  if ( !v5 )\n  {\n    result = sigaction(a1, 0LL, &v2);\n    if ( result )\n      return result;\n    result = (int)v2.sa_handler;\n    if ( v2.sa_handler == (__sighandler_t)1 )\n    {\n      v5 = 4;\n      result = *(unsigned __int8 *)(qword_75D418 + 61);\n      if ( (_BYTE)result )\n      {\n        if ( a1 == 20 || a1 == 21 || a1 == 22 )\n          v5 = 3;\n      }\n    }\n  }\n  if ( v5 != 4 )\n  {\n    result = v5;\n    if ( v5 != v4 )\n    {\n      v2.sa_handler = 0LL;\n      if ( v4 == 2 )\n      {\n        v2.sa_handler = (__sighandler_t)sub_470B36;\n      }\n      else if ( v4 == 3 )\n      {\n        v2.sa_handler = (__sighandler_t)1;\n      }\n      v2.sa_flags = 0;\n      sigfillset(&v2.sa_mask);\n      sub_5081A2((unsigned int)a1, &v2);\n      result = (int)v3;\n      *v3 = v4;\n    }\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "hashcd",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 sub_413733()\n{\n  __int64 result; // rax\n  int v1; // [rsp+10h] [rbp-20h]\n  int v2; // [rsp+14h] [rbp-1Ch]\n  unsigned __int8 *v3; // [rsp+18h] [rbp-18h]\n  int j; // [rsp+24h] [rbp-Ch]\n  unsigned int i; // [rsp+28h] [rbp-8h]\n  int v6; // [rsp+2Ch] [rbp-4h]\n\n  v1 = *((unsigned __int8 *)qword_75D408 + 82) - *((_DWORD *)qword_75D408 + 4);\n  v3 = (unsigned __int8 *)(*(_QWORD *)qword_75D408 + *((int *)qword_75D408 + 10) + (__int64)*((int *)qword_75D408 + 11));\n  v6 = 0;\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i >= v1 )\n      break;\n    result = i;\n    if ( *((_DWORD *)qword_75D408 + 14) <= i )\n      break;\n    v2 = 0;\n    for ( j = 0; j < *((unsigned __int8 *)qword_75D408 + 83); ++j )\n    {\n      if ( (unsigned int)(j - *((_DWORD *)qword_75D408 + 3)) < *((_DWORD *)qword_75D408 + 13) )\n      {\n        ++v2;\n        if ( (dword_75D450 & 0x10) == 0 || *v3 != 32 )\n        {\n          while ( v6 )\n          {\n            sub_40A659(10);\n            --v6;\n          }\n          while ( --v2 )\n            sub_40A659(32);\n          sub_413510(v3);\n        }\n      }\n      v3 += 2;\n    }\n    ++v6;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void screen_dump(void)\n{\n\tint linefeed_cnt;\n\tint line, col;\n\tint linecnt = G.remote.lines - G.y;\n\tchar *data = G.data + G.current + G.first_line_offset;\n\n\tlinefeed_cnt = 0;\n\tfor (line = 0; line < linecnt && line < G.height; line++) {\n\t\tint space_cnt = 0;\n\t\tfor (col = 0; col < G.remote.cols; col++, NEXT(data)) {\n\t\t\tunsigned tty_col = col - G.x; // if will catch col < G.x too\n\n\t\t\tif (tty_col >= G.width)\n\t\t\t\tcontinue;\n\t\t\tspace_cnt++;\n\t\t\tif (BW && CHAR(data) == ' ')\n\t\t\t\tcontinue;\n\t\t\twhile (linefeed_cnt != 0) {\n\t\t\t\t//bb_putchar('\\r'); - tty driver does it for us\n\t\t\t\tbb_putchar('\\n');\n\t\t\t\tlinefeed_cnt--;\n\t\t\t}\n\t\t\twhile (--space_cnt)\n\t\t\t\tbb_putchar(' ');\n\t\t\tscreen_char(data);\n\t\t}\n\t\tlinefeed_cnt++;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_44199F(int a1)\n{\n  __int64 result; // rax\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; ; ++i )\n  {\n    result = (unsigned int)dword_75B1B0;\n    if ( i >= dword_75B1B0 )\n      break;\n    if ( a1 == *(_DWORD *)(16LL * i + qword_75B1A8 + 8) )\n    {\n      free(*(void **)(16LL * i + qword_75B1A8));\n      *(_QWORD *)(16LL * i + qword_75B1A8) = 0LL;\n      result = 16LL * i + qword_75B1A8;\n      *(_DWORD *)(result + 8) = 0;\n      return result;\n    }\n  }\n  return result;\n}\n\n\n Revised code:\nvoid ipsvd_perhost_remove(int pid)\n{\n\tunsigned i;\n\tfor (i = 0; i < cclen; ++i) {\n\t\tif (cc[i].pid == pid) {\n\t\t\tfree(cc[i].ip);\n\t\t\tcc[i].ip = NULL;\n\t\t\tcc[i].pid = 0;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 sub_4DAA06()\n{\n  __int64 result; // rax\n  __int64 i; // [rsp+8h] [rbp-8h]\n\n  result = (unsigned __int8)byte_75D468;\n  if ( byte_75D468 )\n  {\n    result = (unsigned __int8)byte_75B2A8;\n    if ( !byte_75B2A8 )\n    {\n      result = qword_75B2A0;\n      for ( i = qword_75B2A0; i; i = *(_QWORD *)i )\n      {\n        if ( (*(_DWORD *)(i + 12) & 1) == 0 )\n          kill(*(_DWORD *)(i + 8), 15);\n        result = *(_QWORD *)i;\n      }\n      byte_75B2A8 = 1;\n    }\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void kill_all_if_got_signal(void)\n{\n\tstatic smallint kill_sent;\n\n\tstruct fsck_instance *inst;\n\n\tif (!bb_got_signal || kill_sent)\n\t\treturn;\n\n\tfor (inst = instance_list; inst; inst = inst->next) {\n\t\tif (inst->flags & FLAG_DONE)\n\t\t\tcontinue;\n\t\tkill(inst->pid, SIGTERM);\n\t}\n\tkill_sent = 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_477313()\n{\n  __int64 result; // rax\n  __int64 *j; // [rsp+0h] [rbp-10h]\n  __int64 **i; // [rsp+8h] [rbp-8h]\n\n  for ( i = (__int64 **)qword_75B018; ; ++i )\n  {\n    result = qword_75B018 + 248;\n    if ( (unsigned __int64)i >= qword_75B018 + 248 )\n      break;\n    for ( j = *i; j; j = (__int64 *)*j )\n    {\n      if ( !*((_BYTE *)j + 16) || *((_BYTE *)j + 16) == 2 && (**(_BYTE **)j[1] & 2) == 0 && dword_75AE34 > 0 )\n        *((_BYTE *)j + 17) = 1;\n    }\n  }\n  return result;\n}\n"
    },
    {
        "func_name": "f_read8",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 sub_4B2928()\n{\n  uint16_t v1; // [rsp+Eh] [rbp-2h] BYREF\n\n  sub_4B28A8((unsigned __int8 *)&v1, 2);\n  return ntohs(v1);\n}\n\n\n Revised code:\nstatic unsigned f_read16(void)\n{\n\tuint16_t v;\n\tf_read(&v, 2);\n\treturn ntohs(v);\n}\n\n## Example:\n\n Input code:\n__int64 sub_45A660()\n{\n  __int64 v1; // [rsp+8h] [rbp-8h] BYREF\n\n  v1 = 4096LL;\n  return sub_507143(0LL, &v1);\n}\n\n\n Revised code:\nstatic char *xmalloc_read_stdin(void)\n{\n\t// SECURITY:\n\tsize_t max = 4 * 1024; // more than enough for commands!\n\treturn xmalloc_reads(STDIN_FILENO, &max);\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B2907(unsigned __int8 a1)\n{\n  unsigned __int8 v2[4]; // [rsp+Ch] [rbp-4h] BYREF\n\n  v2[0] = a1;\n  return sub_4B2868(v2, 1);\n}\n\n\n Revised code:\nstatic void f_write8(uint8_t v)\n{\n\tf_write(&v, 1);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_4B28E5()\n{\n  unsigned __int8 v1; // [rsp+Fh] [rbp-1h] BYREF\n\n  sub_4B28A8(&v1, 1);\n  return v1;\n}\n"
    },
    {
        "func_name": "get_dhcp_packet_type",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_453547(unsigned __int8 *a1)\n{\n  unsigned __int8 *v3; // [rsp+0h] [rbp-8h]\n\n  while ( 1 )\n  {\n    v3 = sub_4534CD(a1);\n    if ( !v3 )\n      return 0LL;\n    if ( !*v3 )\n      break;\n    a1 = v3 + 1;\n  }\n  return 1LL;\n}\n\n\n Revised code:\nstatic int good_hostname(const char *name)\n{\n\t//const char *start = name;\n\n\tfor (;;) {\n\t\tname = valid_domain_label(name);\n\t\tif (!name)\n\t\t\treturn 0;\n\t\tif (!name[0])\n\t\t\treturn 1;\n\t\t\t//Do we want this?\n\t\t\t//return ((name - start) < 1025); /* NS_MAXDNAME */\n\t\tname++;\n\t}\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_45208A(int a1)\n{\n  __int64 *v2; // [rsp+10h] [rbp-8h]\n\n  if ( !a1 )\n    return 0LL;\n  v2 = sub_451D87(a1);\n  if ( v2 )\n    return *((unsigned int *)v2 + 5);\n  else\n    return 0LL;\n}\n\n\n Revised code:\nendif\n\nunsigned FAST_FUNC ll_index_to_flags(int idx)\n{\n\tstruct idxmap *im;\n\n\tif (idx == 0)\n\t\treturn 0;\n\tim = find_by_index(idx);\n\tif (im)\n\t\treturn im->flags;\n\treturn 0;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_482C7B(const char **a1)\n{\n  int v2; // [rsp+1Ch] [rbp-4h]\n\n  if ( !*a1 )\n    return 0xFFFFFFFFLL;\n  v2 = sub_40BECF(*a1, 0LL, 10);\n  if ( *(_DWORD *)qword_75D400 || v2 < 0 )\n    return 0xFFFFFFFFLL;\n  sub_481365((__int64)a1);\n  return (unsigned int)v2;\n}\n\n\n Revised code:\nstatic int redirect_opt_num(o_string *o)\n{\n\tint num;\n\n\tif (o->data == NULL)\n\t\treturn -1;\n\tnum = bb_strtou(o->data, NULL, 10);\n\tif (errno || num < 0)\n\t\treturn -1;\n\to_reset_to_empty_unquoted(o);\n\treturn num;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_456CD1(_BYTE *a1)\n{\n  unsigned __int8 *v2; // [rsp+18h] [rbp-8h]\n\n  if ( *a1 != 1 && *a1 != 2 )\n    return 0xFFFFFFFFLL;\n  v2 = (unsigned __int8 *)sub_4599BC(a1, 53LL);\n  if ( v2 )\n    return *v2;\n  else\n    return 0xFFFFFFFFLL;\n}\n"
    },
    {
        "func_name": "insert_in_servlist",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4780F0(const char *a1, char *a2)\n{\n  char v3[8]; // [rsp+10h] [rbp-10h] BYREF\n  _DWORD *v4; // [rsp+18h] [rbp-8h]\n\n  ++*(_DWORD *)(qword_75D418 + 48);\n  v3[0] = 1;\n  v4 = sub_47805F(a2, (__int64)a2);\n  sub_477144(a1, (__int64)v3);\n  return sub_46E03F(a1, v3);\n}\n\n\n Revised code:\nstatic void\ndefun(char *name, union node *func)\n{\n\tstruct cmdentry entry;\n\n\tINT_OFF;\n\tentry.cmdtype = CMDFUNCTION;\n\tentry.u.func = copyfunc(func);\n\taddcmdentry(name, &entry);\n\tINT_ON;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_477BCC(_QWORD *a1)\n{\n  __int64 v1; // rbx\n  __int64 v4; // [rsp+10h] [rbp-20h] BYREF\n  __int64 *v5; // [rsp+18h] [rbp-18h]\n\n  v5 = &v4;\n  while ( a1 )\n  {\n    *v5 = qword_75B030;\n    qword_75B030 += 16LL;\n    v1 = *v5;\n    *(_QWORD *)(v1 + 8) = sub_477C51(a1[1]);\n    a1 = (_QWORD *)*a1;\n    v5 = (__int64 *)*v5;\n  }\n  *v5 = 0LL;\n  return v4;\n}\n\n\n Revised code:\nstatic struct nodelist *\ncopynodelist(struct nodelist *lp)\n{\n\tstruct nodelist *start;\n\tstruct nodelist **lpp;\n\n\tlpp = &start;\n\twhile (lp) {\n\t\t*lpp = funcblock;\n\t\tfuncblock = (char *) funcblock + SHELL_ALIGN(sizeof(struct nodelist));\n\t\t(*lpp)->n = copynode(lp->n);\n\t\tlp = lp->next;\n\t\tlpp = &(*lpp)->next;\n\t}\n\t*lpp = NULL;\n\treturn start;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_444B99(_DWORD *a1, int a2, _DWORD *a3, int *a4)\n{\n  int v7; // [rsp+20h] [rbp-10h] BYREF\n  __int16 v8; // [rsp+24h] [rbp-Ch]\n  int v9; // [rsp+28h] [rbp-8h]\n  unsigned int v10; // [rsp+2Ch] [rbp-4h]\n\n  v10 = 0;\n  v7 = 3;\n  v8 = 1;\n  if ( *a4 >= 0 && (int)sub_507F47(&v7, 1LL, (unsigned int)*a4) > 0 )\n  {\n    v10 = sub_508E76(3, (int)qword_75D408 + 44, 512, 64, (int)a1 + 4, a2, *a1);\n    v9 = sub_40BC67();\n    *a4 -= (v9 - *a3) / 0x3E8u;\n    *a3 = v9;\n  }\n  return v10;\n}\n\n\n Revised code:\nstatic int\nwait_for_reply(len_and_sockaddr *from_lsa, struct sockaddr *to, unsigned *timestamp_us, int *left_ms)\n{\n\tstruct pollfd pfd[1];\n\tint read_len = 0;\n\n\tpfd[0].fd = rcvsock;\n\tpfd[0].events = POLLIN;\n\tif (*left_ms >= 0 && safe_poll(pfd, 1, *left_ms) > 0) {\n\t\tunsigned t;\n\n\t\tread_len = recv_from_to(rcvsock,\n\t\t\t\trecv_pkt, sizeof(recv_pkt),\n\t\t\t\t/*flags:*/ MSG_DONTWAIT,\n\t\t\t\t&from_lsa->u.sa, to, from_lsa->len);\n\t\tt = monotonic_us();\n\t\t*left_ms -= (t - *timestamp_us) / 1000;\n\t\t*timestamp_us = t;\n\t}\n\n\treturn read_len;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_DWORD *__fastcall sub_434B9F(const void *a1, __int64 a2)\n{\n  sigset_t v3; // [rsp+10h] [rbp-90h] BYREF\n  _DWORD *v4; // [rsp+98h] [rbp-8h]\n\n  v4 = sub_43433C((__int64)a1, a2);\n  qmemcpy(v4, a1, 0x118uLL);\n  *v4 = -1;\n  v4[8] = -1;\n  sub_433B6A(&v3);\n  *((_QWORD *)v4 + 11) = *(_QWORD *)&dest.c_cc[7];\n  *(_QWORD *)&dest.c_cc[7] = v4;\n  sub_433BCD(&v3);\n  return v4;\n}\n"
    },
    {
        "func_name": "reload_inittab",
        "model_input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Detailed Requirements\n\nBe aware of the following requirements:\n\n1. The provided pseudocode is from a stripped binary, in which the function name, variable names and data types were stripped. You will need to recover the name of this function, as well as all variable names and types involved.\n2. You shall refactor the code structure based on your understanding, but you CANNOT change the functionality of the code.\n3. You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.\n4. You should rename the anonymous function (e.g., sub_4DC7E2) and variables (e.g., v1, v2) with informative names, based on your understanding of the code.\n5. Your input is a complete function, and your output should also be a whole function (i.e., do not separate the code into various functions). \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4DE999(unsigned int a1)\n{\n  char *v1; // rbx\n  __int64 result; // rax\n  int v3; // [rsp+1Ch] [rbp-14h]\n  int i; // [rsp+1Ch] [rbp-14h]\n\n  if ( (signed int)a1 >= *((_DWORD *)qword_75D408 - 12) )\n  {\n    v3 = *((_DWORD *)qword_75D408 - 12);\n    *((_DWORD *)qword_75D408 - 12) = a1 + 16;\n    v1 = (char *)qword_75D408 - 208;\n    *((_QWORD *)v1 + 21) = sub_40A09E(*((void **)qword_75D408 - 5), 32LL * *((int *)qword_75D408 - 12));\n    while ( v3 < *((_DWORD *)qword_75D408 - 12) )\n    {\n      *(_DWORD *)(32LL * v3 + *((_QWORD *)qword_75D408 - 5)) = 1024;\n      *(_QWORD *)(32LL * v3++ + *((_QWORD *)qword_75D408 - 5) + 16) = 0LL;\n    }\n  }\n  for ( i = a1; i < *((_DWORD *)qword_75D408 - 13); ++i )\n    sub_4DC88C((int *)(32LL * i + *((_QWORD *)qword_75D408 - 5)));\n  result = a1;\n  *((_DWORD *)qword_75D408 - 13) = a1;\n  return result;\n}\n\n\n Revised code:\nstatic void fsrealloc(int size)\n{\n\tint i;\n\n\tif (size >= maxfields) {\n\t\ti = maxfields;\n\t\tmaxfields = size + 16;\n\t\tFields = xrealloc(Fields, maxfields * sizeof(Fields[0]));\n\t\tfor (; i < maxfields; i++) {\n\t\t\tFields[i].type = VF_SPECIAL;\n\t\t\tFields[i].string = NULL;\n\t\t}\n\t}\n\t/* if size < nfields, clear extra field variables */\n\tfor (i = size; i < nfields; i++) {\n\t\tclrvar(Fields + i);\n\t}\n\tnfields = size;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_481080(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // [rsp+14h] [rbp-Ch]\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_481051(*(char *)(a1 + 11));\n  do\n  {\n    do\n    {\n      *((_BYTE *)qword_75D408 + 75) = 0;\n      v2 = sub_500C4F(*((_QWORD *)qword_75D408 + 3), v3, (char *)qword_75D408 + 472, 1023LL, 0xFFFFFFFFLL);\n      sub_4804F2();\n    }\n    while ( !v2 );\n  }\n  while ( *((_BYTE *)qword_75D408 + 75) );\n  *(_BYTE *)(a1 + 8) = v2 < 0;\n  if ( *(_BYTE *)(a1 + 8) )\n  {\n    *((_BYTE *)qword_75D408 + 472) = -1;\n    *((_BYTE *)qword_75D408 + 473) = 0;\n  }\n  result = a1;\n  *(_QWORD *)a1 = (char *)qword_75D408 + 472;\n  return result;\n}\n\n\n Revised code:\nstatic void get_user_input(struct in_str *i)\n{\n\tint r;\n\tconst char *prompt_str;\n\n\tprompt_str = setup_prompt_string(i->promptmode);\n# if ENABLE_FEATURE_EDITING\n\t/* Enable command line editing only while a command line\n\t * is actually being read */\n\tdo {\n\t\t/* Unicode support should be activated even if LANG is set\n\t\t * _during_ shell execution, not only if it was set when\n\t\t * shell was started. Therefore, re-check LANG every time:\n\t\t */\n\t\treinit_unicode(get_local_var_value(\"LANG\"));\n\n\t\tG.flag_SIGINT = 0;\n\t\t/* buglet: SIGINT will not make new prompt to appear _at once_,\n\t\t * only after <Enter>. (^C will work) */\n\t\tr = read_line_input(G.line_input_state, prompt_str, G.user_input_buf, CONFIG_FEATURE_EDITING_MAX_LEN-1, /*timeout*/ -1);\n\t\t/* catch *SIGINT* etc (^C is handled by read_line_input) */\n\t\tcheck_and_run_traps();\n\t} while (r == 0 || G.flag_SIGINT); /* repeat if ^C or SIGINT */\n\ti->eof_flag = (r < 0);\n\tif (i->eof_flag) { /* EOF/error detected */\n\t\tG.user_input_buf[0] = EOF; /* yes, it will be truncated, it's ok */\n\t\tG.user_input_buf[1] = '\\0';\n\t}\n# else\n\tdo {\n\t\tG.flag_SIGINT = 0;\n\t\tif (i->last_char == '\\0' || i->last_char == '\\n') {\n\t\t\t/* Why check_and_run_traps here? Try this interactively:\n\t\t\t * $ trap 'echo INT' INT; (sleep 2; kill -INT $$) &\n\t\t\t * $ <[enter], repeatedly...>\n\t\t\t * Without check_and_run_traps, handler never runs.\n\t\t\t */\n\t\t\tcheck_and_run_traps();\n\t\t\tfputs(prompt_str, stdout);\n\t\t}\n\t\tfflush_all();\n\t\tG.user_input_buf[0] = r = fgetc(i->file);\n\t\t/*G.user_input_buf[1] = '\\0'; - already is and never changed */\n\t} while (G.flag_SIGINT);\n\ti->eof_flag = (r == EOF);\n# endif\n\ti->p = G.user_input_buf;\n}\n\n## Example:\n\n Input code:\n__int64 __fastcall sub_4B87F0(__int64 a1)\n{\n  __int64 result; // rax\n  _QWORD *ptra; // [rsp+8h] [rbp-18h]\n  __int64 v4; // [rsp+18h] [rbp-8h]\n\n  while ( a1 )\n  {\n    ptra = (_QWORD *)(a1 - 16);\n    v4 = ptra[1];\n    free(ptra);\n    result = v4;\n    a1 = v4;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic void huft_free(huft_t *p)\n{\n\thuft_t *q;\n\n\t/* Go through linked list, freeing from the malloced (t[-1]) address. */\n\twhile (p) {\n\t\tq = (--p)->v.t;\n\t\tfree(p);\n\t\tp = q;\n\t}\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4F5915(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 result; // rax\n  __int64 *v7; // [rsp+0h] [rbp-10h]\n  _BYTE *ptr; // [rsp+8h] [rbp-8h]\n  _BYTE *ptra; // [rsp+8h] [rbp-8h]\n\n  sub_4F4BC2(1, \"reloading /etc/inittab\", a3, a4, a5, a6);\n  for ( ptr = (_BYTE *)qword_75B2B0; ptr; ptr = *(_BYTE **)ptr )\n    ptr[12] = 0;\n  sub_4F5503();\n  v7 = &qword_75B2B0;\n  while ( 1 )\n  {\n    result = *v7;\n    ptra = (_BYTE *)*v7;\n    if ( !*v7 )\n      break;\n    if ( (ptra[12] & 0xFE) != 0 )\n    {\n      v7 = (__int64 *)*v7;\n    }\n    else\n    {\n      *v7 = *(_QWORD *)ptra;\n      free(ptra);\n    }\n  }\n  return result;\n}\n"
    }
]
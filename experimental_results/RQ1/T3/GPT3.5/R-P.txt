Function Name: collect_ctx
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004606B5 | 55 | push    rbp
0x004606B6 | 48 89 E5 | mov     rbp, rsp
0x004606B9 | 48 83 EC 20 | sub     rsp, 20h
0x004606BD | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004606C1 | 48 8B 05 40 CD 2F 00 | mov     rax, cs:qword_75D408
0x004606C8 | 48 83 C0 30 | add     rax, 30h ; '0'
0x004606CC | 48 89 C7 | mov     rdi, rax
0x004606CF | E8 A5 F1 FF FF | call    sub_45F879
0x004606D4 | 48 89 C7 | mov     rdi, rax
0x004606D7 | 48 8D 45 F0 | lea     rax, [rbp+var_10]
0x004606DB | B9 01 00 00 00 | mov     ecx, 1
0x004606E0 | 48 89 C2 | mov     rdx, rax
0x004606E3 | BE 11 BE 51 00 | mov     esi, offset aProcesses; "processes"
0x004606E8 | B8 00 00 00 00 | mov     eax, 0
0x004606ED | E8 CD F3 FF FF | call    sub_45FABF
0x004606F2 | 85 C0 | test    eax, eax
0x004606F4 | 74 0C | jz      short loc_460702
0x004606F6 | BF 04 00 00 00 | mov     edi, 4
0x004606FB | E8 6C F0 FF FF | call    sub_45F76C
0x00460700 | EB 3A | jmp     short locret_46073C
0x00460702 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00460706 | 48 8B 40 18 | mov     rax, [rax+18h]
0x0046070A | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0046070E | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00460712 | 48 39 45 F8 | cmp     [rbp+var_8], rax
0x00460716 | 76 08 | jbe     short loc_460720
0x00460718 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0046071C | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00460720 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x00460724 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00460728 | 48 89 50 18 | mov     [rax+18h], rdx
0x0046072C | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00460730 | 48 2B 45 F8 | sub     rax, [rbp+var_8]
0x00460734 | 48 89 C7 | mov     rdi, rax
0x00460737 | E8 D2 F6 FF FF | call    sub_45FE0E
0x0046073C | C9 | leave
0x0046073D | C3 | retn

 Ourput decompiled code:
static void FAST_FUNC collect_fork(fork_stat *s)
{
	ullong data[1];
	ullong old;

	if (rdval(get_file(&proc_stat), "processes", data, 1)) {
		put_question_marks(4);
		return;
	}

	old = s->old;
	if (data[0] < old) old = data[0];	//sanitize
	s->old = data[0];
	scale(data[0] - old);
}

## Example:

 Input assembly code:
0x00460B19 | 55 | push    rbp
0x00460B1A | 48 89 E5 | mov     rbp, rsp
0x00460B1D | 48 83 EC 20 | sub     rsp, 20h
0x00460B21 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00460B25 | 48 8B 05 DC C8 2F 00 | mov     rax, cs:qword_75D408
0x00460B2C | 48 83 C0 60 | add     rax, 60h ; '`'
0x00460B30 | 48 89 C7 | mov     rdi, rax
0x00460B33 | E8 41 ED FF FF | call    sub_45F879
0x00460B38 | 48 89 C7 | mov     rdi, rax
0x00460B3B | 48 8D 45 F8 | lea     rax, [rbp+var_8]
0x00460B3F | B9 01 00 00 00 | mov     ecx, 1
0x00460B44 | 48 89 C2 | mov     rdx, rax
0x00460B47 | BE 49 BE 51 00 | mov     esi, offset aSwaptotal; "SwapTotal:"
0x00460B4C | B8 00 00 00 00 | mov     eax, 0
0x00460B51 | E8 69 EF FF FF | call    sub_45FABF
0x00460B56 | 85 C0 | test    eax, eax
0x00460B58 | 75 2A | jnz     short loc_460B84
0x00460B5A | 48 8B 05 A7 C8 2F 00 | mov     rax, cs:qword_75D408
0x00460B61 | 48 8B 40 60 | mov     rax, [rax+60h]
0x00460B65 | 48 8D 55 F0 | lea     rdx, [rbp+var_10]
0x00460B69 | B9 01 00 00 00 | mov     ecx, 1
0x00460B6E | BE 54 BE 51 00 | mov     esi, offset aSwapfree; "SwapFree:"
0x00460B73 | 48 89 C7 | mov     rdi, rax
0x00460B76 | B8 00 00 00 00 | mov     eax, 0
0x00460B7B | E8 3F EF FF FF | call    sub_45FABF
0x00460B80 | 85 C0 | test    eax, eax
0x00460B82 | 74 0C | jz      short loc_460B90
0x00460B84 | BF 04 00 00 00 | mov     edi, 4
0x00460B89 | E8 DE EB FF FF | call    sub_45F76C
0x00460B8E | EB 1A | jmp     short locret_460BAA
0x00460B90 | 48 8B 55 F8 | mov     rdx, [rbp+var_8]
0x00460B94 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00460B98 | 48 29 C2 | sub     rdx, rax
0x00460B9B | 48 89 D0 | mov     rax, rdx
0x00460B9E | 48 C1 E0 0A | shl     rax, 0Ah
0x00460BA2 | 48 89 C7 | mov     rdi, rax
0x00460BA5 | E8 64 F2 FF FF | call    sub_45FE0E
0x00460BAA | C9 | leave
0x00460BAB | C3 | retn

 Ourput decompiled code:
static void FAST_FUNC collect_swp(swp_stat *s UNUSED_PARAM)
{
	ullong s_total[1];
	ullong s_free[1];
	if (rdval(get_file(&proc_meminfo), "SwapTotal:", s_total, 1)
	 || rdval(proc_meminfo.file,       "SwapFree:" , s_free,  1)
	) {
		put_question_marks(4);
		return;
	}
	scale((s_total[0]-s_free[0]) << 10);
}

## Example:

 Input assembly code:
0x0046031C | 55 | push    rbp
0x0046031D | 48 89 E5 | mov     rbp, rsp
0x00460320 | 53 | push    rbx
0x00460321 | 48 83 EC 28 | sub     rsp, 28h
0x00460325 | 48 89 7D D8 | mov     [rbp+var_28], rdi
0x00460329 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x0046032D | 8B 58 20 | mov     ebx, [rax+20h]
0x00460330 | 48 8B 05 D1 D0 2F 00 | mov     rax, cs:qword_75D408
0x00460337 | 48 83 C0 30 | add     rax, 30h ; '0'
0x0046033B | 48 89 C7 | mov     rdi, rax
0x0046033E | E8 36 F5 FF FF | call    sub_45F879
0x00460343 | 48 89 C7 | mov     rdi, rax
0x00460346 | 48 8D 45 E0 | lea     rax, [rbp+var_20]
0x0046034A | 89 D9 | mov     ecx, ebx
0x0046034C | 48 89 C2 | mov     rdx, rax
0x0046034F | BE 02 BE 51 00 | mov     esi, offset aIntr_0; "intr"
0x00460354 | B8 00 00 00 00 | mov     eax, 0
0x00460359 | E8 61 F7 FF FF | call    sub_45FABF
0x0046035E | 85 C0 | test    eax, eax
0x00460360 | 74 0C | jz      short loc_46036E
0x00460362 | BF 04 00 00 00 | mov     edi, 4
0x00460367 | E8 00 F4 FF FF | call    sub_45F76C
0x0046036C | EB 3A | jmp     short loc_4603A8
0x0046036E | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00460372 | 48 8B 40 18 | mov     rax, [rax+18h]
0x00460376 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x0046037A | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0046037E | 48 39 45 E8 | cmp     [rbp+var_18], rax
0x00460382 | 76 08 | jbe     short loc_46038C
0x00460384 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00460388 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x0046038C | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00460390 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00460394 | 48 89 50 18 | mov     [rax+18h], rdx
0x00460398 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0046039C | 48 2B 45 E8 | sub     rax, [rbp+var_18]
0x004603A0 | 48 89 C7 | mov     rdi, rax
0x004603A3 | E8 66 FA FF FF | call    sub_45FE0E
0x004603A8 | 48 83 C4 28 | add     rsp, 28h
0x004603AC | 5B | pop     rbx
0x004603AD | 5D | pop     rbp
0x004603AE | C3 | retn

 Ourput decompiled code:
static void FAST_FUNC collect_int(int_stat *s)
{
	ullong data[1];
	ullong old;

	if (rdval(get_file(&proc_stat), "intr", data, s->no)) {
		put_question_marks(4);
		return;
	}

	old = s->old;
	if (data[0] < old) old = data[0];		//sanitize
	s->old = data[0];
	scale(data[0] - old);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0046040F | 55 | push    rbp
0x00460410 | 48 89 E5 | mov     rbp, rsp
0x00460413 | 48 83 EC 20 | sub     rsp, 20h
0x00460417 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0046041B | 48 8B 05 E6 CF 2F 00 | mov     rax, cs:qword_75D408
0x00460422 | 48 83 C0 30 | add     rax, 30h ; '0'
0x00460426 | 48 89 C7 | mov     rdi, rax
0x00460429 | E8 4B F4 FF FF | call    sub_45F879
0x0046042E | 48 89 C7 | mov     rdi, rax
0x00460431 | 48 8D 45 F0 | lea     rax, [rbp+var_10]
0x00460435 | B9 01 00 00 00 | mov     ecx, 1
0x0046043A | 48 89 C2 | mov     rdx, rax
0x0046043D | BE 07 BE 51 00 | mov     esi, offset aCtxt; "ctxt"
0x00460442 | B8 00 00 00 00 | mov     eax, 0
0x00460447 | E8 73 F6 FF FF | call    sub_45FABF
0x0046044C | 85 C0 | test    eax, eax
0x0046044E | 74 0C | jz      short loc_46045C
0x00460450 | BF 04 00 00 00 | mov     edi, 4
0x00460455 | E8 12 F3 FF FF | call    sub_45F76C
0x0046045A | EB 3A | jmp     short locret_460496
0x0046045C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00460460 | 48 8B 40 18 | mov     rax, [rax+18h]
0x00460464 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00460468 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0046046C | 48 39 45 F8 | cmp     [rbp+var_8], rax
0x00460470 | 76 08 | jbe     short loc_46047A
0x00460472 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00460476 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0046047A | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x0046047E | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00460482 | 48 89 50 18 | mov     [rax+18h], rdx
0x00460486 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0046048A | 48 2B 45 F8 | sub     rax, [rbp+var_8]
0x0046048E | 48 89 C7 | mov     rdi, rax
0x00460491 | E8 78 F9 FF FF | call    sub_45FE0E
0x00460496 | C9 | leave
0x00460497 | C3 | retn
 ************ 
Source Code:
static void FAST_FUNC collect_ctx(ctx_stat *s)
{
	ullong data[1];
	ullong old;

	if (rdval(get_file(&proc_stat), "ctxt", data, 1)) {
		put_question_marks(4);
		return;
	}

	old = s->old;
	if (data[0] < old) old = data[0];		//sanitize
	s->old = data[0];
	scale(data[0] - old);
}
 ************ 
Parsed Output:
static void FAST_FUNC collect_ctxt(ctxt_stat *s)
{
	ullong data[1];
	ullong old;

	if (rdval(get_file(&proc_stat), "ctxt", data, 1)) {
		put_question_marks(4);
		return;
	}

	old = s->old;
	if (data[0] < old) old = data[0];		//sanitize
	s->old = data[0];
	scale(data[0] - old);
}
 ************ 
Similarity Score (Unixcoder): 0.9892679452896118
Func rank: 1

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: str2env
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004B712D | 55 | push    rbp
0x004B712E | 48 89 E5 | mov     rbp, rsp
0x004B7131 | 53 | push    rbx
0x004B7132 | 48 83 EC 28 | sub     rsp, 28h
0x004B7136 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004B713A | 89 75 E4 | mov     [rbp+var_1C], esi
0x004B713D | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x004B7141 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004B7144 | 48 98 | cdqe
0x004B7146 | 48 8B 04 C5 A0 29 52 00 | mov     rax, ds:off_5229A0[rax*8]; "MODE"
0x004B714E | 8B 55 E4 | mov     edx, [rbp+var_1C]
0x004B7151 | 48 63 D2 | movsxd  rdx, edx
0x004B7154 | 48 8D 0C D5 00 00 00 00 | lea     rcx, ds:0[rdx*8]
0x004B715C | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x004B7160 | 48 8D 1C 11 | lea     rbx, [rcx+rdx]
0x004B7164 | 48 8B 55 D8 | mov     rdx, [rbp+var_28]
0x004B7168 | 48 89 C6 | mov     rsi, rax
0x004B716B | BF EA 29 52 00 | mov     edi, offset aTarSLlu; "TAR_%s=%llu"
0x004B7170 | B8 00 00 00 00 | mov     eax, 0
0x004B7175 | E8 39 35 F5 FF | call    sub_40A6B3
0x004B717A | 48 89 03 | mov     [rbx], rax
0x004B717D | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004B7180 | 48 98 | cdqe
0x004B7182 | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]
0x004B718A | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004B718E | 48 01 D0 | add     rax, rdx
0x004B7191 | 48 8B 00 | mov     rax, [rax]
0x004B7194 | 48 89 C7 | mov     rdi, rax
0x004B7197 | E8 EC FE FF FF | call    sub_4B7088
0x004B719C | 90 | nop
0x004B719D | 48 83 C4 28 | add     rsp, 28h
0x004B71A1 | 5B | pop     rbx
0x004B71A2 | 5D | pop     rbp
0x004B71A3 | C3 | retn

 Ourput decompiled code:
static void dec2env(char *env[], int idx, unsigned long long val)
{
	env[idx] = xasprintf("TAR_%s=%llu", tar_var[idx], val);
	xputenv(env[idx]);
}

## Example:

 Input assembly code:
0x004B71A4 | 55 | push    rbp
0x004B71A5 | 48 89 E5 | mov     rbp, rsp
0x004B71A8 | 53 | push    rbx
0x004B71A9 | 48 83 EC 28 | sub     rsp, 28h
0x004B71AD | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004B71B1 | 89 75 E4 | mov     [rbp+var_1C], esi
0x004B71B4 | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x004B71B8 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004B71BB | 48 98 | cdqe
0x004B71BD | 48 8B 04 C5 A0 29 52 00 | mov     rax, ds:off_5229A0[rax*8]; "MODE"
0x004B71C5 | 8B 55 E4 | mov     edx, [rbp+var_1C]
0x004B71C8 | 48 63 D2 | movsxd  rdx, edx
0x004B71CB | 48 8D 0C D5 00 00 00 00 | lea     rcx, ds:0[rdx*8]
0x004B71D3 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x004B71D7 | 48 8D 1C 11 | lea     rbx, [rcx+rdx]
0x004B71DB | 48 8B 55 D8 | mov     rdx, [rbp+var_28]
0x004B71DF | 48 89 C6 | mov     rsi, rax
0x004B71E2 | BF F6 29 52 00 | mov     edi, offset aTarSLo; "TAR_%s=%lo"
0x004B71E7 | B8 00 00 00 00 | mov     eax, 0
0x004B71EC | E8 C2 34 F5 FF | call    sub_40A6B3
0x004B71F1 | 48 89 03 | mov     [rbx], rax
0x004B71F4 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004B71F7 | 48 98 | cdqe
0x004B71F9 | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]
0x004B7201 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004B7205 | 48 01 D0 | add     rax, rdx
0x004B7208 | 48 8B 00 | mov     rax, [rax]
0x004B720B | 48 89 C7 | mov     rdi, rax
0x004B720E | E8 75 FE FF FF | call    sub_4B7088
0x004B7213 | 90 | nop
0x004B7214 | 48 83 C4 28 | add     rsp, 28h
0x004B7218 | 5B | pop     rbx
0x004B7219 | 5D | pop     rbp
0x004B721A | C3 | retn

 Ourput decompiled code:
static void oct2env(char *env[], int idx, unsigned long val)
{
	env[idx] = xasprintf("TAR_%s=%lo", tar_var[idx], val);
	xputenv(env[idx]);
}

## Example:

 Input assembly code:
0x00463151 | 55 | push    rbp
0x00463152 | 48 89 E5 | mov     rbp, rsp
0x00463155 | 53 | push    rbx
0x00463156 | 48 83 EC 28 | sub     rsp, 28h
0x0046315A | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0046315E | 89 75 E4 | mov     [rbp+var_1C], esi
0x00463161 | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x00463165 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x00463168 | 83 C0 01 | add     eax, 1
0x0046316B | 48 63 D8 | movsxd  rbx, eax
0x0046316E | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00463172 | 8B 40 68 | mov     eax, [rax+68h]
0x00463175 | 89 C7 | mov     edi, eax
0x00463177 | E8 CA 01 0A 00 | call    sub_503346
0x0046317C | 48 89 C1 | mov     rcx, rax
0x0046317F | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00463183 | 48 89 DA | mov     rdx, rbx
0x00463186 | 48 89 CE | mov     rsi, rcx
0x00463189 | 48 89 C7 | mov     rdi, rax
0x0046318C | E8 2F 4E 0A 00 | call    sub_507FC0
0x00463191 | 90 | nop
0x00463192 | 48 83 C4 28 | add     rsp, 28h
0x00463196 | 5B | pop     rbx
0x00463197 | 5D | pop     rbp
0x00463198 | C3 | retn

 Ourput decompiled code:
static void func_user(char *buf, int size, const procps_status_t *ps)
{
#if 1
	safe_strncpy(buf, get_cached_username(ps->uid), size+1);
#else
	/* "compatible" version, but it's larger */
	/* procps 2.18 shows numeric UID if name overflows the field */
	/* TODO: get_cached_username() returns numeric string if
	 * user has no passwd record, we will display it
	 * left-justified here; too long usernames are shown
	 * as _right-justified_ IDs. Is it worth fixing? */
	const char *user = get_cached_username(ps->uid);
	if (strlen(user) <= size)
		safe_strncpy(buf, user, size+1);
	else
		sprintf(buf, "%*u", size, (unsigned)ps->uid);
#endif
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004B70B6 | 55 | push    rbp
0x004B70B7 | 48 89 E5 | mov     rbp, rsp
0x004B70BA | 53 | push    rbx
0x004B70BB | 48 83 EC 28 | sub     rsp, 28h
0x004B70BF | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004B70C3 | 89 75 E4 | mov     [rbp+var_1C], esi
0x004B70C6 | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x004B70CA | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004B70CD | 48 98 | cdqe
0x004B70CF | 48 8B 04 C5 A0 29 52 00 | mov     rax, ds:off_5229A0[rax*8]; "MODE"
0x004B70D7 | 8B 55 E4 | mov     edx, [rbp+var_1C]
0x004B70DA | 48 63 D2 | movsxd  rdx, edx
0x004B70DD | 48 8D 0C D5 00 00 00 00 | lea     rcx, ds:0[rdx*8]
0x004B70E5 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x004B70E9 | 48 8D 1C 11 | lea     rbx, [rcx+rdx]
0x004B70ED | 48 8B 55 D8 | mov     rdx, [rbp+var_28]
0x004B70F1 | 48 89 C6 | mov     rsi, rax
0x004B70F4 | BF E0 29 52 00 | mov     edi, offset aTarSS; "TAR_%s=%s"
0x004B70F9 | B8 00 00 00 00 | mov     eax, 0
0x004B70FE | E8 B0 35 F5 FF | call    sub_40A6B3
0x004B7103 | 48 89 03 | mov     [rbx], rax
0x004B7106 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004B7109 | 48 98 | cdqe
0x004B710B | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]
0x004B7113 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004B7117 | 48 01 D0 | add     rax, rdx
0x004B711A | 48 8B 00 | mov     rax, [rax]
0x004B711D | 48 89 C7 | mov     rdi, rax
0x004B7120 | E8 63 FF FF FF | call    sub_4B7088
0x004B7125 | 90 | nop
0x004B7126 | 48 83 C4 28 | add     rsp, 28h
0x004B712A | 5B | pop     rbx
0x004B712B | 5D | pop     rbp
0x004B712C | C3 | retn
 ************ 
Source Code:
static void str2env(char *env[], int idx, const char *str)
{
	env[idx] = xasprintf("TAR_%s=%s", tar_var[idx], str);
	xputenv(env[idx]);
}
 ************ 
Parsed Output:
static void str2env(char *env[], int idx, const char *val)
{
	env[idx] = xasprintf("TAR_%s=%s", tar_var[idx], val);
	xputenv(env[idx]);
}
 ************ 
Similarity Score (Unixcoder): 0.989154040813446
Func rank: 2

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: print_char
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004CDB3F | 55 | push    rbp
0x004CDB40 | 48 89 E5 | mov     rbp, rsp
0x004CDB43 | 48 83 EC 30 | sub     rsp, 30h
0x004CDB47 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004CDB4B | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004CDB4F | 48 89 55 D8 | mov     [rbp+format], rdx
0x004CDB53 | EB 28 | jmp     short loc_4CDB7D
0x004CDB55 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004CDB59 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004CDB5C | 0F BE C0 | movsx   eax, al
0x004CDB5F | 89 45 FC | mov     [rbp+var_4], eax
0x004CDB62 | 8B 55 FC | mov     edx, [rbp+var_4]
0x004CDB65 | 48 8B 45 D8 | mov     rax, [rbp+format]
0x004CDB69 | 89 D6 | mov     esi, edx
0x004CDB6B | 48 89 C7 | mov     rdi, rax; format
0x004CDB6E | B8 00 00 00 00 | mov     eax, 0
0x004CDB73 | E8 58 90 F3 FF | call    _printf
0x004CDB78 | 48 83 45 E0 01 | add     [rbp+var_20], 1
0x004CDB7D | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CDB81 | 48 8D 50 FF | lea     rdx, [rax-1]
0x004CDB85 | 48 89 55 E8 | mov     [rbp+var_18], rdx
0x004CDB89 | 48 85 C0 | test    rax, rax
0x004CDB8C | 75 C7 | jnz     short loc_4CDB55
0x004CDB8E | 90 | nop
0x004CDB8F | C9 | leave
0x004CDB90 | C3 | retn

 Ourput decompiled code:
static void
print_s_char(size_t n_bytes, const char *block, const char *fmt_string)
{
	while (n_bytes--) {
		int tmp = *(signed char *) block;
		printf(fmt_string, tmp);
		block += sizeof(unsigned char);
	}
}

## Example:

 Input assembly code:
0x004CDC9B | 55 | push    rbp
0x004CDC9C | 48 89 E5 | mov     rbp, rsp
0x004CDC9F | 48 83 EC 30 | sub     rsp, 30h
0x004CDCA3 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004CDCA7 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004CDCAB | 48 89 55 D8 | mov     [rbp+format], rdx
0x004CDCAF | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CDCB3 | 48 C1 E8 02 | shr     rax, 2
0x004CDCB7 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x004CDCBB | EB 24 | jmp     short loc_4CDCE1
0x004CDCBD | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004CDCC1 | 8B 00 | mov     eax, [rax]
0x004CDCC3 | 89 45 FC | mov     [rbp+var_4], eax
0x004CDCC6 | 8B 55 FC | mov     edx, [rbp+var_4]
0x004CDCC9 | 48 8B 45 D8 | mov     rax, [rbp+format]
0x004CDCCD | 89 D6 | mov     esi, edx
0x004CDCCF | 48 89 C7 | mov     rdi, rax; format
0x004CDCD2 | B8 00 00 00 00 | mov     eax, 0
0x004CDCD7 | E8 F4 8E F3 FF | call    _printf
0x004CDCDC | 48 83 45 E0 04 | add     [rbp+var_20], 4
0x004CDCE1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CDCE5 | 48 8D 50 FF | lea     rdx, [rax-1]
0x004CDCE9 | 48 89 55 E8 | mov     [rbp+var_18], rdx
0x004CDCED | 48 85 C0 | test    rax, rax
0x004CDCF0 | 75 CB | jnz     short loc_4CDCBD
0x004CDCF2 | 90 | nop
0x004CDCF3 | C9 | leave
0x004CDCF4 | C3 | retn

 Ourput decompiled code:
static void
print_int(size_t n_bytes, const char *block, const char *fmt_string)
{
	n_bytes /= sizeof(unsigned);
	while (n_bytes--) {
		unsigned tmp = *(unsigned *) block;
		printf(fmt_string, tmp);
		block += sizeof(unsigned);
	}
}

## Example:

 Input assembly code:
0x004CDC3E | 55 | push    rbp
0x004CDC3F | 48 89 E5 | mov     rbp, rsp
0x004CDC42 | 48 83 EC 30 | sub     rsp, 30h
0x004CDC46 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004CDC4A | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004CDC4E | 48 89 55 D8 | mov     [rbp+format], rdx
0x004CDC52 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CDC56 | 48 D1 E8 | shr     rax, 1
0x004CDC59 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x004CDC5D | EB 28 | jmp     short loc_4CDC87
0x004CDC5F | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004CDC63 | 0F B7 00 | movzx   eax, word ptr [rax]
0x004CDC66 | 0F B7 C0 | movzx   eax, ax
0x004CDC69 | 89 45 FC | mov     [rbp+var_4], eax
0x004CDC6C | 8B 55 FC | mov     edx, [rbp+var_4]
0x004CDC6F | 48 8B 45 D8 | mov     rax, [rbp+format]
0x004CDC73 | 89 D6 | mov     esi, edx
0x004CDC75 | 48 89 C7 | mov     rdi, rax; format
0x004CDC78 | B8 00 00 00 00 | mov     eax, 0
0x004CDC7D | E8 4E 8F F3 FF | call    _printf
0x004CDC82 | 48 83 45 E0 02 | add     [rbp+var_20], 2
0x004CDC87 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CDC8B | 48 8D 50 FF | lea     rdx, [rax-1]
0x004CDC8F | 48 89 55 E8 | mov     [rbp+var_18], rdx
0x004CDC93 | 48 85 C0 | test    rax, rax
0x004CDC96 | 75 C7 | jnz     short loc_4CDC5F
0x004CDC98 | 90 | nop
0x004CDC99 | C9 | leave
0x004CDC9A | C3 | retn

 Ourput decompiled code:
static void
print_short(size_t n_bytes, const char *block, const char *fmt_string)
{
	n_bytes /= sizeof(unsigned short);
	while (n_bytes--) {
		unsigned tmp = *(unsigned short *) block;
		printf(fmt_string, tmp);
		block += sizeof(unsigned short);
	}
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004CDB91 | 55 | push    rbp
0x004CDB92 | 48 89 E5 | mov     rbp, rsp
0x004CDB95 | 48 83 EC 30 | sub     rsp, 30h
0x004CDB99 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004CDB9D | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004CDBA1 | 48 89 55 D8 | mov     [rbp+format], rdx
0x004CDBA5 | EB 28 | jmp     short loc_4CDBCF
0x004CDBA7 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004CDBAB | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004CDBAE | 0F B6 C0 | movzx   eax, al
0x004CDBB1 | 89 45 FC | mov     [rbp+var_4], eax
0x004CDBB4 | 8B 55 FC | mov     edx, [rbp+var_4]
0x004CDBB7 | 48 8B 45 D8 | mov     rax, [rbp+format]
0x004CDBBB | 89 D6 | mov     esi, edx
0x004CDBBD | 48 89 C7 | mov     rdi, rax; format
0x004CDBC0 | B8 00 00 00 00 | mov     eax, 0
0x004CDBC5 | E8 06 90 F3 FF | call    _printf
0x004CDBCA | 48 83 45 E0 01 | add     [rbp+var_20], 1
0x004CDBCF | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CDBD3 | 48 8D 50 FF | lea     rdx, [rax-1]
0x004CDBD7 | 48 89 55 E8 | mov     [rbp+var_18], rdx
0x004CDBDB | 48 85 C0 | test    rax, rax
0x004CDBDE | 75 C7 | jnz     short loc_4CDBA7
0x004CDBE0 | 90 | nop
0x004CDBE1 | C9 | leave
0x004CDBE2 | C3 | retn
 ************ 
Source Code:
static void
print_char(size_t n_bytes, const char *block, const char *fmt_string)
{
	while (n_bytes--) {
		unsigned tmp = *(unsigned char *) block;
		printf(fmt_string, tmp);
		block += sizeof(unsigned char);
	}
}
 ************ 
Parsed Output:
static void
print_char(size_t n_bytes, const char *block, const char *fmt_string)
{
    while (n_bytes--) {
        int tmp = *(signed char *) block;
        printf(fmt_string, tmp);
        block += sizeof(unsigned char);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.9800081253051758
Func rank: 3

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: rtnl_rtrealm_initialize
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00452770 | 55 | push    rbp
0x00452771 | 48 89 E5 | mov     rbp, rsp
0x00452774 | 48 8B 05 55 8A 30 00 | mov     rax, cs:qword_75B1D0
0x0045277B | 48 85 C0 | test    rax, rax
0x0045277E | 75 3A | jnz     short loc_4527BA
0x00452780 | BF 10 08 00 00 | mov     edi, 810h
0x00452785 | E8 5E 79 FB FF | call    sub_40A0E8
0x0045278A | 48 89 05 3F 8A 30 00 | mov     cs:qword_75B1D0, rax
0x00452791 | 48 8B 05 38 8A 30 00 | mov     rax, cs:qword_75B1D0
0x00452798 | 48 C7 40 10 F9 AC 51 00 | mov     qword ptr [rax+10h], offset a0_1; "0"
0x004527A0 | 48 8B 05 29 8A 30 00 | mov     rax, cs:qword_75B1D0
0x004527A7 | 48 83 C0 10 | add     rax, 10h
0x004527AB | 48 89 C6 | mov     rsi, rax
0x004527AE | BF FB AC 51 00 | mov     edi, offset aEtcIproute2RtD; "/etc/iproute2/rt_dsfield"
0x004527B3 | E8 60 FA FF FF | call    sub_452218
0x004527B8 | EB 01 | jmp     short loc_4527BB
0x004527BA | 90 | nop
0x004527BB | 5D | pop     rbp
0x004527BC | C3 | retn

 Ourput decompiled code:
static void rtnl_rtdsfield_initialize(void)
{
	if (rtnl_rtdsfield_tab) return;
	rtnl_rtdsfield_tab = xzalloc(sizeof(*rtnl_rtdsfield_tab));
	rtnl_rtdsfield_tab->tab[0] = "0";
	rtnl_tab_initialize("/etc/iproute2/rt_dsfield", rtnl_rtdsfield_tab->tab);
}

## Example:

 Input assembly code:
0x004523E0 | 55 | push    rbp
0x004523E1 | 48 89 E5 | mov     rbp, rsp
0x004523E4 | 48 8B 05 CD 8D 30 00 | mov     rax, cs:qword_75B1B8
0x004523EB | 48 85 C0 | test    rax, rax
0x004523EE | 75 48 | jnz     short loc_452438
0x004523F0 | BF 10 08 00 00 | mov     edi, 810h
0x004523F5 | E8 EE 7C FB FF | call    sub_40A0E8
0x004523FA | 48 89 05 B7 8D 30 00 | mov     cs:qword_75B1B8, rax
0x00452401 | 48 8B 05 B0 8D 30 00 | mov     rax, cs:qword_75B1B8
0x00452408 | 48 83 C0 10 | add     rax, 10h
0x0045240C | BA 68 00 00 00 | mov     edx, 68h ; 'h'; n
0x00452411 | BE A0 AD 51 00 | mov     esi, offset off_51ADA0; src
0x00452416 | 48 89 C7 | mov     rdi, rax; dest
0x00452419 | E8 82 4D FB FF | call    _memcpy
0x0045241E | 48 8B 05 93 8D 30 00 | mov     rax, cs:qword_75B1B8
0x00452425 | 48 83 C0 10 | add     rax, 10h
0x00452429 | 48 89 C6 | mov     rsi, rax
0x0045242C | BF 88 AC 51 00 | mov     edi, offset aEtcIproute2RtP; "/etc/iproute2/rt_protos"
0x00452431 | E8 E2 FD FF FF | call    sub_452218
0x00452436 | EB 01 | jmp     short loc_452439
0x00452438 | 90 | nop
0x00452439 | 5D | pop     rbp
0x0045243A | C3 | retn

 Ourput decompiled code:
static void rtnl_rtprot_initialize(void)
{
	static const char *const init_tab[] = {
		"none",
		"redirect",
		"kernel",
		"boot",
		"static",
		NULL,
		NULL,
		NULL,
		"gated",
		"ra",
		"mrt",
		"zebra",
		"bird",
	};

	if (rtnl_rtprot_tab)
		return;
	rtnl_rtprot_tab = xzalloc(sizeof(*rtnl_rtprot_tab));
	memcpy(rtnl_rtprot_tab->tab, init_tab, sizeof(init_tab));
	rtnl_tab_initialize("/etc/iproute2/rt_protos", rtnl_rtprot_tab->tab);
}

## Example:

 Input assembly code:
0x00452882 | 55 | push    rbp
0x00452883 | 48 89 E5 | mov     rbp, rsp
0x00452886 | 48 8B 05 43 89 30 00 | mov     rax, cs:qword_75B1D0
0x0045288D | 48 85 C0 | test    rax, rax
0x00452890 | 75 70 | jnz     short loc_452902
0x00452892 | BF 10 08 00 00 | mov     edi, 810h
0x00452897 | E8 4C 78 FB FF | call    sub_40A0E8
0x0045289C | 48 89 05 35 89 30 00 | mov     cs:qword_75B1D8, rax
0x004528A3 | 48 8B 05 2E 89 30 00 | mov     rax, cs:qword_75B1D8
0x004528AA | 48 C7 40 10 1B AD 51 00 | mov     qword ptr [rax+10h], offset aUnspec; "unspec"
0x004528B2 | 48 8B 05 1F 89 30 00 | mov     rax, cs:qword_75B1D8
0x004528B9 | 48 C7 80 08 08 00 00 22 AD 51 00 | mov     qword ptr [rax+808h], offset aLocal_0; "local"
0x004528C4 | 48 8B 05 0D 89 30 00 | mov     rax, cs:qword_75B1D8
0x004528CB | 48 C7 80 00 08 00 00 28 AD 51 00 | mov     qword ptr [rax+800h], offset aMain; "main"
0x004528D6 | 48 8B 05 FB 88 30 00 | mov     rax, cs:qword_75B1D8
0x004528DD | 48 C7 80 F8 07 00 00 2D AD 51 00 | mov     qword ptr [rax+7F8h], offset aDefault_2; "default"
0x004528E8 | 48 8B 05 E9 88 30 00 | mov     rax, cs:qword_75B1D8
0x004528EF | 48 83 C0 10 | add     rax, 10h
0x004528F3 | 48 89 C6 | mov     rsi, rax
0x004528F6 | BF 35 AD 51 00 | mov     edi, offset aEtcIproute2RtT; "/etc/iproute2/rt_tables"
0x004528FB | E8 18 F9 FF FF | call    sub_452218
0x00452900 | EB 01 | jmp     short loc_452903
0x00452902 | 90 | nop
0x00452903 | 5D | pop     rbp
0x00452904 | C3 | retn

 Ourput decompiled code:
static void rtnl_rttable_initialize(void)
{
	if (rtnl_rtdsfield_tab) return;
	rtnl_rttable_tab = xzalloc(sizeof(*rtnl_rttable_tab));
	rtnl_rttable_tab->tab[0] = "unspec";
	rtnl_rttable_tab->tab[255] = "local";
	rtnl_rttable_tab->tab[254] = "main";
	rtnl_rttable_tab->tab[253] = "default";
	rtnl_tab_initialize("/etc/iproute2/rt_tables", rtnl_rttable_tab->tab);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0045265E | 55 | push    rbp
0x0045265F | 48 89 E5 | mov     rbp, rsp
0x00452662 | 48 8B 05 5F 8B 30 00 | mov     rax, cs:qword_75B1C8
0x00452669 | 48 85 C0 | test    rax, rax
0x0045266C | 75 3A | jnz     short loc_4526A8
0x0045266E | BF 10 08 00 00 | mov     edi, 810h
0x00452673 | E8 70 7A FB FF | call    sub_40A0E8
0x00452678 | 48 89 05 49 8B 30 00 | mov     cs:qword_75B1C8, rax
0x0045267F | 48 8B 05 42 8B 30 00 | mov     rax, cs:qword_75B1C8
0x00452686 | 48 C7 40 10 D9 AC 51 00 | mov     qword ptr [rax+10h], offset aUnknown_9; "unknown"
0x0045268E | 48 8B 05 33 8B 30 00 | mov     rax, cs:qword_75B1C8
0x00452695 | 48 83 C0 10 | add     rax, 10h
0x00452699 | 48 89 C6 | mov     rsi, rax
0x0045269C | BF E1 AC 51 00 | mov     edi, offset aEtcIproute2RtR; "/etc/iproute2/rt_realms"
0x004526A1 | E8 72 FB FF FF | call    sub_452218
0x004526A6 | EB 01 | jmp     short loc_4526A9
0x004526A8 | 90 | nop
0x004526A9 | 5D | pop     rbp
0x004526AA | C3 | retn
 ************ 
Source Code:
static void rtnl_rtrealm_initialize(void)
{
	if (rtnl_rtrealm_tab) return;
	rtnl_rtrealm_tab = xzalloc(sizeof(*rtnl_rtrealm_tab));
	rtnl_rtrealm_tab->tab[0] = "unknown";
	rtnl_tab_initialize("/etc/iproute2/rt_realms", rtnl_rtrealm_tab->tab);
}
 ************ 
Parsed Output:
static void rtnl_rtrealms_initialize(void)
{
	if (rtnl_rtrealms_tab) return;
	rtnl_rtrealms_tab = xzalloc(sizeof(*rtnl_rtrealms_tab));
	rtnl_rtrealms_tab->tab[0] = "unknown";
	rtnl_tab_initialize("/etc/iproute2/rt_realms", rtnl_rtrealms_tab->tab);
}
 ************ 
Similarity Score (Unixcoder): 0.9740039706230164
Func rank: 4

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: bb_strtoull
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0040BECF | 55 | push    rbp
0x0040BED0 | 48 89 E5 | mov     rbp, rsp
0x0040BED3 | 48 83 EC 30 | sub     rsp, 30h
0x0040BED7 | 48 89 7D E8 | mov     [rbp+nptr], rdi
0x0040BEDB | 48 89 75 E0 | mov     [rbp+endptr], rsi
0x0040BEDF | 89 55 DC | mov     [rbp+base], edx
0x0040BEE2 | 48 83 7D E0 00 | cmp     [rbp+endptr], 0
0x0040BEE7 | 75 08 | jnz     short loc_40BEF1
0x0040BEE9 | 48 8D 45 F0 | lea     rax, [rbp+var_10]
0x0040BEED | 48 89 45 E0 | mov     [rbp+endptr], rax
0x0040BEF1 | 48 8B 45 E0 | mov     rax, [rbp+endptr]
0x0040BEF5 | 48 8B 55 E8 | mov     rdx, [rbp+nptr]
0x0040BEF9 | 48 89 10 | mov     [rax], rdx
0x0040BEFC | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0040BF00 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040BF03 | 0F B6 C0 | movzx   eax, al
0x0040BF06 | 89 C7 | mov     edi, eax
0x0040BF08 | E8 E5 FD FF FF | call    sub_40BCF2
0x0040BF0D | 85 C0 | test    eax, eax
0x0040BF0F | 75 07 | jnz     short loc_40BF18
0x0040BF11 | E8 1A FE FF FF | call    sub_40BD30
0x0040BF16 | EB 4C | jmp     short locret_40BF64
0x0040BF18 | 48 8B 05 E1 14 35 00 | mov     rax, cs:qword_75D400
0x0040BF1F | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x0040BF25 | 8B 55 DC | mov     edx, [rbp+base]; base
0x0040BF28 | 48 8B 4D E0 | mov     rcx, [rbp+endptr]
0x0040BF2C | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0040BF30 | 48 89 CE | mov     rsi, rcx; endptr
0x0040BF33 | 48 89 C7 | mov     rdi, rax; nptr
0x0040BF36 | E8 25 BA FF FF | call    _strtoul
0x0040BF3B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0040BF3F | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x0040BF44 | 48 39 45 F8 | cmp     [rbp+var_8], rax
0x0040BF48 | 76 07 | jbe     short loc_40BF51
0x0040BF4A | E8 E1 FD FF FF | call    sub_40BD30
0x0040BF4F | EB 13 | jmp     short locret_40BF64
0x0040BF51 | 48 8B 55 E0 | mov     rdx, [rbp+endptr]
0x0040BF55 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040BF59 | 48 89 D6 | mov     rsi, rdx
0x0040BF5C | 48 89 C7 | mov     rdi, rax
0x0040BF5F | E8 E6 FD FF FF | call    sub_40BD4A
0x0040BF64 | C9 | leave
0x0040BF65 | C3 | retn

 Ourput decompiled code:
ULONG_MAX
unsigned FAST_FUNC bb_strtou(const char *arg, char **endp, int base)
{
	unsigned long v;
	char *endptr;

	if (!endp) endp = &endptr;
	*endp = (char*) arg;

	if (!isalnum(arg[0])) return ret_ERANGE();
	errno = 0;
	v = strtoul(arg, endp, base);
	if (v > UINT_MAX) return ret_ERANGE();
	return handle_errors(v, endp);
}

## Example:

 Input assembly code:
0x0040BE2B | 55 | push    rbp
0x0040BE2C | 48 89 E5 | mov     rbp, rsp
0x0040BE2F | 48 83 EC 40 | sub     rsp, 40h
0x0040BE33 | 48 89 7D D8 | mov     [rbp+nptr], rdi
0x0040BE37 | 48 89 75 D0 | mov     [rbp+endptr], rsi
0x0040BE3B | 89 55 CC | mov     [rbp+base], edx
0x0040BE3E | 48 83 7D D0 00 | cmp     [rbp+endptr], 0
0x0040BE43 | 75 08 | jnz     short loc_40BE4D
0x0040BE45 | 48 8D 45 E8 | lea     rax, [rbp+var_18]
0x0040BE49 | 48 89 45 D0 | mov     [rbp+endptr], rax
0x0040BE4D | 48 8B 45 D0 | mov     rax, [rbp+endptr]
0x0040BE51 | 48 8B 55 D8 | mov     rdx, [rbp+nptr]
0x0040BE55 | 48 89 10 | mov     [rax], rdx
0x0040BE58 | 48 8B 45 D8 | mov     rax, [rbp+nptr]
0x0040BE5C | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040BE5F | 3C 2D | cmp     al, 2Dh ; '-'
0x0040BE61 | 74 09 | jz      short loc_40BE6C
0x0040BE63 | 48 8B 45 D8 | mov     rax, [rbp+nptr]
0x0040BE67 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040BE6A | EB 0B | jmp     short loc_40BE77
0x0040BE6C | 48 8B 45 D8 | mov     rax, [rbp+nptr]
0x0040BE70 | 48 83 C0 01 | add     rax, 1
0x0040BE74 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040BE77 | 88 45 FF | mov     [rbp+var_1], al
0x0040BE7A | 0F B6 45 FF | movzx   eax, [rbp+var_1]
0x0040BE7E | 0F B6 C0 | movzx   eax, al
0x0040BE81 | 89 C7 | mov     edi, eax
0x0040BE83 | E8 6A FE FF FF | call    sub_40BCF2
0x0040BE88 | 85 C0 | test    eax, eax
0x0040BE8A | 75 07 | jnz     short loc_40BE93
0x0040BE8C | E8 9F FE FF FF | call    sub_40BD30
0x0040BE91 | EB 3A | jmp     short locret_40BECD
0x0040BE93 | 48 8B 05 66 15 35 00 | mov     rax, cs:qword_75D400
0x0040BE9A | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x0040BEA0 | 8B 55 CC | mov     edx, [rbp+base]; base
0x0040BEA3 | 48 8B 4D D0 | mov     rcx, [rbp+endptr]
0x0040BEA7 | 48 8B 45 D8 | mov     rax, [rbp+nptr]
0x0040BEAB | 48 89 CE | mov     rsi, rcx; endptr
0x0040BEAE | 48 89 C7 | mov     rdi, rax; nptr
0x0040BEB1 | E8 EA B1 FF FF | call    _strtoll
0x0040BEB6 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0040BEBA | 48 8B 55 D0 | mov     rdx, [rbp+endptr]
0x0040BEBE | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0040BEC2 | 48 89 D6 | mov     rsi, rdx
0x0040BEC5 | 48 89 C7 | mov     rdi, rax
0x0040BEC8 | E8 7D FE FF FF | call    sub_40BD4A
0x0040BECD | C9 | leave
0x0040BECE | C3 | retn

 Ourput decompiled code:
long long FAST_FUNC bb_strtoll(const char *arg, char **endp, int base)
{
	unsigned long long v;
	char *endptr;
	char first;

	if (!endp) endp = &endptr;
	*endp = (char*) arg;

	/* Check for the weird "feature":
	 * a "-" string is apparently a valid "number" for strto[u]l[l]!
	 * It returns zero and errno is 0! :( */
	first = (arg[0] != '-' ? arg[0] : arg[1]);
	if (!isalnum(first)) return ret_ERANGE();

	errno = 0;
	v = strtoll(arg, endp, base);
	return handle_errors(v, endp);
}

## Example:

 Input assembly code:
0x0040BF66 | 55 | push    rbp
0x0040BF67 | 48 89 E5 | mov     rbp, rsp
0x0040BF6A | 48 83 EC 40 | sub     rsp, 40h
0x0040BF6E | 48 89 7D D8 | mov     [rbp+nptr], rdi
0x0040BF72 | 48 89 75 D0 | mov     [rbp+endptr], rsi
0x0040BF76 | 89 55 CC | mov     [rbp+base], edx
0x0040BF79 | 48 83 7D D0 00 | cmp     [rbp+endptr], 0
0x0040BF7E | 75 08 | jnz     short loc_40BF88
0x0040BF80 | 48 8D 45 E8 | lea     rax, [rbp+var_18]
0x0040BF84 | 48 89 45 D0 | mov     [rbp+endptr], rax
0x0040BF88 | 48 8B 45 D0 | mov     rax, [rbp+endptr]
0x0040BF8C | 48 8B 55 D8 | mov     rdx, [rbp+nptr]
0x0040BF90 | 48 89 10 | mov     [rax], rdx
0x0040BF93 | 48 8B 45 D8 | mov     rax, [rbp+nptr]
0x0040BF97 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040BF9A | 3C 2D | cmp     al, 2Dh ; '-'
0x0040BF9C | 74 09 | jz      short loc_40BFA7
0x0040BF9E | 48 8B 45 D8 | mov     rax, [rbp+nptr]
0x0040BFA2 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040BFA5 | EB 0B | jmp     short loc_40BFB2
0x0040BFA7 | 48 8B 45 D8 | mov     rax, [rbp+nptr]
0x0040BFAB | 48 83 C0 01 | add     rax, 1
0x0040BFAF | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040BFB2 | 88 45 FF | mov     [rbp+var_1], al
0x0040BFB5 | 0F B6 45 FF | movzx   eax, [rbp+var_1]
0x0040BFB9 | 0F B6 C0 | movzx   eax, al
0x0040BFBC | 89 C7 | mov     edi, eax
0x0040BFBE | E8 2F FD FF FF | call    sub_40BCF2
0x0040BFC3 | 85 C0 | test    eax, eax
0x0040BFC5 | 75 07 | jnz     short loc_40BFCE
0x0040BFC7 | E8 64 FD FF FF | call    sub_40BD30
0x0040BFCC | EB 5C | jmp     short locret_40C02A
0x0040BFCE | 48 8B 05 2B 14 35 00 | mov     rax, cs:qword_75D400
0x0040BFD5 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x0040BFDB | 8B 55 CC | mov     edx, [rbp+base]; base
0x0040BFDE | 48 8B 4D D0 | mov     rcx, [rbp+endptr]
0x0040BFE2 | 48 8B 45 D8 | mov     rax, [rbp+nptr]
0x0040BFE6 | 48 89 CE | mov     rsi, rcx; endptr
0x0040BFE9 | 48 89 C7 | mov     rdi, rax; nptr
0x0040BFEC | E8 6F B1 FF FF | call    _strtol
0x0040BFF1 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0040BFF5 | 48 81 7D F0 FF FF FF 7F | cmp     [rbp+var_10], 7FFFFFFFh
0x0040BFFD | 7E 07 | jle     short loc_40C006
0x0040BFFF | E8 2C FD FF FF | call    sub_40BD30
0x0040C004 | EB 24 | jmp     short locret_40C02A
0x0040C006 | 48 81 7D F0 00 00 00 80 | cmp     [rbp+var_10], 0FFFFFFFF80000000h
0x0040C00E | 7D 07 | jge     short loc_40C017
0x0040C010 | E8 1B FD FF FF | call    sub_40BD30
0x0040C015 | EB 13 | jmp     short locret_40C02A
0x0040C017 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0040C01B | 48 8B 55 D0 | mov     rdx, [rbp+endptr]
0x0040C01F | 48 89 D6 | mov     rsi, rdx
0x0040C022 | 48 89 C7 | mov     rdi, rax
0x0040C025 | E8 20 FD FF FF | call    sub_40BD4A
0x0040C02A | C9 | leave
0x0040C02B | C3 | retn

 Ourput decompiled code:
int FAST_FUNC bb_strtoi(const char *arg, char **endp, int base)
{
	long v;
	char *endptr;
	char first;

	if (!endp) endp = &endptr;
	*endp = (char*) arg;

	first = (arg[0] != '-' ? arg[0] : arg[1]);
	if (!isalnum(first)) return ret_ERANGE();

	errno = 0;
	v = strtol(arg, endp, base);
	if (v > INT_MAX) return ret_ERANGE();
	if (v < INT_MIN) return ret_ERANGE();
	return handle_errors(v, endp);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0040BDA6 | 55 | push    rbp
0x0040BDA7 | 48 89 E5 | mov     rbp, rsp
0x0040BDAA | 48 83 EC 30 | sub     rsp, 30h
0x0040BDAE | 48 89 7D E8 | mov     [rbp+nptr], rdi
0x0040BDB2 | 48 89 75 E0 | mov     [rbp+endptr], rsi
0x0040BDB6 | 89 55 DC | mov     [rbp+base], edx
0x0040BDB9 | 48 83 7D E0 00 | cmp     [rbp+endptr], 0
0x0040BDBE | 75 08 | jnz     short loc_40BDC8
0x0040BDC0 | 48 8D 45 F0 | lea     rax, [rbp+var_10]
0x0040BDC4 | 48 89 45 E0 | mov     [rbp+endptr], rax
0x0040BDC8 | 48 8B 45 E0 | mov     rax, [rbp+endptr]
0x0040BDCC | 48 8B 55 E8 | mov     rdx, [rbp+nptr]
0x0040BDD0 | 48 89 10 | mov     [rax], rdx
0x0040BDD3 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0040BDD7 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040BDDA | 0F B6 C0 | movzx   eax, al
0x0040BDDD | 89 C7 | mov     edi, eax
0x0040BDDF | E8 0E FF FF FF | call    sub_40BCF2
0x0040BDE4 | 85 C0 | test    eax, eax
0x0040BDE6 | 75 07 | jnz     short loc_40BDEF
0x0040BDE8 | E8 43 FF FF FF | call    sub_40BD30
0x0040BDED | EB 3A | jmp     short locret_40BE29
0x0040BDEF | 48 8B 05 0A 16 35 00 | mov     rax, cs:qword_75D400
0x0040BDF6 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x0040BDFC | 8B 55 DC | mov     edx, [rbp+base]; base
0x0040BDFF | 48 8B 4D E0 | mov     rcx, [rbp+endptr]
0x0040BE03 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0040BE07 | 48 89 CE | mov     rsi, rcx; endptr
0x0040BE0A | 48 89 C7 | mov     rdi, rax; nptr
0x0040BE0D | E8 CE B1 FF FF | call    _strtoull
0x0040BE12 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0040BE16 | 48 8B 55 E0 | mov     rdx, [rbp+endptr]
0x0040BE1A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040BE1E | 48 89 D6 | mov     rsi, rdx
0x0040BE21 | 48 89 C7 | mov     rdi, rax
0x0040BE24 | E8 21 FF FF FF | call    sub_40BD4A
0x0040BE29 | C9 | leave
0x0040BE2A | C3 | retn
 ************ 
Source Code:
unsigned long long FAST_FUNC bb_strtoull(const char *arg, char **endp, int base)
{
	unsigned long long v;
	char *endptr;

	if (!endp) endp = &endptr;
	*endp = (char*) arg;

	/* strtoul("  -4200000000") returns 94967296, errno 0 (!) */
	/* I don't think that this is right. Preventing this... */
	if (!isalnum(arg[0])) return ret_ERANGE();

	/* not 100% correct for lib func, but convenient for the caller */
	errno = 0;
	v = strtoull(arg, endp, base);
	return handle_errors(v, endp);
}
 ************ 
Parsed Output:
unsigned long long FAST_FUNC bb_strtoull(const char *arg, char **endp, int base)
{
    unsigned long long v;
    char *endptr;

    if (!endp) endp = &endptr;
    *endp = (char*) arg;

    if (!isalnum(arg[0])) return ret_ERANGE();
    errno = 0;
    v = strtoull(arg, endp, base);
    return handle_errors(v, endp);
}
 ************ 
Similarity Score (Unixcoder): 0.9612904787063599
Func rank: 5

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: minix_clrbit
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00495E26 | 55 | push    rbp
0x00495E27 | 48 89 E5 | mov     rbp, rsp
0x00495E2A | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00495E2E | 89 75 F4 | mov     [rbp+var_C], esi
0x00495E31 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00495E34 | C1 E8 03 | shr     eax, 3
0x00495E37 | 89 C6 | mov     esi, eax
0x00495E39 | 89 F2 | mov     edx, esi
0x00495E3B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00495E3F | 48 01 D0 | add     rax, rdx
0x00495E42 | 0F B6 10 | movzx   edx, byte ptr [rax]
0x00495E45 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00495E48 | 83 E0 07 | and     eax, 7
0x00495E4B | BF 01 00 00 00 | mov     edi, 1
0x00495E50 | 89 C1 | mov     ecx, eax
0x00495E52 | D3 E7 | shl     edi, cl
0x00495E54 | 89 F8 | mov     eax, edi
0x00495E56 | 89 C7 | mov     edi, eax
0x00495E58 | 89 F1 | mov     ecx, esi
0x00495E5A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00495E5E | 48 01 C8 | add     rax, rcx
0x00495E61 | 09 FA | or      edx, edi
0x00495E63 | 88 10 | mov     [rax], dl
0x00495E65 | 48 8B 05 9C 75 2C 00 | mov     rax, cs:qword_75D408
0x00495E6C | C6 40 01 01 | mov     byte ptr [rax+1], 1
0x00495E70 | 90 | nop
0x00495E71 | 5D | pop     rbp
0x00495E72 | C3 | retn

 Ourput decompiled code:
static void minix_setbit(char *a, unsigned i)
{
	setbit(a, i);
	changed = 1;
}

## Example:

 Input assembly code:
0x00495DF1 | 55 | push    rbp
0x00495DF2 | 48 89 E5 | mov     rbp, rsp
0x00495DF5 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00495DF9 | 89 75 F4 | mov     [rbp+var_C], esi
0x00495DFC | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00495DFF | C1 E8 03 | shr     eax, 3
0x00495E02 | 89 C2 | mov     edx, eax
0x00495E04 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00495E08 | 48 01 D0 | add     rax, rdx
0x00495E0B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00495E0E | 0F BE C0 | movsx   eax, al
0x00495E11 | 8B 55 F4 | mov     edx, [rbp+var_C]
0x00495E14 | 83 E2 07 | and     edx, 7
0x00495E17 | BE 01 00 00 00 | mov     esi, 1
0x00495E1C | 89 D1 | mov     ecx, edx
0x00495E1E | D3 E6 | shl     esi, cl
0x00495E20 | 89 F2 | mov     edx, esi
0x00495E22 | 21 D0 | and     eax, edx
0x00495E24 | 5D | pop     rbp
0x00495E25 | C3 | retn

 Ourput decompiled code:
static int minix_bit(const char *a, unsigned i)
{
	return (a[i >> 3] & (1<<(i & 7)));
}

## Example:

 Input assembly code:
0x00448EC6 | 55 | push    rbp
0x00448EC7 | 48 89 E5 | mov     rbp, rsp
0x00448ECA | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00448ECE | 89 75 F4 | mov     [rbp+var_C], esi
0x00448ED1 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00448ED4 | 8D 50 3F | lea     edx, [rax+3Fh]
0x00448ED7 | 85 C0 | test    eax, eax
0x00448ED9 | 0F 48 C2 | cmovs   eax, edx
0x00448EDC | C1 F8 06 | sar     eax, 6
0x00448EDF | 89 C6 | mov     esi, eax
0x00448EE1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00448EE5 | 48 63 D6 | movsxd  rdx, esi
0x00448EE8 | 48 83 C2 06 | add     rdx, 6
0x00448EEC | 48 8B 7C D0 08 | mov     rdi, [rax+rdx*8+8]
0x00448EF1 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00448EF4 | 99 | cdq
0x00448EF5 | C1 EA 1A | shr     edx, 1Ah
0x00448EF8 | 01 D0 | add     eax, edx
0x00448EFA | 83 E0 3F | and     eax, 3Fh
0x00448EFD | 29 D0 | sub     eax, edx
0x00448EFF | BA 01 00 00 00 | mov     edx, 1
0x00448F04 | 89 C1 | mov     ecx, eax
0x00448F06 | 48 D3 E2 | shl     rdx, cl
0x00448F09 | 48 89 D0 | mov     rax, rdx
0x00448F0C | 48 F7 D0 | not     rax
0x00448F0F | 48 21 C7 | and     rdi, rax
0x00448F12 | 48 89 F9 | mov     rcx, rdi
0x00448F15 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00448F19 | 48 63 D6 | movsxd  rdx, esi
0x00448F1C | 48 83 C2 06 | add     rdx, 6
0x00448F20 | 48 89 4C D0 08 | mov     [rax+rdx*8+8], rcx
0x00448F25 | 90 | nop
0x00448F26 | 5D | pop     rbp
0x00448F27 | C3 | retn

 Ourput decompiled code:
void isrv_dont_want_rd(isrv_state_t *state, int fd)
{
	FD_CLR(fd, &state->rd);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00495E73 | 55 | push    rbp
0x00495E74 | 48 89 E5 | mov     rbp, rsp
0x00495E77 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00495E7B | 89 75 F4 | mov     [rbp+var_C], esi
0x00495E7E | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00495E81 | C1 E8 03 | shr     eax, 3
0x00495E84 | 89 C6 | mov     esi, eax
0x00495E86 | 89 F2 | mov     edx, esi
0x00495E88 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00495E8C | 48 01 D0 | add     rax, rdx
0x00495E8F | 0F B6 10 | movzx   edx, byte ptr [rax]
0x00495E92 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00495E95 | 83 E0 07 | and     eax, 7
0x00495E98 | BF 01 00 00 00 | mov     edi, 1
0x00495E9D | 89 C1 | mov     ecx, eax
0x00495E9F | D3 E7 | shl     edi, cl
0x00495EA1 | 89 F8 | mov     eax, edi
0x00495EA3 | F7 D0 | not     eax
0x00495EA5 | 89 C1 | mov     ecx, eax
0x00495EA7 | 89 F6 | mov     esi, esi
0x00495EA9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00495EAD | 48 01 F0 | add     rax, rsi
0x00495EB0 | 21 CA | and     edx, ecx
0x00495EB2 | 88 10 | mov     [rax], dl
0x00495EB4 | 48 8B 05 4D 75 2C 00 | mov     rax, cs:qword_75D408
0x00495EBB | C6 40 01 01 | mov     byte ptr [rax+1], 1
0x00495EBF | 90 | nop
0x00495EC0 | 5D | pop     rbp
0x00495EC1 | C3 | retn
 ************ 
Source Code:
static void minix_clrbit(char *a, unsigned i)
{
	clrbit(a, i);
	changed = 1;
}
 ************ 
Parsed Output:
static void minix_setbit(char *a, unsigned i)
{
    setbit(a, i);
    changed = 1;
}
 ************ 
Similarity Score (Unixcoder): 0.9501824975013733
Func rank: 6

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: add_zone_ind
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0049787F | 55 | push    rbp
0x00497880 | 48 89 E5 | mov     rbp, rsp
0x00497883 | 48 83 EC 20 | sub     rsp, 20h
0x00497887 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0049788B | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x0049788F | C6 45 F7 00 | mov     [rbp+var_9], 0
0x00497893 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00497897 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0049789B | 48 89 D6 | mov     rsi, rdx
0x0049789E | 48 89 C7 | mov     rdi, rax
0x004978A1 | E8 CB FD FF FF | call    sub_497671
0x004978A6 | 89 45 F8 | mov     [rbp+var_8], eax
0x004978A9 | 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004978AD | 74 7E | jz      short loc_49792D
0x004978AF | 48 8B 05 52 5B 2C 00 | mov     rax, cs:qword_75D408
0x004978B6 | 48 8D 90 A4 09 00 00 | lea     rdx, [rax+9A4h]
0x004978BD | 8B 45 F8 | mov     eax, [rbp+var_8]
0x004978C0 | 48 89 D6 | mov     rsi, rdx
0x004978C3 | 89 C7 | mov     edi, eax
0x004978C5 | E8 37 EA FF FF | call    sub_496301
0x004978CA | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004978D1 | EB 2C | jmp     short loc_4978FF
0x004978D3 | 48 8B 05 2E 5B 2C 00 | mov     rax, cs:qword_75D408
0x004978DA | 48 8D 90 A4 09 00 00 | lea     rdx, [rax+9A4h]
0x004978E1 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004978E4 | 48 98 | cdqe
0x004978E6 | 48 01 C0 | add     rax, rax
0x004978E9 | 48 01 C2 | add     rdx, rax
0x004978EC | 48 8D 45 F7 | lea     rax, [rbp+var_9]
0x004978F0 | 48 89 C6 | mov     rsi, rax
0x004978F3 | 48 89 D7 | mov     rdi, rdx
0x004978F6 | E8 21 FE FF FF | call    sub_49771C
0x004978FB | 83 45 FC 01 | add     [rbp+var_4], 1
0x004978FF | 81 7D FC FF 01 00 00 | cmp     [rbp+var_4], 1FFh
0x00497906 | 7E CB | jle     short loc_4978D3
0x00497908 | 0F B6 45 F7 | movzx   eax, [rbp+var_9]
0x0049790C | 84 C0 | test    al, al
0x0049790E | 74 1E | jz      short locret_49792E
0x00497910 | 48 8B 05 F1 5A 2C 00 | mov     rax, cs:qword_75D408
0x00497917 | 48 8D 90 A4 09 00 00 | lea     rdx, [rax+9A4h]
0x0049791E | 8B 45 F8 | mov     eax, [rbp+var_8]
0x00497921 | 48 89 D6 | mov     rsi, rdx
0x00497924 | 89 C7 | mov     edi, eax
0x00497926 | E8 8B EA FF FF | call    sub_4963B6
0x0049792B | EB 01 | jmp     short locret_49792E
0x0049792D | 90 | nop
0x0049792E | C9 | leave
0x0049792F | C3 | retn

 Ourput decompiled code:
endif

static void add_zone_dind(uint16_t *znr, smallint *corrected)
{
	int i;
	int block;
	smallint chg_blk = 0;

	block = add_zone(znr, corrected);
	if (!block)
		return;
	read_block(block, add_zone_dind_blk);
	for (i = 0; i < (BLOCK_SIZE >> 1); i++)
		add_zone_ind(i + (uint16_t *) add_zone_dind_blk, &chg_blk);
	if (chg_blk)
		write_block(block, add_zone_dind_blk);
}

## Example:

 Input assembly code:
0x004977CD | 55 | push    rbp
0x004977CE | 48 89 E5 | mov     rbp, rsp
0x004977D1 | 48 83 EC 20 | sub     rsp, 20h
0x004977D5 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004977D9 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004977DD | C6 45 F7 00 | mov     [rbp+var_9], 0
0x004977E1 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x004977E5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004977E9 | 48 89 D6 | mov     rsi, rdx
0x004977EC | 48 89 C7 | mov     rdi, rax
0x004977EF | E8 D2 FE FF FF | call    sub_4976C6
0x004977F4 | 89 45 F8 | mov     [rbp+var_8], eax
0x004977F7 | 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004977FB | 74 7F | jz      short loc_49787C
0x004977FD | 48 8B 05 04 5C 2C 00 | mov     rax, cs:qword_75D408
0x00497804 | 48 8D 90 A4 05 00 00 | lea     rdx, [rax+5A4h]
0x0049780B | 8B 45 F8 | mov     eax, [rbp+var_8]
0x0049780E | 48 89 D6 | mov     rsi, rdx
0x00497811 | 89 C7 | mov     edi, eax
0x00497813 | E8 E9 EA FF FF | call    sub_496301
0x00497818 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x0049781F | EB 2D | jmp     short loc_49784E
0x00497821 | 48 8B 05 E0 5B 2C 00 | mov     rax, cs:qword_75D408
0x00497828 | 48 8D 90 A4 05 00 00 | lea     rdx, [rax+5A4h]
0x0049782F | 8B 45 FC | mov     eax, [rbp+var_4]
0x00497832 | 48 98 | cdqe
0x00497834 | 48 C1 E0 02 | shl     rax, 2
0x00497838 | 48 01 C2 | add     rdx, rax
0x0049783B | 48 8D 45 F7 | lea     rax, [rbp+var_9]
0x0049783F | 48 89 C6 | mov     rsi, rax
0x00497842 | 48 89 D7 | mov     rdi, rdx
0x00497845 | E8 7C FE FF FF | call    sub_4976C6
0x0049784A | 83 45 FC 01 | add     [rbp+var_4], 1
0x0049784E | 81 7D FC FF 00 00 00 | cmp     [rbp+var_4], 0FFh
0x00497855 | 7E CA | jle     short loc_497821
0x00497857 | 0F B6 45 F7 | movzx   eax, [rbp+var_9]
0x0049785B | 84 C0 | test    al, al
0x0049785D | 74 1E | jz      short locret_49787D
0x0049785F | 48 8B 05 A2 5B 2C 00 | mov     rax, cs:qword_75D408
0x00497866 | 48 8D 90 A4 05 00 00 | lea     rdx, [rax+5A4h]
0x0049786D | 8B 45 F8 | mov     eax, [rbp+var_8]
0x00497870 | 48 89 D6 | mov     rsi, rdx
0x00497873 | 89 C7 | mov     edi, eax
0x00497875 | E8 3C EB FF FF | call    sub_4963B6
0x0049787A | EB 01 | jmp     short locret_49787D
0x0049787C | 90 | nop
0x0049787D | C9 | leave
0x0049787E | C3 | retn

 Ourput decompiled code:
if ENABLE_FEATURE_MINIX2
static void add_zone_ind2(uint32_t *znr, smallint *corrected)
{
	int i;
	int block;
	smallint chg_blk = 0;

	block = add_zone2(znr, corrected);
	if (!block)
		return;
	read_block(block, add_zone_ind_blk);
	for (i = 0; i < BLOCK_SIZE >> 2; i++)
		add_zone2(i + (uint32_t *) add_zone_ind_blk, &chg_blk);
	if (chg_blk)
		write_block(block, add_zone_ind_blk);
}

## Example:

 Input assembly code:
0x00497930 | 55 | push    rbp
0x00497931 | 48 89 E5 | mov     rbp, rsp
0x00497934 | 48 83 EC 20 | sub     rsp, 20h
0x00497938 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0049793C | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00497940 | C6 45 F7 00 | mov     [rbp+var_9], 0
0x00497944 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00497948 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0049794C | 48 89 D6 | mov     rsi, rdx
0x0049794F | 48 89 C7 | mov     rdi, rax
0x00497952 | E8 6F FD FF FF | call    sub_4976C6
0x00497957 | 89 45 F8 | mov     [rbp+var_8], eax
0x0049795A | 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0049795E | 74 7F | jz      short loc_4979DF
0x00497960 | 48 8B 05 A1 5A 2C 00 | mov     rax, cs:qword_75D408
0x00497967 | 48 8D 90 A4 09 00 00 | lea     rdx, [rax+9A4h]
0x0049796E | 8B 45 F8 | mov     eax, [rbp+var_8]
0x00497971 | 48 89 D6 | mov     rsi, rdx
0x00497974 | 89 C7 | mov     edi, eax
0x00497976 | E8 86 E9 FF FF | call    sub_496301
0x0049797B | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x00497982 | EB 2D | jmp     short loc_4979B1
0x00497984 | 48 8B 05 7D 5A 2C 00 | mov     rax, cs:qword_75D408
0x0049798B | 48 8D 90 A4 09 00 00 | lea     rdx, [rax+9A4h]
0x00497992 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00497995 | 48 98 | cdqe
0x00497997 | 48 C1 E0 02 | shl     rax, 2
0x0049799B | 48 01 C2 | add     rdx, rax
0x0049799E | 48 8D 45 F7 | lea     rax, [rbp+var_9]
0x004979A2 | 48 89 C6 | mov     rsi, rax
0x004979A5 | 48 89 D7 | mov     rdi, rdx
0x004979A8 | E8 20 FE FF FF | call    sub_4977CD
0x004979AD | 83 45 FC 01 | add     [rbp+var_4], 1
0x004979B1 | 81 7D FC FF 00 00 00 | cmp     [rbp+var_4], 0FFh
0x004979B8 | 7E CA | jle     short loc_497984
0x004979BA | 0F B6 45 F7 | movzx   eax, [rbp+var_9]
0x004979BE | 84 C0 | test    al, al
0x004979C0 | 74 1E | jz      short locret_4979E0
0x004979C2 | 48 8B 05 3F 5A 2C 00 | mov     rax, cs:qword_75D408
0x004979C9 | 48 8D 90 A4 09 00 00 | lea     rdx, [rax+9A4h]
0x004979D0 | 8B 45 F8 | mov     eax, [rbp+var_8]
0x004979D3 | 48 89 D6 | mov     rsi, rdx
0x004979D6 | 89 C7 | mov     edi, eax
0x004979D8 | E8 D9 E9 FF FF | call    sub_4963B6
0x004979DD | EB 01 | jmp     short locret_4979E0
0x004979DF | 90 | nop
0x004979E0 | C9 | leave
0x004979E1 | C3 | retn

 Ourput decompiled code:
if ENABLE_FEATURE_MINIX2
static void add_zone_dind2(uint32_t *znr, smallint *corrected)
{
	int i;
	int block;
	smallint chg_blk = 0;

	block = add_zone2(znr, corrected);
	if (!block)
		return;
	read_block(block, add_zone_dind_blk);
	for (i = 0; i < BLOCK_SIZE >> 2; i++)
		add_zone_ind2(i + (uint32_t *) add_zone_dind_blk, &chg_blk);
	if (chg_blk)
		write_block(block, add_zone_dind_blk);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0049771C | 55 | push    rbp
0x0049771D | 48 89 E5 | mov     rbp, rsp
0x00497720 | 48 83 EC 20 | sub     rsp, 20h
0x00497724 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00497728 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x0049772C | C6 45 F7 00 | mov     [rbp+var_9], 0
0x00497730 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00497734 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00497738 | 48 89 D6 | mov     rsi, rdx
0x0049773B | 48 89 C7 | mov     rdi, rax
0x0049773E | E8 2E FF FF FF | call    sub_497671
0x00497743 | 89 45 F8 | mov     [rbp+var_8], eax
0x00497746 | 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0049774A | 74 7E | jz      short loc_4977CA
0x0049774C | 48 8B 05 B5 5C 2C 00 | mov     rax, cs:qword_75D408
0x00497753 | 48 8D 90 A4 05 00 00 | lea     rdx, [rax+5A4h]
0x0049775A | 8B 45 F8 | mov     eax, [rbp+var_8]
0x0049775D | 48 89 D6 | mov     rsi, rdx
0x00497760 | 89 C7 | mov     edi, eax
0x00497762 | E8 9A EB FF FF | call    sub_496301
0x00497767 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x0049776E | EB 2C | jmp     short loc_49779C
0x00497770 | 48 8B 05 91 5C 2C 00 | mov     rax, cs:qword_75D408
0x00497777 | 48 8D 90 A4 05 00 00 | lea     rdx, [rax+5A4h]
0x0049777E | 8B 45 FC | mov     eax, [rbp+var_4]
0x00497781 | 48 98 | cdqe
0x00497783 | 48 01 C0 | add     rax, rax
0x00497786 | 48 01 C2 | add     rdx, rax
0x00497789 | 48 8D 45 F7 | lea     rax, [rbp+var_9]
0x0049778D | 48 89 C6 | mov     rsi, rax
0x00497790 | 48 89 D7 | mov     rdi, rdx
0x00497793 | E8 D9 FE FF FF | call    sub_497671
0x00497798 | 83 45 FC 01 | add     [rbp+var_4], 1
0x0049779C | 81 7D FC FF 01 00 00 | cmp     [rbp+var_4], 1FFh
0x004977A3 | 7E CB | jle     short loc_497770
0x004977A5 | 0F B6 45 F7 | movzx   eax, [rbp+var_9]
0x004977A9 | 84 C0 | test    al, al
0x004977AB | 74 1E | jz      short locret_4977CB
0x004977AD | 48 8B 05 54 5C 2C 00 | mov     rax, cs:qword_75D408
0x004977B4 | 48 8D 90 A4 05 00 00 | lea     rdx, [rax+5A4h]
0x004977BB | 8B 45 F8 | mov     eax, [rbp+var_8]
0x004977BE | 48 89 D6 | mov     rsi, rdx
0x004977C1 | 89 C7 | mov     edi, eax
0x004977C3 | E8 EE EB FF FF | call    sub_4963B6
0x004977C8 | EB 01 | jmp     short locret_4977CB
0x004977CA | 90 | nop
0x004977CB | C9 | leave
0x004977CC | C3 | retn
 ************ 
Source Code:
endif

static void add_zone_ind(uint16_t *znr, smallint *corrected)
{
	int i;
	int block;
	smallint chg_blk = 0;

	block = add_zone(znr, corrected);
	if (!block)
		return;
	read_block(block, add_zone_ind_blk);
	for (i = 0; i < (BLOCK_SIZE >> 1); i++)
		add_zone(i + (uint16_t *) add_zone_ind_blk, &chg_blk);
	if (chg_blk)
		write_block(block, add_zone_ind_blk);
}
 ************ 
Parsed Output:
if ENABLE_FEATURE_MINIX2
static void add_zone_dind(uint16_t *znr, smallint *corrected)
{
    int i;
    int block;
    smallint chg_blk = 0;

    block = add_zone(znr, corrected);
    if (!block)
        return;
    read_block(block, add_zone_dind_blk);
    for (i = 0; i < (BLOCK_SIZE >> 1); i++)
        add_zone_ind(i + (uint16_t *) add_zone_dind_blk, &chg_blk);
    if (chg_blk)
        write_block(block, add_zone_dind_blk);
}
 ************ 
Similarity Score (Unixcoder): 0.9498040080070496
Func rank: 7

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: get_u16
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00452C74 | 55 | push    rbp
0x00452C75 | 48 89 E5 | mov     rbp, rsp
0x00452C78 | 48 83 EC 20 | sub     rsp, 20h
0x00452C7C | 48 89 7D E8 | mov     [rbp+nptr], rdi
0x00452C80 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00452C84 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x00452C88 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00452C8B | 84 C0 | test    al, al
0x00452C8D | 74 38 | jz      short loc_452CC7
0x00452C8F | 48 8D 4D F0 | lea     rcx, [rbp+endptr]
0x00452C93 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x00452C97 | BA 00 00 00 00 | mov     edx, 0; base
0x00452C9C | 48 89 CE | mov     rsi, rcx; endptr
0x00452C9F | 48 89 C7 | mov     rdi, rax; nptr
0x00452CA2 | E8 B9 4C FB FF | call    _strtoul
0x00452CA7 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00452CAB | 48 8B 45 F0 | mov     rax, [rbp+endptr]
0x00452CAF | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00452CB2 | 84 C0 | test    al, al
0x00452CB4 | 75 11 | jnz     short loc_452CC7
0x00452CB6 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x00452CBB | 48 39 45 F8 | cmp     [rbp+var_8], rax
0x00452CBF | 77 06 | ja      short loc_452CC7
0x00452CC1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00452CC5 | EB 13 | jmp     short locret_452CDA
0x00452CC7 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00452CCB | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x00452CCF | 48 89 D6 | mov     rsi, rdx
0x00452CD2 | 48 89 C7 | mov     rdi, rax
0x00452CD5 | E8 B9 05 00 00 | call    sub_453293
0x00452CDA | C9 | leave
0x00452CDB | C3 | retn

 Ourput decompiled code:
unsigned get_unsigned(char *arg, const char *errmsg)
{
	unsigned long res;
	char *ptr;

	if (*arg) {
		res = strtoul(arg, &ptr, 0);
//FIXME: "" will be accepted too, is it correct?!
		if (!*ptr && res <= UINT_MAX) {
			return res;
		}
	}
	invarg(arg, errmsg); /* does not return */
}

## Example:

 Input assembly code:
0x00452CDC | 55 | push    rbp
0x00452CDD | 48 89 E5 | mov     rbp, rsp
0x00452CE0 | 48 83 EC 20 | sub     rsp, 20h
0x00452CE4 | 48 89 7D E8 | mov     [rbp+nptr], rdi
0x00452CE8 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00452CEC | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x00452CF0 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00452CF3 | 84 C0 | test    al, al
0x00452CF5 | 74 38 | jz      short loc_452D2F
0x00452CF7 | 48 8D 4D F0 | lea     rcx, [rbp+endptr]
0x00452CFB | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x00452CFF | BA 00 00 00 00 | mov     edx, 0; base
0x00452D04 | 48 89 CE | mov     rsi, rcx; endptr
0x00452D07 | 48 89 C7 | mov     rdi, rax; nptr
0x00452D0A | E8 51 4C FB FF | call    _strtoul
0x00452D0F | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00452D13 | 48 8B 45 F0 | mov     rax, [rbp+endptr]
0x00452D17 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00452D1A | 84 C0 | test    al, al
0x00452D1C | 75 11 | jnz     short loc_452D2F
0x00452D1E | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x00452D23 | 48 39 45 F8 | cmp     [rbp+var_8], rax
0x00452D27 | 77 06 | ja      short loc_452D2F
0x00452D29 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00452D2D | EB 13 | jmp     short locret_452D42
0x00452D2F | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00452D33 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x00452D37 | 48 89 D6 | mov     rsi, rdx
0x00452D3A | 48 89 C7 | mov     rdi, rax
0x00452D3D | E8 51 05 00 00 | call    sub_453293
0x00452D42 | C9 | leave
0x00452D43 | C3 | retn

 Ourput decompiled code:
uint32_t get_u32(char *arg, const char *errmsg)
{
	unsigned long res;
	char *ptr;

	if (*arg) {
		res = strtoul(arg, &ptr, 0);
//FIXME: "" will be accepted too, is it correct?!
		if (!*ptr && res <= 0xFFFFFFFFUL) {
			return res;
		}
	}
	invarg(arg, errmsg); /* does not return */
}

## Example:

 Input assembly code:
0x00508790 | 55 | push    rbp
0x00508791 | 48 89 E5 | mov     rbp, rsp
0x00508794 | 48 83 EC 20 | sub     rsp, 20h
0x00508798 | 48 89 7D E8 | mov     [rbp+s], rdi
0x0050879C | 48 89 75 E0 | mov     [rbp+needle], rsi
0x005087A0 | 48 C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0
0x005087A8 | 48 8B 45 E0 | mov     rax, [rbp+needle]
0x005087AC | 0F B6 00 | movzx   eax, byte ptr [rax]
0x005087AF | 84 C0 | test    al, al
0x005087B1 | 75 18 | jnz     short loc_5087CB
0x005087B3 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x005087B7 | 48 89 C7 | mov     rdi, rax; s
0x005087BA | E8 11 E3 EF FF | call    _strlen
0x005087BF | 48 89 C2 | mov     rdx, rax
0x005087C2 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x005087C6 | 48 01 D0 | add     rax, rdx
0x005087C9 | EB 3A | jmp     short locret_508805
0x005087CB | 48 8B 55 E0 | mov     rdx, [rbp+needle]
0x005087CF | 48 8B 45 E8 | mov     rax, [rbp+s]
0x005087D3 | 48 89 D6 | mov     rsi, rdx; needle
0x005087D6 | 48 89 C7 | mov     rdi, rax; haystack
0x005087D9 | E8 E2 F4 EF FF | call    _strstr
0x005087DE | 48 89 45 F0 | mov     [rbp+var_10], rax
0x005087E2 | 48 83 7D F0 00 | cmp     [rbp+var_10], 0
0x005087E7 | 75 06 | jnz     short loc_5087EF
0x005087E9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x005087ED | EB 16 | jmp     short locret_508805
0x005087EF | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x005087F3 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x005087F7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x005087FB | 48 83 C0 01 | add     rax, 1
0x005087FF | 48 89 45 E8 | mov     [rbp+s], rax
0x00508803 | EB C6 | jmp     short loc_5087CB
0x00508805 | C9 | leave
0x00508806 | C3 | retn

 Ourput decompiled code:
FAST_FUNC strrstr(const char *haystack, const char *needle)
{
	char *r = NULL;

	if (!needle[0])
		return (char*)haystack + strlen(haystack);
	while (1) {
		char *p = strstr(haystack, needle);
		if (!p)
			return r;
		r = p;
		haystack = p + 1;
	}
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00452D44 | 55 | push    rbp
0x00452D45 | 48 89 E5 | mov     rbp, rsp
0x00452D48 | 48 83 EC 20 | sub     rsp, 20h
0x00452D4C | 48 89 7D E8 | mov     [rbp+nptr], rdi
0x00452D50 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00452D54 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x00452D58 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00452D5B | 84 C0 | test    al, al
0x00452D5D | 74 37 | jz      short loc_452D96
0x00452D5F | 48 8D 4D F0 | lea     rcx, [rbp+endptr]
0x00452D63 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x00452D67 | BA 00 00 00 00 | mov     edx, 0; base
0x00452D6C | 48 89 CE | mov     rsi, rcx; endptr
0x00452D6F | 48 89 C7 | mov     rdi, rax; nptr
0x00452D72 | E8 E9 4B FB FF | call    _strtoul
0x00452D77 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00452D7B | 48 8B 45 F0 | mov     rax, [rbp+endptr]
0x00452D7F | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00452D82 | 84 C0 | test    al, al
0x00452D84 | 75 10 | jnz     short loc_452D96
0x00452D86 | 48 81 7D F8 FF FF 00 00 | cmp     [rbp+var_8], 0FFFFh
0x00452D8E | 77 06 | ja      short loc_452D96
0x00452D90 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00452D94 | EB 13 | jmp     short locret_452DA9
0x00452D96 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00452D9A | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x00452D9E | 48 89 D6 | mov     rsi, rdx
0x00452DA1 | 48 89 C7 | mov     rdi, rax
0x00452DA4 | E8 EA 04 00 00 | call    sub_453293
0x00452DA9 | C9 | leave
0x00452DAA | C3 | retn
 ************ 
Source Code:
uint16_t get_u16(char *arg, const char *errmsg)
{
	unsigned long res;
	char *ptr;

	if (*arg) {
		res = strtoul(arg, &ptr, 0);
//FIXME: "" will be accepted too, is it correct?!
		if (!*ptr && res <= 0xFFFF) {
			return res;
		}
	}
	invarg(arg, errmsg); /* does not return */
}
 ************ 
Parsed Output:
unsigned long get_unsigned_long(char *arg, const char *errmsg)
{
    unsigned long res;
    char *ptr;

    if (*arg) {
        res = strtoul(arg, &ptr, 0);
        if (!*ptr && res <= 0xFFFF) {
            return res;
        }
    }
    invarg(arg, errmsg); /* does not return */
}
 ************ 
Similarity Score (Unixcoder): 0.9376726746559143
Func rank: 8

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: xclose
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0040A851 | 55 | push    rbp
0x0040A852 | 48 89 E5 | mov     rbp, rsp
0x0040A855 | 48 83 EC 10 | sub     rsp, 10h
0x0040A859 | 89 7D FC | mov     [rbp+gid], edi
0x0040A85C | 8B 45 FC | mov     eax, [rbp+gid]
0x0040A85F | 89 C7 | mov     edi, eax; gid
0x0040A861 | E8 0A CF FF FF | call    _setgid
0x0040A866 | 85 C0 | test    eax, eax
0x0040A868 | 74 0F | jz      short loc_40A879
0x0040A86A | BF D4 80 52 00 | mov     edi, offset aSetgid_0; "setgid"
0x0040A86F | B8 00 00 00 00 | mov     eax, 0
0x0040A874 | E8 29 EA FF FF | call    sub_4092A2
0x0040A879 | 90 | nop
0x0040A87A | C9 | leave
0x0040A87B | C3 | retn

 Ourput decompiled code:
void FAST_FUNC xsetgid(gid_t gid)
{
	if (setgid(gid)) bb_perror_msg_and_die("setgid");
}

## Example:

 Input assembly code:
0x0040A87C | 55 | push    rbp
0x0040A87D | 48 89 E5 | mov     rbp, rsp
0x0040A880 | 48 83 EC 10 | sub     rsp, 10h
0x0040A884 | 89 7D FC | mov     [rbp+uid], edi
0x0040A887 | 8B 45 FC | mov     eax, [rbp+uid]
0x0040A88A | 89 C7 | mov     edi, eax; uid
0x0040A88C | E8 CF D2 FF FF | call    _setuid
0x0040A891 | 85 C0 | test    eax, eax
0x0040A893 | 74 0F | jz      short loc_40A8A4
0x0040A895 | BF DB 80 52 00 | mov     edi, offset aSetuid_0; "setuid"
0x0040A89A | B8 00 00 00 00 | mov     eax, 0
0x0040A89F | E8 FE E9 FF FF | call    sub_4092A2
0x0040A8A4 | 90 | nop
0x0040A8A5 | C9 | leave
0x0040A8A6 | C3 | retn

 Ourput decompiled code:
void FAST_FUNC xsetuid(uid_t uid)
{
	if (setuid(uid)) bb_perror_msg_and_die("setuid");
}

## Example:

 Input assembly code:
0x004C6E96 | 55 | push    rbp
0x004C6E97 | 48 89 E5 | mov     rbp, rsp
0x004C6E9A | 48 83 EC 10 | sub     rsp, 10h
0x004C6E9E | 89 7D FC | mov     [rbp+var_4], edi
0x004C6EA1 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004C6EA4 | 83 E0 04 | and     eax, 4
0x004C6EA7 | 85 C0 | test    eax, eax
0x004C6EA9 | 74 0A | jz      short loc_4C6EB5
0x004C6EAB | BF EC 6A 53 00 | mov     edi, offset aTzUtc0; "TZ=UTC0"
0x004C6EB0 | E8 5B 01 F4 FF | call    _putenv
0x004C6EB5 | 90 | nop
0x004C6EB6 | C9 | leave
0x004C6EB7 | C3 | retn

 Ourput decompiled code:
static void maybe_set_utc(int opt)
{
	if (opt & OPT_UTC)
		putenv((char*)"TZ=UTC0");
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0040A52C | 55 | push    rbp
0x0040A52D | 48 89 E5 | mov     rbp, rsp
0x0040A530 | 48 83 EC 10 | sub     rsp, 10h
0x0040A534 | 89 7D FC | mov     [rbp+fd], edi
0x0040A537 | 8B 45 FC | mov     eax, [rbp+fd]
0x0040A53A | 89 C7 | mov     edi, eax; fd
0x0040A53C | E8 CF C8 FF FF | call    _close
0x0040A541 | 85 C0 | test    eax, eax
0x0040A543 | 74 0F | jz      short loc_40A554
0x0040A545 | BF 8C 80 52 00 | mov     edi, offset aCloseFailed; "close failed"
0x0040A54A | B8 00 00 00 00 | mov     eax, 0
0x0040A54F | E8 4E ED FF FF | call    sub_4092A2
0x0040A554 | 90 | nop
0x0040A555 | C9 | leave
0x0040A556 | C3 | retn
 ************ 
Source Code:
void FAST_FUNC xclose(int fd)
{
	if (close(fd))
		bb_perror_msg_and_die("close failed");
}
 ************ 
Parsed Output:
void close_fd(int fd)
{
    if (close(fd) != 0)
        bb_perror_msg_and_die("close failed");
}
 ************ 
Similarity Score (Unixcoder): 0.9242985844612122
Func rank: 9

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: write32
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004B29AD | 55 | push    rbp
0x004B29AE | 48 89 E5 | mov     rbp, rsp
0x004B29B1 | 48 83 EC 10 | sub     rsp, 10h
0x004B29B5 | 89 7D FC | mov     [rbp+hostlong], edi
0x004B29B8 | 8B 45 FC | mov     eax, [rbp+hostlong]
0x004B29BB | 89 C7 | mov     edi, eax; hostlong
0x004B29BD | E8 6E 43 F5 FF | call    _htonl
0x004B29C2 | 89 45 FC | mov     [rbp+hostlong], eax
0x004B29C5 | 48 8D 45 FC | lea     rax, [rbp+hostlong]
0x004B29C9 | BE 04 00 00 00 | mov     esi, 4
0x004B29CE | 48 89 C7 | mov     rdi, rax
0x004B29D1 | E8 92 FE FF FF | call    sub_4B2868
0x004B29D6 | 90 | nop
0x004B29D7 | C9 | leave
0x004B29D8 | C3 | retn

 Ourput decompiled code:
static void f_write32(uint32_t v)
{
	v = htonl(v);
	f_write(&v, 4);
}

## Example:

 Input assembly code:
0x00429778 | 55 | push    rbp
0x00429779 | 48 89 E5 | mov     rbp, rsp
0x0042977C | 48 83 EC 10 | sub     rsp, 10h
0x00429780 | 89 7D FC | mov     [rbp+var_4], edi
0x00429783 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00429786 | BE 7C B2 52 00 | mov     esi, offset aFeatures; "-Features:"
0x0042978B | 89 C7 | mov     edi, eax
0x0042978D | E8 FC FC FF FF | call    sub_42948E
0x00429792 | BF 88 B2 52 00 | mov     edi, offset aEpsvPasvRestSt; " EPSV\r\n PASV\r\n REST STREAM\r\n MDTM"...
0x00429797 | E8 1C FE FF FF | call    sub_4295B8
0x0042979C | 8B 45 FC | mov     eax, [rbp+var_4]
0x0042979F | BE B3 B2 52 00 | mov     esi, offset aOk; " Ok"
0x004297A4 | 89 C7 | mov     edi, eax
0x004297A6 | E8 E3 FC FF FF | call    sub_42948E
0x004297AB | 90 | nop
0x004297AC | C9 | leave
0x004297AD | C3 | retn

 Ourput decompiled code:
static void
handle_feat(unsigned status)
{
	cmdio_write(status, "-Features:");
	cmdio_write_raw(" EPSV\r\n"
			" PASV\r\n"
			" REST STREAM\r\n"
			" MDTM\r\n"
			" SIZE\r\n");
	cmdio_write(status, " Ok");
}

## Example:

 Input assembly code:
0x00480BCB | 55 | push    rbp
0x00480BCC | 48 89 E5 | mov     rbp, rsp
0x00480BCF | 48 83 EC 10 | sub     rsp, 10h
0x00480BD3 | 89 7D FC | mov     [rbp+var_4], edi
0x00480BD6 | BF 01 00 00 00 | mov     edi, 1
0x00480BDB | E8 FD FA FF FF | call    sub_4806DD
0x00480BE0 | 48 89 C6 | mov     rsi, rax
0x00480BE3 | BF 2B E6 51 00 | mov     edi, offset aPwdS; "PWD=%s"
0x00480BE8 | B8 00 00 00 00 | mov     eax, 0
0x00480BED | E8 C1 9A F8 FF | call    sub_40A6B3
0x00480BF2 | 48 89 C1 | mov     rcx, rax
0x00480BF5 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00480BF8 | BA 00 00 00 00 | mov     edx, 0
0x00480BFD | 89 C6 | mov     esi, eax
0x00480BFF | 48 89 CF | mov     rdi, rcx
0x00480C02 | E8 12 FD FF FF | call    sub_480919
0x00480C07 | 90 | nop
0x00480C08 | C9 | leave
0x00480C09 | C3 | retn

 Ourput decompiled code:
static void set_pwd_var(int exp)
{
	set_local_var(xasprintf("PWD=%s", get_cwd(/*force:*/ 1)),
		/*exp:*/ exp, /*lvl:*/ 0, /*ro:*/ 0);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004B2837 | 55 | push    rbp
0x004B2838 | 48 89 E5 | mov     rbp, rsp
0x004B283B | 48 83 EC 10 | sub     rsp, 10h
0x004B283F | 89 7D FC | mov     [rbp+hostlong], edi
0x004B2842 | 8B 45 FC | mov     eax, [rbp+hostlong]
0x004B2845 | 89 C7 | mov     edi, eax; hostlong
0x004B2847 | E8 E4 44 F5 FF | call    _htonl
0x004B284C | 89 45 FC | mov     [rbp+hostlong], eax
0x004B284F | 48 8D 45 FC | lea     rax, [rbp+hostlong]
0x004B2853 | BA 04 00 00 00 | mov     edx, 4
0x004B2858 | 48 89 C6 | mov     rsi, rax
0x004B285B | BF 01 00 00 00 | mov     edi, 1
0x004B2860 | E8 46 7C F5 FF | call    sub_40A4AB
0x004B2865 | 90 | nop
0x004B2866 | C9 | leave
0x004B2867 | C3 | retn
 ************ 
Source Code:
static void write32(uint32_t v)
{
	v = htonl(v);
	xwrite(1, &v, 4);
}
 ************ 
Parsed Output:
static void f_write32(uint32_t v)
{
    v = htonl(v);
    f_write(&v, 4);
}
 ************ 
Similarity Score (Unixcoder): 0.90984046459198
Func rank: 10

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: monotonic_ns
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0040BC67 | 55 | push    rbp
0x0040BC68 | 48 89 E5 | mov     rbp, rsp
0x0040BC6B | 48 83 EC 10 | sub     rsp, 10h
0x0040BC6F | 48 8D 45 F0 | lea     rax, [rbp+tv]
0x0040BC73 | BE 00 00 00 00 | mov     esi, 0; tz
0x0040BC78 | 48 89 C7 | mov     rdi, rax; tv
0x0040BC7B | E8 40 B0 FF FF | call    _gettimeofday
0x0040BC80 | 48 8B 45 F0 | mov     rax, [rbp+tv.tv_sec]
0x0040BC84 | 48 69 C0 40 42 0F 00 | imul    rax, 0F4240h
0x0040BC8B | 48 8B 55 F8 | mov     rdx, [rbp+tv.tv_usec]
0x0040BC8F | 48 01 D0 | add     rax, rdx
0x0040BC92 | C9 | leave
0x0040BC93 | C3 | retn

 Ourput decompiled code:
unsigned long long FAST_FUNC monotonic_us(void)
{
	struct timespec ts;
	get_mono(&ts);
	return ts.tv_sec * 1000000ULL + ts.tv_nsec/1000;
}

## Example:

 Input assembly code:
0x0040BC94 | 55 | push    rbp
0x0040BC95 | 48 89 E5 | mov     rbp, rsp
0x0040BC98 | 48 83 EC 10 | sub     rsp, 10h
0x0040BC9C | 48 8D 45 F0 | lea     rax, [rbp+tv]
0x0040BCA0 | BE 00 00 00 00 | mov     esi, 0; tz
0x0040BCA5 | 48 89 C7 | mov     rdi, rax; tv
0x0040BCA8 | E8 13 B0 FF FF | call    _gettimeofday
0x0040BCAD | 48 8B 45 F0 | mov     rax, [rbp+tv.tv_sec]
0x0040BCB1 | 48 69 F0 E8 03 00 00 | imul    rsi, rax, 3E8h
0x0040BCB8 | 48 8B 4D F8 | mov     rcx, [rbp+tv.tv_usec]
0x0040BCBC | 48 BA CF F7 53 E3 A5 9B C4 20 | mov     rdx, 20C49BA5E353F7CFh
0x0040BCC6 | 48 89 C8 | mov     rax, rcx
0x0040BCC9 | 48 F7 EA | imul    rdx
0x0040BCCC | 48 C1 FA 07 | sar     rdx, 7
0x0040BCD0 | 48 89 C8 | mov     rax, rcx
0x0040BCD3 | 48 C1 F8 3F | sar     rax, 3Fh
0x0040BCD7 | 48 29 C2 | sub     rdx, rax
0x0040BCDA | 48 89 D0 | mov     rax, rdx
0x0040BCDD | 48 01 F0 | add     rax, rsi
0x0040BCE0 | C9 | leave
0x0040BCE1 | C3 | retn

 Ourput decompiled code:
unsigned long long FAST_FUNC monotonic_ms(void)
{
	struct timespec ts;
	get_mono(&ts);
	return ts.tv_sec * 1000ULL + ts.tv_nsec/1000000;
}

## Example:

 Input assembly code:
0x00436544 | 55 | push    rbp
0x00436545 | 48 89 E5 | mov     rbp, rsp
0x00436548 | 48 83 EC 10 | sub     rsp, 10h
0x0043654C | 48 8D 45 F0 | lea     rax, [rbp+tv]
0x00436550 | BE 00 00 00 00 | mov     esi, 0; tz
0x00436555 | 48 89 C7 | mov     rdi, rax; tv
0x00436558 | E8 63 07 FD FF | call    _gettimeofday
0x0043655D | 48 8B 45 F0 | mov     rax, [rbp+tv.tv_sec]
0x00436561 | 2D 80 81 55 7C | sub     eax, 7C558180h
0x00436566 | 89 C7 | mov     edi, eax; hostlong
0x00436568 | E8 C3 07 FD FF | call    _htonl
0x0043656D | C9 | leave
0x0043656E | C3 | retn

 Ourput decompiled code:
static uint32_t machtime(void)
{
	struct timeval tv;

	gettimeofday(&tv, NULL);
	return htonl((uint32_t)(tv.tv_sec + 2208988800));
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0040BC33 | 55 | push    rbp
0x0040BC34 | 48 89 E5 | mov     rbp, rsp
0x0040BC37 | 48 83 EC 10 | sub     rsp, 10h
0x0040BC3B | 48 8D 45 F0 | lea     rax, [rbp+tv]
0x0040BC3F | BE 00 00 00 00 | mov     esi, 0; tz
0x0040BC44 | 48 89 C7 | mov     rdi, rax; tv
0x0040BC47 | E8 74 B0 FF FF | call    _gettimeofday
0x0040BC4C | 48 8B 45 F0 | mov     rax, [rbp+tv.tv_sec]
0x0040BC50 | 48 69 C0 00 CA 9A 3B | imul    rax, 3B9ACA00h
0x0040BC57 | 48 8B 55 F8 | mov     rdx, [rbp+tv.tv_usec]
0x0040BC5B | 48 69 D2 E8 03 00 00 | imul    rdx, 3E8h
0x0040BC62 | 48 01 D0 | add     rax, rdx
0x0040BC65 | C9 | leave
0x0040BC66 | C3 | retn
 ************ 
Source Code:
unsigned long long FAST_FUNC monotonic_ns(void)
{
	struct timespec ts;
	get_mono(&ts);
	return ts.tv_sec * 1000000000ULL + ts.tv_nsec;
}
 ************ 
Parsed Output:
unsigned long long FAST_FUNC monotonic_us(void)
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return tv.tv_sec * 1000000ULL + tv.tv_usec;
}
 ************ 
Similarity Score (Unixcoder): 0.9072164297103882
Func rank: 11

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: skip_non_whitespace
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004093B4 | 55 | push    rbp
0x004093B5 | 48 89 E5 | mov     rbp, rsp
0x004093B8 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004093BC | EB 05 | jmp     short loc_4093C3
0x004093BE | 48 83 45 F8 01 | add     [rbp+var_8], 1
0x004093C3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004093C7 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004093CA | 3C 20 | cmp     al, 20h ; ' '
0x004093CC | 74 F0 | jz      short loc_4093BE
0x004093CE | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004093D2 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004093D5 | 83 E8 09 | sub     eax, 9
0x004093D8 | 3C 04 | cmp     al, 4
0x004093DA | 76 E2 | jbe     short loc_4093BE
0x004093DC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004093E0 | 5D | pop     rbp
0x004093E1 | C3 | retn

 Ourput decompiled code:
FAST_FUNC skip_whitespace(const char *s)
{
	/* In POSIX/C locale (the only locale we care about: do we REALLY want
	 * to allow Unicode whitespace in, say, .conf files? nuts!)
	 * isspace is only these chars: "\t\n\v\f\r" and space.
	 * "\t\n\v\f\r" happen to have ASCII codes 9,10,11,12,13.
	 * Use that.
	 */
	while (*s == ' ' || (unsigned char)(*s - 9) <= (13 - 9))
		s++;

	return (char *) s;
}

## Example:

 Input assembly code:
0x0046DF3E | 55 | push    rbp
0x0046DF3F | 48 89 E5 | mov     rbp, rsp
0x0046DF42 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0046DF46 | EB 13 | jmp     short loc_46DF5B
0x0046DF48 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0046DF4C | 48 8D 50 01 | lea     rdx, [rax+1]
0x0046DF50 | 48 89 55 F8 | mov     [rbp+var_8], rdx
0x0046DF54 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0046DF57 | 3C 3D | cmp     al, 3Dh ; '='
0x0046DF59 | 74 0D | jz      short loc_46DF68
0x0046DF5B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0046DF5F | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0046DF62 | 84 C0 | test    al, al
0x0046DF64 | 75 E2 | jnz     short loc_46DF48
0x0046DF66 | EB 01 | jmp     short loc_46DF69
0x0046DF68 | 90 | nop
0x0046DF69 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0046DF6D | 5D | pop     rbp
0x0046DF6E | C3 | retn

 Ourput decompiled code:
static const char *var_end(const char *var)
{
	while (*var)
		if (*var++ == '=')
			break;
	return var;
}

## Example:

 Input assembly code:
0x0044B2EE | 55 | push    rbp
0x0044B2EF | 48 89 E5 | mov     rbp, rsp
0x0044B2F2 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0044B2F6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0044B2FA | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0044B2FD | 3C 02 | cmp     al, 2
0x0044B2FF | 75 22 | jnz     short loc_44B323
0x0044B301 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0044B305 | 0F B6 40 01 | movzx   eax, byte ptr [rax+1]
0x0044B309 | 84 C0 | test    al, al
0x0044B30B | 74 16 | jz      short loc_44B323
0x0044B30D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0044B311 | 48 83 C0 04 | add     rax, 4
0x0044B315 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0044B318 | 3C 7F | cmp     al, 7Fh
0x0044B31A | 75 07 | jnz     short loc_44B323
0x0044B31C | B8 FE 00 00 00 | mov     eax, 0FEh
0x0044B321 | EB 05 | jmp     short loc_44B328
0x0044B323 | B8 00 00 00 00 | mov     eax, 0
0x0044B328 | 5D | pop     rbp
0x0044B329 | C3 | retn

 Ourput decompiled code:
static int default_scope(inet_prefix *lcl)
{
	if (lcl->family == AF_INET) {
		if (lcl->bytelen >= 1 && *(uint8_t*)&lcl->data == 127)
			return RT_SCOPE_HOST;
	}
	return 0;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004093E2 | 55 | push    rbp
0x004093E3 | 48 89 E5 | mov     rbp, rsp
0x004093E6 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004093EA | EB 05 | jmp     short loc_4093F1
0x004093EC | 48 83 45 F8 01 | add     [rbp+var_8], 1
0x004093F1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004093F5 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004093F8 | 84 C0 | test    al, al
0x004093FA | 74 19 | jz      short loc_409415
0x004093FC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00409400 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00409403 | 3C 20 | cmp     al, 20h ; ' '
0x00409405 | 74 0E | jz      short loc_409415
0x00409407 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040940B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040940E | 83 E8 09 | sub     eax, 9
0x00409411 | 3C 04 | cmp     al, 4
0x00409413 | 77 D7 | ja      short loc_4093EC
0x00409415 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00409419 | 5D | pop     rbp
0x0040941A | C3 | retn
 ************ 
Source Code:
FAST_FUNC skip_non_whitespace(const char *s)
{
	while (*s != '\0' && *s != ' ' && (unsigned char)(*s - 9) > (13 - 9))
		s++;

	return (char *) s;
}
 ************ 
Parsed Output:
static const char *skip_whitespace(const char *s)
{
    while (*s == ' ' || *s == '\t' || *s == '
' || *s == '\v' || *s == '\f' || *s == '\r')
        s++;

    return s;
}
 ************ 
Similarity Score (Unixcoder): 0.9033293724060059
Func rank: 12

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: detect_link_iff
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00430ACD | 55 | push    rbp
0x00430ACE | 48 89 E5 | mov     rbp, rsp
0x00430AD1 | 48 83 EC 30 | sub     rsp, 30h
0x00430AD5 | 48 8B 05 2C C9 32 00 | mov     rax, cs:qword_75D408
0x00430ADC | 0F B6 40 02 | movzx   eax, byte ptr [rax+2]
0x00430AE0 | 84 C0 | test    al, al
0x00430AE2 | 74 78 | jz      short loc_430B5C
0x00430AE4 | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00430AE8 | 48 89 C7 | mov     rdi, rax
0x00430AEB | E8 47 FB FF FF | call    sub_430637
0x00430AF0 | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00430AF4 | BA 48 86 51 00 | mov     edx, offset aGettingInterfa; "getting interface flags"
0x00430AF9 | 48 89 C6 | mov     rsi, rax
0x00430AFC | BF 13 89 00 00 | mov     edi, 8913h
0x00430B01 | E8 70 FB FF FF | call    sub_430676
0x00430B06 | 85 C0 | test    eax, eax
0x00430B08 | 79 0D | jns     short loc_430B17
0x00430B0A | 48 8B 05 F7 C8 32 00 | mov     rax, cs:qword_75D408
0x00430B11 | C6 40 02 00 | mov     byte ptr [rax+2], 0
0x00430B15 | EB 46 | jmp     short locret_430B5D
0x00430B17 | 0F B7 45 E0 | movzx   eax, [rbp+var_20]
0x00430B1B | 98 | cwde
0x00430B1C | 83 E0 01 | and     eax, 1
0x00430B1F | 85 C0 | test    eax, eax
0x00430B21 | 75 3A | jnz     short locret_430B5D
0x00430B23 | 0F B7 45 E0 | movzx   eax, [rbp+var_20]
0x00430B27 | 83 C8 01 | or      eax, 1
0x00430B2A | 66 89 45 E0 | mov     [rbp+var_20], ax
0x00430B2E | BF 60 86 51 00 | mov     edi, offset aUppingInterfac; "upping interface"
0x00430B33 | B8 00 00 00 00 | mov     eax, 0
0x00430B38 | E8 0A 8C FD FF | call    sub_409747
0x00430B3D | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00430B41 | BA 71 86 51 00 | mov     edx, offset aSettingInterfa; "setting interface flags"
0x00430B46 | 48 89 C6 | mov     rsi, rax
0x00430B49 | BF 14 89 00 00 | mov     edi, 8914h
0x00430B4E | E8 23 FB FF FF | call    sub_430676
0x00430B53 | 85 C0 | test    eax, eax
0x00430B55 | 79 06 | jns     short locret_430B5D
0x00430B57 | E8 D3 8D FD FF | call    sub_40992F
0x00430B5C | 90 | nop
0x00430B5D | C9 | leave
0x00430B5E | C3 | retn

 Ourput decompiled code:
static void up_iface(void)
{
	struct ifreq ifrequest;

	if (!G.iface_exists)
		return;

	set_ifreq_to_ifname(&ifrequest);
	if (network_ioctl(SIOCGIFFLAGS, &ifrequest, "getting interface flags") < 0) {
		G.iface_exists = 0;
		return;
	}

	if (!(ifrequest.ifr_flags & IFF_UP)) {
		ifrequest.ifr_flags |= IFF_UP;
		/* Let user know we mess up with interface */
		bb_error_msg("upping interface");
		if (network_ioctl(SIOCSIFFLAGS, &ifrequest, "setting interface flags") < 0)
			xfunc_die();
	}

#if 0 /* why do we mess with IP addr? It's not our business */
	if (network_ioctl(SIOCGIFADDR, &ifrequest, "can't get interface address") < 0) {
	} else if (ifrequest.ifr_addr.sa_family != AF_INET) {
		bb_perror_msg("the interface is not IP-based");
	} else {
		((struct sockaddr_in*)(&ifrequest.ifr_addr))->sin_addr.s_addr = INADDR_ANY;
		network_ioctl(SIOCSIFADDR, &ifrequest, "can't set interface address");
	}
	network_ioctl(SIOCGIFFLAGS, &ifrequest, "can't get interface flags");
#endif
}

## Example:

 Input assembly code:
0x00430893 | 55 | push    rbp
0x00430894 | 48 89 E5 | mov     rbp, rsp
0x00430897 | 48 83 EC 40 | sub     rsp, 40h
0x0043089B | 48 8D 45 D0 | lea     rax, [rbp+s]
0x0043089F | BA 20 00 00 00 | mov     edx, 20h ; ' '; n
0x004308A4 | BE 00 00 00 00 | mov     esi, 0; c
0x004308A9 | 48 89 C7 | mov     rdi, rax; s
0x004308AC | E8 9F 64 FD FF | call    _memset
0x004308B1 | 48 8B 05 50 CB 32 00 | mov     rax, cs:qword_75D408
0x004308B8 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x004308BC | 48 8D 45 D0 | lea     rax, [rbp+s]
0x004308C0 | 48 89 D6 | mov     rsi, rdx
0x004308C3 | 48 89 C7 | mov     rdi, rax
0x004308C6 | E8 87 91 FD FF | call    sub_409A52
0x004308CB | 48 8D 45 D0 | lea     rax, [rbp+s]
0x004308CF | BA 5D 85 51 00 | mov     edx, offset aSiocgiwap; "SIOCGIWAP"
0x004308D4 | 48 89 C6 | mov     rsi, rax
0x004308D7 | BF 15 8B 00 00 | mov     edi, 8B15h
0x004308DC | E8 95 FD FF FF | call    sub_430676
0x004308E1 | 85 C0 | test    eax, eax
0x004308E3 | 79 07 | jns     short loc_4308EC
0x004308E5 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x004308EA | EB 5E | jmp     short locret_43094A
0x004308EC | 8B 45 E2 | mov     eax, [rbp+var_1E]
0x004308EF | 89 45 CA | mov     [rbp+var_36], eax
0x004308F2 | 0F B7 45 E6 | movzx   eax, [rbp+var_1A]
0x004308F6 | 66 89 45 CE | mov     [rbp+var_32], ax
0x004308FA | 0F B6 45 CA | movzx   eax, byte ptr [rbp+var_36]
0x004308FE | 3C FF | cmp     al, 0FFh
0x00430900 | 74 10 | jz      short loc_430912
0x00430902 | 0F B6 45 CA | movzx   eax, byte ptr [rbp+var_36]
0x00430906 | 3C 44 | cmp     al, 44h ; 'D'
0x00430908 | 74 08 | jz      short loc_430912
0x0043090A | 0F B6 45 CA | movzx   eax, byte ptr [rbp+var_36]
0x0043090E | 84 C0 | test    al, al
0x00430910 | 75 33 | jnz     short loc_430945
0x00430912 | C7 45 FC 01 00 00 00 | mov     [rbp+var_4], 1
0x00430919 | EB 1D | jmp     short loc_430938
0x0043091B | 8B 45 FC | mov     eax, [rbp+var_4]
0x0043091E | 48 98 | cdqe
0x00430920 | 0F B6 54 05 CA | movzx   edx, byte ptr [rbp+rax+var_36]
0x00430925 | 0F B6 45 CA | movzx   eax, byte ptr [rbp+var_36]
0x00430929 | 38 C2 | cmp     dl, al
0x0043092B | 74 07 | jz      short loc_430934
0x0043092D | B8 01 00 00 00 | mov     eax, 1
0x00430932 | EB 16 | jmp     short locret_43094A
0x00430934 | 83 45 FC 01 | add     [rbp+var_4], 1
0x00430938 | 83 7D FC 05 | cmp     [rbp+var_4], 5
0x0043093C | 7E DD | jle     short loc_43091B
0x0043093E | B8 00 00 00 00 | mov     eax, 0
0x00430943 | EB 05 | jmp     short locret_43094A
0x00430945 | B8 01 00 00 00 | mov     eax, 1
0x0043094A | C9 | leave
0x0043094B | C3 | retn

 Ourput decompiled code:
static smallint detect_link_wlan(void)
{
	int i;
	struct iwreq iwrequest;
	uint8_t mac[ETH_ALEN];

	memset(&iwrequest, 0, sizeof(iwrequest));
	strncpy_IFNAMSIZ(iwrequest.ifr_ifrn.ifrn_name, G.iface);

	if (network_ioctl(SIOCGIWAP, &iwrequest, "SIOCGIWAP") < 0) {
		return IFSTATUS_ERR;
	}

	memcpy(mac, &iwrequest.u.ap_addr.sa_data, ETH_ALEN);

	if (mac[0] == 0xFF || mac[0] == 0x44 || mac[0] == 0x00) {
		for (i = 1; i < ETH_ALEN; ++i) {
			if (mac[i] != mac[0])
				return IFSTATUS_UP;
		}
		return IFSTATUS_DOWN;
	}

	return IFSTATUS_UP;
}

## Example:

 Input assembly code:
0x004307DD | 55 | push    rbp
0x004307DE | 48 89 E5 | mov     rbp, rsp
0x004307E1 | 48 83 EC 40 | sub     rsp, 40h
0x004307E5 | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x004307E9 | 48 89 C7 | mov     rdi, rax
0x004307EC | E8 46 FE FF FF | call    sub_430637
0x004307F1 | C7 45 C8 0A 00 00 00 | mov     [rbp+var_38], 0Ah
0x004307F8 | 48 8D 45 C8 | lea     rax, [rbp+var_38]
0x004307FC | 48 89 45 E0 | mov     [rbp+var_20], rax
0x00430800 | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00430804 | BA 42 85 51 00 | mov     edx, offset aEthtoolGlink; "ETHTOOL_GLINK"
0x00430809 | 48 89 C6 | mov     rsi, rax
0x0043080C | BF 46 89 00 00 | mov     edi, 8946h
0x00430811 | E8 60 FE FF FF | call    sub_430676
0x00430816 | 85 C0 | test    eax, eax
0x00430818 | 79 07 | jns     short loc_430821
0x0043081A | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x0043081F | EB 08 | jmp     short locret_430829
0x00430821 | 8B 45 CC | mov     eax, [rbp+var_34]
0x00430824 | 85 C0 | test    eax, eax
0x00430826 | 0F 95 C0 | setnz   al
0x00430829 | C9 | leave
0x0043082A | C3 | retn

 Ourput decompiled code:
static smallint detect_link_ethtool(void)
{
	struct ifreq ifreq;
	struct ethtool_value edata;

	set_ifreq_to_ifname(&ifreq);

	edata.cmd = ETHTOOL_GLINK;
	ifreq.ifr_data = (void*) &edata;

	if (network_ioctl(SIOCETHTOOL, &ifreq, "ETHTOOL_GLINK") < 0) {
		return IFSTATUS_ERR;
	}

	return edata.data ? IFSTATUS_UP : IFSTATUS_DOWN;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0043082B | 55 | push    rbp
0x0043082C | 48 89 E5 | mov     rbp, rsp
0x0043082F | 48 83 EC 30 | sub     rsp, 30h
0x00430833 | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00430837 | 48 89 C7 | mov     rdi, rax
0x0043083A | E8 F8 FD FF FF | call    sub_430637
0x0043083F | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00430843 | BA 50 85 51 00 | mov     edx, offset aSiocgifflags_1; "SIOCGIFFLAGS"
0x00430848 | 48 89 C6 | mov     rsi, rax
0x0043084B | BF 13 89 00 00 | mov     edi, 8913h
0x00430850 | E8 21 FE FF FF | call    sub_430676
0x00430855 | 85 C0 | test    eax, eax
0x00430857 | 79 07 | jns     short loc_430860
0x00430859 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x0043085E | EB 31 | jmp     short locret_430891
0x00430860 | 0F B7 45 E0 | movzx   eax, [rbp+var_20]
0x00430864 | 98 | cwde
0x00430865 | 83 E0 01 | and     eax, 1
0x00430868 | 85 C0 | test    eax, eax
0x0043086A | 75 1A | jnz     short loc_430886
0x0043086C | 48 8B 05 95 CB 32 00 | mov     rax, cs:qword_75D408
0x00430873 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00430876 | 3C FF | cmp     al, 0FFh
0x00430878 | 74 0C | jz      short loc_430886
0x0043087A | 48 8B 05 87 CB 32 00 | mov     rax, cs:qword_75D408
0x00430881 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00430884 | EB 0B | jmp     short locret_430891
0x00430886 | 0F B7 45 E0 | movzx   eax, [rbp+var_20]
0x0043088A | 98 | cwde
0x0043088B | C1 F8 06 | sar     eax, 6
0x0043088E | 83 E0 01 | and     eax, 1
0x00430891 | C9 | leave
0x00430892 | C3 | retn
 ************ 
Source Code:
static smallint detect_link_iff(void)
{
	struct ifreq ifreq;

	set_ifreq_to_ifname(&ifreq);

	if (network_ioctl(SIOCGIFFLAGS, &ifreq, "SIOCGIFFLAGS") < 0) {
		return IFSTATUS_ERR;
	}

	/* If IFF_UP is not set (interface is down), IFF_RUNNING is never set
	 * regardless of link status. Simply continue to report last status -
	 * no point in reporting spurious link downs if interface is disabled
	 * by admin. When/if it will be brought up,
	 * we'll report real link status.
	 */
	if (!(ifreq.ifr_flags & IFF_UP) && G.iface_last_status != IFSTATUS_ERR)
		return G.iface_last_status;

	return (ifreq.ifr_flags & IFF_RUNNING) ? IFSTATUS_UP : IFSTATUS_DOWN;
}
 ************ 
Parsed Output:
static smallint check_iface_flags(void)
{
	struct ifreq ifrequest;

	set_ifreq_to_ifname(&ifrequest);

	if (network_ioctl(SIOCGIFFLAGS, &ifrequest, "SIOCGIFFLAGS") < 0) {
		return IFSTATUS_ERR;
	}

	if (ifrequest.ifr_flags & IFF_UP) {
		return IFSTATUS_UP;
	} else {
		return IFSTATUS_DOWN;
	}
}
 ************ 
Similarity Score (Unixcoder): 0.8797438144683838
Func rank: 13

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: rtc_tm2time
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0042B3F8 | 55 | push    rbp
0x0042B3F9 | 48 89 E5 | mov     rbp, rsp
0x0042B3FC | 48 83 EC 20 | sub     rsp, 20h
0x0042B400 | 48 89 7D E8 | mov     [rbp+s], rdi
0x0042B404 | 89 75 E4 | mov     [rbp+var_1C], esi
0x0042B407 | 83 7D E4 00 | cmp     [rbp+var_1C], 0
0x0042B40B | 74 48 | jz      short loc_42B455
0x0042B40D | 48 8B 45 E8 | mov     rax, [rbp+s]
0x0042B411 | BE 4D 98 40 00 | mov     esi, offset sub_40984D
0x0042B416 | 48 89 C7 | mov     rdi, rax
0x0042B419 | E8 32 70 0D 00 | call    sub_502450
0x0042B41E | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0042B422 | EB 11 | jmp     short loc_42B435
0x0042B424 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x0042B428 | BE 00 00 00 00 | mov     esi, 0
0x0042B42D | 48 89 C7 | mov     rdi, rax
0x0042B430 | E8 C3 FF FF FF | call    sub_42B3F8
0x0042B435 | 48 8D 75 E8 | lea     rsi, [rbp+s]
0x0042B439 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0042B43D | B9 FA 58 53 00 | mov     ecx, offset asc_5358FA; "# \t"
0x0042B442 | BA 01 01 43 00 | mov     edx, 430101h
0x0042B447 | 48 89 C7 | mov     rdi, rax
0x0042B44A | E8 4C 72 0D 00 | call    sub_50269B
0x0042B44F | 85 C0 | test    eax, eax
0x0042B451 | 75 D1 | jnz     short loc_42B424
0x0042B453 | EB 31 | jmp     short loc_42B486
0x0042B455 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x0042B459 | 48 89 C7 | mov     rdi, rax; s
0x0042B45C | E8 6F B6 FD FF | call    _strlen
0x0042B461 | 48 89 C2 | mov     rdx, rax
0x0042B464 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x0042B468 | 48 89 D6 | mov     rsi, rdx; len
0x0042B46B | 48 89 C7 | mov     rdi, rax; name
0x0042B46E | E8 6D BC FD FF | call    _sethostname
0x0042B473 | 85 C0 | test    eax, eax
0x0042B475 | 74 0F | jz      short loc_42B486
0x0042B477 | BF FE 58 53 00 | mov     edi, offset aSethostname_0; "sethostname"
0x0042B47C | B8 00 00 00 00 | mov     eax, 0
0x0042B481 | E8 1C DE FD FF | call    sub_4092A2
0x0042B486 | 90 | nop
0x0042B487 | C9 | leave
0x0042B488 | C3 | retn

 Ourput decompiled code:
static void do_sethostname(char *s, int isfile)
{
//	if (!s)
//		return;
	if (isfile) {
		parser_t *parser = config_open2(s, xfopen_for_read);
		while (config_read(parser, &s, 1, 1, "# \t", PARSE_NORMAL & ~PARSE_GREEDY)) {
			do_sethostname(s, 0);
		}
		if (ENABLE_FEATURE_CLEAN_UP)
			config_close(parser);
	} else if (sethostname(s, strlen(s))) {
//		if (errno == EPERM)
//			bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
		bb_perror_msg_and_die("sethostname");
	}
}

## Example:

 Input assembly code:
0x0040B309 | 55 | push    rbp
0x0040B30A | 48 89 E5 | mov     rbp, rsp
0x0040B30D | 48 83 EC 20 | sub     rsp, 20h
0x0040B311 | 89 7D EC | mov     [rbp+var_14], edi
0x0040B314 | 89 75 E8 | mov     [rbp+var_18], esi
0x0040B317 | 48 89 55 E0 | mov     [rbp+var_20], rdx
0x0040B31B | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x0040B31F | 8B 4D E8 | mov     ecx, [rbp+var_18]
0x0040B322 | 8B 45 EC | mov     eax, [rbp+var_14]
0x0040B325 | 89 CE | mov     esi, ecx
0x0040B327 | 89 C7 | mov     edi, eax
0x0040B329 | E8 A6 FF FF FF | call    sub_40B2D4
0x0040B32E | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0040B332 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0040B336 | 48 99 | cqo
0x0040B338 | 48 89 D0 | mov     rax, rdx
0x0040B33B | 48 33 45 E0 | xor     rax, [rbp+var_20]
0x0040B33F | 48 29 D0 | sub     rax, rdx
0x0040B342 | 48 39 45 F8 | cmp     [rbp+var_8], rax
0x0040B346 | 74 1B | jz      short loc_40B363
0x0040B348 | 48 83 7D F8 FF | cmp     [rbp+var_8], 0FFFFFFFFFFFFFFFFh
0x0040B34D | 74 0F | jz      short loc_40B35E
0x0040B34F | BF 0C 50 53 00 | mov     edi, offset aShortRead; "short read"
0x0040B354 | B8 00 00 00 00 | mov     eax, 0
0x0040B359 | E8 40 E3 FF FF | call    sub_40969E
0x0040B35E | E8 CC E5 FF FF | call    sub_40992F
0x0040B363 | 90 | nop
0x0040B364 | C9 | leave
0x0040B365 | C3 | retn

 Ourput decompiled code:
void FAST_FUNC bb_copyfd_exact_size(int fd1, int fd2, off_t size)
{
	off_t sz = bb_copyfd_size(fd1, fd2, size);
	if (sz == (size >= 0 ? size : -size))
		return;
	if (sz != -1)
		bb_error_msg_and_die("short read");
	/* if sz == -1, bb_copyfd_XX already complained */
	xfunc_die();
}

## Example:

 Input assembly code:
0x0043A15B | 55 | push    rbp
0x0043A15C | 48 89 E5 | mov     rbp, rsp
0x0043A15F | 48 83 EC 30 | sub     rsp, 30h
0x0043A163 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0043A167 | 89 75 E4 | mov     [rbp+var_1C], esi
0x0043A16A | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x0043A16E | 89 4D E0 | mov     [rbp+var_20], ecx
0x0043A171 | 83 7D E0 00 | cmp     [rbp+var_20], 0
0x0043A175 | 74 0E | jz      short loc_43A185
0x0043A177 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043A17B | 48 89 C7 | mov     rdi, rax
0x0043A17E | E8 5B 1E 0D 00 | call    sub_50BFDE
0x0043A183 | EB 0C | jmp     short loc_43A191
0x0043A185 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043A189 | 48 89 C7 | mov     rdi, rax
0x0043A18C | E8 F0 1D 0D 00 | call    sub_50BF81
0x0043A191 | 48 89 45 F8 | mov     [rbp+ptr], rax
0x0043A195 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x0043A198 | 0F B7 C0 | movzx   eax, ax
0x0043A19B | 89 C7 | mov     edi, eax; hostshort
0x0043A19D | E8 CE C9 FC FF | call    _htons
0x0043A1A2 | 0F B7 C0 | movzx   eax, ax
0x0043A1A5 | 8B 55 E0 | mov     edx, [rbp+var_20]
0x0043A1A8 | 48 8B 4D D8 | mov     rcx, [rbp+var_28]
0x0043A1AC | 48 89 CE | mov     rsi, rcx
0x0043A1AF | 89 C7 | mov     edi, eax
0x0043A1B1 | E8 42 FF FF FF | call    sub_43A0F8
0x0043A1B6 | 48 89 C2 | mov     rdx, rax
0x0043A1B9 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x0043A1BD | 48 89 C6 | mov     rsi, rax
0x0043A1C0 | BF 0F A0 51 00 | mov     edi, offset aSS_19; "%s:%s"
0x0043A1C5 | B8 00 00 00 00 | mov     eax, 0
0x0043A1CA | E8 E4 04 FD FF | call    sub_40A6B3
0x0043A1CF | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0043A1D3 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x0043A1D7 | 48 89 C7 | mov     rdi, rax; ptr
0x0043A1DA | E8 81 C4 FC FF | call    _free
0x0043A1DF | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0043A1E3 | C9 | leave
0x0043A1E4 | C3 | retn

 Ourput decompiled code:
static char *ip_port_str(struct sockaddr *addr, int port, const char *proto, int numeric)
{
	char *host, *host_port;

	/* Code which used "*" for INADDR_ANY is removed: it's ambiguous
	 * in IPv6, while "0.0.0.0" is not. */

	host = numeric ? xmalloc_sockaddr2dotted_noport(addr)
	               : xmalloc_sockaddr2host_noport(addr);

	host_port = xasprintf("%s:%s", host, get_sname(htons(port), proto, numeric));
	free(host);
	return host_port;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00507D06 | 55 | push    rbp
0x00507D07 | 48 89 E5 | mov     rbp, rsp
0x00507D0A | 48 83 EC 20 | sub     rsp, 20h
0x00507D0E | 48 89 7D E8 | mov     [rbp+tp], rdi
0x00507D12 | 89 75 E4 | mov     [rbp+var_1C], esi
0x00507D15 | 83 7D E4 00 | cmp     [rbp+var_1C], 0
0x00507D19 | 74 1D | jz      short loc_507D38
0x00507D1B | BF E2 75 53 00 | mov     edi, offset aTz; "TZ"
0x00507D20 | E8 EB E8 EF FF | call    _getenv
0x00507D25 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00507D29 | BF E5 75 53 00 | mov     edi, offset aTzUtc0_0; "TZ=UTC0"
0x00507D2E | E8 DD F2 EF FF | call    _putenv
0x00507D33 | E8 D8 F4 EF FF | call    _tzset
0x00507D38 | 48 8B 45 E8 | mov     rax, [rbp+tp]
0x00507D3C | 48 89 C7 | mov     rdi, rax; tp
0x00507D3F | E8 8C F7 EF FF | call    _mktime
0x00507D44 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x00507D48 | 83 7D E4 00 | cmp     [rbp+var_1C], 0
0x00507D4C | 74 26 | jz      short loc_507D74
0x00507D4E | BF E2 75 53 00 | mov     edi, offset aTz; "TZ"
0x00507D53 | E8 88 FB EF FF | call    _unsetenv
0x00507D58 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00507D5D | 74 10 | jz      short loc_507D6F
0x00507D5F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00507D63 | 48 83 E8 03 | sub     rax, 3
0x00507D67 | 48 89 C7 | mov     rdi, rax; string
0x00507D6A | E8 A1 F2 EF FF | call    _putenv
0x00507D6F | E8 9C F4 EF FF | call    _tzset
0x00507D74 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00507D78 | C9 | leave
0x00507D79 | C3 | retn
 ************ 
Source Code:
time_t FAST_FUNC rtc_tm2time(struct tm *ptm, int utc)
{
	char *oldtz = oldtz; /* for compiler */
	time_t t;

	if (utc) {
		oldtz = getenv("TZ");
		putenv((char*)"TZ=UTC0");
		tzset();
	}

	t = mktime(ptm);

	if (utc) {
		unsetenv("TZ");
		if (oldtz)
			putenv(oldtz - 3);
		tzset();
	}

	return t;
}
 ************ 
Parsed Output:
static void set_timezone(char *tp, int is_dst)
{
    if (is_dst) {
        char *tz = getenv("TZ");
        if (tz) {
            free(tz);
        }
        unsetenv("TZ");
        tzset();
    }
    time_t t = mktime(tp);
    if (is_dst) {
        putenv("TZ=UTC0");
        tzset();
    }
    return t;
}
 ************ 
Similarity Score (Unixcoder): 0.8794346451759338
Func rank: 14

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: fopen_or_warn
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0040A1FC | 55 | push    rbp
0x0040A1FD | 48 89 E5 | mov     rbp, rsp
0x0040A200 | 48 83 EC 20 | sub     rsp, 20h
0x0040A204 | 48 89 7D E8 | mov     [rbp+filename], rdi
0x0040A208 | 48 89 75 E0 | mov     [rbp+modes], rsi
0x0040A20C | 48 8B 55 E0 | mov     rdx, [rbp+modes]
0x0040A210 | 48 8B 45 E8 | mov     rax, [rbp+filename]
0x0040A214 | 48 89 D6 | mov     rsi, rdx; modes
0x0040A217 | 48 89 C7 | mov     rdi, rax; filename
0x0040A21A | E8 31 CF FF FF | call    _fopen64
0x0040A21F | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0040A223 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0040A228 | 75 16 | jnz     short loc_40A240
0x0040A22A | 48 8B 45 E8 | mov     rax, [rbp+filename]
0x0040A22E | 48 89 C6 | mov     rsi, rax
0x0040A231 | BF 0D 80 52 00 | mov     edi, offset aCanTOpenS; "can't open '%s'"
0x0040A236 | B8 00 00 00 00 | mov     eax, 0
0x0040A23B | E8 62 F0 FF FF | call    sub_4092A2
0x0040A240 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040A244 | C9 | leave
0x0040A245 | C3 | retn

 Ourput decompiled code:
FAST_FUNC xfopen(const char *path, const char *mode)
{
	FILE *fp = fopen(path, mode);
	if (fp == NULL)
		bb_perror_msg_and_die("can't open '%s'", path);
	return fp;
}

## Example:

 Input assembly code:
0x005074C8 | 55 | push    rbp
0x005074C9 | 48 89 E5 | mov     rbp, rsp
0x005074CC | 48 83 EC 20 | sub     rsp, 20h
0x005074D0 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x005074D4 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x005074D8 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x005074DC | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x005074E0 | 48 89 D6 | mov     rsi, rdx
0x005074E3 | 48 89 C7 | mov     rdi, rax
0x005074E6 | E8 0C FF FF FF | call    sub_5073F7
0x005074EB | 48 89 45 F8 | mov     [rbp+var_8], rax
0x005074EF | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x005074F4 | 75 16 | jnz     short loc_50750C
0x005074F6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x005074FA | 48 89 C6 | mov     rsi, rax
0x005074FD | BF 94 75 53 00 | mov     edi, offset aCanTReadS_3; "can't read '%s'"
0x00507502 | B8 00 00 00 00 | mov     eax, 0
0x00507507 | E8 96 1D F0 FF | call    sub_4092A2
0x0050750C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00507510 | C9 | leave
0x00507511 | C3 | retn

 Ourput decompiled code:
FAST_FUNC xmalloc_xopen_read_close(const char *filename, size_t *maxsz_p)
{
	void *buf = xmalloc_open_read_close(filename, maxsz_p);
	if (!buf)
		bb_perror_msg_and_die("can't read '%s'", filename);
	return buf;
}

## Example:

 Input assembly code:
0x0040A09E | 55 | push    rbp
0x0040A09F | 48 89 E5 | mov     rbp, rsp
0x0040A0A2 | 48 83 EC 10 | sub     rsp, 10h
0x0040A0A6 | 48 89 7D F8 | mov     [rbp+ptr], rdi
0x0040A0AA | 48 89 75 F0 | mov     [rbp+size], rsi
0x0040A0AE | 48 8B 55 F0 | mov     rdx, [rbp+size]
0x0040A0B2 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x0040A0B6 | 48 89 D6 | mov     rsi, rdx; size
0x0040A0B9 | 48 89 C7 | mov     rdi, rax; ptr
0x0040A0BC | E8 EF D4 FF FF | call    _realloc
0x0040A0C1 | 48 89 45 F8 | mov     [rbp+ptr], rax
0x0040A0C5 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0
0x0040A0CA | 75 16 | jnz     short loc_40A0E2
0x0040A0CC | 48 83 7D F0 00 | cmp     [rbp+size], 0
0x0040A0D1 | 74 0F | jz      short loc_40A0E2
0x0040A0D3 | BF 2A 4D 53 00 | mov     edi, offset aOutOfMemory; "out of memory"
0x0040A0D8 | B8 00 00 00 00 | mov     eax, 0
0x0040A0DD | E8 BC F5 FF FF | call    sub_40969E
0x0040A0E2 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x0040A0E6 | C9 | leave
0x0040A0E7 | C3 | retn

 Ourput decompiled code:
FAST_FUNC xrealloc(void *ptr, size_t size)
{
	ptr = realloc(ptr, size);
	if (ptr == NULL && size != 0)
		bb_error_msg_and_die(bb_msg_memory_exhausted);
	return ptr;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004097EE | 55 | push    rbp
0x004097EF | 48 89 E5 | mov     rbp, rsp
0x004097F2 | 48 83 EC 20 | sub     rsp, 20h
0x004097F6 | 48 89 7D E8 | mov     [rbp+filename], rdi
0x004097FA | 48 89 75 E0 | mov     [rbp+modes], rsi
0x004097FE | 48 8B 55 E0 | mov     rdx, [rbp+modes]
0x00409802 | 48 8B 45 E8 | mov     rax, [rbp+filename]
0x00409806 | 48 89 D6 | mov     rsi, rdx; modes
0x00409809 | 48 89 C7 | mov     rdi, rax; filename
0x0040980C | E8 3F D9 FF FF | call    _fopen64
0x00409811 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00409815 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0040981A | 75 0C | jnz     short loc_409828
0x0040981C | 48 8B 45 E8 | mov     rax, [rbp+filename]
0x00409820 | 48 89 C7 | mov     rdi, rax
0x00409823 | E8 45 FB FF FF | call    sub_40936D
0x00409828 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040982C | C9 | leave
0x0040982D | C3 | retn
 ************ 
Source Code:
FAST_FUNC fopen_or_warn(const char *path, const char *mode)
{
	FILE *fp = fopen(path, mode);
	if (!fp) {
		bb_simple_perror_msg(path);
		//errno = 0; /* why? */
	}
	return fp;
}
 ************ 
Parsed Output:
FAST_FUNC xfopen(const char *filename, const char *modes)
{
    FILE *fp = fopen(filename, modes);
    if (fp == NULL)
        bb_perror_msg_and_die("can't open '%s'", filename);
    return fp;
}
 ************ 
Similarity Score (Unixcoder): 0.8762113451957703
Func rank: 15

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: xsetenv_proto
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00440C08 | 55 | push    rbp
0x00440C09 | 48 89 E5 | mov     rbp, rsp
0x00440C0C | 48 83 EC 20 | sub     rsp, 20h
0x00440C10 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00440C14 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00440C18 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00440C1C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00440C20 | 48 89 C6 | mov     rsi, rax
0x00440C23 | BF 48 BA 52 00 | mov     edi, offset aSS_20; "%s=%s"
0x00440C28 | B8 00 00 00 00 | mov     eax, 0
0x00440C2D | E8 81 9A FC FF | call    sub_40A6B3
0x00440C32 | 48 89 45 F8 | mov     [rbp+string], rax
0x00440C36 | BA F8 B3 75 00 | mov     edx, offset dest
0x00440C3B | 48 8B 42 18 | mov     rax, [rdx+18h]
0x00440C3F | 48 8D 48 08 | lea     rcx, [rax+8]
0x00440C43 | 48 89 4A 18 | mov     [rdx+18h], rcx
0x00440C47 | 48 8B 55 F8 | mov     rdx, [rbp+string]
0x00440C4B | 48 89 10 | mov     [rax], rdx
0x00440C4E | 48 8B 45 F8 | mov     rax, [rbp+string]
0x00440C52 | 48 89 C7 | mov     rdi, rax; string
0x00440C55 | E8 B6 63 FC FF | call    _putenv
0x00440C5A | 90 | nop
0x00440C5B | C9 | leave
0x00440C5C | C3 | retn

 Ourput decompiled code:
static void xsetenv_plain(const char *n, const char *v)
{
	char *var = xasprintf("%s=%s", n, v);
	*env_cur++ = var;
	putenv(var);
}

## Example:

 Input assembly code:
0x00480DED | 55 | push    rbp
0x00480DEE | 48 89 E5 | mov     rbp, rsp
0x00480DF1 | 48 83 EC 20 | sub     rsp, 20h
0x00480DF5 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00480DF9 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00480DFD | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00480E01 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00480E05 | 48 89 C6 | mov     rsi, rax
0x00480E08 | BF 32 E6 51 00 | mov     edi, offset aSS_33; "%s=%s"
0x00480E0D | B8 00 00 00 00 | mov     eax, 0
0x00480E12 | E8 9C 98 F8 FF | call    sub_40A6B3
0x00480E17 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00480E1B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00480E1F | BA 00 00 00 00 | mov     edx, 0
0x00480E24 | BE 00 00 00 00 | mov     esi, 0
0x00480E29 | 48 89 C7 | mov     rdi, rax
0x00480E2C | E8 E8 FA FF FF | call    sub_480919
0x00480E31 | 90 | nop
0x00480E32 | C9 | leave
0x00480E33 | C3 | retn

 Ourput decompiled code:
static void FAST_FUNC set_local_var_from_halves(const char *name, const char *val)
{
	char *var = xasprintf("%s=%s", name, val);
	set_local_var(var, /*flags:*/ 0, /*lvl:*/ 0, /*ro:*/ 0);
}

## Example:

 Input assembly code:
0x004DD898 | 55 | push    rbp
0x004DD899 | 48 89 E5 | mov     rbp, rsp
0x004DD89C | 48 83 EC 20 | sub     rsp, 20h
0x004DD8A0 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004DD8A4 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004DD8A8 | 48 89 55 E8 | mov     [rbp+var_18], rdx
0x004DD8AC | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004DD8B0 | C7 00 00 21 00 00 | mov     dword ptr [rax], 2100h
0x004DD8B6 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004DD8BA | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x004DD8BE | 48 89 50 08 | mov     [rax+8], rdx
0x004DD8C2 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DD8C6 | 48 8D 50 40 | lea     rdx, [rax+40h]
0x004DD8CA | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004DD8CE | 48 89 50 10 | mov     [rax+10h], rdx
0x004DD8D2 | 48 8B 4D F8 | mov     rcx, [rbp+var_8]
0x004DD8D6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DD8DA | BA 01 00 00 00 | mov     edx, 1
0x004DD8DF | 48 89 CE | mov     rsi, rcx
0x004DD8E2 | 48 89 C7 | mov     rdi, rax
0x004DD8E5 | E8 04 E9 02 00 | call    sub_50C1EE
0x004DD8EA | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DD8EE | 48 8D 48 40 | lea     rcx, [rax+40h]
0x004DD8F2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004DD8F6 | BA 03 00 00 00 | mov     edx, 3
0x004DD8FB | 48 89 C6 | mov     rsi, rax
0x004DD8FE | 48 89 CF | mov     rdi, rcx
0x004DD901 | E8 E8 E8 02 00 | call    sub_50C1EE
0x004DD906 | 90 | nop
0x004DD907 | C9 | leave
0x004DD908 | C3 | retn

 Ourput decompiled code:
static void mk_re_node(const char *s, node *n, regex_t *re)
{
	n->info = OC_REGEXP;
	n->l.re = re;
	n->r.ire = re + 1;
	xregcomp(re, s, REG_EXTENDED);
	xregcomp(re + 1, s, REG_EXTENDED | REG_ICASE);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00440C5D | 55 | push    rbp
0x00440C5E | 48 89 E5 | mov     rbp, rsp
0x00440C61 | 48 83 EC 30 | sub     rsp, 30h
0x00440C65 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00440C69 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00440C6D | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x00440C71 | 48 8B 4D D8 | mov     rcx, [rbp+var_28]
0x00440C75 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00440C79 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00440C7D | 48 89 C6 | mov     rsi, rax
0x00440C80 | BF 4E BA 52 00 | mov     edi, offset aSSS_2; "%s%s=%s"
0x00440C85 | B8 00 00 00 00 | mov     eax, 0
0x00440C8A | E8 24 9A FC FF | call    sub_40A6B3
0x00440C8F | 48 89 45 F8 | mov     [rbp+string], rax
0x00440C93 | BA F8 B3 75 00 | mov     edx, offset dest
0x00440C98 | 48 8B 42 18 | mov     rax, [rdx+18h]
0x00440C9C | 48 8D 48 08 | lea     rcx, [rax+8]
0x00440CA0 | 48 89 4A 18 | mov     [rdx+18h], rcx
0x00440CA4 | 48 8B 55 F8 | mov     rdx, [rbp+string]
0x00440CA8 | 48 89 10 | mov     [rax], rdx
0x00440CAB | 48 8B 45 F8 | mov     rax, [rbp+string]
0x00440CAF | 48 89 C7 | mov     rdi, rax; string
0x00440CB2 | E8 59 63 FC FF | call    _putenv
0x00440CB7 | 90 | nop
0x00440CB8 | C9 | leave
0x00440CB9 | C3 | retn
 ************ 
Source Code:
static void xsetenv_proto(const char *proto, const char *n, const char *v)
{
	char *var = xasprintf("%s%s=%s", proto, n, v);
	*env_cur++ = var;
	putenv(var);
}
 ************ 
Parsed Output:
static void setenv_plain(const char *name, const char *value)
{
    char *var = xasprintf("%s%s=%s", name, name, value);
    *env_cur++ = var;
    putenv(var);
}
 ************ 
Similarity Score (Unixcoder): 0.8685497045516968
Func rank: 16

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: sfp_to_d
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00454080 | 55 | push    rbp
0x00454081 | 48 89 E5 | mov     rbp, rsp
0x00454084 | 48 83 EC 20 | sub     rsp, 20h
0x00454088 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0045408C | 89 F0 | mov     eax, esi
0x0045408E | 88 45 E4 | mov     [rbp+var_1C], al
0x00454091 | 0F BE 55 E4 | movsx   edx, [rbp+var_1C]
0x00454095 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00454099 | 89 D6 | mov     esi, edx
0x0045409B | 48 89 C7 | mov     rdi, rax
0x0045409E | E8 A1 47 00 00 | call    sub_458844
0x004540A3 | E8 CD FF FF FF | call    sub_454075
0x004540A8 | 89 C2 | mov     edx, eax
0x004540AA | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004540AE | 89 50 04 | mov     [rax+4], edx
0x004540B1 | E8 2C 7C FB FF | call    sub_40BCE2
0x004540B6 | 89 C2 | mov     edx, eax
0x004540B8 | B8 F8 C3 75 00 | mov     eax, offset unk_75C3F8
0x004540BD | 66 89 50 72 | mov     [rax+72h], dx
0x004540C1 | B8 F8 C3 75 00 | mov     eax, offset unk_75C3F8
0x004540C6 | 0F B7 40 70 | movzx   eax, word ptr [rax+70h]
0x004540CA | 66 85 C0 | test    ax, ax
0x004540CD | 75 12 | jnz     short loc_4540E1
0x004540CF | B8 F8 C3 75 00 | mov     eax, offset unk_75C3F8
0x004540D4 | BA F8 C3 75 00 | mov     edx, offset unk_75C3F8
0x004540D9 | 0F B7 40 72 | movzx   eax, word ptr [rax+72h]
0x004540DD | 66 89 42 70 | mov     [rdx+70h], ax
0x004540E1 | B8 F8 C3 75 00 | mov     eax, offset unk_75C3F8
0x004540E6 | 0F B7 50 72 | movzx   edx, word ptr [rax+72h]
0x004540EA | B8 F8 C3 75 00 | mov     eax, offset unk_75C3F8
0x004540EF | 0F B7 40 70 | movzx   eax, word ptr [rax+70h]
0x004540F3 | 29 C2 | sub     edx, eax
0x004540F5 | 89 D0 | mov     eax, edx
0x004540F7 | 66 89 45 FE | mov     [rbp+var_2], ax
0x004540FB | 0F B7 45 FE | movzx   eax, [rbp+var_2]
0x004540FF | 89 C7 | mov     edi, eax; hostshort
0x00454101 | E8 6A 2A FB FF | call    _htons
0x00454106 | 89 C2 | mov     edx, eax
0x00454108 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0045410C | 66 89 50 08 | mov     [rax+8], dx
0x00454110 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00454114 | 48 83 C0 1C | add     rax, 1Ch
0x00454118 | BA 06 00 00 00 | mov     edx, 6; n
0x0045411D | BE F8 C3 75 00 | mov     esi, offset unk_75C3F8; src
0x00454122 | 48 89 C7 | mov     rdi, rax; dest
0x00454125 | E8 76 30 FB FF | call    _memcpy
0x0045412A | B8 F8 C3 75 00 | mov     eax, offset unk_75C3F8
0x0045412F | 48 8B 40 50 | mov     rax, [rax+50h]
0x00454133 | 48 85 C0 | test    rax, rax
0x00454136 | 74 18 | jz      short loc_454150
0x00454138 | B8 F8 C3 75 00 | mov     eax, offset unk_75C3F8
0x0045413D | 48 8B 50 50 | mov     rdx, [rax+50h]
0x00454141 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00454145 | 48 89 D6 | mov     rsi, rdx
0x00454148 | 48 89 C7 | mov     rdi, rax
0x0045414B | E8 32 5A 00 00 | call    sub_459B82
0x00454150 | 90 | nop
0x00454151 | C9 | leave
0x00454152 | C3 | retn

 Ourput decompiled code:
static void init_packet(struct dhcp_packet *packet, char type)
{
	uint16_t secs;

	/* Fill in: op, htype, hlen, cookie fields; message type option: */
	udhcp_init_header(packet, type);

	packet->xid = random_xid();

	client_config.last_secs = monotonic_sec();
	if (client_config.first_secs == 0)
		client_config.first_secs = client_config.last_secs;
	secs = client_config.last_secs - client_config.first_secs;
	packet->secs = htons(secs);

	memcpy(packet->chaddr, client_config.client_mac, 6);
	if (client_config.clientid)
		udhcp_add_binary_option(packet, client_config.clientid);
}

## Example:

 Input assembly code:
0x00412E8A | 55 | push    rbp
0x00412E8B | 48 89 E5 | mov     rbp, rsp
0x00412E8E | 48 83 EC 20 | sub     rsp, 20h
0x00412E92 | 89 7D EC | mov     [rbp+algorithm], edi
0x00412E95 | 48 C7 45 F8 10 50 51 00 | mov     [rbp+format], offset aSMinMaxPriorit; "%s min/max priority\t: %u/%u\n"
0x00412E9D | 8B 45 EC | mov     eax, [rbp+algorithm]
0x00412EA0 | 89 C7 | mov     edi, eax; algorithm
0x00412EA2 | E8 39 4C FF FF | call    _sched_get_priority_max
0x00412EA7 | 89 45 F4 | mov     [rbp+var_C], eax
0x00412EAA | 8B 45 EC | mov     eax, [rbp+algorithm]
0x00412EAD | 89 C7 | mov     edi, eax; algorithm
0x00412EAF | E8 0C 45 FF FF | call    _sched_get_priority_min
0x00412EB4 | 89 45 F0 | mov     [rbp+var_10], eax
0x00412EB7 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00412EBA | 0B 45 F0 | or      eax, [rbp+var_10]
0x00412EBD | 85 C0 | test    eax, eax
0x00412EBF | 79 08 | jns     short loc_412EC9
0x00412EC1 | 48 C7 45 F8 2D 50 51 00 | mov     [rbp+format], offset aSNotSupported; "%s not supported\n"
0x00412EC9 | 8B 45 EC | mov     eax, [rbp+algorithm]
0x00412ECC | 48 98 | cdqe
0x00412ECE | 48 C1 E0 04 | shl     rax, 4
0x00412ED2 | 48 05 E0 4F 51 00 | add     rax, 514FE0h
0x00412ED8 | 48 8D 70 04 | lea     rsi, [rax+4]
0x00412EDC | 8B 4D F4 | mov     ecx, [rbp+var_C]
0x00412EDF | 8B 55 F0 | mov     edx, [rbp+var_10]
0x00412EE2 | 48 8B 45 F8 | mov     rax, [rbp+format]
0x00412EE6 | 48 89 C7 | mov     rdi, rax; format
0x00412EE9 | B8 00 00 00 00 | mov     eax, 0
0x00412EEE | E8 DD 3C FF FF | call    _printf
0x00412EF3 | 90 | nop
0x00412EF4 | C9 | leave
0x00412EF5 | C3 | retn

 Ourput decompiled code:
SCHED_IDLE

static void show_min_max(int pol)
{
	const char *fmt = "%s min/max priority\t: %u/%u\n";
	int max, min;

	max = sched_get_priority_max(pol);
	min = sched_get_priority_min(pol);
	if ((max|min) < 0)
		fmt = "%s not supported\n";
	printf(fmt, policies[pol].name, min, max);
}

## Example:

 Input assembly code:
0x0043B3F6 | 55 | push    rbp
0x0043B3F7 | 48 89 E5 | mov     rbp, rsp
0x0043B3FA | 48 83 EC 20 | sub     rsp, 20h
0x0043B3FE | F2 0F 11 45 E8 | movsd   [rbp+var_18], xmm0
0x0043B403 | F2 0F 2C 45 E8 | cvttsd2si eax, [rbp+var_18]
0x0043B408 | 66 89 45 FC | mov     word ptr [rbp+var_4], ax
0x0043B40C | 0F B7 45 FC | movzx   eax, word ptr [rbp+var_4]
0x0043B410 | 0F B7 C0 | movzx   eax, ax
0x0043B413 | F2 0F 2A C8 | cvtsi2sd xmm1, eax
0x0043B417 | F2 0F 10 45 E8 | movsd   xmm0, [rbp+var_18]
0x0043B41C | F2 0F 5C C1 | subsd   xmm0, xmm1
0x0043B420 | 66 0F 28 C8 | movapd  xmm1, xmm0
0x0043B424 | F2 0F 10 05 0C A9 0E 00 | movsd   xmm0, cs:qword_525D38
0x0043B42C | F2 0F 59 C1 | mulsd   xmm0, xmm1
0x0043B430 | F2 0F 2C C0 | cvttsd2si eax, xmm0
0x0043B434 | 66 89 45 FE | mov     word ptr [rbp+var_4+2], ax
0x0043B438 | 0F B7 45 FC | movzx   eax, word ptr [rbp+var_4]
0x0043B43C | 0F B7 C0 | movzx   eax, ax
0x0043B43F | 89 C7 | mov     edi, eax; hostshort
0x0043B441 | E8 2A B7 FC FF | call    _htons
0x0043B446 | 66 89 45 FC | mov     word ptr [rbp+var_4], ax
0x0043B44A | 0F B7 45 FE | movzx   eax, word ptr [rbp+var_4+2]
0x0043B44E | 0F B7 C0 | movzx   eax, ax
0x0043B451 | 89 C7 | mov     edi, eax; hostshort
0x0043B453 | E8 18 B7 FC FF | call    _htons
0x0043B458 | 66 89 45 FE | mov     word ptr [rbp+var_4+2], ax
0x0043B45C | 8B 45 FC | mov     eax, [rbp+var_4]
0x0043B45F | C9 | leave
0x0043B460 | C3 | retn

 Ourput decompiled code:
static s_fixedpt_t
d_to_sfp(double d)
{
	s_fixedpt_t sfp;
	sfp.int_parts = (uint16_t)d;
	sfp.fractions = (uint16_t)((d - sfp.int_parts) * USHRT_MAX);
	sfp.int_parts = htons(sfp.int_parts);
	sfp.fractions = htons(sfp.fractions);
	return sfp;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0043B318 | 55 | push    rbp
0x0043B319 | 48 89 E5 | mov     rbp, rsp
0x0043B31C | 48 83 EC 20 | sub     rsp, 20h
0x0043B320 | 89 7D EC | mov     [rbp+var_14], edi
0x0043B323 | 0F B7 45 EC | movzx   eax, word ptr [rbp+var_14]
0x0043B327 | 0F B7 C0 | movzx   eax, ax
0x0043B32A | 89 C7 | mov     edi, eax; netshort
0x0043B32C | E8 1F C3 FC FF | call    _ntohs
0x0043B331 | 66 89 45 EC | mov     word ptr [rbp+var_14], ax
0x0043B335 | 0F B7 45 EE | movzx   eax, word ptr [rbp+var_14+2]
0x0043B339 | 0F B7 C0 | movzx   eax, ax
0x0043B33C | 89 C7 | mov     edi, eax; netshort
0x0043B33E | E8 0D C3 FC FF | call    _ntohs
0x0043B343 | 66 89 45 EE | mov     word ptr [rbp+var_14+2], ax
0x0043B347 | 0F B7 45 EC | movzx   eax, word ptr [rbp+var_14]
0x0043B34B | 0F B7 C0 | movzx   eax, ax
0x0043B34E | F2 0F 2A C8 | cvtsi2sd xmm1, eax
0x0043B352 | 0F B7 45 EE | movzx   eax, word ptr [rbp+var_14+2]
0x0043B356 | 0F B7 C0 | movzx   eax, ax
0x0043B359 | F2 0F 2A C0 | cvtsi2sd xmm0, eax
0x0043B35D | F2 0F 10 15 D3 A9 0E 00 | movsd   xmm2, cs:qword_525D38
0x0043B365 | F2 0F 5E C2 | divsd   xmm0, xmm2
0x0043B369 | F2 0F 58 C1 | addsd   xmm0, xmm1
0x0043B36D | F2 0F 11 45 F8 | movsd   [rbp+var_8], xmm0
0x0043B372 | F2 0F 10 45 F8 | movsd   xmm0, [rbp+var_8]
0x0043B377 | C9 | leave
0x0043B378 | C3 | retn
 ************ 
Source Code:
static double
sfp_to_d(s_fixedpt_t sfp)
{
	double ret;
	sfp.int_parts = ntohs(sfp.int_parts);
	sfp.fractions = ntohs(sfp.fractions);
	ret = (double)sfp.int_parts + ((double)sfp.fractions / USHRT_MAX);
	return ret;
}
 ************ 
Parsed Output:
static s_fixedpt_t convert_netshort(uint16_t netshort)
{
    s_fixedpt_t sfp;
    sfp.int_parts = ntohs(netshort);
    sfp.fractions = ntohs(netshort >> 16);
    return sfp;
}

static double convert_sfp(s_fixedpt_t sfp)
{
    double d = (double)sfp.int_parts + ((double)sfp.fractions / USHRT_MAX);
    return d;
}

static double convert_to_fixedpt(uint16_t netshort)
{
    s_fixedpt_t sfp = convert_netshort(netshort);
    double d = convert_sfp(sfp);
    return d;
}
 ************ 
Similarity Score (Unixcoder): 0.8669163584709167
Func rank: 17

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: outcslow
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00490876 | 55 | push    rbp
0x00490877 | 48 89 E5 | mov     rbp, rsp
0x0049087A | 48 83 EC 10 | sub     rsp, 10h
0x0049087E | 89 7D FC | mov     [rbp+var_4], edi
0x00490881 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x00490885 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00490888 | 89 C7 | mov     edi, eax
0x0049088A | E8 26 FD FF FF | call    sub_4905B5
0x0049088F | 48 8B 05 72 CB 2C 00 | mov     rax, cs:qword_75D408
0x00490896 | 8B 40 18 | mov     eax, [rax+18h]
0x00490899 | 89 C2 | mov     edx, eax
0x0049089B | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0049089F | 48 89 C6 | mov     rsi, rax
0x004908A2 | BF 03 00 00 00 | mov     edi, 3
0x004908A7 | E8 FF 9B F7 FF | call    sub_40A4AB
0x004908AC | 90 | nop
0x004908AD | C9 | leave
0x004908AE | C3 | retn

 Ourput decompiled code:
static void
write_sector(sector_t secno, const void *buf)
{
	seek_sector(secno);
	xwrite(dev_fd, buf, sector_size);
}

## Example:

 Input assembly code:
0x0046E097 | 55 | push    rbp
0x0046E098 | 48 89 E5 | mov     rbp, rsp
0x0046E09B | 48 83 EC 10 | sub     rsp, 10h
0x0046E09F | 48 89 7D F8 | mov     [rbp+s], rdi
0x0046E0A3 | 48 89 75 F0 | mov     [rbp+stream], rsi
0x0046E0A7 | 48 8B 05 6A F3 2E 00 | mov     rax, cs:qword_75D418
0x0046E0AE | 8B 50 30 | mov     edx, [rax+30h]
0x0046E0B1 | 83 C2 01 | add     edx, 1
0x0046E0B4 | 89 50 30 | mov     [rax+30h], edx
0x0046E0B7 | 48 8B 55 F0 | mov     rdx, [rbp+stream]
0x0046E0BB | 48 8B 45 F8 | mov     rax, [rbp+s]
0x0046E0BF | 48 89 D6 | mov     rsi, rdx; stream
0x0046E0C2 | 48 89 C7 | mov     rdi, rax; s
0x0046E0C5 | E8 F6 8E F9 FF | call    _fputs_unlocked
0x0046E0CA | E8 70 FF FF FF | call    sub_46E03F
0x0046E0CF | 90 | nop
0x0046E0D0 | C9 | leave
0x0046E0D1 | C3 | retn

 Ourput decompiled code:
static void
outstr(const char *p, FILE *file)
{
	INT_OFF;
	fputs(p, file);
	INT_ON;
}

## Example:

 Input assembly code:
0x004B2734 | 55 | push    rbp
0x004B2735 | 48 89 E5 | mov     rbp, rsp
0x004B2738 | 48 83 EC 10 | sub     rsp, 10h
0x004B273C | 89 7D FC | mov     [rbp+var_4], edi
0x004B273F | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004B2743 | 89 55 F8 | mov     [rbp+var_8], edx
0x004B2746 | 48 8B 0D EB AC 2A 00 | mov     rcx, cs:qword_75D438
0x004B274D | 8B 45 FC | mov     eax, [rbp+var_4]
0x004B2750 | F7 D0 | not     eax
0x004B2752 | 89 C7 | mov     edi, eax
0x004B2754 | 8B 55 F8 | mov     edx, [rbp+var_8]
0x004B2757 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004B275B | 48 89 C6 | mov     rsi, rax
0x004B275E | E8 D1 4D 04 00 | call    sub_4F7534
0x004B2763 | F7 D0 | not     eax
0x004B2765 | C9 | leave
0x004B2766 | C3 | retn

 Ourput decompiled code:
static FAST_FUNC uint32_t
lzo_crc32(uint32_t c, const uint8_t* buf, unsigned len)
{
	//if (buf == NULL) - impossible
	//	return 0;

	return ~crc32_block_endian0(~c, buf, len, global_crc32_table);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0046E0F3 | 55 | push    rbp
0x0046E0F4 | 48 89 E5 | mov     rbp, rsp
0x0046E0F7 | 48 83 EC 10 | sub     rsp, 10h
0x0046E0FB | 89 7D FC | mov     [rbp+c], edi
0x0046E0FE | 48 89 75 F0 | mov     [rbp+stream], rsi
0x0046E102 | 48 8B 05 0F F3 2E 00 | mov     rax, cs:qword_75D418
0x0046E109 | 8B 50 30 | mov     edx, [rax+30h]
0x0046E10C | 83 C2 01 | add     edx, 1
0x0046E10F | 89 50 30 | mov     [rax+30h], edx
0x0046E112 | 48 8B 55 F0 | mov     rdx, [rbp+stream]
0x0046E116 | 8B 45 FC | mov     eax, [rbp+c]
0x0046E119 | 48 89 D6 | mov     rsi, rdx; stream
0x0046E11C | 89 C7 | mov     edi, eax; c
0x0046E11E | E8 0D 92 F9 FF | call    _putc_unlocked
0x0046E123 | 48 8B 45 F0 | mov     rax, [rbp+stream]
0x0046E127 | 48 89 C7 | mov     rdi, rax; stream
0x0046E12A | E8 51 92 F9 FF | call    _fflush
0x0046E12F | E8 0B FF FF FF | call    sub_46E03F
0x0046E134 | 90 | nop
0x0046E135 | C9 | leave
0x0046E136 | C3 | retn
 ************ 
Source Code:
static void
outcslow(int c, FILE *dest)
{
	INT_OFF;
	putc(c, dest);
	fflush(dest);
	INT_ON;
}
 ************ 
Parsed Output:
static void
putchar_unlocked(int c)
{
	INT_OFF;
	putc_unlocked(c, stdout);
	fflush(stdout);
	INT_ON;
}
 ************ 
Similarity Score (Unixcoder): 0.8580515384674072
Func rank: 18

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: llist_add_to_end
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00409191 | 55 | push    rbp
0x00409192 | 48 89 E5 | mov     rbp, rsp
0x00409195 | 48 83 EC 10 | sub     rsp, 10h
0x00409199 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0040919D | 48 89 75 F0 | mov     [rbp+s2], rsi
0x004091A1 | EB 26 | jmp     short loc_4091C9
0x004091A3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004091A7 | 48 8B 40 08 | mov     rax, [rax+8]
0x004091AB | 48 8B 55 F0 | mov     rdx, [rbp+s2]
0x004091AF | 48 89 D6 | mov     rsi, rdx; s2
0x004091B2 | 48 89 C7 | mov     rdi, rax; s1
0x004091B5 | E8 96 DE FF FF | call    _strcmp
0x004091BA | 85 C0 | test    eax, eax
0x004091BC | 74 14 | jz      short loc_4091D2
0x004091BE | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004091C2 | 48 8B 00 | mov     rax, [rax]
0x004091C5 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004091C9 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004091CE | 75 D3 | jnz     short loc_4091A3
0x004091D0 | EB 01 | jmp     short loc_4091D3
0x004091D2 | 90 | nop
0x004091D3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004091D7 | C9 | leave
0x004091D8 | C3 | retn

 Ourput decompiled code:
FAST_FUNC llist_find_str(llist_t *list, const char *str)
{
	while (list) {
		if (strcmp(list->data, str) == 0)
			break;
		list = list->link;
	}
	return list;
}

## Example:

 Input assembly code:
0x004D12FE | 55 | push    rbp
0x004D12FF | 48 89 E5 | mov     rbp, rsp
0x004D1302 | 48 83 EC 10 | sub     rsp, 10h
0x004D1306 | 48 C7 45 F8 50 B2 75 00 | mov     [rbp+var_8], offset qword_75B250
0x004D130E | EB 0B | jmp     short loc_4D131B
0x004D1310 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004D1314 | 48 8B 00 | mov     rax, [rax]
0x004D1317 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004D131B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004D131F | 48 8B 00 | mov     rax, [rax]
0x004D1322 | 48 85 C0 | test    rax, rax
0x004D1325 | 75 E9 | jnz     short loc_4D1310
0x004D1327 | BF 20 00 00 00 | mov     edi, 20h ; ' '
0x004D132C | E8 B7 8D F3 FF | call    sub_40A0E8
0x004D1331 | 48 89 C2 | mov     rdx, rax
0x004D1334 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004D1338 | 48 89 10 | mov     [rax], rdx
0x004D133B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004D133F | 48 8B 00 | mov     rax, [rax]
0x004D1342 | C9 | leave
0x004D1343 | C3 | retn

 Ourput decompiled code:
static struct sort_key *add_key(void)
{
	struct sort_key **pkey = &key_list;
	while (*pkey)
		pkey = &((*pkey)->next_key);
	return *pkey = xzalloc(sizeof(struct sort_key));
}

## Example:

 Input assembly code:
0x004C03B7 | 55 | push    rbp
0x004C03B8 | 48 89 E5 | mov     rbp, rsp
0x004C03BB | 48 83 EC 10 | sub     rsp, 10h
0x004C03BF | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004C03C3 | 48 89 75 F0 | mov     [rbp+name], rsi
0x004C03C7 | EB 31 | jmp     short loc_4C03FA
0x004C03C9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C03CD | 48 8B 40 08 | mov     rax, [rax+8]
0x004C03D1 | 48 8B 4D F0 | mov     rcx, [rbp+name]
0x004C03D5 | BA 00 00 00 00 | mov     edx, 0; flags
0x004C03DA | 48 89 CE | mov     rsi, rcx; name
0x004C03DD | 48 89 C7 | mov     rdi, rax; pattern
0x004C03E0 | E8 3B 69 F4 FF | call    _fnmatch
0x004C03E5 | 85 C0 | test    eax, eax
0x004C03E7 | 75 06 | jnz     short loc_4C03EF
0x004C03E9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C03ED | EB 17 | jmp     short locret_4C0406
0x004C03EF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C03F3 | 48 8B 00 | mov     rax, [rax]
0x004C03F6 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004C03FA | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004C03FF | 75 C8 | jnz     short loc_4C03C9
0x004C0401 | B8 00 00 00 00 | mov     eax, 0
0x004C0406 | C9 | leave
0x004C0407 | C3 | retn

 Ourput decompiled code:
FAST_FUNC find_list_entry(const llist_t *list, const char *filename)
{
	while (list) {
		if (fnmatch(list->data, filename, 0) == 0) {
			return list;
		}
		list = list->link;
	}
	return NULL;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00409018 | 55 | push    rbp
0x00409019 | 48 89 E5 | mov     rbp, rsp
0x0040901C | 48 83 EC 10 | sub     rsp, 10h
0x00409020 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00409024 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x00409028 | EB 0B | jmp     short loc_409035
0x0040902A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040902E | 48 8B 00 | mov     rax, [rax]
0x00409031 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00409035 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00409039 | 48 8B 00 | mov     rax, [rax]
0x0040903C | 48 85 C0 | test    rax, rax
0x0040903F | 75 E9 | jnz     short loc_40902A
0x00409041 | BF 10 00 00 00 | mov     edi, 10h
0x00409046 | E8 9D 10 00 00 | call    sub_40A0E8
0x0040904B | 48 89 C2 | mov     rdx, rax
0x0040904E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00409052 | 48 89 10 | mov     [rax], rdx
0x00409055 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00409059 | 48 8B 00 | mov     rax, [rax]
0x0040905C | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x00409060 | 48 89 50 08 | mov     [rax+8], rdx
0x00409064 | 90 | nop
0x00409065 | C9 | leave
0x00409066 | C3 | retn
 ************ 
Source Code:
void FAST_FUNC llist_add_to_end(llist_t **list_head, void *data)
{
	while (*list_head)
		list_head = &(*list_head)->link;
	*list_head = xzalloc(sizeof(llist_t));
	(*list_head)->data = data;
	/*(*list_head)->link = NULL;*/
}
 ************ 
Parsed Output:
FAST_FUNC add_entry(llist_t **list, const void *data, size_t size)
{
	llist_t *new_entry = xzalloc(sizeof(llist_t));
	new_entry->data = xzalloc(size);
	memcpy(new_entry->data, data, size);
	new_entry->link = *list;
	*list = new_entry;
}
 ************ 
Similarity Score (Unixcoder): 0.8560113906860352
Func rank: 19

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: pivot_root_main
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004D7CA3 | 55 | push    rbp
0x004D7CA4 | 48 89 E5 | mov     rbp, rsp
0x004D7CA7 | 48 83 EC 10 | sub     rsp, 10h
0x004D7CAB | 89 7D FC | mov     [rbp+var_4], edi
0x004D7CAE | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004D7CB2 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004D7CB6 | 48 83 C0 08 | add     rax, 8
0x004D7CBA | 48 8B 00 | mov     rax, [rax]
0x004D7CBD | 48 85 C0 | test    rax, rax
0x004D7CC0 | 75 05 | jnz     short loc_4D7CC7
0x004D7CC2 | E8 9D 02 F3 FF | call    sub_407F64
0x004D7CC7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004D7CCB | 48 83 C0 08 | add     rax, 8
0x004D7CCF | 48 8B 00 | mov     rax, [rax]
0x004D7CD2 | 48 89 C7 | mov     rdi, rax
0x004D7CD5 | E8 27 34 03 00 | call    sub_50B101
0x004D7CDA | 89 C7 | mov     edi, eax; useconds
0x004D7CDC | E8 FF FF F2 FF | call    _usleep
0x004D7CE1 | B8 00 00 00 00 | mov     eax, 0
0x004D7CE6 | C9 | leave
0x004D7CE7 | C3 | retn

 Ourput decompiled code:
int usleep_main(int argc UNUSED_PARAM, char **argv)
{
	if (!argv[1]) {
		bb_show_usage();
	}

	usleep(xatou(argv[1]));

	return EXIT_SUCCESS;
}

## Example:

 Input assembly code:
0x0047E306 | 55 | push    rbp
0x0047E307 | 48 89 E5 | mov     rbp, rsp
0x0047E30A | 48 83 EC 10 | sub     rsp, 10h
0x0047E30E | 89 7D FC | mov     [rbp+var_4], edi
0x0047E311 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x0047E315 | E8 E2 4C FF FF | call    sub_472FFC
0x0047E31A | 85 C0 | test    eax, eax
0x0047E31C | 74 07 | jz      short loc_47E325
0x0047E31E | B8 00 00 00 00 | mov     eax, 0
0x0047E323 | EB 33 | jmp     short locret_47E358
0x0047E325 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0047E329 | 48 83 C0 08 | add     rax, 8
0x0047E32D | 48 8B 00 | mov     rax, [rax]
0x0047E330 | 48 85 C0 | test    rax, rax
0x0047E333 | 74 19 | jz      short loc_47E34E
0x0047E335 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0047E339 | 48 83 C0 08 | add     rax, 8
0x0047E33D | 48 8B 00 | mov     rax, [rax]
0x0047E340 | 48 89 C7 | mov     rdi, rax
0x0047E343 | E8 30 0B FF FF | call    sub_46EE78
0x0047E348 | 88 05 02 CC 2D 00 | mov     cs:byte_75AF50, al
0x0047E34E | BF 04 00 00 00 | mov     edi, 4
0x0047E353 | E8 17 FC FE FF | call    sub_46DF6F
0x0047E358 | C9 | leave
0x0047E359 | C3 | retn

 Ourput decompiled code:
static int FAST_FUNC
exitcmd(int argc UNUSED_PARAM, char **argv)
{
	if (stoppedjobs())
		return 0;
	if (argv[1])
		exitstatus = number(argv[1]);
	raise_exception(EXEXIT);
	/* NOTREACHED */
}

## Example:

 Input assembly code:
0x004228D5 | 55 | push    rbp
0x004228D6 | 48 89 E5 | mov     rbp, rsp
0x004228D9 | 48 83 EC 20 | sub     rsp, 20h
0x004228DD | 89 7D EC | mov     [rbp+var_14], edi
0x004228E0 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004228E4 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004228E8 | 48 83 C0 08 | add     rax, 8
0x004228EC | 48 8B 00 | mov     rax, [rax]
0x004228EF | 48 85 C0 | test    rax, rax
0x004228F2 | 75 05 | jnz     short loc_4228F9
0x004228F4 | E8 6B 56 FE FF | call    sub_407F64
0x004228F9 | E8 72 45 FE FF | call    _setsid
0x004228FE | 85 C0 | test    eax, eax
0x00422900 | 79 1D | jns     short loc_42291F
0x00422902 | E8 DF 85 FE FF | call    sub_40AEE6
0x00422907 | 89 45 FC | mov     [rbp+var_4], eax
0x0042290A | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0042290E | 74 0A | jz      short loc_42291A
0x00422910 | BF 00 00 00 00 | mov     edi, 0; status
0x00422915 | E8 A6 51 FE FF | call    _exit
0x0042291A | E8 51 45 FE FF | call    _setsid
0x0042291F | 48 83 45 E0 08 | add     [rbp+var_20], 8
0x00422924 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00422928 | 48 89 C7 | mov     rdi, rax
0x0042292B | E8 ED 69 0D 00 | call    sub_4F931D

 Ourput decompiled code:
int setsid_main(int argc UNUSED_PARAM, char **argv)
{
	if (!argv[1])
		bb_show_usage();

	/* setsid() is allowed only when we are not a process group leader.
	 * Otherwise our PID serves as PGID of some existing process group
	 * and cannot be used as PGID of a new process group. */
	if (setsid() < 0) {
		pid_t pid = fork_or_rexec(argv);
		if (pid != 0) {
			/* parent */
			/* TODO:
			 * we can waitpid(pid, &status, 0) and then even
			 * emulate exitcode, making the behavior consistent
			 * in both forked and non forked cases.
			 * However, the code is larger and upstream
			 * does not do such trick.
			 */
			exit(EXIT_SUCCESS);
		}

		/* child */
		/* now there should be no error: */
		setsid();
	}

	argv++;
	BB_EXECVP_or_die(argv);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004A32AA | 55 | push    rbp
0x004A32AB | 48 89 E5 | mov     rbp, rsp
0x004A32AE | 48 83 EC 10 | sub     rsp, 10h
0x004A32B2 | 89 7D FC | mov     [rbp+var_4], edi
0x004A32B5 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004A32B9 | 83 7D FC 03 | cmp     [rbp+var_4], 3
0x004A32BD | 74 05 | jz      short loc_4A32C4
0x004A32BF | E8 A0 4C F6 FF | call    sub_407F64
0x004A32C4 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004A32C8 | 48 83 C0 10 | add     rax, 10h
0x004A32CC | 48 8B 10 | mov     rdx, [rax]
0x004A32CF | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004A32D3 | 48 83 C0 08 | add     rax, 8
0x004A32D7 | 48 8B 00 | mov     rax, [rax]
0x004A32DA | 48 89 D6 | mov     rsi, rdx
0x004A32DD | 48 89 C7 | mov     rdi, rax
0x004A32E0 | E8 EB 46 F6 FF | call    _pivot_root
0x004A32E5 | 85 C0 | test    eax, eax
0x004A32E7 | 79 05 | jns     short loc_4A32EE
0x004A32E9 | E8 66 FA 05 00 | call    sub_502D54
0x004A32EE | B8 00 00 00 00 | mov     eax, 0
0x004A32F3 | C9 | leave
0x004A32F4 | C3 | retn
 ************ 
Source Code:
int pivot_root_main(int argc, char **argv)
{
	if (argc != 3)
		bb_show_usage();

	if (pivot_root(argv[1], argv[2]) < 0) {
		/* prints "pivot_root: <strerror text>" */
		bb_perror_nomsg_and_die();
	}

	return EXIT_SUCCESS;
}
 ************ 
Parsed Output:
int pivot_root_main(int argc UNUSED_PARAM, char **argv)
{
    if (argc != 3) {
        bb_show_usage();
    }

    char *new_root = argv[1];
    char *put_old = argv[2];

    if (pivot_root(new_root, put_old) < 0) {
        bb_perror_msg_and_die("pivot_root");
    }

    return EXIT_SUCCESS;
}
 ************ 
Similarity Score (Unixcoder): 0.8457530736923218
Func rank: 20

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: xdup2
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0040AA15 | 55 | push    rbp
0x0040AA16 | 48 89 E5 | mov     rbp, rsp
0x0040AA19 | 48 83 EC 10 | sub     rsp, 10h
0x0040AA1D | 89 7D FC | mov     [rbp+fd], edi
0x0040AA20 | 89 75 F8 | mov     [rbp+n], esi
0x0040AA23 | 8B 55 F8 | mov     edx, [rbp+n]
0x0040AA26 | 8B 45 FC | mov     eax, [rbp+fd]
0x0040AA29 | 89 D6 | mov     esi, edx; n
0x0040AA2B | 89 C7 | mov     edi, eax; fd
0x0040AA2D | E8 1E CA FF FF | call    _listen
0x0040AA32 | 85 C0 | test    eax, eax
0x0040AA34 | 74 0F | jz      short loc_40AA45
0x0040AA36 | BF 3A 81 52 00 | mov     edi, offset aListen_0; "listen"
0x0040AA3B | B8 00 00 00 00 | mov     eax, 0
0x0040AA40 | E8 5D E8 FF FF | call    sub_4092A2
0x0040AA45 | 90 | nop
0x0040AA46 | C9 | leave
0x0040AA47 | C3 | retn

 Ourput decompiled code:
void FAST_FUNC xlisten(int s, int backlog)
{
	if (listen(s, backlog)) bb_perror_msg_and_die("listen");
}

## Example:

 Input assembly code:
0x00471133 | 55 | push    rbp
0x00471134 | 48 89 E5 | mov     rbp, rsp
0x00471137 | 48 83 EC 10 | sub     rsp, 10h
0x0047113B | 89 7D FC | mov     [rbp+fd], edi
0x0047113E | 89 75 F8 | mov     [rbp+pgrp_id], esi
0x00471141 | 8B 55 F8 | mov     edx, [rbp+pgrp_id]
0x00471144 | 8B 45 FC | mov     eax, [rbp+fd]
0x00471147 | 89 D6 | mov     esi, edx; pgrp_id
0x00471149 | 89 C7 | mov     edi, eax; fd
0x0047114B | E8 70 66 F9 FF | call    _tcsetpgrp
0x00471150 | 85 C0 | test    eax, eax
0x00471152 | 74 0F | jz      short loc_471163
0x00471154 | BF 98 C9 51 00 | mov     edi, offset aCanTSetTtyProc; "can't set tty process group (%m)"
0x00471159 | B8 00 00 00 00 | mov     eax, 0
0x0047115E | E8 10 D3 FF FF | call    sub_46E473
0x00471163 | 90 | nop
0x00471164 | C9 | leave
0x00471165 | C3 | retn

 Ourput decompiled code:
if JOBS
static void
xtcsetpgrp(int fd, pid_t pgrp)
{
	if (tcsetpgrp(fd, pgrp))
		ash_msg_and_raise_error("can't set tty process group (%m)");
}

## Example:

 Input assembly code:
0x0040A477 | 55 | push    rbp
0x0040A478 | 48 89 E5 | mov     rbp, rsp
0x0040A47B | 48 83 EC 10 | sub     rsp, 10h
0x0040A47F | 89 7D FC | mov     [rbp+fd], edi
0x0040A482 | 89 75 F8 | mov     [rbp+var_8], esi
0x0040A485 | 8B 45 FC | mov     eax, [rbp+fd]
0x0040A488 | 3B 45 F8 | cmp     eax, [rbp+var_8]
0x0040A48B | 74 1B | jz      short loc_40A4A8
0x0040A48D | 8B 55 F8 | mov     edx, [rbp+var_8]
0x0040A490 | 8B 45 FC | mov     eax, [rbp+fd]
0x0040A493 | 89 D6 | mov     esi, edx
0x0040A495 | 89 C7 | mov     edi, eax
0x0040A497 | E8 A7 FF FF FF | call    sub_40A443
0x0040A49C | 8B 45 FC | mov     eax, [rbp+fd]
0x0040A49F | 89 C7 | mov     edi, eax; fd
0x0040A4A1 | E8 6A C9 FF FF | call    _close
0x0040A4A6 | EB 01 | jmp     short locret_40A4A9
0x0040A4A8 | 90 | nop
0x0040A4A9 | C9 | leave
0x0040A4AA | C3 | retn

 Ourput decompiled code:
opened fd
void FAST_FUNC xmove_fd(int from, int to)
{
	if (from == to)
		return;
	xdup2(from, to);
	close(from);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0040A443 | 55 | push    rbp
0x0040A444 | 48 89 E5 | mov     rbp, rsp
0x0040A447 | 48 83 EC 10 | sub     rsp, 10h
0x0040A44B | 89 7D FC | mov     [rbp+fd], edi
0x0040A44E | 89 75 F8 | mov     [rbp+fd2], esi
0x0040A451 | 8B 55 F8 | mov     edx, [rbp+fd2]
0x0040A454 | 8B 45 FC | mov     eax, [rbp+fd]
0x0040A457 | 89 D6 | mov     esi, edx; fd2
0x0040A459 | 89 C7 | mov     edi, eax; fd
0x0040A45B | E8 20 C7 FF FF | call    _dup2
0x0040A460 | 39 45 F8 | cmp     [rbp+fd2], eax
0x0040A463 | 74 0F | jz      short loc_40A474
0x0040A465 | BF 60 80 52 00 | mov     edi, offset aCanTDuplicateF; "can't duplicate file descriptor"
0x0040A46A | B8 00 00 00 00 | mov     eax, 0
0x0040A46F | E8 2E EE FF FF | call    sub_4092A2
0x0040A474 | 90 | nop
0x0040A475 | C9 | leave
0x0040A476 | C3 | retn
 ************ 
Source Code:
void FAST_FUNC xdup2(int from, int to)
{
	if (dup2(from, to) != to)
		bb_perror_msg_and_die("can't duplicate file descriptor");
}
 ************ 
Parsed Output:
void FAST_FUNC xdup2(int oldfd, int newfd)
{
    if (oldfd == newfd)
        return;
    if (dup2(oldfd, newfd) == -1)
        bb_perror_msg_and_die("can't duplicate file descriptor");
}
 ************ 
Similarity Score (Unixcoder): 0.8337316513061523
Func rank: 21

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: interrupted
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004A181C | 55 | push    rbp
0x004A181D | 48 89 E5 | mov     rbp, rsp
0x004A1820 | 48 83 EC 10 | sub     rsp, 10h
0x004A1824 | 89 7D FC | mov     [rbp+var_4], edi
0x004A1827 | BF 0A 00 00 00 | mov     edi, 0Ah
0x004A182C | E8 58 85 F6 FF | call    sub_409D89
0x004A1831 | BA FC B3 75 00 | mov     edx, offset dest.c_oflag; termios_p
0x004A1836 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004A183B | 8B 00 | mov     eax, [rax]
0x004A183D | BE 00 00 00 00 | mov     esi, 0; optional_actions
0x004A1842 | 89 C7 | mov     edi, eax; fd
0x004A1844 | E8 87 5F F6 FF | call    _tcsetattr
0x004A1849 | BF 01 00 00 00 | mov     edi, 1; status
0x004A184E | E8 6D 4F F6 FF | call    __exit

 Ourput decompiled code:
static void gotsig(int sig UNUSED_PARAM)
{
	/* bb_putchar_stderr doesn't use stdio buffering,
	 * therefore it is safe in signal handler */
	bb_putchar_stderr('\n');
	setTermSettings(cin_fileno, &initial_settings);
	_exit(EXIT_FAILURE);
}

## Example:

 Input assembly code:
0x004C4692 | 55 | push    rbp
0x004C4693 | 48 89 E5 | mov     rbp, rsp
0x004C4696 | 48 83 EC 10 | sub     rsp, 10h
0x004C469A | 89 7D FC | mov     [rbp+var_4], edi
0x004C469D | BA F8 B3 75 00 | mov     edx, offset dest; termios_p
0x004C46A2 | BE 00 00 00 00 | mov     esi, 0; optional_actions
0x004C46A7 | BF 02 00 00 00 | mov     edi, 2; fd
0x004C46AC | E8 1F 31 F4 FF | call    _tcsetattr
0x004C46B1 | BF 01 00 00 00 | mov     edi, 1; status
0x004C46B6 | E8 05 21 F4 FF | call    __exit

 Ourput decompiled code:
static void
onintr(int sig UNUSED_PARAM)
{
	tcsetattr(STDERR_FILENO, TCSANOW, old_termios_p);
	_exit(EXIT_FAILURE);
}

## Example:

 Input assembly code:
0x004EF4E0 | 55 | push    rbp
0x004EF4E1 | 48 89 E5 | mov     rbp, rsp
0x004EF4E4 | 48 83 EC 10 | sub     rsp, 10h
0x004EF4E8 | 89 7D FC | mov     [rbp+val], edi
0x004EF4EB | BE E0 F4 4E 00 | mov     esi, offset sub_4EF4E0; handler
0x004EF4F0 | BF 02 00 00 00 | mov     edi, 2; sig
0x004EF4F5 | E8 76 7B F1 FF | call    _signal
0x004EF4FA | 48 8B 05 07 DF 26 00 | mov     rax, cs:qword_75D408
0x004EF501 | 48 8D 90 88 02 00 00 | lea     rdx, [rax+288h]
0x004EF508 | 8B 45 FC | mov     eax, [rbp+val]
0x004EF50B | 89 C6 | mov     esi, eax; val
0x004EF50D | 48 89 D7 | mov     rdi, rdx; env
0x004EF510 | E8 3B 77 F1 FF | call    _siglongjmp

 Ourput decompiled code:
static void catch_sig(int sig)
{
	signal(SIGINT, catch_sig);
	siglongjmp(restart, sig);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0048C5A7 | 55 | push    rbp
0x0048C5A8 | 48 89 E5 | mov     rbp, rsp
0x0048C5AB | 48 83 EC 10 | sub     rsp, 10h
0x0048C5AF | 89 7D FC | mov     [rbp+var_4], edi
0x0048C5B2 | BE 01 00 00 00 | mov     esi, 1; handler
0x0048C5B7 | BF 02 00 00 00 | mov     edi, 2; sig
0x0048C5BC | E8 AF AA F7 FF | call    _signal
0x0048C5C1 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0048C5C6 | 48 8B 40 18 | mov     rax, [rax+18h]
0x0048C5CA | 48 89 C7 | mov     rdi, rax; shmaddr
0x0048C5CD | E8 3E A3 F7 FF | call    _shmdt
0x0048C5D2 | BF 00 00 00 00 | mov     edi, 0; status
0x0048C5D7 | E8 E4 B4 F7 FF | call    _exit
 ************ 
Source Code:
static void interrupted(int sig UNUSED_PARAM)
{
	signal(SIGINT, SIG_IGN);
	shmdt(shbuf);
	exit(EXIT_SUCCESS);
}
 ************ 
Parsed Output:
static void handler(int sig)
{
    signal(sig, handler);
    shmdt(dest);
    exit(0);
}
 ************ 
Similarity Score (Unixcoder): 0.8250725865364075
Func rank: 22

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: may_wakeup
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004654F9 | 55 | push    rbp
0x004654FA | 48 89 E5 | mov     rbp, rsp
0x004654FD | 48 83 EC 30 | sub     rsp, 30h
0x00465501 | 48 89 7D D8 | mov     [rbp+var_28], rdi
0x00465505 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00465509 | 48 89 C7 | mov     rdi, rax
0x0046550C | E8 8D CF 09 00 | call    sub_50249E
0x00465511 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00465515 | BF 43 DF 52 00 | mov     edi, offset aProcSys; "/proc/sys"
0x0046551A | E8 88 53 FA FF | call    sub_40A8A7
0x0046551F | EB 42 | jmp     short loc_465563
0x00465521 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00465525 | 48 89 C7 | mov     rdi, rax
0x00465528 | E8 13 FB FF FF | call    sub_465040
0x0046552D | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x00465531 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00465535 | 48 89 C6 | mov     rsi, rax
0x00465538 | BF 4D DF 52 00 | mov     edi, offset aSS_27; "%s=%s"
0x0046553D | B8 00 00 00 00 | mov     eax, 0
0x00465542 | E8 6C 51 FA FF | call    sub_40A6B3
0x00465547 | 48 89 45 F0 | mov     [rbp+ptr], rax
0x0046554B | 48 8B 45 F0 | mov     rax, [rbp+ptr]
0x0046554F | 48 89 C7 | mov     rdi, rax
0x00465552 | E8 67 FE FF FF | call    sub_4653BE
0x00465557 | 48 8B 45 F0 | mov     rax, [rbp+ptr]
0x0046555B | 48 89 C7 | mov     rdi, rax; ptr
0x0046555E | E8 FD 10 FA FF | call    _free
0x00465563 | 48 8D 75 E0 | lea     rsi, [rbp+var_20]
0x00465567 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0046556B | B9 53 DF 52 00 | mov     ecx, offset asc_52DF53; "# \t="
0x00465570 | BA 02 02 47 00 | mov     edx, offset loc_470202
0x00465575 | 48 89 C7 | mov     rdi, rax
0x00465578 | E8 1E D1 09 00 | call    sub_50269B
0x0046557D | 85 C0 | test    eax, eax
0x0046557F | 75 A0 | jnz     short loc_465521
0x00465581 | B8 00 00 00 00 | mov     eax, 0
0x00465586 | C9 | leave
0x00465587 | C3 | retn

 Ourput decompiled code:
static int sysctl_handle_preload_file(const char *filename)
{
	char *token[2];
	parser_t *parser;

	parser = config_open(filename);
	/* Must do it _after_ config_open(): */
	xchdir("/proc/sys");
	/* xchroot("/proc/sys") - if you are paranoid */

//TODO: ';' is comment char too
//TODO: comment may be only at line start. "var=1 #abc" - "1 #abc" is the value
// (but _whitespace_ from ends should be trimmed first (and we do it right))
//TODO: "var==1" is mishandled (must use "=1" as a value, but uses "1")
// can it be fixed by removing PARSE_COLLAPSE bit?
	while (config_read(parser, token, 2, 2, "# \t=", PARSE_NORMAL)) {
		char *tp;
		sysctl_dots_to_slashes(token[0]);
		tp = xasprintf("%s=%s", token[0], token[1]);
		sysctl_act_recursive(tp);
		free(tp);
	}
	if (ENABLE_FEATURE_CLEAN_UP)
		config_close(parser);
	return 0;
}

## Example:

 Input assembly code:
0x0044F857 | 55 | push    rbp
0x0044F858 | 48 89 E5 | mov     rbp, rsp
0x0044F85B | 48 83 EC 40 | sub     rsp, 40h
0x0044F85F | 48 89 7D C8 | mov     [rbp+var_38], rdi
0x0044F863 | 48 89 75 C0 | mov     [rbp+var_40], rsi
0x0044F867 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x0044F86B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0044F86E | 84 C0 | test    al, al
0x0044F870 | 74 15 | jz      short loc_44F887
0x0044F872 | 48 8B 55 C0 | mov     rdx, [rbp+var_40]
0x0044F876 | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x0044F87A | 48 89 D6 | mov     rsi, rdx
0x0044F87D | 48 89 C7 | mov     rdi, rax
0x0044F880 | E8 CD A1 FB FF | call    sub_409A52
0x0044F885 | EB 13 | jmp     short loc_44F89A
0x0044F887 | 48 8B 55 C8 | mov     rdx, [rbp+var_38]
0x0044F88B | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x0044F88F | 48 89 D6 | mov     rsi, rdx
0x0044F892 | 48 89 C7 | mov     rdi, rax
0x0044F895 | E8 B8 A1 FB FF | call    sub_409A52
0x0044F89A | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x0044F89E | 48 89 45 E0 | mov     [rbp+var_20], rax
0x0044F8A2 | BA 00 00 00 00 | mov     edx, 0
0x0044F8A7 | BE 02 00 00 00 | mov     esi, 2
0x0044F8AC | BF 02 00 00 00 | mov     edi, 2
0x0044F8B1 | E8 E3 B0 FB FF | call    sub_40A999
0x0044F8B6 | 89 45 FC | mov     [rbp+fd], eax
0x0044F8B9 | 48 8D 55 D0 | lea     rdx, [rbp+var_30]
0x0044F8BD | 8B 45 FC | mov     eax, [rbp+fd]
0x0044F8C0 | B9 29 C8 52 00 | mov     ecx, offset aSiocdeltunnel; "SIOCDELTUNNEL"
0x0044F8C5 | BE F2 89 00 00 | mov     esi, 89F2h
0x0044F8CA | 89 C7 | mov     edi, eax
0x0044F8CC | E8 80 B4 FB FF | call    sub_40AD51
0x0044F8D1 | 8B 45 FC | mov     eax, [rbp+fd]
0x0044F8D4 | 89 C7 | mov     edi, eax; fd
0x0044F8D6 | E8 35 75 FB FF | call    _close
0x0044F8DB | B8 00 00 00 00 | mov     eax, 0
0x0044F8E0 | C9 | leave
0x0044F8E1 | C3 | retn

 Ourput decompiled code:
static int do_del_ioctl(const char *basedev, struct ip_tunnel_parm *p)
{
	struct ifreq ifr;
	int fd;

	if (p->name[0]) {
		strncpy_IFNAMSIZ(ifr.ifr_name, p->name);
	} else {
		strncpy_IFNAMSIZ(ifr.ifr_name, basedev);
	}
	ifr.ifr_ifru.ifru_data = (void*)p;
	fd = xsocket(AF_INET, SOCK_DGRAM, 0);
	xioctl(fd, SIOCDELTUNNEL, &ifr);
	close(fd);
	return 0;
}

## Example:

 Input assembly code:
0x0043A44B | 55 | push    rbp
0x0043A44C | 48 89 E5 | mov     rbp, rsp
0x0043A44F | 48 83 EC 70 | sub     rsp, 70h
0x0043A453 | 48 89 7D 98 | mov     [rbp+var_68], rdi
0x0043A457 | 48 8D 45 A0 | lea     rax, [rbp+s]
0x0043A45B | BA 60 00 00 00 | mov     edx, 60h ; '`'; n
0x0043A460 | BE 00 00 00 00 | mov     esi, 0; c
0x0043A465 | 48 89 C7 | mov     rdi, rax; s
0x0043A468 | E8 E3 C8 FC FF | call    _memset
0x0043A46D | 48 8B 55 98 | mov     rdx, [rbp+var_68]
0x0043A471 | 48 8D 45 A0 | lea     rax, [rbp+s]
0x0043A475 | 48 89 D6 | mov     rsi, rdx
0x0043A478 | 48 89 C7 | mov     rdi, rax
0x0043A47B | E8 65 FD FF FF | call    sub_43A1E5
0x0043A480 | 85 C0 | test    eax, eax
0x0043A482 | 74 07 | jz      short loc_43A48B
0x0043A484 | B8 01 00 00 00 | mov     eax, 1
0x0043A489 | EB 28 | jmp     short locret_43A4B3
0x0043A48B | 8B 55 A4 | mov     edx, [rbp+var_5C]
0x0043A48E | 8B 45 A8 | mov     eax, [rbp+var_58]
0x0043A491 | 48 98 | cdqe
0x0043A493 | 48 8B 34 C5 20 9F 51 00 | mov     rsi, ds:off_519F20[rax*8]
0x0043A49B | 48 8D 45 A0 | lea     rax, [rbp+s]
0x0043A49F | 89 D1 | mov     ecx, edx
0x0043A4A1 | BA 8D A0 51 00 | mov     edx, offset aTcp_3; "tcp"
0x0043A4A6 | 48 89 C7 | mov     rdi, rax
0x0043A4A9 | E8 3C FE FF FF | call    sub_43A2EA
0x0043A4AE | B8 00 00 00 00 | mov     eax, 0
0x0043A4B3 | C9 | leave
0x0043A4B4 | C3 | retn

 Ourput decompiled code:
static int FAST_FUNC tcp_do_one(char *line)
{
	struct inet_params param;

	memset(&param, 0, sizeof(param));
	if (scan_inet_proc_line(&param, line))
		return 1;

	print_inet_line(&param, tcp_state[param.state], "tcp", param.rem_port);
	return 0;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004A4040 | 55 | push    rbp
0x004A4041 | 48 89 E5 | mov     rbp, rsp
0x004A4044 | 48 81 EC A0 00 00 00 | sub     rsp, 0A0h
0x004A404B | 48 89 BD 68 FF FF FF | mov     [rbp+var_98], rdi
0x004A4052 | 48 8B 85 68 FF FF FF | mov     rax, [rbp+var_98]
0x004A4059 | 48 89 C7 | mov     rdi, rax
0x004A405C | E8 BA 53 F6 FF | call    sub_40941B
0x004A4061 | 48 89 85 68 FF FF FF | mov     [rbp+var_98], rax
0x004A4068 | 48 8B 95 68 FF FF FF | mov     rdx, [rbp+var_98]
0x004A406F | 48 8D 85 70 FF FF FF | lea     rax, [rbp+s]
0x004A4076 | 48 89 D1 | mov     rcx, rdx
0x004A4079 | BA 58 09 53 00 | mov     edx, offset aSysClassRtcSDe; "/sys/class/rtc/%s/device/power/wakeup"
0x004A407E | BE 80 00 00 00 | mov     esi, 80h; maxlen
0x004A4083 | 48 89 C7 | mov     rdi, rax; s
0x004A4086 | B8 00 00 00 00 | mov     eax, 0
0x004A408B | E8 80 2B F6 FF | call    _snprintf
0x004A4090 | 48 8D 8D 70 FF FF FF | lea     rcx, [rbp+s]
0x004A4097 | 48 8D 85 70 FF FF FF | lea     rax, [rbp+s]
0x004A409E | BA 80 00 00 00 | mov     edx, 80h
0x004A40A3 | 48 89 CE | mov     rsi, rcx
0x004A40A6 | 48 89 C7 | mov     rdi, rax
0x004A40A9 | E8 53 74 F6 FF | call    sub_40B501
0x004A40AE | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004A40B2 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004A40B7 | 79 07 | jns     short loc_4A40C0
0x004A40B9 | B8 00 00 00 00 | mov     eax, 0
0x004A40BE | EB 1E | jmp     short locret_4A40DE
0x004A40C0 | 48 8D 85 70 FF FF FF | lea     rax, [rbp+s]
0x004A40C7 | BA 08 00 00 00 | mov     edx, 8; n
0x004A40CC | BE 7E 09 53 00 | mov     esi, offset aEnabled_0; "enabled\n"
0x004A40D1 | 48 89 C7 | mov     rdi, rax; s1
0x004A40D4 | E8 C7 26 F6 FF | call    _strncmp
0x004A40D9 | 85 C0 | test    eax, eax
0x004A40DB | 0F 94 C0 | setz    al
0x004A40DE | C9 | leave
0x004A40DF | C3 | retn
 ************ 
Source Code:
static NOINLINE bool may_wakeup(const char *rtcname)
{
	ssize_t ret;
	char buf[128];

	/* strip "/dev/" from the rtcname here */
	rtcname = skip_dev_pfx(rtcname);

	snprintf(buf, sizeof(buf), SYS_RTC_PATH, rtcname);
	ret = open_read_close(buf, buf, sizeof(buf));
	if (ret < 0)
		return false;

	/* wakeup events could be disabled or not supported */
	return strncmp(buf, "enabled
", 8) == 0;
}
 ************ 
Parsed Output:
static int sysctl_handle_power_wakeup(const char *filename)
{
    char s[128];
    int result;

    result = snprintf(s, sizeof(s), "/sys/class/rtc/%s/device/power/wakeup", filename);
    if (result < 0)
        return 0;

    if (strncmp(s, "enabled
", 8) == 0)
        return 1;
    else
        return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.8202369809150696
Func rank: 23

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: get_uptime
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0045BD75 | 55 | push    rbp
0x0045BD76 | 48 89 E5 | mov     rbp, rsp
0x0045BD79 | 48 83 EC 20 | sub     rsp, 20h
0x0045BD7D | BF FE D6 52 00 | mov     edi, offset aProcUptime; "/proc/uptime"
0x0045BD82 | E8 C6 DA FA FF | call    sub_40984D
0x0045BD87 | 48 89 45 F8 | mov     [rbp+stream], rax
0x0045BD8B | 48 8D 4D E8 | lea     rcx, [rbp+var_18]
0x0045BD8F | 48 8D 55 F0 | lea     rdx, [rbp+var_10]
0x0045BD93 | 48 8B 45 F8 | mov     rax, [rbp+stream]
0x0045BD97 | BE 0B D7 52 00 | mov     esi, offset aLuLu; "%lu.%lu"
0x0045BD9C | 48 89 C7 | mov     rdi, rax; stream
0x0045BD9F | B8 00 00 00 00 | mov     eax, 0
0x0045BDA4 | E8 C7 AF FA FF | call    _fscanf
0x0045BDA9 | 83 F8 02 | cmp     eax, 2
0x0045BDAC | 74 14 | jz      short loc_45BDC2
0x0045BDAE | BE FE D6 52 00 | mov     esi, offset aProcUptime; "/proc/uptime"
0x0045BDB3 | BF 13 D7 52 00 | mov     edi, offset aCanTReadS_0; "can't read '%s'"
0x0045BDB8 | B8 00 00 00 00 | mov     eax, 0
0x0045BDBD | E8 DC D8 FA FF | call    sub_40969E
0x0045BDC2 | 48 8B 45 F8 | mov     rax, [rbp+stream]
0x0045BDC6 | 48 89 C7 | mov     rdi, rax; stream
0x0045BDC9 | E8 32 AC FA FF | call    _fclose
0x0045BDCE | 48 8B 05 33 16 30 00 | mov     rax, cs:qword_75D408
0x0045BDD5 | 8B 40 08 | mov     eax, [rax+8]
0x0045BDD8 | 89 C2 | mov     edx, eax
0x0045BDDA | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0045BDDE | 48 89 D1 | mov     rcx, rdx
0x0045BDE1 | 48 0F AF C8 | imul    rcx, rax
0x0045BDE5 | 48 8B 05 1C 16 30 00 | mov     rax, cs:qword_75D408
0x0045BDEC | 8B 40 08 | mov     eax, [rax+8]
0x0045BDEF | 89 C2 | mov     edx, eax
0x0045BDF1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0045BDF5 | 48 0F AF C2 | imul    rax, rdx
0x0045BDF9 | 48 C1 E8 02 | shr     rax, 2
0x0045BDFD | 48 BA C3 F5 28 5C 8F C2 F5 28 | mov     rdx, 28F5C28F5C28F5C3h
0x0045BE07 | 48 F7 E2 | mul     rdx
0x0045BE0A | 48 89 D0 | mov     rax, rdx
0x0045BE0D | 48 C1 E8 02 | shr     rax, 2
0x0045BE11 | 48 01 C8 | add     rax, rcx
0x0045BE14 | C9 | leave
0x0045BE15 | C3 | retn

 Ourput decompiled code:
static cputime_t get_smp_uptime(void)
{
	FILE *fp;
	unsigned long sec, dec;

	fp = xfopen_for_read("/proc/uptime");

	if (fscanf(fp, "%lu.%lu", &sec, &dec) != 2)
		bb_error_msg_and_die("can't read '%s'", "/proc/uptime");

	fclose(fp);

	return (cputime_t)sec * G.clk_tck + dec * G.clk_tck / 100;
}

## Example:

 Input assembly code:
0x0045E442 | 55 | push    rbp
0x0045E443 | 48 89 E5 | mov     rbp, rsp
0x0045E446 | 48 81 EC 20 04 00 00 | sub     rsp, 420h
0x0045E44D | 48 89 BD E8 FB FF FF | mov     [rbp+var_418], rdi
0x0045E454 | BF 24 DA 52 00 | mov     edi, offset aProcStat_0; "/proc/stat"
0x0045E459 | E8 D0 B3 FA FF | call    sub_40982E
0x0045E45E | 48 89 45 F8 | mov     [rbp+stream], rax
0x0045E462 | 48 83 7D F8 00 | cmp     [rbp+stream], 0
0x0045E467 | 74 6E | jz      short loc_45E4D7
0x0045E469 | EB 41 | jmp     short loc_45E4AC
0x0045E46B | 48 8D 85 F0 FB FF FF | lea     rax, [rbp+s1]
0x0045E472 | BA 05 00 00 00 | mov     edx, 5; n
0x0045E477 | BE 69 DA 52 00 | mov     esi, offset aIntr; "intr "
0x0045E47C | 48 89 C7 | mov     rdi, rax; s1
0x0045E47F | E8 1C 83 FA FF | call    _strncmp
0x0045E484 | 85 C0 | test    eax, eax
0x0045E486 | 75 24 | jnz     short loc_45E4AC
0x0045E488 | 48 8B 95 E8 FB FF FF | mov     rdx, [rbp+var_418]
0x0045E48F | 48 8D 85 F0 FB FF FF | lea     rax, [rbp+s1]
0x0045E496 | 48 83 C0 05 | add     rax, 5
0x0045E49A | BE 6F DA 52 00 | mov     esi, offset aLlu_1; "%llu"
0x0045E49F | 48 89 C7 | mov     rdi, rax; s
0x0045E4A2 | B8 00 00 00 00 | mov     eax, 0
0x0045E4A7 | E8 C4 8F FA FF | call    _sscanf
0x0045E4AC | 48 8B 55 F8 | mov     rdx, [rbp+stream]; stream
0x0045E4B0 | 48 8D 85 F0 FB FF FF | lea     rax, [rbp+s1]
0x0045E4B7 | BE 00 04 00 00 | mov     esi, 400h; n
0x0045E4BC | 48 89 C7 | mov     rdi, rax; s
0x0045E4BF | E8 3C 8E FA FF | call    _fgets_unlocked
0x0045E4C4 | 48 85 C0 | test    rax, rax
0x0045E4C7 | 75 A2 | jnz     short loc_45E46B
0x0045E4C9 | 48 8B 45 F8 | mov     rax, [rbp+stream]
0x0045E4CD | 48 89 C7 | mov     rdi, rax; stream
0x0045E4D0 | E8 2B 85 FA FF | call    _fclose
0x0045E4D5 | EB 01 | jmp     short locret_45E4D8
0x0045E4D7 | 90 | nop
0x0045E4D8 | C9 | leave
0x0045E4D9 | C3 | retn

 Ourput decompiled code:
static void get_irqs_from_stat(struct stats_irq *irq)
{
	FILE *fp;
	char buf[1024];

	fp = fopen_for_read(PROCFS_STAT);
	if (!fp)
		return;

	while (fgets(buf, sizeof(buf), fp)) {
		//bb_error_msg("/proc/stat:'%s'", buf);
		if (strncmp(buf, "intr ", 5) == 0) {
			/* Read total number of IRQs since system boot */
			sscanf(buf + 5, "%"FMT_DATA"u", &irq->irq_nr);
		}
	}

	fclose(fp);
}

## Example:

 Input assembly code:
0x00502D6A | 55 | push    rbp
0x00502D6B | 48 89 E5 | mov     rbp, rsp
0x00502D6E | 48 81 EC C0 00 00 00 | sub     rsp, 0C0h
0x00502D75 | 48 89 BD 48 FF FF FF | mov     [rbp+file], rdi
0x00502D7C | 48 83 BD 48 FF FF FF 00 | cmp     [rbp+file], 0
0x00502D84 | 0F 84 C9 00 00 00 | jz      loc_502E53
0x00502D8A | 48 8B 85 48 FF FF FF | mov     rax, [rbp+file]
0x00502D91 | BA B6 01 00 00 | mov     edx, 1B6h
0x00502D96 | BE 41 02 00 00 | mov     esi, 241h; oflag
0x00502D9B | 48 89 C7 | mov     rdi, rax; file
0x00502D9E | B8 00 00 00 00 | mov     eax, 0
0x00502DA3 | E8 28 49 F0 FF | call    _open64
0x00502DA8 | 89 45 FC | mov     [rbp+fd], eax
0x00502DAB | 83 7D FC 00 | cmp     [rbp+fd], 0
0x00502DAF | 0F 88 A1 00 00 00 | js      loc_502E56
0x00502DB5 | 48 8D 95 50 FF FF FF | lea     rdx, [rbp+stat_buf]
0x00502DBC | 8B 45 FC | mov     eax, [rbp+fd]
0x00502DBF | 48 89 D6 | mov     rsi, rdx; stat_buf
0x00502DC2 | 89 C7 | mov     edi, eax; fildes
0x00502DC4 | E8 37 50 F0 FF | call    sub_407E00
0x00502DC9 | 85 C0 | test    eax, eax
0x00502DCB | 75 19 | jnz     short loc_502DE6
0x00502DCD | 8B 85 68 FF FF FF | mov     eax, [rbp+stat_buf.st_mode]
0x00502DD3 | 25 00 F0 00 00 | and     eax, 0F000h
0x00502DD8 | 3D 00 80 00 00 | cmp     eax, 8000h
0x00502DDD | 75 07 | jnz     short loc_502DE6
0x00502DDF | B8 01 00 00 00 | mov     eax, 1
0x00502DE4 | EB 05 | jmp     short loc_502DEB
0x00502DE6 | B8 00 00 00 00 | mov     eax, 0
0x00502DEB | 88 05 76 A6 25 00 | mov     cs:byte_75D467, al
0x00502DF1 | 0F B6 05 6F A6 25 00 | movzx   eax, cs:byte_75D467
0x00502DF8 | 84 C0 | test    al, al
0x00502DFA | 74 4B | jz      short loc_502E47
0x00502DFC | E8 7F 3B F0 FF | call    _getpid
0x00502E01 | 89 C1 | mov     ecx, eax
0x00502E03 | 48 8D 45 E2 | lea     rax, [rbp+var_1E]
0x00502E07 | BA 0E 00 00 00 | mov     edx, 0Eh
0x00502E0C | 48 89 C6 | mov     rsi, rax
0x00502E0F | 89 CF | mov     edi, ecx
0x00502E11 | E8 66 6C F0 FF | call    sub_409A7C
0x00502E16 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x00502E1A | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00502E1E | C6 00 0A | mov     byte ptr [rax], 0Ah
0x00502E21 | 48 8D 45 E2 | lea     rax, [rbp+var_1E]
0x00502E25 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x00502E29 | 48 29 C2 | sub     rdx, rax
0x00502E2C | 48 89 D0 | mov     rax, rdx
0x00502E2F | 48 83 C0 01 | add     rax, 1
0x00502E33 | 48 89 C2 | mov     rdx, rax
0x00502E36 | 48 8D 4D E2 | lea     rcx, [rbp+var_1E]
0x00502E3A | 8B 45 FC | mov     eax, [rbp+fd]
0x00502E3D | 48 89 CE | mov     rsi, rcx
0x00502E40 | 89 C7 | mov     edi, eax
0x00502E42 | E8 43 85 F0 FF | call    sub_40B38A
0x00502E47 | 8B 45 FC | mov     eax, [rbp+fd]
0x00502E4A | 89 C7 | mov     edi, eax; fd
0x00502E4C | E8 BF 3F F0 FF | call    _close
0x00502E51 | EB 04 | jmp     short locret_502E57
0x00502E53 | 90 | nop
0x00502E54 | EB 01 | jmp     short locret_502E57
0x00502E56 | 90 | nop
0x00502E57 | C9 | leave
0x00502E58 | C3 | retn

 Ourput decompiled code:
void FAST_FUNC write_pidfile(const char *path)
{
	int pid_fd;
	char *end;
	char buf[sizeof(int)*3 + 2];
	struct stat sb;

	if (!path)
		return;
	/* we will overwrite stale pidfile */
	pid_fd = open(path, O_WRONLY|O_CREAT|O_TRUNC, 0666);
	if (pid_fd < 0)
		return;

	/* path can be "/dev/null"! Test for such cases */
	wrote_pidfile = (fstat(pid_fd, &sb) == 0) && S_ISREG(sb.st_mode);

	if (wrote_pidfile) {
		/* few bytes larger, but doesn't use stdio */
		end = utoa_to_buf(getpid(), buf, sizeof(buf));
		*end = '\n';
		full_write(pid_fd, buf, end - buf + 1);
	}
	close(pid_fd);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0045E87C | 55 | push    rbp
0x0045E87D | 48 89 E5 | mov     rbp, rsp
0x0045E880 | 48 83 EC 60 | sub     rsp, 60h
0x0045E884 | 48 89 7D A8 | mov     [rbp+var_58], rdi
0x0045E888 | BF 78 DA 52 00 | mov     edi, offset aProcUptime_0; "/proc/uptime"
0x0045E88D | E8 9C AF FA FF | call    sub_40982E
0x0045E892 | 48 89 45 F8 | mov     [rbp+stream], rax
0x0045E896 | 48 83 7D F8 00 | cmp     [rbp+stream], 0
0x0045E89B | 0F 84 99 00 00 00 | jz      loc_45E93A
0x0045E8A1 | 48 8B 55 F8 | mov     rdx, [rbp+stream]; stream
0x0045E8A5 | 48 8D 45 C0 | lea     rax, [rbp+s]
0x0045E8A9 | BE 34 00 00 00 | mov     esi, 34h ; '4'; n
0x0045E8AE | 48 89 C7 | mov     rdi, rax; s
0x0045E8B1 | E8 4A 8A FA FF | call    _fgets_unlocked
0x0045E8B6 | 48 85 C0 | test    rax, rax
0x0045E8B9 | 74 71 | jz      short loc_45E92C
0x0045E8BB | 48 8D 4D B0 | lea     rcx, [rbp+var_50]
0x0045E8BF | 48 8D 55 B8 | lea     rdx, [rbp+var_48]
0x0045E8C3 | 48 8D 45 C0 | lea     rax, [rbp+s]
0x0045E8C7 | BE 85 DA 52 00 | mov     esi, offset aLuLu_0; "%lu.%lu"
0x0045E8CC | 48 89 C7 | mov     rdi, rax; s
0x0045E8CF | B8 00 00 00 00 | mov     eax, 0
0x0045E8D4 | E8 97 8B FA FF | call    _sscanf
0x0045E8D9 | 83 F8 02 | cmp     eax, 2
0x0045E8DC | 75 4E | jnz     short loc_45E92C
0x0045E8DE | 48 8B 05 23 EB 2F 00 | mov     rax, cs:qword_75D408
0x0045E8E5 | 8B 40 18 | mov     eax, [rax+18h]
0x0045E8E8 | 89 C2 | mov     edx, eax
0x0045E8EA | 48 8B 45 B8 | mov     rax, [rbp+var_48]
0x0045E8EE | 48 89 D1 | mov     rcx, rdx
0x0045E8F1 | 48 0F AF C8 | imul    rcx, rax
0x0045E8F5 | 48 8B 05 0C EB 2F 00 | mov     rax, cs:qword_75D408
0x0045E8FC | 8B 40 18 | mov     eax, [rax+18h]
0x0045E8FF | 89 C2 | mov     edx, eax
0x0045E901 | 48 8B 45 B0 | mov     rax, [rbp+var_50]
0x0045E905 | 48 0F AF C2 | imul    rax, rdx
0x0045E909 | 48 C1 E8 02 | shr     rax, 2
0x0045E90D | 48 BA C3 F5 28 5C 8F C2 F5 28 | mov     rdx, 28F5C28F5C28F5C3h
0x0045E917 | 48 F7 E2 | mul     rdx
0x0045E91A | 48 89 D0 | mov     rax, rdx
0x0045E91D | 48 C1 E8 02 | shr     rax, 2
0x0045E921 | 48 8D 14 01 | lea     rdx, [rcx+rax]
0x0045E925 | 48 8B 45 A8 | mov     rax, [rbp+var_58]
0x0045E929 | 48 89 10 | mov     [rax], rdx
0x0045E92C | 48 8B 45 F8 | mov     rax, [rbp+stream]
0x0045E930 | 48 89 C7 | mov     rdi, rax; stream
0x0045E933 | E8 C8 80 FA FF | call    _fclose
0x0045E938 | EB 01 | jmp     short locret_45E93B
0x0045E93A | 90 | nop
0x0045E93B | C9 | leave
0x0045E93C | C3 | retn
 ************ 
Source Code:
static void get_uptime(data_t *uptime)
{
	FILE *fp;
	char buf[sizeof(long)*3 * 2 + 4]; /* enough for long.long */
	unsigned long uptime_sec, decimal;

	fp = fopen_for_read(PROCFS_UPTIME);
	if (!fp)
		return;
	if (fgets(buf, sizeof(buf), fp)) {
		if (sscanf(buf, "%lu.%lu", &uptime_sec, &decimal) == 2) {
			*uptime = (data_t)uptime_sec * G.hz + decimal * G.hz / 100;
		}
	}

	fclose(fp);
}
 ************ 
Parsed Output:
static cputime_t get_uptime(void)
{
	FILE *fp;
	char s[52];
	unsigned long sec, dec;

	fp = xfopen_for_read("/proc/uptime");

	if (fgets_unlocked(s, 52, fp) == NULL)
		bb_error_msg_and_die("can't read '/proc/uptime'");

	fclose(fp);

	if (sscanf(s, "%lu.%lu", &sec, &dec) != 2)
		bb_error_msg_and_die("can't parse '%s'", s);

	return (cputime_t)(sec * G.clk_tck + dec * G.clk_tck / 100);
}
 ************ 
Similarity Score (Unixcoder): 0.8153845071792603
Func rank: 24

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: close_dev_fd
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004F4F3E | 55 | push    rbp
0x004F4F3F | 48 89 E5 | mov     rbp, rsp
0x004F4F42 | BE 00 00 00 00 | mov     esi, 0
0x004F4F47 | BF 0E 94 18 00 | mov     edi, 18940Eh
0x004F4F4C | E8 B0 32 01 00 | call    sub_508201
0x004F4F51 | BF 01 00 00 00 | mov     edi, 1
0x004F4F56 | E8 6E 32 01 00 | call    sub_5081C9
0x004F4F5B | 90 | nop
0x004F4F5C | 5D | pop     rbp
0x004F4F5D | C3 | retn

 Ourput decompiled code:
static void reset_sighandlers_and_unblock_sigs(void)
{
	bb_signals(0
		+ (1 << SIGUSR1)
		+ (1 << SIGUSR2)
		+ (1 << SIGTERM)
		+ (1 << SIGQUIT)
		+ (1 << SIGINT)
		+ (1 << SIGHUP)
		+ (1 << SIGTSTP)
		+ (1 << SIGSTOP)
		, SIG_DFL);
	sigprocmask_allsigs(SIG_UNBLOCK);
}

## Example:

 Input assembly code:
0x0041A18F | 55 | push    rbp
0x0041A190 | 48 89 E5 | mov     rbp, rsp
0x0041A193 | BA 00 00 00 00 | mov     edx, 0
0x0041A198 | BE 00 00 00 00 | mov     esi, 0
0x0041A19D | BF 03 00 00 00 | mov     edi, 3
0x0041A1A2 | E8 B0 03 FF FF | call    sub_40A557
0x0041A1A7 | 90 | nop
0x0041A1A8 | 5D | pop     rbp
0x0041A1A9 | C3 | retn

 Ourput decompiled code:
static void seek_to_zero(/*int fd*/ void)
{
	xlseek(fd, (off_t) 0, SEEK_SET);
}

## Example:

 Input assembly code:
0x0048C1FD | 55 | push    rbp
0x0048C1FE | 48 89 E5 | mov     rbp, rsp
0x0048C201 | BA 00 00 00 00 | mov     edx, 0; len
0x0048C206 | BE 00 00 00 00 | mov     esi, 0; bufp
0x0048C20B | BF 01 00 00 00 | mov     edi, 1; type
0x0048C210 | E8 FB B1 F7 FF | call    _klogctl
0x0048C215 | 90 | nop
0x0048C216 | 5D | pop     rbp
0x0048C217 | C3 | retn

 Ourput decompiled code:
static void klogd_open(void)
{
	/* "Open the log. Currently a NOP" */
	klogctl(1, NULL, 0);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00490398 | 55 | push    rbp
0x00490399 | 48 89 E5 | mov     rbp, rsp
0x0049039C | BE 00 00 00 00 | mov     esi, 0
0x004903A1 | BF C1 06 52 00 | mov     edi, offset aDevNull_2; "/dev/null"
0x004903A6 | E8 EA 9E F7 FF | call    sub_40A295
0x004903AB | BE 03 00 00 00 | mov     esi, 3
0x004903B0 | 89 C7 | mov     edi, eax
0x004903B2 | E8 C0 A0 F7 FF | call    sub_40A477
0x004903B7 | 90 | nop
0x004903B8 | 5D | pop     rbp
0x004903B9 | C3 | retn
 ************ 
Source Code:
static void
close_dev_fd(void)
{
	/* Not really closing, but making sure it is open, and to harmless place */
	xmove_fd(xopen(bb_dev_null, O_RDONLY), dev_fd);
}
 ************ 
Parsed Output:
static void open_dev_null(void)
{
    int fd = open("/dev/null", O_WRONLY);
    if (fd != -1) {
        dup2(fd, 3);
        close(fd);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.8142516016960144
Func rank: 25

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: builtin_help
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004A5902 | 55 | push    rbp
0x004A5903 | 48 89 E5 | mov     rbp, rsp
0x004A5906 | 48 83 EC 20 | sub     rsp, 20h
0x004A590A | 48 89 7D E8 | mov     [rbp+s1], rdi
0x004A590E | BF 01 00 00 00 | mov     edi, 1
0x004A5913 | E8 54 FE FF FF | call    sub_4A576C
0x004A5918 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004A591C | EB 47 | jmp     short loc_4A5965
0x004A591E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004A5922 | 48 8B 40 10 | mov     rax, [rax+10h]
0x004A5926 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004A5929 | 84 C0 | test    al, al
0x004A592B | 74 2D | jz      short loc_4A595A
0x004A592D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004A5931 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x004A5935 | 48 8B 45 E8 | mov     rax, [rbp+s1]
0x004A5939 | 48 89 D6 | mov     rsi, rdx; s2
0x004A593C | 48 89 C7 | mov     rdi, rax; s1
0x004A593F | E8 0C 17 F6 FF | call    _strcmp
0x004A5944 | 85 C0 | test    eax, eax
0x004A5946 | 75 12 | jnz     short loc_4A595A
0x004A5948 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004A594C | 48 8B 40 08 | mov     rax, [rax+8]
0x004A5950 | 48 89 C7 | mov     rdi, rax
0x004A5953 | E8 C7 47 F6 FF | call    sub_40A11F
0x004A5958 | EB 17 | jmp     short locret_4A5971
0x004A595A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004A595E | 48 8B 00 | mov     rax, [rax]
0x004A5961 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004A5965 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004A596A | 75 B2 | jnz     short loc_4A591E
0x004A596C | B8 00 00 00 00 | mov     eax, 0
0x004A5971 | C9 | leave
0x004A5972 | C3 | retn

 Ourput decompiled code:
char *get_devname_from_label(const char *spec)
{
	struct uuidCache_s *uc;

	uc = uuidcache_init(/*scan_devices:*/ 1);
	while (uc) {
		if (uc->label[0] && strcmp(spec, uc->label) == 0) {
			return xstrdup(uc->device);
		}
		uc = uc->next;
	}
	return NULL;
}

## Example:

 Input assembly code:
0x004A5973 | 55 | push    rbp
0x004A5974 | 48 89 E5 | mov     rbp, rsp
0x004A5977 | 48 83 EC 20 | sub     rsp, 20h
0x004A597B | 48 89 7D E8 | mov     [rbp+s1], rdi
0x004A597F | BF 01 00 00 00 | mov     edi, 1
0x004A5984 | E8 E3 FD FF FF | call    sub_4A576C
0x004A5989 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004A598D | EB 38 | jmp     short loc_4A59C7
0x004A598F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004A5993 | 48 8B 50 18 | mov     rdx, [rax+18h]
0x004A5997 | 48 8B 45 E8 | mov     rax, [rbp+s1]
0x004A599B | 48 89 D6 | mov     rsi, rdx; s2
0x004A599E | 48 89 C7 | mov     rdi, rax; s1
0x004A59A1 | E8 1A 0D F6 FF | call    _strcasecmp
0x004A59A6 | 85 C0 | test    eax, eax
0x004A59A8 | 75 12 | jnz     short loc_4A59BC
0x004A59AA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004A59AE | 48 8B 40 08 | mov     rax, [rax+8]
0x004A59B2 | 48 89 C7 | mov     rdi, rax
0x004A59B5 | E8 65 47 F6 FF | call    sub_40A11F
0x004A59BA | EB 17 | jmp     short locret_4A59D3
0x004A59BC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004A59C0 | 48 8B 00 | mov     rax, [rax]
0x004A59C3 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004A59C7 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004A59CC | 75 C1 | jnz     short loc_4A598F
0x004A59CE | B8 00 00 00 00 | mov     eax, 0
0x004A59D3 | C9 | leave
0x004A59D4 | C3 | retn

 Ourput decompiled code:
char *get_devname_from_uuid(const char *spec)
{
	struct uuidCache_s *uc;

	uc = uuidcache_init(/*scan_devices:*/ 1);
	while (uc) {
		/* case of hex numbers doesn't matter */
		if (strcasecmp(spec, uc->uc_uuid) == 0) {
			return xstrdup(uc->device);
		}
		uc = uc->next;
	}
	return NULL;
}

## Example:

 Input assembly code:
0x004E9DD5 | 55 | push    rbp
0x004E9DD6 | 48 89 E5 | mov     rbp, rsp
0x004E9DD9 | 48 83 EC 20 | sub     rsp, 20h
0x004E9DDD | 48 89 7D E8 | mov     [rbp+s2], rdi
0x004E9DE1 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004E9DE6 | 48 8B 80 88 00 00 00 | mov     rax, [rax+88h]
0x004E9DED | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004E9DF1 | EB 45 | jmp     short loc_4E9E38
0x004E9DF3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E9DF7 | 0F B6 40 46 | movzx   eax, byte ptr [rax+46h]
0x004E9DFB | 3C 3A | cmp     al, 3Ah ; ':'
0x004E9DFD | 75 2E | jnz     short loc_4E9E2D
0x004E9DFF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E9E03 | 48 8B 40 38 | mov     rax, [rax+38h]
0x004E9E07 | 48 85 C0 | test    rax, rax
0x004E9E0A | 74 21 | jz      short loc_4E9E2D
0x004E9E0C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E9E10 | 48 8B 40 38 | mov     rax, [rax+38h]
0x004E9E14 | 48 8B 55 E8 | mov     rdx, [rbp+s2]
0x004E9E18 | 48 89 D6 | mov     rsi, rdx; s2
0x004E9E1B | 48 89 C7 | mov     rdi, rax; s1
0x004E9E1E | E8 2D D2 F1 FF | call    _strcmp
0x004E9E23 | 85 C0 | test    eax, eax
0x004E9E25 | 75 06 | jnz     short loc_4E9E2D
0x004E9E27 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E9E2B | EB 28 | jmp     short locret_4E9E55
0x004E9E2D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E9E31 | 48 8B 00 | mov     rax, [rax]
0x004E9E34 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004E9E38 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004E9E3D | 75 B4 | jnz     short loc_4E9DF3
0x004E9E3F | 48 8B 45 E8 | mov     rax, [rbp+s2]
0x004E9E43 | 48 89 C6 | mov     rsi, rax
0x004E9E46 | BF 30 6F 52 00 | mov     edi, offset aCanTFindLabelF; "can't find label for jump to '%s'"
0x004E9E4B | B8 00 00 00 00 | mov     eax, 0
0x004E9E50 | E8 49 F8 F1 FF | call    sub_40969E
0x004E9E55 | C9 | leave
0x004E9E56 | C3 | retn

 Ourput decompiled code:
static sed_cmd_t *branch_to(char *label)
{
	sed_cmd_t *sed_cmd;

	for (sed_cmd = G.sed_cmd_head; sed_cmd; sed_cmd = sed_cmd->next) {
		if (sed_cmd->cmd == ':' && sed_cmd->string && !strcmp(sed_cmd->string, label)) {
			return sed_cmd;
		}
	}
	bb_error_msg_and_die("can't find label for jump to '%s'", label);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00489C62 | 55 | push    rbp
0x00489C63 | 48 89 E5 | mov     rbp, rsp
0x00489C66 | 48 83 EC 20 | sub     rsp, 20h
0x00489C6A | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00489C6E | BF 18 F0 51 00 | mov     edi, offset aBuiltInCommand; "Built-in commands:\n------------------"
0x00489C73 | E8 98 CB F7 FF | call    _puts
0x00489C78 | 48 C7 45 F8 80 E2 51 00 | mov     [rbp+var_8], offset off_51E280; "."
0x00489C80 | EB 33 | jmp     short loc_489CB5
0x00489C82 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00489C86 | 48 8B 40 10 | mov     rax, [rax+10h]
0x00489C8A | 48 85 C0 | test    rax, rax
0x00489C8D | 74 21 | jz      short loc_489CB0
0x00489C8F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00489C93 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x00489C97 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00489C9B | 48 8B 00 | mov     rax, [rax]
0x00489C9E | 48 89 C6 | mov     rsi, rax
0x00489CA1 | BF 3E F0 51 00 | mov     edi, offset a10sS_0; "%-10s%s\n"
0x00489CA6 | B8 00 00 00 00 | mov     eax, 0
0x00489CAB | E8 20 CF F7 FF | call    _printf
0x00489CB0 | 48 83 45 F8 18 | add     [rbp+var_8], 18h
0x00489CB5 | 48 81 7D F8 F0 E4 51 00 | cmp     [rbp+var_8], offset unk_51E4F0
0x00489CBD | 75 C3 | jnz     short loc_489C82
0x00489CBF | BF 0A 00 00 00 | mov     edi, 0Ah
0x00489CC4 | E8 90 09 F8 FF | call    sub_40A659
0x00489CC9 | B8 00 00 00 00 | mov     eax, 0
0x00489CCE | C9 | leave
0x00489CCF | C3 | retn
 ************ 
Source Code:
if ENABLE_HUSH_HELP
static int FAST_FUNC builtin_help(char **argv UNUSED_PARAM)
{
	const struct built_in_command *x;

	printf(
		"Built-in commands:
"
		"------------------
");
	for (x = bltins1; x != &bltins1[ARRAY_SIZE(bltins1)]; x++) {
		if (x->b_descr)
			printf("%-10s%s
", x->b_cmd, x->b_descr);
	}
	bb_putchar('
');
	return EXIT_SUCCESS;
}
 ************ 
Parsed Output:
char *print_builtin_commands()
{
    char *built_in_commands = "Built-in commands:
------------------";
    puts(built_in_commands);

    char *current_dir = ".";
    while (current_dir != NULL) {
        if (current_dir->next == NULL) {
            break;
        }
        printf("%-10s%s
", current_dir->name, current_dir->description);
        current_dir = current_dir->next;
    }

    return NULL;
}
 ************ 
Similarity Score (Unixcoder): 0.8092645406723022
Func rank: 26

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: time_sort
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0046568A | 55 | push    rbp
0x0046568B | 48 89 E5 | mov     rbp, rsp
0x0046568E | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00465692 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x00465696 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0046569A | 48 8B 10 | mov     rdx, [rax]
0x0046569D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004656A1 | 48 8B 00 | mov     rax, [rax]
0x004656A4 | 48 39 C2 | cmp     rdx, rax
0x004656A7 | 73 07 | jnb     short loc_4656B0
0x004656A9 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x004656AE | EB 17 | jmp     short loc_4656C7
0x004656B0 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004656B4 | 48 8B 10 | mov     rdx, [rax]
0x004656B7 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004656BB | 48 8B 00 | mov     rax, [rax]
0x004656BE | 48 39 C2 | cmp     rdx, rax
0x004656C1 | 0F 95 C0 | setnz   al
0x004656C4 | 0F B6 C0 | movzx   eax, al
0x004656C7 | 5D | pop     rbp
0x004656C8 | C3 | retn

 Ourput decompiled code:
endif

static int mem_sort(top_status_t *P, top_status_t *Q)
{
	/* We want to avoid unsigned->signed and truncation errors */
	if (Q->vsz < P->vsz) return -1;
	return Q->vsz != P->vsz; /* 0 if ==, 1 if > */
}

## Example:

 Input assembly code:
0x004BC120 | 55 | push    rbp
0x004BC121 | 48 89 E5 | mov     rbp, rsp
0x004BC124 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004BC128 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004BC12C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BC130 | 48 8B 50 28 | mov     rdx, [rax+28h]
0x004BC134 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BC138 | 48 8B 40 10 | mov     rax, [rax+10h]
0x004BC13C | 48 29 C2 | sub     rdx, rax
0x004BC13F | 48 89 D0 | mov     rax, rdx
0x004BC142 | 48 39 45 F0 | cmp     [rbp+var_10], rax
0x004BC146 | 72 12 | jb      short loc_4BC15A
0x004BC148 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BC14C | 48 8B 50 28 | mov     rdx, [rax+28h]
0x004BC150 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BC154 | 48 89 50 20 | mov     [rax+20h], rdx
0x004BC158 | EB 17 | jmp     short loc_4BC171
0x004BC15A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BC15E | 48 8B 50 10 | mov     rdx, [rax+10h]
0x004BC162 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BC166 | 48 01 C2 | add     rdx, rax
0x004BC169 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BC16D | 48 89 50 20 | mov     [rax+20h], rdx
0x004BC171 | 90 | nop
0x004BC172 | 5D | pop     rbp
0x004BC173 | C3 | retn

 Ourput decompiled code:
static void XZ_FUNC dict_limit(struct dictionary *dict, size_t out_max)
{
	if (dict->end - dict->pos <= out_max)
		dict->limit = dict->end;
	else
		dict->limit = dict->pos + out_max;
}

## Example:

 Input assembly code:
0x004BF520 | 55 | push    rbp
0x004BF521 | 48 89 E5 | mov     rbp, rsp
0x004BF524 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004BF528 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004BF52C | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BF530 | 48 8B 50 08 | mov     rdx, [rax+8]
0x004BF534 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BF538 | 48 8B 40 10 | mov     rax, [rax+10h]
0x004BF53C | 48 39 C2 | cmp     rdx, rax
0x004BF53F | 75 07 | jnz     short loc_4BF548
0x004BF541 | B8 00 00 00 00 | mov     eax, 0
0x004BF546 | EB 7E | jmp     short loc_4BF5C6
0x004BF548 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF54C | 8B 50 20 | mov     edx, [rax+20h]
0x004BF54F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF553 | 8B 40 04 | mov     eax, [rax+4]
0x004BF556 | 89 C1 | mov     ecx, eax
0x004BF558 | D3 EA | shr     edx, cl
0x004BF55A | 89 D0 | mov     eax, edx
0x004BF55C | 0F B6 F0 | movzx   esi, al
0x004BF55F | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BF563 | 48 8B 38 | mov     rdi, [rax]
0x004BF566 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BF56A | 48 8B 40 08 | mov     rax, [rax+8]
0x004BF56E | 48 8D 48 01 | lea     rcx, [rax+1]
0x004BF572 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x004BF576 | 48 89 4A 08 | mov     [rdx+8], rcx
0x004BF57A | 48 01 F8 | add     rax, rdi
0x004BF57D | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004BF580 | 0F B6 C0 | movzx   eax, al
0x004BF583 | 39 C6 | cmp     esi, eax
0x004BF585 | 74 07 | jz      short loc_4BF58E
0x004BF587 | B8 07 00 00 00 | mov     eax, 7
0x004BF58C | EB 38 | jmp     short loc_4BF5C6
0x004BF58E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF592 | 8B 40 04 | mov     eax, [rax+4]
0x004BF595 | 8D 50 08 | lea     edx, [rax+8]
0x004BF598 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF59C | 89 50 04 | mov     [rax+4], edx
0x004BF59F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF5A3 | 8B 40 04 | mov     eax, [rax+4]
0x004BF5A6 | 83 F8 1F | cmp     eax, 1Fh
0x004BF5A9 | 76 81 | jbe     short loc_4BF52C
0x004BF5AB | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF5AF | C7 40 20 00 00 00 00 | mov     dword ptr [rax+20h], 0
0x004BF5B6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF5BA | C7 40 04 00 00 00 00 | mov     dword ptr [rax+4], 0
0x004BF5C1 | B8 01 00 00 00 | mov     eax, 1
0x004BF5C6 | 5D | pop     rbp
0x004BF5C7 | C3 | retn

 Ourput decompiled code:
static enum xz_ret XZ_FUNC crc32_validate(struct xz_dec *s, struct xz_buf *b)
{
	do {
		if (b->in_pos == b->in_size)
			return XZ_OK;

		if (((s->crc32 >> s->pos) & 0xFF) != b->in[b->in_pos++])
			return XZ_DATA_ERROR;

		s->pos += 8;

	} while (s->pos < 32);

	s->crc32 = 0;
	s->pos = 0;

	return XZ_STREAM_END;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004656EB | 55 | push    rbp
0x004656EC | 48 89 E5 | mov     rbp, rsp
0x004656EF | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004656F3 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004656F7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004656FB | 48 8B 50 08 | mov     rdx, [rax+8]
0x004656FF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00465703 | 48 8B 40 08 | mov     rax, [rax+8]
0x00465707 | 48 39 C2 | cmp     rdx, rax
0x0046570A | 73 07 | jnb     short loc_465713
0x0046570C | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x00465711 | EB 19 | jmp     short loc_46572C
0x00465713 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00465717 | 48 8B 50 08 | mov     rdx, [rax+8]
0x0046571B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0046571F | 48 8B 40 08 | mov     rax, [rax+8]
0x00465723 | 48 39 C2 | cmp     rdx, rax
0x00465726 | 0F 95 C0 | setnz   al
0x00465729 | 0F B6 C0 | movzx   eax, al
0x0046572C | 5D | pop     rbp
0x0046572D | C3 | retn
 ************ 
Source Code:
static int time_sort(top_status_t *P, top_status_t *Q)
{
	/* We want to avoid unsigned->signed and truncation errors */
	if (Q->ticks < P->ticks) return -1;
	return Q->ticks != P->ticks; /* 0 if ==, 1 if > */
}
 ************ 
Parsed Output:
static int compare_values(top_status_t *P, top_status_t *Q)
{
    if (Q->value < P->value) return -1;
    return Q->value != P->value;
}
 ************ 
Similarity Score (Unixcoder): 0.8069922924041748
Func rank: 27

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: strncmpz
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004BB517 | 55 | push    rbp
0x004BB518 | 48 89 E5 | mov     rbp, rsp
0x004BB51B | 48 83 EC 30 | sub     rsp, 30h
0x004BB51F | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004BB523 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004BB527 | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x004BB52B | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x004BB52F | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004BB533 | 48 89 D6 | mov     rsi, rdx
0x004BB536 | 48 89 C7 | mov     rdi, rax
0x004BB539 | E8 02 FF FF FF | call    sub_4BB440
0x004BB53E | 89 45 FC | mov     [rbp+var_4], eax
0x004BB541 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004BB545 | 8B 00 | mov     eax, [rax]
0x004BB547 | 8D 14 00 | lea     edx, [rax+rax]
0x004BB54A | 8B 45 FC | mov     eax, [rbp+var_4]
0x004BB54D | 01 C2 | add     edx, eax
0x004BB54F | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004BB553 | 89 10 | mov     [rax], edx
0x004BB555 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004BB558 | C9 | leave
0x004BB559 | C3 | retn

 Ourput decompiled code:
static speed_inline int rc_get_bit(rc_t *rc, uint16_t *p, int *symbol)
{
	int ret = rc_is_bit_1(rc, p);
	*symbol = *symbol * 2 + ret;
	return ret;
}

## Example:

 Input assembly code:
0x0040A3CA | 55 | push    rbp
0x0040A3CB | 48 89 E5 | mov     rbp, rsp
0x0040A3CE | 48 83 EC 20 | sub     rsp, 20h
0x0040A3D2 | 48 89 7D E8 | mov     [rbp+old], rdi
0x0040A3D6 | 48 89 75 E0 | mov     [rbp+new], rsi
0x0040A3DA | 48 8B 55 E0 | mov     rdx, [rbp+new]
0x0040A3DE | 48 8B 45 E8 | mov     rax, [rbp+old]
0x0040A3E2 | 48 89 D6 | mov     rsi, rdx; new
0x0040A3E5 | 48 89 C7 | mov     rdi, rax; old
0x0040A3E8 | E8 A3 D4 FF FF | call    _rename
0x0040A3ED | 89 45 FC | mov     [rbp+var_4], eax
0x0040A3F0 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0040A3F4 | 74 1A | jz      short loc_40A410
0x0040A3F6 | 48 8B 55 E0 | mov     rdx, [rbp+new]
0x0040A3FA | 48 8B 45 E8 | mov     rax, [rbp+old]
0x0040A3FE | 48 89 C6 | mov     rsi, rax
0x0040A401 | BF 34 80 52 00 | mov     edi, offset aCanTMoveSToS; "can't move '%s' to '%s'"
0x0040A406 | B8 00 00 00 00 | mov     eax, 0
0x0040A40B | E8 C9 ED FF FF | call    sub_4091D9
0x0040A410 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0040A413 | C9 | leave
0x0040A414 | C3 | retn

 Ourput decompiled code:
int FAST_FUNC rename_or_warn(const char *oldpath, const char *newpath)
{
	int n = rename(oldpath, newpath);
	if (n)
		bb_perror_msg("can't move '%s' to '%s'", oldpath, newpath);
	return n;
}

## Example:

 Input assembly code:
0x00497671 | 55 | push    rbp
0x00497672 | 48 89 E5 | mov     rbp, rsp
0x00497675 | 48 83 EC 20 | sub     rsp, 20h
0x00497679 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0049767D | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00497681 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00497685 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00497689 | 48 89 D6 | mov     rsi, rdx
0x0049768C | 48 89 C7 | mov     rdi, rax
0x0049768F | E8 29 EC FF FF | call    sub_4962BD
0x00497694 | 89 45 FC | mov     [rbp+var_4], eax
0x00497697 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x0049769B | 8B 45 FC | mov     eax, [rbp+var_4]
0x0049769E | 48 89 D6 | mov     rsi, rdx
0x004976A1 | 89 C7 | mov     edi, eax
0x004976A3 | E8 65 FE FF FF | call    sub_49750D
0x004976A8 | 89 45 FC | mov     [rbp+var_4], eax
0x004976AB | 83 7D FC FF | cmp     [rbp+var_4], 0FFFFFFFFh
0x004976AF | 75 10 | jnz     short loc_4976C1
0x004976B1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004976B5 | 66 C7 00 00 00 | mov     word ptr [rax], 0
0x004976BA | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004976C1 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004976C4 | C9 | leave
0x004976C5 | C3 | retn

 Ourput decompiled code:
static int add_zone(uint16_t *znr, smallint *corrected)
{
	int block;

	block = check_zone_nr(znr, corrected);
	block = add_zone_common(block, corrected);
	if (block == -1) {
		*znr = 0;
		block = 0;
	}
	return block;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004317A8 | 55 | push    rbp
0x004317A9 | 48 89 E5 | mov     rbp, rsp
0x004317AC | 48 83 EC 30 | sub     rsp, 30h
0x004317B0 | 48 89 7D E8 | mov     [rbp+s1], rdi
0x004317B4 | 48 89 75 E0 | mov     [rbp+s2], rsi
0x004317B8 | 48 89 55 D8 | mov     [rbp+n], rdx
0x004317BC | 48 8B 55 D8 | mov     rdx, [rbp+n]; n
0x004317C0 | 48 8B 4D E0 | mov     rcx, [rbp+s2]
0x004317C4 | 48 8B 45 E8 | mov     rax, [rbp+s1]
0x004317C8 | 48 89 CE | mov     rsi, rcx; s2
0x004317CB | 48 89 C7 | mov     rdi, rax; s1
0x004317CE | E8 CD 4F FD FF | call    _strncmp
0x004317D3 | 89 45 FC | mov     [rbp+var_4], eax
0x004317D6 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004317DA | 75 15 | jnz     short loc_4317F1
0x004317DC | 48 8B 55 E0 | mov     rdx, [rbp+s2]
0x004317E0 | 48 8B 45 D8 | mov     rax, [rbp+n]
0x004317E4 | 48 01 D0 | add     rax, rdx
0x004317E7 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004317EA | 0F B6 C0 | movzx   eax, al
0x004317ED | F7 D8 | neg     eax
0x004317EF | EB 03 | jmp     short locret_4317F4
0x004317F1 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004317F4 | C9 | leave
0x004317F5 | C3 | retn
 ************ 
Source Code:
static int strncmpz(const char *l, const char *r, size_t llen)
{
	int i = strncmp(l, r, llen);

	if (i == 0)
		return - (unsigned char)r[llen];
	return i;
}
 ************ 
Parsed Output:
static int strncmp_custom(const char *s1, const char *s2, size_t n)
{
    int result = strncmp(s1, s2, n);
    if (result == 0) {
        const char *p1 = s1 + n;
        const char *p2 = s2 + n;
        result = (int)(*p1 - *p2);
        if (result == 0) {
            result = -1;
        }
    }
    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.8065520524978638
Func rank: 28

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: dot_right
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004ED9FB | 55 | push    rbp
0x004ED9FC | 48 89 E5 | mov     rbp, rsp
0x004ED9FF | 48 8B 05 02 FA 26 00 | mov     rax, cs:qword_75D408
0x004EDA06 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x004EDA0A | 48 8B 05 F7 F9 26 00 | mov     rax, cs:qword_75D408
0x004EDA11 | 48 8B 00 | mov     rax, [rax]
0x004EDA14 | 48 39 C2 | cmp     rdx, rax
0x004EDA17 | 76 29 | jbe     short loc_4EDA42
0x004EDA19 | 48 8B 05 E8 F9 26 00 | mov     rax, cs:qword_75D408
0x004EDA20 | 48 8B 40 10 | mov     rax, [rax+10h]
0x004EDA24 | 48 83 E8 01 | sub     rax, 1
0x004EDA28 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004EDA2B | 3C 0A | cmp     al, 0Ah
0x004EDA2D | 74 13 | jz      short loc_4EDA42
0x004EDA2F | 48 8B 05 D2 F9 26 00 | mov     rax, cs:qword_75D408
0x004EDA36 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x004EDA3A | 48 83 EA 01 | sub     rdx, 1
0x004EDA3E | 48 89 50 10 | mov     [rax+10h], rdx
0x004EDA42 | 90 | nop
0x004EDA43 | 5D | pop     rbp
0x004EDA44 | C3 | retn

 Ourput decompiled code:
static void dot_left(void)
{
	if (dot > text && dot[-1] != '\n')
		dot--;
}

## Example:

 Input assembly code:
0x00495FC0 | 55 | push    rbp
0x00495FC1 | 48 89 E5 | mov     rbp, rsp
0x00495FC4 | 48 8B 05 3D 74 2C 00 | mov     rax, cs:qword_75D408
0x00495FCB | 8B 50 58 | mov     edx, [rax+58h]
0x00495FCE | 83 EA 01 | sub     edx, 1
0x00495FD1 | 89 50 58 | mov     [rax+58h], edx
0x00495FD4 | 48 8B 05 2D 74 2C 00 | mov     rax, cs:qword_75D408
0x00495FDB | 8B 40 58 | mov     eax, [rax+58h]
0x00495FDE | 83 F8 1F | cmp     eax, 1Fh
0x00495FE1 | 7F 49 | jg      short loc_49602C
0x00495FE3 | 48 8B 05 1E 74 2C 00 | mov     rax, cs:qword_75D408
0x00495FEA | 48 8B 15 17 74 2C 00 | mov     rdx, cs:qword_75D408
0x00495FF1 | 8B 52 58 | mov     edx, [rdx+58h]
0x00495FF4 | 48 63 D2 | movsxd  rdx, edx
0x00495FF7 | 48 83 C2 0C | add     rdx, 0Ch
0x00495FFB | 48 8B 04 D0 | mov     rax, [rax+rdx*8]
0x00495FFF | C6 00 00 | mov     byte ptr [rax], 0
0x00496002 | 48 8B 05 FF 73 2C 00 | mov     rax, cs:qword_75D408
0x00496009 | 8B 40 58 | mov     eax, [rax+58h]
0x0049600C | 85 C0 | test    eax, eax
0x0049600E | 75 1C | jnz     short loc_49602C
0x00496010 | 48 8B 05 F1 73 2C 00 | mov     rax, cs:qword_75D408
0x00496017 | C6 80 A4 15 00 00 2F | mov     byte ptr [rax+15A4h], 2Fh ; '/'
0x0049601E | 48 8B 05 E3 73 2C 00 | mov     rax, cs:qword_75D408
0x00496025 | C6 80 A5 15 00 00 00 | mov     byte ptr [rax+15A5h], 0
0x0049602C | 90 | nop
0x0049602D | 5D | pop     rbp
0x0049602E | C3 | retn

 Ourput decompiled code:
static void pop_filename(void)
{
	name_depth--;
	if (name_depth < MAX_DEPTH) {
		*name_component[name_depth] = '\0';
		if (!name_depth) {
			current_name[0] = '/';
			current_name[1] = '\0';
		}
	}
}

## Example:

 Input assembly code:
0x004EDCAC | 55 | push    rbp
0x004EDCAD | 48 89 E5 | mov     rbp, rsp
0x004EDCB0 | EB 13 | jmp     short loc_4EDCC5
0x004EDCB2 | 48 8B 05 4F F7 26 00 | mov     rax, cs:qword_75D408
0x004EDCB9 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x004EDCBD | 48 83 C2 01 | add     rdx, 1
0x004EDCC1 | 48 89 50 10 | mov     [rax+10h], rdx
0x004EDCC5 | 48 8B 05 3C F7 26 00 | mov     rax, cs:qword_75D408
0x004EDCCC | 48 8B 40 10 | mov     rax, [rax+10h]
0x004EDCD0 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004EDCD3 | 83 E8 09 | sub     eax, 9
0x004EDCD6 | 88 45 FF | mov     [rbp+var_1], al
0x004EDCD9 | 80 7D FF 17 | cmp     [rbp+var_1], 17h
0x004EDCDD | 74 06 | jz      short loc_4EDCE5
0x004EDCDF | 80 7D FF 04 | cmp     [rbp+var_1], 4
0x004EDCE3 | 77 07 | ja      short loc_4EDCEC
0x004EDCE5 | B8 01 00 00 00 | mov     eax, 1
0x004EDCEA | EB 05 | jmp     short loc_4EDCF1
0x004EDCEC | B8 00 00 00 00 | mov     eax, 0
0x004EDCF1 | 85 C0 | test    eax, eax
0x004EDCF3 | 74 31 | jz      short loc_4EDD26
0x004EDCF5 | 48 8B 05 0C F7 26 00 | mov     rax, cs:qword_75D408
0x004EDCFC | 48 8B 40 10 | mov     rax, [rax+10h]
0x004EDD00 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004EDD03 | 3C 0A | cmp     al, 0Ah
0x004EDD05 | 74 1F | jz      short loc_4EDD26
0x004EDD07 | 48 8B 05 FA F6 26 00 | mov     rax, cs:qword_75D408
0x004EDD0E | 48 8B 50 10 | mov     rdx, [rax+10h]
0x004EDD12 | 48 8B 05 EF F6 26 00 | mov     rax, cs:qword_75D408
0x004EDD19 | 48 8B 40 08 | mov     rax, [rax+8]
0x004EDD1D | 48 83 E8 01 | sub     rax, 1
0x004EDD21 | 48 39 C2 | cmp     rdx, rax
0x004EDD24 | 72 8C | jb      short loc_4EDCB2
0x004EDD26 | 90 | nop
0x004EDD27 | 5D | pop     rbp
0x004EDD28 | C3 | retn

 Ourput decompiled code:
static void dot_skip_over_ws(void)
{
	// skip WS
	while (isspace(*dot) && *dot != '\n' && dot < end - 1)
		dot++;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004EDA45 | 55 | push    rbp
0x004EDA46 | 48 89 E5 | mov     rbp, rsp
0x004EDA49 | 48 8B 05 B8 F9 26 00 | mov     rax, cs:qword_75D408
0x004EDA50 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x004EDA54 | 48 8B 05 AD F9 26 00 | mov     rax, cs:qword_75D408
0x004EDA5B | 48 8B 40 08 | mov     rax, [rax+8]
0x004EDA5F | 48 83 E8 01 | sub     rax, 1
0x004EDA63 | 48 39 C2 | cmp     rdx, rax
0x004EDA66 | 73 25 | jnb     short loc_4EDA8D
0x004EDA68 | 48 8B 05 99 F9 26 00 | mov     rax, cs:qword_75D408
0x004EDA6F | 48 8B 40 10 | mov     rax, [rax+10h]
0x004EDA73 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004EDA76 | 3C 0A | cmp     al, 0Ah
0x004EDA78 | 74 13 | jz      short loc_4EDA8D
0x004EDA7A | 48 8B 05 87 F9 26 00 | mov     rax, cs:qword_75D408
0x004EDA81 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x004EDA85 | 48 83 C2 01 | add     rdx, 1
0x004EDA89 | 48 89 50 10 | mov     [rax+10h], rdx
0x004EDA8D | 90 | nop
0x004EDA8E | 5D | pop     rbp
0x004EDA8F | C3 | retn
 ************ 
Source Code:
static void dot_right(void)
{
	if (dot < end - 1 && *dot != '
')
		dot++;
}
 ************ 
Parsed Output:
static void dot_skip_over_ws(void)
{
    while (isspace(*dot) && *dot != '
' && dot < end - 1)
    {
        dot++;
    }
}
 ************ 
Similarity Score (Unixcoder): 0.8057628870010376
Func rank: 29

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: change_identity
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00414F2F | 55 | push    rbp
0x00414F30 | 48 89 E5 | mov     rbp, rsp
0x00414F33 | 48 83 EC 10 | sub     rsp, 10h
0x00414F37 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00414F3B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00414F3F | 48 89 C7 | mov     rdi, rax
0x00414F42 | E8 22 16 0E 00 | call    sub_4F6569
0x00414F47 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00414F4B | 48 8B 40 20 | mov     rax, [rax+20h]
0x00414F4F | 48 89 C7 | mov     rdi, rax; path
0x00414F52 | E8 99 1B FF FF | call    _chdir
0x00414F57 | 85 C0 | test    eax, eax
0x00414F59 | 79 3C | jns     short loc_414F97
0x00414F5B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00414F5F | 48 8B 40 20 | mov     rax, [rax+20h]
0x00414F63 | 48 89 C6 | mov     rsi, rax
0x00414F66 | BF 37 8D 52 00 | mov     edi, offset aIchdirS; "Ichdir(%s)"
0x00414F6B | B8 00 00 00 00 | mov     eax, 0
0x00414F70 | E8 02 F4 FF FF | call    sub_414377
0x00414F75 | BF 42 8D 52 00 | mov     edi, offset path; "/var/spool/cron"
0x00414F7A | E8 71 1B FF FF | call    _chdir
0x00414F7F | 85 C0 | test    eax, eax
0x00414F81 | 79 14 | jns     short loc_414F97
0x00414F83 | BE 42 8D 52 00 | mov     esi, offset path; "/var/spool/cron"
0x00414F88 | BF 20 8D 52 00 | mov     edi, offset byte_528D20
0x00414F8D | B8 00 00 00 00 | mov     eax, 0
0x00414F92 | E8 E0 F3 FF FF | call    sub_414377
0x00414F97 | 90 | nop
0x00414F98 | C9 | leave
0x00414F99 | C3 | retn

 Ourput decompiled code:
static void change_user(struct passwd *pas)
{
	/* careful: we're after vfork! */
	change_identity(pas); /* - initgroups, setgid, setuid */
	if (chdir(pas->pw_dir) < 0) {
		crondlog(WARN9 "chdir(%s)", pas->pw_dir);
		if (chdir(TMPDIR) < 0) {
			crondlog(DIE9 "chdir(%s)", TMPDIR); /* exits */
		}
	}
}

## Example:

 Input assembly code:
0x004B748C | 55 | push    rbp
0x004B748D | 48 89 E5 | mov     rbp, rsp
0x004B7490 | 48 83 EC 10 | sub     rsp, 10h
0x004B7494 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004B7498 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004B749C | 48 8B 40 28 | mov     rax, [rax+28h]
0x004B74A0 | 48 8B 50 20 | mov     rdx, [rax+20h]
0x004B74A4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004B74A8 | 8B 40 04 | mov     eax, [rax+4]
0x004B74AB | BE 01 00 00 00 | mov     esi, 1
0x004B74B0 | 89 C7 | mov     edi, eax
0x004B74B2 | E8 52 3E F5 FF | call    sub_40B309
0x004B74B7 | 90 | nop
0x004B74B8 | C9 | leave
0x004B74B9 | C3 | retn

 Ourput decompiled code:
void FAST_FUNC data_extract_to_stdout(archive_handle_t *archive_handle)
{
	bb_copyfd_exact_size(archive_handle->src_fd,
			STDOUT_FILENO,
			archive_handle->file_header->size);
}

## Example:

 Input assembly code:
0x00455CC5 | 55 | push    rbp
0x00455CC6 | 48 89 E5 | mov     rbp, rsp
0x00455CC9 | 48 83 EC 10 | sub     rsp, 10h
0x00455CCD | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00455CD1 | 8B 05 89 77 30 00 | mov     eax, cs:dword_75D460
0x00455CD7 | 85 C0 | test    eax, eax
0x00455CD9 | 74 0F | jz      short loc_455CEA
0x00455CDB | BF 83 CE 52 00 | mov     edi, offset aForwardingPack; "Forwarding packet to relay"
0x00455CE0 | B8 00 00 00 00 | mov     eax, 0
0x00455CE5 | E8 D2 7D 0A 00 | call    sub_4FDABC
0x00455CEA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00455CEE | 8B 50 18 | mov     edx, [rax+18h]
0x00455CF1 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00455CF6 | 8B 70 0C | mov     esi, [rax+0Ch]
0x00455CF9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00455CFD | 41 B8 43 00 00 00 | mov     r8d, 43h ; 'C'
0x00455D03 | 89 D1 | mov     ecx, edx
0x00455D05 | BA 43 00 00 00 | mov     edx, 43h ; 'C'
0x00455D0A | 48 89 C7 | mov     rdi, rax
0x00455D0D | E8 F5 2F 00 00 | call    sub_458D07
0x00455D12 | 90 | nop
0x00455D13 | C9 | leave
0x00455D14 | C3 | retn

 Ourput decompiled code:
static void send_packet_to_relay(struct dhcp_packet *dhcp_pkt)
{
	log1("Forwarding packet to relay");

	udhcp_send_kernel_packet(dhcp_pkt,
			server_config.server_nip, SERVER_PORT,
			dhcp_pkt->gateway_nip, SERVER_PORT);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004F6569 | 55 | push    rbp
0x004F656A | 48 89 E5 | mov     rbp, rsp
0x004F656D | 48 83 EC 10 | sub     rsp, 10h
0x004F6571 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004F6575 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F6579 | 8B 50 14 | mov     edx, [rax+14h]
0x004F657C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F6580 | 48 8B 00 | mov     rax, [rax]
0x004F6583 | 89 D6 | mov     esi, edx
0x004F6585 | 48 89 C7 | mov     rdi, rax
0x004F6588 | E8 5F 63 F1 FF | call    sub_40C8EC
0x004F658D | 83 F8 FF | cmp     eax, 0FFFFFFFFh
0x004F6590 | 75 0F | jnz     short loc_4F65A1
0x004F6592 | BF 1F 72 53 00 | mov     edi, offset aCanTSetGroups; "can't set groups"
0x004F6597 | B8 00 00 00 00 | mov     eax, 0
0x004F659C | E8 01 2D F1 FF | call    sub_4092A2
0x004F65A1 | E8 42 61 F1 FF | call    sub_40C6E8
0x004F65A6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F65AA | 8B 40 14 | mov     eax, [rax+14h]
0x004F65AD | 89 C7 | mov     edi, eax
0x004F65AF | E8 9D 42 F1 FF | call    sub_40A851
0x004F65B4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F65B8 | 8B 40 10 | mov     eax, [rax+10h]
0x004F65BB | 89 C7 | mov     edi, eax
0x004F65BD | E8 BA 42 F1 FF | call    sub_40A87C
0x004F65C2 | 90 | nop
0x004F65C3 | C9 | leave
0x004F65C4 | C3 | retn
 ************ 
Source Code:
void FAST_FUNC change_identity(const struct passwd *pw)
{
	if (initgroups(pw->pw_name, pw->pw_gid) == -1)
		bb_perror_msg_and_die("can't set groups");
	endgrent(); /* helps to close a fd used internally by libc */
	xsetgid(pw->pw_gid);
	xsetuid(pw->pw_uid);
}
 ************ 
Parsed Output:
static void set_groups(struct passwd *pas)
{
    gid_t groups[NGROUPS_MAX];
    int num_groups = getgroups(0, NULL);
    if (num_groups < 0) {
        bb_perror_msg_and_die("can't get groups");
    }
    if (num_groups > NGROUPS_MAX) {
        num_groups = NGROUPS_MAX;
    }
    if (getgroups(num_groups, groups) < 0) {
        bb_perror_msg_and_die("can't get groups");
    }
    if (setgroups(num_groups, groups) < 0) {
        bb_perror_msg_and_die("can't set groups");
    }
}
 ************ 
Similarity Score (Unixcoder): 0.7958858013153076
Func rank: 30

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: do_linemode
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00442153 | 55 | push    rbp
0x00442154 | 48 89 E5 | mov     rbp, rsp
0x00442157 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0044215C | C6 40 06 00 | mov     byte ptr [rax+6], 0
0x00442160 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00442165 | 0F B6 50 07 | movzx   edx, byte ptr [rax+7]
0x00442169 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0044216E | 83 CA 03 | or      edx, 3
0x00442171 | 88 50 07 | mov     [rax+7], dl
0x00442174 | E8 56 FF FF FF | call    sub_4420CF
0x00442179 | BE 01 00 00 00 | mov     esi, 1
0x0044217E | BF FD 00 00 00 | mov     edi, 0FDh
0x00442183 | E8 DF FC FF FF | call    sub_441E67
0x00442188 | BE 03 00 00 00 | mov     esi, 3
0x0044218D | BF FD 00 00 00 | mov     edi, 0FDh
0x00442192 | E8 D0 FC FF FF | call    sub_441E67
0x00442197 | E8 8F F8 FF FF | call    sub_441A2B
0x0044219C | 90 | nop
0x0044219D | 5D | pop     rbp
0x0044219E | C3 | retn

 Ourput decompiled code:
static void will_charmode(void)
{
	G.charmode = CHM_TRY;
	G.telflags |= (UF_ECHO | UF_SGA);
	setConMode();

	put_iac2(DO, TELOPT_ECHO);
	put_iac2(DO, TELOPT_SGA);
	iac_flush();
}

## Example:

 Input assembly code:
0x004420CF | 55 | push    rbp
0x004420D0 | 48 89 E5 | mov     rbp, rsp
0x004420D3 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004420D8 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]
0x004420DC | 0F B6 C0 | movzx   eax, al
0x004420DF | 83 E0 01 | and     eax, 1
0x004420E2 | 85 C0 | test    eax, eax
0x004420E4 | 74 36 | jz      short loc_44211C
0x004420E6 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004420EB | 0F B6 40 06 | movzx   eax, byte ptr [rax+6]
0x004420EF | 84 C0 | test    al, al
0x004420F1 | 75 5D | jnz     short loc_442150
0x004420F3 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004420F8 | C6 40 06 01 | mov     byte ptr [rax+6], 1
0x004420FC | BA 5D 00 00 00 | mov     edx, 5Dh ; ']'
0x00442101 | BE 9D BC 52 00 | mov     esi, offset aCharacter; "character"
0x00442106 | BF A8 BC 52 00 | mov     edi, offset aEnteringSModeE; "\r\nEntering %s mode\r\nEscape characte"...
0x0044210B | B8 00 00 00 00 | mov     eax, 0
0x00442110 | E8 BB 4A FC FF | call    _printf
0x00442115 | E8 07 04 00 00 | call    sub_442521
0x0044211A | EB 34 | jmp     short loc_442150
0x0044211C | B8 F8 B3 75 00 | mov     eax, offset dest
0x00442121 | 0F B6 40 06 | movzx   eax, byte ptr [rax+6]
0x00442125 | 3C 02 | cmp     al, 2
0x00442127 | 74 27 | jz      short loc_442150
0x00442129 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0044212E | C6 40 06 02 | mov     byte ptr [rax+6], 2
0x00442132 | BA 43 00 00 00 | mov     edx, 43h ; 'C'
0x00442137 | BE D9 BC 52 00 | mov     esi, offset aLine; "line"
0x0044213C | BF A8 BC 52 00 | mov     edi, offset aEnteringSModeE; "\r\nEntering %s mode\r\nEscape characte"...
0x00442141 | B8 00 00 00 00 | mov     eax, 0
0x00442146 | E8 85 4A FC FF | call    _printf
0x0044214B | E8 FC 03 00 00 | call    sub_44254C
0x00442150 | 90 | nop
0x00442151 | 5D | pop     rbp
0x00442152 | C3 | retn

 Ourput decompiled code:
endif

static void setConMode(void)
{
	if (G.telflags & UF_ECHO) {
		if (G.charmode == CHM_TRY) {
			G.charmode = CHM_ON;
			printf("\r\nEntering %s mode"
				"\r\nEscape character is '^%c'.\r\n", "character", ']');
			rawmode();
		}
	} else {
		if (G.charmode != CHM_OFF) {
			G.charmode = CHM_OFF;
			printf("\r\nEntering %s mode"
				"\r\nEscape character is '^%c'.\r\n", "line", 'C');
			cookmode();
		}
	}
}

## Example:

 Input assembly code:
0x00440DC1 | 55 | push    rbp
0x00440DC2 | 48 89 E5 | mov     rbp, rsp
0x00440DC5 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00440DCA | 8B 40 10 | mov     eax, [rax+10h]
0x00440DCD | 83 F8 01 | cmp     eax, 1
0x00440DD0 | 76 21 | jbe     short loc_440DF3
0x00440DD2 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00440DD7 | 8B 50 10 | mov     edx, [rax+10h]
0x00440DDA | B8 F8 B3 75 00 | mov     eax, offset dest
0x00440DDF | 8B 40 0C | mov     eax, [rax+0Ch]
0x00440DE2 | 89 C6 | mov     esi, eax
0x00440DE4 | BF 84 BA 52 00 | mov     edi, offset aStatusUU; "status %u/%u"
0x00440DE9 | B8 00 00 00 00 | mov     eax, 0
0x00440DEE | E8 54 89 FC FF | call    sub_409747
0x00440DF3 | 90 | nop
0x00440DF4 | 5D | pop     rbp
0x00440DF5 | C3 | retn

 Ourput decompiled code:
static void connection_status(void)
{
	/* "only 1 client max" desn't need this */
	if (cmax > 1)
		bb_error_msg("status %u/%u", cnum, cmax);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0044219F | 55 | push    rbp
0x004421A0 | 48 89 E5 | mov     rbp, rsp
0x004421A3 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004421A8 | C6 40 06 00 | mov     byte ptr [rax+6], 0
0x004421AC | B8 F8 B3 75 00 | mov     eax, offset dest
0x004421B1 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]
0x004421B5 | BA F8 B3 75 00 | mov     edx, offset dest
0x004421BA | 83 E0 FC | and     eax, 0FFFFFFFCh
0x004421BD | 88 42 07 | mov     [rdx+7], al
0x004421C0 | E8 0A FF FF FF | call    sub_4420CF
0x004421C5 | BE 01 00 00 00 | mov     esi, 1
0x004421CA | BF FE 00 00 00 | mov     edi, 0FEh
0x004421CF | E8 93 FC FF FF | call    sub_441E67
0x004421D4 | BE 03 00 00 00 | mov     esi, 3
0x004421D9 | BF FE 00 00 00 | mov     edi, 0FEh
0x004421DE | E8 84 FC FF FF | call    sub_441E67
0x004421E3 | E8 43 F8 FF FF | call    sub_441A2B
0x004421E8 | 90 | nop
0x004421E9 | 5D | pop     rbp
0x004421EA | C3 | retn
 ************ 
Source Code:
static void do_linemode(void)
{
	G.charmode = CHM_TRY;
	G.telflags &= ~(UF_ECHO | UF_SGA);
	setConMode();

	put_iac2(DONT, TELOPT_ECHO);
	put_iac2(DONT, TELOPT_SGA);
	iac_flush();
}
 ************ 
Parsed Output:
static void set_dest(void)
{
    dest[6] = 0;
    dest[7] &= 0xFC;
    setConMode();

    put_iac2(DO, TELOPT_ECHO);
    put_iac2(DO, TELOPT_SGA);
    iac_flush();
}
 ************ 
Similarity Score (Unixcoder): 0.7945846915245056
Func rank: 31

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: getpwd
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0045F8E2 | 55 | push    rbp
0x0045F8E3 | 48 89 E5 | mov     rbp, rsp
0x0045F8E6 | 48 83 EC 10 | sub     rsp, 10h
0x0045F8EA | 48 89 7D F8 | mov     [rbp+s], rdi
0x0045F8EE | 48 8B 45 F8 | mov     rax, [rbp+s]
0x0045F8F2 | BE 2F 00 00 00 | mov     esi, 2Fh ; '/'; c
0x0045F8F7 | 48 89 C7 | mov     rdi, rax; s
0x0045F8FA | E8 C1 72 FA FF | call    _strchr
0x0045F8FF | 48 89 45 F8 | mov     [rbp+s], rax
0x0045F903 | 48 83 7D F8 00 | cmp     [rbp+s], 0
0x0045F908 | 75 07 | jnz     short loc_45F911
0x0045F90A | B8 00 00 00 00 | mov     eax, 0
0x0045F90F | EB 1A | jmp     short locret_45F92B
0x0045F911 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x0045F915 | 48 83 C0 01 | add     rax, 1
0x0045F919 | BA 0A 00 00 00 | mov     edx, 0Ah; base
0x0045F91E | BE 00 00 00 00 | mov     esi, 0; endptr
0x0045F923 | 48 89 C7 | mov     rdi, rax; nptr
0x0045F926 | E8 B5 76 FA FF | call    _strtoull
0x0045F92B | C9 | leave
0x0045F92C | C3 | retn

 Ourput decompiled code:
static ullong read_after_slash(const char *p)
{
	p = strchr(p, '/');
	if (!p) return 0;
	return strtoull(p+1, NULL, 10);
}

## Example:

 Input assembly code:
0x00490C41 | 55 | push    rbp
0x00490C42 | 48 89 E5 | mov     rbp, rsp
0x00490C45 | 48 83 EC 10 | sub     rsp, 10h
0x00490C49 | 48 89 7D F8 | mov     [rbp+s], rdi
0x00490C4D | 48 83 7D F8 00 | cmp     [rbp+s], 0
0x00490C52 | 74 16 | jz      short loc_490C6A
0x00490C54 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x00490C58 | BA 10 00 00 00 | mov     edx, 10h; n
0x00490C5D | BE 00 00 00 00 | mov     esi, 0; c
0x00490C62 | 48 89 C7 | mov     rdi, rax; s
0x00490C65 | E8 E6 60 F7 FF | call    _memset
0x00490C6A | 90 | nop
0x00490C6B | C9 | leave
0x00490C6C | C3 | retn

 Ourput decompiled code:
static void
clear_partition(struct partition *p)
{
	if (p)
		memset(p, 0, sizeof(*p));
}

## Example:

 Input assembly code:
0x0040A020 | 55 | push    rbp
0x0040A021 | 48 89 E5 | mov     rbp, rsp
0x0040A024 | 48 83 EC 20 | sub     rsp, 20h
0x0040A028 | 48 89 7D E8 | mov     [rbp+size], rdi
0x0040A02C | 48 8B 45 E8 | mov     rax, [rbp+size]
0x0040A030 | 48 89 C7 | mov     rdi, rax; size
0x0040A033 | E8 28 D3 FF FF | call    _malloc
0x0040A038 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0040A03C | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0040A041 | 75 16 | jnz     short loc_40A059
0x0040A043 | 48 83 7D E8 00 | cmp     [rbp+size], 0
0x0040A048 | 74 0F | jz      short loc_40A059
0x0040A04A | BF 2A 4D 53 00 | mov     edi, offset aOutOfMemory; "out of memory"
0x0040A04F | B8 00 00 00 00 | mov     eax, 0
0x0040A054 | E8 EE F6 FF FF | call    sub_409747
0x0040A059 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040A05D | C9 | leave
0x0040A05E | C3 | retn

 Ourput decompiled code:
FAST_FUNC malloc_or_warn(size_t size)
{
	void *ptr = malloc(size);
	if (ptr == NULL && size != 0)
		bb_error_msg(bb_msg_memory_exhausted);
	return ptr;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00470064 | 55 | push    rbp
0x00470065 | 48 89 E5 | mov     rbp, rsp
0x00470068 | 48 83 EC 10 | sub     rsp, 10h
0x0047006C | BE 00 00 00 00 | mov     esi, 0; size
0x00470071 | BF 00 00 00 00 | mov     edi, 0; buf
0x00470076 | E8 45 6D F9 FF | call    _getcwd
0x0047007B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0047007F | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00470084 | 75 0D | jnz     short loc_470093
0x00470086 | 48 8B 05 8B D3 2E 00 | mov     rax, cs:qword_75D418
0x0047008D | 48 83 C0 38 | add     rax, 38h ; '8'
0x00470091 | EB 04 | jmp     short locret_470097
0x00470093 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00470097 | C9 | leave
0x00470098 | C3 | retn
 ************ 
Source Code:
static char *
getpwd(void)
{
	char *dir = getcwd(NULL, 0); /* huh, using glibc extension? */
	return dir ? dir : nullstr;
}
 ************ 
Parsed Output:
static char *get_current_directory() {
    char *buf = malloc(0);
    if (buf == NULL) {
        return NULL;
    }
    if (getcwd(buf, 0) == NULL) {
        free(buf);
        return NULL;
    }
    return buf;
}
 ************ 
Similarity Score (Unixcoder): 0.7859036326408386
Func rank: 32

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: install_sighandler
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00479364 | 55 | push    rbp
0x00479365 | 48 89 E5 | mov     rbp, rsp
0x00479368 | 48 83 EC 10 | sub     rsp, 10h
0x0047936C | 89 7D FC | mov     [rbp+var_4], edi
0x0047936F | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x00479373 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00479377 | 48 83 C0 08 | add     rax, 8
0x0047937B | 48 8B 00 | mov     rax, [rax]
0x0047937E | 48 85 C0 | test    rax, rax
0x00479381 | 74 4C | jz      short loc_4793CF
0x00479383 | 48 8B 05 8E 40 2E 00 | mov     rax, cs:qword_75D418
0x0047938A | C6 40 3C 00 | mov     byte ptr [rax+3Ch], 0
0x0047938E | 48 8B 05 83 40 2E 00 | mov     rax, cs:qword_75D418
0x00479395 | C6 40 3D 00 | mov     byte ptr [rax+3Dh], 0
0x00479399 | E8 E9 F9 FF FF | call    sub_478D87
0x0047939E | 48 8B 05 7B 40 2E 00 | mov     rax, cs:qword_75D420
0x004793A5 | 48 05 60 01 00 00 | add     rax, 160h
0x004793AB | 48 83 C0 20 | add     rax, 20h ; ' '
0x004793AF | 48 8B 40 10 | mov     rax, [rax+10h]
0x004793B3 | 48 8D 48 05 | lea     rcx, [rax+5]
0x004793B7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004793BB | 48 83 C0 08 | add     rax, 8
0x004793BF | BA 00 00 00 00 | mov     edx, 0
0x004793C4 | 48 89 CE | mov     rsi, rcx
0x004793C7 | 48 89 C7 | mov     rdi, rax
0x004793CA | E8 06 D9 FF FF | call    sub_476CD5
0x004793CF | B8 00 00 00 00 | mov     eax, 0
0x004793D4 | C9 | leave
0x004793D5 | C3 | retn

 Ourput decompiled code:
static int FAST_FUNC
execcmd(int argc UNUSED_PARAM, char **argv)
{
	if (argv[1]) {
		iflag = 0;              /* exit on error */
		mflag = 0;
		optschanged();
		shellexec(argv + 1, pathval(), 0);
	}
	return 0;
}

## Example:

 Input assembly code:
0x0046E0F3 | 55 | push    rbp
0x0046E0F4 | 48 89 E5 | mov     rbp, rsp
0x0046E0F7 | 48 83 EC 10 | sub     rsp, 10h
0x0046E0FB | 89 7D FC | mov     [rbp+c], edi
0x0046E0FE | 48 89 75 F0 | mov     [rbp+stream], rsi
0x0046E102 | 48 8B 05 0F F3 2E 00 | mov     rax, cs:qword_75D418
0x0046E109 | 8B 50 30 | mov     edx, [rax+30h]
0x0046E10C | 83 C2 01 | add     edx, 1
0x0046E10F | 89 50 30 | mov     [rax+30h], edx
0x0046E112 | 48 8B 55 F0 | mov     rdx, [rbp+stream]
0x0046E116 | 8B 45 FC | mov     eax, [rbp+c]
0x0046E119 | 48 89 D6 | mov     rsi, rdx; stream
0x0046E11C | 89 C7 | mov     edi, eax; c
0x0046E11E | E8 0D 92 F9 FF | call    _putc_unlocked
0x0046E123 | 48 8B 45 F0 | mov     rax, [rbp+stream]
0x0046E127 | 48 89 C7 | mov     rdi, rax; stream
0x0046E12A | E8 51 92 F9 FF | call    _fflush
0x0046E12F | E8 0B FF FF FF | call    sub_46E03F
0x0046E134 | 90 | nop
0x0046E135 | C9 | leave
0x0046E136 | C3 | retn

 Ourput decompiled code:
static void
outcslow(int c, FILE *dest)
{
	INT_OFF;
	putc(c, dest);
	fflush(dest);
	INT_ON;
}

## Example:

 Input assembly code:
0x0042620E | 55 | push    rbp
0x0042620F | 48 89 E5 | mov     rbp, rsp
0x00426212 | 48 83 EC 10 | sub     rsp, 10h
0x00426216 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0042621A | 89 75 F4 | mov     [rbp+var_C], esi
0x0042621D | 48 8B 05 DC 71 33 00 | mov     rax, cs:qword_75D400
0x00426224 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x0042622A | 8B 55 F4 | mov     edx, [rbp+var_C]
0x0042622D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00426231 | 48 89 C6 | mov     rsi, rax
0x00426234 | BF B0 00 00 00 | mov     edi, 0B0h; sysno
0x00426239 | B8 00 00 00 00 | mov     eax, 0
0x0042623E | E8 AD 0E FE FF | call    _syscall
0x00426243 | 48 8B 05 B6 71 33 00 | mov     rax, cs:qword_75D400
0x0042624A | 8B 00 | mov     eax, [rax]
0x0042624C | C9 | leave
0x0042624D | C3 | retn

 Ourput decompiled code:
int FAST_FUNC bb_delete_module(const char *module, unsigned int flags)
{
	errno = 0;
	delete_module(module, flags);
	return errno;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00480305 | 55 | push    rbp
0x00480306 | 48 89 E5 | mov     rbp, rsp
0x00480309 | 48 81 EC B0 00 00 00 | sub     rsp, 0B0h
0x00480310 | 89 BD 5C FF FF FF | mov     [rbp+sig], edi
0x00480316 | 48 89 B5 50 FF FF FF | mov     [rbp+var_B0], rsi
0x0048031D | 48 8B 05 E4 D0 2D 00 | mov     rax, cs:qword_75D408
0x00480324 | 48 8B 95 50 FF FF FF | mov     rdx, [rbp+var_B0]
0x0048032B | 48 89 90 40 01 00 00 | mov     [rax+140h], rdx
0x00480332 | 48 8B 05 CF D0 2D 00 | mov     rax, cs:qword_75D408
0x00480339 | 48 8D 88 40 01 00 00 | lea     rcx, [rax+140h]
0x00480340 | 48 8D 95 60 FF FF FF | lea     rdx, [rbp+var_A0]; oact
0x00480347 | 8B 85 5C FF FF FF | mov     eax, [rbp+sig]
0x0048034D | 48 89 CE | mov     rsi, rcx; act
0x00480350 | 89 C7 | mov     edi, eax; sig
0x00480352 | E8 19 65 F8 FF | call    _sigaction
0x00480357 | 48 8B 85 60 FF FF FF | mov     rax, [rbp+var_A0]
0x0048035E | C9 | leave
0x0048035F | C3 | retn
 ************ 
Source Code:
static sighandler_t install_sighandler(int sig, sighandler_t handler)
{
	struct sigaction old_sa;

	/* We could use signal() to install handlers... almost:
	 * except that we need to mask ALL signals while handlers run.
	 * I saw signal nesting in strace, race window isn't small.
	 * SA_RESTART is also needed, but in Linux, signal()
	 * sets SA_RESTART too.
	 */
	/* memset(&G.sa, 0, sizeof(G.sa)); - already done */
	/* sigfillset(&G.sa.sa_mask);      - already done */
	/* G.sa.sa_flags = SA_RESTART;     - already done */
	G.sa.sa_handler = handler;
	sigaction(sig, &G.sa, &old_sa);
	return old_sa.sa_handler;
}
 ************ 
Parsed Output:
static void sigaction(int sig, const struct sigaction *act, struct sigaction *oact)
{
    struct sigaction *oldact = oact;
    oact = act;
    _sigaction(sig, act, oldact);
}
 ************ 
Similarity Score (Unixcoder): 0.782030463218689
Func rank: 33

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: bufsum
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004F7534 | 55 | push    rbp
0x004F7535 | 48 89 E5 | mov     rbp, rsp
0x004F7538 | 89 7D EC | mov     [rbp+var_14], edi
0x004F753B | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004F753F | 89 55 E8 | mov     [rbp+var_18], edx
0x004F7542 | 48 89 4D D8 | mov     [rbp+var_28], rcx
0x004F7546 | 8B 55 E8 | mov     edx, [rbp+var_18]
0x004F7549 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004F754D | 48 01 D0 | add     rax, rdx
0x004F7550 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004F7554 | EB 32 | jmp     short loc_4F7588
0x004F7556 | 8B 45 EC | mov     eax, [rbp+var_14]
0x004F7559 | 89 C2 | mov     edx, eax
0x004F755B | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004F755F | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004F7562 | 31 D0 | xor     eax, edx
0x004F7564 | 0F B6 C0 | movzx   eax, al
0x004F7567 | 48 8D 14 85 00 00 00 00 | lea     rdx, ds:0[rax*4]
0x004F756F | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004F7573 | 48 01 D0 | add     rax, rdx
0x004F7576 | 8B 00 | mov     eax, [rax]
0x004F7578 | 8B 55 EC | mov     edx, [rbp+var_14]
0x004F757B | C1 EA 08 | shr     edx, 8
0x004F757E | 31 D0 | xor     eax, edx
0x004F7580 | 89 45 EC | mov     [rbp+var_14], eax
0x004F7583 | 48 83 45 E0 01 | add     [rbp+var_20], 1
0x004F7588 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004F758C | 48 3B 45 F8 | cmp     rax, [rbp+var_8]
0x004F7590 | 75 C4 | jnz     short loc_4F7556
0x004F7592 | 8B 45 EC | mov     eax, [rbp+var_14]
0x004F7595 | 5D | pop     rbp
0x004F7596 | C3 | retn

 Ourput decompiled code:
uint32_t FAST_FUNC crc32_block_endian0(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table)
{
	const void *end = (uint8_t*)buf + len;

	while (buf != end) {
		val = crc_table[(uint8_t)val ^ *(uint8_t*)buf] ^ (val >> 8);
		buf = (uint8_t*)buf + 1;
	}
	return val;
}

## Example:

 Input assembly code:
0x00456E02 | 55 | push    rbp
0x00456E03 | 48 89 E5 | mov     rbp, rsp
0x00456E06 | 53 | push    rbx
0x00456E07 | 48 83 EC 38 | sub     rsp, 38h
0x00456E0B | 48 89 7D D8 | mov     [rbp+var_28], rdi
0x00456E0F | 89 75 D4 | mov     [rbp+var_2C], esi
0x00456E12 | 48 89 55 C8 | mov     [rbp+var_38], rdx
0x00456E16 | C7 45 E8 00 00 00 00 | mov     [rbp+var_18], 0
0x00456E1D | C7 45 EC 00 00 00 00 | mov     [rbp+var_14], 0
0x00456E24 | EB 74 | jmp     short loc_456E9A
0x00456E26 | 8B 45 EC | mov     eax, [rbp+var_14]
0x00456E29 | 48 98 | cdqe
0x00456E2B | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]
0x00456E33 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00456E37 | 48 01 D0 | add     rax, rdx
0x00456E3A | 48 8B 00 | mov     rax, [rax]
0x00456E3D | 8B 55 EC | mov     edx, [rbp+var_14]
0x00456E40 | 48 63 D2 | movsxd  rdx, edx
0x00456E43 | 48 8D 0C 95 00 00 00 00 | lea     rcx, ds:0[rdx*4]
0x00456E4B | 48 8B 55 C8 | mov     rdx, [rbp+var_38]
0x00456E4F | 48 8D 1C 11 | lea     rbx, [rcx+rdx]
0x00456E53 | 48 89 C6 | mov     rsi, rax
0x00456E56 | BF 43 00 00 00 | mov     edi, 43h ; 'C'
0x00456E5B | E8 59 24 00 00 | call    sub_4592B9
0x00456E60 | 89 03 | mov     [rbx], eax
0x00456E62 | 8B 45 EC | mov     eax, [rbp+var_14]
0x00456E65 | 48 98 | cdqe
0x00456E67 | 48 8D 14 85 00 00 00 00 | lea     rdx, ds:0[rax*4]
0x00456E6F | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x00456E73 | 48 01 D0 | add     rax, rdx
0x00456E76 | 8B 00 | mov     eax, [rax]
0x00456E78 | 39 45 E8 | cmp     [rbp+var_18], eax
0x00456E7B | 7D 19 | jge     short loc_456E96
0x00456E7D | 8B 45 EC | mov     eax, [rbp+var_14]
0x00456E80 | 48 98 | cdqe
0x00456E82 | 48 8D 14 85 00 00 00 00 | lea     rdx, ds:0[rax*4]
0x00456E8A | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x00456E8E | 48 01 D0 | add     rax, rdx
0x00456E91 | 8B 00 | mov     eax, [rax]
0x00456E93 | 89 45 E8 | mov     [rbp+var_18], eax
0x00456E96 | 83 45 EC 01 | add     [rbp+var_14], 1
0x00456E9A | 8B 45 EC | mov     eax, [rbp+var_14]
0x00456E9D | 3B 45 D4 | cmp     eax, [rbp+var_2C]
0x00456EA0 | 7C 84 | jl      short loc_456E26
0x00456EA2 | 8B 45 E8 | mov     eax, [rbp+var_18]
0x00456EA5 | 48 83 C4 38 | add     rsp, 38h
0x00456EA9 | 5B | pop     rbx
0x00456EAA | 5D | pop     rbp
0x00456EAB | C3 | retn

 Ourput decompiled code:
static int init_sockets(char **iface_list, int num_clients, int *fds)
{
	int i, n;

	n = 0;
	for (i = 0; i < num_clients; i++) {
		fds[i] = udhcp_listen_socket(/*INADDR_ANY,*/ SERVER_PORT, iface_list[i]);
		if (n < fds[i])
			n = fds[i];
	}
	return n;
}

## Example:

 Input assembly code:
0x0043FF9E | 55 | push    rbp
0x0043FF9F | 48 89 E5 | mov     rbp, rsp
0x0043FFA2 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0043FFA6 | 89 75 E4 | mov     [rbp+var_1C], esi
0x0043FFA9 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043FFAD | 48 8D 50 01 | lea     rdx, [rax+1]
0x0043FFB1 | 48 89 55 E8 | mov     [rbp+var_18], rdx
0x0043FFB5 | C6 00 55 | mov     byte ptr [rax], 55h ; 'U'
0x0043FFB8 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x0043FFBF | EB 1E | jmp     short loc_43FFDF
0x0043FFC1 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0043FFC4 | 48 98 | cdqe
0x0043FFC6 | 8B 14 85 A0 A4 51 00 | mov     edx, ds:dword_51A4A0[rax*4]
0x0043FFCD | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x0043FFD0 | 21 D0 | and     eax, edx
0x0043FFD2 | 85 C0 | test    eax, eax
0x0043FFD4 | 74 05 | jz      short loc_43FFDB
0x0043FFD6 | 48 83 45 E8 01 | add     [rbp+var_18], 1
0x0043FFDB | 83 45 FC 01 | add     [rbp+var_4], 1
0x0043FFDF | 8B 45 FC | mov     eax, [rbp+var_4]
0x0043FFE2 | 48 98 | cdqe
0x0043FFE4 | 0F B6 90 C0 A4 51 00 | movzx   edx, ds:byte_51A4C0[rax]
0x0043FFEB | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043FFEF | 88 10 | mov     [rax], dl
0x0043FFF1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043FFF5 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0043FFF8 | 84 C0 | test    al, al
0x0043FFFA | 75 C5 | jnz     short loc_43FFC1
0x0043FFFC | 90 | nop
0x0043FFFD | 5D | pop     rbp
0x0043FFFE | C3 | retn

 Ourput decompiled code:
static void set_flags(char *flagstr, int flags)
{
	int i;

	*flagstr++ = 'U';

	for (i = 0; (*flagstr = flagchars[i]) != 0; i++) {
		if (flags & flagvals[i]) {
			++flagstr;
		}
	}
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004EFD23 | 55 | push    rbp
0x004EFD24 | 48 89 E5 | mov     rbp, rsp
0x004EFD27 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004EFD2B | 89 75 E4 | mov     [rbp+var_1C], esi
0x004EFD2E | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004EFD35 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004EFD38 | 48 63 D0 | movsxd  rdx, eax
0x004EFD3B | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004EFD3F | 48 01 D0 | add     rax, rdx
0x004EFD42 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x004EFD46 | EB 15 | jmp     short loc_4EFD5D
0x004EFD48 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004EFD4C | 48 8D 50 01 | lea     rdx, [rax+1]
0x004EFD50 | 48 89 55 E8 | mov     [rbp+var_18], rdx
0x004EFD54 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004EFD57 | 0F B6 C0 | movzx   eax, al
0x004EFD5A | 01 45 FC | add     [rbp+var_4], eax
0x004EFD5D | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004EFD61 | 48 3B 45 F0 | cmp     rax, [rbp+var_10]
0x004EFD65 | 72 E1 | jb      short loc_4EFD48
0x004EFD67 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004EFD6A | 5D | pop     rbp
0x004EFD6B | C3 | retn
 ************ 
Source Code:
static int bufsum(char *buf, int count)
{
	int sum = 0;
	char *e = buf + count;

	while (buf < e)
		sum += (unsigned char) *buf++;
	return sum;
}
 ************ 
Parsed Output:
static void calculate_sum(char *str, int len)
{
    int sum = 0;
    
    for (int i = 0; i < len; i++) {
        sum += str[i];
    }
    
    return sum;
}
 ************ 
Similarity Score (Unixcoder): 0.7706966996192932
Func rank: 34

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: invalid_name
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0048B130 | 55 | push    rbp
0x0048B131 | 48 89 E5 | mov     rbp, rsp
0x0048B134 | 48 83 EC 08 | sub     rsp, 8
0x0048B138 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0048B13C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B140 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0048B143 | 3C 5F | cmp     al, 5Fh ; '_'
0x0048B145 | 74 37 | jz      short loc_48B17E
0x0048B147 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B14B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0048B14E | 83 C8 20 | or      eax, 20h
0x0048B151 | 83 E8 61 | sub     eax, 61h ; 'a'
0x0048B154 | 3C 19 | cmp     al, 19h
0x0048B156 | 76 26 | jbe     short loc_48B17E
0x0048B158 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B15C | EB 37 | jmp     short locret_48B195
0x0048B15E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B162 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0048B165 | 3C 5F | cmp     al, 5Fh ; '_'
0x0048B167 | 74 15 | jz      short loc_48B17E
0x0048B169 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B16D | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0048B170 | 0F B6 C0 | movzx   eax, al
0x0048B173 | 89 C7 | mov     edi, eax
0x0048B175 | E8 45 F9 FF FF | call    sub_48AABF
0x0048B17A | 85 C0 | test    eax, eax
0x0048B17C | 74 12 | jz      short loc_48B190
0x0048B17E | 48 83 45 F8 01 | add     [rbp+var_8], 1
0x0048B183 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B187 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0048B18A | 84 C0 | test    al, al
0x0048B18C | 75 D0 | jnz     short loc_48B15E
0x0048B18E | EB 01 | jmp     short loc_48B191
0x0048B190 | 90 | nop
0x0048B191 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B195 | C9 | leave
0x0048B196 | C3 | retn

 Ourput decompiled code:
FAST_FUNC
endofname(const char *name)
{
	if (!is_name(*name))
		return name;
	while (*++name) {
		if (!is_in_name(*name))
			break;
	}
	return name;
}

## Example:

 Input assembly code:
0x0041153F | 55 | push    rbp
0x00411540 | 48 89 E5 | mov     rbp, rsp
0x00411543 | 48 83 EC 18 | sub     rsp, 18h
0x00411547 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0041154B | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0041154F | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00411553 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00411557 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0041155B | EB 5B | jmp     short loc_4115B8
0x0041155D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00411561 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00411564 | 0F B6 C0 | movzx   eax, al
0x00411567 | 89 C7 | mov     edi, eax
0x00411569 | E8 00 FE FF FF | call    sub_41136E
0x0041156E | 85 C0 | test    eax, eax
0x00411570 | 75 2C | jnz     short loc_41159E
0x00411572 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00411576 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00411579 | 3C 5F | cmp     al, 5Fh ; '_'
0x0041157B | 74 21 | jz      short loc_41159E
0x0041157D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00411581 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00411584 | 3C 2D | cmp     al, 2Dh ; '-'
0x00411586 | 74 16 | jz      short loc_41159E
0x00411588 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0041158C | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0041158F | 3C 2E | cmp     al, 2Eh ; '.'
0x00411591 | 74 0B | jz      short loc_41159E
0x00411593 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00411597 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0041159A | 3C 40 | cmp     al, 40h ; '@'
0x0041159C | 75 15 | jnz     short loc_4115B3
0x0041159E | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004115A2 | 48 8D 50 01 | lea     rdx, [rax+1]
0x004115A6 | 48 89 55 F0 | mov     [rbp+var_10], rdx
0x004115AA | 48 8B 55 F8 | mov     rdx, [rbp+var_8]
0x004115AE | 0F B6 12 | movzx   edx, byte ptr [rdx]
0x004115B1 | 88 10 | mov     [rax], dl
0x004115B3 | 48 83 45 F8 01 | add     [rbp+var_8], 1
0x004115B8 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004115BC | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004115BF | 84 C0 | test    al, al
0x004115C1 | 75 9A | jnz     short loc_41155D
0x004115C3 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004115C7 | C6 00 00 | mov     byte ptr [rax], 0
0x004115CA | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004115CE | C9 | leave
0x004115CF | C3 | retn

 Ourput decompiled code:
strip argument of bad chars
static char *sane_address(char *str)
{
	char *s = str;
	char *p = s;
	while (*s) {
		if (isalnum(*s) || '_' == *s || '-' == *s || '.' == *s || '@' == *s) {
			*p++ = *s;
		}
		s++;
	}
	*p = '\0';
	return str;
}

## Example:

 Input assembly code:
0x00453547 | 55 | push    rbp
0x00453548 | 48 89 E5 | mov     rbp, rsp
0x0045354B | 48 83 EC 08 | sub     rsp, 8
0x0045354F | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00453553 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00453557 | 48 89 C7 | mov     rdi, rax
0x0045355A | E8 6E FF FF FF | call    sub_4534CD
0x0045355F | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00453563 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00453568 | 75 07 | jnz     short loc_453571
0x0045356A | B8 00 00 00 00 | mov     eax, 0
0x0045356F | EB 19 | jmp     short locret_45358A
0x00453571 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00453575 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00453578 | 84 C0 | test    al, al
0x0045357A | 75 07 | jnz     short loc_453583
0x0045357C | B8 01 00 00 00 | mov     eax, 1
0x00453581 | EB 07 | jmp     short locret_45358A
0x00453583 | 48 83 45 F8 01 | add     [rbp+var_8], 1
0x00453588 | EB C9 | jmp     short loc_453553
0x0045358A | C9 | leave
0x0045358B | C3 | retn

 Ourput decompiled code:
static int good_hostname(const char *name)
{
	//const char *start = name;

	for (;;) {
		name = valid_domain_label(name);
		if (!name)
			return 0;
		if (!name[0])
			return 1;
			//Do we want this?
			//return ((name - start) < 1025); /* NS_MAXDNAME */
		name++;
	}
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004D8EBD | 55 | push    rbp
0x004D8EBE | 48 89 E5 | mov     rbp, rsp
0x004D8EC1 | 48 83 EC 10 | sub     rsp, 10h
0x004D8EC5 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004D8EC9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004D8ECD | 48 89 C7 | mov     rdi, rax
0x004D8ED0 | E8 BF FF F2 FF | call    sub_408E94
0x004D8ED5 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004D8ED9 | EB 05 | jmp     short loc_4D8EE0
0x004D8EDB | 48 83 45 F8 01 | add     [rbp+var_8], 1
0x004D8EE0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004D8EE4 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004D8EE7 | 84 C0 | test    al, al
0x004D8EE9 | 74 2B | jz      short loc_4D8F16
0x004D8EEB | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004D8EEF | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004D8EF2 | 0F B6 C0 | movzx   eax, al
0x004D8EF5 | 89 C7 | mov     edi, eax
0x004D8EF7 | E8 83 FF FF FF | call    sub_4D8E7F
0x004D8EFC | 85 C0 | test    eax, eax
0x004D8EFE | 75 DB | jnz     short loc_4D8EDB
0x004D8F00 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004D8F04 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004D8F07 | 3C 5F | cmp     al, 5Fh ; '_'
0x004D8F09 | 74 D0 | jz      short loc_4D8EDB
0x004D8F0B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004D8F0F | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004D8F12 | 3C 2D | cmp     al, 2Dh ; '-'
0x004D8F14 | 74 C5 | jz      short loc_4D8EDB
0x004D8F16 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004D8F1A | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004D8F1D | 84 C0 | test    al, al
0x004D8F1F | 0F 95 C0 | setnz   al
0x004D8F22 | C9 | leave
0x004D8F23 | C3 | retn
 ************ 
Source Code:
static bool invalid_name(const char *c)
{
	c = bb_basename(c);

	while (*c && (isalnum(*c) || *c == '_' || *c == '-'))
		c++;

	return *c; /* TRUE (!0) if terminating NUL is not reached */
}
 ************ 
Parsed Output:
static int is_valid_string(const char *str)
{
    while (*str)
    {
        if (*str == '_' || *str == '-')
        {
            return 0;
        }
        str++;
    }
    return 1;
}
 ************ 
Similarity Score (Unixcoder): 0.7634612917900085
Func rank: 35

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: procnetdev_version
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00422081 | 55 | push    rbp
0x00422082 | 48 89 E5 | mov     rbp, rsp
0x00422085 | 48 83 EC 10 | sub     rsp, 10h
0x00422089 | 48 89 7D F8 | mov     [rbp+s1], rdi
0x0042208D | 48 8B 45 F8 | mov     rax, [rbp+s1]
0x00422091 | BE 69 75 51 00 | mov     esi, offset aNone_1; "none"
0x00422096 | 48 89 C7 | mov     rdi, rax; s1
0x00422099 | E8 22 46 FE FF | call    _strcasecmp
0x0042209E | 85 C0 | test    eax, eax
0x004220A0 | 75 07 | jnz     short loc_4220A9
0x004220A2 | B8 FF FF 00 00 | mov     eax, 0FFFFh
0x004220A7 | EB 28 | jmp     short locret_4220D1
0x004220A9 | 48 8B 45 F8 | mov     rax, [rbp+s1]
0x004220AD | BE 60 75 51 00 | mov     esi, offset aInfinite; "infinite"
0x004220B2 | 48 89 C7 | mov     rdi, rax; s1
0x004220B5 | E8 06 46 FE FF | call    _strcasecmp
0x004220BA | 85 C0 | test    eax, eax
0x004220BC | 75 07 | jnz     short loc_4220C5
0x004220BE | B8 00 00 00 00 | mov     eax, 0
0x004220C3 | EB 0C | jmp     short locret_4220D1
0x004220C5 | 48 8B 45 F8 | mov     rax, [rbp+s1]
0x004220C9 | 48 89 C7 | mov     rdi, rax
0x004220CC | E8 8C FF FF FF | call    sub_42205D
0x004220D1 | C9 | leave
0x004220D2 | C3 | retn

 Ourput decompiled code:
static int get_wait(const char *arg)
{
	if (strcasecmp(arg, STR_NONE) == 0)
		return ASYNC_CLOSING_WAIT_NONE;

	if (strcasecmp(arg, STR_INFINITE) == 0)
		return ASYNC_CLOSING_WAIT_INF;

	return get_numeric(arg);
}

## Example:

 Input assembly code:
0x0046EE78 | 55 | push    rbp
0x0046EE79 | 48 89 E5 | mov     rbp, rsp
0x0046EE7C | 48 83 EC 10 | sub     rsp, 10h
0x0046EE80 | 48 89 7D F8 | mov     [rbp+nptr], rdi
0x0046EE84 | 48 8B 45 F8 | mov     rax, [rbp+nptr]
0x0046EE88 | 48 89 C7 | mov     rdi, rax
0x0046EE8B | E8 B4 FF FF FF | call    sub_46EE44
0x0046EE90 | 85 C0 | test    eax, eax
0x0046EE92 | 75 16 | jnz     short loc_46EEAA
0x0046EE94 | 48 8B 45 F8 | mov     rax, [rbp+nptr]
0x0046EE98 | 48 89 C6 | mov     rsi, rax
0x0046EE9B | BF 7D C6 51 00 | mov     edi, offset aIllegalNumberS; "Illegal number: %s"
0x0046EEA0 | B8 00 00 00 00 | mov     eax, 0
0x0046EEA5 | E8 C9 F5 FF FF | call    sub_46E473
0x0046EEAA | 48 8B 45 F8 | mov     rax, [rbp+nptr]
0x0046EEAE | 48 89 C7 | mov     rdi, rax; nptr
0x0046EEB1 | E8 0A 8B F9 FF | call    _atoi
0x0046EEB6 | C9 | leave
0x0046EEB7 | C3 | retn

 Ourput decompiled code:
static int
number(const char *s)
{
	if (!is_number(s))
		ash_msg_and_raise_error(msg_illnum, s);
	return atoi(s);
}

## Example:

 Input assembly code:
0x0040A8DC | 55 | push    rbp
0x0040A8DD | 48 89 E5 | mov     rbp, rsp
0x0040A8E0 | 48 83 EC 10 | sub     rsp, 10h
0x0040A8E4 | 48 89 7D F8 | mov     [rbp+path], rdi
0x0040A8E8 | 48 8B 45 F8 | mov     rax, [rbp+path]
0x0040A8EC | 48 89 C7 | mov     rdi, rax; path
0x0040A8EF | E8 EC BE FF FF | call    _chroot
0x0040A8F4 | 85 C0 | test    eax, eax
0x0040A8F6 | 74 16 | jz      short loc_40A90E
0x0040A8F8 | 48 8B 45 F8 | mov     rax, [rbp+path]
0x0040A8FC | 48 89 C6 | mov     rsi, rax
0x0040A8FF | BF 08 81 52 00 | mov     edi, offset aCanTChangeRoot; "can't change root directory to '%s'"
0x0040A904 | B8 00 00 00 00 | mov     eax, 0
0x0040A909 | E8 94 E9 FF FF | call    sub_4092A2
0x0040A90E | BF 2C 81 52 00 | mov     edi, offset asc_52812C; "/"
0x0040A913 | E8 8F FF FF FF | call    sub_40A8A7
0x0040A918 | 90 | nop
0x0040A919 | C9 | leave
0x0040A91A | C3 | retn

 Ourput decompiled code:
void FAST_FUNC xchroot(const char *path)
{
	if (chroot(path))
		bb_perror_msg_and_die("can't change root directory to '%s'", path);
	xchdir("/");
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00436DA9 | 55 | push    rbp
0x00436DAA | 48 89 E5 | mov     rbp, rsp
0x00436DAD | 48 83 EC 10 | sub     rsp, 10h
0x00436DB1 | 48 89 7D F8 | mov     [rbp+haystack], rdi
0x00436DB5 | 48 8B 45 F8 | mov     rax, [rbp+haystack]
0x00436DB9 | BE 58 97 51 00 | mov     esi, offset aCompressed; "compressed"
0x00436DBE | 48 89 C7 | mov     rdi, rax; haystack
0x00436DC1 | E8 FA 0E FD FF | call    _strstr
0x00436DC6 | 48 85 C0 | test    rax, rax
0x00436DC9 | 74 07 | jz      short loc_436DD2
0x00436DCB | B8 02 00 00 00 | mov     eax, 2
0x00436DD0 | EB 22 | jmp     short locret_436DF4
0x00436DD2 | 48 8B 45 F8 | mov     rax, [rbp+haystack]
0x00436DD6 | BE 63 97 51 00 | mov     esi, offset aBytes_0; "bytes"
0x00436DDB | 48 89 C7 | mov     rdi, rax; haystack
0x00436DDE | E8 DD 0E FD FF | call    _strstr
0x00436DE3 | 48 85 C0 | test    rax, rax
0x00436DE6 | 74 07 | jz      short loc_436DEF
0x00436DE8 | B8 01 00 00 00 | mov     eax, 1
0x00436DED | EB 05 | jmp     short locret_436DF4
0x00436DEF | B8 00 00 00 00 | mov     eax, 0
0x00436DF4 | C9 | leave
0x00436DF5 | C3 | retn
 ************ 
Source Code:
static int procnetdev_version(char *buf)
{
	if (strstr(buf, "compressed"))
		return 2;
	if (strstr(buf, "bytes"))
		return 1;
	return 0;
}
 ************ 
Parsed Output:
static int check_compression(const char *haystack)
{
    if (strstr(haystack, "compressed") != NULL)
        return 2;
    else if (strstr(haystack, "bytes") != NULL)
        return 1;
    else
        return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.753386914730072
Func rank: 36

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: setConMode
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0044230D | 55 | push    rbp
0x0044230E | 48 89 E5 | mov     rbp, rsp
0x00442311 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00442316 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]
0x0044231A | 0F B6 C0 | movzx   eax, al
0x0044231D | 83 E0 02 | and     eax, 2
0x00442320 | 85 C0 | test    eax, eax
0x00442322 | 74 0F | jz      short loc_442333
0x00442324 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00442329 | 0F B6 40 05 | movzx   eax, byte ptr [rax+5]
0x0044232D | 3C FB | cmp     al, 0FBh
0x0044232F | 75 0F | jnz     short loc_442340
0x00442331 | EB 57 | jmp     short loc_44238A
0x00442333 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00442338 | 0F B6 40 05 | movzx   eax, byte ptr [rax+5]
0x0044233C | 3C FC | cmp     al, 0FCh
0x0044233E | 74 49 | jz      short loc_442389
0x00442340 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00442345 | 0F B6 50 07 | movzx   edx, byte ptr [rax+7]
0x00442349 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0044234E | 83 F2 02 | xor     edx, 2
0x00442351 | 88 50 07 | mov     [rax+7], dl
0x00442354 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00442359 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]
0x0044235D | 0F B6 C0 | movzx   eax, al
0x00442360 | 83 E0 02 | and     eax, 2
0x00442363 | 85 C0 | test    eax, eax
0x00442365 | 74 11 | jz      short loc_442378
0x00442367 | BE 03 00 00 00 | mov     esi, 3
0x0044236C | BF FD 00 00 00 | mov     edi, 0FDh
0x00442371 | E8 F1 FA FF FF | call    sub_441E67
0x00442376 | EB 12 | jmp     short loc_44238A
0x00442378 | BE 03 00 00 00 | mov     esi, 3
0x0044237D | BF FE 00 00 00 | mov     edi, 0FEh
0x00442382 | E8 E0 FA FF FF | call    sub_441E67
0x00442387 | EB 01 | jmp     short loc_44238A
0x00442389 | 90 | nop
0x0044238A | 5D | pop     rbp
0x0044238B | C3 | retn

 Ourput decompiled code:
static void to_sga(void)
{
	/* daemon always sends will/wont, client do/dont */

	if (G.telflags & UF_SGA) {
		if (G.telwish == WILL)
			return;
	} else if (G.telwish == WONT)
		return;

	G.telflags ^= UF_SGA; /* toggle */
	if (G.telflags & UF_SGA)
		put_iac2(DO, TELOPT_SGA);
	else
		put_iac2(DONT, TELOPT_SGA);
}

## Example:

 Input assembly code:
0x0044223D | 55 | push    rbp
0x0044223E | 48 89 E5 | mov     rbp, rsp
0x00442241 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00442246 | 0F B6 40 05 | movzx   eax, byte ptr [rax+5]
0x0044224A | 3C FD | cmp     al, 0FDh
0x0044224C | 75 14 | jnz     short loc_442262
0x0044224E | BE 01 00 00 00 | mov     esi, 1
0x00442253 | BF FC 00 00 00 | mov     edi, 0FCh
0x00442258 | E8 0A FC FF FF | call    sub_441E67
0x0044225D | E9 A9 00 00 00 | jmp     loc_44230B
0x00442262 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00442267 | 0F B6 40 05 | movzx   eax, byte ptr [rax+5]
0x0044226B | 3C FE | cmp     al, 0FEh
0x0044226D | 0F 84 94 00 00 00 | jz      loc_442307
0x00442273 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00442278 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]
0x0044227C | 0F B6 C0 | movzx   eax, al
0x0044227F | 83 E0 01 | and     eax, 1
0x00442282 | 85 C0 | test    eax, eax
0x00442284 | 74 0F | jz      short loc_442295
0x00442286 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0044228B | 0F B6 40 05 | movzx   eax, byte ptr [rax+5]
0x0044228F | 3C FB | cmp     al, 0FBh
0x00442291 | 75 0F | jnz     short loc_4422A2
0x00442293 | EB 76 | jmp     short loc_44230B
0x00442295 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0044229A | 0F B6 40 05 | movzx   eax, byte ptr [rax+5]
0x0044229E | 3C FC | cmp     al, 0FCh
0x004422A0 | 74 68 | jz      short loc_44230A
0x004422A2 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004422A7 | 0F B6 40 06 | movzx   eax, byte ptr [rax+6]
0x004422AB | 3C 02 | cmp     al, 2
0x004422AD | 74 14 | jz      short loc_4422C3
0x004422AF | B8 F8 B3 75 00 | mov     eax, offset dest
0x004422B4 | 0F B6 50 07 | movzx   edx, byte ptr [rax+7]
0x004422B8 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004422BD | 83 F2 01 | xor     edx, 1
0x004422C0 | 88 50 07 | mov     [rax+7], dl
0x004422C3 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004422C8 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]
0x004422CC | 0F B6 C0 | movzx   eax, al
0x004422CF | 83 E0 01 | and     eax, 1
0x004422D2 | 85 C0 | test    eax, eax
0x004422D4 | 74 11 | jz      short loc_4422E7
0x004422D6 | BE 01 00 00 00 | mov     esi, 1
0x004422DB | BF FD 00 00 00 | mov     edi, 0FDh
0x004422E0 | E8 82 FB FF FF | call    sub_441E67
0x004422E5 | EB 0F | jmp     short loc_4422F6
0x004422E7 | BE 01 00 00 00 | mov     esi, 1
0x004422EC | BF FE 00 00 00 | mov     edi, 0FEh
0x004422F1 | E8 71 FB FF FF | call    sub_441E67
0x004422F6 | E8 D4 FD FF FF | call    sub_4420CF
0x004422FB | BF DE BC 52 00 | mov     edi, offset asc_52BCDE; "\r\n"
0x00442300 | E8 A9 7A FC FF | call    sub_409DAE
0x00442305 | EB 04 | jmp     short loc_44230B
0x00442307 | 90 | nop
0x00442308 | EB 01 | jmp     short loc_44230B
0x0044230A | 90 | nop
0x0044230B | 5D | pop     rbp
0x0044230C | C3 | retn

 Ourput decompiled code:
static void to_echo(void)
{
	/* if server requests ECHO, don't agree */
	if (G.telwish == DO) {
		put_iac2(WONT, TELOPT_ECHO);
		return;
	}
	if (G.telwish == DONT)
		return;

	if (G.telflags & UF_ECHO) {
		if (G.telwish == WILL)
			return;
	} else if (G.telwish == WONT)
		return;

	if (G.charmode != CHM_OFF)
		G.telflags ^= UF_ECHO;

	if (G.telflags & UF_ECHO)
		put_iac2(DO, TELOPT_ECHO);
	else
		put_iac2(DONT, TELOPT_ECHO);

	setConMode();
	full_write1_str("\r\n");  /* sudden modec */
}

## Example:

 Input assembly code:
0x0044219F | 55 | push    rbp
0x004421A0 | 48 89 E5 | mov     rbp, rsp
0x004421A3 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004421A8 | C6 40 06 00 | mov     byte ptr [rax+6], 0
0x004421AC | B8 F8 B3 75 00 | mov     eax, offset dest
0x004421B1 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]
0x004421B5 | BA F8 B3 75 00 | mov     edx, offset dest
0x004421BA | 83 E0 FC | and     eax, 0FFFFFFFCh
0x004421BD | 88 42 07 | mov     [rdx+7], al
0x004421C0 | E8 0A FF FF FF | call    sub_4420CF
0x004421C5 | BE 01 00 00 00 | mov     esi, 1
0x004421CA | BF FE 00 00 00 | mov     edi, 0FEh
0x004421CF | E8 93 FC FF FF | call    sub_441E67
0x004421D4 | BE 03 00 00 00 | mov     esi, 3
0x004421D9 | BF FE 00 00 00 | mov     edi, 0FEh
0x004421DE | E8 84 FC FF FF | call    sub_441E67
0x004421E3 | E8 43 F8 FF FF | call    sub_441A2B
0x004421E8 | 90 | nop
0x004421E9 | 5D | pop     rbp
0x004421EA | C3 | retn

 Ourput decompiled code:
static void do_linemode(void)
{
	G.charmode = CHM_TRY;
	G.telflags &= ~(UF_ECHO | UF_SGA);
	setConMode();

	put_iac2(DONT, TELOPT_ECHO);
	put_iac2(DONT, TELOPT_SGA);
	iac_flush();
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004420CF | 55 | push    rbp
0x004420D0 | 48 89 E5 | mov     rbp, rsp
0x004420D3 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004420D8 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]
0x004420DC | 0F B6 C0 | movzx   eax, al
0x004420DF | 83 E0 01 | and     eax, 1
0x004420E2 | 85 C0 | test    eax, eax
0x004420E4 | 74 36 | jz      short loc_44211C
0x004420E6 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004420EB | 0F B6 40 06 | movzx   eax, byte ptr [rax+6]
0x004420EF | 84 C0 | test    al, al
0x004420F1 | 75 5D | jnz     short loc_442150
0x004420F3 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004420F8 | C6 40 06 01 | mov     byte ptr [rax+6], 1
0x004420FC | BA 5D 00 00 00 | mov     edx, 5Dh ; ']'
0x00442101 | BE 9D BC 52 00 | mov     esi, offset aCharacter; "character"
0x00442106 | BF A8 BC 52 00 | mov     edi, offset aEnteringSModeE; "\r\nEntering %s mode\r\nEscape characte"...
0x0044210B | B8 00 00 00 00 | mov     eax, 0
0x00442110 | E8 BB 4A FC FF | call    _printf
0x00442115 | E8 07 04 00 00 | call    sub_442521
0x0044211A | EB 34 | jmp     short loc_442150
0x0044211C | B8 F8 B3 75 00 | mov     eax, offset dest
0x00442121 | 0F B6 40 06 | movzx   eax, byte ptr [rax+6]
0x00442125 | 3C 02 | cmp     al, 2
0x00442127 | 74 27 | jz      short loc_442150
0x00442129 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0044212E | C6 40 06 02 | mov     byte ptr [rax+6], 2
0x00442132 | BA 43 00 00 00 | mov     edx, 43h ; 'C'
0x00442137 | BE D9 BC 52 00 | mov     esi, offset aLine; "line"
0x0044213C | BF A8 BC 52 00 | mov     edi, offset aEnteringSModeE; "\r\nEntering %s mode\r\nEscape characte"...
0x00442141 | B8 00 00 00 00 | mov     eax, 0
0x00442146 | E8 85 4A FC FF | call    _printf
0x0044214B | E8 FC 03 00 00 | call    sub_44254C
0x00442150 | 90 | nop
0x00442151 | 5D | pop     rbp
0x00442152 | C3 | retn
 ************ 
Source Code:
endif

static void setConMode(void)
{
	if (G.telflags & UF_ECHO) {
		if (G.charmode == CHM_TRY) {
			G.charmode = CHM_ON;
			printf("\r
Entering %s mode"
				"\r
Escape character is '^%c'.\r
", "character", ']');
			rawmode();
		}
	} else {
		if (G.charmode != CHM_OFF) {
			G.charmode = CHM_OFF;
			printf("\r
Entering %s mode"
				"\r
Escape character is '^%c'.\r
", "line", 'C');
			cookmode();
		}
	}
}
 ************ 
Parsed Output:
static void set_mode(void)
{
    if ((dest[7] & 1) == 1)
    {
        if (dest[6] == 0)
        {
            dest[6] = 1;
            printf("Entering character mode\r
Escape character: ']'\r
");
            sub_442521();
        }
    }
    else
    {
        if (dest[6] != 2)
        {
            dest[6] = 2;
            printf("Entering line mode\r
Escape character: 'C'\r
");
            sub_44254C();
        }
    }
}
 ************ 
Similarity Score (Unixcoder): 0.7481167316436768
Func rank: 37

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: xprint_and_close_file
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004C4489 | 55 | push    rbp
0x004C448A | 48 89 E5 | mov     rbp, rsp
0x004C448D | 48 83 EC 10 | sub     rsp, 10h
0x004C4491 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004C4495 | E8 16 34 F4 FF | call    _vfork
0x004C449A | 85 C0 | test    eax, eax
0x004C449C | 75 2A | jnz     short loc_4C44C8
0x004C449E | E8 CD 29 F4 FF | call    _setsid
0x004C44A3 | BA 00 00 00 00 | mov     edx, 0
0x004C44A8 | BE 0E 54 00 00 | mov     esi, 540Eh; request
0x004C44AD | BF 00 00 00 00 | mov     edi, 0; fd
0x004C44B2 | B8 00 00 00 00 | mov     eax, 0
0x004C44B7 | E8 E4 28 F4 FF | call    _ioctl
0x004C44BC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C44C0 | 48 89 C7 | mov     rdi, rax
0x004C44C3 | E8 55 4E 03 00 | call    sub_4F931D
0x004C44C8 | 90 | nop
0x004C44C9 | C9 | leave
0x004C44CA | C3 | retn

 Ourput decompiled code:
static NOINLINE void vfork_child(char **argv)
{
	if (vfork() == 0) {
		/* CHILD */
		/* Try to make this VT our controlling tty */
		setsid(); /* lose old ctty */
		ioctl(STDIN_FILENO, TIOCSCTTY, 0 /* 0: don't forcibly steal */);
		//bb_error_msg("our sid %d", getsid(0));
		//bb_error_msg("our pgrp %d", getpgrp());
		//bb_error_msg("VT's sid %d", tcgetsid(0));
		//bb_error_msg("VT's pgrp %d", tcgetpgrp(0));
		BB_EXECVP_or_die(argv);
	}
}

## Example:

 Input assembly code:
0x00509D73 | 55 | push    rbp
0x00509D74 | 48 89 E5 | mov     rbp, rsp
0x00509D77 | 48 83 EC 10 | sub     rsp, 10h
0x00509D7B | 48 89 7D F8 | mov     [rbp+name], rdi
0x00509D7F | 48 8B 45 F8 | mov     rax, [rbp+name]
0x00509D83 | BE 06 00 00 00 | mov     esi, 6; type
0x00509D88 | 48 89 C7 | mov     rdi, rax; name
0x00509D8B | E8 60 DA EF FF | call    _access
0x00509D90 | 83 F8 FF | cmp     eax, 0FFFFFFFFh
0x00509D93 | 75 22 | jnz     short loc_509DB7
0x00509D95 | 48 8B 45 F8 | mov     rax, [rbp+name]
0x00509D99 | BA B4 01 00 00 | mov     edx, 1B4h
0x00509D9E | BE 41 00 00 00 | mov     esi, 41h ; 'A'; oflag
0x00509DA3 | 48 89 C7 | mov     rdi, rax; file
0x00509DA6 | B8 00 00 00 00 | mov     eax, 0
0x00509DAB | E8 20 D9 EF FF | call    _open64
0x00509DB0 | 89 C7 | mov     edi, eax; fd
0x00509DB2 | E8 59 D0 EF FF | call    _close
0x00509DB7 | 90 | nop
0x00509DB8 | C9 | leave
0x00509DB9 | C3 | retn

 Ourput decompiled code:
static void touch(const char *filename)
{
	if (access(filename, R_OK | W_OK) == -1)
		close(open(filename, O_WRONLY | O_CREAT, 0664));
}

## Example:

 Input assembly code:
0x0040A8DC | 55 | push    rbp
0x0040A8DD | 48 89 E5 | mov     rbp, rsp
0x0040A8E0 | 48 83 EC 10 | sub     rsp, 10h
0x0040A8E4 | 48 89 7D F8 | mov     [rbp+path], rdi
0x0040A8E8 | 48 8B 45 F8 | mov     rax, [rbp+path]
0x0040A8EC | 48 89 C7 | mov     rdi, rax; path
0x0040A8EF | E8 EC BE FF FF | call    _chroot
0x0040A8F4 | 85 C0 | test    eax, eax
0x0040A8F6 | 74 16 | jz      short loc_40A90E
0x0040A8F8 | 48 8B 45 F8 | mov     rax, [rbp+path]
0x0040A8FC | 48 89 C6 | mov     rsi, rax
0x0040A8FF | BF 08 81 52 00 | mov     edi, offset aCanTChangeRoot; "can't change root directory to '%s'"
0x0040A904 | B8 00 00 00 00 | mov     eax, 0
0x0040A909 | E8 94 E9 FF FF | call    sub_4092A2
0x0040A90E | BF 2C 81 52 00 | mov     edi, offset asc_52812C; "/"
0x0040A913 | E8 8F FF FF FF | call    sub_40A8A7
0x0040A918 | 90 | nop
0x0040A919 | C9 | leave
0x0040A91A | C3 | retn

 Ourput decompiled code:
void FAST_FUNC xchroot(const char *path)
{
	if (chroot(path))
		bb_perror_msg_and_die("can't change root directory to '%s'", path);
	xchdir("/");
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0040A670 | 55 | push    rbp
0x0040A671 | 48 89 E5 | mov     rbp, rsp
0x0040A674 | 48 83 EC 10 | sub     rsp, 10h
0x0040A678 | 48 89 7D F8 | mov     [rbp+stream], rdi
0x0040A67C | E8 C8 FF FF FF | call    sub_40A649
0x0040A681 | 48 8B 45 F8 | mov     rax, [rbp+stream]
0x0040A685 | 48 89 C7 | mov     rdi, rax; stream
0x0040A688 | E8 D3 CB FF FF | call    _fileno
0x0040A68D | BE 01 00 00 00 | mov     esi, 1
0x0040A692 | 89 C7 | mov     edi, eax
0x0040A694 | E8 CD 0C 00 00 | call    sub_40B366
0x0040A699 | 48 83 F8 FF | cmp     rax, 0FFFFFFFFFFFFFFFFh
0x0040A69D | 75 05 | jnz     short loc_40A6A4
0x0040A69F | E8 8B F2 FF FF | call    sub_40992F
0x0040A6A4 | 48 8B 45 F8 | mov     rax, [rbp+stream]
0x0040A6A8 | 48 89 C7 | mov     rdi, rax; stream
0x0040A6AB | E8 50 C3 FF FF | call    _fclose
0x0040A6B0 | 90 | nop
0x0040A6B1 | C9 | leave
0x0040A6B2 | C3 | retn
 ************ 
Source Code:
void FAST_FUNC xprint_and_close_file(FILE *file)
{
	fflush_all();
	// copyfd outputs error messages for us.
	if (bb_copyfd_eof(fileno(file), STDOUT_FILENO) == -1)
		xfunc_die();

	fclose(file);
}
 ************ 
Parsed Output:
void close_stream(FILE *stream)
{
    int fd = fileno(stream);
    if (fd != -1)
    {
        if (close(fd) == -1)
        {
            perror("Error closing file");
        }
    }
    fclose(stream);
}
 ************ 
Similarity Score (Unixcoder): 0.7472817897796631
Func rank: 38

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: next_file
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004EDAEE | 55 | push    rbp
0x004EDAEF | 48 89 E5 | mov     rbp, rsp
0x004EDAF2 | 48 83 EC 20 | sub     rsp, 20h
0x004EDAF6 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004EDAFA | 89 75 E4 | mov     [rbp+var_1C], esi
0x004EDAFD | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004EDB01 | 48 89 C7 | mov     rdi, rax
0x004EDB04 | E8 01 FC FF FF | call    sub_4ED70A
0x004EDB09 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x004EDB0D | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004EDB14 | EB 48 | jmp     short loc_4EDB5E
0x004EDB16 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004EDB1A | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004EDB1D | 3C 0A | cmp     al, 0Ah
0x004EDB1F | 74 58 | jz      short loc_4EDB79
0x004EDB21 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004EDB25 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004EDB28 | 3C 09 | cmp     al, 9
0x004EDB2A | 75 0F | jnz     short loc_4EDB3B
0x004EDB2C | 8B 45 FC | mov     eax, [rbp+var_4]
0x004EDB2F | 89 C7 | mov     edi, eax
0x004EDB31 | E8 CF F8 FF FF | call    sub_4ED405
0x004EDB36 | 89 45 FC | mov     [rbp+var_4], eax
0x004EDB39 | EB 1A | jmp     short loc_4EDB55
0x004EDB3B | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004EDB3F | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004EDB42 | 3C 1F | cmp     al, 1Fh
0x004EDB44 | 7E 0B | jle     short loc_4EDB51
0x004EDB46 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004EDB4A | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004EDB4D | 3C 7F | cmp     al, 7Fh
0x004EDB4F | 75 04 | jnz     short loc_4EDB55
0x004EDB51 | 83 45 FC 01 | add     [rbp+var_4], 1
0x004EDB55 | 83 45 FC 01 | add     [rbp+var_4], 1
0x004EDB59 | 48 83 45 E8 01 | add     [rbp+var_18], 1
0x004EDB5E | 8B 45 FC | mov     eax, [rbp+var_4]
0x004EDB61 | 3B 45 E4 | cmp     eax, [rbp+var_1C]
0x004EDB64 | 7D 14 | jge     short loc_4EDB7A
0x004EDB66 | 48 8B 05 9B F8 26 00 | mov     rax, cs:qword_75D408
0x004EDB6D | 48 8B 40 08 | mov     rax, [rax+8]
0x004EDB71 | 48 39 45 E8 | cmp     [rbp+var_18], rax
0x004EDB75 | 72 9F | jb      short loc_4EDB16
0x004EDB77 | EB 01 | jmp     short loc_4EDB7A
0x004EDB79 | 90 | nop
0x004EDB7A | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004EDB7E | C9 | leave
0x004EDB7F | C3 | retn

 Ourput decompiled code:
static char *move_to_col(char *p, int l)
{
	int co;

	p = begin_line(p);
	co = 0;
	while (co < l && p < end) {
		if (*p == '\n') //vda || *p == '\0')
			break;
		if (*p == '\t') {
			co = next_tabstop(co);
		} else if (*p < ' ' || *p == 127) {
			co++; // display as ^X, use 2 columns
		}
		co++;
		p++;
	}
	return p;
}

## Example:

 Input assembly code:
0x00459B82 | 55 | push    rbp
0x00459B83 | 48 89 E5 | mov     rbp, rsp
0x00459B86 | 48 83 EC 20 | sub     rsp, 20h
0x00459B8A | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00459B8E | 48 89 75 E0 | mov     [rbp+src], rsi
0x00459B92 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00459B96 | 48 05 F0 00 00 00 | add     rax, 0F0h
0x00459B9C | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00459BA0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00459BA4 | 48 89 C7 | mov     rdi, rax
0x00459BA7 | E8 78 FF FF FF | call    sub_459B24
0x00459BAC | 89 45 F4 | mov     dword ptr [rbp+n+4], eax
0x00459BAF | 48 8B 45 E0 | mov     rax, [rbp+src]
0x00459BB3 | 48 83 C0 01 | add     rax, 1
0x00459BB7 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00459BBA | 0F B6 C0 | movzx   eax, al
0x00459BBD | 83 C0 02 | add     eax, 2
0x00459BC0 | 89 45 F0 | mov     dword ptr [rbp+n], eax
0x00459BC3 | 8B 55 F4 | mov     edx, dword ptr [rbp+n+4]
0x00459BC6 | 8B 45 F0 | mov     eax, dword ptr [rbp+n]
0x00459BC9 | 01 D0 | add     eax, edx
0x00459BCB | 83 C0 01 | add     eax, 1
0x00459BCE | 3D 33 01 00 00 | cmp     eax, 133h
0x00459BD3 | 76 1D | jbe     short loc_459BF2
0x00459BD5 | 48 8B 45 E0 | mov     rax, [rbp+src]
0x00459BD9 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00459BDC | 0F B6 C0 | movzx   eax, al
0x00459BDF | 89 C6 | mov     esi, eax
0x00459BE1 | BF 28 BC 51 00 | mov     edi, offset aOption0x02xDid; "option 0x%02x did not fit into the pack"...
0x00459BE6 | B8 00 00 00 00 | mov     eax, 0
0x00459BEB | E8 57 FB FA FF | call    sub_409747
0x00459BF0 | EB 41 | jmp     short locret_459C33
0x00459BF2 | 48 8B 45 E0 | mov     rax, [rbp+src]
0x00459BF6 | 48 89 C6 | mov     rsi, rax
0x00459BF9 | BF 52 BC 51 00 | mov     edi, offset aAddingOption; "Adding option"
0x00459BFE | E8 8B FC FF FF | call    sub_45988E
0x00459C03 | 8B 55 F0 | mov     edx, dword ptr [rbp+n]; n
0x00459C06 | 8B 4D F4 | mov     ecx, dword ptr [rbp+n+4]
0x00459C09 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00459C0D | 48 01 C1 | add     rcx, rax
0x00459C10 | 48 8B 45 E0 | mov     rax, [rbp+src]
0x00459C14 | 48 89 C6 | mov     rsi, rax; src
0x00459C17 | 48 89 CF | mov     rdi, rcx; dest
0x00459C1A | E8 81 D5 FA FF | call    _memcpy
0x00459C1F | 8B 55 F4 | mov     edx, dword ptr [rbp+n+4]
0x00459C22 | 8B 45 F0 | mov     eax, dword ptr [rbp+n]
0x00459C25 | 01 D0 | add     eax, edx
0x00459C27 | 89 C2 | mov     edx, eax
0x00459C29 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00459C2D | 48 01 D0 | add     rax, rdx
0x00459C30 | C6 00 FF | mov     byte ptr [rax], 0FFh
0x00459C33 | C9 | leave
0x00459C34 | C3 | retn

 Ourput decompiled code:
void FAST_FUNC udhcp_add_binary_option(struct dhcp_packet *packet, uint8_t *addopt)
{
	unsigned len;
	uint8_t *optionptr = packet->options;
	unsigned end = udhcp_end_option(optionptr);

	len = OPT_DATA + addopt[OPT_LEN];
	/* end position + (option code/length + addopt length) + end option */
	if (end + len + 1 >= DHCP_OPTIONS_BUFSIZE) {
//TODO: learn how to use overflow option if we exhaust packet->options[]
		bb_error_msg("option 0x%02x did not fit into the packet",
				addopt[OPT_CODE]);
		return;
	}
	log_option("Adding option", addopt);
	memcpy(optionptr + end, addopt, len);
	optionptr[end + len] = DHCP_END;
}

## Example:

 Input assembly code:
0x00432276 | 55 | push    rbp
0x00432277 | 48 89 E5 | mov     rbp, rsp
0x0043227A | 48 83 EC 20 | sub     rsp, 20h
0x0043227E | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00432282 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00432286 | 48 8B 00 | mov     rax, [rax]
0x00432289 | 48 89 C7 | mov     rdi, rax
0x0043228C | E8 23 71 FD FF | call    sub_4093B4
0x00432291 | 48 89 45 F0 | mov     [rbp+s], rax
0x00432295 | 48 8B 45 F0 | mov     rax, [rbp+s]
0x00432299 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0043229C | 84 C0 | test    al, al
0x0043229E | 75 07 | jnz     short loc_4322A7
0x004322A0 | B8 00 00 00 00 | mov     eax, 0
0x004322A5 | EB 5A | jmp     short locret_432301
0x004322A7 | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004322AB | BE 08 8F 51 00 | mov     esi, offset asc_518F08; " \t\n"
0x004322B0 | 48 89 C7 | mov     rdi, rax; s
0x004322B3 | E8 28 4C FD FF | call    _strcspn
0x004322B8 | 89 45 FC | mov     [rbp+var_4], eax
0x004322BB | 8B 55 FC | mov     edx, [rbp+var_4]
0x004322BE | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004322C2 | 48 01 D0 | add     rax, rdx
0x004322C5 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004322C8 | 84 C0 | test    al, al
0x004322CA | 74 15 | jz      short loc_4322E1
0x004322CC | 8B 45 FC | mov     eax, [rbp+var_4]
0x004322CF | 8D 50 01 | lea     edx, [rax+1]
0x004322D2 | 89 55 FC | mov     [rbp+var_4], edx
0x004322D5 | 89 C2 | mov     edx, eax
0x004322D7 | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004322DB | 48 01 D0 | add     rax, rdx
0x004322DE | C6 00 00 | mov     byte ptr [rax], 0
0x004322E1 | 8B 55 FC | mov     edx, [rbp+var_4]
0x004322E4 | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004322E8 | 48 01 D0 | add     rax, rdx
0x004322EB | 48 89 C7 | mov     rdi, rax
0x004322EE | E8 C1 70 FD FF | call    sub_4093B4
0x004322F3 | 48 89 C2 | mov     rdx, rax
0x004322F6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004322FA | 48 89 10 | mov     [rax], rdx
0x004322FD | 48 8B 45 F0 | mov     rax, [rbp+s]
0x00432301 | C9 | leave
0x00432302 | C3 | retn

 Ourput decompiled code:
static char *next_word(char **buf)
{
	unsigned length;
	char *word;

	/* Skip over leading whitespace */
	word = skip_whitespace(*buf);

	/* Stop on EOL */
	if (*word == '\0')
		return NULL;

	/* Find the length of this word (can't be 0) */
	length = strcspn(word, " \t\n");

	/* Unless we are already at NUL, store NUL and advance */
	if (word[length] != '\0')
		word[length++] = '\0';

	*buf = skip_whitespace(word + length);

	return word;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004D1E04 | 55 | push    rbp
0x004D1E05 | 48 89 E5 | mov     rbp, rsp
0x004D1E08 | 48 83 EC 30 | sub     rsp, 30h
0x004D1E0C | 48 89 7D D8 | mov     [rbp+s], rdi
0x004D1E10 | 89 75 D4 | mov     [rbp+var_2C], esi
0x004D1E13 | 48 8B 45 D8 | mov     rax, [rbp+s]
0x004D1E17 | 48 89 C7 | mov     rdi, rax; s
0x004D1E1A | E8 B1 4C F3 FF | call    _strlen
0x004D1E1F | 48 89 45 F0 | mov     [rbp+var_10], rax
0x004D1E23 | C7 45 FC 01 00 00 00 | mov     [rbp+var_4], 1
0x004D1E2A | 8B 45 FC | mov     eax, [rbp+var_4]
0x004D1E2D | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x004D1E31 | 48 29 C2 | sub     rdx, rax
0x004D1E34 | 48 8B 45 D8 | mov     rax, [rbp+s]
0x004D1E38 | 48 01 D0 | add     rax, rdx
0x004D1E3B | 48 89 45 E8 | mov     [rbp+var_18], rax
0x004D1E3F | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D1E43 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004D1E46 | 3C 79 | cmp     al, 79h ; 'y'
0x004D1E48 | 7F 19 | jg      short loc_4D1E63
0x004D1E4A | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D1E4E | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004D1E51 | 83 C0 01 | add     eax, 1
0x004D1E54 | 89 C2 | mov     edx, eax
0x004D1E56 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D1E5A | 88 10 | mov     [rax], dl
0x004D1E5C | 90 | nop
0x004D1E5D | 48 8B 45 D8 | mov     rax, [rbp+s]
0x004D1E61 | EB 1C | jmp     short locret_4D1E7F
0x004D1E63 | 83 45 FC 01 | add     [rbp+var_4], 1
0x004D1E67 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004D1E6A | 3B 45 D4 | cmp     eax, [rbp+var_2C]
0x004D1E6D | 76 07 | jbe     short loc_4D1E76
0x004D1E6F | B8 00 00 00 00 | mov     eax, 0
0x004D1E74 | EB 09 | jmp     short locret_4D1E7F
0x004D1E76 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D1E7A | C6 00 61 | mov     byte ptr [rax], 61h ; 'a'
0x004D1E7D | EB AB | jmp     short loc_4D1E2A
0x004D1E7F | C9 | leave
0x004D1E80 | C3 | retn
 ************ 
Source Code:
static char *next_file(char *old, unsigned suffix_len)
{
	size_t end = strlen(old);
	unsigned i = 1;
	char *curr;

	while (1) {
		curr = old + end - i;
		if (*curr < 'z') {
			*curr += 1;
			break;
		}
		i++;
		if (i > suffix_len) {
			return NULL;
		}
		*curr = 'a';
	}

	return old;
}
 ************ 
Parsed Output:
static void modify_string(char *s, int len)
{
    int i;
    for (i = 0; i < len; i++) {
        if (s[i] <= 'y') {
            s[i]++;
        } else {
            s[i] = 'a';
        }
    }
}
 ************ 
Similarity Score (Unixcoder): 0.7361775636672974
Func rank: 39

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: llist_find_str
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004C03B7 | 55 | push    rbp
0x004C03B8 | 48 89 E5 | mov     rbp, rsp
0x004C03BB | 48 83 EC 10 | sub     rsp, 10h
0x004C03BF | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004C03C3 | 48 89 75 F0 | mov     [rbp+name], rsi
0x004C03C7 | EB 31 | jmp     short loc_4C03FA
0x004C03C9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C03CD | 48 8B 40 08 | mov     rax, [rax+8]
0x004C03D1 | 48 8B 4D F0 | mov     rcx, [rbp+name]
0x004C03D5 | BA 00 00 00 00 | mov     edx, 0; flags
0x004C03DA | 48 89 CE | mov     rsi, rcx; name
0x004C03DD | 48 89 C7 | mov     rdi, rax; pattern
0x004C03E0 | E8 3B 69 F4 FF | call    _fnmatch
0x004C03E5 | 85 C0 | test    eax, eax
0x004C03E7 | 75 06 | jnz     short loc_4C03EF
0x004C03E9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C03ED | EB 17 | jmp     short locret_4C0406
0x004C03EF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C03F3 | 48 8B 00 | mov     rax, [rax]
0x004C03F6 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004C03FA | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004C03FF | 75 C8 | jnz     short loc_4C03C9
0x004C0401 | B8 00 00 00 00 | mov     eax, 0
0x004C0406 | C9 | leave
0x004C0407 | C3 | retn

 Ourput decompiled code:
FAST_FUNC find_list_entry(const llist_t *list, const char *filename)
{
	while (list) {
		if (fnmatch(list->data, filename, 0) == 0) {
			return list;
		}
		list = list->link;
	}
	return NULL;
}

## Example:

 Input assembly code:
0x0045942D | 55 | push    rbp
0x0045942E | 48 89 E5 | mov     rbp, rsp
0x00459431 | 48 83 EC 10 | sub     rsp, 10h
0x00459435 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00459439 | 48 89 75 F0 | mov     [rbp+s2], rsi
0x0045943D | EB 34 | jmp     short loc_459473
0x0045943F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00459443 | 48 8D 48 0C | lea     rcx, [rax+0Ch]
0x00459447 | 48 8B 45 F0 | mov     rax, [rbp+s2]
0x0045944B | BA 06 00 00 00 | mov     edx, 6; n
0x00459450 | 48 89 C6 | mov     rsi, rax; s2
0x00459453 | 48 89 CF | mov     rdi, rcx; s1
0x00459456 | E8 05 DB FA FF | call    _memcmp
0x0045945B | 85 C0 | test    eax, eax
0x0045945D | 75 09 | jnz     short loc_459468
0x0045945F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00459463 | 8B 40 08 | mov     eax, [rax+8]
0x00459466 | EB 17 | jmp     short locret_45947F
0x00459468 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045946C | 48 8B 00 | mov     rax, [rax]
0x0045946F | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00459473 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00459478 | 75 C5 | jnz     short loc_45943F
0x0045947A | B8 00 00 00 00 | mov     eax, 0
0x0045947F | C9 | leave
0x00459480 | C3 | retn

 Ourput decompiled code:
uint32_t FAST_FUNC get_static_nip_by_mac(struct static_lease *st_lease, void *mac)
{
	while (st_lease) {
		if (memcmp(st_lease->mac, mac, 6) == 0)
			return st_lease->nip;
		st_lease = st_lease->next;
	}

	return 0;
}

## Example:

 Input assembly code:
0x00409018 | 55 | push    rbp
0x00409019 | 48 89 E5 | mov     rbp, rsp
0x0040901C | 48 83 EC 10 | sub     rsp, 10h
0x00409020 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00409024 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x00409028 | EB 0B | jmp     short loc_409035
0x0040902A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040902E | 48 8B 00 | mov     rax, [rax]
0x00409031 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00409035 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00409039 | 48 8B 00 | mov     rax, [rax]
0x0040903C | 48 85 C0 | test    rax, rax
0x0040903F | 75 E9 | jnz     short loc_40902A
0x00409041 | BF 10 00 00 00 | mov     edi, 10h
0x00409046 | E8 9D 10 00 00 | call    sub_40A0E8
0x0040904B | 48 89 C2 | mov     rdx, rax
0x0040904E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00409052 | 48 89 10 | mov     [rax], rdx
0x00409055 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00409059 | 48 8B 00 | mov     rax, [rax]
0x0040905C | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x00409060 | 48 89 50 08 | mov     [rax+8], rdx
0x00409064 | 90 | nop
0x00409065 | C9 | leave
0x00409066 | C3 | retn

 Ourput decompiled code:
void FAST_FUNC llist_add_to_end(llist_t **list_head, void *data)
{
	while (*list_head)
		list_head = &(*list_head)->link;
	*list_head = xzalloc(sizeof(llist_t));
	(*list_head)->data = data;
	/*(*list_head)->link = NULL;*/
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00409191 | 55 | push    rbp
0x00409192 | 48 89 E5 | mov     rbp, rsp
0x00409195 | 48 83 EC 10 | sub     rsp, 10h
0x00409199 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0040919D | 48 89 75 F0 | mov     [rbp+s2], rsi
0x004091A1 | EB 26 | jmp     short loc_4091C9
0x004091A3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004091A7 | 48 8B 40 08 | mov     rax, [rax+8]
0x004091AB | 48 8B 55 F0 | mov     rdx, [rbp+s2]
0x004091AF | 48 89 D6 | mov     rsi, rdx; s2
0x004091B2 | 48 89 C7 | mov     rdi, rax; s1
0x004091B5 | E8 96 DE FF FF | call    _strcmp
0x004091BA | 85 C0 | test    eax, eax
0x004091BC | 74 14 | jz      short loc_4091D2
0x004091BE | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004091C2 | 48 8B 00 | mov     rax, [rax]
0x004091C5 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004091C9 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004091CE | 75 D3 | jnz     short loc_4091A3
0x004091D0 | EB 01 | jmp     short loc_4091D3
0x004091D2 | 90 | nop
0x004091D3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004091D7 | C9 | leave
0x004091D8 | C3 | retn
 ************ 
Source Code:
FAST_FUNC llist_find_str(llist_t *list, const char *str)
{
	while (list) {
		if (strcmp(list->data, str) == 0)
			break;
		list = list->link;
	}
	return list;
}
 ************ 
Parsed Output:
void FAST_FUNC find_string(const char *s1, const char *s2)
{
    while (s1) {
        if (strcmp(s1, s2) == 0) {
            return;
        }
        s1 = s1->next;
    }
}
 ************ 
Similarity Score (Unixcoder): 0.7354922890663147
Func rank: 40

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: set_pwd_var
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004B2837 | 55 | push    rbp
0x004B2838 | 48 89 E5 | mov     rbp, rsp
0x004B283B | 48 83 EC 10 | sub     rsp, 10h
0x004B283F | 89 7D FC | mov     [rbp+hostlong], edi
0x004B2842 | 8B 45 FC | mov     eax, [rbp+hostlong]
0x004B2845 | 89 C7 | mov     edi, eax; hostlong
0x004B2847 | E8 E4 44 F5 FF | call    _htonl
0x004B284C | 89 45 FC | mov     [rbp+hostlong], eax
0x004B284F | 48 8D 45 FC | lea     rax, [rbp+hostlong]
0x004B2853 | BA 04 00 00 00 | mov     edx, 4
0x004B2858 | 48 89 C6 | mov     rsi, rax
0x004B285B | BF 01 00 00 00 | mov     edi, 1
0x004B2860 | E8 46 7C F5 FF | call    sub_40A4AB
0x004B2865 | 90 | nop
0x004B2866 | C9 | leave
0x004B2867 | C3 | retn

 Ourput decompiled code:
static void write32(uint32_t v)
{
	v = htonl(v);
	xwrite(1, &v, 4);
}

## Example:

 Input assembly code:
0x00429778 | 55 | push    rbp
0x00429779 | 48 89 E5 | mov     rbp, rsp
0x0042977C | 48 83 EC 10 | sub     rsp, 10h
0x00429780 | 89 7D FC | mov     [rbp+var_4], edi
0x00429783 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00429786 | BE 7C B2 52 00 | mov     esi, offset aFeatures; "-Features:"
0x0042978B | 89 C7 | mov     edi, eax
0x0042978D | E8 FC FC FF FF | call    sub_42948E
0x00429792 | BF 88 B2 52 00 | mov     edi, offset aEpsvPasvRestSt; " EPSV\r\n PASV\r\n REST STREAM\r\n MDTM"...
0x00429797 | E8 1C FE FF FF | call    sub_4295B8
0x0042979C | 8B 45 FC | mov     eax, [rbp+var_4]
0x0042979F | BE B3 B2 52 00 | mov     esi, offset aOk; " Ok"
0x004297A4 | 89 C7 | mov     edi, eax
0x004297A6 | E8 E3 FC FF FF | call    sub_42948E
0x004297AB | 90 | nop
0x004297AC | C9 | leave
0x004297AD | C3 | retn

 Ourput decompiled code:
static void
handle_feat(unsigned status)
{
	cmdio_write(status, "-Features:");
	cmdio_write_raw(" EPSV\r\n"
			" PASV\r\n"
			" REST STREAM\r\n"
			" MDTM\r\n"
			" SIZE\r\n");
	cmdio_write(status, " Ok");
}

## Example:

 Input assembly code:
0x00490876 | 55 | push    rbp
0x00490877 | 48 89 E5 | mov     rbp, rsp
0x0049087A | 48 83 EC 10 | sub     rsp, 10h
0x0049087E | 89 7D FC | mov     [rbp+var_4], edi
0x00490881 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x00490885 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00490888 | 89 C7 | mov     edi, eax
0x0049088A | E8 26 FD FF FF | call    sub_4905B5
0x0049088F | 48 8B 05 72 CB 2C 00 | mov     rax, cs:qword_75D408
0x00490896 | 8B 40 18 | mov     eax, [rax+18h]
0x00490899 | 89 C2 | mov     edx, eax
0x0049089B | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0049089F | 48 89 C6 | mov     rsi, rax
0x004908A2 | BF 03 00 00 00 | mov     edi, 3
0x004908A7 | E8 FF 9B F7 FF | call    sub_40A4AB
0x004908AC | 90 | nop
0x004908AD | C9 | leave
0x004908AE | C3 | retn

 Ourput decompiled code:
static void
write_sector(sector_t secno, const void *buf)
{
	seek_sector(secno);
	xwrite(dev_fd, buf, sector_size);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00480BCB | 55 | push    rbp
0x00480BCC | 48 89 E5 | mov     rbp, rsp
0x00480BCF | 48 83 EC 10 | sub     rsp, 10h
0x00480BD3 | 89 7D FC | mov     [rbp+var_4], edi
0x00480BD6 | BF 01 00 00 00 | mov     edi, 1
0x00480BDB | E8 FD FA FF FF | call    sub_4806DD
0x00480BE0 | 48 89 C6 | mov     rsi, rax
0x00480BE3 | BF 2B E6 51 00 | mov     edi, offset aPwdS; "PWD=%s"
0x00480BE8 | B8 00 00 00 00 | mov     eax, 0
0x00480BED | E8 C1 9A F8 FF | call    sub_40A6B3
0x00480BF2 | 48 89 C1 | mov     rcx, rax
0x00480BF5 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00480BF8 | BA 00 00 00 00 | mov     edx, 0
0x00480BFD | 89 C6 | mov     esi, eax
0x00480BFF | 48 89 CF | mov     rdi, rcx
0x00480C02 | E8 12 FD FF FF | call    sub_480919
0x00480C07 | 90 | nop
0x00480C08 | C9 | leave
0x00480C09 | C3 | retn
 ************ 
Source Code:
static void set_pwd_var(int exp)
{
	set_local_var(xasprintf("PWD=%s", get_cwd(/*force:*/ 1)),
		/*exp:*/ exp, /*lvl:*/ 0, /*ro:*/ 0);
}
 ************ 
Parsed Output:
static void print_pwd(int status)
{
    int fd = 1;
    char buf[256];
    snprintf(buf, sizeof(buf), "PWD=%s", getcwd(NULL, 0));
    xwrite(fd, buf, strlen(buf));
}
 ************ 
Similarity Score (Unixcoder): 0.7345856428146362
Func rank: 41

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: setlogcons_main
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0042408D | 55 | push    rbp
0x0042408E | 48 89 E5 | mov     rbp, rsp
0x00424091 | 48 83 EC 40 | sub     rsp, 40h
0x00424095 | 89 7D CC | mov     [rbp+var_34], edi
0x00424098 | 48 89 75 C0 | mov     [rbp+var_40], rsi
0x0042409C | 48 C7 45 F8 FE 56 53 00 | mov     [rbp+var_8], offset aDevCdrom_0; "/dev/cdrom"
0x004240A4 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004240A8 | 48 83 C0 08 | add     rax, 8
0x004240AC | 48 8B 00 | mov     rax, [rax]
0x004240AF | 48 85 C0 | test    rax, rax
0x004240B2 | 74 21 | jz      short loc_4240D5
0x004240B4 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004240B8 | 48 8B 40 08 | mov     rax, [rax+8]
0x004240BC | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004240C0 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004240C4 | 48 83 C0 10 | add     rax, 10h
0x004240C8 | 48 8B 00 | mov     rax, [rax]
0x004240CB | 48 85 C0 | test    rax, rax
0x004240CE | 74 05 | jz      short loc_4240D5
0x004240D0 | E8 8F 3E FE FF | call    sub_407F64
0x004240D5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004240D9 | BE 00 00 00 00 | mov     esi, 0
0x004240DE | 48 89 C7 | mov     rdi, rax
0x004240E1 | E8 AF 61 FE FF | call    sub_40A295
0x004240E6 | 89 45 F4 | mov     [rbp+var_C], eax
0x004240E9 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x004240EC | BA 00 00 00 00 | mov     edx, 0
0x004240F1 | BE 28 80 00 00 | mov     esi, 8028h
0x004240F6 | 89 C7 | mov     edi, eax
0x004240F8 | E8 5A 64 FE FF | call    sub_40A557
0x004240FD | 48 8D 4D D0 | lea     rcx, [rbp+var_30]
0x00424101 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00424104 | BA 20 00 00 00 | mov     edx, 20h ; ' '
0x00424109 | 48 89 CE | mov     rsi, rcx
0x0042410C | 89 C7 | mov     edi, eax
0x0042410E | E8 3F 33 0E 00 | call    sub_507452
0x00424113 | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00424117 | 48 89 C6 | mov     rsi, rax
0x0042411A | BF 09 57 53 00 | mov     edi, offset a3232s; "%32.32s\n"
0x0042411F | B8 00 00 00 00 | mov     eax, 0
0x00424124 | E8 A7 2A FE FF | call    _printf
0x00424129 | B8 00 00 00 00 | mov     eax, 0
0x0042412E | C9 | leave
0x0042412F | C3 | retn

 Ourput decompiled code:
int volname_main(int argc UNUSED_PARAM, char **argv)
{
	int fd;
	char buffer[32];
	const char *device;

	device = "/dev/cdrom";
	if (argv[1]) {
		device = argv[1];
		if (argv[2])
			bb_show_usage();
	}

	fd = xopen(device, O_RDONLY);
	xlseek(fd, 32808, SEEK_SET);
	xread(fd, buffer, 32);
	printf("%32.32s\n", buffer);
	if (ENABLE_FEATURE_CLEAN_UP) {
		close(fd);
	}
	return 0;
}

## Example:

 Input assembly code:
0x00479364 | 55 | push    rbp
0x00479365 | 48 89 E5 | mov     rbp, rsp
0x00479368 | 48 83 EC 10 | sub     rsp, 10h
0x0047936C | 89 7D FC | mov     [rbp+var_4], edi
0x0047936F | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x00479373 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00479377 | 48 83 C0 08 | add     rax, 8
0x0047937B | 48 8B 00 | mov     rax, [rax]
0x0047937E | 48 85 C0 | test    rax, rax
0x00479381 | 74 4C | jz      short loc_4793CF
0x00479383 | 48 8B 05 8E 40 2E 00 | mov     rax, cs:qword_75D418
0x0047938A | C6 40 3C 00 | mov     byte ptr [rax+3Ch], 0
0x0047938E | 48 8B 05 83 40 2E 00 | mov     rax, cs:qword_75D418
0x00479395 | C6 40 3D 00 | mov     byte ptr [rax+3Dh], 0
0x00479399 | E8 E9 F9 FF FF | call    sub_478D87
0x0047939E | 48 8B 05 7B 40 2E 00 | mov     rax, cs:qword_75D420
0x004793A5 | 48 05 60 01 00 00 | add     rax, 160h
0x004793AB | 48 83 C0 20 | add     rax, 20h ; ' '
0x004793AF | 48 8B 40 10 | mov     rax, [rax+10h]
0x004793B3 | 48 8D 48 05 | lea     rcx, [rax+5]
0x004793B7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004793BB | 48 83 C0 08 | add     rax, 8
0x004793BF | BA 00 00 00 00 | mov     edx, 0
0x004793C4 | 48 89 CE | mov     rsi, rcx
0x004793C7 | 48 89 C7 | mov     rdi, rax
0x004793CA | E8 06 D9 FF FF | call    sub_476CD5
0x004793CF | B8 00 00 00 00 | mov     eax, 0
0x004793D4 | C9 | leave
0x004793D5 | C3 | retn

 Ourput decompiled code:
static int FAST_FUNC
execcmd(int argc UNUSED_PARAM, char **argv)
{
	if (argv[1]) {
		iflag = 0;              /* exit on error */
		mflag = 0;
		optschanged();
		shellexec(argv + 1, pathval(), 0);
	}
	return 0;
}

## Example:

 Input assembly code:
0x004C35B6 | 55 | push    rbp
0x004C35B7 | 48 89 E5 | mov     rbp, rsp
0x004C35BA | 53 | push    rbx
0x004C35BB | 48 83 EC 28 | sub     rsp, 28h
0x004C35BF | 89 7D DC | mov     [rbp+var_24], edi
0x004C35C2 | 48 89 75 D0 | mov     [rbp+var_30], rsi
0x004C35C6 | C7 45 EC 00 00 00 00 | mov     [rbp+var_14], 0
0x004C35CD | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004C35D1 | 48 83 C0 08 | add     rax, 8
0x004C35D5 | 48 8B 00 | mov     rax, [rax]
0x004C35D8 | 48 85 C0 | test    rax, rax
0x004C35DB | 74 35 | jz      short loc_4C3612
0x004C35DD | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004C35E1 | 48 83 C0 10 | add     rax, 10h
0x004C35E5 | 48 8B 00 | mov     rax, [rax]
0x004C35E8 | 48 85 C0 | test    rax, rax
0x004C35EB | 74 05 | jz      short loc_4C35F2
0x004C35ED | E8 72 49 F4 FF | call    sub_407F64
0x004C35F2 | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004C35F6 | 48 83 C0 08 | add     rax, 8
0x004C35FA | 48 8B 00 | mov     rax, [rax]
0x004C35FD | BA 3F 00 00 00 | mov     edx, 3Fh ; '?'
0x004C3602 | BE 01 00 00 00 | mov     esi, 1
0x004C3607 | 48 89 C7 | mov     rdi, rax
0x004C360A | E8 8D 7A 04 00 | call    sub_50B09C
0x004C360F | 89 45 EC | mov     [rbp+var_14], eax
0x004C3612 | 8B 45 EC | mov     eax, [rbp+var_14]
0x004C3615 | 48 98 | cdqe
0x004C3617 | 48 89 C3 | mov     rbx, rax
0x004C361A | E8 05 67 03 00 | call    sub_4F9D24
0x004C361F | B9 DF 68 53 00 | mov     ecx, offset aVtDisallocate; "VT_DISALLOCATE"
0x004C3624 | 48 89 DA | mov     rdx, rbx
0x004C3627 | BE 08 56 00 00 | mov     esi, 5608h
0x004C362C | 89 C7 | mov     edi, eax
0x004C362E | E8 1E 77 F4 FF | call    sub_40AD51
0x004C3633 | B8 00 00 00 00 | mov     eax, 0
0x004C3638 | 48 83 C4 28 | add     rsp, 28h
0x004C363C | 5B | pop     rbx
0x004C363D | 5D | pop     rbp
0x004C363E | C3 | retn

 Ourput decompiled code:
int deallocvt_main(int argc UNUSED_PARAM, char **argv)
{
	/* num = 0 deallocate all unused consoles */
	int num = 0;

	if (argv[1]) {
		if (argv[2])
			bb_show_usage();
		num = xatou_range(argv[1], 1, 63);
	}

	/* double cast suppresses "cast to ptr from int of different size" */
	xioctl(get_console_fd_or_die(), VT_DISALLOCATE, (void *)(ptrdiff_t)num);
	return EXIT_SUCCESS;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004C49F4 | 55 | push    rbp
0x004C49F5 | 48 89 E5 | mov     rbp, rsp
0x004C49F8 | 48 83 EC 20 | sub     rsp, 20h
0x004C49FC | 89 7D EC | mov     [rbp+var_14], edi
0x004C49FF | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004C4A03 | C6 45 FE 0B | mov     [rbp+var_2], 0Bh
0x004C4A07 | C6 45 FF 00 | mov     [rbp+var_1], 0
0x004C4A0B | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004C4A0F | 48 83 C0 08 | add     rax, 8
0x004C4A13 | 48 8B 00 | mov     rax, [rax]
0x004C4A16 | 48 85 C0 | test    rax, rax
0x004C4A19 | 74 20 | jz      short loc_4C4A3B
0x004C4A1B | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004C4A1F | 48 83 C0 08 | add     rax, 8
0x004C4A23 | 48 8B 00 | mov     rax, [rax]
0x004C4A26 | BA 3F 00 00 00 | mov     edx, 3Fh ; '?'
0x004C4A2B | BE 00 00 00 00 | mov     esi, 0
0x004C4A30 | 48 89 C7 | mov     rdi, rax
0x004C4A33 | E8 64 66 04 00 | call    sub_50B09C
0x004C4A38 | 88 45 FF | mov     [rbp+var_1], al
0x004C4A3B | BE 00 00 00 00 | mov     esi, 0
0x004C4A40 | BF 4C 6A 53 00 | mov     edi, offset aDevTty1; "/dev/tty1"
0x004C4A45 | E8 4B 58 F4 FF | call    sub_40A295
0x004C4A4A | 89 C7 | mov     edi, eax
0x004C4A4C | 48 8D 45 FE | lea     rax, [rbp+var_2]
0x004C4A50 | B9 56 6A 53 00 | mov     ecx, offset aTioclinux; "TIOCLINUX"
0x004C4A55 | 48 89 C2 | mov     rdx, rax
0x004C4A58 | BE 1C 54 00 00 | mov     esi, 541Ch
0x004C4A5D | E8 EF 62 F4 FF | call    sub_40AD51
0x004C4A62 | B8 00 00 00 00 | mov     eax, 0
0x004C4A67 | C9 | leave
0x004C4A68 | C3 | retn
 ************ 
Source Code:
int setlogcons_main(int argc UNUSED_PARAM, char **argv)
{
	struct {
		char fn;
		char subarg;
	} arg = {
		11, /* redirect kernel messages */
		0   /* to specified console (current as default) */
	};

	if (argv[1])
		arg.subarg = xatou_range(argv[1], 0, 63);

	xioctl(xopen(VC_1, O_RDONLY), TIOCLINUX, &arg);

	return EXIT_SUCCESS;
}
 ************ 
Parsed Output:
int main(int argc UNUSED_PARAM, char **argv)
{
    int var_2 = 0x0B;
    int var_1 = 0;

    if (argv[1]) {
        if (argv[2])
            bb_show_usage();
        var_1 = sub_50B09C(argv[1], 0x3F);
    }

    sub_40A295("/dev/tty1");
    sub_40AD51("TIOCLINUX", &var_2, 0x541C);

    return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.7312637567520142
Func rank: 42

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: builtin_exec
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0048931C | 55 | push    rbp
0x0048931D | 48 89 E5 | mov     rbp, rsp
0x00489320 | 48 83 EC 10 | sub     rsp, 10h
0x00489324 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00489328 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048932C | 48 89 C7 | mov     rdi, rax
0x0048932F | E8 19 FE FF FF | call    sub_48914D
0x00489334 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00489338 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048933C | 48 8B 00 | mov     rax, [rax]
0x0048933F | 48 85 C0 | test    rax, rax
0x00489342 | 75 15 | jnz     short loc_489359
0x00489344 | 48 8B 05 BD 40 2D 00 | mov     rax, cs:qword_75D408
0x0048934B | 0F B6 40 4F | movzx   eax, byte ptr [rax+4Fh]
0x0048934F | 0F B6 C0 | movzx   eax, al
0x00489352 | 89 C7 | mov     edi, eax
0x00489354 | E8 F1 70 FF FF | call    sub_48044A
0x00489359 | C6 05 E8 1A 2D 00 FF | mov     cs:byte_75AE48, 0FFh
0x00489360 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00489364 | 48 8B 00 | mov     rax, [rax]
0x00489367 | 48 89 C7 | mov     rdi, rax
0x0048936A | E8 68 1F 08 00 | call    sub_50B2D7
0x0048936F | 0F B6 C0 | movzx   eax, al
0x00489372 | 89 C7 | mov     edi, eax
0x00489374 | E8 D1 70 FF FF | call    sub_48044A

 Ourput decompiled code:
static int FAST_FUNC builtin_exit(char **argv)
{
	debug_printf_exec("%s()\n", __func__);

	/* interactive bash:
	 * # trap "echo EEE" EXIT
	 * # exit
	 * exit
	 * There are stopped jobs.
	 * (if there are _stopped_ jobs, running ones don't count)
	 * # exit
	 * exit
	 * EEE (then bash exits)
	 *
	 * TODO: we can use G.exiting = -1 as indicator "last cmd was exit"
	 */

	/* note: EXIT trap is run by hush_exit */
	argv = skip_dash_dash(argv);
	if (argv[0] == NULL)
		hush_exit(G.last_exitcode);
	/* mimic bash: exit 123abc == exit 255 + error msg */
	xfunc_error_retval = 255;
	/* bash: exit -2 == exit 254, no error msg */
	hush_exit(xatoi(argv[0]) & 0xff);
}

## Example:

 Input assembly code:
0x004367CC | 55 | push    rbp
0x004367CD | 48 89 E5 | mov     rbp, rsp
0x004367D0 | 48 83 EC 10 | sub     rsp, 10h
0x004367D4 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004367D8 | 89 75 F4 | mov     [rbp+var_C], esi
0x004367DB | 48 8B 05 9E 49 32 00 | mov     rax, cs:ptr
0x004367E2 | 48 89 C7 | mov     rdi, rax; ptr
0x004367E5 | E8 76 FE FC FF | call    _free
0x004367EA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004367EE | 0F B7 00 | movzx   eax, word ptr [rax]
0x004367F1 | 66 83 F8 FF | cmp     ax, 0FFFFh
0x004367F5 | 74 0C | jz      short loc_436803
0x004367F7 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004367FB | 0F B7 00 | movzx   eax, word ptr [rax]
0x004367FE | 66 85 C0 | test    ax, ax
0x00436801 | 75 07 | jnz     short loc_43680A
0x00436803 | B8 20 95 51 00 | mov     eax, offset aNoneSet; "[NONE SET]"
0x00436808 | EB 24 | jmp     short locret_43682E
0x0043680A | 8B 4D F4 | mov     ecx, [rbp+var_C]
0x0043680D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00436811 | BA 00 FF FF FF | mov     edx, 0FFFFFF00h
0x00436816 | 89 CE | mov     esi, ecx
0x00436818 | 48 89 C7 | mov     rdi, rax
0x0043681B | E8 91 6E 0C 00 | call    sub_4FD6B1
0x00436820 | 48 89 05 59 49 32 00 | mov     cs:ptr, rax
0x00436827 | 48 8B 05 52 49 32 00 | mov     rax, cs:ptr
0x0043682E | C9 | leave
0x0043682F | C3 | retn

 Ourput decompiled code:
FAST_FUNC INET_sprint(struct sockaddr *sap, int numeric)
{
	static char *buff; /* defaults to NULL */

	free(buff);
	if (sap->sa_family == 0xFFFF || sap->sa_family == 0)
		return "[NONE SET]";
	buff = INET_rresolve((struct sockaddr_in *) sap, numeric, 0xffffff00);
	return buff;
}

## Example:

 Input assembly code:
0x0043685A | 55 | push    rbp
0x0043685B | 48 89 E5 | mov     rbp, rsp
0x0043685E | 48 83 EC 10 | sub     rsp, 10h
0x00436862 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00436866 | 89 75 F4 | mov     [rbp+var_C], esi
0x00436869 | 48 8B 05 18 49 32 00 | mov     rax, cs:qword_75B188
0x00436870 | 48 89 C7 | mov     rdi, rax; ptr
0x00436873 | E8 E8 FD FC FF | call    _free
0x00436878 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043687C | 0F B7 00 | movzx   eax, word ptr [rax]
0x0043687F | 66 83 F8 FF | cmp     ax, 0FFFFh
0x00436883 | 74 0C | jz      short loc_436891
0x00436885 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00436889 | 0F B7 00 | movzx   eax, word ptr [rax]
0x0043688C | 66 85 C0 | test    ax, ax
0x0043688F | 75 07 | jnz     short loc_436898
0x00436891 | B8 20 95 51 00 | mov     eax, offset aNoneSet; "[NONE SET]"
0x00436896 | EB 1F | jmp     short locret_4368B7
0x00436898 | 8B 55 F4 | mov     edx, [rbp+var_C]
0x0043689B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043689F | 89 D6 | mov     esi, edx
0x004368A1 | 48 89 C7 | mov     rdi, rax
0x004368A4 | E8 B6 70 0C 00 | call    sub_4FD95F
0x004368A9 | 48 89 05 D8 48 32 00 | mov     cs:qword_75B188, rax
0x004368B0 | 48 8B 05 D1 48 32 00 | mov     rax, cs:qword_75B188
0x004368B7 | C9 | leave
0x004368B8 | C3 | retn

 Ourput decompiled code:
FAST_FUNC INET6_sprint(struct sockaddr *sap, int numeric)
{
	static char *buff;

	free(buff);
	if (sap->sa_family == 0xFFFF || sap->sa_family == 0)
		return "[NONE SET]";
	buff = INET6_rresolve((struct sockaddr_in6 *) sap, numeric);
	return buff;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004892A0 | 55 | push    rbp
0x004892A1 | 48 89 E5 | mov     rbp, rsp
0x004892A4 | 48 83 EC 10 | sub     rsp, 10h
0x004892A8 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004892AC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004892B0 | 48 89 C7 | mov     rdi, rax
0x004892B3 | E8 95 FE FF FF | call    sub_48914D
0x004892B8 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004892BC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004892C0 | 48 8B 00 | mov     rax, [rax]
0x004892C3 | 48 85 C0 | test    rax, rax
0x004892C6 | 75 07 | jnz     short loc_4892CF
0x004892C8 | B8 00 00 00 00 | mov     eax, 0
0x004892CD | EB 4B | jmp     short locret_48931A
0x004892CF | 48 8B 05 32 41 2D 00 | mov     rax, cs:qword_75D408
0x004892D6 | 8B 40 3C | mov     eax, [rax+3Ch]
0x004892D9 | 85 C0 | test    eax, eax
0x004892DB | 74 31 | jz      short loc_48930E
0x004892DD | E8 9E D6 F7 FF | call    _getpid
0x004892E2 | 89 C2 | mov     edx, eax
0x004892E4 | 48 8B 05 1D 41 2D 00 | mov     rax, cs:qword_75D408
0x004892EB | 8B 40 20 | mov     eax, [rax+20h]
0x004892EE | 39 C2 | cmp     edx, eax
0x004892F0 | 75 1C | jnz     short loc_48930E
0x004892F2 | 48 8B 05 0F 41 2D 00 | mov     rax, cs:qword_75D408
0x004892F9 | 8B 50 3C | mov     edx, [rax+3Ch]
0x004892FC | 48 8B 05 05 41 2D 00 | mov     rax, cs:qword_75D408
0x00489303 | 8B 00 | mov     eax, [rax]
0x00489305 | 89 D6 | mov     esi, edx; pgrp_id
0x00489307 | 89 C7 | mov     edi, eax; fd
0x00489309 | E8 B2 E4 F7 FF | call    _tcsetpgrp
0x0048930E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00489312 | 48 89 C7 | mov     rdi, rax
0x00489315 | E8 46 D8 FF FF | call    sub_486B60
0x0048931A | C9 | leave
0x0048931B | C3 | retn
 ************ 
Source Code:
static int FAST_FUNC builtin_exec(char **argv)
{
	argv = skip_dash_dash(argv);
	if (argv[0] == NULL)
		return EXIT_SUCCESS; /* bash does this */

	/* Careful: we can end up here after [v]fork. Do not restore
	 * tty pgrp then, only top-level shell process does that */
	if (G_saved_tty_pgrp && getpid() == G.root_pid)
		tcsetpgrp(G_interactive_fd, G_saved_tty_pgrp);

	/* TODO: if exec fails, bash does NOT exit! We do.
	 * We'll need to undo trap cleanup (it's inside execvp_or_die)
	 * and tcsetpgrp, and this is inherently racy.
	 */
	execvp_or_die(argv);
}
 ************ 
Parsed Output:
static int FAST_FUNC set_terminal_pgrp(char **argv)
{
    int pgrp_id;
    int fd;

    fd = atoi(argv[0]);
    pgrp_id = getpid();

    if (tcsetpgrp(fd, pgrp_id) == -1) {
        perror("tcsetpgrp");
        return 1;
    }

    sub_486B60(argv[0]);

    return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.730282723903656
Func rank: 43

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: quote_special_chars
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0042C232 | 55 | push    rbp
0x0042C233 | 48 89 E5 | mov     rbp, rsp
0x0042C236 | 48 83 EC 30 | sub     rsp, 30h
0x0042C23A | 48 89 7D D8 | mov     [rbp+s], rdi
0x0042C23E | 48 8B 45 D8 | mov     rax, [rbp+s]
0x0042C242 | 48 89 C7 | mov     rdi, rax; s
0x0042C245 | E8 86 A8 FD FF | call    _strlen
0x0042C24A | 89 45 F4 | mov     [rbp+var_C], eax
0x0042C24D | 8B 55 F4 | mov     edx, [rbp+var_C]
0x0042C250 | 89 D0 | mov     eax, edx
0x0042C252 | 01 C0 | add     eax, eax
0x0042C254 | 01 D0 | add     eax, edx
0x0042C256 | 01 C0 | add     eax, eax
0x0042C258 | 83 C0 01 | add     eax, 1
0x0042C25B | 48 98 | cdqe
0x0042C25D | 48 89 C7 | mov     rdi, rax
0x0042C260 | E8 FA DD FD FF | call    sub_40A05F
0x0042C265 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x0042C269 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0042C26D | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0042C271 | EB 49 | jmp     short loc_42C2BC
0x0042C273 | 0F B6 45 E7 | movzx   eax, [rbp+var_19]
0x0042C277 | 0F B6 C0 | movzx   eax, al
0x0042C27A | 89 C7 | mov     edi, eax
0x0042C27C | E8 09 F4 FF FF | call    sub_42B68A
0x0042C281 | 85 C0 | test    eax, eax
0x0042C283 | 74 14 | jz      short loc_42C299
0x0042C285 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0042C289 | 48 8D 50 01 | lea     rdx, [rax+1]
0x0042C28D | 48 89 55 F8 | mov     [rbp+var_8], rdx
0x0042C291 | 0F B6 55 E7 | movzx   edx, [rbp+var_19]
0x0042C295 | 88 10 | mov     [rax], dl
0x0042C297 | EB 23 | jmp     short loc_42C2BC
0x0042C299 | 0F B6 45 E7 | movzx   eax, [rbp+var_19]
0x0042C29D | 0F B6 D0 | movzx   edx, al
0x0042C2A0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0042C2A4 | BE 50 7B 51 00 | mov     esi, offset aD_1; "&#%d;"
0x0042C2A9 | 48 89 C7 | mov     rdi, rax; s
0x0042C2AC | B8 00 00 00 00 | mov     eax, 0
0x0042C2B1 | E8 CA B7 FD FF | call    _sprintf
0x0042C2B6 | 48 98 | cdqe
0x0042C2B8 | 48 01 45 F8 | add     [rbp+var_8], rax
0x0042C2BC | 48 8B 45 D8 | mov     rax, [rbp+s]
0x0042C2C0 | 48 8D 50 01 | lea     rdx, [rax+1]
0x0042C2C4 | 48 89 55 D8 | mov     [rbp+s], rdx
0x0042C2C8 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0042C2CB | 88 45 E7 | mov     [rbp+var_19], al
0x0042C2CE | 80 7D E7 00 | cmp     [rbp+var_19], 0
0x0042C2D2 | 75 9F | jnz     short loc_42C273
0x0042C2D4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0042C2D8 | C6 00 00 | mov     byte ptr [rax], 0
0x0042C2DB | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0042C2DF | C9 | leave
0x0042C2E0 | C3 | retn

 Ourput decompiled code:
static char *encodeString(const char *string)
{
	/* take the simple route and encode everything */
	/* could possibly scan once to get length.     */
	int len = strlen(string);
	char *out = xmalloc(len * 6 + 1);
	char *p = out;
	char ch;

	while ((ch = *string++) != '\0') {
		/* very simple check for what to encode */
		if (isalnum(ch))
			*p++ = ch;
		else
			p += sprintf(p, "&#%d;", (unsigned char) ch);
	}
	*p = '\0';
	return out;
}

## Example:

 Input assembly code:
0x00432276 | 55 | push    rbp
0x00432277 | 48 89 E5 | mov     rbp, rsp
0x0043227A | 48 83 EC 20 | sub     rsp, 20h
0x0043227E | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00432282 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00432286 | 48 8B 00 | mov     rax, [rax]
0x00432289 | 48 89 C7 | mov     rdi, rax
0x0043228C | E8 23 71 FD FF | call    sub_4093B4
0x00432291 | 48 89 45 F0 | mov     [rbp+s], rax
0x00432295 | 48 8B 45 F0 | mov     rax, [rbp+s]
0x00432299 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0043229C | 84 C0 | test    al, al
0x0043229E | 75 07 | jnz     short loc_4322A7
0x004322A0 | B8 00 00 00 00 | mov     eax, 0
0x004322A5 | EB 5A | jmp     short locret_432301
0x004322A7 | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004322AB | BE 08 8F 51 00 | mov     esi, offset asc_518F08; " \t\n"
0x004322B0 | 48 89 C7 | mov     rdi, rax; s
0x004322B3 | E8 28 4C FD FF | call    _strcspn
0x004322B8 | 89 45 FC | mov     [rbp+var_4], eax
0x004322BB | 8B 55 FC | mov     edx, [rbp+var_4]
0x004322BE | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004322C2 | 48 01 D0 | add     rax, rdx
0x004322C5 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004322C8 | 84 C0 | test    al, al
0x004322CA | 74 15 | jz      short loc_4322E1
0x004322CC | 8B 45 FC | mov     eax, [rbp+var_4]
0x004322CF | 8D 50 01 | lea     edx, [rax+1]
0x004322D2 | 89 55 FC | mov     [rbp+var_4], edx
0x004322D5 | 89 C2 | mov     edx, eax
0x004322D7 | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004322DB | 48 01 D0 | add     rax, rdx
0x004322DE | C6 00 00 | mov     byte ptr [rax], 0
0x004322E1 | 8B 55 FC | mov     edx, [rbp+var_4]
0x004322E4 | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004322E8 | 48 01 D0 | add     rax, rdx
0x004322EB | 48 89 C7 | mov     rdi, rax
0x004322EE | E8 C1 70 FD FF | call    sub_4093B4
0x004322F3 | 48 89 C2 | mov     rdx, rax
0x004322F6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004322FA | 48 89 10 | mov     [rax], rdx
0x004322FD | 48 8B 45 F0 | mov     rax, [rbp+s]
0x00432301 | C9 | leave
0x00432302 | C3 | retn

 Ourput decompiled code:
static char *next_word(char **buf)
{
	unsigned length;
	char *word;

	/* Skip over leading whitespace */
	word = skip_whitespace(*buf);

	/* Stop on EOL */
	if (*word == '\0')
		return NULL;

	/* Find the length of this word (can't be 0) */
	length = strcspn(word, " \t\n");

	/* Unless we are already at NUL, store NUL and advance */
	if (word[length] != '\0')
		word[length++] = '\0';

	*buf = skip_whitespace(word + length);

	return word;
}

## Example:

 Input assembly code:
0x004E8B82 | 55 | push    rbp
0x004E8B83 | 48 89 E5 | mov     rbp, rsp
0x004E8B86 | 48 83 EC 20 | sub     rsp, 20h
0x004E8B8A | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004E8B8E | 89 75 E4 | mov     [rbp+var_1C], esi
0x004E8B91 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004E8B94 | 83 C0 01 | add     eax, 1
0x004E8B97 | 48 98 | cdqe
0x004E8B99 | 48 89 C7 | mov     rdi, rax
0x004E8B9C | E8 BE 14 F2 FF | call    sub_40A05F
0x004E8BA1 | 48 89 45 F0 | mov     [rbp+s], rax
0x004E8BA5 | 48 C7 45 F8 37 6E 52 00 | mov     [rbp+var_8], offset aNTR; "\nn\tt\rr"
0x004E8BAD | EB 4A | jmp     short loc_4E8BF9
0x004E8BAF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E8BB3 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004E8BB6 | 0F BE F8 | movsx   edi, al
0x004E8BB9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E8BBD | 48 83 C0 01 | add     rax, 1
0x004E8BC1 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004E8BC4 | 0F BE C8 | movsx   ecx, al
0x004E8BC7 | 8B 55 E4 | mov     edx, [rbp+var_1C]
0x004E8BCA | 48 8B 75 E8 | mov     rsi, [rbp+var_18]
0x004E8BCE | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004E8BD2 | 41 89 F8 | mov     r8d, edi
0x004E8BD5 | 48 89 C7 | mov     rdi, rax
0x004E8BD8 | E8 B8 FE FF FF | call    sub_4E8A95
0x004E8BDD | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004E8BE1 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x004E8BE5 | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004E8BE9 | 48 89 C7 | mov     rdi, rax; s
0x004E8BEC | E8 DF DE F1 FF | call    _strlen
0x004E8BF1 | 89 45 E4 | mov     [rbp+var_1C], eax
0x004E8BF4 | 48 83 45 F8 02 | add     [rbp+var_8], 2
0x004E8BF9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E8BFD | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004E8C00 | 84 C0 | test    al, al
0x004E8C02 | 75 AB | jnz     short loc_4E8BAF
0x004E8C04 | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004E8C08 | C9 | leave
0x004E8C09 | C3 | retn

 Ourput decompiled code:
static char *copy_parsing_escapes(const char *string, int len)
{
	const char *s;
	char *dest = xmalloc(len + 1);

	/* sed recognizes \n */
	/* GNU sed also recognizes \t and \r */
	for (s = "\nn\tt\rr"; *s; s += 2) {
		parse_escapes(dest, string, len, s[1], s[0]);
		string = dest;
		len = strlen(dest);
	}
	return dest;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004FF303 | 55 | push    rbp
0x004FF304 | 48 89 E5 | mov     rbp, rsp
0x004FF307 | 48 83 EC 20 | sub     rsp, 20h
0x004FF30B | 48 89 7D E8 | mov     [rbp+s], rdi
0x004FF30F | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004FF316 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004FF31A | 48 89 C7 | mov     rdi, rax; s
0x004FF31D | E8 AE 77 F0 FF | call    _strlen
0x004FF322 | 48 83 C0 01 | add     rax, 1
0x004FF326 | 48 01 C0 | add     rax, rax
0x004FF329 | 48 89 C7 | mov     rdi, rax
0x004FF32C | E8 B7 AD F0 FF | call    sub_40A0E8
0x004FF331 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x004FF335 | EB 50 | jmp     short loc_4FF387
0x004FF337 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004FF33B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004FF33E | 0F BE C0 | movsx   eax, al
0x004FF341 | 89 C7 | mov     edi, eax
0x004FF343 | E8 9C FF FF FF | call    sub_4FF2E4
0x004FF348 | 48 85 C0 | test    rax, rax
0x004FF34B | 74 16 | jz      short loc_4FF363
0x004FF34D | 8B 45 FC | mov     eax, [rbp+var_4]
0x004FF350 | 8D 50 01 | lea     edx, [rax+1]
0x004FF353 | 89 55 FC | mov     [rbp+var_4], edx
0x004FF356 | 48 63 D0 | movsxd  rdx, eax
0x004FF359 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004FF35D | 48 01 D0 | add     rax, rdx
0x004FF360 | C6 00 5C | mov     byte ptr [rax], 5Ch ; '\'
0x004FF363 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004FF367 | 48 8D 50 01 | lea     rdx, [rax+1]
0x004FF36B | 48 89 55 E8 | mov     [rbp+s], rdx
0x004FF36F | 8B 55 FC | mov     edx, [rbp+var_4]
0x004FF372 | 8D 4A 01 | lea     ecx, [rdx+1]
0x004FF375 | 89 4D FC | mov     [rbp+var_4], ecx
0x004FF378 | 48 63 CA | movsxd  rcx, edx
0x004FF37B | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x004FF37F | 48 01 CA | add     rdx, rcx
0x004FF382 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004FF385 | 88 02 | mov     [rdx], al
0x004FF387 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004FF38B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004FF38E | 84 C0 | test    al, al
0x004FF390 | 75 A5 | jnz     short loc_4FF337
0x004FF392 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004FF396 | C9 | leave
0x004FF397 | C3 | retn
 ************ 
Source Code:
static char *quote_special_chars(char *found)
{
	int l = 0;
	char *s = xzalloc((strlen(found) + 1) * 2);

	while (*found) {
		if (is_special_char(*found))
			s[l++] = '\\';
		s[l++] = *found++;
	}
	/* s[l] = '\0'; - already is */
	return s;
}
 ************ 
Parsed Output:
static char *processString(const char *s)
{
    int len = strlen(s);
    char *result = malloc(len * 2 + 1);
    int i = 0;
    int j = 0;

    while (s[i] != '\0') {
        if (s[i] == '\\') {
            i++;
            switch (s[i]) {
                case 'n':
                    result[j] = '
';
                    break;
                case 't':
                    result[j] = '\t';
                    break;
                case 'r':
                    result[j] = '\r';
                    break;
                default:
                    result[j] = s[i];
                    break;
            }
        } else {
            result[j] = s[i];
        }
        i++;
        j++;
    }

    result[j] = '\0';
    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.7204761505126953
Func rank: 44

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: open_a_console
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0050190E | 55 | push    rbp
0x0050190F | 48 89 E5 | mov     rbp, rsp
0x00501912 | 48 83 EC 20 | sub     rsp, 20h
0x00501916 | 48 89 7D E8 | mov     [rbp+file], rdi
0x0050191A | 48 8B 45 E8 | mov     rax, [rbp+file]
0x0050191E | BE 00 00 00 00 | mov     esi, 0; oflag
0x00501923 | 48 89 C7 | mov     rdi, rax; file
0x00501926 | B8 00 00 00 00 | mov     eax, 0
0x0050192B | E8 A0 5D F0 FF | call    _open64
0x00501930 | 89 45 FC | mov     [rbp+fd], eax
0x00501933 | 83 7D FC 00 | cmp     [rbp+fd], 0
0x00501937 | 79 07 | jns     short loc_501940
0x00501939 | B8 01 00 00 00 | mov     eax, 1
0x0050193E | EB 29 | jmp     short locret_501969
0x00501940 | 8B 45 FC | mov     eax, [rbp+fd]
0x00501943 | BA 00 00 00 00 | mov     edx, 0
0x00501948 | BE 01 4C 00 00 | mov     esi, 4C01h; request
0x0050194D | 89 C7 | mov     edi, eax; fd
0x0050194F | B8 00 00 00 00 | mov     eax, 0
0x00501954 | E8 47 54 F0 FF | call    _ioctl
0x00501959 | 89 45 F8 | mov     [rbp+var_8], eax
0x0050195C | 8B 45 FC | mov     eax, [rbp+fd]
0x0050195F | 89 C7 | mov     edi, eax; fd
0x00501961 | E8 AA 54 F0 FF | call    _close
0x00501966 | 8B 45 F8 | mov     eax, [rbp+var_8]
0x00501969 | C9 | leave
0x0050196A | C3 | retn

 Ourput decompiled code:
int FAST_FUNC del_loop(const char *device)
{
	int fd, rc;

	fd = open(device, O_RDONLY);
	if (fd < 0)
		return 1;
	rc = ioctl(fd, LOOP_CLR_FD, 0);
	close(fd);

	return rc;
}

## Example:

 Input assembly code:
0x0050A55F | 55 | push    rbp
0x0050A560 | 48 89 E5 | mov     rbp, rsp
0x0050A563 | 48 83 EC 20 | sub     rsp, 20h
0x0050A567 | 48 89 7D E8 | mov     [rbp+argv], rdi
0x0050A56B | E8 D9 00 F0 FF | call    sub_40A649
0x0050A570 | C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0
0x0050A577 | E8 34 D3 EF FF | call    _vfork
0x0050A57C | 89 45 FC | mov     [rbp+var_4], eax
0x0050A57F | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0050A583 | 79 05 | jns     short loc_50A58A
0x0050A585 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0050A588 | EB 63 | jmp     short locret_50A5ED
0x0050A58A | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0050A58E | 75 2C | jnz     short loc_50A5BC
0x0050A590 | 48 8B 45 E8 | mov     rax, [rbp+argv]
0x0050A594 | 48 8B 00 | mov     rax, [rax]
0x0050A597 | 48 8B 55 E8 | mov     rdx, [rbp+argv]
0x0050A59B | 48 89 D6 | mov     rsi, rdx; argv
0x0050A59E | 48 89 C7 | mov     rdi, rax; file
0x0050A5A1 | E8 EA D3 EF FF | call    _execvp
0x0050A5A6 | 48 8B 05 53 2E 25 00 | mov     rax, cs:qword_75D400
0x0050A5AD | 8B 00 | mov     eax, [rax]
0x0050A5AF | 89 45 F8 | mov     [rbp+var_8], eax
0x0050A5B2 | BF 6F 00 00 00 | mov     edi, 6Fh ; 'o'; status
0x0050A5B7 | E8 04 C2 EF FF | call    __exit
0x0050A5BC | 8B 45 F8 | mov     eax, [rbp+var_8]
0x0050A5BF | 85 C0 | test    eax, eax
0x0050A5C1 | 74 27 | jz      short loc_50A5EA
0x0050A5C3 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0050A5C6 | BA 00 00 00 00 | mov     edx, 0
0x0050A5CB | BE 00 00 00 00 | mov     esi, 0
0x0050A5D0 | 89 C7 | mov     edi, eax
0x0050A5D2 | E8 71 F9 EF FF | call    sub_409F48
0x0050A5D7 | 48 8B 05 22 2E 25 00 | mov     rax, cs:qword_75D400
0x0050A5DE | 8B 55 F8 | mov     edx, [rbp+var_8]
0x0050A5E1 | 89 10 | mov     [rax], edx
0x0050A5E3 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x0050A5E8 | EB 03 | jmp     short locret_50A5ED
0x0050A5EA | 8B 45 FC | mov     eax, [rbp+var_4]
0x0050A5ED | C9 | leave
0x0050A5EE | C3 | retn

 Ourput decompiled code:
pid_t FAST_FUNC spawn(char **argv)
{
	/* Compiler should not optimize stores here */
	volatile int failed;
	pid_t pid;

	fflush_all();

	/* Be nice to nommu machines. */
	failed = 0;
	pid = vfork();
	if (pid < 0) /* error */
		return pid;
	if (!pid) { /* child */
		/* This macro is ok - it doesn't do NOEXEC/NOFORK tricks */
		BB_EXECVP(argv[0], argv);

		/* We are (maybe) sharing a stack with blocked parent,
		 * let parent know we failed and then exit to unblock parent
		 * (but don't run atexit() stuff, which would screw up parent.)
		 */
		failed = errno;
		/* mount, for example, does not want the message */
		/*bb_perror_msg("can't execute '%s'", argv[0]);*/
		_exit(111);
	}
	/* parent */
	/* Unfortunately, this is not reliable: according to standards
	 * vfork() can be equivalent to fork() and we won't see value
	 * of 'failed'.
	 * Interested party can wait on pid and learn exit code.
	 * If 111 - then it (most probably) failed to exec */
	if (failed) {
		safe_waitpid(pid, NULL, 0); /* prevent zombie */
		errno = failed;
		return -1;
	}
	return pid;
}

## Example:

 Input assembly code:
0x004C33AC | 55 | push    rbp
0x004C33AD | 48 89 E5 | mov     rbp, rsp
0x004C33B0 | 48 83 EC 20 | sub     rsp, 20h
0x004C33B4 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004C33B8 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004C33BC | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004C33C0 | 48 89 C7 | mov     rdi, rax
0x004C33C3 | E8 12 FF FF FF | call    sub_4C32DA
0x004C33C8 | 89 45 FC | mov     [rbp+fd], eax
0x004C33CB | 83 7D FC 00 | cmp     [rbp+fd], 0
0x004C33CF | 79 07 | jns     short loc_4C33D8
0x004C33D1 | B8 00 00 00 00 | mov     eax, 0
0x004C33D6 | EB 40 | jmp     short locret_4C3418
0x004C33D8 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x004C33DC | 8B 45 FC | mov     eax, [rbp+fd]
0x004C33DF | 48 89 D6 | mov     rsi, rdx
0x004C33E2 | 89 C7 | mov     edi, eax
0x004C33E4 | E8 7B 3E 04 00 | call    sub_507264
0x004C33E9 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x004C33ED | 48 83 7D F0 00 | cmp     [rbp+var_10], 0
0x004C33F2 | 75 16 | jnz     short loc_4C340A
0x004C33F4 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004C33F8 | 48 89 C6 | mov     rsi, rax
0x004C33FB | BF B6 68 53 00 | mov     edi, offset aReadErrorFromS; "read error from '%s'"
0x004C3400 | B8 00 00 00 00 | mov     eax, 0
0x004C3405 | E8 CF 5D F4 FF | call    sub_4091D9
0x004C340A | 8B 45 FC | mov     eax, [rbp+fd]
0x004C340D | 89 C7 | mov     edi, eax; fd
0x004C340F | E8 FC 39 F4 FF | call    _close
0x004C3414 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004C3418 | C9 | leave
0x004C3419 | C3 | retn

 Ourput decompiled code:
FAST_FUNC xmalloc_open_zipped_read_close(const char *fname, size_t *maxsz_p)
{
	int fd;
	char *image;

	fd = open_zipped(fname);
	if (fd < 0)
		return NULL;

	image = xmalloc_read(fd, maxsz_p);
	if (!image)
		bb_perror_msg("read error from '%s'", fname);
	close(fd);

	return image;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004F9CA0 | 55 | push    rbp
0x004F9CA1 | 48 89 E5 | mov     rbp, rsp
0x004F9CA4 | 48 83 EC 20 | sub     rsp, 20h
0x004F9CA8 | 48 89 7D E8 | mov     [rbp+file], rdi
0x004F9CAC | 48 8B 45 E8 | mov     rax, [rbp+file]
0x004F9CB0 | BE 02 00 00 00 | mov     esi, 2; oflag
0x004F9CB5 | 48 89 C7 | mov     rdi, rax; file
0x004F9CB8 | B8 00 00 00 00 | mov     eax, 0
0x004F9CBD | E8 0E DA F0 FF | call    _open64
0x004F9CC2 | 89 45 FC | mov     [rbp+var_4], eax
0x004F9CC5 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004F9CC9 | 79 27 | jns     short loc_4F9CF2
0x004F9CCB | 48 8B 05 2E 37 26 00 | mov     rax, cs:qword_75D400
0x004F9CD2 | 8B 00 | mov     eax, [rax]
0x004F9CD4 | 83 F8 0D | cmp     eax, 0Dh
0x004F9CD7 | 75 19 | jnz     short loc_4F9CF2
0x004F9CD9 | 48 8B 45 E8 | mov     rax, [rbp+file]
0x004F9CDD | BE 00 00 00 00 | mov     esi, 0; oflag
0x004F9CE2 | 48 89 C7 | mov     rdi, rax; file
0x004F9CE5 | B8 00 00 00 00 | mov     eax, 0
0x004F9CEA | E8 E1 D9 F0 FF | call    _open64
0x004F9CEF | 89 45 FC | mov     [rbp+var_4], eax
0x004F9CF2 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004F9CF6 | 79 27 | jns     short loc_4F9D1F
0x004F9CF8 | 48 8B 05 01 37 26 00 | mov     rax, cs:qword_75D400
0x004F9CFF | 8B 00 | mov     eax, [rax]
0x004F9D01 | 83 F8 0D | cmp     eax, 0Dh
0x004F9D04 | 75 19 | jnz     short loc_4F9D1F
0x004F9D06 | 48 8B 45 E8 | mov     rax, [rbp+file]
0x004F9D0A | BE 01 00 00 00 | mov     esi, 1; oflag
0x004F9D0F | 48 89 C7 | mov     rdi, rax; file
0x004F9D12 | B8 00 00 00 00 | mov     eax, 0
0x004F9D17 | E8 B4 D9 F0 FF | call    _open64
0x004F9D1C | 89 45 FC | mov     [rbp+var_4], eax
0x004F9D1F | 8B 45 FC | mov     eax, [rbp+var_4]
0x004F9D22 | C9 | leave
0x004F9D23 | C3 | retn
 ************ 
Source Code:
static int open_a_console(const char *fnam)
{
	int fd;

	/* try read-write */
	fd = open(fnam, O_RDWR);

	/* if failed, try read-only */
	if (fd < 0 && errno == EACCES)
		fd = open(fnam, O_RDONLY);

	/* if failed, try write-only */
	if (fd < 0 && errno == EACCES)
		fd = open(fnam, O_WRONLY);

	return fd;
}
 ************ 
Parsed Output:
int open_file(const char *file)
{
    int fd;

    fd = open(file, 2);
    if (fd < 0) {
        if (qword_75D400 == 0xD) {
            fd = open(file, 0);
            if (fd < 0) {
                if (qword_75D400 == 0xD) {
                    fd = open(file, 1);
                    if (fd < 0) {
                        return -1;
                    }
                }
            }
        }
    }

    return fd;
}
 ************ 
Similarity Score (Unixcoder): 0.7164807319641113
Func rank: 45

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: check_signature16
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00453171 | 55 | push    rbp
0x00453172 | 48 89 E5 | mov     rbp, rsp
0x00453175 | 48 83 EC 20 | sub     rsp, 20h
0x00453179 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0045317D | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x00453181 | 89 55 EC | mov     [rbp+var_14], edx
0x00453184 | 83 7D EC 11 | cmp     [rbp+var_14], 11h
0x00453188 | 75 1B | jnz     short loc_4531A5
0x0045318A | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0045318E | BA 5E CD 52 00 | mov     edx, offset aAddress_0; "address"
0x00453193 | 48 89 C6 | mov     rsi, rax
0x00453196 | BF 68 CD 52 00 | mov     edi, offset aSMayBeInetSBut; "\"%s\" may be inet %s, but it is not al"...
0x0045319B | B8 00 00 00 00 | mov     eax, 0
0x004531A0 | E8 F9 64 FB FF | call    sub_40969E
0x004531A5 | 8B 55 EC | mov     edx, [rbp+var_14]
0x004531A8 | 48 8B 4D F0 | mov     rcx, [rbp+var_10]
0x004531AC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004531B0 | 48 89 CE | mov     rsi, rcx
0x004531B3 | 48 89 C7 | mov     rdi, rax
0x004531B6 | E8 F0 FB FF FF | call    sub_452DAB
0x004531BB | 85 C0 | test    eax, eax
0x004531BD | 74 20 | jz      short loc_4531DF
0x004531BF | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004531C3 | 48 89 C1 | mov     rcx, rax
0x004531C6 | BA 5E CD 52 00 | mov     edx, offset aAddress_0; "address"
0x004531CB | BE 2F CD 52 00 | mov     esi, offset aInet_4; "inet"
0x004531D0 | BF 38 CD 52 00 | mov     edi, offset aAnSSIsExpected; "an %s %s is expected rather than \"%s\""
0x004531D5 | B8 00 00 00 00 | mov     eax, 0
0x004531DA | E8 BF 64 FB FF | call    sub_40969E
0x004531DF | B8 00 00 00 00 | mov     eax, 0
0x004531E4 | C9 | leave
0x004531E5 | C3 | retn

 Ourput decompiled code:
int get_addr(inet_prefix *dst, char *arg, int family)
{
	if (family == AF_PACKET) {
		bb_error_msg_and_die("\"%s\" may be inet %s, but it is not allowed in this context", arg, "address");
	}
	if (get_addr_1(dst, arg, family)) {
		bb_error_msg_and_die("an %s %s is expected rather than \"%s\"", "inet", "address", arg);
	}
	return 0;
}

## Example:

 Input assembly code:
0x0043A0F8 | 55 | push    rbp
0x0043A0F9 | 48 89 E5 | mov     rbp, rsp
0x0043A0FC | 48 83 EC 20 | sub     rsp, 20h
0x0043A100 | 89 7D EC | mov     [rbp+port], edi
0x0043A103 | 48 89 75 E0 | mov     [rbp+proto], rsi
0x0043A107 | 89 55 E8 | mov     [rbp+var_18], edx
0x0043A10A | 83 7D EC 00 | cmp     [rbp+port], 0
0x0043A10E | 75 07 | jnz     short loc_43A117
0x0043A110 | B8 0D A0 51 00 | mov     eax, offset asc_51A00D; "*"
0x0043A115 | EB 42 | jmp     short locret_43A159
0x0043A117 | 83 7D E8 00 | cmp     [rbp+var_18], 0
0x0043A11B | 75 25 | jnz     short loc_43A142
0x0043A11D | 48 8B 55 E0 | mov     rdx, [rbp+proto]
0x0043A121 | 8B 45 EC | mov     eax, [rbp+port]
0x0043A124 | 48 89 D6 | mov     rsi, rdx; proto
0x0043A127 | 89 C7 | mov     edi, eax; port
0x0043A129 | E8 52 DA FC FF | call    _getservbyport
0x0043A12E | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0043A132 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0043A137 | 74 09 | jz      short loc_43A142
0x0043A139 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043A13D | 48 8B 00 | mov     rax, [rax]
0x0043A140 | EB 17 | jmp     short locret_43A159
0x0043A142 | 8B 45 EC | mov     eax, [rbp+port]
0x0043A145 | 0F B7 C0 | movzx   eax, ax
0x0043A148 | 89 C7 | mov     edi, eax; netshort
0x0043A14A | E8 01 D5 FC FF | call    _ntohs
0x0043A14F | 0F B7 C0 | movzx   eax, ax
0x0043A152 | 89 C7 | mov     edi, eax
0x0043A154 | E8 33 FA FC FF | call    sub_409B8C
0x0043A159 | C9 | leave
0x0043A15A | C3 | retn

 Ourput decompiled code:
static const char *get_sname(int port, const char *proto, int numeric)
{
	if (!port)
		return "*";
	if (!numeric) {
		struct servent *se = getservbyport(port, proto);
		if (se)
			return se->s_name;
	}
	/* hummm, we may return static buffer here!! */
	return itoa(ntohs(port));
}

## Example:

 Input assembly code:
0x0045045A | 55 | push    rbp
0x0045045B | 48 89 E5 | mov     rbp, rsp
0x0045045E | 48 83 EC 50 | sub     rsp, 50h
0x00450462 | 89 7D BC | mov     [rbp+var_44], edi
0x00450465 | 48 89 75 B0 | mov     [rbp+var_50], rsi
0x00450469 | 48 8D 55 C0 | lea     rdx, [rbp+var_40]
0x0045046D | 8B 4D BC | mov     ecx, [rbp+var_44]
0x00450470 | 48 8B 45 B0 | mov     rax, [rbp+var_50]
0x00450474 | 89 CE | mov     esi, ecx
0x00450476 | 48 89 C7 | mov     rdi, rax
0x00450479 | E8 64 F4 FF FF | call    sub_44F8E2
0x0045047E | 0F B6 45 E8 | movzx   eax, [rbp+var_18]
0x00450482 | 84 C0 | test    al, al
0x00450484 | 74 18 | jz      short loc_45049E
0x00450486 | 0F B7 45 E6 | movzx   eax, [rbp+var_1A]
0x0045048A | 66 85 C0 | test    ax, ax
0x0045048D | 75 0F | jnz     short loc_45049E
0x0045048F | BF 10 C9 52 00 | mov     edi, offset aTtl0AndNoptmud; "ttl != 0 and noptmudisc are incompatibl"...
0x00450494 | B8 00 00 00 00 | mov     eax, 0
0x00450499 | E8 00 92 FB FF | call    sub_40969E
0x0045049E | 0F B6 45 E9 | movzx   eax, [rbp+var_17]
0x004504A2 | 0F B6 C0 | movzx   eax, al
0x004504A5 | 83 F8 29 | cmp     eax, 29h ; ')'
0x004504A8 | 74 34 | jz      short loc_4504DE
0x004504AA | 83 F8 2F | cmp     eax, 2Fh ; '/'
0x004504AD | 74 1A | jz      short loc_4504C9
0x004504AF | 83 F8 04 | cmp     eax, 4
0x004504B2 | 75 3F | jnz     short loc_4504F3
0x004504B4 | 48 8D 55 C0 | lea     rdx, [rbp+var_40]
0x004504B8 | 8B 45 BC | mov     eax, [rbp+var_44]
0x004504BB | BE 39 C9 52 00 | mov     esi, offset aTunl0; "tunl0"
0x004504C0 | 89 C7 | mov     edi, eax
0x004504C2 | E8 D6 F2 FF FF | call    sub_44F79D
0x004504C7 | EB 39 | jmp     short locret_450502
0x004504C9 | 48 8D 55 C0 | lea     rdx, [rbp+var_40]
0x004504CD | 8B 45 BC | mov     eax, [rbp+var_44]
0x004504D0 | BE 3F C9 52 00 | mov     esi, offset aGre0; "gre0"
0x004504D5 | 89 C7 | mov     edi, eax
0x004504D7 | E8 C1 F2 FF FF | call    sub_44F79D
0x004504DC | EB 24 | jmp     short locret_450502
0x004504DE | 48 8D 55 C0 | lea     rdx, [rbp+var_40]
0x004504E2 | 8B 45 BC | mov     eax, [rbp+var_44]
0x004504E5 | BE 44 C9 52 00 | mov     esi, offset aSit0; "sit0"
0x004504EA | 89 C7 | mov     edi, eax
0x004504EC | E8 AC F2 FF FF | call    sub_44F79D
0x004504F1 | EB 0F | jmp     short locret_450502
0x004504F3 | BF 50 C9 52 00 | mov     edi, offset aCanTDetermineT; "can't determine tunnel mode (ipip, gre "...
0x004504F8 | B8 00 00 00 00 | mov     eax, 0
0x004504FD | E8 9C 91 FB FF | call    sub_40969E
0x00450502 | C9 | leave
0x00450503 | C3 | retn

 Ourput decompiled code:
static int do_add(int cmd, char **argv)
{
	struct ip_tunnel_parm p;

	parse_args(argv, cmd, &p);

	if (p.iph.ttl && p.iph.frag_off == 0) {
		bb_error_msg_and_die("ttl != 0 and noptmudisc are incompatible");
	}

	switch (p.iph.protocol) {
	case IPPROTO_IPIP:
		return do_add_ioctl(cmd, "tunl0", &p);
	case IPPROTO_GRE:
		return do_add_ioctl(cmd, "gre0", &p);
	case IPPROTO_IPV6:
		return do_add_ioctl(cmd, "sit0", &p);
	default:
		bb_error_msg_and_die("can't determine tunnel mode (ipip, gre or sit)");
	}
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004C30B5 | 55 | push    rbp
0x004C30B6 | 48 89 E5 | mov     rbp, rsp
0x004C30B9 | 48 83 EC 20 | sub     rsp, 20h
0x004C30BD | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004C30C1 | 89 75 E4 | mov     [rbp+var_1C], esi
0x004C30C4 | 89 55 E0 | mov     [rbp+var_20], edx
0x004C30C7 | 48 83 7D E8 00 | cmp     [rbp+var_18], 0
0x004C30CC | 74 49 | jz      short loc_4C3117
0x004C30CE | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004C30D2 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004C30D5 | 84 C0 | test    al, al
0x004C30D7 | 74 3E | jz      short loc_4C3117
0x004C30D9 | 48 8D 4D FE | lea     rcx, [rbp+var_2]
0x004C30DD | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004C30E0 | BA 02 00 00 00 | mov     edx, 2
0x004C30E5 | 48 89 CE | mov     rsi, rcx
0x004C30E8 | 89 C7 | mov     edi, eax
0x004C30EA | E8 57 83 F4 FF | call    sub_40B446
0x004C30EF | 48 83 F8 02 | cmp     rax, 2
0x004C30F3 | 75 0C | jnz     short loc_4C3101
0x004C30F5 | 0F B7 45 FE | movzx   eax, [rbp+var_2]
0x004C30F9 | 0F B7 C0 | movzx   eax, ax
0x004C30FC | 39 45 E0 | cmp     [rbp+var_20], eax
0x004C30FF | 74 16 | jz      short loc_4C3117
0x004C3101 | BF 82 68 53 00 | mov     edi, offset aInvalidMagic_0; "invalid magic"
0x004C3106 | B8 00 00 00 00 | mov     eax, 0
0x004C310B | E8 37 66 F4 FF | call    sub_409747
0x004C3110 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x004C3115 | EB 05 | jmp     short locret_4C311C
0x004C3117 | B8 00 00 00 00 | mov     eax, 0
0x004C311C | C9 | leave
0x004C311D | C3 | retn
 ************ 
Source Code:
int FAST_FUNC check_signature16(transformer_aux_data_t *aux, int src_fd, unsigned magic16)
{
	if (aux && aux->check_signature) {
		uint16_t magic2;
		if (full_read(src_fd, &magic2, 2) != 2 || magic2 != magic16) {
			bb_error_msg("invalid magic");
#if 0 /* possible future extension */
			if (aux->check_signature > 1)
				xfunc_die();
#endif
			return -1;
		}
	}
	return 0;
}
 ************ 
Parsed Output:
int check_magic(char *arg, int size)
{
    if (arg == NULL || *arg == '\0')
        return 0;
    
    char magic[2];
    get_magic(arg, 2, magic);
    
    if (memcmp(magic, "\xFF\xFF", 2) == 0)
        return -1;
    
    return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.710686981678009
Func rank: 46

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: valid_domain_label
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00464183 | 55 | push    rbp
0x00464184 | 48 89 E5 | mov     rbp, rsp
0x00464187 | 48 83 EC 30 | sub     rsp, 30h
0x0046418B | 48 89 7D D8 | mov     [rbp+var_28], rdi
0x0046418F | C7 45 F4 00 00 00 00 | mov     [rbp+var_C], 0
0x00464196 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x0046419A | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0046419E | EB 7D | jmp     short loc_46421D
0x004641A0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004641A4 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004641A7 | 3C 5C | cmp     al, 5Ch ; '\'
0x004641A9 | 75 10 | jnz     short loc_4641BB
0x004641AB | BF C9 61 53 00 | mov     edi, offset asc_5361C9; "\\\\"
0x004641B0 | E8 7D FC FF FF | call    sub_463E32
0x004641B5 | 83 45 F4 02 | add     [rbp+var_C], 2
0x004641B9 | EB 5D | jmp     short loc_464218
0x004641BB | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004641BF | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004641C2 | 3C 1F | cmp     al, 1Fh
0x004641C4 | 7E 22 | jle     short loc_4641E8
0x004641C6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004641CA | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004641CD | 3C 7F | cmp     al, 7Fh
0x004641CF | 74 17 | jz      short loc_4641E8
0x004641D1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004641D5 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004641D8 | 0F BE C0 | movsx   eax, al
0x004641DB | 89 C7 | mov     edi, eax
0x004641DD | E8 F3 FB FF FF | call    sub_463DD5
0x004641E2 | 83 45 F4 01 | add     [rbp+var_C], 1
0x004641E6 | EB 30 | jmp     short loc_464218
0x004641E8 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004641EC | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004641EF | 0F B6 D0 | movzx   edx, al
0x004641F2 | 48 8D 45 EF | lea     rax, [rbp+s]
0x004641F6 | BE CC 61 53 00 | mov     esi, offset a03o; "\\%03o"
0x004641FB | 48 89 C7 | mov     rdi, rax; s
0x004641FE | B8 00 00 00 00 | mov     eax, 0
0x00464203 | E8 78 38 FA FF | call    _sprintf
0x00464208 | 48 8D 45 EF | lea     rax, [rbp+s]
0x0046420C | 48 89 C7 | mov     rdi, rax
0x0046420F | E8 1E FC FF FF | call    sub_463E32
0x00464214 | 83 45 F4 04 | add     [rbp+var_C], 4
0x00464218 | 48 83 45 F8 01 | add     [rbp+var_8], 1
0x0046421D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00464221 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00464224 | 84 C0 | test    al, al
0x00464226 | 0F 85 74 FF FF FF | jnz     loc_4641A0
0x0046422C | 8B 45 F4 | mov     eax, [rbp+var_C]
0x0046422F | C9 | leave
0x00464230 | C3 | retn

 Ourput decompiled code:
static int out_args(const char *mystr)
{
	const char *here;
	int strcount = 0;
	char tmpstr[5];

	for (here = mystr; *here; here++) {
		if (*here == '\\') {
			out_string("\\\\");
			strcount += 2;
		} else if (*here >= ' ' && *here < 0x7f) {
			out_char(*here);
			strcount++;
		} else {
			sprintf(tmpstr, "\\%03o", (unsigned char) *here);
			out_string(tmpstr);
			strcount += 4;
		}
	}

	return strcount;
}

## Example:

 Input assembly code:
0x0046DEFF | 55 | push    rbp
0x0046DF00 | 48 89 E5 | mov     rbp, rsp
0x0046DF03 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0046DF07 | C7 45 FC 0A 00 00 00 | mov     [rbp+var_4], 0Ah
0x0046DF0E | EB 05 | jmp     short loc_46DF15
0x0046DF10 | 48 83 45 E8 01 | add     [rbp+var_18], 1
0x0046DF15 | 83 6D FC 01 | sub     [rbp+var_4], 1
0x0046DF19 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0046DF1D | 74 0E | jz      short loc_46DF2D
0x0046DF1F | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0046DF23 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0046DF26 | 83 E8 30 | sub     eax, 30h ; '0'
0x0046DF29 | 3C 09 | cmp     al, 9
0x0046DF2B | 76 E3 | jbe     short loc_46DF10
0x0046DF2D | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0046DF31 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0046DF34 | 84 C0 | test    al, al
0x0046DF36 | 0F 94 C0 | setz    al
0x0046DF39 | 0F B6 C0 | movzx   eax, al
0x0046DF3C | 5D | pop     rbp
0x0046DF3D | C3 | retn

 Ourput decompiled code:
static int isdigit_str9(const char *str)
{
	int maxlen = 9 + 1; /* max 9 digits: 999999999 */
	while (--maxlen && isdigit(*str))
		str++;
	return (*str == '\0');
}

## Example:

 Input assembly code:
0x0048B79A | 55 | push    rbp
0x0048B79B | 48 89 E5 | mov     rbp, rsp
0x0048B79E | 48 83 EC 10 | sub     rsp, 10h
0x0048B7A2 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0048B7A6 | 89 F0 | mov     eax, esi
0x0048B7A8 | 88 45 F4 | mov     [rbp+var_C], al
0x0048B7AB | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0048B7B0 | 74 1C | jz      short loc_48B7CE
0x0048B7B2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B7B6 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0048B7B9 | 83 C8 20 | or      eax, 20h
0x0048B7BC | 83 E8 61 | sub     eax, 61h ; 'a'
0x0048B7BF | 3C 19 | cmp     al, 19h
0x0048B7C1 | 76 12 | jbe     short loc_48B7D5
0x0048B7C3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B7C7 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0048B7CA | 3C 5F | cmp     al, 5Fh ; '_'
0x0048B7CC | 74 07 | jz      short loc_48B7D5
0x0048B7CE | B8 00 00 00 00 | mov     eax, 0
0x0048B7D3 | EB 35 | jmp     short locret_48B80A
0x0048B7D5 | 48 83 45 F8 01 | add     [rbp+var_8], 1
0x0048B7DA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B7DE | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0048B7E1 | 0F B6 C0 | movzx   eax, al
0x0048B7E4 | 89 C7 | mov     edi, eax
0x0048B7E6 | E8 71 FF FF FF | call    sub_48B75C
0x0048B7EB | 85 C0 | test    eax, eax
0x0048B7ED | 75 E6 | jnz     short loc_48B7D5
0x0048B7EF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B7F3 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0048B7F6 | 3C 5F | cmp     al, 5Fh ; '_'
0x0048B7F8 | 74 DB | jz      short loc_48B7D5
0x0048B7FA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B7FE | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0048B801 | 38 45 F4 | cmp     [rbp+var_C], al
0x0048B804 | 0F 94 C0 | setz    al
0x0048B807 | 0F B6 C0 | movzx   eax, al
0x0048B80A | C9 | leave
0x0048B80B | C3 | retn

 Ourput decompiled code:
int FAST_FUNC is_well_formed_var_name(const char *s, char terminator)
{
	if (!s || !(isalpha(*s) || *s == '_'))
		return 0;

	do
		s++;
	while (isalnum(*s) || *s == '_');

	return *s == terminator;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004534CD | 55 | push    rbp
0x004534CE | 48 89 E5 | mov     rbp, rsp
0x004534D1 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004534D5 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004534DC | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004534E0 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004534E3 | 88 45 FB | mov     [rbp+var_5], al
0x004534E6 | 0F B6 45 FB | movzx   eax, [rbp+var_5]
0x004534EA | 83 C8 20 | or      eax, 20h
0x004534ED | 3C 60 | cmp     al, 60h ; '`'
0x004534EF | 76 0B | jbe     short loc_4534FC
0x004534F1 | 0F B6 45 FB | movzx   eax, [rbp+var_5]
0x004534F5 | 83 C8 20 | or      eax, 20h
0x004534F8 | 3C 7A | cmp     al, 7Ah ; 'z'
0x004534FA | 76 3E | jbe     short loc_45353A
0x004534FC | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x00453500 | 75 07 | jnz     short loc_453509
0x00453502 | B8 00 00 00 00 | mov     eax, 0
0x00453507 | EB 3C | jmp     short loc_453545
0x00453509 | 80 7D FB 2F | cmp     [rbp+var_5], 2Fh ; '/'
0x0045350D | 76 06 | jbe     short loc_453515
0x0045350F | 80 7D FB 39 | cmp     [rbp+var_5], 39h ; '9'
0x00453513 | 76 25 | jbe     short loc_45353A
0x00453515 | 80 7D FB 00 | cmp     [rbp+var_5], 0
0x00453519 | 74 06 | jz      short loc_453521
0x0045351B | 80 7D FB 2E | cmp     [rbp+var_5], 2Eh ; '.'
0x0045351F | 75 06 | jnz     short loc_453527
0x00453521 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00453525 | EB 1E | jmp     short loc_453545
0x00453527 | 80 7D FB 2D | cmp     [rbp+var_5], 2Dh ; '-'
0x0045352B | 74 0D | jz      short loc_45353A
0x0045352D | 80 7D FB 5F | cmp     [rbp+var_5], 5Fh ; '_'
0x00453531 | 74 07 | jz      short loc_45353A
0x00453533 | B8 00 00 00 00 | mov     eax, 0
0x00453538 | EB 0B | jmp     short loc_453545
0x0045353A | 48 83 45 E8 01 | add     [rbp+var_18], 1
0x0045353F | 83 45 FC 01 | add     [rbp+var_4], 1
0x00453543 | EB 97 | jmp     short loc_4534DC
0x00453545 | 5D | pop     rbp
0x00453546 | C3 | retn
 ************ 
Source Code:
static const char *valid_domain_label(const char *label)
{
	unsigned char ch;
	unsigned pos = 0;

	for (;;) {
		ch = *label;
		if ((ch|0x20) < 'a' || (ch|0x20) > 'z') {
			if (pos == 0) {
				/* label must begin with letter */
				return NULL;
			}
			if (ch < '0' || ch > '9') {
				if (ch == '\0' || ch == '.')
					return label;
				/* DNS allows only '-', but we are more permissive */
				if (ch != '-' && ch != '_')
					return NULL;
			}
		}
		label++;
		pos++;
		//Do we want this?
		//if (pos > 63) /* NS_MAXLABEL; labels must be 63 chars or less */
		//	return NULL;
	}
}
 ************ 
Parsed Output:
static int is_valid_identifier(const char *str)
{
    if (!str || !isalpha(*str) || *str == '_')
        return 0;

    while (*str) {
        if (!isalnum(*str) && *str != '_' && *str != '/' && *str != '.' && *str != '-' && *str != '_')
            return 0;
        str++;
    }

    return 1;
}
 ************ 
Similarity Score (Unixcoder): 0.7092132568359375
Func rank: 47

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: copy_parsing_escapes
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004FF303 | 55 | push    rbp
0x004FF304 | 48 89 E5 | mov     rbp, rsp
0x004FF307 | 48 83 EC 20 | sub     rsp, 20h
0x004FF30B | 48 89 7D E8 | mov     [rbp+s], rdi
0x004FF30F | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004FF316 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004FF31A | 48 89 C7 | mov     rdi, rax; s
0x004FF31D | E8 AE 77 F0 FF | call    _strlen
0x004FF322 | 48 83 C0 01 | add     rax, 1
0x004FF326 | 48 01 C0 | add     rax, rax
0x004FF329 | 48 89 C7 | mov     rdi, rax
0x004FF32C | E8 B7 AD F0 FF | call    sub_40A0E8
0x004FF331 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x004FF335 | EB 50 | jmp     short loc_4FF387
0x004FF337 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004FF33B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004FF33E | 0F BE C0 | movsx   eax, al
0x004FF341 | 89 C7 | mov     edi, eax
0x004FF343 | E8 9C FF FF FF | call    sub_4FF2E4
0x004FF348 | 48 85 C0 | test    rax, rax
0x004FF34B | 74 16 | jz      short loc_4FF363
0x004FF34D | 8B 45 FC | mov     eax, [rbp+var_4]
0x004FF350 | 8D 50 01 | lea     edx, [rax+1]
0x004FF353 | 89 55 FC | mov     [rbp+var_4], edx
0x004FF356 | 48 63 D0 | movsxd  rdx, eax
0x004FF359 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004FF35D | 48 01 D0 | add     rax, rdx
0x004FF360 | C6 00 5C | mov     byte ptr [rax], 5Ch ; '\'
0x004FF363 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004FF367 | 48 8D 50 01 | lea     rdx, [rax+1]
0x004FF36B | 48 89 55 E8 | mov     [rbp+s], rdx
0x004FF36F | 8B 55 FC | mov     edx, [rbp+var_4]
0x004FF372 | 8D 4A 01 | lea     ecx, [rdx+1]
0x004FF375 | 89 4D FC | mov     [rbp+var_4], ecx
0x004FF378 | 48 63 CA | movsxd  rcx, edx
0x004FF37B | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x004FF37F | 48 01 CA | add     rdx, rcx
0x004FF382 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004FF385 | 88 02 | mov     [rdx], al
0x004FF387 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004FF38B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004FF38E | 84 C0 | test    al, al
0x004FF390 | 75 A5 | jnz     short loc_4FF337
0x004FF392 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004FF396 | C9 | leave
0x004FF397 | C3 | retn

 Ourput decompiled code:
static char *quote_special_chars(char *found)
{
	int l = 0;
	char *s = xzalloc((strlen(found) + 1) * 2);

	while (*found) {
		if (is_special_char(*found))
			s[l++] = '\\';
		s[l++] = *found++;
	}
	/* s[l] = '\0'; - already is */
	return s;
}

## Example:

 Input assembly code:
0x0042C232 | 55 | push    rbp
0x0042C233 | 48 89 E5 | mov     rbp, rsp
0x0042C236 | 48 83 EC 30 | sub     rsp, 30h
0x0042C23A | 48 89 7D D8 | mov     [rbp+s], rdi
0x0042C23E | 48 8B 45 D8 | mov     rax, [rbp+s]
0x0042C242 | 48 89 C7 | mov     rdi, rax; s
0x0042C245 | E8 86 A8 FD FF | call    _strlen
0x0042C24A | 89 45 F4 | mov     [rbp+var_C], eax
0x0042C24D | 8B 55 F4 | mov     edx, [rbp+var_C]
0x0042C250 | 89 D0 | mov     eax, edx
0x0042C252 | 01 C0 | add     eax, eax
0x0042C254 | 01 D0 | add     eax, edx
0x0042C256 | 01 C0 | add     eax, eax
0x0042C258 | 83 C0 01 | add     eax, 1
0x0042C25B | 48 98 | cdqe
0x0042C25D | 48 89 C7 | mov     rdi, rax
0x0042C260 | E8 FA DD FD FF | call    sub_40A05F
0x0042C265 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x0042C269 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0042C26D | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0042C271 | EB 49 | jmp     short loc_42C2BC
0x0042C273 | 0F B6 45 E7 | movzx   eax, [rbp+var_19]
0x0042C277 | 0F B6 C0 | movzx   eax, al
0x0042C27A | 89 C7 | mov     edi, eax
0x0042C27C | E8 09 F4 FF FF | call    sub_42B68A
0x0042C281 | 85 C0 | test    eax, eax
0x0042C283 | 74 14 | jz      short loc_42C299
0x0042C285 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0042C289 | 48 8D 50 01 | lea     rdx, [rax+1]
0x0042C28D | 48 89 55 F8 | mov     [rbp+var_8], rdx
0x0042C291 | 0F B6 55 E7 | movzx   edx, [rbp+var_19]
0x0042C295 | 88 10 | mov     [rax], dl
0x0042C297 | EB 23 | jmp     short loc_42C2BC
0x0042C299 | 0F B6 45 E7 | movzx   eax, [rbp+var_19]
0x0042C29D | 0F B6 D0 | movzx   edx, al
0x0042C2A0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0042C2A4 | BE 50 7B 51 00 | mov     esi, offset aD_1; "&#%d;"
0x0042C2A9 | 48 89 C7 | mov     rdi, rax; s
0x0042C2AC | B8 00 00 00 00 | mov     eax, 0
0x0042C2B1 | E8 CA B7 FD FF | call    _sprintf
0x0042C2B6 | 48 98 | cdqe
0x0042C2B8 | 48 01 45 F8 | add     [rbp+var_8], rax
0x0042C2BC | 48 8B 45 D8 | mov     rax, [rbp+s]
0x0042C2C0 | 48 8D 50 01 | lea     rdx, [rax+1]
0x0042C2C4 | 48 89 55 D8 | mov     [rbp+s], rdx
0x0042C2C8 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0042C2CB | 88 45 E7 | mov     [rbp+var_19], al
0x0042C2CE | 80 7D E7 00 | cmp     [rbp+var_19], 0
0x0042C2D2 | 75 9F | jnz     short loc_42C273
0x0042C2D4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0042C2D8 | C6 00 00 | mov     byte ptr [rax], 0
0x0042C2DB | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0042C2DF | C9 | leave
0x0042C2E0 | C3 | retn

 Ourput decompiled code:
static char *encodeString(const char *string)
{
	/* take the simple route and encode everything */
	/* could possibly scan once to get length.     */
	int len = strlen(string);
	char *out = xmalloc(len * 6 + 1);
	char *p = out;
	char ch;

	while ((ch = *string++) != '\0') {
		/* very simple check for what to encode */
		if (isalnum(ch))
			*p++ = ch;
		else
			p += sprintf(p, "&#%d;", (unsigned char) ch);
	}
	*p = '\0';
	return out;
}

## Example:

 Input assembly code:
0x0040AF13 | 55 | push    rbp
0x0040AF14 | 48 89 E5 | mov     rbp, rsp
0x0040AF17 | 48 83 EC 20 | sub     rsp, 20h
0x0040AF1B | 48 89 7D E8 | mov     [rbp+path], rdi
0x0040AF1F | 48 C7 45 F8 00 00 00 00 | mov     [rbp+buf], 0
0x0040AF27 | C7 45 F4 00 00 00 00 | mov     [rbp+var_C], 0
0x0040AF2E | C7 45 F0 00 00 00 00 | mov     [rbp+var_10], 0
0x0040AF35 | 83 45 F4 50 | add     [rbp+var_C], 50h ; 'P'
0x0040AF39 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x0040AF3C | 48 63 D0 | movsxd  rdx, eax
0x0040AF3F | 48 8B 45 F8 | mov     rax, [rbp+buf]
0x0040AF43 | 48 89 D6 | mov     rsi, rdx
0x0040AF46 | 48 89 C7 | mov     rdi, rax
0x0040AF49 | E8 50 F1 FF FF | call    sub_40A09E
0x0040AF4E | 48 89 45 F8 | mov     [rbp+buf], rax
0x0040AF52 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x0040AF55 | 48 63 D0 | movsxd  rdx, eax; len
0x0040AF58 | 48 8B 4D F8 | mov     rcx, [rbp+buf]
0x0040AF5C | 48 8B 45 E8 | mov     rax, [rbp+path]
0x0040AF60 | 48 89 CE | mov     rsi, rcx; buf
0x0040AF63 | 48 89 C7 | mov     rdi, rax; path
0x0040AF66 | E8 C5 B9 FF FF | call    _readlink
0x0040AF6B | 89 45 F0 | mov     [rbp+var_10], eax
0x0040AF6E | 83 7D F0 FF | cmp     [rbp+var_10], 0FFFFFFFFh
0x0040AF72 | 75 13 | jnz     short loc_40AF87
0x0040AF74 | 48 8B 45 F8 | mov     rax, [rbp+buf]
0x0040AF78 | 48 89 C7 | mov     rdi, rax; ptr
0x0040AF7B | E8 E0 B6 FF FF | call    _free
0x0040AF80 | B8 00 00 00 00 | mov     eax, 0
0x0040AF85 | EB 1C | jmp     short locret_40AFA3
0x0040AF87 | 8B 45 F0 | mov     eax, [rbp+var_10]
0x0040AF8A | 3B 45 F4 | cmp     eax, [rbp+var_C]
0x0040AF8D | 7D A6 | jge     short loc_40AF35
0x0040AF8F | 8B 45 F0 | mov     eax, [rbp+var_10]
0x0040AF92 | 48 63 D0 | movsxd  rdx, eax
0x0040AF95 | 48 8B 45 F8 | mov     rax, [rbp+buf]
0x0040AF99 | 48 01 D0 | add     rax, rdx
0x0040AF9C | C6 00 00 | mov     byte ptr [rax], 0
0x0040AF9F | 48 8B 45 F8 | mov     rax, [rbp+buf]
0x0040AFA3 | C9 | leave
0x0040AFA4 | C3 | retn

 Ourput decompiled code:
FAST_FUNC xmalloc_readlink(const char *path)
{
	enum { GROWBY = 80 }; /* how large we will grow strings by */

	char *buf = NULL;
	int bufsize = 0, readsize = 0;

	do {
		bufsize += GROWBY;
		buf = xrealloc(buf, bufsize);
		readsize = readlink(path, buf, bufsize);
		if (readsize == -1) {
			free(buf);
			return NULL;
		}
	} while (bufsize < readsize + 1);

	buf[readsize] = '\0';

	return buf;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004E8B82 | 55 | push    rbp
0x004E8B83 | 48 89 E5 | mov     rbp, rsp
0x004E8B86 | 48 83 EC 20 | sub     rsp, 20h
0x004E8B8A | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004E8B8E | 89 75 E4 | mov     [rbp+var_1C], esi
0x004E8B91 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004E8B94 | 83 C0 01 | add     eax, 1
0x004E8B97 | 48 98 | cdqe
0x004E8B99 | 48 89 C7 | mov     rdi, rax
0x004E8B9C | E8 BE 14 F2 FF | call    sub_40A05F
0x004E8BA1 | 48 89 45 F0 | mov     [rbp+s], rax
0x004E8BA5 | 48 C7 45 F8 37 6E 52 00 | mov     [rbp+var_8], offset aNTR; "\nn\tt\rr"
0x004E8BAD | EB 4A | jmp     short loc_4E8BF9
0x004E8BAF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E8BB3 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004E8BB6 | 0F BE F8 | movsx   edi, al
0x004E8BB9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E8BBD | 48 83 C0 01 | add     rax, 1
0x004E8BC1 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004E8BC4 | 0F BE C8 | movsx   ecx, al
0x004E8BC7 | 8B 55 E4 | mov     edx, [rbp+var_1C]
0x004E8BCA | 48 8B 75 E8 | mov     rsi, [rbp+var_18]
0x004E8BCE | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004E8BD2 | 41 89 F8 | mov     r8d, edi
0x004E8BD5 | 48 89 C7 | mov     rdi, rax
0x004E8BD8 | E8 B8 FE FF FF | call    sub_4E8A95
0x004E8BDD | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004E8BE1 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x004E8BE5 | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004E8BE9 | 48 89 C7 | mov     rdi, rax; s
0x004E8BEC | E8 DF DE F1 FF | call    _strlen
0x004E8BF1 | 89 45 E4 | mov     [rbp+var_1C], eax
0x004E8BF4 | 48 83 45 F8 02 | add     [rbp+var_8], 2
0x004E8BF9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E8BFD | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004E8C00 | 84 C0 | test    al, al
0x004E8C02 | 75 AB | jnz     short loc_4E8BAF
0x004E8C04 | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004E8C08 | C9 | leave
0x004E8C09 | C3 | retn
 ************ 
Source Code:
static char *copy_parsing_escapes(const char *string, int len)
{
	const char *s;
	char *dest = xmalloc(len + 1);

	/* sed recognizes 
 */
	/* GNU sed also recognizes \t and \r */
	for (s = "
n\tt\rr"; *s; s += 2) {
		parse_escapes(dest, string, len, s[1], s[0]);
		string = dest;
		len = strlen(dest);
	}
	return dest;
}
 ************ 
Parsed Output:
static char *process_string(const char *input)
{
    int len = strlen(input);
    char *output = malloc(len + 1);
    int i;

    for (i = 0; i < len; i++) {
        if (input[i] == '
') {
            output[i] = '\\';
            output[i+1] = 'n';
            i++;
        } else if (input[i] == '\t') {
            output[i] = '\\';
            output[i+1] = 't';
            i++;
        } else if (input[i] == '\r') {
            output[i] = '\\';
            output[i+1] = 'r';
            i++;
        } else {
            output[i] = input[i];
        }
    }
    output[len] = '\0';

    return output;
}
 ************ 
Similarity Score (Unixcoder): 0.7082924842834473
Func rank: 48

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: func_tty
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00417CF4 | 55 | push    rbp
0x00417CF5 | 48 89 E5 | mov     rbp, rsp
0x00417CF8 | 48 83 EC 20 | sub     rsp, 20h
0x00417CFC | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00417D00 | 89 75 F4 | mov     [rbp+var_C], esi
0x00417D03 | 48 89 55 E8 | mov     [rbp+var_18], rdx
0x00417D07 | 89 4D F0 | mov     [rbp+var_10], ecx
0x00417D0A | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00417D0D | 48 98 | cdqe
0x00417D0F | 48 8D 14 00 | lea     rdx, [rax+rax]
0x00417D13 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00417D17 | 48 01 D0 | add     rax, rdx
0x00417D1A | 0F B7 00 | movzx   eax, word ptr [rax]
0x00417D1D | 66 85 C0 | test    ax, ax
0x00417D20 | 74 33 | jz      short loc_417D55
0x00417D22 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00417D26 | 48 89 C6 | mov     rsi, rax
0x00417D29 | BF 0B 53 51 00 | mov     edi, offset a20s; "\t%-20s"
0x00417D2E | B8 00 00 00 00 | mov     eax, 0
0x00417D33 | E8 98 EE FE FF | call    _printf
0x00417D38 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00417D3B | 48 98 | cdqe
0x00417D3D | 48 8D 14 00 | lea     rdx, [rax+rax]
0x00417D41 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00417D45 | 48 01 C2 | add     rdx, rax
0x00417D48 | 8B 45 F0 | mov     eax, [rbp+var_10]
0x00417D4B | 89 C6 | mov     esi, eax
0x00417D4D | 48 89 D7 | mov     rdi, rdx
0x00417D50 | E8 0F FF FF FF | call    sub_417C64
0x00417D55 | 90 | nop
0x00417D56 | C9 | leave
0x00417D57 | C3 | retn

 Ourput decompiled code:
static void xprint_ascii(uint16_t *val, int i, const char *string, int n)
{
	if (val[i]) {
		printf("\t%-20s", string);
		print_ascii((void*)&val[i], n);
	}
}

## Example:

 Input assembly code:
0x00481463 | 55 | push    rbp
0x00481464 | 48 89 E5 | mov     rbp, rsp
0x00481467 | 48 83 EC 10 | sub     rsp, 10h
0x0048146B | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0048146F | 89 75 F4 | mov     [rbp+var_C], esi
0x00481472 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00481476 | BE 01 00 00 00 | mov     esi, 1
0x0048147B | 48 89 C7 | mov     rdi, rax
0x0048147E | E8 68 FF FF FF | call    sub_4813EB
0x00481483 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00481487 | 48 8B 10 | mov     rdx, [rax]
0x0048148A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048148E | 8B 40 08 | mov     eax, [rax+8]
0x00481491 | 48 98 | cdqe
0x00481493 | 48 01 D0 | add     rax, rdx
0x00481496 | 8B 55 F4 | mov     edx, [rbp+var_C]
0x00481499 | 88 10 | mov     [rax], dl
0x0048149B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048149F | 8B 40 08 | mov     eax, [rax+8]
0x004814A2 | 8D 50 01 | lea     edx, [rax+1]
0x004814A5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004814A9 | 89 50 08 | mov     [rax+8], edx
0x004814AC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004814B0 | 48 8B 10 | mov     rdx, [rax]
0x004814B3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004814B7 | 8B 40 08 | mov     eax, [rax+8]
0x004814BA | 48 98 | cdqe
0x004814BC | 48 01 D0 | add     rax, rdx
0x004814BF | C6 00 00 | mov     byte ptr [rax], 0
0x004814C2 | 90 | nop
0x004814C3 | C9 | leave
0x004814C4 | C3 | retn

 Ourput decompiled code:
static void o_addchr(o_string *o, int ch)
{
	debug_printf("o_addchr: '%c' o->length=%d o=%p\n", ch, o->length, o);
	o_grow_by(o, 1);
	o->data[o->length] = ch;
	o->length++;
	o->data[o->length] = '\0';
}

## Example:

 Input assembly code:
0x004D39DE | 55 | push    rbp
0x004D39DF | 48 89 E5 | mov     rbp, rsp
0x004D39E2 | 48 83 EC 20 | sub     rsp, 20h
0x004D39E6 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004D39EA | 89 75 E4 | mov     [rbp+var_1C], esi
0x004D39ED | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D39F1 | 8B 40 0C | mov     eax, [rax+0Ch]
0x004D39F4 | 89 C6 | mov     esi, eax
0x004D39F6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D39FA | 8B 40 08 | mov     eax, [rax+8]
0x004D39FD | 89 C1 | mov     ecx, eax
0x004D39FF | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D3A03 | 8B 40 04 | mov     eax, [rax+4]
0x004D3A06 | 89 C2 | mov     edx, eax
0x004D3A08 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D3A0C | 8B 00 | mov     eax, [rax]
0x004D3A0E | 89 C0 | mov     eax, eax
0x004D3A10 | 49 89 F0 | mov     r8, rsi
0x004D3A13 | 48 89 C6 | mov     rsi, rax
0x004D3A16 | BF 38 40 52 00 | mov     edi, offset aLxLxLxLx; "%lx:%lx:%lx:%lx"
0x004D3A1B | B8 00 00 00 00 | mov     eax, 0
0x004D3A20 | E8 AB 31 F3 FF | call    _printf
0x004D3A25 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004D3A2C | EB 26 | jmp     short loc_4D3A54
0x004D3A2E | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x004D3A32 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004D3A35 | 48 98 | cdqe
0x004D3A37 | 0F B6 44 02 11 | movzx   eax, byte ptr [rdx+rax+11h]
0x004D3A3C | 0F B6 C0 | movzx   eax, al
0x004D3A3F | 89 C6 | mov     esi, eax
0x004D3A41 | BF 48 40 52 00 | mov     edi, offset asc_524048; ":%x"
0x004D3A46 | B8 00 00 00 00 | mov     eax, 0
0x004D3A4B | E8 80 31 F3 FF | call    _printf
0x004D3A50 | 83 45 FC 01 | add     [rbp+var_4], 1
0x004D3A54 | 83 7D FC 1F | cmp     [rbp+var_4], 1Fh
0x004D3A58 | 7E D4 | jle     short loc_4D3A2E
0x004D3A5A | BF 0A 00 00 00 | mov     edi, 0Ah
0x004D3A5F | E8 F5 6B F3 FF | call    sub_40A659
0x004D3A64 | 90 | nop
0x004D3A65 | C9 | leave
0x004D3A66 | C3 | retn

 Ourput decompiled code:
static void display_recoverable(const struct termios *mode,
				int UNUSED_PARAM dummy)
{
	int i;
	printf("%lx:%lx:%lx:%lx",
		   (unsigned long) mode->c_iflag, (unsigned long) mode->c_oflag,
		   (unsigned long) mode->c_cflag, (unsigned long) mode->c_lflag);
	for (i = 0; i < NCCS; ++i)
		printf(":%x", (unsigned int) mode->c_cc[i]);
	bb_putchar('\n');
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004633DC | 55 | push    rbp
0x004633DD | 48 89 E5 | mov     rbp, rsp
0x004633E0 | 48 83 EC 20 | sub     rsp, 20h
0x004633E4 | 48 89 7D F8 | mov     [rbp+s], rdi
0x004633E8 | 89 75 F4 | mov     [rbp+var_C], esi
0x004633EB | 48 89 55 E8 | mov     [rbp+var_18], rdx
0x004633EF | 48 8B 45 F8 | mov     rax, [rbp+s]
0x004633F3 | C6 00 3F | mov     byte ptr [rax], 3Fh ; '?'
0x004633F6 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x004633FA | 48 83 C0 01 | add     rax, 1
0x004633FE | C6 00 00 | mov     byte ptr [rax], 0
0x00463401 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00463405 | 8B 40 7C | mov     eax, [rax+7Ch]
0x00463408 | 85 C0 | test    eax, eax
0x0046340A | 74 35 | jz      short loc_463441
0x0046340C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00463410 | 8B 88 80 00 00 00 | mov     ecx, [rax+80h]
0x00463416 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0046341A | 8B 50 7C | mov     edx, [rax+7Ch]
0x0046341D | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00463420 | 83 C0 01 | add     eax, 1
0x00463423 | 48 63 F0 | movsxd  rsi, eax; maxlen
0x00463426 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x0046342A | 41 89 C8 | mov     r8d, ecx
0x0046342D | 89 D1 | mov     ecx, edx
0x0046342F | BA 12 BF 51 00 | mov     edx, offset aUU_2; "%u,%u"
0x00463434 | 48 89 C7 | mov     rdi, rax; s
0x00463437 | B8 00 00 00 00 | mov     eax, 0
0x0046343C | E8 CF 37 FA FF | call    _snprintf
0x00463441 | 90 | nop
0x00463442 | C9 | leave
0x00463443 | C3 | retn
 ************ 
Source Code:
static void func_tty(char *buf, int size, const procps_status_t *ps)
{
	buf[0] = '?';
	buf[1] = '\0';
	if (ps->tty_major) /* tty field of "0" means "no tty" */
		snprintf(buf, size+1, "%u,%u", ps->tty_major, ps->tty_minor);
}
 ************ 
Parsed Output:
static void process_string(char *s, int n) {
    s[0] = '?';
    s[1] = '\0';
    if (n != 0) {
        int len = snprintf(s, n, "%u,%u", s[0x7C], s[0x7C] + 1);
        s[len] = '\0';
    }
}
 ************ 
Similarity Score (Unixcoder): 0.7078933715820312
Func rank: 49

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: block_CHLD_HUP_ALRM
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00482419 | 55 | push    rbp
0x0048241A | 48 89 E5 | mov     rbp, rsp
0x0048241D | 48 83 EC 10 | sub     rsp, 10h
0x00482421 | 48 89 7D F8 | mov     [rbp+s], rdi
0x00482425 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x00482429 | BA 30 00 00 00 | mov     edx, 30h ; '0'; n
0x0048242E | BE 00 00 00 00 | mov     esi, 0; c
0x00482433 | 48 89 C7 | mov     rdi, rax; s
0x00482436 | E8 15 49 F8 FF | call    _memset
0x0048243B | E8 A0 FD FF FF | call    sub_4821E0
0x00482440 | 48 89 C2 | mov     rdx, rax
0x00482443 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x00482447 | 48 89 10 | mov     [rax], rdx
0x0048244A | 48 8B 45 F8 | mov     rax, [rbp+s]
0x0048244E | 48 8B 10 | mov     rdx, [rax]
0x00482451 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x00482455 | 48 89 50 08 | mov     [rax+8], rdx
0x00482459 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x0048245D | 48 89 C7 | mov     rdi, rax
0x00482460 | E8 97 FD FF FF | call    sub_4821FC
0x00482465 | 90 | nop
0x00482466 | C9 | leave
0x00482467 | C3 | retn

 Ourput decompiled code:
static void initialize_context(struct parse_context *ctx)
{
	memset(ctx, 0, sizeof(*ctx));
	ctx->pipe = ctx->list_head = new_pipe();
	/* Create the memory for command, roughly:
	 * ctx->pipe->cmds = new struct command;
	 * ctx->command = &ctx->pipe->cmds[0];
	 */
	done_command(ctx);
}

## Example:

 Input assembly code:
0x004DA7BB | 55 | push    rbp
0x004DA7BC | 48 89 E5 | mov     rbp, rsp
0x004DA7BF | 48 83 EC 10 | sub     rsp, 10h
0x004DA7C3 | 48 89 7D F8 | mov     [rbp+ptr], rdi
0x004DA7C7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004DA7CB | 48 8B 40 10 | mov     rax, [rax+10h]
0x004DA7CF | 48 89 C7 | mov     rdi, rax; ptr
0x004DA7D2 | E8 89 BE F2 FF | call    _free
0x004DA7D7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004DA7DB | 48 8B 40 18 | mov     rax, [rax+18h]
0x004DA7DF | 48 89 C7 | mov     rdi, rax; ptr
0x004DA7E2 | E8 79 BE F2 FF | call    _free
0x004DA7E7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004DA7EB | 48 8B 40 20 | mov     rax, [rax+20h]
0x004DA7EF | 48 89 C7 | mov     rdi, rax; ptr
0x004DA7F2 | E8 69 BE F2 FF | call    _free
0x004DA7F7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004DA7FB | 48 89 C7 | mov     rdi, rax; ptr
0x004DA7FE | E8 5D BE F2 FF | call    _free
0x004DA803 | 90 | nop
0x004DA804 | C9 | leave
0x004DA805 | C3 | retn

 Ourput decompiled code:
static void free_instance(struct fsck_instance *p)
{
	free(p->prog);
	free(p->device);
	free(p->base_device);
	free(p);
}

## Example:

 Input assembly code:
0x00481399 | 55 | push    rbp
0x0048139A | 48 89 E5 | mov     rbp, rsp
0x0048139D | 48 83 EC 10 | sub     rsp, 10h
0x004813A1 | 48 89 7D F8 | mov     [rbp+s], rdi
0x004813A5 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x004813A9 | 48 8B 00 | mov     rax, [rax]
0x004813AC | 48 89 C7 | mov     rdi, rax; ptr
0x004813AF | E8 AC 52 F8 FF | call    _free
0x004813B4 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x004813B8 | BA 18 00 00 00 | mov     edx, 18h; n
0x004813BD | BE 00 00 00 00 | mov     esi, 0; c
0x004813C2 | 48 89 C7 | mov     rdi, rax; s
0x004813C5 | E8 86 59 F8 FF | call    _memset
0x004813CA | 90 | nop
0x004813CB | C9 | leave
0x004813CC | C3 | retn

 Ourput decompiled code:
static void o_free(o_string *o)
{
	free(o->data);
	memset(o, 0, sizeof(*o));
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00433B6A | 55 | push    rbp
0x00433B6B | 48 89 E5 | mov     rbp, rsp
0x00433B6E | 48 83 EC 10 | sub     rsp, 10h
0x00433B72 | 48 89 7D F8 | mov     [rbp+set], rdi
0x00433B76 | 48 8B 45 F8 | mov     rax, [rbp+set]
0x00433B7A | 48 89 C7 | mov     rdi, rax; set
0x00433B7D | E8 7E 35 FD FF | call    _sigemptyset
0x00433B82 | 48 8B 45 F8 | mov     rax, [rbp+set]
0x00433B86 | BE 11 00 00 00 | mov     esi, 11h; signo
0x00433B8B | 48 89 C7 | mov     rdi, rax; set
0x00433B8E | E8 FD 40 FD FF | call    _sigaddset
0x00433B93 | 48 8B 45 F8 | mov     rax, [rbp+set]
0x00433B97 | BE 01 00 00 00 | mov     esi, 1; signo
0x00433B9C | 48 89 C7 | mov     rdi, rax; set
0x00433B9F | E8 EC 40 FD FF | call    _sigaddset
0x00433BA4 | 48 8B 45 F8 | mov     rax, [rbp+set]
0x00433BA8 | BE 0E 00 00 00 | mov     esi, 0Eh; signo
0x00433BAD | 48 89 C7 | mov     rdi, rax; set
0x00433BB0 | E8 DB 40 FD FF | call    _sigaddset
0x00433BB5 | 48 8B 55 F8 | mov     rdx, [rbp+set]; oset
0x00433BB9 | 48 8B 45 F8 | mov     rax, [rbp+set]
0x00433BBD | 48 89 C6 | mov     rsi, rax; set
0x00433BC0 | BF 00 00 00 00 | mov     edi, 0; how
0x00433BC5 | E8 76 2A FD FF | call    _sigprocmask
0x00433BCA | 90 | nop
0x00433BCB | C9 | leave
0x00433BCC | C3 | retn
 ************ 
Source Code:
static void block_CHLD_HUP_ALRM(sigset_t *m)
{
	sigemptyset(m);
	sigaddset(m, SIGCHLD);
	sigaddset(m, SIGHUP);
	sigaddset(m, SIGALRM);
	sigprocmask(SIG_BLOCK, m, m); /* old sigmask is stored in m */
}
 ************ 
Parsed Output:
static void initialize_signal_set(sigset_t *set)
{
    sigemptyset(set);
    sigaddset(set, 0x11);
    sigaddset(set, 0x01);
    sigaddset(set, 0x0E);
    sigprocmask(0, set, set);
}
 ************ 
Similarity Score (Unixcoder): 0.7070642709732056
Func rank: 50

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: reset_main
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00421726 | 55 | push    rbp
0x00421727 | 48 89 E5 | mov     rbp, rsp
0x0042172A | 48 83 EC 10 | sub     rsp, 10h
0x0042172E | 89 7D FC | mov     [rbp+var_4], edi
0x00421731 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x00421735 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00421739 | 48 89 C7 | mov     rdi, rax
0x0042173C | E8 B8 6E 0E 00 | call    sub_5085F9
0x00421741 | BE 00 00 00 00 | mov     esi, 0
0x00421746 | 48 89 C7 | mov     rdi, rax
0x00421749 | E8 47 8B FE FF | call    sub_40A295
0x0042174E | B9 9A 56 53 00 | mov     ecx, offset aRaidAutorun; "RAID_AUTORUN"
0x00421753 | BA 00 00 00 00 | mov     edx, 0
0x00421758 | BE 14 09 00 00 | mov     esi, 914h
0x0042175D | 89 C7 | mov     edi, eax
0x0042175F | E8 ED 95 FE FF | call    sub_40AD51
0x00421764 | B8 00 00 00 00 | mov     eax, 0
0x00421769 | C9 | leave
0x0042176A | C3 | retn

 Ourput decompiled code:
int raidautorun_main(int argc UNUSED_PARAM, char **argv)
{
	xioctl(xopen(single_argv(argv), O_RDONLY), RAID_AUTORUN, NULL);
	return EXIT_SUCCESS;
}

## Example:

 Input assembly code:
0x0040A52C | 55 | push    rbp
0x0040A52D | 48 89 E5 | mov     rbp, rsp
0x0040A530 | 48 83 EC 10 | sub     rsp, 10h
0x0040A534 | 89 7D FC | mov     [rbp+fd], edi
0x0040A537 | 8B 45 FC | mov     eax, [rbp+fd]
0x0040A53A | 89 C7 | mov     edi, eax; fd
0x0040A53C | E8 CF C8 FF FF | call    _close
0x0040A541 | 85 C0 | test    eax, eax
0x0040A543 | 74 0F | jz      short loc_40A554
0x0040A545 | BF 8C 80 52 00 | mov     edi, offset aCloseFailed; "close failed"
0x0040A54A | B8 00 00 00 00 | mov     eax, 0
0x0040A54F | E8 4E ED FF FF | call    sub_4092A2
0x0040A554 | 90 | nop
0x0040A555 | C9 | leave
0x0040A556 | C3 | retn

 Ourput decompiled code:
void FAST_FUNC xclose(int fd)
{
	if (close(fd))
		bb_perror_msg_and_die("close failed");
}

## Example:

 Input assembly code:
0x0040A851 | 55 | push    rbp
0x0040A852 | 48 89 E5 | mov     rbp, rsp
0x0040A855 | 48 83 EC 10 | sub     rsp, 10h
0x0040A859 | 89 7D FC | mov     [rbp+gid], edi
0x0040A85C | 8B 45 FC | mov     eax, [rbp+gid]
0x0040A85F | 89 C7 | mov     edi, eax; gid
0x0040A861 | E8 0A CF FF FF | call    _setgid
0x0040A866 | 85 C0 | test    eax, eax
0x0040A868 | 74 0F | jz      short loc_40A879
0x0040A86A | BF D4 80 52 00 | mov     edi, offset aSetgid_0; "setgid"
0x0040A86F | B8 00 00 00 00 | mov     eax, 0
0x0040A874 | E8 29 EA FF FF | call    sub_4092A2
0x0040A879 | 90 | nop
0x0040A87A | C9 | leave
0x0040A87B | C3 | retn

 Ourput decompiled code:
void FAST_FUNC xsetgid(gid_t gid)
{
	if (setgid(gid)) bb_perror_msg_and_die("setgid");
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004C464E | 55 | push    rbp
0x004C464F | 48 89 E5 | mov     rbp, rsp
0x004C4652 | 48 83 EC 10 | sub     rsp, 10h
0x004C4656 | 89 7D FC | mov     [rbp+var_4], edi
0x004C4659 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004C465D | BF 01 00 00 00 | mov     edi, 1; fd
0x004C4662 | E8 F9 21 F4 FF | call    _isatty
0x004C4667 | 85 C0 | test    eax, eax
0x004C4669 | 74 20 | jz      short loc_4C468B
0x004C466B | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; "\x1Bc\x1B(B\x1B[0m\x1B[J\x1B[?25h"
0x004C4670 | B8 00 00 00 00 | mov     eax, 0
0x004C4675 | E8 56 25 F4 FF | call    _printf
0x004C467A | BE 50 6D 52 00 | mov     esi, offset off_526D50; "stty"
0x004C467F | BF 02 00 00 00 | mov     edi, 2
0x004C4684 | E8 7D FE 00 00 | call    sub_4D4506
0x004C4689 | EB 05 | jmp     short locret_4C4690
0x004C468B | B8 00 00 00 00 | mov     eax, 0
0x004C4690 | C9 | leave
0x004C4691 | C3 | retn
 ************ 
Source Code:
int reset_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	static const char *const args[] = {
		"stty", "sane", NULL
	};

	/* no options, no getopt */

	if (/*isatty(STDIN_FILENO) &&*/ isatty(STDOUT_FILENO)) {
		/* See 'man 4 console_codes' for details:
		 * "ESC c"        -- Reset
		 * "ESC ( B"      -- Select G0 Character Set (B = US)
		 * "ESC [ 0 m"    -- Reset all display attributes
		 * "ESC [ J"      -- Erase to the end of screen
		 * "ESC [ ? 25 h" -- Make cursor visible
		 */
		printf(ESC"c" ESC"(B" ESC"[0m" ESC"[J" ESC"[?25h");
		/* http://bugs.busybox.net/view.php?id=1414:
		 * people want it to reset echo etc: */
#if ENABLE_STTY
		return stty_main(2, (char**)args);
#else
		execvp("stty", (char**)args);
#endif
	}
	return EXIT_SUCCESS;
}
 ************ 
Parsed Output:
int main(int argc, char **argv)
{
    int fd = 1;
    if (_isatty(fd) == 0)
    {
        printf("\x1Bc\x1B(B\x1B[0m\x1B[J\x1B[?25h");
    }
    sub_4D4506(2, "stty");
    return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.7016666531562805
Func rank: 51

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: dirname_main
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0047F17A | 55 | push    rbp
0x0047F17B | 48 89 E5 | mov     rbp, rsp
0x0047F17E | 48 83 EC 10 | sub     rsp, 10h
0x0047F182 | 89 7D FC | mov     [rbp+var_4], edi
0x0047F185 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x0047F189 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0047F18D | 48 89 C7 | mov     rdi, rax
0x0047F190 | E8 7E CD 00 00 | call    sub_48BF13
0x0047F195 | C9 | leave
0x0047F196 | C3 | retn

 Ourput decompiled code:
static int FAST_FUNC
ulimitcmd(int argc UNUSED_PARAM, char **argv)
{
	return shell_builtin_ulimit(argv);
}

## Example:

 Input assembly code:
0x004D8AD5 | 55 | push    rbp
0x004D8AD6 | 48 89 E5 | mov     rbp, rsp
0x004D8AD9 | 48 83 EC 10 | sub     rsp, 10h
0x004D8ADD | 89 7D FC | mov     [rbp+var_4], edi
0x004D8AE0 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004D8AE4 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004D8AE8 | 48 83 C0 08 | add     rax, 8
0x004D8AEC | 48 8B 00 | mov     rax, [rax]
0x004D8AEF | 48 85 C0 | test    rax, rax
0x004D8AF2 | 74 05 | jz      short loc_4D8AF9
0x004D8AF4 | E8 6B F4 F2 FF | call    sub_407F64
0x004D8AF9 | E8 62 E2 F2 FF | call    _geteuid
0x004D8AFE | 89 C7 | mov     edi, eax
0x004D8B00 | E8 6C D8 01 00 | call    sub_4F6371
0x004D8B05 | 48 89 C7 | mov     rdi, rax; s
0x004D8B08 | E8 03 DD F2 FF | call    _puts
0x004D8B0D | E8 37 1B F3 FF | call    sub_40A649
0x004D8B12 | C9 | leave
0x004D8B13 | C3 | retn

 Ourput decompiled code:
int whoami_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	if (argv[1])
		bb_show_usage();

	/* Will complain and die if username not found */
	puts(xuid2uname(geteuid()));

	return fflush_all();
}

## Example:

 Input assembly code:
0x0044629E | 55 | push    rbp
0x0044629F | 48 89 E5 | mov     rbp, rsp
0x004462A2 | 48 83 EC 10 | sub     rsp, 10h
0x004462A6 | 89 7D FC | mov     [rbp+var_4], edi
0x004462A9 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004462AD | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004462B1 | 48 89 C6 | mov     rsi, rax
0x004462B4 | BF 00 00 00 00 | mov     edi, 0
0x004462B9 | E8 F9 F2 FF FF | call    sub_4455B7
0x004462BE | C9 | leave
0x004462BF | C3 | retn

 Ourput decompiled code:
int traceroute_main(int argc UNUSED_PARAM, char **argv)
{
	return common_traceroute_main(0, argv);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004C8347 | 55 | push    rbp
0x004C8348 | 48 89 E5 | mov     rbp, rsp
0x004C834B | 48 83 EC 10 | sub     rsp, 10h
0x004C834F | 89 7D FC | mov     [rbp+var_4], edi
0x004C8352 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004C8356 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004C835A | 48 89 C7 | mov     rdi, rax
0x004C835D | E8 97 02 04 00 | call    sub_5085F9
0x004C8362 | 48 89 C7 | mov     rdi, rax; path
0x004C8365 | E8 16 E9 F3 FF | call    _dirname
0x004C836A | 48 89 C7 | mov     rdi, rax; s
0x004C836D | E8 9E E4 F3 FF | call    _puts
0x004C8372 | E8 D2 22 F4 FF | call    sub_40A649
0x004C8377 | C9 | leave
0x004C8378 | C3 | retn
 ************ 
Source Code:
int dirname_main(int argc UNUSED_PARAM, char **argv)
{
	puts(dirname(single_argv(argv)));
	return fflush_all();
}
 ************ 
Parsed Output:
int main(int argc UNUSED_PARAM, char **argv)
{
    int var_4 = edi;
    int var_10 = esi;
    int rax = var_10;
    int rdi = rax;
    sub_5085F9(rdi);
    rdi = rax;
    _dirname(rdi);
    rdi = rax;
    _puts(rdi);
    sub_40A649();
    leave();
    return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.6958051919937134
Func rank: 52

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: gotsig
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0048C5A7 | 55 | push    rbp
0x0048C5A8 | 48 89 E5 | mov     rbp, rsp
0x0048C5AB | 48 83 EC 10 | sub     rsp, 10h
0x0048C5AF | 89 7D FC | mov     [rbp+var_4], edi
0x0048C5B2 | BE 01 00 00 00 | mov     esi, 1; handler
0x0048C5B7 | BF 02 00 00 00 | mov     edi, 2; sig
0x0048C5BC | E8 AF AA F7 FF | call    _signal
0x0048C5C1 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0048C5C6 | 48 8B 40 18 | mov     rax, [rax+18h]
0x0048C5CA | 48 89 C7 | mov     rdi, rax; shmaddr
0x0048C5CD | E8 3E A3 F7 FF | call    _shmdt
0x0048C5D2 | BF 00 00 00 00 | mov     edi, 0; status
0x0048C5D7 | E8 E4 B4 F7 FF | call    _exit

 Ourput decompiled code:
static void interrupted(int sig UNUSED_PARAM)
{
	signal(SIGINT, SIG_IGN);
	shmdt(shbuf);
	exit(EXIT_SUCCESS);
}

## Example:

 Input assembly code:
0x004C4692 | 55 | push    rbp
0x004C4693 | 48 89 E5 | mov     rbp, rsp
0x004C4696 | 48 83 EC 10 | sub     rsp, 10h
0x004C469A | 89 7D FC | mov     [rbp+var_4], edi
0x004C469D | BA F8 B3 75 00 | mov     edx, offset dest; termios_p
0x004C46A2 | BE 00 00 00 00 | mov     esi, 0; optional_actions
0x004C46A7 | BF 02 00 00 00 | mov     edi, 2; fd
0x004C46AC | E8 1F 31 F4 FF | call    _tcsetattr
0x004C46B1 | BF 01 00 00 00 | mov     edi, 1; status
0x004C46B6 | E8 05 21 F4 FF | call    __exit

 Ourput decompiled code:
static void
onintr(int sig UNUSED_PARAM)
{
	tcsetattr(STDERR_FILENO, TCSANOW, old_termios_p);
	_exit(EXIT_FAILURE);
}

## Example:

 Input assembly code:
0x004EF4E0 | 55 | push    rbp
0x004EF4E1 | 48 89 E5 | mov     rbp, rsp
0x004EF4E4 | 48 83 EC 10 | sub     rsp, 10h
0x004EF4E8 | 89 7D FC | mov     [rbp+val], edi
0x004EF4EB | BE E0 F4 4E 00 | mov     esi, offset sub_4EF4E0; handler
0x004EF4F0 | BF 02 00 00 00 | mov     edi, 2; sig
0x004EF4F5 | E8 76 7B F1 FF | call    _signal
0x004EF4FA | 48 8B 05 07 DF 26 00 | mov     rax, cs:qword_75D408
0x004EF501 | 48 8D 90 88 02 00 00 | lea     rdx, [rax+288h]
0x004EF508 | 8B 45 FC | mov     eax, [rbp+val]
0x004EF50B | 89 C6 | mov     esi, eax; val
0x004EF50D | 48 89 D7 | mov     rdi, rdx; env
0x004EF510 | E8 3B 77 F1 FF | call    _siglongjmp

 Ourput decompiled code:
static void catch_sig(int sig)
{
	signal(SIGINT, catch_sig);
	siglongjmp(restart, sig);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004A181C | 55 | push    rbp
0x004A181D | 48 89 E5 | mov     rbp, rsp
0x004A1820 | 48 83 EC 10 | sub     rsp, 10h
0x004A1824 | 89 7D FC | mov     [rbp+var_4], edi
0x004A1827 | BF 0A 00 00 00 | mov     edi, 0Ah
0x004A182C | E8 58 85 F6 FF | call    sub_409D89
0x004A1831 | BA FC B3 75 00 | mov     edx, offset dest.c_oflag; termios_p
0x004A1836 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004A183B | 8B 00 | mov     eax, [rax]
0x004A183D | BE 00 00 00 00 | mov     esi, 0; optional_actions
0x004A1842 | 89 C7 | mov     edi, eax; fd
0x004A1844 | E8 87 5F F6 FF | call    _tcsetattr
0x004A1849 | BF 01 00 00 00 | mov     edi, 1; status
0x004A184E | E8 6D 4F F6 FF | call    __exit
 ************ 
Source Code:
static void gotsig(int sig UNUSED_PARAM)
{
	/* bb_putchar_stderr doesn't use stdio buffering,
	 * therefore it is safe in signal handler */
	bb_putchar_stderr('
');
	setTermSettings(cin_fileno, &initial_settings);
	_exit(EXIT_FAILURE);
}
 ************ 
Parsed Output:
static void set_terminal_attributes(int var_4)
{
    sub_409D89(0x0A);
    tcsetattr(fd, TCSANOW, &dest);
    exit(1);
}
 ************ 
Similarity Score (Unixcoder): 0.6956831216812134
Func rank: 53

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: rawmode
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0044254C | 55 | push    rbp
0x0044254D | 48 89 E5 | mov     rbp, rsp
0x00442550 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00442555 | 0F B6 40 08 | movzx   eax, byte ptr [rax+8]
0x00442559 | 84 C0 | test    al, al
0x0044255B | 74 17 | jz      short loc_442574
0x0044255D | B8 20 B5 75 00 | mov     eax, offset stru_75B520
0x00442562 | 48 89 C2 | mov     rdx, rax; termios_p
0x00442565 | BE 01 00 00 00 | mov     esi, 1; optional_actions
0x0044256A | BF 00 00 00 00 | mov     edi, 0; fd
0x0044256F | E8 5C 52 FC FF | call    _tcsetattr
0x00442574 | 90 | nop
0x00442575 | 5D | pop     rbp
0x00442576 | C3 | retn

 Ourput decompiled code:
static void cookmode(void)
{
	fflush_all();
	tcsetattr_stdin_TCSANOW(&term_orig);
}

## Example:

 Input assembly code:
0x00433B43 | 55 | push    rbp
0x00433B44 | 48 89 E5 | mov     rbp, rsp
0x00433B47 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00433B4C | 0F B6 40 30 | movzx   eax, byte ptr [rax+30h]
0x00433B50 | 84 C0 | test    al, al
0x00433B52 | 75 13 | jnz     short loc_433B67
0x00433B54 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00433B59 | C6 40 30 01 | mov     byte ptr [rax+30h], 1
0x00433B5D | BF 3C 00 00 00 | mov     edi, 3Ch ; '<'; seconds
0x00433B62 | E8 89 32 FD FF | call    _alarm
0x00433B67 | 90 | nop
0x00433B68 | 5D | pop     rbp
0x00433B69 | C3 | retn

 Ourput decompiled code:
static void rearm_alarm(void)
{
	if (!alarm_armed) {
		alarm_armed = 1;
		alarm(RETRYTIME);
	}
}

## Example:

 Input assembly code:
0x004D36C5 | 55 | push    rbp
0x004D36C6 | 48 89 E5 | mov     rbp, rsp
0x004D36C9 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004D36CE | 8B 40 0C | mov     eax, [rax+0Ch]
0x004D36D1 | 85 C0 | test    eax, eax
0x004D36D3 | 74 0F | jz      short loc_4D36E4
0x004D36D5 | BF AA 3F 52 00 | mov     edi, offset asc_523FAA; "\n"
0x004D36DA | B8 00 00 00 00 | mov     eax, 0
0x004D36DF | E8 5D FE FF FF | call    sub_4D3541
0x004D36E4 | 90 | nop
0x004D36E5 | 5D | pop     rbp
0x004D36E6 | C3 | retn

 Ourput decompiled code:
static void newline(void)
{
	if (G.current_col != 0)
		wrapf("\n");
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00442521 | 55 | push    rbp
0x00442522 | 48 89 E5 | mov     rbp, rsp
0x00442525 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0044252A | 0F B6 40 08 | movzx   eax, byte ptr [rax+8]
0x0044252E | 84 C0 | test    al, al
0x00442530 | 74 17 | jz      short loc_442549
0x00442532 | B8 5C B5 75 00 | mov     eax, offset termios_p
0x00442537 | 48 89 C2 | mov     rdx, rax; termios_p
0x0044253A | BE 01 00 00 00 | mov     esi, 1; optional_actions
0x0044253F | BF 00 00 00 00 | mov     edi, 0; fd
0x00442544 | E8 87 52 FC FF | call    _tcsetattr
0x00442549 | 90 | nop
0x0044254A | 5D | pop     rbp
0x0044254B | C3 | retn
 ************ 
Source Code:
static void rawmode(void)
{
	tcgetattr(0, &term_orig);
	term_vi = term_orig;
	term_vi.c_lflag &= (~ICANON & ~ECHO);	// leave ISIG on - allow intr's
	term_vi.c_iflag &= (~IXON & ~ICRNL);
	term_vi.c_oflag &= (~ONLCR);
	term_vi.c_cc[VMIN] = 1;
	term_vi.c_cc[VTIME] = 0;
	erase_char = term_vi.c_cc[VERASE];
	tcsetattr_stdin_TCSANOW(&term_vi);
}
 ************ 
Parsed Output:
static void set_termios(void)
{
    if (dest[8] != 0)
    {
        tcsetattr(termios_p, 1, 0);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.6800126433372498
Func rank: 54

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: unregister_rpc
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004FFAE0 | 55 | push    rbp
0x004FFAE1 | 48 89 E5 | mov     rbp, rsp
0x004FFAE4 | 48 83 EC 20 | sub     rsp, 20h
0x004FFAE8 | 48 89 7D E8 | mov     [rbp+ptr], rdi
0x004FFAEC | 48 8B 45 E8 | mov     rax, [rbp+ptr]
0x004FFAF0 | 8B 40 10 | mov     eax, [rax+10h]
0x004FFAF3 | 89 45 FC | mov     [rbp+var_4], eax
0x004FFAF6 | EB 1F | jmp     short loc_4FFB17
0x004FFAF8 | 83 6D FC 01 | sub     [rbp+var_4], 1
0x004FFAFC | 48 8B 45 E8 | mov     rax, [rbp+ptr]
0x004FFB00 | 8B 55 FC | mov     edx, [rbp+var_4]
0x004FFB03 | 48 63 D2 | movsxd  rdx, edx
0x004FFB06 | 48 83 C2 04 | add     rdx, 4
0x004FFB0A | 48 8B 44 D0 08 | mov     rax, [rax+rdx*8+8]
0x004FFB0F | 48 89 C7 | mov     rdi, rax; ptr
0x004FFB12 | E8 49 6B F0 FF | call    _free
0x004FFB17 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004FFB1B | 7F DB | jg      short loc_4FFAF8
0x004FFB1D | 48 8B 45 E8 | mov     rax, [rbp+ptr]
0x004FFB21 | 48 89 C7 | mov     rdi, rax; ptr
0x004FFB24 | E8 37 6B F0 FF | call    _free
0x004FFB29 | 90 | nop
0x004FFB2A | C9 | leave
0x004FFB2B | C3 | retn

 Ourput decompiled code:
static void free_line_input_t(line_input_t *n)
{
	int i = n->cnt_history;
	while (i > 0)
		free(n->history[--i]);
	free(n);
}

## Example:

 Input assembly code:
0x004AC054 | 55 | push    rbp
0x004AC055 | 48 89 E5 | mov     rbp, rsp
0x004AC058 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004AC05C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004AC060 | C7 80 8C 00 00 00 00 00 00 00 | mov     dword ptr [rax+8Ch], 0
0x004AC06A | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004AC071 | EB 4C | jmp     short loc_4AC0BF
0x004AC073 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x004AC077 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004AC07A | 48 98 | cdqe
0x004AC07C | 0F B6 84 02 90 00 00 00 | movzx   eax, byte ptr [rdx+rax+90h]
0x004AC084 | 84 C0 | test    al, al
0x004AC086 | 74 33 | jz      short loc_4AC0BB
0x004AC088 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004AC08C | 8B 80 8C 00 00 00 | mov     eax, [rax+8Ch]
0x004AC092 | 89 C1 | mov     ecx, eax
0x004AC094 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x004AC098 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004AC09B | 48 98 | cdqe
0x004AC09D | 88 8C 02 90 01 00 00 | mov     [rdx+rax+190h], cl
0x004AC0A4 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004AC0A8 | 8B 80 8C 00 00 00 | mov     eax, [rax+8Ch]
0x004AC0AE | 8D 50 01 | lea     edx, [rax+1]
0x004AC0B1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004AC0B5 | 89 90 8C 00 00 00 | mov     [rax+8Ch], edx
0x004AC0BB | 83 45 FC 01 | add     [rbp+var_4], 1
0x004AC0BF | 81 7D FC FF 00 00 00 | cmp     [rbp+var_4], 0FFh
0x004AC0C6 | 7E AB | jle     short loc_4AC073
0x004AC0C8 | 90 | nop
0x004AC0C9 | 5D | pop     rbp
0x004AC0CA | C3 | retn

 Ourput decompiled code:
static
void makeMaps_e(EState* s)
{
	int i;
	s->nInUse = 0;
	for (i = 0; i < 256; i++) {
		if (s->inUse[i]) {
			s->unseqToSeq[i] = s->nInUse;
			s->nInUse++;
		}
	}
}

## Example:

 Input assembly code:
0x004D39DE | 55 | push    rbp
0x004D39DF | 48 89 E5 | mov     rbp, rsp
0x004D39E2 | 48 83 EC 20 | sub     rsp, 20h
0x004D39E6 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004D39EA | 89 75 E4 | mov     [rbp+var_1C], esi
0x004D39ED | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D39F1 | 8B 40 0C | mov     eax, [rax+0Ch]
0x004D39F4 | 89 C6 | mov     esi, eax
0x004D39F6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D39FA | 8B 40 08 | mov     eax, [rax+8]
0x004D39FD | 89 C1 | mov     ecx, eax
0x004D39FF | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D3A03 | 8B 40 04 | mov     eax, [rax+4]
0x004D3A06 | 89 C2 | mov     edx, eax
0x004D3A08 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D3A0C | 8B 00 | mov     eax, [rax]
0x004D3A0E | 89 C0 | mov     eax, eax
0x004D3A10 | 49 89 F0 | mov     r8, rsi
0x004D3A13 | 48 89 C6 | mov     rsi, rax
0x004D3A16 | BF 38 40 52 00 | mov     edi, offset aLxLxLxLx; "%lx:%lx:%lx:%lx"
0x004D3A1B | B8 00 00 00 00 | mov     eax, 0
0x004D3A20 | E8 AB 31 F3 FF | call    _printf
0x004D3A25 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004D3A2C | EB 26 | jmp     short loc_4D3A54
0x004D3A2E | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x004D3A32 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004D3A35 | 48 98 | cdqe
0x004D3A37 | 0F B6 44 02 11 | movzx   eax, byte ptr [rdx+rax+11h]
0x004D3A3C | 0F B6 C0 | movzx   eax, al
0x004D3A3F | 89 C6 | mov     esi, eax
0x004D3A41 | BF 48 40 52 00 | mov     edi, offset asc_524048; ":%x"
0x004D3A46 | B8 00 00 00 00 | mov     eax, 0
0x004D3A4B | E8 80 31 F3 FF | call    _printf
0x004D3A50 | 83 45 FC 01 | add     [rbp+var_4], 1
0x004D3A54 | 83 7D FC 1F | cmp     [rbp+var_4], 1Fh
0x004D3A58 | 7E D4 | jle     short loc_4D3A2E
0x004D3A5A | BF 0A 00 00 00 | mov     edi, 0Ah
0x004D3A5F | E8 F5 6B F3 FF | call    sub_40A659
0x004D3A64 | 90 | nop
0x004D3A65 | C9 | leave
0x004D3A66 | C3 | retn

 Ourput decompiled code:
static void display_recoverable(const struct termios *mode,
				int UNUSED_PARAM dummy)
{
	int i;
	printf("%lx:%lx:%lx:%lx",
		   (unsigned long) mode->c_iflag, (unsigned long) mode->c_oflag,
		   (unsigned long) mode->c_cflag, (unsigned long) mode->c_lflag);
	for (i = 0; i < NCCS; ++i)
		printf(":%x", (unsigned int) mode->c_cc[i]);
	bb_putchar('\n');
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00433D06 | 55 | push    rbp
0x00433D07 | 48 89 E5 | mov     rbp, rsp
0x00433D0A | 48 83 EC 20 | sub     rsp, 20h
0x00433D0E | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00433D12 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00433D16 | 8B 40 24 | mov     eax, [rax+24h]
0x00433D19 | 89 45 FC | mov     [rbp+var_4], eax
0x00433D1C | EB 3D | jmp     short loc_433D5B
0x00433D1E | 8B 45 FC | mov     eax, [rbp+var_4]
0x00433D21 | 48 63 D0 | movsxd  rdx, eax
0x00433D24 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00433D28 | 8B 40 20 | mov     eax, [rax+20h]
0x00433D2B | 48 98 | cdqe
0x00433D2D | 48 89 D6 | mov     rsi, rdx; vers
0x00433D30 | 48 89 C7 | mov     rdi, rax; program
0x00433D33 | E8 48 33 FD FF | call    _pmap_unset
0x00433D38 | 85 C0 | test    eax, eax
0x00433D3A | 75 1B | jnz     short loc_433D57
0x00433D3C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00433D40 | 8B 40 20 | mov     eax, [rax+20h]
0x00433D43 | 8B 55 FC | mov     edx, [rbp+var_4]
0x00433D46 | 89 C6 | mov     esi, eax
0x00433D48 | BF A1 92 51 00 | mov     edi, offset aPmapUnsetUU; "pmap_unset(%u,%u)"
0x00433D4D | B8 00 00 00 00 | mov     eax, 0
0x00433D52 | E8 82 54 FD FF | call    sub_4091D9
0x00433D57 | 83 45 FC 01 | add     [rbp+var_4], 1
0x00433D5B | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00433D5F | 8B 40 28 | mov     eax, [rax+28h]
0x00433D62 | 39 45 FC | cmp     [rbp+var_4], eax
0x00433D65 | 7E B7 | jle     short loc_433D1E
0x00433D67 | 90 | nop
0x00433D68 | C9 | leave
0x00433D69 | C3 | retn
 ************ 
Source Code:
static void unregister_rpc(servtab_t *sep)
{
	int n;

	for (n = sep->se_rpcver_lo; n <= sep->se_rpcver_hi; n++) {
		if (!pmap_unset(sep->se_rpcprog, n))
			bb_perror_msg("pmap_unset(%u,%u)", sep->se_rpcprog, n);
	}
}
 ************ 
Parsed Output:
static void unset_pmap_entries(pmap_t *map)
{
    int i;
    for (i = map->min; i <= map->max; i++) {
        pmap_unset(map->program, map->vers);
        map->vers++;
    }
}
 ************ 
Similarity Score (Unixcoder): 0.6639237403869629
Func rank: 55

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: stack_nputstr
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.


# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0046ED32 | 55 | push    rbp
0x0046ED33 | 48 89 E5 | mov     rbp, rsp
0x0046ED36 | 48 83 EC 20 | sub     rsp, 20h
0x0046ED3A | 48 89 7D F8 | mov     [rbp+src], rdi
0x0046ED3E | 48 89 75 F0 | mov     [rbp+n], rsi
0x0046ED42 | 48 89 55 E8 | mov     [rbp+dest], rdx
0x0046ED46 | 48 8B 55 E8 | mov     rdx, [rbp+dest]
0x0046ED4A | 48 8B 45 F0 | mov     rax, [rbp+n]
0x0046ED4E | 48 89 D6 | mov     rsi, rdx
0x0046ED51 | 48 89 C7 | mov     rdi, rax
0x0046ED54 | E8 60 FF FF FF | call    sub_46ECB9
0x0046ED59 | 48 89 45 E8 | mov     [rbp+dest], rax
0x0046ED5D | 48 8B 55 F0 | mov     rdx, [rbp+n]; n
0x0046ED61 | 48 8B 4D F8 | mov     rcx, [rbp+src]
0x0046ED65 | 48 8B 45 E8 | mov     rax, [rbp+dest]
0x0046ED69 | 48 89 CE | mov     rsi, rcx; src
0x0046ED6C | 48 89 C7 | mov     rdi, rax; dest
0x0046ED6F | E8 2C 84 F9 FF | call    _memcpy
0x0046ED74 | 48 89 C2 | mov     rdx, rax
0x0046ED77 | 48 8B 45 F0 | mov     rax, [rbp+n]
0x0046ED7B | 48 01 D0 | add     rax, rdx
0x0046ED7E | 48 89 45 E8 | mov     [rbp+dest], rax
0x0046ED82 | 48 8B 45 E8 | mov     rax, [rbp+dest]
0x0046ED86 | C9 | leave
0x0046ED87 | C3 | retn
 ************ 
Source Code:
static char *
stack_nputstr(const char *s, size_t n, char *p)
{
	p = makestrspace(n, p);
	p = (char *)memcpy(p, s, n) + n;
	return p;
}
 ************ 
Parsed Output:
void function(void* src, void* n, void* dest) {
    memcpy(dest, src, n);
    dest += n;
    return dest;
}
 ************ 
Similarity Score (Unixcoder): 0.6540344953536987
Func rank: 56

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: unbackslash
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00408F1D | 55 | push    rbp
0x00408F1E | 48 89 E5 | mov     rbp, rsp
0x00408F21 | 48 83 EC 20 | sub     rsp, 20h
0x00408F25 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00408F29 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00408F2D | BE 2F 00 00 00 | mov     esi, 2Fh ; '/'
0x00408F32 | 48 89 C7 | mov     rdi, rax
0x00408F35 | E8 3F 00 00 00 | call    sub_408F79
0x00408F3A | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00408F3E | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00408F43 | 74 26 | jz      short loc_408F6B
0x00408F45 | EB 0F | jmp     short loc_408F56
0x00408F47 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00408F4B | 48 8D 50 FF | lea     rdx, [rax-1]
0x00408F4F | 48 89 55 F8 | mov     [rbp+var_8], rdx
0x00408F53 | C6 00 00 | mov     byte ptr [rax], 0
0x00408F56 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00408F5A | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00408F5D | 3C 2F | cmp     al, 2Fh ; '/'
0x00408F5F | 75 0A | jnz     short loc_408F6B
0x00408F61 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00408F65 | 48 3B 45 E8 | cmp     rax, [rbp+var_18]
0x00408F69 | 75 DC | jnz     short loc_408F47
0x00408F6B | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00408F6F | 48 89 C7 | mov     rdi, rax
0x00408F72 | E8 55 FF FF FF | call    sub_408ECC
0x00408F77 | C9 | leave
0x00408F78 | C3 | retn

 Ourput decompiled code:
FAST_FUNC bb_get_last_path_component_strip(char *path)
{
	char *slash = last_char_is(path, '/');

	if (slash)
		while (*slash == '/' && slash != path)
			*slash-- = '\0';

	return bb_get_last_path_component_nostrip(path);
}

## Example:

 Input assembly code:
0x00446899 | 55 | push    rbp
0x0044689A | 48 89 E5 | mov     rbp, rsp
0x0044689D | 48 83 EC 20 | sub     rsp, 20h
0x004468A1 | 48 89 7D E8 | mov     [rbp+s], rdi
0x004468A5 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004468A9 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004468AC | 3C 5B | cmp     al, 5Bh ; '['
0x004468AE | 75 6B | jnz     short loc_44691B
0x004468B0 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004468B4 | BE 25 00 00 00 | mov     esi, 25h ; '%'; c
0x004468B9 | 48 89 C7 | mov     rdi, rax; s
0x004468BC | E8 FF 02 FC FF | call    _strchr
0x004468C1 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004468C5 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004468CA | 74 52 | jz      short loc_44691E
0x004468CC | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004468D0 | BE 5D 00 00 00 | mov     esi, 5Dh ; ']'; c
0x004468D5 | 48 89 C7 | mov     rdi, rax; s
0x004468D8 | E8 E3 02 FC FF | call    _strchr
0x004468DD | 48 89 45 F0 | mov     [rbp+var_10], rax
0x004468E1 | 48 83 7D F0 00 | cmp     [rbp+var_10], 0
0x004468E6 | 74 39 | jz      short loc_446921
0x004468E8 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004468EC | 48 83 C0 01 | add     rax, 1
0x004468F0 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004468F3 | 3C 3A | cmp     al, 3Ah ; ':'
0x004468F5 | 74 0F | jz      short loc_446906
0x004468F7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004468FB | 48 83 C0 01 | add     rax, 1
0x004468FF | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00446902 | 84 C0 | test    al, al
0x00446904 | 75 1B | jnz     short loc_446921
0x00446906 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x0044690A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0044690E | 48 89 D6 | mov     rsi, rdx
0x00446911 | 48 89 C7 | mov     rdi, rax
0x00446914 | E8 F4 16 0C 00 | call    sub_50800D
0x00446919 | EB 07 | jmp     short locret_446922
0x0044691B | 90 | nop
0x0044691C | EB 04 | jmp     short locret_446922
0x0044691E | 90 | nop
0x0044691F | EB 01 | jmp     short locret_446922
0x00446921 | 90 | nop
0x00446922 | C9 | leave
0x00446923 | C3 | retn

 Ourput decompiled code:
static void strip_ipv6_scope_id(char *host)
{
	char *scope, *cp;

	/* bbox wget actually handles IPv6 addresses without [], like
	 * wget "http://::1/xxx", but this is not standard.
	 * To save code, _here_ we do not support it. */

	if (host[0] != '[')
		return; /* not IPv6 */

	scope = strchr(host, '%');
	if (!scope)
		return;

	/* Remove the IPv6 zone identifier from the host address */
	cp = strchr(host, ']');
	if (!cp || (cp[1] != ':' && cp[1] != '\0')) {
		/* malformed address (not "[xx]:nn" or "[xx]") */
		return;
	}

	/* cp points to "]...", scope points to "%eth0]..." */
	overlapping_strcpy(scope, cp);
}

## Example:

 Input assembly code:
0x00408ECC | 55 | push    rbp
0x00408ECD | 48 89 E5 | mov     rbp, rsp
0x00408ED0 | 48 83 EC 20 | sub     rsp, 20h
0x00408ED4 | 48 89 7D E8 | mov     [rbp+s], rdi
0x00408ED8 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x00408EDC | BE 2F 00 00 00 | mov     esi, 2Fh ; '/'; c
0x00408EE1 | 48 89 C7 | mov     rdi, rax; s
0x00408EE4 | E8 47 DD FF FF | call    _strrchr
0x00408EE9 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00408EED | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00408EF2 | 74 19 | jz      short loc_408F0D
0x00408EF4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00408EF8 | 48 3B 45 E8 | cmp     rax, [rbp+s]
0x00408EFC | 75 15 | jnz     short loc_408F13
0x00408EFE | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00408F02 | 48 83 C0 01 | add     rax, 1
0x00408F06 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00408F09 | 84 C0 | test    al, al
0x00408F0B | 75 06 | jnz     short loc_408F13
0x00408F0D | 48 8B 45 E8 | mov     rax, [rbp+s]
0x00408F11 | EB 08 | jmp     short locret_408F1B
0x00408F13 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00408F17 | 48 83 C0 01 | add     rax, 1
0x00408F1B | C9 | leave
0x00408F1C | C3 | retn

 Ourput decompiled code:
FAST_FUNC bb_get_last_path_component_nostrip(const char *path)
{
	char *slash = strrchr(path, '/');

	if (!slash || (slash == path && !slash[1]))
		return (char*)path;

	return slash + 1;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0047FF75 | 55 | push    rbp
0x0047FF76 | 48 89 E5 | mov     rbp, rsp
0x0047FF79 | 48 83 EC 20 | sub     rsp, 20h
0x0047FF7D | 48 89 7D E8 | mov     [rbp+s], rdi
0x0047FF81 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x0047FF85 | BE 5C 00 00 00 | mov     esi, 5Ch ; '\'; c
0x0047FF8A | 48 89 C7 | mov     rdi, rax; s
0x0047FF8D | E8 5E 69 F8 FF | call    _strchrnul
0x0047FF92 | 48 89 45 E8 | mov     [rbp+s], rax
0x0047FF96 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x0047FF9A | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0047FF9E | 48 8B 45 E8 | mov     rax, [rbp+s]
0x0047FFA2 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0047FFA5 | 3C 5C | cmp     al, 5Ch ; '\'
0x0047FFA7 | 75 05 | jnz     short loc_47FFAE
0x0047FFA9 | 48 83 45 E8 01 | add     [rbp+s], 1
0x0047FFAE | 48 8B 55 E8 | mov     rdx, [rbp+s]
0x0047FFB2 | 48 8D 42 01 | lea     rax, [rdx+1]
0x0047FFB6 | 48 89 45 E8 | mov     [rbp+s], rax
0x0047FFBA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0047FFBE | 48 8D 48 01 | lea     rcx, [rax+1]
0x0047FFC2 | 48 89 4D F8 | mov     [rbp+var_8], rcx
0x0047FFC6 | 0F B6 12 | movzx   edx, byte ptr [rdx]
0x0047FFC9 | 88 10 | mov     [rax], dl
0x0047FFCB | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0047FFCE | 84 C0 | test    al, al
0x0047FFD0 | 74 02 | jz      short loc_47FFD4
0x0047FFD2 | EB CA | jmp     short loc_47FF9E
0x0047FFD4 | 90 | nop
0x0047FFD5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0047FFD9 | C9 | leave
0x0047FFDA | C3 | retn
 ************ 
Source Code:
static char *unbackslash(char *src)
{
	char *dst = src = strchrnul(src, '\\');
	while (1) {
		if (*src == '\\')
			src++;
		if ((*dst++ = *src++) == '\0')
			break;
	}
	return dst;
}
 ************ 
Parsed Output:
FAST_FUNC bb_get_last_path_component_strip(char *path)
{
    char *slash = strchrnul(path, '/');

    if (*slash == '/')
        slash++;

    return slash;
}
 ************ 
Similarity Score (Unixcoder): 0.6522589921951294
Func rank: 57

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: free_instance
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004B882D | 55 | push    rbp
0x004B882E | 48 89 E5 | mov     rbp, rsp
0x004B8831 | 48 83 EC 10 | sub     rsp, 10h
0x004B8835 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004B8839 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004B883D | 48 8B 40 60 | mov     rax, [rax+60h]
0x004B8841 | 48 89 C7 | mov     rdi, rax
0x004B8844 | E8 A7 FF FF FF | call    sub_4B87F0
0x004B8849 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004B884D | 48 8B 40 68 | mov     rax, [rax+68h]
0x004B8851 | 48 89 C7 | mov     rdi, rax
0x004B8854 | E8 97 FF FF FF | call    sub_4B87F0
0x004B8859 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004B885D | 48 C7 40 60 00 00 00 00 | mov     qword ptr [rax+60h], 0
0x004B8865 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004B8869 | 48 C7 40 68 00 00 00 00 | mov     qword ptr [rax+68h], 0
0x004B8871 | 90 | nop
0x004B8872 | C9 | leave
0x004B8873 | C3 | retn

 Ourput decompiled code:
static void huft_free_all(STATE_PARAM_ONLY)
{
	huft_free(inflate_codes_tl);
	huft_free(inflate_codes_td);
	inflate_codes_tl = NULL;
	inflate_codes_td = NULL;
}

## Example:

 Input assembly code:
0x005024BD | 55 | push    rbp
0x005024BE | 48 89 E5 | mov     rbp, rsp
0x005024C1 | 48 83 EC 10 | sub     rsp, 10h
0x005024C5 | 48 89 7D F8 | mov     [rbp+ptr], rdi
0x005024C9 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0
0x005024CE | 74 4B | jz      short loc_50251B
0x005024D0 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x005024D4 | 48 8B 40 08 | mov     rax, [rax+8]
0x005024D8 | 48 89 C7 | mov     rdi, rax; ptr
0x005024DB | E8 80 41 F0 FF | call    _free
0x005024E0 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x005024E4 | 48 8B 00 | mov     rax, [rax]
0x005024E7 | 48 89 C7 | mov     rdi, rax; stream
0x005024EA | E8 11 45 F0 FF | call    _fclose
0x005024EF | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x005024F3 | 48 8B 40 10 | mov     rax, [rax+10h]
0x005024F7 | 48 89 C7 | mov     rdi, rax; ptr
0x005024FA | E8 61 41 F0 FF | call    _free
0x005024FF | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00502503 | 48 8B 40 18 | mov     rax, [rax+18h]
0x00502507 | 48 89 C7 | mov     rdi, rax; ptr
0x0050250A | E8 51 41 F0 FF | call    _free
0x0050250F | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00502513 | 48 89 C7 | mov     rdi, rax; ptr
0x00502516 | E8 45 41 F0 FF | call    _free
0x0050251B | 90 | nop
0x0050251C | C9 | leave
0x0050251D | C3 | retn

 Ourput decompiled code:
void FAST_FUNC config_close(parser_t *parser)
{
	if (parser) {
		if (PARSE_KEEP_COPY) /* compile-time constant */
			free(parser->data);
		fclose(parser->fp);
		free(parser->line);
		free(parser->nline);
		free(parser);
	}
}

## Example:

 Input assembly code:
0x0050346D | 55 | push    rbp
0x0050346E | 48 89 E5 | mov     rbp, rsp
0x00503471 | 48 83 EC 10 | sub     rsp, 10h
0x00503475 | 48 89 7D F8 | mov     [rbp+ptr], rdi
0x00503479 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x0050347D | 48 8B 00 | mov     rax, [rax]
0x00503480 | 48 89 C7 | mov     rdi, rax; dirp
0x00503483 | E8 08 3A F0 FF | call    _closedir
0x00503488 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x0050348C | 48 8B 40 08 | mov     rax, [rax+8]
0x00503490 | 48 85 C0 | test    rax, rax
0x00503493 | 74 10 | jz      short loc_5034A5
0x00503495 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00503499 | 48 8B 40 08 | mov     rax, [rax+8]
0x0050349D | 48 89 C7 | mov     rdi, rax; dirp
0x005034A0 | E8 EB 39 F0 FF | call    _closedir
0x005034A5 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x005034A9 | 48 8B 40 18 | mov     rax, [rax+18h]
0x005034AD | 48 89 C7 | mov     rdi, rax; ptr
0x005034B0 | E8 AB 31 F0 FF | call    _free
0x005034B5 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x005034B9 | 48 8B 40 20 | mov     rax, [rax+20h]
0x005034BD | 48 89 C7 | mov     rdi, rax; ptr
0x005034C0 | E8 9B 31 F0 FF | call    _free
0x005034C5 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x005034C9 | 48 89 C7 | mov     rdi, rax; ptr
0x005034CC | E8 8F 31 F0 FF | call    _free
0x005034D1 | 90 | nop
0x005034D2 | C9 | leave
0x005034D3 | C3 | retn

 Ourput decompiled code:
void FAST_FUNC free_procps_scan(procps_status_t* sp)
{
	closedir(sp->dir);
#if ENABLE_FEATURE_SHOW_THREADS
	if (sp->task_dir)
		closedir(sp->task_dir);
#endif
	free(sp->argv0);
	free(sp->exe);
	IF_SELINUX(free(sp->context);)
	free(sp);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004DA7BB | 55 | push    rbp
0x004DA7BC | 48 89 E5 | mov     rbp, rsp
0x004DA7BF | 48 83 EC 10 | sub     rsp, 10h
0x004DA7C3 | 48 89 7D F8 | mov     [rbp+ptr], rdi
0x004DA7C7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004DA7CB | 48 8B 40 10 | mov     rax, [rax+10h]
0x004DA7CF | 48 89 C7 | mov     rdi, rax; ptr
0x004DA7D2 | E8 89 BE F2 FF | call    _free
0x004DA7D7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004DA7DB | 48 8B 40 18 | mov     rax, [rax+18h]
0x004DA7DF | 48 89 C7 | mov     rdi, rax; ptr
0x004DA7E2 | E8 79 BE F2 FF | call    _free
0x004DA7E7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004DA7EB | 48 8B 40 20 | mov     rax, [rax+20h]
0x004DA7EF | 48 89 C7 | mov     rdi, rax; ptr
0x004DA7F2 | E8 69 BE F2 FF | call    _free
0x004DA7F7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004DA7FB | 48 89 C7 | mov     rdi, rax; ptr
0x004DA7FE | E8 5D BE F2 FF | call    _free
0x004DA803 | 90 | nop
0x004DA804 | C9 | leave
0x004DA805 | C3 | retn
 ************ 
Source Code:
static void free_instance(struct fsck_instance *p)
{
	free(p->prog);
	free(p->device);
	free(p->base_device);
	free(p);
}
 ************ 
Parsed Output:
void free_procps_scan(procps_status_t* sp)
{
    free(sp->ptr->field1);
    free(sp->ptr->field2);
    free(sp->ptr->field3);
    free(sp->ptr);
}
 ************ 
Similarity Score (Unixcoder): 0.6433712244033813
Func rank: 58

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: free_volume_id
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0045C54B | 55 | push    rbp
0x0045C54C | 48 89 E5 | mov     rbp, rsp
0x0045C54F | 48 83 EC 10 | sub     rsp, 10h
0x0045C553 | 48 89 7D F8 | mov     [rbp+ptr], rdi
0x0045C557 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0
0x0045C55C | 74 1B | jz      short loc_45C579
0x0045C55E | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x0045C562 | 48 8B 00 | mov     rax, [rax]
0x0045C565 | 48 89 C7 | mov     rdi, rax
0x0045C568 | E8 DE FF FF FF | call    sub_45C54B
0x0045C56D | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x0045C571 | 48 89 C7 | mov     rdi, rax; ptr
0x0045C574 | E8 E7 A0 FA FF | call    _free
0x0045C579 | 90 | nop
0x0045C57A | C9 | leave
0x0045C57B | C3 | retn

 Ourput decompiled code:
static void stats_dev_free(stats_dev_t *stats_dev)
{
	if (stats_dev) {
		stats_dev_free(stats_dev->next);
		free(stats_dev);
	}
}

## Example:

 Input assembly code:
0x004C00B6 | 55 | push    rbp
0x004C00B7 | 48 89 E5 | mov     rbp, rsp
0x004C00BA | 48 83 EC 10 | sub     rsp, 10h
0x004C00BE | 48 89 7D F8 | mov     [rbp+ptr], rdi
0x004C00C2 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0
0x004C00C7 | 74 1F | jz      short loc_4C00E8
0x004C00C9 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004C00CD | 48 8B 80 B8 04 00 00 | mov     rax, [rax+4B8h]
0x004C00D4 | 48 89 C7 | mov     rdi, rax
0x004C00D7 | E8 0E EE FF FF | call    sub_4BEEEA
0x004C00DC | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004C00E0 | 48 89 C7 | mov     rdi, rax; ptr
0x004C00E3 | E8 78 65 F4 FF | call    _free
0x004C00E8 | 90 | nop
0x004C00E9 | C9 | leave
0x004C00EA | C3 | retn

 Ourput decompiled code:
XZ_EXTERN void XZ_FUNC xz_dec_end(struct xz_dec *s)
{
	if (s != NULL) {
		xz_dec_lzma2_end(s->lzma2);
#ifdef XZ_DEC_BCJ
		xz_dec_bcj_end(s->bcj);
#endif
		kfree(s);
	}
}

## Example:

 Input assembly code:
0x0040F557 | 55 | push    rbp
0x0040F558 | 48 89 E5 | mov     rbp, rsp
0x0040F55B | 48 83 EC 10 | sub     rsp, 10h
0x0040F55F | 48 89 7D F8 | mov     [rbp+s], rdi
0x0040F563 | 48 83 7D F8 00 | cmp     [rbp+s], 0
0x0040F568 | 74 20 | jz      short loc_40F58A
0x0040F56A | 48 8B 45 F8 | mov     rax, [rbp+s]
0x0040F56E | 48 89 C7 | mov     rdi, rax; s
0x0040F571 | E8 5A 75 FF FF | call    _strlen
0x0040F576 | 48 89 C2 | mov     rdx, rax; n
0x0040F579 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x0040F57D | BE 00 00 00 00 | mov     esi, 0; c
0x0040F582 | 48 89 C7 | mov     rdi, rax; s
0x0040F585 | E8 C6 77 FF FF | call    _memset
0x0040F58A | 90 | nop
0x0040F58B | C9 | leave
0x0040F58C | C3 | retn

 Ourput decompiled code:
static void nuke_str(char *str)
{
	if (str) memset(str, 0, strlen(str));
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004A5BEA | 55 | push    rbp
0x004A5BEB | 48 89 E5 | mov     rbp, rsp
0x004A5BEE | 48 83 EC 10 | sub     rsp, 10h
0x004A5BF2 | 48 89 7D F8 | mov     [rbp+ptr], rdi
0x004A5BF6 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0
0x004A5BFB | 74 27 | jz      short loc_4A5C24
0x004A5BFD | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004A5C01 | 8B 00 | mov     eax, [rax]
0x004A5C03 | 89 C7 | mov     edi, eax; fd
0x004A5C05 | E8 06 12 F6 FF | call    _close
0x004A5C0A | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004A5C0E | 48 89 C7 | mov     rdi, rax
0x004A5C11 | E8 1B 27 00 00 | call    sub_4A8331
0x004A5C16 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004A5C1A | 48 89 C7 | mov     rdi, rax; ptr
0x004A5C1D | E8 3E 0A F6 FF | call    _free
0x004A5C22 | EB 01 | jmp     short locret_4A5C25
0x004A5C24 | 90 | nop
0x004A5C25 | C9 | leave
0x004A5C26 | C3 | retn
 ************ 
Source Code:
endif

void FAST_FUNC free_volume_id(struct volume_id *id)
{
	if (id == NULL)
		return;

	//if (id->fd_close != 0) - always true
		close(id->fd);
	volume_id_free_buffer(id);
#ifdef UNUSED_PARTITION_CODE
	free(id->partitions);
#endif
	free(id);
}
 ************ 
Parsed Output:
static void close_and_free(int *ptr) {
    if (ptr != NULL) {
        int fd = *ptr;
        close(fd);
        sub_4A8331(ptr);
        free(ptr);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.6384432911872864
Func rank: 59

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: bb_alphasort
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004CFE71 | 55 | push    rbp
0x004CFE72 | 48 89 E5 | mov     rbp, rsp
0x004CFE75 | 48 83 EC 20 | sub     rsp, 20h
0x004CFE79 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004CFE7D | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CFE81 | BA 0A 00 00 00 | mov     edx, 0Ah
0x004CFE86 | BE 00 00 00 00 | mov     esi, 0
0x004CFE8B | 48 89 C7 | mov     rdi, rax
0x004CFE8E | E8 D3 C0 F3 FF | call    sub_40BF66
0x004CFE93 | 89 45 FC | mov     [rbp+var_4], eax
0x004CFE96 | 48 8B 05 63 D5 28 00 | mov     rax, cs:qword_75D400
0x004CFE9D | 8B 00 | mov     eax, [rax]
0x004CFE9F | 85 C0 | test    eax, eax
0x004CFEA1 | 74 1D | jz      short loc_4CFEC0
0x004CFEA3 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CFEA7 | 48 89 C6 | mov     rsi, rax
0x004CFEAA | BF 60 23 53 00 | mov     edi, offset aInvalidNumberS_2; "invalid number '%s'"
0x004CFEAF | B8 00 00 00 00 | mov     eax, 0
0x004CFEB4 | E8 8E 98 F3 FF | call    sub_409747
0x004CFEB9 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004CFEC0 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004CFEC3 | C9 | leave
0x004CFEC4 | C3 | retn

 Ourput decompiled code:
static int get_width_prec(const char *str)
{
	int v = bb_strtoi(str, NULL, 10);
	if (errno) {
		bb_error_msg("invalid number '%s'", str);
		v = 0;
	}
	return v;
}

## Example:

 Input assembly code:
0x00432144 | 55 | push    rbp
0x00432145 | 48 89 E5 | mov     rbp, rsp
0x00432148 | 48 83 EC 20 | sub     rsp, 20h
0x0043214C | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00432150 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00432154 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00432158 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043215C | 48 89 C6 | mov     rsi, rax
0x0043215F | BF 70 8C 51 00 | mov     edi, offset aTestFVarRunUdh; "test -f /var/run/udhcpc.%iface%.pid && "...
0x00432164 | E8 E5 FB FF FF | call    sub_431D4E
0x00432169 | 89 45 FC | mov     [rbp+var_4], eax
0x0043216C | BF A0 86 01 00 | mov     edi, 186A0h; useconds
0x00432171 | E8 6A 5B FD FF | call    _usleep
0x00432176 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x0043217A | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043217E | 48 89 D6 | mov     rsi, rdx
0x00432181 | 48 89 C7 | mov     rdi, rax
0x00432184 | E8 20 FF FF FF | call    sub_4320A9
0x00432189 | 01 45 FC | add     [rbp+var_4], eax
0x0043218C | 83 7D FC 03 | cmp     [rbp+var_4], 3
0x00432190 | 75 07 | jnz     short loc_432199
0x00432192 | B8 03 00 00 00 | mov     eax, 3
0x00432197 | EB 05 | jmp     short locret_43219E
0x00432199 | B8 00 00 00 00 | mov     eax, 0
0x0043219E | C9 | leave
0x0043219F | C3 | retn

 Ourput decompiled code:
if ENABLE_FEATURE_IFUPDOWN_EXTERNAL_DHCP
static int FAST_FUNC dhcp_down(struct interface_defn_t *ifd, execfn *exec)
{
	int result = 0;
	unsigned i;

	for (i = 0; i < ARRAY_SIZE(ext_dhcp_clients); i++) {
		if (exists_execable(ext_dhcp_clients[i].name)) {
			result = execute(ext_dhcp_clients[i].stopcmd, ifd, exec);
			if (result)
				break;
		}
	}

	if (!result)
		bb_error_msg("warning: no dhcp clients found and stopped");

	/* Sleep a bit, otherwise static_down tries to bring down interface too soon,
	   and it may come back up because udhcpc is still shutting down */
	usleep(100000);
	result += static_down(ifd, exec);
	return ((result == 3) ? 3 : 0);
}

## Example:

 Input assembly code:
0x00431DC9 | 55 | push    rbp
0x00431DCA | 48 89 E5 | mov     rbp, rsp
0x00431DCD | 48 83 EC 20 | sub     rsp, 20h
0x00431DD1 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00431DD5 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00431DD9 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00431DDD | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00431DE1 | 48 89 C6 | mov     rsi, rax
0x00431DE4 | BF 3F 88 51 00 | mov     edi, offset aIpAddrAdd1DevI; "ip addr add ::1 dev %iface%"
0x00431DE9 | E8 60 FF FF FF | call    sub_431D4E
0x00431DEE | 89 45 FC | mov     [rbp+var_4], eax
0x00431DF1 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00431DF5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00431DF9 | 48 89 C6 | mov     rsi, rax
0x00431DFC | BF 5B 88 51 00 | mov     edi, offset aIpLinkSetIface; "ip link set %iface% up"
0x00431E01 | E8 48 FF FF FF | call    sub_431D4E
0x00431E06 | 01 45 FC | add     [rbp+var_4], eax
0x00431E09 | 83 7D FC 02 | cmp     [rbp+var_4], 2
0x00431E0D | 75 07 | jnz     short loc_431E16
0x00431E0F | B8 02 00 00 00 | mov     eax, 2
0x00431E14 | EB 05 | jmp     short locret_431E1B
0x00431E16 | B8 00 00 00 00 | mov     eax, 0
0x00431E1B | C9 | leave
0x00431E1C | C3 | retn

 Ourput decompiled code:
if ENABLE_FEATURE_IFUPDOWN_IPV6

static int FAST_FUNC loopback_up6(struct interface_defn_t *ifd, execfn *exec)
{
# if ENABLE_FEATURE_IFUPDOWN_IP
	int result;
	result = execute("ip addr add ::1 dev %iface%", ifd, exec);
	result += execute("ip link set %iface% up", ifd, exec);
	return ((result == 2) ? 2 : 0);
# else
	return execute("ifconfig %iface% add ::1", ifd, exec);
# endif
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004D8F24 | 55 | push    rbp
0x004D8F25 | 48 89 E5 | mov     rbp, rsp
0x004D8F28 | 48 83 EC 20 | sub     rsp, 20h
0x004D8F2C | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004D8F30 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004D8F34 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004D8F38 | 48 8B 10 | mov     rdx, [rax]
0x004D8F3B | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D8F3F | 48 8B 00 | mov     rax, [rax]
0x004D8F42 | 48 89 D6 | mov     rsi, rdx; s2
0x004D8F45 | 48 89 C7 | mov     rdi, rax; s1
0x004D8F48 | E8 03 E1 F2 FF | call    _strcmp
0x004D8F4D | 89 45 FC | mov     [rbp+var_4], eax
0x004D8F50 | 8B 05 FA 44 28 00 | mov     eax, cs:dword_75D450
0x004D8F56 | 83 E0 01 | and     eax, 1
0x004D8F59 | 85 C0 | test    eax, eax
0x004D8F5B | 74 07 | jz      short loc_4D8F64
0x004D8F5D | 8B 45 FC | mov     eax, [rbp+var_4]
0x004D8F60 | F7 D8 | neg     eax
0x004D8F62 | EB 03 | jmp     short locret_4D8F67
0x004D8F64 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004D8F67 | C9 | leave
0x004D8F68 | C3 | retn
 ************ 
Source Code:
static int bb_alphasort(const void *p1, const void *p2)
{
	int r = strcmp(*(char **) p1, *(char **) p2);
	return (option_mask32 & OPT_r) ? -r : r;
}
 ************ 
Parsed Output:
static int compare_strings(const char *s1, const char *s2)
{
    int result = strcmp(s1, s2);
    if (result == 0) {
        int flag = dword_75D450 & 1;
        if (flag != 0) {
            result = -result;
        }
    }
    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.6294555068016052
Func rank: 60

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: get_trimmed_slice
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004C57E8 | 55 | push    rbp
0x004C57E9 | 48 89 E5 | mov     rbp, rsp
0x004C57EC | 48 83 EC 20 | sub     rsp, 20h
0x004C57F0 | 48 89 7D E8 | mov     [rbp+s], rdi
0x004C57F4 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004C57F8 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004C57FC | EB 05 | jmp     short loc_4C5803
0x004C57FE | 48 83 45 F8 01 | add     [rbp+var_8], 1
0x004C5803 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C5807 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004C580A | 84 C0 | test    al, al
0x004C580C | 75 F0 | jnz     short loc_4C57FE
0x004C580E | EB 3B | jmp     short loc_4C584B
0x004C5810 | 48 83 6D F8 01 | sub     [rbp+var_8], 1
0x004C5815 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C5819 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004C581C | 83 E8 09 | sub     eax, 9
0x004C581F | 88 45 F7 | mov     [rbp+var_9], al
0x004C5822 | 80 7D F7 17 | cmp     [rbp+var_9], 17h
0x004C5826 | 74 06 | jz      short loc_4C582E
0x004C5828 | 80 7D F7 04 | cmp     [rbp+var_9], 4
0x004C582C | 77 07 | ja      short loc_4C5835
0x004C582E | B8 01 00 00 00 | mov     eax, 1
0x004C5833 | EB 05 | jmp     short loc_4C583A
0x004C5835 | B8 00 00 00 00 | mov     eax, 0
0x004C583A | 85 C0 | test    eax, eax
0x004C583C | 75 0D | jnz     short loc_4C584B
0x004C583E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C5842 | 48 83 C0 01 | add     rax, 1
0x004C5846 | C6 00 00 | mov     byte ptr [rax], 0
0x004C5849 | EB 0A | jmp     short loc_4C5855
0x004C584B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C584F | 48 3B 45 E8 | cmp     rax, [rbp+s]
0x004C5853 | 75 BB | jnz     short loc_4C5810
0x004C5855 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004C5859 | 48 89 C7 | mov     rdi, rax; s
0x004C585C | E8 AF 0F F4 FF | call    _puts
0x004C5861 | 90 | nop
0x004C5862 | C9 | leave
0x004C5863 | C3 | retn

 Ourput decompiled code:
static void trim_trailing_spaces_and_print(char *s)
{
	char *p = s;

	while (*p) {
		++p;
	}
	while (p != s) {
		--p;
		if (!isspace(*p)) {
			p[1] = '\0';
			break;
		}
	}

	puts(s);
}

## Example:

 Input assembly code:
0x0048E12B | 55 | push    rbp
0x0048E12C | 48 89 E5 | mov     rbp, rsp
0x0048E12F | 48 83 EC 20 | sub     rsp, 20h
0x0048E133 | 48 89 7D E8 | mov     [rbp+nptr], rdi
0x0048E137 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x0048E13B | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0048E13F | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0048E142 | 83 E8 30 | sub     eax, 30h ; '0'
0x0048E145 | 3C 09 | cmp     al, 9
0x0048E147 | 77 0E | ja      short loc_48E157
0x0048E149 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0048E14D | 48 89 C7 | mov     rdi, rax; nptr
0x0048E150 | E8 6B 98 F7 FF | call    _atoi
0x0048E155 | EB 43 | jmp     short locret_48E19A
0x0048E157 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0048E15B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0048E15F | EB 28 | jmp     short loc_48E189
0x0048E161 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048E165 | 48 8B 10 | mov     rdx, [rax]
0x0048E168 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0048E16C | 48 89 D6 | mov     rsi, rdx; s2
0x0048E16F | 48 89 C7 | mov     rdi, rax; s1
0x0048E172 | E8 49 85 F7 FF | call    _strcasecmp
0x0048E177 | 85 C0 | test    eax, eax
0x0048E179 | 75 09 | jnz     short loc_48E184
0x0048E17B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048E17F | 8B 40 08 | mov     eax, [rax+8]
0x0048E182 | EB 16 | jmp     short locret_48E19A
0x0048E184 | 48 83 45 F8 10 | add     [rbp+var_8], 10h
0x0048E189 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048E18D | 48 8B 00 | mov     rax, [rax]
0x0048E190 | 48 85 C0 | test    rax, rax
0x0048E193 | 75 CC | jnz     short loc_48E161
0x0048E195 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x0048E19A | C9 | leave
0x0048E19B | C3 | retn

 Ourput decompiled code:
static int decode(char *name, const CODE *codetab)
{
	const CODE *c;

	if (isdigit(*name))
		return atoi(name);
	for (c = codetab; c->c_name; c++) {
		if (!strcasecmp(name, c->c_name)) {
			return c->c_val;
		}
	}

	return -1;
}

## Example:

 Input assembly code:
0x004CFBB7 | 55 | push    rbp
0x004CFBB8 | 48 89 E5 | mov     rbp, rsp
0x004CFBBB | 48 83 EC 20 | sub     rsp, 20h
0x004CFBBF | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004CFBC3 | EB 57 | jmp     short loc_4CFC1C
0x004CFBC5 | 48 83 45 E8 01 | add     [rbp+var_18], 1
0x004CFBCA | 80 7D FF 5C | cmp     [rbp+var_1], 5Ch ; '\'
0x004CFBCE | 75 41 | jnz     short loc_4CFC11
0x004CFBD0 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CFBD4 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004CFBD7 | 3C 30 | cmp     al, 30h ; '0'
0x004CFBD9 | 75 17 | jnz     short loc_4CFBF2
0x004CFBDB | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CFBDF | 48 83 C0 01 | add     rax, 1
0x004CFBE3 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004CFBE6 | 83 E8 30 | sub     eax, 30h ; '0'
0x004CFBE9 | 3C 07 | cmp     al, 7
0x004CFBEB | 77 05 | ja      short loc_4CFBF2
0x004CFBED | 48 83 45 E8 01 | add     [rbp+var_18], 1
0x004CFBF2 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CFBF6 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x004CFBFA | 48 8D 45 F0 | lea     rax, [rbp+var_10]
0x004CFBFE | 48 89 C7 | mov     rdi, rax
0x004CFC01 | E8 84 34 03 00 | call    sub_50308A
0x004CFC06 | 88 45 FF | mov     [rbp+var_1], al
0x004CFC09 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004CFC0D | 48 89 45 E8 | mov     [rbp+var_18], rax
0x004CFC11 | 0F BE 45 FF | movsx   eax, [rbp+var_1]
0x004CFC15 | 89 C7 | mov     edi, eax; c
0x004CFC17 | E8 D4 75 F3 FF | call    _putchar_unlocked
0x004CFC1C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CFC20 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004CFC23 | 88 45 FF | mov     [rbp+var_1], al
0x004CFC26 | 80 7D FF 00 | cmp     [rbp+var_1], 0
0x004CFC2A | 75 99 | jnz     short loc_4CFBC5
0x004CFC2C | 90 | nop
0x004CFC2D | C9 | leave
0x004CFC2E | C3 | retn

 Ourput decompiled code:
static void print_esc_string(const char *str)
{
	char c;
	while ((c = *str) != '\0') {
		str++;
		if (c == '\\') {
			/* %b also accepts 4-digit octals of the form \0### */
			if (*str == '0') {
				if ((unsigned char)(str[1] - '0') < 8) {
					/* 2nd char is 0..7: skip leading '0' */
					str++;
				}
			}
			{
				/* optimization: don't force arg to be on-stack,
				 * use another variable for that. */
				const char *z = str;
				c = bb_process_escape_sequence(&z);
				str = z;
			}
		}
		putchar(c);
	}
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00408145 | 55 | push    rbp
0x00408146 | 48 89 E5 | mov     rbp, rsp
0x00408149 | 48 83 EC 20 | sub     rsp, 20h
0x0040814D | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00408151 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00408155 | EB 29 | jmp     short loc_408180
0x00408157 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0040815B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040815E | 83 E8 09 | sub     eax, 9
0x00408161 | 88 45 FF | mov     [rbp+var_1], al
0x00408164 | 80 7D FF 17 | cmp     [rbp+var_1], 17h
0x00408168 | 74 06 | jz      short loc_408170
0x0040816A | 80 7D FF 04 | cmp     [rbp+var_1], 4
0x0040816E | 77 07 | ja      short loc_408177
0x00408170 | B8 01 00 00 00 | mov     eax, 1
0x00408175 | EB 05 | jmp     short loc_40817C
0x00408177 | B8 00 00 00 00 | mov     eax, 0
0x0040817C | 85 C0 | test    eax, eax
0x0040817E | 74 14 | jz      short loc_408194
0x00408180 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00408184 | 48 8D 50 FF | lea     rdx, [rax-1]
0x00408188 | 48 89 55 E0 | mov     [rbp+var_20], rdx
0x0040818C | 48 39 45 E8 | cmp     [rbp+var_18], rax
0x00408190 | 72 C5 | jb      short loc_408157
0x00408192 | EB 01 | jmp     short loc_408195
0x00408194 | 90 | nop
0x00408195 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00408199 | 48 83 C0 01 | add     rax, 1
0x0040819D | C6 00 00 | mov     byte ptr [rax], 0
0x004081A0 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004081A4 | 48 89 C7 | mov     rdi, rax
0x004081A7 | E8 08 12 00 00 | call    sub_4093B4
0x004081AC | C9 | leave
0x004081AD | C3 | retn
 ************ 
Source Code:
static char *get_trimmed_slice(char *s, char *e)
{
	/* First, consider the value at e to be nul and back up until we
	 * reach a non-space char.  Set the char after that (possibly at
	 * the original e) to nul. */
	while (e-- > s) {
		if (!isspace(*e)) {
			break;
		}
	}
	e[1] = '\0';

	/* Next, advance past all leading space and return a ptr to the
	 * first non-space char; possibly the terminating nul. */
	return skip_whitespace(s);
}
 ************ 
Parsed Output:
static void process_string(char *str)
{
    char c;
    while ((c = *str) != '\0') {
        str++;
        if (c >= 9 && c <= 23) {
            if (c == 9 || c == 20) {
                continue;
            }
            else if (c >= 17 && c <= 20) {
                return;
            }
            else if (c >= 4 && c <= 7) {
                return;
            }
        }
        else {
            *str = '\0';
            str--;
            while (*str >= 9 && *str <= 23) {
                *str = '\0';
                str--;
            }
            return;
        }
    }
}
 ************ 
Similarity Score (Unixcoder): 0.6168186664581299
Func rank: 61

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: read_maybe_empty
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00489651 | 55 | push    rbp
0x00489652 | 48 89 E5 | mov     rbp, rsp
0x00489655 | 48 83 EC 10 | sub     rsp, 10h
0x00489659 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0048965D | 48 8B 05 A4 3D 2D 00 | mov     rax, cs:qword_75D408
0x00489664 | 8B 80 98 00 00 00 | mov     eax, [rax+98h]
0x0048966A | 85 C0 | test    eax, eax
0x0048966C | 75 20 | jnz     short loc_48968E
0x0048966E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00489672 | 48 8B 00 | mov     rax, [rax]
0x00489675 | 48 89 C6 | mov     rsi, rax
0x00489678 | BF 21 EF 51 00 | mov     edi, offset aSNotInAFunctio; "%s: not in a function"
0x0048967D | B8 00 00 00 00 | mov     eax, 0
0x00489682 | E8 C0 00 F8 FF | call    sub_409747
0x00489687 | B8 01 00 00 00 | mov     eax, 1
0x0048968C | EB 25 | jmp     short locret_4896B3
0x0048968E | 48 8B 05 73 3D 2D 00 | mov     rax, cs:qword_75D408
0x00489695 | 8B 80 98 00 00 00 | mov     eax, [rax+98h]
0x0048969B | 89 C2 | mov     edx, eax
0x0048969D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004896A1 | BE 00 00 00 00 | mov     esi, 0
0x004896A6 | 48 89 C7 | mov     rdi, rax
0x004896A9 | E8 72 FD FF FF | call    sub_489420
0x004896AE | B8 00 00 00 00 | mov     eax, 0
0x004896B3 | C9 | leave
0x004896B4 | C3 | retn

 Ourput decompiled code:
if ENABLE_HUSH_LOCAL
static int FAST_FUNC builtin_local(char **argv)
{
	if (G.func_nest_level == 0) {
		bb_error_msg("%s: not in a function", argv[0]);
		return EXIT_FAILURE; /* bash compat */
	}
	helper_export_local(argv, 0, G.func_nest_level);
	return EXIT_SUCCESS;
}

## Example:

 Input assembly code:
0x004892A0 | 55 | push    rbp
0x004892A1 | 48 89 E5 | mov     rbp, rsp
0x004892A4 | 48 83 EC 10 | sub     rsp, 10h
0x004892A8 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004892AC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004892B0 | 48 89 C7 | mov     rdi, rax
0x004892B3 | E8 95 FE FF FF | call    sub_48914D
0x004892B8 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004892BC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004892C0 | 48 8B 00 | mov     rax, [rax]
0x004892C3 | 48 85 C0 | test    rax, rax
0x004892C6 | 75 07 | jnz     short loc_4892CF
0x004892C8 | B8 00 00 00 00 | mov     eax, 0
0x004892CD | EB 4B | jmp     short locret_48931A
0x004892CF | 48 8B 05 32 41 2D 00 | mov     rax, cs:qword_75D408
0x004892D6 | 8B 40 3C | mov     eax, [rax+3Ch]
0x004892D9 | 85 C0 | test    eax, eax
0x004892DB | 74 31 | jz      short loc_48930E
0x004892DD | E8 9E D6 F7 FF | call    _getpid
0x004892E2 | 89 C2 | mov     edx, eax
0x004892E4 | 48 8B 05 1D 41 2D 00 | mov     rax, cs:qword_75D408
0x004892EB | 8B 40 20 | mov     eax, [rax+20h]
0x004892EE | 39 C2 | cmp     edx, eax
0x004892F0 | 75 1C | jnz     short loc_48930E
0x004892F2 | 48 8B 05 0F 41 2D 00 | mov     rax, cs:qword_75D408
0x004892F9 | 8B 50 3C | mov     edx, [rax+3Ch]
0x004892FC | 48 8B 05 05 41 2D 00 | mov     rax, cs:qword_75D408
0x00489303 | 8B 00 | mov     eax, [rax]
0x00489305 | 89 D6 | mov     esi, edx; pgrp_id
0x00489307 | 89 C7 | mov     edi, eax; fd
0x00489309 | E8 B2 E4 F7 FF | call    _tcsetpgrp
0x0048930E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00489312 | 48 89 C7 | mov     rdi, rax
0x00489315 | E8 46 D8 FF FF | call    sub_486B60
0x0048931A | C9 | leave
0x0048931B | C3 | retn

 Ourput decompiled code:
static int FAST_FUNC builtin_exec(char **argv)
{
	argv = skip_dash_dash(argv);
	if (argv[0] == NULL)
		return EXIT_SUCCESS; /* bash does this */

	/* Careful: we can end up here after [v]fork. Do not restore
	 * tty pgrp then, only top-level shell process does that */
	if (G_saved_tty_pgrp && getpid() == G.root_pid)
		tcsetpgrp(G_interactive_fd, G_saved_tty_pgrp);

	/* TODO: if exec fails, bash does NOT exit! We do.
	 * We'll need to undo trap cleanup (it's inside execvp_or_die)
	 * and tcsetpgrp, and this is inherently racy.
	 */
	execvp_or_die(argv);
}

## Example:

 Input assembly code:
0x00460DE5 | 55 | push    rbp
0x00460DE6 | 48 89 E5 | mov     rbp, rsp
0x00460DE9 | 48 83 EC 10 | sub     rsp, 10h
0x00460DED | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00460DF1 | 48 8B 05 10 C6 2F 00 | mov     rax, cs:qword_75D408
0x00460DF8 | 0F B6 10 | movzx   edx, byte ptr [rax]
0x00460DFB | 48 8B 05 06 C6 2F 00 | mov     rax, cs:qword_75D408
0x00460E02 | 83 F2 01 | xor     edx, 1
0x00460E05 | 88 10 | mov     [rax], dl
0x00460E07 | EB 2C | jmp     short loc_460E35
0x00460E09 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00460E0D | 48 8B 40 10 | mov     rax, [rax+10h]
0x00460E11 | 48 89 C7 | mov     rdi, rax
0x00460E14 | E8 82 E8 FF FF | call    sub_45F69B
0x00460E19 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00460E1D | 48 8B 40 08 | mov     rax, [rax+8]
0x00460E21 | 48 8B 55 F8 | mov     rdx, [rbp+var_8]
0x00460E25 | 48 89 D7 | mov     rdi, rdx
0x00460E28 | FF D0 | call    rax
0x00460E2A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00460E2E | 48 8B 00 | mov     rax, [rax]
0x00460E31 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00460E35 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00460E3A | 75 CD | jnz     short loc_460E09
0x00460E3C | 90 | nop
0x00460E3D | C9 | leave
0x00460E3E | C3 | retn

 Ourput decompiled code:
static void FAST_FUNC collect_info(s_stat *s)
{
	gen ^= 1;
	while (s) {
		put(s->label);
		s->collect(s);
		s = s->next;
	}
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004907A9 | 55 | push    rbp
0x004907AA | 48 89 E5 | mov     rbp, rsp
0x004907AD | 48 83 EC 10 | sub     rsp, 10h
0x004907B1 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004907B5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004907B9 | 48 89 C7 | mov     rdi, rax
0x004907BC | E8 48 FE FF FF | call    sub_490609
0x004907C1 | 85 C0 | test    eax, eax
0x004907C3 | 75 36 | jnz     short loc_4907FB
0x004907C5 | 48 8B 15 3C CC 2C 00 | mov     rdx, cs:qword_75D408
0x004907CC | 48 8B 05 35 CC 2C 00 | mov     rax, cs:qword_75D408
0x004907D3 | 48 81 C2 28 01 00 00 | add     rdx, 128h
0x004907DA | 48 89 10 | mov     [rax], rdx
0x004907DD | 48 8B 05 24 CC 2C 00 | mov     rax, cs:qword_75D408
0x004907E4 | 48 8B 00 | mov     rax, [rax]
0x004907E7 | C6 00 0A | mov     byte ptr [rax], 0Ah
0x004907EA | 48 8B 05 17 CC 2C 00 | mov     rax, cs:qword_75D408
0x004907F1 | 48 8B 00 | mov     rax, [rax]
0x004907F4 | 48 83 C0 01 | add     rax, 1
0x004907F8 | C6 00 00 | mov     byte ptr [rax], 0
0x004907FB | 48 8B 05 06 CC 2C 00 | mov     rax, cs:qword_75D408
0x00490802 | 48 8B 00 | mov     rax, [rax]
0x00490805 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00490808 | C9 | leave
0x00490809 | C3 | retn
 ************ 
Source Code:
static char
read_maybe_empty(const char *mesg)
{
	if (!read_line(mesg)) {
		line_ptr = line_buffer;
		line_ptr[0] = '
';
		line_ptr[1] = '\0';
	}
	return line_ptr[0];
}
 ************ 
Parsed Output:
static void FAST_FUNC check_and_set_flag(char *flag)
{
    if (sub_490609(flag) != 0) {
        char *ptr = (char *)0x75D408;
        ptr += 0x128;
        *ptr = '
';
        *(ptr + 1) = '\0';
    }
}
 ************ 
Similarity Score (Unixcoder): 0.6142549514770508
Func rank: 62

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: iac_flush
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0049C7AA | 55 | push    rbp
0x0049C7AB | 48 89 E5 | mov     rbp, rsp
0x0049C7AE | B8 38 B4 75 00 | mov     eax, offset stru_75B438
0x0049C7B3 | BA 80 00 00 00 | mov     edx, 80h; n
0x0049C7B8 | BE 00 00 00 00 | mov     esi, 0; c
0x0049C7BD | 48 89 C7 | mov     rdi, rax; s
0x0049C7C0 | E8 8B A5 F6 FF | call    _memset
0x0049C7C5 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0049C7CA | C7 40 48 FF FF FF FF | mov     dword ptr [rax+48h], 0FFFFFFFFh
0x0049C7D1 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0049C7D6 | C7 40 44 B0 01 00 00 | mov     dword ptr [rax+44h], 1B0h
0x0049C7DD | 90 | nop
0x0049C7DE | 5D | pop     rbp
0x0049C7DF | C3 | retn

 Ourput decompiled code:
if ENABLE_FEATURE_MDEV_CONF

static void make_default_cur_rule(void)
{
	memset(&G.cur_rule, 0, sizeof(G.cur_rule));
	G.cur_rule.maj = -1; /* "not a @major,minor rule" */
	G.cur_rule.mode = 0660;
}

## Example:

 Input assembly code:
0x00443AA3 | 55 | push    rbp
0x00443AA4 | 48 89 E5 | mov     rbp, rsp
0x00443AA7 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00443AAC | 48 8B 80 38 02 00 00 | mov     rax, [rax+238h]
0x00443AB3 | 48 89 C1 | mov     rcx, rax
0x00443AB6 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00443ABB | 48 8B 80 30 02 00 00 | mov     rax, [rax+230h]
0x00443AC2 | 48 89 C2 | mov     rdx, rax
0x00443AC5 | B8 40 B6 75 00 | mov     eax, offset unk_75B640
0x00443ACA | BE 00 00 00 00 | mov     esi, 0
0x00443ACF | 48 89 C7 | mov     rdi, rax
0x00443AD2 | E8 8A 0B 0C 00 | call    sub_504661
0x00443AD7 | 90 | nop
0x00443AD8 | 5D | pop     rbp
0x00443AD9 | C3 | retn

 Ourput decompiled code:
if ENABLE_FEATURE_TFTP_PROGRESS_BAR
static void tftp_progress_update(void)
{
	bb_progress_update(&G.pmt, 0, G.pos, G.size);
}

## Example:

 Input assembly code:
0x00443ADA | 55 | push    rbp
0x00443ADB | 48 89 E5 | mov     rbp, rsp
0x00443ADE | B8 F8 B3 75 00 | mov     eax, offset dest
0x00443AE3 | 48 8B 80 40 02 00 00 | mov     rax, [rax+240h]
0x00443AEA | BA 40 B6 75 00 | mov     edx, offset unk_75B640
0x00443AEF | 48 89 C6 | mov     rsi, rax
0x00443AF2 | 48 89 D7 | mov     rdi, rdx
0x00443AF5 | E8 04 0B 0C 00 | call    sub_5045FE
0x00443AFA | E8 A4 FF FF FF | call    sub_443AA3
0x00443AFF | 90 | nop
0x00443B00 | 5D | pop     rbp
0x00443B01 | C3 | retn

 Ourput decompiled code:
static void tftp_progress_init(void)
{
	bb_progress_init(&G.pmt, G.file);
	tftp_progress_update();
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00441A2B | 55 | push    rbp
0x00441A2C | 48 89 E5 | mov     rbp, rsp
0x00441A2F | B8 F8 B3 75 00 | mov     eax, offset dest
0x00441A34 | 8B 00 | mov     eax, [rax]
0x00441A36 | 48 98 | cdqe
0x00441A38 | B9 A0 B4 75 00 | mov     ecx, offset qword_75B4A0
0x00441A3D | 48 89 C2 | mov     rdx, rax; n
0x00441A40 | 48 89 CE | mov     rsi, rcx; buf
0x00441A43 | BF 03 00 00 00 | mov     edi, 3; fd
0x00441A48 | E8 13 4F FC FF | call    _write
0x00441A4D | B8 F8 B3 75 00 | mov     eax, offset dest
0x00441A52 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x00441A58 | 90 | nop
0x00441A59 | 5D | pop     rbp
0x00441A5A | C3 | retn
 ************ 
Source Code:
static void iac_flush(void)
{
	write(netfd, G.iacbuf, G.iaclen);
	G.iaclen = 0;
}
 ************ 
Parsed Output:
static void write_data_to_file(void)
{
    int fd = 3;
    char *buf = (char *)qword_75B4A0;
    int n = *(int *)dest;
    
    write(fd, buf, n);
    *(int *)dest = 0;
}
 ************ 
Similarity Score (Unixcoder): 0.5943422317504883
Func rank: 63

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: check_zone_nr
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004BB517 | 55 | push    rbp
0x004BB518 | 48 89 E5 | mov     rbp, rsp
0x004BB51B | 48 83 EC 30 | sub     rsp, 30h
0x004BB51F | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004BB523 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004BB527 | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x004BB52B | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x004BB52F | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004BB533 | 48 89 D6 | mov     rsi, rdx
0x004BB536 | 48 89 C7 | mov     rdi, rax
0x004BB539 | E8 02 FF FF FF | call    sub_4BB440
0x004BB53E | 89 45 FC | mov     [rbp+var_4], eax
0x004BB541 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004BB545 | 8B 00 | mov     eax, [rax]
0x004BB547 | 8D 14 00 | lea     edx, [rax+rax]
0x004BB54A | 8B 45 FC | mov     eax, [rbp+var_4]
0x004BB54D | 01 C2 | add     edx, eax
0x004BB54F | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004BB553 | 89 10 | mov     [rax], edx
0x004BB555 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004BB558 | C9 | leave
0x004BB559 | C3 | retn

 Ourput decompiled code:
static speed_inline int rc_get_bit(rc_t *rc, uint16_t *p, int *symbol)
{
	int ret = rc_is_bit_1(rc, p);
	*symbol = *symbol * 2 + ret;
	return ret;
}

## Example:

 Input assembly code:
0x00497671 | 55 | push    rbp
0x00497672 | 48 89 E5 | mov     rbp, rsp
0x00497675 | 48 83 EC 20 | sub     rsp, 20h
0x00497679 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0049767D | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00497681 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00497685 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00497689 | 48 89 D6 | mov     rsi, rdx
0x0049768C | 48 89 C7 | mov     rdi, rax
0x0049768F | E8 29 EC FF FF | call    sub_4962BD
0x00497694 | 89 45 FC | mov     [rbp+var_4], eax
0x00497697 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x0049769B | 8B 45 FC | mov     eax, [rbp+var_4]
0x0049769E | 48 89 D6 | mov     rsi, rdx
0x004976A1 | 89 C7 | mov     edi, eax
0x004976A3 | E8 65 FE FF FF | call    sub_49750D
0x004976A8 | 89 45 FC | mov     [rbp+var_4], eax
0x004976AB | 83 7D FC FF | cmp     [rbp+var_4], 0FFFFFFFFh
0x004976AF | 75 10 | jnz     short loc_4976C1
0x004976B1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004976B5 | 66 C7 00 00 00 | mov     word ptr [rax], 0
0x004976BA | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004976C1 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004976C4 | C9 | leave
0x004976C5 | C3 | retn

 Ourput decompiled code:
static int add_zone(uint16_t *znr, smallint *corrected)
{
	int block;

	block = check_zone_nr(znr, corrected);
	block = add_zone_common(block, corrected);
	if (block == -1) {
		*znr = 0;
		block = 0;
	}
	return block;
}

## Example:

 Input assembly code:
0x0050BDEA | 55 | push    rbp
0x0050BDEB | 48 89 E5 | mov     rbp, rsp
0x0050BDEE | 48 83 EC 20 | sub     rsp, 20h
0x0050BDF2 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0050BDF6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0050BDFA | 0F B7 40 04 | movzx   eax, word ptr [rax+4]
0x0050BDFE | 0F B7 C0 | movzx   eax, ax
0x0050BE01 | BA 00 00 00 00 | mov     edx, 0
0x0050BE06 | BE 01 00 00 00 | mov     esi, 1
0x0050BE0B | 89 C7 | mov     edi, eax
0x0050BE0D | E8 87 EB EF FF | call    sub_40A999
0x0050BE12 | 89 45 FC | mov     [rbp+var_4], eax
0x0050BE15 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0050BE19 | 8B 10 | mov     edx, [rax]
0x0050BE1B | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0050BE1F | 48 8D 48 04 | lea     rcx, [rax+4]
0x0050BE23 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0050BE26 | 48 89 CE | mov     rsi, rcx
0x0050BE29 | 89 C7 | mov     edi, eax
0x0050BE2B | E8 AD F6 FF FF | call    sub_50B4DD
0x0050BE30 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0050BE33 | C9 | leave
0x0050BE34 | C3 | retn

 Ourput decompiled code:
int FAST_FUNC xconnect_stream(const len_and_sockaddr *lsa)
{
	int fd = xsocket(lsa->u.sa.sa_family, SOCK_STREAM, 0);
	xconnect(fd, &lsa->u.sa, lsa->len);
	return fd;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004962BD | 55 | push    rbp
0x004962BE | 48 89 E5 | mov     rbp, rsp
0x004962C1 | 48 83 EC 20 | sub     rsp, 20h
0x004962C5 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004962C9 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004962CD | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004962D1 | 0F B7 00 | movzx   eax, word ptr [rax]
0x004962D4 | 0F B7 C0 | movzx   eax, ax
0x004962D7 | 89 45 F8 | mov     [rbp+var_8], eax
0x004962DA | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x004962DE | 48 8D 45 F8 | lea     rax, [rbp+var_8]
0x004962E2 | 48 89 D6 | mov     rsi, rdx
0x004962E5 | 48 89 C7 | mov     rdi, rax
0x004962E8 | E8 E5 FE FF FF | call    sub_4961D2
0x004962ED | 89 45 FC | mov     [rbp+var_4], eax
0x004962F0 | 8B 45 F8 | mov     eax, [rbp+var_8]
0x004962F3 | 89 C2 | mov     edx, eax
0x004962F5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004962F9 | 66 89 10 | mov     [rax], dx
0x004962FC | 8B 45 FC | mov     eax, [rbp+var_4]
0x004962FF | C9 | leave
0x00496300 | C3 | retn
 ************ 
Source Code:
static int check_zone_nr(uint16_t *nr, smallint *corrected)
{
	uint32_t nr32 = *nr;
	int r = check_zone_nr2(&nr32, corrected);
	*nr = (uint16_t)nr32;
	return r;
}
 ************ 
Parsed Output:
int get_first_byte(uint16_t *data, int *result)
{
    int first_byte = (int)(*data);
    *result = first_byte;
    return first_byte;
}
 ************ 
Similarity Score (Unixcoder): 0.5903355479240417
Func rank: 64

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: put_prompt
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004EB63E | 55 | push    rbp
0x004EB63F | 48 89 E5 | mov     rbp, rsp
0x004EB642 | 48 83 EC 10 | sub     rsp, 10h
0x004EB646 | 48 8B 05 BB 1D 27 00 | mov     rax, cs:qword_75D408
0x004EB64D | 48 8D 50 30 | lea     rdx, [rax+30h]
0x004EB651 | 48 8B 05 B0 1D 27 00 | mov     rax, cs:qword_75D408
0x004EB658 | 48 83 C0 34 | add     rax, 34h ; '4'
0x004EB65C | 48 89 C6 | mov     rsi, rax
0x004EB65F | BF 00 00 00 00 | mov     edi, 0
0x004EB664 | E8 07 E8 F1 FF | call    sub_409E70
0x004EB669 | 89 45 FC | mov     [rbp+var_4], eax
0x004EB66C | 48 8B 05 95 1D 27 00 | mov     rax, cs:qword_75D408
0x004EB673 | 8B 40 30 | mov     eax, [rax+30h]
0x004EB676 | 3D 00 10 00 00 | cmp     eax, 1000h
0x004EB67B | 76 0E | jbe     short loc_4EB68B
0x004EB67D | 48 8B 05 84 1D 27 00 | mov     rax, cs:qword_75D408
0x004EB684 | C7 40 30 00 10 00 00 | mov     dword ptr [rax+30h], 1000h
0x004EB68B | 48 8B 05 76 1D 27 00 | mov     rax, cs:qword_75D408
0x004EB692 | 8B 40 34 | mov     eax, [rax+34h]
0x004EB695 | 3D 00 10 00 00 | cmp     eax, 1000h
0x004EB69A | 76 0E | jbe     short loc_4EB6AA
0x004EB69C | 48 8B 05 65 1D 27 00 | mov     rax, cs:qword_75D408
0x004EB6A3 | C7 40 34 00 10 00 00 | mov     dword ptr [rax+34h], 1000h
0x004EB6AA | 8B 45 FC | mov     eax, [rbp+var_4]
0x004EB6AD | C9 | leave
0x004EB6AE | C3 | retn

 Ourput decompiled code:
if ENABLE_FEATURE_VI_WIN_RESIZE
static int query_screen_dimensions(void)
{
	int err = get_terminal_width_height(STDIN_FILENO, &columns, &rows);
	if (rows > MAX_SCR_ROWS)
		rows = MAX_SCR_ROWS;
	if (columns > MAX_SCR_COLS)
		columns = MAX_SCR_COLS;
	return err;
}

## Example:

 Input assembly code:
0x0042C3F5 | 55 | push    rbp
0x0042C3F6 | 48 89 E5 | mov     rbp, rsp
0x0042C3F9 | 48 83 EC 10 | sub     rsp, 10h
0x0042C3FD | 48 8B 05 04 10 33 00 | mov     rax, cs:qword_75D408
0x0042C404 | 48 8B 40 20 | mov     rax, [rax+20h]
0x0042C408 | BA 0A 00 00 00 | mov     edx, 0Ah
0x0042C40D | BE 00 00 00 00 | mov     esi, 0
0x0042C412 | 48 89 C7 | mov     rdi, rax
0x0042C415 | E8 B5 FA FD FF | call    sub_40BECF
0x0042C41A | 89 45 FC | mov     [rbp+var_4], eax
0x0042C41D | 48 8B 05 DC 0F 33 00 | mov     rax, cs:qword_75D400
0x0042C424 | 8B 00 | mov     eax, [rax]
0x0042C426 | 85 C0 | test    eax, eax
0x0042C428 | 75 23 | jnz     short loc_42C44D
0x0042C42A | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0042C42E | 74 1D | jz      short loc_42C44D
0x0042C430 | 81 7D FC FF FF 00 00 | cmp     [rbp+var_4], 0FFFFh
0x0042C437 | 77 14 | ja      short loc_42C44D
0x0042C439 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0042C43C | 89 C6 | mov     esi, eax
0x0042C43E | BF 00 00 00 00 | mov     edi, 0
0x0042C443 | E8 DB F8 0D 00 | call    sub_50BD23
0x0042C448 | 89 45 FC | mov     [rbp+var_4], eax
0x0042C44B | EB 1B | jmp     short loc_42C468
0x0042C44D | 48 8B 05 B4 0F 33 00 | mov     rax, cs:qword_75D408
0x0042C454 | 48 8B 40 20 | mov     rax, [rax+20h]
0x0042C458 | BE 50 00 00 00 | mov     esi, 50h ; 'P'
0x0042C45D | 48 89 C7 | mov     rdi, rax
0x0042C460 | E8 BE F8 0D 00 | call    sub_50BD23
0x0042C465 | 89 45 FC | mov     [rbp+var_4], eax
0x0042C468 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0042C46B | BE 09 00 00 00 | mov     esi, 9
0x0042C470 | 89 C7 | mov     edi, eax
0x0042C472 | E8 9E E5 FD FF | call    sub_40AA15
0x0042C477 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0042C47A | C9 | leave
0x0042C47B | C3 | retn

 Ourput decompiled code:
static int openServer(void)
{
	unsigned n = bb_strtou(bind_addr_or_port, NULL, 10);
	if (!errno && n && n <= 0xffff)
		n = create_and_bind_stream_or_die(NULL, n);
	else
		n = create_and_bind_stream_or_die(bind_addr_or_port, 80);
	xlisten(n, 9);
	return n;
}

## Example:

 Input assembly code:
0x004770DD | 55 | push    rbp
0x004770DE | 48 89 E5 | mov     rbp, rsp
0x004770E1 | 48 83 EC 10 | sub     rsp, 10h
0x004770E5 | 48 8B 05 2C 63 2E 00 | mov     rax, cs:qword_75D418
0x004770EC | 8B 50 30 | mov     edx, [rax+30h]
0x004770EF | 83 C2 01 | add     edx, 1
0x004770F2 | 89 50 30 | mov     [rax+30h], edx
0x004770F5 | 48 8B 05 24 3F 2E 00 | mov     rax, cs:qword_75B020
0x004770FC | 48 8B 00 | mov     rax, [rax]
0x004770FF | 48 89 45 F8 | mov     [rbp+ptr], rax
0x00477103 | 48 8B 05 16 3F 2E 00 | mov     rax, cs:qword_75B020
0x0047710A | 48 8B 55 F8 | mov     rdx, [rbp+ptr]
0x0047710E | 48 8B 12 | mov     rdx, [rdx]
0x00477111 | 48 89 10 | mov     [rax], rdx
0x00477114 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00477118 | 0F B6 40 10 | movzx   eax, byte ptr [rax+10h]
0x0047711C | 3C 01 | cmp     al, 1
0x0047711E | 75 10 | jnz     short loc_477130
0x00477120 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00477124 | 48 8B 40 08 | mov     rax, [rax+8]
0x00477128 | 48 89 C7 | mov     rdi, rax
0x0047712B | E8 E5 71 FF FF | call    sub_46E315
0x00477130 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00477134 | 48 89 C7 | mov     rdi, rax; ptr
0x00477137 | E8 24 F5 F8 FF | call    _free
0x0047713C | E8 FE 6E FF FF | call    sub_46E03F
0x00477141 | 90 | nop
0x00477142 | C9 | leave
0x00477143 | C3 | retn

 Ourput decompiled code:
static void
delete_cmd_entry(void)
{
	struct tblentry *cmdp;

	INT_OFF;
	cmdp = *lastcmdentry;
	*lastcmdentry = cmdp->next;
	if (cmdp->cmdtype == CMDFUNCTION)
		freefunc(cmdp->param.func);
	free(cmdp);
	INT_ON;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004FE30A | 55 | push    rbp
0x004FE30B | 48 89 E5 | mov     rbp, rsp
0x004FE30E | 48 83 EC 10 | sub     rsp, 10h
0x004FE312 | 48 8B 15 4F CB 25 00 | mov     rdx, cs:stdout
0x004FE319 | 48 8B 05 38 F1 25 00 | mov     rax, cs:qword_75D458
0x004FE320 | 48 8B 40 38 | mov     rax, [rax+38h]
0x004FE324 | 48 89 D6 | mov     rsi, rdx; stream
0x004FE327 | 48 89 C7 | mov     rdi, rax; s
0x004FE32A | E8 91 8C F0 FF | call    _fputs_unlocked
0x004FE32F | E8 15 C3 F0 FF | call    sub_40A649
0x004FE334 | 48 8B 05 1D F1 25 00 | mov     rax, cs:qword_75D458
0x004FE33B | C7 40 24 00 00 00 00 | mov     dword ptr [rax+24h], 0
0x004FE342 | 48 8B 05 0F F1 25 00 | mov     rax, cs:qword_75D458
0x004FE349 | 8B 40 08 | mov     eax, [rax+8]
0x004FE34C | 89 45 FC | mov     [rbp+var_4], eax
0x004FE34F | 48 8B 05 02 F1 25 00 | mov     rax, cs:qword_75D458
0x004FE356 | 8B 40 20 | mov     eax, [rax+20h]
0x004FE359 | 48 8B 0D F8 F0 25 00 | mov     rcx, cs:qword_75D458
0x004FE360 | BA 00 00 00 00 | mov     edx, 0
0x004FE365 | F7 75 FC | div     [rbp+var_4]
0x004FE368 | 89 41 1C | mov     [rcx+1Ch], eax
0x004FE36B | 48 8B 05 E6 F0 25 00 | mov     rax, cs:qword_75D458
0x004FE372 | 8B 40 20 | mov     eax, [rax+20h]
0x004FE375 | 48 8B 0D DC F0 25 00 | mov     rcx, cs:qword_75D458
0x004FE37C | BA 00 00 00 00 | mov     edx, 0
0x004FE381 | F7 75 FC | div     [rbp+var_4]
0x004FE384 | 89 D0 | mov     eax, edx
0x004FE386 | 89 41 18 | mov     [rcx+18h], eax
0x004FE389 | 90 | nop
0x004FE38A | C9 | leave
0x004FE38B | C3 | retn
 ************ 
Source Code:
static void put_prompt(void)
{
	unsigned w;

	fputs(cmdedit_prompt, stdout);
	fflush_all();
	cursor = 0;
	w = cmdedit_termw; /* read volatile var once */
	cmdedit_y = cmdedit_prmt_len / w; /* new quasireal y */
	cmdedit_x = cmdedit_prmt_len % w;
}
 ************ 
Parsed Output:
static void print_string(const char *s)
{
    FILE *stream = stdout;
    fputs_unlocked(s, stream);
    fflush(stream);
}

static void reset_counters(void)
{
    qword_75D458->count = 0;
    int var_4 = qword_75D458->ptr->count;
    qword_75D458->ptr->count = var_4 / var_4;
    qword_75D458->ptr->total = var_4 % var_4;
}
 ************ 
Similarity Score (Unixcoder): 0.5894370079040527
Func rank: 65

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: sendping6
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0043E2ED | 55 | push    rbp
0x0043E2EE | 48 89 E5 | mov     rbp, rsp
0x0043E2F1 | 48 83 EC 20 | sub     rsp, 20h
0x0043E2F5 | 89 7D EC | mov     [rbp+var_14], edi
0x0043E2F8 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E2FD | 48 8B 40 70 | mov     rax, [rax+70h]
0x0043E301 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0043E305 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E309 | C6 00 08 | mov     byte ptr [rax], 8
0x0043E30C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E310 | 66 C7 40 02 00 00 | mov     word ptr [rax+2], 0
0x0043E316 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E31B | 48 8B 40 28 | mov     rax, [rax+28h]
0x0043E31F | 0F B7 C0 | movzx   eax, ax
0x0043E322 | 89 C7 | mov     edi, eax; hostshort
0x0043E324 | E8 47 88 FC FF | call    _htons
0x0043E329 | 89 C2 | mov     edx, eax
0x0043E32B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E32F | 66 89 50 06 | mov     [rax+6], dx
0x0043E333 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E338 | 0F B7 50 40 | movzx   edx, word ptr [rax+40h]
0x0043E33C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E340 | 66 89 50 04 | mov     [rax+4], dx
0x0043E344 | E8 1E D9 FC FF | call    sub_40BC67
0x0043E349 | 48 89 C2 | mov     rdx, rax
0x0043E34C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E350 | 48 83 C0 08 | add     rax, 8
0x0043E354 | 89 10 | mov     [rax], edx
0x0043E356 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E35B | 8B 40 18 | mov     eax, [rax+18h]
0x0043E35E | 83 C0 08 | add     eax, 8
0x0043E361 | 89 C2 | mov     edx, eax
0x0043E363 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E367 | 89 D6 | mov     esi, edx
0x0043E369 | 48 89 C7 | mov     rdi, rax
0x0043E36C | E8 DE F1 0B 00 | call    sub_4FD54F
0x0043E371 | 89 C2 | mov     edx, eax
0x0043E373 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E377 | 66 89 50 02 | mov     [rax+2], dx
0x0043E37B | BE 08 00 00 00 | mov     esi, 8
0x0043E380 | BF ED E2 43 00 | mov     edi, offset sub_43E2ED
0x0043E385 | E8 AA FD FF FF | call    sub_43E134
0x0043E38A | 90 | nop
0x0043E38B | C9 | leave
0x0043E38C | C3 | retn

 Ourput decompiled code:
static void sendping4(int junk UNUSED_PARAM)
{
	struct icmp *pkt = G.snd_packet;

	//memset(pkt, 0, datalen + ICMP_MINLEN + 4); - G.snd_packet was xzalloced
	pkt->icmp_type = ICMP_ECHO;
	/*pkt->icmp_code = 0;*/
	pkt->icmp_cksum = 0; /* cksum is calculated with this field set to 0 */
	pkt->icmp_seq = htons(ntransmitted); /* don't ++ here, it can be a macro */
	pkt->icmp_id = myid;

	/* If datalen < 4, we store timestamp _past_ the packet,
	 * but it's ok - we allocated 4 extra bytes in xzalloc() just in case.
	 */
	/*if (datalen >= 4)*/
		/* No hton: we'll read it back on the same machine */
		*(uint32_t*)&pkt->icmp_dun = monotonic_us();

	pkt->icmp_cksum = inet_cksum((uint16_t *) pkt, datalen + ICMP_MINLEN);

	sendping_tail(sendping4, ICMP_MINLEN);
}

## Example:

 Input assembly code:
0x0043542A | 55 | push    rbp
0x0043542B | 48 89 E5 | mov     rbp, rsp
0x0043542E | 48 83 EC 20 | sub     rsp, 20h
0x00435432 | 89 7D EC | mov     [rbp+var_14], edi
0x00435435 | 48 8B 05 C4 7F 32 00 | mov     rax, cs:qword_75D400
0x0043543C | 8B 00 | mov     eax, [rax]
0x0043543E | 89 45 F4 | mov     [rbp+var_C], eax
0x00435441 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00435446 | C6 40 30 00 | mov     byte ptr [rax+30h], 0
0x0043544A | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043544F | 48 8B 40 18 | mov     rax, [rax+18h]
0x00435453 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00435457 | EB 45 | jmp     short loc_43549E
0x00435459 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043545D | 8B 00 | mov     eax, [rax]
0x0043545F | 83 F8 FF | cmp     eax, 0FFFFFFFFh
0x00435462 | 75 2E | jnz     short loc_435492
0x00435464 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00435468 | 48 89 C7 | mov     rdi, rax
0x0043546B | E8 5C EB FF FF | call    sub_433FCC
0x00435470 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00435474 | 8B 00 | mov     eax, [rax]
0x00435476 | 83 F8 FF | cmp     eax, 0FFFFFFFFh
0x00435479 | 74 17 | jz      short loc_435492
0x0043547B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043547F | 8B 40 24 | mov     eax, [rax+24h]
0x00435482 | 85 C0 | test    eax, eax
0x00435484 | 74 0C | jz      short loc_435492
0x00435486 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043548A | 48 89 C7 | mov     rdi, rax
0x0043548D | E8 60 E7 FF FF | call    sub_433BF2
0x00435492 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00435496 | 48 8B 40 58 | mov     rax, [rax+58h]
0x0043549A | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0043549E | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004354A3 | 75 B4 | jnz     short loc_435459
0x004354A5 | 48 8B 05 54 7F 32 00 | mov     rax, cs:qword_75D400
0x004354AC | 8B 55 F4 | mov     edx, [rbp+var_C]
0x004354AF | 89 10 | mov     [rax], edx
0x004354B1 | 90 | nop
0x004354B2 | C9 | leave
0x004354B3 | C3 | retn

 Ourput decompiled code:
static void retry_network_setup(int sig UNUSED_PARAM)
{
	int save_errno = errno;
	servtab_t *sep;

	alarm_armed = 0;
	for (sep = serv_list; sep; sep = sep->se_next) {
		if (sep->se_fd == -1) {
			prepare_socket_fd(sep);
#if ENABLE_FEATURE_INETD_RPC
			if (sep->se_fd != -1 && is_rpc_service(sep))
				register_rpc(sep);
#endif
		}
	}
	errno = save_errno;
}

## Example:

 Input assembly code:
0x00456C5B | 55 | push    rbp
0x00456C5C | 48 89 E5 | mov     rbp, rsp
0x00456C5F | 48 83 EC 20 | sub     rsp, 20h
0x00456C63 | 89 7D EC | mov     [rbp+var_14], edi
0x00456C66 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00456C6B | 48 8B 40 20 | mov     rax, [rax+20h]
0x00456C6F | 48 89 45 F8 | mov     [rbp+ptr], rax
0x00456C73 | 48 C7 45 F0 F8 B3 75 00 | mov     [rbp+var_10], offset dest
0x00456C7B | EB 4A | jmp     short loc_456CC7
0x00456C7D | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00456C81 | 8B 40 08 | mov     eax, [rax+8]
0x00456C84 | 39 45 EC | cmp     [rbp+var_14], eax
0x00456C87 | 75 2A | jnz     short loc_456CB3
0x00456C89 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00456C8D | 48 8B 50 20 | mov     rdx, [rax+20h]
0x00456C91 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00456C95 | 48 89 50 20 | mov     [rax+20h], rdx
0x00456C99 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00456C9D | 48 89 C7 | mov     rdi, rax; ptr
0x00456CA0 | E8 BB F9 FA FF | call    _free
0x00456CA5 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00456CA9 | 48 8B 40 20 | mov     rax, [rax+20h]
0x00456CAD | 48 89 45 F8 | mov     [rbp+ptr], rax
0x00456CB1 | EB 14 | jmp     short loc_456CC7
0x00456CB3 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00456CB7 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x00456CBB | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00456CBF | 48 8B 40 20 | mov     rax, [rax+20h]
0x00456CC3 | 48 89 45 F8 | mov     [rbp+ptr], rax
0x00456CC7 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0
0x00456CCC | 75 AF | jnz     short loc_456C7D
0x00456CCE | 90 | nop
0x00456CCF | C9 | leave
0x00456CD0 | C3 | retn

 Ourput decompiled code:
static void xid_del(uint32_t xid)
{
	struct xid_item *item = dhcprelay_xid_list.next;
	struct xid_item *last = &dhcprelay_xid_list;
	while (item != NULL) {
		if (item->xid == xid) {
			last->next = item->next;
			free(item);
			item = last->next;
		} else {
			last = item;
			item = item->next;
		}
	}
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0043E38D | 55 | push    rbp
0x0043E38E | 48 89 E5 | mov     rbp, rsp
0x0043E391 | 48 83 EC 20 | sub     rsp, 20h
0x0043E395 | 89 7D EC | mov     [rbp+var_14], edi
0x0043E398 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E39D | 48 8B 40 70 | mov     rax, [rax+70h]
0x0043E3A1 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0043E3A5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E3A9 | C6 00 80 | mov     byte ptr [rax], 80h
0x0043E3AC | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E3B1 | 48 8B 40 28 | mov     rax, [rax+28h]
0x0043E3B5 | 0F B7 C0 | movzx   eax, ax
0x0043E3B8 | 89 C7 | mov     edi, eax; hostshort
0x0043E3BA | E8 B1 87 FC FF | call    _htons
0x0043E3BF | 89 C2 | mov     edx, eax
0x0043E3C1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E3C5 | 66 89 50 06 | mov     [rax+6], dx
0x0043E3C9 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E3CE | 0F B7 50 40 | movzx   edx, word ptr [rax+40h]
0x0043E3D2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E3D6 | 66 89 50 04 | mov     [rax+4], dx
0x0043E3DA | E8 88 D8 FC FF | call    sub_40BC67
0x0043E3DF | 48 89 C2 | mov     rdx, rax
0x0043E3E2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E3E6 | 48 83 C0 08 | add     rax, 8
0x0043E3EA | 89 10 | mov     [rax], edx
0x0043E3EC | BE 08 00 00 00 | mov     esi, 8
0x0043E3F1 | BF 8D E3 43 00 | mov     edi, offset sub_43E38D
0x0043E3F6 | E8 39 FD FF FF | call    sub_43E134
0x0043E3FB | 90 | nop
0x0043E3FC | C9 | leave
0x0043E3FD | C3 | retn
 ************ 
Source Code:
if ENABLE_PING6
static void sendping6(int junk UNUSED_PARAM)
{
	struct icmp6_hdr *pkt = G.snd_packet;

	//memset(pkt, 0, datalen + sizeof(struct icmp6_hdr) + 4);
	pkt->icmp6_type = ICMP6_ECHO_REQUEST;
	/*pkt->icmp6_code = 0;*/
	/*pkt->icmp6_cksum = 0;*/
	pkt->icmp6_seq = htons(ntransmitted); /* don't ++ here, it can be a macro */
	pkt->icmp6_id = myid;

	/*if (datalen >= 4)*/
		*(uint32_t*)(&pkt->icmp6_data8[4]) = monotonic_us();

	//TODO? pkt->icmp_cksum = inet_cksum(...);

	sendping_tail(sendping6, sizeof(struct icmp6_hdr));
}
 ************ 
Parsed Output:
static void process_data(int data)
{
    int var_14 = data;
    char *dest = &dest;
    int var_8 = *(int *)(dest + 0x70);

    *(char *)var_8 = 0x80;

    int var_28 = *(int *)(dest + 0x28);
    int hostshort = (unsigned short)*(unsigned short *)(dest + 0x40);
    int var_2C = htons(hostshort);

    *(short *)(var_8 + 6) = var_2C;
    *(short *)(var_8 + 4) = var_2C;

    sub_40BC67();

    int var_30 = var_8 + 8;
    *(int *)var_30 = var_28;

    int esi = 8;
    int edi = (int)process_data;

    sub_43E134();
}
 ************ 
Similarity Score (Unixcoder): 0.5864424705505371
Func rank: 66

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: get_prefix
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00502E59 | 55 | push    rbp
0x00502E5A | 48 89 E5 | mov     rbp, rsp
0x00502E5D | 48 83 EC 30 | sub     rsp, 30h
0x00502E61 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00502E65 | 48 89 75 E0 | mov     [rbp+s], rsi
0x00502E69 | 89 55 DC | mov     [rbp+var_24], edx
0x00502E6C | 48 89 4D D0 | mov     [rbp+var_30], rcx
0x00502E70 | 48 C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0
0x00502E78 | EB 61 | jmp     short loc_502EDB
0x00502E7A | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00502E7E | 8B 00 | mov     eax, [rax]
0x00502E80 | 23 45 DC | and     eax, [rbp+var_24]
0x00502E83 | 85 C0 | test    eax, eax
0x00502E85 | 74 3B | jz      short loc_502EC2
0x00502E87 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00502E8C | 74 06 | jz      short loc_502E94
0x00502E8E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00502E92 | EB 05 | jmp     short loc_502E99
0x00502E94 | B8 F0 73 53 00 | mov     eax, offset unk_5373F0
0x00502E99 | 48 8B 55 E0 | mov     rdx, [rbp+s]
0x00502E9D | 48 89 C6 | mov     rsi, rax
0x00502EA0 | BF F1 73 53 00 | mov     edi, offset aSS_67; "%s%s"
0x00502EA5 | B8 00 00 00 00 | mov     eax, 0
0x00502EAA | E8 21 3D F0 FF | call    _printf
0x00502EAF | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x00502EB3 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00502EB7 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00502EBB | 8B 00 | mov     eax, [rax]
0x00502EBD | F7 D0 | not     eax
0x00502EBF | 21 45 DC | and     [rbp+var_24], eax
0x00502EC2 | 48 83 45 E8 04 | add     [rbp+var_18], 4
0x00502EC7 | 48 8B 45 E0 | mov     rax, [rbp+s]
0x00502ECB | 48 89 C7 | mov     rdi, rax; s
0x00502ECE | E8 FD 3B F0 FF | call    _strlen
0x00502ED3 | 48 83 C0 01 | add     rax, 1
0x00502ED7 | 48 01 45 E0 | add     [rbp+s], rax
0x00502EDB | 48 8B 45 E0 | mov     rax, [rbp+s]
0x00502EDF | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00502EE2 | 84 C0 | test    al, al
0x00502EE4 | 75 94 | jnz     short loc_502E7A
0x00502EE6 | 8B 45 DC | mov     eax, [rbp+var_24]
0x00502EE9 | C9 | leave
0x00502EEA | C3 | retn

 Ourput decompiled code:
int FAST_FUNC print_flags_separated(const int *masks, const char *labels, int flags, const char *separator)
{
	const char *need_separator = NULL;
	while (*labels) {
		if (flags & *masks) {
			printf("%s%s",
				need_separator ? need_separator : "",
				labels);
			need_separator = separator;
			flags &= ~ *masks;
		}
		masks++;
		labels += strlen(labels) + 1;
	}
	return flags;
}

## Example:

 Input assembly code:
0x0048BEA2 | 55 | push    rbp
0x0048BEA3 | 48 89 E5 | mov     rbp, rsp
0x0048BEA6 | 48 83 EC 30 | sub     rsp, 30h
0x0048BEAA | 89 7D EC | mov     [rbp+var_14], edi
0x0048BEAD | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x0048BEB1 | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x0048BEB5 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0048BEB9 | 48 8B 40 08 | mov     rax, [rax+8]
0x0048BEBD | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0048BEC1 | 8B 45 EC | mov     eax, [rbp+var_14]
0x0048BEC4 | 83 E0 01 | and     eax, 1
0x0048BEC7 | 85 C0 | test    eax, eax
0x0048BEC9 | 75 0B | jnz     short loc_48BED6
0x0048BECB | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0048BECF | 48 8B 00 | mov     rax, [rax]
0x0048BED2 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0048BED6 | 48 83 7D F8 FF | cmp     [rbp+var_8], 0FFFFFFFFFFFFFFFFh
0x0048BEDB | 75 0C | jnz     short loc_48BEE9
0x0048BEDD | BF CC F4 51 00 | mov     edi, offset aUnlimited; "unlimited"
0x0048BEE2 | E8 29 A9 F7 FF | call    _puts
0x0048BEE7 | EB 27 | jmp     short loc_48BF10
0x0048BEE9 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x0048BEED | 0F B6 40 01 | movzx   eax, byte ptr [rax+1]
0x0048BEF1 | 0F B6 C0 | movzx   eax, al
0x0048BEF4 | 89 C1 | mov     ecx, eax
0x0048BEF6 | 48 D3 6D F8 | shr     [rbp+var_8], cl
0x0048BEFA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048BEFE | 48 89 C6 | mov     rsi, rax
0x0048BF01 | BF D6 F4 51 00 | mov     edi, offset aLlu_2; "%llu\n"
0x0048BF06 | B8 00 00 00 00 | mov     eax, 0
0x0048BF0B | E8 C0 AC F7 FF | call    _printf
0x0048BF10 | 90 | nop
0x0048BF11 | C9 | leave
0x0048BF12 | C3 | retn

 Ourput decompiled code:
static void printlim(unsigned opts, const struct rlimit *limit,
			const struct limits *l)
{
	rlim_t val;

	val = limit->rlim_max;
	if (!(opts & OPT_hard))
		val = limit->rlim_cur;

	if (val == RLIM_INFINITY)
		printf("unlimited\n");
	else {
		val >>= l->factor_shift;
		printf("%llu\n", (long long) val);
	}
}

## Example:

 Input assembly code:
0x004ADC8A | 55 | push    rbp
0x004ADC8B | 48 89 E5 | mov     rbp, rsp
0x004ADC8E | 48 83 EC 20 | sub     rsp, 20h
0x004ADC92 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004ADC96 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004ADC9A | F7 D8 | neg     eax
0x004ADC9C | 83 E0 03 | and     eax, 3
0x004ADC9F | 89 45 FC | mov     [rbp+var_4], eax
0x004ADCA2 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004ADCA5 | 48 98 | cdqe
0x004ADCA7 | 48 01 45 E8 | add     [rbp+var_18], rax
0x004ADCAB | EB 0A | jmp     short loc_4ADCB7
0x004ADCAD | BF 00 00 00 00 | mov     edi, 0
0x004ADCB2 | E8 A2 C9 F5 FF | call    sub_40A659
0x004ADCB7 | 83 6D FC 01 | sub     [rbp+var_4], 1
0x004ADCBB | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004ADCBF | 79 EC | jns     short loc_4ADCAD
0x004ADCC1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004ADCC5 | C9 | leave
0x004ADCC6 | C3 | retn

 Ourput decompiled code:
if ENABLE_FEATURE_CPIO_O
static off_t cpio_pad4(off_t size)
{
	int i;

	i = (- size) & 3;
	size += i;
	while (--i >= 0)
		bb_putchar('\0');
	return size;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0043841E | 55 | push    rbp
0x0043841F | 48 89 E5 | mov     rbp, rsp
0x00438422 | 48 83 EC 20 | sub     rsp, 20h
0x00438426 | 48 89 7D E8 | mov     qword ptr [rbp+hostlong], rdi
0x0043842A | B8 00 00 00 80 | mov     eax, 80000000h
0x0043842F | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00438433 | C7 45 F4 00 00 00 00 | mov     [rbp+var_C], 0
0x0043843A | 48 8B 45 E8 | mov     rax, qword ptr [rbp+hostlong]
0x0043843E | 89 C7 | mov     edi, eax; hostlong
0x00438440 | E8 EB E8 FC FF | call    _htonl
0x00438445 | 89 C0 | mov     eax, eax
0x00438447 | 48 89 45 E8 | mov     qword ptr [rbp+hostlong], rax
0x0043844B | EB 15 | jmp     short loc_438462
0x0043844D | 48 8B 45 E8 | mov     rax, qword ptr [rbp+hostlong]
0x00438451 | 48 23 45 F8 | and     rax, [rbp+var_8]
0x00438455 | 48 85 C0 | test    rax, rax
0x00438458 | 74 04 | jz      short loc_43845E
0x0043845A | 83 45 F4 01 | add     [rbp+var_C], 1
0x0043845E | 48 D1 6D F8 | shr     [rbp+var_8], 1
0x00438462 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00438467 | 75 E4 | jnz     short loc_43844D
0x00438469 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x0043846C | C9 | leave
0x0043846D | C3 | retn
 ************ 
Source Code:
if ENABLE_FEATURE_IPCALC_FANCY
static int get_prefix(unsigned long netmask)
{
	unsigned long msk = 0x80000000;
	int ret = 0;

	netmask = htonl(netmask);
	while (msk) {
		if (netmask & msk)
			ret++;
		msk >>= 1;
	}
	return ret;
}
 ************ 
Parsed Output:
int htonl(int hostlong) {
    int result = 0x80000000;
    int count = 0;
    while (hostlong & result) {
        count++;
        result >>= 1;
    }
    return count;
}
 ************ 
Similarity Score (Unixcoder): 0.5856342315673828
Func rank: 67

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: overflow_safe_sub
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0045BF70 | 55 | push    rbp
0x0045BF71 | 48 89 E5 | mov     rbp, rsp
0x0045BF74 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0045BF78 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x0045BF7C | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0045BF80 | 48 2B 45 E8 | sub     rax, [rbp+var_18]
0x0045BF84 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0045BF88 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0045BF8D | 74 06 | jz      short loc_45BF95
0x0045BF8F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045BF93 | EB 05 | jmp     short loc_45BF9A
0x0045BF95 | B8 01 00 00 00 | mov     eax, 1
0x0045BF9A | 5D | pop     rbp
0x0045BF9B | C3 | retn

 Ourput decompiled code:
static ALWAYS_INLINE cputime_t get_interval(cputime_t old, cputime_t new)
{
	cputime_t itv = new - old;

	return (itv == 0) ? 1 : itv;
}

## Example:

 Input assembly code:
0x0045D449 | 55 | push    rbp
0x0045D44A | 48 89 E5 | mov     rbp, rsp
0x0045D44D | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0045D451 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x0045D455 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0045D459 | 48 2B 45 E8 | sub     rax, [rbp+var_18]
0x0045D45D | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0045D461 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0045D466 | 74 06 | jz      short loc_45D46E
0x0045D468 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045D46C | EB 05 | jmp     short loc_45D473
0x0045D46E | B8 01 00 00 00 | mov     eax, 1
0x0045D473 | 5D | pop     rbp
0x0045D474 | C3 | retn

 Ourput decompiled code:
static ALWAYS_INLINE data_t jiffies_diff(data_t old, data_t new)
{
	data_t diff = new - old;
	return (diff == 0) ? 1 : diff;
}

## Example:

 Input assembly code:
0x00473C97 | 55 | push    rbp
0x00473C98 | 48 89 E5 | mov     rbp, rsp
0x00473C9B | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00473C9F | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00473CA3 | 48 C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0
0x00473CAB | EB 05 | jmp     short loc_473CB2
0x00473CAD | 48 83 45 F8 01 | add     [rbp+var_8], 1
0x00473CB2 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00473CB6 | 48 3B 45 E8 | cmp     rax, [rbp+var_18]
0x00473CBA | 76 10 | jbe     short loc_473CCC
0x00473CBC | 48 83 6D E0 01 | sub     [rbp+var_20], 1
0x00473CC1 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00473CC5 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00473CC8 | 3C 81 | cmp     al, 81h
0x00473CCA | 74 E1 | jz      short loc_473CAD
0x00473CCC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00473CD0 | 5D | pop     rbp
0x00473CD1 | C3 | retn

 Ourput decompiled code:
static size_t
esclen(const char *start, const char *p)
{
	size_t esc = 0;

	while (p > start && (unsigned char)*--p == CTLESC) {
		esc++;
	}
	return esc;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0045BF9C | 55 | push    rbp
0x0045BF9D | 48 89 E5 | mov     rbp, rsp
0x0045BFA0 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0045BFA4 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x0045BFA8 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0045BFAC | 48 2B 45 E8 | sub     rax, [rbp+var_18]
0x0045BFB0 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0045BFB4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045BFB8 | 48 85 C0 | test    rax, rax
0x0045BFBB | 79 19 | jns     short loc_45BFD6
0x0045BFBD | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x0045BFC2 | 48 39 45 E8 | cmp     [rbp+var_18], rax
0x0045BFC6 | 77 0E | ja      short loc_45BFD6
0x0045BFC8 | 48 B8 00 00 00 00 01 00 00 00 | mov     rax, 100000000h
0x0045BFD2 | 48 01 45 F8 | add     [rbp+var_8], rax
0x0045BFD6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045BFDA | 5D | pop     rbp
0x0045BFDB | C3 | retn
 ************ 
Source Code:
static ALWAYS_INLINE cputime_t overflow_safe_sub(cputime_t prev, cputime_t curr)
{
	cputime_t v = curr - prev;

	if ((icputime_t)v < 0     /* curr < prev - counter overflow? */
	 && prev <= 0xffffffff /* kernel uses 32bit value for the counter? */
	) {
		/* Add 33th bit set to 1 to curr, compensating for the overflow */
		/* double shift defeats "warning: left shift count >= width of type" */
		v += ((cputime_t)1 << 16) << 16;
	}
	return v;
}
 ************ 
Parsed Output:
static int calculate_value(int arg1, int arg2)
{
    int var_18 = arg1;
    int var_20 = arg2;
    int var_8 = var_20 - var_18;
    
    if (var_8 < 0)
    {
        return -1;
    }
    else if (var_18 > 0xFFFFFFFF)
    {
        return -1;
    }
    else
    {
        var_8 += 0x100000000;
        return var_8;
    }
}
 ************ 
Similarity Score (Unixcoder): 0.5842227935791016
Func rank: 68

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: unalias
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004892A0 | 55 | push    rbp
0x004892A1 | 48 89 E5 | mov     rbp, rsp
0x004892A4 | 48 83 EC 10 | sub     rsp, 10h
0x004892A8 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004892AC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004892B0 | 48 89 C7 | mov     rdi, rax
0x004892B3 | E8 95 FE FF FF | call    sub_48914D
0x004892B8 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004892BC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004892C0 | 48 8B 00 | mov     rax, [rax]
0x004892C3 | 48 85 C0 | test    rax, rax
0x004892C6 | 75 07 | jnz     short loc_4892CF
0x004892C8 | B8 00 00 00 00 | mov     eax, 0
0x004892CD | EB 4B | jmp     short locret_48931A
0x004892CF | 48 8B 05 32 41 2D 00 | mov     rax, cs:qword_75D408
0x004892D6 | 8B 40 3C | mov     eax, [rax+3Ch]
0x004892D9 | 85 C0 | test    eax, eax
0x004892DB | 74 31 | jz      short loc_48930E
0x004892DD | E8 9E D6 F7 FF | call    _getpid
0x004892E2 | 89 C2 | mov     edx, eax
0x004892E4 | 48 8B 05 1D 41 2D 00 | mov     rax, cs:qword_75D408
0x004892EB | 8B 40 20 | mov     eax, [rax+20h]
0x004892EE | 39 C2 | cmp     edx, eax
0x004892F0 | 75 1C | jnz     short loc_48930E
0x004892F2 | 48 8B 05 0F 41 2D 00 | mov     rax, cs:qword_75D408
0x004892F9 | 8B 50 3C | mov     edx, [rax+3Ch]
0x004892FC | 48 8B 05 05 41 2D 00 | mov     rax, cs:qword_75D408
0x00489303 | 8B 00 | mov     eax, [rax]
0x00489305 | 89 D6 | mov     esi, edx; pgrp_id
0x00489307 | 89 C7 | mov     edi, eax; fd
0x00489309 | E8 B2 E4 F7 FF | call    _tcsetpgrp
0x0048930E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00489312 | 48 89 C7 | mov     rdi, rax
0x00489315 | E8 46 D8 FF FF | call    sub_486B60
0x0048931A | C9 | leave
0x0048931B | C3 | retn

 Ourput decompiled code:
static int FAST_FUNC builtin_exec(char **argv)
{
	argv = skip_dash_dash(argv);
	if (argv[0] == NULL)
		return EXIT_SUCCESS; /* bash does this */

	/* Careful: we can end up here after [v]fork. Do not restore
	 * tty pgrp then, only top-level shell process does that */
	if (G_saved_tty_pgrp && getpid() == G.root_pid)
		tcsetpgrp(G_interactive_fd, G_saved_tty_pgrp);

	/* TODO: if exec fails, bash does NOT exit! We do.
	 * We'll need to undo trap cleanup (it's inside execvp_or_die)
	 * and tcsetpgrp, and this is inherently racy.
	 */
	execvp_or_die(argv);
}

## Example:

 Input assembly code:
0x004891A3 | 55 | push    rbp
0x004891A4 | 48 89 E5 | mov     rbp, rsp
0x004891A7 | 48 83 EC 20 | sub     rsp, 20h
0x004891AB | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004891AF | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004891B6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004891BA | 48 89 C7 | mov     rdi, rax
0x004891BD | E8 8B FF FF FF | call    sub_48914D
0x004891C2 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x004891C6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004891CA | 48 8B 00 | mov     rax, [rax]
0x004891CD | 48 85 C0 | test    rax, rax
0x004891D0 | 74 39 | jz      short loc_48920B
0x004891D2 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004891D6 | 48 89 C7 | mov     rdi, rax
0x004891D9 | E8 25 C9 FF FF | call    sub_485B03
0x004891DE | 48 89 45 F0 | mov     [rbp+ptr], rax
0x004891E2 | 48 8B 45 F0 | mov     rax, [rbp+ptr]
0x004891E6 | 48 89 C7 | mov     rdi, rax
0x004891E9 | E8 EA CD FF FF | call    sub_485FD8
0x004891EE | 48 8B 45 F0 | mov     rax, [rbp+ptr]
0x004891F2 | 48 89 C7 | mov     rdi, rax; ptr
0x004891F5 | E8 66 D4 F7 FF | call    _free
0x004891FA | 48 8B 05 07 42 2D 00 | mov     rax, cs:qword_75D408
0x00489201 | 0F B6 40 4F | movzx   eax, byte ptr [rax+4Fh]
0x00489205 | 0F B6 C0 | movzx   eax, al
0x00489208 | 89 45 FC | mov     [rbp+var_4], eax
0x0048920B | 8B 45 FC | mov     eax, [rbp+var_4]
0x0048920E | C9 | leave
0x0048920F | C3 | retn

 Ourput decompiled code:
static int FAST_FUNC builtin_eval(char **argv)
{
	int rcode = EXIT_SUCCESS;

	argv = skip_dash_dash(argv);
	if (*argv) {
		char *str = expand_strvec_to_string(argv);
		/* bash:
		 * eval "echo Hi; done" ("done" is syntax error):
		 * "echo Hi" will not execute too.
		 */
		parse_and_run_string(str);
		free(str);
		rcode = G.last_exitcode;
	}
	return rcode;
}

## Example:

 Input assembly code:
0x0046F438 | 55 | push    rbp
0x0046F439 | 48 89 E5 | mov     rbp, rsp
0x0046F43C | 48 83 EC 20 | sub     rsp, 20h
0x0046F440 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0046F444 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0046F448 | 48 89 C7 | mov     rdi, rax
0x0046F44B | E8 71 FE FF FF | call    sub_46F2C1
0x0046F450 | 48 89 C2 | mov     rdx, rax
0x0046F453 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0046F457 | 48 89 C6 | mov     rsi, rax
0x0046F45A | 48 89 D7 | mov     rdi, rdx
0x0046F45D | E8 86 FF FF FF | call    sub_46F3E8
0x0046F462 | 48 8B 00 | mov     rax, [rax]
0x0046F465 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0046F469 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0046F46E | 74 3F | jz      short loc_46F4AF
0x0046F470 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0046F474 | 8B 40 08 | mov     eax, [rax+8]
0x0046F477 | 25 00 02 00 00 | and     eax, 200h
0x0046F47C | 85 C0 | test    eax, eax
0x0046F47E | 74 0F | jz      short loc_46F48F
0x0046F480 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0046F484 | 48 8B 40 18 | mov     rax, [rax+18h]
0x0046F488 | BF 00 00 00 00 | mov     edi, 0
0x0046F48D | FF D0 | call    rax
0x0046F48F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0046F493 | 8B 40 08 | mov     eax, [rax+8]
0x0046F496 | 83 E0 20 | and     eax, 20h
0x0046F499 | 85 C0 | test    eax, eax
0x0046F49B | 75 12 | jnz     short loc_46F4AF
0x0046F49D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0046F4A1 | 48 8B 40 10 | mov     rax, [rax+10h]
0x0046F4A5 | 48 89 C7 | mov     rdi, rax
0x0046F4A8 | E8 91 EA FF FF | call    sub_46DF3E
0x0046F4AD | EB 05 | jmp     short locret_46F4B4
0x0046F4AF | B8 00 00 00 00 | mov     eax, 0
0x0046F4B4 | C9 | leave
0x0046F4B5 | C3 | retn

 Ourput decompiled code:
FAST_FUNC
lookupvar(const char *name)
{
	struct var *v;

	v = *findvar(hashvar(name), name);
	if (v) {
#if ENABLE_ASH_RANDOM_SUPPORT
	/*
	 * Dynamic variables are implemented roughly the same way they are
	 * in bash. Namely, they're "special" so long as they aren't unset.
	 * As soon as they're unset, they're no longer dynamic, and dynamic
	 * lookup will no longer happen at that point. -- PFM.
	 */
		if (v->flags & VDYNAMIC)
			v->var_func(NULL);
#endif
		if (!(v->flags & VUNSET))
			return var_end(v->var_text);
	}
	return NULL;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004707B3 | 55 | push    rbp
0x004707B4 | 48 89 E5 | mov     rbp, rsp
0x004707B7 | 48 83 EC 20 | sub     rsp, 20h
0x004707BB | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004707BF | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004707C3 | 48 89 C7 | mov     rdi, rax
0x004707C6 | E8 97 FD FF FF | call    sub_470562
0x004707CB | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004707CF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004707D3 | 48 8B 00 | mov     rax, [rax]
0x004707D6 | 48 85 C0 | test    rax, rax
0x004707D9 | 74 35 | jz      short loc_470810
0x004707DB | 48 8B 05 36 CC 2E 00 | mov     rax, cs:qword_75D418
0x004707E2 | 8B 50 30 | mov     edx, [rax+30h]
0x004707E5 | 83 C2 01 | add     edx, 1
0x004707E8 | 89 50 30 | mov     [rax+30h], edx
0x004707EB | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004707EF | 48 8B 00 | mov     rax, [rax]
0x004707F2 | 48 89 C7 | mov     rdi, rax
0x004707F5 | E8 6E FE FF FF | call    sub_470668
0x004707FA | 48 89 C2 | mov     rdx, rax
0x004707FD | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00470801 | 48 89 10 | mov     [rax], rdx
0x00470804 | E8 36 D8 FF FF | call    sub_46E03F
0x00470809 | B8 00 00 00 00 | mov     eax, 0
0x0047080E | EB 05 | jmp     short locret_470815
0x00470810 | B8 01 00 00 00 | mov     eax, 1
0x00470815 | C9 | leave
0x00470816 | C3 | retn
 ************ 
Source Code:
static int
unalias(const char *name)
{
	struct alias **app;

	app = __lookupalias(name);

	if (*app) {
		INT_OFF;
		*app = freealias(*app);
		INT_ON;
		return 0;
	}

	return 1;
}
 ************ 
Parsed Output:
static int FAST_FUNC lookupvar(const char *name)
{
    struct var *v;

    v = *findvar(hashvar(name), name);
    if (v) {
        if (!(v->flags & VUNSET)) {
            return var_end(v->var_text);
        }
    }
    return NULL;
}
 ************ 
Similarity Score (Unixcoder): 0.5771398544311523
Func rank: 69

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: setcmd
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00479364 | 55 | push    rbp
0x00479365 | 48 89 E5 | mov     rbp, rsp
0x00479368 | 48 83 EC 10 | sub     rsp, 10h
0x0047936C | 89 7D FC | mov     [rbp+var_4], edi
0x0047936F | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x00479373 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00479377 | 48 83 C0 08 | add     rax, 8
0x0047937B | 48 8B 00 | mov     rax, [rax]
0x0047937E | 48 85 C0 | test    rax, rax
0x00479381 | 74 4C | jz      short loc_4793CF
0x00479383 | 48 8B 05 8E 40 2E 00 | mov     rax, cs:qword_75D418
0x0047938A | C6 40 3C 00 | mov     byte ptr [rax+3Ch], 0
0x0047938E | 48 8B 05 83 40 2E 00 | mov     rax, cs:qword_75D418
0x00479395 | C6 40 3D 00 | mov     byte ptr [rax+3Dh], 0
0x00479399 | E8 E9 F9 FF FF | call    sub_478D87
0x0047939E | 48 8B 05 7B 40 2E 00 | mov     rax, cs:qword_75D420
0x004793A5 | 48 05 60 01 00 00 | add     rax, 160h
0x004793AB | 48 83 C0 20 | add     rax, 20h ; ' '
0x004793AF | 48 8B 40 10 | mov     rax, [rax+10h]
0x004793B3 | 48 8D 48 05 | lea     rcx, [rax+5]
0x004793B7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004793BB | 48 83 C0 08 | add     rax, 8
0x004793BF | BA 00 00 00 00 | mov     edx, 0
0x004793C4 | 48 89 CE | mov     rsi, rcx
0x004793C7 | 48 89 C7 | mov     rdi, rax
0x004793CA | E8 06 D9 FF FF | call    sub_476CD5
0x004793CF | B8 00 00 00 00 | mov     eax, 0
0x004793D4 | C9 | leave
0x004793D5 | C3 | retn

 Ourput decompiled code:
static int FAST_FUNC
execcmd(int argc UNUSED_PARAM, char **argv)
{
	if (argv[1]) {
		iflag = 0;              /* exit on error */
		mflag = 0;
		optschanged();
		shellexec(argv + 1, pathval(), 0);
	}
	return 0;
}

## Example:

 Input assembly code:
0x00470A25 | 55 | push    rbp
0x00470A26 | 48 89 E5 | mov     rbp, rsp
0x00470A29 | 48 83 EC 20 | sub     rsp, 20h
0x00470A2D | 89 7D EC | mov     [rbp+var_14], edi
0x00470A30 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00470A34 | EB 15 | jmp     short loc_470A4B
0x00470A36 | 83 7D FC 61 | cmp     [rbp+var_4], 61h ; 'a'
0x00470A3A | 75 0F | jnz     short loc_470A4B
0x00470A3C | E8 D6 FD FF FF | call    sub_470817
0x00470A41 | B8 00 00 00 00 | mov     eax, 0
0x00470A46 | E9 88 00 00 00 | jmp     locret_470AD3
0x00470A4B | BF 67 C8 51 00 | mov     edi, offset aA_4; "a"
0x00470A50 | E8 E3 E5 FF FF | call    sub_46F038
0x00470A55 | 89 45 FC | mov     [rbp+var_4], eax
0x00470A58 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x00470A5C | 75 D8 | jnz     short loc_470A36
0x00470A5E | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x00470A65 | EB 5A | jmp     short loc_470AC1
0x00470A67 | 48 8B 05 EA A4 2E 00 | mov     rax, cs:qword_75AF58
0x00470A6E | 48 8B 00 | mov     rax, [rax]
0x00470A71 | 48 89 C7 | mov     rdi, rax
0x00470A74 | E8 3A FD FF FF | call    sub_4707B3
0x00470A79 | 85 C0 | test    eax, eax
0x00470A7B | 74 32 | jz      short loc_470AAF
0x00470A7D | 48 8B 05 D4 A4 2E 00 | mov     rax, cs:qword_75AF58
0x00470A84 | 48 8B 10 | mov     rdx, [rax]
0x00470A87 | 48 8B 05 32 A4 2E 00 | mov     rax, cs:stderr
0x00470A8E | 48 89 D1 | mov     rcx, rdx
0x00470A91 | BA 69 C8 51 00 | mov     edx, offset aUnalias; "unalias"
0x00470A96 | BE 55 C8 51 00 | mov     esi, offset aSSNotFound; "%s: %s not found\n"
0x00470A9B | 48 89 C7 | mov     rdi, rax; stream
0x00470A9E | B8 00 00 00 00 | mov     eax, 0
0x00470AA3 | E8 28 66 F9 FF | call    _fprintf
0x00470AA8 | C7 45 FC 01 00 00 00 | mov     [rbp+var_4], 1
0x00470AAF | 48 8B 05 A2 A4 2E 00 | mov     rax, cs:qword_75AF58
0x00470AB6 | 48 83 C0 08 | add     rax, 8
0x00470ABA | 48 89 05 97 A4 2E 00 | mov     cs:qword_75AF58, rax
0x00470AC1 | 48 8B 05 90 A4 2E 00 | mov     rax, cs:qword_75AF58
0x00470AC8 | 48 8B 00 | mov     rax, [rax]
0x00470ACB | 48 85 C0 | test    rax, rax
0x00470ACE | 75 97 | jnz     short loc_470A67
0x00470AD0 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00470AD3 | C9 | leave
0x00470AD4 | C3 | retn

 Ourput decompiled code:
static int FAST_FUNC
unaliascmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	int i;

	while ((i = nextopt("a")) != '\0') {
		if (i == 'a') {
			rmaliases();
			return 0;
		}
	}
	for (i = 0; *argptr; argptr++) {
		if (unalias(*argptr)) {
			fprintf(stderr, "%s: %s not found\n", "unalias", *argptr);
			i = 1;
		}
	}

	return i;
}

## Example:

 Input assembly code:
0x0047E306 | 55 | push    rbp
0x0047E307 | 48 89 E5 | mov     rbp, rsp
0x0047E30A | 48 83 EC 10 | sub     rsp, 10h
0x0047E30E | 89 7D FC | mov     [rbp+var_4], edi
0x0047E311 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x0047E315 | E8 E2 4C FF FF | call    sub_472FFC
0x0047E31A | 85 C0 | test    eax, eax
0x0047E31C | 74 07 | jz      short loc_47E325
0x0047E31E | B8 00 00 00 00 | mov     eax, 0
0x0047E323 | EB 33 | jmp     short locret_47E358
0x0047E325 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0047E329 | 48 83 C0 08 | add     rax, 8
0x0047E32D | 48 8B 00 | mov     rax, [rax]
0x0047E330 | 48 85 C0 | test    rax, rax
0x0047E333 | 74 19 | jz      short loc_47E34E
0x0047E335 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0047E339 | 48 83 C0 08 | add     rax, 8
0x0047E33D | 48 8B 00 | mov     rax, [rax]
0x0047E340 | 48 89 C7 | mov     rdi, rax
0x0047E343 | E8 30 0B FF FF | call    sub_46EE78
0x0047E348 | 88 05 02 CC 2D 00 | mov     cs:byte_75AF50, al
0x0047E34E | BF 04 00 00 00 | mov     edi, 4
0x0047E353 | E8 17 FC FE FF | call    sub_46DF6F
0x0047E358 | C9 | leave
0x0047E359 | C3 | retn

 Ourput decompiled code:
static int FAST_FUNC
exitcmd(int argc UNUSED_PARAM, char **argv)
{
	if (stoppedjobs())
		return 0;
	if (argv[1])
		exitstatus = number(argv[1]);
	raise_exception(EXEXIT);
	/* NOTREACHED */
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0047AF6D | 55 | push    rbp
0x0047AF6E | 48 89 E5 | mov     rbp, rsp
0x0047AF71 | 48 83 EC 20 | sub     rsp, 20h
0x0047AF75 | 89 7D EC | mov     [rbp+var_14], edi
0x0047AF78 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x0047AF7C | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0047AF80 | 48 83 C0 08 | add     rax, 8
0x0047AF84 | 48 8B 00 | mov     rax, [rax]
0x0047AF87 | 48 85 C0 | test    rax, rax
0x0047AF8A | 75 1F | jnz     short loc_47AFAB
0x0047AF8C | 48 8B 05 85 24 2E 00 | mov     rax, cs:qword_75D418
0x0047AF93 | 48 83 C0 38 | add     rax, 38h ; '8'
0x0047AF97 | BA 20 00 00 00 | mov     edx, 20h ; ' '
0x0047AF9C | BE 00 00 00 00 | mov     esi, 0
0x0047AFA1 | 48 89 C7 | mov     rdi, rax
0x0047AFA4 | E8 B6 FE FF FF | call    sub_47AE5F
0x0047AFA9 | EB 4E | jmp     short locret_47AFF9
0x0047AFAB | 48 8B 05 66 24 2E 00 | mov     rax, cs:qword_75D418
0x0047AFB2 | 8B 50 30 | mov     edx, [rax+30h]
0x0047AFB5 | 83 C2 01 | add     edx, 1
0x0047AFB8 | 89 50 30 | mov     [rax+30h], edx
0x0047AFBB | BF 00 00 00 00 | mov     edi, 0
0x0047AFC0 | E8 78 FB FF FF | call    sub_47AB3D
0x0047AFC5 | 89 45 FC | mov     [rbp+var_4], eax
0x0047AFC8 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0047AFCC | 75 23 | jnz     short loc_47AFF1
0x0047AFCE | E8 B4 DD FF FF | call    sub_478D87
0x0047AFD3 | 48 8B 05 7E FF 2D 00 | mov     rax, cs:qword_75AF58
0x0047AFDA | 48 8B 00 | mov     rax, [rax]
0x0047AFDD | 48 85 C0 | test    rax, rax
0x0047AFE0 | 74 0F | jz      short loc_47AFF1
0x0047AFE2 | 48 8B 05 6F FF 2D 00 | mov     rax, cs:qword_75AF58
0x0047AFE9 | 48 89 C7 | mov     rdi, rax
0x0047AFEC | E8 8D F8 FF FF | call    sub_47A87E
0x0047AFF1 | E8 49 30 FF FF | call    sub_46E03F
0x0047AFF6 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0047AFF9 | C9 | leave
0x0047AFFA | C3 | retn
 ************ 
Source Code:
static int FAST_FUNC
setcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	int retval;

	if (!argv[1])
		return showvars(nullstr, 0, VUNSET);

	INT_OFF;
	retval = options(/*cmdline:*/ 0);
	if (retval == 0) { /* if no parse error... */
		optschanged();
		if (*argptr != NULL) {
			setparam(argptr);
		}
	}
	INT_ON;
	return retval;
}
 ************ 
Parsed Output:
static int FAST_FUNC
func(int argc UNUSED_PARAM, char **argv)
{
    if (argv[1]) {
        int var_4 = 0;
        int var_20 = 0;
        int *rax = (int *)(argv[1] + 8);
        if (*rax == 0) {
            rax = (int *)&qword_75D418 + 0x38;
            int edx = 0x20;
            int esi = 0;
            int edi = *rax;
            sub_47AE5F(rdi, esi, edx);
        }
        else {
            rax = (int *)&qword_75D418;
            int edx = *(rax + 0x30);
            edx += 1;
            *(rax + 0x30) = edx;
            int edi = 0;
            sub_47AB3D(edi);
        }
        var_4 = eax;
        if (var_4 == 0) {
            sub_478D87();
            rax = *(int *)&qword_75AF58;
            if (*rax != 0) {
                sub_47A87E(rax);
            }
            sub_46E03F();
        }
    }
    return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.5770775079727173
Func rank: 70

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: bb_init_module
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0040D112 | 55 | push    rbp
0x0040D113 | 48 89 E5 | mov     rbp, rsp
0x0040D116 | 48 83 EC 20 | sub     rsp, 20h
0x0040D11A | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0040D11E | 48 89 75 E0 | mov     [rbp+s], rsi
0x0040D122 | 48 8B 45 E0 | mov     rax, [rbp+s]
0x0040D126 | BE 2E 00 00 00 | mov     esi, 2Eh ; '.'; c
0x0040D12B | 48 89 C7 | mov     rdi, rax; s
0x0040D12E | E8 8D 9A FF FF | call    _strchr
0x0040D133 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0040D137 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0040D13C | 75 17 | jnz     short loc_40D155
0x0040D13E | 48 8B 45 E0 | mov     rax, [rbp+s]
0x0040D142 | BE 3A 00 00 00 | mov     esi, 3Ah ; ':'; c
0x0040D147 | 48 89 C7 | mov     rdi, rax; s
0x0040D14A | E8 71 9A FF FF | call    _strchr
0x0040D14F | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0040D153 | EB 07 | jmp     short loc_40D15C
0x0040D155 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040D159 | C6 00 3A | mov     byte ptr [rax], 3Ah ; ':'
0x0040D15C | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0040D161 | 75 1B | jnz     short loc_40D17E
0x0040D163 | 48 8B 45 E0 | mov     rax, [rbp+s]
0x0040D167 | BE 79 64 4F 00 | mov     esi, offset sub_4F6479
0x0040D16C | 48 89 C7 | mov     rdi, rax
0x0040D16F | E8 53 93 0E 00 | call    sub_4F64C7
0x0040D174 | 89 C2 | mov     edx, eax
0x0040D176 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0040D17A | 89 10 | mov     [rax], edx
0x0040D17C | EB 53 | jmp     short loc_40D1D1
0x0040D17E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040D182 | 48 3B 45 E0 | cmp     rax, [rbp+s]
0x0040D186 | 75 20 | jnz     short loc_40D1A8
0x0040D188 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040D18C | 48 83 C0 01 | add     rax, 1
0x0040D190 | BE A0 64 4F 00 | mov     esi, offset sub_4F64A0
0x0040D195 | 48 89 C7 | mov     rdi, rax
0x0040D198 | E8 2A 93 0E 00 | call    sub_4F64C7
0x0040D19D | 89 C2 | mov     edx, eax
0x0040D19F | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0040D1A3 | 89 50 04 | mov     [rax+4], edx
0x0040D1A6 | EB 29 | jmp     short loc_40D1D1
0x0040D1A8 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040D1AC | 48 83 C0 01 | add     rax, 1
0x0040D1B0 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040D1B3 | 84 C0 | test    al, al
0x0040D1B5 | 75 07 | jnz     short loc_40D1BE
0x0040D1B7 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040D1BB | C6 00 00 | mov     byte ptr [rax], 0
0x0040D1BE | 48 8B 55 E0 | mov     rdx, [rbp+s]
0x0040D1C2 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0040D1C6 | 48 89 D6 | mov     rsi, rdx
0x0040D1C9 | 48 89 C7 | mov     rdi, rax
0x0040D1CC | E8 FC FE FF FF | call    sub_40D0CD
0x0040D1D1 | 90 | nop
0x0040D1D2 | C9 | leave
0x0040D1D3 | C3 | retn

 Ourput decompiled code:
void FAST_FUNC parse_chown_usergroup_or_die(struct bb_uidgid_t *u, char *user_group)
{
	char *group;

	/* Check if there is a group name */
	group = strchr(user_group, '.'); /* deprecated? */
	if (!group)
		group = strchr(user_group, ':');
	else
		*group = ':'; /* replace '.' with ':' */

	/* Parse "user[:[group]]" */
	if (!group) { /* "user" */
		u->uid = get_ug_id(user_group, xuname2uid);
	} else if (group == user_group) { /* ":group" */
		u->gid = get_ug_id(group + 1, xgroup2gid);
	} else {
		if (!group[1]) /* "user:" */
			*group = '\0';
		xget_uidgid(u, user_group);
	}
}

## Example:

 Input assembly code:
0x0040BDA6 | 55 | push    rbp
0x0040BDA7 | 48 89 E5 | mov     rbp, rsp
0x0040BDAA | 48 83 EC 30 | sub     rsp, 30h
0x0040BDAE | 48 89 7D E8 | mov     [rbp+nptr], rdi
0x0040BDB2 | 48 89 75 E0 | mov     [rbp+endptr], rsi
0x0040BDB6 | 89 55 DC | mov     [rbp+base], edx
0x0040BDB9 | 48 83 7D E0 00 | cmp     [rbp+endptr], 0
0x0040BDBE | 75 08 | jnz     short loc_40BDC8
0x0040BDC0 | 48 8D 45 F0 | lea     rax, [rbp+var_10]
0x0040BDC4 | 48 89 45 E0 | mov     [rbp+endptr], rax
0x0040BDC8 | 48 8B 45 E0 | mov     rax, [rbp+endptr]
0x0040BDCC | 48 8B 55 E8 | mov     rdx, [rbp+nptr]
0x0040BDD0 | 48 89 10 | mov     [rax], rdx
0x0040BDD3 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0040BDD7 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040BDDA | 0F B6 C0 | movzx   eax, al
0x0040BDDD | 89 C7 | mov     edi, eax
0x0040BDDF | E8 0E FF FF FF | call    sub_40BCF2
0x0040BDE4 | 85 C0 | test    eax, eax
0x0040BDE6 | 75 07 | jnz     short loc_40BDEF
0x0040BDE8 | E8 43 FF FF FF | call    sub_40BD30
0x0040BDED | EB 3A | jmp     short locret_40BE29
0x0040BDEF | 48 8B 05 0A 16 35 00 | mov     rax, cs:qword_75D400
0x0040BDF6 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x0040BDFC | 8B 55 DC | mov     edx, [rbp+base]; base
0x0040BDFF | 48 8B 4D E0 | mov     rcx, [rbp+endptr]
0x0040BE03 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0040BE07 | 48 89 CE | mov     rsi, rcx; endptr
0x0040BE0A | 48 89 C7 | mov     rdi, rax; nptr
0x0040BE0D | E8 CE B1 FF FF | call    _strtoull
0x0040BE12 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0040BE16 | 48 8B 55 E0 | mov     rdx, [rbp+endptr]
0x0040BE1A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040BE1E | 48 89 D6 | mov     rsi, rdx
0x0040BE21 | 48 89 C7 | mov     rdi, rax
0x0040BE24 | E8 21 FF FF FF | call    sub_40BD4A
0x0040BE29 | C9 | leave
0x0040BE2A | C3 | retn

 Ourput decompiled code:
unsigned long long FAST_FUNC bb_strtoull(const char *arg, char **endp, int base)
{
	unsigned long long v;
	char *endptr;

	if (!endp) endp = &endptr;
	*endp = (char*) arg;

	/* strtoul("  -4200000000") returns 94967296, errno 0 (!) */
	/* I don't think that this is right. Preventing this... */
	if (!isalnum(arg[0])) return ret_ERANGE();

	/* not 100% correct for lib func, but convenient for the caller */
	errno = 0;
	v = strtoull(arg, endp, base);
	return handle_errors(v, endp);
}

## Example:

 Input assembly code:
0x0040BECF | 55 | push    rbp
0x0040BED0 | 48 89 E5 | mov     rbp, rsp
0x0040BED3 | 48 83 EC 30 | sub     rsp, 30h
0x0040BED7 | 48 89 7D E8 | mov     [rbp+nptr], rdi
0x0040BEDB | 48 89 75 E0 | mov     [rbp+endptr], rsi
0x0040BEDF | 89 55 DC | mov     [rbp+base], edx
0x0040BEE2 | 48 83 7D E0 00 | cmp     [rbp+endptr], 0
0x0040BEE7 | 75 08 | jnz     short loc_40BEF1
0x0040BEE9 | 48 8D 45 F0 | lea     rax, [rbp+var_10]
0x0040BEED | 48 89 45 E0 | mov     [rbp+endptr], rax
0x0040BEF1 | 48 8B 45 E0 | mov     rax, [rbp+endptr]
0x0040BEF5 | 48 8B 55 E8 | mov     rdx, [rbp+nptr]
0x0040BEF9 | 48 89 10 | mov     [rax], rdx
0x0040BEFC | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0040BF00 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040BF03 | 0F B6 C0 | movzx   eax, al
0x0040BF06 | 89 C7 | mov     edi, eax
0x0040BF08 | E8 E5 FD FF FF | call    sub_40BCF2
0x0040BF0D | 85 C0 | test    eax, eax
0x0040BF0F | 75 07 | jnz     short loc_40BF18
0x0040BF11 | E8 1A FE FF FF | call    sub_40BD30
0x0040BF16 | EB 4C | jmp     short locret_40BF64
0x0040BF18 | 48 8B 05 E1 14 35 00 | mov     rax, cs:qword_75D400
0x0040BF1F | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x0040BF25 | 8B 55 DC | mov     edx, [rbp+base]; base
0x0040BF28 | 48 8B 4D E0 | mov     rcx, [rbp+endptr]
0x0040BF2C | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0040BF30 | 48 89 CE | mov     rsi, rcx; endptr
0x0040BF33 | 48 89 C7 | mov     rdi, rax; nptr
0x0040BF36 | E8 25 BA FF FF | call    _strtoul
0x0040BF3B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0040BF3F | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x0040BF44 | 48 39 45 F8 | cmp     [rbp+var_8], rax
0x0040BF48 | 76 07 | jbe     short loc_40BF51
0x0040BF4A | E8 E1 FD FF FF | call    sub_40BD30
0x0040BF4F | EB 13 | jmp     short locret_40BF64
0x0040BF51 | 48 8B 55 E0 | mov     rdx, [rbp+endptr]
0x0040BF55 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040BF59 | 48 89 D6 | mov     rsi, rdx
0x0040BF5C | 48 89 C7 | mov     rdi, rax
0x0040BF5F | E8 E6 FD FF FF | call    sub_40BD4A
0x0040BF64 | C9 | leave
0x0040BF65 | C3 | retn

 Ourput decompiled code:
ULONG_MAX
unsigned FAST_FUNC bb_strtou(const char *arg, char **endp, int base)
{
	unsigned long v;
	char *endptr;

	if (!endp) endp = &endptr;
	*endp = (char*) arg;

	if (!isalnum(arg[0])) return ret_ERANGE();
	errno = 0;
	v = strtoul(arg, endp, base);
	if (v > UINT_MAX) return ret_ERANGE();
	return handle_errors(v, endp);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00426133 | 55 | push    rbp
0x00426134 | 48 89 E5 | mov     rbp, rsp
0x00426137 | 48 83 EC 30 | sub     rsp, 30h
0x0042613B | 48 89 7D D8 | mov     [rbp+var_28], rdi
0x0042613F | 48 89 75 D0 | mov     [rbp+var_30], rsi
0x00426143 | 48 83 7D D0 00 | cmp     [rbp+var_30], 0
0x00426148 | 75 08 | jnz     short loc_426152
0x0042614A | 48 C7 45 D0 22 AA 52 00 | mov     [rbp+var_30], offset unk_52AA22
0x00426152 | 48 C7 45 E8 00 F0 FF 7F | mov     [rbp+len], 7FFFF000h
0x0042615A | C6 45 F7 00 | mov     [rbp+var_9], 0
0x0042615E | 48 C7 45 F8 00 00 00 00 | mov     [rbp+addr], 0
0x00426166 | 48 83 7D F8 00 | cmp     [rbp+addr], 0
0x0042616B | 74 06 | jz      short loc_426173
0x0042616D | C6 45 F7 01 | mov     [rbp+var_9], 1
0x00426171 | EB 38 | jmp     short loc_4261AB
0x00426173 | 48 8B 05 86 72 33 00 | mov     rax, cs:qword_75D400
0x0042617A | C7 00 0C 00 00 00 | mov     dword ptr [rax], 0Ch
0x00426180 | 48 8D 55 E8 | lea     rdx, [rbp+len]
0x00426184 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00426188 | 48 89 D6 | mov     rsi, rdx
0x0042618B | 48 89 C7 | mov     rdi, rax
0x0042618E | E8 19 D2 09 00 | call    sub_4C33AC
0x00426193 | 48 89 45 F8 | mov     [rbp+addr], rax
0x00426197 | 48 83 7D F8 00 | cmp     [rbp+addr], 0
0x0042619C | 75 0D | jnz     short loc_4261AB
0x0042619E | 48 8B 05 5B 72 33 00 | mov     rax, cs:qword_75D400
0x004261A5 | 8B 00 | mov     eax, [rax]
0x004261A7 | F7 D8 | neg     eax
0x004261A9 | EB 61 | jmp     short locret_42620C
0x004261AB | 48 8B 05 4E 72 33 00 | mov     rax, cs:qword_75D400
0x004261B2 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x004261B8 | 48 8B 55 E8 | mov     rdx, [rbp+len]
0x004261BC | 48 8B 4D D0 | mov     rcx, [rbp+var_30]
0x004261C0 | 48 8B 45 F8 | mov     rax, [rbp+addr]
0x004261C4 | 48 89 C6 | mov     rsi, rax
0x004261C7 | BF AF 00 00 00 | mov     edi, 0AFh; sysno
0x004261CC | B8 00 00 00 00 | mov     eax, 0
0x004261D1 | E8 1A 0F FE FF | call    _syscall
0x004261D6 | 48 8B 05 23 72 33 00 | mov     rax, cs:qword_75D400
0x004261DD | 8B 00 | mov     eax, [rax]
0x004261DF | 89 45 F0 | mov     [rbp+var_10], eax
0x004261E2 | 80 7D F7 00 | cmp     [rbp+var_9], 0
0x004261E6 | 74 15 | jz      short loc_4261FD
0x004261E8 | 48 8B 55 E8 | mov     rdx, [rbp+len]
0x004261EC | 48 8B 45 F8 | mov     rax, [rbp+addr]
0x004261F0 | 48 89 D6 | mov     rsi, rdx; len
0x004261F3 | 48 89 C7 | mov     rdi, rax; addr
0x004261F6 | E8 05 14 FE FF | call    _munmap
0x004261FB | EB 0C | jmp     short loc_426209
0x004261FD | 48 8B 45 F8 | mov     rax, [rbp+addr]
0x00426201 | 48 89 C7 | mov     rdi, rax; ptr
0x00426204 | E8 57 04 FE FF | call    _free
0x00426209 | 8B 45 F0 | mov     eax, [rbp+var_10]
0x0042620C | C9 | leave
0x0042620D | C3 | retn
 ************ 
Source Code:
int FAST_FUNC bb_init_module(const char *filename, const char *options)
{
	size_t image_size;
	char *image;
	int rc;
	bool mmaped;

	if (!options)
		options = "";

//TODO: audit bb_init_module_24 to match error code convention
#if ENABLE_FEATURE_2_4_MODULES
	if (get_linux_version_code() < KERNEL_VERSION(2,6,0))
		return bb_init_module_24(filename, options);
#endif

	image_size = INT_MAX - 4095;
	mmaped = 0;
	image = try_to_mmap_module(filename, &image_size);
	if (image) {
		mmaped = 1;
	} else {
		errno = ENOMEM; /* may be changed by e.g. open errors below */
		image = xmalloc_open_zipped_read_close(filename, &image_size);
		if (!image)
			return -errno;
	}

	errno = 0;
	init_module(image, image_size, options);
	rc = errno;
	if (mmaped)
		munmap(image, image_size);
	else
		free(image);
	return rc;
}
 ************ 
Parsed Output:
void func_name(void *var_28, void *var_30) {
    if (var_30 == 0) {
        var_30 = &unk_52AA22;
    }
    void *len = (void *)0x7FFFF000;
    char var_9 = 0;
    void *addr = 0;
    if (addr != 0) {
        var_9 = 1;
    }
    else {
        goto loc_4261AB;
    }
    *(int *)0x75D400 = 0x0C;
    void *rdx = len;
    void *rax = var_28;
    sub_4C33AC(rax, rdx);
    addr = rax;
    if (addr == 0) {
        *(int *)0x75D400 = 0;
        void *rdx = len;
        void *rcx = var_30;
        void *rax = addr;
        _syscall(0xAF, 0, rax, rcx, rdx);
        *(int *)0x75D400 = *(int *)0x75D400;
        int var_10 = *(int *)0x75D400;
        if (var_9 != 0) {
            void *rdx = len;
            void *rax = addr;
            _munmap(rax, rdx);
        }
        else {
            void *rax = addr;
            _free(rax);
        }
        return var_10;
    }
    else {
        goto loc_4261AB;
    }
}
 ************ 
Similarity Score (Unixcoder): 0.5750727653503418
Func rank: 71

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: run_applet_and_exit
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004C33AC | 55 | push    rbp
0x004C33AD | 48 89 E5 | mov     rbp, rsp
0x004C33B0 | 48 83 EC 20 | sub     rsp, 20h
0x004C33B4 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004C33B8 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004C33BC | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004C33C0 | 48 89 C7 | mov     rdi, rax
0x004C33C3 | E8 12 FF FF FF | call    sub_4C32DA
0x004C33C8 | 89 45 FC | mov     [rbp+fd], eax
0x004C33CB | 83 7D FC 00 | cmp     [rbp+fd], 0
0x004C33CF | 79 07 | jns     short loc_4C33D8
0x004C33D1 | B8 00 00 00 00 | mov     eax, 0
0x004C33D6 | EB 40 | jmp     short locret_4C3418
0x004C33D8 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x004C33DC | 8B 45 FC | mov     eax, [rbp+fd]
0x004C33DF | 48 89 D6 | mov     rsi, rdx
0x004C33E2 | 89 C7 | mov     edi, eax
0x004C33E4 | E8 7B 3E 04 00 | call    sub_507264
0x004C33E9 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x004C33ED | 48 83 7D F0 00 | cmp     [rbp+var_10], 0
0x004C33F2 | 75 16 | jnz     short loc_4C340A
0x004C33F4 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004C33F8 | 48 89 C6 | mov     rsi, rax
0x004C33FB | BF B6 68 53 00 | mov     edi, offset aReadErrorFromS; "read error from '%s'"
0x004C3400 | B8 00 00 00 00 | mov     eax, 0
0x004C3405 | E8 CF 5D F4 FF | call    sub_4091D9
0x004C340A | 8B 45 FC | mov     eax, [rbp+fd]
0x004C340D | 89 C7 | mov     edi, eax; fd
0x004C340F | E8 FC 39 F4 FF | call    _close
0x004C3414 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004C3418 | C9 | leave
0x004C3419 | C3 | retn

 Ourput decompiled code:
FAST_FUNC xmalloc_open_zipped_read_close(const char *fname, size_t *maxsz_p)
{
	int fd;
	char *image;

	fd = open_zipped(fname);
	if (fd < 0)
		return NULL;

	image = xmalloc_read(fd, maxsz_p);
	if (!image)
		bb_perror_msg("read error from '%s'", fname);
	close(fd);

	return image;
}

## Example:

 Input assembly code:
0x004F3F0D | 55 | push    rbp
0x004F3F0E | 48 89 E5 | mov     rbp, rsp
0x004F3F11 | 48 83 EC 20 | sub     rsp, 20h
0x004F3F15 | 48 89 7D E8 | mov     [rbp+stream], rdi
0x004F3F19 | 48 89 75 E0 | mov     [rbp+file], rsi
0x004F3F1D | 48 8B 45 E0 | mov     rax, [rbp+file]
0x004F3F21 | BE 00 00 00 00 | mov     esi, 0; oflag
0x004F3F26 | 48 89 C7 | mov     rdi, rax; file
0x004F3F29 | B8 00 00 00 00 | mov     eax, 0
0x004F3F2E | E8 9D 37 F1 FF | call    _open64
0x004F3F33 | 89 45 FC | mov     [rbp+fd], eax
0x004F3F36 | 83 7D FC 00 | cmp     [rbp+fd], 0
0x004F3F3A | 78 52 | js      short loc_4F3F8E
0x004F3F3C | 48 8B 45 E8 | mov     rax, [rbp+stream]
0x004F3F40 | 48 89 C6 | mov     rsi, rax; stream
0x004F3F43 | BF F8 B3 75 00 | mov     edi, offset dest; s
0x004F3F48 | E8 73 30 F1 FF | call    _fputs_unlocked
0x004F3F4D | 48 8B 45 E8 | mov     rax, [rbp+stream]
0x004F3F51 | 48 89 C7 | mov     rdi, rax; stream
0x004F3F54 | E8 27 34 F1 FF | call    _fflush
0x004F3F59 | 48 8B 45 E8 | mov     rax, [rbp+stream]
0x004F3F5D | 48 89 C7 | mov     rdi, rax; stream
0x004F3F60 | E8 FB 32 F1 FF | call    _fileno
0x004F3F65 | 89 C2 | mov     edx, eax
0x004F3F67 | 8B 45 FC | mov     eax, [rbp+fd]
0x004F3F6A | 89 D6 | mov     esi, edx
0x004F3F6C | 89 C7 | mov     edi, eax
0x004F3F6E | E8 F3 73 F1 FF | call    sub_40B366
0x004F3F73 | 8B 45 FC | mov     eax, [rbp+fd]
0x004F3F76 | 89 C7 | mov     edi, eax; fd
0x004F3F78 | E8 93 2E F1 FF | call    _close
0x004F3F7D | 48 8B 45 E8 | mov     rax, [rbp+stream]
0x004F3F81 | 48 89 C6 | mov     rsi, rax; stream
0x004F3F84 | BF 0A 00 00 00 | mov     edi, 0Ah; c
0x004F3F89 | E8 A2 33 F1 FF | call    _putc_unlocked
0x004F3F8E | 90 | nop
0x004F3F8F | C9 | leave
0x004F3F90 | C3 | retn

 Ourput decompiled code:
static void dump_file(FILE *fp, const char *filename)
{
	int fd = open(filename, O_RDONLY);
	if (fd >= 0) {
		fputs(G.jiffy_line, fp);
		fflush(fp);
		bb_copyfd_eof(fd, fileno(fp));
		close(fd);
		fputc('\n', fp);
	}
}

## Example:

 Input assembly code:
0x005073F7 | 55 | push    rbp
0x005073F8 | 48 89 E5 | mov     rbp, rsp
0x005073FB | 48 83 EC 20 | sub     rsp, 20h
0x005073FF | 48 89 7D E8 | mov     [rbp+file], rdi
0x00507403 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00507407 | 48 8B 45 E8 | mov     rax, [rbp+file]
0x0050740B | BE 00 00 00 00 | mov     esi, 0; oflag
0x00507410 | 48 89 C7 | mov     rdi, rax; file
0x00507413 | B8 00 00 00 00 | mov     eax, 0
0x00507418 | E8 B3 02 F0 FF | call    _open64
0x0050741D | 89 45 FC | mov     [rbp+fd], eax
0x00507420 | 83 7D FC 00 | cmp     [rbp+fd], 0
0x00507424 | 79 07 | jns     short loc_50742D
0x00507426 | B8 00 00 00 00 | mov     eax, 0
0x0050742B | EB 23 | jmp     short locret_507450
0x0050742D | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00507431 | 8B 45 FC | mov     eax, [rbp+fd]
0x00507434 | 48 89 D6 | mov     rsi, rdx
0x00507437 | 89 C7 | mov     edi, eax
0x00507439 | E8 26 FE FF FF | call    sub_507264
0x0050743E | 48 89 45 F0 | mov     [rbp+var_10], rax
0x00507442 | 8B 45 FC | mov     eax, [rbp+fd]
0x00507445 | 89 C7 | mov     edi, eax; fd
0x00507447 | E8 C4 F9 EF FF | call    _close
0x0050744C | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00507450 | C9 | leave
0x00507451 | C3 | retn

 Ourput decompiled code:
FAST_FUNC xmalloc_open_read_close(const char *filename, size_t *maxsz_p)
{
	char *buf;
	size_t size;
	int fd;
	off_t len;

	fd = open(filename, O_RDONLY);
	if (fd < 0)
		return NULL;

	/* /proc/N/stat files report len 0 here */
	/* In order to make such files readable, we add small const */
	size = 0x3ff; /* read only 1k on unseekable files */
	len = lseek(fd, 0, SEEK_END) | 0x3ff; /* + up to 1k */
	if (len != (off_t)-1) {
		xlseek(fd, 0, SEEK_SET);
		size = maxsz_p ? *maxsz_p : (INT_MAX - 4095);
		if (len < size)
			size = len;
	}

	buf = xmalloc(size + 1);
	size = read_close(fd, buf, size);
	if ((ssize_t)size < 0) {
		free(buf);
		return NULL;
	}
	buf = xrealloc(buf, size + 1);
	buf[size] = '\0';

	if (maxsz_p)
		*maxsz_p = size;
	return buf;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00408CFF | 55 | push    rbp
0x00408D00 | 48 89 E5 | mov     rbp, rsp
0x00408D03 | 48 83 EC 20 | sub     rsp, 20h
0x00408D07 | 48 89 7D E8 | mov     [rbp+s1], rdi
0x00408D0B | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00408D0F | 48 8B 45 E8 | mov     rax, [rbp+s1]
0x00408D13 | 48 89 C7 | mov     rdi, rax
0x00408D16 | E8 4D F3 FF FF | call    sub_408068
0x00408D1B | 89 45 FC | mov     [rbp+var_4], eax
0x00408D1E | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x00408D22 | 78 11 | js      short loc_408D35
0x00408D24 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00408D28 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00408D2B | 48 89 D6 | mov     rsi, rdx
0x00408D2E | 89 C7 | mov     edi, eax
0x00408D30 | E8 FE FE FF FF | call    sub_408C33
0x00408D35 | 48 8B 45 E8 | mov     rax, [rbp+s1]
0x00408D39 | BA 07 00 00 00 | mov     edx, 7; n
0x00408D3E | BE 3F 4D 51 00 | mov     esi, offset aBusybox; "busybox"
0x00408D43 | 48 89 C7 | mov     rdi, rax; s1
0x00408D46 | E8 55 DA FF FF | call    _strncmp
0x00408D4B | 85 C0 | test    eax, eax
0x00408D4D | 75 13 | jnz     short loc_408D62
0x00408D4F | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00408D53 | 48 89 C7 | mov     rdi, rax
0x00408D56 | E8 4E FB FF FF | call    sub_4088A9
0x00408D5B | 89 C7 | mov     edi, eax; status
0x00408D5D | E8 5E ED FF FF | call    _exit
0x00408D62 | 90 | nop
0x00408D63 | C9 | leave
0x00408D64 | C3 | retn
 ************ 
Source Code:
void FAST_FUNC run_applet_and_exit(const char *name, char **argv)
{
	int applet = find_applet_by_name(name);
	if (applet >= 0)
		run_applet_no_and_exit(applet, argv);
	if (strncmp(name, "busybox", 7) == 0)
		exit(busybox_main(argv));
}
 ************ 
Parsed Output:
FAST_FUNC xmalloc_strncmp_exit(const char *s1, const char *s2, size_t n)
{
    int status;

    status = strncmp(s1, s2, n);
    if (status == 0) {
        exit(0);
    }

    return status;
}
 ************ 
Similarity Score (Unixcoder): 0.5727896690368652
Func rank: 72

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: is_nip_reserved
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00503608 | 55 | push    rbp
0x00503609 | 48 89 E5 | mov     rbp, rsp
0x0050360C | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00503610 | 89 75 F4 | mov     [rbp+var_C], esi
0x00503613 | EB 01 | jmp     short loc_503616
0x00503615 | 90 | nop
0x00503616 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0050361A | 48 8D 50 01 | lea     rdx, [rax+1]
0x0050361E | 48 89 55 F8 | mov     [rbp+var_8], rdx
0x00503622 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00503625 | 3C 20 | cmp     al, 20h ; ' '
0x00503627 | 75 EC | jnz     short loc_503615
0x00503629 | 83 6D F4 01 | sub     [rbp+var_C], 1
0x0050362D | 83 7D F4 00 | cmp     [rbp+var_C], 0
0x00503631 | 75 E3 | jnz     short loc_503616
0x00503633 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00503637 | 5D | pop     rbp
0x00503638 | C3 | retn

 Ourput decompiled code:
endif

static char *skip_fields(char *str, int count)
{
	do {
		while (*str++ != ' ')
			continue;
		/* we found a space char, str points after it */
	} while (--count);
	return str;
}

## Example:

 Input assembly code:
0x0046EDFC | 55 | push    rbp
0x0046EDFD | 48 89 E5 | mov     rbp, rsp
0x0046EE00 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0046EE04 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x0046EE08 | EB 29 | jmp     short loc_46EE33
0x0046EE0A | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0046EE0E | 48 8D 50 01 | lea     rdx, [rax+1]
0x0046EE12 | 48 89 55 F0 | mov     [rbp+var_10], rdx
0x0046EE16 | 0F B6 08 | movzx   ecx, byte ptr [rax]
0x0046EE19 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0046EE1D | 48 8D 50 01 | lea     rdx, [rax+1]
0x0046EE21 | 48 89 55 F8 | mov     [rbp+var_8], rdx
0x0046EE25 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0046EE28 | 38 C1 | cmp     cl, al
0x0046EE2A | 74 07 | jz      short loc_46EE33
0x0046EE2C | B8 00 00 00 00 | mov     eax, 0
0x0046EE31 | EB 0F | jmp     short loc_46EE42
0x0046EE33 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0046EE37 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0046EE3A | 84 C0 | test    al, al
0x0046EE3C | 75 CC | jnz     short loc_46EE0A
0x0046EE3E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0046EE42 | 5D | pop     rbp
0x0046EE43 | C3 | retn

 Ourput decompiled code:
static char *
prefix(const char *string, const char *pfx)
{
	while (*pfx) {
		if (*pfx++ != *string++)
			return NULL;
	}
	return (char *) string;
}

## Example:

 Input assembly code:
0x00459CD1 | 55 | push    rbp
0x00459CD2 | 48 89 E5 | mov     rbp, rsp
0x00459CD5 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00459CD9 | 89 F0 | mov     eax, esi
0x00459CDB | 88 45 F4 | mov     [rbp+var_C], al
0x00459CDE | EB 0C | jmp     short loc_459CEC
0x00459CE0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00459CE4 | 48 8B 40 08 | mov     rax, [rax+8]
0x00459CE8 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00459CEC | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00459CF1 | 74 0F | jz      short loc_459D02
0x00459CF3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00459CF7 | 48 8B 00 | mov     rax, [rax]
0x00459CFA | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00459CFD | 38 45 F4 | cmp     [rbp+var_C], al
0x00459D00 | 77 DE | ja      short loc_459CE0
0x00459D02 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00459D07 | 74 15 | jz      short loc_459D1E
0x00459D09 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00459D0D | 48 8B 00 | mov     rax, [rax]
0x00459D10 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00459D13 | 38 45 F4 | cmp     [rbp+var_C], al
0x00459D16 | 75 06 | jnz     short loc_459D1E
0x00459D18 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00459D1C | EB 05 | jmp     short loc_459D23
0x00459D1E | B8 00 00 00 00 | mov     eax, 0
0x00459D23 | 5D | pop     rbp
0x00459D24 | C3 | retn

 Ourput decompiled code:
FAST_FUNC udhcp_find_option(struct option_set *opt_list, uint8_t code)
{
	while (opt_list && opt_list->data[OPT_CODE] < code)
		opt_list = opt_list->next;

	if (opt_list && opt_list->data[OPT_CODE] == code)
		return opt_list;
	return NULL;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00459481 | 55 | push    rbp
0x00459482 | 48 89 E5 | mov     rbp, rsp
0x00459485 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00459489 | 89 75 F4 | mov     [rbp+var_C], esi
0x0045948C | EB 1E | jmp     short loc_4594AC
0x0045948E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00459492 | 8B 40 08 | mov     eax, [rax+8]
0x00459495 | 39 45 F4 | cmp     [rbp+var_C], eax
0x00459498 | 75 07 | jnz     short loc_4594A1
0x0045949A | B8 01 00 00 00 | mov     eax, 1
0x0045949F | EB 17 | jmp     short loc_4594B8
0x004594A1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004594A5 | 48 8B 00 | mov     rax, [rax]
0x004594A8 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004594AC | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004594B1 | 75 DB | jnz     short loc_45948E
0x004594B3 | B8 00 00 00 00 | mov     eax, 0
0x004594B8 | 5D | pop     rbp
0x004594B9 | C3 | retn
 ************ 
Source Code:
int FAST_FUNC is_nip_reserved(struct static_lease *st_lease, uint32_t nip)
{
	while (st_lease) {
		if (st_lease->nip == nip)
			return 1;
		st_lease = st_lease->next;
	}

	return 0;
}
 ************ 
Parsed Output:
static int check_value(struct node *head, int value)
{
    while (head != NULL) {
        if (head->data == value) {
            return 1;
        }
        head = head->next;
    }
    return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.5717897415161133
Func rank: 73

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: rc_read_init
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004BF5C8 | 55 | push    rbp
0x004BF5C9 | 48 89 E5 | mov     rbp, rsp
0x004BF5CC | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004BF5D0 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004BF5D4 | EB 41 | jmp     short loc_4BF617
0x004BF5D6 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BF5DA | 48 8B 50 08 | mov     rdx, [rax+8]
0x004BF5DE | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BF5E2 | 48 8B 40 10 | mov     rax, [rax+10h]
0x004BF5E6 | 48 39 C2 | cmp     rdx, rax
0x004BF5E9 | 75 07 | jnz     short loc_4BF5F2
0x004BF5EB | B8 00 00 00 00 | mov     eax, 0
0x004BF5F0 | EB 53 | jmp     short loc_4BF645
0x004BF5F2 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BF5F6 | 48 8B 40 08 | mov     rax, [rax+8]
0x004BF5FA | 48 8D 50 01 | lea     rdx, [rax+1]
0x004BF5FE | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BF602 | 48 89 50 08 | mov     [rax+8], rdx
0x004BF606 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF60A | 8B 40 04 | mov     eax, [rax+4]
0x004BF60D | 8D 50 01 | lea     edx, [rax+1]
0x004BF610 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF614 | 89 50 04 | mov     [rax+4], edx
0x004BF617 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF61B | 8B 50 04 | mov     edx, [rax+4]
0x004BF61E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF622 | 8B 40 24 | mov     eax, [rax+24h]
0x004BF625 | 89 C0 | mov     eax, eax
0x004BF627 | 0F B6 80 A0 6C 52 00 | movzx   eax, ds:byte_526CA0[rax]
0x004BF62E | 0F B6 C0 | movzx   eax, al
0x004BF631 | 39 C2 | cmp     edx, eax
0x004BF633 | 72 A1 | jb      short loc_4BF5D6
0x004BF635 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF639 | C7 40 04 00 00 00 00 | mov     dword ptr [rax+4], 0
0x004BF640 | B8 01 00 00 00 | mov     eax, 1
0x004BF645 | 5D | pop     rbp
0x004BF646 | C3 | retn

 Ourput decompiled code:
static bool XZ_FUNC check_skip(struct xz_dec *s, struct xz_buf *b)
{
	while (s->pos < check_sizes[s->check_type]) {
		if (b->in_pos == b->in_size)
			return false;

		++b->in_pos;
		++s->pos;
	}

	s->pos = 0;

	return true;
}

## Example:

 Input assembly code:
0x004BF520 | 55 | push    rbp
0x004BF521 | 48 89 E5 | mov     rbp, rsp
0x004BF524 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004BF528 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004BF52C | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BF530 | 48 8B 50 08 | mov     rdx, [rax+8]
0x004BF534 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BF538 | 48 8B 40 10 | mov     rax, [rax+10h]
0x004BF53C | 48 39 C2 | cmp     rdx, rax
0x004BF53F | 75 07 | jnz     short loc_4BF548
0x004BF541 | B8 00 00 00 00 | mov     eax, 0
0x004BF546 | EB 7E | jmp     short loc_4BF5C6
0x004BF548 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF54C | 8B 50 20 | mov     edx, [rax+20h]
0x004BF54F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF553 | 8B 40 04 | mov     eax, [rax+4]
0x004BF556 | 89 C1 | mov     ecx, eax
0x004BF558 | D3 EA | shr     edx, cl
0x004BF55A | 89 D0 | mov     eax, edx
0x004BF55C | 0F B6 F0 | movzx   esi, al
0x004BF55F | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BF563 | 48 8B 38 | mov     rdi, [rax]
0x004BF566 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BF56A | 48 8B 40 08 | mov     rax, [rax+8]
0x004BF56E | 48 8D 48 01 | lea     rcx, [rax+1]
0x004BF572 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x004BF576 | 48 89 4A 08 | mov     [rdx+8], rcx
0x004BF57A | 48 01 F8 | add     rax, rdi
0x004BF57D | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004BF580 | 0F B6 C0 | movzx   eax, al
0x004BF583 | 39 C6 | cmp     esi, eax
0x004BF585 | 74 07 | jz      short loc_4BF58E
0x004BF587 | B8 07 00 00 00 | mov     eax, 7
0x004BF58C | EB 38 | jmp     short loc_4BF5C6
0x004BF58E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF592 | 8B 40 04 | mov     eax, [rax+4]
0x004BF595 | 8D 50 08 | lea     edx, [rax+8]
0x004BF598 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF59C | 89 50 04 | mov     [rax+4], edx
0x004BF59F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF5A3 | 8B 40 04 | mov     eax, [rax+4]
0x004BF5A6 | 83 F8 1F | cmp     eax, 1Fh
0x004BF5A9 | 76 81 | jbe     short loc_4BF52C
0x004BF5AB | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF5AF | C7 40 20 00 00 00 00 | mov     dword ptr [rax+20h], 0
0x004BF5B6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BF5BA | C7 40 04 00 00 00 00 | mov     dword ptr [rax+4], 0
0x004BF5C1 | B8 01 00 00 00 | mov     eax, 1
0x004BF5C6 | 5D | pop     rbp
0x004BF5C7 | C3 | retn

 Ourput decompiled code:
static enum xz_ret XZ_FUNC crc32_validate(struct xz_dec *s, struct xz_buf *b)
{
	do {
		if (b->in_pos == b->in_size)
			return XZ_OK;

		if (((s->crc32 >> s->pos) & 0xFF) != b->in[b->in_pos++])
			return XZ_DATA_ERROR;

		s->pos += 8;

	} while (s->pos < 32);

	s->crc32 = 0;
	s->pos = 0;

	return XZ_STREAM_END;
}

## Example:

 Input assembly code:
0x004B4EE0 | 55 | push    rbp
0x004B4EE1 | 48 89 E5 | mov     rbp, rsp
0x004B4EE4 | 48 83 EC 20 | sub     rsp, 20h
0x004B4EE8 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004B4EEC | 48 89 75 E0 | mov     [rbp+name], rsi
0x004B4EF0 | E9 A9 00 00 00 | jmp     loc_4B4F9E
0x004B4EF5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004B4EF9 | 48 8B 40 08 | mov     rax, [rax+8]
0x004B4EFD | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004B4F00 | 3C 2F | cmp     al, 2Fh ; '/'
0x004B4F02 | 75 2A | jnz     short loc_4B4F2E
0x004B4F04 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004B4F08 | 48 8B 40 08 | mov     rax, [rax+8]
0x004B4F0C | 48 8B 4D E0 | mov     rcx, [rbp+name]
0x004B4F10 | BA 09 00 00 00 | mov     edx, 9; flags
0x004B4F15 | 48 89 CE | mov     rsi, rcx; name
0x004B4F18 | 48 89 C7 | mov     rdi, rax; pattern
0x004B4F1B | E8 00 1E F5 FF | call    _fnmatch
0x004B4F20 | 85 C0 | test    eax, eax
0x004B4F22 | 75 6F | jnz     short loc_4B4F93
0x004B4F24 | B8 01 00 00 00 | mov     eax, 1
0x004B4F29 | E9 80 00 00 00 | jmp     locret_4B4FAE
0x004B4F2E | 48 8B 45 E0 | mov     rax, [rbp+name]
0x004B4F32 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004B4F36 | EB 50 | jmp     short loc_4B4F88
0x004B4F38 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004B4F3C | 48 3B 45 E0 | cmp     rax, [rbp+name]
0x004B4F40 | 74 0F | jz      short loc_4B4F51
0x004B4F42 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004B4F46 | 48 83 E8 01 | sub     rax, 1
0x004B4F4A | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004B4F4D | 3C 2F | cmp     al, 2Fh ; '/'
0x004B4F4F | 75 32 | jnz     short loc_4B4F83
0x004B4F51 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004B4F55 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004B4F58 | 3C 2F | cmp     al, 2Fh ; '/'
0x004B4F5A | 74 27 | jz      short loc_4B4F83
0x004B4F5C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004B4F60 | 48 8B 40 08 | mov     rax, [rax+8]
0x004B4F64 | 48 8B 4D F8 | mov     rcx, [rbp+var_8]
0x004B4F68 | BA 09 00 00 00 | mov     edx, 9; flags
0x004B4F6D | 48 89 CE | mov     rsi, rcx; name
0x004B4F70 | 48 89 C7 | mov     rdi, rax; pattern
0x004B4F73 | E8 A8 1D F5 FF | call    _fnmatch
0x004B4F78 | 85 C0 | test    eax, eax
0x004B4F7A | 75 07 | jnz     short loc_4B4F83
0x004B4F7C | B8 01 00 00 00 | mov     eax, 1
0x004B4F81 | EB 2B | jmp     short locret_4B4FAE
0x004B4F83 | 48 83 45 F8 01 | add     [rbp+var_8], 1
0x004B4F88 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004B4F8C | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004B4F8F | 84 C0 | test    al, al
0x004B4F91 | 75 A5 | jnz     short loc_4B4F38
0x004B4F93 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004B4F97 | 48 8B 00 | mov     rax, [rax]
0x004B4F9A | 48 89 45 E8 | mov     [rbp+var_18], rax
0x004B4F9E | 48 83 7D E8 00 | cmp     [rbp+var_18], 0
0x004B4FA3 | 0F 85 4C FF FF FF | jnz     loc_4B4EF5
0x004B4FA9 | B8 00 00 00 00 | mov     eax, 0
0x004B4FAE | C9 | leave
0x004B4FAF | C3 | retn

 Ourput decompiled code:
if ENABLE_FEATURE_TAR_FROM
static int exclude_file(const llist_t *excluded_files, const char *file)
{
	while (excluded_files) {
		if (excluded_files->data[0] == '/') {
			if (fnmatch(excluded_files->data, file,
					FNM_PATHNAME | FNM_LEADING_DIR) == 0)
				return 1;
		} else {
			const char *p;

			for (p = file; p[0] != '\0'; p++) {
				if ((p == file || p[-1] == '/')
				 && p[0] != '/'
				 && fnmatch(excluded_files->data, p,
						FNM_PATHNAME | FNM_LEADING_DIR) == 0
				) {
					return 1;
				}
			}
		}
		excluded_files = excluded_files->link;
	}

	return 0;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004BC5C3 | 55 | push    rbp
0x004BC5C4 | 48 89 E5 | mov     rbp, rsp
0x004BC5C7 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004BC5CB | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004BC5CF | EB 67 | jmp     short loc_4BC638
0x004BC5D1 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BC5D5 | 48 8B 50 08 | mov     rdx, [rax+8]
0x004BC5D9 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BC5DD | 48 8B 40 10 | mov     rax, [rax+10h]
0x004BC5E1 | 48 39 C2 | cmp     rdx, rax
0x004BC5E4 | 75 07 | jnz     short loc_4BC5ED
0x004BC5E6 | B8 00 00 00 00 | mov     eax, 0
0x004BC5EB | EB 5B | jmp     short loc_4BC648
0x004BC5ED | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BC5F1 | 8B 40 04 | mov     eax, [rax+4]
0x004BC5F4 | C1 E0 08 | shl     eax, 8
0x004BC5F7 | 89 C7 | mov     edi, eax
0x004BC5F9 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BC5FD | 48 8B 30 | mov     rsi, [rax]
0x004BC600 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004BC604 | 48 8B 40 08 | mov     rax, [rax+8]
0x004BC608 | 48 8D 48 01 | lea     rcx, [rax+1]
0x004BC60C | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x004BC610 | 48 89 4A 08 | mov     [rdx+8], rcx
0x004BC614 | 48 01 F0 | add     rax, rsi
0x004BC617 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004BC61A | 0F B6 C0 | movzx   eax, al
0x004BC61D | 8D 14 07 | lea     edx, [rdi+rax]
0x004BC620 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BC624 | 89 50 04 | mov     [rax+4], edx
0x004BC627 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BC62B | 8B 40 08 | mov     eax, [rax+8]
0x004BC62E | 8D 50 FF | lea     edx, [rax-1]
0x004BC631 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BC635 | 89 50 08 | mov     [rax+8], edx
0x004BC638 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BC63C | 8B 40 08 | mov     eax, [rax+8]
0x004BC63F | 85 C0 | test    eax, eax
0x004BC641 | 75 8E | jnz     short loc_4BC5D1
0x004BC643 | B8 01 00 00 00 | mov     eax, 1
0x004BC648 | 5D | pop     rbp
0x004BC649 | C3 | retn
 ************ 
Source Code:
static bool XZ_FUNC rc_read_init(struct rc_dec *rc, struct xz_buf *b)
{
	while (rc->init_bytes_left > 0) {
		if (b->in_pos == b->in_size)
			return false;

		rc->code = (rc->code << 8) + b->in[b->in_pos++];
		--rc->init_bytes_left;
	}

	return true;
}
 ************ 
Parsed Output:
static int check_value(struct data *d) {
    if (d->value == 0) {
        return 0;
    }
    
    int result = (d->value >> 8) & 0xFF;
    d->value = d->value + d->next;
    int temp = (d->value & 0xFF) + result;
    d->next = temp - 1;
    
    if (d->next != 0) {
        return 1;
    } else {
        return 0;
    }
}
 ************ 
Similarity Score (Unixcoder): 0.5623485445976257
Func rank: 74

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: print_closing_wait
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0041A462 | 55 | push    rbp
0x0041A463 | 48 89 E5 | mov     rbp, rsp
0x0041A466 | 48 83 EC 10 | sub     rsp, 10h
0x0041A46A | 89 7D FC | mov     [rbp+var_4], edi
0x0041A46D | 83 7D FC 01 | cmp     [rbp+var_4], 1
0x0041A471 | 75 0C | jnz     short loc_41A47F
0x0041A473 | BF 01 00 00 00 | mov     edi, 1
0x0041A478 | E8 3F D7 FF FF | call    sub_417BBC
0x0041A47D | EB 38 | jmp     short loc_41A4B7
0x0041A47F | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0041A483 | 75 0C | jnz     short loc_41A491
0x0041A485 | BF 00 00 00 00 | mov     edi, 0
0x0041A48A | E8 2D D7 FF FF | call    sub_417BBC
0x0041A48F | EB 26 | jmp     short loc_41A4B7
0x0041A491 | 83 7D FC 02 | cmp     [rbp+var_4], 2
0x0041A495 | 75 0C | jnz     short loc_41A4A3
0x0041A497 | BF DB 69 51 00 | mov     edi, offset aTristate; " (tristate)"
0x0041A49C | E8 6F C3 FE FF | call    _puts
0x0041A4A1 | EB 14 | jmp     short loc_41A4B7
0x0041A4A3 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0041A4A6 | 89 C6 | mov     esi, eax
0x0041A4A8 | BF E7 69 51 00 | mov     edi, offset aUnknownD; " (unknown: %d)\n"
0x0041A4AD | B8 00 00 00 00 | mov     eax, 0
0x0041A4B2 | E8 19 C7 FE FF | call    _printf
0x0041A4B7 | 90 | nop
0x0041A4B8 | C9 | leave
0x0041A4B9 | C3 | retn

 Ourput decompiled code:
if ENABLE_FEATURE_HDPARM_HDIO_TRISTATE_HWIF
static void bus_state_value(unsigned value)
{
	if (value == BUSSTATE_ON)
		on_off(1);
	else if (value == BUSSTATE_OFF)
		on_off(0);
	else if (value == BUSSTATE_TRISTATE)
		printf(" (tristate)\n");
	else
		printf(" (unknown: %d)\n", value);
}

## Example:

 Input assembly code:
0x00421F28 | 55 | push    rbp
0x00421F29 | 48 89 E5 | mov     rbp, rsp
0x00421F2C | 48 83 EC 10 | sub     rsp, 10h
0x00421F30 | 89 7D FC | mov     [rbp+var_4], edi
0x00421F33 | 83 7D FC 13 | cmp     [rbp+var_4], 13h
0x00421F37 | 7E 07 | jle     short loc_421F40
0x00421F39 | B8 6E 75 51 00 | mov     eax, offset aUndefined; "undefined"
0x00421F3E | EB 0F | jmp     short locret_421F4F
0x00421F40 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00421F43 | 89 C6 | mov     esi, eax
0x00421F45 | BF A0 73 51 00 | mov     edi, offset aUnknown_4; "unknown"
0x00421F4A | E8 1C 48 0D 00 | call    sub_4F676B
0x00421F4F | C9 | leave
0x00421F50 | C3 | retn

 Ourput decompiled code:
static const char *uart_type(int type)
{
	if (type > MAX_SERIAL_TYPE)
		return "undefined";

	return nth_string(serial_types, type);
}

## Example:

 Input assembly code:
0x00417BBC | 55 | push    rbp
0x00417BBD | 48 89 E5 | mov     rbp, rsp
0x00417BC0 | 48 83 EC 10 | sub     rsp, 10h
0x00417BC4 | 89 7D FC | mov     [rbp+var_4], edi
0x00417BC7 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x00417BCB | 74 07 | jz      short loc_417BD4
0x00417BCD | B8 E0 52 51 00 | mov     eax, offset aOn; " (on)"
0x00417BD2 | EB 05 | jmp     short loc_417BD9
0x00417BD4 | B8 E6 52 51 00 | mov     eax, offset aOff; " (off)"
0x00417BD9 | 48 89 C7 | mov     rdi, rax; s
0x00417BDC | E8 2F EC FE FF | call    _puts
0x00417BE1 | 90 | nop
0x00417BE2 | C9 | leave
0x00417BE3 | C3 | retn

 Ourput decompiled code:
endif

static void on_off(int value)
{
	puts(value ? " (on)" : " (off)");
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00422354 | 55 | push    rbp
0x00422355 | 48 89 E5 | mov     rbp, rsp
0x00422358 | 48 83 EC 10 | sub     rsp, 10h
0x0042235C | 89 7D FC | mov     [rbp+var_4], edi
0x0042235F | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x00422363 | 74 15 | jz      short loc_42237A
0x00422365 | 81 7D FC FF FF 00 00 | cmp     [rbp+var_4], 0FFFFh
0x0042236C | 75 18 | jnz     short loc_422386
0x0042236E | BF 69 75 51 00 | mov     edi, offset aNone_1; "none"
0x00422373 | E8 98 44 FE FF | call    _puts
0x00422378 | EB 20 | jmp     short loc_42239A
0x0042237A | BF 60 75 51 00 | mov     edi, offset aInfinite; "infinite"
0x0042237F | E8 8C 44 FE FF | call    _puts
0x00422384 | EB 14 | jmp     short loc_42239A
0x00422386 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00422389 | 89 C6 | mov     esi, eax
0x0042238B | BF DB 75 51 00 | mov     edi, offset aU_5; "%u\n"
0x00422390 | B8 00 00 00 00 | mov     eax, 0
0x00422395 | E8 36 48 FE FF | call    _printf
0x0042239A | 90 | nop
0x0042239B | C9 | leave
0x0042239C | C3 | retn
 ************ 
Source Code:
static void print_closing_wait(unsigned int closing_wait)
{
	switch (closing_wait) {
	case ASYNC_CLOSING_WAIT_NONE:
		puts(STR_NONE);
		break;
	case ASYNC_CLOSING_WAIT_INF:
		puts(STR_INFINITE);
		break;
	default:
		printf("%u
", closing_wait);
	}
}
 ************ 
Parsed Output:
static void process_value(unsigned int value)
{
    if (value == 0)
    {
        puts("none");
    }
    else if (value == 0xFFFF)
    {
        puts("infinite");
    }
    else
    {
        printf("%u
", value);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.5623412728309631
Func rank: 75

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: ash_arith
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004780F0 | 55 | push    rbp
0x004780F1 | 48 89 E5 | mov     rbp, rsp
0x004780F4 | 48 83 EC 20 | sub     rsp, 20h
0x004780F8 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004780FC | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00478100 | 48 8B 05 11 53 2E 00 | mov     rax, cs:qword_75D418
0x00478107 | 8B 50 30 | mov     edx, [rax+30h]
0x0047810A | 83 C2 01 | add     edx, 1
0x0047810D | 89 50 30 | mov     [rax+30h], edx
0x00478110 | C6 45 F0 01 | mov     [rbp+var_10], 1
0x00478114 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00478118 | 48 89 C7 | mov     rdi, rax
0x0047811B | E8 3F FF FF FF | call    sub_47805F
0x00478120 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00478124 | 48 8D 55 F0 | lea     rdx, [rbp+var_10]
0x00478128 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0047812C | 48 89 D6 | mov     rsi, rdx
0x0047812F | 48 89 C7 | mov     rdi, rax
0x00478132 | E8 0D F0 FF FF | call    sub_477144
0x00478137 | E8 03 5F FF FF | call    sub_46E03F
0x0047813C | 90 | nop
0x0047813D | C9 | leave
0x0047813E | C3 | retn

 Ourput decompiled code:
static void
defun(char *name, union node *func)
{
	struct cmdentry entry;

	INT_OFF;
	entry.cmdtype = CMDFUNCTION;
	entry.u.func = copyfunc(func);
	addcmdentry(name, &entry);
	INT_ON;
}

## Example:

 Input assembly code:
0x004707B3 | 55 | push    rbp
0x004707B4 | 48 89 E5 | mov     rbp, rsp
0x004707B7 | 48 83 EC 20 | sub     rsp, 20h
0x004707BB | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004707BF | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004707C3 | 48 89 C7 | mov     rdi, rax
0x004707C6 | E8 97 FD FF FF | call    sub_470562
0x004707CB | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004707CF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004707D3 | 48 8B 00 | mov     rax, [rax]
0x004707D6 | 48 85 C0 | test    rax, rax
0x004707D9 | 74 35 | jz      short loc_470810
0x004707DB | 48 8B 05 36 CC 2E 00 | mov     rax, cs:qword_75D418
0x004707E2 | 8B 50 30 | mov     edx, [rax+30h]
0x004707E5 | 83 C2 01 | add     edx, 1
0x004707E8 | 89 50 30 | mov     [rax+30h], edx
0x004707EB | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004707EF | 48 8B 00 | mov     rax, [rax]
0x004707F2 | 48 89 C7 | mov     rdi, rax
0x004707F5 | E8 6E FE FF FF | call    sub_470668
0x004707FA | 48 89 C2 | mov     rdx, rax
0x004707FD | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00470801 | 48 89 10 | mov     [rax], rdx
0x00470804 | E8 36 D8 FF FF | call    sub_46E03F
0x00470809 | B8 00 00 00 00 | mov     eax, 0
0x0047080E | EB 05 | jmp     short locret_470815
0x00470810 | B8 01 00 00 00 | mov     eax, 1
0x00470815 | C9 | leave
0x00470816 | C3 | retn

 Ourput decompiled code:
static int
unalias(const char *name)
{
	struct alias **app;

	app = __lookupalias(name);

	if (*app) {
		INT_OFF;
		*app = freealias(*app);
		INT_ON;
		return 0;
	}

	return 1;
}

## Example:

 Input assembly code:
0x00422B9A | 55 | push    rbp
0x00422B9B | 48 89 E5 | mov     rbp, rsp
0x00422B9E | 48 83 EC 20 | sub     rsp, 20h
0x00422BA2 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00422BA6 | 48 C7 45 F8 77 A4 52 00 | mov     [rbp+format], (offset aS_23+1); "%s"
0x00422BAE | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00422BB2 | 48 8B 10 | mov     rdx, [rax]
0x00422BB5 | 48 8B 45 F8 | mov     rax, [rbp+format]
0x00422BB9 | 48 89 D6 | mov     rsi, rdx
0x00422BBC | 48 89 C7 | mov     rdi, rax; format
0x00422BBF | B8 00 00 00 00 | mov     eax, 0
0x00422BC4 | E8 07 40 FE FF | call    _printf
0x00422BC9 | 48 C7 45 F8 76 A4 52 00 | mov     [rbp+format], offset aS_23; " %s"
0x00422BD1 | 48 83 45 E8 08 | add     [rbp+var_18], 8
0x00422BD6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00422BDA | 48 8B 00 | mov     rax, [rax]
0x00422BDD | 48 85 C0 | test    rax, rax
0x00422BE0 | 75 CC | jnz     short loc_422BAE
0x00422BE2 | 90 | nop
0x00422BE3 | C9 | leave
0x00422BE4 | C3 | retn

 Ourput decompiled code:
static void printargv(char *const *argv)
{
	const char *fmt = " %s" + 1;
	do {
		printf(fmt, *argv);
		fmt = " %s";
	} while (*++argv);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00473BC5 | 55 | push    rbp
0x00473BC6 | 48 89 E5 | mov     rbp, rsp
0x00473BC9 | 48 83 EC 40 | sub     rsp, 40h
0x00473BCD | 48 89 7D C8 | mov     [rbp+var_38], rdi
0x00473BD1 | 48 C7 45 D8 38 F4 46 00 | mov     [rbp+var_28], offset sub_46F438
0x00473BD9 | 48 C7 45 E0 03 F8 46 00 | mov     [rbp+var_20], offset sub_46F803
0x00473BE1 | 48 8B 05 30 98 2E 00 | mov     rax, cs:qword_75D418
0x00473BE8 | 8B 50 30 | mov     edx, [rax+30h]
0x00473BEB | 83 C2 01 | add     edx, 1
0x00473BEE | 89 50 30 | mov     [rax+30h], edx
0x00473BF1 | 48 8B 55 C8 | mov     rdx, [rbp+var_38]
0x00473BF5 | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00473BF9 | 48 89 D6 | mov     rsi, rdx
0x00473BFC | 48 89 C7 | mov     rdi, rax
0x00473BFF | E8 66 7A 01 00 | call    sub_48B66A
0x00473C04 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00473C08 | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x00473C0C | 48 85 C0 | test    rax, rax
0x00473C0F | 74 11 | jz      short loc_473C22
0x00473C11 | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x00473C15 | 48 89 C7 | mov     rdi, rax
0x00473C18 | B8 00 00 00 00 | mov     eax, 0
0x00473C1D | E8 51 A8 FF FF | call    sub_46E473
0x00473C22 | E8 18 A4 FF FF | call    sub_46E03F
0x00473C27 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00473C2B | C9 | leave
0x00473C2C | C3 | retn
 ************ 
Source Code:
if ENABLE_SH_MATH_SUPPORT
static arith_t
ash_arith(const char *s)
{
	arith_state_t math_state;
	arith_t result;

	math_state.lookupvar = lookupvar;
	math_state.setvar    = setvar2;
	//math_state.endofname = endofname;

	INT_OFF;
	result = arith(&math_state, s);
	if (math_state.errmsg)
		ash_msg_and_raise_error(math_state.errmsg);
	INT_ON;

	return result;
}
 ************ 
Parsed Output:
static void func(char *arg)
{
    int var_30;
    int var_38 = arg;
    int var_20 = sub_46F803;
    int var_28 = sub_46F438;

    // Increment value at cs:qword_75D418+30h
    *(cs:qword_75D418+30h) += 1;

    // Call sub_48B66A with arguments var_38 and var_30
    var_30 = sub_48B66A(var_38);

    // If var_30 is not null, call sub_46E473 with argument var_30
    if (var_30 != NULL) {
        sub_46E473(var_30);
    }

    // Call sub_46E03F
    sub_46E03F();

    return;
}
 ************ 
Similarity Score (Unixcoder): 0.5528440475463867
Func rank: 76

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: query_loop
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00503388 | 55 | push    rbp
0x00503389 | 48 89 E5 | mov     rbp, rsp
0x0050338C | 48 83 EC 20 | sub     rsp, 20h
0x00503390 | 48 89 7D E8 | mov     [rbp+file], rdi
0x00503394 | 48 89 75 E0 | mov     [rbp+buf], rsi
0x00503398 | 48 C7 45 F8 FF FF FF FF | mov     [rbp+var_8], 0FFFFFFFFFFFFFFFFh
0x005033A0 | 48 8B 45 E8 | mov     rax, [rbp+file]
0x005033A4 | BE 00 00 00 00 | mov     esi, 0; oflag
0x005033A9 | 48 89 C7 | mov     rdi, rax; file
0x005033AC | B8 00 00 00 00 | mov     eax, 0
0x005033B1 | E8 1A 43 F0 FF | call    _open64
0x005033B6 | 89 45 F4 | mov     [rbp+fd], eax
0x005033B9 | 83 7D F4 00 | cmp     [rbp+fd], 0
0x005033BD | 78 24 | js      short loc_5033E3
0x005033BF | 48 8B 4D E0 | mov     rcx, [rbp+buf]
0x005033C3 | 8B 45 F4 | mov     eax, [rbp+fd]
0x005033C6 | BA FF 03 00 00 | mov     edx, 3FFh; nbytes
0x005033CB | 48 89 CE | mov     rsi, rcx; buf
0x005033CE | 89 C7 | mov     edi, eax; fd
0x005033D0 | E8 6B 3B F0 FF | call    _read
0x005033D5 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x005033D9 | 8B 45 F4 | mov     eax, [rbp+fd]
0x005033DC | 89 C7 | mov     edi, eax; fd
0x005033DE | E8 2D 3A F0 FF | call    _close
0x005033E3 | B8 00 00 00 00 | mov     eax, 0
0x005033E8 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x005033ED | 48 0F 49 45 F8 | cmovns  rax, [rbp+var_8]
0x005033F2 | 48 89 C2 | mov     rdx, rax
0x005033F5 | 48 8B 45 E0 | mov     rax, [rbp+buf]
0x005033F9 | 48 01 D0 | add     rax, rdx
0x005033FC | C6 00 00 | mov     byte ptr [rax], 0
0x005033FF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00503403 | C9 | leave
0x00503404 | C3 | retn

 Ourput decompiled code:
define PROCPS_BUFSIZE 1024

static int read_to_buf(const char *filename, void *buf)
{
	int fd;
	/* open_read_close() would do two reads, checking for EOF.
	 * When you have 10000 /proc/$NUM/stat to read, it isn't desirable */
	ssize_t ret = -1;
	fd = open(filename, O_RDONLY);
	if (fd >= 0) {
		ret = read(fd, buf, PROCPS_BUFSIZE-1);
		close(fd);
	}
	((char *)buf)[ret > 0 ? ret : 0] = '\0';
	return ret;
}

## Example:

 Input assembly code:
0x004178BF | 55 | push    rbp
0x004178C0 | 48 89 E5 | mov     rbp, rsp
0x004178C3 | 48 83 EC 30 | sub     rsp, 30h
0x004178C7 | 48 89 7D D8 | mov     [rbp+var_28], rdi
0x004178CB | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004178CF | BE F5 A7 50 00 | mov     esi, offset sub_50A7F5
0x004178D4 | 48 89 C7 | mov     rdi, rax
0x004178D7 | E8 74 AB 0E 00 | call    sub_502450
0x004178DC | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004178E0 | EB 5F | jmp     short loc_417941
0x004178E2 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004178E6 | 48 89 C7 | mov     rdi, rax
0x004178E9 | E8 18 3A 0F 00 | call    sub_50B306
0x004178EE | 89 45 F4 | mov     [rbp+var_C], eax
0x004178F1 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004178F5 | 48 89 C6 | mov     rsi, rax
0x004178F8 | BF AD 55 53 00 | mov     edi, offset aBarWidth; "BAR_WIDTH"
0x004178FD | E8 64 ED 0D 00 | call    sub_4F6666
0x00417902 | 89 45 F0 | mov     [rbp+var_10], eax
0x00417905 | 83 7D F0 00 | cmp     [rbp+var_10], 0
0x00417909 | 79 16 | jns     short loc_417921
0x0041790B | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0041790F | 48 89 C6 | mov     rsi, rax
0x00417912 | BF 73 55 53 00 | mov     edi, offset aSyntaxErrorS; "syntax error: %s"
0x00417917 | B8 00 00 00 00 | mov     eax, 0
0x0041791C | E8 7D 1D FF FF | call    sub_40969E
0x00417921 | 83 7D F0 00 | cmp     [rbp+var_10], 0
0x00417925 | 78 1A | js      short loc_417941
0x00417927 | 83 7D F0 06 | cmp     [rbp+var_10], 6
0x0041792B | 7F 14 | jg      short loc_417941
0x0041792D | 48 8B 05 D4 5A 34 00 | mov     rax, cs:qword_75D408
0x00417934 | 8B 55 F0 | mov     edx, [rbp+var_10]
0x00417937 | 48 63 D2 | movsxd  rdx, edx
0x0041793A | 8B 4D F4 | mov     ecx, [rbp+var_C]
0x0041793D | 89 4C 90 08 | mov     [rax+rdx*4+8], ecx
0x00417941 | 48 8D 75 E0 | lea     rsi, [rbp+var_20]
0x00417945 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00417949 | B9 84 55 53 00 | mov     ecx, offset asc_535584; "#="
0x0041794E | BA 02 02 54 00 | mov     edx, offset unk_540202
0x00417953 | 48 89 C7 | mov     rdi, rax
0x00417956 | E8 40 AD 0E 00 | call    sub_50269B
0x0041795B | 85 C0 | test    eax, eax
0x0041795D | 75 83 | jnz     short loc_4178E2
0x0041795F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00417963 | 48 89 C7 | mov     rdi, rax
0x00417966 | E8 52 AB 0E 00 | call    sub_5024BD
0x0041796B | 90 | nop
0x0041796C | C9 | leave
0x0041796D | C3 | retn

 Ourput decompiled code:
static void init(const char *cfg_filename)
{
	static const char param_names[] ALIGN1 =
		"BAR_WIDTH\0" "BAR_HEIGHT\0"
		"BAR_LEFT\0" "BAR_TOP\0"
		"BAR_R\0" "BAR_G\0" "BAR_B\0"
#if DEBUG
		"DEBUG\0"
#endif
		;
	char *token[2];
	parser_t *parser = config_open2(cfg_filename, xfopen_stdin);
	while (config_read(parser, token, 2, 2, "#=",
				(PARSE_NORMAL | PARSE_MIN_DIE) & ~(PARSE_TRIM | PARSE_COLLAPSE))) {
		unsigned val = xatoi_positive(token[1]);
		int i = index_in_strings(param_names, token[0]);
		if (i < 0)
			bb_error_msg_and_die("syntax error: %s", token[0]);
		if (i >= 0 && i < 7)
			G.ns[i] = val;
#if DEBUG
		if (i == 7) {
			G.bdebug_messages = val;
			if (G.bdebug_messages)
				G.logfile_fd = xfopen_for_write("/tmp/fbsplash.log");
		}
#endif
	}
	config_close(parser);
}

## Example:

 Input assembly code:
0x0049F475 | 55 | push    rbp
0x0049F476 | 48 89 E5 | mov     rbp, rsp
0x0049F479 | 48 83 EC 20 | sub     rsp, 20h
0x0049F47D | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0049F481 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0049F485 | BE 02 00 00 00 | mov     esi, 2
0x0049F48A | 48 89 C7 | mov     rdi, rax
0x0049F48D | E8 03 AE F6 FF | call    sub_40A295
0x0049F492 | 89 45 FC | mov     [rbp+fd], eax
0x0049F495 | 48 8D 55 F0 | lea     rdx, [rbp+var_10]
0x0049F499 | 8B 45 FC | mov     eax, [rbp+fd]
0x0049F49C | BE 60 12 00 00 | mov     esi, 1260h; request
0x0049F4A1 | 89 C7 | mov     edi, eax; fd
0x0049F4A3 | B8 00 00 00 00 | mov     eax, 0
0x0049F4A8 | E8 F3 78 F6 FF | call    _ioctl
0x0049F4AD | 85 C0 | test    eax, eax
0x0049F4AF | 78 13 | js      short loc_49F4C4
0x0049F4B1 | 8B 45 FC | mov     eax, [rbp+fd]
0x0049F4B4 | 89 C7 | mov     edi, eax; fd
0x0049F4B6 | E8 55 79 F6 FF | call    _close
0x0049F4BB | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0049F4BF | C1 E0 09 | shl     eax, 9
0x0049F4C2 | EB 1E | jmp     short locret_49F4E2
0x0049F4C4 | 8B 45 FC | mov     eax, [rbp+fd]
0x0049F4C7 | 89 C7 | mov     edi, eax
0x0049F4C9 | E8 15 FF FF FF | call    sub_49F3E3
0x0049F4CE | 48 98 | cdqe
0x0049F4D0 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0049F4D4 | 8B 45 FC | mov     eax, [rbp+fd]
0x0049F4D7 | 89 C7 | mov     edi, eax; fd
0x0049F4D9 | E8 32 79 F6 FF | call    _close
0x0049F4DE | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0049F4E2 | C9 | leave
0x0049F4E3 | C3 | retn

 Ourput decompiled code:
static int get_size(const char *file)
{
	int fd;
	long size;

	fd = xopen(file, O_RDWR);
	if (ioctl(fd, BLKGETSIZE, &size) >= 0) {
		close(fd);
		return (size * 512);
	}

	size = count_blocks(fd);
	close(fd);
	return size;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00501875 | 55 | push    rbp
0x00501876 | 48 89 E5 | mov     rbp, rsp
0x00501879 | 48 81 EC 10 01 00 00 | sub     rsp, 110h
0x00501880 | 48 89 BD F8 FE FF FF | mov     [rbp+file], rdi
0x00501887 | 48 C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0
0x0050188F | 48 8B 85 F8 FE FF FF | mov     rax, [rbp+file]
0x00501896 | BE 00 00 00 00 | mov     esi, 0; oflag
0x0050189B | 48 89 C7 | mov     rdi, rax; file
0x0050189E | B8 00 00 00 00 | mov     eax, 0
0x005018A3 | E8 28 5E F0 FF | call    _open64
0x005018A8 | 89 45 F4 | mov     [rbp+fd], eax
0x005018AB | 83 7D F4 00 | cmp     [rbp+fd], 0
0x005018AF | 78 57 | js      short loc_501908
0x005018B1 | 48 8D 95 00 FF FF FF | lea     rdx, [rbp+var_100]
0x005018B8 | 8B 45 F4 | mov     eax, [rbp+fd]
0x005018BB | BE 05 4C 00 00 | mov     esi, 4C05h; request
0x005018C0 | 89 C7 | mov     edi, eax; fd
0x005018C2 | B8 00 00 00 00 | mov     eax, 0
0x005018C7 | E8 D4 54 F0 FF | call    _ioctl
0x005018CC | 85 C0 | test    eax, eax
0x005018CE | 75 2E | jnz     short loc_5018FE
0x005018D0 | 48 8B 85 18 FF FF FF | mov     rax, [rbp+var_E8]
0x005018D7 | 48 89 C1 | mov     rcx, rax
0x005018DA | 48 8D 85 00 FF FF FF | lea     rax, [rbp+var_100]
0x005018E1 | 48 83 C0 38 | add     rax, 38h ; '8'
0x005018E5 | 48 89 C2 | mov     rdx, rax
0x005018E8 | 48 89 CE | mov     rsi, rcx
0x005018EB | BF 19 73 53 00 | mov     edi, offset aLuS; "%lu %s"
0x005018F0 | B8 00 00 00 00 | mov     eax, 0
0x005018F5 | E8 B9 8D F0 FF | call    sub_40A6B3
0x005018FA | 48 89 45 F8 | mov     [rbp+var_8], rax
0x005018FE | 8B 45 F4 | mov     eax, [rbp+fd]
0x00501901 | 89 C7 | mov     edi, eax; fd
0x00501903 | E8 08 55 F0 FF | call    _close
0x00501908 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0050190C | C9 | leave
0x0050190D | C3 | retn
 ************ 
Source Code:
FAST_FUNC query_loop(const char *device)
{
	int fd;
	bb_loop_info loopinfo;
	char *dev = NULL;

	fd = open(device, O_RDONLY);
	if (fd >= 0) {
		if (ioctl(fd, BB_LOOP_GET_STATUS, &loopinfo) == 0) {
			dev = xasprintf("%"OFF_FMT"u %s", (off_t) loopinfo.lo_offset,
					(char *)loopinfo.lo_file_name);
		}
		close(fd);
	}

	return dev;
}
 ************ 
Parsed Output:
static void read_file(const char *file) {
    int fd;
    ssize_t ret;
    char buf[256];

    fd = open(file, O_RDONLY);
    if (fd >= 0) {
        ret = read(fd, buf, sizeof(buf) - 1);
        close(fd);
    }
    buf[ret > 0 ? ret : 0] = '\0';
}
 ************ 
Similarity Score (Unixcoder): 0.5387266874313354
Func rank: 77

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: str_value
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004C92AB | 55 | push    rbp
0x004C92AC | 48 89 E5 | mov     rbp, rsp
0x004C92AF | 48 83 EC 20 | sub     rsp, 20h
0x004C92B3 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004C92B7 | BF 10 00 00 00 | mov     edi, 10h
0x004C92BC | E8 27 0E F4 FF | call    sub_40A0E8
0x004C92C1 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004C92C5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C92C9 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x004C92CD | 48 89 50 08 | mov     [rax+8], rdx
0x004C92D1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C92D5 | C9 | leave
0x004C92D6 | C3 | retn

 Ourput decompiled code:
static VALUE *int_value(arith_t i)
{
	VALUE *v;

	v = xzalloc(sizeof(VALUE));
	if (INTEGER) /* otherwise xzaaloc did it already */
		v->type = INTEGER;
	v->u.i = i;
	return v;
}

## Example:

 Input assembly code:
0x00476145 | 55 | push    rbp
0x00476146 | 48 89 E5 | mov     rbp, rsp
0x00476149 | 48 83 EC 20 | sub     rsp, 20h
0x0047614D | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00476151 | BF 10 00 00 00 | mov     edi, 10h
0x00476156 | E8 8C 86 FF FF | call    sub_46E7E7
0x0047615B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0047615F | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00476163 | 48 89 C7 | mov     rdi, rax
0x00476166 | E8 F2 86 FF FF | call    sub_46E85D
0x0047616B | 48 89 C2 | mov     rdx, rax
0x0047616E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00476172 | 48 89 50 08 | mov     [rax+8], rdx
0x00476176 | 48 8B 05 8B 4E 2E 00 | mov     rax, cs:qword_75B008
0x0047617D | 48 8B 55 F8 | mov     rdx, [rbp+var_8]
0x00476181 | 48 89 10 | mov     [rax], rdx
0x00476184 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00476188 | 48 89 05 79 4E 2E 00 | mov     cs:qword_75B008, rax
0x0047618F | 90 | nop
0x00476190 | C9 | leave
0x00476191 | C3 | retn

 Ourput decompiled code:
static void
addfname(const char *name)
{
	struct strlist *sp;

	sp = stzalloc(sizeof(*sp));
	sp->text = ststrdup(name);
	*exparg.lastp = sp;
	exparg.lastp = &sp->next;
}

## Example:

 Input assembly code:
0x00408FD2 | 55 | push    rbp
0x00408FD3 | 48 89 E5 | mov     rbp, rsp
0x00408FD6 | 48 83 EC 20 | sub     rsp, 20h
0x00408FDA | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00408FDE | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00408FE2 | BF 10 00 00 00 | mov     edi, 10h
0x00408FE7 | E8 73 10 00 00 | call    sub_40A05F
0x00408FEC | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00408FF0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00408FF4 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00408FF8 | 48 89 50 08 | mov     [rax+8], rdx
0x00408FFC | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00409000 | 48 8B 10 | mov     rdx, [rax]
0x00409003 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00409007 | 48 89 10 | mov     [rax], rdx
0x0040900A | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0040900E | 48 8B 55 F8 | mov     rdx, [rbp+var_8]
0x00409012 | 48 89 10 | mov     [rax], rdx
0x00409015 | 90 | nop
0x00409016 | C9 | leave
0x00409017 | C3 | retn

 Ourput decompiled code:
void FAST_FUNC llist_add_to(llist_t **old_head, void *data)
{
	llist_t *new_head = xmalloc(sizeof(llist_t));

	new_head->data = data;
	new_head->link = *old_head;
	*old_head = new_head;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004C92D7 | 55 | push    rbp
0x004C92D8 | 48 89 E5 | mov     rbp, rsp
0x004C92DB | 48 83 EC 20 | sub     rsp, 20h
0x004C92DF | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004C92E3 | BF 10 00 00 00 | mov     edi, 10h
0x004C92E8 | E8 FB 0D F4 FF | call    sub_40A0E8
0x004C92ED | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004C92F1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C92F5 | C6 00 01 | mov     byte ptr [rax], 1
0x004C92F8 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004C92FC | 48 89 C7 | mov     rdi, rax
0x004C92FF | E8 1B 0E F4 FF | call    sub_40A11F
0x004C9304 | 48 89 C2 | mov     rdx, rax
0x004C9307 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C930B | 48 89 50 08 | mov     [rax+8], rdx
0x004C930F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C9313 | C9 | leave
0x004C9314 | C3 | retn
 ************ 
Source Code:
static VALUE *str_value(const char *s)
{
	VALUE *v;

	v = xzalloc(sizeof(VALUE));
	if (STRING) /* otherwise xzaaloc did it already */
		v->type = STRING;
	v->u.s = xstrdup(s);
	return v;
}
 ************ 
Parsed Output:
void set_flag(int *flag) {
    *flag = 1;
}

void set_value(int *ptr, int value) {
    *ptr = value;
}

void func(int arg) {
    int flag;
    int *ptr;

    flag = 0;
    set_flag(&flag);
    ptr = &flag;
    set_value(ptr, arg);
}
 ************ 
Similarity Score (Unixcoder): 0.5274269580841064
Func rank: 78

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: strstr_pattern
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00431D4E | 55 | push    rbp
0x00431D4F | 48 89 E5 | mov     rbp, rsp
0x00431D52 | 48 83 EC 30 | sub     rsp, 30h
0x00431D56 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00431D5A | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00431D5E | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x00431D62 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00431D66 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00431D6A | 48 89 D6 | mov     rsi, rdx
0x00431D6D | 48 89 C7 | mov     rdi, rax
0x00431D70 | E8 B1 FB FF FF | call    sub_431926
0x00431D75 | 48 89 45 F8 | mov     [rbp+ptr], rax
0x00431D79 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0
0x00431D7E | 75 07 | jnz     short loc_431D87
0x00431D80 | B8 00 00 00 00 | mov     eax, 0
0x00431D85 | EB 40 | jmp     short locret_431DC7
0x00431D87 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00431D8B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00431D8E | 84 C0 | test    al, al
0x00431D90 | 74 0F | jz      short loc_431DA1
0x00431D92 | 48 8B 55 F8 | mov     rdx, [rbp+ptr]
0x00431D96 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00431D9A | 48 89 D7 | mov     rdi, rdx
0x00431D9D | FF D0 | call    rax
0x00431D9F | EB 05 | jmp     short loc_431DA6
0x00431DA1 | B8 01 00 00 00 | mov     eax, 1
0x00431DA6 | 89 45 F4 | mov     [rbp+var_C], eax
0x00431DA9 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00431DAD | 48 89 C7 | mov     rdi, rax; ptr
0x00431DB0 | E8 AB 48 FD FF | call    _free
0x00431DB5 | 83 7D F4 01 | cmp     [rbp+var_C], 1
0x00431DB9 | 74 07 | jz      short loc_431DC2
0x00431DBB | B8 00 00 00 00 | mov     eax, 0
0x00431DC0 | EB 05 | jmp     short locret_431DC7
0x00431DC2 | B8 01 00 00 00 | mov     eax, 1
0x00431DC7 | C9 | leave
0x00431DC8 | C3 | retn

 Ourput decompiled code:
static void execute(const char *type, const char *device,
		const char *mntpt /*, int interactive */)
{
	int i;
	struct fsck_instance *inst;
	pid_t pid;

	args[0] = xasprintf("fsck.%s", type);

#if DO_PROGRESS_INDICATOR
	if (progress && !progress_active()) {
		if (strcmp(type, "ext2") == 0
		 || strcmp(type, "ext3") == 0
		) {
			args[XXX] = xasprintf("-C%d", progress_fd); /* 1 */
			inst->flags |= FLAG_PROGRESS;
		}
	}
#endif

	args[num_args - 2] = (char*)device;
	/* args[num_args - 1] = NULL; - already is */

	if (verbose || noexecute) {
		printf("[%s (%d) -- %s]", args[0], num_running,
					mntpt ? mntpt : device);
		for (i = 0; args[i]; i++)
			printf(" %s", args[i]);
		bb_putchar('\n');
	}

	/* Fork and execute the correct program. */
	pid = -1;
	if (!noexecute) {
		pid = spawn(args);
		if (pid < 0)
			bb_simple_perror_msg(args[0]);
	}

#if DO_PROGRESS_INDICATOR
	free(args[XXX]);
#endif

	/* No child, so don't record an instance */
	if (pid <= 0) {
		free(args[0]);
		return;
	}

	inst = xzalloc(sizeof(*inst));
	inst->pid = pid;
	inst->prog = args[0];
	inst->device = xstrdup(device);
	inst->base_device = base_device(device);
#if DO_PROGRESS_INDICATOR
	inst->start_time = time(NULL);
#endif

	/* Add to the list of running fsck's.
	 * (was adding to the end, but adding to the front is simpler...) */
	inst->next = instance_list;
	instance_list = inst;
}

## Example:

 Input assembly code:
0x00508790 | 55 | push    rbp
0x00508791 | 48 89 E5 | mov     rbp, rsp
0x00508794 | 48 83 EC 20 | sub     rsp, 20h
0x00508798 | 48 89 7D E8 | mov     [rbp+s], rdi
0x0050879C | 48 89 75 E0 | mov     [rbp+needle], rsi
0x005087A0 | 48 C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0
0x005087A8 | 48 8B 45 E0 | mov     rax, [rbp+needle]
0x005087AC | 0F B6 00 | movzx   eax, byte ptr [rax]
0x005087AF | 84 C0 | test    al, al
0x005087B1 | 75 18 | jnz     short loc_5087CB
0x005087B3 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x005087B7 | 48 89 C7 | mov     rdi, rax; s
0x005087BA | E8 11 E3 EF FF | call    _strlen
0x005087BF | 48 89 C2 | mov     rdx, rax
0x005087C2 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x005087C6 | 48 01 D0 | add     rax, rdx
0x005087C9 | EB 3A | jmp     short locret_508805
0x005087CB | 48 8B 55 E0 | mov     rdx, [rbp+needle]
0x005087CF | 48 8B 45 E8 | mov     rax, [rbp+s]
0x005087D3 | 48 89 D6 | mov     rsi, rdx; needle
0x005087D6 | 48 89 C7 | mov     rdi, rax; haystack
0x005087D9 | E8 E2 F4 EF FF | call    _strstr
0x005087DE | 48 89 45 F0 | mov     [rbp+var_10], rax
0x005087E2 | 48 83 7D F0 00 | cmp     [rbp+var_10], 0
0x005087E7 | 75 06 | jnz     short loc_5087EF
0x005087E9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x005087ED | EB 16 | jmp     short locret_508805
0x005087EF | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x005087F3 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x005087F7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x005087FB | 48 83 C0 01 | add     rax, 1
0x005087FF | 48 89 45 E8 | mov     [rbp+s], rax
0x00508803 | EB C6 | jmp     short loc_5087CB
0x00508805 | C9 | leave
0x00508806 | C3 | retn

 Ourput decompiled code:
FAST_FUNC strrstr(const char *haystack, const char *needle)
{
	char *r = NULL;

	if (!needle[0])
		return (char*)haystack + strlen(haystack);
	while (1) {
		char *p = strstr(haystack, needle);
		if (!p)
			return r;
		r = p;
		haystack = p + 1;
	}
}

## Example:

 Input assembly code:
0x00432B8B | 55 | push    rbp
0x00432B8C | 48 89 E5 | mov     rbp, rsp
0x00432B8F | 48 83 EC 40 | sub     rsp, 40h
0x00432B93 | 48 89 7D D8 | mov     [rbp+var_28], rdi
0x00432B97 | 48 89 75 D0 | mov     [rbp+var_30], rsi
0x00432B9B | 48 89 55 C8 | mov     [rbp+var_38], rdx
0x00432B9F | 48 8B 55 C8 | mov     rdx, [rbp+var_38]
0x00432BA3 | 48 8B 4D D0 | mov     rcx, [rbp+var_30]
0x00432BA7 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00432BAB | 48 89 CE | mov     rsi, rcx
0x00432BAE | 48 89 C7 | mov     rdi, rax
0x00432BB1 | B8 00 00 00 00 | mov     eax, 0
0x00432BB6 | E8 F8 7A FD FF | call    sub_40A6B3
0x00432BBB | 48 89 45 E0 | mov     [rbp+var_20], rax
0x00432BBF | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00432BC3 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x00432BC7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00432BCB | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00432BCF | EB 4F | jmp     short loc_432C20
0x00432BD1 | 80 7D EF 2D | cmp     [rbp+var_11], 2Dh ; '-'
0x00432BD5 | 75 04 | jnz     short loc_432BDB
0x00432BD7 | C6 45 EF 5F | mov     [rbp+var_11], 5Fh ; '_'
0x00432BDB | 80 7D EF 60 | cmp     [rbp+var_11], 60h ; '`'
0x00432BDF | 7E 10 | jle     short loc_432BF1
0x00432BE1 | 80 7D EF 7A | cmp     [rbp+var_11], 7Ah ; 'z'
0x00432BE5 | 7F 0A | jg      short loc_432BF1
0x00432BE7 | 0F B6 45 EF | movzx   eax, [rbp+var_11]
0x00432BEB | 83 E8 20 | sub     eax, 20h ; ' '
0x00432BEE | 88 45 EF | mov     [rbp+var_11], al
0x00432BF1 | 0F B6 45 EF | movzx   eax, [rbp+var_11]
0x00432BF5 | 0F B6 C0 | movzx   eax, al
0x00432BF8 | 89 C7 | mov     edi, eax
0x00432BFA | E8 DB EA FF FF | call    sub_4316DA
0x00432BFF | 85 C0 | test    eax, eax
0x00432C01 | 75 06 | jnz     short loc_432C09
0x00432C03 | 80 7D EF 5F | cmp     [rbp+var_11], 5Fh ; '_'
0x00432C07 | 75 12 | jnz     short loc_432C1B
0x00432C09 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00432C0D | 48 8D 50 01 | lea     rdx, [rax+1]
0x00432C11 | 48 89 55 F8 | mov     [rbp+var_8], rdx
0x00432C15 | 0F B6 55 EF | movzx   edx, [rbp+var_11]
0x00432C19 | 88 10 | mov     [rax], dl
0x00432C1B | 48 83 45 F0 01 | add     [rbp+var_10], 1
0x00432C20 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00432C24 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00432C27 | 88 45 EF | mov     [rbp+var_11], al
0x00432C2A | 80 7D EF 3D | cmp     [rbp+var_11], 3Dh ; '='
0x00432C2E | 74 06 | jz      short loc_432C36
0x00432C30 | 80 7D EF 00 | cmp     [rbp+var_11], 0
0x00432C34 | 75 9B | jnz     short loc_432BD1
0x00432C36 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x00432C3A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00432C3E | 48 89 D6 | mov     rsi, rdx
0x00432C41 | 48 89 C7 | mov     rdi, rax
0x00432C44 | E8 C4 53 0D 00 | call    sub_50800D
0x00432C49 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00432C4D | C9 | leave
0x00432C4E | C3 | retn

 Ourput decompiled code:
static char *setlocalenv(const char *format, const char *name, const char *value)
{
	char *result;
	char *dst;
	char *src;
	char c;

	result = xasprintf(format, name, value);

	for (dst = src = result; (c = *src) != '=' && c; src++) {
		if (c == '-')
			c = '_';
		if (c >= 'a' && c <= 'z')
			c -= ('a' - 'A');
		if (isalnum(c) || c == '_')
			*dst++ = c;
	}
	overlapping_strcpy(dst, src);

	return result;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00484A4F | 55 | push    rbp
0x00484A50 | 48 89 E5 | mov     rbp, rsp
0x00484A53 | 48 83 EC 30 | sub     rsp, 30h
0x00484A57 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00484A5B | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00484A5F | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x00484A63 | 48 8B 4D E0 | mov     rcx, [rbp+var_20]
0x00484A67 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00484A6B | BA 06 00 00 00 | mov     edx, 6
0x00484A70 | 48 89 CE | mov     rsi, rcx
0x00484A73 | 48 89 C7 | mov     rdi, rax
0x00484A76 | E8 AC 5E 00 00 | call    sub_48A927
0x00484A7B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00484A7F | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00484A84 | 74 16 | jz      short loc_484A9C
0x00484A86 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00484A8A | 48 2B 45 E8 | sub     rax, [rbp+var_18]
0x00484A8E | 89 C2 | mov     edx, eax
0x00484A90 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00484A94 | 89 10 | mov     [rax], edx
0x00484A96 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00484A9A | EB 2B | jmp     short locret_484AC7
0x00484A9C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00484AA0 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00484AA3 | 84 C0 | test    al, al
0x00484AA5 | 75 07 | jnz     short loc_484AAE
0x00484AA7 | B8 00 00 00 00 | mov     eax, 0
0x00484AAC | EB 19 | jmp     short locret_484AC7
0x00484AAE | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00484AB2 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00484AB5 | 3C 2A | cmp     al, 2Ah ; '*'
0x00484AB7 | 75 07 | jnz     short loc_484AC0
0x00484AB9 | B8 00 00 00 00 | mov     eax, 0
0x00484ABE | EB 07 | jmp     short locret_484AC7
0x00484AC0 | 48 83 45 E8 01 | add     [rbp+var_18], 1
0x00484AC5 | EB 9C | jmp     short loc_484A63
0x00484AC7 | C9 | leave
0x00484AC8 | C3 | retn
 ************ 
Source Code:
static char *strstr_pattern(char *val, const char *pattern, int *size)
{
	while (1) {
		char *end = scan_and_match(val, pattern, SCAN_MOVE_FROM_RIGHT + SCAN_MATCH_LEFT_HALF);
		debug_printf_varexp("val:'%s' pattern:'%s' end:'%s'
", val, pattern, end);
		if (end) {
			*size = end - val;
			return val;
		}
		if (*val == '\0')
			return NULL;
		/* Optimization: if "*pat" did not match the start of "string",
		 * we know that "tring", "ring" etc will not match too:
		 */
		if (pattern[0] == '*')
			return NULL;
		val++;
	}
}
 ************ 
Parsed Output:
static void process(const char *arg1, const char *arg2, const char *arg3)
{
    int var_8;
    int var_18;
    int var_20;
    int var_28;

    var_18 = arg1;
    var_20 = arg2;
    var_28 = arg3;

    int rcx = var_20;
    int rax = var_18;
    int edx = 6;

    var_8 = sub_48A927(rcx, rax, edx);

    if (var_8 == 0) {
        return;
    }

    int eax = var_8 - var_18;
    int edx = eax;
    int rax = var_28;
    *rax = edx;

    if (*var_18 == 0) {
        return;
    }

    if (*var_20 == '*') {
        return;
    }

    var_18 += 1;
    goto loc_484A63;
}
 ************ 
Similarity Score (Unixcoder): 0.5252102613449097
Func rank: 79

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: reload_inittab
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004E9DD5 | 55 | push    rbp
0x004E9DD6 | 48 89 E5 | mov     rbp, rsp
0x004E9DD9 | 48 83 EC 20 | sub     rsp, 20h
0x004E9DDD | 48 89 7D E8 | mov     [rbp+s2], rdi
0x004E9DE1 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004E9DE6 | 48 8B 80 88 00 00 00 | mov     rax, [rax+88h]
0x004E9DED | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004E9DF1 | EB 45 | jmp     short loc_4E9E38
0x004E9DF3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E9DF7 | 0F B6 40 46 | movzx   eax, byte ptr [rax+46h]
0x004E9DFB | 3C 3A | cmp     al, 3Ah ; ':'
0x004E9DFD | 75 2E | jnz     short loc_4E9E2D
0x004E9DFF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E9E03 | 48 8B 40 38 | mov     rax, [rax+38h]
0x004E9E07 | 48 85 C0 | test    rax, rax
0x004E9E0A | 74 21 | jz      short loc_4E9E2D
0x004E9E0C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E9E10 | 48 8B 40 38 | mov     rax, [rax+38h]
0x004E9E14 | 48 8B 55 E8 | mov     rdx, [rbp+s2]
0x004E9E18 | 48 89 D6 | mov     rsi, rdx; s2
0x004E9E1B | 48 89 C7 | mov     rdi, rax; s1
0x004E9E1E | E8 2D D2 F1 FF | call    _strcmp
0x004E9E23 | 85 C0 | test    eax, eax
0x004E9E25 | 75 06 | jnz     short loc_4E9E2D
0x004E9E27 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E9E2B | EB 28 | jmp     short locret_4E9E55
0x004E9E2D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E9E31 | 48 8B 00 | mov     rax, [rax]
0x004E9E34 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004E9E38 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004E9E3D | 75 B4 | jnz     short loc_4E9DF3
0x004E9E3F | 48 8B 45 E8 | mov     rax, [rbp+s2]
0x004E9E43 | 48 89 C6 | mov     rsi, rax
0x004E9E46 | BF 30 6F 52 00 | mov     edi, offset aCanTFindLabelF; "can't find label for jump to '%s'"
0x004E9E4B | B8 00 00 00 00 | mov     eax, 0
0x004E9E50 | E8 49 F8 F1 FF | call    sub_40969E
0x004E9E55 | C9 | leave
0x004E9E56 | C3 | retn

 Ourput decompiled code:
static sed_cmd_t *branch_to(char *label)
{
	sed_cmd_t *sed_cmd;

	for (sed_cmd = G.sed_cmd_head; sed_cmd; sed_cmd = sed_cmd->next) {
		if (sed_cmd->cmd == ':' && sed_cmd->string && !strcmp(sed_cmd->string, label)) {
			return sed_cmd;
		}
	}
	bb_error_msg_and_die("can't find label for jump to '%s'", label);
}

## Example:

 Input assembly code:
0x0042DD7A | 55 | push    rbp
0x0042DD7B | 48 89 E5 | mov     rbp, rsp
0x0042DD7E | 48 83 EC 20 | sub     rsp, 20h
0x0042DD82 | 48 89 7D E8 | mov     [rbp+s1], rdi
0x0042DD86 | 48 8B 05 7B F6 32 00 | mov     rax, cs:qword_75D408
0x0042DD8D | 48 8B 80 38 01 00 00 | mov     rax, [rax+138h]
0x0042DD94 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0042DD98 | EB 3F | jmp     short loc_42DDD9
0x0042DD9A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0042DD9E | 48 8B 40 08 | mov     rax, [rax+8]
0x0042DDA2 | 48 89 C7 | mov     rdi, rax; s
0x0042DDA5 | E8 26 8D FD FF | call    _strlen
0x0042DDAA | 48 89 C2 | mov     rdx, rax; n
0x0042DDAD | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0042DDB1 | 48 8B 48 08 | mov     rcx, [rax+8]
0x0042DDB5 | 48 8B 45 E8 | mov     rax, [rbp+s1]
0x0042DDB9 | 48 89 CE | mov     rsi, rcx; s2
0x0042DDBC | 48 89 C7 | mov     rdi, rax; s1
0x0042DDBF | E8 DC 89 FD FF | call    _strncmp
0x0042DDC4 | 85 C0 | test    eax, eax
0x0042DDC6 | 75 06 | jnz     short loc_42DDCE
0x0042DDC8 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0042DDCC | EB 17 | jmp     short locret_42DDE5
0x0042DDCE | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0042DDD2 | 48 8B 00 | mov     rax, [rax]
0x0042DDD5 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0042DDD9 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0042DDDE | 75 BA | jnz     short loc_42DD9A
0x0042DDE0 | B8 00 00 00 00 | mov     eax, 0
0x0042DDE5 | C9 | leave
0x0042DDE6 | C3 | retn

 Ourput decompiled code:
if ENABLE_FEATURE_HTTPD_PROXY
static Htaccess_Proxy *find_proxy_entry(const char *url)
{
	Htaccess_Proxy *p;
	for (p = proxy; p; p = p->next) {
		if (strncmp(url, p->url_from, strlen(p->url_from)) == 0)
			return p;
	}
	return NULL;
}

## Example:

 Input assembly code:
0x0045B51E | 55 | push    rbp
0x0045B51F | 48 89 E5 | mov     rbp, rsp
0x0045B522 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0045B526 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0045B52B | 48 8B 40 08 | mov     rax, [rax+8]
0x0045B52F | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0045B533 | EB 4F | jmp     short loc_45B584
0x0045B535 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B539 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x0045B53D | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0045B541 | 48 8B 00 | mov     rax, [rax]
0x0045B544 | 48 39 C2 | cmp     rdx, rax
0x0045B547 | 75 30 | jnz     short loc_45B579
0x0045B549 | 8B 05 01 1F 30 00 | mov     eax, cs:dword_75D450
0x0045B54F | 83 E0 01 | and     eax, 1
0x0045B552 | 85 C0 | test    eax, eax
0x0045B554 | 74 07 | jz      short loc_45B55D
0x0045B556 | B8 01 00 00 00 | mov     eax, 1
0x0045B55B | EB 33 | jmp     short loc_45B590
0x0045B55D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B561 | 48 8B 50 08 | mov     rdx, [rax+8]
0x0045B565 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0045B569 | 48 8B 40 08 | mov     rax, [rax+8]
0x0045B56D | 48 39 C2 | cmp     rdx, rax
0x0045B570 | 75 07 | jnz     short loc_45B579
0x0045B572 | B8 01 00 00 00 | mov     eax, 1
0x0045B577 | EB 17 | jmp     short loc_45B590
0x0045B579 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B57D | 48 8B 00 | mov     rax, [rax]
0x0045B580 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0045B584 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0045B589 | 75 AA | jnz     short loc_45B535
0x0045B58B | B8 00 00 00 00 | mov     eax, 0
0x0045B590 | 5D | pop     rbp
0x0045B591 | C3 | retn

 Ourput decompiled code:
static smallint search_dev_inode(const struct stat *st)
{
	inode_list *ilist = G.inode_list_head;

	while (ilist) {
		if (ilist->dev == st->st_dev) {
			if (option_mask32 & OPT_MOUNT)
				return 1;
			if (ilist->inode == st->st_ino)
				return 1;
		}
		ilist = ilist->next;
	}
	return 0;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004F5915 | 55 | push    rbp
0x004F5916 | 48 89 E5 | mov     rbp, rsp
0x004F5919 | 48 83 EC 10 | sub     rsp, 10h
0x004F591D | BE F8 39 53 00 | mov     esi, offset aReloadingEtcIn; "reloading /etc/inittab"
0x004F5922 | BF 01 00 00 00 | mov     edi, 1
0x004F5927 | B8 00 00 00 00 | mov     eax, 0
0x004F592C | E8 91 F2 FF FF | call    sub_4F4BC2
0x004F5931 | 48 8B 05 78 59 26 00 | mov     rax, cs:qword_75B2B0
0x004F5938 | 48 89 45 F8 | mov     [rbp+ptr], rax
0x004F593C | EB 13 | jmp     short loc_4F5951
0x004F593E | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004F5942 | C6 40 0C 00 | mov     byte ptr [rax+0Ch], 0
0x004F5946 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004F594A | 48 8B 00 | mov     rax, [rax]
0x004F594D | 48 89 45 F8 | mov     [rbp+ptr], rax
0x004F5951 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0
0x004F5956 | 75 E6 | jnz     short loc_4F593E
0x004F5958 | E8 A6 FB FF FF | call    sub_4F5503
0x004F595D | 48 C7 45 F0 B0 B2 75 00 | mov     [rbp+var_10], offset qword_75B2B0
0x004F5965 | EB 36 | jmp     short loc_4F599D
0x004F5967 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004F596B | 0F B6 40 0C | movzx   eax, byte ptr [rax+0Ch]
0x004F596F | 0F B6 C0 | movzx   eax, al
0x004F5972 | 83 E0 FE | and     eax, 0FFFFFFFEh
0x004F5975 | 85 C0 | test    eax, eax
0x004F5977 | 75 1C | jnz     short loc_4F5995
0x004F5979 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004F597D | 48 8B 10 | mov     rdx, [rax]
0x004F5980 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004F5984 | 48 89 10 | mov     [rax], rdx
0x004F5987 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004F598B | 48 89 C7 | mov     rdi, rax; ptr
0x004F598E | E8 CD 0C F1 FF | call    _free
0x004F5993 | EB 08 | jmp     short loc_4F599D
0x004F5995 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004F5999 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x004F599D | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004F59A1 | 48 8B 00 | mov     rax, [rax]
0x004F59A4 | 48 89 45 F8 | mov     [rbp+ptr], rax
0x004F59A8 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0
0x004F59AD | 75 B8 | jnz     short loc_4F5967
0x004F59AF | 90 | nop
0x004F59B0 | C9 | leave
0x004F59B1 | C3 | retn
 ************ 
Source Code:
if ENABLE_FEATURE_USE_INITTAB
static void reload_inittab(void)
{
	struct init_action *a, **nextp;

	message(L_LOG, "reloading /etc/inittab");

	/* Disable old entries */
	for (a = init_action_list; a; a = a->next)
		a->action_type = 0;

	/* Append new entries, or modify existing entries
	 * (incl. setting a->action_type) if cmd and device name
	 * match new ones. End result: only entries with
	 * a->action_type == 0 are stale.
	 */
	parse_inittab();

#if ENABLE_FEATURE_KILL_REMOVED
	/* Kill stale entries */
	/* Be nice and send SIGTERM first */
	for (a = init_action_list; a; a = a->next)
		if (a->action_type == 0 && a->pid != 0)
			kill(a->pid, SIGTERM);
	if (CONFIG_FEATURE_KILL_DELAY) {
		/* NB: parent will wait in NOMMU case */
		if ((BB_MMU ? fork() : vfork()) == 0) { /* child */
			sleep(CONFIG_FEATURE_KILL_DELAY);
			for (a = init_action_list; a; a = a->next)
				if (a->action_type == 0 && a->pid != 0)
					kill(a->pid, SIGKILL);
			_exit(EXIT_SUCCESS);
		}
	}
#endif

	/* Remove stale entries and SYSINIT entries.
	 * We never rerun SYSINIT entries anyway,
	 * removing them too saves a few bytes */
	nextp = &init_action_list;
	while ((a = *nextp) != NULL) {
		if ((a->action_type & ~SYSINIT) == 0) {
			*nextp = a->next;
			free(a);
		} else {
			nextp = &a->next;
		}
	}

	/* Not needed: */
	/* run_actions(RESPAWN | ASKFIRST); */
	/* - we return to main loop, which does this automagically */
}
 ************ 
Parsed Output:
static void reload_etc_inittab() {
    int result = sub_4F4BC2(1, "reloading /etc/inittab");
    if (result == 0) {
        qword_75B2B0 = NULL;
        sub_4F5503();
        qword_75B2B0 = &qword_75B2B0;
    }
    free(qword_75B2B0);
}
 ************ 
Similarity Score (Unixcoder): 0.5199917554855347
Func rank: 80

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: size_from_HISTFILESIZE
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0050A825 | 55 | push    rbp
0x0050A826 | 48 89 E5 | mov     rbp, rsp
0x0050A829 | 48 83 EC 20 | sub     rsp, 20h
0x0050A82D | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0050A831 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x0050A838 | 48 81 7D E8 D5 4D 53 00 | cmp     [rbp+var_18], offset aStandardInput; "standard input"
0x0050A840 | 74 2E | jz      short loc_50A870
0x0050A842 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0050A846 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0050A849 | 3C 2D | cmp     al, 2Dh ; '-'
0x0050A84B | 75 0F | jnz     short loc_50A85C
0x0050A84D | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0050A851 | 48 83 C0 01 | add     rax, 1
0x0050A855 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0050A858 | 84 C0 | test    al, al
0x0050A85A | 74 14 | jz      short loc_50A870
0x0050A85C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0050A860 | BE 00 00 00 00 | mov     esi, 0
0x0050A865 | 48 89 C7 | mov     rdi, rax
0x0050A868 | E8 BD FA EF FF | call    sub_40A32A
0x0050A86D | 89 45 FC | mov     [rbp+var_4], eax
0x0050A870 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0050A873 | C9 | leave
0x0050A874 | C3 | retn

 Ourput decompiled code:
int FAST_FUNC open_or_warn_stdin(const char *filename)
{
	int fd = STDIN_FILENO;

	if (filename != bb_msg_standard_input
	 && NOT_LONE_DASH(filename)
	) {
		fd = open_or_warn(filename, O_RDONLY);
	}

	return fd;
}

## Example:

 Input assembly code:
0x004D3891 | 55 | push    rbp
0x004D3892 | 48 89 E5 | mov     rbp, rsp
0x004D3895 | 48 83 EC 20 | sub     rsp, 20h
0x004D3899 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004D389D | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D38A1 | 48 89 C6 | mov     rsi, rax
0x004D38A4 | BF 98 41 52 00 | mov     edi, offset aLine_0; "line"
0x004D38A9 | E8 B8 2D 02 00 | call    sub_4F6666
0x004D38AE | 83 C0 01 | add     eax, 1
0x004D38B1 | 89 45 FC | mov     [rbp+var_4], eax
0x004D38B4 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004D38B8 | 75 07 | jnz     short loc_4D38C1
0x004D38BA | B8 00 00 00 00 | mov     eax, 0
0x004D38BF | EB 16 | jmp     short locret_4D38D7
0x004D38C1 | 83 7D FC 05 | cmp     [rbp+var_4], 5
0x004D38C5 | 74 0D | jz      short loc_4D38D4
0x004D38C7 | 83 7D FC 06 | cmp     [rbp+var_4], 6
0x004D38CB | 74 07 | jz      short loc_4D38D4
0x004D38CD | 81 4D FC 80 00 00 00 | or      [rbp+var_4], 80h
0x004D38D4 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004D38D7 | C9 | leave
0x004D38D8 | C3 | retn

 Ourput decompiled code:
static int find_param(const char *name)
{
	static const char params[] ALIGN1 =
		"line\0"    /* 1 */
		"rows\0"    /* 2 */
		"cols\0"    /* 3 */
		"columns\0" /* 4 */
		"size\0"    /* 5 */
		"speed\0"   /* 6 */
		"ispeed\0"
		"ospeed\0";
	int i = index_in_strings(params, name) + 1;
	if (i == 0)
		return 0;
	if (i != 5 && i != 6)
		i |= 0x80;
	return i;
}

## Example:

 Input assembly code:
0x004D3816 | 55 | push    rbp
0x004D3817 | 48 89 E5 | mov     rbp, rsp
0x004D381A | 48 83 EC 20 | sub     rsp, 20h
0x004D381E | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004D3822 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D3826 | 48 89 C6 | mov     rsi, rax
0x004D3829 | BF 60 3A 52 00 | mov     edi, offset aEvenp; "evenp"
0x004D382E | E8 33 2E 02 00 | call    sub_4F6666
0x004D3833 | 89 45 FC | mov     [rbp+var_4], eax
0x004D3836 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004D383A | 78 11 | js      short loc_4D384D
0x004D383C | 8B 45 FC | mov     eax, [rbp+var_4]
0x004D383F | 48 98 | cdqe
0x004D3841 | 48 C1 E0 03 | shl     rax, 3
0x004D3845 | 48 05 60 3C 52 00 | add     rax, 523C60h
0x004D384B | EB 05 | jmp     short locret_4D3852
0x004D384D | B8 00 00 00 00 | mov     eax, 0
0x004D3852 | C9 | leave
0x004D3853 | C3 | retn

 Ourput decompiled code:
static const struct mode_info *find_mode(const char *name)
{
	int i = index_in_strings(mode_name, name);
	return i >= 0 ? &mode_info[i] : NULL;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004FF94D | 55 | push    rbp
0x004FF94E | 48 89 E5 | mov     rbp, rsp
0x004FF951 | 48 83 EC 20 | sub     rsp, 20h
0x004FF955 | 48 89 7D E8 | mov     [rbp+nptr], rdi
0x004FF959 | C7 45 FC FF 00 00 00 | mov     [rbp+var_4], 0FFh
0x004FF960 | 48 83 7D E8 00 | cmp     [rbp+nptr], 0
0x004FF965 | 74 2C | jz      short loc_4FF993
0x004FF967 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x004FF96B | 48 89 C7 | mov     rdi, rax; nptr
0x004FF96E | E8 4D 80 F0 FF | call    _atoi
0x004FF973 | 89 45 FC | mov     [rbp+var_4], eax
0x004FF976 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004FF97A | 7F 07 | jg      short loc_4FF983
0x004FF97C | B8 01 00 00 00 | mov     eax, 1
0x004FF981 | EB 13 | jmp     short locret_4FF996
0x004FF983 | 81 7D FC FF 00 00 00 | cmp     [rbp+var_4], 0FFh
0x004FF98A | 7E 07 | jle     short loc_4FF993
0x004FF98C | B8 FF 00 00 00 | mov     eax, 0FFh
0x004FF991 | EB 03 | jmp     short locret_4FF996
0x004FF993 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004FF996 | C9 | leave
0x004FF997 | C3 | retn
 ************ 
Source Code:
0

unsigned size_from_HISTFILESIZE(const char *hp)
{
	int size = MAX_HISTORY;
	if (hp) {
		size = atoi(hp);
		if (size <= 0)
			return 1;
		if (size > MAX_HISTORY)
			return MAX_HISTORY;
	}
	return size;
}
 ************ 
Parsed Output:
int check_input(const char *nptr)
{
    int var_4 = 0xFF;

    if (nptr != 0)
    {
        int num = atoi(nptr);
        var_4 = num;
    }

    if (var_4 <= 0)
    {
        return 1;
    }
    else if (var_4 > 0xFF)
    {
        return 0xFF;
    }
    else
    {
        return var_4;
    }
}
 ************ 
Similarity Score (Unixcoder): 0.5173600912094116
Func rank: 81

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: start_new_cmd_q
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00463D34 | 55 | push    rbp
0x00463D35 | 48 89 E5 | mov     rbp, rsp
0x00463D38 | 53 | push    rbx
0x00463D39 | 48 83 EC 18 | sub     rsp, 18h
0x00463D3D | 89 7D EC | mov     [rbp+var_14], edi
0x00463D40 | 48 8B 05 C1 96 2F 00 | mov     rax, cs:qword_75D408
0x00463D47 | 8B 50 08 | mov     edx, [rax+8]
0x00463D4A | 8B 45 EC | mov     eax, [rbp+var_14]
0x00463D4D | 39 C2 | cmp     edx, eax
0x00463D4F | 77 7C | ja      short loc_463DCD
0x00463D51 | 48 8B 05 B0 96 2F 00 | mov     rax, cs:qword_75D408
0x00463D58 | 8B 50 08 | mov     edx, [rax+8]
0x00463D5B | 48 8B 05 A6 96 2F 00 | mov     rax, cs:qword_75D408
0x00463D62 | 81 C2 00 01 00 00 | add     edx, 100h
0x00463D68 | 89 50 08 | mov     [rax+8], edx
0x00463D6B | 48 8B 05 96 96 2F 00 | mov     rax, cs:qword_75D408
0x00463D72 | 8B 40 08 | mov     eax, [rax+8]
0x00463D75 | 89 C0 | mov     eax, eax
0x00463D77 | 48 8D 14 85 00 00 00 00 | lea     rdx, ds:0[rax*4]
0x00463D7F | 48 8B 05 82 96 2F 00 | mov     rax, cs:qword_75D408
0x00463D86 | 48 8B 40 10 | mov     rax, [rax+10h]
0x00463D8A | 48 8B 1D 77 96 2F 00 | mov     rbx, cs:qword_75D408
0x00463D91 | 48 89 D6 | mov     rsi, rdx
0x00463D94 | 48 89 C7 | mov     rdi, rax
0x00463D97 | E8 02 63 FA FF | call    sub_40A09E
0x00463D9C | 48 89 43 10 | mov     [rbx+10h], rax
0x00463DA0 | 48 8B 05 61 96 2F 00 | mov     rax, cs:qword_75D408
0x00463DA7 | 8B 40 08 | mov     eax, [rax+8]
0x00463DAA | 89 C2 | mov     edx, eax
0x00463DAC | 48 8B 05 55 96 2F 00 | mov     rax, cs:qword_75D408
0x00463DB3 | 48 8B 40 18 | mov     rax, [rax+18h]
0x00463DB7 | 48 8B 1D 4A 96 2F 00 | mov     rbx, cs:qword_75D408
0x00463DBE | 48 89 D6 | mov     rsi, rdx
0x00463DC1 | 48 89 C7 | mov     rdi, rax
0x00463DC4 | E8 D5 62 FA FF | call    sub_40A09E
0x00463DC9 | 48 89 43 18 | mov     [rbx+18h], rax
0x00463DCD | 90 | nop
0x00463DCE | 48 83 C4 18 | add     rsp, 18h
0x00463DD2 | 5B | pop     rbx
0x00463DD3 | 5D | pop     rbp
0x00463DD4 | C3 | retn

 Ourput decompiled code:
static void ensure_buffer_capacity(int bufindex)
{
	if (bufindex >= G.capacity) {
		G.capacity += 0x100;
		G.width = xrealloc(G.width, G.capacity * sizeof(G.width[0]));
		G.more = xrealloc(G.more, G.capacity * sizeof(G.more[0]));
	}
}

## Example:

 Input assembly code:
0x0041E546 | 55 | push    rbp
0x0041E547 | 48 89 E5 | mov     rbp, rsp
0x0041E54A | 53 | push    rbx
0x0041E54B | 48 83 EC 18 | sub     rsp, 18h
0x0041E54F | 89 7D EC | mov     [rbp+var_14], edi
0x0041E552 | 48 8B 05 AF EE 33 00 | mov     rax, cs:qword_75D408
0x0041E559 | 8B 50 64 | mov     edx, [rax+64h]
0x0041E55C | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x0041E560 | 7E 0C | jle     short loc_41E56E
0x0041E562 | 48 8B 05 9F EE 33 00 | mov     rax, cs:qword_75D408
0x0041E569 | 8B 40 60 | mov     eax, [rax+60h]
0x0041E56C | EB 05 | jmp     short loc_41E573
0x0041E56E | B8 01 00 00 00 | mov     eax, 1
0x0041E573 | 39 D0 | cmp     eax, edx
0x0041E575 | 74 77 | jz      short loc_41E5EE
0x0041E577 | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x0041E57B | 74 11 | jz      short loc_41E58E
0x0041E57D | 48 8B 05 84 EE 33 00 | mov     rax, cs:qword_75D408
0x0041E584 | 8B 50 64 | mov     edx, [rax+64h]
0x0041E587 | 8B 45 EC | mov     eax, [rbp+var_14]
0x0041E58A | 01 C2 | add     edx, eax
0x0041E58C | EB 05 | jmp     short loc_41E593
0x0041E58E | BA 01 00 00 00 | mov     edx, 1
0x0041E593 | 48 8B 05 6E EE 33 00 | mov     rax, cs:qword_75D408
0x0041E59A | 89 50 64 | mov     [rax+64h], edx
0x0041E59D | 48 8B 05 64 EE 33 00 | mov     rax, cs:qword_75D408
0x0041E5A4 | 48 8B 40 68 | mov     rax, [rax+68h]
0x0041E5A8 | 48 89 C7 | mov     rdi, rax; ptr
0x0041E5AB | E8 B0 80 FE FF | call    _free
0x0041E5B0 | 48 8B 05 51 EE 33 00 | mov     rax, cs:qword_75D408
0x0041E5B7 | 48 8B 50 70 | mov     rdx, [rax+70h]
0x0041E5BB | 48 8B 05 46 EE 33 00 | mov     rax, cs:qword_75D408
0x0041E5C2 | 8B 40 64 | mov     eax, [rax+64h]
0x0041E5C5 | 83 E8 01 | sub     eax, 1
0x0041E5C8 | 89 C0 | mov     eax, eax
0x0041E5CA | 48 C1 E0 03 | shl     rax, 3
0x0041E5CE | 48 01 D0 | add     rax, rdx
0x0041E5D1 | 48 8B 00 | mov     rax, [rax]
0x0041E5D4 | 48 8B 1D 2D EE 33 00 | mov     rbx, cs:qword_75D408
0x0041E5DB | 48 89 C7 | mov     rdi, rax
0x0041E5DE | E8 3C BB FE FF | call    sub_40A11F
0x0041E5E3 | 48 89 43 68 | mov     [rbx+68h], rax
0x0041E5E7 | E8 6B FA FF FF | call    sub_41E057
0x0041E5EC | EB 1A | jmp     short loc_41E608
0x0041E5EE | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x0041E5F2 | 7E 07 | jle     short loc_41E5FB
0x0041E5F4 | B8 B3 91 52 00 | mov     eax, offset aNoNextFile; "No next file"
0x0041E5F9 | EB 05 | jmp     short loc_41E600
0x0041E5FB | B8 C0 91 52 00 | mov     eax, offset aNoPreviousFile; "No previous file"
0x0041E600 | 48 89 C7 | mov     rdi, rax
0x0041E603 | E8 07 E5 FF FF | call    sub_41CB0F
0x0041E608 | 90 | nop
0x0041E609 | 48 83 C4 18 | add     rsp, 18h
0x0041E60D | 5B | pop     rbx
0x0041E60E | 5D | pop     rbp
0x0041E60F | C3 | retn

 Ourput decompiled code:
static void change_file(int direction)
{
	if (current_file != ((direction > 0) ? num_files : 1)) {
		current_file = direction ? current_file + direction : 1;
		free(filename);
		filename = xstrdup(files[current_file - 1]);
		reinitialize();
	} else {
		print_statusline(direction > 0 ? "No next file" : "No previous file");
	}
}

## Example:

 Input assembly code:
0x00463DD5 | 55 | push    rbp
0x00463DD6 | 48 89 E5 | mov     rbp, rsp
0x00463DD9 | 48 83 EC 10 | sub     rsp, 10h
0x00463DDD | 89 F8 | mov     eax, edi
0x00463DDF | 88 45 FC | mov     [rbp+var_4], al
0x00463DE2 | 48 8B 05 1F 96 2F 00 | mov     rax, cs:qword_75D408
0x00463DE9 | 8B 10 | mov     edx, [rax]
0x00463DEB | 83 C2 01 | add     edx, 1
0x00463DEE | 89 10 | mov     [rax], edx
0x00463DF0 | 48 8B 05 11 96 2F 00 | mov     rax, cs:qword_75D408
0x00463DF7 | 8B 10 | mov     edx, [rax]
0x00463DF9 | 48 8B 05 08 96 2F 00 | mov     rax, cs:qword_75D408
0x00463E00 | 8B 40 04 | mov     eax, [rax+4]
0x00463E03 | 39 C2 | cmp     edx, eax
0x00463E05 | 77 28 | ja      short loc_463E2F
0x00463E07 | 48 8B 05 FA 95 2F 00 | mov     rax, cs:qword_75D408
0x00463E0E | 8B 10 | mov     edx, [rax]
0x00463E10 | 48 8B 05 F1 95 2F 00 | mov     rax, cs:qword_75D408
0x00463E17 | 8B 40 04 | mov     eax, [rax+4]
0x00463E1A | 39 C2 | cmp     edx, eax
0x00463E1C | 75 04 | jnz     short loc_463E22
0x00463E1E | C6 45 FC 2B | mov     [rbp+var_4], 2Bh ; '+'
0x00463E22 | 0F BE 45 FC | movsx   eax, [rbp+var_4]
0x00463E26 | 89 C7 | mov     edi, eax; c
0x00463E28 | E8 C3 33 FA FF | call    _putchar_unlocked
0x00463E2D | EB 01 | jmp     short locret_463E30
0x00463E2F | 90 | nop
0x00463E30 | C9 | leave
0x00463E31 | C3 | retn

 Ourput decompiled code:
static void out_char(char c)
{
	G.cur_x++;
	if (G.cur_x > G.output_width)
		return;
	if (G.cur_x == G.output_width)
		c = '+';
	putchar(c);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004EEE0F | 55 | push    rbp
0x004EEE10 | 48 89 E5 | mov     rbp, rsp
0x004EEE13 | 53 | push    rbx
0x004EEE14 | 48 83 EC 18 | sub     rsp, 18h
0x004EEE18 | 89 F8 | mov     eax, edi
0x004EEE1A | 88 45 EC | mov     [rbp+var_14], al
0x004EEE1D | 48 8B 05 E4 E5 26 00 | mov     rax, cs:qword_75D408
0x004EEE24 | 8B 40 2C | mov     eax, [rax+2Ch]
0x004EEE27 | 85 C0 | test    eax, eax
0x004EEE29 | 7E 3B | jle     short loc_4EEE66
0x004EEE2B | 0F BE 55 EC | movsx   edx, [rbp+var_14]
0x004EEE2F | 48 8B 05 D2 E5 26 00 | mov     rax, cs:qword_75D408
0x004EEE36 | 8B 40 2C | mov     eax, [rax+2Ch]
0x004EEE39 | 48 8B 0D C8 E5 26 00 | mov     rcx, cs:qword_75D408
0x004EEE40 | 48 8D B9 B8 04 00 00 | lea     rdi, [rcx+4B8h]; s
0x004EEE47 | 48 8B 1D BA E5 26 00 | mov     rbx, cs:qword_75D408
0x004EEE4E | 89 D1 | mov     ecx, edx
0x004EEE50 | 89 C2 | mov     edx, eax
0x004EEE52 | BE 7C 76 52 00 | mov     esi, offset aDC; "%d%c"
0x004EEE57 | B8 00 00 00 00 | mov     eax, 0
0x004EEE5C | E8 1F 8C F1 FF | call    _sprintf
0x004EEE61 | 89 43 78 | mov     [rbx+78h], eax
0x004EEE64 | EB 1F | jmp     short loc_4EEE85
0x004EEE66 | 48 8B 05 9B E5 26 00 | mov     rax, cs:qword_75D408
0x004EEE6D | 0F B6 55 EC | movzx   edx, [rbp+var_14]
0x004EEE71 | 88 90 B8 04 00 00 | mov     [rax+4B8h], dl
0x004EEE77 | 48 8B 05 8A E5 26 00 | mov     rax, cs:qword_75D408
0x004EEE7E | C7 40 78 01 00 00 00 | mov     dword ptr [rax+78h], 1
0x004EEE85 | 48 8B 05 7C E5 26 00 | mov     rax, cs:qword_75D408
0x004EEE8C | C6 40 76 01 | mov     byte ptr [rax+76h], 1
0x004EEE90 | 90 | nop
0x004EEE91 | 48 83 C4 18 | add     rsp, 18h
0x004EEE95 | 5B | pop     rbx
0x004EEE96 | 5D | pop     rbp
0x004EEE97 | C3 | retn
 ************ 
Source Code:
if ENABLE_FEATURE_VI_DOT_CMD
static void start_new_cmd_q(char c)
{
	// get buffer for new cmd
	// if there is a current cmd count put it in the buffer first
	if (cmdcnt > 0) {
		lmc_len = sprintf(last_modifying_cmd, "%d%c", cmdcnt, c);
	} else { // just save char c onto queue
		last_modifying_cmd[0] = c;
		lmc_len = 1;
	}
	adding2q = 1;
}
 ************ 
Parsed Output:
static void process_data(char c)
{
	if (G.num_entries > 0) {
		int index = (int)c;
		if (index >= 0 && index < G.num_entries) {
			char* s = G.entries[index].s;
			sprintf(G.output_buffer, "%d%c", G.entries[index].n, *s);
			G.output_length = strlen(G.output_buffer);
		}
	} else {
		G.entries[0].s = &c;
		G.entries[0].n = 1;
		G.output_buffer[0] = c;
		G.output_length = 1;
	}
	G.entries[G.num_entries].s = G.output_buffer;
	G.entries[G.num_entries].n = G.output_length;
	G.num_entries++;
	G.has_output = 1;
}
 ************ 
Similarity Score (Unixcoder): 0.5067240595817566
Func rank: 82

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: chksum_and_xwrite
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0042948E | 55 | push    rbp
0x0042948F | 48 89 E5 | mov     rbp, rsp
0x00429492 | 48 83 EC 20 | sub     rsp, 20h
0x00429496 | 89 7D EC | mov     [rbp+var_14], edi
0x00429499 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x0042949D | 48 8B 4D E0 | mov     rcx, [rbp+var_20]
0x004294A1 | 48 8D 45 EC | lea     rax, [rbp+var_14]
0x004294A5 | BA 0D FF 00 00 | mov     edx, 0FF0Dh
0x004294AA | 48 89 CE | mov     rsi, rcx
0x004294AD | 48 89 C7 | mov     rdi, rax
0x004294B0 | E8 47 FE FF FF | call    sub_4292FC
0x004294B5 | 48 89 45 F8 | mov     [rbp+ptr], rax
0x004294B9 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004294BD | BA 00 00 00 00 | mov     edx, 0
0x004294C2 | BE 0A 00 00 00 | mov     esi, 0Ah
0x004294C7 | 48 89 C7 | mov     rdi, rax
0x004294CA | E8 39 FF FF FF | call    sub_429408
0x004294CF | 89 45 F4 | mov     [rbp+var_C], eax
0x004294D2 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x004294D5 | 8D 50 01 | lea     edx, [rax+1]
0x004294D8 | 89 55 F4 | mov     [rbp+var_C], edx
0x004294DB | 48 63 D0 | movsxd  rdx, eax
0x004294DE | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004294E2 | 48 01 D0 | add     rax, rdx
0x004294E5 | C6 00 0A | mov     byte ptr [rax], 0Ah
0x004294E8 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x004294EB | 48 63 D0 | movsxd  rdx, eax
0x004294EE | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004294F2 | 48 89 C6 | mov     rsi, rax
0x004294F5 | BF 01 00 00 00 | mov     edi, 1
0x004294FA | E8 AC 0F FE FF | call    sub_40A4AB
0x004294FF | B8 F8 B3 75 00 | mov     eax, offset dest
0x00429504 | 8B 40 10 | mov     eax, [rax+10h]
0x00429507 | 83 F8 01 | cmp     eax, 1
0x0042950A | 76 0C | jbe     short loc_429518
0x0042950C | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00429510 | 48 89 C7 | mov     rdi, rax
0x00429513 | E8 3C FF FF FF | call    sub_429454
0x00429518 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x0042951C | 48 89 C7 | mov     rdi, rax; ptr
0x0042951F | E8 3C D1 FD FF | call    _free
0x00429524 | 90 | nop
0x00429525 | C9 | leave
0x00429526 | C3 | retn

 Ourput decompiled code:
static void
cmdio_write(uint32_t status_str, const char *str)
{
	char *response;
	int len;

	/* FTP uses telnet protocol for command link.
	 * In telnet, 0xff is an escape char, and needs to be escaped: */
	response = escape_text((char *) &status_str, str, (0xff << 8) + '\r');

	/* FTP sends embedded LFs as NULs */
	len = replace_char(response, '\n', '\0');

	response[len++] = '\n'; /* tack on trailing '\n' */
	xwrite(STDOUT_FILENO, response, len);
	if (G.verbose > 1)
		verbose_log(response);
	free(response);
}

## Example:

 Input assembly code:
0x0042408D | 55 | push    rbp
0x0042408E | 48 89 E5 | mov     rbp, rsp
0x00424091 | 48 83 EC 40 | sub     rsp, 40h
0x00424095 | 89 7D CC | mov     [rbp+var_34], edi
0x00424098 | 48 89 75 C0 | mov     [rbp+var_40], rsi
0x0042409C | 48 C7 45 F8 FE 56 53 00 | mov     [rbp+var_8], offset aDevCdrom_0; "/dev/cdrom"
0x004240A4 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004240A8 | 48 83 C0 08 | add     rax, 8
0x004240AC | 48 8B 00 | mov     rax, [rax]
0x004240AF | 48 85 C0 | test    rax, rax
0x004240B2 | 74 21 | jz      short loc_4240D5
0x004240B4 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004240B8 | 48 8B 40 08 | mov     rax, [rax+8]
0x004240BC | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004240C0 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004240C4 | 48 83 C0 10 | add     rax, 10h
0x004240C8 | 48 8B 00 | mov     rax, [rax]
0x004240CB | 48 85 C0 | test    rax, rax
0x004240CE | 74 05 | jz      short loc_4240D5
0x004240D0 | E8 8F 3E FE FF | call    sub_407F64
0x004240D5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004240D9 | BE 00 00 00 00 | mov     esi, 0
0x004240DE | 48 89 C7 | mov     rdi, rax
0x004240E1 | E8 AF 61 FE FF | call    sub_40A295
0x004240E6 | 89 45 F4 | mov     [rbp+var_C], eax
0x004240E9 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x004240EC | BA 00 00 00 00 | mov     edx, 0
0x004240F1 | BE 28 80 00 00 | mov     esi, 8028h
0x004240F6 | 89 C7 | mov     edi, eax
0x004240F8 | E8 5A 64 FE FF | call    sub_40A557
0x004240FD | 48 8D 4D D0 | lea     rcx, [rbp+var_30]
0x00424101 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00424104 | BA 20 00 00 00 | mov     edx, 20h ; ' '
0x00424109 | 48 89 CE | mov     rsi, rcx
0x0042410C | 89 C7 | mov     edi, eax
0x0042410E | E8 3F 33 0E 00 | call    sub_507452
0x00424113 | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00424117 | 48 89 C6 | mov     rsi, rax
0x0042411A | BF 09 57 53 00 | mov     edi, offset a3232s; "%32.32s\n"
0x0042411F | B8 00 00 00 00 | mov     eax, 0
0x00424124 | E8 A7 2A FE FF | call    _printf
0x00424129 | B8 00 00 00 00 | mov     eax, 0
0x0042412E | C9 | leave
0x0042412F | C3 | retn

 Ourput decompiled code:
int volname_main(int argc UNUSED_PARAM, char **argv)
{
	int fd;
	char buffer[32];
	const char *device;

	device = "/dev/cdrom";
	if (argv[1]) {
		device = argv[1];
		if (argv[2])
			bb_show_usage();
	}

	fd = xopen(device, O_RDONLY);
	xlseek(fd, 32808, SEEK_SET);
	xread(fd, buffer, 32);
	printf("%32.32s\n", buffer);
	if (ENABLE_FEATURE_CLEAN_UP) {
		close(fd);
	}
	return 0;
}

## Example:

 Input assembly code:
0x004D3284 | 55 | push    rbp
0x004D3285 | 48 89 E5 | mov     rbp, rsp
0x004D3288 | 48 83 EC 30 | sub     rsp, 30h
0x004D328C | 89 7D DC | mov     [rbp+var_24], edi
0x004D328F | 48 89 75 D0 | mov     [rbp+var_30], rsi
0x004D3293 | 48 C7 45 E0 00 00 00 00 | mov     [rbp+var_20], 0
0x004D329B | 48 C7 45 F0 8F 31 4D 00 | mov     [rbp+var_10], offset sub_4D318F
0x004D32A3 | 48 C7 05 92 A1 28 00 2B 37 52 00 | mov     cs:qword_75D440, offset a1_26; "-1"
0x004D32AE | 48 8D 55 E0 | lea     rdx, [rbp+var_20]
0x004D32B2 | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004D32B6 | BE 2E 37 52 00 | mov     esi, offset aFtlc; "ftLc:"
0x004D32BB | 48 89 C7 | mov     rdi, rax
0x004D32BE | B8 00 00 00 00 | mov     eax, 0
0x004D32C3 | E8 27 6F 02 00 | call    sub_4FA1EF
0x004D32C8 | 89 45 EC | mov     [rbp+var_14], eax
0x004D32CB | 8B 45 EC | mov     eax, [rbp+var_14]
0x004D32CE | 83 E0 01 | and     eax, 1
0x004D32D1 | 85 C0 | test    eax, eax
0x004D32D3 | 74 08 | jz      short loc_4D32DD
0x004D32D5 | 48 C7 45 F0 E9 30 4D 00 | mov     [rbp+var_10], offset sub_4D30E9
0x004D32DD | C7 45 F8 01 00 00 00 | mov     [rbp+var_8], 1
0x004D32E4 | 8B 05 8E 7B 28 00 | mov     eax, cs:optind
0x004D32EA | 48 98 | cdqe
0x004D32EC | 48 C1 E0 03 | shl     rax, 3
0x004D32F0 | 48 01 45 D0 | add     [rbp+var_30], rax
0x004D32F4 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004D32FB | EB 31 | jmp     short loc_4D332E
0x004D32FD | 48 8B 4D E0 | mov     rcx, [rbp+var_20]
0x004D3301 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004D3304 | 48 98 | cdqe
0x004D3306 | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]
0x004D330E | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004D3312 | 48 01 D0 | add     rax, rdx
0x004D3315 | 48 8B 10 | mov     rdx, [rax]
0x004D3318 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004D331C | 48 89 CE | mov     rsi, rcx
0x004D331F | 48 89 D7 | mov     rdi, rdx
0x004D3322 | FF D0 | call    rax
0x004D3324 | 0F B6 C0 | movzx   eax, al
0x004D3327 | 21 45 F8 | and     [rbp+var_8], eax
0x004D332A | 83 45 FC 01 | add     [rbp+var_4], 1
0x004D332E | 8B 45 FC | mov     eax, [rbp+var_4]
0x004D3331 | 48 98 | cdqe
0x004D3333 | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]
0x004D333B | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004D333F | 48 01 D0 | add     rax, rdx
0x004D3342 | 48 8B 00 | mov     rax, [rax]
0x004D3345 | 48 85 C0 | test    rax, rax
0x004D3348 | 75 B3 | jnz     short loc_4D32FD
0x004D334A | 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004D334E | 0F 94 C0 | setz    al
0x004D3351 | 0F B6 C0 | movzx   eax, al
0x004D3354 | C9 | leave
0x004D3355 | C3 | retn

 Ourput decompiled code:
int stat_main(int argc UNUSED_PARAM, char **argv)
{
	IF_FEATURE_STAT_FORMAT(char *format = NULL;)
	int i;
	int ok;
	unsigned opts;
	statfunc_ptr statfunc = do_stat;

	opt_complementary = "-1"; /* min one arg */
	opts = getopt32(argv, "ftL"
		IF_SELINUX("Z")
		IF_FEATURE_STAT_FORMAT("c:", &format)
	);
	if (opts & OPT_FILESYS) /* -f */
		statfunc = do_statfs;
#if ENABLE_SELINUX
	if (opts & OPT_SELINUX) {
		selinux_or_die();
	}
#endif
	ok = 1;
	argv += optind;
	for (i = 0; argv[i]; ++i)
		ok &= statfunc(argv[i] IF_FEATURE_STAT_FORMAT(, format));

	return (ok ? EXIT_SUCCESS : EXIT_FAILURE);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004B46FF | 55 | push    rbp
0x004B4700 | 48 89 E5 | mov     rbp, rsp
0x004B4703 | 48 83 EC 20 | sub     rsp, 20h
0x004B4707 | 89 7D EC | mov     [rbp+var_14], edi
0x004B470A | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004B470E | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004B4712 | 48 05 01 01 00 00 | add     rax, 101h
0x004B4718 | 48 B9 75 73 74 61 72 20 20 00 | mov     rcx, 20207261747375h
0x004B4722 | 48 89 08 | mov     [rax], rcx
0x004B4725 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004B4729 | 48 05 94 00 00 00 | add     rax, 94h
0x004B472F | BA 08 00 00 00 | mov     edx, 8; n
0x004B4734 | BE 20 00 00 00 | mov     esi, 20h ; ' '; c
0x004B4739 | 48 89 C7 | mov     rdi, rax; s
0x004B473C | E8 0F 26 F5 FF | call    _memset
0x004B4741 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004B4745 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004B4749 | C7 45 F4 00 00 00 00 | mov     [rbp+var_C], 0
0x004B4750 | C7 45 F0 00 02 00 00 | mov     [rbp+var_10], 200h
0x004B4757 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004B475B | 48 8D 50 01 | lea     rdx, [rax+1]
0x004B475F | 48 89 55 F8 | mov     [rbp+var_8], rdx
0x004B4763 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004B4766 | 0F B6 C0 | movzx   eax, al
0x004B4769 | 01 45 F4 | add     [rbp+var_C], eax
0x004B476C | 83 6D F0 01 | sub     [rbp+var_10], 1
0x004B4770 | 83 7D F0 00 | cmp     [rbp+var_10], 0
0x004B4774 | 75 E1 | jnz     short loc_4B4757
0x004B4776 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x004B4779 | 48 98 | cdqe
0x004B477B | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x004B477F | 48 8D 8A 94 00 00 00 | lea     rcx, [rdx+94h]
0x004B4786 | 48 89 C2 | mov     rdx, rax
0x004B4789 | BE 07 00 00 00 | mov     esi, 7
0x004B478E | 48 89 CF | mov     rdi, rcx
0x004B4791 | E8 F6 FE FF FF | call    sub_4B468C
0x004B4796 | 48 8B 4D E0 | mov     rcx, [rbp+var_20]
0x004B479A | 8B 45 EC | mov     eax, [rbp+var_14]
0x004B479D | BA 00 02 00 00 | mov     edx, 200h
0x004B47A2 | 48 89 CE | mov     rsi, rcx
0x004B47A5 | 89 C7 | mov     edi, eax
0x004B47A7 | E8 FF 5C F5 FF | call    sub_40A4AB
0x004B47AC | 90 | nop
0x004B47AD | C9 | leave
0x004B47AE | C3 | retn
 ************ 
Source Code:
static void chksum_and_xwrite(int fd, struct tar_header_t* hp)
{
	/* POSIX says that checksum is done on unsigned bytes
	 * (Sun and HP-UX gets it wrong... more details in
	 * GNU tar source) */
	const unsigned char *cp;
	int chksum, size;

	strcpy(hp->magic, "ustar  ");

	/* Calculate and store the checksum (i.e., the sum of all of the bytes of
	 * the header).  The checksum field must be filled with blanks for the
	 * calculation.  The checksum field is formatted differently from the
	 * other fields: it has 6 digits, a null, then a space -- rather than
	 * digits, followed by a null like the other fields... */
	memset(hp->chksum, ' ', sizeof(hp->chksum));
	cp = (const unsigned char *) hp;
	chksum = 0;
	size = sizeof(*hp);
	do { chksum += *cp++; } while (--size);
	putOctal(hp->chksum, sizeof(hp->chksum)-1, chksum);

	/* Now write the header out to disk */
	xwrite(fd, hp, sizeof(*hp));
}
 ************ 
Parsed Output:
static void func(uint32_t arg1, uint64_t arg2) {
    char *ptr = (char *)arg2;
    uint64_t *ptr2 = (uint64_t *)(ptr + 0x101);
    *ptr2 = 0x20207261747375;
    memset(ptr + 0x94, ' ', 8);
    uint64_t *ptr3 = (uint64_t *)(ptr + 0x1);
    uint32_t sum = 0;
    for (int i = 0; i < 0x200; i++) {
        sum += *ptr3;
        ptr3++;
    }
    uint32_t arg3 = arg1;
    uint64_t arg4 = arg2;
    sub_4B468C(ptr + 0x94, sum, arg3, arg4);
}
 ************ 
Similarity Score (Unixcoder): 0.5065139532089233
Func rank: 83

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: archivejoin
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004562E0 | 55 | push    rbp
0x004562E1 | 48 89 E5 | mov     rbp, rsp
0x004562E4 | 48 81 EC 90 02 00 00 | sub     rsp, 290h
0x004562EB | 48 89 BD 78 FD FF FF | mov     [rbp+var_288], rdi
0x004562F2 | 48 8B 8D 78 FD FF FF | mov     rcx, [rbp+var_288]
0x004562F9 | 48 8D 85 80 FD FF FF | lea     rax, [rbp+var_280]
0x00456300 | BA 05 00 00 00 | mov     edx, 5
0x00456305 | 48 89 CE | mov     rsi, rcx
0x00456308 | 48 89 C7 | mov     rdi, rax
0x0045630B | E8 41 FA FF FF | call    sub_455D51
0x00456310 | 48 8D 85 80 FD FF FF | lea     rax, [rbp+var_280]
0x00456317 | 48 89 C7 | mov     rdi, rax
0x0045631A | E8 CD FA FF FF | call    sub_455DEC
0x0045631F | 48 8D 85 80 FD FF FF | lea     rax, [rbp+var_280]
0x00456326 | BE 00 00 00 00 | mov     esi, 0
0x0045632B | 48 89 C7 | mov     rdi, rax
0x0045632E | E8 E2 F9 FF FF | call    sub_455D15
0x00456333 | 90 | nop
0x00456334 | C9 | leave
0x00456335 | C3 | retn

 Ourput decompiled code:
static NOINLINE void send_inform(struct dhcp_packet *oldpacket)
{
	struct dhcp_packet packet;

	/* "If a client has obtained a network address through some other means
	 * (e.g., manual configuration), it may use a DHCPINFORM request message
	 * to obtain other local configuration parameters.  Servers receiving a
	 * DHCPINFORM message construct a DHCPACK message with any local
	 * configuration parameters appropriate for the client without:
	 * allocating a new address, checking for an existing binding, filling
	 * in 'yiaddr' or including lease time parameters.  The servers SHOULD
	 * unicast the DHCPACK reply to the address given in the 'ciaddr' field
	 * of the DHCPINFORM message.
	 * ...
	 * The server responds to a DHCPINFORM message by sending a DHCPACK
	 * message directly to the address given in the 'ciaddr' field
	 * of the DHCPINFORM message.  The server MUST NOT send a lease
	 * expiration time to the client and SHOULD NOT fill in 'yiaddr'."
	 */
//TODO: do a few sanity checks: is ciaddr set?
//Better yet: is ciaddr == IP source addr?
	init_packet(&packet, oldpacket, DHCPACK);
	add_server_options(&packet);

	send_packet(&packet, /*force_bcast:*/ 0);
}

## Example:

 Input assembly code:
0x004F018A | 55 | push    rbp
0x004F018B | 48 89 E5 | mov     rbp, rsp
0x004F018E | 48 81 EC 90 00 00 00 | sub     rsp, 90h
0x004F0195 | 48 89 BD 78 FF FF FF | mov     [rbp+var_88], rdi
0x004F019C | 48 8B 95 78 FF FF FF | mov     rdx, [rbp+var_88]
0x004F01A3 | 48 8D 45 80 | lea     rax, [rbp+var_80]
0x004F01A7 | 48 89 D6 | mov     rsi, rdx
0x004F01AA | 48 89 C7 | mov     rdi, rax
0x004F01AD | E8 B7 FE FF FF | call    sub_4F0069
0x004F01B2 | 48 8D 45 80 | lea     rax, [rbp+var_80]
0x004F01B6 | 48 89 C6 | mov     rsi, rax
0x004F01B9 | BF 60 77 52 00 | mov     edi, offset aSIsNotImplemen; "'%s' is not implemented"
0x004F01BE | B8 00 00 00 00 | mov     eax, 0
0x004F01C3 | E8 CF FC FF FF | call    sub_4EFE97
0x004F01C8 | 90 | nop
0x004F01C9 | C9 | leave
0x004F01CA | C3 | retn

 Ourput decompiled code:
static void not_implemented(const char *s)
{
	char buf[MAX_INPUT_LEN];

	print_literal(buf, s);
	status_line_bold("\'%s\' is not implemented", buf);
}

## Example:

 Input assembly code:
0x00485FD8 | 55 | push    rbp
0x00485FD9 | 48 89 E5 | mov     rbp, rsp
0x00485FDC | 48 83 EC 40 | sub     rsp, 40h
0x00485FE0 | 48 89 7D C8 | mov     [rbp+var_38], rdi
0x00485FE4 | 48 8B 55 C8 | mov     rdx, [rbp+var_38]
0x00485FE8 | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00485FEC | 48 89 D6 | mov     rsi, rdx
0x00485FEF | 48 89 C7 | mov     rdi, rax
0x00485FF2 | E8 22 B3 FF FF | call    sub_481319
0x00485FF7 | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00485FFB | BE 00 00 00 00 | mov     esi, 0
0x00486000 | 48 89 C7 | mov     rdi, rax
0x00486003 | E8 FD FE FF FF | call    sub_485F05
0x00486008 | 90 | nop
0x00486009 | C9 | leave
0x0048600A | C3 | retn

 Ourput decompiled code:
static void parse_and_run_string(const char *s)
{
	struct in_str input;
	setup_string_in_str(&input, s);
	parse_and_run_stream(&input, '\0');
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00464F04 | 55 | push    rbp
0x00464F05 | 48 89 E5 | mov     rbp, rsp
0x00464F08 | 48 83 EC 40 | sub     rsp, 40h
0x00464F0C | 48 89 7D C8 | mov     [rbp+var_38], rdi
0x00464F10 | 48 89 75 C0 | mov     [rbp+var_40], rsi
0x00464F14 | 48 8B 4D C0 | mov     rcx, [rbp+var_40]
0x00464F18 | 48 8B 55 C8 | mov     rdx, [rbp+var_38]
0x00464F1C | 48 8D 45 D0 | lea     rax, [rbp+s]
0x00464F20 | BE 8D 62 53 00 | mov     esi, offset aSS_26; "%s/%s"
0x00464F25 | 48 89 C7 | mov     rdi, rax; s
0x00464F28 | B8 00 00 00 00 | mov     eax, 0
0x00464F2D | E8 4E 2B FA FF | call    _sprintf
0x00464F32 | 48 8D 45 D0 | lea     rax, [rbp+s]
0x00464F36 | 48 89 C7 | mov     rdi, rax
0x00464F39 | E8 A1 FE FF FF | call    sub_464DDF
0x00464F3E | 90 | nop
0x00464F3F | C9 | leave
0x00464F40 | C3 | retn
 ************ 
Source Code:
static void archivejoin(const char *sub, const char *name)
{
	char path[sizeof(long long)*3 + sizeof("/cmdline")];
	sprintf(path, "%s/%s", sub, name);
	archivefile(path);
}
 ************ 
Parsed Output:
static void format_string(const char *s, const char *t)
{
    char buf[64];
    sprintf(buf, "%s/%s", s, t);
    sub_464DDF(buf);
}
 ************ 
Similarity Score (Unixcoder): 0.49631571769714355
Func rank: 84

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: udhcp_str2nip
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004A872C | 55 | push    rbp
0x004A872D | 48 89 E5 | mov     rbp, rsp
0x004A8730 | 48 83 EC 20 | sub     rsp, 20h
0x004A8734 | 48 89 7D E8 | mov     [rbp+s], rdi
0x004A8738 | 48 89 75 E0 | mov     [rbp+s2], rsi
0x004A873C | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004A8740 | BE 2E 00 00 00 | mov     esi, 2Eh ; '.'; c
0x004A8745 | 48 89 C7 | mov     rdi, rax; s
0x004A8748 | E8 E3 E4 F5 FF | call    _strrchr
0x004A874D | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004A8751 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004A8756 | 74 1B | jz      short loc_4A8773
0x004A8758 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004A875C | 48 8D 50 01 | lea     rdx, [rax+1]
0x004A8760 | 48 8B 45 E0 | mov     rax, [rbp+s2]
0x004A8764 | 48 89 C6 | mov     rsi, rax; s2
0x004A8767 | 48 89 D7 | mov     rdi, rdx; s1
0x004A876A | E8 E1 E8 F5 FF | call    _strcmp
0x004A876F | 85 C0 | test    eax, eax
0x004A8771 | 74 07 | jz      short loc_4A877A
0x004A8773 | B8 00 00 00 00 | mov     eax, 0
0x004A8778 | EB 0B | jmp     short locret_4A8785
0x004A877A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004A877E | C6 00 00 | mov     byte ptr [rax], 0
0x004A8781 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004A8785 | C9 | leave
0x004A8786 | C3 | retn

 Ourput decompiled code:
FAST_FUNC make_new_name_generic(char *filename, const char *expected_ext)
{
	char *extension = strrchr(filename, '.');
	if (!extension || strcmp(extension + 1, expected_ext) != 0) {
		/* Mimic GNU gunzip - "real" bunzip2 tries to */
		/* unpack file anyway, to file.out */
		return NULL;
	}
	*extension = '\0';
	return filename;
}

## Example:

 Input assembly code:
0x00461B56 | 55 | push    rbp
0x00461B57 | 48 89 E5 | mov     rbp, rsp
0x00461B5A | 48 83 EC 20 | sub     rsp, 20h
0x00461B5E | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00461B62 | 48 89 75 E0 | mov     [rbp+s], rsi
0x00461B66 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00461B6A | 48 89 C7 | mov     rdi, rax
0x00461B6D | E8 FA 7C FA FF | call    sub_40986C
0x00461B72 | 48 89 45 F8 | mov     [rbp+stream], rax
0x00461B76 | 48 83 7D F8 00 | cmp     [rbp+stream], 0
0x00461B7B | 75 07 | jnz     short loc_461B84
0x00461B7D | B8 01 00 00 00 | mov     eax, 1
0x00461B82 | EB 24 | jmp     short locret_461BA8
0x00461B84 | 48 8B 55 F8 | mov     rdx, [rbp+stream]
0x00461B88 | 48 8B 45 E0 | mov     rax, [rbp+s]
0x00461B8C | 48 89 D6 | mov     rsi, rdx; stream
0x00461B8F | 48 89 C7 | mov     rdi, rax; s
0x00461B92 | E8 29 54 FA FF | call    _fputs_unlocked
0x00461B97 | 48 8B 45 F8 | mov     rax, [rbp+stream]
0x00461B9B | 48 89 C7 | mov     rdi, rax; stream
0x00461B9E | E8 5D 4E FA FF | call    _fclose
0x00461BA3 | B8 00 00 00 00 | mov     eax, 0
0x00461BA8 | C9 | leave
0x00461BA9 | C3 | retn

 Ourput decompiled code:
endif

static int write_str_to_file(const char *fname, const char *str)
{
	FILE *fp = fopen_for_write(fname);
	if (!fp)
		return 1;
	fputs(str, fp);
	fclose(fp);
	return 0;
}

## Example:

 Input assembly code:
0x0040A1FC | 55 | push    rbp
0x0040A1FD | 48 89 E5 | mov     rbp, rsp
0x0040A200 | 48 83 EC 20 | sub     rsp, 20h
0x0040A204 | 48 89 7D E8 | mov     [rbp+filename], rdi
0x0040A208 | 48 89 75 E0 | mov     [rbp+modes], rsi
0x0040A20C | 48 8B 55 E0 | mov     rdx, [rbp+modes]
0x0040A210 | 48 8B 45 E8 | mov     rax, [rbp+filename]
0x0040A214 | 48 89 D6 | mov     rsi, rdx; modes
0x0040A217 | 48 89 C7 | mov     rdi, rax; filename
0x0040A21A | E8 31 CF FF FF | call    _fopen64
0x0040A21F | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0040A223 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0040A228 | 75 16 | jnz     short loc_40A240
0x0040A22A | 48 8B 45 E8 | mov     rax, [rbp+filename]
0x0040A22E | 48 89 C6 | mov     rsi, rax
0x0040A231 | BF 0D 80 52 00 | mov     edi, offset aCanTOpenS; "can't open '%s'"
0x0040A236 | B8 00 00 00 00 | mov     eax, 0
0x0040A23B | E8 62 F0 FF FF | call    sub_4092A2
0x0040A240 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040A244 | C9 | leave
0x0040A245 | C3 | retn

 Ourput decompiled code:
FAST_FUNC xfopen(const char *path, const char *mode)
{
	FILE *fp = fopen(path, mode);
	if (fp == NULL)
		bb_perror_msg_and_die("can't open '%s'", path);
	return fp;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00459D25 | 55 | push    rbp
0x00459D26 | 48 89 E5 | mov     rbp, rsp
0x00459D29 | 48 83 EC 20 | sub     rsp, 20h
0x00459D2D | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00459D31 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00459D35 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00459D39 | BA 02 00 00 00 | mov     edx, 2
0x00459D3E | BE 00 00 00 00 | mov     esi, 0
0x00459D43 | 48 89 C7 | mov     rdi, rax
0x00459D46 | E8 57 1D 0B 00 | call    sub_50BAA2
0x00459D4B | 48 89 45 F8 | mov     [rbp+ptr], rax
0x00459D4F | 48 83 7D F8 00 | cmp     [rbp+ptr], 0
0x00459D54 | 75 07 | jnz     short loc_459D5D
0x00459D56 | B8 00 00 00 00 | mov     eax, 0
0x00459D5B | EB 1E | jmp     short locret_459D7B
0x00459D5D | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00459D61 | 8B 50 08 | mov     edx, [rax+8]
0x00459D64 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00459D68 | 89 10 | mov     [rax], edx
0x00459D6A | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00459D6E | 48 89 C7 | mov     rdi, rax; ptr
0x00459D71 | E8 EA C8 FA FF | call    _free
0x00459D76 | B8 01 00 00 00 | mov     eax, 1
0x00459D7B | C9 | leave
0x00459D7C | C3 | retn
 ************ 
Source Code:
int FAST_FUNC udhcp_str2nip(const char *str, void *arg)
{
	len_and_sockaddr *lsa;

	lsa = host_and_af2sockaddr(str, 0, AF_INET);
	if (!lsa)
		return 0;
	/* arg maybe unaligned */
	move_to_unaligned32((uint32_t*)arg, lsa->u.sin.sin_addr.s_addr);
	free(lsa);
	return 1;
}
 ************ 
Parsed Output:
FAST_FUNC set_value(int *ptr, int value)
{
    *ptr = value;
    free(ptr);
    return 1;
}
 ************ 
Similarity Score (Unixcoder): 0.4944765567779541
Func rank: 85

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: count_blocks
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004F73F6 | 55 | push    rbp
0x004F73F7 | 48 89 E5 | mov     rbp, rsp
0x004F73FA | 48 83 EC 20 | sub     rsp, 20h
0x004F73FE | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004F7402 | 89 75 E4 | mov     [rbp+var_1C], esi
0x004F7405 | 83 7D E4 00 | cmp     [rbp+var_1C], 0
0x004F7409 | 74 07 | jz      short loc_4F7412
0x004F740B | B8 B7 1D C1 04 | mov     eax, 4C11DB7h
0x004F7410 | EB 05 | jmp     short loc_4F7417
0x004F7412 | B8 20 83 B8 ED | mov     eax, 0EDB88320h
0x004F7417 | 89 45 F0 | mov     [rbp+var_10], eax
0x004F741A | 48 83 7D E8 00 | cmp     [rbp+var_18], 0
0x004F741F | 75 0E | jnz     short loc_4F742F
0x004F7421 | BF 00 04 00 00 | mov     edi, 400h
0x004F7426 | E8 34 2C F1 FF | call    sub_40A05F
0x004F742B | 48 89 45 E8 | mov     [rbp+var_18], rax
0x004F742F | C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0
0x004F7436 | EB 79 | jmp     short loc_4F74B1
0x004F7438 | 83 7D E4 00 | cmp     [rbp+var_1C], 0
0x004F743C | 74 08 | jz      short loc_4F7446
0x004F743E | 8B 45 F8 | mov     eax, [rbp+var_8]
0x004F7441 | C1 E0 18 | shl     eax, 18h
0x004F7444 | EB 03 | jmp     short loc_4F7449
0x004F7446 | 8B 45 F8 | mov     eax, [rbp+var_8]
0x004F7449 | 89 45 FC | mov     [rbp+var_4], eax
0x004F744C | C7 45 F4 08 00 00 00 | mov     [rbp+var_C], 8
0x004F7453 | EB 41 | jmp     short loc_4F7496
0x004F7455 | 83 7D E4 00 | cmp     [rbp+var_1C], 0
0x004F7459 | 74 1B | jz      short loc_4F7476
0x004F745B | 8B 45 FC | mov     eax, [rbp+var_4]
0x004F745E | 85 C0 | test    eax, eax
0x004F7460 | 79 0A | jns     short loc_4F746C
0x004F7462 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004F7465 | 01 C0 | add     eax, eax
0x004F7467 | 33 45 F0 | xor     eax, [rbp+var_10]
0x004F746A | EB 05 | jmp     short loc_4F7471
0x004F746C | 8B 45 FC | mov     eax, [rbp+var_4]
0x004F746F | 01 C0 | add     eax, eax
0x004F7471 | 89 45 FC | mov     [rbp+var_4], eax
0x004F7474 | EB 1C | jmp     short loc_4F7492
0x004F7476 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004F7479 | 83 E0 01 | and     eax, 1
0x004F747C | 85 C0 | test    eax, eax
0x004F747E | 74 0A | jz      short loc_4F748A
0x004F7480 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004F7483 | D1 E8 | shr     eax, 1
0x004F7485 | 33 45 F0 | xor     eax, [rbp+var_10]
0x004F7488 | EB 05 | jmp     short loc_4F748F
0x004F748A | 8B 45 FC | mov     eax, [rbp+var_4]
0x004F748D | D1 E8 | shr     eax, 1
0x004F748F | 89 45 FC | mov     [rbp+var_4], eax
0x004F7492 | 83 6D F4 01 | sub     [rbp+var_C], 1
0x004F7496 | 83 7D F4 00 | cmp     [rbp+var_C], 0
0x004F749A | 75 B9 | jnz     short loc_4F7455
0x004F749C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004F74A0 | 48 8D 50 04 | lea     rdx, [rax+4]
0x004F74A4 | 48 89 55 E8 | mov     [rbp+var_18], rdx
0x004F74A8 | 8B 55 FC | mov     edx, [rbp+var_4]
0x004F74AB | 89 10 | mov     [rax], edx
0x004F74AD | 83 45 F8 01 | add     [rbp+var_8], 1
0x004F74B1 | 81 7D F8 FF 00 00 00 | cmp     [rbp+var_8], 0FFh
0x004F74B8 | 0F 8E 7A FF FF FF | jle     loc_4F7438
0x004F74BE | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004F74C2 | 48 2D 00 04 00 00 | sub     rax, 400h
0x004F74C8 | C9 | leave
0x004F74C9 | C3 | retn

 Ourput decompiled code:
FAST_FUNC crc32_filltable(uint32_t *crc_table, int endian)
{
	uint32_t polynomial = endian ? 0x04c11db7 : 0xedb88320;
	uint32_t c;
	int i, j;

	if (!crc_table)
		crc_table = xmalloc(256 * sizeof(uint32_t));

	for (i = 0; i < 256; i++) {
		c = endian ? (i << 24) : i;
		for (j = 8; j; j--) {
			if (endian)
				c = (c&0x80000000) ? ((c << 1) ^ polynomial) : (c << 1);
			else
				c = (c&1) ? ((c >> 1) ^ polynomial) : (c >> 1);
		}
		*crc_table++ = c;
	}

	return crc_table - 256;
}

## Example:

 Input assembly code:
0x0047AAC3 | 55 | push    rbp
0x0047AAC4 | 48 89 E5 | mov     rbp, rsp
0x0047AAC7 | 48 83 EC 20 | sub     rsp, 20h
0x0047AACB | 89 7D EC | mov     [rbp+var_14], edi
0x0047AACE | 89 75 E8 | mov     [rbp+var_18], esi
0x0047AAD1 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x0047AAD8 | EB 33 | jmp     short loc_47AB0D
0x0047AADA | 8B 45 FC | mov     eax, [rbp+var_4]
0x0047AADD | 48 98 | cdqe
0x0047AADF | 48 8B 04 C5 E0 C5 51 00 | mov     rax, ds:off_51C5E0[rax*8]; "eerrexit"
0x0047AAE7 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0047AAEA | 0F BE C0 | movsx   eax, al
0x0047AAED | 39 45 EC | cmp     [rbp+var_14], eax
0x0047AAF0 | 75 17 | jnz     short loc_47AB09
0x0047AAF2 | 48 8B 15 1F 29 2E 00 | mov     rdx, cs:qword_75D418
0x0047AAF9 | 8B 45 E8 | mov     eax, [rbp+var_18]
0x0047AAFC | 89 C1 | mov     ecx, eax
0x0047AAFE | 8B 45 FC | mov     eax, [rbp+var_4]
0x0047AB01 | 48 98 | cdqe
0x0047AB03 | 88 4C 02 39 | mov     [rdx+rax+39h], cl
0x0047AB07 | EB 32 | jmp     short locret_47AB3B
0x0047AB09 | 83 45 FC 01 | add     [rbp+var_4], 1
0x0047AB0D | 83 7D FC 0E | cmp     [rbp+var_4], 0Eh
0x0047AB11 | 7E C7 | jle     short loc_47AADA
0x0047AB13 | 83 7D E8 00 | cmp     [rbp+var_18], 0
0x0047AB17 | 74 07 | jz      short loc_47AB20
0x0047AB19 | B9 2D 00 00 00 | mov     ecx, 2Dh ; '-'
0x0047AB1E | EB 05 | jmp     short loc_47AB25
0x0047AB20 | B9 2B 00 00 00 | mov     ecx, 2Bh ; '+'
0x0047AB25 | 8B 45 EC | mov     eax, [rbp+var_14]
0x0047AB28 | 89 C2 | mov     edx, eax
0x0047AB2A | 89 CE | mov     esi, ecx
0x0047AB2C | BF F0 D9 51 00 | mov     edi, offset aIllegalOptionC_1; "illegal option %c%c"
0x0047AB31 | B8 00 00 00 00 | mov     eax, 0
0x0047AB36 | E8 38 39 FF FF | call    sub_46E473
0x0047AB3B | C9 | leave
0x0047AB3C | C3 | retn

 Ourput decompiled code:
static void
setoption(int flag, int val)
{
	int i;

	for (i = 0; i < NOPTS; i++) {
		if (optletters(i) == flag) {
			optlist[i] = val;
			return;
		}
	}
	ash_msg_and_raise_error("illegal option %c%c", val ? '-' : '+', flag);
	/* NOTREACHED */
}

## Example:

 Input assembly code:
0x00473441 | 55 | push    rbp
0x00473442 | 48 89 E5 | mov     rbp, rsp
0x00473445 | 48 83 EC 20 | sub     rsp, 20h
0x00473449 | 89 7D EC | mov     [rbp+fd], edi
0x0047344C | 89 75 E8 | mov     [rbp+fd2], esi
0x0047344F | 83 7D E8 00 | cmp     [rbp+fd2], 0
0x00473453 | 79 1B | jns     short loc_473470
0x00473455 | 81 65 E8 FF FF FF 7F | and     [rbp+fd2], 7FFFFFFFh
0x0047345C | 8B 55 E8 | mov     edx, [rbp+fd2]
0x0047345F | 8B 45 EC | mov     eax, [rbp+fd]
0x00473462 | 89 D6 | mov     esi, edx; fd2
0x00473464 | 89 C7 | mov     edi, eax; fd
0x00473466 | E8 15 37 F9 FF | call    _dup2
0x0047346B | 89 45 FC | mov     [rbp+var_4], eax
0x0047346E | EB 1A | jmp     short loc_47348A
0x00473470 | 8B 55 E8 | mov     edx, [rbp+fd2]
0x00473473 | 8B 45 EC | mov     eax, [rbp+fd]
0x00473476 | BE 00 00 00 00 | mov     esi, 0; cmd
0x0047347B | 89 C7 | mov     edi, eax; fd
0x0047347D | B8 00 00 00 00 | mov     eax, 0
0x00473482 | E8 B9 34 F9 FF | call    _fcntl
0x00473487 | 89 45 FC | mov     [rbp+var_4], eax
0x0047348A | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0047348E | 79 29 | jns     short loc_4734B9
0x00473490 | 48 8B 05 69 9F 2E 00 | mov     rax, cs:qword_75D400
0x00473497 | 8B 00 | mov     eax, [rax]
0x00473499 | 83 F8 18 | cmp     eax, 18h
0x0047349C | 75 07 | jnz     short loc_4734A5
0x0047349E | B8 FE FF FF FF | mov     eax, 0FFFFFFFEh
0x004734A3 | EB 17 | jmp     short locret_4734BC
0x004734A5 | 8B 45 EC | mov     eax, [rbp+fd]
0x004734A8 | 89 C6 | mov     esi, eax
0x004734AA | BF E8 CF 51 00 | mov     edi, offset aDM; "%d: %m"
0x004734AF | B8 00 00 00 00 | mov     eax, 0
0x004734B4 | E8 BA AF FF FF | call    sub_46E473
0x004734B9 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004734BC | C9 | leave
0x004734BD | C3 | retn

 Ourput decompiled code:
static int
copyfd(int from, int to)
{
	int newfd;

	if (to & COPYFD_EXACT) {
		to &= ~COPYFD_EXACT;
		/*if (from != to)*/
			newfd = dup2(from, to);
	} else {
		newfd = fcntl(from, F_DUPFD, to);
	}
	if (newfd < 0) {
		if (errno == EMFILE)
			return EMPTY;
		/* Happens when source fd is not open: try "echo >&99" */
		ash_msg_and_raise_error("%d: %m", from);
	}
	return newfd;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0049F3E3 | 55 | push    rbp
0x0049F3E4 | 48 89 E5 | mov     rbp, rsp
0x0049F3E7 | 48 83 EC 20 | sub     rsp, 20h
0x0049F3EB | 89 7D EC | mov     [rbp+var_14], edi
0x0049F3EE | C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0
0x0049F3F5 | C7 45 FC 01 00 00 00 | mov     [rbp+var_4], 1
0x0049F3FC | EB 09 | jmp     short loc_49F407
0x0049F3FE | 8B 45 FC | mov     eax, [rbp+var_4]
0x0049F401 | 89 45 F8 | mov     [rbp+var_8], eax
0x0049F404 | D1 65 FC | shl     [rbp+var_4], 1
0x0049F407 | 8B 55 FC | mov     edx, [rbp+var_4]
0x0049F40A | 8B 45 EC | mov     eax, [rbp+var_14]
0x0049F40D | 89 D6 | mov     esi, edx
0x0049F40F | 89 C7 | mov     edi, eax
0x0049F411 | E8 72 FF FF FF | call    sub_49F388
0x0049F416 | 48 85 C0 | test    rax, rax
0x0049F419 | 75 E3 | jnz     short loc_49F3FE
0x0049F41B | EB 36 | jmp     short loc_49F453
0x0049F41D | 8B 55 F8 | mov     edx, [rbp+var_8]
0x0049F420 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0049F423 | 01 D0 | add     eax, edx
0x0049F425 | 89 C2 | mov     edx, eax
0x0049F427 | C1 EA 1F | shr     edx, 1Fh
0x0049F42A | 01 D0 | add     eax, edx
0x0049F42C | D1 F8 | sar     eax, 1
0x0049F42E | 89 45 F4 | mov     [rbp+var_C], eax
0x0049F431 | 8B 55 F4 | mov     edx, [rbp+var_C]
0x0049F434 | 8B 45 EC | mov     eax, [rbp+var_14]
0x0049F437 | 89 D6 | mov     esi, edx
0x0049F439 | 89 C7 | mov     edi, eax
0x0049F43B | E8 48 FF FF FF | call    sub_49F388
0x0049F440 | 48 85 C0 | test    rax, rax
0x0049F443 | 74 08 | jz      short loc_49F44D
0x0049F445 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x0049F448 | 89 45 F8 | mov     [rbp+var_8], eax
0x0049F44B | EB 06 | jmp     short loc_49F453
0x0049F44D | 8B 45 F4 | mov     eax, [rbp+var_C]
0x0049F450 | 89 45 FC | mov     [rbp+var_4], eax
0x0049F453 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0049F456 | 83 E8 01 | sub     eax, 1
0x0049F459 | 39 45 F8 | cmp     [rbp+var_8], eax
0x0049F45C | 7C BF | jl      short loc_49F41D
0x0049F45E | 8B 45 EC | mov     eax, [rbp+var_14]
0x0049F461 | BE 00 00 00 00 | mov     esi, 0
0x0049F466 | 89 C7 | mov     edi, eax
0x0049F468 | E8 1B FF FF FF | call    sub_49F388
0x0049F46D | 8B 45 F8 | mov     eax, [rbp+var_8]
0x0049F470 | 83 C0 01 | add     eax, 1
0x0049F473 | C9 | leave
0x0049F474 | C3 | retn
 ************ 
Source Code:
static int count_blocks(int fd)
{
	int high, low;

	low = 0;
	for (high = 1; valid_offset(fd, high); high *= 2)
		low = high;

	while (low < high - 1) {
		const int mid = (low + high) / 2;

		if (valid_offset(fd, mid))
			low = mid;
		else
			high = mid;
	}
	valid_offset(fd, 0);
	return (low + 1);
}
 ************ 
Parsed Output:
static void sub_49F388(int a, int b) {
    // function body
}

void function(int var_14) {
    int var_8 = 0;
    int var_4 = 1;

    while (1) {
        var_8 = var_4;
        var_4 = var_4 << 1;

        if (sub_49F388(var_14, var_8) == 0) {
            break;
        }
    }

    int var_C = (var_4 + var_8) >> 1;

    while (sub_49F388(var_14, var_C) != 0) {
        if (var_C < var_8) {
            var_8 = var_C;
        } else {
            var_4 = var_C;
        }
        var_C = (var_4 + var_8) >> 1;
    }

    sub_49F388(var_14, var_8 + 1);
}
 ************ 
Similarity Score (Unixcoder): 0.4790564179420471
Func rank: 86

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: set_changed
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00490C6D | 55 | push    rbp
0x00490C6E | 48 89 E5 | mov     rbp, rsp
0x00490C71 | 89 7D FC | mov     [rbp+var_4], edi
0x00490C74 | 48 8B 0D 8D C7 2C 00 | mov     rcx, cs:qword_75D408
0x00490C7B | 8B 45 FC | mov     eax, [rbp+var_4]
0x00490C7E | 48 63 D0 | movsxd  rdx, eax
0x00490C81 | 48 89 D0 | mov     rax, rdx
0x00490C84 | 48 C1 E0 02 | shl     rax, 2
0x00490C88 | 48 01 D0 | add     rax, rdx
0x00490C8B | 48 C1 E0 03 | shl     rax, 3
0x00490C8F | 48 01 C8 | add     rax, rcx
0x00490C92 | 48 05 C8 09 00 00 | add     rax, 9C8h
0x00490C98 | 48 8B 00 | mov     rax, [rax]
0x00490C9B | 0F B6 40 04 | movzx   eax, byte ptr [rax+4]
0x00490C9F | 0F B6 C0 | movzx   eax, al
0x00490CA2 | 5D | pop     rbp
0x00490CA3 | C3 | retn

 Ourput decompiled code:
if ENABLE_FEATURE_FDISK_WRITABLE
static int
get_sysid(int i)
{
	return LABEL_IS_SUN ? sunlabel->infos[i].id :
			(LABEL_IS_SGI ? sgi_get_sysid(i) :
				ptes[i].part_table->sys_ind);
}

## Example:

 Input assembly code:
0x004ED405 | 55 | push    rbp
0x004ED406 | 48 89 E5 | mov     rbp, rsp
0x004ED409 | 89 7D FC | mov     [rbp+var_4], edi
0x004ED40C | 48 8B 05 F5 FF 26 00 | mov     rax, cs:qword_75D408
0x004ED413 | 8B 40 6C | mov     eax, [rax+6Ch]
0x004ED416 | 8D 70 FF | lea     esi, [rax-1]
0x004ED419 | 48 8B 05 E8 FF 26 00 | mov     rax, cs:qword_75D408
0x004ED420 | 8B 48 6C | mov     ecx, [rax+6Ch]
0x004ED423 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004ED426 | 99 | cdq
0x004ED427 | F7 F9 | idiv    ecx
0x004ED429 | 89 D0 | mov     eax, edx
0x004ED42B | 29 C6 | sub     esi, eax
0x004ED42D | 89 F2 | mov     edx, esi
0x004ED42F | 8B 45 FC | mov     eax, [rbp+var_4]
0x004ED432 | 01 D0 | add     eax, edx
0x004ED434 | 5D | pop     rbp
0x004ED435 | C3 | retn

 Ourput decompiled code:
static int next_tabstop(int col)
{
	return col + ((tabstop - 1) - (col % tabstop));
}

## Example:

 Input assembly code:
0x00458611 | 55 | push    rbp
0x00458612 | 48 89 E5 | mov     rbp, rsp
0x00458615 | 89 7D EC | mov     [rbp+var_14], edi
0x00458618 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x0045861F | EB 44 | jmp     short loc_458665
0x00458621 | 48 8B 0D E8 4D 30 00 | mov     rcx, cs:qword_75D410
0x00458628 | 8B 55 FC | mov     edx, [rbp+var_4]
0x0045862B | 48 89 D0 | mov     rax, rdx
0x0045862E | 48 C1 E0 03 | shl     rax, 3
0x00458632 | 48 01 D0 | add     rax, rdx
0x00458635 | 48 C1 E0 02 | shl     rax, 2
0x00458639 | 48 01 C8 | add     rax, rcx
0x0045863C | 8B 40 04 | mov     eax, [rax+4]
0x0045863F | 39 45 EC | cmp     [rbp+var_14], eax
0x00458642 | 75 1D | jnz     short loc_458661
0x00458644 | 48 8B 0D C5 4D 30 00 | mov     rcx, cs:qword_75D410
0x0045864B | 8B 55 FC | mov     edx, [rbp+var_4]
0x0045864E | 48 89 D0 | mov     rax, rdx
0x00458651 | 48 C1 E0 03 | shl     rax, 3
0x00458655 | 48 01 D0 | add     rax, rdx
0x00458658 | 48 C1 E0 02 | shl     rax, 2
0x0045865C | 48 01 C8 | add     rax, rcx
0x0045865F | EB 16 | jmp     short loc_458677
0x00458661 | 83 45 FC 01 | add     [rbp+var_4], 1
0x00458665 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0045866A | 8B 40 30 | mov     eax, [rax+30h]
0x0045866D | 39 45 FC | cmp     [rbp+var_4], eax
0x00458670 | 72 AF | jb      short loc_458621
0x00458672 | B8 00 00 00 00 | mov     eax, 0
0x00458677 | 5D | pop     rbp
0x00458678 | C3 | retn

 Ourput decompiled code:
FAST_FUNC find_lease_by_nip(uint32_t nip)
{
	unsigned i;

	for (i = 0; i < server_config.max_leases; i++)
		if (g_leases[i].lease_nip == nip)
			return &g_leases[i];

	return NULL;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00490725 | 55 | push    rbp
0x00490726 | 48 89 E5 | mov     rbp, rsp
0x00490729 | 89 7D FC | mov     [rbp+var_4], edi
0x0049072C | 48 8B 0D D5 CC 2C 00 | mov     rcx, cs:qword_75D408
0x00490733 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00490736 | 48 63 D0 | movsxd  rdx, eax
0x00490739 | 48 89 D0 | mov     rax, rdx
0x0049073C | 48 C1 E0 02 | shl     rax, 2
0x00490740 | 48 01 D0 | add     rax, rdx
0x00490743 | 48 C1 E0 03 | shl     rax, 3
0x00490747 | 48 01 C8 | add     rax, rcx
0x0049074A | 48 05 E8 09 00 00 | add     rax, 9E8h
0x00490750 | C6 00 01 | mov     byte ptr [rax], 1
0x00490753 | 90 | nop
0x00490754 | 5D | pop     rbp
0x00490755 | C3 | retn
 ************ 
Source Code:
static ALWAYS_INLINE void
set_changed(int i)
{
	ptes[i].changed = 1;
}
 ************ 
Parsed Output:
static void set_flag(int i) {
    uint64_t* ptr = &qword_75D408;
    int var_4 = i;
    int eax = var_4;
    int edx = eax;
    uint64_t rax = edx;
    rax = rax << 2;
    rax = rax + edx;
    rax = rax << 3;
    rax = rax + *ptr;
    rax = rax + 0x9E8;
    *(uint8_t*)rax = 1;
}
 ************ 
Similarity Score (Unixcoder): 0.4780780076980591
Func rank: 87

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: add_peers
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004706D8 | 55 | push    rbp
0x004706D9 | 48 89 E5 | mov     rbp, rsp
0x004706DC | 48 83 EC 20 | sub     rsp, 20h
0x004706E0 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004706E4 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004706E8 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004706EC | 48 89 C7 | mov     rdi, rax
0x004706EF | E8 6E FE FF FF | call    sub_470562
0x004706F4 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004706F8 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004706FC | 48 8B 00 | mov     rax, [rax]
0x004706FF | 48 89 45 F0 | mov     [rbp+var_10], rax
0x00470703 | 48 8B 05 0E CD 2E 00 | mov     rax, cs:qword_75D418
0x0047070A | 8B 50 30 | mov     edx, [rax+30h]
0x0047070D | 83 C2 01 | add     edx, 1
0x00470710 | 89 50 30 | mov     [rax+30h], edx
0x00470713 | 48 83 7D F0 00 | cmp     [rbp+var_10], 0
0x00470718 | 74 4A | jz      short loc_470764
0x0047071A | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0047071E | 8B 40 18 | mov     eax, [rax+18h]
0x00470721 | 83 E0 01 | and     eax, 1
0x00470724 | 85 C0 | test    eax, eax
0x00470726 | 75 10 | jnz     short loc_470738
0x00470728 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0047072C | 48 8B 40 10 | mov     rax, [rax+10h]
0x00470730 | 48 89 C7 | mov     rdi, rax; ptr
0x00470733 | E8 28 5F F9 FF | call    _free
0x00470738 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0047073C | 48 89 C7 | mov     rdi, rax
0x0047073F | E8 DB 99 F9 FF | call    sub_40A11F
0x00470744 | 48 89 C2 | mov     rdx, rax
0x00470747 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0047074B | 48 89 50 10 | mov     [rax+10h], rdx
0x0047074F | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00470753 | 8B 40 18 | mov     eax, [rax+18h]
0x00470756 | 83 E0 FD | and     eax, 0FFFFFFFDh
0x00470759 | 89 C2 | mov     edx, eax
0x0047075B | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0047075F | 89 50 18 | mov     [rax+18h], edx
0x00470762 | EB 47 | jmp     short loc_4707AB
0x00470764 | BF 20 00 00 00 | mov     edi, 20h ; ' '
0x00470769 | E8 7A 99 F9 FF | call    sub_40A0E8
0x0047076E | 48 89 45 F0 | mov     [rbp+var_10], rax
0x00470772 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00470776 | 48 89 C7 | mov     rdi, rax
0x00470779 | E8 A1 99 F9 FF | call    sub_40A11F
0x0047077E | 48 89 C2 | mov     rdx, rax
0x00470781 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00470785 | 48 89 50 08 | mov     [rax+8], rdx
0x00470789 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0047078D | 48 89 C7 | mov     rdi, rax
0x00470790 | E8 8A 99 F9 FF | call    sub_40A11F
0x00470795 | 48 89 C2 | mov     rdx, rax
0x00470798 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0047079C | 48 89 50 10 | mov     [rax+10h], rdx
0x004707A0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004707A4 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x004707A8 | 48 89 10 | mov     [rax], rdx
0x004707AB | E8 8F D8 FF FF | call    sub_46E03F
0x004707B0 | 90 | nop
0x004707B1 | C9 | leave
0x004707B2 | C3 | retn

 Ourput decompiled code:
static void
setalias(const char *name, const char *val)
{
	struct alias *ap, **app;

	app = __lookupalias(name);
	ap = *app;
	INT_OFF;
	if (ap) {
		if (!(ap->flag & ALIASINUSE)) {
			free(ap->val);
		}
		ap->val = ckstrdup(val);
		ap->flag &= ~ALIASDEAD;
	} else {
		/* not found */
		ap = ckzalloc(sizeof(struct alias));
		ap->name = ckstrdup(name);
		ap->val = ckstrdup(val);
		/*ap->flag = 0; - ckzalloc did it */
		/*ap->next = NULL;*/
		*app = ap;
	}
	INT_ON;
}

## Example:

 Input assembly code:
0x00479F0F | 55 | push    rbp
0x00479F10 | 48 89 E5 | mov     rbp, rsp
0x00479F13 | 48 83 EC 20 | sub     rsp, 20h
0x00479F17 | 48 89 7D E8 | mov     [rbp+s], rdi
0x00479F1B | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00479F1F | 48 8B 45 E8 | mov     rax, [rbp+s]
0x00479F23 | 48 89 C7 | mov     rdi, rax; s
0x00479F26 | E8 A5 CB F8 FF | call    _strlen
0x00479F2B | 89 45 F4 | mov     [rbp+var_C], eax
0x00479F2E | 48 8B 05 E3 34 2E 00 | mov     rax, cs:qword_75D418
0x00479F35 | 8B 50 30 | mov     edx, [rax+30h]
0x00479F38 | 83 C2 01 | add     edx, 1
0x00479F3B | 89 50 30 | mov     [rax+30h], edx
0x00479F3E | 48 8B 05 E3 0E 2E 00 | mov     rax, cs:off_75AE28
0x00479F45 | 48 8B 40 28 | mov     rax, [rax+28h]
0x00479F49 | 48 85 C0 | test    rax, rax
0x00479F4C | 74 22 | jz      short loc_479F70
0x00479F4E | BF 28 00 00 00 | mov     edi, 28h ; '('
0x00479F53 | E8 90 01 F9 FF | call    sub_40A0E8
0x00479F58 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00479F5C | 48 8B 05 C5 0E 2E 00 | mov     rax, cs:off_75AE28
0x00479F63 | 48 8B 50 28 | mov     rdx, [rax+28h]
0x00479F67 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00479F6B | 48 89 10 | mov     [rax], rdx
0x00479F6E | EB 0F | jmp     short loc_479F7F
0x00479F70 | 48 8B 05 B1 0E 2E 00 | mov     rax, cs:off_75AE28
0x00479F77 | 48 83 C0 30 | add     rax, 30h ; '0'
0x00479F7B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00479F7F | 48 8B 05 A2 0E 2E 00 | mov     rax, cs:off_75AE28
0x00479F86 | 48 8B 55 F8 | mov     rdx, [rbp+var_8]
0x00479F8A | 48 89 50 28 | mov     [rax+28h], rdx
0x00479F8E | 48 8B 05 93 0E 2E 00 | mov     rax, cs:off_75AE28
0x00479F95 | 48 8B 50 18 | mov     rdx, [rax+18h]
0x00479F99 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00479F9D | 48 89 50 08 | mov     [rax+8], rdx
0x00479FA1 | 48 8B 05 80 0E 2E 00 | mov     rax, cs:off_75AE28
0x00479FA8 | 8B 50 10 | mov     edx, [rax+10h]
0x00479FAB | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00479FAF | 89 50 10 | mov     [rax+10h], edx
0x00479FB2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00479FB6 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00479FBA | 48 89 50 18 | mov     [rax+18h], rdx
0x00479FBE | 48 83 7D E0 00 | cmp     [rbp+var_20], 0
0x00479FC3 | 74 1F | jz      short loc_479FE4
0x00479FC5 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00479FC9 | 8B 40 18 | mov     eax, [rax+18h]
0x00479FCC | 83 C8 01 | or      eax, 1
0x00479FCF | 89 C2 | mov     edx, eax
0x00479FD1 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00479FD5 | 89 50 18 | mov     [rax+18h], edx
0x00479FD8 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00479FDC | 48 8B 55 E8 | mov     rdx, [rbp+s]
0x00479FE0 | 48 89 50 20 | mov     [rax+20h], rdx
0x00479FE4 | 48 8B 05 3D 0E 2E 00 | mov     rax, cs:off_75AE28
0x00479FEB | 48 8B 55 E8 | mov     rdx, [rbp+s]
0x00479FEF | 48 89 50 18 | mov     [rax+18h], rdx
0x00479FF3 | 48 8B 05 2E 0E 2E 00 | mov     rax, cs:off_75AE28
0x00479FFA | 8B 55 F4 | mov     edx, [rbp+var_C]
0x00479FFD | 89 50 10 | mov     [rax+10h], edx
0x0047A000 | E8 3A 40 FF FF | call    sub_46E03F
0x0047A005 | 90 | nop
0x0047A006 | C9 | leave
0x0047A007 | C3 | retn

 Ourput decompiled code:
endif
static void
pushstring(char *s, struct alias *ap)
{
	struct strpush *sp;
	int len;

	len = strlen(s);
	INT_OFF;
	if (g_parsefile->strpush) {
		sp = ckzalloc(sizeof(*sp));
		sp->prev = g_parsefile->strpush;
	} else {
		sp = &(g_parsefile->basestrpush);
	}
	g_parsefile->strpush = sp;
	sp->prev_string = g_parsefile->next_to_pgetc;
	sp->prev_left_in_line = g_parsefile->left_in_line;
#if ENABLE_ASH_ALIAS
	sp->ap = ap;
	if (ap) {
		ap->flag |= ALIASINUSE;
		sp->string = s;
	}
#endif
	g_parsefile->next_to_pgetc = s;
	g_parsefile->left_in_line = len;
	INT_ON;
}

## Example:

 Input assembly code:
0x00476145 | 55 | push    rbp
0x00476146 | 48 89 E5 | mov     rbp, rsp
0x00476149 | 48 83 EC 20 | sub     rsp, 20h
0x0047614D | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00476151 | BF 10 00 00 00 | mov     edi, 10h
0x00476156 | E8 8C 86 FF FF | call    sub_46E7E7
0x0047615B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0047615F | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00476163 | 48 89 C7 | mov     rdi, rax
0x00476166 | E8 F2 86 FF FF | call    sub_46E85D
0x0047616B | 48 89 C2 | mov     rdx, rax
0x0047616E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00476172 | 48 89 50 08 | mov     [rax+8], rdx
0x00476176 | 48 8B 05 8B 4E 2E 00 | mov     rax, cs:qword_75B008
0x0047617D | 48 8B 55 F8 | mov     rdx, [rbp+var_8]
0x00476181 | 48 89 10 | mov     [rax], rdx
0x00476184 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00476188 | 48 89 05 79 4E 2E 00 | mov     cs:qword_75B008, rax
0x0047618F | 90 | nop
0x00476190 | C9 | leave
0x00476191 | C3 | retn

 Ourput decompiled code:
static void
addfname(const char *name)
{
	struct strlist *sp;

	sp = stzalloc(sizeof(*sp));
	sp->text = ststrdup(name);
	*exparg.lastp = sp;
	exparg.lastp = &sp->next;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0043B939 | 55 | push    rbp
0x0043B93A | 48 89 E5 | mov     rbp, rsp
0x0043B93D | 48 83 EC 20 | sub     rsp, 20h
0x0043B941 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0043B945 | BF 70 01 00 00 | mov     edi, 170h
0x0043B94A | E8 99 E7 FC FF | call    sub_40A0E8
0x0043B94F | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0043B953 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043B957 | BE 7B 00 00 00 | mov     esi, 7Bh ; '{'
0x0043B95C | 48 89 C7 | mov     rdi, rax
0x0043B95F | E8 C6 01 0D 00 | call    sub_50BB2A
0x0043B964 | 48 89 C2 | mov     rdx, rax
0x0043B967 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B96B | 48 89 10 | mov     [rax], rdx
0x0043B96E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B972 | 48 8B 00 | mov     rax, [rax]
0x0043B975 | 48 83 C0 04 | add     rax, 4
0x0043B979 | 48 89 C7 | mov     rdi, rax
0x0043B97C | E8 5D 06 0D 00 | call    sub_50BFDE
0x0043B981 | 48 89 C2 | mov     rdx, rax
0x0043B984 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B988 | 48 89 50 08 | mov     [rax+8], rdx
0x0043B98C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B990 | C7 40 10 FF FF FF FF | mov     dword ptr [rax+10h], 0FFFFFFFFh
0x0043B997 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B99B | C6 80 28 01 00 00 23 | mov     byte ptr [rax+128h], 23h ; '#'
0x0043B9A2 | 48 8B 05 5F 1A 32 00 | mov     rax, cs:qword_75D408
0x0043B9A9 | F2 0F 10 00 | movsd   xmm0, qword ptr [rax]
0x0043B9AD | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B9B1 | F2 0F 11 40 20 | movsd   qword ptr [rax+20h], xmm0
0x0043B9B6 | F2 0F 10 05 92 A3 0E 00 | movsd   xmm0, cs:qword_525D50
0x0043B9BE | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B9C2 | 48 89 C7 | mov     rdi, rax
0x0043B9C5 | E8 82 FD FF FF | call    sub_43B74C
0x0043B9CA | 48 8B 05 37 1A 32 00 | mov     rax, cs:qword_75D408
0x0043B9D1 | 48 8D 50 30 | lea     rdx, [rax+30h]
0x0043B9D5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B9D9 | 48 89 C6 | mov     rsi, rax
0x0043B9DC | 48 89 D7 | mov     rdi, rdx
0x0043B9DF | E8 EE D5 FC FF | call    sub_408FD2
0x0043B9E4 | 48 8B 05 1D 1A 32 00 | mov     rax, cs:qword_75D408
0x0043B9EB | 8B 50 40 | mov     edx, [rax+40h]
0x0043B9EE | 83 C2 01 | add     edx, 1
0x0043B9F1 | 89 50 40 | mov     [rax+40h], edx
0x0043B9F4 | 90 | nop
0x0043B9F5 | C9 | leave
0x0043B9F6 | C3 | retn
 ************ 
Source Code:
static void
add_peers(char *s)
{
	peer_t *p;

	p = xzalloc(sizeof(*p));
	p->p_lsa = xhost2sockaddr(s, 123);
	p->p_dotted = xmalloc_sockaddr2dotted_noport(&p->p_lsa->u.sa);
	p->p_fd = -1;
	p->p_xmt_msg.m_status = MODE_CLIENT | (NTP_VERSION << 3);
	p->next_action_time = G.cur_time; /* = set_next(p, 0); */
	reset_peer_stats(p, 16 * STEP_THRESHOLD);

	llist_add_to(&G.ntp_peers, p);
	G.peer_cnt++;
}
 ************ 
Parsed Output:
static void sub_43B939(const char *rdi) {
    struct struct_1 *var_18 = rdi;
    int edi = 0x170;
    struct struct_2 *var_8 = sub_40A0E8(edi);
    var_18->ptr = var_8;
    var_8->ptr = sub_50BB2A(var_18);
    var_8->ptr += 4;
    sub_50BFDE(var_8->ptr);
    var_8->ptr += 8;
    var_8->ptr->field_1 = -1;
    var_8->ptr->field_2 = '#';
    var_8->ptr->field_3 = *(double *)0x75D408;
    var_8->ptr->field_4 = *(double *)0x525D50;
    sub_43B74C(var_8);
    var_8->ptr->field_5 = *(double *)(0x75D408 + 0x30);
    *(int *)(0x75D408 + 0x40) += 1;
}
 ************ 
Similarity Score (Unixcoder): 0.475824773311615
Func rank: 88

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: peektoken
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004C4435 | 55 | push    rbp
0x004C4436 | 48 89 E5 | mov     rbp, rsp
0x004C4439 | 48 83 EC 10 | sub     rsp, 10h
0x004C443D | E8 84 FF FF FF | call    sub_4C43C6
0x004C4442 | 89 45 FC | mov     [rbp+fd], eax
0x004C4445 | 48 8B 05 B4 8F 29 00 | mov     rax, cs:qword_75D400
0x004C444C | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x004C4452 | 48 8D 55 F8 | lea     rdx, [rbp+var_8]
0x004C4456 | 8B 45 FC | mov     eax, [rbp+fd]
0x004C4459 | BE 00 56 00 00 | mov     esi, 5600h; request
0x004C445E | 89 C7 | mov     edi, eax; fd
0x004C4460 | B8 00 00 00 00 | mov     eax, 0
0x004C4465 | E8 36 29 F4 FF | call    _ioctl
0x004C446A | 85 C0 | test    eax, eax
0x004C446C | 75 07 | jnz     short loc_4C4475
0x004C446E | 8B 45 F8 | mov     eax, [rbp+var_8]
0x004C4471 | 85 C0 | test    eax, eax
0x004C4473 | 7F 0F | jg      short loc_4C4484
0x004C4475 | BF DD 69 53 00 | mov     edi, offset aCanTFindOpenVt; "can't find open VT"
0x004C447A | B8 00 00 00 00 | mov     eax, 0
0x004C447F | E8 1E 4E F4 FF | call    sub_4092A2
0x004C4484 | 8B 45 F8 | mov     eax, [rbp+var_8]
0x004C4487 | C9 | leave
0x004C4488 | C3 | retn

 Ourput decompiled code:
static int find_free_vtno(void)
{
	int vtno;
	int fd = get_vt_fd();

	errno = 0;
	/*xfunc_error_retval = 3; - do we need compat? */
	if (ioctl(fd, VT_OPENQRY, &vtno) != 0 || vtno <= 0)
		bb_perror_msg_and_die("can't find open VT");
// Not really needed, grep for DAEMON_ONLY_SANITIZE
//	if (fd > 2)
//		close(fd);
	return vtno;
}

## Example:

 Input assembly code:
0x0043CF39 | 55 | push    rbp
0x0043CF3A | 48 89 E5 | mov     rbp, rsp
0x0043CF3D | 48 83 EC 10 | sub     rsp, 10h
0x0043CF41 | C7 45 FC 05 00 00 00 | mov     [rbp+var_4], 5
0x0043CF48 | E8 C3 A3 FC FF | call    _random
0x0043CF4D | 89 45 F8 | mov     [rbp+var_8], eax
0x0043CF50 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0043CF53 | C9 | leave
0x0043CF54 | C3 | retn

 Ourput decompiled code:
static unsigned
retry_interval(void)
{
	/* Local problem, want to retry soon */
	unsigned interval, r;
	interval = RETRY_INTERVAL;
	r = random();
	interval += r % (unsigned)(RETRY_INTERVAL / 4);
	VERB3 bb_error_msg("chose retry interval:%u", interval);
	return interval;
}

## Example:

 Input assembly code:
0x0040AEE6 | 55 | push    rbp
0x0040AEE7 | 48 89 E5 | mov     rbp, rsp
0x0040AEEA | 48 83 EC 10 | sub     rsp, 10h
0x0040AEEE | E8 BD CD FF FF | call    _fork
0x0040AEF3 | 89 45 FC | mov     [rbp+var_4], eax
0x0040AEF6 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0040AEFA | 79 12 | jns     short loc_40AF0E
0x0040AEFC | B8 82 81 52 00 | mov     eax, offset aFork; "fork"
0x0040AF01 | 48 89 C7 | mov     rdi, rax
0x0040AF04 | B8 00 00 00 00 | mov     eax, 0
0x0040AF09 | E8 94 E3 FF FF | call    sub_4092A2
0x0040AF0E | 8B 45 FC | mov     eax, [rbp+var_4]
0x0040AF11 | C9 | leave
0x0040AF12 | C3 | retn

 Ourput decompiled code:
if BB_MMU
pid_t FAST_FUNC xfork(void)
{
	pid_t pid;
	pid = fork();
	if (pid < 0) /* wtf? */
		bb_perror_msg_and_die("vfork"+1);
	return pid;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0047DC18 | 55 | push    rbp
0x0047DC19 | 48 89 E5 | mov     rbp, rsp
0x0047DC1C | 48 83 EC 10 | sub     rsp, 10h
0x0047DC20 | E8 EE FE FF FF | call    sub_47DB13
0x0047DC25 | 89 45 FC | mov     [rbp+var_4], eax
0x0047DC28 | C6 05 2A D4 2D 00 01 | mov     cs:byte_75B059, 1
0x0047DC2F | 8B 45 FC | mov     eax, [rbp+var_4]
0x0047DC32 | 48 98 | cdqe
0x0047DC34 | 48 8B 04 C5 20 D2 51 00 | mov     rax, ds:off_51D220[rax*8]
0x0047DC3C | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0047DC3F | C9 | leave
0x0047DC40 | C3 | retn
 ************ 
Source Code:
static char
peektoken(void)
{
	int t;

	t = readtoken();
	tokpushback = 1;
	return tokname_array[t][0];
}
 ************ 
Parsed Output:
static void sub_47DB13(void)
{
    int var_4;
    var_4 = some_function();
    byte_75B059 = 1;
    int eax = var_4;
    int rax = off_51D220[eax * 8];
    eax = (unsigned char)rax;
    return;
}
 ************ 
Similarity Score (Unixcoder): 0.47195419669151306
Func rank: 89

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: read_big_block
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004BB2CA | 55 | push    rbp
0x004BB2CB | 48 89 E5 | mov     rbp, rsp
0x004BB2CE | 48 83 EC 20 | sub     rsp, 20h
0x004BB2D2 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004BB2D6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004BB2DA | 48 8D 48 28 | lea     rcx, [rax+28h]
0x004BB2DE | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004BB2E2 | 8B 00 | mov     eax, [rax]
0x004BB2E4 | BA 00 00 01 00 | mov     edx, 10000h
0x004BB2E9 | 48 89 CE | mov     rsi, rcx
0x004BB2EC | 89 C7 | mov     edi, eax
0x004BB2EE | E8 0C 01 F5 FF | call    sub_40B3FF
0x004BB2F3 | 89 45 FC | mov     [rbp+var_4], eax
0x004BB2F6 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004BB2FA | 7F 0F | jg      short loc_4BB30B
0x004BB2FC | BF 08 16 53 00 | mov     edi, offset aUnexpectedEof; "unexpected EOF"
0x004BB301 | B8 00 00 00 00 | mov     eax, 0
0x004BB306 | E8 93 E3 F4 FF | call    sub_40969E
0x004BB30B | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004BB30F | 48 8D 50 28 | lea     rdx, [rax+28h]
0x004BB313 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004BB317 | 48 89 50 08 | mov     [rax+8], rdx
0x004BB31B | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004BB31F | 48 8D 50 28 | lea     rdx, [rax+28h]
0x004BB323 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004BB326 | 48 98 | cdqe
0x004BB328 | 48 01 C2 | add     rdx, rax
0x004BB32B | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004BB32F | 48 89 50 10 | mov     [rax+10h], rdx
0x004BB333 | 90 | nop
0x004BB334 | C9 | leave
0x004BB335 | C3 | retn

 Ourput decompiled code:
static size_inline void rc_read(rc_t *rc)
{
	int buffer_size = safe_read(rc->fd, RC_BUFFER, RC_BUFFER_SIZE);
//TODO: return -1 instead
//This will make unlzma delete broken unpacked file on unpack errors
	if (buffer_size <= 0)
		bb_error_msg_and_die("unexpected EOF");
	rc->ptr = RC_BUFFER;
	rc->buffer_end = RC_BUFFER + buffer_size;
}

## Example:

 Input assembly code:
0x004CB548 | 55 | push    rbp
0x004CB549 | 48 89 E5 | mov     rbp, rsp
0x004CB54C | 48 83 EC 20 | sub     rsp, 20h
0x004CB550 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004CB554 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x004CB558 | 48 8D 45 F0 | lea     rax, [rbp+var_10]
0x004CB55C | 48 89 D6 | mov     rsi, rdx
0x004CB55F | 48 89 C7 | mov     rdi, rax
0x004CB562 | E8 4A 7A 03 00 | call    sub_502FB1
0x004CB567 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x004CB56B | 8B 05 DF 1E 29 00 | mov     eax, cs:dword_75D450
0x004CB571 | 25 00 04 00 00 | and     eax, 400h
0x004CB576 | 85 C0 | test    eax, eax
0x004CB578 | 75 05 | jnz     short loc_4CB57F
0x004CB57A | 8B 45 F8 | mov     eax, [rbp+var_8]
0x004CB57D | EB 38 | jmp     short locret_4CB5B7
0x004CB57F | 8B 45 F8 | mov     eax, [rbp+var_8]
0x004CB582 | 83 C0 02 | add     eax, 2
0x004CB585 | 89 45 FC | mov     [rbp+var_4], eax
0x004CB588 | EB 1F | jmp     short loc_4CB5A9
0x004CB58A | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CB58E | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004CB591 | 3C 22 | cmp     al, 22h ; '"'
0x004CB593 | 74 0B | jz      short loc_4CB5A0
0x004CB595 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CB599 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004CB59C | 3C 5C | cmp     al, 5Ch ; '\'
0x004CB59E | 75 04 | jnz     short loc_4CB5A4
0x004CB5A0 | 83 45 FC 01 | add     [rbp+var_4], 1
0x004CB5A4 | 48 83 45 E8 01 | add     [rbp+var_18], 1
0x004CB5A9 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CB5AD | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004CB5B0 | 84 C0 | test    al, al
0x004CB5B2 | 75 D6 | jnz     short loc_4CB58A
0x004CB5B4 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004CB5B7 | C9 | leave
0x004CB5B8 | C3 | retn

 Ourput decompiled code:
endif

static unsigned calc_name_len(const char *name)
{
	unsigned len;
	uni_stat_t uni_stat;

	// TODO: quote tab as \t, etc, if -Q
	name = printable_string(&uni_stat, name);

	if (!(option_mask32 & OPT_Q)) {
		return uni_stat.unicode_width;
	}

	len = 2 + uni_stat.unicode_width;
	while (*name) {
		if (*name == '"' || *name == '\\') {
			len++;
		}
		name++;
	}
	return len;
}

## Example:

 Input assembly code:
0x00433D06 | 55 | push    rbp
0x00433D07 | 48 89 E5 | mov     rbp, rsp
0x00433D0A | 48 83 EC 20 | sub     rsp, 20h
0x00433D0E | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00433D12 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00433D16 | 8B 40 24 | mov     eax, [rax+24h]
0x00433D19 | 89 45 FC | mov     [rbp+var_4], eax
0x00433D1C | EB 3D | jmp     short loc_433D5B
0x00433D1E | 8B 45 FC | mov     eax, [rbp+var_4]
0x00433D21 | 48 63 D0 | movsxd  rdx, eax
0x00433D24 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00433D28 | 8B 40 20 | mov     eax, [rax+20h]
0x00433D2B | 48 98 | cdqe
0x00433D2D | 48 89 D6 | mov     rsi, rdx; vers
0x00433D30 | 48 89 C7 | mov     rdi, rax; program
0x00433D33 | E8 48 33 FD FF | call    _pmap_unset
0x00433D38 | 85 C0 | test    eax, eax
0x00433D3A | 75 1B | jnz     short loc_433D57
0x00433D3C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00433D40 | 8B 40 20 | mov     eax, [rax+20h]
0x00433D43 | 8B 55 FC | mov     edx, [rbp+var_4]
0x00433D46 | 89 C6 | mov     esi, eax
0x00433D48 | BF A1 92 51 00 | mov     edi, offset aPmapUnsetUU; "pmap_unset(%u,%u)"
0x00433D4D | B8 00 00 00 00 | mov     eax, 0
0x00433D52 | E8 82 54 FD FF | call    sub_4091D9
0x00433D57 | 83 45 FC 01 | add     [rbp+var_4], 1
0x00433D5B | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00433D5F | 8B 40 28 | mov     eax, [rax+28h]
0x00433D62 | 39 45 FC | cmp     [rbp+var_4], eax
0x00433D65 | 7E B7 | jle     short loc_433D1E
0x00433D67 | 90 | nop
0x00433D68 | C9 | leave
0x00433D69 | C3 | retn

 Ourput decompiled code:
static void unregister_rpc(servtab_t *sep)
{
	int n;

	for (n = sep->se_rpcver_lo; n <= sep->se_rpcver_hi; n++) {
		if (!pmap_unset(sep->se_rpcprog, n))
			bb_perror_msg("pmap_unset(%u,%u)", sep->se_rpcprog, n);
	}
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0041A1AA | 55 | push    rbp
0x0041A1AB | 48 89 E5 | mov     rbp, rsp
0x0041A1AE | 48 83 EC 20 | sub     rsp, 20h
0x0041A1B2 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0041A1B6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0041A1BA | BA 00 00 10 00 | mov     edx, 100000h
0x0041A1BF | 48 89 C6 | mov     rsi, rax
0x0041A1C2 | BF 03 00 00 00 | mov     edi, 3
0x0041A1C7 | E8 86 D2 0E 00 | call    sub_507452
0x0041A1CC | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x0041A1D3 | EB 29 | jmp     short loc_41A1FE
0x0041A1D5 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0041A1D8 | 48 63 D0 | movsxd  rdx, eax
0x0041A1DB | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0041A1DF | 48 01 D0 | add     rax, rdx
0x0041A1E2 | 0F B6 10 | movzx   edx, byte ptr [rax]
0x0041A1E5 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0041A1E8 | 48 63 C8 | movsxd  rcx, eax
0x0041A1EB | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0041A1EF | 48 01 C8 | add     rax, rcx
0x0041A1F2 | 83 E2 01 | and     edx, 1
0x0041A1F5 | 88 10 | mov     [rax], dl
0x0041A1F7 | 81 45 FC 00 02 00 00 | add     [rbp+var_4], 200h
0x0041A1FE | 81 7D FC FF FF 0F 00 | cmp     [rbp+var_4], 0FFFFFh
0x0041A205 | 7E CE | jle     short loc_41A1D5
0x0041A207 | 90 | nop
0x0041A208 | C9 | leave
0x0041A209 | C3 | retn
 ************ 
Source Code:
static void read_big_block(/*int fd,*/ char *buf)
{
	int i;

	xread(fd, buf, TIMING_BUF_BYTES);
	/* access all sectors of buf to ensure the read fully completed */
	for (i = 0; i < TIMING_BUF_BYTES; i += 512)
		buf[i] &= 1;
}
 ************ 
Parsed Output:
static void set_flag(rc_t *rc)
{
    int i;
    for (i = 0; i <= 0xFFFFF; i += 0x200) {
        rc->flag[i] = rc->flag[i] & 1;
    }
}
 ************ 
Similarity Score (Unixcoder): 0.46913906931877136
Func rank: 90

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: makestrspace
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004DF493 | 55 | push    rbp
0x004DF494 | 48 89 E5 | mov     rbp, rsp
0x004DF497 | 48 83 EC 20 | sub     rsp, 20h
0x004DF49B | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004DF49F | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DF4A3 | 48 8B 40 18 | mov     rax, [rax+18h]
0x004DF4A7 | 48 89 45 F8 | mov     [rbp+ptr], rax
0x004DF4AB | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004DF4AF | 48 8B 50 08 | mov     rdx, [rax+8]
0x004DF4B3 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004DF4B7 | 48 8B 00 | mov     rax, [rax]
0x004DF4BA | 48 39 C2 | cmp     rdx, rax
0x004DF4BD | 72 2B | jb      short loc_4DF4EA
0x004DF4BF | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004DF4C3 | 48 8B 40 10 | mov     rax, [rax+10h]
0x004DF4C7 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x004DF4CB | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004DF4CF | 48 89 C7 | mov     rdi, rax; ptr
0x004DF4D2 | E8 89 71 F2 FF | call    _free
0x004DF4D7 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DF4DB | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x004DF4DF | 48 89 50 18 | mov     [rax+18h], rdx
0x004DF4E3 | B8 00 00 00 00 | mov     eax, 0
0x004DF4E8 | EB 27 | jmp     short locret_4DF511
0x004DF4EA | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004DF4EE | 48 83 C0 08 | add     rax, 8
0x004DF4F2 | 48 89 C7 | mov     rdi, rax
0x004DF4F5 | E8 65 D0 FF FF | call    sub_4DC55F
0x004DF4FA | 48 89 C2 | mov     rdx, rax
0x004DF4FD | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DF501 | 48 89 D6 | mov     rsi, rdx
0x004DF504 | 48 89 C7 | mov     rdi, rax
0x004DF507 | E8 1B D4 FF FF | call    sub_4DC927
0x004DF50C | B8 01 00 00 00 | mov     eax, 1
0x004DF511 | C9 | leave
0x004DF512 | C3 | retn

 Ourput decompiled code:
static int hashwalk_next(var *v)
{
	walker_list *w = v->x.walker;

	if (w->cur >= w->end) {
		walker_list *prev_walker = w->prev;

		debug_printf_walker("end of iteration, free(walker@%p:%p), prev_walker:%p\n", &v->x.walker, w, prev_walker);
		free(w);
		v->x.walker = prev_walker;
		return FALSE;
	}

	setvar_s(v, nextword(&w->cur));
	return TRUE;
}

## Example:

 Input assembly code:
0x004CE68B | 55 | push    rbp
0x004CE68C | 48 89 E5 | mov     rbp, rsp
0x004CE68F | 48 83 EC 40 | sub     rsp, 40h
0x004CE693 | 48 89 7D C8 | mov     [rbp+var_38], rdi
0x004CE697 | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x004CE69B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004CE69F | E9 83 00 00 00 | jmp     loc_4CE727
0x004CE6A4 | 48 8D 55 D0 | lea     rdx, [rbp+src]
0x004CE6A8 | 48 8B 4D C8 | mov     rcx, [rbp+var_38]
0x004CE6AC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004CE6B0 | 48 89 CE | mov     rsi, rcx
0x004CE6B3 | 48 89 C7 | mov     rdi, rax
0x004CE6B6 | E8 5C FB FF FF | call    sub_4CE217
0x004CE6BB | 48 89 45 F0 | mov     [rbp+var_10], rax
0x004CE6BF | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004CE6C3 | 48 89 45 C8 | mov     [rbp+var_38], rax
0x004CE6C7 | 48 8B 05 42 CB 28 00 | mov     rax, cs:qword_75B210
0x004CE6CE | 89 C2 | mov     edx, eax
0x004CE6D0 | 48 8B 05 41 CB 28 00 | mov     rax, cs:qword_75B218
0x004CE6D7 | BE 04 20 00 00 | mov     esi, 2004h
0x004CE6DC | 48 89 C7 | mov     rdi, rax
0x004CE6DF | E8 FD D9 03 00 | call    sub_50C0E1
0x004CE6E4 | 48 89 05 2D CB 28 00 | mov     cs:qword_75B218, rax
0x004CE6EB | 48 8B 05 26 CB 28 00 | mov     rax, cs:qword_75B218
0x004CE6F2 | 48 8B 15 17 CB 28 00 | mov     rdx, cs:qword_75B210
0x004CE6F9 | 48 C1 E2 05 | shl     rdx, 5
0x004CE6FD | 48 8D 0C 10 | lea     rcx, [rax+rdx]
0x004CE701 | 48 8D 45 D0 | lea     rax, [rbp+src]
0x004CE705 | BA 20 00 00 00 | mov     edx, 20h ; ' '; n
0x004CE70A | 48 89 C6 | mov     rsi, rax; src
0x004CE70D | 48 89 CF | mov     rdi, rcx; dest
0x004CE710 | E8 8B 8A F3 FF | call    _memcpy
0x004CE715 | 48 8B 05 F4 CA 28 00 | mov     rax, cs:qword_75B210
0x004CE71C | 48 83 C0 01 | add     rax, 1
0x004CE720 | 48 89 05 E9 CA 28 00 | mov     cs:qword_75B210, rax
0x004CE727 | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x004CE72B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004CE72E | 84 C0 | test    al, al
0x004CE730 | 0F 85 6E FF FF FF | jnz     loc_4CE6A4
0x004CE736 | 90 | nop
0x004CE737 | C9 | leave
0x004CE738 | C3 | retn

 Ourput decompiled code:
static void
decode_format_string(const char *s)
{
	const char *s_orig = s;

	while (*s != '\0') {
		struct tspec tspec;
		const char *next;

		next = decode_one_format(s_orig, s, &tspec);

		assert(s != next);
		s = next;
		spec = xrealloc_vector(spec, 4, n_specs);
		memcpy(&spec[n_specs], &tspec, sizeof(spec[0]));
		n_specs++;
	}
}

## Example:

 Input assembly code:
0x004368DE | 55 | push    rbp
0x004368DF | 48 89 E5 | mov     rbp, rsp
0x004368E2 | 48 83 EC 20 | sub     rsp, 20h
0x004368E6 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004368EA | 48 8B 05 9F 48 32 00 | mov     rax, cs:qword_75B190
0x004368F1 | 48 85 C0 | test    rax, rax
0x004368F4 | 75 11 | jnz     short loc_436907
0x004368F6 | BF 31 00 00 00 | mov     edi, 31h ; '1'
0x004368FB | E8 5F 37 FD FF | call    sub_40A05F
0x00436900 | 48 89 05 89 48 32 00 | mov     cs:qword_75B190, rax
0x00436907 | 48 8B 05 82 48 32 00 | mov     rax, cs:qword_75B190
0x0043690E | 48 89 45 F8 | mov     [rbp+s], rax
0x00436912 | C7 45 F4 00 00 00 00 | mov     [rbp+var_C], 0
0x00436919 | EB 31 | jmp     short loc_43694C
0x0043691B | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043691F | 48 8D 50 01 | lea     rdx, [rax+1]
0x00436923 | 48 89 55 E8 | mov     [rbp+var_18], rdx
0x00436927 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0043692A | 0F B6 D0 | movzx   edx, al
0x0043692D | 48 8B 45 F8 | mov     rax, [rbp+s]
0x00436931 | BE F0 95 51 00 | mov     esi, offset a02x; "%02X-"
0x00436936 | 48 89 C7 | mov     rdi, rax; s
0x00436939 | B8 00 00 00 00 | mov     eax, 0
0x0043693E | E8 3D 11 FD FF | call    _sprintf
0x00436943 | 48 83 45 F8 03 | add     [rbp+s], 3
0x00436948 | 83 45 F4 01 | add     [rbp+var_C], 1
0x0043694C | 83 7D F4 0F | cmp     [rbp+var_C], 0Fh
0x00436950 | 76 C9 | jbe     short loc_43691B
0x00436952 | 48 83 6D F8 01 | sub     [rbp+s], 1
0x00436957 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x0043695B | C6 00 00 | mov     byte ptr [rax], 0
0x0043695E | 48 8B 05 2B 48 32 00 | mov     rax, cs:qword_75B190
0x00436965 | C9 | leave
0x00436966 | C3 | retn

 Ourput decompiled code:
FAST_FUNC UNSPEC_print(unsigned char *ptr)
{
	static char *buff;

	char *pos;
	unsigned int i;

	if (!buff)
		buff = xmalloc(sizeof(struct sockaddr) * 3 + 1);
	pos = buff;
	for (i = 0; i < sizeof(struct sockaddr); i++) {
		/* careful -- not every libc's sprintf returns # bytes written */
		sprintf(pos, "%02X-", (*ptr++ & 0377));
		pos += 3;
	}
	/* Erase trailing "-".  Works as long as sizeof(struct sockaddr) != 0 */
	*--pos = '\0';
	return buff;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0046ECB9 | 55 | push    rbp
0x0046ECBA | 48 89 E5 | mov     rbp, rsp
0x0046ECBD | 48 83 EC 30 | sub     rsp, 30h
0x0046ECC1 | 48 89 7D D8 | mov     [rbp+var_28], rdi
0x0046ECC5 | 48 89 75 D0 | mov     [rbp+var_30], rsi
0x0046ECC9 | 48 8B 05 58 E7 2E 00 | mov     rax, cs:qword_75D428
0x0046ECD0 | 48 8B 40 10 | mov     rax, [rax+10h]
0x0046ECD4 | 48 8B 55 D0 | mov     rdx, [rbp+var_30]
0x0046ECD8 | 48 29 C2 | sub     rdx, rax
0x0046ECDB | 48 89 D0 | mov     rax, rdx
0x0046ECDE | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0046ECE2 | 48 8B 05 3F E7 2E 00 | mov     rax, cs:qword_75D428
0x0046ECE9 | 48 8B 40 20 | mov     rax, [rax+20h]
0x0046ECED | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0046ECF1 | 48 8B 05 30 E7 2E 00 | mov     rax, cs:qword_75D428
0x0046ECF8 | 48 8B 40 20 | mov     rax, [rax+20h]
0x0046ECFC | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0046ED00 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0046ED04 | 48 2B 45 F8 | sub     rax, [rbp+var_8]
0x0046ED08 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x0046ED0C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0046ED10 | 48 3B 45 D8 | cmp     rax, [rbp+var_28]
0x0046ED14 | 73 07 | jnb     short loc_46ED1D
0x0046ED16 | E8 BA FC FF FF | call    sub_46E9D5
0x0046ED1B | EB D4 | jmp     short loc_46ECF1
0x0046ED1D | 90 | nop
0x0046ED1E | 48 8B 05 03 E7 2E 00 | mov     rax, cs:qword_75D428
0x0046ED25 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x0046ED29 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0046ED2D | 48 01 D0 | add     rax, rdx
0x0046ED30 | C9 | leave
0x0046ED31 | C3 | retn
 ************ 
Source Code:
static char *
makestrspace(size_t newlen, char *p)
{
	size_t len = p - g_stacknxt;
	size_t size = stackblocksize();

	for (;;) {
		size_t nleft;

		size = stackblocksize();
		nleft = size - len;
		if (nleft >= newlen)
			break;
		growstackblock();
	}
	return (char *)stackblock() + len;
}
 ************ 
Parsed Output:
static void func(unsigned char *var_28, unsigned char *var_30)
{
    unsigned char *var_8;
    unsigned char *var_10;
    unsigned char *var_18;

    var_8 = var_30 - cs:qword_75D428[0x10];
    var_10 = cs:qword_75D428[0x20];
    var_10 = cs:qword_75D428[0x20];
    var_18 = var_10 - var_8;

    if (var_18 >= var_28) {
        sub_46E9D5();
        func(var_28, var_30);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.4536189138889313
Func rank: 91

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: setvar_p
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0048B66A | 55 | push    rbp
0x0048B66B | 48 89 E5 | mov     rbp, rsp
0x0048B66E | 48 83 EC 10 | sub     rsp, 10h
0x0048B672 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0048B676 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x0048B67A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B67E | 48 C7 00 00 00 00 00 | mov     qword ptr [rax], 0
0x0048B685 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B689 | 48 C7 40 18 00 00 00 00 | mov     qword ptr [rax+18h], 0
0x0048B691 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x0048B695 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B699 | 48 89 D6 | mov     rsi, rdx
0x0048B69C | 48 89 C7 | mov     rdi, rax
0x0048B69F | E8 F3 FA FF FF | call    sub_48B197
0x0048B6A4 | C9 | leave
0x0048B6A5 | C3 | retn

 Ourput decompiled code:
arith_t FAST_FUNC
arith(arith_state_t *math_state, const char *expr)
{
	math_state->errmsg = NULL;
	math_state->list_of_recursed_names = NULL;
	return evaluate_string(math_state, expr);
}

## Example:

 Input assembly code:
0x0046ED88 | 55 | push    rbp
0x0046ED89 | 48 89 E5 | mov     rbp, rsp
0x0046ED8C | 48 83 EC 10 | sub     rsp, 10h
0x0046ED90 | 48 89 7D F8 | mov     [rbp+s], rdi
0x0046ED94 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x0046ED98 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x0046ED9C | 48 89 C7 | mov     rdi, rax; s
0x0046ED9F | E8 2C 7D F9 FF | call    _strlen
0x0046EDA4 | 48 89 C1 | mov     rcx, rax
0x0046EDA7 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x0046EDAB | 48 8B 45 F8 | mov     rax, [rbp+s]
0x0046EDAF | 48 89 CE | mov     rsi, rcx
0x0046EDB2 | 48 89 C7 | mov     rdi, rax
0x0046EDB5 | E8 78 FF FF FF | call    sub_46ED32
0x0046EDBA | C9 | leave
0x0046EDBB | C3 | retn

 Ourput decompiled code:
static char *
stack_putstr(const char *s, char *p)
{
	return stack_nputstr(s, strlen(s), p);
}

## Example:

 Input assembly code:
0x004C92AB | 55 | push    rbp
0x004C92AC | 48 89 E5 | mov     rbp, rsp
0x004C92AF | 48 83 EC 20 | sub     rsp, 20h
0x004C92B3 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004C92B7 | BF 10 00 00 00 | mov     edi, 10h
0x004C92BC | E8 27 0E F4 FF | call    sub_40A0E8
0x004C92C1 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004C92C5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C92C9 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x004C92CD | 48 89 50 08 | mov     [rax+8], rdx
0x004C92D1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C92D5 | C9 | leave
0x004C92D6 | C3 | retn

 Ourput decompiled code:
static VALUE *int_value(arith_t i)
{
	VALUE *v;

	v = xzalloc(sizeof(VALUE));
	if (INTEGER) /* otherwise xzaaloc did it already */
		v->type = INTEGER;
	v->u.i = i;
	return v;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004DC8ED | 55 | push    rbp
0x004DC8EE | 48 89 E5 | mov     rbp, rsp
0x004DC8F1 | 48 83 EC 10 | sub     rsp, 10h
0x004DC8F5 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004DC8F9 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004DC8FD | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004DC901 | 48 89 C7 | mov     rdi, rax
0x004DC904 | E8 83 FF FF FF | call    sub_4DC88C
0x004DC909 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004DC90D | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x004DC911 | 48 89 50 10 | mov     [rax+10h], rdx
0x004DC915 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004DC919 | 48 89 C7 | mov     rdi, rax
0x004DC91C | E8 EA 26 00 00 | call    sub_4DF00B
0x004DC921 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004DC925 | C9 | leave
0x004DC926 | C3 | retn
 ************ 
Source Code:
static var *setvar_p(var *v, char *value)
{
	clrvar(v);
	v->string = value;
	handle_special(v);
	return v;
}
 ************ 
Parsed Output:
static void update_value(arith_state_t *math_state, int value)
{
    math_state->result = value;
    math_state->list_of_values = value;
    math_state->list_of_values->next = NULL;
}
 ************ 
Similarity Score (Unixcoder): 0.4487777054309845
Func rank: 92

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: write_and_stats
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x005023F6 | 55 | push    rbp
0x005023F7 | 48 89 E5 | mov     rbp, rsp
0x005023FA | 48 83 EC 30 | sub     rsp, 30h
0x005023FE | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00502402 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00502406 | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x0050240A | 48 8B 55 D8 | mov     rdx, [rbp+var_28]
0x0050240E | 48 8B 4D E0 | mov     rcx, [rbp+var_20]
0x00502412 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00502416 | 48 89 CE | mov     rsi, rcx
0x00502419 | 48 89 C7 | mov     rdi, rax
0x0050241C | E8 C3 FD FF FF | call    sub_5021E4
0x00502421 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00502425 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0050242A | 74 1D | jz      short loc_502449
0x0050242C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00502430 | 48 89 C6 | mov     rsi, rax
0x00502433 | BF DE 73 53 00 | mov     edi, offset aBadPasswordS; "Bad password: %s\n"
0x00502438 | B8 00 00 00 00 | mov     eax, 0
0x0050243D | E8 8E 47 F0 FF | call    _printf
0x00502442 | B8 01 00 00 00 | mov     eax, 1
0x00502447 | EB 05 | jmp     short locret_50244E
0x00502449 | B8 00 00 00 00 | mov     eax, 0
0x0050244E | C9 | leave
0x0050244F | C3 | retn

 Ourput decompiled code:
int FAST_FUNC obscure(const char *old, const char *newval, const struct passwd *pw)
{
	const char *msg;

	msg = obscure_msg(old, newval, pw);
	if (msg) {
		printf("Bad password: %s\n", msg);
		return 1;
	}
	return 0;
}

## Example:

 Input assembly code:
0x0040BECF | 55 | push    rbp
0x0040BED0 | 48 89 E5 | mov     rbp, rsp
0x0040BED3 | 48 83 EC 30 | sub     rsp, 30h
0x0040BED7 | 48 89 7D E8 | mov     [rbp+nptr], rdi
0x0040BEDB | 48 89 75 E0 | mov     [rbp+endptr], rsi
0x0040BEDF | 89 55 DC | mov     [rbp+base], edx
0x0040BEE2 | 48 83 7D E0 00 | cmp     [rbp+endptr], 0
0x0040BEE7 | 75 08 | jnz     short loc_40BEF1
0x0040BEE9 | 48 8D 45 F0 | lea     rax, [rbp+var_10]
0x0040BEED | 48 89 45 E0 | mov     [rbp+endptr], rax
0x0040BEF1 | 48 8B 45 E0 | mov     rax, [rbp+endptr]
0x0040BEF5 | 48 8B 55 E8 | mov     rdx, [rbp+nptr]
0x0040BEF9 | 48 89 10 | mov     [rax], rdx
0x0040BEFC | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0040BF00 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040BF03 | 0F B6 C0 | movzx   eax, al
0x0040BF06 | 89 C7 | mov     edi, eax
0x0040BF08 | E8 E5 FD FF FF | call    sub_40BCF2
0x0040BF0D | 85 C0 | test    eax, eax
0x0040BF0F | 75 07 | jnz     short loc_40BF18
0x0040BF11 | E8 1A FE FF FF | call    sub_40BD30
0x0040BF16 | EB 4C | jmp     short locret_40BF64
0x0040BF18 | 48 8B 05 E1 14 35 00 | mov     rax, cs:qword_75D400
0x0040BF1F | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x0040BF25 | 8B 55 DC | mov     edx, [rbp+base]; base
0x0040BF28 | 48 8B 4D E0 | mov     rcx, [rbp+endptr]
0x0040BF2C | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0040BF30 | 48 89 CE | mov     rsi, rcx; endptr
0x0040BF33 | 48 89 C7 | mov     rdi, rax; nptr
0x0040BF36 | E8 25 BA FF FF | call    _strtoul
0x0040BF3B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0040BF3F | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x0040BF44 | 48 39 45 F8 | cmp     [rbp+var_8], rax
0x0040BF48 | 76 07 | jbe     short loc_40BF51
0x0040BF4A | E8 E1 FD FF FF | call    sub_40BD30
0x0040BF4F | EB 13 | jmp     short locret_40BF64
0x0040BF51 | 48 8B 55 E0 | mov     rdx, [rbp+endptr]
0x0040BF55 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040BF59 | 48 89 D6 | mov     rsi, rdx
0x0040BF5C | 48 89 C7 | mov     rdi, rax
0x0040BF5F | E8 E6 FD FF FF | call    sub_40BD4A
0x0040BF64 | C9 | leave
0x0040BF65 | C3 | retn

 Ourput decompiled code:
ULONG_MAX
unsigned FAST_FUNC bb_strtou(const char *arg, char **endp, int base)
{
	unsigned long v;
	char *endptr;

	if (!endp) endp = &endptr;
	*endp = (char*) arg;

	if (!isalnum(arg[0])) return ret_ERANGE();
	errno = 0;
	v = strtoul(arg, endp, base);
	if (v > UINT_MAX) return ret_ERANGE();
	return handle_errors(v, endp);
}

## Example:

 Input assembly code:
0x00484A4F | 55 | push    rbp
0x00484A50 | 48 89 E5 | mov     rbp, rsp
0x00484A53 | 48 83 EC 30 | sub     rsp, 30h
0x00484A57 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00484A5B | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00484A5F | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x00484A63 | 48 8B 4D E0 | mov     rcx, [rbp+var_20]
0x00484A67 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00484A6B | BA 06 00 00 00 | mov     edx, 6
0x00484A70 | 48 89 CE | mov     rsi, rcx
0x00484A73 | 48 89 C7 | mov     rdi, rax
0x00484A76 | E8 AC 5E 00 00 | call    sub_48A927
0x00484A7B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00484A7F | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00484A84 | 74 16 | jz      short loc_484A9C
0x00484A86 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00484A8A | 48 2B 45 E8 | sub     rax, [rbp+var_18]
0x00484A8E | 89 C2 | mov     edx, eax
0x00484A90 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00484A94 | 89 10 | mov     [rax], edx
0x00484A96 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00484A9A | EB 2B | jmp     short locret_484AC7
0x00484A9C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00484AA0 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00484AA3 | 84 C0 | test    al, al
0x00484AA5 | 75 07 | jnz     short loc_484AAE
0x00484AA7 | B8 00 00 00 00 | mov     eax, 0
0x00484AAC | EB 19 | jmp     short locret_484AC7
0x00484AAE | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00484AB2 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00484AB5 | 3C 2A | cmp     al, 2Ah ; '*'
0x00484AB7 | 75 07 | jnz     short loc_484AC0
0x00484AB9 | B8 00 00 00 00 | mov     eax, 0
0x00484ABE | EB 07 | jmp     short locret_484AC7
0x00484AC0 | 48 83 45 E8 01 | add     [rbp+var_18], 1
0x00484AC5 | EB 9C | jmp     short loc_484A63
0x00484AC7 | C9 | leave
0x00484AC8 | C3 | retn

 Ourput decompiled code:
static char *strstr_pattern(char *val, const char *pattern, int *size)
{
	while (1) {
		char *end = scan_and_match(val, pattern, SCAN_MOVE_FROM_RIGHT + SCAN_MATCH_LEFT_HALF);
		debug_printf_varexp("val:'%s' pattern:'%s' end:'%s'\n", val, pattern, end);
		if (end) {
			*size = end - val;
			return val;
		}
		if (*val == '\0')
			return NULL;
		/* Optimization: if "*pat" did not match the start of "string",
		 * we know that "tring", "ring" etc will not match too:
		 */
		if (pattern[0] == '*')
			return NULL;
		val++;
	}
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004C760C | 55 | push    rbp
0x004C760D | 48 89 E5 | mov     rbp, rsp
0x004C7610 | 48 83 EC 30 | sub     rsp, 30h
0x004C7614 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004C7618 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004C761C | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x004C7620 | 48 89 4D D0 | mov     [rbp+var_30], rcx
0x004C7624 | 48 8B 55 D0 | mov     rdx, [rbp+var_30]
0x004C7628 | 48 8B 4D E0 | mov     rcx, [rbp+var_20]
0x004C762C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004C7630 | 48 89 CE | mov     rsi, rcx
0x004C7633 | 48 89 C7 | mov     rdi, rax
0x004C7636 | E8 81 FF FF FF | call    sub_4C75BC
0x004C763B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004C763F | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004C7644 | 79 07 | jns     short loc_4C764D
0x004C7646 | B8 01 00 00 00 | mov     eax, 1
0x004C764B | EB 51 | jmp     short locret_4C769E
0x004C764D | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004C7651 | 48 39 45 F8 | cmp     [rbp+var_8], rax
0x004C7655 | 75 11 | jnz     short loc_4C7668
0x004C7657 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004C765C | 48 8B 10 | mov     rdx, [rax]
0x004C765F | 48 83 C2 01 | add     rdx, 1
0x004C7663 | 48 89 10 | mov     [rax], rdx
0x004C7666 | EB 18 | jmp     short loc_4C7680
0x004C7668 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004C766D | 74 11 | jz      short loc_4C7680
0x004C766F | B8 F8 B3 75 00 | mov     eax, offset dest
0x004C7674 | 48 8B 50 08 | mov     rdx, [rax+8]
0x004C7678 | 48 83 C2 01 | add     rdx, 1
0x004C767C | 48 89 50 08 | mov     [rax+8], rdx
0x004C7680 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004C7685 | 48 8B 50 20 | mov     rdx, [rax+20h]
0x004C7689 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C768D | B9 F8 B3 75 00 | mov     ecx, offset dest
0x004C7692 | 48 01 D0 | add     rax, rdx
0x004C7695 | 48 89 41 20 | mov     [rcx+20h], rax
0x004C7699 | B8 00 00 00 00 | mov     eax, 0
0x004C769E | C9 | leave
0x004C769F | C3 | retn
 ************ 
Source Code:
static bool write_and_stats(const void *buf, size_t len, size_t obs,
	const char *filename)
{
	ssize_t n = full_write_or_warn(buf, len, filename);
	if (n < 0)
		return 1;
	if ((size_t)n == obs)
		G.out_full++;
	else if (n) /* > 0 */
		G.out_part++;
#if ENABLE_FEATURE_DD_THIRD_STATUS_LINE
	G.total_bytes += n;
#endif
	return 0;
}
 ************ 
Parsed Output:
int function(const char *arg1, const char *arg2, const char *arg3, const char *arg4)
{
    int var_8;
    int var_18;
    int var_20;
    int var_28;
    int var_30;
    
    var_30 = arg4;
    var_28 = arg3;
    var_20 = arg2;
    var_18 = arg1;
    
    var_8 = sub_4C75BC(var_18, var_20, var_28, var_30);
    
    if (var_8 < 0)
    {
        return 1;
    }
    
    if (var_8 != var_28)
    {
        dest += 1;
    }
    
    return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.4474903345108032
Func rank: 93

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: buffer_line
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0041E7FF | 55 | push    rbp
0x0041E800 | 48 89 E5 | mov     rbp, rsp
0x0041E803 | 48 83 EC 10 | sub     rsp, 10h
0x0041E807 | 89 7D FC | mov     [rbp+var_4], edi
0x0041E80A | 48 8B 05 F7 EB 33 00 | mov     rax, cs:qword_75D408
0x0041E811 | 0F B6 80 50 01 00 00 | movzx   eax, byte ptr [rax+150h]
0x0041E818 | 84 C0 | test    al, al
0x0041E81A | 0F 84 9A 00 00 00 | jz      loc_41E8BA
0x0041E820 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0041E824 | 79 07 | jns     short loc_41E82D
0x0041E826 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x0041E82D | 48 8B 05 D4 EB 33 00 | mov     rax, cs:qword_75D408
0x0041E834 | 8B 80 08 01 00 00 | mov     eax, [rax+108h]
0x0041E83A | 39 45 FC | cmp     [rbp+var_4], eax
0x0041E83D | 7C 25 | jl      short loc_41E864
0x0041E83F | 48 8B 05 C2 EB 33 00 | mov     rax, cs:qword_75D408
0x0041E846 | 48 8B 40 30 | mov     rax, [rax+30h]
0x0041E84A | 48 85 C0 | test    rax, rax
0x0041E84D | 7E 15 | jle     short loc_41E864
0x0041E84F | 48 8B 05 B2 EB 33 00 | mov     rax, cs:qword_75D408
0x0041E856 | 8B 55 FC | mov     edx, [rbp+var_4]
0x0041E859 | 89 90 04 01 00 00 | mov     [rax+104h], edx
0x0041E85F | E8 E7 E5 FF FF | call    sub_41CE4B
0x0041E864 | 48 8B 05 9D EB 33 00 | mov     rax, cs:qword_75D408
0x0041E86B | 8B 80 08 01 00 00 | mov     eax, [rax+108h]
0x0041E871 | 85 C0 | test    eax, eax
0x0041E873 | 74 39 | jz      short loc_41E8AE
0x0041E875 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0041E878 | 89 C7 | mov     edi, eax
0x0041E87A | E8 34 FF FF FF | call    sub_41E7B3
0x0041E87F | 48 8B 05 82 EB 33 00 | mov     rax, cs:qword_75D408
0x0041E886 | 48 8B 90 F8 00 00 00 | mov     rdx, [rax+0F8h]
0x0041E88D | 48 8B 05 74 EB 33 00 | mov     rax, cs:qword_75D408
0x0041E894 | 8B 80 00 01 00 00 | mov     eax, [rax+100h]
0x0041E89A | 48 98 | cdqe
0x0041E89C | 48 C1 E0 02 | shl     rax, 2
0x0041E8A0 | 48 01 D0 | add     rax, rdx
0x0041E8A3 | 8B 00 | mov     eax, [rax]
0x0041E8A5 | 89 C7 | mov     edi, eax
0x0041E8A7 | E8 8A F6 FF FF | call    sub_41DF36
0x0041E8AC | EB 0D | jmp     short locret_41E8BB
0x0041E8AE | BF 80 92 52 00 | mov     edi, offset aNoMatchesFound; "No matches found"
0x0041E8B3 | E8 57 E2 FF FF | call    sub_41CB0F
0x0041E8B8 | EB 01 | jmp     short locret_41E8BB
0x0041E8BA | 90 | nop
0x0041E8BB | C9 | leave
0x0041E8BC | C3 | retn

 Ourput decompiled code:
static void goto_match(int match)
{
	if (!pattern_valid)
		return;
	if (match < 0)
		match = 0;
	/* Try to find next match if eof isn't reached yet */
	if (match >= num_matches && eof_error > 0) {
		wanted_match = match; /* "I want to read until I see N'th match" */
		read_lines();
	}
	if (num_matches) {
		normalize_match_pos(match);
		buffer_line(match_lines[match_pos]);
	} else {
		print_statusline("No matches found");
	}
}

## Example:

 Input assembly code:
0x0049F8D8 | 55 | push    rbp
0x0049F8D9 | 48 89 E5 | mov     rbp, rsp
0x0049F8DC | 48 83 EC 08 | sub     rsp, 8
0x0049F8E0 | 89 7D FC | mov     [rbp+var_4], edi
0x0049F8E3 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0049F8E7 | 75 5A | jnz     short loc_49F943
0x0049F8E9 | 48 8B 05 18 DB 2B 00 | mov     rax, cs:qword_75D408
0x0049F8F0 | 48 05 54 04 00 00 | add     rax, 454h
0x0049F8F6 | 0F B7 40 08 | movzx   eax, word ptr [rax+8]
0x0049F8FA | 0F B7 C0 | movzx   eax, ax
0x0049F8FD | 83 E8 01 | sub     eax, 1
0x0049F900 | 89 45 FC | mov     [rbp+var_4], eax
0x0049F903 | EB 3E | jmp     short loc_49F943
0x0049F905 | 48 8B 05 FC DA 2B 00 | mov     rax, cs:qword_75D408
0x0049F90C | 48 05 54 04 00 00 | add     rax, 454h
0x0049F912 | 0F B7 40 08 | movzx   eax, word ptr [rax+8]
0x0049F916 | 0F B7 C0 | movzx   eax, ax
0x0049F919 | 8B 55 FC | mov     edx, [rbp+var_4]
0x0049F91C | 29 C2 | sub     edx, eax
0x0049F91E | 89 D0 | mov     eax, edx
0x0049F920 | 83 C0 01 | add     eax, 1
0x0049F923 | 89 C2 | mov     edx, eax
0x0049F925 | 48 8B 05 DC DA 2B 00 | mov     rax, cs:qword_75D408
0x0049F92C | 48 8B 40 38 | mov     rax, [rax+38h]
0x0049F930 | 89 D6 | mov     esi, edx
0x0049F932 | 48 89 C7 | mov     rdi, rax
0x0049F935 | E8 93 F9 FF FF | call    sub_49F2CD
0x0049F93A | 85 C0 | test    eax, eax
0x0049F93C | 74 05 | jz      short loc_49F943
0x0049F93E | 8B 45 FC | mov     eax, [rbp+var_4]
0x0049F941 | EB 44 | jmp     short locret_49F987
0x0049F943 | 83 45 FC 01 | add     [rbp+var_4], 1
0x0049F947 | 8B 55 FC | mov     edx, [rbp+var_4]
0x0049F94A | 48 8B 05 B7 DA 2B 00 | mov     rax, cs:qword_75D408
0x0049F951 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0049F954 | 84 C0 | test    al, al
0x0049F956 | 74 12 | jz      short loc_49F96A
0x0049F958 | 48 8B 05 A9 DA 2B 00 | mov     rax, cs:qword_75D408
0x0049F95F | 48 05 54 04 00 00 | add     rax, 454h
0x0049F965 | 8B 40 14 | mov     eax, [rax+14h]
0x0049F968 | EB 14 | jmp     short loc_49F97E
0x0049F96A | 48 8B 05 97 DA 2B 00 | mov     rax, cs:qword_75D408
0x0049F971 | 48 05 54 04 00 00 | add     rax, 454h
0x0049F977 | 0F B7 40 02 | movzx   eax, word ptr [rax+2]
0x0049F97B | 0F B7 C0 | movzx   eax, ax
0x0049F97E | 39 D0 | cmp     eax, edx
0x0049F980 | 77 83 | ja      short loc_49F905
0x0049F982 | B8 00 00 00 00 | mov     eax, 0
0x0049F987 | C9 | leave
0x0049F988 | C3 | retn

 Ourput decompiled code:
static NOINLINE int next(priv_dumper_t *dumper)
{
	int statok;

	for (;;) {
		if (*dumper->argv) {
			dumper->next__done = statok = 1;
			if (!(freopen(*dumper->argv, "r", stdin))) {
				bb_simple_perror_msg(*dumper->argv);
				dumper->exitval = 1;
				++dumper->argv;
				continue;
			}
		} else {
			if (dumper->next__done)
				return 0; /* no next file */
			dumper->next__done = 1;
			statok = 0;
		}
		if (dumper->pub.dump_skip)
			do_skip(dumper, statok ? *dumper->argv : "stdin", statok);
		if (*dumper->argv)
			++dumper->argv;
		if (!dumper->pub.dump_skip)
			return 1;
	}
	/* NOTREACHED */
}

## Example:

 Input assembly code:
0x00480360 | 55 | push    rbp
0x00480361 | 48 89 E5 | mov     rbp, rsp
0x00480364 | 48 83 EC 10 | sub     rsp, 10h
0x00480368 | 89 7D FC | mov     [rbp+var_4], edi
0x0048036B | 48 8B 05 96 D0 2D 00 | mov     rax, cs:qword_75D408
0x00480372 | 8B 40 3C | mov     eax, [rax+3Ch]
0x00480375 | 85 C0 | test    eax, eax
0x00480377 | 74 3B | jz      short loc_4803B4
0x00480379 | E8 02 66 F8 FF | call    _getpid
0x0048037E | 89 C2 | mov     edx, eax
0x00480380 | 48 8B 05 81 D0 2D 00 | mov     rax, cs:qword_75D408
0x00480387 | 8B 40 20 | mov     eax, [rax+20h]
0x0048038A | 39 C2 | cmp     edx, eax
0x0048038C | 75 26 | jnz     short loc_4803B4
0x0048038E | BF 00 00 00 00 | mov     edi, 0
0x00480393 | E8 31 7E 08 00 | call    sub_5081C9
0x00480398 | 48 8B 05 69 D0 2D 00 | mov     rax, cs:qword_75D408
0x0048039F | 8B 50 3C | mov     edx, [rax+3Ch]
0x004803A2 | 48 8B 05 5F D0 2D 00 | mov     rax, cs:qword_75D408
0x004803A9 | 8B 00 | mov     eax, [rax]
0x004803AB | 89 D6 | mov     esi, edx; pgrp_id
0x004803AD | 89 C7 | mov     edi, eax; fd
0x004803AF | E8 0C 74 F8 FF | call    _tcsetpgrp
0x004803B4 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004803B8 | 7F 0C | jg      short loc_4803C6
0x004803BA | 8B 45 FC | mov     eax, [rbp+var_4]
0x004803BD | F7 D8 | neg     eax
0x004803BF | 89 C7 | mov     edi, eax; status
0x004803C1 | E8 FA 63 F8 FF | call    __exit
0x004803C6 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004803C9 | 89 C7 | mov     edi, eax
0x004803CB | E8 C4 7F 08 00 | call    sub_508394

 Ourput decompiled code:
static void sigexit(int sig)
{
	/* Careful: we can end up here after [v]fork. Do not restore
	 * tty pgrp then, only top-level shell process does that */
	if (G_saved_tty_pgrp && getpid() == G.root_pid) {
		/* Disable all signals: job control, SIGPIPE, etc.
		 * Mostly paranoid measure, to prevent infinite SIGTTOU.
		 */
		sigprocmask_allsigs(SIG_BLOCK);
		tcsetpgrp(G_interactive_fd, G_saved_tty_pgrp);
	}

	/* Not a signal, just exit */
	if (sig <= 0)
		_exit(- sig);

	kill_myself_with_sig(sig); /* does not return */
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0041DF36 | 55 | push    rbp
0x0041DF37 | 48 89 E5 | mov     rbp, rsp
0x0041DF3A | 48 83 EC 10 | sub     rsp, 10h
0x0041DF3E | 89 7D FC | mov     [rbp+var_4], edi
0x0041DF41 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0041DF45 | 79 07 | jns     short loc_41DF4E
0x0041DF47 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x0041DF4E | 48 8B 05 B3 F4 33 00 | mov     rax, cs:qword_75D408
0x0041DF55 | 8B 55 FC | mov     edx, [rbp+var_4]
0x0041DF58 | 89 10 | mov     [rax], edx
0x0041DF5A | E8 EC EE FF FF | call    sub_41CE4B
0x0041DF5F | 48 8B 05 A2 F4 33 00 | mov     rax, cs:qword_75D408
0x0041DF66 | 8B 50 20 | mov     edx, [rax+20h]
0x0041DF69 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0041DF6C | 01 C2 | add     edx, eax
0x0041DF6E | 48 8B 05 93 F4 33 00 | mov     rax, cs:qword_75D408
0x0041DF75 | 8B 40 18 | mov     eax, [rax+18h]
0x0041DF78 | 39 C2 | cmp     edx, eax
0x0041DF7A | 76 1E | jbe     short loc_41DF9A
0x0041DF7C | 48 8B 05 85 F4 33 00 | mov     rax, cs:qword_75D408
0x0041DF83 | 8B 50 18 | mov     edx, [rax+18h]
0x0041DF86 | 48 8B 05 7B F4 33 00 | mov     rax, cs:qword_75D408
0x0041DF8D | 8B 40 20 | mov     eax, [rax+20h]
0x0041DF90 | 29 C2 | sub     edx, eax
0x0041DF92 | 89 D0 | mov     eax, edx
0x0041DF94 | 83 C0 01 | add     eax, 1
0x0041DF97 | 89 45 FC | mov     [rbp+var_4], eax
0x0041DF9A | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0041DF9E | 79 07 | jns     short loc_41DFA7
0x0041DFA0 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x0041DFA7 | 48 8B 05 5A F4 33 00 | mov     rax, cs:qword_75D408
0x0041DFAE | 8B 55 FC | mov     edx, [rbp+var_4]
0x0041DFB1 | 89 10 | mov     [rax], edx
0x0041DFB3 | E8 71 FD FF FF | call    sub_41DD29
0x0041DFB8 | 90 | nop
0x0041DFB9 | C9 | leave
0x0041DFBA | C3 | retn
 ************ 
Source Code:
static void buffer_line(int linenum)
{
	if (linenum < 0)
		linenum = 0;
	cur_fline = linenum;
	read_lines();
	if (linenum + max_displayed_line > max_fline)
		linenum = max_fline - max_displayed_line + TILDES;
	if (linenum < 0)
		linenum = 0;
	cur_fline = linenum;
	buffer_fill_and_print();
}
 ************ 
Parsed Output:
static void sub_41DF36(int edi) {
    int var_4 = edi;
    if (var_4 < 0) {
        var_4 = 0;
    }
    qword_75D408 = var_4;
    sub_41CE4B();
    int edx = qword_75D408 + 0x20;
    int eax = var_4;
    edx += eax;
    eax = qword_75D408 + 0x18;
    if (edx > eax) {
        edx = qword_75D408 + 0x18;
        eax = qword_75D408 + 0x20;
        edx -= eax;
        eax = edx + 1;
        var_4 = eax;
    }
    if (var_4 < 0) {
        var_4 = 0;
    }
    qword_75D408 = var_4;
    sub_41DD29();
}
 ************ 
Similarity Score (Unixcoder): 0.4410436451435089
Func rank: 94

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: hash_bin_to_hex
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0050BD71 | 55 | push    rbp
0x0050BD72 | 48 89 E5 | mov     rbp, rsp
0x0050BD75 | 48 83 EC 20 | sub     rsp, 20h
0x0050BD79 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0050BD7D | 89 75 E4 | mov     [rbp+var_1C], esi
0x0050BD80 | 8B 55 E4 | mov     edx, [rbp+var_1C]
0x0050BD83 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0050BD87 | 89 D6 | mov     esi, edx
0x0050BD89 | 48 89 C7 | mov     rdi, rax
0x0050BD8C | E8 99 FD FF FF | call    sub_50BB2A
0x0050BD91 | 48 89 45 F8 | mov     [rbp+ptr], rax
0x0050BD95 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x0050BD99 | 0F B7 40 04 | movzx   eax, word ptr [rax+4]
0x0050BD9D | 0F B7 C0 | movzx   eax, ax
0x0050BDA0 | BA 00 00 00 00 | mov     edx, 0
0x0050BDA5 | BE 01 00 00 00 | mov     esi, 1
0x0050BDAA | 89 C7 | mov     edi, eax
0x0050BDAC | E8 E8 EB EF FF | call    sub_40A999
0x0050BDB1 | 89 45 F4 | mov     [rbp+var_C], eax
0x0050BDB4 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x0050BDB7 | 89 C7 | mov     edi, eax
0x0050BDB9 | E8 90 F5 FF FF | call    sub_50B34E
0x0050BDBE | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x0050BDC2 | 8B 10 | mov     edx, [rax]
0x0050BDC4 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x0050BDC8 | 48 8D 48 04 | lea     rcx, [rax+4]
0x0050BDCC | 8B 45 F4 | mov     eax, [rbp+var_C]
0x0050BDCF | 48 89 CE | mov     rsi, rcx
0x0050BDD2 | 89 C7 | mov     edi, eax
0x0050BDD4 | E8 04 F7 FF FF | call    sub_50B4DD
0x0050BDD9 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x0050BDDD | 48 89 C7 | mov     rdi, rax; ptr
0x0050BDE0 | E8 7B A8 EF FF | call    _free
0x0050BDE5 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x0050BDE8 | C9 | leave
0x0050BDE9 | C3 | retn

 Ourput decompiled code:
int FAST_FUNC create_and_connect_stream_or_die(const char *peer, int port)
{
	int fd;
	len_and_sockaddr *lsa;

	lsa = xhost2sockaddr(peer, port);
	fd = xsocket(lsa->u.sa.sa_family, SOCK_STREAM, 0);
	setsockopt_reuseaddr(fd);
	xconnect(fd, &lsa->u.sa, lsa->len);
	free(lsa);
	return fd;
}

## Example:

 Input assembly code:
0x0049A1CE | 55 | push    rbp
0x0049A1CF | 48 89 E5 | mov     rbp, rsp
0x0049A1D2 | 48 83 EC 50 | sub     rsp, 50h
0x0049A1D6 | 48 89 7D B8 | mov     [rbp+var_48], rdi
0x0049A1DA | 89 75 B4 | mov     [rbp+var_4C], esi
0x0049A1DD | 48 8B 45 B8 | mov     rax, [rbp+var_48]
0x0049A1E1 | BE 00 00 00 00 | mov     esi, 0
0x0049A1E6 | 48 89 C7 | mov     rdi, rax
0x0049A1E9 | E8 2D DA 06 00 | call    sub_507C1B
0x0049A1EE | 89 45 FC | mov     [rbp+var_4], eax
0x0049A1F1 | 8B 55 FC | mov     edx, [rbp+var_4]
0x0049A1F4 | 48 8D 45 C0 | lea     rax, [rbp+var_40]
0x0049A1F8 | 89 D6 | mov     esi, edx
0x0049A1FA | 48 89 C7 | mov     rdi, rax
0x0049A1FD | E8 B9 DA 06 00 | call    sub_507CBB
0x0049A202 | 8B 55 B4 | mov     edx, [rbp+var_4C]
0x0049A205 | 48 8D 45 C0 | lea     rax, [rbp+var_40]
0x0049A209 | 89 D6 | mov     esi, edx
0x0049A20B | 48 89 C7 | mov     rdi, rax
0x0049A20E | E8 F3 DA 06 00 | call    sub_507D06
0x0049A213 | C9 | leave
0x0049A214 | C3 | retn

 Ourput decompiled code:
endif
static time_t read_rtc(const char **pp_rtcname, struct timeval *sys_tv, int utc)
{
	struct tm tm_time;
	int fd;

	fd = rtc_xopen(pp_rtcname, O_RDONLY);

	rtc_read_tm(&tm_time, fd);

#if SHOW_HWCLOCK_DIFF
	{
		int before = tm_time.tm_sec;
		while (1) {
			rtc_read_tm(&tm_time, fd);
			gettimeofday(sys_tv, NULL);
			if (before != (int)tm_time.tm_sec)
				break;
		}
	}
#endif

	if (ENABLE_FEATURE_CLEAN_UP)
		close(fd);

	return rtc_tm2time(&tm_time, utc);
}

## Example:

 Input assembly code:
0x00463151 | 55 | push    rbp
0x00463152 | 48 89 E5 | mov     rbp, rsp
0x00463155 | 53 | push    rbx
0x00463156 | 48 83 EC 28 | sub     rsp, 28h
0x0046315A | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0046315E | 89 75 E4 | mov     [rbp+var_1C], esi
0x00463161 | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x00463165 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x00463168 | 83 C0 01 | add     eax, 1
0x0046316B | 48 63 D8 | movsxd  rbx, eax
0x0046316E | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00463172 | 8B 40 68 | mov     eax, [rax+68h]
0x00463175 | 89 C7 | mov     edi, eax
0x00463177 | E8 CA 01 0A 00 | call    sub_503346
0x0046317C | 48 89 C1 | mov     rcx, rax
0x0046317F | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00463183 | 48 89 DA | mov     rdx, rbx
0x00463186 | 48 89 CE | mov     rsi, rcx
0x00463189 | 48 89 C7 | mov     rdi, rax
0x0046318C | E8 2F 4E 0A 00 | call    sub_507FC0
0x00463191 | 90 | nop
0x00463192 | 48 83 C4 28 | add     rsp, 28h
0x00463196 | 5B | pop     rbx
0x00463197 | 5D | pop     rbp
0x00463198 | C3 | retn

 Ourput decompiled code:
static void func_user(char *buf, int size, const procps_status_t *ps)
{
#if 1
	safe_strncpy(buf, get_cached_username(ps->uid), size+1);
#else
	/* "compatible" version, but it's larger */
	/* procps 2.18 shows numeric UID if name overflows the field */
	/* TODO: get_cached_username() returns numeric string if
	 * user has no passwd record, we will display it
	 * left-justified here; too long usernames are shown
	 * as _right-justified_ IDs. Is it worth fixing? */
	const char *user = get_cached_username(ps->uid);
	if (strlen(user) <= size)
		safe_strncpy(buf, user, size+1);
	else
		sprintf(buf, "%*u", size, (unsigned)ps->uid);
#endif
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004CCD81 | 55 | push    rbp
0x004CCD82 | 48 89 E5 | mov     rbp, rsp
0x004CCD85 | 48 83 EC 20 | sub     rsp, 20h
0x004CCD89 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004CCD8D | 89 75 E4 | mov     [rbp+var_1C], esi
0x004CCD90 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004CCD93 | 01 C0 | add     eax, eax
0x004CCD95 | 83 C0 01 | add     eax, 1
0x004CCD98 | 89 C0 | mov     eax, eax
0x004CCD9A | 48 89 C7 | mov     rdi, rax
0x004CCD9D | E8 46 D3 F3 FF | call    sub_40A0E8
0x004CCDA2 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004CCDA6 | 8B 55 E4 | mov     edx, [rbp+var_1C]
0x004CCDA9 | 48 8B 4D E8 | mov     rcx, [rbp+var_18]
0x004CCDAD | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004CCDB1 | 48 89 CE | mov     rsi, rcx
0x004CCDB4 | 48 89 C7 | mov     rdi, rax
0x004CCDB7 | E8 F9 CD F3 FF | call    sub_409BB5
0x004CCDBC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004CCDC0 | C9 | leave
0x004CCDC1 | C3 | retn
 ************ 
Source Code:
static unsigned char *hash_bin_to_hex(unsigned char *hash_value,
				unsigned hash_length)
{
	/* xzalloc zero-terminates */
	char *hex_value = xzalloc((hash_length * 2) + 1);
	bin2hex(hex_value, (char*)hash_value, hash_length);
	return (unsigned char *)hex_value;
}
 ************ 
Parsed Output:
int func(int arg1, int arg2)
{
    int var1 = arg2 + arg2 + 1;
    int var2 = sub_40A0E8(var1);
    int var3 = sub_409BB5(arg1, var2);
    return var3;
}
 ************ 
Similarity Score (Unixcoder): 0.4373875856399536
Func rank: 95

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: do_lzo_decompress
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00508371 | 55 | push    rbp
0x00508372 | 48 89 E5 | mov     rbp, rsp
0x00508375 | 48 83 C4 80 | add     rsp, 0FFFFFFFFFFFFFF80h
0x00508379 | 48 8D 45 80 | lea     rax, [rbp+set]
0x0050837D | 48 89 C7 | mov     rdi, rax; set
0x00508380 | E8 7B ED EF FF | call    _sigemptyset
0x00508385 | 48 8D 45 80 | lea     rax, [rbp+set]
0x00508389 | 48 89 C7 | mov     rdi, rax; set
0x0050838C | E8 7F F1 EF FF | call    _sigsuspend
0x00508391 | 90 | nop
0x00508392 | C9 | leave
0x00508393 | C3 | retn

 Ourput decompiled code:
void FAST_FUNC wait_for_any_sig(void)
{
	sigset_t ss;
	sigemptyset(&ss);
	sigsuspend(&ss);
}

## Example:

 Input assembly code:
0x00507F01 | 55 | push    rbp
0x00507F02 | 48 89 E5 | mov     rbp, rsp
0x00507F05 | 48 81 EC 90 01 00 00 | sub     rsp, 190h
0x00507F0C | 48 8D 85 70 FE FF FF | lea     rax, [rbp+name]
0x00507F13 | 48 89 C7 | mov     rdi, rax; name
0x00507F16 | E8 25 ED EF FF | call    _uname
0x00507F1B | 0F B6 85 B1 FE FF FF | movzx   eax, [rbp+name.nodename]
0x00507F22 | 84 C0 | test    al, al
0x00507F24 | 74 0D | jz      short loc_507F33
0x00507F26 | 48 8D 85 70 FE FF FF | lea     rax, [rbp+name]
0x00507F2D | 48 83 C0 41 | add     rax, 41h ; 'A'
0x00507F31 | EB 05 | jmp     short loc_507F38
0x00507F33 | B8 07 76 53 00 | mov     eax, offset asc_537607; "?"
0x00507F38 | BE 41 00 00 00 | mov     esi, 41h ; 'A'
0x00507F3D | 48 89 C7 | mov     rdi, rax
0x00507F40 | E8 20 22 F0 FF | call    sub_40A165
0x00507F45 | C9 | leave
0x00507F46 | C3 | retn

 Ourput decompiled code:
FAST_FUNC safe_gethostname(void)
{
	struct utsname uts;

	/* The length of the arrays in a struct utsname is unspecified;
	 * the fields are terminated by a null byte.
	 * Note that there is no standard that says that the hostname
	 * set by sethostname(2) is the same string as the nodename field of the
	 * struct returned by uname (indeed, some systems allow a 256-byte host-
	 * name and an 8-byte nodename), but this is true on Linux. The same holds
	 * for setdomainname(2) and the domainname field.
	 */

	/* Uname can fail only if you pass a bad pointer to it. */
	uname(&uts);
	return xstrndup(!uts.nodename[0] ? "?" : uts.nodename, sizeof(uts.nodename));
}

## Example:

 Input assembly code:
0x00436544 | 55 | push    rbp
0x00436545 | 48 89 E5 | mov     rbp, rsp
0x00436548 | 48 83 EC 10 | sub     rsp, 10h
0x0043654C | 48 8D 45 F0 | lea     rax, [rbp+tv]
0x00436550 | BE 00 00 00 00 | mov     esi, 0; tz
0x00436555 | 48 89 C7 | mov     rdi, rax; tv
0x00436558 | E8 63 07 FD FF | call    _gettimeofday
0x0043655D | 48 8B 45 F0 | mov     rax, [rbp+tv.tv_sec]
0x00436561 | 2D 80 81 55 7C | sub     eax, 7C558180h
0x00436566 | 89 C7 | mov     edi, eax; hostlong
0x00436568 | E8 C3 07 FD FF | call    _htonl
0x0043656D | C9 | leave
0x0043656E | C3 | retn

 Ourput decompiled code:
static uint32_t machtime(void)
{
	struct timeval tv;

	gettimeofday(&tv, NULL);
	return htonl((uint32_t)(tv.tv_sec + 2208988800));
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004B363F | 55 | push    rbp
0x004B3640 | 48 89 E5 | mov     rbp, rsp
0x004B3643 | 48 81 EC 30 01 00 00 | sub     rsp, 130h
0x004B364A | E8 AF FA FF FF | call    sub_4B30FE
0x004B364F | 48 8D 85 D0 FE FF FF | lea     rax, [rbp+var_130]
0x004B3656 | 48 89 C7 | mov     rdi, rax
0x004B3659 | E8 81 FE FF FF | call    sub_4B34DF
0x004B365E | 48 8D 85 D0 FE FF FF | lea     rax, [rbp+var_130]
0x004B3665 | 48 89 C7 | mov     rdi, rax
0x004B3668 | E8 86 F7 FF FF | call    sub_4B2DF3
0x004B366D | C9 | leave
0x004B366E | C3 | retn
 ************ 
Source Code:
static smallint do_lzo_decompress(void)
{
	header_t header;

	check_magic();
	p_header(&header);
	return lzo_decompress(&header);
}
 ************ 
Parsed Output:
void func(void)
{
    char var_130[304];
    
    sub_4B30FE();
    
    sub_4B34DF(var_130);
    
    sub_4B2DF3(var_130);
}
 ************ 
Similarity Score (Unixcoder): 0.3977280557155609
Func rank: 96

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: clearredir
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0046D3A8 | 55 | push    rbp
0x0046D3A9 | 48 89 E5 | mov     rbp, rsp
0x0046D3AC | 48 83 EC 10 | sub     rsp, 10h
0x0046D3B0 | 89 7D FC | mov     [rbp+var_4], edi
0x0046D3B3 | 48 8B 05 4E 00 2F 00 | mov     rax, cs:qword_75D408
0x0046D3BA | 8B 40 08 | mov     eax, [rax+8]
0x0046D3BD | 85 C0 | test    eax, eax
0x0046D3BF | 74 14 | jz      short loc_46D3D5
0x0046D3C1 | BE C0 68 52 00 | mov     esi, offset aAlarm_0; "alarm"
0x0046D3C6 | BF A5 68 52 00 | mov     edi, offset aInfoSigSReceiv; "info: sig%s received"
0x0046D3CB | B8 00 00 00 00 | mov     eax, 0
0x0046D3D0 | E8 72 C3 F9 FF | call    sub_409747
0x0046D3D5 | 48 8B 05 2C 00 2F 00 | mov     rax, cs:qword_75D408
0x0046D3DC | C6 40 39 01 | mov     byte ptr [rax+39h], 1
0x0046D3E0 | 90 | nop
0x0046D3E1 | C9 | leave
0x0046D3E2 | C3 | retn

 Ourput decompiled code:
static void sig_alarm_handler(int sig_no UNUSED_PARAM)
{
	if (verbose)
		bb_error_msg(INFO"sig%s received", "alarm");
	rotateasap = 1;
}

## Example:

 Input assembly code:
0x0046D3E3 | 55 | push    rbp
0x0046D3E4 | 48 89 E5 | mov     rbp, rsp
0x0046D3E7 | 48 83 EC 10 | sub     rsp, 10h
0x0046D3EB | 89 7D FC | mov     [rbp+var_4], edi
0x0046D3EE | 48 8B 05 13 00 2F 00 | mov     rax, cs:qword_75D408
0x0046D3F5 | 8B 40 08 | mov     eax, [rax+8]
0x0046D3F8 | 85 C0 | test    eax, eax
0x0046D3FA | 74 14 | jz      short loc_46D410
0x0046D3FC | BE C6 68 52 00 | mov     esi, offset aHangup_0; "hangup"
0x0046D401 | BF A5 68 52 00 | mov     edi, offset aInfoSigSReceiv; "info: sig%s received"
0x0046D406 | B8 00 00 00 00 | mov     eax, 0
0x0046D40B | E8 37 C3 F9 FF | call    sub_409747
0x0046D410 | 48 8B 05 F1 FF 2E 00 | mov     rax, cs:qword_75D408
0x0046D417 | C6 40 3A 01 | mov     byte ptr [rax+3Ah], 1
0x0046D41B | 90 | nop
0x0046D41C | C9 | leave
0x0046D41D | C3 | retn

 Ourput decompiled code:
static void sig_hangup_handler(int sig_no UNUSED_PARAM)
{
	if (verbose)
		bb_error_msg(INFO"sig%s received", "hangup");
	reopenasap = 1;
}

## Example:

 Input assembly code:
0x004EF418 | 55 | push    rbp
0x004EF419 | 48 89 E5 | mov     rbp, rsp
0x004EF41C | 48 83 EC 20 | sub     rsp, 20h
0x004EF420 | 89 7D EC | mov     [rbp+var_14], edi
0x004EF423 | 48 8B 05 D6 DF 26 00 | mov     rax, cs:qword_75D400
0x004EF42A | 8B 00 | mov     eax, [rax]
0x004EF42C | 89 45 FC | mov     [rbp+var_4], eax
0x004EF42F | E8 19 FE FF FF | call    sub_4EF24D
0x004EF434 | 48 8B 05 CD DF 26 00 | mov     rax, cs:qword_75D408
0x004EF43B | C7 40 4C 00 00 00 00 | mov     dword ptr [rax+4Ch], 0
0x004EF442 | BF 01 00 00 00 | mov     edi, 1
0x004EF447 | E8 58 0F 00 00 | call    sub_4F03A4
0x004EF44C | BE 79 F4 4E 00 | mov     esi, offset sub_4EF479; handler
0x004EF451 | BF 14 00 00 00 | mov     edi, 14h; sig
0x004EF456 | E8 15 7C F1 FF | call    _signal
0x004EF45B | BE 00 00 00 00 | mov     esi, 0; handler
0x004EF460 | BF 12 00 00 00 | mov     edi, 12h; sig
0x004EF465 | E8 06 7C F1 FF | call    _signal
0x004EF46A | 48 8B 05 8F DF 26 00 | mov     rax, cs:qword_75D400
0x004EF471 | 8B 55 FC | mov     edx, [rbp+var_4]
0x004EF474 | 89 10 | mov     [rax], edx
0x004EF476 | 90 | nop
0x004EF477 | C9 | leave
0x004EF478 | C3 | retn

 Ourput decompiled code:
static void cont_sig(int sig UNUSED_PARAM)
{
	int save_errno = errno;
	rawmode(); // terminal to "raw"
	last_status_cksum = 0; // force status update
	redraw(TRUE); // re-draw the screen

	signal(SIGTSTP, suspend_sig);
	signal(SIGCONT, SIG_DFL);
	//kill(my_pid, SIGCONT); // huh? why? we are already "continued"...
	errno = save_errno;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00473AA2 | 55 | push    rbp
0x00473AA3 | 48 89 E5 | mov     rbp, rsp
0x00473AA6 | 48 83 EC 10 | sub     rsp, 10h
0x00473AAA | 89 7D FC | mov     [rbp+var_4], edi
0x00473AAD | 48 8B 05 6C 99 2E 00 | mov     rax, cs:qword_75D420
0x00473AB4 | C7 40 20 00 00 00 00 | mov     dword ptr [rax+20h], 0
0x00473ABB | 48 8B 05 5E 99 2E 00 | mov     rax, cs:qword_75D420
0x00473AC2 | 48 8B 40 18 | mov     rax, [rax+18h]
0x00473AC6 | 48 85 C0 | test    rax, rax
0x00473AC9 | 74 11 | jz      short loc_473ADC
0x00473ACB | 8B 45 FC | mov     eax, [rbp+var_4]
0x00473ACE | BE 00 00 00 00 | mov     esi, 0
0x00473AD3 | 89 C7 | mov     edi, eax
0x00473AD5 | E8 99 FE FF FF | call    sub_473973
0x00473ADA | EB D1 | jmp     short loc_473AAD
0x00473ADC | 90 | nop
0x00473ADD | 90 | nop
0x00473ADE | C9 | leave
0x00473ADF | C3 | retn
 ************ 
Source Code:
static void
clearredir(int drop)
{
	for (;;) {
		g_nullredirs = 0;
		if (!redirlist)
			break;
		popredir(drop, /*restore:*/ 0);
	}
}
 ************ 
Parsed Output:
static void func_name(int arg)
{
    int var_4 = arg;
    qword_75D420->field_20 = 0;
    if (qword_75D420->field_18 != NULL)
    {
        sub_473973(var_4);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.39136800169944763
Func rank: 97

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: add_inode
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x0045C4B4 | 55 | push    rbp
0x0045C4B5 | 48 89 E5 | mov     rbp, rsp
0x0045C4B8 | 48 83 EC 20 | sub     rsp, 20h
0x0045C4BC | 48 89 7D E8 | mov     [rbp+s2], rdi
0x0045C4C0 | 48 8B 05 41 0F 30 00 | mov     rax, cs:qword_75D408
0x0045C4C7 | 48 83 C0 18 | add     rax, 18h
0x0045C4CB | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0045C4CF | EB 32 | jmp     short loc_45C503
0x0045C4D1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045C4D5 | 48 8B 00 | mov     rax, [rax]
0x0045C4D8 | 48 8D 50 08 | lea     rdx, [rax+8]
0x0045C4DC | 48 8B 45 E8 | mov     rax, [rbp+s2]
0x0045C4E0 | 48 89 C6 | mov     rsi, rax; s2
0x0045C4E3 | 48 89 D7 | mov     rdi, rdx; s1
0x0045C4E6 | E8 65 AB FA FF | call    _strcmp
0x0045C4EB | 85 C0 | test    eax, eax
0x0045C4ED | 75 09 | jnz     short loc_45C4F8
0x0045C4EF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045C4F3 | 48 8B 00 | mov     rax, [rax]
0x0045C4F6 | EB 51 | jmp     short locret_45C549
0x0045C4F8 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045C4FC | 48 8B 00 | mov     rax, [rax]
0x0045C4FF | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0045C503 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045C507 | 48 8B 00 | mov     rax, [rax]
0x0045C50A | 48 85 C0 | test    rax, rax
0x0045C50D | 75 C2 | jnz     short loc_45C4D1
0x0045C50F | BF 58 00 00 00 | mov     edi, 58h ; 'X'
0x0045C514 | E8 CF DB FA FF | call    sub_40A0E8
0x0045C519 | 48 89 C2 | mov     rdx, rax
0x0045C51C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045C520 | 48 89 10 | mov     [rax], rdx
0x0045C523 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045C527 | 48 8B 00 | mov     rax, [rax]
0x0045C52A | 48 8D 48 08 | lea     rcx, [rax+8]
0x0045C52E | 48 8B 45 E8 | mov     rax, [rbp+s2]
0x0045C532 | BA 0C 00 00 00 | mov     edx, 0Ch; n
0x0045C537 | 48 89 C6 | mov     rsi, rax; src
0x0045C53A | 48 89 CF | mov     rdi, rcx; dest
0x0045C53D | E8 1E A2 FA FF | call    _strncpy
0x0045C542 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045C546 | 48 8B 00 | mov     rax, [rax]
0x0045C549 | C9 | leave
0x0045C54A | C3 | retn

 Ourput decompiled code:
static stats_dev_t *stats_dev_find_or_new(const char *dev_name)
{
	stats_dev_t **curr = &G.stats_dev_list;

	while (*curr != NULL) {
		if (strcmp((*curr)->dname, dev_name) == 0)
			return *curr;
		curr = &(*curr)->next;
	}

	*curr = xzalloc(sizeof(stats_dev_t));
	strncpy((*curr)->dname, dev_name, MAX_DEVICE_NAME);
	return *curr;
}

## Example:

 Input assembly code:
0x0048682E | 55 | push    rbp
0x0048682F | 48 89 E5 | mov     rbp, rsp
0x00486832 | 48 83 EC 30 | sub     rsp, 30h
0x00486836 | 48 89 7D D8 | mov     [rbp+var_28], rdi
0x0048683A | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x0048683E | 48 89 C7 | mov     rdi, rax
0x00486841 | E8 66 FF FF FF | call    sub_4867AC
0x00486846 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0048684A | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0048684E | 48 8B 00 | mov     rax, [rax]
0x00486851 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00486855 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0048685A | 74 67 | jz      short loc_4868C3
0x0048685C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00486860 | 48 8B 40 10 | mov     rax, [rax+10h]
0x00486864 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x00486868 | 48 83 7D E8 00 | cmp     [rbp+var_18], 0
0x0048686D | 75 2F | jnz     short loc_48689E
0x0048686F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00486873 | 48 8B 40 08 | mov     rax, [rax+8]
0x00486877 | 48 89 C7 | mov     rdi, rax; ptr
0x0048687A | E8 E1 FD F7 FF | call    _free
0x0048687F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00486883 | 48 8B 40 18 | mov     rax, [rax+18h]
0x00486887 | 48 85 C0 | test    rax, rax
0x0048688A | 74 56 | jz      short loc_4868E2
0x0048688C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00486890 | 48 8B 40 18 | mov     rax, [rax+18h]
0x00486894 | 48 89 C7 | mov     rdi, rax
0x00486897 | E8 1C B9 FF FF | call    sub_4821B8
0x0048689C | EB 44 | jmp     short loc_4868E2
0x0048689E | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004868A2 | 48 8B 40 20 | mov     rax, [rax+20h]
0x004868A6 | 48 8B 55 F8 | mov     rdx, [rbp+var_8]
0x004868AA | 48 8B 52 08 | mov     rdx, [rdx+8]
0x004868AE | 48 89 10 | mov     [rax], rdx
0x004868B1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004868B5 | 48 8B 50 18 | mov     rdx, [rax+18h]
0x004868B9 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004868BD | 48 89 50 10 | mov     [rax+10h], rdx
0x004868C1 | EB 1F | jmp     short loc_4868E2
0x004868C3 | BF 20 00 00 00 | mov     edi, 20h ; ' '
0x004868C8 | E8 1B 38 F8 FF | call    sub_40A0E8
0x004868CD | 48 89 C2 | mov     rdx, rax
0x004868D0 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004868D4 | 48 89 10 | mov     [rax], rdx
0x004868D7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004868DB | 48 8B 00 | mov     rax, [rax]
0x004868DE | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004868E2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004868E6 | 48 8B 55 D8 | mov     rdx, [rbp+var_28]
0x004868EA | 48 89 50 08 | mov     [rax+8], rdx
0x004868EE | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004868F2 | C9 | leave
0x004868F3 | C3 | retn

 Ourput decompiled code:
static struct function *new_function(char *name)
{
	struct function **funcpp = find_function_slot(name);
	struct function *funcp = *funcpp;

	if (funcp != NULL) {
		struct command *cmd = funcp->parent_cmd;
		debug_printf_exec("func %p parent_cmd %p\n", funcp, cmd);
		if (!cmd) {
			debug_printf_exec("freeing & replacing function '%s'\n", funcp->name);
			free(funcp->name);
			/* Note: if !funcp->body, do not free body_as_string!
			 * This is a special case of "-F name body" function:
			 * body_as_string was not malloced! */
			if (funcp->body) {
				free_pipe_list(funcp->body);
# if !BB_MMU
				free(funcp->body_as_string);
# endif
			}
		} else {
			debug_printf_exec("reinserting in tree & replacing function '%s'\n", funcp->name);
			cmd->argv[0] = funcp->name;
			cmd->group = funcp->body;
# if !BB_MMU
			cmd->group_as_string = funcp->body_as_string;
# endif
		}
	} else {
		debug_printf_exec("remembering new function '%s'\n", name);
		funcp = *funcpp = xzalloc(sizeof(*funcp));
		/*funcp->next = NULL;*/
	}

	funcp->name = name;
	return funcp;
}

## Example:

 Input assembly code:
0x004871D1 | 55 | push    rbp
0x004871D2 | 48 89 E5 | mov     rbp, rsp
0x004871D5 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004871D9 | 48 8B 05 28 62 2D 00 | mov     rax, cs:qword_75D408
0x004871E0 | 48 8B 40 40 | mov     rax, [rax+40h]
0x004871E4 | 48 39 45 E8 | cmp     [rbp+var_18], rax
0x004871E8 | 75 14 | jnz     short loc_4871FE
0x004871EA | 48 8B 05 17 62 2D 00 | mov     rax, cs:qword_75D408
0x004871F1 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x004871F5 | 48 8B 12 | mov     rdx, [rdx]
0x004871F8 | 48 89 50 40 | mov     [rax+40h], rdx
0x004871FC | EB 37 | jmp     short loc_487235
0x004871FE | 48 8B 05 03 62 2D 00 | mov     rax, cs:qword_75D408
0x00487205 | 48 8B 40 40 | mov     rax, [rax+40h]
0x00487209 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0048720D | EB 0B | jmp     short loc_48721A
0x0048720F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00487213 | 48 8B 00 | mov     rax, [rax]
0x00487216 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0048721A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048721E | 48 8B 00 | mov     rax, [rax]
0x00487221 | 48 39 45 E8 | cmp     [rbp+var_18], rax
0x00487225 | 75 E8 | jnz     short loc_48720F
0x00487227 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0048722B | 48 8B 10 | mov     rdx, [rax]
0x0048722E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00487232 | 48 89 10 | mov     [rax], rdx
0x00487235 | 48 8B 05 CC 61 2D 00 | mov     rax, cs:qword_75D408
0x0048723C | 48 8B 40 40 | mov     rax, [rax+40h]
0x00487240 | 48 85 C0 | test    rax, rax
0x00487243 | 74 1A | jz      short loc_48725F
0x00487245 | 48 8B 05 BC 61 2D 00 | mov     rax, cs:qword_75D408
0x0048724C | 48 8B 50 40 | mov     rdx, [rax+40h]
0x00487250 | 48 8B 05 B1 61 2D 00 | mov     rax, cs:qword_75D408
0x00487257 | 8B 52 14 | mov     edx, [rdx+14h]
0x0048725A | 89 50 38 | mov     [rax+38h], edx
0x0048725D | EB 0E | jmp     short loc_48726D
0x0048725F | 48 8B 05 A2 61 2D 00 | mov     rax, cs:qword_75D408
0x00487266 | C7 40 38 00 00 00 00 | mov     dword ptr [rax+38h], 0
0x0048726D | 90 | nop
0x0048726E | 5D | pop     rbp
0x0048726F | C3 | retn

 Ourput decompiled code:
static void remove_bg_job(struct pipe *pi)
{
	struct pipe *prev_pipe;

	if (pi == G.job_list) {
		G.job_list = pi->next;
	} else {
		prev_pipe = G.job_list;
		while (prev_pipe->next != pi)
			prev_pipe = prev_pipe->next;
		prev_pipe->next = pi->next;
	}
	if (G.job_list)
		G.last_jobid = G.job_list->jobid;
	else
		G.last_jobid = 0;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0045B484 | 55 | push    rbp
0x0045B485 | 48 89 E5 | mov     rbp, rsp
0x0045B488 | 48 83 EC 20 | sub     rsp, 20h
0x0045B48C | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0045B490 | 48 C7 45 F8 00 B4 75 00 | mov     [rbp+var_8], offset dest.c_cflag
0x0045B498 | EB 3A | jmp     short loc_45B4D4
0x0045B49A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B49E | 48 8B 00 | mov     rax, [rax]
0x0045B4A1 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x0045B4A5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0045B4A9 | 48 8B 00 | mov     rax, [rax]
0x0045B4AC | 48 39 C2 | cmp     rdx, rax
0x0045B4AF | 75 18 | jnz     short loc_45B4C9
0x0045B4B1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B4B5 | 48 8B 00 | mov     rax, [rax]
0x0045B4B8 | 48 8B 50 08 | mov     rdx, [rax+8]
0x0045B4BC | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0045B4C0 | 48 8B 40 08 | mov     rax, [rax+8]
0x0045B4C4 | 48 39 C2 | cmp     rdx, rax
0x0045B4C7 | 74 52 | jz      short loc_45B51B
0x0045B4C9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B4CD | 48 8B 00 | mov     rax, [rax]
0x0045B4D0 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0045B4D4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B4D8 | 48 8B 00 | mov     rax, [rax]
0x0045B4DB | 48 85 C0 | test    rax, rax
0x0045B4DE | 75 BA | jnz     short loc_45B49A
0x0045B4E0 | BF 18 00 00 00 | mov     edi, 18h
0x0045B4E5 | E8 FE EB FA FF | call    sub_40A0E8
0x0045B4EA | 48 89 C2 | mov     rdx, rax
0x0045B4ED | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B4F1 | 48 89 10 | mov     [rax], rdx
0x0045B4F4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B4F8 | 48 8B 00 | mov     rax, [rax]
0x0045B4FB | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x0045B4FF | 48 8B 12 | mov     rdx, [rdx]
0x0045B502 | 48 89 50 10 | mov     [rax+10h], rdx
0x0045B506 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B50A | 48 8B 00 | mov     rax, [rax]
0x0045B50D | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x0045B511 | 48 8B 52 08 | mov     rdx, [rdx+8]
0x0045B515 | 48 89 50 08 | mov     [rax+8], rdx
0x0045B519 | EB 01 | jmp     short locret_45B51C
0x0045B51B | 90 | nop
0x0045B51C | C9 | leave
0x0045B51D | C3 | retn
 ************ 
Source Code:
static void add_inode(const struct stat *st)
{
	inode_list **curr = &G.inode_list_head;

	while (*curr) {
		if ((*curr)->dev == st->st_dev
		 && (*curr)->inode == st->st_ino
		) {
			return;
		}
		curr = &(*curr)->next;
	}

	*curr = xzalloc(sizeof(inode_list));
	(*curr)->dev = st->st_dev;
	(*curr)->inode = st->st_ino;
}
 ************ 
Parsed Output:
static void update_c_cflag(struct termios *term)
{
    if (term->c_cflag & CLOCAL) {
        term->c_cflag &= ~CLOCAL;
    }
    if (term->c_cflag & CREAD) {
        term->c_cflag &= ~CREAD;
    }
}
 ************ 
Similarity Score (Unixcoder): 0.3782278895378113
Func rank: 98

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: arith
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x004DC8ED | 55 | push    rbp
0x004DC8EE | 48 89 E5 | mov     rbp, rsp
0x004DC8F1 | 48 83 EC 10 | sub     rsp, 10h
0x004DC8F5 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004DC8F9 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004DC8FD | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004DC901 | 48 89 C7 | mov     rdi, rax
0x004DC904 | E8 83 FF FF FF | call    sub_4DC88C
0x004DC909 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004DC90D | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x004DC911 | 48 89 50 10 | mov     [rax+10h], rdx
0x004DC915 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004DC919 | 48 89 C7 | mov     rdi, rax
0x004DC91C | E8 EA 26 00 00 | call    sub_4DF00B
0x004DC921 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004DC925 | C9 | leave
0x004DC926 | C3 | retn

 Ourput decompiled code:
static var *setvar_p(var *v, char *value)
{
	clrvar(v);
	v->string = value;
	handle_special(v);
	return v;
}

## Example:

 Input assembly code:
0x0046F33E | 55 | push    rbp
0x0046F33F | 48 89 E5 | mov     rbp, rsp
0x0046F342 | 48 83 EC 10 | sub     rsp, 10h
0x0046F346 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0046F34A | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x0046F34E | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0046F352 | 48 8B 10 | mov     rdx, [rax]
0x0046F355 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0046F359 | 48 8B 00 | mov     rax, [rax]
0x0046F35C | 48 89 D6 | mov     rsi, rdx
0x0046F35F | 48 89 C7 | mov     rdi, rax
0x0046F362 | E8 EC FE FF FF | call    sub_46F253
0x0046F367 | C9 | leave
0x0046F368 | C3 | retn

 Ourput decompiled code:
static int
vpcmp(const void *a, const void *b)
{
	return varcmp(*(const char **)a, *(const char **)b);
}

## Example:

 Input assembly code:
0x004CFA97 | 55 | push    rbp
0x004CFA98 | 48 89 E5 | mov     rbp, rsp
0x004CFA9B | 48 83 EC 10 | sub     rsp, 10h
0x004CFA9F | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004CFAA3 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004CFAA7 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004CFAAB | BA 00 00 00 00 | mov     edx, 0
0x004CFAB0 | BE 00 00 00 00 | mov     esi, 0
0x004CFAB5 | 48 89 C7 | mov     rdi, rax
0x004CFAB8 | E8 6E C3 F3 FF | call    sub_40BE2B
0x004CFABD | 48 89 C2 | mov     rdx, rax
0x004CFAC0 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004CFAC4 | 48 89 10 | mov     [rax], rdx
0x004CFAC7 | 90 | nop
0x004CFAC8 | C9 | leave
0x004CFAC9 | C3 | retn

 Ourput decompiled code:
static void FAST_FUNC conv_strtoll(const char *arg, void *result)
{
	*(long long*)result = bb_strtoll(arg, NULL, 0);
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0048B66A | 55 | push    rbp
0x0048B66B | 48 89 E5 | mov     rbp, rsp
0x0048B66E | 48 83 EC 10 | sub     rsp, 10h
0x0048B672 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0048B676 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x0048B67A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B67E | 48 C7 00 00 00 00 00 | mov     qword ptr [rax], 0
0x0048B685 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B689 | 48 C7 40 18 00 00 00 00 | mov     qword ptr [rax+18h], 0
0x0048B691 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x0048B695 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0048B699 | 48 89 D6 | mov     rsi, rdx
0x0048B69C | 48 89 C7 | mov     rdi, rax
0x0048B69F | E8 F3 FA FF FF | call    sub_48B197
0x0048B6A4 | C9 | leave
0x0048B6A5 | C3 | retn
 ************ 
Source Code:
arith_t FAST_FUNC
arith(arith_state_t *math_state, const char *expr)
{
	math_state->errmsg = NULL;
	math_state->list_of_recursed_names = NULL;
	return evaluate_string(math_state, expr);
}
 ************ 
Parsed Output:
static void initialize_struct(var *v)
{
    v->field1 = 0;
    v->field2 = 0;
    v->field3 = 0;
    handle_special(v);
}
 ************ 
Similarity Score (Unixcoder): 0.33488374948501587
Func rank: 99

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: rc_get_bit
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Few-shot examples

I will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.



## Example:

 Input assembly code:
0x00497671 | 55 | push    rbp
0x00497672 | 48 89 E5 | mov     rbp, rsp
0x00497675 | 48 83 EC 20 | sub     rsp, 20h
0x00497679 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0049767D | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00497681 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00497685 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00497689 | 48 89 D6 | mov     rsi, rdx
0x0049768C | 48 89 C7 | mov     rdi, rax
0x0049768F | E8 29 EC FF FF | call    sub_4962BD
0x00497694 | 89 45 FC | mov     [rbp+var_4], eax
0x00497697 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x0049769B | 8B 45 FC | mov     eax, [rbp+var_4]
0x0049769E | 48 89 D6 | mov     rsi, rdx
0x004976A1 | 89 C7 | mov     edi, eax
0x004976A3 | E8 65 FE FF FF | call    sub_49750D
0x004976A8 | 89 45 FC | mov     [rbp+var_4], eax
0x004976AB | 83 7D FC FF | cmp     [rbp+var_4], 0FFFFFFFFh
0x004976AF | 75 10 | jnz     short loc_4976C1
0x004976B1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004976B5 | 66 C7 00 00 00 | mov     word ptr [rax], 0
0x004976BA | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004976C1 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004976C4 | C9 | leave
0x004976C5 | C3 | retn

 Ourput decompiled code:
static int add_zone(uint16_t *znr, smallint *corrected)
{
	int block;

	block = check_zone_nr(znr, corrected);
	block = add_zone_common(block, corrected);
	if (block == -1) {
		*znr = 0;
		block = 0;
	}
	return block;
}

## Example:

 Input assembly code:
0x004976C6 | 55 | push    rbp
0x004976C7 | 48 89 E5 | mov     rbp, rsp
0x004976CA | 48 83 EC 20 | sub     rsp, 20h
0x004976CE | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004976D2 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004976D6 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x004976DA | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004976DE | 48 89 D6 | mov     rsi, rdx
0x004976E1 | 48 89 C7 | mov     rdi, rax
0x004976E4 | E8 E9 EA FF FF | call    sub_4961D2
0x004976E9 | 89 45 FC | mov     [rbp+var_4], eax
0x004976EC | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x004976F0 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004976F3 | 48 89 D6 | mov     rsi, rdx
0x004976F6 | 89 C7 | mov     edi, eax
0x004976F8 | E8 10 FE FF FF | call    sub_49750D
0x004976FD | 89 45 FC | mov     [rbp+var_4], eax
0x00497700 | 83 7D FC FF | cmp     [rbp+var_4], 0FFFFFFFFh
0x00497704 | 75 11 | jnz     short loc_497717
0x00497706 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0049770A | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x00497710 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x00497717 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0049771A | C9 | leave
0x0049771B | C3 | retn

 Ourput decompiled code:
if ENABLE_FEATURE_MINIX2
static int add_zone2(uint32_t *znr, smallint *corrected)
{
	int block;

	block = check_zone_nr2(znr, corrected);
	block = add_zone_common(block, corrected);
	if (block == -1) {
		*znr = 0;
		block = 0;
	}
	return block;
}

## Example:

 Input assembly code:
0x004317A8 | 55 | push    rbp
0x004317A9 | 48 89 E5 | mov     rbp, rsp
0x004317AC | 48 83 EC 30 | sub     rsp, 30h
0x004317B0 | 48 89 7D E8 | mov     [rbp+s1], rdi
0x004317B4 | 48 89 75 E0 | mov     [rbp+s2], rsi
0x004317B8 | 48 89 55 D8 | mov     [rbp+n], rdx
0x004317BC | 48 8B 55 D8 | mov     rdx, [rbp+n]; n
0x004317C0 | 48 8B 4D E0 | mov     rcx, [rbp+s2]
0x004317C4 | 48 8B 45 E8 | mov     rax, [rbp+s1]
0x004317C8 | 48 89 CE | mov     rsi, rcx; s2
0x004317CB | 48 89 C7 | mov     rdi, rax; s1
0x004317CE | E8 CD 4F FD FF | call    _strncmp
0x004317D3 | 89 45 FC | mov     [rbp+var_4], eax
0x004317D6 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004317DA | 75 15 | jnz     short loc_4317F1
0x004317DC | 48 8B 55 E0 | mov     rdx, [rbp+s2]
0x004317E0 | 48 8B 45 D8 | mov     rax, [rbp+n]
0x004317E4 | 48 01 D0 | add     rax, rdx
0x004317E7 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004317EA | 0F B6 C0 | movzx   eax, al
0x004317ED | F7 D8 | neg     eax
0x004317EF | EB 03 | jmp     short locret_4317F4
0x004317F1 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004317F4 | C9 | leave
0x004317F5 | C3 | retn

 Ourput decompiled code:
static int strncmpz(const char *l, const char *r, size_t llen)
{
	int i = strncmp(l, r, llen);

	if (i == 0)
		return - (unsigned char)r[llen];
	return i;
}
# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004BB517 | 55 | push    rbp
0x004BB518 | 48 89 E5 | mov     rbp, rsp
0x004BB51B | 48 83 EC 30 | sub     rsp, 30h
0x004BB51F | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004BB523 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004BB527 | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x004BB52B | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x004BB52F | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004BB533 | 48 89 D6 | mov     rsi, rdx
0x004BB536 | 48 89 C7 | mov     rdi, rax
0x004BB539 | E8 02 FF FF FF | call    sub_4BB440
0x004BB53E | 89 45 FC | mov     [rbp+var_4], eax
0x004BB541 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004BB545 | 8B 00 | mov     eax, [rax]
0x004BB547 | 8D 14 00 | lea     edx, [rax+rax]
0x004BB54A | 8B 45 FC | mov     eax, [rbp+var_4]
0x004BB54D | 01 C2 | add     edx, eax
0x004BB54F | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004BB553 | 89 10 | mov     [rax], edx
0x004BB555 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004BB558 | C9 | leave
0x004BB559 | C3 | retn
 ************ 
Source Code:
static speed_inline int rc_get_bit(rc_t *rc, uint16_t *p, int *symbol)
{
	int ret = rc_is_bit_1(rc, p);
	*symbol = *symbol * 2 + ret;
	return ret;
}
 ************ 
Parsed Output:
static void update_value(int *ptr, int value)
{
    int *temp = ptr;
    int *temp2 = ptr;
    int *temp3 = ptr;
    int *temp4 = ptr;
    int *temp5 = ptr;
    int *temp6 = ptr;
    int *temp7 = ptr;
    int *temp8 = ptr;
    int *temp9 = ptr;
    int *temp10 = ptr;
    int *temp11 = ptr;
    int *temp12 = ptr;
    int *temp13 = ptr;
    int *temp14 = ptr;
    int *temp15 = ptr;
    int *temp16 = ptr;
    int *temp17 = ptr;
    int *temp18 = ptr;
    int *temp19 = ptr;
    int *temp20 = ptr;
    int *temp21 = ptr;
    int *temp22 = ptr;
    int *temp23 = ptr;
    int *temp24 = ptr;
    int *temp25 = ptr;
    int *temp26 = ptr;
    int *temp27 = ptr;
    int *temp28 = ptr;
    int *temp29 = ptr;
    int *temp30 = ptr;
    int *temp31 = ptr;
    int *temp32 = ptr;
    int *temp33 = ptr;
    int *temp34 = ptr;
    int *temp35 = ptr;
    int *temp36 = ptr;
    int *temp37 = ptr;
    int *temp38 = ptr;
    int *temp39 = ptr;
    int *temp40 = ptr;
    int *temp41 = ptr;
    int *temp42 = ptr;
    int *temp43 = ptr;
    int *temp44 = ptr;
    int *temp45 = ptr;
    int *temp46 = ptr;
    int *temp47 = ptr;
    int *temp48 = ptr;
    int *temp49 = ptr;
    int *temp50 = ptr;
    int *temp51 = ptr;
    int *temp52 = ptr;
    int *temp53 = ptr;
    int *temp54 = ptr;
    int *temp55 = ptr;
    int *temp56 = ptr;
    int *temp57 = ptr;
    int *temp58 = ptr;
    int *temp59 = ptr;
    int *temp60 = ptr;
    int *temp61 = ptr;
    int *temp62 = ptr;
    int *temp63 = ptr;
    int *temp64 = ptr;
    int *temp65 = ptr;
    int *temp66 = ptr;
    int *temp67 = ptr;
    int *temp68 = ptr;
    int *temp69 = ptr;
    int *temp70 = ptr;
    int *temp71 = ptr;
    int *temp72 = ptr;
    int *temp73 = ptr;
    int *temp74 = ptr;
    int *temp75 = ptr;
    int *temp76 = ptr;
    int *temp77 = ptr;
    int *temp78 = ptr;
    int *temp79 = ptr;
    int *temp80 = ptr;
    int *temp81 = ptr;
    int *temp82 = ptr;
    int *temp83 = ptr;
    int *temp84 = ptr;
    int *temp85 = ptr;
    int *temp86 = ptr;
    int *temp87 = ptr;
    int *temp88 = ptr;
    int *temp89 = ptr;
    int *temp90 = ptr;
    int *temp91 = ptr;
    int *temp92 = ptr;
    int *temp93 = ptr;
    int *temp94 = ptr;
    int *temp95 = ptr;
    int *temp96 = ptr;
    int *temp97 = ptr;
    int *temp98 = ptr;
    int *temp99 = ptr;
    int *temp100 = ptr;
    int *temp101 = ptr;
    int *temp102 = ptr;
    int *temp103 = ptr;
    int *temp104 = ptr;
    int *temp105 = ptr;
    int *temp106 = ptr;
    int *temp107 = ptr;
    int *temp108 = ptr;
    int *temp109 = ptr;
    int *temp110 = ptr;
    int *temp111 = ptr;
    int *temp112 = ptr;
    int *temp113 = ptr;
    int *temp114 = ptr;
    int *temp115 = ptr;
    int *temp116 = ptr;
    int *temp117 = ptr;
    int *temp118 = ptr;
    int *temp119 = ptr;
    int *temp120 = ptr;
    int *temp121 = ptr;
    int *temp122 = ptr;
    int *temp123 = ptr;
    int *temp124 = ptr;
    int *temp125 = ptr;
    int *temp126 = ptr;
    int *temp127 = ptr;
    int *temp128 = ptr;
    int *temp129 = ptr;
    int *temp130 = ptr;
    int *temp131 = ptr;
    int *temp132 = ptr;
    int *temp133 = ptr;
    int *temp134 = ptr;
    int *temp135 = ptr;
    int *temp136 = ptr;
    int *temp137 = ptr;
    int *temp138 = ptr;
    int *temp139 = ptr;
    int *temp140 = ptr;
    int *temp141 = ptr;
    int *temp142 = ptr;
    int *temp143 = ptr;
    int *temp144 = ptr;
    int *temp145 = ptr;
    int *temp146 = ptr;
    int *temp147 = ptr;
    int *temp148 = ptr;
    int *temp149 = ptr;
    int *temp150 = ptr;
    int *temp151 = ptr;
    int *temp152 = ptr;
    int *temp153 = ptr;
    int *temp154 = ptr;
    int *temp155 = ptr;
    int *temp156 = ptr;
    int *temp157 = ptr;
    int *temp158 = ptr;
    int *temp159 = ptr;
    int *temp160 = ptr;
    int *temp161 = ptr;
    int *temp162 = ptr;
    int *temp163 = ptr;
    int *temp164 = ptr;
    int *temp165 = ptr;
    int *temp166 = ptr;
    int *temp167 = ptr;
    int *temp168 = ptr;
    int *temp169 = ptr;
    int *temp170 = ptr;
    int *temp171 = ptr;
    int *temp172 = ptr;
    int *temp173 = ptr;
    int *temp174 = ptr;
    int *temp175 = ptr;
    int *temp176 = ptr;
    int *temp177 = ptr;
    int *temp178 = ptr;
    int *temp179 = ptr;
    int *temp180 = ptr;
    int *temp181 = ptr;
    int *temp182 = ptr;
    int *temp183 = ptr;
    int *temp184 = ptr;
    int *temp185 = ptr;
    int *temp186 = ptr;
    int *temp187 = ptr;
    int *temp188 = ptr;
    int *temp189 = ptr;
    int *temp190 = ptr;
    int *temp191 = ptr;
    int *temp192 = ptr;
    int *temp193 = ptr;
    int *temp194 = ptr;
    int *temp195 = ptr;
    int *temp196 = ptr;
    int *temp197 = ptr;
    int *temp198 = ptr;
    int *temp199 = ptr;
    int *temp200 = ptr;
    int *temp201 = ptr;
    int *temp202 = ptr;
    int *temp203 = ptr;
    int *temp204 = ptr;
    int *temp205 = ptr;
    int *temp206 = ptr;
    int *temp207 = ptr;
    int *temp208 = ptr;
    int *temp209 = ptr;
    int *temp210 = ptr;
    int *temp211 = ptr;
    int *temp212 = ptr;
    int *temp213 = ptr;
    int *temp214 = ptr;
    int *temp215 = ptr;
    int *temp216 = ptr;
    int *temp217 = ptr;
    int *temp218 = ptr;
    int *temp219 = ptr;
    int *temp220 = ptr;
    int *temp221 = ptr;
    int *temp222 = ptr;
    int *temp223 = ptr;
    int *temp224 = ptr;
    int *temp225 = ptr;
    int *temp226 = ptr;
    int *temp227 = ptr;
    int *temp228 = ptr;
    int *temp229 = ptr;
    int *temp230 = ptr;
    int *temp231 = ptr;
    int *temp232 = ptr;
    int *temp233 = ptr;
    int *temp234 = ptr;
    int *temp235 = ptr;
    int *temp236 = ptr;
    int *temp237 = ptr;
    int *temp238 = ptr;
    int *temp239 = ptr;
    int *temp240 = ptr;
    int *temp241 = ptr;
    int *temp242 = ptr;
    int *temp243 = ptr;
    int *temp244 = ptr;
    int *temp245 = ptr;
    int *temp246 = ptr;
    int *temp247 = ptr;
    int *temp248 = ptr;
    int *temp249 = ptr;
    int *temp250 = ptr;
    int *temp251 = ptr;
    int *temp252 = ptr;
    int *temp253 = ptr;
    int *temp254 = ptr;
    int *temp255 = ptr;
    int *temp256 = ptr;
    int *temp257 = ptr;
    int *temp258 = ptr;
    int *temp259 = ptr;
    int *temp260 = ptr;
    int *temp261 = ptr;
    int *temp262 = ptr;
    int *temp263 = ptr;
    int *temp264 = ptr;
    int *temp265 = ptr;
    int *temp266 = ptr;
    int *temp267 = ptr;
    int *temp268 = ptr;
    int *temp269 = ptr;
    int *temp270 = ptr;
    int *temp271 = ptr;
    int *temp272 = ptr;
    int *temp273 = ptr;
    int *temp274 = ptr;
    int *temp275 = ptr;
    int *temp276 = ptr;
    int *temp277 = ptr;
    int *temp278 = ptr;
    int *temp279 = ptr;
    int *temp280 = ptr;
    int *temp281 = ptr;
    int *temp282 = ptr;
    int *temp283 = ptr;
    int *temp284 = ptr;
    int *temp285 = ptr;
    int *temp286 = ptr;
    int *temp287 = ptr;
    int *temp288 = ptr;
    int *temp289 = ptr;
    int *temp290 = ptr;
    int *temp291 = ptr;
    int *temp292 = ptr;
    int *temp293 = ptr;
    int *temp294 = ptr;
    int *temp295 = ptr;
    int *temp296 = ptr;
    int *temp297 = ptr;
    int *temp298 = ptr;
    int *temp299 = ptr;
    int *temp300 = ptr;
    int *temp301 = ptr;
    int *temp302 = ptr;
    int *temp303 = ptr;
    int *temp304 = ptr;
    int *temp305 = ptr;
    int *temp306 = ptr;
    int *temp307 = ptr;
    int *temp308 = ptr;
    int *temp309 = ptr;
    int *temp310 = ptr;
    int *temp311 = ptr;
    int *temp312 = ptr;
    int *temp313 = ptr;
    int *temp314 = ptr;
    int *temp315 = ptr;
    int *temp316 = ptr;
    int *temp317 = ptr;
    int *temp318 = ptr;
    int *temp319 = ptr;
    int *temp320 = ptr;
    int *temp321 = ptr;
    int *temp322 = ptr;
    int *temp323 = ptr;
    int *temp324 = ptr;
    int *temp325 = ptr;
    int *temp326 = ptr;
    int *temp327 = ptr;
    int *temp328 = ptr;
    int *temp329 = ptr;
    int *temp330 = ptr;
    int *temp331 = ptr;
    int *temp332 = ptr;
    int *temp333 = ptr;
    int *temp334 = ptr;
    int *temp335 = ptr;
    int *temp336 = ptr;
    int *temp337 = ptr;
    int *temp338 = ptr;
    int *temp339 = ptr;
    int *temp340 = ptr;
    int *temp341 = ptr;
    int *temp342 = ptr;
    int *temp343 = ptr;
    int *temp344 = ptr;
    int *temp345 = ptr;
    int *temp346 = ptr;
    int *temp347 = ptr;
    int *temp348 = ptr;
    int *temp349 = ptr;
    int *temp350 = ptr;
    int *temp351 = ptr;
    int *temp352 = ptr;
    int *temp353 = ptr;
    int *temp354 = ptr;
    int *temp355 = ptr;
    int *temp356 = ptr;
    int *temp357 = ptr;
    int *temp358 = ptr;
    int *temp359 = ptr;
    int *temp360 = ptr;
    int *temp361 = ptr;
    int *temp362 = ptr;
    int *temp363 = ptr;
    int *temp364 = ptr;
    int *temp365 = ptr;
    int *temp366 = ptr;
    int *temp367 = ptr;
    int *temp368 = ptr;
    int *temp369 = ptr;
    int *temp370 = ptr;
    int *temp371 = ptr;
    int *temp372 = ptr;
    int *temp373 = ptr;
    int *temp374 = ptr;
    int *temp375 = ptr;
    int *temp376 = ptr;
    int *temp377 = ptr;
    int *temp378 = ptr;
    int *temp379 = ptr;
    int *temp380 = ptr;
    int *temp381 = ptr;
    int *temp382 = ptr;
    int *temp383 = ptr;
    int *temp384 = ptr;
    int *temp385 = ptr;
    int *temp386 = ptr;
    int *temp387 = ptr;
    int *temp388 = ptr;
    int *temp389 = ptr;
    int *temp390 = ptr;
    int *temp391 = ptr;
    int *temp392 = ptr;
    int *temp393 = ptr;
    int *temp394 = ptr;
    int *temp395 = ptr;
    int *temp396 = ptr;
    int *temp397 = ptr;
    int *temp398 = ptr;
    int *temp399 = ptr;
    int *temp400 = ptr;
    int *temp401 = ptr;
    int *temp402 = ptr;
    int *temp403 = ptr;
    int *temp404 = ptr;
    int *temp405 = ptr;
    int *temp406 = ptr;
    int *temp407 = ptr;
    int *temp408 = ptr;
    int *temp409 = ptr;
    int *temp410 = ptr;
    int *temp411 = ptr;
    int *temp412 = ptr;
    int *temp413 = ptr;
    int *temp414 = ptr;
    int *temp415 = ptr;
    int *temp416 = ptr;
    int *temp417 = ptr;
    int *temp418 = ptr;
    int *temp419 = ptr;
    int *temp420 = ptr;
    int *temp421 = ptr;
    int *temp422 = ptr;
    int *temp423 = ptr;
    int *temp424 = ptr;
    int *temp425 = ptr;
    int *temp426 = ptr;
    int *temp427 = ptr;
    int *temp428 = ptr;
    int *temp429 = ptr;
    int *temp430 = ptr;
    int *temp431 = ptr;
    int *temp432 = ptr;
    int *temp433 = ptr;
    int *temp434 = ptr;
    int *temp435 = ptr;
    int *temp436 = ptr;
    int *temp437 = ptr;
    int *temp438 = ptr;
    int *temp439 = ptr;
    int *temp440 = ptr;
    int *temp441 = ptr;
    int *temp442 = ptr;
    int *temp443 = ptr;
    int *temp444 = ptr;
    int *temp445 = ptr;
    int *temp446 = ptr;
    int *temp447 = ptr;
    int *temp448 = ptr;
    int *temp449 = ptr;
    int *temp450 = ptr;
    int *temp451 = ptr;
    int *temp452 = ptr;
    int *temp453 = ptr;
    int *temp454 = ptr;
    int *temp455 = ptr;
    int *temp456 = ptr;
    int *temp457 = ptr;
    int *temp458 = ptr;
    int *temp459 = ptr;
    int *temp460 = ptr;
    int *temp461 = ptr;
    int *temp462 = ptr;
    int *temp463 = ptr;
    int *temp464 = ptr;
    int *temp465 = ptr;
    int *temp466 = ptr;
    int *temp467 = ptr;
    int *temp468 = ptr;
    int *temp469 = ptr;
    int *temp470 = ptr;
    int *temp471 = ptr;
    int *temp472 = ptr;
    int *temp473 = ptr;
    int *temp474 = ptr;
    int *temp475 = ptr;
    int *temp476 = ptr;
    int *temp477 = ptr;
    int *temp478 = ptr;
    int *temp479 = ptr;
    int *temp480 = ptr;
    int *temp481 = ptr;
    int *temp482 = ptr;
    int *temp483 = ptr;
    int *temp484 = ptr;
    int *temp485 = ptr;
    int *temp486 = ptr;
    int *temp487 = ptr;
    int *temp488 = ptr;
    int *temp489 = ptr;
    int *temp490 = ptr;
    int *temp491 = ptr;
    int *temp492 = ptr;
    int *temp493 = ptr;
    int *temp494 = ptr;
    int *temp495 = ptr;
    int *temp496 = ptr;
    int *temp497 = ptr;
    int *temp498 = ptr;
    int *temp499 = ptr;
    int *temp500 = ptr;
    int *temp501 = ptr;
    int *temp502 = ptr;
    int *temp503 = ptr;
    int *temp504 = ptr;
    int *temp505 = ptr;
    int *temp506 = ptr;
    int *temp507 = ptr;
    int *temp508 = ptr;
    int *temp509 = ptr;
    int *temp510 = ptr;
    int *temp511 = ptr;
    int *temp512 = ptr;
    int *temp513 = ptr;
    int *temp514 = ptr;
    int *temp515 = ptr;
    int *temp516 = ptr;
    int *temp517 = ptr;
    int *temp518 = ptr;
    int *temp519 = ptr;
    int *temp520 = ptr;
    int *temp521 = ptr;
    int *temp522 = ptr;
    int *temp523 = ptr;
    int *temp524 = ptr;
    int *temp525 = ptr;
    int *temp526 = ptr;
    int *temp527 = ptr;
    int *temp528 = ptr;
    int *temp529 = ptr;
    int *temp530 = ptr;
    int *temp531 = ptr;
    int *temp532 = ptr;
    int *temp533 = ptr;
    int *temp534 = ptr;
    int *temp535 = ptr;
    int *temp536 = ptr;
    int *temp537 = ptr;
    int *temp538 = ptr;
    int *temp539 = ptr;
    int *temp540 = ptr;
    int *temp541 = ptr;
    int *temp542 = ptr;
    int *temp543 = ptr;
    int *temp544 = ptr;
    int *temp545 = ptr;
    int *temp546 = ptr;
    int *temp547 = ptr;
    int *temp548 = ptr;
    int *temp549 = ptr;
    int *temp550 = ptr;
    int *temp551 = ptr;
    int *temp552 = ptr;
    int *temp553 = ptr;
    int *temp554 = ptr;
    int *temp555 = ptr;
    int *temp556 = ptr;
    int *temp557 = ptr;
    int *temp558 = ptr;
    int *temp559 = ptr;
    int *temp560 = ptr;
    int *temp561 = ptr;
    int *temp562 = ptr;
    int *temp563 = ptr;
    int *temp564 = ptr;
    int *temp565 = ptr;
    int *temp566 = ptr;
    int *temp567 = ptr;
    int *temp568 = ptr;
    int *temp569 = ptr;
    int *temp570 = ptr;
    int *temp571 = ptr;
    int *temp572 = ptr;
    int *temp573 = ptr;
    int *temp574 = ptr;
    int *temp575 = ptr;
    int *temp576 = ptr;
    int *temp577 = ptr;
    int *temp578 = ptr;
    int *temp579 = ptr;
    int *temp580 = ptr;
    int *temp581 = ptr;
    int *temp582 = ptr;
    int *temp583 = ptr;
    int *temp584 = ptr;
    int *temp585 = ptr;
    int *temp586 = ptr;
    int *temp587 = ptr;
    int *temp588 = ptr;
    int *temp589 = ptr;
    int *temp590 = ptr;
    int *temp591 = ptr;
    int *temp592 = ptr;
    int *temp593 = ptr;
    int *temp594 = ptr;
    int *temp595 = ptr;
    int *temp596 = ptr;
    int *temp597 = ptr;
    int *temp598 = ptr;
    int *temp599 = ptr;
    int *temp600 = ptr;
    int *temp601 = ptr;
    int *temp602 = ptr;
    int *temp603 = ptr;
    int *temp604 = ptr;
    int *temp605 = ptr;
    int *temp606 = ptr;
    int *temp607 = ptr;
    int *temp608 = ptr;
    int *temp609 = ptr;
    int *temp610 = ptr;
    int *temp611 = ptr;
    int *temp612 = ptr;
    int *temp613 = ptr;
    int *temp614 = ptr;
    int *temp615 = ptr;
    int *temp616 = ptr;
    int *temp617 = ptr;
    int *temp618 = ptr;
    int *temp619 = ptr;
    int *temp620 = ptr;
    int *temp621 = ptr;
    int *temp622 = ptr;
    int *temp623 = ptr;
    int *temp624 = ptr;
    int *temp625 = ptr;
    int *temp626 = ptr;
    int *temp627 = ptr;
    int *temp628 = ptr;
    int *temp629 = ptr;
    int *temp630 = ptr;
    int *temp631 = ptr;
    int *temp632 = ptr;
    int *temp633 = ptr;
    int *temp634 = ptr;
    int *temp635 = ptr;
    int *temp636 = ptr;
    int *temp637 = ptr;
    int *temp638 = ptr;
    int *temp639 = ptr;
    int *temp640 = ptr;
    int *temp641 = ptr;
    int *temp642 = ptr;
    int *temp643 = ptr;
    int *temp644 = ptr;
    int *temp645 = ptr;
    int *temp646 = ptr;
    int *temp647 = ptr;
    int *temp648 = ptr;
    int *temp649 = ptr;
    int *temp650 = ptr;
    int *temp651 = ptr;
    int *temp652 = ptr;
    int *temp653 = ptr;
    int *temp654 = ptr;
    int *temp655 = ptr;
    int *temp656 = ptr;
    int *temp657 = ptr;
    int *temp658 = ptr;
    int *temp659 = ptr;
    int *temp660 = ptr;
    int *temp661 = ptr;
    int *temp662 = ptr;
    int *temp663 = ptr;
    int *temp664 = ptr;
    int *temp665 = ptr;
    int *temp666 = ptr;
    int *temp667 = ptr;
    int *temp668 = ptr;
    int *temp669 = ptr;
    int *temp670 = ptr;
    int *temp671 = ptr;
    int *temp672 = ptr;
    int *temp673 = ptr;
    int *temp674 = ptr;
    int *temp675 = ptr;
    int *temp676 = ptr;
    int *temp677 = ptr;
    int *temp678 = ptr;
    int *temp679 = ptr;
    int *temp680 = ptr;
    int *temp681 = ptr;
    int *temp682 = ptr;
    int *temp683 = ptr;
    int *temp684 = ptr;
    int *temp685 = ptr;
    int *temp686 = ptr;
    int *temp687 = ptr;
    int *temp688 = ptr;
    int *temp689 = ptr;
    int *temp690 = ptr;
    int *temp691 = ptr;
    int *temp692 = ptr;
    int *temp693 = ptr;
    int *temp694 = ptr;
    int *temp695 = ptr;
    int *temp696 = ptr;
    int *temp697 = ptr;
    int *temp698 = ptr;
    int *temp699 = ptr;
    int *temp700 = ptr;
    int *temp701 = ptr;
    int *temp702 = ptr;
    int *temp703 = ptr;
    int *temp704 = ptr;
    int *temp705 = ptr;
    int *temp706 = ptr;
    int *temp707 = ptr;
    int *temp708 = ptr;
    int *temp709 = ptr;
    int *temp710 = ptr;
    int *temp711 = ptr;
    int *temp712 = ptr;
    int *temp713 = ptr;
    int *temp714 = ptr;
    int *temp715 = ptr;
    int *temp716 = ptr;
    int *temp717 = ptr;
    int *temp718 = ptr;
    int *temp719 = ptr;
    int *temp720 = ptr;
    int *temp721 = ptr;
    int *temp722 = ptr;
    int *temp723 = ptr;
    int *temp724 = ptr;
    int *temp725 = ptr;
    int *temp726 = ptr;
    int *temp727 = ptr;
    int *temp728 = ptr;
    int *temp729 = ptr;
    int *temp730 = ptr;
    int *temp731 = ptr;
    int *temp732 = ptr;
    int *temp733 = ptr;
    int *temp734 = ptr;
    int *temp735 = ptr;
    int *temp736 = ptr;
    int *temp737 = ptr;
    int *temp738 = ptr;
    int *temp739 = ptr;
    int *temp740 = ptr;
    int *temp741 = ptr;
    int *temp742 = ptr;
    int *temp743 = ptr;
    int *temp744 = ptr;
    int *temp745 = ptr;
    int *temp746 = ptr;
    int *temp747 = ptr;
    int *temp748 = ptr;
    int *temp749 = ptr;
    int *temp750 = ptr;
    int *temp751 = ptr;
    int *temp752 = ptr;
    int *temp753 = ptr;
    int *temp754 = ptr;
    int *temp755 = ptr;
    int *temp756 = ptr;
    int *temp757 = ptr;
    int *temp758 = ptr;
    int *temp759 = ptr;
    int *temp760 = ptr;
    int *temp761 = ptr;
    int *temp762 = ptr;
    int *temp763 = ptr;
    int *temp764 = ptr;
    int *temp765 = ptr;
    int *temp766 = ptr;
    int *temp767 = ptr;
    int *temp768 = ptr;
    int *temp769 = ptr;
    int *temp770 = ptr;
    int *temp771 = ptr;
    int *temp772 = ptr;
    int *temp773 = ptr;
    int *temp774 = ptr;
    int *temp775 = ptr;
    int *temp776 = ptr;
    int *temp777 = ptr;
    int *temp778 = ptr;
    int *temp779 = ptr;
    int *temp780 = ptr;
    int *temp781 = ptr;
    int *temp782 = ptr;
    int *temp783 = ptr;
    int *temp784 = ptr;
    int *temp785 = ptr;
    int *temp786 = ptr;
    int *temp787 = ptr;
    int *temp788 = ptr;
    int *temp789 = ptr;
    int *temp790 = ptr;
    int *temp791 = ptr;
    int *temp792 = ptr;
    int *temp793 = ptr;
    int *temp794 = ptr;
    int *temp795 = ptr;
    int *temp796 = ptr;
    int *temp797 = ptr;
    int *temp798 = ptr;
    int *temp799 = ptr;
    int *temp800 = ptr;
    int *temp801 = ptr;
    int *temp802 = ptr;
    int *temp803 = ptr;
    int *temp804 = ptr;
    int *temp805 = ptr;
    int *temp806 = ptr;
    int *temp807 = ptr;
    int *temp808 = ptr;
    int *temp809 = ptr;
    int *temp810 = ptr;
    int *temp811 = ptr;
    int *temp812 = ptr;
    int *temp813 = ptr;
    int *temp814 = ptr;
    int *temp815 = ptr;
    int *temp816 = ptr;
    int *temp817 = ptr;
    int *temp818 = ptr;
    int *temp819 = ptr;
    int *temp820 = ptr;
    int *temp821 = ptr;
    int *temp822 = ptr;
    int *temp823 = ptr;
    int *temp824 = ptr;
    int *temp825 = ptr;
    int *temp826 = ptr;
    int *temp827 = ptr;
    int *temp828 = ptr;
    int *temp829 = ptr;
    int *temp830 = ptr;
    int *temp831 = ptr;
    int *temp832 = ptr;
    int *temp833 = ptr;
    int *temp834 = ptr;
    int *temp835 = ptr;
    int *temp836 = ptr;
    int *temp837 = ptr;
    int *temp838 = ptr;
    int *temp839 = ptr;
    int *temp840 = ptr;
    int *temp841 = ptr;
    int *temp842 = ptr;
    int *temp843 = ptr;
    int *temp844 = ptr;
    int *temp845 = ptr;
    int *temp846 = ptr;
    int *temp847 = ptr;
    int *temp848 = ptr;
    int *temp849 = ptr;
    int *temp850 = ptr;
    int *temp851 = ptr;
    int *temp852 = ptr;
    int *temp853 = ptr;
    int *temp854 = ptr;
    int *temp855 = ptr;
    int *temp856 = ptr;
    int *temp857 = ptr;
    int *temp858 = ptr;
    int *temp859 = ptr;
    int *temp860 = ptr;
    int *temp861 = ptr;
    int *temp862 = ptr;
    int *temp863 = ptr;
    int *temp864 = ptr;
    int *temp865 = ptr;
    int *temp866 = ptr;
    int *temp867 = ptr;
    int *temp868 = ptr;
    int *temp869 = ptr;
    int *temp870 = ptr;
    int *temp871 = ptr;
    int *temp872 = ptr;
    int *temp873 = ptr;
    int *temp874 = ptr;
    int *temp875 = ptr;
    int *temp876 = ptr;
    int *temp877 = ptr;
    int *temp878 = ptr;
    int *temp879 = ptr;
    int *temp880 = ptr;
    int *temp881 = ptr;
    int *temp882 = ptr;
    int *temp883 = ptr;
    int *temp884 = ptr;
    int *temp885 = ptr;
    int *temp886 = ptr;
    int *temp887 = ptr;
    int *temp888 = ptr;
    int *temp889 = ptr;
    int *temp890 = ptr;
    int *temp891 = ptr;
    int *temp892 = ptr;
    int *temp893 = ptr;
    int *temp894 = ptr;
    int *temp895 = ptr;
    int *temp896 = ptr;
    int *temp897 = ptr;
    int *temp898 = ptr;
    int *temp899 = ptr;
    int *temp900 = ptr;
    int *temp901 = ptr;
    int *temp902 = ptr;
    int *temp903 = ptr;
    int *temp904 = ptr;
    int *temp905 = ptr;
    int *temp906 = ptr;
    int *temp907 = ptr;
    int *temp908 = ptr;
    int *temp909 = ptr;
    int *temp910 = ptr;
    int *temp911 = ptr;
    int *temp912 = ptr;
    int *temp913 = ptr;
    int *temp914 = ptr;
    int *temp915 = ptr;
    int *temp916 = ptr;
    int *temp917 = ptr;
    int *temp918 = ptr;
    int *temp919 = ptr;
    int *temp920 = ptr;
    int *temp921 = ptr;
    int *temp922 = ptr;
    int *temp923 = ptr;
    int *temp924 = ptr;
    int *temp925 = ptr;
    int *temp926 = ptr;
    int *temp927 = ptr;
    int *temp928 = ptr;
    int *temp929 = ptr;
    int *temp930 = ptr;
    int *temp931 = ptr;
    int *temp932 = ptr;
    int *temp933 = ptr;
    int *temp934 = ptr;
    int *temp935 = ptr;
    int *temp936 = ptr;
    int *temp937 = ptr;
    int *temp938 = ptr;
    int *temp939 = ptr;
    int *temp940 = ptr;
    int *temp941 = ptr;
    int *temp942 = ptr;
    int *temp943 = ptr;
    int *temp944 = ptr;
    int *temp945 = ptr;
    int *temp946 = ptr;
    int *temp947 = ptr;
    int *temp948 = ptr;
    int *temp949 = ptr;
    int *temp950 = ptr;
    int *temp951 = ptr;
    int *temp952 = ptr;
    int *temp953 = ptr;
    int *temp954 = ptr;
    int *temp955 = ptr;
    int *temp956 = ptr;
    int *temp957 = ptr;
    int *temp958 = ptr;
    int *temp959 = ptr;
    int *temp960 = ptr;
    int *temp961 = ptr;
    int *temp962 = ptr;
    int *temp963 = ptr;
    int *temp964 = ptr;
    int *temp965 = ptr;
    int *temp966 = ptr;
    int *temp967 = ptr;
    int *temp968 = ptr;
    int *temp969 = ptr;
    int *temp970 = ptr;
    int *temp971 = ptr;
    int *temp972 = ptr;
    int *temp973 = ptr;
    int *temp974 = ptr;
    int *temp975 = ptr;
    int *temp976 = ptr;
    int *temp977 = ptr;
    int *temp978 = ptr;
    int *temp979 = ptr;
    int *temp980 = ptr;
    int *temp981 = ptr;
    int *temp982 = ptr;
    int *temp983 = ptr;
    int *temp984 = ptr;
    int *temp985 = ptr;
    int *temp986 = ptr;
    int *temp987 = ptr;
    int *temp988 = ptr;
    int *temp989 = ptr;
    int *temp990 = ptr;
    int *temp991 = ptr;
    int *temp992 = ptr;
    int *temp993 = ptr;
    int *temp994 = ptr;
    int *temp995 = ptr;
    int *temp996 = ptr;
    int *temp997 = ptr;
    int *temp998 = ptr;
    int *temp999 = ptr;
    int *temp1000 = ptr;
    int *temp1001 = ptr;
    int *temp1002 = ptr;
    int *temp1003 = ptr;
    int *temp1004 = ptr;
    int *temp1005 = ptr;
    int *temp1006 = ptr;
    int *temp1007 = ptr;
    int *temp1008 = ptr;
    int *temp1009 = ptr;
    int *temp1010 = ptr;
    int *temp1011 = ptr;
    int *temp1012 = ptr;
    int *temp1013 = ptr;
    int *temp1014 = ptr;
    int *temp1015 = ptr;
    int *temp1016 = ptr;
    int *temp1017 = ptr;
    int *temp1018 = ptr;
    int *temp1019 = ptr;
    int *temp1020 = ptr;
    int *temp1021 = ptr;
    int *temp1022 = ptr;
    int *temp1023 = ptr;
    int *temp1024 = ptr;
    int *temp1025 = ptr;
    int *temp1026 = ptr;
    int *temp1027 = ptr;
    int *temp1028 = ptr;
    int *temp1029 = ptr;
    int *temp1030 = ptr;
    int *temp1031 = ptr;
    int *temp1032 = ptr;
    int *temp1033 = ptr;
    int *temp1034 = ptr;
    int *temp1035 = ptr;
    int *temp1036 = ptr;
    int *temp1037 = ptr;
    int *temp1038 = ptr;
    int *temp1039 = ptr;
    int *temp1040 = ptr;
    int *temp1041 = ptr;
    int *temp1042 = ptr;
    int *temp1043 = ptr;
    int *temp1044 = ptr;
    int *temp1045 = ptr;
    int *temp1046 = ptr;
    int *temp1047 = ptr;
    int *temp1048 = ptr;
    int *temp1049 = ptr;
    int *temp1050 = ptr;
    int *temp1051 = ptr;
    int *temp1052 = ptr;
    int *temp1053 = ptr;
    int *temp1054 = ptr;
    int *temp1055 = ptr;
    int *temp1056 = ptr;
    int *temp1057 = ptr;
    int *temp1058 = ptr;
    int *temp1059 = ptr;
    int *temp1060 = ptr;
    int *temp1061 = ptr;
    int *temp1062 = ptr;
    int *temp1063 = ptr;
    int *temp1064 = ptr;
    int *temp1065 = ptr;
    int *temp1066 = ptr;
    int *temp1067 = ptr;
    int *temp1068 = ptr;
    int *temp1069 = ptr;
    int *temp1070 = ptr;
    int *temp1071 = ptr;
    int *temp1072 = ptr;
    int *temp1073 = ptr;
    int *temp1074 = ptr;
    int *temp1075 = ptr;
    int *temp1076 = ptr;
    int *temp1077 = ptr;
    int *temp1078 = ptr;
    int *temp1079 = ptr;
    int *temp1080 = ptr;
    int *temp1081 = ptr;
    int *temp1082 = ptr;
    int *temp1083 = ptr;
    int *temp1084 = ptr;
    int *temp1085 = ptr;
    int *temp1086 = ptr;
    int *temp1087 = ptr;
    int *temp1088 = ptr;
    int *temp1089 = ptr;
    int *temp1090 = ptr;
    int *temp1091 = ptr;
    int *temp1092 = ptr;
    int *temp1093 = ptr;
    int *temp1094 = ptr;
    int *temp1095 = ptr;
    int *temp1096 = ptr;
    int *temp1097 = ptr;
    int *temp1098 = ptr;
    int *temp1099 = ptr;
    int *temp1100 = ptr;
    int *temp1101 = ptr;
    int *temp1102 = ptr;
    int *temp1103 = ptr;
    int *temp1104 = ptr;
    int *temp1105 = ptr;
    int *temp1106 = ptr;
    int *temp1107 = ptr;
    int *temp1108 = ptr;
    int *temp1109 = ptr;
    int *temp1110 = ptr;
    int *temp1111 = ptr;
    int *temp1112 = ptr;
    int *temp1113 = ptr;
    int *temp1114 = ptr;
    int *temp1115 = ptr;
    int *temp1116 = ptr;
    int *temp1117 = ptr;
    int *temp1118 = ptr;
    int *temp1119 = ptr;
    int *temp1120 = ptr;
    int *temp1121 = ptr;
    int *temp1122 = ptr;
    int *temp1123 = ptr;
    int *temp1124 = ptr;
    int *temp1125 = ptr;
    int *temp1126 = ptr;
    int *temp1127 = ptr;
    int *temp1128 = ptr;
    int *temp1129 = ptr;
    int *temp1130 = ptr;
    int *temp1131 = ptr;
    int *temp1132 = ptr;
    int *temp1133 = ptr;
    int *temp1134 = ptr;
    int *temp1135 = ptr;
    int *temp1136 = ptr;
    int *temp1137 = ptr;
    int *temp1138 = ptr;
    int *temp1139 = ptr;
    int *temp1140 = ptr;
    int *temp1141 = ptr;
    int *temp1142 = ptr;
    int *temp1143 = ptr;
    int *temp1144 = ptr;
    int *temp1145 = ptr;
    int *temp1146 = ptr;
    int *temp1147 = ptr;
    int *temp1148 = ptr;
    int *temp1149 = ptr;
    int *temp1150 = ptr;
    int *temp1151 = ptr;
    int *temp1152 = ptr;
    int *temp1153 = ptr;
    int *temp1154 = ptr;
    int *temp1155 = ptr;
    int *temp1156 = ptr;
    int *temp1157 = ptr;
    int *temp1158 = ptr;
    int *temp1159 = ptr;
    int *temp1160 = ptr;
    int *temp1161 = ptr;
    int *temp1162 = ptr;
    int *temp1163 = ptr;
    int *temp1164 = ptr;
    int *temp1165 = ptr;
    int *temp1166 = ptr;
    int *temp1167 = ptr;
    int *temp1168 = ptr;
    int *temp1169 = ptr;
    int *temp1170 = ptr;
    int *temp1171 = ptr;
    int *temp1172 = ptr;
    int *temp1173 = ptr;
    int *temp1174 = ptr;
    int *temp1175 = ptr;
    int *temp1176 = ptr;
    int *temp1177 = ptr;
    int *temp1178 = ptr;
    int *temp1179 = ptr;
    int *temp1180 = ptr;
    int *temp1181 = ptr;
    int *temp1182 = ptr;
    int *temp1183 = ptr;
    int *temp1184 = ptr;
    int *temp1185 = ptr;
    int *temp1186 = ptr;
    int *temp1187 = ptr;
    int *temp1188 = ptr;
    int *temp1189 = ptr;
    int *temp1190 = ptr;
    int *temp1191 = ptr;
    int *temp1192 = ptr;
    int *temp1193 = ptr;
    int *temp1194 = ptr;
    int *temp1195 = ptr;
    int *temp1196 = ptr;
    int *temp1197 = ptr;
    int *temp1198 = ptr;
    int *temp1199 = ptr;
    int *temp1200 = ptr;
    int *temp1201 = ptr;
    int *temp1202 = ptr;
    int *temp1203 = ptr;
    int *temp1204 = ptr;
    int *temp1205 = ptr;
    int *temp1206 = ptr;
    int *temp1207 = ptr;
    int *temp1208 = ptr;
    int *temp1209 = ptr;
    int *temp1210 = ptr;
    int *temp1211 = ptr;
    int *temp1212 = ptr;
    int *temp1213 = ptr;
    int *temp1214 = ptr;
    int *temp1215 = ptr;
    int *temp1216 = ptr;
    int *temp1217 = ptr;
    int *temp1218 = ptr;
    int *temp1219 = ptr;
    int *temp1220 = ptr;
    int *temp1221 = ptr;
    int *temp1222 = ptr;
    int *temp1223 = ptr;
    int *temp1224 = ptr;
    int *temp1225 = ptr;
    int *temp1226 = ptr;
    int *temp1227 = ptr;
    int *temp1228 = ptr;
    int *temp1229 = ptr;
    int *temp1230 = ptr;
    int *temp1231 = ptr;
    int *temp1232 = ptr;
    int *temp1233 = ptr;
    int *temp1234 = ptr;
    int *temp1235 = ptr;
    int *temp1236 = ptr;
    int *temp1237 = ptr;
    int *temp1238 = ptr;
    int *temp1239 = ptr;
    int *temp1240 = ptr;
    int *temp1241 = ptr;
    int *temp1242 = ptr;
    int *temp1243 = ptr;
    int *temp1244 = ptr;
    int *temp1245 = ptr;
    int *temp1246 = ptr;
    int *temp1247 = ptr;
    int *temp1248 = ptr;
    int *temp1249 = ptr;
    int *temp1250 = ptr;
    int *temp1251 = ptr;
    int *temp1252 = ptr;
    int *temp1253 = ptr;
    int *temp1254 = ptr;
    int *temp1255 = ptr;
    int *temp1256 = ptr;
    int *temp1257 = ptr;
    int *temp1258 = ptr;
    int *temp1259 = ptr;
    int *temp1260 = ptr;
    int *temp1261 = ptr;
    int *temp1262 = ptr;
    int *temp1263 = ptr;
    int *temp1264 = ptr;
    int *temp1265 = ptr;
    int *temp1266 = ptr;
    int *temp1267 = ptr;
    int *temp1268 = ptr;
    int *temp1269 = ptr;
    int *temp1270 = ptr;
    int *temp1271 = ptr;
    int *temp1272 = ptr;
    int *temp1273 = ptr;
    int *temp1274 = ptr;
    int *temp1275 = ptr;
    int *temp1276 = ptr;
    int *temp1277 = ptr;
    int *temp1278 = ptr;
    int *temp1279 = ptr;
    int *temp1280 = ptr;
    int *temp1281 = ptr;
    int *temp1282 = ptr;
    int *temp1283 = ptr;
    int *temp1284 = ptr;
    int *temp1285 = ptr;
    int *temp1286 = ptr;
    int *temp1287 = ptr;
    int *temp1288 = ptr;
    int *temp1289 = ptr;
    int *temp1290 = ptr;
    int *temp1291 = ptr;
    int *temp1292 = ptr;
    int *temp1293 = ptr;
    int *temp1294 = ptr;
    int *temp1295 = ptr;
    int *temp1296 = ptr;
    int *temp1297 = ptr;
    int *temp1298 = ptr;
    int *temp1299 = ptr;
    int *temp1300 = ptr;
    int *temp1301 = ptr;
    int *temp1302 = ptr;
    int *temp1303 = ptr;
    int *temp1304 = ptr;
    int *temp1305 = ptr;
    int *temp1306 = ptr;
    int *temp1307 = ptr;
    int *temp1308 = ptr;
    int *temp1309 = ptr;
    int *temp1310 = ptr;
    int *temp1311 = ptr;
    int *temp1312 = ptr;
    int *temp1313 = ptr;
    int *temp1314 = ptr;
    int *temp1315 = ptr;
    int *temp1316 = ptr;
    int *temp1317 = ptr;
    int *temp1318 = ptr;
    int *temp1319 = ptr;
    int *temp1320 = ptr;
    int *temp1321 = ptr;
    int *temp1322 = ptr;
    int *temp1323 = ptr;
    int *temp1324 = ptr;
    int *temp1325 = ptr;
    int *temp1326 = ptr;
    int *temp1327 = ptr;
    int *temp1328 = ptr;
    int *temp1329 = ptr;
    int *temp1330 = ptr;
    int *temp1331 = ptr;
    int *temp1332 = ptr;
    int *temp1333 = ptr;
    int *temp1334 = ptr;
    int *temp1335 = ptr;
    int *temp1336 = ptr;
    int *temp1337 = ptr;
    int *temp1338 = ptr;
    int *temp1339 = ptr;
    int *temp1340 = ptr;
    int *temp1341 = ptr;
    int *temp1342 = ptr;
    int *temp1343 = ptr;
    int *temp1344 = ptr;
    int *temp1345 = ptr;
    int *temp1346 = ptr;
    int *temp1347 = ptr;
    int *temp1348 = ptr;
    int *temp1349 = ptr;
    int *temp1350 = ptr;
    int *temp1351 = ptr;
    int *temp1352 = ptr;
    int *temp1353 = ptr;
    int *temp1354 = ptr;
    int *temp1355 = ptr;
    int *temp1356 = ptr;
    int *temp1357 = ptr;
    int *temp1358 = ptr;
    int *temp1359 = ptr;
    int *temp1360 = ptr;
    int *temp1361 = ptr;
    int *temp1362 = ptr;
    int *temp1363 = ptr;
    int *temp1364 = ptr;
    int *temp1365 = ptr;
    int *temp1366 = ptr;
    int *temp1367 = ptr;
    int *temp1368 = ptr;
    int *temp1369 = ptr;
    int *temp1370 = ptr;
    int *temp1371 = ptr;
    int *temp1372 = ptr;
    int *temp1373 = ptr;
    int *temp1374 = ptr;
    int *temp1375 = ptr;
    int *temp1376 = ptr;
    int *temp1377 = ptr;
    int *temp1378 = ptr;
    int *temp1379 = ptr;
    int *temp1380 = ptr;
    int *temp1381 = ptr;
    int *temp1382 = ptr;
    int *temp1383 = ptr;
    int *temp1384 = ptr;
    int *temp1385 = ptr;
    int *temp1386 = ptr;
    int *temp1387 = ptr;
    int *temp1388 = ptr;
    int *temp1389 = ptr;
    int *temp1390 = ptr;
    int *temp1391 = ptr;
    int *temp1392 = ptr;
    int *temp1393 = ptr;
    int *temp1394 = ptr;
    int *temp1395 = ptr;
    int *temp1396 = ptr;
    int *temp1397 = ptr;
    int *temp1398 = ptr;
    int *temp1399 = ptr;
    int *temp1400 = ptr;
    int *temp1401 = ptr;
    int *temp1402 = ptr;
    int *temp1403 = ptr;
    int *temp1404 = ptr;
    int *temp1405 = ptr;
    int *temp1406 = ptr;
    int *temp1407 = ptr;
    int *temp1408 = ptr;
    int *temp1409 = ptr;
    int *temp1410 = ptr;
    int *temp1411 = ptr;
    int *temp1412 = ptr;
    int *temp1413 = ptr;
    int *temp1414 = ptr;
    int *temp1415 = ptr;
    int *temp1416 = ptr;
    int *temp1417 = ptr;
    int *temp1418 = ptr;
    int *temp1419 = ptr;
    int *temp1420 = ptr;
    int *temp1421 = ptr;
    int *temp1422 = ptr;
    int *temp1423 = ptr;
    int *temp1424 = ptr;
    int *temp1425 = ptr;
    int *temp1426 = ptr;
    int *temp1427 = ptr;
    int *temp1428 = ptr;
    int *temp1429 = ptr;
    int *temp1430 = ptr;
    int *temp1431 = ptr;
    int *temp1432 = ptr;
    int *temp1433 = ptr;
    int *temp1434 = ptr;
    int *temp1435 = ptr;
    int *temp1436 = ptr;
    int *temp1437 = ptr;
    int *temp1438 = ptr;
    int *temp1439 = ptr;
    int *temp1440 = ptr;
    int *temp1441 = ptr;
    int *temp1442 = ptr;
    int *temp1443 = ptr;
    int *temp1444 = ptr;
    int *temp1445 = ptr;
    int *temp1446 = ptr;
    int *temp1447 = ptr;
    int *temp1448 = ptr;
    int *temp1449 = ptr;
    int *temp1450 = ptr;
    int *temp1451 = ptr;
    int *temp1452 = ptr;
    int *temp1453 = ptr;
    int *temp1454 = ptr;
    int *temp1455 = ptr;
    int *temp1456 = ptr;
    int *temp1457 = ptr;
    int *temp1458 = ptr;
    int *temp1459 = ptr;
    int *temp1460 = ptr;
    int *temp1461 = ptr;
    int *temp1462 = ptr;
    int *temp1463 = ptr;
    int *temp1464 = ptr;
    int *temp1465 = ptr;
    int *temp1466 = ptr;
    int *temp1467 = ptr;
    int *temp1468 = ptr;
    int *temp1469 = ptr;
    int *temp1470 = ptr;
    int *temp1471 = ptr;
    int *temp1472 = ptr;
    int *temp1473 = ptr;
    int *temp1474 = ptr;
    int *temp1475 = ptr;
    int *temp1476 = ptr;
    int *temp1477 = ptr;
    int *temp1478 = ptr;
    int *temp1479 = ptr;
    int *temp1480 = ptr;
    int *temp1481 = ptr;
    int *temp1482 = ptr;
    int *temp1483 = ptr;
    int *temp1484 = ptr;
    int *temp1485 = ptr;
    int *temp1486 = ptr;
    int *temp1487 = ptr;
    int *temp1488 = ptr;
    int *temp1489 = ptr;
    int *temp1490 = ptr;
    int *temp1491 = ptr;
    int *temp1492 = ptr;
    int *temp1493 = ptr;
    int *temp1494 = ptr;
    int *temp1495 = ptr;
    int *temp1496 = ptr;
    int *temp1497 = ptr;
    int *temp1498 = ptr;
    int *temp1499 = ptr;
    int *temp1500 = ptr;
    int *temp1501 = ptr;
    int *temp1502 = ptr;
    int *temp1503 = ptr;
    int *temp1504 = ptr;
    int *temp1505 = ptr;
    int *temp1506 = ptr;
    int *temp1507 = ptr;
    int *temp1508 = ptr;
    int *temp1509 = ptr;
    int *temp1510 = ptr;
    int *temp1511 = ptr;
    int *temp1512 = ptr;
    int *temp1513 = ptr;
    int *temp1514 = ptr;
    int *temp1515 = ptr;
    int *temp1516 = ptr;
    int *temp1517 = ptr;
    int *temp1518 = ptr;
    int *temp1519 = ptr;
    int *temp1520 = ptr;
    int *temp1521 = ptr;
    int *temp1522 = ptr;
    int *temp1523 = ptr;
    int *temp1524 = ptr;
    int *temp1525 = ptr;
    int *temp1526 = ptr;
    int *temp1527 = ptr;
    int *temp1528 = ptr;
    int *temp1529 = ptr;
    int *temp1530 = ptr;
    int *temp1531 = ptr;
    int *temp1532 = ptr;
    int *temp1533 = ptr;
    int *temp1534 = ptr;
    int *temp1535 = ptr;
    int *temp1536 = ptr;
    int *temp1537 = ptr;
    int *temp1538 = ptr;
    int *temp1539 = ptr;
    int *temp1540 = ptr;
    int *temp1541 = ptr;
    int *temp1542 = ptr;
    int *temp1543 = ptr;
    int *temp1544 = ptr;
    int *temp1545 = ptr;
    int *temp1546 = ptr;
    int *temp1547 = ptr;
    int *temp1548 = ptr;
    int *temp1549 = ptr;
    int *temp1550 = ptr;
    int *temp1551 = ptr;
    int *temp1552 = ptr;
    int *temp1553 = ptr;
    int *temp1554 = ptr;
    int *temp1555 = ptr;
    int *temp1556 = ptr;
    int *temp1557 = ptr;
    int *temp1558 = ptr;
    int *temp1559 = ptr;
    int *temp1560 = ptr;
    int *temp1561 = ptr;
    int *temp1562 = ptr;
    int *temp1563 = ptr;
    int *temp1564 = ptr;
    int *temp1565 = ptr;
    int *temp1566 = ptr;
    int *temp1567 = ptr;
    int *temp1568 = ptr;
    int *temp1569 = ptr;
    int *temp1570 = ptr;
    int *temp1571 = ptr;
    int *temp1572 = ptr;
    int *temp1573 = ptr;
    int *temp1574 = ptr;
    int *temp1575 = ptr;
    int *temp1576 = ptr;
    int *temp1577 = ptr;
    int *temp1578 = ptr;
    int *temp1579 = ptr;
    int *temp1580 = ptr;
    int *temp1581 = ptr;
    int *temp1582 = ptr;
    int *temp1583 = ptr;
    int *temp1584 = ptr;
    int *temp1585 = ptr;
    int *temp1586 = ptr;
    int *temp1587 = ptr;
    int *temp1588 = ptr;
    int *temp1589 = ptr;
    int *temp1590 = ptr;
    int *temp1591 = ptr;
    int *temp1592 = ptr;
    int *temp1593 = ptr;
    int *temp1594 = ptr;
    int *temp1595 = ptr;
    int *temp1596 = ptr;
    int *temp1597 = ptr;
    int *temp1598 = ptr;
    int *temp1599 = ptr;
    int *temp1600 = ptr;
    int *temp1601 = ptr;
    int *temp1602 = ptr;
    int *temp1603 = ptr;
    int *temp1604 = ptr;
    int *temp1605 = ptr;
    int *temp1606 = ptr;
    int *temp1607 = ptr;
    int *temp1608 = ptr;
    int *temp1609 = ptr;
    int *temp1610 = ptr;
    int *temp1611 = ptr;
    int *temp1612 = ptr;
    int *temp1613 = ptr;
    int *temp1614 = ptr;
    int *temp1615 = ptr;
    int *temp1616 = ptr;
    int *temp1617 = ptr;
    int *temp1618 = ptr;
    int *temp1619 = ptr;
    int *temp1620 = ptr;
    int *temp1621 = ptr;
    int *temp1622 = ptr;
    int *temp1623 = ptr;
    int *temp1624 = ptr;
    int *temp1625 = ptr;
    int *temp162
 ************ 
Similarity Score (Unixcoder): 0.30156388878822327
Func rank: 100

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


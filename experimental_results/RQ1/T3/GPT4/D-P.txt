Function Name: rtc_tm2time
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00507D06 | 55 | push    rbp
0x00507D07 | 48 89 E5 | mov     rbp, rsp
0x00507D0A | 48 83 EC 20 | sub     rsp, 20h
0x00507D0E | 48 89 7D E8 | mov     [rbp+tp], rdi
0x00507D12 | 89 75 E4 | mov     [rbp+var_1C], esi
0x00507D15 | 83 7D E4 00 | cmp     [rbp+var_1C], 0
0x00507D19 | 74 1D | jz      short loc_507D38
0x00507D1B | BF E2 75 53 00 | mov     edi, offset aTz; "TZ"
0x00507D20 | E8 EB E8 EF FF | call    _getenv
0x00507D25 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00507D29 | BF E5 75 53 00 | mov     edi, offset aTzUtc0_0; "TZ=UTC0"
0x00507D2E | E8 DD F2 EF FF | call    _putenv
0x00507D33 | E8 D8 F4 EF FF | call    _tzset
0x00507D38 | 48 8B 45 E8 | mov     rax, [rbp+tp]
0x00507D3C | 48 89 C7 | mov     rdi, rax; tp
0x00507D3F | E8 8C F7 EF FF | call    _mktime
0x00507D44 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x00507D48 | 83 7D E4 00 | cmp     [rbp+var_1C], 0
0x00507D4C | 74 26 | jz      short loc_507D74
0x00507D4E | BF E2 75 53 00 | mov     edi, offset aTz; "TZ"
0x00507D53 | E8 88 FB EF FF | call    _unsetenv
0x00507D58 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00507D5D | 74 10 | jz      short loc_507D6F
0x00507D5F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00507D63 | 48 83 E8 03 | sub     rax, 3
0x00507D67 | 48 89 C7 | mov     rdi, rax; string
0x00507D6A | E8 A1 F2 EF FF | call    _putenv
0x00507D6F | E8 9C F4 EF FF | call    _tzset
0x00507D74 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00507D78 | C9 | leave
0x00507D79 | C3 | retn
 ************ 
Source Code:
time_t FAST_FUNC rtc_tm2time(struct tm *ptm, int utc)
{
	char *oldtz = oldtz; /* for compiler */
	time_t t;

	if (utc) {
		oldtz = getenv("TZ");
		putenv((char*)"TZ=UTC0");
		tzset();
	}

	t = mktime(ptm);

	if (utc) {
		unsetenv("TZ");
		if (oldtz)
			putenv(oldtz - 3);
		tzset();
	}

	return t;
}
 ************ 
Parsed Output:
#include <stdlib.h>
#include <time.h>

time_t adjust_time_for_utc(time_t *tp, int flag) {
    time_t result;
    char *original_tz = NULL;

    if (flag != 0) {
        original_tz = getenv("TZ");
        putenv("TZ=UTC0");
        tzset();
    }

    result = mktime(tp);

    if (flag != 0) {
        unsetenv("TZ");
        if (original_tz != NULL) {
            putenv(original_tz - 3); // Assuming original_tz points to the 'T' in "TZ=..."
        }
        tzset();
    }

    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.8749853372573853
Func rank: 1

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: unbackslash
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0047FF75 | 55 | push    rbp
0x0047FF76 | 48 89 E5 | mov     rbp, rsp
0x0047FF79 | 48 83 EC 20 | sub     rsp, 20h
0x0047FF7D | 48 89 7D E8 | mov     [rbp+s], rdi
0x0047FF81 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x0047FF85 | BE 5C 00 00 00 | mov     esi, 5Ch ; '\'; c
0x0047FF8A | 48 89 C7 | mov     rdi, rax; s
0x0047FF8D | E8 5E 69 F8 FF | call    _strchrnul
0x0047FF92 | 48 89 45 E8 | mov     [rbp+s], rax
0x0047FF96 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x0047FF9A | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0047FF9E | 48 8B 45 E8 | mov     rax, [rbp+s]
0x0047FFA2 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0047FFA5 | 3C 5C | cmp     al, 5Ch ; '\'
0x0047FFA7 | 75 05 | jnz     short loc_47FFAE
0x0047FFA9 | 48 83 45 E8 01 | add     [rbp+s], 1
0x0047FFAE | 48 8B 55 E8 | mov     rdx, [rbp+s]
0x0047FFB2 | 48 8D 42 01 | lea     rax, [rdx+1]
0x0047FFB6 | 48 89 45 E8 | mov     [rbp+s], rax
0x0047FFBA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0047FFBE | 48 8D 48 01 | lea     rcx, [rax+1]
0x0047FFC2 | 48 89 4D F8 | mov     [rbp+var_8], rcx
0x0047FFC6 | 0F B6 12 | movzx   edx, byte ptr [rdx]
0x0047FFC9 | 88 10 | mov     [rax], dl
0x0047FFCB | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0047FFCE | 84 C0 | test    al, al
0x0047FFD0 | 74 02 | jz      short loc_47FFD4
0x0047FFD2 | EB CA | jmp     short loc_47FF9E
0x0047FFD4 | 90 | nop
0x0047FFD5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0047FFD9 | C9 | leave
0x0047FFDA | C3 | retn
 ************ 
Source Code:
static char *unbackslash(char *src)
{
	char *dst = src = strchrnul(src, '\\');
	while (1) {
		if (*src == '\\')
			src++;
		if ((*dst++ = *src++) == '\0')
			break;
	}
	return dst;
}
 ************ 
Parsed Output:
char* escape_backslashes(const char* s) {
    char* result = strchrnul(s, '\\');
    char* dest = result;
    while (*result) {
        if (*result == '\\') {
            result++;
        }
        *dest++ = *result++;
    }
    *dest = '\0';
    return dest;
}
 ************ 
Similarity Score (Unixcoder): 0.8709126710891724
Func rank: 2

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: rmoldest
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0046BA5F | 55 | push    rbp
0x0046BA60 | 48 89 E5 | mov     rbp, rsp
0x0046BA63 | 48 83 EC 50 | sub     rsp, 50h
0x0046BA67 | 48 89 7D B8 | mov     [rbp+var_48], rdi
0x0046BA6B | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x0046BA72 | C6 45 C0 41 | mov     [rbp+s2], 41h ; 'A'
0x0046BA76 | C6 45 DB 00 | mov     [rbp+var_25], 0
0x0046BA7A | 0F B6 45 DB | movzx   eax, [rbp+var_25]
0x0046BA7E | 88 45 C1 | mov     [rbp+var_3F], al
0x0046BA81 | EB 15 | jmp     short loc_46BA98
0x0046BA83 | 48 8B 45 B8 | mov     rax, [rbp+var_48]
0x0046BA87 | 48 8B 40 10 | mov     rax, [rax+10h]
0x0046BA8B | 48 89 C6 | mov     rsi, rax
0x0046BA8E | BF FC 62 52 00 | mov     edi, offset aOpenDirectoryW; "open directory, want rotate"
0x0046BA93 | E8 1E F8 FF FF | call    sub_46B2B6
0x0046BA98 | BF 18 63 52 00 | mov     edi, offset asc_526318; "."
0x0046BA9D | E8 8E AF F9 FF | call    _opendir
0x0046BAA2 | 48 89 45 F0 | mov     [rbp+dirp], rax
0x0046BAA6 | 48 83 7D F0 00 | cmp     [rbp+dirp], 0
0x0046BAAB | 74 D6 | jz      short loc_46BA83
0x0046BAAD | 48 8B 05 4C 19 2F 00 | mov     rax, cs:qword_75D400
0x0046BAB4 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x0046BABA | E9 AA 00 00 00 | jmp     loc_46BB69
0x0046BABF | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0046BAC3 | 0F B6 40 13 | movzx   eax, byte ptr [rax+13h]
0x0046BAC7 | 3C 40 | cmp     al, 40h ; '@'
0x0046BAC9 | 0F 85 9A 00 00 00 | jnz     loc_46BB69
0x0046BACF | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0046BAD3 | 48 83 C0 13 | add     rax, 13h
0x0046BAD7 | 48 89 C7 | mov     rdi, rax; s
0x0046BADA | E8 F1 AF F9 FF | call    _strlen
0x0046BADF | 48 83 F8 1B | cmp     rax, 1Bh
0x0046BAE3 | 0F 85 80 00 00 00 | jnz     loc_46BB69
0x0046BAE9 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0046BAED | 0F B6 40 2D | movzx   eax, byte ptr [rax+2Dh]
0x0046BAF1 | 3C 74 | cmp     al, 74h ; 't'
0x0046BAF3 | 75 2C | jnz     short loc_46BB21
0x0046BAF5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0046BAF9 | 48 83 C0 13 | add     rax, 13h
0x0046BAFD | 48 89 C7 | mov     rdi, rax; name
0x0046BB00 | E8 4B AC F9 FF | call    _unlink
0x0046BB05 | 83 F8 FF | cmp     eax, 0FFFFFFFFh
0x0046BB08 | 75 52 | jnz     short loc_46BB5C
0x0046BB0A | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0046BB0E | 48 83 C0 13 | add     rax, 13h
0x0046BB12 | 48 89 C6 | mov     rsi, rax
0x0046BB15 | BF 20 63 52 00 | mov     edi, offset aCanTUnlinkProc; "can't unlink processor leftover"
0x0046BB1A | E8 EE F6 FF FF | call    sub_46B20D
0x0046BB1F | EB 3B | jmp     short loc_46BB5C
0x0046BB21 | 83 45 FC 01 | add     [rbp+var_4], 1
0x0046BB25 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0046BB29 | 48 8D 50 13 | lea     rdx, [rax+13h]
0x0046BB2D | 48 8D 45 C0 | lea     rax, [rbp+s2]
0x0046BB31 | 48 89 C6 | mov     rsi, rax; s2
0x0046BB34 | 48 89 D7 | mov     rdi, rdx; s1
0x0046BB37 | E8 14 B5 F9 FF | call    _strcmp
0x0046BB3C | 85 C0 | test    eax, eax
0x0046BB3E | 79 1C | jns     short loc_46BB5C
0x0046BB40 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0046BB44 | 48 8D 48 13 | lea     rcx, [rax+13h]
0x0046BB48 | 48 8D 45 C0 | lea     rax, [rbp+s2]
0x0046BB4C | BA 1B 00 00 00 | mov     edx, 1Bh; n
0x0046BB51 | 48 89 CE | mov     rsi, rcx; src
0x0046BB54 | 48 89 C7 | mov     rdi, rax; dest
0x0046BB57 | E8 44 B6 F9 FF | call    _memcpy
0x0046BB5C | 48 8B 05 9D 18 2F 00 | mov     rax, cs:qword_75D400
0x0046BB63 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x0046BB69 | 48 8B 45 F0 | mov     rax, [rbp+dirp]
0x0046BB6D | 48 89 C7 | mov     rdi, rax; dirp
0x0046BB70 | E8 AB BB F9 FF | call    _readdir64
0x0046BB75 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x0046BB79 | 48 83 7D E8 00 | cmp     [rbp+var_18], 0
0x0046BB7E | 0F 85 3B FF FF FF | jnz     loc_46BABF
0x0046BB84 | 48 8B 05 75 18 2F 00 | mov     rax, cs:qword_75D400
0x0046BB8B | 8B 00 | mov     eax, [rax]
0x0046BB8D | 85 C0 | test    eax, eax
0x0046BB8F | 74 15 | jz      short loc_46BBA6
0x0046BB91 | 48 8B 45 B8 | mov     rax, [rbp+var_48]
0x0046BB95 | 48 8B 40 10 | mov     rax, [rax+10h]
0x0046BB99 | 48 89 C6 | mov     rsi, rax
0x0046BB9C | BF 40 63 52 00 | mov     edi, offset aCanTReadDirect; "can't read directory"
0x0046BBA1 | E8 67 F6 FF FF | call    sub_46B20D
0x0046BBA6 | 48 8B 45 F0 | mov     rax, [rbp+dirp]
0x0046BBAA | 48 89 C7 | mov     rdi, rax; dirp
0x0046BBAD | E8 DE B2 F9 FF | call    _closedir
0x0046BBB2 | 48 8B 45 B8 | mov     rax, [rbp+var_48]
0x0046BBB6 | 8B 40 20 | mov     eax, [rax+20h]
0x0046BBB9 | 85 C0 | test    eax, eax
0x0046BBBB | 74 68 | jz      short loc_46BC25
0x0046BBBD | 48 8B 45 B8 | mov     rax, [rbp+var_48]
0x0046BBC1 | 8B 50 20 | mov     edx, [rax+20h]
0x0046BBC4 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0046BBC7 | 39 C2 | cmp     edx, eax
0x0046BBC9 | 73 5A | jnb     short loc_46BC25
0x0046BBCB | 48 8B 05 36 18 2F 00 | mov     rax, cs:qword_75D408
0x0046BBD2 | 8B 40 08 | mov     eax, [rax+8]
0x0046BBD5 | 85 C0 | test    eax, eax
0x0046BBD7 | 74 1E | jz      short loc_46BBF7
0x0046BBD9 | 48 8B 45 B8 | mov     rax, [rbp+var_48]
0x0046BBDD | 48 8B 40 10 | mov     rax, [rax+10h]
0x0046BBE1 | 48 8D 55 C0 | lea     rdx, [rbp+s2]
0x0046BBE5 | 48 89 C6 | mov     rsi, rax
0x0046BBE8 | BF 55 63 52 00 | mov     edi, offset aInfoDeleteSS; "info: delete: %s/%s"
0x0046BBED | B8 00 00 00 00 | mov     eax, 0
0x0046BBF2 | E8 50 DB F9 FF | call    sub_409747
0x0046BBF7 | 0F B6 45 C0 | movzx   eax, [rbp+s2]
0x0046BBFB | 3C 40 | cmp     al, 40h ; '@'
0x0046BBFD | 75 26 | jnz     short loc_46BC25
0x0046BBFF | 48 8D 45 C0 | lea     rax, [rbp+s2]
0x0046BC03 | 48 89 C7 | mov     rdi, rax; name
0x0046BC06 | E8 45 AB F9 FF | call    _unlink
0x0046BC0B | 83 F8 FF | cmp     eax, 0FFFFFFFFh
0x0046BC0E | 75 15 | jnz     short loc_46BC25
0x0046BC10 | 48 8B 45 B8 | mov     rax, [rbp+var_48]
0x0046BC14 | 48 8B 40 10 | mov     rax, [rax+10h]
0x0046BC18 | 48 89 C6 | mov     rsi, rax
0x0046BC1B | BF 69 63 52 00 | mov     edi, offset aCanTUnlinkOlde; "can't unlink oldest logfile"
0x0046BC20 | E8 E8 F5 FF FF | call    sub_46B20D
0x0046BC25 | 90 | nop
0x0046BC26 | C9 | leave
0x0046BC27 | C3 | retn
 ************ 
Source Code:
static void rmoldest(struct logdir *ld)
{
	DIR *d;
	struct dirent *f;
	char oldest[FMT_PTIME];
	int n = 0;

	oldest[0] = 'A'; oldest[1] = oldest[27] = 0;
	while (!(d = opendir(".")))
		pause2cannot("open directory, want rotate", ld->name);
	errno = 0;
	while ((f = readdir(d))) {
		if ((f->d_name[0] == '@') && (strlen(f->d_name) == 27)) {
			if (f->d_name[26] == 't') {
				if (unlink(f->d_name) == -1)
					warn2("can't unlink processor leftover", f->d_name);
			} else {
				++n;
				if (strcmp(f->d_name, oldest) < 0)
					memcpy(oldest, f->d_name, 27);
			}
			errno = 0;
		}
	}
	if (errno)
		warn2("can't read directory", ld->name);
	closedir(d);

	if (ld->nmax && (n > ld->nmax)) {
		if (verbose)
			bb_error_msg(INFO"delete: %s/%s", ld->name, oldest);
		if ((*oldest == '@') && (unlink(oldest) == -1))
			warn2("can't unlink oldest logfile", ld->name);
	}
}
 ************ 
Parsed Output:
#include <dirent.h>
#include <string.h>
#include <unistd.h>

void processDirectoryEntries(void *ptr) {
    DIR *dirp;
    struct dirent *entry;
    int count = 0;
    char s2[32] = {'A', 0};

    dirp = opendir(".");
    if (!dirp) {
        // "open directory, want rotate" error handling
        return;
    }

    qword_75D400 = 0;

    while ((entry = readdir64(dirp)) != NULL) {
        if (entry->d_name[0] == '@' && strlen(entry->d_name) == 27 && entry->d_name[20] == 't') {
            if (unlink(entry->d_name) == -1) {
                // "can't unlink processor leftover" error handling
            }
        } else {
            count++;
            if (strcmp(entry->d_name, s2) < 0) {
                memcpy(s2, entry->d_name, 27);
            }
        }
        qword_75D400 = 0;
    }

    closedir(dirp);

    if (ptr && *((int *)ptr + 8) > count) {
        if (qword_75D408) {
            // "info: delete: %s/%s" logging
        }
        if (s2[0] == '@') {
            if (unlink(s2) == -1) {
                // "can't unlink oldest logfile" error handling
            }
        }
    }
}
 ************ 
Similarity Score (Unixcoder): 0.8657870888710022
Func rank: 3

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: svstatus_get
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0046A465 | 55 | push    rbp
0x0046A466 | 48 89 E5 | mov     rbp, rsp
0x0046A469 | 48 83 EC 10 | sub     rsp, 10h
0x0046A46D | BE 01 08 00 00 | mov     esi, 801h; oflag
0x0046A472 | BF CC E5 52 00 | mov     edi, offset aSuperviseOk_0; "supervise/ok"
0x0046A477 | B8 00 00 00 00 | mov     eax, 0
0x0046A47C | E8 4F D2 F9 FF | call    _open64
0x0046A481 | 89 45 FC | mov     [rbp+fd], eax
0x0046A484 | 83 7D FC FF | cmp     [rbp+fd], 0FFFFFFFFh
0x0046A488 | 75 51 | jnz     short loc_46A4DB
0x0046A48A | 48 8B 05 6F 2F 2F 00 | mov     rax, cs:qword_75D400
0x0046A491 | 8B 00 | mov     eax, [rax]
0x0046A493 | 83 F8 13 | cmp     eax, 13h
0x0046A496 | 75 2F | jnz     short loc_46A4C7
0x0046A498 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0046A49D | 48 8B 00 | mov     rax, [rax]
0x0046A4A0 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0046A4A3 | 3C 78 | cmp     al, 78h ; 'x'
0x0046A4A5 | 75 0C | jnz     short loc_46A4B3
0x0046A4A7 | BF D9 E5 52 00 | mov     edi, offset aRunsvNotRunnin; "runsv not running"
0x0046A4AC | E8 87 FF FF FF | call    sub_46A438
0x0046A4B1 | EB 0A | jmp     short loc_46A4BD
0x0046A4B3 | BF D9 E5 52 00 | mov     edi, offset aRunsvNotRunnin; "runsv not running"
0x0046A4B8 | E8 25 FF FF FF | call    sub_46A3E2
0x0046A4BD | B8 00 00 00 00 | mov     eax, 0
0x0046A4C2 | E9 B2 00 00 00 | jmp     locret_46A579
0x0046A4C7 | BF EB E5 52 00 | mov     edi, offset aCanTOpenSuperv; "can't open supervise/ok"
0x0046A4CC | E8 39 FF FF FF | call    sub_46A40A
0x0046A4D1 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x0046A4D6 | E9 9E 00 00 00 | jmp     locret_46A579
0x0046A4DB | 8B 45 FC | mov     eax, [rbp+fd]
0x0046A4DE | 89 C7 | mov     edi, eax; fd
0x0046A4E0 | E8 2B C9 F9 FF | call    _close
0x0046A4E5 | BE 00 08 00 00 | mov     esi, 800h; oflag
0x0046A4EA | BF 03 E6 52 00 | mov     edi, offset aSuperviseStatu_0; "supervise/status"
0x0046A4EF | B8 00 00 00 00 | mov     eax, 0
0x0046A4F4 | E8 D7 D1 F9 FF | call    _open64
0x0046A4F9 | 89 45 FC | mov     [rbp+fd], eax
0x0046A4FC | 83 7D FC FF | cmp     [rbp+fd], 0FFFFFFFFh
0x0046A500 | 75 11 | jnz     short loc_46A513
0x0046A502 | BF 14 E6 52 00 | mov     edi, offset aCanTOpenSuperv_0; "can't open supervise/status"
0x0046A507 | E8 FE FE FF FF | call    sub_46A40A
0x0046A50C | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x0046A511 | EB 66 | jmp     short locret_46A579
0x0046A513 | B9 20 B4 75 00 | mov     ecx, (offset dest.c_cc+17h)
0x0046A518 | 8B 45 FC | mov     eax, [rbp+fd]
0x0046A51B | BA 14 00 00 00 | mov     edx, 14h; nbytes
0x0046A520 | 48 89 CE | mov     rsi, rcx; buf
0x0046A523 | 89 C7 | mov     edi, eax; fd
0x0046A525 | E8 16 CA F9 FF | call    _read
0x0046A52A | 89 45 F8 | mov     [rbp+var_8], eax
0x0046A52D | 8B 45 FC | mov     eax, [rbp+fd]
0x0046A530 | 89 C7 | mov     edi, eax; fd
0x0046A532 | E8 D9 C8 F9 FF | call    _close
0x0046A537 | 83 7D F8 FF | cmp     [rbp+var_8], 0FFFFFFFFh
0x0046A53B | 74 08 | jz      short loc_46A545
0x0046A53D | 83 7D F8 14 | cmp     [rbp+var_8], 14h
0x0046A541 | 75 13 | jnz     short loc_46A556
0x0046A543 | EB 2F | jmp     short loc_46A574
0x0046A545 | BF 30 E6 52 00 | mov     edi, offset aCanTReadSuperv; "can't read supervise/status"
0x0046A54A | E8 BB FE FF FF | call    sub_46A40A
0x0046A54F | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x0046A554 | EB 23 | jmp     short locret_46A579
0x0046A556 | 48 8B 05 A3 2E 2F 00 | mov     rax, cs:qword_75D400
0x0046A55D | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x0046A563 | BF 50 E6 52 00 | mov     edi, offset aCanTReadSuperv_0; "can't read supervise/status: bad format"
0x0046A568 | E8 9D FE FF FF | call    sub_46A40A
0x0046A56D | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x0046A572 | EB 05 | jmp     short locret_46A579
0x0046A574 | B8 01 00 00 00 | mov     eax, 1
0x0046A579 | C9 | leave
0x0046A57A | C3 | retn
 ************ 
Source Code:
static int svstatus_get(void)
{
	int fd, r;

	fd = open("supervise/ok", O_WRONLY|O_NDELAY);
	if (fd == -1) {
		if (errno == ENODEV) {
			*acts == 'x' ? ok("runsv not running")
			             : failx("runsv not running");
			return 0;
		}
		warn("can't open supervise/ok");
		return -1;
	}
	close(fd);
	fd = open("supervise/status", O_RDONLY|O_NDELAY);
	if (fd == -1) {
		warn("can't open supervise/status");
		return -1;
	}
	r = read(fd, &svstatus, 20);
	close(fd);
	switch (r) {
	case 20:
		break;
	case -1:
		warn("can't read supervise/status");
		return -1;
	default:
		errno = 0;
		warn("can't read supervise/status: bad format");
		return -1;
	}
	return 1;
}
 ************ 
Parsed Output:
#include <fcntl.h>
#include <unistd.h>

int checkSuperviseStatus() {
    int fd;
    char buf[20];
    ssize_t bytesRead;

    fd = open("supervise/ok", O_RDONLY | O_NONBLOCK);
    if (fd == -1) {
        if (*qword_75D400 == 19) {
            if (dest[0] == 'x') {
                sub_46A438("runsv not running");
            } else {
                sub_46A3E2("runsv not running");
            }
            return 0;
        } else {
            sub_46A40A("can't open supervise/ok");
            return -1;
        }
    }

    close(fd);

    fd = open("supervise/status", O_RDONLY | O_NONBLOCK);
    if (fd == -1) {
        sub_46A40A("can't open supervise/status");
        return -1;
    }

    bytesRead = read(fd, buf, 20);
    close(fd);

    if (bytesRead == -1) {
        sub_46A40A("can't read supervise/status");
        return -1;
    } else if (bytesRead != 20) {
        *qword_75D400 = 0;
        sub_46A40A("can't read supervise/status: bad format");
        return -1;
    }

    return 1;
}
 ************ 
Similarity Score (Unixcoder): 0.8633008003234863
Func rank: 4

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: launch_helper
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00411CED | 55 | push    rbp
0x00411CEE | 48 89 E5 | mov     rbp, rsp
0x00411CF1 | 48 83 EC 30 | sub     rsp, 30h
0x00411CF5 | 48 89 7D D8 | mov     [rbp+var_28], rdi
0x00411CF9 | 48 8D 45 E0 | lea     rax, [rbp+fd]
0x00411CFD | 48 89 C7 | mov     rdi, rax
0x00411D00 | E8 10 87 FF FF | call    sub_40A415
0x00411D05 | 48 8D 45 E0 | lea     rax, [rbp+fd]
0x00411D09 | 48 83 C0 08 | add     rax, 8
0x00411D0D | 48 89 C7 | mov     rdi, rax
0x00411D10 | E8 00 87 FF FF | call    sub_40A415
0x00411D15 | BE 3F 1C 41 00 | mov     esi, offset sub_411C3F
0x00411D1A | BF 00 40 02 00 | mov     edi, 24000h
0x00411D1F | E8 DD 64 0F 00 | call    sub_508201
0x00411D24 | E8 87 5B FF FF | call    _vfork
0x00411D29 | 89 45 FC | mov     [rbp+var_4], eax
0x00411D2C | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x00411D30 | 79 0F | jns     short loc_411D41
0x00411D32 | BF D0 53 53 00 | mov     edi, offset aVfork_0; "vfork"
0x00411D37 | B8 00 00 00 00 | mov     eax, 0
0x00411D3C | E8 61 75 FF FF | call    sub_4092A2
0x00411D41 | 8B 55 FC | mov     edx, [rbp+var_4]
0x00411D44 | 48 8B 05 BD B6 34 00 | mov     rax, cs:qword_75D408
0x00411D4B | 89 10 | mov     [rax], edx
0x00411D4D | 48 8B 05 B4 B6 34 00 | mov     rax, cs:qword_75D408
0x00411D54 | 8B 00 | mov     eax, [rax]
0x00411D56 | 85 C0 | test    eax, eax
0x00411D58 | 75 07 | jnz     short loc_411D61
0x00411D5A | B8 02 00 00 00 | mov     eax, 2
0x00411D5F | EB 05 | jmp     short loc_411D66
0x00411D61 | B8 00 00 00 00 | mov     eax, 0
0x00411D66 | 89 45 F8 | mov     [rbp+var_8], eax
0x00411D69 | 8B 45 F8 | mov     eax, [rbp+var_8]
0x00411D6C | 83 C0 01 | add     eax, 1
0x00411D6F | 48 98 | cdqe
0x00411D71 | 8B 44 85 E0 | mov     eax, [rbp+rax*4+fd]
0x00411D75 | 89 C7 | mov     edi, eax; fd
0x00411D77 | E8 94 50 FF FF | call    _close
0x00411D7C | B8 02 00 00 00 | mov     eax, 2
0x00411D81 | 2B 45 F8 | sub     eax, [rbp+var_8]
0x00411D84 | 48 98 | cdqe
0x00411D86 | 8B 44 85 E0 | mov     eax, [rbp+rax*4+fd]
0x00411D8A | 89 C7 | mov     edi, eax; fd
0x00411D8C | E8 7F 50 FF FF | call    _close
0x00411D91 | 8B 45 F8 | mov     eax, [rbp+var_8]
0x00411D94 | 48 98 | cdqe
0x00411D96 | 8B 44 85 E0 | mov     eax, [rbp+rax*4+fd]
0x00411D9A | BE 00 00 00 00 | mov     esi, 0
0x00411D9F | 89 C7 | mov     edi, eax
0x00411DA1 | E8 D1 86 FF FF | call    sub_40A477
0x00411DA6 | B8 03 00 00 00 | mov     eax, 3
0x00411DAB | 2B 45 F8 | sub     eax, [rbp+var_8]
0x00411DAE | 48 98 | cdqe
0x00411DB0 | 8B 44 85 E0 | mov     eax, [rbp+rax*4+fd]
0x00411DB4 | BE 01 00 00 00 | mov     esi, 1
0x00411DB9 | 89 C7 | mov     edi, eax
0x00411DBB | E8 B7 86 FF FF | call    sub_40A477
0x00411DC0 | 48 8B 05 41 B6 34 00 | mov     rax, cs:qword_75D408
0x00411DC7 | 8B 00 | mov     eax, [rax]
0x00411DC9 | 85 C0 | test    eax, eax
0x00411DCB | 75 0C | jnz     short loc_411DD9
0x00411DCD | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00411DD1 | 48 89 C7 | mov     rdi, rax
0x00411DD4 | E8 44 75 0E 00 | call    sub_4F931D
0x00411DD9 | BF 09 1C 41 00 | mov     edi, offset sub_411C09
0x00411DDE | E8 ED 5F FF FF | call    sub_407DD0
0x00411DE3 | 90 | nop
0x00411DE4 | C9 | leave
0x00411DE5 | C3 | retn
 ************ 
Source Code:
void FAST_FUNC launch_helper(const char **argv)
{
	// setup vanilla unidirectional pipes interchange
	int i;
	int pipes[4];

	xpipe(pipes);
	xpipe(pipes + 2);

	// NB: handler must be installed before vfork
	bb_signals(0
		+ (1 << SIGCHLD)
		+ (1 << SIGALRM)
		, signal_handler);

	G.helper_pid = xvfork();

	i = (!G.helper_pid) * 2; // for parent:0, for child:2
	close(pipes[i + 1]);     // 1 or 3 - closing one write end
	close(pipes[2 - i]);     // 2 or 0 - closing one read end
	xmove_fd(pipes[i], STDIN_FILENO);      // 0 or 2 - using other read end
	xmove_fd(pipes[3 - i], STDOUT_FILENO); // 3 or 1 - using other write end
	// End result:
	// parent stdout [3] -> child stdin [2]
	// child stdout [1] -> parent stdin [0]

	if (!G.helper_pid) {
		// child: try to execute connection helper
		// NB: SIGCHLD & SIGALRM revert to SIG_DFL on exec
		BB_EXECVP_or_die((char**)argv);
	}

	// parent
	// check whether child is alive
	//redundant:signal_handler(SIGCHLD);
	// child seems OK -> parent goes on
	atexit(kill_helper);
}
 ************ 
Parsed Output:
int execute_and_manage_processes() {
    int fd[2];
    int pid;
    int status;
    int exit_code;

    // Create two pipes
    if (pipe(fd) == -1 || pipe(fd + 2) == -1) {
        perror("pipe");
        exit(1);
    }

    // Fork a child process
    pid = vfork();
    if (pid == -1) {
        perror("vfork");
        exit(1);
    }

    // Store the child process ID
    qword_75D408 = pid;

    if (pid == 0) {
        // Child process
        close(fd[1]);
        close(fd[2]);
        dup2(fd[0], STDIN_FILENO);
        dup2(fd[3], STDOUT_FILENO);
        execve(sub_411C09, NULL, NULL);
        exit(1);
    } else {
        // Parent process
        close(fd[0]);
        close(fd[3]);
        write(fd[1], &status, sizeof(status));
        read(fd[2], &exit_code, sizeof(exit_code));
    }

    // Check if the child process has exited
    if (qword_75D408 == 0) {
        sub_4F931D(&status);
    }

    sub_407DD0(sub_411C09);

    return exit_code;
}
 ************ 
Similarity Score (Unixcoder): 0.8572601079940796
Func rank: 5

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: may_wakeup
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004A4040 | 55 | push    rbp
0x004A4041 | 48 89 E5 | mov     rbp, rsp
0x004A4044 | 48 81 EC A0 00 00 00 | sub     rsp, 0A0h
0x004A404B | 48 89 BD 68 FF FF FF | mov     [rbp+var_98], rdi
0x004A4052 | 48 8B 85 68 FF FF FF | mov     rax, [rbp+var_98]
0x004A4059 | 48 89 C7 | mov     rdi, rax
0x004A405C | E8 BA 53 F6 FF | call    sub_40941B
0x004A4061 | 48 89 85 68 FF FF FF | mov     [rbp+var_98], rax
0x004A4068 | 48 8B 95 68 FF FF FF | mov     rdx, [rbp+var_98]
0x004A406F | 48 8D 85 70 FF FF FF | lea     rax, [rbp+s]
0x004A4076 | 48 89 D1 | mov     rcx, rdx
0x004A4079 | BA 58 09 53 00 | mov     edx, offset aSysClassRtcSDe; "/sys/class/rtc/%s/device/power/wakeup"
0x004A407E | BE 80 00 00 00 | mov     esi, 80h; maxlen
0x004A4083 | 48 89 C7 | mov     rdi, rax; s
0x004A4086 | B8 00 00 00 00 | mov     eax, 0
0x004A408B | E8 80 2B F6 FF | call    _snprintf
0x004A4090 | 48 8D 8D 70 FF FF FF | lea     rcx, [rbp+s]
0x004A4097 | 48 8D 85 70 FF FF FF | lea     rax, [rbp+s]
0x004A409E | BA 80 00 00 00 | mov     edx, 80h
0x004A40A3 | 48 89 CE | mov     rsi, rcx
0x004A40A6 | 48 89 C7 | mov     rdi, rax
0x004A40A9 | E8 53 74 F6 FF | call    sub_40B501
0x004A40AE | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004A40B2 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004A40B7 | 79 07 | jns     short loc_4A40C0
0x004A40B9 | B8 00 00 00 00 | mov     eax, 0
0x004A40BE | EB 1E | jmp     short locret_4A40DE
0x004A40C0 | 48 8D 85 70 FF FF FF | lea     rax, [rbp+s]
0x004A40C7 | BA 08 00 00 00 | mov     edx, 8; n
0x004A40CC | BE 7E 09 53 00 | mov     esi, offset aEnabled_0; "enabled\n"
0x004A40D1 | 48 89 C7 | mov     rdi, rax; s1
0x004A40D4 | E8 C7 26 F6 FF | call    _strncmp
0x004A40D9 | 85 C0 | test    eax, eax
0x004A40DB | 0F 94 C0 | setz    al
0x004A40DE | C9 | leave
0x004A40DF | C3 | retn
 ************ 
Source Code:
static NOINLINE bool may_wakeup(const char *rtcname)
{
	ssize_t ret;
	char buf[128];

	/* strip "/dev/" from the rtcname here */
	rtcname = skip_dev_pfx(rtcname);

	snprintf(buf, sizeof(buf), SYS_RTC_PATH, rtcname);
	ret = open_read_close(buf, buf, sizeof(buf));
	if (ret < 0)
		return false;

	/* wakeup events could be disabled or not supported */
	return strncmp(buf, "enabled
", 8) == 0;
}
 ************ 
Parsed Output:
#include <stdio.h>
#include <string.h>

int check_rtc_wakeup_enabled(const char *rtc_device) {
    char s[128];
    int result;

    // Call to sub_40941B, which might be a function to retrieve some information
    // related to the rtc_device. We assume it returns a pointer or an integer.
    int info = sub_40941B(rtc_device);

    // Construct the path to the wakeup file for the rtc device
    snprintf(s, sizeof(s), "/sys/class/rtc/%s/device/power/wakeup", info);

    // Call to sub_40B501, which might be a function to open the file and read its content
    // or perform some other file-related operation. We assume it returns a file descriptor or a status.
    int fd_or_status = sub_40B501(s, sizeof(s));

    if (fd_or_status < 0) {
        // If the function returned a negative value, we assume an error occurred
        return 0;
    }

    // Compare the first 8 characters of the file content with "enabled
"
    result = strncmp(s, "enabled
", 8) == 0;

    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.8248388171195984
Func rank: 6

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: svstatus_print
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0046A57B | 55 | push    rbp
0x0046A57C | 48 89 E5 | mov     rbp, rsp
0x0046A57F | 48 81 EC C0 00 00 00 | sub     rsp, 0C0h
0x0046A586 | 48 89 BD 48 FF FF FF | mov     [rbp+var_B8], rdi
0x0046A58D | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x0046A594 | 48 8D 85 50 FF FF FF | lea     rax, [rbp+stat_buf]
0x0046A59B | 48 89 C6 | mov     rsi, rax; stat_buf
0x0046A59E | BF 78 E6 52 00 | mov     edi, offset aDown_3; "down"
0x0046A5A3 | E8 48 D8 F9 FF | call    sub_407DF0
0x0046A5A8 | 83 F8 FF | cmp     eax, 0FFFFFFFFh
0x0046A5AB | 75 3D | jnz     short loc_46A5EA
0x0046A5AD | 48 8B 05 4C 2E 2F 00 | mov     rax, cs:qword_75D400
0x0046A5B4 | 8B 00 | mov     eax, [rax]
0x0046A5B6 | 83 F8 02 | cmp     eax, 2
0x0046A5B9 | 74 28 | jz      short loc_46A5E3
0x0046A5BB | B8 F8 B3 75 00 | mov     eax, offset dest
0x0046A5C0 | 48 8B 40 08 | mov     rax, [rax+8]
0x0046A5C4 | 48 8B 00 | mov     rax, [rax]
0x0046A5C7 | 48 89 C6 | mov     rsi, rax
0x0046A5CA | BF 7D E6 52 00 | mov     edi, offset aWarningCanTSta; "warning: can't stat %s/down"
0x0046A5CF | B8 00 00 00 00 | mov     eax, 0
0x0046A5D4 | E8 00 EC F9 FF | call    sub_4091D9
0x0046A5D9 | B8 00 00 00 00 | mov     eax, 0
0x0046A5DE | E9 85 01 00 00 | jmp     locret_46A768
0x0046A5E3 | C7 45 FC 01 00 00 00 | mov     [rbp+var_4], 1
0x0046A5EA | B8 F8 B3 75 00 | mov     eax, offset dest
0x0046A5EF | 8B 40 34 | mov     eax, [rax+34h]
0x0046A5F2 | 89 45 F8 | mov     [rbp+var_8], eax
0x0046A5F5 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0046A5FA | 48 8B 40 28 | mov     rax, [rax+28h]
0x0046A5FE | 48 89 C7 | mov     rdi, rax
0x0046A601 | E8 FF FC FF FF | call    sub_46A305
0x0046A606 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0046A60A | 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0046A60E | 74 57 | jz      short loc_46A667
0x0046A610 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0046A615 | 0F B6 40 3B | movzx   eax, byte ptr [rax+3Bh]
0x0046A619 | 0F B6 C0 | movzx   eax, al
0x0046A61C | 83 F8 01 | cmp     eax, 1
0x0046A61F | 74 07 | jz      short loc_46A628
0x0046A621 | 83 F8 02 | cmp     eax, 2
0x0046A624 | 74 13 | jz      short loc_46A639
0x0046A626 | EB 21 | jmp     short loc_46A649
0x0046A628 | BF 99 E6 52 00 | mov     edi, offset aRun_0; "run: "
0x0046A62D | B8 00 00 00 00 | mov     eax, 0
0x0046A632 | E8 99 C5 F9 FF | call    _printf
0x0046A637 | EB 10 | jmp     short loc_46A649
0x0046A639 | BF 9F E6 52 00 | mov     edi, offset aFinish_1; "finish: "
0x0046A63E | B8 00 00 00 00 | mov     eax, 0
0x0046A643 | E8 88 C5 F9 FF | call    _printf
0x0046A648 | 90 | nop
0x0046A649 | 8B 55 F8 | mov     edx, [rbp+var_8]
0x0046A64C | 48 8B 85 48 FF FF FF | mov     rax, [rbp+var_B8]
0x0046A653 | 48 89 C6 | mov     rsi, rax
0x0046A656 | BF A8 E6 52 00 | mov     edi, offset aSPidD; "%s: (pid %d) "
0x0046A65B | B8 00 00 00 00 | mov     eax, 0
0x0046A660 | E8 6B C5 F9 FF | call    _printf
0x0046A665 | EB 19 | jmp     short loc_46A680
0x0046A667 | 48 8B 85 48 FF FF FF | mov     rax, [rbp+var_B8]
0x0046A66E | 48 89 C6 | mov     rsi, rax
0x0046A671 | BF B6 E6 52 00 | mov     edi, offset aDownS; "down: %s: "
0x0046A676 | B8 00 00 00 00 | mov     eax, 0
0x0046A67B | E8 50 C5 F9 FF | call    _printf
0x0046A680 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0046A685 | 48 8B 40 20 | mov     rax, [rax+20h]
0x0046A689 | 89 C2 | mov     edx, eax
0x0046A68B | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0046A68F | 29 C2 | sub     edx, eax
0x0046A691 | 89 D0 | mov     eax, edx
0x0046A693 | 89 45 EC | mov     [rbp+var_14], eax
0x0046A696 | B8 00 00 00 00 | mov     eax, 0
0x0046A69B | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x0046A69F | 0F 49 45 EC | cmovns  eax, [rbp+var_14]
0x0046A6A3 | 89 C6 | mov     esi, eax
0x0046A6A5 | BF C1 E6 52 00 | mov     edi, offset aUs; "%us"
0x0046A6AA | B8 00 00 00 00 | mov     eax, 0
0x0046A6AF | E8 1C C5 F9 FF | call    _printf
0x0046A6B4 | 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0046A6B8 | 74 6B | jz      short loc_46A725
0x0046A6BA | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0046A6BE | 75 0F | jnz     short loc_46A6CF
0x0046A6C0 | BF C5 E6 52 00 | mov     edi, offset aNormallyDown; ", normally down"
0x0046A6C5 | B8 00 00 00 00 | mov     eax, 0
0x0046A6CA | E8 01 C5 F9 FF | call    _printf
0x0046A6CF | B8 F8 B3 75 00 | mov     eax, offset dest
0x0046A6D4 | 0F B6 40 38 | movzx   eax, byte ptr [rax+38h]
0x0046A6D8 | 84 C0 | test    al, al
0x0046A6DA | 74 0F | jz      short loc_46A6EB
0x0046A6DC | BF D5 E6 52 00 | mov     edi, offset aPaused; ", paused"
0x0046A6E1 | B8 00 00 00 00 | mov     eax, 0
0x0046A6E6 | E8 E5 C4 F9 FF | call    _printf
0x0046A6EB | B8 F8 B3 75 00 | mov     eax, offset dest
0x0046A6F0 | 0F B6 40 39 | movzx   eax, byte ptr [rax+39h]
0x0046A6F4 | 3C 64 | cmp     al, 64h ; 'd'
0x0046A6F6 | 75 0F | jnz     short loc_46A707
0x0046A6F8 | BF DE E6 52 00 | mov     edi, offset aWantDown; ", want down"
0x0046A6FD | B8 00 00 00 00 | mov     eax, 0
0x0046A702 | E8 C9 C4 F9 FF | call    _printf
0x0046A707 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0046A70C | 0F B6 40 3A | movzx   eax, byte ptr [rax+3Ah]
0x0046A710 | 84 C0 | test    al, al
0x0046A712 | 74 42 | jz      short loc_46A756
0x0046A714 | BF EA E6 52 00 | mov     edi, offset aGotTerm; ", got TERM"
0x0046A719 | B8 00 00 00 00 | mov     eax, 0
0x0046A71E | E8 AD C4 F9 FF | call    _printf
0x0046A723 | EB 31 | jmp     short loc_46A756
0x0046A725 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x0046A729 | 74 0F | jz      short loc_46A73A
0x0046A72B | BF F5 E6 52 00 | mov     edi, offset aNormallyUp; ", normally up"
0x0046A730 | B8 00 00 00 00 | mov     eax, 0
0x0046A735 | E8 96 C4 F9 FF | call    _printf
0x0046A73A | B8 F8 B3 75 00 | mov     eax, offset dest
0x0046A73F | 0F B6 40 39 | movzx   eax, byte ptr [rax+39h]
0x0046A743 | 3C 75 | cmp     al, 75h ; 'u'
0x0046A745 | 75 0F | jnz     short loc_46A756
0x0046A747 | BF 03 E7 52 00 | mov     edi, offset aWantUp; ", want up"
0x0046A74C | B8 00 00 00 00 | mov     eax, 0
0x0046A751 | E8 7A C4 F9 FF | call    _printf
0x0046A756 | 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0046A75A | 74 07 | jz      short loc_46A763
0x0046A75C | B8 01 00 00 00 | mov     eax, 1
0x0046A761 | EB 05 | jmp     short locret_46A768
0x0046A763 | B8 02 00 00 00 | mov     eax, 2
0x0046A768 | C9 | leave
0x0046A769 | C3 | retn
 ************ 
Source Code:
static unsigned svstatus_print(const char *m)
{
	int diff;
	int pid;
	int normallyup = 0;
	struct stat s;
	uint64_t timestamp;

	if (stat("down", &s) == -1) {
		if (errno != ENOENT) {
			bb_perror_msg(WARN"can't stat %s/down", *service);
			return 0;
		}
		normallyup = 1;
	}
	pid = SWAP_LE32(svstatus.pid_le32);
	timestamp = SWAP_BE64(svstatus.time_be64);
	if (pid) {
		switch (svstatus.run_or_finish) {
		case 1: printf("run: "); break;
		case 2: printf("finish: "); break;
		}
		printf("%s: (pid %d) ", m, pid);
	} else {
		printf("down: %s: ", m);
	}
	diff = tnow - timestamp;
	printf("%us", (diff < 0 ? 0 : diff));
	if (pid) {
		if (!normallyup) printf(", normally down");
		if (svstatus.paused) printf(", paused");
		if (svstatus.want == 'd') printf(", want down");
		if (svstatus.got_term) printf(", got TERM");
	} else {
		if (normallyup) printf(", normally up");
		if (svstatus.want == 'u') printf(", want up");
	}
	return pid ? 1 : 2;
}
 ************ 
Parsed Output:
#include <stdio.h>

int check_and_print_status(char *service_name) {
    struct stat stat_buf;
    int status_flag = 0;
    int service_status;
    int time_difference;
    int exit_code = 0;

    if (stat("down", &stat_buf) != 0) {
        if (qword_75D400 == 2) {
            printf("warning: can't stat %s/down
", service_name);
            return 0;
        }
        status_flag = 1;
    }

    service_status = dest[34];
    time_difference = dest[20] - sub_46A305(dest[28]);

    if (service_status != 0) {
        if (service_status == 1) {
            printf("run: ");
        } else if (service_status == 2) {
            printf("finish: ");
        }
        printf("%s: (pid %d) ", service_name, service_status);
    } else {
        printf("down: %s: ", service_name);
    }

    if (time_difference < 0) {
        time_difference = 0;
    }
    printf("%us", time_difference);

    if (service_status != 0) {
        if (status_flag == 0) {
            printf(", normally down");
        }
        if (dest[38]) {
            printf(", paused");
        }
        if (dest[39] == 'd') {
            printf(", want down");
        }
        if (dest[3A]) {
            printf(", got TERM");
        }
    } else {
        if (status_flag != 0) {
            printf(", normally up");
        }
        if (dest[39] == 'u') {
            printf(", want up");
        }
    }

    if (service_status != 0) {
        exit_code = 1;
    } else {
        exit_code = 2;
    }

    return exit_code;
}
 ************ 
Similarity Score (Unixcoder): 0.8101451992988586
Func rank: 7

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: block_CHLD_HUP_ALRM
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00433B6A | 55 | push    rbp
0x00433B6B | 48 89 E5 | mov     rbp, rsp
0x00433B6E | 48 83 EC 10 | sub     rsp, 10h
0x00433B72 | 48 89 7D F8 | mov     [rbp+set], rdi
0x00433B76 | 48 8B 45 F8 | mov     rax, [rbp+set]
0x00433B7A | 48 89 C7 | mov     rdi, rax; set
0x00433B7D | E8 7E 35 FD FF | call    _sigemptyset
0x00433B82 | 48 8B 45 F8 | mov     rax, [rbp+set]
0x00433B86 | BE 11 00 00 00 | mov     esi, 11h; signo
0x00433B8B | 48 89 C7 | mov     rdi, rax; set
0x00433B8E | E8 FD 40 FD FF | call    _sigaddset
0x00433B93 | 48 8B 45 F8 | mov     rax, [rbp+set]
0x00433B97 | BE 01 00 00 00 | mov     esi, 1; signo
0x00433B9C | 48 89 C7 | mov     rdi, rax; set
0x00433B9F | E8 EC 40 FD FF | call    _sigaddset
0x00433BA4 | 48 8B 45 F8 | mov     rax, [rbp+set]
0x00433BA8 | BE 0E 00 00 00 | mov     esi, 0Eh; signo
0x00433BAD | 48 89 C7 | mov     rdi, rax; set
0x00433BB0 | E8 DB 40 FD FF | call    _sigaddset
0x00433BB5 | 48 8B 55 F8 | mov     rdx, [rbp+set]; oset
0x00433BB9 | 48 8B 45 F8 | mov     rax, [rbp+set]
0x00433BBD | 48 89 C6 | mov     rsi, rax; set
0x00433BC0 | BF 00 00 00 00 | mov     edi, 0; how
0x00433BC5 | E8 76 2A FD FF | call    _sigprocmask
0x00433BCA | 90 | nop
0x00433BCB | C9 | leave
0x00433BCC | C3 | retn
 ************ 
Source Code:
static void block_CHLD_HUP_ALRM(sigset_t *m)
{
	sigemptyset(m);
	sigaddset(m, SIGCHLD);
	sigaddset(m, SIGHUP);
	sigaddset(m, SIGALRM);
	sigprocmask(SIG_BLOCK, m, m); /* old sigmask is stored in m */
}
 ************ 
Parsed Output:
void initializeSignalSet(sigset_t *set) {
    sigemptyset(set);
    sigaddset(set, SIGSEGV);
    sigaddset(set, SIGHUP);
    sigaddset(set, SIGALRM);
    sigprocmask(SIG_BLOCK, set, set);
}
 ************ 
Similarity Score (Unixcoder): 0.7919183373451233
Func rank: 8

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: chpasswd_main
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0040DC16 | 55 | push    rbp
0x0040DC17 | 48 89 E5 | mov     rbp, rsp
0x0040DC1A | 48 83 EC 40 | sub     rsp, 40h
0x0040DC1E | 89 7D CC | mov     [rbp+var_34], edi
0x0040DC21 | 48 89 75 C0 | mov     [rbp+var_40], rsi
0x0040DC25 | E8 D6 8E FF FF | call    _getuid
0x0040DC2A | 85 C0 | test    eax, eax
0x0040DC2C | 74 0F | jz      short loc_40DC3D
0x0040DC2E | BF 6C 4D 53 00 | mov     edi, offset aPermissionDeni; "permission denied (are you root?)"
0x0040DC33 | B8 00 00 00 00 | mov     eax, 0
0x0040DC38 | E8 61 BA FF FF | call    sub_40969E
0x0040DC3D | 48 C7 05 F8 F7 34 00 1B 83 52 00 | mov     cs:qword_75D440, offset aMEEM; "m--e:e--m"
0x0040DC48 | 48 C7 05 F5 F7 34 00 08 83 52 00 | mov     cs:qword_75D448, offset aEncrypted; "encrypted"
0x0040DC53 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x0040DC57 | BE 25 83 52 00 | mov     esi, offset aEm; "em"
0x0040DC5C | 48 89 C7 | mov     rdi, rax
0x0040DC5F | B8 00 00 00 00 | mov     eax, 0
0x0040DC64 | E8 86 C5 0E 00 | call    sub_4FA1EF
0x0040DC69 | 89 45 E8 | mov     [rbp+var_18], eax
0x0040DC6C | E9 64 01 00 00 | jmp     loc_40DDD5
0x0040DC71 | 48 8B 45 E0 | mov     rax, [rbp+s]
0x0040DC75 | BE 3A 00 00 00 | mov     esi, 3Ah ; ':'; c
0x0040DC7A | 48 89 C7 | mov     rdi, rax; s
0x0040DC7D | E8 3E 8F FF FF | call    _strchr
0x0040DC82 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0040DC86 | 48 83 7D F0 00 | cmp     [rbp+var_10], 0
0x0040DC8B | 75 0F | jnz     short loc_40DC9C
0x0040DC8D | BF 28 83 52 00 | mov     edi, offset aMissingNewPass; "missing new password"
0x0040DC92 | B8 00 00 00 00 | mov     eax, 0
0x0040DC97 | E8 02 BA FF FF | call    sub_40969E
0x0040DC9C | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0040DCA0 | 48 8D 50 01 | lea     rdx, [rax+1]
0x0040DCA4 | 48 89 55 F0 | mov     [rbp+var_10], rdx
0x0040DCA8 | C6 00 00 | mov     byte ptr [rax], 0
0x0040DCAB | 48 8B 45 E0 | mov     rax, [rbp+s]
0x0040DCAF | 48 89 C7 | mov     rdi, rax
0x0040DCB2 | E8 C2 87 0E 00 | call    sub_4F6479
0x0040DCB7 | 48 C7 45 F8 00 00 00 00 | mov     [rbp+ptr], 0
0x0040DCBF | 8B 45 E8 | mov     eax, [rbp+var_18]
0x0040DCC2 | 83 E0 01 | and     eax, 1
0x0040DCC5 | 85 C0 | test    eax, eax
0x0040DCC7 | 75 60 | jnz     short loc_40DD29
0x0040DCC9 | 48 8D 45 D4 | lea     rax, [rbp+var_2C]
0x0040DCCD | BE 01 00 00 00 | mov     esi, 1
0x0040DCD2 | 48 89 C7 | mov     rdi, rax
0x0040DCD5 | E8 C8 6D 0F 00 | call    sub_504AA2
0x0040DCDA | 8B 45 E8 | mov     eax, [rbp+var_18]
0x0040DCDD | 83 E0 02 | and     eax, 2
0x0040DCE0 | 85 C0 | test    eax, eax
0x0040DCE2 | 74 21 | jz      short loc_40DD05
0x0040DCE4 | C6 45 D4 24 | mov     [rbp+var_2C], 24h ; '$'
0x0040DCE8 | C6 45 D5 31 | mov     [rbp+var_2B], 31h ; '1'
0x0040DCEC | C6 45 D6 24 | mov     [rbp+var_2A], 24h ; '$'
0x0040DCF0 | 48 8D 45 D4 | lea     rax, [rbp+var_2C]
0x0040DCF4 | 48 83 C0 03 | add     rax, 3
0x0040DCF8 | BE 04 00 00 00 | mov     esi, 4
0x0040DCFD | 48 89 C7 | mov     rdi, rax
0x0040DD00 | E8 9D 6D 0F 00 | call    sub_504AA2
0x0040DD05 | 48 8D 4D D4 | lea     rcx, [rbp+var_2C]
0x0040DD09 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0040DD0D | BA 00 00 00 00 | mov     edx, 0
0x0040DD12 | 48 89 CE | mov     rsi, rcx
0x0040DD15 | 48 89 C7 | mov     rdi, rax
0x0040DD18 | E8 BF 8E 0F 00 | call    sub_506BDC
0x0040DD1D | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0040DD21 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0040DD25 | 48 89 45 F8 | mov     [rbp+ptr], rax
0x0040DD29 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x0040DD2D | 48 8B 45 E0 | mov     rax, [rbp+s]
0x0040DD31 | B9 00 00 00 00 | mov     ecx, 0
0x0040DD36 | 48 89 C6 | mov     rsi, rax
0x0040DD39 | BF 3D 83 52 00 | mov     edi, offset aEtcShadow_1; "/etc/shadow"
0x0040DD3E | E8 38 B9 0F 00 | call    sub_50967B
0x0040DD43 | 89 45 EC | mov     [rbp+var_14], eax
0x0040DD46 | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x0040DD4A | 7E 08 | jle     short loc_40DD54
0x0040DD4C | 48 C7 45 F0 49 83 52 00 | mov     [rbp+var_10], offset asc_528349; "x"
0x0040DD54 | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x0040DD58 | 78 1D | js      short loc_40DD77
0x0040DD5A | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x0040DD5E | 48 8B 45 E0 | mov     rax, [rbp+s]
0x0040DD62 | B9 00 00 00 00 | mov     ecx, 0
0x0040DD67 | 48 89 C6 | mov     rsi, rax
0x0040DD6A | BF 4B 83 52 00 | mov     edi, offset aEtcPasswd_1; "/etc/passwd"
0x0040DD6F | E8 07 B9 0F 00 | call    sub_50967B
0x0040DD74 | 89 45 EC | mov     [rbp+var_14], eax
0x0040DD77 | C6 05 9A D0 34 00 03 | mov     cs:byte_75AE18, 3
0x0040DD7E | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x0040DD82 | 79 16 | jns     short loc_40DD9A
0x0040DD84 | 48 8B 45 E0 | mov     rax, [rbp+s]
0x0040DD88 | 48 89 C6 | mov     rsi, rax
0x0040DD8B | BF 58 83 52 00 | mov     edi, offset aAnErrorOccurre; "an error occurred updating password for"...
0x0040DD90 | B8 00 00 00 00 | mov     eax, 0
0x0040DD95 | E8 04 B9 FF FF | call    sub_40969E
0x0040DD9A | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x0040DD9E | 74 16 | jz      short loc_40DDB6
0x0040DDA0 | 48 8B 45 E0 | mov     rax, [rbp+s]
0x0040DDA4 | 48 89 C6 | mov     rsi, rax
0x0040DDA7 | BF 83 83 52 00 | mov     edi, offset aPasswordForSCh; "Password for '%s' changed"
0x0040DDAC | B8 00 00 00 00 | mov     eax, 0
0x0040DDB1 | E8 06 FD 0E 00 | call    sub_4FDABC
0x0040DDB6 | C6 05 5B D0 34 00 01 | mov     cs:byte_75AE18, 1
0x0040DDBD | 48 8B 45 E0 | mov     rax, [rbp+s]
0x0040DDC1 | 48 89 C7 | mov     rdi, rax; ptr
0x0040DDC4 | E8 97 88 FF FF | call    _free
0x0040DDC9 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x0040DDCD | 48 89 C7 | mov     rdi, rax; ptr
0x0040DDD0 | E8 8B 88 FF FF | call    _free
0x0040DDD5 | 48 8B 05 94 D0 34 00 | mov     rax, cs:stdin
0x0040DDDC | 48 89 C7 | mov     rdi, rax
0x0040DDDF | E8 0D C2 0E 00 | call    sub_4F9FF1
0x0040DDE4 | 48 89 45 E0 | mov     [rbp+s], rax
0x0040DDE8 | 48 83 7D E0 00 | cmp     [rbp+s], 0
0x0040DDED | 0F 85 7E FE FF FF | jnz     loc_40DC71
0x0040DDF3 | B8 00 00 00 00 | mov     eax, 0
0x0040DDF8 | C9 | leave
0x0040DDF9 | C3 | retn
 ************ 
Source Code:
int chpasswd_main(int argc UNUSED_PARAM, char **argv)
{
	char *name;
	int opt;

	if (getuid() != 0)
		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);

	opt_complementary = "m--e:e--m";
	IF_LONG_OPTS(applet_long_options = chpasswd_longopts;)
	opt = getopt32(argv, "em");

	while ((name = xmalloc_fgetline(stdin)) != NULL) {
		char *free_me;
		char *pass;
		int rc;

		pass = strchr(name, ':');
		if (!pass)
			bb_error_msg_and_die("missing new password");
		*pass++ = '\0';

		xuname2uid(name); /* dies if there is no such user */

		free_me = NULL;
		if (!(opt & OPT_ENC)) {
			char salt[sizeof("$N$XXXXXXXX")];

			crypt_make_salt(salt, 1);
			if (opt & OPT_MD5) {
				salt[0] = '$';
				salt[1] = '1';
				salt[2] = '$';
				crypt_make_salt(salt + 3, 4);
			}
			free_me = pass = pw_encrypt(pass, salt, 0);
		}

		/* This is rather complex: if user is not found in /etc/shadow,
		 * we try to find & change his passwd in /etc/passwd */
#if ENABLE_FEATURE_SHADOWPASSWDS
		rc = update_passwd(bb_path_shadow_file, name, pass, NULL);
		if (rc > 0) /* password in /etc/shadow was updated */
			pass = (char*)"x";
		if (rc >= 0)
			/* 0 = /etc/shadow missing (not an error), >0 = passwd changed in /etc/shadow */
#endif
			rc = update_passwd(bb_path_passwd_file, name, pass, NULL);
		/* LOGMODE_BOTH logs to syslog also */
		logmode = LOGMODE_BOTH;
		if (rc < 0)
			bb_error_msg_and_die("an error occurred updating password for %s", name);
		if (rc)
			bb_info_msg("Password for '%s' changed", name);
		logmode = LOGMODE_STDIO;
		free(name);
		free(free_me);
	}
	return EXIT_SUCCESS;
}
 ************ 
Parsed Output:
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

void updatePassword(int argc, char *argv[]) {
    int result;
    char *s, *new_password, *ptr;
    char salt[8];
    int var_18;

    if (getuid() != 0) {
        printf("permission denied (are you root?)");
        return;
    }

    // Initialize global variables
    qword_75D440 = "m--e:e--m";
    qword_75D448 = "encrypted";

    s = argv[1];
    new_password = strchr(s, ':');
    if (!new_password) {
        printf("missing new password");
        return;
    }

    *new_password++ = '\0'; // Split the string and move to the new password
    var_18 = sub_4FA1EF(s, "em");

    ptr = NULL;
    if ((var_18 & 1) == 0) {
        sub_504AA2(salt, 1);
        if (var_18 & 2) {
            salt[0] = '$';
            salt[1] = '1';
            salt[2] = '$';
            sub_504AA2(salt + 3, 4);
        }
        new_password = sub_506BDC(new_password, salt, 0);
        ptr = new_password;
    }

    result = sub_50967B("/etc/shadow", s, new_password, 0);
    if (result > 0) {
        var_10 = "x";
    }

    if (result >= 0) {
        result = sub_50967B("/etc/passwd", s, new_password, 0);
    }

    byte_75AE18 = 3;
    if (result < 0) {
        printf("an error occurred updating password for %s", s);
    } else if (result > 0) {
        printf("Password for '%s' changed", s);
    }

    byte_75AE18 = 1;
    free(s);
    free(ptr);

    while ((s = sub_4F9FF1(stdin)) != NULL) {
        new_password = strchr(s, ':');
        if (!new_password) {
            printf("missing new password");
            free(s);
            return;
        }
        *new_password++ = '\0';
        var_18 = sub_4FA1EF(s, "em");
        goto loc_40DC71;
    }
}
 ************ 
Similarity Score (Unixcoder): 0.7873935699462891
Func rank: 9

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: print_stats_and_exit
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0043DEF7 | 55 | push    rbp
0x0043DEF8 | 48 89 E5 | mov     rbp, rsp
0x0043DEFB | 48 83 EC 20 | sub     rsp, 20h
0x0043DEFF | 89 7D EC | mov     [rbp+var_14], edi
0x0043DF02 | BE 01 00 00 00 | mov     esi, 1; handler
0x0043DF07 | BF 02 00 00 00 | mov     edi, 2; sig
0x0043DF0C | E8 5F 91 FC FF | call    _signal
0x0043DF11 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043DF16 | 48 8B 40 78 | mov     rax, [rax+78h]
0x0043DF1A | 48 89 C6 | mov     rsi, rax
0x0043DF1D | BF 00 B6 52 00 | mov     edi, offset aSPingStatistic; "\n--- %s ping statistics ---\n"
0x0043DF22 | B8 00 00 00 00 | mov     eax, 0
0x0043DF27 | E8 A4 8C FC FF | call    _printf
0x0043DF2C | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043DF31 | 48 8B 40 28 | mov     rax, [rax+28h]
0x0043DF35 | 48 89 C6 | mov     rsi, rax
0x0043DF38 | BF 1D B6 52 00 | mov     edi, offset aLuPacketsTrans; "%lu packets transmitted, "
0x0043DF3D | B8 00 00 00 00 | mov     eax, 0
0x0043DF42 | E8 89 8C FC FF | call    _printf
0x0043DF47 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043DF4C | 48 8B 40 30 | mov     rax, [rax+30h]
0x0043DF50 | 48 89 C6 | mov     rsi, rax
0x0043DF53 | BF 37 B6 52 00 | mov     edi, offset aLuPacketsRecei; "%lu packets received, "
0x0043DF58 | B8 00 00 00 00 | mov     eax, 0
0x0043DF5D | E8 6E 8C FC FF | call    _printf
0x0043DF62 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043DF67 | 48 8B 40 38 | mov     rax, [rax+38h]
0x0043DF6B | 48 85 C0 | test    rax, rax
0x0043DF6E | 74 1B | jz      short loc_43DF8B
0x0043DF70 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043DF75 | 48 8B 40 38 | mov     rax, [rax+38h]
0x0043DF79 | 48 89 C6 | mov     rsi, rax
0x0043DF7C | BF 4E B6 52 00 | mov     edi, offset aLuDuplicates; "%lu duplicates, "
0x0043DF81 | B8 00 00 00 00 | mov     eax, 0
0x0043DF86 | E8 45 8C FC FF | call    _printf
0x0043DF8B | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043DF90 | 48 8B 40 28 | mov     rax, [rax+28h]
0x0043DF94 | 48 85 C0 | test    rax, rax
0x0043DF97 | 74 48 | jz      short loc_43DFE1
0x0043DF99 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043DF9E | 48 8B 50 28 | mov     rdx, [rax+28h]
0x0043DFA2 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043DFA7 | 48 8B 40 30 | mov     rax, [rax+30h]
0x0043DFAB | 48 29 C2 | sub     rdx, rax
0x0043DFAE | 48 89 D0 | mov     rax, rdx
0x0043DFB1 | 48 C1 E0 02 | shl     rax, 2
0x0043DFB5 | 48 01 D0 | add     rax, rdx
0x0043DFB8 | 48 8D 14 85 00 00 00 00 | lea     rdx, ds:0[rax*4]
0x0043DFC0 | 48 01 D0 | add     rax, rdx
0x0043DFC3 | 48 C1 E0 02 | shl     rax, 2
0x0043DFC7 | BA F8 B3 75 00 | mov     edx, offset dest
0x0043DFCC | 48 8B 7A 28 | mov     rdi, [rdx+28h]
0x0043DFD0 | B9 F8 B3 75 00 | mov     ecx, offset dest
0x0043DFD5 | BA 00 00 00 00 | mov     edx, 0
0x0043DFDA | 48 F7 F7 | div     rdi
0x0043DFDD | 48 89 41 28 | mov     [rcx+28h], rax
0x0043DFE1 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043DFE6 | 48 8B 40 28 | mov     rax, [rax+28h]
0x0043DFEA | 48 89 C6 | mov     rsi, rax
0x0043DFED | BF 5F B6 52 00 | mov     edi, offset aLuPacketLoss; "%lu%% packet loss\n"
0x0043DFF2 | B8 00 00 00 00 | mov     eax, 0
0x0043DFF7 | E8 D4 8B FC FF | call    _printf
0x0043DFFC | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E001 | 8B 40 44 | mov     eax, [rax+44h]
0x0043E004 | 83 F8 FF | cmp     eax, 0FFFFFFFFh
0x0043E007 | 0F 84 E2 00 00 00 | jz      loc_43E0EF
0x0043E00D | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E012 | 48 8B 40 50 | mov     rax, [rax+50h]
0x0043E016 | BA F8 B3 75 00 | mov     edx, offset dest
0x0043E01B | 48 8B 4A 30 | mov     rcx, [rdx+30h]
0x0043E01F | BA F8 B3 75 00 | mov     edx, offset dest
0x0043E024 | 48 8B 52 38 | mov     rdx, [rdx+38h]
0x0043E028 | 48 01 D1 | add     rcx, rdx
0x0043E02B | BA 00 00 00 00 | mov     edx, 0
0x0043E030 | 48 F7 F1 | div     rcx
0x0043E033 | 89 45 FC | mov     [rbp+var_4], eax
0x0043E036 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E03B | 8B 70 48 | mov     esi, [rax+48h]
0x0043E03E | BA D3 4D 62 10 | mov     edx, 10624DD3h
0x0043E043 | 89 F0 | mov     eax, esi
0x0043E045 | F7 E2 | mul     edx
0x0043E047 | 89 D1 | mov     ecx, edx
0x0043E049 | C1 E9 06 | shr     ecx, 6
0x0043E04C | 69 C1 E8 03 00 00 | imul    eax, ecx, 3E8h
0x0043E052 | 89 F1 | mov     ecx, esi
0x0043E054 | 29 C1 | sub     ecx, eax
0x0043E056 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E05B | 8B 40 48 | mov     eax, [rax+48h]
0x0043E05E | BA D3 4D 62 10 | mov     edx, 10624DD3h
0x0043E063 | F7 E2 | mul     edx
0x0043E065 | C1 EA 06 | shr     edx, 6
0x0043E068 | 41 89 D1 | mov     r9d, edx
0x0043E06B | 8B 75 FC | mov     esi, [rbp+var_4]
0x0043E06E | BA D3 4D 62 10 | mov     edx, 10624DD3h
0x0043E073 | 89 F0 | mov     eax, esi
0x0043E075 | F7 E2 | mul     edx
0x0043E077 | 89 D7 | mov     edi, edx
0x0043E079 | C1 EF 06 | shr     edi, 6
0x0043E07C | 69 C7 E8 03 00 00 | imul    eax, edi, 3E8h
0x0043E082 | 89 F7 | mov     edi, esi
0x0043E084 | 29 C7 | sub     edi, eax
0x0043E086 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0043E089 | BA D3 4D 62 10 | mov     edx, 10624DD3h
0x0043E08E | F7 E2 | mul     edx
0x0043E090 | C1 EA 06 | shr     edx, 6
0x0043E093 | 41 89 D2 | mov     r10d, edx
0x0043E096 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E09B | 44 8B 40 44 | mov     r8d, [rax+44h]
0x0043E09F | BA D3 4D 62 10 | mov     edx, 10624DD3h
0x0043E0A4 | 44 89 C0 | mov     eax, r8d
0x0043E0A7 | F7 E2 | mul     edx
0x0043E0A9 | 89 D6 | mov     esi, edx
0x0043E0AB | C1 EE 06 | shr     esi, 6
0x0043E0AE | 69 C6 E8 03 00 00 | imul    eax, esi, 3E8h
0x0043E0B4 | 44 89 C6 | mov     esi, r8d
0x0043E0B7 | 29 C6 | sub     esi, eax
0x0043E0B9 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E0BE | 8B 40 44 | mov     eax, [rax+44h]
0x0043E0C1 | BA D3 4D 62 10 | mov     edx, 10624DD3h
0x0043E0C6 | F7 E2 | mul     edx
0x0043E0C8 | 89 D0 | mov     eax, edx
0x0043E0CA | C1 E8 06 | shr     eax, 6
0x0043E0CD | 48 83 EC 08 | sub     rsp, 8
0x0043E0D1 | 51 | push    rcx
0x0043E0D2 | 41 89 F8 | mov     r8d, edi
0x0043E0D5 | 44 89 D1 | mov     ecx, r10d
0x0043E0D8 | 89 F2 | mov     edx, esi
0x0043E0DA | 89 C6 | mov     esi, eax
0x0043E0DC | BF 78 B6 52 00 | mov     edi, offset aRoundTripMinAv; "round-trip min/avg/max = %u.%03u/%u.%03"...
0x0043E0E1 | B8 00 00 00 00 | mov     eax, 0
0x0043E0E6 | E8 E5 8A FC FF | call    _printf
0x0043E0EB | 48 83 C4 10 | add     rsp, 10h
0x0043E0EF | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E0F4 | 48 8B 40 30 | mov     rax, [rax+30h]
0x0043E0F8 | 48 85 C0 | test    rax, rax
0x0043E0FB | 74 24 | jz      short loc_43E121
0x0043E0FD | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E102 | 8B 40 58 | mov     eax, [rax+58h]
0x0043E105 | 85 C0 | test    eax, eax
0x0043E107 | 74 1F | jz      short loc_43E128
0x0043E109 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E10E | 48 8B 40 30 | mov     rax, [rax+30h]
0x0043E112 | BA F8 B3 75 00 | mov     edx, offset dest
0x0043E117 | 8B 52 1C | mov     edx, [rdx+1Ch]
0x0043E11A | 89 D2 | mov     edx, edx
0x0043E11C | 48 39 D0 | cmp     rax, rdx
0x0043E11F | 73 07 | jnb     short loc_43E128
0x0043E121 | B8 01 00 00 00 | mov     eax, 1
0x0043E126 | EB 05 | jmp     short loc_43E12D
0x0043E128 | B8 00 00 00 00 | mov     eax, 0
0x0043E12D | 89 C7 | mov     edi, eax; status
0x0043E12F | E8 8C 99 FC FF | call    _exit
 ************ 
Source Code:
static void print_stats_and_exit(int junk UNUSED_PARAM)
{
	signal(SIGINT, SIG_IGN);

	printf("
--- %s ping statistics ---
", hostname);
	printf("%lu packets transmitted, ", ntransmitted);
	printf("%lu packets received, ", nreceived);
	if (nrepeats)
		printf("%lu duplicates, ", nrepeats);
	if (ntransmitted)
		ntransmitted = (ntransmitted - nreceived) * 100 / ntransmitted;
	printf("%lu%% packet loss
", ntransmitted);
	if (tmin != UINT_MAX) {
		unsigned tavg = tsum / (nreceived + nrepeats);
		printf("round-trip min/avg/max = %u.%03u/%u.%03u/%u.%03u ms
",
			tmin / 1000, tmin % 1000,
			tavg / 1000, tavg % 1000,
			tmax / 1000, tmax % 1000);
	}
	/* if condition is true, exit with 1 -- 'failure' */
	exit(nreceived == 0 || (deadline && nreceived < pingcount));
}
 ************ 
Parsed Output:
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>

struct PingStats {
    unsigned long packets_transmitted;
    unsigned long packets_received;
    unsigned long duplicates;
    unsigned long packet_loss;
    unsigned long min_time;
    unsigned long avg_time;
    unsigned long max_time;
    unsigned long mdev;
    unsigned long transmitted_bytes;
    unsigned long received_bytes;
    int status;
};

void print_ping_statistics(struct PingStats *stats) {
    signal(SIGINT, handler);

    printf("
--- %s ping statistics ---
", (char *)(stats + 0x78));
    printf("%lu packets transmitted, ", stats->packets_transmitted);
    printf("%lu packets received, ", stats->packets_received);

    if (stats->duplicates) {
        printf("%lu duplicates, ", stats->duplicates);
    }

    if (stats->packets_transmitted) {
        unsigned long lost_packets = stats->packets_transmitted - stats->packets_received;
        unsigned long loss_percent = (lost_packets * 100) / stats->packets_transmitted;
        stats->packet_loss = loss_percent;
    }

    printf("%lu%% packet loss
", stats->packet_loss);

    if (stats->received_bytes != 0xFFFFFFFF) {
        unsigned long total_received = stats->packets_received + stats->duplicates;
        unsigned long avg_time = stats->avg_time / total_received;
        stats->avg_time = avg_time;

        unsigned long min_time = stats->min_time;
        unsigned long max_time = stats->max_time;
        unsigned long mdev = stats->mdev;

        unsigned long min_time_ms = (min_time * 1000) / 0x10624DD3;
        unsigned long avg_time_ms = (avg_time * 1000) / 0x10624DD3;
        unsigned long max_time_ms = (max_time * 1000) / 0x10624DD3;
        unsigned long mdev_ms = (mdev * 1000) / 0x10624DD3;

        printf("round-trip min/avg/max/mdev = %u.%03u/%u.%03u/%u.%03u/%u.%03u ms
",
               min_time_ms / 1000, min_time_ms % 1000,
               avg_time_ms / 1000, avg_time_ms % 1000,
               max_time_ms / 1000, max_time_ms % 1000,
               mdev_ms / 1000, mdev_ms % 1000);
    }

    if (stats->packets_received && stats->received_bytes && stats->received_bytes < stats->transmitted_bytes) {
        stats->status = 1;
    } else {
        stats->status = 0;
    }

    exit(stats->status);
}
 ************ 
Similarity Score (Unixcoder): 0.7843313813209534
Func rank: 10

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: out_args
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00464183 | 55 | push    rbp
0x00464184 | 48 89 E5 | mov     rbp, rsp
0x00464187 | 48 83 EC 30 | sub     rsp, 30h
0x0046418B | 48 89 7D D8 | mov     [rbp+var_28], rdi
0x0046418F | C7 45 F4 00 00 00 00 | mov     [rbp+var_C], 0
0x00464196 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x0046419A | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0046419E | EB 7D | jmp     short loc_46421D
0x004641A0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004641A4 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004641A7 | 3C 5C | cmp     al, 5Ch ; '\'
0x004641A9 | 75 10 | jnz     short loc_4641BB
0x004641AB | BF C9 61 53 00 | mov     edi, offset asc_5361C9; "\\\\"
0x004641B0 | E8 7D FC FF FF | call    sub_463E32
0x004641B5 | 83 45 F4 02 | add     [rbp+var_C], 2
0x004641B9 | EB 5D | jmp     short loc_464218
0x004641BB | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004641BF | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004641C2 | 3C 1F | cmp     al, 1Fh
0x004641C4 | 7E 22 | jle     short loc_4641E8
0x004641C6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004641CA | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004641CD | 3C 7F | cmp     al, 7Fh
0x004641CF | 74 17 | jz      short loc_4641E8
0x004641D1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004641D5 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004641D8 | 0F BE C0 | movsx   eax, al
0x004641DB | 89 C7 | mov     edi, eax
0x004641DD | E8 F3 FB FF FF | call    sub_463DD5
0x004641E2 | 83 45 F4 01 | add     [rbp+var_C], 1
0x004641E6 | EB 30 | jmp     short loc_464218
0x004641E8 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004641EC | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004641EF | 0F B6 D0 | movzx   edx, al
0x004641F2 | 48 8D 45 EF | lea     rax, [rbp+s]
0x004641F6 | BE CC 61 53 00 | mov     esi, offset a03o; "\\%03o"
0x004641FB | 48 89 C7 | mov     rdi, rax; s
0x004641FE | B8 00 00 00 00 | mov     eax, 0
0x00464203 | E8 78 38 FA FF | call    _sprintf
0x00464208 | 48 8D 45 EF | lea     rax, [rbp+s]
0x0046420C | 48 89 C7 | mov     rdi, rax
0x0046420F | E8 1E FC FF FF | call    sub_463E32
0x00464214 | 83 45 F4 04 | add     [rbp+var_C], 4
0x00464218 | 48 83 45 F8 01 | add     [rbp+var_8], 1
0x0046421D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00464221 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00464224 | 84 C0 | test    al, al
0x00464226 | 0F 85 74 FF FF FF | jnz     loc_4641A0
0x0046422C | 8B 45 F4 | mov     eax, [rbp+var_C]
0x0046422F | C9 | leave
0x00464230 | C3 | retn
 ************ 
Source Code:
static int out_args(const char *mystr)
{
	const char *here;
	int strcount = 0;
	char tmpstr[5];

	for (here = mystr; *here; here++) {
		if (*here == '\\') {
			out_string("\\\\");
			strcount += 2;
		} else if (*here >= ' ' && *here < 0x7f) {
			out_char(*here);
			strcount++;
		} else {
			sprintf(tmpstr, "\\%03o", (unsigned char) *here);
			out_string(tmpstr);
			strcount += 4;
		}
	}

	return strcount;
}
 ************ 
Parsed Output:
int escape_string_length(const char *input) {
    int length = 0;
    char s[4];

    while (*input) {
        if (*input == '\\') {
            length += 2;
        } else if (*input <= 0x1F || *input == 0x7F) {
            sprintf(s, "\\%03o", (unsigned char)*input);
            length += 4;
        } else {
            length += 1;
        }
        input++;
    }

    return length;
}
 ************ 
Similarity Score (Unixcoder): 0.7793459296226501
Func rank: 11

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: fopen_or_warn
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004097EE | 55 | push    rbp
0x004097EF | 48 89 E5 | mov     rbp, rsp
0x004097F2 | 48 83 EC 20 | sub     rsp, 20h
0x004097F6 | 48 89 7D E8 | mov     [rbp+filename], rdi
0x004097FA | 48 89 75 E0 | mov     [rbp+modes], rsi
0x004097FE | 48 8B 55 E0 | mov     rdx, [rbp+modes]
0x00409802 | 48 8B 45 E8 | mov     rax, [rbp+filename]
0x00409806 | 48 89 D6 | mov     rsi, rdx; modes
0x00409809 | 48 89 C7 | mov     rdi, rax; filename
0x0040980C | E8 3F D9 FF FF | call    _fopen64
0x00409811 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00409815 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0040981A | 75 0C | jnz     short loc_409828
0x0040981C | 48 8B 45 E8 | mov     rax, [rbp+filename]
0x00409820 | 48 89 C7 | mov     rdi, rax
0x00409823 | E8 45 FB FF FF | call    sub_40936D
0x00409828 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040982C | C9 | leave
0x0040982D | C3 | retn
 ************ 
Source Code:
FAST_FUNC fopen_or_warn(const char *path, const char *mode)
{
	FILE *fp = fopen(path, mode);
	if (!fp) {
		bb_simple_perror_msg(path);
		//errno = 0; /* why? */
	}
	return fp;
}
 ************ 
Parsed Output:
FILE *open_file(const char *filename, const char *modes) {
    FILE *file = fopen64(filename, modes);
    if (file == NULL) {
        sub_40936D(filename);
    }
    return file;
}
 ************ 
Similarity Score (Unixcoder): 0.7763688564300537
Func rank: 12

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: handle_size_or_mdtm
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0042A051 | 55 | push    rbp
0x0042A052 | 48 89 E5 | mov     rbp, rsp
0x0042A055 | 48 81 EC 20 01 00 00 | sub     rsp, 120h
0x0042A05C | 89 BD EC FE FF FF | mov     [rbp+var_114], edi
0x0042A062 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0042A067 | 48 8B 40 40 | mov     rax, [rax+40h]
0x0042A06B | 48 85 C0 | test    rax, rax
0x0042A06E | 74 2E | jz      short loc_42A09E
0x0042A070 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0042A075 | 48 8B 40 40 | mov     rax, [rax+40h]
0x0042A079 | 48 8D 95 70 FF FF FF | lea     rdx, [rbp+stat_buf]
0x0042A080 | 48 89 D6 | mov     rsi, rdx; stat_buf
0x0042A083 | 48 89 C7 | mov     rdi, rax; filename
0x0042A086 | E8 65 DD FD FF | call    sub_407DF0
0x0042A08B | 85 C0 | test    eax, eax
0x0042A08D | 75 0F | jnz     short loc_42A09E
0x0042A08F | 8B 45 88 | mov     eax, [rbp+stat_buf.st_mode]
0x0042A092 | 25 00 F0 00 00 | and     eax, 0F000h
0x0042A097 | 3D 00 80 00 00 | cmp     eax, 8000h
0x0042A09C | 74 0F | jz      short loc_42A0AD
0x0042A09E | BF 35 35 30 20 | mov     edi, 20303535h
0x0042A0A3 | E8 C8 F4 FF FF | call    sub_429570
0x0042A0A8 | E9 A6 00 00 00 | jmp     locret_42A153
0x0042A0AD | 83 BD EC FE FF FF 00 | cmp     [rbp+var_114], 0
0x0042A0B4 | 74 1F | jz      short loc_42A0D5
0x0042A0B6 | 48 8B 55 A0 | mov     rdx, [rbp+stat_buf.st_size]
0x0042A0BA | 48 8D 85 F0 FE FF FF | lea     rax, [rbp+s]
0x0042A0C1 | BE 72 B3 52 00 | mov     esi, offset a213Lu; "213 %lu\r\n"
0x0042A0C6 | 48 89 C7 | mov     rdi, rax; s
0x0042A0C9 | B8 00 00 00 00 | mov     eax, 0
0x0042A0CE | E8 AD D9 FD FF | call    _sprintf
0x0042A0D3 | EB 6F | jmp     short loc_42A144
0x0042A0D5 | 48 8D 85 30 FF FF FF | lea     rax, [rbp+tp]
0x0042A0DC | 48 8D 95 70 FF FF FF | lea     rdx, [rbp+stat_buf]
0x0042A0E3 | 48 83 C2 58 | add     rdx, 58h ; 'X'
0x0042A0E7 | 48 89 C6 | mov     rsi, rax; tp
0x0042A0EA | 48 89 D7 | mov     rdi, rdx; timer
0x0042A0ED | E8 7E CB FD FF | call    _gmtime_r
0x0042A0F2 | 8B 8D 30 FF FF FF | mov     ecx, [rbp+tp.tm_sec]
0x0042A0F8 | 8B 95 34 FF FF FF | mov     edx, [rbp+tp.tm_min]
0x0042A0FE | 44 8B 8D 38 FF FF FF | mov     r9d, [rbp+tp.tm_hour]
0x0042A105 | 44 8B 85 3C FF FF FF | mov     r8d, [rbp+tp.tm_mday]
0x0042A10C | 8B 85 40 FF FF FF | mov     eax, [rbp+tp.tm_mon]
0x0042A112 | 8D 78 01 | lea     edi, [rax+1]
0x0042A115 | 8B 85 44 FF FF FF | mov     eax, [rbp+tp.tm_year]
0x0042A11B | 8D B0 6C 07 00 00 | lea     esi, [rax+76Ch]
0x0042A121 | 48 8D 85 F0 FE FF FF | lea     rax, [rbp+s]
0x0042A128 | 51 | push    rcx
0x0042A129 | 52 | push    rdx
0x0042A12A | 89 F9 | mov     ecx, edi
0x0042A12C | 89 F2 | mov     edx, esi
0x0042A12E | BE 80 B3 52 00 | mov     esi, offset a21304u02u02u02; "213 %04u%02u%02u%02u%02u%02u\r\n"
0x0042A133 | 48 89 C7 | mov     rdi, rax; s
0x0042A136 | B8 00 00 00 00 | mov     eax, 0
0x0042A13B | E8 40 D9 FD FF | call    _sprintf
0x0042A140 | 48 83 C4 10 | add     rsp, 10h
0x0042A144 | 48 8D 85 F0 FE FF FF | lea     rax, [rbp+s]
0x0042A14B | 48 89 C7 | mov     rdi, rax
0x0042A14E | E8 65 F4 FF FF | call    sub_4295B8
0x0042A153 | C9 | leave
0x0042A154 | C3 | retn
 ************ 
Source Code:
static void
handle_size_or_mdtm(int need_size)
{
	struct stat statbuf;
	struct tm broken_out;
	char buf[(sizeof("NNN %"OFF_FMT"u\r
") + sizeof(off_t) * 3)
		| sizeof("NNN YYYYMMDDhhmmss\r
")
	];

	if (!G.ftp_arg
	 || stat(G.ftp_arg, &statbuf) != 0
	 || !S_ISREG(statbuf.st_mode)
	) {
		WRITE_ERR(FTP_FILEFAIL);
		return;
	}
	if (need_size) {
		sprintf(buf, STR(FTP_STATFILE_OK)" %"OFF_FMT"u\r
", statbuf.st_size);
	} else {
		gmtime_r(&statbuf.st_mtime, &broken_out);
		sprintf(buf, STR(FTP_STATFILE_OK)" %04u%02u%02u%02u%02u%02u\r
",
			broken_out.tm_year + 1900,
			broken_out.tm_mon + 1,
			broken_out.tm_mday,
			broken_out.tm_hour,
			broken_out.tm_min,
			broken_out.tm_sec);
	}
	cmdio_write_raw(buf);
}
 ************ 
Parsed Output:
#include <stdio.h>
#include <time.h>
#include <sys/stat.h>

void processFileInformation(int flag) {
    struct stat stat_buf;
    char s[256];
    struct tm tp;
    int result = stat("dest", &stat_buf);

    if (result != 0) {
        handleError(20303535);
        return;
    }

    if ((stat_buf.st_mode & 0xF000) == 0x8000) {
        if (flag != 0) {
            sprintf(s, "213 %lu\r
", stat_buf.st_size);
        } else {
            gmtime_r(&stat_buf.st_mtime, &tp);
            sprintf(s, "213 %04u%02u%02u%02u%02u%02u\r
",
                    tp.tm_year + 1900, tp.tm_mon + 1, tp.tm_mday,
                    tp.tm_hour, tp.tm_min, tp.tm_sec);
        }
    } else {
        handleError(20303535);
        return;
    }

    outputResult(s);
}
 ************ 
Similarity Score (Unixcoder): 0.7759232521057129
Func rank: 13

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: collect_mem
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00460936 | 55 | push    rbp
0x00460937 | 48 89 E5 | mov     rbp, rsp
0x0046093A | 48 83 EC 40 | sub     rsp, 40h
0x0046093E | 48 89 7D C8 | mov     [rbp+var_38], rdi
0x00460942 | 48 C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0
0x0046094A | 48 C7 45 F0 00 00 00 00 | mov     [rbp+var_10], 0
0x00460952 | 48 C7 45 E8 00 00 00 00 | mov     [rbp+var_18], 0
0x0046095A | 48 C7 45 E0 00 00 00 00 | mov     [rbp+var_20], 0
0x00460962 | 48 C7 45 D8 00 00 00 00 | mov     [rbp+var_28], 0
0x0046096A | 48 8B 05 97 CA 2F 00 | mov     rax, cs:qword_75D408
0x00460971 | 48 83 C0 60 | add     rax, 60h ; '`'
0x00460975 | 48 89 C7 | mov     rdi, rax
0x00460978 | E8 FC EE FF FF | call    sub_45F879
0x0046097D | 48 89 C7 | mov     rdi, rax
0x00460980 | 48 8D 45 F8 | lea     rax, [rbp+var_8]
0x00460984 | B9 01 00 00 00 | mov     ecx, 1
0x00460989 | 48 89 C2 | mov     rdx, rax
0x0046098C | BE 1F BE 51 00 | mov     esi, offset aMemtotal; "MemTotal:"
0x00460991 | B8 00 00 00 00 | mov     eax, 0
0x00460996 | E8 24 F1 FF FF | call    sub_45FABF
0x0046099B | 85 C0 | test    eax, eax
0x0046099D | 74 0F | jz      short loc_4609AE
0x0046099F | BF 04 00 00 00 | mov     edi, 4
0x004609A4 | E8 C3 ED FF FF | call    sub_45F76C
0x004609A9 | E9 2F 01 00 00 | jmp     locret_460ADD
0x004609AE | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x004609B2 | 0F B6 40 18 | movzx   eax, byte ptr [rax+18h]
0x004609B6 | 3C 74 | cmp     al, 74h ; 't'
0x004609B8 | 75 15 | jnz     short loc_4609CF
0x004609BA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004609BE | 48 C1 E0 0A | shl     rax, 0Ah
0x004609C2 | 48 89 C7 | mov     rdi, rax
0x004609C5 | E8 44 F4 FF FF | call    sub_45FE0E
0x004609CA | E9 0E 01 00 00 | jmp     locret_460ADD
0x004609CF | 48 8B 05 32 CA 2F 00 | mov     rax, cs:qword_75D408
0x004609D6 | 48 8B 40 60 | mov     rax, [rax+60h]
0x004609DA | 48 8D 55 F0 | lea     rdx, [rbp+var_10]
0x004609DE | B9 01 00 00 00 | mov     ecx, 1
0x004609E3 | BE 29 BE 51 00 | mov     esi, offset aMemfree; "MemFree:"
0x004609E8 | 48 89 C7 | mov     rdi, rax
0x004609EB | B8 00 00 00 00 | mov     eax, 0
0x004609F0 | E8 CA F0 FF FF | call    sub_45FABF
0x004609F5 | 85 C0 | test    eax, eax
0x004609F7 | 75 7E | jnz     short loc_460A77
0x004609F9 | 48 8B 05 08 CA 2F 00 | mov     rax, cs:qword_75D408
0x00460A00 | 48 8B 40 60 | mov     rax, [rax+60h]
0x00460A04 | 48 8D 55 E8 | lea     rdx, [rbp+var_18]
0x00460A08 | B9 01 00 00 00 | mov     ecx, 1
0x00460A0D | BE 32 BE 51 00 | mov     esi, offset aBuffers_1; "Buffers:"
0x00460A12 | 48 89 C7 | mov     rdi, rax
0x00460A15 | B8 00 00 00 00 | mov     eax, 0
0x00460A1A | E8 A0 F0 FF FF | call    sub_45FABF
0x00460A1F | 85 C0 | test    eax, eax
0x00460A21 | 75 54 | jnz     short loc_460A77
0x00460A23 | 48 8B 05 DE C9 2F 00 | mov     rax, cs:qword_75D408
0x00460A2A | 48 8B 40 60 | mov     rax, [rax+60h]
0x00460A2E | 48 8D 55 E0 | lea     rdx, [rbp+var_20]
0x00460A32 | B9 01 00 00 00 | mov     ecx, 1
0x00460A37 | BE 3B BE 51 00 | mov     esi, offset aCached; "Cached:"
0x00460A3C | 48 89 C7 | mov     rdi, rax
0x00460A3F | B8 00 00 00 00 | mov     eax, 0
0x00460A44 | E8 76 F0 FF FF | call    sub_45FABF
0x00460A49 | 85 C0 | test    eax, eax
0x00460A4B | 75 2A | jnz     short loc_460A77
0x00460A4D | 48 8B 05 B4 C9 2F 00 | mov     rax, cs:qword_75D408
0x00460A54 | 48 8B 40 60 | mov     rax, [rax+60h]
0x00460A58 | 48 8D 55 D8 | lea     rdx, [rbp+var_28]
0x00460A5C | B9 01 00 00 00 | mov     ecx, 1
0x00460A61 | BE 43 BE 51 00 | mov     esi, offset aSlab; "Slab:"
0x00460A66 | 48 89 C7 | mov     rdi, rax
0x00460A69 | B8 00 00 00 00 | mov     eax, 0
0x00460A6E | E8 4C F0 FF FF | call    sub_45FABF
0x00460A73 | 85 C0 | test    eax, eax
0x00460A75 | 74 0C | jz      short loc_460A83
0x00460A77 | BF 04 00 00 00 | mov     edi, 4
0x00460A7C | E8 EB EC FF FF | call    sub_45F76C
0x00460A81 | EB 5A | jmp     short locret_460ADD
0x00460A83 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x00460A87 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00460A8B | 48 01 C2 | add     rdx, rax
0x00460A8E | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00460A92 | 48 01 C2 | add     rdx, rax
0x00460A95 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00460A99 | 48 01 D0 | add     rax, rdx
0x00460A9C | 48 89 45 F0 | mov     [rbp+var_10], rax
0x00460AA0 | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x00460AA4 | 0F B6 40 18 | movzx   eax, byte ptr [rax+18h]
0x00460AA8 | 0F BE C0 | movsx   eax, al
0x00460AAB | 83 F8 66 | cmp     eax, 66h ; 'f'
0x00460AAE | 75 12 | jnz     short loc_460AC2
0x00460AB0 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00460AB4 | 48 C1 E0 0A | shl     rax, 0Ah
0x00460AB8 | 48 89 C7 | mov     rdi, rax
0x00460ABB | E8 4E F3 FF FF | call    sub_45FE0E
0x00460AC0 | EB 1B | jmp     short locret_460ADD
0x00460AC2 | 48 8B 55 F8 | mov     rdx, [rbp+var_8]
0x00460AC6 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00460ACA | 48 29 C2 | sub     rdx, rax
0x00460ACD | 48 89 D0 | mov     rax, rdx
0x00460AD0 | 48 C1 E0 0A | shl     rax, 0Ah
0x00460AD4 | 48 89 C7 | mov     rdi, rax
0x00460AD7 | E8 32 F3 FF FF | call    sub_45FE0E
0x00460ADC | 90 | nop
0x00460ADD | C9 | leave
0x00460ADE | C3 | retn
 ************ 
Source Code:
4096 kB
static void FAST_FUNC collect_mem(mem_stat *s)
{
	ullong m_total = 0;
	ullong m_free = 0;
	ullong m_bufs = 0;
	ullong m_cached = 0;
	ullong m_slab = 0;

	if (rdval(get_file(&proc_meminfo), "MemTotal:", &m_total, 1)) {
		put_question_marks(4);
		return;
	}
	if (s->opt == 't') {
		scale(m_total << 10);
		return;
	}

	if (rdval(proc_meminfo.file, "MemFree:", &m_free  , 1)
	 || rdval(proc_meminfo.file, "Buffers:", &m_bufs  , 1)
	 || rdval(proc_meminfo.file, "Cached:",  &m_cached, 1)
	 || rdval(proc_meminfo.file, "Slab:",    &m_slab  , 1)
	) {
		put_question_marks(4);
		return;
	}

	m_free += m_bufs + m_cached + m_slab;
	switch (s->opt) {
	case 'f':
		scale(m_free << 10); break;
	default:
		scale((m_total - m_free) << 10); break;
	}
}
 ************ 
Parsed Output:
#include <stdint.h>

void processMemoryInfo(uint64_t *info) {
    uint64_t memTotal = 0;
    uint64_t memFree = 0;
    uint64_t buffers = 0;
    uint64_t cached = 0;
    uint64_t slab = 0;
    uint64_t *memInfoBase = (uint64_t *)0x75D408 + 0x60; // Adjusted for the actual address

    if (sub_45F879(memInfoBase) == 0) {
        exit(4);
    }

    if (info[3] == 't') {
        memTotal = sub_45FE0E(memTotal << 10);
    } else {
        if (sub_45FABF(memInfoBase, "MemFree:", 1) == 0) {
            memFree = 0;
        } else {
            exit(4);
        }

        if (sub_45FABF(memInfoBase, "Buffers:", 1) == 0) {
            buffers = 0;
        } else {
            exit(4);
        }

        if (sub_45FABF(memInfoBase, "Cached:", 1) == 0) {
            cached = 0;
        } else {
            exit(4);
        }

        if (sub_45FABF(memInfoBase, "Slab:", 1) == 0) {
            slab = 0;
        } else {
            exit(4);
        }

        memFree += buffers + cached + slab;
        memTotal += memFree;

        if (info[3] == 'f') {
            memFree = sub_45FE0E(memFree << 10);
        } else {
            memTotal -= memFree;
            memTotal = sub_45FE0E(memTotal << 10);
        }
    }
}
 ************ 
Similarity Score (Unixcoder): 0.7710984945297241
Func rank: 14

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: quote_special_chars
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004FF303 | 55 | push    rbp
0x004FF304 | 48 89 E5 | mov     rbp, rsp
0x004FF307 | 48 83 EC 20 | sub     rsp, 20h
0x004FF30B | 48 89 7D E8 | mov     [rbp+s], rdi
0x004FF30F | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004FF316 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004FF31A | 48 89 C7 | mov     rdi, rax; s
0x004FF31D | E8 AE 77 F0 FF | call    _strlen
0x004FF322 | 48 83 C0 01 | add     rax, 1
0x004FF326 | 48 01 C0 | add     rax, rax
0x004FF329 | 48 89 C7 | mov     rdi, rax
0x004FF32C | E8 B7 AD F0 FF | call    sub_40A0E8
0x004FF331 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x004FF335 | EB 50 | jmp     short loc_4FF387
0x004FF337 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004FF33B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004FF33E | 0F BE C0 | movsx   eax, al
0x004FF341 | 89 C7 | mov     edi, eax
0x004FF343 | E8 9C FF FF FF | call    sub_4FF2E4
0x004FF348 | 48 85 C0 | test    rax, rax
0x004FF34B | 74 16 | jz      short loc_4FF363
0x004FF34D | 8B 45 FC | mov     eax, [rbp+var_4]
0x004FF350 | 8D 50 01 | lea     edx, [rax+1]
0x004FF353 | 89 55 FC | mov     [rbp+var_4], edx
0x004FF356 | 48 63 D0 | movsxd  rdx, eax
0x004FF359 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004FF35D | 48 01 D0 | add     rax, rdx
0x004FF360 | C6 00 5C | mov     byte ptr [rax], 5Ch ; '\'
0x004FF363 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004FF367 | 48 8D 50 01 | lea     rdx, [rax+1]
0x004FF36B | 48 89 55 E8 | mov     [rbp+s], rdx
0x004FF36F | 8B 55 FC | mov     edx, [rbp+var_4]
0x004FF372 | 8D 4A 01 | lea     ecx, [rdx+1]
0x004FF375 | 89 4D FC | mov     [rbp+var_4], ecx
0x004FF378 | 48 63 CA | movsxd  rcx, edx
0x004FF37B | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x004FF37F | 48 01 CA | add     rdx, rcx
0x004FF382 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004FF385 | 88 02 | mov     [rdx], al
0x004FF387 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x004FF38B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004FF38E | 84 C0 | test    al, al
0x004FF390 | 75 A5 | jnz     short loc_4FF337
0x004FF392 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004FF396 | C9 | leave
0x004FF397 | C3 | retn
 ************ 
Source Code:
static char *quote_special_chars(char *found)
{
	int l = 0;
	char *s = xzalloc((strlen(found) + 1) * 2);

	while (*found) {
		if (is_special_char(*found))
			s[l++] = '\\';
		s[l++] = *found++;
	}
	/* s[l] = '\0'; - already is */
	return s;
}
 ************ 
Parsed Output:
#include <string.h>

char* escape_special_chars(const char* s) {
    int len = strlen(s);
    char* result = (char*)malloc(2 * len + 1);
    if (!result) return NULL;

    int j = 0;
    for (int i = 0; s[i] != '\0'; ++i) {
        if (sub_4FF2E4(s[i])) {
            result[j++] = '\\';
        }
        result[j++] = s[i];
    }
    result[j] = '\0';
    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.7710480093955994
Func rank: 15

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: print_char
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004CDB91 | 55 | push    rbp
0x004CDB92 | 48 89 E5 | mov     rbp, rsp
0x004CDB95 | 48 83 EC 30 | sub     rsp, 30h
0x004CDB99 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004CDB9D | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004CDBA1 | 48 89 55 D8 | mov     [rbp+format], rdx
0x004CDBA5 | EB 28 | jmp     short loc_4CDBCF
0x004CDBA7 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004CDBAB | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004CDBAE | 0F B6 C0 | movzx   eax, al
0x004CDBB1 | 89 45 FC | mov     [rbp+var_4], eax
0x004CDBB4 | 8B 55 FC | mov     edx, [rbp+var_4]
0x004CDBB7 | 48 8B 45 D8 | mov     rax, [rbp+format]
0x004CDBBB | 89 D6 | mov     esi, edx
0x004CDBBD | 48 89 C7 | mov     rdi, rax; format
0x004CDBC0 | B8 00 00 00 00 | mov     eax, 0
0x004CDBC5 | E8 06 90 F3 FF | call    _printf
0x004CDBCA | 48 83 45 E0 01 | add     [rbp+var_20], 1
0x004CDBCF | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004CDBD3 | 48 8D 50 FF | lea     rdx, [rax-1]
0x004CDBD7 | 48 89 55 E8 | mov     [rbp+var_18], rdx
0x004CDBDB | 48 85 C0 | test    rax, rax
0x004CDBDE | 75 C7 | jnz     short loc_4CDBA7
0x004CDBE0 | 90 | nop
0x004CDBE1 | C9 | leave
0x004CDBE2 | C3 | retn
 ************ 
Source Code:
static void
print_char(size_t n_bytes, const char *block, const char *fmt_string)
{
	while (n_bytes--) {
		unsigned tmp = *(unsigned char *) block;
		printf(fmt_string, tmp);
		block += sizeof(unsigned char);
	}
}
 ************ 
Parsed Output:
void printCharacters(const char *format, const char *str, int count) {
    for (int i = count; i > 0; --i) {
        printf(format, *str++);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.7704088091850281
Func rank: 16

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: pid_is_exec
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004D9236 | 55 | push    rbp
0x004D9237 | 48 89 E5 | mov     rbp, rsp
0x004D923A | 48 83 EC 50 | sub     rsp, 50h
0x004D923E | 89 7D BC | mov     [rbp+var_44], edi
0x004D9241 | 8B 55 BC | mov     edx, [rbp+var_44]
0x004D9244 | 48 8D 45 C0 | lea     rax, [rbp+s]
0x004D9248 | BE 80 26 53 00 | mov     esi, offset aProcUExe; "/proc/%u/exe"
0x004D924D | 48 89 C7 | mov     rdi, rax; s
0x004D9250 | B8 00 00 00 00 | mov     eax, 0
0x004D9255 | E8 26 E8 F2 FF | call    _sprintf
0x004D925A | 48 98 | cdqe
0x004D925C | 48 8D 50 FD | lea     rdx, [rax-3]
0x004D9260 | 48 8D 45 C0 | lea     rax, [rbp+s]
0x004D9264 | 48 01 D0 | add     rax, rdx
0x004D9267 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004D926B | 48 8D 45 C0 | lea     rax, [rbp+s]
0x004D926F | 48 89 C7 | mov     rdi, rax
0x004D9272 | E8 9C 1C F3 FF | call    sub_40AF13
0x004D9277 | 48 89 45 F0 | mov     [rbp+s2], rax
0x004D927B | 48 83 7D F0 00 | cmp     [rbp+s2], 0
0x004D9280 | 74 23 | jz      short loc_4D92A5
0x004D9282 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004D9287 | 48 8B 40 18 | mov     rax, [rax+18h]
0x004D928B | 48 8B 55 F0 | mov     rdx, [rbp+s2]
0x004D928F | 48 89 D6 | mov     rsi, rdx; s2
0x004D9292 | 48 89 C7 | mov     rdi, rax; s1
0x004D9295 | E8 B6 DD F2 FF | call    _strcmp
0x004D929A | 85 C0 | test    eax, eax
0x004D929C | 75 07 | jnz     short loc_4D92A5
0x004D929E | B8 01 00 00 00 | mov     eax, 1
0x004D92A3 | EB 05 | jmp     short loc_4D92AA
0x004D92A5 | B8 00 00 00 00 | mov     eax, 0
0x004D92AA | 89 45 EC | mov     [rbp+var_14], eax
0x004D92AD | 48 8B 45 F0 | mov     rax, [rbp+s2]
0x004D92B1 | 48 89 C7 | mov     rdi, rax; ptr
0x004D92B4 | E8 A7 D3 F2 FF | call    _free
0x004D92B9 | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x004D92BD | 74 05 | jz      short loc_4D92C4
0x004D92BF | 8B 45 EC | mov     eax, [rbp+var_14]
0x004D92C2 | EB 7D | jmp     short locret_4D9341
0x004D92C4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004D92C8 | 48 B9 63 6D 64 6C 69 6E 65 00 | mov     rcx, 656E696C646D63h
0x004D92D2 | 48 89 08 | mov     [rax], rcx
0x004D92D5 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004D92DA | 8B 40 30 | mov     eax, [rax+30h]
0x004D92DD | 89 C2 | mov     edx, eax
0x004D92DF | B8 F8 B3 75 00 | mov     eax, offset dest
0x004D92E4 | 48 8B 48 28 | mov     rcx, [rax+28h]
0x004D92E8 | 48 8D 45 C0 | lea     rax, [rbp+s]
0x004D92EC | 48 89 CE | mov     rsi, rcx
0x004D92EF | 48 89 C7 | mov     rdi, rax
0x004D92F2 | E8 0A 22 F3 FF | call    sub_40B501
0x004D92F7 | 48 89 45 E0 | mov     [rbp+var_20], rax
0x004D92FB | 48 83 7D E0 00 | cmp     [rbp+var_20], 0
0x004D9300 | 7E 3A | jle     short loc_4D933C
0x004D9302 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004D9307 | 48 8B 50 28 | mov     rdx, [rax+28h]
0x004D930B | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004D930F | 48 01 D0 | add     rax, rdx
0x004D9312 | C6 00 00 | mov     byte ptr [rax], 0
0x004D9315 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004D931A | 48 8B 50 28 | mov     rdx, [rax+28h]
0x004D931E | B8 F8 B3 75 00 | mov     eax, offset dest
0x004D9323 | 48 8B 40 18 | mov     rax, [rax+18h]
0x004D9327 | 48 89 D6 | mov     rsi, rdx; s2
0x004D932A | 48 89 C7 | mov     rdi, rax; s1
0x004D932D | E8 1E DD F2 FF | call    _strcmp
0x004D9332 | 85 C0 | test    eax, eax
0x004D9334 | 0F 94 C0 | setz    al
0x004D9337 | 0F B6 C0 | movzx   eax, al
0x004D933A | EB 05 | jmp     short locret_4D9341
0x004D933C | B8 00 00 00 00 | mov     eax, 0
0x004D9341 | C9 | leave
0x004D9342 | C3 | retn
 ************ 
Source Code:
static int pid_is_exec(pid_t pid)
{
	struct stat st;
	char buf[sizeof("/proc/%u/exe") + sizeof(int)*3];

	sprintf(buf, "/proc/%u/exe", (unsigned)pid);
	if (stat(buf, &st) < 0)
		return 0;
	if (st.st_dev == execstat.st_dev
	 && st.st_ino == execstat.st_ino)
		return 1;
	return 0;
}
 ************ 
Parsed Output:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int check_process_name(int pid) {
    char s[80];
    sprintf(s, "/proc/%u/exe", pid);
    char *s2 = sub_40AF13(s);
    if (s2 != NULL) {
        if (strcmp(dest + 24, s2) == 0) {
            free(s2);
            return 1;
        }
        free(s2);
    }

    strcpy(s + strlen(s) - 3, "cmdline");
    int result = sub_40B501(s, dest + 40);
    if (result > 0) {
        dest[40 + result] = '\0';
        if (strcmp(dest + 24, dest + 40) == 0) {
            return 1;
        }
    }
    return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.7583965063095093
Func rank: 17

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: xdup2
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0040A443 | 55 | push    rbp
0x0040A444 | 48 89 E5 | mov     rbp, rsp
0x0040A447 | 48 83 EC 10 | sub     rsp, 10h
0x0040A44B | 89 7D FC | mov     [rbp+fd], edi
0x0040A44E | 89 75 F8 | mov     [rbp+fd2], esi
0x0040A451 | 8B 55 F8 | mov     edx, [rbp+fd2]
0x0040A454 | 8B 45 FC | mov     eax, [rbp+fd]
0x0040A457 | 89 D6 | mov     esi, edx; fd2
0x0040A459 | 89 C7 | mov     edi, eax; fd
0x0040A45B | E8 20 C7 FF FF | call    _dup2
0x0040A460 | 39 45 F8 | cmp     [rbp+fd2], eax
0x0040A463 | 74 0F | jz      short loc_40A474
0x0040A465 | BF 60 80 52 00 | mov     edi, offset aCanTDuplicateF; "can't duplicate file descriptor"
0x0040A46A | B8 00 00 00 00 | mov     eax, 0
0x0040A46F | E8 2E EE FF FF | call    sub_4092A2
0x0040A474 | 90 | nop
0x0040A475 | C9 | leave
0x0040A476 | C3 | retn
 ************ 
Source Code:
void FAST_FUNC xdup2(int from, int to)
{
	if (dup2(from, to) != to)
		bb_perror_msg_and_die("can't duplicate file descriptor");
}
 ************ 
Parsed Output:
#include <unistd.h>

void duplicateFileDescriptor(int oldfd, int newfd) {
    if (dup2(oldfd, newfd) != newfd) {
        perror("can't duplicate file descriptor");
        exit(1);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.748607873916626
Func rank: 18

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: install_sighandler
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00480305 | 55 | push    rbp
0x00480306 | 48 89 E5 | mov     rbp, rsp
0x00480309 | 48 81 EC B0 00 00 00 | sub     rsp, 0B0h
0x00480310 | 89 BD 5C FF FF FF | mov     [rbp+sig], edi
0x00480316 | 48 89 B5 50 FF FF FF | mov     [rbp+var_B0], rsi
0x0048031D | 48 8B 05 E4 D0 2D 00 | mov     rax, cs:qword_75D408
0x00480324 | 48 8B 95 50 FF FF FF | mov     rdx, [rbp+var_B0]
0x0048032B | 48 89 90 40 01 00 00 | mov     [rax+140h], rdx
0x00480332 | 48 8B 05 CF D0 2D 00 | mov     rax, cs:qword_75D408
0x00480339 | 48 8D 88 40 01 00 00 | lea     rcx, [rax+140h]
0x00480340 | 48 8D 95 60 FF FF FF | lea     rdx, [rbp+var_A0]; oact
0x00480347 | 8B 85 5C FF FF FF | mov     eax, [rbp+sig]
0x0048034D | 48 89 CE | mov     rsi, rcx; act
0x00480350 | 89 C7 | mov     edi, eax; sig
0x00480352 | E8 19 65 F8 FF | call    _sigaction
0x00480357 | 48 8B 85 60 FF FF FF | mov     rax, [rbp+var_A0]
0x0048035E | C9 | leave
0x0048035F | C3 | retn
 ************ 
Source Code:
static sighandler_t install_sighandler(int sig, sighandler_t handler)
{
	struct sigaction old_sa;

	/* We could use signal() to install handlers... almost:
	 * except that we need to mask ALL signals while handlers run.
	 * I saw signal nesting in strace, race window isn't small.
	 * SA_RESTART is also needed, but in Linux, signal()
	 * sets SA_RESTART too.
	 */
	/* memset(&G.sa, 0, sizeof(G.sa)); - already done */
	/* sigfillset(&G.sa.sa_mask);      - already done */
	/* G.sa.sa_flags = SA_RESTART;     - already done */
	G.sa.sa_handler = handler;
	sigaction(sig, &G.sa, &old_sa);
	return old_sa.sa_handler;
}
 ************ 
Parsed Output:
#include <signal.h>

void set_signal_handler(int sig, struct sigaction *act) {
    struct sigaction *oact = (struct sigaction *)((char *)qword_75D408 + 0x140);
    sigaction(sig, act, oact);
}
 ************ 
Similarity Score (Unixcoder): 0.7389364838600159
Func rank: 19

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: run_parts_main
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004D9040 | 55 | push    rbp
0x004D9041 | 48 89 E5 | mov     rbp, rsp
0x004D9044 | 41 54 | push    r12
0x004D9046 | 53 | push    rbx
0x004D9047 | 48 83 EC 40 | sub     rsp, 40h
0x004D904B | 89 7D BC | mov     [rbp+var_44], edi
0x004D904E | 48 89 75 B0 | mov     [rbp+var_50], rsi
0x004D9052 | 48 C7 45 D0 F1 70 53 00 | mov     [rbp+var_30], offset unk_5370F1
0x004D905A | 48 C7 45 C8 00 00 00 00 | mov     [rbp+var_38], 0
0x004D9062 | 48 C7 05 DB 43 28 00 CA 70 53 00 | mov     cs:qword_75D448, offset aArg; "arg"
0x004D906D | 48 C7 05 C8 43 28 00 F4 70 53 00 | mov     cs:qword_75D440, offset a1A; "=1:a::"
0x004D9078 | 48 8D 4D D0 | lea     rcx, [rbp+var_30]
0x004D907C | 48 8D 55 C8 | lea     rdx, [rbp+var_38]
0x004D9080 | 48 8B 45 B0 | mov     rax, [rbp+var_50]
0x004D9084 | BE FB 70 53 00 | mov     esi, offset aRaUTl; "ra:u:tl"
0x004D9089 | 48 89 C7 | mov     rdi, rax
0x004D908C | B8 00 00 00 00 | mov     eax, 0
0x004D9091 | E8 59 11 02 00 | call    sub_4FA1EF
0x004D9096 | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004D909A | B9 FF 0F 00 00 | mov     ecx, 0FFFh
0x004D909F | BA 00 00 00 00 | mov     edx, 0
0x004D90A4 | BE 08 00 00 00 | mov     esi, 8
0x004D90A9 | 48 89 C7 | mov     rdi, rax
0x004D90AC | E8 1E 1F 03 00 | call    sub_50AFCF
0x004D90B1 | 89 C7 | mov     edi, eax; mask
0x004D90B3 | E8 78 E0 F2 FF | call    _umask
0x004D90B8 | C7 45 EC 01 00 00 00 | mov     [rbp+var_14], 1
0x004D90BF | EB 28 | jmp     short loc_4D90E9
0x004D90C1 | 41 BC F8 B3 75 00 | mov     r12d, offset dest
0x004D90C7 | 8B 5D EC | mov     ebx, [rbp+var_14]
0x004D90CA | 8D 43 01 | lea     eax, [rbx+1]
0x004D90CD | 89 45 EC | mov     [rbp+var_14], eax
0x004D90D0 | 48 8D 45 C8 | lea     rax, [rbp+var_38]
0x004D90D4 | 48 89 C7 | mov     rdi, rax
0x004D90D7 | E8 8B FF F2 FF | call    sub_409067
0x004D90DC | 48 89 C2 | mov     rdx, rax
0x004D90DF | 89 D8 | mov     eax, ebx
0x004D90E1 | 48 83 C0 02 | add     rax, 2
0x004D90E5 | 49 89 14 C4 | mov     [r12+rax*8], rdx
0x004D90E9 | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x004D90ED | 48 85 C0 | test    rax, rax
0x004D90F0 | 74 09 | jz      short loc_4D90FB
0x004D90F2 | 81 7D EC FB 03 00 00 | cmp     [rbp+var_14], 3FBh
0x004D90F9 | 76 C6 | jbe     short loc_4D90C1
0x004D90FB | 8B 05 77 1D 28 00 | mov     eax, cs:optind
0x004D9101 | 48 98 | cdqe
0x004D9103 | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]
0x004D910B | 48 8B 45 B0 | mov     rax, [rbp+var_50]
0x004D910F | 48 01 D0 | add     rax, rdx
0x004D9112 | 48 8B 00 | mov     rax, [rax]
0x004D9115 | 41 B9 01 00 00 00 | mov     r9d, 1
0x004D911B | 41 B8 00 00 00 00 | mov     r8d, 0
0x004D9121 | B9 69 8F 4D 00 | mov     ecx, offset sub_4D8F69
0x004D9126 | BA 69 8F 4D 00 | mov     edx, offset sub_4D8F69
0x004D912B | BE 03 00 00 00 | mov     esi, 3
0x004D9130 | 48 89 C7 | mov     rdi, rax
0x004D9133 | E8 F4 E3 02 00 | call    sub_50752C
0x004D9138 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004D913D | 48 8B 00 | mov     rax, [rax]
0x004D9140 | 48 85 C0 | test    rax, rax
0x004D9143 | 75 0A | jnz     short loc_4D914F
0x004D9145 | B8 00 00 00 00 | mov     eax, 0
0x004D914A | E9 DE 00 00 00 | jmp     loc_4D922D
0x004D914F | B8 F8 B3 75 00 | mov     eax, offset dest
0x004D9154 | 8B 40 08 | mov     eax, [rax+8]
0x004D9157 | 48 63 F0 | movsxd  rsi, eax; nmemb
0x004D915A | B8 F8 B3 75 00 | mov     eax, offset dest
0x004D915F | 48 8B 00 | mov     rax, [rax]
0x004D9162 | B9 24 8F 4D 00 | mov     ecx, offset sub_4D8F24; compar
0x004D9167 | BA 08 00 00 00 | mov     edx, 8; size
0x004D916C | 48 89 C7 | mov     rdi, rax; base
0x004D916F | E8 DC D6 F2 FF | call    _qsort
0x004D9174 | C7 45 EC 00 00 00 00 | mov     [rbp+var_14], 0
0x004D917B | BA F8 B3 75 00 | mov     edx, offset dest
0x004D9180 | 48 8B 02 | mov     rax, [rdx]
0x004D9183 | 48 8D 48 08 | lea     rcx, [rax+8]
0x004D9187 | 48 89 0A | mov     [rdx], rcx
0x004D918A | 48 8B 00 | mov     rax, [rax]
0x004D918D | 48 89 45 E0 | mov     [rbp+s], rax
0x004D9191 | 48 83 7D E0 00 | cmp     [rbp+s], 0
0x004D9196 | 0F 84 8D 00 00 00 | jz      loc_4D9229
0x004D919C | 8B 05 AE 42 28 00 | mov     eax, cs:dword_75D450
0x004D91A2 | 83 E0 18 | and     eax, 18h
0x004D91A5 | 85 C0 | test    eax, eax
0x004D91A7 | 74 0E | jz      short loc_4D91B7
0x004D91A9 | 48 8B 45 E0 | mov     rax, [rbp+s]
0x004D91AD | 48 89 C7 | mov     rdi, rax; s
0x004D91B0 | E8 5B D6 F2 FF | call    _puts
0x004D91B5 | EB 6D | jmp     short loc_4D9224
0x004D91B7 | BA F8 B3 75 00 | mov     edx, offset dest
0x004D91BC | 48 8B 45 E0 | mov     rax, [rbp+s]
0x004D91C0 | 48 89 42 10 | mov     [rdx+10h], rax
0x004D91C4 | B8 08 B4 75 00 | mov     eax, offset dest.c_line
0x004D91C9 | 48 89 C7 | mov     rdi, rax
0x004D91CC | E8 53 14 03 00 | call    sub_50A624
0x004D91D1 | 89 45 DC | mov     [rbp+var_24], eax
0x004D91D4 | 83 7D DC 00 | cmp     [rbp+var_24], 0
0x004D91D8 | 74 49 | jz      short loc_4D9223
0x004D91DA | C7 45 EC 01 00 00 00 | mov     [rbp+var_14], 1
0x004D91E1 | 83 7D DC 00 | cmp     [rbp+var_24], 0
0x004D91E5 | 79 1B | jns     short loc_4D9202
0x004D91E7 | 48 8B 45 E0 | mov     rax, [rbp+s]
0x004D91EB | 48 89 C6 | mov     rsi, rax
0x004D91EE | BF 03 71 53 00 | mov     edi, offset aCanTExecuteS_7; "can't execute '%s'"
0x004D91F3 | B8 00 00 00 00 | mov     eax, 0
0x004D91F8 | E8 DC FF F2 FF | call    sub_4091D9
0x004D91FD | E9 79 FF FF FF | jmp     loc_4D917B
0x004D9202 | 8B 45 DC | mov     eax, [rbp+var_24]
0x004D9205 | 0F B6 D0 | movzx   edx, al
0x004D9208 | 48 8B 45 E0 | mov     rax, [rbp+s]
0x004D920C | 48 89 C6 | mov     rsi, rax
0x004D920F | BF 16 71 53 00 | mov     edi, offset aSExitedWithCod; "%s exited with code %d"
0x004D9214 | B8 00 00 00 00 | mov     eax, 0
0x004D9219 | E8 29 05 F3 FF | call    sub_409747
0x004D921E | E9 58 FF FF FF | jmp     loc_4D917B
0x004D9223 | 90 | nop
0x004D9224 | E9 52 FF FF FF | jmp     loc_4D917B
0x004D9229 | 90 | nop
0x004D922A | 8B 45 EC | mov     eax, [rbp+var_14]
0x004D922D | 48 83 C4 40 | add     rsp, 40h
0x004D9231 | 5B | pop     rbx
0x004D9232 | 41 5C | pop     r12
0x004D9234 | 5D | pop     rbp
0x004D9235 | C3 | retn
 ************ 
Source Code:
int run_parts_main(int argc UNUSED_PARAM, char **argv)
{
	const char *umask_p = "22";
	llist_t *arg_list = NULL;
	unsigned n;
	int ret;

	INIT_G();

#if ENABLE_FEATURE_RUN_PARTS_LONG_OPTIONS
	applet_long_options = runparts_longopts;
#endif
	/* We require exactly one argument: the directory name */
	opt_complementary = "=1:a::";
	getopt32(argv, "ra:u:t"IF_FEATURE_RUN_PARTS_FANCY("l"), &arg_list, &umask_p);

	umask(xstrtou_range(umask_p, 8, 0, 07777));

	n = 1;
	while (arg_list && n < NUM_CMD) {
		cmd[n++] = llist_pop(&arg_list);
	}
	/* cmd[n] = NULL; - is already zeroed out */

	/* run-parts has to sort executables by name before running them */

	recursive_action(argv[optind],
			ACTION_RECURSE|ACTION_FOLLOWLINKS,
			act,            /* file action */
			act,            /* dir action */
			NULL,           /* user data */
			1               /* depth */
		);

	if (!names)
		return 0;

	qsort(names, cur, sizeof(char *), bb_alphasort);

	n = 0;
	while (1) {
		char *name = *names++;
		if (!name)
			break;
		if (option_mask32 & (OPT_t | OPT_l)) {
			puts(name);
			continue;
		}
		cmd[0] = name;
		ret = spawn_and_wait(cmd);
		if (ret == 0)
			continue;
		n = 1;
		if (ret < 0)
			bb_perror_msg("can't execute '%s'", name);
		else /* ret > 0 */
			bb_error_msg("%s exited with code %d", name, ret & 0xff);
	}

	return n;
}
 ************ 
Parsed Output:
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

int execute_command(char **argv) {
    void *unk_5370F1 = &unk_5370F1; // Placeholder for unknown data
    int var_38 = 0;
    const char *arg = "arg";
    const char *a1A = "=1:a::";
    const char *aRaUTl = "ra:u:tl";
    int mask;
    int var_14 = 1;
    void *dest = &dest; // Placeholder for destination address

    sub_4FA1EF(argv, aRaUTl);
    mask = sub_50AFCF(unk_5370F1, 0xFFF, 0, 8);
    _umask(mask);

    while (var_38 != 0 && var_14 <= 0x3FB) {
        void *result = sub_409067(&var_38);
        dest[var_14 + 2] = result;
        var_14++;
    }

    int optind_value = optind;
    char *first_arg = argv[optind_value];
    sub_50752C(first_arg, sub_4D8F69, sub_4D8F69, 3, 1, 0);

    if (dest[0] == NULL) {
        return 0;
    }

    qsort(dest[0], dest[1], 8, sub_4D8F24);

    char *s = dest[2];
    if (s == NULL) {
        return var_14;
    }

    int flags = dword_75D450;
    if (flags & 0x18) {
        puts(s);
    } else {
        dest[4] = s;
        int result = sub_50A624(dest.c_line);
        int var_24 = result;

        if (var_24 != 0) {
            var_14 = 1;
            if (var_24 < 0) {
                printf("can't execute '%s'", s);
            } else {
                printf("%s exited with code %d", s, var_24);
            }
        }
    }

    return var_14;
}
 ************ 
Similarity Score (Unixcoder): 0.7388392686843872
Func rank: 20

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: procnetdev_version
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00436DA9 | 55 | push    rbp
0x00436DAA | 48 89 E5 | mov     rbp, rsp
0x00436DAD | 48 83 EC 10 | sub     rsp, 10h
0x00436DB1 | 48 89 7D F8 | mov     [rbp+haystack], rdi
0x00436DB5 | 48 8B 45 F8 | mov     rax, [rbp+haystack]
0x00436DB9 | BE 58 97 51 00 | mov     esi, offset aCompressed; "compressed"
0x00436DBE | 48 89 C7 | mov     rdi, rax; haystack
0x00436DC1 | E8 FA 0E FD FF | call    _strstr
0x00436DC6 | 48 85 C0 | test    rax, rax
0x00436DC9 | 74 07 | jz      short loc_436DD2
0x00436DCB | B8 02 00 00 00 | mov     eax, 2
0x00436DD0 | EB 22 | jmp     short locret_436DF4
0x00436DD2 | 48 8B 45 F8 | mov     rax, [rbp+haystack]
0x00436DD6 | BE 63 97 51 00 | mov     esi, offset aBytes_0; "bytes"
0x00436DDB | 48 89 C7 | mov     rdi, rax; haystack
0x00436DDE | E8 DD 0E FD FF | call    _strstr
0x00436DE3 | 48 85 C0 | test    rax, rax
0x00436DE6 | 74 07 | jz      short loc_436DEF
0x00436DE8 | B8 01 00 00 00 | mov     eax, 1
0x00436DED | EB 05 | jmp     short locret_436DF4
0x00436DEF | B8 00 00 00 00 | mov     eax, 0
0x00436DF4 | C9 | leave
0x00436DF5 | C3 | retn
 ************ 
Source Code:
static int procnetdev_version(char *buf)
{
	if (strstr(buf, "compressed"))
		return 2;
	if (strstr(buf, "bytes"))
		return 1;
	return 0;
}
 ************ 
Parsed Output:
int checkFileType(const char *haystack) {
    if (strstr(haystack, "compressed")) {
        return 2;
    } else if (strstr(haystack, "bytes")) {
        return 1;
    }
    return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.72562175989151
Func rank: 21

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: get_terminal_width_height
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00409E70 | 55 | push    rbp
0x00409E71 | 48 89 E5 | mov     rbp, rsp
0x00409E74 | 48 83 EC 30 | sub     rsp, 30h
0x00409E78 | 89 7D EC | mov     [rbp+fd], edi
0x00409E7B | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00409E7F | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x00409E83 | 66 C7 45 F8 00 00 | mov     [rbp+var_8], 0
0x00409E89 | 66 C7 45 FA 00 00 | mov     [rbp+var_6], 0
0x00409E8F | 48 8D 55 F8 | lea     rdx, [rbp+var_8]
0x00409E93 | 8B 45 EC | mov     eax, [rbp+fd]
0x00409E96 | BE 13 54 00 00 | mov     esi, 5413h; request
0x00409E9B | 89 C7 | mov     edi, eax; fd
0x00409E9D | B8 00 00 00 00 | mov     eax, 0
0x00409EA2 | E8 F9 CE FF FF | call    _ioctl
0x00409EA7 | 85 C0 | test    eax, eax
0x00409EA9 | 75 09 | jnz     short loc_409EB4
0x00409EAB | 0F B7 45 F8 | movzx   eax, [rbp+var_8]
0x00409EAF | 66 85 C0 | test    ax, ax
0x00409EB2 | 75 07 | jnz     short loc_409EBB
0x00409EB4 | B8 01 00 00 00 | mov     eax, 1
0x00409EB9 | EB 05 | jmp     short loc_409EC0
0x00409EBB | B8 00 00 00 00 | mov     eax, 0
0x00409EC0 | 89 45 F4 | mov     [rbp+var_C], eax
0x00409EC3 | 48 83 7D D8 00 | cmp     [rbp+var_28], 0
0x00409EC8 | 74 27 | jz      short loc_409EF1
0x00409ECA | 0F B7 45 F8 | movzx   eax, [rbp+var_8]
0x00409ECE | 0F B7 C0 | movzx   eax, ax
0x00409ED1 | 48 8D 55 F4 | lea     rdx, [rbp+var_C]
0x00409ED5 | 48 89 D1 | mov     rcx, rdx
0x00409ED8 | BA C0 4F 53 00 | mov     edx, offset aLines; "LINES"
0x00409EDD | BE 18 00 00 00 | mov     esi, 18h
0x00409EE2 | 89 C7 | mov     edi, eax
0x00409EE4 | E8 21 FF FF FF | call    sub_409E0A
0x00409EE9 | 89 C2 | mov     edx, eax
0x00409EEB | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00409EEF | 89 10 | mov     [rax], edx
0x00409EF1 | 48 83 7D E0 00 | cmp     [rbp+var_20], 0
0x00409EF6 | 74 27 | jz      short loc_409F1F
0x00409EF8 | 0F B7 45 FA | movzx   eax, [rbp+var_6]
0x00409EFC | 0F B7 C0 | movzx   eax, ax
0x00409EFF | 48 8D 55 F4 | lea     rdx, [rbp+var_C]
0x00409F03 | 48 89 D1 | mov     rcx, rdx
0x00409F06 | BA C6 4F 53 00 | mov     edx, offset aColumns; "COLUMNS"
0x00409F0B | BE 50 00 00 00 | mov     esi, 50h ; 'P'
0x00409F10 | 89 C7 | mov     edi, eax
0x00409F12 | E8 F3 FE FF FF | call    sub_409E0A
0x00409F17 | 89 C2 | mov     edx, eax
0x00409F19 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00409F1D | 89 10 | mov     [rax], edx
0x00409F1F | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00409F22 | C9 | leave
0x00409F23 | C3 | retn
 ************ 
Source Code:
int FAST_FUNC get_terminal_width_height(int fd, unsigned *width, unsigned *height)
{
	struct winsize win;
	int err;

	win.ws_row = 0;
	win.ws_col = 0;
	/* I've seen ioctl returning 0, but row/col is (still?) 0.
	 * We treat that as an error too.  */
	err = ioctl(fd, TIOCGWINSZ, &win) != 0 || win.ws_row == 0;
	if (height)
		*height = wh_helper(win.ws_row, 24, "LINES", &err);
	if (width)
		*width = wh_helper(win.ws_col, 80, "COLUMNS", &err);
	return err;
}
 ************ 
Parsed Output:
int get_terminal_dimensions(int fd, int *lines, int *columns) {
    unsigned short var_8 = 0;
    unsigned short var_6 = 0;
    int result = 0;

    if (_ioctl(fd, 0x5413, &var_8) == 0 && var_8 != 0) {
        result = 1;
    }

    if (lines != NULL) {
        *lines = sub_409E0A(var_8, "LINES", 0x18);
    }

    if (columns != NULL) {
        *columns = sub_409E0A(var_6, "COLUMNS", 0x50);
    }

    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.7233688235282898
Func rank: 22

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: xsetenv_proto
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00440C5D | 55 | push    rbp
0x00440C5E | 48 89 E5 | mov     rbp, rsp
0x00440C61 | 48 83 EC 30 | sub     rsp, 30h
0x00440C65 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00440C69 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00440C6D | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x00440C71 | 48 8B 4D D8 | mov     rcx, [rbp+var_28]
0x00440C75 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00440C79 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00440C7D | 48 89 C6 | mov     rsi, rax
0x00440C80 | BF 4E BA 52 00 | mov     edi, offset aSSS_2; "%s%s=%s"
0x00440C85 | B8 00 00 00 00 | mov     eax, 0
0x00440C8A | E8 24 9A FC FF | call    sub_40A6B3
0x00440C8F | 48 89 45 F8 | mov     [rbp+string], rax
0x00440C93 | BA F8 B3 75 00 | mov     edx, offset dest
0x00440C98 | 48 8B 42 18 | mov     rax, [rdx+18h]
0x00440C9C | 48 8D 48 08 | lea     rcx, [rax+8]
0x00440CA0 | 48 89 4A 18 | mov     [rdx+18h], rcx
0x00440CA4 | 48 8B 55 F8 | mov     rdx, [rbp+string]
0x00440CA8 | 48 89 10 | mov     [rax], rdx
0x00440CAB | 48 8B 45 F8 | mov     rax, [rbp+string]
0x00440CAF | 48 89 C7 | mov     rdi, rax; string
0x00440CB2 | E8 59 63 FC FF | call    _putenv
0x00440CB7 | 90 | nop
0x00440CB8 | C9 | leave
0x00440CB9 | C3 | retn
 ************ 
Source Code:
static void xsetenv_proto(const char *proto, const char *n, const char *v)
{
	char *var = xasprintf("%s%s=%s", proto, n, v);
	*env_cur++ = var;
	putenv(var);
}
 ************ 
Parsed Output:
#include <stdio.h>

void setEnvironmentVariable(const char *key, const char *value, void *dest) {
    char *formattedString;
    formattedString = snprintf(NULL, 0, "%s%s=%s", key, value);
    *((void **)(dest + 0x18)) = (char *)dest + 0x18 + 0x8;
    *((void **)(*((void **)(dest + 0x18)))) = formattedString;
    _putenv(formattedString);
}
 ************ 
Similarity Score (Unixcoder): 0.7210114002227783
Func rank: 23

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: restore_state_and_exit
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0044076F | 55 | push    rbp
0x00440770 | 48 89 E5 | mov     rbp, rsp
0x00440773 | 48 83 EC 50 | sub     rsp, 50h
0x00440777 | 89 7D BC | mov     [rbp+status], edi
0x0044077A | BA FC B3 75 00 | mov     edx, 75B3FCh
0x0044077F | B8 F8 B3 75 00 | mov     eax, offset dest
0x00440784 | 8B 00 | mov     eax, [rax]
0x00440786 | B9 E4 5A 53 00 | mov     ecx, offset aTiocsetd; "TIOCSETD"
0x0044078B | BE 23 54 00 00 | mov     esi, 5423h
0x00440790 | 89 C7 | mov     edi, eax
0x00440792 | E8 71 A5 FC FF | call    sub_40AD08
0x00440797 | 85 C0 | test    eax, eax
0x00440799 | 79 07 | jns     short loc_4407A2
0x0044079B | C7 45 BC 01 00 00 00 | mov     [rbp+status], 1
0x004407A2 | B8 00 B4 75 00 | mov     eax, offset dest.c_cflag
0x004407A7 | 48 8B 10 | mov     rdx, [rax]
0x004407AA | 48 8B 48 08 | mov     rcx, [rax+8]
0x004407AE | 48 89 55 C0 | mov     qword ptr [rbp+termios_p.c_iflag], rdx
0x004407B2 | 48 89 4D C8 | mov     qword ptr [rbp+termios_p.c_cflag], rcx
0x004407B6 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x004407BA | 48 8B 48 18 | mov     rcx, [rax+18h]
0x004407BE | 48 89 55 D0 | mov     qword ptr [rbp+termios_p.c_line], rdx
0x004407C2 | 48 89 4D D8 | mov     qword ptr [rbp+termios_p.c_cc+7], rcx
0x004407C6 | 48 8B 50 20 | mov     rdx, [rax+20h]
0x004407CA | 48 8B 48 28 | mov     rcx, [rax+28h]
0x004407CE | 48 89 55 E0 | mov     qword ptr [rbp+termios_p.c_cc+0Fh], rdx
0x004407D2 | 48 89 4D E8 | mov     qword ptr [rbp+termios_p.c_cc+17h], rcx
0x004407D6 | 48 8B 50 30 | mov     rdx, [rax+30h]
0x004407DA | 48 89 55 F0 | mov     qword ptr [rbp+termios_p.c_cc+1Fh], rdx
0x004407DE | 8B 40 38 | mov     eax, [rax+38h]
0x004407E1 | 89 45 F8 | mov     [rbp+termios_p.c_ospeed], eax
0x004407E4 | 48 8D 45 C0 | lea     rax, [rbp+termios_p]
0x004407E8 | BE 00 00 00 00 | mov     esi, 0; speed
0x004407ED | 48 89 C7 | mov     rdi, rax; termios_p
0x004407F0 | E8 5B 70 FC FF | call    _cfsetispeed
0x004407F5 | 48 8D 45 C0 | lea     rax, [rbp+termios_p]
0x004407F9 | BE 00 00 00 00 | mov     esi, 0; speed
0x004407FE | 48 89 C7 | mov     rdi, rax; termios_p
0x00440801 | E8 8A 62 FC FF | call    _cfsetospeed
0x00440806 | 48 8D 45 C0 | lea     rax, [rbp+termios_p]
0x0044080A | 48 89 C7 | mov     rdi, rax
0x0044080D | E8 14 FF FF FF | call    sub_440726
0x00440812 | 85 C0 | test    eax, eax
0x00440814 | 74 07 | jz      short loc_44081D
0x00440816 | C7 45 BC 01 00 00 00 | mov     [rbp+status], 1
0x0044081D | BF 01 00 00 00 | mov     edi, 1; seconds
0x00440822 | E8 19 74 FC FF | call    _sleep
0x00440827 | B8 00 B4 75 00 | mov     eax, offset dest.c_cflag
0x0044082C | 48 89 C7 | mov     rdi, rax
0x0044082F | E8 F2 FE FF FF | call    sub_440726
0x00440834 | 85 C0 | test    eax, eax
0x00440836 | 74 0A | jz      short loc_440842
0x00440838 | BF 01 00 00 00 | mov     edi, 1; status
0x0044083D | E8 7E 72 FC FF | call    _exit
0x00440842 | 8B 45 BC | mov     eax, [rbp+status]
0x00440845 | 89 C7 | mov     edi, eax; status
0x00440847 | E8 74 72 FC FF | call    _exit
 ************ 
Source Code:
static void restore_state_and_exit(int exitcode)
{
	struct termios state;

	/* Restore line discipline */
	if (ioctl_or_warn(handle, TIOCSETD, &saved_disc) < 0) {
		exitcode = 1;
	}

	/* Hangup */
	memcpy(&state, &saved_state, sizeof(state));
	cfsetispeed(&state, B0);
	cfsetospeed(&state, B0);
	if (set_termios_state_or_warn(&state))
		exitcode = 1;
	sleep(1);

	/* Restore line status */
	if (set_termios_state_or_warn(&saved_state))
		exit(EXIT_FAILURE);
	if (ENABLE_FEATURE_CLEAN_UP)
		close(handle);

	exit(exitcode);
}
 ************ 
Parsed Output:
#include <termios.h> // for termios structure
#include <unistd.h>  // for sleep and _exit functions

int configure_serial_port() {
    int status = 0;
    struct termios termios_p;
    int result;

    result = sub_40AD08(dest, "TIOCSETD", 0x5423);
    if (result < 0) {
        status = 1;
    }

    termios_p.c_iflag = dest.c_iflag;
    termios_p.c_cflag = dest.c_cflag;
    termios_p.c_line = dest.c_line;
    termios_p.c_cc[7] = dest.c_cc[7];
    termios_p.c_cc[15] = dest.c_cc[15];
    termios_p.c_cc[23] = dest.c_cc[23];
    termios_p.c_cc[31] = dest.c_cc[31];
    termios_p.c_ospeed = dest.c_ospeed;

    _cfsetispeed(&termios_p, 0);
    _cfsetospeed(&termios_p, 0);

    result = sub_440726(&termios_p);
    if (result != 0) {
        status = 1;
    }

    sleep(1);

    result = sub_440726(&dest.c_cflag);
    if (result != 0) {
        _exit(1);
    }

    _exit(status);
}
 ************ 
Similarity Score (Unixcoder): 0.7196806073188782
Func rank: 24

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: handle_retr
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00429C7C | 55 | push    rbp
0x00429C7D | 48 89 E5 | mov     rbp, rsp
0x00429C80 | 48 81 EC C0 00 00 00 | sub     rsp, 0C0h
0x00429C87 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00429C8C | 48 8B 40 20 | mov     rax, [rax+20h]
0x00429C90 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00429C94 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00429C99 | 48 C7 40 20 00 00 00 00 | mov     qword ptr [rax+20h], 0
0x00429CA1 | E8 38 FC FF FF | call    sub_4298DE
0x00429CA6 | 85 C0 | test    eax, eax
0x00429CA8 | 0F 84 4F 01 00 00 | jz      loc_429DFD
0x00429CAE | B8 F8 B3 75 00 | mov     eax, offset dest
0x00429CB3 | 48 8B 40 40 | mov     rax, [rax+40h]
0x00429CB7 | 48 85 C0 | test    rax, rax
0x00429CBA | 74 1D | jz      short loc_429CD9
0x00429CBC | B8 F8 B3 75 00 | mov     eax, offset dest
0x00429CC1 | 48 8B 40 40 | mov     rax, [rax+40h]
0x00429CC5 | BE 00 08 00 00 | mov     esi, 800h; oflag
0x00429CCA | 48 89 C7 | mov     rdi, rax; file
0x00429CCD | B8 00 00 00 00 | mov     eax, 0
0x00429CD2 | E8 F9 D9 FD FF | call    _open64
0x00429CD7 | EB 05 | jmp     short loc_429CDE
0x00429CD9 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x00429CDE | 89 45 F4 | mov     [rbp+fildes], eax
0x00429CE1 | 83 7D F4 00 | cmp     [rbp+fildes], 0
0x00429CE5 | 79 0F | jns     short loc_429CF6
0x00429CE7 | BF 35 35 30 20 | mov     edi, 20303535h
0x00429CEC | E8 7F F8 FF FF | call    sub_429570
0x00429CF1 | E9 08 01 00 00 | jmp     locret_429DFE
0x00429CF6 | 48 8D 95 40 FF FF FF | lea     rdx, [rbp+stat_buf]
0x00429CFD | 8B 45 F4 | mov     eax, [rbp+fildes]
0x00429D00 | 48 89 D6 | mov     rsi, rdx; stat_buf
0x00429D03 | 89 C7 | mov     edi, eax; fildes
0x00429D05 | E8 F6 E0 FD FF | call    sub_407E00
0x00429D0A | 85 C0 | test    eax, eax
0x00429D0C | 75 12 | jnz     short loc_429D20
0x00429D0E | 8B 85 58 FF FF FF | mov     eax, [rbp+stat_buf.st_mode]
0x00429D14 | 25 00 F0 00 00 | and     eax, 0F000h
0x00429D19 | 3D 00 80 00 00 | cmp     eax, 8000h
0x00429D1E | 74 0F | jz      short loc_429D2F
0x00429D20 | BF 35 35 30 20 | mov     edi, 20303535h
0x00429D25 | E8 46 F8 FF FF | call    sub_429570
0x00429D2A | E9 B6 00 00 00 | jmp     loc_429DE5
0x00429D2F | BA F8 B3 75 00 | mov     edx, offset dest
0x00429D34 | 8B 45 F4 | mov     eax, [rbp+fildes]
0x00429D37 | 89 42 04 | mov     [rdx+4], eax
0x00429D3A | 8B 45 F4 | mov     eax, [rbp+fildes]
0x00429D3D | 89 C7 | mov     edi, eax
0x00429D3F | E8 98 FC FD FF | call    sub_4099DC
0x00429D44 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00429D49 | 74 16 | jz      short loc_429D61
0x00429D4B | 48 8B 4D F8 | mov     rcx, [rbp+var_8]
0x00429D4F | 8B 45 F4 | mov     eax, [rbp+fildes]
0x00429D52 | BA 00 00 00 00 | mov     edx, 0
0x00429D57 | 48 89 CE | mov     rsi, rcx
0x00429D5A | 89 C7 | mov     edi, eax
0x00429D5C | E8 F6 07 FE FF | call    sub_40A557
0x00429D61 | 48 8B 95 70 FF FF FF | mov     rdx, [rbp+stat_buf.st_size]
0x00429D68 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00429D6D | 48 8B 40 40 | mov     rax, [rax+40h]
0x00429D71 | 48 89 C6 | mov     rsi, rax
0x00429D74 | BF 10 B3 52 00 | mov     edi, offset aOpeningBinaryC; " Opening BINARY connection for %s (%lu "...
0x00429D79 | B8 00 00 00 00 | mov     eax, 0
0x00429D7E | E8 30 09 FE FF | call    sub_40A6B3
0x00429D83 | 48 89 45 E8 | mov     [rbp+ptr], rax
0x00429D87 | 48 8B 45 E8 | mov     rax, [rbp+ptr]
0x00429D8B | 48 89 C7 | mov     rdi, rax
0x00429D8E | E8 F2 FA FF FF | call    sub_429885
0x00429D93 | 89 45 E4 | mov     [rbp+fd], eax
0x00429D96 | 48 8B 45 E8 | mov     rax, [rbp+ptr]
0x00429D9A | 48 89 C7 | mov     rdi, rax; ptr
0x00429D9D | E8 BE C8 FD FF | call    _free
0x00429DA2 | 83 7D E4 00 | cmp     [rbp+fd], 0
0x00429DA6 | 78 3C | js      short loc_429DE4
0x00429DA8 | 8B 55 E4 | mov     edx, [rbp+fd]
0x00429DAB | 8B 45 F4 | mov     eax, [rbp+fildes]
0x00429DAE | 89 D6 | mov     esi, edx
0x00429DB0 | 89 C7 | mov     edi, eax
0x00429DB2 | E8 AF 15 FE FF | call    sub_40B366
0x00429DB7 | 48 89 45 D8 | mov     [rbp+var_28], rax
0x00429DBB | 8B 45 E4 | mov     eax, [rbp+fd]
0x00429DBE | 89 C7 | mov     edi, eax; fd
0x00429DC0 | E8 4B D0 FD FF | call    _close
0x00429DC5 | 48 83 7D D8 00 | cmp     [rbp+var_28], 0
0x00429DCA | 79 0C | jns     short loc_429DD8
0x00429DCC | BF 34 35 31 20 | mov     edi, 20313534h
0x00429DD1 | E8 9A F7 FF FF | call    sub_429570
0x00429DD6 | EB 0D | jmp     short loc_429DE5
0x00429DD8 | BF 32 32 36 20 | mov     edi, 20363232h
0x00429DDD | E8 45 F7 FF FF | call    sub_429527
0x00429DE2 | EB 01 | jmp     short loc_429DE5
0x00429DE4 | 90 | nop
0x00429DE5 | 8B 45 F4 | mov     eax, [rbp+fildes]
0x00429DE8 | 89 C7 | mov     edi, eax; fd
0x00429DEA | E8 21 D0 FD FF | call    _close
0x00429DEF | B8 F8 B3 75 00 | mov     eax, offset dest
0x00429DF4 | C7 40 04 00 00 00 00 | mov     dword ptr [rax+4], 0
0x00429DFB | EB 01 | jmp     short locret_429DFE
0x00429DFD | 90 | nop
0x00429DFE | C9 | leave
0x00429DFF | C3 | retn
 ************ 
Source Code:
static void
handle_retr(void)
{
	struct stat statbuf;
	off_t bytes_transferred;
	int remote_fd;
	int local_file_fd;
	off_t offset = G.restart_pos;
	char *response;

	G.restart_pos = 0;

	if (!port_or_pasv_was_seen())
		return; /* port_or_pasv_was_seen emitted error response */

	/* O_NONBLOCK is useful if file happens to be a device node */
	local_file_fd = G.ftp_arg ? open(G.ftp_arg, O_RDONLY | O_NONBLOCK) : -1;
	if (local_file_fd < 0) {
		WRITE_ERR(FTP_FILEFAIL);
		return;
	}

	if (fstat(local_file_fd, &statbuf) != 0 || !S_ISREG(statbuf.st_mode)) {
		/* Note - pretend open failed */
		WRITE_ERR(FTP_FILEFAIL);
		goto file_close_out;
	}
	G.local_file_fd = local_file_fd;

	/* Now deactive O_NONBLOCK, otherwise we have a problem
	 * on DMAPI filesystems such as XFS DMAPI.
	 */
	ndelay_off(local_file_fd);

	/* Set the download offset (from REST) if any */
	if (offset != 0)
		xlseek(local_file_fd, offset, SEEK_SET);

	response = xasprintf(
		" Opening BINARY connection for %s (%"OFF_FMT"u bytes)",
		G.ftp_arg, statbuf.st_size);
	remote_fd = get_remote_transfer_fd(response);
	free(response);
	if (remote_fd < 0)
		goto file_close_out;

	bytes_transferred = bb_copyfd_eof(local_file_fd, remote_fd);
	close(remote_fd);
	if (bytes_transferred < 0)
		WRITE_ERR(FTP_BADSENDFILE);
	else
		WRITE_OK(FTP_TRANSFEROK);

 file_close_out:
	close(local_file_fd);
	G.local_file_fd = 0;
}
 ************ 
Parsed Output:
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>

typedef struct {
    void *unknown1; // Placeholder for unknown data at offset 0x20
    char *filename; // Placeholder for filename string at offset 0x40
    int file_descriptor; // Placeholder for file descriptor at offset 0x4
    // ... other members not shown due to lack of context
} DestStruct;

DestStruct dest; // Assuming 'dest' is a global structure

void process_file_transfer() {
    struct stat stat_buf;
    int fildes;
    int fd;
    void *ptr;

    dest.unknown1 = NULL;
    if (sub_4298DE() == 0) {
        return;
    }

    if (dest.filename != NULL) {
        fildes = open64(dest.filename, O_RDONLY | 0x800); // 0x800 is assumed to be O_LARGEFILE or similar flag
    } else {
        fildes = -1;
    }

    if (fildes < 0) {
        sub_429570(0x20303535); // Placeholder for error handling function
        return;
    }

    if (fstat(fildes, &stat_buf) == 0 && (stat_buf.st_mode & S_IFMT) == S_IFREG) {
        dest.file_descriptor = fildes;
        sub_4099DC(fildes); // Placeholder for function operating on file descriptor

        if (dest.unknown1 != NULL) {
            sub_40A557(fildes, dest.unknown1, 0); // Placeholder for function operating on file descriptor and unknown1
        }

        ptr = sub_40A6B3(" Opening BINARY connection for %s (%lu bytes).
", dest.filename, stat_buf.st_size);
        fd = sub_429885(ptr); // Placeholder for function that uses the message
        free(ptr);

        if (fd >= 0) {
            void *var_28 = sub_40B366(fildes, fd); // Placeholder for function that transfers data between file descriptors
            close(fd);

            if (var_28 < 0) {
                sub_429570(0x20313534); // Placeholder for error handling function
            } else {
                sub_429527(0x20363232); // Placeholder for success handling function
            }
        }
    } else {
        sub_429570(0x20303535); // Placeholder for error handling function
    }

    close(fildes);
    dest.file_descriptor = 0;
}
 ************ 
Similarity Score (Unixcoder): 0.7177382111549377
Func rank: 25

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: rx_main
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00421D8D | 55 | push    rbp
0x00421D8E | 48 89 E5 | mov     rbp, rsp
0x00421D91 | 48 81 EC A0 00 00 00 | sub     rsp, 0A0h
0x00421D98 | 89 BD 6C FF FF FF | mov     [rbp+var_94], edi
0x00421D9E | 48 89 B5 60 FF FF FF | mov     [rbp+var_A0], rsi
0x00421DA5 | 48 8B 85 60 FF FF FF | mov     rax, [rbp+var_A0]
0x00421DAC | 48 89 C7 | mov     rdi, rax
0x00421DAF | E8 45 68 0E 00 | call    sub_5085F9
0x00421DB4 | BE 42 02 00 00 | mov     esi, 242h
0x00421DB9 | 48 89 C7 | mov     rdi, rax
0x00421DBC | E8 D4 84 FE FF | call    sub_40A295
0x00421DC1 | 89 45 FC | mov     [rbp+var_4], eax
0x00421DC4 | 48 8D 45 B0 | lea     rax, [rbp+termios_p]
0x00421DC8 | 48 89 C6 | mov     rsi, rax; termios_p
0x00421DCB | BF 00 00 00 00 | mov     edi, 0; fd
0x00421DD0 | E8 CB 59 FE FF | call    _tcgetattr
0x00421DD5 | 89 45 F8 | mov     [rbp+var_8], eax
0x00421DD8 | 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00421DDC | 75 66 | jnz     short loc_421E44
0x00421DDE | 48 8B 45 B0 | mov     rax, qword ptr [rbp+termios_p.c_iflag]
0x00421DE2 | 48 8B 55 B8 | mov     rdx, qword ptr [rbp+termios_p.c_cflag]
0x00421DE6 | 48 89 85 70 FF FF FF | mov     qword ptr [rbp+var_90.c_iflag], rax
0x00421DED | 48 89 95 78 FF FF FF | mov     qword ptr [rbp+var_90.c_cflag], rdx
0x00421DF4 | 48 8B 45 C0 | mov     rax, qword ptr [rbp+termios_p.c_line]
0x00421DF8 | 48 8B 55 C8 | mov     rdx, qword ptr [rbp+termios_p.c_cc+7]
0x00421DFC | 48 89 45 80 | mov     qword ptr [rbp+var_90.c_line], rax
0x00421E00 | 48 89 55 88 | mov     qword ptr [rbp+var_90.c_cc+7], rdx
0x00421E04 | 48 8B 45 D0 | mov     rax, qword ptr [rbp+termios_p.c_cc+0Fh]
0x00421E08 | 48 8B 55 D8 | mov     rdx, qword ptr [rbp+termios_p.c_cc+17h]
0x00421E0C | 48 89 45 90 | mov     qword ptr [rbp+var_90.c_cc+0Fh], rax
0x00421E10 | 48 89 55 98 | mov     qword ptr [rbp+var_90.c_cc+17h], rdx
0x00421E14 | 48 8B 45 E0 | mov     rax, qword ptr [rbp+termios_p.c_cc+1Fh]
0x00421E18 | 48 89 45 A0 | mov     qword ptr [rbp+var_90.c_cc+1Fh], rax
0x00421E1C | 8B 45 E8 | mov     eax, [rbp+termios_p.c_ospeed]
0x00421E1F | 89 45 A8 | mov     [rbp+var_90.c_ospeed], eax
0x00421E22 | 48 8D 45 B0 | lea     rax, [rbp+termios_p]
0x00421E26 | 48 89 C7 | mov     rdi, rax; termios_p
0x00421E29 | E8 A2 57 FE FF | call    _cfmakeraw
0x00421E2E | 48 8D 45 B0 | lea     rax, [rbp+termios_p]
0x00421E32 | 48 89 C2 | mov     rdx, rax; termios_p
0x00421E35 | BE 02 00 00 00 | mov     esi, 2; optional_actions
0x00421E3A | BF 00 00 00 00 | mov     edi, 0; fd
0x00421E3F | E8 8C 59 FE FF | call    _tcsetattr
0x00421E44 | BE 83 1D 42 00 | mov     esi, offset sub_421D83
0x00421E49 | BF 0E 00 00 00 | mov     edi, 0Eh
0x00421E4E | E8 DB 65 0E 00 | call    sub_50842E
0x00421E53 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00421E56 | 89 C7 | mov     edi, eax
0x00421E58 | E8 D2 FA FF FF | call    sub_42192F
0x00421E5D | 89 45 F4 | mov     [rbp+var_C], eax
0x00421E60 | 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00421E64 | 75 19 | jnz     short loc_421E7F
0x00421E66 | 48 8D 85 70 FF FF FF | lea     rax, [rbp+var_90]
0x00421E6D | 48 89 C2 | mov     rdx, rax; termios_p
0x00421E70 | BE 02 00 00 00 | mov     esi, 2; optional_actions
0x00421E75 | BF 00 00 00 00 | mov     edi, 0; fd
0x00421E7A | E8 51 59 FE FF | call    _tcsetattr
0x00421E7F | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00421E82 | F7 D0 | not     eax
0x00421E84 | C1 E8 1F | shr     eax, 1Fh
0x00421E87 | 0F B6 C0 | movzx   eax, al
0x00421E8A | 89 C7 | mov     edi, eax
0x00421E8C | E8 38 75 0D 00 | call    sub_4F93C9
 ************ 
Source Code:
int rx_main(int argc UNUSED_PARAM, char **argv)
{
	struct termios tty, orig_tty;
	int termios_err;
	int file_fd;
	int n;

	/* Disabled by vda:
	 * why we can't receive from stdin? Why we *require*
	 * controlling tty?? */
	/*read_fd = xopen(CURRENT_TTY, O_RDWR);*/
	file_fd = xopen(single_argv(argv), O_RDWR|O_CREAT|O_TRUNC);

	termios_err = tcgetattr(read_fd, &tty);
	if (termios_err == 0) {
		orig_tty = tty;
		cfmakeraw(&tty);
		tcsetattr(read_fd, TCSAFLUSH, &tty);
	}

	/* No SA_RESTART: we want ALRM to interrupt read() */
	signal_no_SA_RESTART_empty_mask(SIGALRM, sigalrm_handler);

	n = receive(file_fd);

	if (termios_err == 0)
		tcsetattr(read_fd, TCSAFLUSH, &orig_tty);
	if (ENABLE_FEATURE_CLEAN_UP)
		close(file_fd);
	fflush_stdout_and_exit(n >= 0);
}
 ************ 
Parsed Output:
#include <termios.h>

int configure_serial_port(int fd, void *termios_p) {
    struct termios original_termios, modified_termios;
    int result, status;

    result = _tcgetattr(fd, &original_termios);
    if (result == 0) {
        modified_termios = original_termios;

        _cfmakeraw(&modified_termios);
        _tcsetattr(fd, TCSANOW, &modified_termios);
    }

    sub_50842E(0xE, sub_421D83);
    status = sub_42192F(result);

    if (result == 0) {
        _tcsetattr(fd, TCSANOW, &original_termios);
    }

    return status != 0 ? 1 : 0;
}
 ************ 
Similarity Score (Unixcoder): 0.7162231206893921
Func rank: 26

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: pivot_root_main
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004A32AA | 55 | push    rbp
0x004A32AB | 48 89 E5 | mov     rbp, rsp
0x004A32AE | 48 83 EC 10 | sub     rsp, 10h
0x004A32B2 | 89 7D FC | mov     [rbp+var_4], edi
0x004A32B5 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004A32B9 | 83 7D FC 03 | cmp     [rbp+var_4], 3
0x004A32BD | 74 05 | jz      short loc_4A32C4
0x004A32BF | E8 A0 4C F6 FF | call    sub_407F64
0x004A32C4 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004A32C8 | 48 83 C0 10 | add     rax, 10h
0x004A32CC | 48 8B 10 | mov     rdx, [rax]
0x004A32CF | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004A32D3 | 48 83 C0 08 | add     rax, 8
0x004A32D7 | 48 8B 00 | mov     rax, [rax]
0x004A32DA | 48 89 D6 | mov     rsi, rdx
0x004A32DD | 48 89 C7 | mov     rdi, rax
0x004A32E0 | E8 EB 46 F6 FF | call    _pivot_root
0x004A32E5 | 85 C0 | test    eax, eax
0x004A32E7 | 79 05 | jns     short loc_4A32EE
0x004A32E9 | E8 66 FA 05 00 | call    sub_502D54
0x004A32EE | B8 00 00 00 00 | mov     eax, 0
0x004A32F3 | C9 | leave
0x004A32F4 | C3 | retn
 ************ 
Source Code:
int pivot_root_main(int argc, char **argv)
{
	if (argc != 3)
		bb_show_usage();

	if (pivot_root(argv[1], argv[2]) < 0) {
		/* prints "pivot_root: <strerror text>" */
		bb_perror_nomsg_and_die();
	}

	return EXIT_SUCCESS;
}
 ************ 
Parsed Output:
#include <unistd.h>

int performPivotRoot(const char *new_root, const char *put_old) {
    if (new_root == NULL || put_old == NULL) {
        sub_407F64(); // External function, details not provided
        return -1;
    }

    int result = pivot_root(new_root, put_old);
    if (result < 0) {
        sub_502D54(); // External function, details not provided
    }

    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.7159002423286438
Func rank: 27

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: monotonic_ns
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0040BC33 | 55 | push    rbp
0x0040BC34 | 48 89 E5 | mov     rbp, rsp
0x0040BC37 | 48 83 EC 10 | sub     rsp, 10h
0x0040BC3B | 48 8D 45 F0 | lea     rax, [rbp+tv]
0x0040BC3F | BE 00 00 00 00 | mov     esi, 0; tz
0x0040BC44 | 48 89 C7 | mov     rdi, rax; tv
0x0040BC47 | E8 74 B0 FF FF | call    _gettimeofday
0x0040BC4C | 48 8B 45 F0 | mov     rax, [rbp+tv.tv_sec]
0x0040BC50 | 48 69 C0 00 CA 9A 3B | imul    rax, 3B9ACA00h
0x0040BC57 | 48 8B 55 F8 | mov     rdx, [rbp+tv.tv_usec]
0x0040BC5B | 48 69 D2 E8 03 00 00 | imul    rdx, 3E8h
0x0040BC62 | 48 01 D0 | add     rax, rdx
0x0040BC65 | C9 | leave
0x0040BC66 | C3 | retn
 ************ 
Source Code:
unsigned long long FAST_FUNC monotonic_ns(void)
{
	struct timespec ts;
	get_mono(&ts);
	return ts.tv_sec * 1000000000ULL + ts.tv_nsec;
}
 ************ 
Parsed Output:
#include <sys/time.h>

long long convertTimevalToMilliseconds() {
    struct timeval tv;
    gettimeofday(&tv, 0);
    long long milliseconds = (long long)tv.tv_sec * 1000000 + (long long)tv.tv_usec;
    return milliseconds / 1000;
}
 ************ 
Similarity Score (Unixcoder): 0.7151281833648682
Func rank: 28

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: llist_add_to_end
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00409018 | 55 | push    rbp
0x00409019 | 48 89 E5 | mov     rbp, rsp
0x0040901C | 48 83 EC 10 | sub     rsp, 10h
0x00409020 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00409024 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x00409028 | EB 0B | jmp     short loc_409035
0x0040902A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040902E | 48 8B 00 | mov     rax, [rax]
0x00409031 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00409035 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00409039 | 48 8B 00 | mov     rax, [rax]
0x0040903C | 48 85 C0 | test    rax, rax
0x0040903F | 75 E9 | jnz     short loc_40902A
0x00409041 | BF 10 00 00 00 | mov     edi, 10h
0x00409046 | E8 9D 10 00 00 | call    sub_40A0E8
0x0040904B | 48 89 C2 | mov     rdx, rax
0x0040904E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00409052 | 48 89 10 | mov     [rax], rdx
0x00409055 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00409059 | 48 8B 00 | mov     rax, [rax]
0x0040905C | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x00409060 | 48 89 50 08 | mov     [rax+8], rdx
0x00409064 | 90 | nop
0x00409065 | C9 | leave
0x00409066 | C3 | retn
 ************ 
Source Code:
void FAST_FUNC llist_add_to_end(llist_t **list_head, void *data)
{
	while (*list_head)
		list_head = &(*list_head)->link;
	*list_head = xzalloc(sizeof(llist_t));
	(*list_head)->data = data;
	/*(*list_head)->link = NULL;*/
}
 ************ 
Parsed Output:
void initializeLinkedListNode(void **node, void *value) {
    while (*node) {
        node = (void **)*node;
    }
    *node = malloc(16);
    (*node)[1] = value;
}
 ************ 
Similarity Score (Unixcoder): 0.7073717713356018
Func rank: 29

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: fork_job
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00414F9A | 55 | push    rbp
0x00414F9B | 48 89 E5 | mov     rbp, rsp
0x00414F9E | 48 83 EC 30 | sub     rsp, 30h
0x00414FA2 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00414FA6 | 89 75 E4 | mov     [rbp+fd], esi
0x00414FA9 | 48 89 55 D8 | mov     [rbp+file], rdx
0x00414FAD | 48 89 4D D0 | mov     [rbp+var_30], rcx
0x00414FB1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00414FB5 | 48 89 C7 | mov     rdi, rax
0x00414FB8 | E8 67 75 FF FF | call    sub_40C524
0x00414FBD | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00414FC1 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00414FC6 | 75 1B | jnz     short loc_414FE3
0x00414FC8 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00414FCC | 48 89 C6 | mov     rsi, rax
0x00414FCF | BF 52 8D 52 00 | mov     edi, offset aIcanTGetUidFor; "Ican't get uid for %s"
0x00414FD4 | B8 00 00 00 00 | mov     eax, 0
0x00414FD9 | E8 99 F3 FF FF | call    sub_414377
0x00414FDE | E9 18 01 00 00 | jmp     loc_4150FB
0x00414FE3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00414FE7 | 48 89 C7 | mov     rdi, rax
0x00414FEA | E8 08 FF FF FF | call    sub_414EF7
0x00414FEF | E8 BC 28 FF FF | call    _vfork
0x00414FF4 | 89 45 F4 | mov     [rbp+var_C], eax
0x00414FF7 | 83 7D F4 00 | cmp     [rbp+var_C], 0
0x00414FFB | 0F 85 E5 00 00 00 | jnz     loc_4150E6
0x00415001 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00415005 | 48 89 C7 | mov     rdi, rax
0x00415008 | E8 22 FF FF FF | call    sub_414F2F
0x0041500D | 8B 05 3D 84 34 00 | mov     eax, cs:dword_75D450
0x00415013 | 83 E0 40 | and     eax, 40h
0x00415016 | 85 C0 | test    eax, eax
0x00415018 | 74 16 | jz      short loc_415030
0x0041501A | 48 8B 45 D8 | mov     rax, [rbp+file]
0x0041501E | 48 89 C6 | mov     rsi, rax
0x00415021 | BF 68 8D 52 00 | mov     edi, offset unk_528D68
0x00415026 | B8 00 00 00 00 | mov     eax, 0
0x0041502B | E8 47 F3 FF FF | call    sub_414377
0x00415030 | 83 7D E4 00 | cmp     [rbp+fd], 0
0x00415034 | 78 26 | js      short loc_41505C
0x00415036 | 48 83 7D D0 00 | cmp     [rbp+var_30], 0
0x0041503B | 0F 95 C0 | setnz   al
0x0041503E | 0F B6 D0 | movzx   edx, al
0x00415041 | 8B 45 E4 | mov     eax, [rbp+fd]
0x00415044 | 89 D6 | mov     esi, edx
0x00415046 | 89 C7 | mov     edi, eax
0x00415048 | E8 2A 54 FF FF | call    sub_40A477
0x0041504D | BE 02 00 00 00 | mov     esi, 2; fd2
0x00415052 | BF 01 00 00 00 | mov     edi, 1; fd
0x00415057 | E8 24 1B FF FF | call    _dup2
0x0041505C | E8 1F 2C FF FF | call    _setpgrp
0x00415061 | 48 83 7D D0 00 | cmp     [rbp+var_30], 0
0x00415066 | 74 07 | jz      short loc_41506F
0x00415068 | BF 7A 8D 52 00 | mov     edi, offset unk_528D7A
0x0041506D | EB 05 | jmp     short loc_415074
0x0041506F | BF 7D 8D 52 00 | mov     edi, offset unk_528D7D
0x00415074 | 48 8B 55 D0 | mov     rdx, [rbp+var_30]
0x00415078 | 48 8B 75 D8 | mov     rsi, [rbp+file]; arg
0x0041507C | 48 8B 45 D8 | mov     rax, [rbp+file]
0x00415080 | 41 B8 00 00 00 00 | mov     r8d, 0
0x00415086 | 48 89 D1 | mov     rcx, rdx
0x00415089 | 48 89 FA | mov     rdx, rdi
0x0041508C | 48 89 C7 | mov     rdi, rax; file
0x0041508F | B8 00 00 00 00 | mov     eax, 0
0x00415094 | E8 57 2B FF FF | call    _execlp
0x00415099 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x0041509D | 48 8B 45 D8 | mov     rax, [rbp+file]
0x004150A1 | 48 89 C6 | mov     rsi, rax
0x004150A4 | BF 88 8D 52 00 | mov     edi, offset unk_528D88
0x004150A9 | B8 00 00 00 00 | mov     eax, 0
0x004150AE | E8 C4 F2 FF FF | call    sub_414377
0x004150B3 | 48 83 7D D0 00 | cmp     [rbp+var_30], 0
0x004150B8 | 74 22 | jz      short loc_4150DC
0x004150BA | 48 8B 55 D0 | mov     rdx, [rbp+var_30]
0x004150BE | 48 8B 45 D8 | mov     rax, [rbp+file]
0x004150C2 | 48 89 D1 | mov     rcx, rdx
0x004150C5 | 48 89 C2 | mov     rdx, rax
0x004150C8 | BE A8 8D 52 00 | mov     esi, offset aExecFailedSCS; "Exec failed: %s -c %s\n"
0x004150CD | BF 01 00 00 00 | mov     edi, 1; fd
0x004150D2 | B8 00 00 00 00 | mov     eax, 0
0x004150D7 | E8 44 1D FF FF | call    _dprintf
0x004150DC | BF 00 00 00 00 | mov     edi, 0; status
0x004150E1 | E8 DA 16 FF FF | call    __exit
0x004150E6 | 83 7D F4 00 | cmp     [rbp+var_C], 0
0x004150EA | 79 16 | jns     short loc_415102
0x004150EC | BF BF 8D 52 00 | mov     edi, offset unk_528DBF
0x004150F1 | B8 00 00 00 00 | mov     eax, 0
0x004150F6 | E8 7C F2 FF FF | call    sub_414377
0x004150FB | C7 45 F4 00 00 00 00 | mov     [rbp+var_C], 0
0x00415102 | 83 7D E4 00 | cmp     [rbp+fd], 0
0x00415106 | 78 0A | js      short loc_415112
0x00415108 | 8B 45 E4 | mov     eax, [rbp+fd]
0x0041510B | 89 C7 | mov     edi, eax; fd
0x0041510D | E8 FE 1C FF FF | call    _close
0x00415112 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00415115 | C9 | leave
0x00415116 | C3 | retn
 ************ 
Source Code:
if ENABLE_FEATURE_CROND_CALL_SENDMAIL

static pid_t
fork_job(const char *user, int mailFd,
		const char *prog,
		const char *shell_cmd /* if NULL, we run sendmail */
) {
	struct passwd *pas;
	pid_t pid;

	/* prepare things before vfork */
	pas = getpwnam(user);
	if (!pas) {
		crondlog(WARN9 "can't get uid for %s", user);
		goto err;
	}
	set_env_vars(pas);

	pid = vfork();
	if (pid == 0) {
		/* CHILD */
		/* initgroups, setgid, setuid, and chdir to home or TMPDIR */
		change_user(pas);
		if (DebugOpt) {
			crondlog(LVL5 "child running %s", prog);
		}
		if (mailFd >= 0) {
			xmove_fd(mailFd, shell_cmd ? 1 : 0);
			dup2(1, 2);
		}
		/* crond 3.0pl1-100 puts tasks in separate process groups */
		bb_setpgrp();
		execlp(prog, prog, (shell_cmd ? "-c" : SENDMAIL_ARGS), shell_cmd, (char *) NULL);
		crondlog(ERR20 "can't execute '%s' for user %s", prog, user);
		if (shell_cmd) {
			fdprintf(1, "Exec failed: %s -c %s
", prog, shell_cmd);
		}
		_exit(EXIT_SUCCESS);
	}

	if (pid < 0) {
		/* FORK FAILED */
		crondlog(ERR20 "can't vfork");
 err:
		pid = 0;
	} /* else: PARENT, FORK SUCCESS */

	/*
	 * Close the mail file descriptor.. we can't just leave it open in
	 * a structure, closing it later, because we might run out of descriptors
	 */
	if (mailFd >= 0) {
		close(mailFd);
	}
	return pid;
}
 ************ 
Parsed Output:
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void execute_command_with_uid(const char *uid, int fd, const char *file, const char *arg) {
    uid_t *user_id = sub_40C524(uid);
    if (user_id == NULL) {
        sub_414377("I can't get uid for %s", uid);
        loc_4150FB();
        return;
    }

    sub_414EF7(user_id);
    pid_t pid = vfork();
    if (pid == 0) {
        sub_414F2F(user_id);
        if (cs_dword_75D450 & 0x40) {
            sub_414377(unk_528D68, file);
        }
        if (fd >= 0) {
            int flag = arg != NULL;
            sub_40A477(fd, flag);
            dup2(2, 1);
        }
        setpgrp();
        const char *command = arg ? unk_528D7A : unk_528D7D;
        execlp(file, file, command, arg, NULL);
        sub_414377(unk_528D88, file);
        if (arg) {
            dprintf(1, "Exec failed: %s -c %s
", file, arg);
        }
        __exit(0);
    } else if (pid < 0) {
        sub_414377(unk_528DBF);
        loc_4150FB();
        return;
    }

    if (fd >= 0) {
        close(fd);
    }
    loc_4150FB();
}

void loc_4150FB() {
    // This function is a placeholder for the jump target at 0x00414FDE and 0x004150FB.
    // It represents the end of the control flow for the execute_command_with_uid function.
    // The actual implementation would depend on the context of the binary and what should happen after the function call.
    // For the purpose of this decompilation, we assume it's a return point.
}

void sub_414377(const char *format, ...) {
    // This function is a placeholder for the external function call at 0x00414FD9, 0x0041502B, 0x004150AE, 0x004150F6.
    // It seems to be a logging or error reporting function, possibly similar to printf.
    // The actual implementation would depend on the context of the binary and the external function's behavior.
    va_list args;
    va_start(args, format);
    vfprintf(stderr, format, args);
    va_end(args);
}

uid_t *sub_40C524(const char *uid) {
    // This function is a placeholder for the external function call at 0x00414FB8.
    // It seems to be responsible for retrieving a user ID based on a string representation of the UID.
    // The actual implementation would depend on the context of the binary and the external function's behavior.
    // For the purpose of this decompilation, we assume it returns a pointer to a uid_t.
    return getpwnam(uid)->pw_uid;
}

void sub_414EF7(uid_t *user_id) {
    // This function is a placeholder for the external function call at 0x00414FEA.
    // It seems to be performing some operation with the user ID, possibly setting it for the current process.
    // The actual implementation would depend on the context of the binary and the external function's behavior.
}

void sub_414F2F(uid_t *user_id) {
    // This function is a placeholder for the external function call at 0x00415008.
    // It seems to be performing some operation with the user ID, possibly setting it for the current process.
    // The actual implementation would depend on the context of the binary and the external function's behavior.
}

void sub_40A477(int fd, int flag) {
    // This function is a placeholder for the external function call at 0x00415048.
    // It seems to be performing some operation with the file descriptor and a flag, possibly related to file operations or process control.
    // The actual implementation would depend on the context of the binary and the external function's behavior.
}

void __exit(int status) {
    // This function is a placeholder for the external function call at 0x004150E1.
    // It seems to be the exit function, terminating the process with the given status.
    exit(status);
}
 ************ 
Similarity Score (Unixcoder): 0.7042345404624939
Func rank: 30

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: next_good_eraseblock
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0042111A | 55 | push    rbp
0x0042111B | 48 89 E5 | mov     rbp, rsp
0x0042111E | 48 83 EC 20 | sub     rsp, 20h
0x00421122 | 89 7D EC | mov     [rbp+var_14], edi
0x00421125 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00421129 | 89 55 E8 | mov     [rbp+var_18], edx
0x0042112C | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00421130 | 8B 40 08 | mov     eax, [rax+8]
0x00421133 | 39 45 E8 | cmp     [rbp+var_18], eax
0x00421136 | 72 26 | jb      short loc_42115E
0x00421138 | 48 8B 05 B1 A2 33 00 | mov     rax, cs:ident
0x0042113F | 48 83 C0 04 | add     rax, 4
0x00421143 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00421146 | 3C 64 | cmp     al, 64h ; 'd'
0x00421148 | 74 0F | jz      short loc_421159
0x0042114A | BF 98 9F 52 00 | mov     edi, offset aNotEnoughSpace; "not enough space in MTD device"
0x0042114F | B8 00 00 00 00 | mov     eax, 0
0x00421154 | E8 45 85 FE FF | call    sub_40969E
0x00421159 | 8B 45 E8 | mov     eax, [rbp+var_18]
0x0042115C | EB 5D | jmp     short locret_4211BB
0x0042115E | 8B 45 E8 | mov     eax, [rbp+var_18]
0x00421161 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00421165 | 48 8D 55 F8 | lea     rdx, [rbp+var_8]
0x00421169 | 8B 45 EC | mov     eax, [rbp+var_14]
0x0042116C | B9 B7 9F 52 00 | mov     ecx, offset aMemgetbadblock; "MEMGETBADBLOCK"
0x00421171 | BE 0B 4D 08 40 | mov     esi, 40084D0Bh
0x00421176 | 89 C7 | mov     edi, eax
0x00421178 | E8 D4 9B FE FF | call    sub_40AD51
0x0042117D | 85 C0 | test    eax, eax
0x0042117F | 75 05 | jnz     short loc_421186
0x00421181 | 8B 45 E8 | mov     eax, [rbp+var_18]
0x00421184 | EB 35 | jmp     short locret_4211BB
0x00421186 | 48 8B 05 63 A2 33 00 | mov     rax, cs:ident
0x0042118D | 48 83 C0 04 | add     rax, 4
0x00421191 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00421194 | 3C 64 | cmp     al, 64h ; 'd'
0x00421196 | 74 14 | jz      short loc_4211AC
0x00421198 | 8B 45 E8 | mov     eax, [rbp+var_18]
0x0042119B | 89 C6 | mov     esi, eax
0x0042119D | BF C6 9F 52 00 | mov     edi, offset aSkippingBadBlo; "Skipping bad block at 0x%08x\n"
0x004211A2 | B8 00 00 00 00 | mov     eax, 0
0x004211A7 | E8 24 5A FE FF | call    _printf
0x004211AC | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004211B0 | 8B 40 0C | mov     eax, [rax+0Ch]
0x004211B3 | 01 45 E8 | add     [rbp+var_18], eax
0x004211B6 | E9 71 FF FF FF | jmp     loc_42112C
0x004211BB | C9 | leave
0x004211BC | C3 | retn
 ************ 
Source Code:
static unsigned next_good_eraseblock(int fd, struct mtd_info_user *meminfo,
		unsigned block_offset)
{
	while (1) {
		loff_t offs;

		if (block_offset >= meminfo->size) {
			if (IS_NANDWRITE)
				bb_error_msg_and_die("not enough space in MTD device");
			return block_offset; /* let the caller exit */
		}
		offs = block_offset;
		if (xioctl(fd, MEMGETBADBLOCK, &offs) == 0)
			return block_offset;
		/* ioctl returned 1 => "bad block" */
		if (IS_NANDWRITE)
			printf("Skipping bad block at 0x%08x
", block_offset);
		block_offset += meminfo->erasesize;
	}
}
 ************ 
Parsed Output:
int checkAndProcessBlock(int blockIndex, void *deviceInfo) {
    int blockSize = *(int *)(deviceInfo + 8);
    if (blockIndex >= blockSize) {
        if (*(char *)(ident + 4) == 'd') {
            return blockIndex;
        }
        sub_40969E("not enough space in MTD device");
        return blockIndex;
    }

    int result = sub_40AD51(blockIndex, "MEMGETBADBLOCK", 0x40084D0B);
    if (result != 0) {
        return blockIndex;
    }

    if (*(char *)(ident + 4) == 'd') {
        int increment = *(int *)(deviceInfo + 12);
        blockIndex += increment;
        goto checkAndProcessBlock;
    }

    _printf("Skipping bad block at 0x%08x
", blockIndex);
    blockIndex += *(int *)(deviceInfo + 12);
    goto checkAndProcessBlock;
}
 ************ 
Similarity Score (Unixcoder): 0.7026308178901672
Func rank: 31

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: setlogcons_main
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004C49F4 | 55 | push    rbp
0x004C49F5 | 48 89 E5 | mov     rbp, rsp
0x004C49F8 | 48 83 EC 20 | sub     rsp, 20h
0x004C49FC | 89 7D EC | mov     [rbp+var_14], edi
0x004C49FF | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004C4A03 | C6 45 FE 0B | mov     [rbp+var_2], 0Bh
0x004C4A07 | C6 45 FF 00 | mov     [rbp+var_1], 0
0x004C4A0B | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004C4A0F | 48 83 C0 08 | add     rax, 8
0x004C4A13 | 48 8B 00 | mov     rax, [rax]
0x004C4A16 | 48 85 C0 | test    rax, rax
0x004C4A19 | 74 20 | jz      short loc_4C4A3B
0x004C4A1B | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004C4A1F | 48 83 C0 08 | add     rax, 8
0x004C4A23 | 48 8B 00 | mov     rax, [rax]
0x004C4A26 | BA 3F 00 00 00 | mov     edx, 3Fh ; '?'
0x004C4A2B | BE 00 00 00 00 | mov     esi, 0
0x004C4A30 | 48 89 C7 | mov     rdi, rax
0x004C4A33 | E8 64 66 04 00 | call    sub_50B09C
0x004C4A38 | 88 45 FF | mov     [rbp+var_1], al
0x004C4A3B | BE 00 00 00 00 | mov     esi, 0
0x004C4A40 | BF 4C 6A 53 00 | mov     edi, offset aDevTty1; "/dev/tty1"
0x004C4A45 | E8 4B 58 F4 FF | call    sub_40A295
0x004C4A4A | 89 C7 | mov     edi, eax
0x004C4A4C | 48 8D 45 FE | lea     rax, [rbp+var_2]
0x004C4A50 | B9 56 6A 53 00 | mov     ecx, offset aTioclinux; "TIOCLINUX"
0x004C4A55 | 48 89 C2 | mov     rdx, rax
0x004C4A58 | BE 1C 54 00 00 | mov     esi, 541Ch
0x004C4A5D | E8 EF 62 F4 FF | call    sub_40AD51
0x004C4A62 | B8 00 00 00 00 | mov     eax, 0
0x004C4A67 | C9 | leave
0x004C4A68 | C3 | retn
 ************ 
Source Code:
int setlogcons_main(int argc UNUSED_PARAM, char **argv)
{
	struct {
		char fn;
		char subarg;
	} arg = {
		11, /* redirect kernel messages */
		0   /* to specified console (current as default) */
	};

	if (argv[1])
		arg.subarg = xatou_range(argv[1], 0, 63);

	xioctl(xopen(VC_1, O_RDONLY), TIOCLINUX, &arg);

	return EXIT_SUCCESS;
}
 ************ 
Parsed Output:
#include <sys/ioctl.h>

int setConsoleMode(void *consoleData) {
    int consoleDescriptor;
    char mode = 0x0B;
    char result = 0;

    if (consoleData) {
        consoleDescriptor = ioctl(*(int *)(consoleData + 8), 0x541C, &mode);
        result = consoleDescriptor != -1 ? 1 : 0;
    }

    consoleDescriptor = open("/dev/tty1", 0);
    ioctl(consoleDescriptor, 0x541C, "TIOCLINUX");

    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.7019137144088745
Func rank: 32

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: get_trimmed_slice
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00408145 | 55 | push    rbp
0x00408146 | 48 89 E5 | mov     rbp, rsp
0x00408149 | 48 83 EC 20 | sub     rsp, 20h
0x0040814D | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00408151 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00408155 | EB 29 | jmp     short loc_408180
0x00408157 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0040815B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040815E | 83 E8 09 | sub     eax, 9
0x00408161 | 88 45 FF | mov     [rbp+var_1], al
0x00408164 | 80 7D FF 17 | cmp     [rbp+var_1], 17h
0x00408168 | 74 06 | jz      short loc_408170
0x0040816A | 80 7D FF 04 | cmp     [rbp+var_1], 4
0x0040816E | 77 07 | ja      short loc_408177
0x00408170 | B8 01 00 00 00 | mov     eax, 1
0x00408175 | EB 05 | jmp     short loc_40817C
0x00408177 | B8 00 00 00 00 | mov     eax, 0
0x0040817C | 85 C0 | test    eax, eax
0x0040817E | 74 14 | jz      short loc_408194
0x00408180 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00408184 | 48 8D 50 FF | lea     rdx, [rax-1]
0x00408188 | 48 89 55 E0 | mov     [rbp+var_20], rdx
0x0040818C | 48 39 45 E8 | cmp     [rbp+var_18], rax
0x00408190 | 72 C5 | jb      short loc_408157
0x00408192 | EB 01 | jmp     short loc_408195
0x00408194 | 90 | nop
0x00408195 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00408199 | 48 83 C0 01 | add     rax, 1
0x0040819D | C6 00 00 | mov     byte ptr [rax], 0
0x004081A0 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004081A4 | 48 89 C7 | mov     rdi, rax
0x004081A7 | E8 08 12 00 00 | call    sub_4093B4
0x004081AC | C9 | leave
0x004081AD | C3 | retn
 ************ 
Source Code:
static char *get_trimmed_slice(char *s, char *e)
{
	/* First, consider the value at e to be nul and back up until we
	 * reach a non-space char.  Set the char after that (possibly at
	 * the original e) to nul. */
	while (e-- > s) {
		if (!isspace(*e)) {
			break;
		}
	}
	e[1] = '\0';

	/* Next, advance past all leading space and return a ptr to the
	 * first non-space char; possibly the terminating nul. */
	return skip_whitespace(s);
}
 ************ 
Parsed Output:
void processString(char *str, char *end) {
    while (end > str) {
        char c = *str - 9;
        if (c == 0x17 || c <= 4) {
            *str = '\0';
            break;
        }
        str--;
    }
    sub_4093B4(str + 1);
}
 ************ 
Similarity Score (Unixcoder): 0.6988118886947632
Func rank: 33

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: writeTarFile
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004B52FD | 55 | push    rbp
0x004B52FE | 48 89 E5 | mov     rbp, rsp
0x004B5301 | 48 81 EC F0 00 00 00 | sub     rsp, 0F0h
0x004B5308 | 89 BD 2C FF FF FF | mov     [rbp+var_D4], edi
0x004B530E | 89 B5 28 FF FF FF | mov     [rbp+var_D8], esi
0x004B5314 | 89 95 24 FF FF FF | mov     [rbp+var_DC], edx
0x004B531A | 48 89 8D 18 FF FF FF | mov     [rbp+var_E8], rcx
0x004B5321 | 4C 89 85 10 FF FF FF | mov     [rbp+var_F0], r8
0x004B5328 | 44 89 8D 20 FF FF FF | mov     [rbp+var_E0], r9d
0x004B532F | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004B5336 | 48 C7 85 50 FF FF FF 00 00 00 00 | mov     [rbp+var_B0], 0
0x004B5341 | 8B 85 2C FF FF FF | mov     eax, [rbp+var_D4]
0x004B5347 | 89 85 40 FF FF FF | mov     [rbp+fd], eax
0x004B534D | 8B 85 28 FF FF FF | mov     eax, [rbp+var_D8]
0x004B5353 | 89 85 44 FF FF FF | mov     [rbp+var_BC], eax
0x004B5359 | 8B 85 40 FF FF FF | mov     eax, [rbp+fd]
0x004B535F | 48 8D 95 40 FF FF FF | lea     rdx, [rbp+fd]
0x004B5366 | 48 8D 4A 20 | lea     rcx, [rdx+20h]
0x004B536A | BA 21 27 52 00 | mov     edx, offset aCanTStatTarFil; "can't stat tar file"
0x004B536F | 48 89 CE | mov     rsi, rcx
0x004B5372 | 89 C7 | mov     edi, eax
0x004B5374 | E8 6E 57 F5 FF | call    sub_40AAE7
0x004B5379 | 83 BD 20 FF FF FF 00 | cmp     [rbp+var_E0], 0
0x004B5380 | 74 15 | jz      short loc_4B5397
0x004B5382 | 8B 85 40 FF FF FF | mov     eax, [rbp+fd]
0x004B5388 | 8B 95 20 FF FF FF | mov     edx, [rbp+var_E0]
0x004B538E | 89 D6 | mov     esi, edx
0x004B5390 | 89 C7 | mov     edi, eax
0x004B5392 | E8 55 FE FF FF | call    sub_4B51EC
0x004B5397 | 48 8B 85 10 FF FF FF | mov     rax, [rbp+var_F0]
0x004B539E | 48 89 85 48 FF FF FF | mov     [rbp+var_B8], rax
0x004B53A5 | EB 4F | jmp     short loc_4B53F6
0x004B53A7 | 8B B5 24 FF FF FF | mov     esi, [rbp+var_DC]
0x004B53AD | 48 8B 85 18 FF FF FF | mov     rax, [rbp+var_E8]
0x004B53B4 | 48 8B 40 08 | mov     rax, [rax+8]
0x004B53B8 | 48 8D 95 40 FF FF FF | lea     rdx, [rbp+fd]
0x004B53BF | 41 B9 00 00 00 00 | mov     r9d, 0
0x004B53C5 | 49 89 D0 | mov     r8, rdx
0x004B53C8 | B9 B0 4F 4B 00 | mov     ecx, offset sub_4B4FB0
0x004B53CD | BA B0 4F 4B 00 | mov     edx, offset sub_4B4FB0
0x004B53D2 | 48 89 C7 | mov     rdi, rax
0x004B53D5 | E8 52 21 05 00 | call    sub_50752C
0x004B53DA | 85 C0 | test    eax, eax
0x004B53DC | 75 07 | jnz     short loc_4B53E5
0x004B53DE | C7 45 FC 01 00 00 00 | mov     [rbp+var_4], 1
0x004B53E5 | 48 8B 85 18 FF FF FF | mov     rax, [rbp+var_E8]
0x004B53EC | 48 8B 00 | mov     rax, [rax]
0x004B53EF | 48 89 85 18 FF FF FF | mov     [rbp+var_E8], rax
0x004B53F6 | 48 83 BD 18 FF FF FF 00 | cmp     [rbp+var_E8], 0
0x004B53FE | 75 A7 | jnz     short loc_4B53A7
0x004B5400 | BA 00 04 00 00 | mov     edx, 400h; n
0x004B5405 | BE 00 00 00 00 | mov     esi, 0; c
0x004B540A | BF F8 B3 75 00 | mov     edi, offset dest; s
0x004B540F | E8 3C 19 F5 FF | call    _memset
0x004B5414 | 8B 85 40 FF FF FF | mov     eax, [rbp+fd]
0x004B541A | BA 00 04 00 00 | mov     edx, 400h
0x004B541F | BE F8 B3 75 00 | mov     esi, offset dest
0x004B5424 | 89 C7 | mov     edi, eax
0x004B5426 | E8 80 50 F5 FF | call    sub_40A4AB
0x004B542B | 8B 85 40 FF FF FF | mov     eax, [rbp+fd]
0x004B5431 | 89 C7 | mov     edi, eax; fd
0x004B5433 | E8 D8 19 F5 FF | call    _close
0x004B5438 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004B543C | 74 0F | jz      short loc_4B544D
0x004B543E | BF 38 27 52 00 | mov     edi, offset aErrorExitDelay; "error exit delayed from previous errors"
0x004B5443 | B8 00 00 00 00 | mov     eax, 0
0x004B5448 | E8 FA 42 F5 FF | call    sub_409747
0x004B544D | 83 BD 20 FF FF FF 00 | cmp     [rbp+var_E0], 0
0x004B5454 | 74 53 | jz      short loc_4B54A9
0x004B5456 | 48 8D 85 3C FF FF FF | lea     rax, [rbp+var_C4]
0x004B545D | BA 00 00 00 00 | mov     edx, 0
0x004B5462 | 48 89 C6 | mov     rsi, rax
0x004B5465 | BF FF FF FF FF | mov     edi, 0FFFFFFFFh
0x004B546A | E8 D9 4A F5 FF | call    sub_409F48
0x004B546F | 83 F8 FF | cmp     eax, 0FFFFFFFFh
0x004B5472 | 75 11 | jnz     short loc_4B5485
0x004B5474 | BF 60 27 52 00 | mov     edi, offset aWaitpid_1; "waitpid"
0x004B5479 | B8 00 00 00 00 | mov     eax, 0
0x004B547E | E8 56 3D F5 FF | call    sub_4091D9
0x004B5483 | EB 24 | jmp     short loc_4B54A9
0x004B5485 | 8B 85 3C FF FF FF | mov     eax, [rbp+var_C4]
0x004B548B | 83 E0 7F | and     eax, 7Fh
0x004B548E | 85 C0 | test    eax, eax
0x004B5490 | 75 10 | jnz     short loc_4B54A2
0x004B5492 | 8B 85 3C FF FF FF | mov     eax, [rbp+var_C4]
0x004B5498 | C1 F8 08 | sar     eax, 8
0x004B549B | 0F B6 C0 | movzx   eax, al
0x004B549E | 85 C0 | test    eax, eax
0x004B54A0 | 74 07 | jz      short loc_4B54A9
0x004B54A2 | C7 45 FC 01 00 00 00 | mov     [rbp+var_4], 1
0x004B54A9 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004B54AC | C9 | leave
0x004B54AD | C3 | retn
 ************ 
Source Code:
static NOINLINE int writeTarFile(int tar_fd, int verboseFlag,
	int recurseFlags, const llist_t *include,
	const llist_t *exclude, int gzip)
{
	int errorFlag = FALSE;
	struct TarBallInfo tbInfo;

	tbInfo.hlInfoHead = NULL;
	tbInfo.tarFd = tar_fd;
	tbInfo.verboseFlag = verboseFlag;

	/* Store the stat info for the tarball's file, so
	 * can avoid including the tarball into itself....  */
	xfstat(tbInfo.tarFd, &tbInfo.tarFileStatBuf, "can't stat tar file");

#if ENABLE_FEATURE_SEAMLESS_GZ || ENABLE_FEATURE_SEAMLESS_BZ2
	if (gzip)
		vfork_compressor(tbInfo.tarFd, gzip);
#endif

	tbInfo.excludeList = exclude;

	/* Read the directory/files and iterate over them one at a time */
	while (include) {
		if (!recursive_action(include->data, recurseFlags,
				writeFileToTarball, writeFileToTarball, &tbInfo, 0)
		) {
			errorFlag = TRUE;
		}
		include = include->link;
	}
	/* Write two empty blocks to the end of the archive */
	memset(block_buf, 0, 2*TAR_BLOCK_SIZE);
	xwrite(tbInfo.tarFd, block_buf, 2*TAR_BLOCK_SIZE);

	/* To be pedantically correct, we would check if the tarball
	 * is smaller than 20 tar blocks, and pad it if it was smaller,
	 * but that isn't necessary for GNU tar interoperability, and
	 * so is considered a waste of space */

	/* Close so the child process (if any) will exit */
	close(tbInfo.tarFd);

	/* Hang up the tools, close up shop, head home */
	if (ENABLE_FEATURE_CLEAN_UP)
		freeHardLinkInfo(&tbInfo.hlInfoHead);

	if (errorFlag)
		bb_error_msg("error exit delayed from previous errors");

#if ENABLE_FEATURE_SEAMLESS_GZ || ENABLE_FEATURE_SEAMLESS_BZ2
	if (gzip) {
		int status;
		if (safe_waitpid(-1, &status, 0) == -1)
			bb_perror_msg("waitpid");
		else if (!WIFEXITED(status) || WEXITSTATUS(status))
			/* gzip was killed or has exited with nonzero! */
			errorFlag = TRUE;
	}
#endif
	return errorFlag;
}
 ************ 
Parsed Output:
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

void processTarFile(int fd, int flag, const char *tarFileName, void *callbackData, void (*callback)(void *, const char *, int)) {
    int status = 0;
    int childExitStatus = 0;
    char dest[1024];
    memset(dest, 0, 1024);

    callback(callbackData, "can't stat tar file", fd);

    if (flag != 0) {
        sub_4B51EC(fd, flag);
    }

    void *data = callbackData;
    while (data != NULL) {
        callback(data, sub_4B4FB0, fd);
        if (sub_50752C(data, sub_4B4FB0, 0, fd, 0) != 0) {
            status = 1;
        }
        data = *(void **)data;
    }

    _memset(dest, 0, 1024);
    sub_40A4AB(fd, dest, 1024);
    _close(fd);

    if (status != 0) {
        sub_409747("error exit delayed from previous errors", 0);
    }

    if (flag != 0) {
        pid_t pid = waitpid(-1, &childExitStatus, 0);
        if (pid == -1) {
            sub_4091D9("waitpid", 0);
        } else if (WIFSIGNALED(childExitStatus) || WEXITSTATUS(childExitStatus) != 0) {
            status = 1;
        }
    }

    return status;
}
 ************ 
Similarity Score (Unixcoder): 0.6927143931388855
Func rank: 34

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: reset_main
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004C464E | 55 | push    rbp
0x004C464F | 48 89 E5 | mov     rbp, rsp
0x004C4652 | 48 83 EC 10 | sub     rsp, 10h
0x004C4656 | 89 7D FC | mov     [rbp+var_4], edi
0x004C4659 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004C465D | BF 01 00 00 00 | mov     edi, 1; fd
0x004C4662 | E8 F9 21 F4 FF | call    _isatty
0x004C4667 | 85 C0 | test    eax, eax
0x004C4669 | 74 20 | jz      short loc_4C468B
0x004C466B | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; "\x1Bc\x1B(B\x1B[0m\x1B[J\x1B[?25h"
0x004C4670 | B8 00 00 00 00 | mov     eax, 0
0x004C4675 | E8 56 25 F4 FF | call    _printf
0x004C467A | BE 50 6D 52 00 | mov     esi, offset off_526D50; "stty"
0x004C467F | BF 02 00 00 00 | mov     edi, 2
0x004C4684 | E8 7D FE 00 00 | call    sub_4D4506
0x004C4689 | EB 05 | jmp     short locret_4C4690
0x004C468B | B8 00 00 00 00 | mov     eax, 0
0x004C4690 | C9 | leave
0x004C4691 | C3 | retn
 ************ 
Source Code:
int reset_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
{
	static const char *const args[] = {
		"stty", "sane", NULL
	};

	/* no options, no getopt */

	if (/*isatty(STDIN_FILENO) &&*/ isatty(STDOUT_FILENO)) {
		/* See 'man 4 console_codes' for details:
		 * "ESC c"        -- Reset
		 * "ESC ( B"      -- Select G0 Character Set (B = US)
		 * "ESC [ 0 m"    -- Reset all display attributes
		 * "ESC [ J"      -- Erase to the end of screen
		 * "ESC [ ? 25 h" -- Make cursor visible
		 */
		printf(ESC"c" ESC"(B" ESC"[0m" ESC"[J" ESC"[?25h");
		/* http://bugs.busybox.net/view.php?id=1414:
		 * people want it to reset echo etc: */
#if ENABLE_STTY
		return stty_main(2, (char**)args);
#else
		execvp("stty", (char**)args);
#endif
	}
	return EXIT_SUCCESS;
}
 ************ 
Parsed Output:
int clearAndSetTerminal(int fd, char *command) {
    int isTerminal = isatty(fd);
    if (isTerminal) {
        printf("\x1Bc\x1B(B\x1B[0m\x1B[J\x1B[?25h");
        sub_4D4506(2, "stty");
    }
    return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.6906628012657166
Func rank: 35

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: log_to_shmem
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0048CF88 | 55 | push    rbp
0x0048CF89 | 48 89 E5 | mov     rbp, rsp
0x0048CF8C | 48 83 EC 20 | sub     rsp, 20h
0x0048CF90 | 48 89 7D E8 | mov     [rbp+s], rdi
0x0048CF94 | 48 8B 05 6D 04 2D 00 | mov     rax, cs:qword_75D408
0x0048CF9B | 48 8D 48 36 | lea     rcx, [rax+36h]
0x0048CF9F | 48 8B 05 62 04 2D 00 | mov     rax, cs:qword_75D408
0x0048CFA6 | 8B 40 28 | mov     eax, [rax+28h]
0x0048CFA9 | BA 03 00 00 00 | mov     edx, 3; nsops
0x0048CFAE | 48 89 CE | mov     rsi, rcx; sops
0x0048CFB1 | 89 C7 | mov     edi, eax; semid
0x0048CFB3 | E8 88 AA F7 FF | call    _semop
0x0048CFB8 | 83 F8 FF | cmp     eax, 0FFFFFFFFh
0x0048CFBB | 75 0F | jnz     short loc_48CFCC
0x0048CFBD | BF 9A F6 51 00 | mov     edi, offset aSmwdn; "SMwdn"
0x0048CFC2 | B8 00 00 00 00 | mov     eax, 0
0x0048CFC7 | E8 D6 C2 F7 FF | call    sub_4092A2
0x0048CFCC | 48 8B 45 E8 | mov     rax, [rbp+s]
0x0048CFD0 | 48 89 C7 | mov     rdi, rax; s
0x0048CFD3 | E8 F8 9A F7 FF | call    _strlen
0x0048CFD8 | 83 C0 01 | add     eax, 1
0x0048CFDB | 89 45 FC | mov     [rbp+var_4], eax
0x0048CFDE | 48 8B 05 23 04 2D 00 | mov     rax, cs:qword_75D408
0x0048CFE5 | 48 8B 40 60 | mov     rax, [rax+60h]
0x0048CFE9 | 8B 40 04 | mov     eax, [rax+4]
0x0048CFEC | 89 45 F8 | mov     [rbp+var_8], eax
0x0048CFEF | 8B 55 F8 | mov     edx, [rbp+var_8]
0x0048CFF2 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0048CFF5 | 01 D0 | add     eax, edx
0x0048CFF7 | 89 45 F4 | mov     [rbp+var_C], eax
0x0048CFFA | 48 8B 05 07 04 2D 00 | mov     rax, cs:qword_75D408
0x0048D001 | 48 8B 40 60 | mov     rax, [rax+60h]
0x0048D005 | 8B 00 | mov     eax, [rax]
0x0048D007 | 39 45 F4 | cmp     [rbp+var_C], eax
0x0048D00A | 7D 68 | jge     short loc_48D074
0x0048D00C | 8B 45 FC | mov     eax, [rbp+var_4]
0x0048D00F | 48 63 D0 | movsxd  rdx, eax; n
0x0048D012 | 48 8B 05 EF 03 2D 00 | mov     rax, cs:qword_75D408
0x0048D019 | 48 8B 40 60 | mov     rax, [rax+60h]
0x0048D01D | 48 8D 48 08 | lea     rcx, [rax+8]
0x0048D021 | 8B 45 F8 | mov     eax, [rbp+var_8]
0x0048D024 | 48 98 | cdqe
0x0048D026 | 48 01 C1 | add     rcx, rax
0x0048D029 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x0048D02D | 48 89 C6 | mov     rsi, rax; src
0x0048D030 | 48 89 CF | mov     rdi, rcx; dest
0x0048D033 | E8 68 A1 F7 FF | call    _memcpy
0x0048D038 | 48 8B 05 C9 03 2D 00 | mov     rax, cs:qword_75D408
0x0048D03F | 48 8B 40 60 | mov     rax, [rax+60h]
0x0048D043 | 8B 55 F4 | mov     edx, [rbp+var_C]
0x0048D046 | 89 50 04 | mov     [rax+4], edx
0x0048D049 | 48 8B 05 B8 03 2D 00 | mov     rax, cs:qword_75D408
0x0048D050 | 48 8D 48 30 | lea     rcx, [rax+30h]
0x0048D054 | 48 8B 05 AD 03 2D 00 | mov     rax, cs:qword_75D408
0x0048D05B | 8B 40 28 | mov     eax, [rax+28h]
0x0048D05E | BA 01 00 00 00 | mov     edx, 1; nsops
0x0048D063 | 48 89 CE | mov     rsi, rcx; sops
0x0048D066 | 89 C7 | mov     edi, eax; semid
0x0048D068 | E8 D3 A9 F7 FF | call    _semop
0x0048D06D | 83 F8 FF | cmp     eax, 0FFFFFFFFh
0x0048D070 | 75 76 | jnz     short loc_48D0E8
0x0048D072 | EB 65 | jmp     short loc_48D0D9
0x0048D074 | 48 8B 05 8D 03 2D 00 | mov     rax, cs:qword_75D408
0x0048D07B | 48 8B 40 60 | mov     rax, [rax+60h]
0x0048D07F | 8B 00 | mov     eax, [rax]
0x0048D081 | 2B 45 F8 | sub     eax, [rbp+var_8]
0x0048D084 | 89 45 F0 | mov     [rbp+var_10], eax
0x0048D087 | 8B 45 F0 | mov     eax, [rbp+var_10]
0x0048D08A | 48 63 D0 | movsxd  rdx, eax; n
0x0048D08D | 48 8B 05 74 03 2D 00 | mov     rax, cs:qword_75D408
0x0048D094 | 48 8B 40 60 | mov     rax, [rax+60h]
0x0048D098 | 48 8D 48 08 | lea     rcx, [rax+8]
0x0048D09C | 8B 45 F8 | mov     eax, [rbp+var_8]
0x0048D09F | 48 98 | cdqe
0x0048D0A1 | 48 01 C1 | add     rcx, rax
0x0048D0A4 | 48 8B 45 E8 | mov     rax, [rbp+s]
0x0048D0A8 | 48 89 C6 | mov     rsi, rax; src
0x0048D0AB | 48 89 CF | mov     rdi, rcx; dest
0x0048D0AE | E8 ED A0 F7 FF | call    _memcpy
0x0048D0B3 | 8B 45 F0 | mov     eax, [rbp+var_10]
0x0048D0B6 | 48 98 | cdqe
0x0048D0B8 | 48 01 45 E8 | add     [rbp+s], rax
0x0048D0BC | 8B 45 F0 | mov     eax, [rbp+var_10]
0x0048D0BF | 29 45 FC | sub     [rbp+var_4], eax
0x0048D0C2 | 48 8B 05 3F 03 2D 00 | mov     rax, cs:qword_75D408
0x0048D0C9 | 48 8B 40 60 | mov     rax, [rax+60h]
0x0048D0CD | C7 40 04 00 00 00 00 | mov     dword ptr [rax+4], 0
0x0048D0D4 | E9 05 FF FF FF | jmp     loc_48CFDE
0x0048D0D9 | BF A0 F6 51 00 | mov     edi, offset aSmwup; "SMwup"
0x0048D0DE | B8 00 00 00 00 | mov     eax, 0
0x0048D0E3 | E8 BA C1 F7 FF | call    sub_4092A2
0x0048D0E8 | 90 | nop
0x0048D0E9 | C9 | leave
0x0048D0EA | C3 | retn
 ************ 
Source Code:
static void log_to_shmem(const char *msg)
{
	int old_tail, new_tail;
	int len;

	if (semop(G.s_semid, G.SMwdn, 3) == -1) {
		bb_perror_msg_and_die("SMwdn");
	}

	/* Circular Buffer Algorithm:
	 * --------------------------
	 * tail == position where to store next syslog message.
	 * tail's max value is (shbuf->size - 1)
	 * Last byte of buffer is never used and remains NUL.
	 */
	len = strlen(msg) + 1; /* length with NUL included */
 again:
	old_tail = G.shbuf->tail;
	new_tail = old_tail + len;
	if (new_tail < G.shbuf->size) {
		/* store message, set new tail */
		memcpy(G.shbuf->data + old_tail, msg, len);
		G.shbuf->tail = new_tail;
	} else {
		/* k == available buffer space ahead of old tail */
		int k = G.shbuf->size - old_tail;
		/* copy what fits to the end of buffer, and repeat */
		memcpy(G.shbuf->data + old_tail, msg, k);
		msg += k;
		len -= k;
		G.shbuf->tail = 0;
		goto again;
	}
	if (semop(G.s_semid, G.SMwup, 1) == -1) {
		bb_perror_msg_and_die("SMwup");
	}
	if (DEBUG)
		printf("tail:%d
", G.shbuf->tail);
}
 ************ 
Parsed Output:
#include <string.h>
#include <sys/sem.h>

void updateSharedBuffer(char *s) {
    int semid = *((int*)0x75D408 + 10);
    struct sembuf sops[2] = {
        { .sem_num = 0, .sem_op = 0, .sem_flg = 0 },
        { .sem_num = 0, .sem_op = 1, .sem_flg = 0 }
    };

    if (semop(semid, &sops[1], 1) == -1) {
        sub_4092A2("SMwdn", 0);
        return;
    }

    int s_len = strlen(s) + 1;
    int *shared_len = (int*)(*((int*)0x75D408 + 24) + 4);
    int new_len = *shared_len + s_len;

    if (new_len < *((int*)0x75D408 + 24)) {
        char *shared_buffer = (char*)(*((int*)0x75D408 + 24) + 8);
        memcpy(shared_buffer + *shared_len, s, s_len);
        *shared_len = new_len;
    } else {
        int available_space = *((int*)0x75D408 + 24) - *shared_len;
        memcpy((char*)(*((int*)0x75D408 + 24) + 8 + *shared_len), s, available_space);
        s += available_space;
        s_len -= available_space;
        *shared_len = 0;
        if (s_len > 0) {
            memcpy((char*)(*((int*)0x75D408 + 24) + 8), s, s_len);
            *shared_len = s_len;
        }
    }

    if (semop(semid, &sops[0], 1) == -1) {
        sub_4092A2("SMwup", 0);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.688118577003479
Func rank: 36

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: strncmpz
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004317A8 | 55 | push    rbp
0x004317A9 | 48 89 E5 | mov     rbp, rsp
0x004317AC | 48 83 EC 30 | sub     rsp, 30h
0x004317B0 | 48 89 7D E8 | mov     [rbp+s1], rdi
0x004317B4 | 48 89 75 E0 | mov     [rbp+s2], rsi
0x004317B8 | 48 89 55 D8 | mov     [rbp+n], rdx
0x004317BC | 48 8B 55 D8 | mov     rdx, [rbp+n]; n
0x004317C0 | 48 8B 4D E0 | mov     rcx, [rbp+s2]
0x004317C4 | 48 8B 45 E8 | mov     rax, [rbp+s1]
0x004317C8 | 48 89 CE | mov     rsi, rcx; s2
0x004317CB | 48 89 C7 | mov     rdi, rax; s1
0x004317CE | E8 CD 4F FD FF | call    _strncmp
0x004317D3 | 89 45 FC | mov     [rbp+var_4], eax
0x004317D6 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004317DA | 75 15 | jnz     short loc_4317F1
0x004317DC | 48 8B 55 E0 | mov     rdx, [rbp+s2]
0x004317E0 | 48 8B 45 D8 | mov     rax, [rbp+n]
0x004317E4 | 48 01 D0 | add     rax, rdx
0x004317E7 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004317EA | 0F B6 C0 | movzx   eax, al
0x004317ED | F7 D8 | neg     eax
0x004317EF | EB 03 | jmp     short locret_4317F4
0x004317F1 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004317F4 | C9 | leave
0x004317F5 | C3 | retn
 ************ 
Source Code:
static int strncmpz(const char *l, const char *r, size_t llen)
{
	int i = strncmp(l, r, llen);

	if (i == 0)
		return - (unsigned char)r[llen];
	return i;
}
 ************ 
Parsed Output:
int compare_and_negate_if_equal(const char *s1, const char *s2, size_t n) {
    int result = strncmp(s1, s2, n);
    if (result == 0) {
        result = -s2[n];
    }
    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.6855593919754028
Func rank: 37

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: bb_strtoull
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0040BDA6 | 55 | push    rbp
0x0040BDA7 | 48 89 E5 | mov     rbp, rsp
0x0040BDAA | 48 83 EC 30 | sub     rsp, 30h
0x0040BDAE | 48 89 7D E8 | mov     [rbp+nptr], rdi
0x0040BDB2 | 48 89 75 E0 | mov     [rbp+endptr], rsi
0x0040BDB6 | 89 55 DC | mov     [rbp+base], edx
0x0040BDB9 | 48 83 7D E0 00 | cmp     [rbp+endptr], 0
0x0040BDBE | 75 08 | jnz     short loc_40BDC8
0x0040BDC0 | 48 8D 45 F0 | lea     rax, [rbp+var_10]
0x0040BDC4 | 48 89 45 E0 | mov     [rbp+endptr], rax
0x0040BDC8 | 48 8B 45 E0 | mov     rax, [rbp+endptr]
0x0040BDCC | 48 8B 55 E8 | mov     rdx, [rbp+nptr]
0x0040BDD0 | 48 89 10 | mov     [rax], rdx
0x0040BDD3 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0040BDD7 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0040BDDA | 0F B6 C0 | movzx   eax, al
0x0040BDDD | 89 C7 | mov     edi, eax
0x0040BDDF | E8 0E FF FF FF | call    sub_40BCF2
0x0040BDE4 | 85 C0 | test    eax, eax
0x0040BDE6 | 75 07 | jnz     short loc_40BDEF
0x0040BDE8 | E8 43 FF FF FF | call    sub_40BD30
0x0040BDED | EB 3A | jmp     short locret_40BE29
0x0040BDEF | 48 8B 05 0A 16 35 00 | mov     rax, cs:qword_75D400
0x0040BDF6 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x0040BDFC | 8B 55 DC | mov     edx, [rbp+base]; base
0x0040BDFF | 48 8B 4D E0 | mov     rcx, [rbp+endptr]
0x0040BE03 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x0040BE07 | 48 89 CE | mov     rsi, rcx; endptr
0x0040BE0A | 48 89 C7 | mov     rdi, rax; nptr
0x0040BE0D | E8 CE B1 FF FF | call    _strtoull
0x0040BE12 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0040BE16 | 48 8B 55 E0 | mov     rdx, [rbp+endptr]
0x0040BE1A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0040BE1E | 48 89 D6 | mov     rsi, rdx
0x0040BE21 | 48 89 C7 | mov     rdi, rax
0x0040BE24 | E8 21 FF FF FF | call    sub_40BD4A
0x0040BE29 | C9 | leave
0x0040BE2A | C3 | retn
 ************ 
Source Code:
unsigned long long FAST_FUNC bb_strtoull(const char *arg, char **endp, int base)
{
	unsigned long long v;
	char *endptr;

	if (!endp) endp = &endptr;
	*endp = (char*) arg;

	/* strtoul("  -4200000000") returns 94967296, errno 0 (!) */
	/* I don't think that this is right. Preventing this... */
	if (!isalnum(arg[0])) return ret_ERANGE();

	/* not 100% correct for lib func, but convenient for the caller */
	errno = 0;
	v = strtoull(arg, endp, base);
	return handle_errors(v, endp);
}
 ************ 
Parsed Output:
#include <stdlib.h>

unsigned long long parseAndValidateInput(const char *nptr, char **endptr, int base) {
    if (endptr == NULL) {
        char *local_endptr;
        endptr = &local_endptr;
    }

    *endptr = (char *)nptr;
    unsigned char firstChar = (unsigned char)**endptr;

    if (!sub_40BCF2(firstChar)) {
        sub_40BD30();
        return 0;
    }

    qword_75D400 = 0;
    unsigned long long result = strtoull(nptr, endptr, base);
    sub_40BD4A(result, *endptr);

    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.6837901473045349
Func rank: 38

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: get_input_line
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004EF6AB | 55 | push    rbp
0x004EF6AC | 48 89 E5 | mov     rbp, rsp
0x004EF6AF | 48 83 EC 20 | sub     rsp, 20h
0x004EF6B3 | 48 89 7D E8 | mov     [rbp+src], rdi
0x004EF6B7 | 48 8B 05 4A DD 26 00 | mov     rax, cs:qword_75D408
0x004EF6BE | 48 8D 90 38 05 00 00 | lea     rdx, [rax+538h]
0x004EF6C5 | 48 8B 45 E8 | mov     rax, [rbp+src]
0x004EF6C9 | 48 89 C6 | mov     rsi, rax; src
0x004EF6CC | 48 89 D7 | mov     rdi, rdx; dest
0x004EF6CF | E8 FC 70 F1 FF | call    _strcpy
0x004EF6D4 | 48 8B 05 2D DD 26 00 | mov     rax, cs:qword_75D408
0x004EF6DB | C7 40 4C 00 00 00 00 | mov     dword ptr [rax+4Ch], 0
0x004EF6E2 | E8 50 05 00 00 | call    sub_4EFC37
0x004EF6E7 | 48 8B 45 E8 | mov     rax, [rbp+src]
0x004EF6EB | 48 89 C7 | mov     rdi, rax
0x004EF6EE | E8 E3 BB FF FF | call    sub_4EB2D6
0x004EF6F3 | 48 8B 05 0E DD 26 00 | mov     rax, cs:qword_75D408
0x004EF6FA | 48 05 38 05 00 00 | add     rax, 538h
0x004EF700 | 48 89 C7 | mov     rdi, rax; s
0x004EF703 | E8 C8 73 F1 FF | call    _strlen
0x004EF708 | 89 45 FC | mov     [rbp+var_4], eax
0x004EF70B | E9 B8 00 00 00 | jmp     loc_4EF7C8
0x004EF710 | E8 94 FE FF FF | call    sub_4EF5A9
0x004EF715 | 89 45 F8 | mov     [rbp+var_8], eax
0x004EF718 | 83 7D F8 0A | cmp     [rbp+var_8], 0Ah
0x004EF71C | 0F 84 B3 00 00 00 | jz      loc_4EF7D5
0x004EF722 | 83 7D F8 0D | cmp     [rbp+var_8], 0Dh
0x004EF726 | 0F 84 A9 00 00 00 | jz      loc_4EF7D5
0x004EF72C | 83 7D F8 1B | cmp     [rbp+var_8], 1Bh
0x004EF730 | 0F 84 9F 00 00 00 | jz      loc_4EF7D5
0x004EF736 | 48 8B 05 CB DC 26 00 | mov     rax, cs:qword_75D408
0x004EF73D | 0F B6 40 74 | movzx   eax, byte ptr [rax+74h]
0x004EF741 | 0F BE C0 | movsx   eax, al
0x004EF744 | 39 45 F8 | cmp     [rbp+var_8], eax
0x004EF747 | 74 0C | jz      short loc_4EF755
0x004EF749 | 83 7D F8 08 | cmp     [rbp+var_8], 8
0x004EF74D | 74 06 | jz      short loc_4EF755
0x004EF74F | 83 7D F8 7F | cmp     [rbp+var_8], 7Fh
0x004EF753 | 75 2A | jnz     short loc_4EF77F
0x004EF755 | 48 8B 15 AC DC 26 00 | mov     rdx, cs:qword_75D408
0x004EF75C | 83 6D FC 01 | sub     [rbp+var_4], 1
0x004EF760 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004EF763 | 48 98 | cdqe
0x004EF765 | C6 84 02 38 05 00 00 00 | mov     byte ptr [rdx+rax+538h], 0
0x004EF76D | BF DB 76 52 00 | mov     edi, offset asc_5276DB; "\b \b"
0x004EF772 | E8 5F BB FF FF | call    sub_4EB2D6
0x004EF777 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004EF77B | 7E 57 | jle     short loc_4EF7D4
0x004EF77D | EB 49 | jmp     short loc_4EF7C8
0x004EF77F | 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004EF783 | 7E 43 | jle     short loc_4EF7C8
0x004EF785 | 81 7D F8 FF 00 00 00 | cmp     [rbp+var_8], 0FFh
0x004EF78C | 7F 3A | jg      short loc_4EF7C8
0x004EF78E | 48 8B 15 73 DC 26 00 | mov     rdx, cs:qword_75D408
0x004EF795 | 8B 45 F8 | mov     eax, [rbp+var_8]
0x004EF798 | 89 C1 | mov     ecx, eax
0x004EF79A | 8B 45 FC | mov     eax, [rbp+var_4]
0x004EF79D | 48 98 | cdqe
0x004EF79F | 88 8C 02 38 05 00 00 | mov     [rdx+rax+538h], cl
0x004EF7A6 | 48 8B 15 5B DC 26 00 | mov     rdx, cs:qword_75D408
0x004EF7AD | 83 45 FC 01 | add     [rbp+var_4], 1
0x004EF7B1 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004EF7B4 | 48 98 | cdqe
0x004EF7B6 | C6 84 02 38 05 00 00 00 | mov     byte ptr [rdx+rax+538h], 0
0x004EF7BE | 8B 45 F8 | mov     eax, [rbp+var_8]
0x004EF7C1 | 89 C7 | mov     edi, eax
0x004EF7C3 | E8 91 AE F1 FF | call    sub_40A659
0x004EF7C8 | 83 7D FC 7F | cmp     [rbp+var_4], 7Fh
0x004EF7CC | 0F 8E 3E FF FF FF | jle     loc_4EF710
0x004EF7D2 | EB 01 | jmp     short loc_4EF7D5
0x004EF7D4 | 90 | nop
0x004EF7D5 | BF 00 00 00 00 | mov     edi, 0
0x004EF7DA | E8 1C 0E 00 00 | call    sub_4F05FB
0x004EF7DF | 48 8B 05 22 DC 26 00 | mov     rax, cs:qword_75D408
0x004EF7E6 | 48 05 38 05 00 00 | add     rax, 538h
0x004EF7EC | C9 | leave
0x004EF7ED | C3 | retn
 ************ 
Source Code:
static char *get_input_line(const char *prompt)
{
	// char [MAX_INPUT_LEN]
#define buf get_input_line__buf

	int c;
	int i;

	strcpy(buf, prompt);
	last_status_cksum = 0;	// force status update
	go_bottom_and_clear_to_eol();
	write1(prompt);      // write out the :, /, or ? prompt

	i = strlen(buf);
	while (i < MAX_INPUT_LEN) {
		c = get_one_char();
		if (c == '
' || c == '\r' || c == 27)
			break;		// this is end of input
		if (c == erase_char || c == 8 || c == 127) {
			// user wants to erase prev char
			buf[--i] = '\0';
			write1("\b \b"); // erase char on screen
			if (i <= 0) // user backs up before b-o-l, exit
				break;
		} else if (c > 0 && c < 256) { // exclude Unicode
			// (TODO: need to handle Unicode)
			buf[i] = c;
			buf[++i] = '\0';
			bb_putchar(c);
		}
	}
	refresh(FALSE);
	return buf;
#undef buf
}
 ************ 
Parsed Output:
void processInputString(char *src) {
    extern char qword_75D408[];
    strcpy(&qword_75D408[538], src);
    *(int *)&qword_75D408[76] = 0;
    sub_4EFC37();
    sub_4EB2D6(src);
    int length = strlen(&qword_75D408[538]);
    int inputChar;

    while (length <= 127) {
        inputChar = sub_4EF5A9();
        if (inputChar == 10 || inputChar == 13 || inputChar == 27) {
            break;
        }

        if (inputChar == qword_75D408[116] || inputChar == 8 || inputChar == 127) {
            if (--length >= 0) {
                qword_75D408[length + 538] = '\0';
                sub_4EB2D6("\b \b");
            }
        } else if (inputChar > 0 && inputChar <= 255) {
            qword_75D408[length + 538] = (char)inputChar;
            length++;
            qword_75D408[length + 538] = '\0';
            sub_40A659(inputChar);
        }
    }

    if (length > 127) {
        while (length > 127) {
            inputChar = sub_4EF5A9();
        }
    }

    sub_4F05FB(0);
}
 ************ 
Similarity Score (Unixcoder): 0.6768890023231506
Func rank: 39

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: udhcp_recv_kernel_packet
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0045897C | 55 | push    rbp
0x0045897D | 48 89 E5 | mov     rbp, rsp
0x00458980 | 53 | push    rbx
0x00458981 | 48 83 EC 28 | sub     rsp, 28h
0x00458985 | 48 89 7D D8 | mov     [rbp+s], rdi
0x00458989 | 89 75 D4 | mov     [rbp+var_2C], esi
0x0045898C | 48 8B 45 D8 | mov     rax, [rbp+s]
0x00458990 | BA 74 02 00 00 | mov     edx, 274h; n
0x00458995 | BE 00 00 00 00 | mov     esi, 0; c
0x0045899A | 48 89 C7 | mov     rdi, rax; s
0x0045899D | E8 AE E3 FA FF | call    _memset
0x004589A2 | 48 8B 4D D8 | mov     rcx, [rbp+s]
0x004589A6 | 8B 45 D4 | mov     eax, [rbp+var_2C]
0x004589A9 | BA 74 02 00 00 | mov     edx, 274h
0x004589AE | 48 89 CE | mov     rsi, rcx
0x004589B1 | 89 C7 | mov     edi, eax
0x004589B3 | E8 47 2A FB FF | call    sub_40B3FF
0x004589B8 | 89 45 EC | mov     [rbp+var_14], eax
0x004589BB | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x004589BF | 79 1E | jns     short loc_4589DF
0x004589C1 | 8B 05 99 4A 30 00 | mov     eax, cs:dword_75D460
0x004589C7 | 85 C0 | test    eax, eax
0x004589C9 | 74 0F | jz      short loc_4589DA
0x004589CB | BF 7B D2 52 00 | mov     edi, offset aPacketReadErro_0; "Packet read error, ignoring"
0x004589D0 | B8 00 00 00 00 | mov     eax, 0
0x004589D5 | E8 E2 50 0A 00 | call    sub_4FDABC
0x004589DA | 8B 45 EC | mov     eax, [rbp+var_14]
0x004589DD | EB 60 | jmp     short loc_458A3F
0x004589DF | 8B 45 EC | mov     eax, [rbp+var_14]
0x004589E2 | 3D EF 00 00 00 | cmp     eax, 0EFh
0x004589E7 | 76 18 | jbe     short loc_458A01
0x004589E9 | 48 8B 45 D8 | mov     rax, [rbp+s]
0x004589ED | 8B 98 EC 00 00 00 | mov     ebx, [rax+0ECh]
0x004589F3 | BF 63 53 82 63 | mov     edi, 63825363h; hostlong
0x004589F8 | E8 33 E3 FA FF | call    _htonl
0x004589FD | 39 C3 | cmp     ebx, eax
0x004589FF | 74 16 | jz      short loc_458A17
0x00458A01 | BF 98 D2 52 00 | mov     edi, offset aPacketWithBadM_0; "Packet with bad magic, ignoring"
0x00458A06 | B8 00 00 00 00 | mov     eax, 0
0x00458A0B | E8 AC 50 0A 00 | call    sub_4FDABC
0x00458A10 | B8 FE FF FF FF | mov     eax, 0FFFFFFFEh
0x00458A15 | EB 28 | jmp     short loc_458A3F
0x00458A17 | 8B 05 43 4A 30 00 | mov     eax, cs:dword_75D460
0x00458A1D | 85 C0 | test    eax, eax
0x00458A1F | 74 0F | jz      short loc_458A30
0x00458A21 | BF B8 D2 52 00 | mov     edi, offset aReceivedAPacke_0; "Received a packet"
0x00458A26 | B8 00 00 00 00 | mov     eax, 0
0x00458A2B | E8 8C 50 0A 00 | call    sub_4FDABC
0x00458A30 | 48 8B 45 D8 | mov     rax, [rbp+s]
0x00458A34 | 48 89 C7 | mov     rdi, rax
0x00458A37 | E8 9C FE FF FF | call    sub_4588D8
0x00458A3C | 8B 45 EC | mov     eax, [rbp+var_14]
0x00458A3F | 48 83 C4 28 | add     rsp, 28h
0x00458A43 | 5B | pop     rbx
0x00458A44 | 5D | pop     rbp
0x00458A45 | C3 | retn
 ************ 
Source Code:
int FAST_FUNC udhcp_recv_kernel_packet(struct dhcp_packet *packet, int fd)
{
	int bytes;

	memset(packet, 0, sizeof(*packet));
	bytes = safe_read(fd, packet, sizeof(*packet));
	if (bytes < 0) {
		log1("Packet read error, ignoring");
		return bytes; /* returns -1 */
	}

	if (bytes < offsetof(struct dhcp_packet, options)
	 || packet->cookie != htonl(DHCP_MAGIC)
	) {
		bb_info_msg("Packet with bad magic, ignoring");
		return -2;
	}
	log1("Received a packet");
	udhcp_dump_packet(packet);

	return bytes;
}
 ************ 
Parsed Output:
#include <string.h>

int process_packet(void *s, int var_2C) {
    memset(s, 0, 0x274);
    int result = sub_40B3FF(s, var_2C, 0x274);
    
    if (result < 0) {
        if (dword_75D460) {
            sub_4FDABC("Packet read error, ignoring", 0);
        }
        return result;
    } else if (result > 0xEF) {
        int magic = *((int *)(s + 0xEC));
        if (htonl(0x63825363) != magic) {
            if (dword_75D460) {
                sub_4FDABC("Packet with bad magic, ignoring", 0);
            }
            return 0xFFFFFFFE;
        }
    }
    
    if (dword_75D460) {
        sub_4FDABC("Received a packet", 0);
    }
    
    sub_4588D8(s);
    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.6766293048858643
Func rank: 40

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: func_tty
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004633DC | 55 | push    rbp
0x004633DD | 48 89 E5 | mov     rbp, rsp
0x004633E0 | 48 83 EC 20 | sub     rsp, 20h
0x004633E4 | 48 89 7D F8 | mov     [rbp+s], rdi
0x004633E8 | 89 75 F4 | mov     [rbp+var_C], esi
0x004633EB | 48 89 55 E8 | mov     [rbp+var_18], rdx
0x004633EF | 48 8B 45 F8 | mov     rax, [rbp+s]
0x004633F3 | C6 00 3F | mov     byte ptr [rax], 3Fh ; '?'
0x004633F6 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x004633FA | 48 83 C0 01 | add     rax, 1
0x004633FE | C6 00 00 | mov     byte ptr [rax], 0
0x00463401 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00463405 | 8B 40 7C | mov     eax, [rax+7Ch]
0x00463408 | 85 C0 | test    eax, eax
0x0046340A | 74 35 | jz      short loc_463441
0x0046340C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00463410 | 8B 88 80 00 00 00 | mov     ecx, [rax+80h]
0x00463416 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0046341A | 8B 50 7C | mov     edx, [rax+7Ch]
0x0046341D | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00463420 | 83 C0 01 | add     eax, 1
0x00463423 | 48 63 F0 | movsxd  rsi, eax; maxlen
0x00463426 | 48 8B 45 F8 | mov     rax, [rbp+s]
0x0046342A | 41 89 C8 | mov     r8d, ecx
0x0046342D | 89 D1 | mov     ecx, edx
0x0046342F | BA 12 BF 51 00 | mov     edx, offset aUU_2; "%u,%u"
0x00463434 | 48 89 C7 | mov     rdi, rax; s
0x00463437 | B8 00 00 00 00 | mov     eax, 0
0x0046343C | E8 CF 37 FA FF | call    _snprintf
0x00463441 | 90 | nop
0x00463442 | C9 | leave
0x00463443 | C3 | retn
 ************ 
Source Code:
static void func_tty(char *buf, int size, const procps_status_t *ps)
{
	buf[0] = '?';
	buf[1] = '\0';
	if (ps->tty_major) /* tty field of "0" means "no tty" */
		snprintf(buf, size+1, "%u,%u", ps->tty_major, ps->tty_minor);
}
 ************ 
Parsed Output:
#include <stdio.h>

void formatStringWithValues(char *s, int value, unsigned int *data) {
    *s = '?';
    *(s + 1) = '\0';

    if (data[31] != 0) {
        snprintf(s, value + 1, "%u,%u", data[32], data[31]);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.6742444038391113
Func rank: 41

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: str2env
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004B70B6 | 55 | push    rbp
0x004B70B7 | 48 89 E5 | mov     rbp, rsp
0x004B70BA | 53 | push    rbx
0x004B70BB | 48 83 EC 28 | sub     rsp, 28h
0x004B70BF | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004B70C3 | 89 75 E4 | mov     [rbp+var_1C], esi
0x004B70C6 | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x004B70CA | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004B70CD | 48 98 | cdqe
0x004B70CF | 48 8B 04 C5 A0 29 52 00 | mov     rax, ds:off_5229A0[rax*8]; "MODE"
0x004B70D7 | 8B 55 E4 | mov     edx, [rbp+var_1C]
0x004B70DA | 48 63 D2 | movsxd  rdx, edx
0x004B70DD | 48 8D 0C D5 00 00 00 00 | lea     rcx, ds:0[rdx*8]
0x004B70E5 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x004B70E9 | 48 8D 1C 11 | lea     rbx, [rcx+rdx]
0x004B70ED | 48 8B 55 D8 | mov     rdx, [rbp+var_28]
0x004B70F1 | 48 89 C6 | mov     rsi, rax
0x004B70F4 | BF E0 29 52 00 | mov     edi, offset aTarSS; "TAR_%s=%s"
0x004B70F9 | B8 00 00 00 00 | mov     eax, 0
0x004B70FE | E8 B0 35 F5 FF | call    sub_40A6B3
0x004B7103 | 48 89 03 | mov     [rbx], rax
0x004B7106 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004B7109 | 48 98 | cdqe
0x004B710B | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]
0x004B7113 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004B7117 | 48 01 D0 | add     rax, rdx
0x004B711A | 48 8B 00 | mov     rax, [rax]
0x004B711D | 48 89 C7 | mov     rdi, rax
0x004B7120 | E8 63 FF FF FF | call    sub_4B7088
0x004B7125 | 90 | nop
0x004B7126 | 48 83 C4 28 | add     rsp, 28h
0x004B712A | 5B | pop     rbx
0x004B712B | 5D | pop     rbp
0x004B712C | C3 | retn
 ************ 
Source Code:
static void str2env(char *env[], int idx, const char *str)
{
	env[idx] = xasprintf("TAR_%s=%s", tar_var[idx], str);
	xputenv(env[idx]);
}
 ************ 
Parsed Output:
void setEnvironmentVariable(int index, char *value) {
    char **environmentArray = (char **)0x5229A0;
    char *key = environmentArray[index];
    char *envEntry;
    asprintf(&envEntry, "TAR_%s=%s", key, value);
    environmentArray[index] = envEntry;
    sub_4B7088(envEntry);
}
 ************ 
Similarity Score (Unixcoder): 0.6717510223388672
Func rank: 42

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: add_till_closing_bracket
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004832A5 | 55 | push    rbp
0x004832A6 | 48 89 E5 | mov     rbp, rsp
0x004832A9 | 48 83 EC 30 | sub     rsp, 30h
0x004832AD | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004832B1 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004832B5 | 89 55 DC | mov     [rbp+var_24], edx
0x004832B8 | 8B 45 DC | mov     eax, [rbp+var_24]
0x004832BB | 83 E0 80 | and     eax, 0FFFFFF80h
0x004832BE | 88 45 FF | mov     [rbp+var_1], al
0x004832C1 | 8B 45 DC | mov     eax, [rbp+var_24]
0x004832C4 | C1 E8 08 | shr     eax, 8
0x004832C7 | 88 45 FE | mov     [rbp+var_2], al
0x004832CA | 83 65 DC 7F | and     [rbp+var_24], 7Fh
0x004832CE | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004832D2 | 48 8B 40 18 | mov     rax, [rax+18h]
0x004832D6 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x004832DA | 48 89 D7 | mov     rdi, rdx
0x004832DD | FF D0 | call    rax
0x004832DF | 89 45 F8 | mov     [rbp+var_8], eax
0x004832E2 | 83 7D F8 FF | cmp     [rbp+var_8], 0FFFFFFFFh
0x004832E6 | 75 17 | jnz     short loc_4832FF
0x004832E8 | 8B 45 DC | mov     eax, [rbp+var_24]
0x004832EB | 0F BE C0 | movsx   eax, al
0x004832EE | 89 C7 | mov     edi, eax
0x004832F0 | E8 1E CC FF FF | call    sub_47FF13
0x004832F5 | B8 00 00 00 00 | mov     eax, 0
0x004832FA | E9 B9 01 00 00 | jmp     locret_4834B8
0x004832FF | 8B 45 F8 | mov     eax, [rbp+var_8]
0x00483302 | 39 45 DC | cmp     [rbp+var_24], eax
0x00483305 | 74 09 | jz      short loc_483310
0x00483307 | 0F BE 45 FE | movsx   eax, [rbp+var_2]
0x0048330B | 39 45 F8 | cmp     [rbp+var_8], eax
0x0048330E | 75 36 | jnz     short loc_483346
0x00483310 | 80 7D FF 00 | cmp     [rbp+var_1], 0
0x00483314 | 0F 84 9A 01 00 00 | jz      loc_4834B4
0x0048331A | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0048331E | 48 8B 40 20 | mov     rax, [rax+20h]
0x00483322 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00483326 | 48 89 D7 | mov     rdi, rdx
0x00483329 | FF D0 | call    rax
0x0048332B | 39 45 DC | cmp     [rbp+var_24], eax
0x0048332E | 75 16 | jnz     short loc_483346
0x00483330 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00483334 | 48 8B 40 18 | mov     rax, [rax+18h]
0x00483338 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x0048333C | 48 89 D7 | mov     rdi, rdx
0x0048333F | FF D0 | call    rax
0x00483341 | E9 6F 01 00 00 | jmp     loc_4834B5
0x00483346 | 8B 55 F8 | mov     edx, [rbp+var_8]
0x00483349 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0048334D | 89 D6 | mov     esi, edx
0x0048334F | 48 89 C7 | mov     rdi, rax
0x00483352 | E8 0C E1 FF FF | call    sub_481463
0x00483357 | 83 7D F8 28 | cmp     [rbp+var_8], 28h ; '('
0x0048335B | 74 06 | jz      short loc_483363
0x0048335D | 83 7D F8 7B | cmp     [rbp+var_8], 7Bh ; '{'
0x00483361 | 75 4F | jnz     short loc_4833B2
0x00483363 | 83 7D F8 28 | cmp     [rbp+var_8], 28h ; '('
0x00483367 | 75 07 | jnz     short loc_483370
0x00483369 | B8 29 00 00 00 | mov     eax, 29h ; ')'
0x0048336E | EB 05 | jmp     short loc_483375
0x00483370 | B8 7D 00 00 00 | mov     eax, 7Dh ; '}'
0x00483375 | 89 45 F8 | mov     [rbp+var_8], eax
0x00483378 | 8B 55 F8 | mov     edx, [rbp+var_8]
0x0048337B | 48 8B 4D E0 | mov     rcx, [rbp+var_20]
0x0048337F | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00483383 | 48 89 CE | mov     rsi, rcx
0x00483386 | 48 89 C7 | mov     rdi, rax
0x00483389 | E8 17 FF FF FF | call    sub_4832A5
0x0048338E | 85 C0 | test    eax, eax
0x00483390 | 75 0A | jnz     short loc_48339C
0x00483392 | B8 00 00 00 00 | mov     eax, 0
0x00483397 | E9 1C 01 00 00 | jmp     locret_4834B8
0x0048339C | 8B 55 F8 | mov     edx, [rbp+var_8]
0x0048339F | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004833A3 | 89 D6 | mov     esi, edx
0x004833A5 | 48 89 C7 | mov     rdi, rax
0x004833A8 | E8 B6 E0 FF FF | call    sub_481463
0x004833AD | E9 FD 00 00 00 | jmp     loc_4834AF
0x004833B2 | 83 7D F8 27 | cmp     [rbp+var_8], 27h ; '''
0x004833B6 | 75 37 | jnz     short loc_4833EF
0x004833B8 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x004833BC | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004833C0 | 48 89 D6 | mov     rsi, rdx
0x004833C3 | 48 89 C7 | mov     rdi, rax
0x004833C6 | E8 08 FD FF FF | call    sub_4830D3
0x004833CB | 85 C0 | test    eax, eax
0x004833CD | 75 0A | jnz     short loc_4833D9
0x004833CF | B8 00 00 00 00 | mov     eax, 0
0x004833D4 | E9 DF 00 00 00 | jmp     locret_4834B8
0x004833D9 | 8B 55 F8 | mov     edx, [rbp+var_8]
0x004833DC | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004833E0 | 89 D6 | mov     esi, edx
0x004833E2 | 48 89 C7 | mov     rdi, rax
0x004833E5 | E8 79 E0 FF FF | call    sub_481463
0x004833EA | E9 C0 00 00 00 | jmp     loc_4834AF
0x004833EF | 83 7D F8 22 | cmp     [rbp+var_8], 22h ; '"'
0x004833F3 | 75 37 | jnz     short loc_48342C
0x004833F5 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x004833F9 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004833FD | 48 89 D6 | mov     rsi, rdx
0x00483400 | 48 89 C7 | mov     rdi, rax
0x00483403 | E8 28 FD FF FF | call    sub_483130
0x00483408 | 85 C0 | test    eax, eax
0x0048340A | 75 0A | jnz     short loc_483416
0x0048340C | B8 00 00 00 00 | mov     eax, 0
0x00483411 | E9 A2 00 00 00 | jmp     locret_4834B8
0x00483416 | 8B 55 F8 | mov     edx, [rbp+var_8]
0x00483419 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0048341D | 89 D6 | mov     esi, edx
0x0048341F | 48 89 C7 | mov     rdi, rax
0x00483422 | E8 3C E0 FF FF | call    sub_481463
0x00483427 | E9 83 00 00 00 | jmp     loc_4834AF
0x0048342C | 83 7D F8 60 | cmp     [rbp+var_8], 60h ; '`'
0x00483430 | 75 36 | jnz     short loc_483468
0x00483432 | 48 8B 4D E0 | mov     rcx, [rbp+var_20]
0x00483436 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0048343A | BA 00 00 00 00 | mov     edx, 0
0x0048343F | 48 89 CE | mov     rsi, rcx
0x00483442 | 48 89 C7 | mov     rdi, rax
0x00483445 | E8 AF FD FF FF | call    sub_4831F9
0x0048344A | 85 C0 | test    eax, eax
0x0048344C | 75 07 | jnz     short loc_483455
0x0048344E | B8 00 00 00 00 | mov     eax, 0
0x00483453 | EB 63 | jmp     short locret_4834B8
0x00483455 | 8B 55 F8 | mov     edx, [rbp+var_8]
0x00483458 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0048345C | 89 D6 | mov     esi, edx
0x0048345E | 48 89 C7 | mov     rdi, rax
0x00483461 | E8 FD DF FF FF | call    sub_481463
0x00483466 | EB 47 | jmp     short loc_4834AF
0x00483468 | 83 7D F8 5C | cmp     [rbp+var_8], 5Ch ; '\'
0x0048346C | 0F 85 5C FE FF FF | jnz     loc_4832CE
0x00483472 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00483476 | 48 8B 40 18 | mov     rax, [rax+18h]
0x0048347A | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x0048347E | 48 89 D7 | mov     rdi, rdx
0x00483481 | FF D0 | call    rax
0x00483483 | 89 45 F8 | mov     [rbp+var_8], eax
0x00483486 | 83 7D F8 FF | cmp     [rbp+var_8], 0FFFFFFFFh
0x0048348A | 75 11 | jnz     short loc_48349D
0x0048348C | BF 29 00 00 00 | mov     edi, 29h ; ')'
0x00483491 | E8 7D CA FF FF | call    sub_47FF13
0x00483496 | B8 00 00 00 00 | mov     eax, 0
0x0048349B | EB 1B | jmp     short locret_4834B8
0x0048349D | 8B 55 F8 | mov     edx, [rbp+var_8]
0x004834A0 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004834A4 | 89 D6 | mov     esi, edx
0x004834A6 | 48 89 C7 | mov     rdi, rax
0x004834A9 | E8 B5 DF FF FF | call    sub_481463
0x004834AE | 90 | nop
0x004834AF | E9 1A FE FF FF | jmp     loc_4832CE
0x004834B4 | 90 | nop
0x004834B5 | 8B 45 F8 | mov     eax, [rbp+var_8]
0x004834B8 | C9 | leave
0x004834B9 | C3 | retn
 ************ 
Source Code:
define DOUBLE_CLOSE_CHAR_FLAG 0x80
static int add_till_closing_bracket(o_string *dest, struct in_str *input, unsigned end_ch)
{
	int ch;
	char dbl = end_ch & DOUBLE_CLOSE_CHAR_FLAG;
# if ENABLE_HUSH_BASH_COMPAT
	char end_char2 = end_ch >> 8;
# endif
	end_ch &= (DOUBLE_CLOSE_CHAR_FLAG - 1);

	while (1) {
		ch = i_getch(input);
		if (ch == EOF) {
			syntax_error_unterm_ch(end_ch);
			return 0;
		}
		if (ch == end_ch  IF_HUSH_BASH_COMPAT( || ch == end_char2)) {
			if (!dbl)
				break;
			/* we look for closing )) of $((EXPR)) */
			if (i_peek(input) == end_ch) {
				i_getch(input); /* eat second ')' */
				break;
			}
		}
		o_addchr(dest, ch);
		if (ch == '(' || ch == '{') {
			ch = (ch == '(' ? ')' : '}');
			if (!add_till_closing_bracket(dest, input, ch))
				return 0;
			o_addchr(dest, ch);
			continue;
		}
		if (ch == '\'') {
			if (!add_till_single_quote(dest, input))
				return 0;
			o_addchr(dest, ch);
			continue;
		}
		if (ch == '"') {
			if (!add_till_double_quote(dest, input))
				return 0;
			o_addchr(dest, ch);
			continue;
		}
		if (ch == '`') {
			if (!add_till_backquote(dest, input, /*in_dquote:*/ 0))
				return 0;
			o_addchr(dest, ch);
			continue;
		}
		if (ch == '\\') {
			/* \x. Copy verbatim. Important for  \(, \) */
			ch = i_getch(input);
			if (ch == EOF) {
				syntax_error_unterm_ch(')');
				return 0;
			}
			o_addchr(dest, ch);
			continue;
		}
	}
	return ch;
}
 ************ 
Parsed Output:
int processInput(void *inputStruct, char *buffer, int value) {
    int result = ((int (*)(char *, int))(*(void **)((char *)inputStruct + 24)))(buffer, value);
    if (result == -1) {
        value &= 0x7F;
        sub_47FF13(value);
        return 0;
    }
    if (result != (value & 0x7F)) {
        if (result == ((value >> 8) & 0xFF)) {
            if (((value >> 7) & 1) != 0) {
                result = ((int (*)(char *, int))(*(void **)((char *)inputStruct + 32)))(buffer, value);
                if (result != (value & 0x7F)) {
                    return 0;
                }
                ((void (*)(char *, int))(*(void **)((char *)inputStruct + 24)))(buffer, value);
                return 0;
            }
        } else {
            sub_481463(inputStruct, result);
            switch (result) {
                case '(':
                case '{':
                    result = (result == '(') ? ')' : '}';
                    buffer[result] = result;
                    return processInput(inputStruct, buffer, result);
                case '\'':
                    if (!sub_4830D3(inputStruct, buffer)) {
                        return 0;
                    }
                    sub_481463(inputStruct, result);
                    return 0;
                case '"':
                    if (!sub_483130(inputStruct, buffer)) {
                        return 0;
                    }
                    sub_481463(inputStruct, result);
                    return 0;
                case '`':
                    if (!sub_4831F9(inputStruct, buffer, 0)) {
                        return 0;
                    }
                    sub_481463(inputStruct, result);
                    return 0;
                case '\\':
                    result = ((int (*)(char *, int))(*(void **)((char *)inputStruct + 24)))(buffer, value);
                    if (result == -1) {
                        sub_47FF13(')');
                        return 0;
                    }
                    sub_481463(inputStruct, result);
                    return 0;
                default:
                    return 0;
            }
        }
    }
    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.6607023477554321
Func rank: 43

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: step_time
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0043BDFE | 55 | push    rbp
0x0043BDFF | 48 89 E5 | mov     rbp, rsp
0x0043BE02 | 48 83 C4 80 | add     rsp, 0FFFFFFFFFFFFFF80h
0x0043BE06 | F2 0F 11 45 88 | movsd   [rbp+var_78], xmm0
0x0043BE0B | 48 8D 45 D0 | lea     rax, [rbp+tv]
0x0043BE0F | BE 00 00 00 00 | mov     esi, 0; tz
0x0043BE14 | 48 89 C7 | mov     rdi, rax; tv
0x0043BE17 | E8 A4 AE FC FF | call    _gettimeofday
0x0043BE1C | 48 8B 45 D0 | mov     rax, [rbp+tv.tv_sec]
0x0043BE20 | F2 48 0F 2A C8 | cvtsi2sd xmm1, rax
0x0043BE25 | 48 8B 45 D8 | mov     rax, [rbp+tv.tv_usec]
0x0043BE29 | F2 48 0F 2A D0 | cvtsi2sd xmm2, rax
0x0043BE2E | F2 0F 10 05 E2 9E 0E 00 | movsd   xmm0, cs:qword_525D18
0x0043BE36 | F2 0F 59 C2 | mulsd   xmm0, xmm2
0x0043BE3A | F2 0F 58 C1 | addsd   xmm0, xmm1
0x0043BE3E | F2 0F 10 4D 88 | movsd   xmm1, [rbp+var_78]
0x0043BE43 | F2 0F 58 C1 | addsd   xmm0, xmm1
0x0043BE47 | F2 0F 11 45 F0 | movsd   [rbp+var_10], xmm0
0x0043BE4C | 48 8D 45 C0 | lea     rax, [rbp+var_40]
0x0043BE50 | F2 0F 10 45 F0 | movsd   xmm0, [rbp+var_10]
0x0043BE55 | 48 89 C7 | mov     rdi, rax
0x0043BE58 | E8 D6 F3 FF FF | call    sub_43B233
0x0043BE5D | 48 8D 45 C0 | lea     rax, [rbp+var_40]
0x0043BE61 | BE 00 00 00 00 | mov     esi, 0; tz
0x0043BE66 | 48 89 C7 | mov     rdi, rax; tv
0x0043BE69 | E8 12 B4 FC FF | call    _settimeofday
0x0043BE6E | 83 F8 FF | cmp     eax, 0FFFFFFFFh
0x0043BE71 | 75 0F | jnz     short loc_43BE82
0x0043BE73 | BF A5 5A 52 00 | mov     edi, offset aSettimeofday_0; "settimeofday"
0x0043BE78 | B8 00 00 00 00 | mov     eax, 0
0x0043BE7D | E8 20 D4 FC FF | call    sub_4092A2
0x0043BE82 | 48 8B 05 7F 15 32 00 | mov     rax, cs:qword_75D408
0x0043BE89 | 8B 40 3C | mov     eax, [rax+3Ch]
0x0043BE8C | 83 F8 01 | cmp     eax, 1
0x0043BE8F | 76 4C | jbe     short loc_43BEDD
0x0043BE91 | 48 8B 45 D0 | mov     rax, [rbp+tv.tv_sec]
0x0043BE95 | 48 89 45 98 | mov     [rbp+timer], rax
0x0043BE99 | 48 8D 45 98 | lea     rax, [rbp+timer]
0x0043BE9D | 48 89 C7 | mov     rdi, rax; timer
0x0043BEA0 | E8 3B A8 FC FF | call    _localtime
0x0043BEA5 | 48 89 C2 | mov     rdx, rax
0x0043BEA8 | 48 8D 45 A0 | lea     rax, [rbp+s]
0x0043BEAC | 48 89 D1 | mov     rcx, rdx; tp
0x0043BEAF | BA B2 5A 52 00 | mov     edx, offset aYMDHMS; "%Y-%m-%d %H:%M:%S"
0x0043BEB4 | BE 18 00 00 00 | mov     esi, 18h; maxsize
0x0043BEB9 | 48 89 C7 | mov     rdi, rax; s
0x0043BEBC | E8 1F B8 FC FF | call    _strftime
0x0043BEC1 | 48 8B 45 D8 | mov     rax, [rbp+tv.tv_usec]
0x0043BEC5 | 89 C2 | mov     edx, eax
0x0043BEC7 | 48 8D 45 A0 | lea     rax, [rbp+s]
0x0043BECB | 48 89 C6 | mov     rsi, rax
0x0043BECE | BF C4 5A 52 00 | mov     edi, offset aCurrentTimeIsS; "current time is %s.%06u"
0x0043BED3 | B8 00 00 00 00 | mov     eax, 0
0x0043BED8 | E8 6A D8 FC FF | call    sub_409747
0x0043BEDD | 48 8B 45 C0 | mov     rax, [rbp+var_40.tv_sec]
0x0043BEE1 | 48 89 45 98 | mov     [rbp+timer], rax
0x0043BEE5 | 48 8D 45 98 | lea     rax, [rbp+timer]
0x0043BEE9 | 48 89 C7 | mov     rdi, rax; timer
0x0043BEEC | E8 EF A7 FC FF | call    _localtime
0x0043BEF1 | 48 89 C2 | mov     rdx, rax
0x0043BEF4 | 48 8D 45 A0 | lea     rax, [rbp+s]
0x0043BEF8 | 48 89 D1 | mov     rcx, rdx; tp
0x0043BEFB | BA B2 5A 52 00 | mov     edx, offset aYMDHMS; "%Y-%m-%d %H:%M:%S"
0x0043BF00 | BE 18 00 00 00 | mov     esi, 18h; maxsize
0x0043BF05 | 48 89 C7 | mov     rdi, rax; s
0x0043BF08 | E8 D3 B7 FC FF | call    _strftime
0x0043BF0D | 48 8B 45 C8 | mov     rax, [rbp+var_40.tv_usec]
0x0043BF11 | 89 C2 | mov     edx, eax
0x0043BF13 | F2 0F 10 45 88 | movsd   xmm0, [rbp+var_78]
0x0043BF18 | 48 8D 45 A0 | lea     rax, [rbp+s]
0x0043BF1C | 48 89 C6 | mov     rsi, rax
0x0043BF1F | BF E0 5A 52 00 | mov     edi, offset aSettingTimeToS; "setting time to %s.%06u (offset %+fs)"
0x0043BF24 | B8 01 00 00 00 | mov     eax, 1
0x0043BF29 | E8 19 D8 FC FF | call    sub_409747
0x0043BF2E | 48 8B 05 D3 14 32 00 | mov     rax, cs:qword_75D408
0x0043BF35 | F2 0F 10 00 | movsd   xmm0, qword ptr [rax]
0x0043BF39 | 48 8B 05 C8 14 32 00 | mov     rax, cs:qword_75D408
0x0043BF40 | F2 0F 58 45 88 | addsd   xmm0, [rbp+var_78]
0x0043BF45 | F2 0F 11 00 | movsd   qword ptr [rax], xmm0
0x0043BF49 | 48 8B 05 B8 14 32 00 | mov     rax, cs:qword_75D408
0x0043BF50 | F2 0F 10 40 70 | movsd   xmm0, qword ptr [rax+70h]
0x0043BF55 | 48 8B 05 AC 14 32 00 | mov     rax, cs:qword_75D408
0x0043BF5C | F2 0F 58 45 88 | addsd   xmm0, [rbp+var_78]
0x0043BF61 | F2 0F 11 40 70 | movsd   qword ptr [rax+70h], xmm0
0x0043BF66 | 48 8B 05 9B 14 32 00 | mov     rax, cs:qword_75D408
0x0043BF6D | F2 0F 10 40 20 | movsd   xmm0, qword ptr [rax+20h]
0x0043BF72 | 48 8B 05 8F 14 32 00 | mov     rax, cs:qword_75D408
0x0043BF79 | F2 0F 58 45 88 | addsd   xmm0, [rbp+var_78]
0x0043BF7E | F2 0F 11 40 20 | movsd   qword ptr [rax+20h], xmm0
0x0043BF83 | 48 8B 05 7E 14 32 00 | mov     rax, cs:qword_75D408
0x0043BF8A | 48 8B 40 30 | mov     rax, [rax+30h]
0x0043BF8E | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0043BF92 | EB 74 | jmp     short loc_43C008
0x0043BF94 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043BF98 | 48 8B 40 08 | mov     rax, [rax+8]
0x0043BF9C | 48 89 45 E8 | mov     [rbp+var_18], rax
0x0043BFA0 | F2 0F 10 45 88 | movsd   xmm0, [rbp+var_78]
0x0043BFA5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043BFA9 | 48 89 C7 | mov     rdi, rax
0x0043BFAC | E8 9B F7 FF FF | call    sub_43B74C
0x0043BFB1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043BFB5 | F2 0F 10 40 20 | movsd   xmm0, qword ptr [rax+20h]
0x0043BFBA | F2 0F 58 45 88 | addsd   xmm0, [rbp+var_78]
0x0043BFBF | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043BFC3 | F2 0F 11 40 20 | movsd   qword ptr [rax+20h], xmm0
0x0043BFC8 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043BFCC | 8B 40 10 | mov     eax, [rax+10h]
0x0043BFCF | 85 C0 | test    eax, eax
0x0043BFD1 | 78 2A | js      short loc_43BFFD
0x0043BFD3 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043BFD7 | 8B 40 10 | mov     eax, [rax+10h]
0x0043BFDA | 89 C7 | mov     edi, eax; fd
0x0043BFDC | E8 2F AE FC FF | call    _close
0x0043BFE1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043BFE5 | C7 40 10 FF FF FF FF | mov     dword ptr [rax+10h], 0FFFFFFFFh
0x0043BFEC | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043BFF0 | BE 05 00 00 00 | mov     esi, 5
0x0043BFF5 | 48 89 C7 | mov     rdi, rax
0x0043BFF8 | E8 37 F5 FF FF | call    sub_43B534
0x0043BFFD | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043C001 | 48 8B 00 | mov     rax, [rax]
0x0043C004 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0043C008 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0043C00D | 75 85 | jnz     short loc_43BF94
0x0043C00F | 90 | nop
0x0043C010 | C9 | leave
0x0043C011 | C3 | retn
 ************ 
Source Code:
static NOINLINE void
step_time(double offset)
{
	llist_t *item;
	double dtime;
	struct timeval tvc, tvn;
	char buf[sizeof("yyyy-mm-dd hh:mm:ss") + /*paranoia:*/ 4];
	time_t tval;

	gettimeofday(&tvc, NULL); /* never fails */
	dtime = tvc.tv_sec + (1.0e-6 * tvc.tv_usec) + offset;
	d_to_tv(dtime, &tvn);
	if (settimeofday(&tvn, NULL) == -1)
		bb_perror_msg_and_die("settimeofday");

	VERB2 {
		tval = tvc.tv_sec;
		strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", localtime(&tval));
		bb_error_msg("current time is %s.%06u", buf, (unsigned)tvc.tv_usec);
	}
	tval = tvn.tv_sec;
	strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", localtime(&tval));
	bb_error_msg("setting time to %s.%06u (offset %+fs)", buf, (unsigned)tvn.tv_usec, offset);

	/* Correct various fields which contain time-relative values: */

	/* Globals: */
	G.cur_time += offset;
	G.last_update_recv_time += offset;
	G.last_script_run += offset;

	/* p->lastpkt_recv_time, p->next_action_time and such: */
	for (item = G.ntp_peers; item != NULL; item = item->link) {
		peer_t *pp = (peer_t *) item->data;
		reset_peer_stats(pp, offset);
		//bb_error_msg("offset:%+f pp->next_action_time:%f -> %f",
		//	offset, pp->next_action_time, pp->next_action_time + offset);
		pp->next_action_time += offset;
		if (pp->p_fd >= 0) {
			/* We wait for reply from this peer too.
			 * But due to step we are doing, reply's data is no longer
			 * useful (in fact, it'll be bogus). Stop waiting for it.
			 */
			close(pp->p_fd);
			pp->p_fd = -1;
			set_next(pp, RETRY_INTERVAL);
		}
	}
}
 ************ 
Parsed Output:
#include <sys/time.h>
#include <time.h>

void updateSystemTime(double offset) {
    struct timeval tv;
    double currentTime, newTime;
    char s[24];
    struct tm *tp;
    unsigned int microseconds;

    // Store the incoming offset
    double initialOffset = offset;

    // Get the current time
    gettimeofday(&tv, NULL);
    currentTime = (double)tv.tv_sec + (double)tv.tv_usec * 1e-6;

    // Add the offset to the current time
    newTime = currentTime + offset;

    // Set the new system time
    tv.tv_sec = (time_t)newTime;
    tv.tv_usec = (suseconds_t)((newTime - (double)tv.tv_sec) * 1e6);
    if (settimeofday(&tv, NULL) != 0) {
        perror("settimeofday");
    }

    // Check if we need to print the time
    if (someGlobalVariable > 1) {
        // Convert the time to a string and print it
        tp = localtime(&tv.tv_sec);
        strftime(s, sizeof(s), "%Y-%m-%d %H:%M:%S", tp);
        microseconds = tv.tv_usec;
        printf("current time is %s.%06u
", s, microseconds);

        // Print the setting time message
        printf("setting time to %s.%06u (offset %+fs)
", s, microseconds, initialOffset);
    }

    // Update some global variables with the offset
    someGlobalVariable += offset;
    someGlobalVariable2 += offset;
    someGlobalVariable3 += offset;

    // Iterate through a linked list and update each node
    for (struct Node *node = someGlobalLinkedList; node != NULL; node = node->next) {
        node->someTimeValue += offset;
        if (node->someFlag < 0) {
            continue;
        }
        if (node->fileDescriptor >= 0) {
            close(node->fileDescriptor);
            node->fileDescriptor = -1;
        }
        someFunction(node, 5);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.6602673530578613
Func rank: 44

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: do_load
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004C3C8E | 55 | push    rbp
0x004C3C8F | 48 89 E5 | mov     rbp, rsp
0x004C3C92 | 48 83 EC 50 | sub     rsp, 50h
0x004C3C96 | 89 7D CC | mov     [rbp+var_34], edi
0x004C3C99 | 48 89 75 C0 | mov     [rbp+var_40], rsi
0x004C3C9D | 48 89 55 B8 | mov     [rbp+var_48], rdx
0x004C3CA1 | C7 45 F8 08 00 00 00 | mov     [rbp+var_8], 8
0x004C3CA8 | C7 45 F0 00 01 00 00 | mov     [rbp+var_10], 100h
0x004C3CAF | C7 45 EC 00 00 00 00 | mov     [rbp+var_14], 0
0x004C3CB6 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3CBA | 48 89 45 E0 | mov     [rbp+var_20], rax
0x004C3CBE | 48 83 7D B8 03 | cmp     [rbp+var_48], 3
0x004C3CC3 | 0F 86 82 00 00 00 | jbe     loc_4C3D4B
0x004C3CC9 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3CCD | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004C3CD0 | 3C 36 | cmp     al, 36h ; '6'
0x004C3CD2 | 75 77 | jnz     short loc_4C3D4B
0x004C3CD4 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3CD8 | 0F B6 40 01 | movzx   eax, byte ptr [rax+1]
0x004C3CDC | 3C 04 | cmp     al, 4
0x004C3CDE | 75 6B | jnz     short loc_4C3D4B
0x004C3CE0 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3CE4 | 0F B6 40 02 | movzx   eax, byte ptr [rax+2]
0x004C3CE8 | 3C 05 | cmp     al, 5
0x004C3CEA | 76 0F | jbe     short loc_4C3CFB
0x004C3CEC | BF D3 1A 53 00 | mov     edi, offset aUnsupportedPsf; "unsupported psf file mode"
0x004C3CF1 | B8 00 00 00 00 | mov     eax, 0
0x004C3CF6 | E8 A3 59 F4 FF | call    sub_40969E
0x004C3CFB | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3CFF | 0F B6 40 02 | movzx   eax, byte ptr [rax+2]
0x004C3D03 | 0F B6 C0 | movzx   eax, al
0x004C3D06 | 83 E0 01 | and     eax, 1
0x004C3D09 | 85 C0 | test    eax, eax
0x004C3D0B | 74 07 | jz      short loc_4C3D14
0x004C3D0D | C7 45 F0 00 02 00 00 | mov     [rbp+var_10], 200h
0x004C3D14 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3D18 | 0F B6 40 02 | movzx   eax, byte ptr [rax+2]
0x004C3D1C | 0F B6 C0 | movzx   eax, al
0x004C3D1F | 83 E0 02 | and     eax, 2
0x004C3D22 | 85 C0 | test    eax, eax
0x004C3D24 | 74 07 | jz      short loc_4C3D2D
0x004C3D26 | C7 45 EC 01 00 00 00 | mov     [rbp+var_14], 1
0x004C3D2D | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3D31 | 0F B6 40 03 | movzx   eax, byte ptr [rax+3]
0x004C3D35 | 0F B6 C0 | movzx   eax, al
0x004C3D38 | 89 45 F4 | mov     [rbp+var_C], eax
0x004C3D3B | 8B 45 F4 | mov     eax, [rbp+var_C]
0x004C3D3E | 89 45 FC | mov     [rbp+var_4], eax
0x004C3D41 | 48 83 45 E0 04 | add     [rbp+var_20], 4
0x004C3D46 | E9 F0 00 00 00 | jmp     loc_4C3E3B
0x004C3D4B | 48 83 7D B8 1F | cmp     [rbp+var_48], 1Fh
0x004C3D50 | 0F 86 99 00 00 00 | jbe     loc_4C3DEF
0x004C3D56 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3D5A | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004C3D5D | 3C 72 | cmp     al, 72h ; 'r'
0x004C3D5F | 0F 85 8A 00 00 00 | jnz     loc_4C3DEF
0x004C3D65 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3D69 | 0F B6 40 01 | movzx   eax, byte ptr [rax+1]
0x004C3D6D | 3C B5 | cmp     al, 0B5h
0x004C3D6F | 75 7E | jnz     short loc_4C3DEF
0x004C3D71 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3D75 | 0F B6 40 02 | movzx   eax, byte ptr [rax+2]
0x004C3D79 | 3C 4A | cmp     al, 4Ah ; 'J'
0x004C3D7B | 75 72 | jnz     short loc_4C3DEF
0x004C3D7D | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3D81 | 0F B6 40 03 | movzx   eax, byte ptr [rax+3]
0x004C3D85 | 3C 86 | cmp     al, 86h
0x004C3D87 | 75 66 | jnz     short loc_4C3DEF
0x004C3D89 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3D8D | 8B 40 04 | mov     eax, [rax+4]
0x004C3D90 | 85 C0 | test    eax, eax
0x004C3D92 | 74 0F | jz      short loc_4C3DA3
0x004C3D94 | BF ED 1A 53 00 | mov     edi, offset aUnsupportedPsf_0; "unsupported psf file version"
0x004C3D99 | B8 00 00 00 00 | mov     eax, 0
0x004C3D9E | E8 FB 58 F4 FF | call    sub_40969E
0x004C3DA3 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3DA7 | 8B 40 10 | mov     eax, [rax+10h]
0x004C3DAA | 89 45 F0 | mov     [rbp+var_10], eax
0x004C3DAD | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3DB1 | 8B 40 0C | mov     eax, [rax+0Ch]
0x004C3DB4 | 83 E0 01 | and     eax, 1
0x004C3DB7 | 85 C0 | test    eax, eax
0x004C3DB9 | 74 07 | jz      short loc_4C3DC2
0x004C3DBB | C7 45 EC 02 00 00 00 | mov     [rbp+var_14], 2
0x004C3DC2 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3DC6 | 8B 40 14 | mov     eax, [rax+14h]
0x004C3DC9 | 89 45 F4 | mov     [rbp+var_C], eax
0x004C3DCC | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3DD0 | 8B 40 18 | mov     eax, [rax+18h]
0x004C3DD3 | 89 45 FC | mov     [rbp+var_4], eax
0x004C3DD6 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3DDA | 8B 40 1C | mov     eax, [rax+1Ch]
0x004C3DDD | 89 45 F8 | mov     [rbp+var_8], eax
0x004C3DE0 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3DE4 | 8B 40 08 | mov     eax, [rax+8]
0x004C3DE7 | 89 C0 | mov     eax, eax
0x004C3DE9 | 48 01 45 E0 | add     [rbp+var_20], rax
0x004C3DED | EB 4C | jmp     short loc_4C3E3B
0x004C3DEF | 48 81 7D B8 34 26 00 00 | cmp     [rbp+var_48], 2634h
0x004C3DF7 | 75 14 | jnz     short loc_4C3E0D
0x004C3DF9 | C7 45 FC 10 00 00 00 | mov     [rbp+var_4], 10h
0x004C3E00 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004C3E03 | 89 45 F4 | mov     [rbp+var_C], eax
0x004C3E06 | 48 83 45 E0 28 | add     [rbp+var_20], 28h ; '('
0x004C3E0B | EB 2E | jmp     short loc_4C3E3B
0x004C3E0D | 48 8B 45 B8 | mov     rax, [rbp+var_48]
0x004C3E11 | 0F B6 C0 | movzx   eax, al
0x004C3E14 | 48 85 C0 | test    rax, rax
0x004C3E17 | 75 13 | jnz     short loc_4C3E2C
0x004C3E19 | 48 8B 45 B8 | mov     rax, [rbp+var_48]
0x004C3E1D | 48 C1 E8 08 | shr     rax, 8
0x004C3E21 | 89 45 FC | mov     [rbp+var_4], eax
0x004C3E24 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004C3E27 | 89 45 F4 | mov     [rbp+var_C], eax
0x004C3E2A | EB 0F | jmp     short loc_4C3E3B
0x004C3E2C | BF 10 1B 53 00 | mov     edi, offset aInputFileBadLe; "input file: bad length or unsupported f"...
0x004C3E31 | B8 00 00 00 00 | mov     eax, 0
0x004C3E36 | E8 63 58 F4 FF | call    sub_40969E
0x004C3E3B | 8B 45 F0 | mov     eax, [rbp+var_10]
0x004C3E3E | 0F AF 45 F4 | imul    eax, [rbp+var_C]
0x004C3E42 | 48 63 D0 | movsxd  rdx, eax
0x004C3E45 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004C3E49 | 48 01 D0 | add     rax, rdx
0x004C3E4C | 48 89 45 D8 | mov     [rbp+var_28], rax
0x004C3E50 | 48 8B 45 B8 | mov     rax, [rbp+var_48]
0x004C3E54 | 48 01 45 C0 | add     [rbp+var_40], rax
0x004C3E58 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004C3E5C | 48 3B 45 C0 | cmp     rax, [rbp+var_40]
0x004C3E60 | 77 10 | ja      short loc_4C3E72
0x004C3E62 | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x004C3E66 | 75 19 | jnz     short loc_4C3E81
0x004C3E68 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004C3E6C | 48 3B 45 C0 | cmp     rax, [rbp+var_40]
0x004C3E70 | 74 0F | jz      short loc_4C3E81
0x004C3E72 | BF 40 1B 53 00 | mov     edi, offset aInputFileBadLe_0; "input file: bad length"
0x004C3E77 | B8 00 00 00 00 | mov     eax, 0
0x004C3E7C | E8 1D 58 F4 FF | call    sub_40969E
0x004C3E81 | 44 8B 45 F0 | mov     r8d, [rbp+var_10]
0x004C3E85 | 8B 7D F4 | mov     edi, [rbp+var_C]
0x004C3E88 | 8B 4D F8 | mov     ecx, [rbp+var_8]
0x004C3E8B | 8B 55 FC | mov     edx, [rbp+var_4]
0x004C3E8E | 48 8B 75 E0 | mov     rsi, [rbp+var_20]
0x004C3E92 | 8B 45 CC | mov     eax, [rbp+var_34]
0x004C3E95 | 45 89 C1 | mov     r9d, r8d
0x004C3E98 | 41 89 F8 | mov     r8d, edi
0x004C3E9B | 89 C7 | mov     edi, eax
0x004C3E9D | E8 7E FA FF FF | call    sub_4C3920
0x004C3EA2 | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x004C3EA6 | 74 28 | jz      short loc_4C3ED0
0x004C3EA8 | 8B 45 EC | mov     eax, [rbp+var_14]
0x004C3EAB | 8D 48 FF | lea     ecx, [rax-1]
0x004C3EAE | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004C3EB2 | 48 2B 45 D8 | sub     rax, [rbp+var_28]
0x004C3EB6 | 89 C7 | mov     edi, eax
0x004C3EB8 | 8B 55 F0 | mov     edx, [rbp+var_10]
0x004C3EBB | 48 8B 75 D8 | mov     rsi, [rbp+var_28]
0x004C3EBF | 8B 45 CC | mov     eax, [rbp+var_34]
0x004C3EC2 | 41 89 C8 | mov     r8d, ecx
0x004C3EC5 | 89 D1 | mov     ecx, edx
0x004C3EC7 | 89 FA | mov     edx, edi
0x004C3EC9 | 89 C7 | mov     edi, eax
0x004C3ECB | E8 6C FB FF FF | call    sub_4C3A3C
0x004C3ED0 | 90 | nop
0x004C3ED1 | C9 | leave
0x004C3ED2 | C3 | retn
 ************ 
Source Code:
static void do_load(int fd, unsigned char *buffer, size_t len)
{
	int height;
	int width = 8;
	int charsize;
	int fontsize = 256;
	int has_table = 0;
	unsigned char *font = buffer;
	unsigned char *table;

	if (len >= sizeof(struct psf1_header) && PSF1_MAGIC_OK(psf1h(buffer))) {
		if (psf1h(buffer)->mode > PSF1_MAXMODE)
			bb_error_msg_and_die("unsupported psf file mode");
		if (psf1h(buffer)->mode & PSF1_MODE512)
			fontsize = 512;
		if (psf1h(buffer)->mode & PSF1_MODEHASTAB)
			has_table = 1;
		height = charsize = psf1h(buffer)->charsize;
		font += sizeof(struct psf1_header);
	} else
#if ENABLE_FEATURE_LOADFONT_PSF2
	if (len >= sizeof(struct psf2_header) && PSF2_MAGIC_OK(psf2h(buffer))) {
		if (psf2h(buffer)->version > PSF2_MAXVERSION)
			bb_error_msg_and_die("unsupported psf file version");
		fontsize = psf2h(buffer)->length;
		if (psf2h(buffer)->flags & PSF2_HAS_UNICODE_TABLE)
			has_table = 2;
		charsize = psf2h(buffer)->charsize;
		height = psf2h(buffer)->height;
		width = psf2h(buffer)->width;
		font += psf2h(buffer)->headersize;
	} else
#endif
#if ENABLE_FEATURE_LOADFONT_RAW
	if (len == 9780) {  /* file with three code pages? */
		charsize = height = 16;
		font += 40;
	} else if ((len & 0377) == 0) {  /* bare font */
		charsize = height = len / 256;
	} else
#endif
	{
		bb_error_msg_and_die("input file: bad length or unsupported font type");
	}

#if !defined(PIO_FONTX) || defined(__sparc__)
	if (fontsize != 256)
		bb_error_msg_and_die("only fontsize 256 supported");
#endif

	table = font + fontsize * charsize;
	buffer += len;

	if (table > buffer || (!has_table && table != buffer))
		bb_error_msg_and_die("input file: bad length");

	do_loadfont(fd, font, height, width, charsize, fontsize);

	if (has_table)
		do_loadtable(fd, table, buffer - table, fontsize, has_table - 1);
}
 ************ 
Parsed Output:
int processFileHeader(int fileDescriptor, char *fileBuffer, unsigned int fileSize) {
    int mode = 0x100;
    int flags = 0;
    char *bufferPtr = fileBuffer;
    int version = 8;
    
    if (fileSize > 3) {
        if (fileBuffer[0] == '6' && fileBuffer[1] == 4 && (fileBuffer[2] & 0xFE) == 4) {
            if (fileBuffer[2] & 1) {
                mode = 0x200;
            }
            if (fileBuffer[2] & 2) {
                flags = 1;
            }
            version = fileBuffer[3];
            bufferPtr += 4;
        } else if (fileSize > 0x1F) {
            if (fileBuffer[0] == 'r' && fileBuffer[1] == 0xB5 && fileBuffer[2] == 'J' && fileBuffer[3] == 0x86) {
                if (*(int *)(fileBuffer + 4) != 0) {
                    unsupportedPsfFileVersion();
                }
                mode = *(int *)(fileBuffer + 0x10);
                if (*(int *)(fileBuffer + 0xC) & 1) {
                    flags = 2;
                }
                version = *(int *)(fileBuffer + 0x14);
                fileSize = *(int *)(fileBuffer + 0x18);
                bufferPtr += *(int *)(fileBuffer + 0x1C) + 8;
            } else if (fileSize == 0x2634) {
                version = 0x10;
                bufferPtr += 0x28;
            } else if (fileSize == 0 || (fileSize >> 8) == 0) {
                version = fileSize >> 8;
                bufferPtr += fileSize & 0xFF;
            } else {
                inputFileBadLengthOrUnsupportedFormat();
            }
        } else {
            inputFileBadLengthOrUnsupportedFormat();
        }
    } else {
        inputFileBadLengthOrUnsupportedFormat();
    }
    
    char *endPtr = fileBuffer + fileSize;
    if (bufferPtr <= endPtr) {
        if (flags == 0 && bufferPtr != endPtr) {
            inputFileBadLength();
        }
    } else {
        inputFileBadLength();
    }
    
    processFileData(fileDescriptor, version, fileSize, mode, bufferPtr);
    
    if (flags != 0) {
        int remainingSize = fileBuffer + fileSize - bufferPtr;
        processRemainingFileData(fileDescriptor, remainingSize, mode, bufferPtr, flags - 1);
    }
    
    return 0;
}

void unsupportedPsfFileVersion() {
    // This function handles the unsupported PSF file version error.
    // The actual implementation is not provided in the assembly.
}

void inputFileBadLengthOrUnsupportedFormat() {
    // This function handles the bad length or unsupported format error.
    // The actual implementation is not provided in the assembly.
}

void inputFileBadLength() {
    // This function handles the bad length error.
    // The actual implementation is not provided in the assembly.
}

void processFileData(int fileDescriptor, int version, int fileSize, int mode, char *bufferPtr) {
    // This function processes the main file data.
    // The actual implementation is not provided in the assembly.
}

void processRemainingFileData(int fileDescriptor, int remainingSize, int mode, char *bufferPtr, int flags) {
    // This function processes the remaining file data.
    // The actual implementation is not provided in the assembly.
}
 ************ 
Similarity Score (Unixcoder): 0.6547409296035767
Func rank: 45

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: llist_find_str
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00409191 | 55 | push    rbp
0x00409192 | 48 89 E5 | mov     rbp, rsp
0x00409195 | 48 83 EC 10 | sub     rsp, 10h
0x00409199 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x0040919D | 48 89 75 F0 | mov     [rbp+s2], rsi
0x004091A1 | EB 26 | jmp     short loc_4091C9
0x004091A3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004091A7 | 48 8B 40 08 | mov     rax, [rax+8]
0x004091AB | 48 8B 55 F0 | mov     rdx, [rbp+s2]
0x004091AF | 48 89 D6 | mov     rsi, rdx; s2
0x004091B2 | 48 89 C7 | mov     rdi, rax; s1
0x004091B5 | E8 96 DE FF FF | call    _strcmp
0x004091BA | 85 C0 | test    eax, eax
0x004091BC | 74 14 | jz      short loc_4091D2
0x004091BE | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004091C2 | 48 8B 00 | mov     rax, [rax]
0x004091C5 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004091C9 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004091CE | 75 D3 | jnz     short loc_4091A3
0x004091D0 | EB 01 | jmp     short loc_4091D3
0x004091D2 | 90 | nop
0x004091D3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004091D7 | C9 | leave
0x004091D8 | C3 | retn
 ************ 
Source Code:
FAST_FUNC llist_find_str(llist_t *list, const char *str)
{
	while (list) {
		if (strcmp(list->data, str) == 0)
			break;
		list = list->link;
	}
	return list;
}
 ************ 
Parsed Output:
char *find_matching_string(char *s1, char *s2) {
    while (s1) {
        if (strcmp(s1 + 8, s2) == 0) {
            return s1;
        }
        s1 = *(char **)s1;
    }
    return NULL;
}
 ************ 
Similarity Score (Unixcoder): 0.6506023406982422
Func rank: 46

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: detect_link_iff
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0043082B | 55 | push    rbp
0x0043082C | 48 89 E5 | mov     rbp, rsp
0x0043082F | 48 83 EC 30 | sub     rsp, 30h
0x00430833 | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00430837 | 48 89 C7 | mov     rdi, rax
0x0043083A | E8 F8 FD FF FF | call    sub_430637
0x0043083F | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00430843 | BA 50 85 51 00 | mov     edx, offset aSiocgifflags_1; "SIOCGIFFLAGS"
0x00430848 | 48 89 C6 | mov     rsi, rax
0x0043084B | BF 13 89 00 00 | mov     edi, 8913h
0x00430850 | E8 21 FE FF FF | call    sub_430676
0x00430855 | 85 C0 | test    eax, eax
0x00430857 | 79 07 | jns     short loc_430860
0x00430859 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x0043085E | EB 31 | jmp     short locret_430891
0x00430860 | 0F B7 45 E0 | movzx   eax, [rbp+var_20]
0x00430864 | 98 | cwde
0x00430865 | 83 E0 01 | and     eax, 1
0x00430868 | 85 C0 | test    eax, eax
0x0043086A | 75 1A | jnz     short loc_430886
0x0043086C | 48 8B 05 95 CB 32 00 | mov     rax, cs:qword_75D408
0x00430873 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00430876 | 3C FF | cmp     al, 0FFh
0x00430878 | 74 0C | jz      short loc_430886
0x0043087A | 48 8B 05 87 CB 32 00 | mov     rax, cs:qword_75D408
0x00430881 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00430884 | EB 0B | jmp     short locret_430891
0x00430886 | 0F B7 45 E0 | movzx   eax, [rbp+var_20]
0x0043088A | 98 | cwde
0x0043088B | C1 F8 06 | sar     eax, 6
0x0043088E | 83 E0 01 | and     eax, 1
0x00430891 | C9 | leave
0x00430892 | C3 | retn
 ************ 
Source Code:
static smallint detect_link_iff(void)
{
	struct ifreq ifreq;

	set_ifreq_to_ifname(&ifreq);

	if (network_ioctl(SIOCGIFFLAGS, &ifreq, "SIOCGIFFLAGS") < 0) {
		return IFSTATUS_ERR;
	}

	/* If IFF_UP is not set (interface is down), IFF_RUNNING is never set
	 * regardless of link status. Simply continue to report last status -
	 * no point in reporting spurious link downs if interface is disabled
	 * by admin. When/if it will be brought up,
	 * we'll report real link status.
	 */
	if (!(ifreq.ifr_flags & IFF_UP) && G.iface_last_status != IFSTATUS_ERR)
		return G.iface_last_status;

	return (ifreq.ifr_flags & IFF_RUNNING) ? IFSTATUS_UP : IFSTATUS_DOWN;
}
 ************ 
Parsed Output:
int checkInterfaceFlags() {
    int interfaceFlags;
    int result = getInterfaceFlags(&interfaceFlags);
    if (result < 0) {
        return -1;
    }

    if (!(interfaceFlags & 1)) {
        if (*globalFlag == 0xFF) {
            return 1;
        }
        return *globalFlag;
    }

    return (interfaceFlags >> 6) & 1;
}
 ************ 
Similarity Score (Unixcoder): 0.6499181985855103
Func rank: 47

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: copy_parsing_escapes
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004E8B82 | 55 | push    rbp
0x004E8B83 | 48 89 E5 | mov     rbp, rsp
0x004E8B86 | 48 83 EC 20 | sub     rsp, 20h
0x004E8B8A | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004E8B8E | 89 75 E4 | mov     [rbp+var_1C], esi
0x004E8B91 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004E8B94 | 83 C0 01 | add     eax, 1
0x004E8B97 | 48 98 | cdqe
0x004E8B99 | 48 89 C7 | mov     rdi, rax
0x004E8B9C | E8 BE 14 F2 FF | call    sub_40A05F
0x004E8BA1 | 48 89 45 F0 | mov     [rbp+s], rax
0x004E8BA5 | 48 C7 45 F8 37 6E 52 00 | mov     [rbp+var_8], offset aNTR; "\nn\tt\rr"
0x004E8BAD | EB 4A | jmp     short loc_4E8BF9
0x004E8BAF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E8BB3 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004E8BB6 | 0F BE F8 | movsx   edi, al
0x004E8BB9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E8BBD | 48 83 C0 01 | add     rax, 1
0x004E8BC1 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004E8BC4 | 0F BE C8 | movsx   ecx, al
0x004E8BC7 | 8B 55 E4 | mov     edx, [rbp+var_1C]
0x004E8BCA | 48 8B 75 E8 | mov     rsi, [rbp+var_18]
0x004E8BCE | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004E8BD2 | 41 89 F8 | mov     r8d, edi
0x004E8BD5 | 48 89 C7 | mov     rdi, rax
0x004E8BD8 | E8 B8 FE FF FF | call    sub_4E8A95
0x004E8BDD | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004E8BE1 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x004E8BE5 | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004E8BE9 | 48 89 C7 | mov     rdi, rax; s
0x004E8BEC | E8 DF DE F1 FF | call    _strlen
0x004E8BF1 | 89 45 E4 | mov     [rbp+var_1C], eax
0x004E8BF4 | 48 83 45 F8 02 | add     [rbp+var_8], 2
0x004E8BF9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004E8BFD | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004E8C00 | 84 C0 | test    al, al
0x004E8C02 | 75 AB | jnz     short loc_4E8BAF
0x004E8C04 | 48 8B 45 F0 | mov     rax, [rbp+s]
0x004E8C08 | C9 | leave
0x004E8C09 | C3 | retn
 ************ 
Source Code:
static char *copy_parsing_escapes(const char *string, int len)
{
	const char *s;
	char *dest = xmalloc(len + 1);

	/* sed recognizes 
 */
	/* GNU sed also recognizes \t and \r */
	for (s = "
n\tt\rr"; *s; s += 2) {
		parse_escapes(dest, string, len, s[1], s[0]);
		string = dest;
		len = strlen(dest);
	}
	return dest;
}
 ************ 
Parsed Output:
char* processString(char* input, int length) {
    char* s = (char*)malloc(length + 1);
    const char* specialChars = "
n\tt\rr";

    while (*specialChars) {
        int firstChar = *specialChars;
        specialChars++;
        int secondChar = *specialChars;
        s = sub_4E8A95(s, firstChar, secondChar, input, length);
        input = s;
        length = strlen(s);
        specialChars++;
    }

    return s;
}
 ************ 
Similarity Score (Unixcoder): 0.6391450762748718
Func rank: 48

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: rawmode
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00442521 | 55 | push    rbp
0x00442522 | 48 89 E5 | mov     rbp, rsp
0x00442525 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0044252A | 0F B6 40 08 | movzx   eax, byte ptr [rax+8]
0x0044252E | 84 C0 | test    al, al
0x00442530 | 74 17 | jz      short loc_442549
0x00442532 | B8 5C B5 75 00 | mov     eax, offset termios_p
0x00442537 | 48 89 C2 | mov     rdx, rax; termios_p
0x0044253A | BE 01 00 00 00 | mov     esi, 1; optional_actions
0x0044253F | BF 00 00 00 00 | mov     edi, 0; fd
0x00442544 | E8 87 52 FC FF | call    _tcsetattr
0x00442549 | 90 | nop
0x0044254A | 5D | pop     rbp
0x0044254B | C3 | retn
 ************ 
Source Code:
static void rawmode(void)
{
	tcgetattr(0, &term_orig);
	term_vi = term_orig;
	term_vi.c_lflag &= (~ICANON & ~ECHO);	// leave ISIG on - allow intr's
	term_vi.c_iflag &= (~IXON & ~ICRNL);
	term_vi.c_oflag &= (~ONLCR);
	term_vi.c_cc[VMIN] = 1;
	term_vi.c_cc[VTIME] = 0;
	erase_char = term_vi.c_cc[VERASE];
	tcsetattr_stdin_TCSANOW(&term_vi);
}
 ************ 
Parsed Output:
void configureTerminalSettings() {
    if (dest[8] != 0) {
        _tcsetattr(0, 1, termios_p);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.6359250545501709
Func rank: 49

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: bb_alphasort
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004D8F24 | 55 | push    rbp
0x004D8F25 | 48 89 E5 | mov     rbp, rsp
0x004D8F28 | 48 83 EC 20 | sub     rsp, 20h
0x004D8F2C | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004D8F30 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004D8F34 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004D8F38 | 48 8B 10 | mov     rdx, [rax]
0x004D8F3B | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D8F3F | 48 8B 00 | mov     rax, [rax]
0x004D8F42 | 48 89 D6 | mov     rsi, rdx; s2
0x004D8F45 | 48 89 C7 | mov     rdi, rax; s1
0x004D8F48 | E8 03 E1 F2 FF | call    _strcmp
0x004D8F4D | 89 45 FC | mov     [rbp+var_4], eax
0x004D8F50 | 8B 05 FA 44 28 00 | mov     eax, cs:dword_75D450
0x004D8F56 | 83 E0 01 | and     eax, 1
0x004D8F59 | 85 C0 | test    eax, eax
0x004D8F5B | 74 07 | jz      short loc_4D8F64
0x004D8F5D | 8B 45 FC | mov     eax, [rbp+var_4]
0x004D8F60 | F7 D8 | neg     eax
0x004D8F62 | EB 03 | jmp     short locret_4D8F67
0x004D8F64 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004D8F67 | C9 | leave
0x004D8F68 | C3 | retn
 ************ 
Source Code:
static int bb_alphasort(const void *p1, const void *p2)
{
	int r = strcmp(*(char **) p1, *(char **) p2);
	return (option_mask32 & OPT_r) ? -r : r;
}
 ************ 
Parsed Output:
int compare_strings_with_option(const char *s1, const char *s2) {
    int result = strcmp(s1, s2);
    if (dword_75D450 & 1) {
        result = -result;
    }
    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.6350091695785522
Func rank: 50

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: xprint_and_close_file
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0040A670 | 55 | push    rbp
0x0040A671 | 48 89 E5 | mov     rbp, rsp
0x0040A674 | 48 83 EC 10 | sub     rsp, 10h
0x0040A678 | 48 89 7D F8 | mov     [rbp+stream], rdi
0x0040A67C | E8 C8 FF FF FF | call    sub_40A649
0x0040A681 | 48 8B 45 F8 | mov     rax, [rbp+stream]
0x0040A685 | 48 89 C7 | mov     rdi, rax; stream
0x0040A688 | E8 D3 CB FF FF | call    _fileno
0x0040A68D | BE 01 00 00 00 | mov     esi, 1
0x0040A692 | 89 C7 | mov     edi, eax
0x0040A694 | E8 CD 0C 00 00 | call    sub_40B366
0x0040A699 | 48 83 F8 FF | cmp     rax, 0FFFFFFFFFFFFFFFFh
0x0040A69D | 75 05 | jnz     short loc_40A6A4
0x0040A69F | E8 8B F2 FF FF | call    sub_40992F
0x0040A6A4 | 48 8B 45 F8 | mov     rax, [rbp+stream]
0x0040A6A8 | 48 89 C7 | mov     rdi, rax; stream
0x0040A6AB | E8 50 C3 FF FF | call    _fclose
0x0040A6B0 | 90 | nop
0x0040A6B1 | C9 | leave
0x0040A6B2 | C3 | retn
 ************ 
Source Code:
void FAST_FUNC xprint_and_close_file(FILE *file)
{
	fflush_all();
	// copyfd outputs error messages for us.
	if (bb_copyfd_eof(fileno(file), STDOUT_FILENO) == -1)
		xfunc_die();

	fclose(file);
}
 ************ 
Parsed Output:
void closeAndFlushFile(FILE *stream) {
    sub_40A649();
    int fileDescriptor = _fileno(stream);
    if (sub_40B366(fileDescriptor, 1) == -1) {
        sub_40992F();
    }
    _fclose(stream);
}
 ************ 
Similarity Score (Unixcoder): 0.630675196647644
Func rank: 51

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: readlink_main
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004D055D | 55 | push    rbp
0x004D055E | 48 89 E5 | mov     rbp, rsp
0x004D0561 | 48 83 EC 30 | sub     rsp, 30h
0x004D0565 | 89 7D DC | mov     [rbp+var_24], edi
0x004D0568 | 48 89 75 D0 | mov     [rbp+var_30], rsi
0x004D056C | 48 C7 05 C9 CE 28 00 7D 6E 53 00 | mov     cs:qword_75D440, offset a1_25; "=1"
0x004D0577 | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004D057B | BE 80 6E 53 00 | mov     esi, offset aFnvsq; "fnvsq"
0x004D0580 | 48 89 C7 | mov     rdi, rax
0x004D0583 | B8 00 00 00 00 | mov     eax, 0
0x004D0588 | E8 62 9C 02 00 | call    sub_4FA1EF
0x004D058D | 89 45 F4 | mov     [rbp+var_C], eax
0x004D0590 | 8B 05 E2 A8 28 00 | mov     eax, cs:optind
0x004D0596 | 48 98 | cdqe
0x004D0598 | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]
0x004D05A0 | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004D05A4 | 48 01 D0 | add     rax, rdx
0x004D05A7 | 48 8B 00 | mov     rax, [rax]
0x004D05AA | 48 89 45 E8 | mov     [rbp+var_18], rax
0x004D05AE | 8B 45 F4 | mov     eax, [rbp+var_C]
0x004D05B1 | 83 E0 04 | and     eax, 4
0x004D05B4 | 85 C0 | test    eax, eax
0x004D05B6 | 75 07 | jnz     short loc_4D05BF
0x004D05B8 | C6 05 59 A8 28 00 00 | mov     cs:byte_75AE18, 0
0x004D05BF | 8B 45 F4 | mov     eax, [rbp+var_C]
0x004D05C2 | 83 E0 01 | and     eax, 1
0x004D05C5 | 85 C0 | test    eax, eax
0x004D05C7 | 74 12 | jz      short loc_4D05DB
0x004D05C9 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D05CD | 48 89 C7 | mov     rdi, rax
0x004D05D0 | E8 6B AB F3 FF | call    sub_40B140
0x004D05D5 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004D05D9 | EB 10 | jmp     short loc_4D05EB
0x004D05DB | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004D05DF | 48 89 C7 | mov     rdi, rax
0x004D05E2 | E8 EE AA F3 FF | call    sub_40B0D5
0x004D05E7 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004D05EB | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004D05F0 | 75 07 | jnz     short loc_4D05F9
0x004D05F2 | B8 01 00 00 00 | mov     eax, 1
0x004D05F7 | EB 34 | jmp     short locret_4D062D
0x004D05F9 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x004D05FC | 83 E0 02 | and     eax, 2
0x004D05FF | 85 C0 | test    eax, eax
0x004D0601 | 74 07 | jz      short loc_4D060A
0x004D0603 | BA 86 6E 53 00 | mov     edx, offset aS_96; "%s"
0x004D0608 | EB 05 | jmp     short loc_4D060F
0x004D060A | BA 89 6E 53 00 | mov     edx, offset aS_97; "%s\n"
0x004D060F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004D0613 | 48 89 C6 | mov     rsi, rax
0x004D0616 | 48 89 D7 | mov     rdi, rdx; format
0x004D0619 | B8 00 00 00 00 | mov     eax, 0
0x004D061E | E8 AD 65 F3 FF | call    _printf
0x004D0623 | BF 00 00 00 00 | mov     edi, 0
0x004D0628 | E8 9C 8D 02 00 | call    sub_4F93C9
0x004D062D | C9 | leave
0x004D062E | C3 | retn
 ************ 
Source Code:
int readlink_main(int argc UNUSED_PARAM, char **argv)
{
	char *buf;
	char *fname;

	IF_FEATURE_READLINK_FOLLOW(
		unsigned opt;
		/* We need exactly one non-option argument.  */
		opt_complementary = "=1";
		opt = getopt32(argv, "fnvsq");
		fname = argv[optind];
	)
	IF_NOT_FEATURE_READLINK_FOLLOW(
		const unsigned opt = 0;
		if (argc != 2) bb_show_usage();
		fname = argv[1];
	)

	/* compat: coreutils readlink reports errors silently via exit code */
	if (!(opt & 4)) /* not -v */
		logmode = LOGMODE_NONE;

	if (opt & 1) { /* -f */
		buf = xmalloc_realpath(fname);
	} else {
		buf = xmalloc_readlink_or_warn(fname);
	}

	if (!buf)
		return EXIT_FAILURE;
	printf((opt & 2) ? "%s" : "%s
", buf);

	if (ENABLE_FEATURE_CLEAN_UP)
		free(buf);

	fflush_stdout_and_exit(EXIT_SUCCESS);
}
 ************ 
Parsed Output:
#include <stdio.h>

void processInput(int option, char **argv) {
    extern const char *a1_25;
    extern int optind;
    extern char byte_75AE18;
    const char *inputString;
    int result;
    void *processedString;

    a1_25 = "=1";
    inputString = argv[optind];
    result = sub_4FA1EF(inputString, "fnvsq");

    if ((result & 4) == 0) {
        byte_75AE18 = 0;
    }

    if (result & 1) {
        processedString = sub_40B140(inputString);
    } else {
        processedString = sub_40B0D5(inputString);
    }

    if (processedString == NULL) {
        exit(1);
    }

    if (result & 2) {
        printf("%s", processedString);
    } else {
        printf("%s
", processedString);
    }

    sub_4F93C9(0);
}
 ************ 
Similarity Score (Unixcoder): 0.6210771799087524
Func rank: 52

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: xrealloc_vector_helper
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0050C0E1 | 55 | push    rbp
0x0050C0E2 | 48 89 E5 | mov     rbp, rsp
0x0050C0E5 | 48 83 EC 20 | sub     rsp, 20h
0x0050C0E9 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0050C0ED | 89 75 E4 | mov     [rbp+var_1C], esi
0x0050C0F0 | 89 55 E0 | mov     [rbp+var_20], edx
0x0050C0F3 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x0050C0F6 | 0F B6 C0 | movzx   eax, al
0x0050C0F9 | BA 01 00 00 00 | mov     edx, 1
0x0050C0FE | 89 C1 | mov     ecx, eax
0x0050C100 | D3 E2 | shl     edx, cl
0x0050C102 | 89 D0 | mov     eax, edx
0x0050C104 | 89 45 FC | mov     [rbp+var_4], eax
0x0050C107 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0050C10A | 83 E8 01 | sub     eax, 1
0x0050C10D | 23 45 E0 | and     eax, [rbp+var_20]
0x0050C110 | 85 C0 | test    eax, eax
0x0050C112 | 75 51 | jnz     short loc_50C165
0x0050C114 | C1 6D E4 08 | shr     [rbp+var_1C], 8
0x0050C118 | 8B 55 E0 | mov     edx, [rbp+var_20]
0x0050C11B | 8B 45 FC | mov     eax, [rbp+var_4]
0x0050C11E | 01 D0 | add     eax, edx
0x0050C120 | 83 C0 01 | add     eax, 1
0x0050C123 | 0F AF 45 E4 | imul    eax, [rbp+var_1C]
0x0050C127 | 89 C2 | mov     edx, eax
0x0050C129 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0050C12D | 48 89 D6 | mov     rsi, rdx
0x0050C130 | 48 89 C7 | mov     rdi, rax
0x0050C133 | E8 66 DF EF FF | call    sub_40A09E
0x0050C138 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x0050C13C | 8B 45 FC | mov     eax, [rbp+var_4]
0x0050C13F | 83 C0 01 | add     eax, 1
0x0050C142 | 0F AF 45 E4 | imul    eax, [rbp+var_1C]
0x0050C146 | 89 C2 | mov     edx, eax; n
0x0050C148 | 8B 45 E0 | mov     eax, [rbp+var_20]
0x0050C14B | 0F AF 45 E4 | imul    eax, [rbp+var_1C]
0x0050C14F | 89 C1 | mov     ecx, eax
0x0050C151 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0050C155 | 48 01 C8 | add     rax, rcx
0x0050C158 | BE 00 00 00 00 | mov     esi, 0; c
0x0050C15D | 48 89 C7 | mov     rdi, rax; s
0x0050C160 | E8 EB AB EF FF | call    _memset
0x0050C165 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0050C169 | C9 | leave
0x0050C16A | C3 | retn
 ************ 
Source Code:
FAST_FUNC xrealloc_vector_helper(void *vector, unsigned sizeof_and_shift, int idx)
{
	int mask = 1 << (uint8_t)sizeof_and_shift;

	if (!(idx & (mask - 1))) {
		sizeof_and_shift >>= 8; /* sizeof(vector[0]) */
		vector = xrealloc(vector, sizeof_and_shift * (idx + mask + 1));
		memset((char*)vector + (sizeof_and_shift * idx), 0, sizeof_and_shift * (mask + 1));
	}
	return vector;
}
 ************ 
Parsed Output:
void *processBuffer(void *buffer, int shift, int mask) {
    shift &= 0xFF; // Masking to keep only the lowest byte
    int flag = 1 << shift;
    flag -= 1;
    flag &= mask;

    if (flag == 0) {
        shift >>= 8;
        int result = (mask + flag + 1) * shift;
        buffer = sub_40A09E(buffer, result);
        result = (flag + 1) * shift;
        int temp = mask * shift;
        memset(buffer + temp, 0, result);
    }

    return buffer;
}
 ************ 
Similarity Score (Unixcoder): 0.6183755993843079
Func rank: 53

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: fix_partition_table_order
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004932AD | 55 | push    rbp
0x004932AE | 48 89 E5 | mov     rbp, rsp
0x004932B1 | 48 83 EC 50 | sub     rsp, 50h
0x004932B5 | BF 00 00 00 00 | mov     edi, 0
0x004932BA | E8 44 FB FF FF | call    sub_492E03
0x004932BF | 85 C0 | test    eax, eax
0x004932C1 | 0F 85 F8 00 00 00 | jnz     loc_4933BF
0x004932C7 | BF BC 13 52 00 | mov     edi, offset aOrderingIsAlre; "Ordering is already correct\n"
0x004932CC | E8 3F 35 F7 FF | call    _puts
0x004932D1 | E9 1D 01 00 00 | jmp     locret_4933F3
0x004932D6 | 48 8B 0D 2B A1 2C 00 | mov     rcx, cs:qword_75D408
0x004932DD | 8B 45 FC | mov     eax, [rbp+var_4]
0x004932E0 | 48 63 D0 | movsxd  rdx, eax
0x004932E3 | 48 89 D0 | mov     rax, rdx
0x004932E6 | 48 C1 E0 02 | shl     rax, 2
0x004932EA | 48 01 D0 | add     rax, rdx
0x004932ED | 48 C1 E0 03 | shl     rax, 3
0x004932F1 | 48 05 C0 09 00 00 | add     rax, 9C0h
0x004932F7 | 48 01 C8 | add     rax, rcx
0x004932FA | 48 83 C0 08 | add     rax, 8
0x004932FE | 48 89 45 F0 | mov     [rbp+var_10], rax
0x00493302 | 48 8B 0D FF A0 2C 00 | mov     rcx, cs:qword_75D408
0x00493309 | 8B 45 CC | mov     eax, [rbp+var_34]
0x0049330C | 48 63 D0 | movsxd  rdx, eax
0x0049330F | 48 89 D0 | mov     rax, rdx
0x00493312 | 48 C1 E0 02 | shl     rax, 2
0x00493316 | 48 01 D0 | add     rax, rdx
0x00493319 | 48 C1 E0 03 | shl     rax, 3
0x0049331D | 48 05 C0 09 00 00 | add     rax, 9C0h
0x00493323 | 48 01 C8 | add     rax, rcx
0x00493326 | 48 83 C0 08 | add     rax, 8
0x0049332A | 48 89 45 E8 | mov     [rbp+var_18], rax
0x0049332E | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00493332 | 48 8B 40 08 | mov     rax, [rax+8]
0x00493336 | 48 89 45 E0 | mov     [rbp+var_20], rax
0x0049333A | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0049333E | 48 8B 50 08 | mov     rdx, [rax+8]
0x00493342 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00493346 | 48 89 50 08 | mov     [rax+8], rdx
0x0049334A | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0049334E | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x00493352 | 48 89 50 08 | mov     [rax+8], rdx
0x00493356 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0049335A | 48 8B 00 | mov     rax, [rax]
0x0049335D | 48 89 45 D8 | mov     [rbp+var_28], rax
0x00493361 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00493365 | 48 8B 00 | mov     rax, [rax]
0x00493368 | 48 89 45 D0 | mov     [rbp+var_30], rax
0x0049336C | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00493370 | 48 8B 50 08 | mov     rdx, [rax+8]
0x00493374 | 48 8B 00 | mov     rax, [rax]
0x00493377 | 48 89 45 B0 | mov     [rbp+var_50], rax
0x0049337B | 48 89 55 B8 | mov     [rbp+var_48], rdx
0x0049337F | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x00493383 | 48 8B 50 08 | mov     rdx, [rax+8]
0x00493387 | 48 8B 00 | mov     rax, [rax]
0x0049338A | 48 8B 4D D8 | mov     rcx, [rbp+var_28]
0x0049338E | 48 89 01 | mov     [rcx], rax
0x00493391 | 48 89 51 08 | mov     [rcx+8], rdx
0x00493395 | 48 8B 45 B0 | mov     rax, [rbp+var_50]
0x00493399 | 48 8B 55 B8 | mov     rdx, [rbp+var_48]
0x0049339D | 48 8B 4D D0 | mov     rcx, [rbp+var_30]
0x004933A1 | 48 89 01 | mov     [rcx], rax
0x004933A4 | 48 89 51 08 | mov     [rcx+8], rdx
0x004933A8 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004933AC | C6 40 20 01 | mov     byte ptr [rax+20h], 1
0x004933B0 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004933B4 | 0F B6 50 20 | movzx   edx, byte ptr [rax+20h]
0x004933B8 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004933BC | 88 50 20 | mov     [rax+20h], dl
0x004933BF | 48 8D 45 CC | lea     rax, [rbp+var_34]
0x004933C3 | 48 89 C7 | mov     rdi, rax
0x004933C6 | E8 38 FA FF FF | call    sub_492E03
0x004933CB | 89 45 FC | mov     [rbp+var_4], eax
0x004933CE | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004933D2 | 74 0A | jz      short loc_4933DE
0x004933D4 | 83 7D FC 03 | cmp     [rbp+var_4], 3
0x004933D8 | 0F 8E F8 FE FF FF | jle     loc_4932D6
0x004933DE | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004933E2 | 74 05 | jz      short loc_4933E9
0x004933E4 | E8 EA FA FF FF | call    sub_492ED3
0x004933E9 | BF D9 13 52 00 | mov     edi, offset aDone_4; "Done."
0x004933EE | E8 1D 34 F7 FF | call    _puts
0x004933F3 | C9 | leave
0x004933F4 | C3 | retn
 ************ 
Source Code:
static void
fix_partition_table_order(void)
{
	struct pte *pei, *pek;
	int i,k;

	if (!wrong_p_order(NULL)) {
		printf("Ordering is already correct

");
		return;
	}

	while ((i = wrong_p_order(&k)) != 0 && i < 4) {
		/* partition i should have come earlier, move it */
		/* We have to move data in the MBR */
		struct partition *pi, *pk, *pe, pbuf;
		pei = &ptes[i];
		pek = &ptes[k];

		pe = pei->ext_pointer;
		pei->ext_pointer = pek->ext_pointer;
		pek->ext_pointer = pe;

		pi = pei->part_table;
		pk = pek->part_table;

		memmove(&pbuf, pi, sizeof(struct partition));
		memmove(pi, pk, sizeof(struct partition));
		memmove(pk, &pbuf, sizeof(struct partition));

		pei->changed = pek->changed = 1;
	}

	if (i)
		fix_chain_of_logicals();

	printf("Done.
");
}
 ************ 
Parsed Output:
#include <stdio.h>

void swapElements() {
    int result = sub_492E03(0);
    if (result != 0) {
        // Assuming qword_75D408 is a global variable pointing to an array of structures
        // and each structure has a pointer at offset 0 and a flag at offset 20h (32 in decimal).
        // The following code swaps two elements in that array.
        ElementType *array = qword_75D408;
        int index1 = var_34;
        int index2 = var_4;

        ElementType temp = array[index1];
        array[index1] = array[index2];
        array[index2] = temp;

        // Set the flag at offset 20h to 1 for the element at index1
        array[index1].flag = 1;
        // Copy the flag from the element at index1 to the element at index2
        array[index2].flag = array[index1].flag;

        result = sub_492E03(&var_34);
        var_4 = result;
        if (var_4 != 0) {
            if (var_4 > 3) {
                goto loc_4932D6;
            }
        } else {
            sub_492ED3();
        }
        puts("Done.");
    } else {
        puts("Ordering is already correct
");
    }
}
 ************ 
Similarity Score (Unixcoder): 0.6169686913490295
Func rank: 54

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: change_file
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0041E546 | 55 | push    rbp
0x0041E547 | 48 89 E5 | mov     rbp, rsp
0x0041E54A | 53 | push    rbx
0x0041E54B | 48 83 EC 18 | sub     rsp, 18h
0x0041E54F | 89 7D EC | mov     [rbp+var_14], edi
0x0041E552 | 48 8B 05 AF EE 33 00 | mov     rax, cs:qword_75D408
0x0041E559 | 8B 50 64 | mov     edx, [rax+64h]
0x0041E55C | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x0041E560 | 7E 0C | jle     short loc_41E56E
0x0041E562 | 48 8B 05 9F EE 33 00 | mov     rax, cs:qword_75D408
0x0041E569 | 8B 40 60 | mov     eax, [rax+60h]
0x0041E56C | EB 05 | jmp     short loc_41E573
0x0041E56E | B8 01 00 00 00 | mov     eax, 1
0x0041E573 | 39 D0 | cmp     eax, edx
0x0041E575 | 74 77 | jz      short loc_41E5EE
0x0041E577 | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x0041E57B | 74 11 | jz      short loc_41E58E
0x0041E57D | 48 8B 05 84 EE 33 00 | mov     rax, cs:qword_75D408
0x0041E584 | 8B 50 64 | mov     edx, [rax+64h]
0x0041E587 | 8B 45 EC | mov     eax, [rbp+var_14]
0x0041E58A | 01 C2 | add     edx, eax
0x0041E58C | EB 05 | jmp     short loc_41E593
0x0041E58E | BA 01 00 00 00 | mov     edx, 1
0x0041E593 | 48 8B 05 6E EE 33 00 | mov     rax, cs:qword_75D408
0x0041E59A | 89 50 64 | mov     [rax+64h], edx
0x0041E59D | 48 8B 05 64 EE 33 00 | mov     rax, cs:qword_75D408
0x0041E5A4 | 48 8B 40 68 | mov     rax, [rax+68h]
0x0041E5A8 | 48 89 C7 | mov     rdi, rax; ptr
0x0041E5AB | E8 B0 80 FE FF | call    _free
0x0041E5B0 | 48 8B 05 51 EE 33 00 | mov     rax, cs:qword_75D408
0x0041E5B7 | 48 8B 50 70 | mov     rdx, [rax+70h]
0x0041E5BB | 48 8B 05 46 EE 33 00 | mov     rax, cs:qword_75D408
0x0041E5C2 | 8B 40 64 | mov     eax, [rax+64h]
0x0041E5C5 | 83 E8 01 | sub     eax, 1
0x0041E5C8 | 89 C0 | mov     eax, eax
0x0041E5CA | 48 C1 E0 03 | shl     rax, 3
0x0041E5CE | 48 01 D0 | add     rax, rdx
0x0041E5D1 | 48 8B 00 | mov     rax, [rax]
0x0041E5D4 | 48 8B 1D 2D EE 33 00 | mov     rbx, cs:qword_75D408
0x0041E5DB | 48 89 C7 | mov     rdi, rax
0x0041E5DE | E8 3C BB FE FF | call    sub_40A11F
0x0041E5E3 | 48 89 43 68 | mov     [rbx+68h], rax
0x0041E5E7 | E8 6B FA FF FF | call    sub_41E057
0x0041E5EC | EB 1A | jmp     short loc_41E608
0x0041E5EE | 83 7D EC 00 | cmp     [rbp+var_14], 0
0x0041E5F2 | 7E 07 | jle     short loc_41E5FB
0x0041E5F4 | B8 B3 91 52 00 | mov     eax, offset aNoNextFile; "No next file"
0x0041E5F9 | EB 05 | jmp     short loc_41E600
0x0041E5FB | B8 C0 91 52 00 | mov     eax, offset aNoPreviousFile; "No previous file"
0x0041E600 | 48 89 C7 | mov     rdi, rax
0x0041E603 | E8 07 E5 FF FF | call    sub_41CB0F
0x0041E608 | 90 | nop
0x0041E609 | 48 83 C4 18 | add     rsp, 18h
0x0041E60D | 5B | pop     rbx
0x0041E60E | 5D | pop     rbp
0x0041E60F | C3 | retn
 ************ 
Source Code:
static void change_file(int direction)
{
	if (current_file != ((direction > 0) ? num_files : 1)) {
		current_file = direction ? current_file + direction : 1;
		free(filename);
		filename = xstrdup(files[current_file - 1]);
		reinitialize();
	} else {
		print_statusline(direction > 0 ? "No next file" : "No previous file");
	}
}
 ************ 
Parsed Output:
void updateFileIndexAndProcess(int indexDelta) {
    extern int fileIndex;
    extern void* filePtr;
    extern void* nextFilePtr;
    extern char* noNextFileMessage;
    extern char* noPreviousFileMessage;
    extern void free(void*);
    extern void processFile(void*);
    extern void displayMessage(char*);

    int newIndex = fileIndex + indexDelta;
    if (indexDelta > 0) {
        if (newIndex == fileIndex) {
            if (indexDelta > 0) {
                displayMessage(noNextFileMessage);
            } else {
                displayMessage(noPreviousFileMessage);
            }
            return;
        }
    }

    fileIndex = newIndex;
    free(filePtr);
    void* newFilePtr = nextFilePtr + (fileIndex - 1) * sizeof(void*);
    filePtr = processFile(*(void**)newFilePtr);
    // Additional function call, purpose unknown without further context
    // sub_41E057();
}
 ************ 
Similarity Score (Unixcoder): 0.6129786372184753
Func rank: 55

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: iac_flush
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00441A2B | 55 | push    rbp
0x00441A2C | 48 89 E5 | mov     rbp, rsp
0x00441A2F | B8 F8 B3 75 00 | mov     eax, offset dest
0x00441A34 | 8B 00 | mov     eax, [rax]
0x00441A36 | 48 98 | cdqe
0x00441A38 | B9 A0 B4 75 00 | mov     ecx, offset qword_75B4A0
0x00441A3D | 48 89 C2 | mov     rdx, rax; n
0x00441A40 | 48 89 CE | mov     rsi, rcx; buf
0x00441A43 | BF 03 00 00 00 | mov     edi, 3; fd
0x00441A48 | E8 13 4F FC FF | call    _write
0x00441A4D | B8 F8 B3 75 00 | mov     eax, offset dest
0x00441A52 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x00441A58 | 90 | nop
0x00441A59 | 5D | pop     rbp
0x00441A5A | C3 | retn
 ************ 
Source Code:
static void iac_flush(void)
{
	write(netfd, G.iacbuf, G.iaclen);
	G.iaclen = 0;
}
 ************ 
Parsed Output:
void writeToDest() {
    int *dest = (int *)0x75B3F8;
    char *buf = (char *)0x75B4A0;
    int fd = 3;
    int n = *dest;
    _write(fd, buf, n);
    *dest = 0;
}
 ************ 
Similarity Score (Unixcoder): 0.6121311783790588
Func rank: 56

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: topmem_sort
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00466863 | 55 | push    rbp
0x00466864 | 48 89 E5 | mov     rbp, rsp
0x00466867 | 48 89 7D D8 | mov     [rbp+var_28], rdi
0x0046686B | 48 89 75 D0 | mov     [rbp+var_30], rsi
0x0046686F | B8 F8 B3 75 00 | mov     eax, offset dest
0x00466874 | 0F B6 40 0D | movzx   eax, byte ptr [rax+0Dh]
0x00466878 | 48 0F BE C0 | movsx   rax, al
0x0046687C | 48 83 C0 03 | add     rax, 3
0x00466880 | C1 E0 03 | shl     eax, 3
0x00466883 | 89 45 EC | mov     [rbp+var_14], eax
0x00466886 | 8B 45 EC | mov     eax, [rbp+var_14]
0x00466889 | 48 63 D0 | movsxd  rdx, eax
0x0046688C | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00466890 | 48 01 D0 | add     rax, rdx
0x00466893 | 48 8B 00 | mov     rax, [rax]
0x00466896 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0046689A | 8B 45 EC | mov     eax, [rbp+var_14]
0x0046689D | 48 63 D0 | movsxd  rdx, eax
0x004668A0 | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004668A4 | 48 01 D0 | add     rax, rdx
0x004668A7 | 48 8B 00 | mov     rax, [rax]
0x004668AA | 48 89 45 F0 | mov     [rbp+var_10], rax
0x004668AE | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004668B2 | 48 3B 45 F0 | cmp     rax, [rbp+var_10]
0x004668B6 | 75 18 | jnz     short loc_4668D0
0x004668B8 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004668BC | 48 8B 40 38 | mov     rax, [rax+38h]
0x004668C0 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004668C4 | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004668C8 | 48 8B 40 38 | mov     rax, [rax+38h]
0x004668CC | 48 89 45 F0 | mov     [rbp+var_10], rax
0x004668D0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004668D4 | 48 3B 45 F0 | cmp     rax, [rbp+var_10]
0x004668D8 | 77 10 | ja      short loc_4668EA
0x004668DA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004668DE | 48 3B 45 F0 | cmp     rax, [rbp+var_10]
0x004668E2 | 0F 95 C0 | setnz   al
0x004668E5 | 0F B6 C0 | movzx   eax, al
0x004668E8 | EB 05 | jmp     short loc_4668EF
0x004668EA | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x004668EF | 89 45 EC | mov     [rbp+var_14], eax
0x004668F2 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004668F7 | 0F B6 40 0C | movzx   eax, byte ptr [rax+0Ch]
0x004668FB | 84 C0 | test    al, al
0x004668FD | 74 07 | jz      short loc_466906
0x004668FF | 8B 45 EC | mov     eax, [rbp+var_14]
0x00466902 | F7 D8 | neg     eax
0x00466904 | EB 03 | jmp     short loc_466909
0x00466906 | 8B 45 EC | mov     eax, [rbp+var_14]
0x00466909 | 5D | pop     rbp
0x0046690A | C3 | retn
 ************ 
Source Code:
if ENABLE_FEATURE_TOPMEM

static int topmem_sort(char *a, char *b)
{
	int n;
	mem_t l, r;

	n = offsetof(topmem_status_t, vsz) + (sort_field * sizeof(mem_t));
	l = *(mem_t*)(a + n);
	r = *(mem_t*)(b + n);
	if (l == r) {
		l = ((topmem_status_t*)a)->dirty;
		r = ((topmem_status_t*)b)->dirty;
	}
	/* We want to avoid unsigned->signed and truncation errors */
	/* l>r: -1, l=r: 0, l<r: 1 */
	n = (l > r) ? -1 : (l != r);
	return inverted ? -n : n;
}
 ************ 
Parsed Output:
int compare_offsets(void *ptr1, void *ptr2) {
    char dest_offset_1 = *((char*)dest + 0x0D);
    int offset = (int)(dest_offset_1 + 3) << 3;
    
    long *value1 = (long *)((char *)ptr1 + offset);
    long *value2 = (long *)((char *)ptr2 + offset);
    
    if (*value1 != *value2) {
        value1 = (long *)((char *)ptr1 + 0x38);
        value2 = (long *)((char *)ptr2 + 0x38);
    }
    
    if (*value1 > *value2) {
        return -1;
    }
    
    char dest_offset_2 = *((char*)dest + 0x0C);
    if (dest_offset_2 == 0) {
        return offset;
    } else {
        return -offset;
    }
}
 ************ 
Similarity Score (Unixcoder): 0.6038485765457153
Func rank: 57

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: print_closing_wait
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00422354 | 55 | push    rbp
0x00422355 | 48 89 E5 | mov     rbp, rsp
0x00422358 | 48 83 EC 10 | sub     rsp, 10h
0x0042235C | 89 7D FC | mov     [rbp+var_4], edi
0x0042235F | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x00422363 | 74 15 | jz      short loc_42237A
0x00422365 | 81 7D FC FF FF 00 00 | cmp     [rbp+var_4], 0FFFFh
0x0042236C | 75 18 | jnz     short loc_422386
0x0042236E | BF 69 75 51 00 | mov     edi, offset aNone_1; "none"
0x00422373 | E8 98 44 FE FF | call    _puts
0x00422378 | EB 20 | jmp     short loc_42239A
0x0042237A | BF 60 75 51 00 | mov     edi, offset aInfinite; "infinite"
0x0042237F | E8 8C 44 FE FF | call    _puts
0x00422384 | EB 14 | jmp     short loc_42239A
0x00422386 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00422389 | 89 C6 | mov     esi, eax
0x0042238B | BF DB 75 51 00 | mov     edi, offset aU_5; "%u\n"
0x00422390 | B8 00 00 00 00 | mov     eax, 0
0x00422395 | E8 36 48 FE FF | call    _printf
0x0042239A | 90 | nop
0x0042239B | C9 | leave
0x0042239C | C3 | retn
 ************ 
Source Code:
static void print_closing_wait(unsigned int closing_wait)
{
	switch (closing_wait) {
	case ASYNC_CLOSING_WAIT_NONE:
		puts(STR_NONE);
		break;
	case ASYNC_CLOSING_WAIT_INF:
		puts(STR_INFINITE);
		break;
	default:
		printf("%u
", closing_wait);
	}
}
 ************ 
Parsed Output:
void printNumberOrSpecialMessage(int number) {
    if (number == 0) {
        puts("infinite");
    } else if (number == 0xFFFF) {
        puts("none");
    } else {
        printf("%u
", number);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.5946201682090759
Func rank: 58

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: dot_right
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004EDA45 | 55 | push    rbp
0x004EDA46 | 48 89 E5 | mov     rbp, rsp
0x004EDA49 | 48 8B 05 B8 F9 26 00 | mov     rax, cs:qword_75D408
0x004EDA50 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x004EDA54 | 48 8B 05 AD F9 26 00 | mov     rax, cs:qword_75D408
0x004EDA5B | 48 8B 40 08 | mov     rax, [rax+8]
0x004EDA5F | 48 83 E8 01 | sub     rax, 1
0x004EDA63 | 48 39 C2 | cmp     rdx, rax
0x004EDA66 | 73 25 | jnb     short loc_4EDA8D
0x004EDA68 | 48 8B 05 99 F9 26 00 | mov     rax, cs:qword_75D408
0x004EDA6F | 48 8B 40 10 | mov     rax, [rax+10h]
0x004EDA73 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004EDA76 | 3C 0A | cmp     al, 0Ah
0x004EDA78 | 74 13 | jz      short loc_4EDA8D
0x004EDA7A | 48 8B 05 87 F9 26 00 | mov     rax, cs:qword_75D408
0x004EDA81 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x004EDA85 | 48 83 C2 01 | add     rdx, 1
0x004EDA89 | 48 89 50 10 | mov     [rax+10h], rdx
0x004EDA8D | 90 | nop
0x004EDA8E | 5D | pop     rbp
0x004EDA8F | C3 | retn
 ************ 
Source Code:
static void dot_right(void)
{
	if (dot < end - 1 && *dot != '
')
		dot++;
}
 ************ 
Parsed Output:
int checkNextCharacter() {
    extern char *data;
    if (data[16] >= data[8] - 1) {
        return 0;
    }
    if (data[data[16]] == '
') {
        return 0;
    }
    data[16]++;
    return 1;
}
 ************ 
Similarity Score (Unixcoder): 0.5946109294891357
Func rank: 59

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: close_dev_fd
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00490398 | 55 | push    rbp
0x00490399 | 48 89 E5 | mov     rbp, rsp
0x0049039C | BE 00 00 00 00 | mov     esi, 0
0x004903A1 | BF C1 06 52 00 | mov     edi, offset aDevNull_2; "/dev/null"
0x004903A6 | E8 EA 9E F7 FF | call    sub_40A295
0x004903AB | BE 03 00 00 00 | mov     esi, 3
0x004903B0 | 89 C7 | mov     edi, eax
0x004903B2 | E8 C0 A0 F7 FF | call    sub_40A477
0x004903B7 | 90 | nop
0x004903B8 | 5D | pop     rbp
0x004903B9 | C3 | retn
 ************ 
Source Code:
static void
close_dev_fd(void)
{
	/* Not really closing, but making sure it is open, and to harmless place */
	xmove_fd(xopen(bb_dev_null, O_RDONLY), dev_fd);
}
 ************ 
Parsed Output:
int openAndSetFlags() {
    int fileDescriptor = open("/dev/null", 0);
    setFlags(fileDescriptor, 3);
    return fileDescriptor;
}
 ************ 
Similarity Score (Unixcoder): 0.592117965221405
Func rank: 60

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: sendping6
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0043E38D | 55 | push    rbp
0x0043E38E | 48 89 E5 | mov     rbp, rsp
0x0043E391 | 48 83 EC 20 | sub     rsp, 20h
0x0043E395 | 89 7D EC | mov     [rbp+var_14], edi
0x0043E398 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E39D | 48 8B 40 70 | mov     rax, [rax+70h]
0x0043E3A1 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0043E3A5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E3A9 | C6 00 80 | mov     byte ptr [rax], 80h
0x0043E3AC | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E3B1 | 48 8B 40 28 | mov     rax, [rax+28h]
0x0043E3B5 | 0F B7 C0 | movzx   eax, ax
0x0043E3B8 | 89 C7 | mov     edi, eax; hostshort
0x0043E3BA | E8 B1 87 FC FF | call    _htons
0x0043E3BF | 89 C2 | mov     edx, eax
0x0043E3C1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E3C5 | 66 89 50 06 | mov     [rax+6], dx
0x0043E3C9 | B8 F8 B3 75 00 | mov     eax, offset dest
0x0043E3CE | 0F B7 50 40 | movzx   edx, word ptr [rax+40h]
0x0043E3D2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E3D6 | 66 89 50 04 | mov     [rax+4], dx
0x0043E3DA | E8 88 D8 FC FF | call    sub_40BC67
0x0043E3DF | 48 89 C2 | mov     rdx, rax
0x0043E3E2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043E3E6 | 48 83 C0 08 | add     rax, 8
0x0043E3EA | 89 10 | mov     [rax], edx
0x0043E3EC | BE 08 00 00 00 | mov     esi, 8
0x0043E3F1 | BF 8D E3 43 00 | mov     edi, offset sub_43E38D
0x0043E3F6 | E8 39 FD FF FF | call    sub_43E134
0x0043E3FB | 90 | nop
0x0043E3FC | C9 | leave
0x0043E3FD | C3 | retn
 ************ 
Source Code:
if ENABLE_PING6
static void sendping6(int junk UNUSED_PARAM)
{
	struct icmp6_hdr *pkt = G.snd_packet;

	//memset(pkt, 0, datalen + sizeof(struct icmp6_hdr) + 4);
	pkt->icmp6_type = ICMP6_ECHO_REQUEST;
	/*pkt->icmp6_code = 0;*/
	/*pkt->icmp6_cksum = 0;*/
	pkt->icmp6_seq = htons(ntransmitted); /* don't ++ here, it can be a macro */
	pkt->icmp6_id = myid;

	/*if (datalen >= 4)*/
		*(uint32_t*)(&pkt->icmp6_data8[4]) = monotonic_us();

	//TODO? pkt->icmp_cksum = inet_cksum(...);

	sendping_tail(sendping6, sizeof(struct icmp6_hdr));
}
 ************ 
Parsed Output:
#include <stdint.h>

void configureDestination() {
    uint8_t *dest_ptr = (uint8_t *)(dest + 0x70);
    *dest_ptr = 0x80;

    uint16_t hostshort = *(uint16_t *)(dest + 0x28);
    uint16_t networkshort = htons(hostshort);
    *(uint16_t *)(dest_ptr + 6) = networkshort;

    uint16_t value = *(uint16_t *)(dest + 0x40);
    *(uint16_t *)(dest_ptr + 4) = value;

    uint32_t result = sub_40BC67();
    *(uint32_t *)(dest_ptr + 8) = result;

    sub_43E134(8, configureDestination);
}
 ************ 
Similarity Score (Unixcoder): 0.591204047203064
Func rank: 61

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: fs_match
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004DB197 | 55 | push    rbp
0x004DB198 | 48 89 E5 | mov     rbp, rsp
0x004DB19B | 48 83 EC 30 | sub     rsp, 30h
0x004DB19F | 48 89 7D D8 | mov     [rbp+var_28], rdi
0x004DB1A3 | 48 8B 05 BE 00 28 00 | mov     rax, cs:qword_75B268
0x004DB1AA | 48 85 C0 | test    rax, rax
0x004DB1AD | 75 0A | jnz     short loc_4DB1B9
0x004DB1AF | B8 01 00 00 00 | mov     eax, 1
0x004DB1B4 | E9 02 01 00 00 | jmp     locret_4DB2BB
0x004DB1B9 | C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0
0x004DB1C0 | C7 45 F4 00 00 00 00 | mov     [rbp+var_C], 0
0x004DB1C7 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x004DB1CE | 48 8B 05 93 00 28 00 | mov     rax, cs:qword_75B268
0x004DB1D5 | 8B 55 FC | mov     edx, [rbp+var_4]
0x004DB1D8 | 48 63 D2 | movsxd  rdx, edx
0x004DB1DB | 48 C1 E2 03 | shl     rdx, 3
0x004DB1DF | 48 01 D0 | add     rax, rdx
0x004DB1E2 | 48 8B 00 | mov     rax, [rax]
0x004DB1E5 | 48 89 45 E8 | mov     [rbp+s1], rax
0x004DB1E9 | 48 83 7D E8 00 | cmp     [rbp+s1], 0
0x004DB1EE | 0F 84 9F 00 00 00 | jz      loc_4DB293
0x004DB1F4 | 48 8B 15 75 00 28 00 | mov     rdx, cs:qword_75B270
0x004DB1FB | 8B 45 FC | mov     eax, [rbp+var_4]
0x004DB1FE | 48 98 | cdqe
0x004DB200 | 48 01 D0 | add     rax, rdx
0x004DB203 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004DB206 | 0F B6 C0 | movzx   eax, al
0x004DB209 | 83 F8 01 | cmp     eax, 1
0x004DB20C | 74 53 | jz      short loc_4DB261
0x004DB20E | 83 F8 02 | cmp     eax, 2
0x004DB211 | 74 2C | jz      short loc_4DB23F
0x004DB213 | 85 C0 | test    eax, eax
0x004DB215 | 75 73 | jnz     short loc_4DB28A
0x004DB217 | 83 45 F4 01 | add     [rbp+var_C], 1
0x004DB21B | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004DB21F | 48 8B 50 18 | mov     rdx, [rax+18h]
0x004DB223 | 48 8B 45 E8 | mov     rax, [rbp+s1]
0x004DB227 | 48 89 D6 | mov     rsi, rdx; s2
0x004DB22A | 48 89 C7 | mov     rdi, rax; s1
0x004DB22D | E8 1E BE F2 FF | call    _strcmp
0x004DB232 | 85 C0 | test    eax, eax
0x004DB234 | 75 4D | jnz     short loc_4DB283
0x004DB236 | C7 45 F8 01 00 00 00 | mov     [rbp+var_8], 1
0x004DB23D | EB 44 | jmp     short loc_4DB283
0x004DB23F | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004DB243 | 48 8B 50 20 | mov     rdx, [rax+20h]
0x004DB247 | 48 8B 45 E8 | mov     rax, [rbp+s1]
0x004DB24B | 48 89 D6 | mov     rsi, rdx
0x004DB24E | 48 89 C7 | mov     rdi, rax
0x004DB251 | E8 8C FE FF FF | call    sub_4DB0E2
0x004DB256 | 85 C0 | test    eax, eax
0x004DB258 | 74 2C | jz      short loc_4DB286
0x004DB25A | B8 00 00 00 00 | mov     eax, 0
0x004DB25F | EB 5A | jmp     short locret_4DB2BB
0x004DB261 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004DB265 | 48 8B 50 20 | mov     rdx, [rax+20h]
0x004DB269 | 48 8B 45 E8 | mov     rax, [rbp+s1]
0x004DB26D | 48 89 D6 | mov     rsi, rdx
0x004DB270 | 48 89 C7 | mov     rdi, rax
0x004DB273 | E8 6A FE FF FF | call    sub_4DB0E2
0x004DB278 | 85 C0 | test    eax, eax
0x004DB27A | 75 0D | jnz     short loc_4DB289
0x004DB27C | B8 00 00 00 00 | mov     eax, 0
0x004DB281 | EB 38 | jmp     short locret_4DB2BB
0x004DB283 | 90 | nop
0x004DB284 | EB 04 | jmp     short loc_4DB28A
0x004DB286 | 90 | nop
0x004DB287 | EB 01 | jmp     short loc_4DB28A
0x004DB289 | 90 | nop
0x004DB28A | 83 45 FC 01 | add     [rbp+var_4], 1
0x004DB28E | E9 3B FF FF FF | jmp     loc_4DB1CE
0x004DB293 | 90 | nop
0x004DB294 | 83 7D F4 00 | cmp     [rbp+var_C], 0
0x004DB298 | 75 07 | jnz     short loc_4DB2A1
0x004DB29A | B8 01 00 00 00 | mov     eax, 1
0x004DB29F | EB 1A | jmp     short locret_4DB2BB
0x004DB2A1 | 0F B6 05 D0 FF 27 00 | movzx   eax, cs:byte_75B278
0x004DB2A8 | 84 C0 | test    al, al
0x004DB2AA | 74 0C | jz      short loc_4DB2B8
0x004DB2AC | 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004DB2B0 | 0F 94 C0 | setz    al
0x004DB2B3 | 0F B6 C0 | movzx   eax, al
0x004DB2B6 | EB 03 | jmp     short locret_4DB2BB
0x004DB2B8 | 8B 45 F8 | mov     eax, [rbp+var_8]
0x004DB2BB | C9 | leave
0x004DB2BC | C3 | retn
 ************ 
Source Code:
static int fs_match(struct fs_info *fs)
{
	int n, ret, checked_type;
	char *cp;

	if (!fs_type_list)
		return 1;

	ret = 0;
	checked_type = 0;
	n = 0;
	while (1) {
		cp = fs_type_list[n];
		if (!cp)
			break;
		switch (fs_type_flag[n]) {
		case FS_TYPE_FLAG_NORMAL:
			checked_type++;
			if (strcmp(cp, fs->type) == 0)
				ret = 1;
			break;
		case FS_TYPE_FLAG_NEGOPT:
			if (opt_in_list(cp, fs->opts))
				return 0;
			break;
		case FS_TYPE_FLAG_OPT:
			if (!opt_in_list(cp, fs->opts))
				return 0;
			break;
		}
		n++;
	}
	if (checked_type == 0)
		return 1;

	return (fs_type_negated ? !ret : ret);
}
 ************ 
Parsed Output:
int check_conditions(void *input_struct) {
    extern int64_t *qword_75B268;
    extern int8_t *qword_75B270;
    extern int8_t byte_75B278;
    int64_t *s1;
    int var_4 = 0;
    int var_C = 0;
    int var_8 = 0;

    if (!qword_75B268) {
        return 1;
    }

    while (1) {
        s1 = qword_75B268[var_4];
        if (!s1) {
            break;
        }

        int8_t condition_type = qword_75B270[var_4];
        switch (condition_type) {
            case 0:
                var_C++;
                if (strcmp(((char **)input_struct)[3], (char *)s1) == 0) {
                    var_8 = 1;
                }
                break;
            case 1:
                if (sub_4DB0E2(((char **)input_struct)[4], (char *)s1) != 0) {
                    return 0;
                }
                break;
            case 2:
                if (sub_4DB0E2(((char **)input_struct)[4], (char *)s1) == 0) {
                    return 0;
                }
                break;
            default:
                break;
        }

        var_4++;
    }

    if (var_C != 0) {
        if (byte_75B278) {
            return var_8 == 0;
        } else {
            return var_8;
        }
    }

    return 1;
}
 ************ 
Similarity Score (Unixcoder): 0.5895183086395264
Func rank: 62

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: strstr_pattern
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00484A4F | 55 | push    rbp
0x00484A50 | 48 89 E5 | mov     rbp, rsp
0x00484A53 | 48 83 EC 30 | sub     rsp, 30h
0x00484A57 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00484A5B | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00484A5F | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x00484A63 | 48 8B 4D E0 | mov     rcx, [rbp+var_20]
0x00484A67 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00484A6B | BA 06 00 00 00 | mov     edx, 6
0x00484A70 | 48 89 CE | mov     rsi, rcx
0x00484A73 | 48 89 C7 | mov     rdi, rax
0x00484A76 | E8 AC 5E 00 00 | call    sub_48A927
0x00484A7B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00484A7F | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x00484A84 | 74 16 | jz      short loc_484A9C
0x00484A86 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00484A8A | 48 2B 45 E8 | sub     rax, [rbp+var_18]
0x00484A8E | 89 C2 | mov     edx, eax
0x00484A90 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00484A94 | 89 10 | mov     [rax], edx
0x00484A96 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00484A9A | EB 2B | jmp     short locret_484AC7
0x00484A9C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00484AA0 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00484AA3 | 84 C0 | test    al, al
0x00484AA5 | 75 07 | jnz     short loc_484AAE
0x00484AA7 | B8 00 00 00 00 | mov     eax, 0
0x00484AAC | EB 19 | jmp     short locret_484AC7
0x00484AAE | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00484AB2 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x00484AB5 | 3C 2A | cmp     al, 2Ah ; '*'
0x00484AB7 | 75 07 | jnz     short loc_484AC0
0x00484AB9 | B8 00 00 00 00 | mov     eax, 0
0x00484ABE | EB 07 | jmp     short locret_484AC7
0x00484AC0 | 48 83 45 E8 01 | add     [rbp+var_18], 1
0x00484AC5 | EB 9C | jmp     short loc_484A63
0x00484AC7 | C9 | leave
0x00484AC8 | C3 | retn
 ************ 
Source Code:
static char *strstr_pattern(char *val, const char *pattern, int *size)
{
	while (1) {
		char *end = scan_and_match(val, pattern, SCAN_MOVE_FROM_RIGHT + SCAN_MATCH_LEFT_HALF);
		debug_printf_varexp("val:'%s' pattern:'%s' end:'%s'
", val, pattern, end);
		if (end) {
			*size = end - val;
			return val;
		}
		if (*val == '\0')
			return NULL;
		/* Optimization: if "*pat" did not match the start of "string",
		 * we know that "tring", "ring" etc will not match too:
		 */
		if (pattern[0] == '*')
			return NULL;
		val++;
	}
}
 ************ 
Parsed Output:
int findStringDifference(char *str1, char *str2, int *diff) {
    char *original_str1 = str1;
    int result = sub_48A927(str1, str2, 6);
    if (result != 0) {
        *diff = result - original_str1;
        return original_str1;
    }

    while (*original_str1) {
        if (*original_str1 != '*') {
            original_str1++;
        } else {
            return 0;
        }
    }

    return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.5787341594696045
Func rank: 63

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: bb_init_module
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00426133 | 55 | push    rbp
0x00426134 | 48 89 E5 | mov     rbp, rsp
0x00426137 | 48 83 EC 30 | sub     rsp, 30h
0x0042613B | 48 89 7D D8 | mov     [rbp+var_28], rdi
0x0042613F | 48 89 75 D0 | mov     [rbp+var_30], rsi
0x00426143 | 48 83 7D D0 00 | cmp     [rbp+var_30], 0
0x00426148 | 75 08 | jnz     short loc_426152
0x0042614A | 48 C7 45 D0 22 AA 52 00 | mov     [rbp+var_30], offset unk_52AA22
0x00426152 | 48 C7 45 E8 00 F0 FF 7F | mov     [rbp+len], 7FFFF000h
0x0042615A | C6 45 F7 00 | mov     [rbp+var_9], 0
0x0042615E | 48 C7 45 F8 00 00 00 00 | mov     [rbp+addr], 0
0x00426166 | 48 83 7D F8 00 | cmp     [rbp+addr], 0
0x0042616B | 74 06 | jz      short loc_426173
0x0042616D | C6 45 F7 01 | mov     [rbp+var_9], 1
0x00426171 | EB 38 | jmp     short loc_4261AB
0x00426173 | 48 8B 05 86 72 33 00 | mov     rax, cs:qword_75D400
0x0042617A | C7 00 0C 00 00 00 | mov     dword ptr [rax], 0Ch
0x00426180 | 48 8D 55 E8 | lea     rdx, [rbp+len]
0x00426184 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00426188 | 48 89 D6 | mov     rsi, rdx
0x0042618B | 48 89 C7 | mov     rdi, rax
0x0042618E | E8 19 D2 09 00 | call    sub_4C33AC
0x00426193 | 48 89 45 F8 | mov     [rbp+addr], rax
0x00426197 | 48 83 7D F8 00 | cmp     [rbp+addr], 0
0x0042619C | 75 0D | jnz     short loc_4261AB
0x0042619E | 48 8B 05 5B 72 33 00 | mov     rax, cs:qword_75D400
0x004261A5 | 8B 00 | mov     eax, [rax]
0x004261A7 | F7 D8 | neg     eax
0x004261A9 | EB 61 | jmp     short locret_42620C
0x004261AB | 48 8B 05 4E 72 33 00 | mov     rax, cs:qword_75D400
0x004261B2 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x004261B8 | 48 8B 55 E8 | mov     rdx, [rbp+len]
0x004261BC | 48 8B 4D D0 | mov     rcx, [rbp+var_30]
0x004261C0 | 48 8B 45 F8 | mov     rax, [rbp+addr]
0x004261C4 | 48 89 C6 | mov     rsi, rax
0x004261C7 | BF AF 00 00 00 | mov     edi, 0AFh; sysno
0x004261CC | B8 00 00 00 00 | mov     eax, 0
0x004261D1 | E8 1A 0F FE FF | call    _syscall
0x004261D6 | 48 8B 05 23 72 33 00 | mov     rax, cs:qword_75D400
0x004261DD | 8B 00 | mov     eax, [rax]
0x004261DF | 89 45 F0 | mov     [rbp+var_10], eax
0x004261E2 | 80 7D F7 00 | cmp     [rbp+var_9], 0
0x004261E6 | 74 15 | jz      short loc_4261FD
0x004261E8 | 48 8B 55 E8 | mov     rdx, [rbp+len]
0x004261EC | 48 8B 45 F8 | mov     rax, [rbp+addr]
0x004261F0 | 48 89 D6 | mov     rsi, rdx; len
0x004261F3 | 48 89 C7 | mov     rdi, rax; addr
0x004261F6 | E8 05 14 FE FF | call    _munmap
0x004261FB | EB 0C | jmp     short loc_426209
0x004261FD | 48 8B 45 F8 | mov     rax, [rbp+addr]
0x00426201 | 48 89 C7 | mov     rdi, rax; ptr
0x00426204 | E8 57 04 FE FF | call    _free
0x00426209 | 8B 45 F0 | mov     eax, [rbp+var_10]
0x0042620C | C9 | leave
0x0042620D | C3 | retn
 ************ 
Source Code:
int FAST_FUNC bb_init_module(const char *filename, const char *options)
{
	size_t image_size;
	char *image;
	int rc;
	bool mmaped;

	if (!options)
		options = "";

//TODO: audit bb_init_module_24 to match error code convention
#if ENABLE_FEATURE_2_4_MODULES
	if (get_linux_version_code() < KERNEL_VERSION(2,6,0))
		return bb_init_module_24(filename, options);
#endif

	image_size = INT_MAX - 4095;
	mmaped = 0;
	image = try_to_mmap_module(filename, &image_size);
	if (image) {
		mmaped = 1;
	} else {
		errno = ENOMEM; /* may be changed by e.g. open errors below */
		image = xmalloc_open_zipped_read_close(filename, &image_size);
		if (!image)
			return -errno;
	}

	errno = 0;
	init_module(image, image_size, options);
	rc = errno;
	if (mmaped)
		munmap(image, image_size);
	else
		free(image);
	return rc;
}
 ************ 
Parsed Output:
int performSystemCallWithMemoryCheck(void *data, const char *param) {
    const char *defaultParam;
    void *mappedAddr;
    int result;
    int hasMapped = 0;

    if (!param) {
        defaultParam = (const char *)0x52AA22;
    } else {
        defaultParam = param;
    }

    int len = 0x7FFFF000;

    mappedAddr = sub_4C33AC(data, &len);
    if (mappedAddr) {
        qword_75D400 = 0;
        result = _syscall(0xAF, mappedAddr, defaultParam, len);
        qword_75D400 = result;
        if (hasMapped) {
            _munmap(mappedAddr, len);
        }
    } else {
        result = -qword_75D400;
    }

    if (!hasMapped) {
        _free(mappedAddr);
    }

    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.5781257748603821
Func rank: 64

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: minix_clrbit
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00495E73 | 55 | push    rbp
0x00495E74 | 48 89 E5 | mov     rbp, rsp
0x00495E77 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x00495E7B | 89 75 F4 | mov     [rbp+var_C], esi
0x00495E7E | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00495E81 | C1 E8 03 | shr     eax, 3
0x00495E84 | 89 C6 | mov     esi, eax
0x00495E86 | 89 F2 | mov     edx, esi
0x00495E88 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00495E8C | 48 01 D0 | add     rax, rdx
0x00495E8F | 0F B6 10 | movzx   edx, byte ptr [rax]
0x00495E92 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x00495E95 | 83 E0 07 | and     eax, 7
0x00495E98 | BF 01 00 00 00 | mov     edi, 1
0x00495E9D | 89 C1 | mov     ecx, eax
0x00495E9F | D3 E7 | shl     edi, cl
0x00495EA1 | 89 F8 | mov     eax, edi
0x00495EA3 | F7 D0 | not     eax
0x00495EA5 | 89 C1 | mov     ecx, eax
0x00495EA7 | 89 F6 | mov     esi, esi
0x00495EA9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00495EAD | 48 01 F0 | add     rax, rsi
0x00495EB0 | 21 CA | and     edx, ecx
0x00495EB2 | 88 10 | mov     [rax], dl
0x00495EB4 | 48 8B 05 4D 75 2C 00 | mov     rax, cs:qword_75D408
0x00495EBB | C6 40 01 01 | mov     byte ptr [rax+1], 1
0x00495EBF | 90 | nop
0x00495EC0 | 5D | pop     rbp
0x00495EC1 | C3 | retn
 ************ 
Source Code:
static void minix_clrbit(char *a, unsigned i)
{
	clrbit(a, i);
	changed = 1;
}
 ************ 
Parsed Output:
void setBitInByteArray(char *array, int index) {
    int byteIndex = index >> 3;
    char *byteAddress = array + byteIndex;
    char currentByte = *byteAddress;
    
    int bitPosition = index & 7;
    char mask = 1 << bitPosition;
    mask = ~mask;
    
    currentByte &= mask;
    *byteAddress = currentByte;
    
    // The following line is setting a global or static variable, which is not shown in the assembly.
    // Assuming the variable is named 'globalFlag', and it's a byte located at an address that is
    // 1 byte offset from the pointer stored at a fixed address (cs:qword_75D408).
    *(char *)(*((char **)(&globalFlag) + 1)) = 1;
}
 ************ 
Similarity Score (Unixcoder): 0.5737420320510864
Func rank: 65

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: write_and_stats
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004C760C | 55 | push    rbp
0x004C760D | 48 89 E5 | mov     rbp, rsp
0x004C7610 | 48 83 EC 30 | sub     rsp, 30h
0x004C7614 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004C7618 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004C761C | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x004C7620 | 48 89 4D D0 | mov     [rbp+var_30], rcx
0x004C7624 | 48 8B 55 D0 | mov     rdx, [rbp+var_30]
0x004C7628 | 48 8B 4D E0 | mov     rcx, [rbp+var_20]
0x004C762C | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004C7630 | 48 89 CE | mov     rsi, rcx
0x004C7633 | 48 89 C7 | mov     rdi, rax
0x004C7636 | E8 81 FF FF FF | call    sub_4C75BC
0x004C763B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004C763F | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004C7644 | 79 07 | jns     short loc_4C764D
0x004C7646 | B8 01 00 00 00 | mov     eax, 1
0x004C764B | EB 51 | jmp     short locret_4C769E
0x004C764D | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004C7651 | 48 39 45 F8 | cmp     [rbp+var_8], rax
0x004C7655 | 75 11 | jnz     short loc_4C7668
0x004C7657 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004C765C | 48 8B 10 | mov     rdx, [rax]
0x004C765F | 48 83 C2 01 | add     rdx, 1
0x004C7663 | 48 89 10 | mov     [rax], rdx
0x004C7666 | EB 18 | jmp     short loc_4C7680
0x004C7668 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004C766D | 74 11 | jz      short loc_4C7680
0x004C766F | B8 F8 B3 75 00 | mov     eax, offset dest
0x004C7674 | 48 8B 50 08 | mov     rdx, [rax+8]
0x004C7678 | 48 83 C2 01 | add     rdx, 1
0x004C767C | 48 89 50 08 | mov     [rax+8], rdx
0x004C7680 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004C7685 | 48 8B 50 20 | mov     rdx, [rax+20h]
0x004C7689 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C768D | B9 F8 B3 75 00 | mov     ecx, offset dest
0x004C7692 | 48 01 D0 | add     rax, rdx
0x004C7695 | 48 89 41 20 | mov     [rcx+20h], rax
0x004C7699 | B8 00 00 00 00 | mov     eax, 0
0x004C769E | C9 | leave
0x004C769F | C3 | retn
 ************ 
Source Code:
static bool write_and_stats(const void *buf, size_t len, size_t obs,
	const char *filename)
{
	ssize_t n = full_write_or_warn(buf, len, filename);
	if (n < 0)
		return 1;
	if ((size_t)n == obs)
		G.out_full++;
	else if (n) /* > 0 */
		G.out_part++;
#if ENABLE_FEATURE_DD_THIRD_STATUS_LINE
	G.total_bytes += n;
#endif
	return 0;
}
 ************ 
Parsed Output:
int update_counters(void *var_18, void *var_20, void *var_28, void *var_30) {
    void *result = sub_4C75BC(var_18, var_20, var_30);
    if ((intptr_t)result < 0) {
        return 1;
    }

    if (result == var_28) {
        dest[0]++;
    } else if (result != 0) {
        dest[2]++;
    }

    dest[4] += (intptr_t)result;
    return 0;
}
 ************ 
Similarity Score (Unixcoder): 0.5713053941726685
Func rank: 66

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: getvar_i
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004DCB18 | 55 | push    rbp
0x004DCB19 | 48 89 E5 | mov     rbp, rsp
0x004DCB1C | 48 83 EC 20 | sub     rsp, 20h
0x004DCB20 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004DCB24 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DCB28 | 8B 00 | mov     eax, [rax]
0x004DCB2A | 25 01 01 00 00 | and     eax, 101h
0x004DCB2F | 85 C0 | test    eax, eax
0x004DCB31 | 0F 85 A8 00 00 00 | jnz     loc_4DCBDF
0x004DCB37 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DCB3B | 66 0F EF C0 | pxor    xmm0, xmm0
0x004DCB3F | F2 0F 11 40 08 | movsd   qword ptr [rax+8], xmm0
0x004DCB44 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DCB48 | 48 8B 40 10 | mov     rax, [rax+10h]
0x004DCB4C | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004DCB50 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004DCB54 | 48 85 C0 | test    rax, rax
0x004DCB57 | 74 61 | jz      short loc_4DCBBA
0x004DCB59 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004DCB5D | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004DCB60 | 84 C0 | test    al, al
0x004DCB62 | 74 56 | jz      short loc_4DCBBA
0x004DCB64 | 48 8D 45 F8 | lea     rax, [rbp+var_8]
0x004DCB68 | 48 89 C7 | mov     rdi, rax
0x004DCB6B | E8 13 FB FF FF | call    sub_4DC683
0x004DCB70 | 66 48 0F 7E C2 | movq    rdx, xmm0
0x004DCB75 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DCB79 | 48 89 50 08 | mov     [rax+8], rdx
0x004DCB7D | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DCB81 | 8B 00 | mov     eax, [rax]
0x004DCB83 | 25 00 02 00 00 | and     eax, 200h
0x004DCB88 | 85 C0 | test    eax, eax
0x004DCB8A | 74 41 | jz      short loc_4DCBCD
0x004DCB8C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004DCB90 | 48 89 C7 | mov     rdi, rax
0x004DCB93 | E8 6A F9 FF FF | call    sub_4DC502
0x004DCB98 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004DCB9C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004DCBA0 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004DCBA3 | 84 C0 | test    al, al
0x004DCBA5 | 74 26 | jz      short loc_4DCBCD
0x004DCBA7 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DCBAB | 8B 00 | mov     eax, [rax]
0x004DCBAD | 80 E4 FD | and     ah, 0FDh
0x004DCBB0 | 89 C2 | mov     edx, eax
0x004DCBB2 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DCBB6 | 89 10 | mov     [rax], edx
0x004DCBB8 | EB 13 | jmp     short loc_4DCBCD
0x004DCBBA | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DCBBE | 8B 00 | mov     eax, [rax]
0x004DCBC0 | 80 E4 FD | and     ah, 0FDh
0x004DCBC3 | 89 C2 | mov     edx, eax
0x004DCBC5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DCBC9 | 89 10 | mov     [rax], edx
0x004DCBCB | EB 01 | jmp     short loc_4DCBCE
0x004DCBCD | 90 | nop
0x004DCBCE | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DCBD2 | 8B 00 | mov     eax, [rax]
0x004DCBD4 | 80 CC 01 | or      ah, 1
0x004DCBD7 | 89 C2 | mov     edx, eax
0x004DCBD9 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DCBDD | 89 10 | mov     [rax], edx
0x004DCBDF | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DCBE3 | F2 0F 10 40 08 | movsd   xmm0, qword ptr [rax+8]
0x004DCBE8 | C9 | leave
0x004DCBE9 | C3 | retn
 ************ 
Source Code:
static double getvar_i(var *v)
{
	char *s;

	if ((v->type & (VF_NUMBER | VF_CACHED)) == 0) {
		v->number = 0;
		s = v->string;
		if (s && *s) {
			debug_printf_eval("getvar_i: '%s'->", s);
			v->number = my_strtod(&s);
			debug_printf_eval("%f (s:'%s')
", v->number, s);
			if (v->type & VF_USER) {
				s = skip_spaces(s);
				if (*s != '\0')
					v->type &= ~VF_USER;
			}
		} else {
			debug_printf_eval("getvar_i: '%s'->zero
", s);
			v->type &= ~VF_USER;
		}
		v->type |= VF_CACHED;
	}
	debug_printf_eval("getvar_i: %f
", v->number);
	return v->number;
}
 ************ 
Parsed Output:
void updateStatusAndValue(double *param) {
    if (*param & 0x101) {
        return;
    }

    *((double *)(param + 1)) = 0.0;
    char *str = *(char **)(param + 2);

    if (str && *str) {
        double value = sub_4DC683(&str);
        *((double *)(param + 1)) = value;

        if (*param & 0x200) {
            str = sub_4DC502(str);
            if (*str) {
                *param &= ~0x200;
            }
        }
    } else {
        *param &= ~0x200;
    }

    *param |= 0x1;
}
 ************ 
Similarity Score (Unixcoder): 0.5631956458091736
Func rank: 67

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: free_volume_id
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004A5BEA | 55 | push    rbp
0x004A5BEB | 48 89 E5 | mov     rbp, rsp
0x004A5BEE | 48 83 EC 10 | sub     rsp, 10h
0x004A5BF2 | 48 89 7D F8 | mov     [rbp+ptr], rdi
0x004A5BF6 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0
0x004A5BFB | 74 27 | jz      short loc_4A5C24
0x004A5BFD | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004A5C01 | 8B 00 | mov     eax, [rax]
0x004A5C03 | 89 C7 | mov     edi, eax; fd
0x004A5C05 | E8 06 12 F6 FF | call    _close
0x004A5C0A | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004A5C0E | 48 89 C7 | mov     rdi, rax
0x004A5C11 | E8 1B 27 00 00 | call    sub_4A8331
0x004A5C16 | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x004A5C1A | 48 89 C7 | mov     rdi, rax; ptr
0x004A5C1D | E8 3E 0A F6 FF | call    _free
0x004A5C22 | EB 01 | jmp     short locret_4A5C25
0x004A5C24 | 90 | nop
0x004A5C25 | C9 | leave
0x004A5C26 | C3 | retn
 ************ 
Source Code:
endif

void FAST_FUNC free_volume_id(struct volume_id *id)
{
	if (id == NULL)
		return;

	//if (id->fd_close != 0) - always true
		close(id->fd);
	volume_id_free_buffer(id);
#ifdef UNUSED_PARTITION_CODE
	free(id->partitions);
#endif
	free(id);
}
 ************ 
Parsed Output:
void closeAndFreeResource(void *ptr) {
    if (ptr != NULL) {
        close(*(int *)ptr);
        sub_4A8331(ptr);
        free(ptr);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.5604243278503418
Func rank: 68

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: overflow_safe_sub
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0045BF9C | 55 | push    rbp
0x0045BF9D | 48 89 E5 | mov     rbp, rsp
0x0045BFA0 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0045BFA4 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x0045BFA8 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0045BFAC | 48 2B 45 E8 | sub     rax, [rbp+var_18]
0x0045BFB0 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0045BFB4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045BFB8 | 48 85 C0 | test    rax, rax
0x0045BFBB | 79 19 | jns     short loc_45BFD6
0x0045BFBD | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x0045BFC2 | 48 39 45 E8 | cmp     [rbp+var_18], rax
0x0045BFC6 | 77 0E | ja      short loc_45BFD6
0x0045BFC8 | 48 B8 00 00 00 00 01 00 00 00 | mov     rax, 100000000h
0x0045BFD2 | 48 01 45 F8 | add     [rbp+var_8], rax
0x0045BFD6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045BFDA | 5D | pop     rbp
0x0045BFDB | C3 | retn
 ************ 
Source Code:
static ALWAYS_INLINE cputime_t overflow_safe_sub(cputime_t prev, cputime_t curr)
{
	cputime_t v = curr - prev;

	if ((icputime_t)v < 0     /* curr < prev - counter overflow? */
	 && prev <= 0xffffffff /* kernel uses 32bit value for the counter? */
	) {
		/* Add 33th bit set to 1 to curr, compensating for the overflow */
		/* double shift defeats "warning: left shift count >= width of type" */
		v += ((cputime_t)1 << 16) << 16;
	}
	return v;
}
 ************ 
Parsed Output:
unsigned long calculateDifferenceWithWraparound(unsigned long a, unsigned long b) {
    unsigned long difference = b - a;
    if (difference > 0xFFFFFFFF) {
        difference += 0x100000000;
    }
    return difference;
}
 ************ 
Similarity Score (Unixcoder): 0.5593568086624146
Func rank: 69

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: archivejoin
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00464F04 | 55 | push    rbp
0x00464F05 | 48 89 E5 | mov     rbp, rsp
0x00464F08 | 48 83 EC 40 | sub     rsp, 40h
0x00464F0C | 48 89 7D C8 | mov     [rbp+var_38], rdi
0x00464F10 | 48 89 75 C0 | mov     [rbp+var_40], rsi
0x00464F14 | 48 8B 4D C0 | mov     rcx, [rbp+var_40]
0x00464F18 | 48 8B 55 C8 | mov     rdx, [rbp+var_38]
0x00464F1C | 48 8D 45 D0 | lea     rax, [rbp+s]
0x00464F20 | BE 8D 62 53 00 | mov     esi, offset aSS_26; "%s/%s"
0x00464F25 | 48 89 C7 | mov     rdi, rax; s
0x00464F28 | B8 00 00 00 00 | mov     eax, 0
0x00464F2D | E8 4E 2B FA FF | call    _sprintf
0x00464F32 | 48 8D 45 D0 | lea     rax, [rbp+s]
0x00464F36 | 48 89 C7 | mov     rdi, rax
0x00464F39 | E8 A1 FE FF FF | call    sub_464DDF
0x00464F3E | 90 | nop
0x00464F3F | C9 | leave
0x00464F40 | C3 | retn
 ************ 
Source Code:
static void archivejoin(const char *sub, const char *name)
{
	char path[sizeof(long long)*3 + sizeof("/cmdline")];
	sprintf(path, "%s/%s", sub, name);
	archivefile(path);
}
 ************ 
Parsed Output:
#include <stdio.h>

void constructPathAndProcess(const char *baseDir, const char *subDir) {
    char s[64];
    sprintf(s, "%s/%s", baseDir, subDir);
    sub_464DDF(s);
}
 ************ 
Similarity Score (Unixcoder): 0.5509687662124634
Func rank: 70

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: add_inode
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0045B484 | 55 | push    rbp
0x0045B485 | 48 89 E5 | mov     rbp, rsp
0x0045B488 | 48 83 EC 20 | sub     rsp, 20h
0x0045B48C | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0045B490 | 48 C7 45 F8 00 B4 75 00 | mov     [rbp+var_8], offset dest.c_cflag
0x0045B498 | EB 3A | jmp     short loc_45B4D4
0x0045B49A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B49E | 48 8B 00 | mov     rax, [rax]
0x0045B4A1 | 48 8B 50 10 | mov     rdx, [rax+10h]
0x0045B4A5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0045B4A9 | 48 8B 00 | mov     rax, [rax]
0x0045B4AC | 48 39 C2 | cmp     rdx, rax
0x0045B4AF | 75 18 | jnz     short loc_45B4C9
0x0045B4B1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B4B5 | 48 8B 00 | mov     rax, [rax]
0x0045B4B8 | 48 8B 50 08 | mov     rdx, [rax+8]
0x0045B4BC | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0045B4C0 | 48 8B 40 08 | mov     rax, [rax+8]
0x0045B4C4 | 48 39 C2 | cmp     rdx, rax
0x0045B4C7 | 74 52 | jz      short loc_45B51B
0x0045B4C9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B4CD | 48 8B 00 | mov     rax, [rax]
0x0045B4D0 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0045B4D4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B4D8 | 48 8B 00 | mov     rax, [rax]
0x0045B4DB | 48 85 C0 | test    rax, rax
0x0045B4DE | 75 BA | jnz     short loc_45B49A
0x0045B4E0 | BF 18 00 00 00 | mov     edi, 18h
0x0045B4E5 | E8 FE EB FA FF | call    sub_40A0E8
0x0045B4EA | 48 89 C2 | mov     rdx, rax
0x0045B4ED | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B4F1 | 48 89 10 | mov     [rax], rdx
0x0045B4F4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B4F8 | 48 8B 00 | mov     rax, [rax]
0x0045B4FB | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x0045B4FF | 48 8B 12 | mov     rdx, [rdx]
0x0045B502 | 48 89 50 10 | mov     [rax+10h], rdx
0x0045B506 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0045B50A | 48 8B 00 | mov     rax, [rax]
0x0045B50D | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x0045B511 | 48 8B 52 08 | mov     rdx, [rdx+8]
0x0045B515 | 48 89 50 08 | mov     [rax+8], rdx
0x0045B519 | EB 01 | jmp     short locret_45B51C
0x0045B51B | 90 | nop
0x0045B51C | C9 | leave
0x0045B51D | C3 | retn
 ************ 
Source Code:
static void add_inode(const struct stat *st)
{
	inode_list **curr = &G.inode_list_head;

	while (*curr) {
		if ((*curr)->dev == st->st_dev
		 && (*curr)->inode == st->st_ino
		) {
			return;
		}
		curr = &(*curr)->next;
	}

	*curr = xzalloc(sizeof(inode_list));
	(*curr)->dev = st->st_dev;
	(*curr)->inode = st->st_ino;
}
 ************ 
Parsed Output:
typedef struct {
    void *data;
    void *next;
} Node;

void insertNodeAtBeginning(Node **head, Node *newNode) {
    if (head == NULL || newNode == NULL) {
        return;
    }

    while (*head != NULL) {
        head = &((*head)->next);
    }

    newNode->next = *head;
    newNode->data = (*head)->data;
    *head = newNode;
}
 ************ 
Similarity Score (Unixcoder): 0.5470060110092163
Func rank: 71

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: logdirs_reopen
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0046CD10 | 55 | push    rbp
0x0046CD11 | 48 89 E5 | mov     rbp, rsp
0x0046CD14 | 48 83 EC 10 | sub     rsp, 10h
0x0046CD18 | C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0
0x0046CD1F | 48 8B 05 E2 06 2F 00 | mov     rax, cs:qword_75D408
0x0046CD26 | C6 40 3C 00 | mov     byte ptr [rax+3Ch], 0
0x0046CD2A | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x0046CD31 | E9 8B 00 00 00 | jmp     loc_46CDC1
0x0046CD36 | 48 8B 05 CB 06 2F 00 | mov     rax, cs:qword_75D408
0x0046CD3D | 48 8B 08 | mov     rcx, [rax]
0x0046CD40 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0046CD43 | 48 63 D0 | movsxd  rdx, eax
0x0046CD46 | 48 89 D0 | mov     rax, rdx
0x0046CD49 | 48 01 C0 | add     rax, rax
0x0046CD4C | 48 01 D0 | add     rax, rdx
0x0046CD4F | 48 C1 E0 02 | shl     rax, 2
0x0046CD53 | 48 01 D0 | add     rax, rdx
0x0046CD56 | 48 C1 E0 03 | shl     rax, 3
0x0046CD5A | 48 01 C8 | add     rax, rcx
0x0046CD5D | 48 89 C7 | mov     rdi, rax
0x0046CD60 | E8 0B F6 FF FF | call    sub_46C370
0x0046CD65 | 48 8B 05 9C 06 2F 00 | mov     rax, cs:qword_75D408
0x0046CD6C | 48 8B 40 18 | mov     rax, [rax+18h]
0x0046CD70 | 8B 55 FC | mov     edx, [rbp+var_4]
0x0046CD73 | 48 63 D2 | movsxd  rdx, edx
0x0046CD76 | 48 C1 E2 03 | shl     rdx, 3
0x0046CD7A | 48 01 D0 | add     rax, rdx
0x0046CD7D | 48 8B 08 | mov     rcx, [rax]
0x0046CD80 | 48 8B 05 81 06 2F 00 | mov     rax, cs:qword_75D408
0x0046CD87 | 48 8B 30 | mov     rsi, [rax]
0x0046CD8A | 8B 45 FC | mov     eax, [rbp+var_4]
0x0046CD8D | 48 63 D0 | movsxd  rdx, eax
0x0046CD90 | 48 89 D0 | mov     rax, rdx
0x0046CD93 | 48 01 C0 | add     rax, rax
0x0046CD96 | 48 01 D0 | add     rax, rdx
0x0046CD99 | 48 C1 E0 02 | shl     rax, 2
0x0046CD9D | 48 01 D0 | add     rax, rdx
0x0046CDA0 | 48 C1 E0 03 | shl     rax, 3
0x0046CDA4 | 48 01 F0 | add     rax, rsi
0x0046CDA7 | 48 89 CE | mov     rsi, rcx
0x0046CDAA | 48 89 C7 | mov     rdi, rax
0x0046CDAD | E8 FF F6 FF FF | call    sub_46C4B1
0x0046CDB2 | 85 C0 | test    eax, eax
0x0046CDB4 | 74 07 | jz      short loc_46CDBD
0x0046CDB6 | C7 45 F8 01 00 00 00 | mov     [rbp+var_8], 1
0x0046CDBD | 83 45 FC 01 | add     [rbp+var_4], 1
0x0046CDC1 | 48 8B 05 40 06 2F 00 | mov     rax, cs:qword_75D408
0x0046CDC8 | 8B 50 4C | mov     edx, [rax+4Ch]
0x0046CDCB | 8B 45 FC | mov     eax, [rbp+var_4]
0x0046CDCE | 39 C2 | cmp     edx, eax
0x0046CDD0 | 0F 87 60 FF FF FF | ja      loc_46CD36
0x0046CDD6 | 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0046CDDA | 75 0A | jnz     short loc_46CDE6
0x0046CDDC | BF 68 68 52 00 | mov     edi, offset aNoFunctionalLo; "no functional log directories"
0x0046CDE1 | E8 E0 E3 FF FF | call    sub_46B1C6
0x0046CDE6 | 90 | nop
0x0046CDE7 | C9 | leave
0x0046CDE8 | C3 | retn
 ************ 
Source Code:
static void logdirs_reopen(void)
{
	int l;
	int ok = 0;

	tmaxflag = 0;
	for (l = 0; l < dirn; ++l) {
		logdir_close(&dir[l]);
		if (logdir_open(&dir[l], fndir[l]))
			ok = 1;
	}
	if (!ok)
		fatalx("no functional log directories");
}
 ************ 
Parsed Output:
void processLogDirectories() {
    int flag = 0;
    int index = 0;
    void* baseAddress = qword_75D408; // Assuming qword_75D408 is a global variable or a memory-mapped register

    *(char*)(baseAddress + 0x3C) = 0;

    while (index < *(int*)(baseAddress + 0x4C)) {
        void* entryAddress = *(void**)(baseAddress) + (index * 56);
        sub_46C370(entryAddress);

        void* logAddress = *(void**)(baseAddress + 0x18) + (index * 8);
        void* logEntry = *(void**)logAddress;
        void* baseEntry = *(void**)baseAddress + (index * 56);

        if (sub_46C4B1(logEntry, baseEntry)) {
            flag = 1;
        }

        index++;
    }

    if (flag == 0) {
        sub_46B1C6("no functional log directories");
    }
}
 ************ 
Similarity Score (Unixcoder): 0.5368103384971619
Func rank: 72

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: catcher
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0042727C | 55 | push    rbp
0x0042727D | 48 89 E5 | mov     rbp, rsp
0x00427280 | 48 83 EC 10 | sub     rsp, 10h
0x00427284 | E8 DE 49 FE FF | call    sub_40BC67
0x00427289 | 89 45 FC | mov     [rbp+var_4], eax
0x0042728C | B8 F8 B3 75 00 | mov     eax, offset dest
0x00427291 | 8B 40 40 | mov     eax, [rax+40h]
0x00427294 | 85 C0 | test    eax, eax
0x00427296 | 75 0B | jnz     short loc_4272A3
0x00427298 | BA F8 B3 75 00 | mov     edx, offset dest
0x0042729D | 8B 45 FC | mov     eax, [rbp+var_4]
0x004272A0 | 89 42 40 | mov     [rdx+40h], eax
0x004272A3 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004272A8 | 8B 40 34 | mov     eax, [rax+34h]
0x004272AB | 85 C0 | test    eax, eax
0x004272AD | 74 25 | jz      short loc_4272D4
0x004272AF | B8 F8 B3 75 00 | mov     eax, offset dest
0x004272B4 | 8B 40 3C | mov     eax, [rax+3Ch]
0x004272B7 | 85 C0 | test    eax, eax
0x004272B9 | 74 1E | jz      short loc_4272D9
0x004272BB | B8 F8 B3 75 00 | mov     eax, offset dest
0x004272C0 | 8B 40 40 | mov     eax, [rax+40h]
0x004272C3 | 8B 55 FC | mov     edx, [rbp+var_4]
0x004272C6 | 29 C2 | sub     edx, eax
0x004272C8 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004272CD | 8B 40 3C | mov     eax, [rax+3Ch]
0x004272D0 | 39 C2 | cmp     edx, eax
0x004272D2 | 76 05 | jbe     short loc_4272D9
0x004272D4 | E8 E0 FE FF FF | call    sub_4271B9
0x004272D9 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004272DE | 8B 40 34 | mov     eax, [rax+34h]
0x004272E1 | 85 C0 | test    eax, eax
0x004272E3 | 7E 0E | jle     short loc_4272F3
0x004272E5 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004272EA | 8B 50 34 | mov     edx, [rax+34h]
0x004272ED | 83 EA 01 | sub     edx, 1
0x004272F0 | 89 50 34 | mov     [rax+34h], edx
0x004272F3 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004272F8 | 8B 40 38 | mov     eax, [rax+38h]
0x004272FB | 85 C0 | test    eax, eax
0x004272FD | 74 16 | jz      short loc_427315
0x004272FF | B8 F8 B3 75 00 | mov     eax, offset dest
0x00427304 | 8B 40 38 | mov     eax, [rax+38h]
0x00427307 | 8B 55 FC | mov     edx, [rbp+var_4]
0x0042730A | 29 C2 | sub     edx, eax
0x0042730C | 89 D0 | mov     eax, edx
0x0042730E | 3D 20 A1 07 00 | cmp     eax, 7A120h
0x00427313 | 76 3A | jbe     short loc_42734F
0x00427315 | B9 14 B4 75 00 | mov     ecx, 75B414h
0x0042731A | BA 00 B4 75 00 | mov     edx, offset dest.c_cflag
0x0042731F | B8 FC B3 75 00 | mov     eax, 75B3FCh
0x00427324 | 48 89 C6 | mov     rsi, rax
0x00427327 | BF F8 B3 75 00 | mov     edi, offset dest
0x0042732C | E8 7C FC FF FF | call    sub_426FAD
0x00427331 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00427336 | 8B 40 34 | mov     eax, [rax+34h]
0x00427339 | 85 C0 | test    eax, eax
0x0042733B | 75 12 | jnz     short loc_42734F
0x0042733D | 8B 05 0D 61 33 00 | mov     eax, cs:dword_75D450
0x00427343 | 83 E0 02 | and     eax, 2
0x00427346 | 85 C0 | test    eax, eax
0x00427348 | 74 05 | jz      short loc_42734F
0x0042734A | E8 6A FE FF FF | call    sub_4271B9
0x0042734F | BF 01 00 00 00 | mov     edi, 1; seconds
0x00427354 | E8 97 FA FD FF | call    _alarm
0x00427359 | 90 | nop
0x0042735A | C9 | leave
0x0042735B | C3 | retn
 ************ 
Source Code:
static void catcher(void)
{
	unsigned now;

	now = MONOTONIC_US();
	if (start == 0)
		start = now;

	if (count == 0 || (timeout_us && (now - start) > timeout_us))
		finish();

	/* count < 0 means "infinite count" */
	if (count > 0)
		count--;

	if (last == 0 || (now - last) > 500000) {
		send_pack(&src, &dst, &me, &he);
		if (count == 0 && (option_mask32 & UNSOLICITED))
			finish();
	}
	alarm(1);
}
 ************ 
Parsed Output:
typedef struct {
    int field_34;
    int field_38;
    int field_3C;
    int field_40;
    // other fields might be present, but are not accessed by this function
} DestStruct;

extern DestStruct dest;
extern int sub_40BC67();
extern void sub_4271B9();
extern void sub_426FAD(DestStruct *dest, int param_2, int param_3, int param_4);
extern int dword_75D450;
extern void _alarm(int seconds);

void updateDestStruct() {
    int result = sub_40BC67();
    if (dest.field_40 == 0) {
        dest.field_40 = result;
    }

    if (dest.field_34 != 0) {
        if (dest.field_3C != 0) {
            int diff = result - dest.field_40;
            if (diff > dest.field_3C) {
                sub_4271B9();
            }
        }
    } else {
        sub_4271B9();
    }

    if (dest.field_34 > 0) {
        dest.field_34 -= 1;
    }

    if (dest.field_38 != 0) {
        int diff = result - dest.field_38;
        if (diff > 0x7A120) {
            sub_426FAD(&dest, 0x75B414, (int)&dest.c_cflag, 0x75B3FC);
        }
    }

    if (dest.field_34 == 0) {
        if ((dword_75D450 & 2) != 0) {
            sub_4271B9();
        }
    }

    _alarm(1);
}
 ************ 
Similarity Score (Unixcoder): 0.5278784036636353
Func rank: 73

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: wget_main
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00447FE0 | 55 | push    rbp
0x00447FE1 | 48 89 E5 | mov     rbp, rsp
0x00447FE4 | 53 | push    rbx
0x00447FE5 | 48 83 EC 38 | sub     rsp, 38h
0x00447FE9 | 89 7D CC | mov     [rbp+var_34], edi
0x00447FEC | 48 89 75 C0 | mov     [rbp+var_40], rsi
0x00447FF0 | 48 C7 45 D0 00 00 00 00 | mov     [rbp+var_30], 0
0x00447FF8 | BB 08 D4 75 00 | mov     ebx, offset qword_75D408
0x00447FFD | BF 80 10 00 00 | mov     edi, 1080h
0x00448002 | E8 E1 20 FC FF | call    sub_40A0E8
0x00448007 | 48 89 03 | mov     [rbx], rax
0x0044800A | 48 8B 05 F7 53 31 00 | mov     rax, cs:qword_75D408
0x00448011 | C7 40 68 84 03 00 00 | mov     dword ptr [rax+68h], 384h
0x00448018 | 48 8B 05 E9 53 31 00 | mov     rax, cs:qword_75D408
0x0044801F | C7 40 68 84 03 00 00 | mov     dword ptr [rax+68h], 384h
0x00448026 | 48 8B 05 DB 53 31 00 | mov     rax, cs:qword_75D408
0x0044802D | 48 C7 40 58 4C C1 52 00 | mov     qword ptr [rax+58h], offset aOn_0; "on"
0x00448035 | 48 8B 05 CC 53 31 00 | mov     rax, cs:qword_75D408
0x0044803C | 48 C7 40 60 4F C1 52 00 | mov     qword ptr [rax+60h], offset aWget; "Wget"
0x00448044 | 48 C7 05 F9 53 31 00 9E C1 52 00 | mov     cs:qword_75D448, offset aContinue_0; "continue"
0x0044804F | 48 C7 05 E6 53 31 00 54 C1 52 00 | mov     cs:qword_75D440, offset unk_52C154
0x0044805A | 48 8B 05 A7 53 31 00 | mov     rax, cs:qword_75D408
0x00448061 | 48 8D 50 40 | lea     rdx, [rax+40h]
0x00448065 | 48 8B 05 9C 53 31 00 | mov     rax, cs:qword_75D408
0x0044806C | 48 8D 78 68 | lea     rdi, [rax+68h]
0x00448070 | 48 8B 05 91 53 31 00 | mov     rax, cs:qword_75D408
0x00448077 | 4C 8D 48 60 | lea     r9, [rax+60h]
0x0044807B | 48 8B 05 86 53 31 00 | mov     rax, cs:qword_75D408
0x00448082 | 4C 8D 40 58 | lea     r8, [rax+58h]
0x00448086 | 48 8B 05 7B 53 31 00 | mov     rax, cs:qword_75D408
0x0044808D | 48 8D 48 38 | lea     rcx, [rax+38h]
0x00448091 | 48 8B 05 70 53 31 00 | mov     rax, cs:qword_75D408
0x00448098 | 48 8D 70 50 | lea     rsi, [rax+50h]
0x0044809C | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004480A0 | 52 | push    rdx
0x004480A1 | 48 8D 55 D0 | lea     rdx, [rbp+var_30]
0x004480A5 | 52 | push    rdx
0x004480A6 | 6A 00 | push    0
0x004480A8 | 57 | push    rdi
0x004480A9 | 48 89 F2 | mov     rdx, rsi
0x004480AC | BE 5E C1 52 00 | mov     esi, offset aCsqoPYUTT; "csqO:P:Y:U:T:t:"
0x004480B1 | 48 89 C7 | mov     rdi, rax
0x004480B4 | B8 00 00 00 00 | mov     eax, 0
0x004480B9 | E8 31 21 0B 00 | call    sub_4FA1EF
0x004480BE | 48 83 C4 20 | add     rsp, 20h
0x004480C2 | 8B 05 B0 2D 31 00 | mov     eax, cs:optind
0x004480C8 | 48 98 | cdqe
0x004480CA | 48 C1 E0 03 | shl     rax, 3
0x004480CE | 48 01 45 C0 | add     [rbp+var_40], rax
0x004480D2 | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004480D6 | 48 85 C0 | test    rax, rax
0x004480D9 | 0F 84 96 00 00 00 | jz      loc_448175
0x004480DF | C7 45 EC 01 00 00 00 | mov     [rbp+var_14], 1
0x004480E6 | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004480EA | 48 89 45 D8 | mov     [rbp+var_28], rax
0x004480EE | EB 28 | jmp     short loc_448118
0x004480F0 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004480F4 | 48 8B 40 08 | mov     rax, [rax+8]
0x004480F8 | 48 89 C7 | mov     rdi, rax; s
0x004480FB | E8 D0 E9 FB FF | call    _strlen
0x00448100 | 89 C2 | mov     edx, eax
0x00448102 | 8B 45 EC | mov     eax, [rbp+var_14]
0x00448105 | 01 D0 | add     eax, edx
0x00448107 | 83 C0 02 | add     eax, 2
0x0044810A | 89 45 EC | mov     [rbp+var_14], eax
0x0044810D | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x00448111 | 48 8B 00 | mov     rax, [rax]
0x00448114 | 48 89 45 D8 | mov     [rbp+var_28], rax
0x00448118 | 48 83 7D D8 00 | cmp     [rbp+var_28], 0
0x0044811D | 75 D1 | jnz     short loc_4480F0
0x0044811F | 8B 45 EC | mov     eax, [rbp+var_14]
0x00448122 | 48 98 | cdqe
0x00448124 | 48 89 C7 | mov     rdi, rax
0x00448127 | E8 33 1F FC FF | call    sub_40A05F
0x0044812C | 48 89 45 E0 | mov     [rbp+s], rax
0x00448130 | 48 8B 05 D1 52 31 00 | mov     rax, cs:qword_75D408
0x00448137 | 48 8B 55 E0 | mov     rdx, [rbp+s]
0x0044813B | 48 89 50 48 | mov     [rax+48h], rdx
0x0044813F | EB 2B | jmp     short loc_44816C
0x00448141 | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00448145 | 48 89 C7 | mov     rdi, rax
0x00448148 | E8 1A 0F FC FF | call    sub_409067
0x0044814D | 48 89 C2 | mov     rdx, rax
0x00448150 | 48 8B 45 E0 | mov     rax, [rbp+s]
0x00448154 | BE 6E C1 52 00 | mov     esi, offset aS_37; "%s\r\n"
0x00448159 | 48 89 C7 | mov     rdi, rax; s
0x0044815C | B8 00 00 00 00 | mov     eax, 0
0x00448161 | E8 1A F9 FB FF | call    _sprintf
0x00448166 | 48 98 | cdqe
0x00448168 | 48 01 45 E0 | add     [rbp+s], rax
0x0044816C | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x00448170 | 48 85 C0 | test    rax, rax
0x00448173 | 75 CC | jnz     short loc_448141
0x00448175 | 48 8B 05 8C 52 31 00 | mov     rax, cs:qword_75D408
0x0044817C | C7 40 6C FF FF FF FF | mov     dword ptr [rax+6Ch], 0FFFFFFFFh
0x00448183 | 48 8B 05 7E 52 31 00 | mov     rax, cs:qword_75D408
0x0044818A | C7 40 70 C1 02 00 00 | mov     dword ptr [rax+70h], 2C1h
0x00448191 | 48 8B 05 70 52 31 00 | mov     rax, cs:qword_75D408
0x00448198 | 48 8B 40 50 | mov     rax, [rax+50h]
0x0044819C | 48 85 C0 | test    rax, rax
0x0044819F | 74 6C | jz      short loc_44820D
0x004481A1 | 48 8B 05 60 52 31 00 | mov     rax, cs:qword_75D408
0x004481A8 | 48 8B 40 50 | mov     rax, [rax+50h]
0x004481AC | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004481AF | 3C 2D | cmp     al, 2Dh ; '-'
0x004481B1 | 75 33 | jnz     short loc_4481E6
0x004481B3 | 48 8B 05 4E 52 31 00 | mov     rax, cs:qword_75D408
0x004481BA | 48 8B 40 50 | mov     rax, [rax+50h]
0x004481BE | 48 83 C0 01 | add     rax, 1
0x004481C2 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x004481C5 | 84 C0 | test    al, al
0x004481C7 | 75 1D | jnz     short loc_4481E6
0x004481C9 | 48 8B 05 38 52 31 00 | mov     rax, cs:qword_75D408
0x004481D0 | C7 40 6C 01 00 00 00 | mov     dword ptr [rax+6Ch], 1
0x004481D7 | 8B 05 73 52 31 00 | mov     eax, cs:dword_75D450
0x004481DD | 83 E0 FE | and     eax, 0FFFFFFFEh
0x004481E0 | 89 05 6A 52 31 00 | mov     cs:dword_75D450, eax
0x004481E6 | 48 8B 05 1B 52 31 00 | mov     rax, cs:qword_75D408
0x004481ED | C7 40 70 41 02 00 00 | mov     dword ptr [rax+70h], 241h
0x004481F4 | EB 17 | jmp     short loc_44820D
0x004481F6 | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x004481FA | 48 8D 50 08 | lea     rdx, [rax+8]
0x004481FE | 48 89 55 C0 | mov     [rbp+var_40], rdx
0x00448202 | 48 8B 00 | mov     rax, [rax]
0x00448205 | 48 89 C7 | mov     rdi, rax
0x00448208 | E8 0A F4 FF FF | call    sub_447617
0x0044820D | 48 8B 45 C0 | mov     rax, [rbp+var_40]
0x00448211 | 48 8B 00 | mov     rax, [rax]
0x00448214 | 48 85 C0 | test    rax, rax
0x00448217 | 75 DD | jnz     short loc_4481F6
0x00448219 | 48 8B 05 E8 51 31 00 | mov     rax, cs:qword_75D408
0x00448220 | 8B 40 6C | mov     eax, [rax+6Ch]
0x00448223 | 85 C0 | test    eax, eax
0x00448225 | 78 11 | js      short loc_448238
0x00448227 | 48 8B 05 DA 51 31 00 | mov     rax, cs:qword_75D408
0x0044822E | 8B 40 6C | mov     eax, [rax+6Ch]
0x00448231 | 89 C7 | mov     edi, eax
0x00448233 | E8 F4 22 FC FF | call    sub_40A52C
0x00448238 | B8 00 00 00 00 | mov     eax, 0
0x0044823D | 48 8B 5D F8 | mov     rbx, [rbp+var_8]
0x00448241 | C9 | leave
0x00448242 | C3 | retn
 ************ 
Source Code:
int wget_main(int argc UNUSED_PARAM, char **argv)
{
#if ENABLE_FEATURE_WGET_LONG_OPTIONS
	static const char wget_longopts[] ALIGN1 =
		/* name, has_arg, val */
		"continue\0"         No_argument       "c"
//FIXME: -s isn't --spider, it's --save-headers!
		"spider\0"           No_argument       "s"
		"quiet\0"            No_argument       "q"
		"output-document\0"  Required_argument "O"
		"directory-prefix\0" Required_argument "P"
		"proxy\0"            Required_argument "Y"
		"user-agent\0"       Required_argument "U"
#if ENABLE_FEATURE_WGET_TIMEOUT
		"timeout\0"          Required_argument "T"
#endif
		/* Ignored: */
		// "tries\0"            Required_argument "t"
		/* Ignored (we always use PASV): */
		"passive-ftp\0"      No_argument       "\xff"
		"header\0"           Required_argument "\xfe"
		"post-data\0"        Required_argument "\xfd"
		/* Ignored (we don't do ssl) */
		"no-check-certificate\0" No_argument   "\xfc"
		/* Ignored (we don't support caching) */
		"no-cache\0"         No_argument       "\xfb"
		;
#endif

#if ENABLE_FEATURE_WGET_LONG_OPTIONS
	llist_t *headers_llist = NULL;
#endif

	INIT_G();

	IF_FEATURE_WGET_TIMEOUT(G.timeout_seconds = 900;)
	G.proxy_flag = "on";   /* use proxies if env vars are set */
	G.user_agent = "Wget"; /* "User-Agent" header field */

#if ENABLE_FEATURE_WGET_LONG_OPTIONS
	applet_long_options = wget_longopts;
#endif
	opt_complementary = "-1" IF_FEATURE_WGET_TIMEOUT(":T+") IF_FEATURE_WGET_LONG_OPTIONS(":\xfe::");
	getopt32(argv, "csqO:P:Y:U:T:" /*ignored:*/ "t:",
		&G.fname_out, &G.dir_prefix,
		&G.proxy_flag, &G.user_agent,
		IF_FEATURE_WGET_TIMEOUT(&G.timeout_seconds) IF_NOT_FEATURE_WGET_TIMEOUT(NULL),
		NULL /* -t RETRIES */
		IF_FEATURE_WGET_LONG_OPTIONS(, &headers_llist)
		IF_FEATURE_WGET_LONG_OPTIONS(, &G.post_data)
	);
	argv += optind;

#if ENABLE_FEATURE_WGET_LONG_OPTIONS
	if (headers_llist) {
		int size = 1;
		char *cp;
		llist_t *ll = headers_llist;
		while (ll) {
			size += strlen(ll->data) + 2;
			ll = ll->link;
		}
		G.extra_headers = cp = xmalloc(size);
		while (headers_llist) {
			cp += sprintf(cp, "%s\r
", (char*)llist_pop(&headers_llist));
		}
	}
#endif

	G.output_fd = -1;
	G.o_flags = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL;
	if (G.fname_out) { /* -O FILE ? */
		if (LONE_DASH(G.fname_out)) { /* -O - ? */
			G.output_fd = 1;
			option_mask32 &= ~WGET_OPT_CONTINUE;
		}
		/* compat with wget: -O FILE can overwrite */
		G.o_flags = O_WRONLY | O_CREAT | O_TRUNC;
	}

	while (*argv)
		download_one_url(*argv++);

	if (G.output_fd >= 0)
		xclose(G.output_fd);

	return EXIT_SUCCESS;
}
 ************ 
Parsed Output:
#include <stdio.h>
#include <string.h>

void initializeSettings() {
    void *settings = sub_40A0E8(0x1080);
    qword_75D408 = settings;
    *((int *)(settings + 0x68)) = 0x384;
    *((int *)(settings + 0x68)) = 0x384; // Redundant, same as above
    *((const char **)(settings + 0x58)) = "on";
    *((const char **)(settings + 0x60)) = "Wget";
    qword_75D448 = "continue";
    qword_75D440 = unk_52C154;
    char **argv = var_40;
    int argc = sub_4FA1EF(argv, "csqO:P:Y:U:T:t:", NULL, NULL, 0);
    argv += optind;
    char **arg = var_30;
    if (arg) {
        int total_length = 1;
        char *current_arg;
        while ((current_arg = *arg++)) {
            total_length += strlen(current_arg) + 2;
        }
        char *s = sub_40A05F(total_length);
        qword_75D408->field_48 = s;
        do {
            char *next_arg = sub_409067(arg);
            sprintf(s, "%s\r
", next_arg);
            s += strlen(next_arg) + 2;
        } while (*arg);
    }
    int status = qword_75D408->field_6C;
    if (status >= 0) {
        if (qword_75D408->field_50) {
            if (*qword_75D408->field_50 == '-') {
                if (!qword_75D408->field_50[1]) {
                    qword_75D408->field_6C = 1;
                    dword_75D450 &= 0xFFFFFFFE;
                }
            } else {
                qword_75D408->field_70 = 0x241;
            }
        }
        while ((arg = *argv++)) {
            sub_447617(arg);
        }
        status = qword_75D408->field_6C;
        if (status >= 0) {
            sub_40A52C(status);
        }
    }
}
 ************ 
Similarity Score (Unixcoder): 0.5265107750892639
Func rank: 74

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: change_identity
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004F6569 | 55 | push    rbp
0x004F656A | 48 89 E5 | mov     rbp, rsp
0x004F656D | 48 83 EC 10 | sub     rsp, 10h
0x004F6571 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004F6575 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F6579 | 8B 50 14 | mov     edx, [rax+14h]
0x004F657C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F6580 | 48 8B 00 | mov     rax, [rax]
0x004F6583 | 89 D6 | mov     esi, edx
0x004F6585 | 48 89 C7 | mov     rdi, rax
0x004F6588 | E8 5F 63 F1 FF | call    sub_40C8EC
0x004F658D | 83 F8 FF | cmp     eax, 0FFFFFFFFh
0x004F6590 | 75 0F | jnz     short loc_4F65A1
0x004F6592 | BF 1F 72 53 00 | mov     edi, offset aCanTSetGroups; "can't set groups"
0x004F6597 | B8 00 00 00 00 | mov     eax, 0
0x004F659C | E8 01 2D F1 FF | call    sub_4092A2
0x004F65A1 | E8 42 61 F1 FF | call    sub_40C6E8
0x004F65A6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F65AA | 8B 40 14 | mov     eax, [rax+14h]
0x004F65AD | 89 C7 | mov     edi, eax
0x004F65AF | E8 9D 42 F1 FF | call    sub_40A851
0x004F65B4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F65B8 | 8B 40 10 | mov     eax, [rax+10h]
0x004F65BB | 89 C7 | mov     edi, eax
0x004F65BD | E8 BA 42 F1 FF | call    sub_40A87C
0x004F65C2 | 90 | nop
0x004F65C3 | C9 | leave
0x004F65C4 | C3 | retn
 ************ 
Source Code:
void FAST_FUNC change_identity(const struct passwd *pw)
{
	if (initgroups(pw->pw_name, pw->pw_gid) == -1)
		bb_perror_msg_and_die("can't set groups");
	endgrent(); /* helps to close a fd used internally by libc */
	xsetgid(pw->pw_gid);
	xsetuid(pw->pw_uid);
}
 ************ 
Parsed Output:
void setGroupsAndPerformActions(void *ptr) {
    int group_id = *((int *)(ptr + 0x14));
    void *object = *(void **)ptr;

    if (sub_40C8EC(object, group_id) == -1) {
        sub_4092A2("can't set groups", 0);
    }

    sub_40C6E8();
    group_id = *((int *)(ptr + 0x14));
    sub_40A851(group_id);

    int action_id = *((int *)(ptr + 0x10));
    sub_40A87C(action_id);
}
 ************ 
Similarity Score (Unixcoder): 0.5263287425041199
Func rank: 75

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: evalcmd
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0047DEBD | 55 | push    rbp
0x0047DEBE | 48 89 E5 | mov     rbp, rsp
0x0047DEC1 | 48 83 EC 20 | sub     rsp, 20h
0x0047DEC5 | 89 7D EC | mov     [rbp+var_14], edi
0x0047DEC8 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x0047DECC | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0047DED0 | 48 83 C0 08 | add     rax, 8
0x0047DED4 | 48 8B 00 | mov     rax, [rax]
0x0047DED7 | 48 85 C0 | test    rax, rax
0x0047DEDA | 0F 84 C0 00 00 00 | jz      loc_47DFA0
0x0047DEE0 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0047DEE4 | 48 8B 40 08 | mov     rax, [rax+8]
0x0047DEE8 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0047DEEC | 48 83 45 E0 10 | add     [rbp+var_20], 10h
0x0047DEF1 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0047DEF5 | 48 8B 00 | mov     rax, [rax]
0x0047DEF8 | 48 85 C0 | test    rax, rax
0x0047DEFB | 0F 84 8E 00 00 00 | jz      loc_47DF8F
0x0047DF01 | 48 8B 05 20 F5 2D 00 | mov     rax, cs:qword_75D428
0x0047DF08 | 48 8B 40 10 | mov     rax, [rax+10h]
0x0047DF0C | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0047DF10 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x0047DF14 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0047DF18 | 48 89 D6 | mov     rsi, rdx
0x0047DF1B | 48 89 C7 | mov     rdi, rax
0x0047DF1E | E8 65 0E FF FF | call    sub_46ED88
0x0047DF23 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0047DF27 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x0047DF2B | 48 8D 50 08 | lea     rdx, [rax+8]
0x0047DF2F | 48 89 55 E0 | mov     [rbp+var_20], rdx
0x0047DF33 | 48 8B 00 | mov     rax, [rax]
0x0047DF36 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0047DF3A | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0047DF3F | 74 17 | jz      short loc_47DF58
0x0047DF41 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0047DF45 | 48 89 C6 | mov     rsi, rax
0x0047DF48 | BF 20 00 00 00 | mov     edi, 20h ; ' '
0x0047DF4D | E8 6A 0E FF FF | call    sub_46EDBC
0x0047DF52 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0047DF56 | EB B8 | jmp     short loc_47DF10
0x0047DF58 | 90 | nop
0x0047DF59 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0047DF5D | 48 89 C6 | mov     rsi, rax
0x0047DF60 | BF 00 00 00 00 | mov     edi, 0
0x0047DF65 | E8 52 0E FF FF | call    sub_46EDBC
0x0047DF6A | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0047DF6E | 48 8B 05 B3 F4 2D 00 | mov     rax, cs:qword_75D428
0x0047DF75 | 48 8B 40 10 | mov     rax, [rax+10h]
0x0047DF79 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]
0x0047DF7D | 48 29 C2 | sub     rdx, rax
0x0047DF80 | 48 89 D0 | mov     rax, rdx
0x0047DF83 | 48 89 C7 | mov     rdi, rax
0x0047DF86 | E8 1D 07 FF FF | call    sub_46E6A8
0x0047DF8B | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0047DF8F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0047DF93 | BE EF FF FF FF | mov     esi, 0FFFFFFEFh
0x0047DF98 | 48 89 C7 | mov     rdi, rax
0x0047DF9B | E8 8C FE FF FF | call    sub_47DE2C
0x0047DFA0 | 0F B6 05 A9 CF 2D 00 | movzx   eax, cs:byte_75AF50
0x0047DFA7 | 0F B6 C0 | movzx   eax, al
0x0047DFAA | C9 | leave
0x0047DFAB | C3 | retn
 ************ 
Source Code:
static int FAST_FUNC
evalcmd(int argc UNUSED_PARAM, char **argv)
{
	char *p;
	char *concat;

	if (argv[1]) {
		p = argv[1];
		argv += 2;
		if (argv[0]) {
			STARTSTACKSTR(concat);
			for (;;) {
				concat = stack_putstr(p, concat);
				p = *argv++;
				if (p == NULL)
					break;
				STPUTC(' ', concat);
			}
			STPUTC('\0', concat);
			p = grabstackstr(concat);
		}
		evalstring(p, ~SKIPEVAL);
	}
	return exitstatus;
}
 ************ 
Parsed Output:
int processInput(int input, char **array) {
    char *data;
    char *result;
    int length;

    if (array[1] == NULL) {
        return byte_75AF50;
    }

    data = array[1];
    array += 2;

    if (*array == NULL) {
        return byte_75AF50;
    }

    result = sub_46ED88(data, qword_75D428[2]);

    while (*array != NULL) {
        result = sub_46EDBC(result, ' ');
        data = *array++;
        result = sub_46ED88(result, data);
    }

    result = sub_46EDBC(result, 0);
    length = result - qword_75D428[2];
    result = sub_46E6A8(length);
    sub_47DE2C(result, 0xFFFFFFEF);

    return byte_75AF50;
}
 ************ 
Similarity Score (Unixcoder): 0.525824785232544
Func rank: 76

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: add_logical
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00494AF9 | 55 | push    rbp
0x00494AFA | 48 89 E5 | mov     rbp, rsp
0x00494AFD | 48 83 EC 10 | sub     rsp, 10h
0x00494B01 | 48 8B 05 00 89 2C 00 | mov     rax, cs:qword_75D408
0x00494B08 | 8B 40 10 | mov     eax, [rax+10h]
0x00494B0B | 83 F8 05 | cmp     eax, 5
0x00494B0E | 7F 1A | jg      short loc_494B2A
0x00494B10 | 48 8B 05 F1 88 2C 00 | mov     rax, cs:qword_75D408
0x00494B17 | 48 8B 80 68 0A 00 00 | mov     rax, [rax+0A68h]
0x00494B1E | 0F B6 40 04 | movzx   eax, byte ptr [rax+4]
0x00494B22 | 84 C0 | test    al, al
0x00494B24 | 0F 84 9E 00 00 00 | jz      loc_494BC8
0x00494B2A | 48 8B 0D D7 88 2C 00 | mov     rcx, cs:qword_75D408
0x00494B31 | 48 8B 05 D0 88 2C 00 | mov     rax, cs:qword_75D408
0x00494B38 | 8B 40 10 | mov     eax, [rax+10h]
0x00494B3B | 48 63 D0 | movsxd  rdx, eax
0x00494B3E | 48 89 D0 | mov     rax, rdx
0x00494B41 | 48 C1 E0 02 | shl     rax, 2
0x00494B45 | 48 01 D0 | add     rax, rdx
0x00494B48 | 48 C1 E0 03 | shl     rax, 3
0x00494B4C | 48 05 C0 09 00 00 | add     rax, 9C0h
0x00494B52 | 48 01 C8 | add     rax, rcx
0x00494B55 | 48 83 C0 08 | add     rax, 8
0x00494B59 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00494B5D | 48 8B 05 A4 88 2C 00 | mov     rax, cs:qword_75D408
0x00494B64 | 8B 40 18 | mov     eax, [rax+18h]
0x00494B67 | 89 C0 | mov     eax, eax
0x00494B69 | 48 89 C7 | mov     rdi, rax
0x00494B6C | E8 77 55 F7 FF | call    sub_40A0E8
0x00494B71 | 48 89 C2 | mov     rdx, rax
0x00494B74 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00494B78 | 48 89 50 18 | mov     [rax+18h], rdx
0x00494B7C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00494B80 | 48 8B 40 18 | mov     rax, [rax+18h]
0x00494B84 | 48 8D 90 BE 01 00 00 | lea     rdx, [rax+1BEh]
0x00494B8B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00494B8F | 48 89 10 | mov     [rax], rdx
0x00494B92 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00494B96 | 48 8B 00 | mov     rax, [rax]
0x00494B99 | 48 8D 50 10 | lea     rdx, [rax+10h]
0x00494B9D | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00494BA1 | 48 89 50 08 | mov     [rax+8], rdx
0x00494BA5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00494BA9 | C7 40 10 00 00 00 00 | mov     dword ptr [rax+10h], 0
0x00494BB0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00494BB4 | C6 40 20 01 | mov     byte ptr [rax+20h], 1
0x00494BB8 | 48 8B 05 49 88 2C 00 | mov     rax, cs:qword_75D408
0x00494BBF | 8B 50 10 | mov     edx, [rax+10h]
0x00494BC2 | 83 C2 01 | add     edx, 1
0x00494BC5 | 89 50 10 | mov     [rax+10h], edx
0x00494BC8 | 48 8B 05 39 88 2C 00 | mov     rax, cs:qword_75D408
0x00494BCF | 8B 40 10 | mov     eax, [rax+10h]
0x00494BD2 | 83 E8 01 | sub     eax, 1
0x00494BD5 | BE 83 00 00 00 | mov     esi, 83h
0x00494BDA | 89 C7 | mov     edi, eax
0x00494BDC | E8 F2 F4 FF FF | call    sub_4940D3
0x00494BE1 | 90 | nop
0x00494BE2 | C9 | leave
0x00494BE3 | C3 | retn
 ************ 
Source Code:
static void
add_logical(void)
{
	if (g_partitions > 5 || ptes[4].part_table->sys_ind) {
		struct pte *pe = &ptes[g_partitions];

		pe->sectorbuffer = xzalloc(sector_size);
		pe->part_table = pt_offset(pe->sectorbuffer, 0);
		pe->ext_pointer = pe->part_table + 1;
		pe->offset_from_dev_start = 0;
		pe->changed = 1;
		g_partitions++;
	}
	add_partition(g_partitions - 1, LINUX_NATIVE);
}
 ************ 
Parsed Output:
void updateGlobalState() {
    int value = *globalStatePtr;
    if (value <= 5) {
        if (globalStatePtr->flag) {
            return;
        }
    }

    int newValue = calculateNewValue(value);
    globalStatePtr->value = newValue;
    globalStatePtr->pointer = globalStatePtr + newValue * sizeof(StateStruct) + 0x1BE;
    globalStatePtr->pointer2 = globalStatePtr->pointer + 0x10;
    globalStatePtr->counter = 0;
    globalStatePtr->flag = 1;
    globalStatePtr->value += 1;

    performSomeAction(value - 1, 0x83);
}
 ************ 
Similarity Score (Unixcoder): 0.5183768272399902
Func rank: 77

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: rc_get_bit
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004BB517 | 55 | push    rbp
0x004BB518 | 48 89 E5 | mov     rbp, rsp
0x004BB51B | 48 83 EC 30 | sub     rsp, 30h
0x004BB51F | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004BB523 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x004BB527 | 48 89 55 D8 | mov     [rbp+var_28], rdx
0x004BB52B | 48 8B 55 E0 | mov     rdx, [rbp+var_20]
0x004BB52F | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004BB533 | 48 89 D6 | mov     rsi, rdx
0x004BB536 | 48 89 C7 | mov     rdi, rax
0x004BB539 | E8 02 FF FF FF | call    sub_4BB440
0x004BB53E | 89 45 FC | mov     [rbp+var_4], eax
0x004BB541 | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004BB545 | 8B 00 | mov     eax, [rax]
0x004BB547 | 8D 14 00 | lea     edx, [rax+rax]
0x004BB54A | 8B 45 FC | mov     eax, [rbp+var_4]
0x004BB54D | 01 C2 | add     edx, eax
0x004BB54F | 48 8B 45 D8 | mov     rax, [rbp+var_28]
0x004BB553 | 89 10 | mov     [rax], edx
0x004BB555 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004BB558 | C9 | leave
0x004BB559 | C3 | retn
 ************ 
Source Code:
static speed_inline int rc_get_bit(rc_t *rc, uint16_t *p, int *symbol)
{
	int ret = rc_is_bit_1(rc, p);
	*symbol = *symbol * 2 + ret;
	return ret;
}
 ************ 
Parsed Output:
int calculateAndUpdate(int *value, int *param1, int *param2) {
    int result = sub_4BB440(param1, param2);
    *value = *value * 2 + result;
    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.5169146060943604
Func rank: 78

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: nvalloc
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004DCDF7 | 55 | push    rbp
0x004DCDF8 | 48 89 E5 | mov     rbp, rsp
0x004DCDFB | 53 | push    rbx
0x004DCDFC | 48 83 EC 38 | sub     rsp, 38h
0x004DCE00 | 89 7D CC | mov     [rbp+var_34], edi
0x004DCE03 | 48 C7 45 E8 00 00 00 00 | mov     [rbp+var_18], 0
0x004DCE0B | E9 A5 00 00 00 | jmp     loc_4DCEB5
0x004DCE10 | 48 8B 05 F1 05 28 00 | mov     rax, cs:qword_75D408
0x004DCE17 | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DCE1D | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]
0x004DCE24 | 48 89 45 E8 | mov     [rbp+var_18], rax
0x004DCE28 | 48 8B 05 D9 05 28 00 | mov     rax, cs:qword_75D408
0x004DCE2F | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DCE35 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]
0x004DCE3C | 48 8B 40 08 | mov     rax, [rax+8]
0x004DCE40 | 48 8B 15 C1 05 28 00 | mov     rdx, cs:qword_75D408
0x004DCE47 | 48 81 EA D0 00 00 00 | sub     rdx, 0D0h
0x004DCE4E | 48 8B 92 B0 00 00 00 | mov     rdx, [rdx+0B0h]
0x004DCE55 | 48 83 C2 20 | add     rdx, 20h ; ' '
0x004DCE59 | 48 29 D0 | sub     rax, rdx
0x004DCE5C | 48 C1 F8 05 | sar     rax, 5
0x004DCE60 | 48 89 C2 | mov     rdx, rax
0x004DCE63 | 8B 45 CC | mov     eax, [rbp+var_34]
0x004DCE66 | 48 98 | cdqe
0x004DCE68 | 48 01 C2 | add     rdx, rax
0x004DCE6B | 48 8B 05 96 05 28 00 | mov     rax, cs:qword_75D408
0x004DCE72 | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DCE78 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]
0x004DCE7F | 8B 00 | mov     eax, [rax]
0x004DCE81 | 48 98 | cdqe
0x004DCE83 | 48 39 C2 | cmp     rdx, rax
0x004DCE86 | 7E 4C | jle     short loc_4DCED4
0x004DCE88 | 48 8B 05 79 05 28 00 | mov     rax, cs:qword_75D408
0x004DCE8F | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DCE95 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]
0x004DCE9C | 48 8B 15 65 05 28 00 | mov     rdx, cs:qword_75D408
0x004DCEA3 | 48 81 EA D0 00 00 00 | sub     rdx, 0D0h
0x004DCEAA | 48 8B 40 18 | mov     rax, [rax+18h]
0x004DCEAE | 48 89 82 B0 00 00 00 | mov     [rdx+0B0h], rax
0x004DCEB5 | 48 8B 05 4C 05 28 00 | mov     rax, cs:qword_75D408
0x004DCEBC | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DCEC2 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]
0x004DCEC9 | 48 85 C0 | test    rax, rax
0x004DCECC | 0F 85 3E FF FF FF | jnz     loc_4DCE10
0x004DCED2 | EB 01 | jmp     short loc_4DCED5
0x004DCED4 | 90 | nop
0x004DCED5 | 48 8B 05 2C 05 28 00 | mov     rax, cs:qword_75D408
0x004DCEDC | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DCEE2 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]
0x004DCEE9 | 48 85 C0 | test    rax, rax
0x004DCEEC | 0F 85 C2 00 00 00 | jnz     loc_4DCFB4
0x004DCEF2 | B8 40 00 00 00 | mov     eax, 40h ; '@'
0x004DCEF7 | 83 7D CC 40 | cmp     [rbp+var_34], 40h ; '@'
0x004DCEFB | 0F 4D 45 CC | cmovge  eax, [rbp+var_34]
0x004DCEFF | 89 45 DC | mov     [rbp+var_24], eax
0x004DCF02 | 8B 45 DC | mov     eax, [rbp+var_24]
0x004DCF05 | 48 98 | cdqe
0x004DCF07 | 48 83 C0 01 | add     rax, 1
0x004DCF0B | 48 C1 E0 05 | shl     rax, 5
0x004DCF0F | 48 8B 15 F2 04 28 00 | mov     rdx, cs:qword_75D408
0x004DCF16 | 48 8D 9A 30 FF FF FF | lea     rbx, [rdx-0D0h]
0x004DCF1D | 48 89 C7 | mov     rdi, rax
0x004DCF20 | E8 C3 D1 F2 FF | call    sub_40A0E8
0x004DCF25 | 48 89 83 B0 00 00 00 | mov     [rbx+0B0h], rax
0x004DCF2C | 48 8B 05 D5 04 28 00 | mov     rax, cs:qword_75D408
0x004DCF33 | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DCF39 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]
0x004DCF40 | 8B 55 DC | mov     edx, [rbp+var_24]
0x004DCF43 | 89 10 | mov     [rax], edx
0x004DCF45 | 48 8B 05 BC 04 28 00 | mov     rax, cs:qword_75D408
0x004DCF4C | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DCF52 | 48 8B 90 B0 00 00 00 | mov     rdx, [rax+0B0h]
0x004DCF59 | 48 8B 05 A8 04 28 00 | mov     rax, cs:qword_75D408
0x004DCF60 | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DCF66 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]
0x004DCF6D | 48 83 C2 20 | add     rdx, 20h ; ' '
0x004DCF71 | 48 89 50 08 | mov     [rax+8], rdx
0x004DCF75 | 48 8B 05 8C 04 28 00 | mov     rax, cs:qword_75D408
0x004DCF7C | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DCF82 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]
0x004DCF89 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]
0x004DCF8D | 48 89 50 10 | mov     [rax+10h], rdx
0x004DCF91 | 48 83 7D E8 00 | cmp     [rbp+var_18], 0
0x004DCF96 | 74 1C | jz      short loc_4DCFB4
0x004DCF98 | 48 8B 05 69 04 28 00 | mov     rax, cs:qword_75D408
0x004DCF9F | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DCFA5 | 48 8B 90 B0 00 00 00 | mov     rdx, [rax+0B0h]
0x004DCFAC | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004DCFB0 | 48 89 50 18 | mov     [rax+18h], rdx
0x004DCFB4 | 48 8B 05 4D 04 28 00 | mov     rax, cs:qword_75D408
0x004DCFBB | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DCFC1 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]
0x004DCFC8 | 48 8B 40 08 | mov     rax, [rax+8]
0x004DCFCC | 48 89 45 D0 | mov     [rbp+var_30], rax
0x004DCFD0 | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004DCFD4 | 48 89 45 E0 | mov     [rbp+var_20], rax
0x004DCFD8 | 48 8B 05 29 04 28 00 | mov     rax, cs:qword_75D408
0x004DCFDF | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DCFE5 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]
0x004DCFEC | 48 8B 50 08 | mov     rdx, [rax+8]
0x004DCFF0 | 8B 45 CC | mov     eax, [rbp+var_34]
0x004DCFF3 | 48 98 | cdqe
0x004DCFF5 | 48 C1 E0 05 | shl     rax, 5
0x004DCFF9 | 48 89 C1 | mov     rcx, rax
0x004DCFFC | 48 8B 05 05 04 28 00 | mov     rax, cs:qword_75D408
0x004DD003 | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DD009 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]
0x004DD010 | 48 01 CA | add     rdx, rcx
0x004DD013 | 48 89 50 08 | mov     [rax+8], rdx
0x004DD017 | EB 1B | jmp     short loc_4DD034
0x004DD019 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004DD01D | C7 00 00 00 00 00 | mov     dword ptr [rax], 0
0x004DD023 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x004DD027 | 48 C7 40 10 00 00 00 00 | mov     qword ptr [rax+10h], 0
0x004DD02F | 48 83 45 E0 20 | add     [rbp+var_20], 20h ; ' '
0x004DD034 | 48 8B 05 CD 03 28 00 | mov     rax, cs:qword_75D408
0x004DD03B | 48 2D D0 00 00 00 | sub     rax, 0D0h
0x004DD041 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]
0x004DD048 | 48 8B 40 08 | mov     rax, [rax+8]
0x004DD04C | 48 39 45 E0 | cmp     [rbp+var_20], rax
0x004DD050 | 72 C7 | jb      short loc_4DD019
0x004DD052 | 48 8B 45 D0 | mov     rax, [rbp+var_30]
0x004DD056 | 48 83 C4 38 | add     rsp, 38h
0x004DD05A | 5B | pop     rbx
0x004DD05B | 5D | pop     rbp
0x004DD05C | C3 | retn
 ************ 
Source Code:
static var *nvalloc(int n)
{
	nvblock *pb = NULL;
	var *v, *r;
	int size;

	while (g_cb) {
		pb = g_cb;
		if ((g_cb->pos - g_cb->nv) + n <= g_cb->size)
			break;
		g_cb = g_cb->next;
	}

	if (!g_cb) {
		size = (n <= MINNVBLOCK) ? MINNVBLOCK : n;
		g_cb = xzalloc(sizeof(nvblock) + size * sizeof(var));
		g_cb->size = size;
		g_cb->pos = g_cb->nv;
		g_cb->prev = pb;
		/*g_cb->next = NULL; - xzalloc did it */
		if (pb)
			pb->next = g_cb;
	}

	v = r = g_cb->pos;
	g_cb->pos += n;

	while (v < g_cb->pos) {
		v->type = 0;
		v->string = NULL;
		v++;
	}

	return r;
}
 ************ 
Parsed Output:
void updateStructure(int input) {
    void *structure = NULL;
    void *tempStructure;
    int calculatedValue;
    int size;

    do {
        tempStructure = *((void **)(qword_75D408 - 0xD0) + 0x22);
        structure = tempStructure;
    } while (tempStructure != NULL);

    if (input >= 0x40) {
        size = input;
    } else {
        size = 0x40;
    }

    void *newMemory = sub_40A0E8(size * 32 + 1);
    *((void **)(qword_75D408 - 0xD0) + 0x22) = newMemory;
    *(int *)newMemory = size;

    void *current = *((void **)(qword_75D408 - 0xD0) + 0x22);
    *((void **)(current + 4)) = current + 0x20;

    if (structure != NULL) {
        *((void **)(current + 8)) = structure;
        if (structure) {
            *((void **)(structure + 0x18)) = current;
        }
    }

    void *iterator = *((void **)(qword_75D408 - 0xD0) + 0x22) + 8;
    void *end = iterator;

    do {
        calculatedValue = input * 32;
        end += calculatedValue;
        *((void **)(qword_75D408 - 0xD0) + 0x22) + 8 = end;

        iterator += 0x20;
        *(int *)iterator = 0;
        *((void **)(iterator + 0x10)) = 0;
    } while (iterator < end);

    return;
}
 ************ 
Similarity Score (Unixcoder): 0.5151569247245789
Func rank: 79

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: time_sort
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004656EB | 55 | push    rbp
0x004656EC | 48 89 E5 | mov     rbp, rsp
0x004656EF | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004656F3 | 48 89 75 F0 | mov     [rbp+var_10], rsi
0x004656F7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x004656FB | 48 8B 50 08 | mov     rdx, [rax+8]
0x004656FF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00465703 | 48 8B 40 08 | mov     rax, [rax+8]
0x00465707 | 48 39 C2 | cmp     rdx, rax
0x0046570A | 73 07 | jnb     short loc_465713
0x0046570C | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh
0x00465711 | EB 19 | jmp     short loc_46572C
0x00465713 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00465717 | 48 8B 50 08 | mov     rdx, [rax+8]
0x0046571B | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0046571F | 48 8B 40 08 | mov     rax, [rax+8]
0x00465723 | 48 39 C2 | cmp     rdx, rax
0x00465726 | 0F 95 C0 | setnz   al
0x00465729 | 0F B6 C0 | movzx   eax, al
0x0046572C | 5D | pop     rbp
0x0046572D | C3 | retn
 ************ 
Source Code:
static int time_sort(top_status_t *P, top_status_t *Q)
{
	/* We want to avoid unsigned->signed and truncation errors */
	if (Q->ticks < P->ticks) return -1;
	return Q->ticks != P->ticks; /* 0 if ==, 1 if > */
}
 ************ 
Parsed Output:
int compare_struct_field8(void* struct1, void* struct2) {
    if (((unsigned long long *)(struct2))[1] >= ((unsigned long long *)(struct1))[1]) {
        return -1;
    }
    return ((unsigned long long *)(struct2))[1] != ((unsigned long long *)(struct1))[1];
}
 ************ 
Similarity Score (Unixcoder): 0.5112549066543579
Func rank: 80

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: calcsize
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004778EC | 55 | push    rbp
0x004778ED | 48 89 E5 | mov     rbp, rsp
0x004778F0 | 48 83 EC 10 | sub     rsp, 10h
0x004778F4 | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004778F8 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004778FD | 0F 84 6C 02 00 00 | jz      loc_477B6F
0x00477903 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00477907 | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0047790A | 0F BE C0 | movsx   eax, al
0x0047790D | 48 98 | cdqe
0x0047790F | 0F B6 80 A0 D3 51 00 | movzx   eax, ds:byte_51D3A0[rax]
0x00477916 | 0F B6 D0 | movzx   edx, al
0x00477919 | 8B 05 09 37 2E 00 | mov     eax, cs:dword_75B028
0x0047791F | 01 D0 | add     eax, edx
0x00477921 | 89 05 01 37 2E 00 | mov     cs:dword_75B028, eax
0x00477927 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0047792B | 0F B6 00 | movzx   eax, byte ptr [rax]
0x0047792E | 0F BE C0 | movsx   eax, al
0x00477931 | 83 F8 1A | cmp     eax, 1Ah; switch 27 cases
0x00477934 | 0F 87 36 02 00 00 | ja      def_477944; jumptable 0000000000477944 default case
0x0047793A | 89 C0 | mov     eax, eax
0x0047793C | 48 8B 04 C5 C0 D3 51 00 | mov     rax, ds:jpt_477944[rax*8]
0x00477944 | FF E0 | jmp     rax; switch jump
0x00477946 | 48 8B 45 F8 | mov     rax, [rbp+var_8]; jumptable 0000000000477944 case 0
0x0047794A | 48 8B 40 18 | mov     rax, [rax+18h]
0x0047794E | 48 89 C7 | mov     rdi, rax
0x00477951 | E8 96 FF FF FF | call    sub_4778EC
0x00477956 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0047795A | 48 8B 40 10 | mov     rax, [rax+10h]
0x0047795E | 48 89 C7 | mov     rdi, rax
0x00477961 | E8 86 FF FF FF | call    sub_4778EC
0x00477966 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0047796A | 48 8B 40 08 | mov     rax, [rax+8]
0x0047796E | 48 89 C7 | mov     rdi, rax
0x00477971 | E8 76 FF FF FF | call    sub_4778EC
0x00477976 | E9 F5 01 00 00 | jmp     def_477944; jumptable 0000000000477944 default case
0x0047797B | 48 8B 45 F8 | mov     rax, [rbp+var_8]; jumptable 0000000000477944 case 1
0x0047797F | 48 8B 40 08 | mov     rax, [rax+8]
0x00477983 | 48 89 C7 | mov     rdi, rax
0x00477986 | E8 1F FF FF FF | call    sub_4778AA
0x0047798B | E9 E0 01 00 00 | jmp     def_477944; jumptable 0000000000477944 default case
0x00477990 | 48 8B 45 F8 | mov     rax, [rbp+var_8]; jumptable 0000000000477944 cases 2-4
0x00477994 | 48 8B 40 10 | mov     rax, [rax+10h]
0x00477998 | 48 89 C7 | mov     rdi, rax
0x0047799B | E8 4C FF FF FF | call    sub_4778EC
0x004779A0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004779A4 | 48 8B 40 08 | mov     rax, [rax+8]
0x004779A8 | 48 89 C7 | mov     rdi, rax
0x004779AB | E8 3C FF FF FF | call    sub_4778EC
0x004779B0 | E9 BB 01 00 00 | jmp     def_477944; jumptable 0000000000477944 default case
0x004779B5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]; jumptable 0000000000477944 cases 5-7,9,10
0x004779B9 | 48 8B 40 10 | mov     rax, [rax+10h]
0x004779BD | 48 89 C7 | mov     rdi, rax
0x004779C0 | E8 27 FF FF FF | call    sub_4778EC
0x004779C5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004779C9 | 48 8B 40 08 | mov     rax, [rax+8]
0x004779CD | 48 89 C7 | mov     rdi, rax
0x004779D0 | E8 17 FF FF FF | call    sub_4778EC
0x004779D5 | E9 96 01 00 00 | jmp     def_477944; jumptable 0000000000477944 default case
0x004779DA | 48 8B 45 F8 | mov     rax, [rbp+var_8]; jumptable 0000000000477944 case 8
0x004779DE | 48 8B 40 18 | mov     rax, [rax+18h]
0x004779E2 | 48 89 C7 | mov     rdi, rax
0x004779E5 | E8 02 FF FF FF | call    sub_4778EC
0x004779EA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004779EE | 48 8B 40 10 | mov     rax, [rax+10h]
0x004779F2 | 48 89 C7 | mov     rdi, rax
0x004779F5 | E8 F2 FE FF FF | call    sub_4778EC
0x004779FA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004779FE | 48 8B 40 08 | mov     rax, [rax+8]
0x00477A02 | 48 89 C7 | mov     rdi, rax
0x00477A05 | E8 E2 FE FF FF | call    sub_4778EC
0x00477A0A | E9 61 01 00 00 | jmp     def_477944; jumptable 0000000000477944 default case
0x00477A0F | 48 8B 45 F8 | mov     rax, [rbp+var_8]; jumptable 0000000000477944 case 11
0x00477A13 | 48 8B 40 18 | mov     rax, [rax+18h]
0x00477A17 | 48 89 C7 | mov     rdi, rax; s
0x00477A1A | E8 B1 F0 F8 FF | call    _strlen
0x00477A1F | 89 C2 | mov     edx, eax
0x00477A21 | 8B 05 05 36 2E 00 | mov     eax, cs:dword_75B02C
0x00477A27 | 01 D0 | add     eax, edx
0x00477A29 | 83 C0 01 | add     eax, 1
0x00477A2C | 89 05 FA 35 2E 00 | mov     cs:dword_75B02C, eax
0x00477A32 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00477A36 | 48 8B 40 10 | mov     rax, [rax+10h]
0x00477A3A | 48 89 C7 | mov     rdi, rax
0x00477A3D | E8 AA FE FF FF | call    sub_4778EC
0x00477A42 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00477A46 | 48 8B 40 08 | mov     rax, [rax+8]
0x00477A4A | 48 89 C7 | mov     rdi, rax
0x00477A4D | E8 9A FE FF FF | call    sub_4778EC
0x00477A52 | E9 19 01 00 00 | jmp     def_477944; jumptable 0000000000477944 default case
0x00477A57 | 48 8B 45 F8 | mov     rax, [rbp+var_8]; jumptable 0000000000477944 case 12
0x00477A5B | 48 8B 40 10 | mov     rax, [rax+10h]
0x00477A5F | 48 89 C7 | mov     rdi, rax
0x00477A62 | E8 85 FE FF FF | call    sub_4778EC
0x00477A67 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00477A6B | 48 8B 40 08 | mov     rax, [rax+8]
0x00477A6F | 48 89 C7 | mov     rdi, rax
0x00477A72 | E8 75 FE FF FF | call    sub_4778EC
0x00477A77 | E9 F4 00 00 00 | jmp     def_477944; jumptable 0000000000477944 default case
0x00477A7C | 48 8B 45 F8 | mov     rax, [rbp+var_8]; jumptable 0000000000477944 case 13
0x00477A80 | 48 8B 40 18 | mov     rax, [rax+18h]
0x00477A84 | 48 89 C7 | mov     rdi, rax
0x00477A87 | E8 60 FE FF FF | call    sub_4778EC
0x00477A8C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00477A90 | 48 8B 40 10 | mov     rax, [rax+10h]
0x00477A94 | 48 89 C7 | mov     rdi, rax
0x00477A97 | E8 50 FE FF FF | call    sub_4778EC
0x00477A9C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00477AA0 | 48 8B 40 08 | mov     rax, [rax+8]
0x00477AA4 | 48 89 C7 | mov     rdi, rax
0x00477AA7 | E8 40 FE FF FF | call    sub_4778EC
0x00477AAC | E9 BF 00 00 00 | jmp     def_477944; jumptable 0000000000477944 default case
0x00477AB1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]; jumptable 0000000000477944 cases 14,15
0x00477AB5 | 48 8B 40 18 | mov     rax, [rax+18h]
0x00477AB9 | 48 89 C7 | mov     rdi, rax
0x00477ABC | E8 E9 FD FF FF | call    sub_4778AA
0x00477AC1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00477AC5 | 48 8B 40 10 | mov     rax, [rax+10h]
0x00477AC9 | 48 89 C7 | mov     rdi, rax; s
0x00477ACC | E8 FF EF F8 FF | call    _strlen
0x00477AD1 | 89 C2 | mov     edx, eax
0x00477AD3 | 8B 05 53 35 2E 00 | mov     eax, cs:dword_75B02C
0x00477AD9 | 01 D0 | add     eax, edx
0x00477ADB | 83 C0 01 | add     eax, 1
0x00477ADE | 89 05 48 35 2E 00 | mov     cs:dword_75B02C, eax
0x00477AE4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00477AE8 | 48 8B 40 08 | mov     rax, [rax+8]
0x00477AEC | 48 89 C7 | mov     rdi, rax
0x00477AEF | E8 F8 FD FF FF | call    sub_4778EC
0x00477AF4 | EB 7A | jmp     short def_477944; jumptable 0000000000477944 default case
0x00477AF6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]; jumptable 0000000000477944 cases 16-21
0x00477AFA | 48 8B 40 18 | mov     rax, [rax+18h]
0x00477AFE | 48 89 C7 | mov     rdi, rax
0x00477B01 | E8 E6 FD FF FF | call    sub_4778EC
0x00477B06 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00477B0A | 48 8B 40 08 | mov     rax, [rax+8]
0x00477B0E | 48 89 C7 | mov     rdi, rax
0x00477B11 | E8 D6 FD FF FF | call    sub_4778EC
0x00477B16 | EB 58 | jmp     short def_477944; jumptable 0000000000477944 default case
0x00477B18 | 48 8B 45 F8 | mov     rax, [rbp+var_8]; jumptable 0000000000477944 cases 22,23
0x00477B1C | 48 8B 40 18 | mov     rax, [rax+18h]
0x00477B20 | 48 89 C7 | mov     rdi, rax
0x00477B23 | E8 C4 FD FF FF | call    sub_4778EC
0x00477B28 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00477B2C | 48 8B 40 08 | mov     rax, [rax+8]
0x00477B30 | 48 89 C7 | mov     rdi, rax
0x00477B33 | E8 B4 FD FF FF | call    sub_4778EC
0x00477B38 | EB 36 | jmp     short def_477944; jumptable 0000000000477944 default case
0x00477B3A | 48 8B 45 F8 | mov     rax, [rbp+var_8]; jumptable 0000000000477944 cases 24,25
0x00477B3E | 48 8B 40 18 | mov     rax, [rax+18h]
0x00477B42 | 48 89 C7 | mov     rdi, rax
0x00477B45 | E8 A2 FD FF FF | call    sub_4778EC
0x00477B4A | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00477B4E | 48 8B 40 08 | mov     rax, [rax+8]
0x00477B52 | 48 89 C7 | mov     rdi, rax
0x00477B55 | E8 92 FD FF FF | call    sub_4778EC
0x00477B5A | EB 14 | jmp     short def_477944; jumptable 0000000000477944 default case
0x00477B5C | 48 8B 45 F8 | mov     rax, [rbp+var_8]; jumptable 0000000000477944 case 26
0x00477B60 | 48 8B 40 08 | mov     rax, [rax+8]
0x00477B64 | 48 89 C7 | mov     rdi, rax
0x00477B67 | E8 80 FD FF FF | call    sub_4778EC
0x00477B6C | 90 | nop
0x00477B6D | EB 01 | jmp     short def_477944; jumptable 0000000000477944 default case
0x00477B6F | 90 | nop
0x00477B70 | C9 | leave; jumptable 0000000000477944 default case
0x00477B71 | C3 | retn
 ************ 
Source Code:
static void
calcsize(union node *n)
{
	if (n == NULL)
		return;
	funcblocksize += nodesize[n->type];
	switch (n->type) {
	case NCMD:
		calcsize(n->ncmd.redirect);
		calcsize(n->ncmd.args);
		calcsize(n->ncmd.assign);
		break;
	case NPIPE:
		sizenodelist(n->npipe.cmdlist);
		break;
	case NREDIR:
	case NBACKGND:
	case NSUBSHELL:
		calcsize(n->nredir.redirect);
		calcsize(n->nredir.n);
		break;
	case NAND:
	case NOR:
	case NSEMI:
	case NWHILE:
	case NUNTIL:
		calcsize(n->nbinary.ch2);
		calcsize(n->nbinary.ch1);
		break;
	case NIF:
		calcsize(n->nif.elsepart);
		calcsize(n->nif.ifpart);
		calcsize(n->nif.test);
		break;
	case NFOR:
		funcstringsize += strlen(n->nfor.var) + 1;
		calcsize(n->nfor.body);
		calcsize(n->nfor.args);
		break;
	case NCASE:
		calcsize(n->ncase.cases);
		calcsize(n->ncase.expr);
		break;
	case NCLIST:
		calcsize(n->nclist.body);
		calcsize(n->nclist.pattern);
		calcsize(n->nclist.next);
		break;
	case NDEFUN:
	case NARG:
		sizenodelist(n->narg.backquote);
		funcstringsize += strlen(n->narg.text) + 1;
		calcsize(n->narg.next);
		break;
	case NTO:
#if ENABLE_ASH_BASH_COMPAT
	case NTO2:
#endif
	case NCLOBBER:
	case NFROM:
	case NFROMTO:
	case NAPPEND:
		calcsize(n->nfile.fname);
		calcsize(n->nfile.next);
		break;
	case NTOFD:
	case NFROMFD:
		calcsize(n->ndup.vname);
		calcsize(n->ndup.next);
	break;
	case NHERE:
	case NXHERE:
		calcsize(n->nhere.doc);
		calcsize(n->nhere.next);
		break;
	case NNOT:
		calcsize(n->nnot.com);
		break;
	};
}
 ************ 
Parsed Output:
void processInputData(void *inputData) {
    if (inputData == NULL) {
        return;
    }

    unsigned char inputChar = *(unsigned char *)inputData;
    int index = (int)inputChar;
    int globalCounter = 0;

    // Update global counter based on input character
    globalCounter += byte_51D3A0[index];

    // Switch-like structure based on input character
    switch (index) {
        case 0:
            sub_4778EC(*(void **)(inputData + 0x18));
            sub_4778EC(*(void **)(inputData + 0x10));
            sub_4778EC(*(void **)(inputData + 0x08));
            break;
        case 1:
            sub_4778AA(*(void **)(inputData + 0x08));
            break;
        case 2:
        case 3:
        case 4:
            sub_4778EC(*(void **)(inputData + 0x10));
            sub_4778EC(*(void **)(inputData + 0x08));
            break;
        case 5:
        case 6:
        case 7:
        case 9:
        case 10:
            sub_4778EC(*(void **)(inputData + 0x10));
            sub_4778EC(*(void **)(inputData + 0x08));
            break;
        case 8:
            sub_4778EC(*(void **)(inputData + 0x18));
            sub_4778EC(*(void **)(inputData + 0x10));
            sub_4778EC(*(void **)(inputData + 0x08));
            break;
        case 11:
            globalCounter += strlen(*(char **)(inputData + 0x18)) + 1;
            sub_4778EC(*(void **)(inputData + 0x10));
            sub_4778EC(*(void **)(inputData + 0x08));
            break;
        case 12:
            sub_4778EC(*(void **)(inputData + 0x10));
            sub_4778EC(*(void **)(inputData + 0x08));
            break;
        case 13:
            sub_4778EC(*(void **)(inputData + 0x18));
            sub_4778EC(*(void **)(inputData + 0x10));
            sub_4778EC(*(void **)(inputData + 0x08));
            break;
        case 14:
        case 15:
            sub_4778AA(*(void **)(inputData + 0x18));
            globalCounter += strlen(*(char **)(inputData + 0x10)) + 1;
            sub_4778EC(*(void **)(inputData + 0x08));
            break;
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
            sub_4778EC(*(void **)(inputData + 0x18));
            sub_4778EC(*(void **)(inputData + 0x08));
            break;
        case 22:
        case 23:
            sub_4778EC(*(void **)(inputData + 0x18));
            sub_4778EC(*(void **)(inputData + 0x08));
            break;
        case 24:
        case 25:
            sub_4778EC(*(void **)(inputData + 0x18));
            sub_4778EC(*(void **)(inputData + 0x08));
            break;
        case 26:
            sub_4778EC(*(void **)(inputData + 0x08));
            break;
        default:
            // No operation for default case
            break;
    }

    // Update global counters
    dword_75B028 = globalCounter;
    dword_75B02C += globalCounter + 1;
}
 ************ 
Similarity Score (Unixcoder): 0.5102236270904541
Func rank: 81

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: run_actions
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004F5345 | 55 | push    rbp
0x004F5346 | 48 89 E5 | mov     rbp, rsp
0x004F5349 | 48 83 EC 20 | sub     rsp, 20h
0x004F534D | 89 7D EC | mov     [rbp+var_14], edi
0x004F5350 | 48 8B 05 59 5F 26 00 | mov     rax, cs:qword_75B2B0
0x004F5357 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004F535B | E9 8F 00 00 00 | jmp     loc_4F53EF
0x004F5360 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F5364 | 0F B6 40 0C | movzx   eax, byte ptr [rax+0Ch]
0x004F5368 | 0F B6 C0 | movzx   eax, al
0x004F536B | 23 45 EC | and     eax, [rbp+var_14]
0x004F536E | 85 C0 | test    eax, eax
0x004F5370 | 74 71 | jz      short loc_4F53E3
0x004F5372 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F5376 | 0F B6 40 0C | movzx   eax, byte ptr [rax+0Ch]
0x004F537A | 0F B6 C0 | movzx   eax, al
0x004F537D | 83 E0 67 | and     eax, 67h
0x004F5380 | 85 C0 | test    eax, eax
0x004F5382 | 74 2B | jz      short loc_4F53AF
0x004F5384 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F5388 | 48 89 C7 | mov     rdi, rax
0x004F538B | E8 93 FD FF FF | call    sub_4F5123
0x004F5390 | 89 45 F4 | mov     [rbp+var_C], eax
0x004F5393 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F5397 | 0F B6 40 0C | movzx   eax, byte ptr [rax+0Ch]
0x004F539B | 0F B6 C0 | movzx   eax, al
0x004F539E | 83 E0 63 | and     eax, 63h
0x004F53A1 | 85 C0 | test    eax, eax
0x004F53A3 | 74 0A | jz      short loc_4F53AF
0x004F53A5 | 8B 45 F4 | mov     eax, [rbp+var_C]
0x004F53A8 | 89 C7 | mov     edi, eax
0x004F53AA | E8 53 FF FF FF | call    sub_4F5302
0x004F53AF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F53B3 | 0F B6 40 0C | movzx   eax, byte ptr [rax+0Ch]
0x004F53B7 | 0F B6 C0 | movzx   eax, al
0x004F53BA | 83 E0 18 | and     eax, 18h
0x004F53BD | 85 C0 | test    eax, eax
0x004F53BF | 74 23 | jz      short loc_4F53E4
0x004F53C1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F53C5 | 8B 40 08 | mov     eax, [rax+8]
0x004F53C8 | 85 C0 | test    eax, eax
0x004F53CA | 75 18 | jnz     short loc_4F53E4
0x004F53CC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F53D0 | 48 89 C7 | mov     rdi, rax
0x004F53D3 | E8 4B FD FF FF | call    sub_4F5123
0x004F53D8 | 89 C2 | mov     edx, eax
0x004F53DA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F53DE | 89 50 08 | mov     [rax+8], edx
0x004F53E1 | EB 01 | jmp     short loc_4F53E4
0x004F53E3 | 90 | nop
0x004F53E4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004F53E8 | 48 8B 00 | mov     rax, [rax]
0x004F53EB | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004F53EF | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x004F53F4 | 0F 85 66 FF FF FF | jnz     loc_4F5360
0x004F53FA | 90 | nop
0x004F53FB | C9 | leave
0x004F53FC | C3 | retn
 ************ 
Source Code:
static void run_actions(int action_type)
{
	struct init_action *a;

	for (a = init_action_list; a; a = a->next) {
		if (!(a->action_type & action_type))
			continue;

		if (a->action_type & (SYSINIT | WAIT | ONCE | CTRLALTDEL | SHUTDOWN)) {
			pid_t pid = run(a);
			if (a->action_type & (SYSINIT | WAIT | CTRLALTDEL | SHUTDOWN))
				waitfor(pid);
		}
		if (a->action_type & (RESPAWN | ASKFIRST)) {
			/* Only run stuff with pid == 0. If pid != 0,
			 * it is already running
			 */
			if (a->pid == 0)
				a->pid = run(a);
		}
	}
}
 ************ 
Parsed Output:
void processLinkedList(int input) {
    Node *current = qword_75B2B0;
    while (current != NULL) {
        if ((current->data & input) != 0) {
            if ((current->data & 0x67) != 0) {
                int result = sub_4F5123(current);
                if ((current->data & 0x63) != 0) {
                    sub_4F5302(result);
                }
            }
            if ((current->data & 0x18) == 0 && current->next == NULL) {
                int result = sub_4F5123(current);
                current->next = result;
            }
        }
        current = current->next;
    }
}
 ************ 
Similarity Score (Unixcoder): 0.5032876133918762
Func rank: 82

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: size_from_HISTFILESIZE
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004FF94D | 55 | push    rbp
0x004FF94E | 48 89 E5 | mov     rbp, rsp
0x004FF951 | 48 83 EC 20 | sub     rsp, 20h
0x004FF955 | 48 89 7D E8 | mov     [rbp+nptr], rdi
0x004FF959 | C7 45 FC FF 00 00 00 | mov     [rbp+var_4], 0FFh
0x004FF960 | 48 83 7D E8 00 | cmp     [rbp+nptr], 0
0x004FF965 | 74 2C | jz      short loc_4FF993
0x004FF967 | 48 8B 45 E8 | mov     rax, [rbp+nptr]
0x004FF96B | 48 89 C7 | mov     rdi, rax; nptr
0x004FF96E | E8 4D 80 F0 FF | call    _atoi
0x004FF973 | 89 45 FC | mov     [rbp+var_4], eax
0x004FF976 | 83 7D FC 00 | cmp     [rbp+var_4], 0
0x004FF97A | 7F 07 | jg      short loc_4FF983
0x004FF97C | B8 01 00 00 00 | mov     eax, 1
0x004FF981 | EB 13 | jmp     short locret_4FF996
0x004FF983 | 81 7D FC FF 00 00 00 | cmp     [rbp+var_4], 0FFh
0x004FF98A | 7E 07 | jle     short loc_4FF993
0x004FF98C | B8 FF 00 00 00 | mov     eax, 0FFh
0x004FF991 | EB 03 | jmp     short locret_4FF996
0x004FF993 | 8B 45 FC | mov     eax, [rbp+var_4]
0x004FF996 | C9 | leave
0x004FF997 | C3 | retn
 ************ 
Source Code:
0

unsigned size_from_HISTFILESIZE(const char *hp)
{
	int size = MAX_HISTORY;
	if (hp) {
		size = atoi(hp);
		if (size <= 0)
			return 1;
		if (size > MAX_HISTORY)
			return MAX_HISTORY;
	}
	return size;
}
 ************ 
Parsed Output:
int parse_and_validate_input(const char *nptr) {
    int value = 0xFF;

    if (nptr != NULL) {
        value = atoi(nptr);
        if (value <= 0) {
            return 1;
        } else if (value > 0xFF) {
            return 0xFF;
        }
    }

    return value;
}
 ************ 
Similarity Score (Unixcoder): 0.49578022956848145
Func rank: 83

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: str_value
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004C92D7 | 55 | push    rbp
0x004C92D8 | 48 89 E5 | mov     rbp, rsp
0x004C92DB | 48 83 EC 20 | sub     rsp, 20h
0x004C92DF | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004C92E3 | BF 10 00 00 00 | mov     edi, 10h
0x004C92E8 | E8 FB 0D F4 FF | call    sub_40A0E8
0x004C92ED | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004C92F1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C92F5 | C6 00 01 | mov     byte ptr [rax], 1
0x004C92F8 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004C92FC | 48 89 C7 | mov     rdi, rax
0x004C92FF | E8 1B 0E F4 FF | call    sub_40A11F
0x004C9304 | 48 89 C2 | mov     rdx, rax
0x004C9307 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C930B | 48 89 50 08 | mov     [rax+8], rdx
0x004C930F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004C9313 | C9 | leave
0x004C9314 | C3 | retn
 ************ 
Source Code:
static VALUE *str_value(const char *s)
{
	VALUE *v;

	v = xzalloc(sizeof(VALUE));
	if (STRING) /* otherwise xzaaloc did it already */
		v->type = STRING;
	v->u.s = xstrdup(s);
	return v;
}
 ************ 
Parsed Output:
#include <stdint.h>

void* sub_40A0E8(size_t size);
void* sub_40A11F(void* ptr);

typedef struct {
    uint8_t flag;
    void* data;
} CustomStruct;

CustomStruct* createAndInitializeCustomStruct(void* ptr) {
    CustomStruct* cs = (CustomStruct*)sub_40A0E8(sizeof(CustomStruct));
    cs->flag = 1;
    cs->data = sub_40A11F(ptr);
    return cs;
}
 ************ 
Similarity Score (Unixcoder): 0.49247533082962036
Func rank: 84

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: lzma_props
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004BE323 | 55 | push    rbp
0x004BE324 | 48 89 E5 | mov     rbp, rsp
0x004BE327 | 48 83 EC 10 | sub     rsp, 10h
0x004BE32B | 48 89 7D F8 | mov     [rbp+var_8], rdi
0x004BE32F | 89 F0 | mov     eax, esi
0x004BE331 | 88 45 F4 | mov     [rbp+var_C], al
0x004BE334 | 80 7D F4 E0 | cmp     [rbp+var_C], 0E0h
0x004BE338 | 76 0A | jbe     short loc_4BE344
0x004BE33A | B8 00 00 00 00 | mov     eax, 0
0x004BE33F | E9 EB 00 00 00 | jmp     locret_4BE42F
0x004BE344 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BE348 | C7 80 9C 00 00 00 00 00 00 00 | mov     dword ptr [rax+9Ch], 0
0x004BE352 | EB 1B | jmp     short loc_4BE36F
0x004BE354 | 80 6D F4 2D | sub     [rbp+var_C], 2Dh ; '-'
0x004BE358 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BE35C | 8B 80 9C 00 00 00 | mov     eax, [rax+9Ch]
0x004BE362 | 8D 50 01 | lea     edx, [rax+1]
0x004BE365 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BE369 | 89 90 9C 00 00 00 | mov     [rax+9Ch], edx
0x004BE36F | 80 7D F4 2C | cmp     [rbp+var_C], 2Ch ; ','
0x004BE373 | 77 DF | ja      short loc_4BE354
0x004BE375 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BE379 | 8B 80 9C 00 00 00 | mov     eax, [rax+9Ch]
0x004BE37F | BA 01 00 00 00 | mov     edx, 1
0x004BE384 | 89 C1 | mov     ecx, eax
0x004BE386 | D3 E2 | shl     edx, cl
0x004BE388 | 89 D0 | mov     eax, edx
0x004BE38A | 83 E8 01 | sub     eax, 1
0x004BE38D | 89 C2 | mov     edx, eax
0x004BE38F | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BE393 | 89 90 9C 00 00 00 | mov     [rax+9Ch], edx
0x004BE399 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BE39D | C7 80 98 00 00 00 00 00 00 00 | mov     dword ptr [rax+98h], 0
0x004BE3A7 | EB 1B | jmp     short loc_4BE3C4
0x004BE3A9 | 80 6D F4 09 | sub     [rbp+var_C], 9
0x004BE3AD | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BE3B1 | 8B 80 98 00 00 00 | mov     eax, [rax+98h]
0x004BE3B7 | 8D 50 01 | lea     edx, [rax+1]
0x004BE3BA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BE3BE | 89 90 98 00 00 00 | mov     [rax+98h], edx
0x004BE3C4 | 80 7D F4 08 | cmp     [rbp+var_C], 8
0x004BE3C8 | 77 DF | ja      short loc_4BE3A9
0x004BE3CA | 0F B6 55 F4 | movzx   edx, [rbp+var_C]
0x004BE3CE | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BE3D2 | 89 90 94 00 00 00 | mov     [rax+94h], edx
0x004BE3D8 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BE3DC | 8B 90 94 00 00 00 | mov     edx, [rax+94h]
0x004BE3E2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BE3E6 | 8B 80 98 00 00 00 | mov     eax, [rax+98h]
0x004BE3EC | 01 D0 | add     eax, edx
0x004BE3EE | 83 F8 04 | cmp     eax, 4
0x004BE3F1 | 76 07 | jbe     short loc_4BE3FA
0x004BE3F3 | B8 00 00 00 00 | mov     eax, 0
0x004BE3F8 | EB 35 | jmp     short locret_4BE42F
0x004BE3FA | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BE3FE | 8B 80 98 00 00 00 | mov     eax, [rax+98h]
0x004BE404 | BA 01 00 00 00 | mov     edx, 1
0x004BE409 | 89 C1 | mov     ecx, eax
0x004BE40B | D3 E2 | shl     edx, cl
0x004BE40D | 89 D0 | mov     eax, edx
0x004BE40F | 83 E8 01 | sub     eax, 1
0x004BE412 | 89 C2 | mov     edx, eax
0x004BE414 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BE418 | 89 90 98 00 00 00 | mov     [rax+98h], edx
0x004BE41E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004BE422 | 48 89 C7 | mov     rdi, rax
0x004BE425 | E8 60 FE FF FF | call    sub_4BE28A
0x004BE42A | B8 01 00 00 00 | mov     eax, 1
0x004BE42F | C9 | leave
0x004BE430 | C3 | retn
 ************ 
Source Code:
static bool XZ_FUNC lzma_props(struct xz_dec_lzma2 *s, uint8_t props)
{
	if (props > (4 * 5 + 4) * 9 + 8)
		return false;

	s->lzma.pos_mask = 0;
	while (props >= 9 * 5) {
		props -= 9 * 5;
		++s->lzma.pos_mask;
	}

	s->lzma.pos_mask = (1 << s->lzma.pos_mask) - 1;

	s->lzma.literal_pos_mask = 0;
	while (props >= 9) {
		props -= 9;
		++s->lzma.literal_pos_mask;
	}

	s->lzma.lc = props;

	if (s->lzma.lc + s->lzma.literal_pos_mask > 4)
		return false;

	s->lzma.literal_pos_mask = (1 << s->lzma.literal_pos_mask) - 1;

	lzma_reset(s);

	return true;
}
 ************ 
Parsed Output:
int processInput(void *ptr, int input) {
    if (input > 0xE0) {
        return 0;
    }

    *((int *)(ptr + 0x9C)) = 0;
    while (input > 0x2C) {
        input -= 0x2D;
        *((int *)(ptr + 0x9C)) += 1;
    }

    int count = *((int *)(ptr + 0x9C));
    *((int *)(ptr + 0x9C)) = (1 << count) - 1;

    *((int *)(ptr + 0x98)) = 0;
    while (input > 0x08) {
        input -= 0x09;
        *((int *)(ptr + 0x98)) += 1;
    }

    *((int *)(ptr + 0x94)) = input;

    int sum = *((int *)(ptr + 0x94)) + *((int *)(ptr + 0x98));
    if (sum > 0x04) {
        return 0;
    }

    *((int *)(ptr + 0x98)) = (1 << *((int *)(ptr + 0x98))) - 1;

    sub_4BE28A(ptr);
    return 1;
}
 ************ 
Similarity Score (Unixcoder): 0.4911114573478699
Func rank: 85

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: read_big_block
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0041A1AA | 55 | push    rbp
0x0041A1AB | 48 89 E5 | mov     rbp, rsp
0x0041A1AE | 48 83 EC 20 | sub     rsp, 20h
0x0041A1B2 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0041A1B6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0041A1BA | BA 00 00 10 00 | mov     edx, 100000h
0x0041A1BF | 48 89 C6 | mov     rsi, rax
0x0041A1C2 | BF 03 00 00 00 | mov     edi, 3
0x0041A1C7 | E8 86 D2 0E 00 | call    sub_507452
0x0041A1CC | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x0041A1D3 | EB 29 | jmp     short loc_41A1FE
0x0041A1D5 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0041A1D8 | 48 63 D0 | movsxd  rdx, eax
0x0041A1DB | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0041A1DF | 48 01 D0 | add     rax, rdx
0x0041A1E2 | 0F B6 10 | movzx   edx, byte ptr [rax]
0x0041A1E5 | 8B 45 FC | mov     eax, [rbp+var_4]
0x0041A1E8 | 48 63 C8 | movsxd  rcx, eax
0x0041A1EB | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0041A1EF | 48 01 C8 | add     rax, rcx
0x0041A1F2 | 83 E2 01 | and     edx, 1
0x0041A1F5 | 88 10 | mov     [rax], dl
0x0041A1F7 | 81 45 FC 00 02 00 00 | add     [rbp+var_4], 200h
0x0041A1FE | 81 7D FC FF FF 0F 00 | cmp     [rbp+var_4], 0FFFFFh
0x0041A205 | 7E CE | jle     short loc_41A1D5
0x0041A207 | 90 | nop
0x0041A208 | C9 | leave
0x0041A209 | C3 | retn
 ************ 
Source Code:
static void read_big_block(/*int fd,*/ char *buf)
{
	int i;

	xread(fd, buf, TIMING_BUF_BYTES);
	/* access all sectors of buf to ensure the read fully completed */
	for (i = 0; i < TIMING_BUF_BYTES; i += 512)
		buf[i] &= 1;
}
 ************ 
Parsed Output:
void processBuffer(char *buffer) {
    sub_507452(buffer, 0x100000, 3);

    for (int i = 0; i <= 0xFFFFF; i += 0x200) {
        buffer[i] &= 1;
    }
}
 ************ 
Similarity Score (Unixcoder): 0.48815029859542847
Func rank: 86

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: udhcp_str2nip
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00459D25 | 55 | push    rbp
0x00459D26 | 48 89 E5 | mov     rbp, rsp
0x00459D29 | 48 83 EC 20 | sub     rsp, 20h
0x00459D2D | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x00459D31 | 48 89 75 E0 | mov     [rbp+var_20], rsi
0x00459D35 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x00459D39 | BA 02 00 00 00 | mov     edx, 2
0x00459D3E | BE 00 00 00 00 | mov     esi, 0
0x00459D43 | 48 89 C7 | mov     rdi, rax
0x00459D46 | E8 57 1D 0B 00 | call    sub_50BAA2
0x00459D4B | 48 89 45 F8 | mov     [rbp+ptr], rax
0x00459D4F | 48 83 7D F8 00 | cmp     [rbp+ptr], 0
0x00459D54 | 75 07 | jnz     short loc_459D5D
0x00459D56 | B8 00 00 00 00 | mov     eax, 0
0x00459D5B | EB 1E | jmp     short locret_459D7B
0x00459D5D | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00459D61 | 8B 50 08 | mov     edx, [rax+8]
0x00459D64 | 48 8B 45 E0 | mov     rax, [rbp+var_20]
0x00459D68 | 89 10 | mov     [rax], edx
0x00459D6A | 48 8B 45 F8 | mov     rax, [rbp+ptr]
0x00459D6E | 48 89 C7 | mov     rdi, rax; ptr
0x00459D71 | E8 EA C8 FA FF | call    _free
0x00459D76 | B8 01 00 00 00 | mov     eax, 1
0x00459D7B | C9 | leave
0x00459D7C | C3 | retn
 ************ 
Source Code:
int FAST_FUNC udhcp_str2nip(const char *str, void *arg)
{
	len_and_sockaddr *lsa;

	lsa = host_and_af2sockaddr(str, 0, AF_INET);
	if (!lsa)
		return 0;
	/* arg maybe unaligned */
	move_to_unaligned32((uint32_t*)arg, lsa->u.sin.sin_addr.s_addr);
	free(lsa);
	return 1;
}
 ************ 
Parsed Output:
int extract_and_free(void *input_ptr, int *output_value) {
    void *ptr = sub_50BAA2(input_ptr, 2, 0);
    if (ptr == NULL) {
        return 0;
    }
    *output_value = *((int *)(ptr + 8));
    free(ptr);
    return 1;
}
 ************ 
Similarity Score (Unixcoder): 0.47252628207206726
Func rank: 87

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: put_prompt
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004FE30A | 55 | push    rbp
0x004FE30B | 48 89 E5 | mov     rbp, rsp
0x004FE30E | 48 83 EC 10 | sub     rsp, 10h
0x004FE312 | 48 8B 15 4F CB 25 00 | mov     rdx, cs:stdout
0x004FE319 | 48 8B 05 38 F1 25 00 | mov     rax, cs:qword_75D458
0x004FE320 | 48 8B 40 38 | mov     rax, [rax+38h]
0x004FE324 | 48 89 D6 | mov     rsi, rdx; stream
0x004FE327 | 48 89 C7 | mov     rdi, rax; s
0x004FE32A | E8 91 8C F0 FF | call    _fputs_unlocked
0x004FE32F | E8 15 C3 F0 FF | call    sub_40A649
0x004FE334 | 48 8B 05 1D F1 25 00 | mov     rax, cs:qword_75D458
0x004FE33B | C7 40 24 00 00 00 00 | mov     dword ptr [rax+24h], 0
0x004FE342 | 48 8B 05 0F F1 25 00 | mov     rax, cs:qword_75D458
0x004FE349 | 8B 40 08 | mov     eax, [rax+8]
0x004FE34C | 89 45 FC | mov     [rbp+var_4], eax
0x004FE34F | 48 8B 05 02 F1 25 00 | mov     rax, cs:qword_75D458
0x004FE356 | 8B 40 20 | mov     eax, [rax+20h]
0x004FE359 | 48 8B 0D F8 F0 25 00 | mov     rcx, cs:qword_75D458
0x004FE360 | BA 00 00 00 00 | mov     edx, 0
0x004FE365 | F7 75 FC | div     [rbp+var_4]
0x004FE368 | 89 41 1C | mov     [rcx+1Ch], eax
0x004FE36B | 48 8B 05 E6 F0 25 00 | mov     rax, cs:qword_75D458
0x004FE372 | 8B 40 20 | mov     eax, [rax+20h]
0x004FE375 | 48 8B 0D DC F0 25 00 | mov     rcx, cs:qword_75D458
0x004FE37C | BA 00 00 00 00 | mov     edx, 0
0x004FE381 | F7 75 FC | div     [rbp+var_4]
0x004FE384 | 89 D0 | mov     eax, edx
0x004FE386 | 89 41 18 | mov     [rcx+18h], eax
0x004FE389 | 90 | nop
0x004FE38A | C9 | leave
0x004FE38B | C3 | retn
 ************ 
Source Code:
static void put_prompt(void)
{
	unsigned w;

	fputs(cmdedit_prompt, stdout);
	fflush_all();
	cursor = 0;
	w = cmdedit_termw; /* read volatile var once */
	cmdedit_y = cmdedit_prmt_len / w; /* new quasireal y */
	cmdedit_x = cmdedit_prmt_len % w;
}
 ************ 
Parsed Output:
#include <stdio.h>

void print_and_update_statistics() {
    // Assuming qword_75D458 is a global structure with offsets 0x38, 0x24, 0x08, 0x20, 0x1C, and 0x18
    // representing different members of the structure.
    extern struct {
        char _padding_38[0x38]; // Padding to reach the offset 0x38
        char *message;           // Offset 0x38
        int _padding_24;         // Padding to reach the offset 0x24
        int value_08;            // Offset 0x08
        int value_20;            // Offset 0x20
        int result_1C;           // Offset 0x1C
        int result_18;           // Offset 0x18
    } globalStruct;

    fputs_unlocked(globalStruct.message, stdout); // Print the message to stdout
    sub_40A649(); // Call another function (name unknown, assuming it's a void function with no parameters)

    globalStruct._padding_24 = 0; // Set the value at offset 0x24 to 0

    int divisor = globalStruct.value_08; // Load the value at offset 0x08
    int dividend = globalStruct.value_20; // Load the value at offset 0x20

    // Perform division, store quotient at offset 0x1C and remainder at offset 0x18
    globalStruct.result_1C = dividend / divisor;
    globalStruct.result_18 = dividend % divisor;
}
 ************ 
Similarity Score (Unixcoder): 0.46183598041534424
Func rank: 88

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: set_changed
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00490725 | 55 | push    rbp
0x00490726 | 48 89 E5 | mov     rbp, rsp
0x00490729 | 89 7D FC | mov     [rbp+var_4], edi
0x0049072C | 48 8B 0D D5 CC 2C 00 | mov     rcx, cs:qword_75D408
0x00490733 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00490736 | 48 63 D0 | movsxd  rdx, eax
0x00490739 | 48 89 D0 | mov     rax, rdx
0x0049073C | 48 C1 E0 02 | shl     rax, 2
0x00490740 | 48 01 D0 | add     rax, rdx
0x00490743 | 48 C1 E0 03 | shl     rax, 3
0x00490747 | 48 01 C8 | add     rax, rcx
0x0049074A | 48 05 E8 09 00 00 | add     rax, 9E8h
0x00490750 | C6 00 01 | mov     byte ptr [rax], 1
0x00490753 | 90 | nop
0x00490754 | 5D | pop     rbp
0x00490755 | C3 | retn
 ************ 
Source Code:
static ALWAYS_INLINE void
set_changed(int i)
{
	ptes[i].changed = 1;
}
 ************ 
Parsed Output:
void setFlagInArray(int index) {
    extern int64_t arrayBaseAddress;
    int64_t offset = (index * 11 + 9E8h) * 8;
    *((char*)(arrayBaseAddress + offset)) = 1;
}
 ************ 
Similarity Score (Unixcoder): 0.45581725239753723
Func rank: 89

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: hash_bin_to_hex
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004CCD81 | 55 | push    rbp
0x004CCD82 | 48 89 E5 | mov     rbp, rsp
0x004CCD85 | 48 83 EC 20 | sub     rsp, 20h
0x004CCD89 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004CCD8D | 89 75 E4 | mov     [rbp+var_1C], esi
0x004CCD90 | 8B 45 E4 | mov     eax, [rbp+var_1C]
0x004CCD93 | 01 C0 | add     eax, eax
0x004CCD95 | 83 C0 01 | add     eax, 1
0x004CCD98 | 89 C0 | mov     eax, eax
0x004CCD9A | 48 89 C7 | mov     rdi, rax
0x004CCD9D | E8 46 D3 F3 FF | call    sub_40A0E8
0x004CCDA2 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004CCDA6 | 8B 55 E4 | mov     edx, [rbp+var_1C]
0x004CCDA9 | 48 8B 4D E8 | mov     rcx, [rbp+var_18]
0x004CCDAD | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004CCDB1 | 48 89 CE | mov     rsi, rcx
0x004CCDB4 | 48 89 C7 | mov     rdi, rax
0x004CCDB7 | E8 F9 CD F3 FF | call    sub_409BB5
0x004CCDBC | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004CCDC0 | C9 | leave
0x004CCDC1 | C3 | retn
 ************ 
Source Code:
static unsigned char *hash_bin_to_hex(unsigned char *hash_value,
				unsigned hash_length)
{
	/* xzalloc zero-terminates */
	char *hex_value = xzalloc((hash_length * 2) + 1);
	bin2hex(hex_value, (char*)hash_value, hash_length);
	return (unsigned char *)hex_value;
}
 ************ 
Parsed Output:
int doubleAndIncrement(int value) {
    return value * 2 + 1;
}

void performOperation(int value, void *ptr) {
    int doubledValue = doubleAndIncrement(value);
    sub_409BB5(doubledValue, ptr);
}

int informativeFunctionName(int value, void *ptr) {
    performOperation(value, ptr);
    return value;
}
 ************ 
Similarity Score (Unixcoder): 0.4435972571372986
Func rank: 90

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: start_new_cmd_q
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004EEE0F | 55 | push    rbp
0x004EEE10 | 48 89 E5 | mov     rbp, rsp
0x004EEE13 | 53 | push    rbx
0x004EEE14 | 48 83 EC 18 | sub     rsp, 18h
0x004EEE18 | 89 F8 | mov     eax, edi
0x004EEE1A | 88 45 EC | mov     [rbp+var_14], al
0x004EEE1D | 48 8B 05 E4 E5 26 00 | mov     rax, cs:qword_75D408
0x004EEE24 | 8B 40 2C | mov     eax, [rax+2Ch]
0x004EEE27 | 85 C0 | test    eax, eax
0x004EEE29 | 7E 3B | jle     short loc_4EEE66
0x004EEE2B | 0F BE 55 EC | movsx   edx, [rbp+var_14]
0x004EEE2F | 48 8B 05 D2 E5 26 00 | mov     rax, cs:qword_75D408
0x004EEE36 | 8B 40 2C | mov     eax, [rax+2Ch]
0x004EEE39 | 48 8B 0D C8 E5 26 00 | mov     rcx, cs:qword_75D408
0x004EEE40 | 48 8D B9 B8 04 00 00 | lea     rdi, [rcx+4B8h]; s
0x004EEE47 | 48 8B 1D BA E5 26 00 | mov     rbx, cs:qword_75D408
0x004EEE4E | 89 D1 | mov     ecx, edx
0x004EEE50 | 89 C2 | mov     edx, eax
0x004EEE52 | BE 7C 76 52 00 | mov     esi, offset aDC; "%d%c"
0x004EEE57 | B8 00 00 00 00 | mov     eax, 0
0x004EEE5C | E8 1F 8C F1 FF | call    _sprintf
0x004EEE61 | 89 43 78 | mov     [rbx+78h], eax
0x004EEE64 | EB 1F | jmp     short loc_4EEE85
0x004EEE66 | 48 8B 05 9B E5 26 00 | mov     rax, cs:qword_75D408
0x004EEE6D | 0F B6 55 EC | movzx   edx, [rbp+var_14]
0x004EEE71 | 88 90 B8 04 00 00 | mov     [rax+4B8h], dl
0x004EEE77 | 48 8B 05 8A E5 26 00 | mov     rax, cs:qword_75D408
0x004EEE7E | C7 40 78 01 00 00 00 | mov     dword ptr [rax+78h], 1
0x004EEE85 | 48 8B 05 7C E5 26 00 | mov     rax, cs:qword_75D408
0x004EEE8C | C6 40 76 01 | mov     byte ptr [rax+76h], 1
0x004EEE90 | 90 | nop
0x004EEE91 | 48 83 C4 18 | add     rsp, 18h
0x004EEE95 | 5B | pop     rbx
0x004EEE96 | 5D | pop     rbp
0x004EEE97 | C3 | retn
 ************ 
Source Code:
if ENABLE_FEATURE_VI_DOT_CMD
static void start_new_cmd_q(char c)
{
	// get buffer for new cmd
	// if there is a current cmd count put it in the buffer first
	if (cmdcnt > 0) {
		lmc_len = sprintf(last_modifying_cmd, "%d%c", cmdcnt, c);
	} else { // just save char c onto queue
		last_modifying_cmd[0] = c;
		lmc_len = 1;
	}
	adding2q = 1;
}
 ************ 
Parsed Output:
void updateStatusWithInput(char input) {
    int status;
    char *statusString;
    char format[] = "%d%c";
    
    status = *(int *)(qword_75D408 + 0x2C);
    if (status > 0) {
        statusString = (char *)(qword_75D408 + 0x4B8);
        sprintf(statusString, format, status, input);
        *(int *)(qword_75D408 + 0x78) = strlen(statusString);
    } else {
        *(char *)(qword_75D408 + 0x4B8) = input;
        *(int *)(qword_75D408 + 0x78) = 1;
    }
    
    *(char *)(qword_75D408 + 0x76) = 1;
}
 ************ 
Similarity Score (Unixcoder): 0.4435696601867676
Func rank: 91

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: unalias
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004707B3 | 55 | push    rbp
0x004707B4 | 48 89 E5 | mov     rbp, rsp
0x004707B7 | 48 83 EC 20 | sub     rsp, 20h
0x004707BB | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x004707BF | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x004707C3 | 48 89 C7 | mov     rdi, rax
0x004707C6 | E8 97 FD FF FF | call    sub_470562
0x004707CB | 48 89 45 F8 | mov     [rbp+var_8], rax
0x004707CF | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004707D3 | 48 8B 00 | mov     rax, [rax]
0x004707D6 | 48 85 C0 | test    rax, rax
0x004707D9 | 74 35 | jz      short loc_470810
0x004707DB | 48 8B 05 36 CC 2E 00 | mov     rax, cs:qword_75D418
0x004707E2 | 8B 50 30 | mov     edx, [rax+30h]
0x004707E5 | 83 C2 01 | add     edx, 1
0x004707E8 | 89 50 30 | mov     [rax+30h], edx
0x004707EB | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x004707EF | 48 8B 00 | mov     rax, [rax]
0x004707F2 | 48 89 C7 | mov     rdi, rax
0x004707F5 | E8 6E FE FF FF | call    sub_470668
0x004707FA | 48 89 C2 | mov     rdx, rax
0x004707FD | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00470801 | 48 89 10 | mov     [rax], rdx
0x00470804 | E8 36 D8 FF FF | call    sub_46E03F
0x00470809 | B8 00 00 00 00 | mov     eax, 0
0x0047080E | EB 05 | jmp     short locret_470815
0x00470810 | B8 01 00 00 00 | mov     eax, 1
0x00470815 | C9 | leave
0x00470816 | C3 | retn
 ************ 
Source Code:
static int
unalias(const char *name)
{
	struct alias **app;

	app = __lookupalias(name);

	if (*app) {
		INT_OFF;
		*app = freealias(*app);
		INT_ON;
		return 0;
	}

	return 1;
}
 ************ 
Parsed Output:
int processInput(void *input) {
    void *data = sub_470562(input);
    if (data) {
        int *counter = &qword_75D418->field_30;
        *counter += 1;

        void *result = sub_470668(*data);
        *data = result;

        sub_46E03F();
        return 0;
    } else {
        return 1;
    }
}
 ************ 
Similarity Score (Unixcoder): 0.439882755279541
Func rank: 92

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: do_linemode
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0044219F | 55 | push    rbp
0x004421A0 | 48 89 E5 | mov     rbp, rsp
0x004421A3 | B8 F8 B3 75 00 | mov     eax, offset dest
0x004421A8 | C6 40 06 00 | mov     byte ptr [rax+6], 0
0x004421AC | B8 F8 B3 75 00 | mov     eax, offset dest
0x004421B1 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]
0x004421B5 | BA F8 B3 75 00 | mov     edx, offset dest
0x004421BA | 83 E0 FC | and     eax, 0FFFFFFFCh
0x004421BD | 88 42 07 | mov     [rdx+7], al
0x004421C0 | E8 0A FF FF FF | call    sub_4420CF
0x004421C5 | BE 01 00 00 00 | mov     esi, 1
0x004421CA | BF FE 00 00 00 | mov     edi, 0FEh
0x004421CF | E8 93 FC FF FF | call    sub_441E67
0x004421D4 | BE 03 00 00 00 | mov     esi, 3
0x004421D9 | BF FE 00 00 00 | mov     edi, 0FEh
0x004421DE | E8 84 FC FF FF | call    sub_441E67
0x004421E3 | E8 43 F8 FF FF | call    sub_441A2B
0x004421E8 | 90 | nop
0x004421E9 | 5D | pop     rbp
0x004421EA | C3 | retn
 ************ 
Source Code:
static void do_linemode(void)
{
	G.charmode = CHM_TRY;
	G.telflags &= ~(UF_ECHO | UF_SGA);
	setConMode();

	put_iac2(DONT, TELOPT_ECHO);
	put_iac2(DONT, TELOPT_SGA);
	iac_flush();
}
 ************ 
Parsed Output:
void modify_and_process_data() {
    char *dest = (char *)0x75B3F8;
    dest[6] = 0;
    dest[7] &= 0xFC;
    
    sub_4420CF();
    
    sub_441E67(0xFE, 1);
    sub_441E67(0xFE, 3);
    
    sub_441A2B();
}
 ************ 
Similarity Score (Unixcoder): 0.4373627305030823
Func rank: 93

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: casematch
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00476B22 | 55 | push    rbp
0x00476B23 | 48 89 E5 | mov     rbp, rsp
0x00476B26 | 48 83 EC 40 | sub     rsp, 40h
0x00476B2A | 48 89 7D C8 | mov     [rbp+var_38], rdi
0x00476B2E | 48 89 75 C0 | mov     [rbp+var_40], rsi
0x00476B32 | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00476B36 | 48 89 C7 | mov     rdi, rax
0x00476B39 | E8 63 7D FF FF | call    sub_46E8A1
0x00476B3E | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x00476B42 | 48 8B 40 18 | mov     rax, [rax+18h]
0x00476B46 | 48 89 05 83 44 2E 00 | mov     cs:qword_75AFD0, rax
0x00476B4D | 48 8B 05 D4 68 2E 00 | mov     rax, cs:qword_75D428
0x00476B54 | 48 8B 40 10 | mov     rax, [rax+10h]
0x00476B58 | 48 89 05 69 44 2E 00 | mov     cs:qword_75AFC8, rax
0x00476B5F | 48 C7 05 8E 44 2E 00 00 00 00 00 | mov     cs:qword_75AFF8, 0
0x00476B6A | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x00476B6E | 48 8B 40 10 | mov     rax, [rax+10h]
0x00476B72 | BA 00 00 00 00 | mov     edx, 0
0x00476B77 | BE 12 00 00 00 | mov     esi, 12h
0x00476B7C | 48 89 C7 | mov     rdi, rax
0x00476B7F | E8 F5 DB FF FF | call    sub_474779
0x00476B84 | 48 8B 05 9D 68 2E 00 | mov     rax, cs:qword_75D428
0x00476B8B | 48 8B 50 18 | mov     rdx, [rax+18h]
0x00476B8F | 48 8B 05 32 44 2E 00 | mov     rax, cs:qword_75AFC8
0x00476B96 | 48 39 C2 | cmp     rdx, rax
0x00476B99 | 75 0C | jnz     short loc_476BA7
0x00476B9B | E8 A1 80 FF FF | call    sub_46EC41
0x00476BA0 | 48 89 05 21 44 2E 00 | mov     cs:qword_75AFC8, rax
0x00476BA7 | 48 8B 05 1A 44 2E 00 | mov     rax, cs:qword_75AFC8
0x00476BAE | C6 00 00 | mov     byte ptr [rax], 0
0x00476BB1 | 48 8B 05 70 68 2E 00 | mov     rax, cs:qword_75D428
0x00476BB8 | 48 8B 40 10 | mov     rax, [rax+10h]
0x00476BBC | 48 8B 55 C0 | mov     rdx, [rbp+var_40]
0x00476BC0 | 48 89 D6 | mov     rsi, rdx
0x00476BC3 | 48 89 C7 | mov     rdi, rax
0x00476BC6 | E8 10 FF FF FF | call    sub_476ADB
0x00476BCB | 89 45 FC | mov     [rbp+var_4], eax
0x00476BCE | 48 8D 45 D0 | lea     rax, [rbp+var_30]
0x00476BD2 | 48 89 C7 | mov     rdi, rax
0x00476BD5 | E8 2B 7D FF FF | call    sub_46E905
0x00476BDA | 8B 45 FC | mov     eax, [rbp+var_4]
0x00476BDD | C9 | leave
0x00476BDE | C3 | retn
 ************ 
Source Code:
static int
casematch(union node *pattern, char *val)
{
	struct stackmark smark;
	int result;

	setstackmark(&smark);
	argbackq = pattern->narg.backquote;
	STARTSTACKSTR(expdest);
	ifslastp = NULL;
	argstr(pattern->narg.text, EXP_TILDE | EXP_CASE,
			/* var_str_list: */ NULL);
	STACKSTRNUL(expdest);
	result = patmatch(stackblock(), val);
	popstackmark(&smark);
	return result;
}
 ************ 
Parsed Output:
int process_data_structure(void* data_structure, void* additional_data) {
    void* data_structure_field_18;
    void* data_structure_field_10;
    void* global_var_75AFD0;
    void* global_var_75AFC8;
    void* global_var_75D428;
    int result;
    char buffer[48];

    initialize_buffer(buffer);
    data_structure_field_18 = *((void**)((char*)data_structure + 0x18));
    global_var_75AFD0 = data_structure_field_18;

    global_var_75D428 = *((void**)(global_var_75D428 + 0x10));
    global_var_75AFC8 = global_var_75D428;

    global_var_75AFF8 = 0;

    data_structure_field_10 = *((void**)((char*)data_structure + 0x10));
    result = some_function(data_structure_field_10, 0x12, 0);

    if (*((void**)(global_var_75D428 + 0x18)) == global_var_75AFC8) {
        global_var_75AFC8 = another_function();
    }

    *((char*)global_var_75AFC8) = 0;

    data_structure_field_10 = *((void**)(global_var_75D428 + 0x10));
    result = yet_another_function(data_structure_field_10, additional_data);

    finalize_buffer(buffer);

    return result;
}
 ************ 
Similarity Score (Unixcoder): 0.42474910616874695
Func rank: 94

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: clearredir
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00473AA2 | 55 | push    rbp
0x00473AA3 | 48 89 E5 | mov     rbp, rsp
0x00473AA6 | 48 83 EC 10 | sub     rsp, 10h
0x00473AAA | 89 7D FC | mov     [rbp+var_4], edi
0x00473AAD | 48 8B 05 6C 99 2E 00 | mov     rax, cs:qword_75D420
0x00473AB4 | C7 40 20 00 00 00 00 | mov     dword ptr [rax+20h], 0
0x00473ABB | 48 8B 05 5E 99 2E 00 | mov     rax, cs:qword_75D420
0x00473AC2 | 48 8B 40 18 | mov     rax, [rax+18h]
0x00473AC6 | 48 85 C0 | test    rax, rax
0x00473AC9 | 74 11 | jz      short loc_473ADC
0x00473ACB | 8B 45 FC | mov     eax, [rbp+var_4]
0x00473ACE | BE 00 00 00 00 | mov     esi, 0
0x00473AD3 | 89 C7 | mov     edi, eax
0x00473AD5 | E8 99 FE FF FF | call    sub_473973
0x00473ADA | EB D1 | jmp     short loc_473AAD
0x00473ADC | 90 | nop
0x00473ADD | 90 | nop
0x00473ADE | C9 | leave
0x00473ADF | C3 | retn
 ************ 
Source Code:
static void
clearredir(int drop)
{
	for (;;) {
		g_nullredirs = 0;
		if (!redirlist)
			break;
		popredir(drop, /*restore:*/ 0);
	}
}
 ************ 
Parsed Output:
void resetGlobalStructField(int value) {
    extern struct GlobalStruct *globalStructPtr;
    globalStructPtr->field_20 = 0;

    while (globalStructPtr->field_18 != NULL) {
        sub_473973(value, 0);
    }
}
 ************ 
Similarity Score (Unixcoder): 0.42214906215667725
Func rank: 95

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: recalculate_maxsock
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00433F24 | 55 | push    rbp
0x00433F25 | 48 89 E5 | mov     rbp, rsp
0x00433F28 | 48 83 EC 10 | sub     rsp, 10h
0x00433F2C | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0
0x00433F33 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00433F38 | C7 40 24 00 00 00 00 | mov     dword ptr [rax+24h], 0
0x00433F3F | EB 4B | jmp     short loc_433F8C
0x00433F41 | B9 D8 B4 75 00 | mov     ecx, offset qword_75B4D8
0x00433F46 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00433F49 | 8D 50 3F | lea     edx, [rax+3Fh]
0x00433F4C | 85 C0 | test    eax, eax
0x00433F4E | 0F 48 C2 | cmovs   eax, edx
0x00433F51 | C1 F8 06 | sar     eax, 6
0x00433F54 | 48 98 | cdqe
0x00433F56 | 48 8B 34 C1 | mov     rsi, [rcx+rax*8]
0x00433F5A | 8B 45 FC | mov     eax, [rbp+var_4]
0x00433F5D | 99 | cdq
0x00433F5E | C1 EA 1A | shr     edx, 1Ah
0x00433F61 | 01 D0 | add     eax, edx
0x00433F63 | 83 E0 3F | and     eax, 3Fh
0x00433F66 | 29 D0 | sub     eax, edx
0x00433F68 | BA 01 00 00 00 | mov     edx, 1
0x00433F6D | 89 C1 | mov     ecx, eax
0x00433F6F | 48 D3 E2 | shl     rdx, cl
0x00433F72 | 48 89 D0 | mov     rax, rdx
0x00433F75 | 48 21 F0 | and     rax, rsi
0x00433F78 | 48 85 C0 | test    rax, rax
0x00433F7B | 74 0B | jz      short loc_433F88
0x00433F7D | BA F8 B3 75 00 | mov     edx, offset dest
0x00433F82 | 8B 45 FC | mov     eax, [rbp+var_4]
0x00433F85 | 89 42 24 | mov     [rdx+24h], eax
0x00433F88 | 83 45 FC 01 | add     [rbp+var_4], 1
0x00433F8C | B8 F8 B3 75 00 | mov     eax, offset dest
0x00433F91 | 8B 40 28 | mov     eax, [rax+28h]
0x00433F94 | 39 45 FC | cmp     [rbp+var_4], eax
0x00433F97 | 7E A8 | jle     short loc_433F41
0x00433F99 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00433F9E | BA F8 B3 75 00 | mov     edx, offset dest
0x00433FA3 | 8B 40 24 | mov     eax, [rax+24h]
0x00433FA6 | 89 42 28 | mov     [rdx+28h], eax
0x00433FA9 | B8 F8 B3 75 00 | mov     eax, offset dest
0x00433FAE | 8B 40 24 | mov     eax, [rax+24h]
0x00433FB1 | 48 98 | cdqe
0x00433FB3 | BA F8 B3 75 00 | mov     edx, offset dest
0x00433FB8 | 48 8B 12 | mov     rdx, [rdx]
0x00433FBB | 48 83 EA 08 | sub     rdx, 8
0x00433FBF | 48 39 D0 | cmp     rax, rdx
0x00433FC2 | 76 05 | jbe     short loc_433FC9
0x00433FC4 | E8 A1 FD FF FF | call    sub_433D6A
0x00433FC9 | 90 | nop
0x00433FCA | C9 | leave
0x00433FCB | C3 | retn
 ************ 
Source Code:
static void recalculate_maxsock(void)
{
	int fd = 0;

	/* We may have no services, in this case maxsock should still be >= 0
	 * (code elsewhere is not happy with maxsock == -1) */
	maxsock = 0;
	while (fd <= prev_maxsock) {
		if (FD_ISSET(fd, &allsock))
			maxsock = fd;
		fd++;
	}
	dbg("recalculated maxsock:%d
", maxsock);
	prev_maxsock = maxsock;
	if ((rlim_t)maxsock > rlim_ofile_cur - FD_MARGIN)
		bump_nofile();
}
 ************ 
Parsed Output:
void updateDestinationIndex() {
    int index = 0;
    int *dest = (int *)0x75B3F8;
    dest[9] = 0;

    do {
        long long *array = (long long *)0x75B4D8;
        int tempIndex = index;
        if (tempIndex < 0) {
            tempIndex += 63;
        }
        tempIndex >>= 6;
        long long value = array[tempIndex];

        int hash = ((index >> 26) + index) & 0x3F;
        hash -= index >> 26;

        if ((1LL << hash) & value) {
            dest[9] = index;
        }

        index++;
    } while (index <= dest[10]);

    dest[10] = dest[9];
}
 ************ 
Similarity Score (Unixcoder): 0.39029520750045776
Func rank: 96

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: rmaliases
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x00470817 | 55 | push    rbp
0x00470818 | 48 89 E5 | mov     rbp, rsp
0x0047081B | 48 83 EC 20 | sub     rsp, 20h
0x0047081F | 48 8B 05 F2 CB 2E 00 | mov     rax, cs:qword_75D418
0x00470826 | 8B 50 30 | mov     edx, [rax+30h]
0x00470829 | 83 C2 01 | add     edx, 1
0x0047082C | 89 50 30 | mov     [rax+30h], edx
0x0047082F | C7 45 EC 00 00 00 00 | mov     [rbp+var_14], 0
0x00470836 | EB 69 | jmp     short loc_4708A1
0x00470838 | 48 8B 05 51 A7 2E 00 | mov     rax, cs:qword_75AF90
0x0047083F | 8B 55 EC | mov     edx, [rbp+var_14]
0x00470842 | 48 63 D2 | movsxd  rdx, edx
0x00470845 | 48 C1 E2 03 | shl     rdx, 3
0x00470849 | 48 01 D0 | add     rax, rdx
0x0047084C | 48 89 45 F0 | mov     [rbp+var_10], rax
0x00470850 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00470854 | 48 8B 00 | mov     rax, [rax]
0x00470857 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0047085B | EB 39 | jmp     short loc_470896
0x0047085D | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00470861 | 48 8B 00 | mov     rax, [rax]
0x00470864 | 48 89 C7 | mov     rdi, rax
0x00470867 | E8 FC FD FF FF | call    sub_470668
0x0047086C | 48 89 C2 | mov     rdx, rax
0x0047086F | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x00470873 | 48 89 10 | mov     [rax], rdx
0x00470876 | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0047087A | 48 8B 00 | mov     rax, [rax]
0x0047087D | 48 39 45 F8 | cmp     [rbp+var_8], rax
0x00470881 | 75 08 | jnz     short loc_47088B
0x00470883 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x00470887 | 48 89 45 F0 | mov     [rbp+var_10], rax
0x0047088B | 48 8B 45 F0 | mov     rax, [rbp+var_10]
0x0047088F | 48 8B 00 | mov     rax, [rax]
0x00470892 | 48 89 45 F8 | mov     [rbp+var_8], rax
0x00470896 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0
0x0047089B | 75 C0 | jnz     short loc_47085D
0x0047089D | 83 45 EC 01 | add     [rbp+var_14], 1
0x004708A1 | 83 7D EC 26 | cmp     [rbp+var_14], 26h ; '&'
0x004708A5 | 7E 91 | jle     short loc_470838
0x004708A7 | E8 93 D7 FF FF | call    sub_46E03F
0x004708AC | 90 | nop
0x004708AD | C9 | leave
0x004708AE | C3 | retn
 ************ 
Source Code:
static void
rmaliases(void)
{
	struct alias *ap, **app;
	int i;

	INT_OFF;
	for (i = 0; i < ATABSIZE; i++) {
		app = &atab[i];
		for (ap = *app; ap; ap = *app) {
			*app = freealias(*app);
			if (ap == *app) {
				app = &ap->next;
			}
		}
	}
	INT_ON;
}
 ************ 
Parsed Output:
void processElements() {
    extern int64_t qword_75D418;
    extern int64_t qword_75AF90;
    extern void sub_470668(int64_t *);
    extern void sub_46E03F();

    qword_75D418 += 1;
    int var_14 = 0;

    do {
        int64_t *var_10 = (int64_t *)(qword_75AF90 + (var_14 << 3));
        int64_t var_8 = *var_10;

        while (var_8 != 0) {
            var_8 = *var_10;
            int64_t result = sub_470668(var_8);
            *var_10 = result;

            if (var_8 == *var_10) {
                var_10 = &var_8;
            }

            var_8 = *var_10;
        }

        var_14 += 1;
    } while (var_14 <= 0x26);

    sub_46E03F();
}
 ************ 
Similarity Score (Unixcoder): 0.38438868522644043
Func rank: 97

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: do_lzo_decompress
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x004B363F | 55 | push    rbp
0x004B3640 | 48 89 E5 | mov     rbp, rsp
0x004B3643 | 48 81 EC 30 01 00 00 | sub     rsp, 130h
0x004B364A | E8 AF FA FF FF | call    sub_4B30FE
0x004B364F | 48 8D 85 D0 FE FF FF | lea     rax, [rbp+var_130]
0x004B3656 | 48 89 C7 | mov     rdi, rax
0x004B3659 | E8 81 FE FF FF | call    sub_4B34DF
0x004B365E | 48 8D 85 D0 FE FF FF | lea     rax, [rbp+var_130]
0x004B3665 | 48 89 C7 | mov     rdi, rax
0x004B3668 | E8 86 F7 FF FF | call    sub_4B2DF3
0x004B366D | C9 | leave
0x004B366E | C3 | retn
 ************ 
Source Code:
static smallint do_lzo_decompress(void)
{
	header_t header;

	check_magic();
	p_header(&header);
	return lzo_decompress(&header);
}
 ************ 
Parsed Output:
void performOperations() {
    char buffer[288];
    initializeBuffer();
    processBuffer(buffer);
    finalizeBuffer(buffer);
}
 ************ 
Similarity Score (Unixcoder): 0.3738855719566345
Func rank: 98

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: rtnl_rtcache_request
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0044DBD3 | 55 | push    rbp
0x0044DBD4 | 48 89 E5 | mov     rbp, rsp
0x0044DBD7 | 48 83 EC 40 | sub     rsp, 40h
0x0044DBDB | 48 89 7D C8 | mov     [rbp+var_38], rdi
0x0044DBDF | 89 75 C4 | mov     [rbp+var_3C], esi
0x0044DBE2 | 48 8D 45 D4 | lea     rax, [rbp+s]
0x0044DBE6 | BA 0C 00 00 00 | mov     edx, 0Ch; n
0x0044DBEB | BE 00 00 00 00 | mov     esi, 0; c
0x0044DBF0 | 48 89 C7 | mov     rdi, rax; s
0x0044DBF3 | E8 58 91 FB FF | call    _memset
0x0044DBF8 | 48 8D 45 E0 | lea     rax, [rbp+var_20]
0x0044DBFC | BA 1C 00 00 00 | mov     edx, 1Ch; n
0x0044DC01 | BE 00 00 00 00 | mov     esi, 0; c
0x0044DC06 | 48 89 C7 | mov     rdi, rax; s
0x0044DC09 | E8 42 91 FB FF | call    _memset
0x0044DC0E | 66 C7 45 D4 10 00 | mov     [rbp+s], 10h
0x0044DC14 | C7 45 E0 1C 00 00 00 | mov     [rbp+var_20], 1Ch
0x0044DC1B | 66 C7 45 E4 1A 00 | mov     [rbp+var_1C], 1Ah
0x0044DC21 | 66 C7 45 E6 01 01 | mov     [rbp+var_1A], 101h
0x0044DC27 | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x0044DC2B | 8B 40 1C | mov     eax, [rax+1Ch]
0x0044DC2E | 8D 50 01 | lea     edx, [rax+1]
0x0044DC31 | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x0044DC35 | 89 50 1C | mov     [rax+1Ch], edx
0x0044DC38 | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x0044DC3C | 8B 50 1C | mov     edx, [rax+1Ch]
0x0044DC3F | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x0044DC43 | 89 50 20 | mov     [rax+20h], edx
0x0044DC46 | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x0044DC4A | 8B 40 20 | mov     eax, [rax+20h]
0x0044DC4D | 89 45 E8 | mov     [rbp+var_18], eax
0x0044DC50 | 8B 45 C4 | mov     eax, [rbp+var_3C]
0x0044DC53 | 88 45 F0 | mov     [rbp+var_10], al
0x0044DC56 | C7 45 F8 00 02 00 00 | mov     [rbp+var_8], 200h
0x0044DC5D | 48 8B 45 C8 | mov     rax, [rbp+var_38]
0x0044DC61 | 8B 00 | mov     eax, [rax]
0x0044DC63 | 48 8D 55 D4 | lea     rdx, [rbp+s]
0x0044DC67 | 48 8D 75 E0 | lea     rsi, [rbp+var_20]
0x0044DC6B | 41 B8 0C 00 00 00 | mov     r8d, 0Ch
0x0044DC71 | 48 89 D1 | mov     rcx, rdx
0x0044DC74 | BA 1C 00 00 00 | mov     edx, 1Ch
0x0044DC79 | 89 C7 | mov     edi, eax
0x0044DC7B | E8 C8 CD FB FF | call    sub_40AA48
0x0044DC80 | C9 | leave
0x0044DC81 | C3 | retn
 ************ 
Source Code:
static int rtnl_rtcache_request(struct rtnl_handle *rth, int family)
{
	struct {
		struct nlmsghdr nlh;
		struct rtmsg rtm;
	} req;
	struct sockaddr_nl nladdr;

	memset(&nladdr, 0, sizeof(nladdr));
	memset(&req, 0, sizeof(req));
	nladdr.nl_family = AF_NETLINK;

	req.nlh.nlmsg_len = sizeof(req);
	if (RTM_GETROUTE)
		req.nlh.nlmsg_type = RTM_GETROUTE;
	if (NLM_F_ROOT | NLM_F_REQUEST)
		req.nlh.nlmsg_flags = NLM_F_ROOT | NLM_F_REQUEST;
	/*req.nlh.nlmsg_pid = 0; - memset did it already */
	req.nlh.nlmsg_seq = rth->dump = ++rth->seq;
	req.rtm.rtm_family = family;
	if (RTM_F_CLONED)
		req.rtm.rtm_flags = RTM_F_CLONED;

	return xsendto(rth->fd, (void*)&req, sizeof(req), (struct sockaddr*)&nladdr, sizeof(nladdr));
}
 ************ 
Parsed Output:
#include <string.h>

void updateStructure(int value, void *structure) {
    char s[12];
    int var_20[7];
    int var_18;
    char var_10;
    int var_8 = 512;

    memset(s, 0, sizeof(s));
    memset(var_20, 0, sizeof(var_20));

    s[0] = 0x10;
    var_20[0] = 0x1C;
    var_20[1] = 0x1A;
    var_20[2] = 0x101;

    int *struct_ptr = (int *)structure;
    struct_ptr[7] += 1;
    struct_ptr[8] = struct_ptr[7];

    var_18 = struct_ptr[8];
    var_10 = value & 0xFF;

    sub_40AA48(value, s, var_20, 0x1C, 0x0C);
}
 ************ 
Similarity Score (Unixcoder): 0.3485684394836426
Func rank: 99

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------

Function Name: add_peers
 ************ 
Input: # Task Description

You are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.


# Input & Output format

Your input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. 


# Detailed Requirements

Specifically, you should perform the following steps to finish this task:

1. You should first read the provided assembly instructions, and transform them into the C-like source code format. The C-like pseudocode code should have the identical function with the assembly code.
2. You will then revise the C-like code to make it more readable. Specifically, you should do the following (but not limited to them):
 - Re-structure the code structure to make it close to the human-written source code.
 - Recover the variable names and types based on your observations on the specific code. DO NOT keep the register names such as ebx, edi...
 - Do not use "goto", "LABEL xxx", "loc_xxx" in C-like source code output.
 - The revised C-like code should maintain the same functionality with the original C-like code, and the assembly code.
 - You should eliminate all Non-idiomatic expressions (e.g., '*_DWORD', '*_QWORD', 'LOBYTE', 'HIBYTE' expression in IDA pro), and make the revised code as close as possible to the original source code.
 - You should rename the decompiled function with a informative name.

# Data to be processed

Below is the assembly code you will process. You will analyze the code and output the decompiled code:
0x0043B939 | 55 | push    rbp
0x0043B93A | 48 89 E5 | mov     rbp, rsp
0x0043B93D | 48 83 EC 20 | sub     rsp, 20h
0x0043B941 | 48 89 7D E8 | mov     [rbp+var_18], rdi
0x0043B945 | BF 70 01 00 00 | mov     edi, 170h
0x0043B94A | E8 99 E7 FC FF | call    sub_40A0E8
0x0043B94F | 48 89 45 F8 | mov     [rbp+var_8], rax
0x0043B953 | 48 8B 45 E8 | mov     rax, [rbp+var_18]
0x0043B957 | BE 7B 00 00 00 | mov     esi, 7Bh ; '{'
0x0043B95C | 48 89 C7 | mov     rdi, rax
0x0043B95F | E8 C6 01 0D 00 | call    sub_50BB2A
0x0043B964 | 48 89 C2 | mov     rdx, rax
0x0043B967 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B96B | 48 89 10 | mov     [rax], rdx
0x0043B96E | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B972 | 48 8B 00 | mov     rax, [rax]
0x0043B975 | 48 83 C0 04 | add     rax, 4
0x0043B979 | 48 89 C7 | mov     rdi, rax
0x0043B97C | E8 5D 06 0D 00 | call    sub_50BFDE
0x0043B981 | 48 89 C2 | mov     rdx, rax
0x0043B984 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B988 | 48 89 50 08 | mov     [rax+8], rdx
0x0043B98C | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B990 | C7 40 10 FF FF FF FF | mov     dword ptr [rax+10h], 0FFFFFFFFh
0x0043B997 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B99B | C6 80 28 01 00 00 23 | mov     byte ptr [rax+128h], 23h ; '#'
0x0043B9A2 | 48 8B 05 5F 1A 32 00 | mov     rax, cs:qword_75D408
0x0043B9A9 | F2 0F 10 00 | movsd   xmm0, qword ptr [rax]
0x0043B9AD | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B9B1 | F2 0F 11 40 20 | movsd   qword ptr [rax+20h], xmm0
0x0043B9B6 | F2 0F 10 05 92 A3 0E 00 | movsd   xmm0, cs:qword_525D50
0x0043B9BE | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B9C2 | 48 89 C7 | mov     rdi, rax
0x0043B9C5 | E8 82 FD FF FF | call    sub_43B74C
0x0043B9CA | 48 8B 05 37 1A 32 00 | mov     rax, cs:qword_75D408
0x0043B9D1 | 48 8D 50 30 | lea     rdx, [rax+30h]
0x0043B9D5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]
0x0043B9D9 | 48 89 C6 | mov     rsi, rax
0x0043B9DC | 48 89 D7 | mov     rdi, rdx
0x0043B9DF | E8 EE D5 FC FF | call    sub_408FD2
0x0043B9E4 | 48 8B 05 1D 1A 32 00 | mov     rax, cs:qword_75D408
0x0043B9EB | 8B 50 40 | mov     edx, [rax+40h]
0x0043B9EE | 83 C2 01 | add     edx, 1
0x0043B9F1 | 89 50 40 | mov     [rax+40h], edx
0x0043B9F4 | 90 | nop
0x0043B9F5 | C9 | leave
0x0043B9F6 | C3 | retn
 ************ 
Source Code:
static void
add_peers(char *s)
{
	peer_t *p;

	p = xzalloc(sizeof(*p));
	p->p_lsa = xhost2sockaddr(s, 123);
	p->p_dotted = xmalloc_sockaddr2dotted_noport(&p->p_lsa->u.sa);
	p->p_fd = -1;
	p->p_xmt_msg.m_status = MODE_CLIENT | (NTP_VERSION << 3);
	p->next_action_time = G.cur_time; /* = set_next(p, 0); */
	reset_peer_stats(p, 16 * STEP_THRESHOLD);

	llist_add_to(&G.ntp_peers, p);
	G.peer_cnt++;
}
 ************ 
Parsed Output:
#include <stdint.h>

void* sub_40A0E8(size_t size);
void* sub_50BB2A(const char* str, char c);
void sub_50BFDE(void* ptr);
void sub_43B74C(void* ptr);
void sub_408FD2(void* dst, void* src);

typedef struct {
    void* ptr1;
    void* ptr2;
    int32_t val;
    char padding[0x118];
    char specialChar;
    double someDouble;
} CustomStruct;

typedef struct {
    double someValue;
    char padding[0x30];
    int32_t counter;
} GlobalStruct;

extern GlobalStruct* qword_75D408;
extern double qword_525D50;

CustomStruct* createCustomStruct(void) {
    CustomStruct* customStruct = sub_40A0E8(0x170);
    customStruct->ptr1 = sub_50BB2A((const char*)customStruct, '{');
    customStruct->ptr2 = sub_50BFDE(customStruct->ptr1 + 4);
    customStruct->val = -1;
    customStruct->specialChar = '#';
    customStruct->someDouble = qword_75D408->someValue;
    sub_43B74C(customStruct);
    sub_408FD2((void*)((uintptr_t)qword_75D408 + 0x30), customStruct);
    qword_75D408->counter += 1;
    return customStruct;
}
 ************ 
Similarity Score (Unixcoder): 0.3123181462287903
Func rank: 100

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


--------------------------------------------------------------------------------


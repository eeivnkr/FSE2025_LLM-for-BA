[
    {
        "func_name": "bb_info_msg",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x001453BC | 0F 00 2D E9 | PUSH    {R0-R3}\n0x001453C0 | 00 48 2D E9 | PUSH    {R11,LR}\n0x001453C4 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x001453C8 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x001453CC | D0 30 9F E5 | LDR     R3, =logmode\n0x001453D0 | 00 30 93 E5 | LDR     R3, [R3]\n0x001453D4 | 00 00 53 E3 | CMP     R3, #0\n0x001453D8 | 2A 00 00 0A | BEQ     loc_145488\n0x001453DC | 08 30 8B E2 | ADD     R3, R11, #8\n0x001453E0 | 10 30 0B E5 | STR     R3, [R11,#p]\n0x001453E4 | 0C 30 4B E2 | SUB     R3, R11, #-msg\n0x001453E8 | 10 20 1B E5 | LDR     R2, [R11,#p]; va_list\n0x001453EC | 04 10 9B E5 | LDR     R1, [R11,#s]; char *\n0x001453F0 | 03 00 A0 E1 | MOV     R0, R3; char **\n0x001453F4 | 35 3E FB EB | BL      vasprintf\n0x001453F8 | 08 00 0B E5 | STR     R0, [R11,#used]\n0x001453FC | 08 30 1B E5 | LDR     R3, [R11,#used]\n0x00145400 | 00 00 53 E3 | CMP     R3, #0\n0x00145404 | 21 00 00 BA | BLT     loc_145490\n0x00145408 | 94 30 9F E5 | LDR     R3, =logmode\n0x0014540C | 00 30 93 E5 | LDR     R3, [R3]\n0x00145410 | 02 30 03 E2 | AND     R3, R3, #2\n0x00145414 | 00 00 53 E3 | CMP     R3, #0\n0x00145418 | 04 00 00 0A | BEQ     loc_145430\n0x0014541C | 0C 30 1B E5 | LDR     R3, [R11,#msg]\n0x00145420 | 03 20 A0 E1 | MOV     R2, R3\n0x00145424 | 7C 10 9F E5 | LDR     R1, =aS_122; \"%s\"\n0x00145428 | 06 00 A0 E3 | MOV     R0, #6; pri\n0x0014542C | 8D 41 FB EB | BL      syslog\n0x00145430 | 6C 30 9F E5 | LDR     R3, =logmode\n0x00145434 | 00 30 93 E5 | LDR     R3, [R3]\n0x00145438 | 01 30 03 E2 | AND     R3, R3, #1\n0x0014543C | 00 00 53 E3 | CMP     R3, #0\n0x00145440 | 0C 00 00 0A | BEQ     loc_145478\n0x00145444 | 72 53 FB EB | BL      fflush_all\n0x00145448 | 0C 20 1B E5 | LDR     R2, [R11,#msg]\n0x0014544C | 08 30 1B E5 | LDR     R3, [R11,#used]\n0x00145450 | 01 10 83 E2 | ADD     R1, R3, #1\n0x00145454 | 08 10 0B E5 | STR     R1, [R11,#used]\n0x00145458 | 03 30 82 E0 | ADD     R3, R2, R3\n0x0014545C | 0A 20 A0 E3 | MOV     R2, #0xA\n0x00145460 | 00 20 C3 E5 | STRB    R2, [R3]\n0x00145464 | 0C 30 1B E5 | LDR     R3, [R11,#msg]\n0x00145468 | 08 20 1B E5 | LDR     R2, [R11,#used]; len\n0x0014546C | 03 10 A0 E1 | MOV     R1, R3; buf\n0x00145470 | 01 00 A0 E3 | MOV     R0, #1; fd\n0x00145474 | 6F 57 FB EB | BL      full_write\n0x00145478 | 0C 30 1B E5 | LDR     R3, [R11,#msg]\n0x0014547C | 03 00 A0 E1 | MOV     R0, R3; ptr\n0x00145480 | 8A 3E FB EB | BL      free\n0x00145484 | 02 00 00 EA | B       loc_145494\n0x00145488 | 00 00 A0 E1 | NOP\n0x0014548C | 00 00 00 EA | B       loc_145494\n0x00145490 | 00 00 A0 E1 | NOP\n0x00145494 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00145498 | 00 48 BD E8 | POP     {R11,LR}\n0x0014549C | 10 D0 8D E2 | ADD     SP, SP, #0x10\n0x001454A0 | 1E FF 2F E1 | BX      LR",
        "output": "```c\nvoid function() {\n    int logmode = *logmode;\n    if (logmode != 0) {\n        char* p = &msg;\n        va_list va;\n        char* s = &s;\n        int used = vasprintf(&p, s, &va);\n        if (used >= 0) {\n            if (logmode & 2) {\n                syslog(aS_122, 6, p);\n            }\n            if (logmode & 1) {\n                fflush_all();\n            }\n            int len = used + 1;\n            char* buf = &msg + used;\n            *buf = '\\n';\n            full_write(1, buf, len);\n            free(p);\n        }\n    }\n}\n```"
    },
    {
        "func_name": "chargen_stream",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0004F1A8 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0004F1AC | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0004F1B0 | 60 D0 4D E2 | SUB     SP, SP, #0x60\n0x0004F1B4 | 60 00 0B E5 | STR     R0, [R11,#s]\n0x0004F1B8 | 64 10 0B E5 | STR     R1, [R11,#sep]\n0x0004F1BC | D8 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004F1C0 | 40 30 93 E5 | LDR     R3, [R3,#(dst.data - 0x18F9D8)]\n0x0004F1C4 | 00 00 53 E3 | CMP     R3, #0\n0x0004F1C8 | 02 00 00 1A | BNE     loc_4F1D8\n0x0004F1CC | D9 FF FF EB | BL      init_ring\n0x0004F1D0 | C8 30 9F E5 | LDR     R3, =(dst.data+8)\n0x0004F1D4 | 08 30 0B E5 | STR     R3, [R11,#rs]\n0x0004F1D8 | 0D 30 A0 E3 | MOV     R3, #0xD\n0x0004F1DC | 10 30 4B E5 | STRB    R3, [R11,#text+0x48]\n0x0004F1E0 | 0A 30 A0 E3 | MOV     R3, #0xA\n0x0004F1E4 | 0F 30 4B E5 | STRB    R3, [R11,#text+0x49]\n0x0004F1E8 | B0 30 9F E5 | LDR     R3, =(dst.data+8)\n0x0004F1EC | 08 30 0B E5 | STR     R3, [R11,#rs]\n0x0004F1F0 | A4 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004F1F4 | 40 20 93 E5 | LDR     R2, [R3,#(dst.data - 0x18F9D8)]\n0x0004F1F8 | 08 30 1B E5 | LDR     R3, [R11,#rs]\n0x0004F1FC | 03 30 42 E0 | SUB     R3, R2, R3\n0x0004F200 | 0C 30 0B E5 | STR     R3, [R11,#len]\n0x0004F204 | 0C 30 1B E5 | LDR     R3, [R11,#len]\n0x0004F208 | 47 00 53 E3 | CMP     R3, #0x47 ; 'G'\n0x0004F20C | 05 00 00 DA | BLE     loc_4F228\n0x0004F210 | 58 30 4B E2 | SUB     R3, R11, #-text\n0x0004F214 | 48 20 A0 E3 | MOV     R2, #0x48 ; 'H'; n\n0x0004F218 | 08 10 1B E5 | LDR     R1, [R11,#rs]; src\n0x0004F21C | 03 00 A0 E1 | MOV     R0, R3; dest\n0x0004F220 | 1C 17 FF EB | BL      memmove\n0x0004F224 | 0C 00 00 EA | B       loc_4F25C\n0x0004F228 | 0C 20 1B E5 | LDR     R2, [R11,#len]; n\n0x0004F22C | 58 30 4B E2 | SUB     R3, R11, #-text\n0x0004F230 | 08 10 1B E5 | LDR     R1, [R11,#rs]; src\n0x0004F234 | 03 00 A0 E1 | MOV     R0, R3; dest\n0x0004F238 | 16 17 FF EB | BL      memmove\n0x0004F23C | 0C 30 1B E5 | LDR     R3, [R11,#len]\n0x0004F240 | 58 20 4B E2 | SUB     R2, R11, #-text\n0x0004F244 | 03 00 82 E0 | ADD     R0, R2, R3; dest\n0x0004F248 | 50 10 9F E5 | LDR     R1, =(dst.data+8); src\n0x0004F24C | 0C 30 1B E5 | LDR     R3, [R11,#len]\n0x0004F250 | 48 30 63 E2 | RSB     R3, R3, #0x48 ; 'H'\n0x0004F254 | 03 20 A0 E1 | MOV     R2, R3; n\n0x0004F258 | 0E 17 FF EB | BL      memmove\n0x0004F25C | 08 30 1B E5 | LDR     R3, [R11,#rs]\n0x0004F260 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0004F264 | 08 30 0B E5 | STR     R3, [R11,#rs]\n0x0004F268 | 2C 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004F26C | 40 30 93 E5 | LDR     R3, [R3,#(dst.data - 0x18F9D8)]\n0x0004F270 | 08 20 1B E5 | LDR     R2, [R11,#rs]\n0x0004F274 | 03 00 52 E1 | CMP     R2, R3\n0x0004F278 | 01 00 00 1A | BNE     loc_4F284\n0x0004F27C | 1C 30 9F E5 | LDR     R3, =(dst.data+8)\n0x0004F280 | 08 30 0B E5 | STR     R3, [R11,#rs]\n0x0004F284 | 58 30 4B E2 | SUB     R3, R11, #-text\n0x0004F288 | 4A 20 A0 E3 | MOV     R2, #0x4A ; 'J'; count\n0x0004F28C | 03 10 A0 E1 | MOV     R1, R3; buf\n0x0004F290 | 60 00 1B E5 | LDR     R0, [R11,#s]; fd\n0x0004F294 | 54 2B FF EB | BL      xwrite\n0x0004F298 | D4 FF FF EA | B       loc_4F1F0",
        "output": "```c\nvoid function(int fd, char* buf, int count) {\n    int s = 0;\n    int sep = 0;\n    char* rs = buf;\n    int len = count;\n    \n    if (dst.data == NULL) {\n        init_ring();\n    }\n    \n    rs = dst.data + 8;\n    buf[s + 0x48] = 0xD;\n    buf[s + 0x49] = 0xA;\n    \n    int n = dst.data + 8 - rs;\n    int cmp = len - n;\n    if (cmp <= 0x47) {\n        memmove(rs, buf, n);\n    } else {\n        memmove(rs, buf, len);\n        memmove(rs, dst.data + 8, len - 0x48);\n    }\n    \n    rs++;\n    if (rs == dst.data + 8) {\n        rs = dst.data + 8;\n    }\n    \n    int cmp2 = rs - dst.data;\n    if (cmp2 != 0) {\n        memmove(rs, dst.data + 8, cmp2);\n    }\n    \n    xwrite(fd, buf, count);\n}\n```"
    },
    {
        "func_name": "out_char",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00086E80 | 00 48 2D E9 | PUSH    {R11,LR}\n0x00086E84 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00086E88 | 08 D0 4D E2 | SUB     SP, SP, #8\n0x00086E8C | 00 30 A0 E1 | MOV     R3, R0\n0x00086E90 | 05 30 4B E5 | STRB    R3, [R11,#c]\n0x00086E94 | 70 30 9F E5 | LDR     R3, =ptr_to_globals\n0x00086E98 | 00 30 93 E5 | LDR     R3, [R3]\n0x00086E9C | 00 20 93 E5 | LDR     R2, [R3]\n0x00086EA0 | 01 20 82 E2 | ADD     R2, R2, #1\n0x00086EA4 | 00 20 83 E5 | STR     R2, [R3]\n0x00086EA8 | 5C 30 9F E5 | LDR     R3, =ptr_to_globals\n0x00086EAC | 00 30 93 E5 | LDR     R3, [R3]\n0x00086EB0 | 00 20 93 E5 | LDR     R2, [R3]\n0x00086EB4 | 50 30 9F E5 | LDR     R3, =ptr_to_globals\n0x00086EB8 | 00 30 93 E5 | LDR     R3, [R3]\n0x00086EBC | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x00086EC0 | 03 00 52 E1 | CMP     R2, R3\n0x00086EC4 | 0D 00 00 8A | BHI     loc_86F00\n0x00086EC8 | 3C 30 9F E5 | LDR     R3, =ptr_to_globals\n0x00086ECC | 00 30 93 E5 | LDR     R3, [R3]\n0x00086ED0 | 00 20 93 E5 | LDR     R2, [R3]\n0x00086ED4 | 30 30 9F E5 | LDR     R3, =ptr_to_globals\n0x00086ED8 | 00 30 93 E5 | LDR     R3, [R3]\n0x00086EDC | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x00086EE0 | 03 00 52 E1 | CMP     R2, R3\n0x00086EE4 | 01 00 00 1A | BNE     loc_86EF0\n0x00086EE8 | 2B 30 A0 E3 | MOV     R3, #0x2B ; '+'\n0x00086EEC | 05 30 4B E5 | STRB    R3, [R11,#c]\n0x00086EF0 | 05 30 5B E5 | LDRB    R3, [R11,#c]\n0x00086EF4 | 03 00 A0 E1 | MOV     R0, R3; c\n0x00086EF8 | A3 3B FE EB | BL      putchar_unlocked\n0x00086EFC | 00 00 00 EA | B       loc_86F04\n0x00086F00 | 00 00 A0 E1 | NOP\n0x00086F04 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00086F08 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(int c) {\n    // Save R11 and LR onto the stack\n    __asm__(\"PUSH {R11, LR}\");\n\n    // Set R11 to the current stack pointer + 4\n    __asm__(\"ADD R11, SP, #4\");\n\n    // Allocate 8 bytes on the stack\n    __asm__(\"SUB SP, SP, #8\");\n\n    // Move the value of R0 into R3\n    __asm__(\"MOV R3, R0\");\n\n    // Store the value of R3 at [R11 + 0xc]\n    __asm__(\"STRB R3, [R11, #0xc]\");\n\n    // Load the address of ptr_to_globals into R3\n    __asm__(\"LDR R3, =ptr_to_globals\");\n\n    // Load the value at [R3] into R3\n    __asm__(\"LDR R3, [R3]\");\n\n    // Load the value at [R3] into R2\n    __asm__(\"LDR R2, [R3]\");\n\n    // Add 1 to the value of R2\n    __asm__(\"ADD R2, R2, #1\");\n\n    // Store the value of R2 at [R3]\n    __asm__(\"STR R2, [R3]\");\n\n    // Load the address of ptr_to_globals into R3\n    __asm__(\"LDR R3, =ptr_to_globals\");\n\n    // Load the value at [R3] into R3\n    __asm__(\"LDR R3, [R3]\");\n\n    // Load the value at [R3] into R2\n    __asm__(\"LDR R2, [R3]\");\n\n    // Load the address of ptr_to_globals into R3\n    __asm__(\"LDR R3, =ptr_to_globals\");\n\n    // Load the value at [R3] into R3\n    __asm__(\"LDR R3, [R3]\");\n\n    // Load the value at [R3 + 4] into R3\n    __asm__(\"LDR R3, [R3, #4]\");\n\n    // Compare the values of R2 and R3\n    __asm__(\"CMP R2, R3\");\n\n    // Branch if R2 is higher than R3 to loc_86F00\n    __asm__(\"BHI loc_86F00\");\n\n    // Load the address of ptr_to_globals into R3\n    __asm__(\"LDR R3, =ptr_to_globals\");\n\n    // Load the value at [R3] into R3\n    __asm__(\"LDR R3, [R3]\");\n\n    // Load the value at [R3] into R2\n    __asm__(\"LDR R2, [R3]\");\n\n    // Load the address of ptr_to_globals into R3\n    __asm__(\"LDR R3, =ptr_to_globals\");\n\n    // Load the value at [R3] into R3\n    __asm__(\"LDR R3, [R3]\");\n\n    // Load the value at [R3 + 4] into R3\n    __asm__(\"LDR R3, [R3, #4]\");\n\n    // Compare the values of R2 and R3\n    __asm__(\"CMP R2, R3\");\n\n    // Branch if R2 is not equal to R3 to loc_86EF0\n    __asm__(\"BNE loc_86EF0\");\n\n    // Move the value 0x2B into R3\n    __asm__(\"MOV R3, #0x2B\");\n\n    // Store the value of R3 at [R11 + 0xc]\n    __asm__(\"STRB R3, [R11, #0xc]\");\n\n    // Load the value at [R11 + 0xc] into R3\n    __asm__(\"LDRB R3, [R11, #0xc]\");\n\n    // Move the value of R3 into R0\n    __asm__(\"MOV R0, R3\");\n\n    // Call the putchar_unlocked function\n    __asm__(\"BL putchar_unlocked\");\n\n    // Branch to loc_86F04\n    __asm__(\"B loc_86F04\");\n\nloc_86F00:\n    // No operation\n\nloc_86F04:\n    // Restore the stack pointer to R11 - 4\n    __asm__(\"SUB SP, R11, #4\");\n\n    // Restore R11 and PC from the stack\n    __asm__(\"POP {R11, PC}\");\n}\n```"
    },
    {
        "func_name": "mesg_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0013BEB8 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0013BEBC | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0013BEC0 | 78 D0 4D E2 | SUB     SP, SP, #0x78\n0x0013BEC4 | 78 00 0B E5 | STR     R0, [R11,#argc]\n0x0013BEC8 | 7C 10 0B E5 | STR     R1, [R11,#argv]\n0x0013BECC | 00 30 A0 E3 | MOV     R3, #0\n0x0013BED0 | 05 30 4B E5 | STRB    R3, [R11,#c]\n0x0013BED4 | 7C 30 1B E5 | LDR     R3, [R11,#argv]\n0x0013BED8 | 04 30 83 E2 | ADD     R3, R3, #4\n0x0013BEDC | 7C 30 0B E5 | STR     R3, [R11,#argv]\n0x0013BEE0 | 7C 30 1B E5 | LDR     R3, [R11,#argv]\n0x0013BEE4 | 00 30 93 E5 | LDR     R3, [R3]\n0x0013BEE8 | 00 00 53 E3 | CMP     R3, #0\n0x0013BEEC | 0F 00 00 0A | BEQ     loc_13BF30\n0x0013BEF0 | 7C 30 1B E5 | LDR     R3, [R11,#argv]\n0x0013BEF4 | 04 30 83 E2 | ADD     R3, R3, #4\n0x0013BEF8 | 00 30 93 E5 | LDR     R3, [R3]\n0x0013BEFC | 00 00 53 E3 | CMP     R3, #0\n0x0013BF00 | 09 00 00 1A | BNE     loc_13BF2C\n0x0013BF04 | 7C 30 1B E5 | LDR     R3, [R11,#argv]\n0x0013BF08 | 00 30 93 E5 | LDR     R3, [R3]\n0x0013BF0C | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0013BF10 | 05 30 4B E5 | STRB    R3, [R11,#c]\n0x0013BF14 | 05 30 5B E5 | LDRB    R3, [R11,#c]\n0x0013BF18 | 79 00 53 E3 | CMP     R3, #0x79 ; 'y'\n0x0013BF1C | 03 00 00 0A | BEQ     loc_13BF30\n0x0013BF20 | 05 30 5B E5 | LDRB    R3, [R11,#c]\n0x0013BF24 | 6E 00 53 E3 | CMP     R3, #0x6E ; 'n'\n0x0013BF28 | 00 00 00 0A | BEQ     loc_13BF30\n0x0013BF2C | 6E 6C FB EB | BL      bb_show_usage\n0x0013BF30 | 00 00 A0 E3 | MOV     R0, #0; fd\n0x0013BF34 | 5B 67 FB EB | BL      isatty\n0x0013BF38 | 00 30 A0 E1 | MOV     R3, R0\n0x0013BF3C | 00 00 53 E3 | CMP     R3, #0\n0x0013BF40 | 01 00 00 1A | BNE     loc_13BF4C\n0x0013BF44 | 9C 00 9F E5 | LDR     R0, =aNotATty_1; \"not a tty\"\n0x0013BF48 | 92 73 FB EB | BL      bb_error_msg_and_die\n0x0013BF4C | 74 30 4B E2 | SUB     R3, R11, #-sb\n0x0013BF50 | 94 20 9F E5 | LDR     R2, =aStderr_0; \"stderr\"\n0x0013BF54 | 03 10 A0 E1 | MOV     R1, R3; stat_buf\n0x0013BF58 | 00 00 A0 E3 | MOV     R0, #0; fd\n0x0013BF5C | F2 79 FB EB | BL      xfstat\n0x0013BF60 | 05 30 5B E5 | LDRB    R3, [R11,#c]\n0x0013BF64 | 00 00 53 E3 | CMP     R3, #0\n0x0013BF68 | 0A 00 00 1A | BNE     loc_13BF98\n0x0013BF6C | 64 30 1B E5 | LDR     R3, [R11,#sb.st_mode]\n0x0013BF70 | 12 30 03 E2 | AND     R3, R3, #0x12\n0x0013BF74 | 00 00 53 E3 | CMP     R3, #0\n0x0013BF78 | 01 00 00 0A | BEQ     loc_13BF84\n0x0013BF7C | 6C 30 9F E5 | LDR     R3, =aIsY; \"is y\"\n0x0013BF80 | 00 00 00 EA | B       loc_13BF88\n0x0013BF84 | 68 30 9F E5 | LDR     R3, =aIsN; \"is n\"\n0x0013BF88 | 03 00 A0 E1 | MOV     R0, R3; s\n0x0013BF8C | 11 65 FB EB | BL      puts\n0x0013BF90 | 00 30 A0 E3 | MOV     R3, #0\n0x0013BF94 | 10 00 00 EA | B       loc_13BFDC\n0x0013BF98 | 05 30 5B E5 | LDRB    R3, [R11,#c]\n0x0013BF9C | 79 00 53 E3 | CMP     R3, #0x79 ; 'y'\n0x0013BFA0 | 02 00 00 1A | BNE     loc_13BFB0\n0x0013BFA4 | 64 30 1B E5 | LDR     R3, [R11,#sb.st_mode]\n0x0013BFA8 | 10 30 83 E3 | ORR     R3, R3, #0x10\n0x0013BFAC | 01 00 00 EA | B       loc_13BFB8\n0x0013BFB0 | 64 30 1B E5 | LDR     R3, [R11,#sb.st_mode]\n0x0013BFB4 | 12 30 C3 E3 | BIC     R3, R3, #0x12\n0x0013BFB8 | 0C 30 0B E5 | STR     R3, [R11,#m]\n0x0013BFBC | 0C 10 1B E5 | LDR     R1, [R11,#m]; mode\n0x0013BFC0 | 00 00 A0 E3 | MOV     R0, #0; fd\n0x0013BFC4 | 76 67 FB EB | BL      fchmod\n0x0013BFC8 | 00 30 A0 E1 | MOV     R3, R0\n0x0013BFCC | 00 00 53 E3 | CMP     R3, #0\n0x0013BFD0 | 00 00 00 0A | BEQ     loc_13BFD8\n0x0013BFD4 | C5 3F 00 EB | BL      bb_perror_nomsg_and_die\n0x0013BFD8 | 00 30 A0 E3 | MOV     R3, #0\n0x0013BFDC | 03 00 A0 E1 | MOV     R0, R3\n0x0013BFE0 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0013BFE4 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(int argc, char** argv) {\n    int c = 0;\n    argv[argc] = 0;\n    if (argv[argc + 1] != 0) {\n        if (argv[argc + 1][0] != 0) {\n            c = argv[argc + 1][0];\n            if (c == 'y') {\n                bb_show_usage();\n            } else if (c == 'n') {\n                if (isatty(0) == 0) {\n                    bb_error_msg_and_die(\"not a tty\");\n                }\n                struct stat sb;\n                if (xfstat(2, &sb) == 0) {\n                    if ((sb.st_mode & 0x12) != 0) {\n                        puts(\"is y\");\n                    } else {\n                        puts(\"is n\");\n                    }\n                }\n            }\n        }\n    }\n    if (argv[argc + 2] != 0) {\n        if (argv[argc + 2][0] == 'y') {\n            struct stat sb;\n            if (xfstat(2, &sb) == 0) {\n                sb.st_mode |= 0x10;\n            }\n        } else {\n            struct stat sb;\n            if (xfstat(2, &sb) == 0) {\n                sb.st_mode &= ~0x12;\n                argv[argc + 3] = &sb.st_mode;\n                fchmod(0, sb.st_mode);\n            }\n        }\n    }\n}\n```"
    },
    {
        "func_name": "filter_datapoints",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00055640 | 30 48 2D E9 | PUSH    {R4,R5,R11,LR}\n0x00055644 | 0C B0 8D E2 | ADD     R11, SP, #0xC\n0x00055648 | 28 D0 4D E2 | SUB     SP, SP, #0x28\n0x0005564C | 30 00 0B E5 | STR     R0, [R11,#p]\n0x00055650 | 30 30 1B E5 | LDR     R3, [R11,#p]\n0x00055654 | 60 30 83 E2 | ADD     R3, R3, #0x60 ; '`'\n0x00055658 | 28 30 0B E5 | STR     R3, [R11,#fdp]\n0x0005565C | 30 30 1B E5 | LDR     R3, [R11,#p]\n0x00055660 | 0C 30 93 E5 | LDR     R3, [R3,#0xC]\n0x00055664 | 14 30 0B E5 | STR     R3, [R11,#idx]\n0x00055668 | 14 20 1B E5 | LDR     R2, [R11,#idx]\n0x0005566C | 02 30 A0 E1 | MOV     R3, R2\n0x00055670 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x00055674 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00055678 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x0005567C | 03 20 A0 E1 | MOV     R2, R3\n0x00055680 | 28 30 1B E5 | LDR     R3, [R11,#fdp]\n0x00055684 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00055688 | 18 00 93 E8 | LDM     R3, {R3,R4}\n0x0005568C | 30 20 1B E5 | LDR     R2, [R11,#p]\n0x00055690 | 48 30 82 E5 | STR     R3, [R2,#0x48]\n0x00055694 | 4C 40 82 E5 | STR     R4, [R2,#0x4C]\n0x00055698 | 00 30 A0 E3 | MOV     R3, #0\n0x0005569C | 00 40 A0 E3 | MOV     R4, #0\n0x000556A0 | 24 30 0B E5 | STR     R3, [R11,#wavg]\n0x000556A4 | 20 40 0B E5 | STR     R4, [R11,#wavg+4]\n0x000556A8 | 00 30 A0 E3 | MOV     R3, #0\n0x000556AC | 00 40 A0 E3 | MOV     R4, #0\n0x000556B0 | 1C 30 0B E5 | STR     R3, [R11,#sum]\n0x000556B4 | 18 40 0B E5 | STR     R4, [R11,#sum+4]\n0x000556B8 | 00 30 A0 E3 | MOV     R3, #0\n0x000556BC | 10 30 0B E5 | STR     R3, [R11,#i]\n0x000556C0 | 39 00 00 EA | B       loc_557AC\n0x000556C4 | 14 20 1B E5 | LDR     R2, [R11,#idx]\n0x000556C8 | 02 30 A0 E1 | MOV     R3, R2\n0x000556CC | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000556D0 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000556D4 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x000556D8 | 03 20 A0 E1 | MOV     R2, R3\n0x000556DC | 28 30 1B E5 | LDR     R3, [R11,#fdp]\n0x000556E0 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000556E4 | 03 00 A0 E1 | MOV     R0, R3; dp\n0x000556E8 | 3E FF FF EB | BL      dispersion\n0x000556EC | 00 40 A0 E1 | MOV     R4, R0\n0x000556F0 | 01 50 A0 E1 | MOV     R5, R1\n0x000556F4 | 02 20 A0 E3 | MOV     R2, #2\n0x000556F8 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000556FC | 12 33 A0 E1 | MOV     R3, R2,LSL R3\n0x00055700 | 03 00 A0 E1 | MOV     R0, R3\n0x00055704 | 87 07 04 EB | BL      __floatsidf\n0x00055708 | 00 20 A0 E1 | MOV     R2, R0\n0x0005570C | 01 30 A0 E1 | MOV     R3, R1\n0x00055710 | 04 00 A0 E1 | MOV     R0, R4\n0x00055714 | 05 10 A0 E1 | MOV     R1, R5\n0x00055718 | 56 08 04 EB | BL      __divdf3\n0x0005571C | 00 30 A0 E1 | MOV     R3, R0\n0x00055720 | 01 40 A0 E1 | MOV     R4, R1\n0x00055724 | 03 20 A0 E1 | MOV     R2, R3\n0x00055728 | 04 30 A0 E1 | MOV     R3, R4\n0x0005572C | 1C 10 4B E2 | SUB     R1, R11, #-sum\n0x00055730 | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x00055734 | C7 06 04 EB | BL      __aeabi_dadd\n0x00055738 | 00 30 A0 E1 | MOV     R3, R0\n0x0005573C | 01 40 A0 E1 | MOV     R4, R1\n0x00055740 | 1C 30 0B E5 | STR     R3, [R11,#sum]\n0x00055744 | 18 40 0B E5 | STR     R4, [R11,#sum+4]\n0x00055748 | 14 20 1B E5 | LDR     R2, [R11,#idx]\n0x0005574C | 02 30 A0 E1 | MOV     R3, R2\n0x00055750 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x00055754 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00055758 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x0005575C | 03 20 A0 E1 | MOV     R2, R3\n0x00055760 | 28 30 1B E5 | LDR     R3, [R11,#fdp]\n0x00055764 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00055768 | 18 00 93 E8 | LDM     R3, {R3,R4}\n0x0005576C | 03 20 A0 E1 | MOV     R2, R3\n0x00055770 | 04 30 A0 E1 | MOV     R3, R4\n0x00055774 | 24 10 4B E2 | SUB     R1, R11, #-wavg\n0x00055778 | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x0005577C | B5 06 04 EB | BL      __aeabi_dadd\n0x00055780 | 00 30 A0 E1 | MOV     R3, R0\n0x00055784 | 01 40 A0 E1 | MOV     R4, R1\n0x00055788 | 24 30 0B E5 | STR     R3, [R11,#wavg]\n0x0005578C | 20 40 0B E5 | STR     R4, [R11,#wavg+4]\n0x00055790 | 14 30 1B E5 | LDR     R3, [R11,#idx]\n0x00055794 | 01 30 43 E2 | SUB     R3, R3, #1\n0x00055798 | 07 30 03 E2 | AND     R3, R3, #7\n0x0005579C | 14 30 0B E5 | STR     R3, [R11,#idx]\n0x000557A0 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000557A4 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000557A8 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x000557AC | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000557B0 | 07 00 53 E3 | CMP     R3, #7\n0x000557B4 | C2 FF FF DA | BLE     loc_556C4\n0x000557B8 | 00 20 A0 E3 | MOV     R2, #0\n0x000557BC | 54 31 9F E5 | LDR     R3, =0x40200000\n0x000557C0 | 24 10 4B E2 | SUB     R1, R11, #-wavg\n0x000557C4 | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x000557C8 | 2A 08 04 EB | BL      __divdf3\n0x000557CC | 00 30 A0 E1 | MOV     R3, R0\n0x000557D0 | 01 40 A0 E1 | MOV     R4, R1\n0x000557D4 | 24 30 0B E5 | STR     R3, [R11,#wavg]\n0x000557D8 | 20 40 0B E5 | STR     R4, [R11,#wavg+4]\n0x000557DC | 30 20 1B E5 | LDR     R2, [R11,#p]\n0x000557E0 | 1C 40 4B E2 | SUB     R4, R11, #-sum\n0x000557E4 | 18 00 94 E8 | LDM     R4, {R3,R4}\n0x000557E8 | 50 30 82 E5 | STR     R3, [R2,#0x50]\n0x000557EC | 54 40 82 E5 | STR     R4, [R2,#0x54]\n0x000557F0 | 00 30 A0 E3 | MOV     R3, #0\n0x000557F4 | 00 40 A0 E3 | MOV     R4, #0\n0x000557F8 | 1C 30 0B E5 | STR     R3, [R11,#sum]\n0x000557FC | 18 40 0B E5 | STR     R4, [R11,#sum+4]\n0x00055800 | 00 30 A0 E3 | MOV     R3, #0\n0x00055804 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x00055808 | 20 00 00 EA | B       loc_55890\n0x0005580C | 10 20 1B E5 | LDR     R2, [R11,#i]\n0x00055810 | 02 30 A0 E1 | MOV     R3, R2\n0x00055814 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x00055818 | 02 30 83 E0 | ADD     R3, R3, R2\n0x0005581C | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x00055820 | 03 20 A0 E1 | MOV     R2, R3\n0x00055824 | 28 30 1B E5 | LDR     R3, [R11,#fdp]\n0x00055828 | 02 30 83 E0 | ADD     R3, R3, R2\n0x0005582C | 18 00 93 E8 | LDM     R3, {R3,R4}\n0x00055830 | 03 20 A0 E1 | MOV     R2, R3\n0x00055834 | 04 30 A0 E1 | MOV     R3, R4\n0x00055838 | 24 10 4B E2 | SUB     R1, R11, #-wavg\n0x0005583C | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x00055840 | 83 06 04 EB | BL      __subdf3\n0x00055844 | 00 30 A0 E1 | MOV     R3, R0\n0x00055848 | 01 40 A0 E1 | MOV     R4, R1\n0x0005584C | 03 00 A0 E1 | MOV     R0, R3; x\n0x00055850 | 04 10 A0 E1 | MOV     R1, R4; x\n0x00055854 | 3E FD FF EB | BL      SQUARE\n0x00055858 | 00 30 A0 E1 | MOV     R3, R0\n0x0005585C | 01 40 A0 E1 | MOV     R4, R1\n0x00055860 | 03 20 A0 E1 | MOV     R2, R3\n0x00055864 | 04 30 A0 E1 | MOV     R3, R4\n0x00055868 | 1C 10 4B E2 | SUB     R1, R11, #-sum\n0x0005586C | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x00055870 | 78 06 04 EB | BL      __aeabi_dadd\n0x00055874 | 00 30 A0 E1 | MOV     R3, R0\n0x00055878 | 01 40 A0 E1 | MOV     R4, R1\n0x0005587C | 1C 30 0B E5 | STR     R3, [R11,#sum]\n0x00055880 | 18 40 0B E5 | STR     R4, [R11,#sum+4]\n0x00055884 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x00055888 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0005588C | 10 30 0B E5 | STR     R3, [R11,#i]\n0x00055890 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x00055894 | 07 00 53 E3 | CMP     R3, #7\n0x00055898 | DB FF FF DA | BLE     loc_5580C\n0x0005589C | 00 20 A0 E3 | MOV     R2, #0\n0x000558A0 | 70 30 9F E5 | LDR     R3, =0x40200000\n0x000558A4 | 1C 10 4B E2 | SUB     R1, R11, #-sum\n0x000558A8 | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x000558AC | F1 07 04 EB | BL      __divdf3\n0x000558B0 | 00 30 A0 E1 | MOV     R3, R0\n0x000558B4 | 01 40 A0 E1 | MOV     R4, R1\n0x000558B8 | 03 00 A0 E1 | MOV     R0, R3; X\n0x000558BC | 04 10 A0 E1 | MOV     R1, R4; X\n0x000558C0 | 96 FD FF EB | BL      SQRT\n0x000558C4 | 1C 00 0B E5 | STR     R0, [R11,#sum]\n0x000558C8 | 18 10 0B E5 | STR     R1, [R11,#sum+4]\n0x000558CC | 48 20 9F E5 | LDR     R2, =0xD2F1A9FC\n0x000558D0 | 48 30 9F E5 | LDR     R3, =0x3F60624D\n0x000558D4 | 1C 10 4B E2 | SUB     R1, R11, #-sum\n0x000558D8 | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x000558DC | AC 08 04 EB | BL      __aeabi_dcmpgt\n0x000558E0 | 00 30 A0 E1 | MOV     R3, R0\n0x000558E4 | 00 00 53 E3 | CMP     R3, #0\n0x000558E8 | 02 00 00 0A | BEQ     loc_558F8\n0x000558EC | 1C 40 4B E2 | SUB     R4, R11, #-sum\n0x000558F0 | 18 00 94 E8 | LDM     R4, {R3,R4}\n0x000558F4 | 01 00 00 EA | B       loc_55900\n0x000558F8 | 1C 30 9F E5 | LDR     R3, =0xD2F1A9FC\n0x000558FC | 1C 40 9F E5 | LDR     R4, =0x3F60624D\n0x00055900 | 30 20 1B E5 | LDR     R2, [R11,#p]\n0x00055904 | 58 30 82 E5 | STR     R3, [R2,#0x58]\n0x00055908 | 5C 40 82 E5 | STR     R4, [R2,#0x5C]\n0x0005590C | 00 00 A0 E1 | NOP\n0x00055910 | 0C D0 4B E2 | SUB     SP, R11, #0xC\n0x00055914 | 30 88 BD E8 | POP     {R4,R5,R11,PC}",
        "output": "```c\nvoid function(int* p, int* fdp, int* idx, int* wavg, int* sum, int* i) {\n    int dp = *p;\n    int x, X;\n    int wavg_temp[2] = {0, 0};\n    int sum_temp[2] = {0, 0};\n    \n    for (*i = 0; *i < 8; (*i)++) {\n        int idx_temp = *idx;\n        int fdp_temp = *fdp;\n        int dp_temp = dp;\n        \n        x = fdp_temp + (idx_temp << 4);\n        X = wavg_temp[0] - sum_temp[0];\n        \n        float result = (float)x / (float)X;\n        \n        sum_temp[0] += result;\n        sum_temp[1] += result;\n        \n        wavg_temp[0] = dp_temp + (idx_temp << 4);\n        wavg_temp[1] = dp_temp + (idx_temp << 4);\n        \n        *sum = sum_temp[0];\n        *(sum + 1) = sum_temp[1];\n        \n        *wavg = wavg_temp[0];\n        *(wavg + 1) = wavg_temp[1];\n        \n        (*idx)--;\n        (*i)++;\n    }\n    \n    float temp1 = sum_temp[0];\n    float temp2 = sum_temp[1];\n    \n    if (temp1 > 0.5 && temp2 > 0.5) {\n        *sum = 0xD2F1A9FC;\n        *(sum + 1) = 0x3F60624D;\n    }\n    \n    return;\n}\n```"
    },
    {
        "func_name": "ln_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x001073E8 | 00 48 2D E9 | PUSH    {R11,LR}\n0x001073EC | 04 B0 8D E2 | ADD     R11, SP, #4\n0x001073F0 | 90 D0 4D E2 | SUB     SP, SP, #0x90\n0x001073F4 | 90 00 0B E5 | STR     R0, [R11,#argc]\n0x001073F8 | 94 10 0B E5 | STR     R1, [R11,#argv]\n0x001073FC | 00 30 A0 E3 | MOV     R3, #0\n0x00107400 | 08 30 0B E5 | STR     R3, [R11,#status]\n0x00107404 | 4C 33 9F E5 | LDR     R3, =asc_178DE0; \"~\"\n0x00107408 | 24 30 0B E5 | STR     R3, [R11,#suffix]\n0x0010740C | 48 33 9F E5 | LDR     R3, =opt_complementary\n0x00107410 | 48 23 9F E5 | LDR     R2, =a1_24; \"-1\"\n0x00107414 | 00 20 83 E5 | STR     R2, [R3]\n0x00107418 | 24 30 4B E2 | SUB     R3, R11, #-suffix\n0x0010741C | 03 20 A0 E1 | MOV     R2, R3\n0x00107420 | 3C 13 9F E5 | LDR     R1, =aSfnbsVt; \"sfnbS:vT\"\n0x00107424 | 94 00 1B E5 | LDR     R0, [R11,#argv]; argv\n0x00107428 | 1E E7 00 EB | BL      getopt32\n0x0010742C | 00 30 A0 E1 | MOV     R3, R0\n0x00107430 | 1C 30 0B E5 | STR     R3, [R11,#opts]\n0x00107434 | 90 30 1B E5 | LDR     R3, [R11,#argc]\n0x00107438 | 07 31 43 E2 | SUB     R3, R3, #0xC0000001\n0x0010743C | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00107440 | 94 20 1B E5 | LDR     R2, [R11,#argv]\n0x00107444 | 03 30 82 E0 | ADD     R3, R2, R3\n0x00107448 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010744C | 0C 30 0B E5 | STR     R3, [R11,#last]\n0x00107450 | 10 33 9F E5 | LDR     R3, =optind__GLIBC_2.4\n0x00107454 | 00 30 93 E5 | LDR     R3, [R3]\n0x00107458 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x0010745C | 94 20 1B E5 | LDR     R2, [R11,#argv]\n0x00107460 | 03 30 82 E0 | ADD     R3, R2, R3\n0x00107464 | 94 30 0B E5 | STR     R3, [R11,#argv]\n0x00107468 | F8 32 9F E5 | LDR     R3, =optind__GLIBC_2.4\n0x0010746C | 00 30 93 E5 | LDR     R3, [R3]\n0x00107470 | 90 20 1B E5 | LDR     R2, [R11,#argc]\n0x00107474 | 03 30 42 E0 | SUB     R3, R2, R3\n0x00107478 | 90 30 0B E5 | STR     R3, [R11,#argc]\n0x0010747C | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x00107480 | 40 30 03 E2 | AND     R3, R3, #0x40\n0x00107484 | 00 00 53 E3 | CMP     R3, #0\n0x00107488 | 04 00 00 0A | BEQ     loc_1074A0\n0x0010748C | 90 30 1B E5 | LDR     R3, [R11,#argc]\n0x00107490 | 02 00 53 E3 | CMP     R3, #2\n0x00107494 | 01 00 00 DA | BLE     loc_1074A0\n0x00107498 | CC 02 9F E5 | LDR     R0, =aTAccepts2ArgsM; \"-T accepts 2 args max\"\n0x0010749C | 3D 46 FC EB | BL      bb_error_msg_and_die\n0x001074A0 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x001074A4 | 04 30 83 E2 | ADD     R3, R3, #4\n0x001074A8 | 00 30 93 E5 | LDR     R3, [R3]\n0x001074AC | 00 00 53 E3 | CMP     R3, #0\n0x001074B0 | 0B 00 00 1A | BNE     loc_1074E4\n0x001074B4 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x001074B8 | 04 30 43 E2 | SUB     R3, R3, #4\n0x001074BC | 94 30 0B E5 | STR     R3, [R11,#argv]\n0x001074C0 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x001074C4 | 0C 20 1B E5 | LDR     R2, [R11,#last]\n0x001074C8 | 00 20 83 E5 | STR     R2, [R3]\n0x001074CC | 0C 00 1B E5 | LDR     R0, [R11,#last]; s\n0x001074D0 | A5 49 FC EB | BL      xstrdup\n0x001074D4 | 00 30 A0 E1 | MOV     R3, R0\n0x001074D8 | 03 00 A0 E1 | MOV     R0, R3; path\n0x001074DC | F7 43 FC EB | BL      bb_get_last_path_component_strip\n0x001074E0 | 0C 00 0B E5 | STR     R0, [R11,#last]\n0x001074E4 | 00 30 A0 E3 | MOV     R3, #0\n0x001074E8 | 10 30 0B E5 | STR     R3, [R11,#src_name]\n0x001074EC | 0C 30 1B E5 | LDR     R3, [R11,#last]\n0x001074F0 | 14 30 0B E5 | STR     R3, [R11,#src]\n0x001074F4 | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x001074F8 | 03 30 E0 E1 | MVN     R3, R3\n0x001074FC | 04 30 03 E2 | AND     R3, R3, #4\n0x00107500 | 03 10 A0 E1 | MOV     R1, R3; followLinks\n0x00107504 | 14 00 1B E5 | LDR     R0, [R11,#src]; fileName\n0x00107508 | A6 F8 00 EB | BL      is_directory\n0x0010750C | 00 30 A0 E1 | MOV     R3, R0\n0x00107510 | 00 00 53 E3 | CMP     R3, #0\n0x00107514 | 17 00 00 0A | BEQ     loc_107578\n0x00107518 | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x0010751C | 40 30 03 E2 | AND     R3, R3, #0x40\n0x00107520 | 00 00 53 E3 | CMP     R3, #0\n0x00107524 | 02 00 00 0A | BEQ     loc_107534\n0x00107528 | 14 10 1B E5 | LDR     R1, [R11,#src]\n0x0010752C | 3C 02 9F E5 | LDR     R0, =aSIsADirectory; \"'%s' is a directory\"\n0x00107530 | 18 46 FC EB | BL      bb_error_msg_and_die\n0x00107534 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x00107538 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010753C | 03 00 A0 E1 | MOV     R0, R3; s\n0x00107540 | 89 49 FC EB | BL      xstrdup\n0x00107544 | 00 30 A0 E1 | MOV     R3, R0\n0x00107548 | 10 30 0B E5 | STR     R3, [R11,#src_name]\n0x0010754C | 10 00 1B E5 | LDR     R0, [R11,#src_name]; path\n0x00107550 | DA 43 FC EB | BL      bb_get_last_path_component_strip\n0x00107554 | 00 30 A0 E1 | MOV     R3, R0\n0x00107558 | 03 10 A0 E1 | MOV     R1, R3; filename\n0x0010755C | 14 00 1B E5 | LDR     R0, [R11,#src]; path\n0x00107560 | 82 43 FC EB | BL      concat_path_file\n0x00107564 | 14 00 0B E5 | STR     R0, [R11,#src]\n0x00107568 | 10 00 1B E5 | LDR     R0, [R11,#src_name]; ptr\n0x0010756C | 4F 36 FC EB | BL      free\n0x00107570 | 14 30 1B E5 | LDR     R3, [R11,#src]\n0x00107574 | 10 30 0B E5 | STR     R3, [R11,#src_name]\n0x00107578 | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x0010757C | 01 30 03 E2 | AND     R3, R3, #1\n0x00107580 | 00 00 53 E3 | CMP     R3, #0\n0x00107584 | 1E 00 00 1A | BNE     loc_107604\n0x00107588 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x0010758C | 00 30 93 E5 | LDR     R3, [R3]\n0x00107590 | 8C 20 4B E2 | SUB     R2, R11, #-statbuf\n0x00107594 | 02 10 A0 E1 | MOV     R1, R2; buf\n0x00107598 | 03 00 A0 E1 | MOV     R0, R3; file\n0x0010759C | F4 43 01 EB | BL      stat64_0\n0x001075A0 | 00 30 A0 E1 | MOV     R3, R0\n0x001075A4 | 00 00 53 E3 | CMP     R3, #0\n0x001075A8 | 15 00 00 0A | BEQ     loc_107604\n0x001075AC | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x001075B0 | 00 30 93 E5 | LDR     R3, [R3]\n0x001075B4 | 8C 20 4B E2 | SUB     R2, R11, #-statbuf\n0x001075B8 | 02 10 A0 E1 | MOV     R1, R2; buf\n0x001075BC | 03 00 A0 E1 | MOV     R0, R3; file\n0x001075C0 | F3 43 01 EB | BL      lstat64\n0x001075C4 | 00 30 A0 E1 | MOV     R3, R0\n0x001075C8 | 00 00 53 E3 | CMP     R3, #0\n0x001075CC | 03 00 00 1A | BNE     loc_1075E0\n0x001075D0 | 7C 30 1B E5 | LDR     R3, [R11,#statbuf.st_mode]\n0x001075D4 | 0F 3A 03 E2 | AND     R3, R3, #0xF000\n0x001075D8 | 0A 0A 53 E3 | CMP     R3, #0xA000\n0x001075DC | 08 00 00 0A | BEQ     loc_107604\n0x001075E0 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x001075E4 | 00 30 93 E5 | LDR     R3, [R3]\n0x001075E8 | 03 00 A0 E1 | MOV     R0, R3; s\n0x001075EC | DB 44 FC EB | BL      bb_simple_perror_msg\n0x001075F0 | 01 30 A0 E3 | MOV     R3, #1\n0x001075F4 | 08 30 0B E5 | STR     R3, [R11,#status]\n0x001075F8 | 10 00 1B E5 | LDR     R0, [R11,#src_name]; ptr\n0x001075FC | 2B 36 FC EB | BL      free\n0x00107600 | 48 00 00 EA | B       loc_107728\n0x00107604 | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x00107608 | 08 30 03 E2 | AND     R3, R3, #8\n0x0010760C | 00 00 53 E3 | CMP     R3, #0\n0x00107610 | 1D 00 00 0A | BEQ     loc_10768C\n0x00107614 | 24 30 1B E5 | LDR     R3, [R11,#suffix]\n0x00107618 | 03 20 A0 E1 | MOV     R2, R3\n0x0010761C | 14 10 1B E5 | LDR     R1, [R11,#src]\n0x00107620 | 4C 01 9F E5 | LDR     R0, =aSS_55; \"%s%s\"\n0x00107624 | 23 4B FC EB | BL      xasprintf\n0x00107628 | 00 30 A0 E1 | MOV     R3, R0\n0x0010762C | 20 30 0B E5 | STR     R3, [R11,#backup]\n0x00107630 | 20 10 1B E5 | LDR     R1, [R11,#backup]; new\n0x00107634 | 14 00 1B E5 | LDR     R0, [R11,#src]; old\n0x00107638 | AB 37 FC EB | BL      rename\n0x0010763C | 00 30 A0 E1 | MOV     R3, R0\n0x00107640 | 00 00 53 E3 | CMP     R3, #0\n0x00107644 | 0B 00 00 AA | BGE     loc_107678\n0x00107648 | 28 31 9F E5 | LDR     R3, =bb_errno\n0x0010764C | 00 30 93 E5 | LDR     R3, [R3]\n0x00107650 | 00 30 93 E5 | LDR     R3, [R3]\n0x00107654 | 02 00 53 E3 | CMP     R3, #2\n0x00107658 | 06 00 00 0A | BEQ     loc_107678\n0x0010765C | 14 00 1B E5 | LDR     R0, [R11,#src]; s\n0x00107660 | BE 44 FC EB | BL      bb_simple_perror_msg\n0x00107664 | 01 30 A0 E3 | MOV     R3, #1\n0x00107668 | 08 30 0B E5 | STR     R3, [R11,#status]\n0x0010766C | 20 00 1B E5 | LDR     R0, [R11,#backup]; ptr\n0x00107670 | 0E 36 FC EB | BL      free\n0x00107674 | 2B 00 00 EA | B       loc_107728\n0x00107678 | 20 00 1B E5 | LDR     R0, [R11,#backup]; ptr\n0x0010767C | 0B 36 FC EB | BL      free\n0x00107680 | 14 00 1B E5 | LDR     R0, [R11,#src]; name\n0x00107684 | 8D 36 FC EB | BL      unlink\n0x00107688 | 05 00 00 EA | B       loc_1076A4\n0x0010768C | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x00107690 | 02 30 03 E2 | AND     R3, R3, #2\n0x00107694 | 00 00 53 E3 | CMP     R3, #0\n0x00107698 | 01 00 00 0A | BEQ     loc_1076A4\n0x0010769C | 14 00 1B E5 | LDR     R0, [R11,#src]; name\n0x001076A0 | 86 36 FC EB | BL      unlink\n0x001076A4 | D0 30 9F E5 | LDR     R3, =link\n0x001076A8 | 18 30 0B E5 | STR     R3, [R11,#link_func]\n0x001076AC | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x001076B0 | 01 30 03 E2 | AND     R3, R3, #1\n0x001076B4 | 00 00 53 E3 | CMP     R3, #0\n0x001076B8 | 01 00 00 0A | BEQ     loc_1076C4\n0x001076BC | BC 30 9F E5 | LDR     R3, =symlink\n0x001076C0 | 18 30 0B E5 | STR     R3, [R11,#link_func]\n0x001076C4 | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x001076C8 | 20 30 03 E2 | AND     R3, R3, #0x20\n0x001076CC | 00 00 53 E3 | CMP     R3, #0\n0x001076D0 | 05 00 00 0A | BEQ     loc_1076EC\n0x001076D4 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x001076D8 | 00 30 93 E5 | LDR     R3, [R3]\n0x001076DC | 03 20 A0 E1 | MOV     R2, R3\n0x001076E0 | 14 10 1B E5 | LDR     R1, [R11,#src]\n0x001076E4 | 98 00 9F E5 | LDR     R0, =aSS_56; \"'%s' -> '%s'\\n\"\n0x001076E8 | BA 35 FC EB | BL      printf\n0x001076EC | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x001076F0 | 00 20 93 E5 | LDR     R2, [R3]\n0x001076F4 | 18 30 1B E5 | LDR     R3, [R11,#link_func]\n0x001076F8 | 14 10 1B E5 | LDR     R1, [R11,#src]\n0x001076FC | 02 00 A0 E1 | MOV     R0, R2\n0x00107700 | 33 FF 2F E1 | BLX     R3\n0x00107704 | 00 30 A0 E1 | MOV     R3, R0\n0x00107708 | 00 00 53 E3 | CMP     R3, #0\n0x0010770C | 03 00 00 0A | BEQ     loc_107720\n0x00107710 | 14 00 1B E5 | LDR     R0, [R11,#src]; s\n0x00107714 | 91 44 FC EB | BL      bb_simple_perror_msg\n0x00107718 | 01 30 A0 E3 | MOV     R3, #1\n0x0010771C | 08 30 0B E5 | STR     R3, [R11,#status]\n0x00107720 | 10 00 1B E5 | LDR     R0, [R11,#src_name]; ptr\n0x00107724 | E1 35 FC EB | BL      free\n0x00107728 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x0010772C | 04 30 83 E2 | ADD     R3, R3, #4\n0x00107730 | 94 30 0B E5 | STR     R3, [R11,#argv]\n0x00107734 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x00107738 | 04 30 83 E2 | ADD     R3, R3, #4\n0x0010773C | 00 30 93 E5 | LDR     R3, [R3]\n0x00107740 | 00 00 53 E3 | CMP     R3, #0\n0x00107744 | 66 FF FF 1A | BNE     loc_1074E4\n0x00107748 | 08 30 1B E5 | LDR     R3, [R11,#status]\n0x0010774C | 03 00 A0 E1 | MOV     R0, R3\n0x00107750 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00107754 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/stat.h>\n\nint main(int argc, char *argv[]) {\n    int status = 0;\n    char *suffix = \"~\";\n    char *opt_complementary = \"-1\";\n    char *optind__GLIBC_2.4 = \"optind__GLIBC_2.4\";\n    char *src_name = NULL;\n    char *src = NULL;\n    char *backup = NULL;\n    int opts = 0;\n\n    int opt;\n    while ((opt = getopt(argc, argv, \"sfnbS:vT\")) != -1) {\n        switch (opt) {\n            case 's':\n                opts |= 1;\n                break;\n            case 'f':\n                opts |= 2;\n                break;\n            case 'n':\n                opts |= 4;\n                break;\n            case 'b':\n                opts |= 8;\n                break;\n            case 'S':\n                suffix = optarg;\n                break;\n            case 'v':\n                opts |= 16;\n                break;\n            case 'T':\n                opts |= 32;\n                break;\n            default:\n                break;\n        }\n    }\n\n    int followLinks = opts & 1;\n    int is_directory = 0;\n\n    if (optind < argc) {\n        char *path = argv[optind];\n        char *filename = path;\n        bb_get_last_path_component_strip(&path);\n        char *new = bb_get_last_path_component_strip(&backup);\n        rename(path, new);\n        if (is_directory) {\n            if (opts & 64) {\n                printf(\"'%s' is a directory\\n\", path);\n                exit(1);\n            }\n            char *s = xstrdup(path);\n            bb_get_last_path_component_strip(&s);\n            char *filename = s;\n            concat_path_file(&path, filename);\n            free(s);\n        }\n        if (unlink(path) < 0) {\n            bb_simple_perror_msg(path);\n            status = 1;\n        }\n        if (opts & 128) {\n            unlink(backup);\n        }\n        if (opts & 32) {\n            printf(\"'%s' -> '%s'\\n\", filename, backup);\n            link(filename, backup);\n            if (is_directory) {\n                symlink(filename, backup);\n            }\n        }\n    }\n\n    return status;\n}\n```"
    },
    {
        "func_name": "get_local_var_value",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000AA928 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000AA92C | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000AA930 | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x000AA934 | 18 00 0B E5 | STR     R0, [R11,#name]\n0x000AA938 | 18 00 1B E5 | LDR     R0, [R11,#name]; s\n0x000AA93C | 11 AB FD EB | BL      strlen\n0x000AA940 | 0C 00 0B E5 | STR     R0, [R11,#len]\n0x000AA944 | 4C 31 9F E5 | LDR     R3, =ptr_to_globals\n0x000AA948 | 00 30 93 E5 | LDR     R3, [R3]\n0x000AA94C | 6C 30 93 E5 | LDR     R3, [R3,#0x6C]\n0x000AA950 | 00 00 53 E3 | CMP     R3, #0\n0x000AA954 | 20 00 00 0A | BEQ     loc_AA9DC\n0x000AA958 | 38 31 9F E5 | LDR     R3, =ptr_to_globals\n0x000AA95C | 00 30 93 E5 | LDR     R3, [R3]\n0x000AA960 | 6C 30 93 E5 | LDR     R3, [R3,#0x6C]\n0x000AA964 | 08 30 0B E5 | STR     R3, [R11,#cpp]\n0x000AA968 | 17 00 00 EA | B       loc_AA9CC\n0x000AA96C | 08 30 1B E5 | LDR     R3, [R11,#cpp]\n0x000AA970 | 00 30 93 E5 | LDR     R3, [R3]\n0x000AA974 | 10 30 0B E5 | STR     R3, [R11,#cp]\n0x000AA978 | 0C 20 1B E5 | LDR     R2, [R11,#len]; n\n0x000AA97C | 18 10 1B E5 | LDR     R1, [R11,#name]; s2\n0x000AA980 | 10 00 1B E5 | LDR     R0, [R11,#cp]; s1\n0x000AA984 | D0 AC FD EB | BL      strncmp\n0x000AA988 | 00 30 A0 E1 | MOV     R3, R0\n0x000AA98C | 00 00 53 E3 | CMP     R3, #0\n0x000AA990 | 0A 00 00 1A | BNE     loc_AA9C0\n0x000AA994 | 10 20 1B E5 | LDR     R2, [R11,#cp]\n0x000AA998 | 0C 30 1B E5 | LDR     R3, [R11,#len]\n0x000AA99C | 03 30 82 E0 | ADD     R3, R2, R3\n0x000AA9A0 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000AA9A4 | 3D 00 53 E3 | CMP     R3, #0x3D ; '='\n0x000AA9A8 | 04 00 00 1A | BNE     loc_AA9C0\n0x000AA9AC | 0C 30 1B E5 | LDR     R3, [R11,#len]\n0x000AA9B0 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000AA9B4 | 10 20 1B E5 | LDR     R2, [R11,#cp]\n0x000AA9B8 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000AA9BC | 32 00 00 EA | B       loc_AAA8C\n0x000AA9C0 | 08 30 1B E5 | LDR     R3, [R11,#cpp]\n0x000AA9C4 | 04 30 83 E2 | ADD     R3, R3, #4\n0x000AA9C8 | 08 30 0B E5 | STR     R3, [R11,#cpp]\n0x000AA9CC | 08 30 1B E5 | LDR     R3, [R11,#cpp]\n0x000AA9D0 | 00 30 93 E5 | LDR     R3, [R3]\n0x000AA9D4 | 00 00 53 E3 | CMP     R3, #0\n0x000AA9D8 | E3 FF FF 1A | BNE     loc_AA96C\n0x000AA9DC | 0C 10 1B E5 | LDR     R1, [R11,#len]; len\n0x000AA9E0 | 18 00 1B E5 | LDR     R0, [R11,#name]; name\n0x000AA9E4 | A6 FF FF EB | BL      get_ptr_to_local_var\n0x000AA9E8 | 14 00 0B E5 | STR     R0, [R11,#vpp]\n0x000AA9EC | 14 30 1B E5 | LDR     R3, [R11,#vpp]\n0x000AA9F0 | 00 00 53 E3 | CMP     R3, #0\n0x000AA9F4 | 06 00 00 0A | BEQ     loc_AAA14\n0x000AA9F8 | 14 30 1B E5 | LDR     R3, [R11,#vpp]\n0x000AA9FC | 00 30 93 E5 | LDR     R3, [R3]\n0x000AAA00 | 04 20 93 E5 | LDR     R2, [R3,#4]\n0x000AAA04 | 0C 30 1B E5 | LDR     R3, [R11,#len]\n0x000AAA08 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000AAA0C | 03 30 82 E0 | ADD     R3, R2, R3\n0x000AAA10 | 1D 00 00 EA | B       loc_AAA8C\n0x000AAA14 | 80 10 9F E5 | LDR     R1, =aPpid_1; \"PPID\"\n0x000AAA18 | 18 00 1B E5 | LDR     R0, [R11,#name]; s1\n0x000AAA1C | CC A8 FD EB | BL      strcmp\n0x000AAA20 | 00 30 A0 E1 | MOV     R3, R0\n0x000AAA24 | 00 00 53 E3 | CMP     R3, #0\n0x000AAA28 | 06 00 00 1A | BNE     loc_AAA48\n0x000AAA2C | 64 30 9F E5 | LDR     R3, =ptr_to_globals\n0x000AAA30 | 00 30 93 E5 | LDR     R3, [R3]\n0x000AAA34 | 14 30 93 E5 | LDR     R3, [R3,#0x14]\n0x000AAA38 | 03 00 A0 E1 | MOV     R0, R3; n\n0x000AAA3C | 32 BA FD EB | BL      utoa\n0x000AAA40 | 00 30 A0 E1 | MOV     R3, R0\n0x000AAA44 | 10 00 00 EA | B       loc_AAA8C\n0x000AAA48 | 50 10 9F E5 | LDR     R1, =aRandom; \"RANDOM\"\n0x000AAA4C | 18 00 1B E5 | LDR     R0, [R11,#name]; s1\n0x000AAA50 | BF A8 FD EB | BL      strcmp\n0x000AAA54 | 00 30 A0 E1 | MOV     R3, R0\n0x000AAA58 | 00 00 53 E3 | CMP     R3, #0\n0x000AAA5C | 09 00 00 1A | BNE     loc_AAA88\n0x000AAA60 | 30 30 9F E5 | LDR     R3, =ptr_to_globals\n0x000AAA64 | 00 30 93 E5 | LDR     R3, [R3]\n0x000AAA68 | 1C 30 83 E2 | ADD     R3, R3, #0x1C\n0x000AAA6C | 03 00 A0 E1 | MOV     R0, R3; rnd\n0x000AAA70 | CE 35 00 EB | BL      next_random\n0x000AAA74 | 00 30 A0 E1 | MOV     R3, R0\n0x000AAA78 | 03 00 A0 E1 | MOV     R0, R3; n\n0x000AAA7C | 22 BA FD EB | BL      utoa\n0x000AAA80 | 00 30 A0 E1 | MOV     R3, R0\n0x000AAA84 | 00 00 00 EA | B       loc_AAA8C\n0x000AAA88 | 00 30 A0 E3 | MOV     R3, #0\n0x000AAA8C | 03 00 A0 E1 | MOV     R0, R3\n0x000AAA90 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000AAA94 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(char* name, int len) {\n    char* cpp = NULL;\n    char* cp = NULL;\n    char* vpp = NULL;\n    int n;\n    if (strlen(name) == 0) {\n        return;\n    }\n    if (strcmp(name, \"PPID\") == 0) {\n        n = utoa(ptr_to_globals->pid);\n    } else if (strcmp(name, \"RANDOM\") == 0) {\n        n = utoa(next_random());\n    } else {\n        n = 0;\n    }\n    utoa(n);\n}\n```"
    },
    {
        "func_name": "find_list_entry2",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000F9914 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000F9918 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000F991C | 01 DA 4D E2 | SUB     SP, SP, #0x1000\n0x000F9920 | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x000F9924 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9928 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F992C | 14 00 03 E5 | STR     R0, [R3,#-0x14]\n0x000F9930 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9934 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9938 | 18 10 03 E5 | STR     R1, [R3,#-0x18]\n0x000F993C | 59 00 00 EA | B       loc_F9AA8\n0x000F9940 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9944 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9948 | 14 30 13 E5 | LDR     R3, [R3,#-0x14]\n0x000F994C | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000F9950 | 0C 30 0B E5 | STR     R3, [R11,#c]\n0x000F9954 | 00 30 A0 E3 | MOV     R3, #0\n0x000F9958 | 08 30 0B E5 | STR     R3, [R11,#pattern_slash_cnt]\n0x000F995C | 08 00 00 EA | B       loc_F9984\n0x000F9960 | 0C 30 1B E5 | LDR     R3, [R11,#c]\n0x000F9964 | 01 20 83 E2 | ADD     R2, R3, #1\n0x000F9968 | 0C 20 0B E5 | STR     R2, [R11,#c]\n0x000F996C | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000F9970 | 2F 00 53 E3 | CMP     R3, #0x2F ; '/'\n0x000F9974 | 02 00 00 1A | BNE     loc_F9984\n0x000F9978 | 08 30 1B E5 | LDR     R3, [R11,#pattern_slash_cnt]\n0x000F997C | 01 30 83 E2 | ADD     R3, R3, #1\n0x000F9980 | 08 30 0B E5 | STR     R3, [R11,#pattern_slash_cnt]\n0x000F9984 | 0C 30 1B E5 | LDR     R3, [R11,#c]\n0x000F9988 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000F998C | 00 00 53 E3 | CMP     R3, #0\n0x000F9990 | F2 FF FF 1A | BNE     loc_F9960\n0x000F9994 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9998 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F999C | 18 30 13 E5 | LDR     R3, [R3,#-0x18]\n0x000F99A0 | 0C 30 0B E5 | STR     R3, [R11,#c]\n0x000F99A4 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F99A8 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F99AC | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x000F99B0 | 10 30 0B E5 | STR     R3, [R11,#d]\n0x000F99B4 | 11 00 00 EA | B       loc_F9A00\n0x000F99B8 | 0C 30 1B E5 | LDR     R3, [R11,#c]\n0x000F99BC | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000F99C0 | 2F 00 53 E3 | CMP     R3, #0x2F ; '/'\n0x000F99C4 | 05 00 00 1A | BNE     loc_F99E0\n0x000F99C8 | 08 30 1B E5 | LDR     R3, [R11,#pattern_slash_cnt]\n0x000F99CC | 01 30 43 E2 | SUB     R3, R3, #1\n0x000F99D0 | 08 30 0B E5 | STR     R3, [R11,#pattern_slash_cnt]\n0x000F99D4 | 08 30 1B E5 | LDR     R3, [R11,#pattern_slash_cnt]\n0x000F99D8 | 00 00 53 E3 | CMP     R3, #0\n0x000F99DC | 14 00 00 BA | BLT     loc_F9A34\n0x000F99E0 | 0C 20 1B E5 | LDR     R2, [R11,#c]\n0x000F99E4 | 01 30 82 E2 | ADD     R3, R2, #1\n0x000F99E8 | 0C 30 0B E5 | STR     R3, [R11,#c]\n0x000F99EC | 10 30 1B E5 | LDR     R3, [R11,#d]\n0x000F99F0 | 01 10 83 E2 | ADD     R1, R3, #1\n0x000F99F4 | 10 10 0B E5 | STR     R1, [R11,#d]\n0x000F99F8 | 00 20 D2 E5 | LDRB    R2, [R2]\n0x000F99FC | 00 20 C3 E5 | STRB    R2, [R3]\n0x000F9A00 | 0C 30 1B E5 | LDR     R3, [R11,#c]\n0x000F9A04 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000F9A08 | 00 00 53 E3 | CMP     R3, #0\n0x000F9A0C | 09 00 00 0A | BEQ     loc_F9A38\n0x000F9A10 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9A14 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9A18 | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x000F9A1C | FF 3E 83 E2 | ADD     R3, R3, #0xFF0\n0x000F9A20 | 0F 30 83 E2 | ADD     R3, R3, #0xF\n0x000F9A24 | 10 20 1B E5 | LDR     R2, [R11,#d]\n0x000F9A28 | 03 00 52 E1 | CMP     R2, R3\n0x000F9A2C | E1 FF FF 1A | BNE     loc_F99B8\n0x000F9A30 | 00 00 00 EA | B       loc_F9A38\n0x000F9A34 | 00 00 A0 E1 | NOP\n0x000F9A38 | 10 30 1B E5 | LDR     R3, [R11,#d]\n0x000F9A3C | 00 20 A0 E3 | MOV     R2, #0\n0x000F9A40 | 00 20 C3 E5 | STRB    R2, [R3]\n0x000F9A44 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9A48 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9A4C | 14 30 13 E5 | LDR     R3, [R3,#-0x14]\n0x000F9A50 | 04 00 93 E5 | LDR     R0, [R3,#4]; pattern\n0x000F9A54 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9A58 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9A5C | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x000F9A60 | 00 20 A0 E3 | MOV     R2, #0; flags\n0x000F9A64 | 03 10 A0 E1 | MOV     R1, R3; name\n0x000F9A68 | 48 6E FC EB | BL      fnmatch\n0x000F9A6C | 00 30 A0 E1 | MOV     R3, R0\n0x000F9A70 | 00 00 53 E3 | CMP     R3, #0\n0x000F9A74 | 03 00 00 1A | BNE     loc_F9A88\n0x000F9A78 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9A7C | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9A80 | 14 30 13 E5 | LDR     R3, [R3,#-0x14]\n0x000F9A84 | 0D 00 00 EA | B       loc_F9AC0\n0x000F9A88 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9A8C | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9A90 | 03 20 A0 E1 | MOV     R2, R3\n0x000F9A94 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9A98 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9A9C | 14 30 13 E5 | LDR     R3, [R3,#-0x14]\n0x000F9AA0 | 00 30 93 E5 | LDR     R3, [R3]\n0x000F9AA4 | 14 30 02 E5 | STR     R3, [R2,#-0x14]\n0x000F9AA8 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9AAC | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9AB0 | 14 30 13 E5 | LDR     R3, [R3,#-0x14]\n0x000F9AB4 | 00 00 53 E3 | CMP     R3, #0\n0x000F9AB8 | A0 FF FF 1A | BNE     loc_F9940\n0x000F9ABC | 00 30 A0 E3 | MOV     R3, #0\n0x000F9AC0 | 03 00 A0 E1 | MOV     R0, R3\n0x000F9AC4 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000F9AC8 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function() {\n    int buf[256];\n    int pattern_slash_cnt = 0;\n    int c = 0;\n    int d = 0;\n    \n    buf[0] = 0;\n    buf[1] = 0;\n    \n    while (1) {\n        if (buf[c] == '/') {\n            pattern_slash_cnt++;\n        }\n        \n        if (buf[c] == 0) {\n            break;\n        }\n        \n        if (buf[c] == '/') {\n            if (pattern_slash_cnt < 2) {\n                buf[d] = buf[c];\n                d++;\n            }\n        } else {\n            buf[d] = buf[c];\n            d++;\n        }\n        \n        c++;\n    }\n    \n    buf[d] = 0;\n    \n    if (fnmatch(buf, buf, 0) == 0) {\n        buf[0] = 0;\n    }\n}\n```"
    },
    {
        "func_name": "sprint_status",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00097928 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0009792C | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00097930 | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x00097934 | 10 00 0B E5 | STR     R0, [R11,#s]\n0x00097938 | 14 10 0B E5 | STR     R1, [R11,#status]\n0x0009793C | 18 20 0B E5 | STR     R2, [R11,#sigonly]\n0x00097940 | 00 30 A0 E3 | MOV     R3, #0\n0x00097944 | 08 30 0B E5 | STR     R3, [R11,#col]\n0x00097948 | 14 30 1B E5 | LDR     R3, [R11,#status]\n0x0009794C | 7F 30 03 E2 | AND     R3, R3, #0x7F\n0x00097950 | 00 00 53 E3 | CMP     R3, #0\n0x00097954 | 33 00 00 0A | BEQ     loc_97A28\n0x00097958 | 14 30 1B E5 | LDR     R3, [R11,#status]\n0x0009795C | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x00097960 | 7F 00 53 E3 | CMP     R3, #0x7F\n0x00097964 | 04 00 00 1A | BNE     loc_9797C\n0x00097968 | 14 30 1B E5 | LDR     R3, [R11,#status]\n0x0009796C | 43 34 A0 E1 | MOV     R3, R3,ASR#8\n0x00097970 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x00097974 | 0C 30 0B E5 | STR     R3, [R11,#st]\n0x00097978 | 02 00 00 EA | B       loc_97988\n0x0009797C | 14 30 1B E5 | LDR     R3, [R11,#status]\n0x00097980 | 7F 30 03 E2 | AND     R3, R3, #0x7F\n0x00097984 | 0C 30 0B E5 | STR     R3, [R11,#st]\n0x00097988 | 18 30 1B E5 | LDR     R3, [R11,#sigonly]\n0x0009798C | 00 00 53 E3 | CMP     R3, #0\n0x00097990 | 09 00 00 0A | BEQ     loc_979BC\n0x00097994 | 0C 30 1B E5 | LDR     R3, [R11,#st]\n0x00097998 | 02 00 53 E3 | CMP     R3, #2\n0x0009799C | 38 00 00 0A | BEQ     loc_97A84\n0x000979A0 | 0C 30 1B E5 | LDR     R3, [R11,#st]\n0x000979A4 | 0D 00 53 E3 | CMP     R3, #0xD\n0x000979A8 | 35 00 00 0A | BEQ     loc_97A84\n0x000979AC | 14 30 1B E5 | LDR     R3, [R11,#status]\n0x000979B0 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x000979B4 | 7F 00 53 E3 | CMP     R3, #0x7F\n0x000979B8 | 33 00 00 0A | BEQ     loc_97A8C\n0x000979BC | 0C 30 1B E5 | LDR     R3, [R11,#st]\n0x000979C0 | 7F 30 03 E2 | AND     R3, R3, #0x7F\n0x000979C4 | 0C 30 0B E5 | STR     R3, [R11,#st]\n0x000979C8 | 0C 00 1B E5 | LDR     R0, [R11,#st]\n0x000979CC | FA F5 FD EB | BL      strsignal\n0x000979D0 | 00 30 A0 E1 | MOV     R3, R0\n0x000979D4 | 03 20 A0 E1 | MOV     R2, R3; fmt\n0x000979D8 | 20 10 A0 E3 | MOV     R1, #0x20 ; ' '; length\n0x000979DC | 10 00 1B E5 | LDR     R0, [R11,#s]; outbuf\n0x000979E0 | 48 EF FF EB | BL      fmtstr\n0x000979E4 | 08 00 0B E5 | STR     R0, [R11,#col]\n0x000979E8 | 14 30 1B E5 | LDR     R3, [R11,#status]\n0x000979EC | 80 30 03 E2 | AND     R3, R3, #0x80\n0x000979F0 | 00 00 53 E3 | CMP     R3, #0\n0x000979F4 | 27 00 00 0A | BEQ     out\n0x000979F8 | 08 30 1B E5 | LDR     R3, [R11,#col]\n0x000979FC | 10 20 1B E5 | LDR     R2, [R11,#s]\n0x00097A00 | 03 30 82 E0 | ADD     R3, R2, R3\n0x00097A04 | 9C 20 9F E5 | LDR     R2, =aCoreDumped; \" (core dumped)\"\n0x00097A08 | 10 10 A0 E3 | MOV     R1, #0x10; length\n0x00097A0C | 03 00 A0 E1 | MOV     R0, R3; outbuf\n0x00097A10 | 3C EF FF EB | BL      fmtstr\n0x00097A14 | 00 20 A0 E1 | MOV     R2, R0\n0x00097A18 | 08 30 1B E5 | LDR     R3, [R11,#col]\n0x00097A1C | 02 30 83 E0 | ADD     R3, R3, R2\n0x00097A20 | 08 30 0B E5 | STR     R3, [R11,#col]\n0x00097A24 | 1B 00 00 EA | B       out\n0x00097A28 | 18 30 1B E5 | LDR     R3, [R11,#sigonly]\n0x00097A2C | 00 00 53 E3 | CMP     R3, #0\n0x00097A30 | 17 00 00 1A | BNE     loc_97A94\n0x00097A34 | 14 30 1B E5 | LDR     R3, [R11,#status]\n0x00097A38 | 43 34 A0 E1 | MOV     R3, R3,ASR#8\n0x00097A3C | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x00097A40 | 0C 30 0B E5 | STR     R3, [R11,#st]\n0x00097A44 | 0C 30 1B E5 | LDR     R3, [R11,#st]\n0x00097A48 | 00 00 53 E3 | CMP     R3, #0\n0x00097A4C | 06 00 00 0A | BEQ     loc_97A6C\n0x00097A50 | 0C 30 1B E5 | LDR     R3, [R11,#st]\n0x00097A54 | 50 20 9F E5 | LDR     R2, =aDoneD; \"Done(%d)\"\n0x00097A58 | 10 10 A0 E3 | MOV     R1, #0x10; length\n0x00097A5C | 10 00 1B E5 | LDR     R0, [R11,#s]; outbuf\n0x00097A60 | 28 EF FF EB | BL      fmtstr\n0x00097A64 | 08 00 0B E5 | STR     R0, [R11,#col]\n0x00097A68 | 0A 00 00 EA | B       out\n0x00097A6C | 3C 20 9F E5 | LDR     R2, =aDone_0; \"Done\"\n0x00097A70 | 10 10 A0 E3 | MOV     R1, #0x10; length\n0x00097A74 | 10 00 1B E5 | LDR     R0, [R11,#s]; outbuf\n0x00097A78 | 22 EF FF EB | BL      fmtstr\n0x00097A7C | 08 00 0B E5 | STR     R0, [R11,#col]\n0x00097A80 | 04 00 00 EA | B       out\n0x00097A84 | 00 00 A0 E1 | NOP\n0x00097A88 | 02 00 00 EA | B       out\n0x00097A8C | 00 00 A0 E1 | NOP\n0x00097A90 | 00 00 00 EA | B       out\n0x00097A94 | 00 00 A0 E1 | NOP\n0x00097A98 | 08 30 1B E5 | LDR     R3, [R11,#col]\n0x00097A9C | 03 00 A0 E1 | MOV     R0, R3\n0x00097AA0 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00097AA4 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(int s, int status, int sigonly, int col) {\n    int st;\n    st = status & 0xFF;\n    if (st == 0) {\n        st = (status >> 8) & 0xFF;\n    }\n    if (st == 0) {\n        st = sigonly & 0x7F;\n    }\n    if (st == 0) {\n        st = 2;\n    }\n    if (st == 0xD) {\n        st = 2;\n    }\n    if (st == 0x7F) {\n        st = sigonly & 0x7F;\n    }\n    strsignal(st);\n    char outbuf[0x20];\n    sprintf(outbuf, \" (core dumped)\");\n    col += sprintf(outbuf + col, outbuf);\n    if (status & 0x80) {\n        sprintf(outbuf + col, \"Done(%d)\", st);\n    } else {\n        sprintf(outbuf + col, \"Done\");\n    }\n    return;\n}\n```"
    },
    {
        "func_name": "write_str_to_file",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0008440C | 00 48 2D E9 | PUSH    {R11,LR}\n0x00084410 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00084414 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x00084418 | 10 00 0B E5 | STR     R0, [R11,#fname]\n0x0008441C | 14 10 0B E5 | STR     R1, [R11,#str]\n0x00084420 | 10 00 1B E5 | LDR     R0, [R11,#fname]; path\n0x00084424 | 9F 52 FE EB | BL      fopen_for_write\n0x00084428 | 08 00 0B E5 | STR     R0, [R11,#fp]\n0x0008442C | 08 30 1B E5 | LDR     R3, [R11,#fp]\n0x00084430 | 00 00 53 E3 | CMP     R3, #0\n0x00084434 | 01 00 00 1A | BNE     loc_84440\n0x00084438 | 01 30 A0 E3 | MOV     R3, #1\n0x0008443C | 05 00 00 EA | B       loc_84458\n0x00084440 | 08 10 1B E5 | LDR     R1, [R11,#fp]\n0x00084444 | 14 00 1B E5 | LDR     R0, [R11,#str]\n0x00084448 | 0E 42 FE EB | BL      fputs_unlocked\n0x0008444C | 08 00 1B E5 | LDR     R0, [R11,#fp]; stream\n0x00084450 | 1E 45 FE EB | BL      fclose\n0x00084454 | 00 30 A0 E3 | MOV     R3, #0\n0x00084458 | 03 00 A0 E1 | MOV     R0, R3\n0x0008445C | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00084460 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(char* fname, char* str) {\n    FILE* fp = fopen(fname, \"w\");\n    if (fp != NULL) {\n        fputs_unlocked(str, fp);\n        fclose(fp);\n    }\n}\n```"
    },
    {
        "func_name": "parse_old_offset",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0010C85C | 10 48 2D E9 | PUSH    {R4,R11,LR}\n0x0010C860 | 08 B0 8D E2 | ADD     R11, SP, #8\n0x0010C864 | 14 D0 4D E2 | SUB     SP, SP, #0x14\n0x0010C868 | 18 00 0B E5 | STR     R0, [R11,#s]\n0x0010C86C | 1C 10 0B E5 | STR     R1, [R11,#offset]\n0x0010C870 | 18 30 1B E5 | LDR     R3, [R11,#s]\n0x0010C874 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0010C878 | 2B 00 53 E3 | CMP     R3, #0x2B ; '+'\n0x0010C87C | 02 00 00 1A | BNE     loc_10C88C\n0x0010C880 | 18 30 1B E5 | LDR     R3, [R11,#s]\n0x0010C884 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0010C888 | 18 30 0B E5 | STR     R3, [R11,#s]\n0x0010C88C | 18 30 1B E5 | LDR     R3, [R11,#s]\n0x0010C890 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0010C894 | 30 30 43 E2 | SUB     R3, R3, #0x30 ; '0'\n0x0010C898 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x0010C89C | 09 00 53 E3 | CMP     R3, #9\n0x0010C8A0 | 01 00 00 9A | BLS     loc_10C8AC\n0x0010C8A4 | 00 30 A0 E3 | MOV     R3, #0\n0x0010C8A8 | 31 00 00 EA | B       loc_10C974\n0x0010C8AC | 2E 10 A0 E3 | MOV     R1, #0x2E ; '.'; c\n0x0010C8B0 | 18 00 1B E5 | LDR     R0, [R11,#s]; s\n0x0010C8B4 | 45 23 FC EB | BL      strchr\n0x0010C8B8 | 14 00 0B E5 | STR     R0, [R11,#p]\n0x0010C8BC | 08 30 A0 E3 | MOV     R3, #8\n0x0010C8C0 | 10 30 0B E5 | STR     R3, [R11,#radix]\n0x0010C8C4 | 14 30 1B E5 | LDR     R3, [R11,#p]\n0x0010C8C8 | 00 00 53 E3 | CMP     R3, #0\n0x0010C8CC | 05 00 00 0A | BEQ     loc_10C8E8\n0x0010C8D0 | 14 30 1B E5 | LDR     R3, [R11,#p]\n0x0010C8D4 | 00 20 A0 E3 | MOV     R2, #0\n0x0010C8D8 | 00 20 C3 E5 | STRB    R2, [R3]\n0x0010C8DC | 0A 30 A0 E3 | MOV     R3, #0xA\n0x0010C8E0 | 10 30 0B E5 | STR     R3, [R11,#radix]\n0x0010C8E4 | 0F 00 00 EA | B       loc_10C928\n0x0010C8E8 | 18 30 1B E5 | LDR     R3, [R11,#s]\n0x0010C8EC | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0010C8F0 | 30 00 53 E3 | CMP     R3, #0x30 ; '0'\n0x0010C8F4 | 0B 00 00 1A | BNE     loc_10C928\n0x0010C8F8 | 18 30 1B E5 | LDR     R3, [R11,#s]\n0x0010C8FC | 01 30 83 E2 | ADD     R3, R3, #1\n0x0010C900 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0010C904 | 78 00 53 E3 | CMP     R3, #0x78 ; 'x'\n0x0010C908 | 04 00 00 0A | BEQ     loc_10C920\n0x0010C90C | 18 30 1B E5 | LDR     R3, [R11,#s]\n0x0010C910 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0010C914 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0010C918 | 58 00 53 E3 | CMP     R3, #0x58 ; 'X'\n0x0010C91C | 01 00 00 1A | BNE     loc_10C928\n0x0010C920 | 10 30 A0 E3 | MOV     R3, #0x10\n0x0010C924 | 10 30 0B E5 | STR     R3, [R11,#radix]\n0x0010C928 | 50 20 9F E5 | LDR     R2, =Bb.10702; suffixes\n0x0010C92C | 10 10 1B E5 | LDR     R1, [R11,#radix]; base\n0x0010C930 | 18 00 1B E5 | LDR     R0, [R11,#s]; numstr\n0x0010C934 | 4A 22 01 EB | BL      xstrtoull_sfx\n0x0010C938 | 00 30 A0 E1 | MOV     R3, R0\n0x0010C93C | 01 40 A0 E1 | MOV     R4, R1\n0x0010C940 | 1C 20 1B E5 | LDR     R2, [R11,#offset]\n0x0010C944 | 18 00 82 E8 | STM     R2, {R3,R4}\n0x0010C948 | 14 30 1B E5 | LDR     R3, [R11,#p]\n0x0010C94C | 00 00 53 E3 | CMP     R3, #0\n0x0010C950 | 02 00 00 0A | BEQ     loc_10C960\n0x0010C954 | 14 30 1B E5 | LDR     R3, [R11,#p]\n0x0010C958 | 2E 20 A0 E3 | MOV     R2, #0x2E ; '.'\n0x0010C95C | 00 20 C3 E5 | STRB    R2, [R3]\n0x0010C960 | 1C 30 1B E5 | LDR     R3, [R11,#offset]\n0x0010C964 | 18 00 93 E8 | LDM     R3, {R3,R4}\n0x0010C968 | 04 30 E0 E1 | MVN     R3, R4\n0x0010C96C | A3 3F A0 E1 | MOV     R3, R3,LSR#31\n0x0010C970 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x0010C974 | 03 00 A0 E1 | MOV     R0, R3\n0x0010C978 | 08 D0 4B E2 | SUB     SP, R11, #8\n0x0010C97C | 10 88 BD E8 | POP     {R4,R11,PC}",
        "output": "```c\nvoid function(char* s, int offset, int radix, char* p) {\n    // Save registers\n    __asm__(\"PUSH {R4,R11,LR}\");\n    \n    // Set up stack frame\n    __asm__(\"ADD R11, SP, #8\");\n    __asm__(\"SUB SP, SP, #0x14\");\n    \n    // Store arguments on stack\n    __asm__(\"STR R0, [R11,#s]\");\n    __asm__(\"STR R1, [R11,#offset]\");\n    \n    // Load s into R3\n    __asm__(\"LDR R3, [R11,#s]\");\n    \n    // Load first character of s into R3\n    __asm__(\"LDRB R3, [R3]\");\n    \n    // Compare R3 with '+'\n    __asm__(\"CMP R3, #0x2B\");\n    \n    // Branch if not equal\n    __asm__(\"BNE loc_10C88C\");\n    \n    // Increment s by 1\n    __asm__(\"LDR R3, [R11,#s]\");\n    __asm__(\"ADD R3, R3, #1\");\n    __asm__(\"STR R3, [R11,#s]\");\n    \n    // Load s into R3\n    __asm__(\"LDR R3, [R11,#s]\");\n    \n    // Load first character of s into R3\n    __asm__(\"LDRB R3, [R3]\");\n    \n    // Subtract '0' from R3\n    __asm__(\"SUB R3, R3, #0x30\");\n    \n    // Mask R3 with 0xFF\n    __asm__(\"AND R3, R3, #0xFF\");\n    \n    // Compare R3 with 9\n    __asm__(\"CMP R3, #9\");\n    \n    // Branch if less than or equal\n    __asm__(\"BLS loc_10C8AC\");\n    \n    // Set R3 to 0\n    __asm__(\"MOV R3, #0\");\n    \n    // Branch to loc_10C974\n    __asm__(\"B loc_10C974\");\n    \nloc_10C88C:\n    // Set R1 to '.'\n    __asm__(\"MOV R1, #0x2E\");\n    \n    // Load s into R0\n    __asm__(\"LDR R0, [R11,#s]\");\n    \n    // Call strchr\n    __asm__(\"BL strchr\");\n    \n    // Store return value in p\n    __asm__(\"STR R0, [R11,#p]\");\n    \n    // Set R3 to 8\n    __asm__(\"MOV R3, #8\");\n    \n    // Store R3 in radix\n    __asm__(\"STR R3, [R11,#radix]\");\n    \n    // Load p into R3\n    __asm__(\"LDR R3, [R11,#p]\");\n    \n    // Compare R3 with 0\n    __asm__(\"CMP R3, #0\");\n    \n    // Branch if equal\n    __asm__(\"BEQ loc_10C8E8\");\n    \n    // Load p into R3\n    __asm__(\"LDR R3, [R11,#p]\");\n    \n    // Set R2 to 0\n    __asm__(\"MOV R2, #0\");\n    \n    // Store R2 in R3\n    __asm__(\"STRB R2, [R3]\");\n    \n    // Set R3 to 0xA\n    __asm__(\"MOV R3, #0xA\");\n    \n    // Store R3 in radix\n    __asm__(\"STR R3, [R11,#radix]\");\n    \n    // Branch to loc_10C928\n    __asm__(\"B loc_10C928\");\n    \nloc_10C8E8:\n    // Load s into R3\n    __asm__(\"LDR R3, [R11,#s]\");\n    \n    // Load first character of s into R3\n    __asm__(\"LDRB R3, [R3]\");\n    \n    // Compare R3 with '0'\n    __asm__(\"CMP R3, #0x30\");\n    \n    // Branch if not equal\n    __asm__(\"BNE loc_10C928\");\n    \n    // Increment s by 1\n    __asm__(\"LDR R3, [R11,#s]\");\n    __asm__(\"ADD R3, R3, #1\");\n    __asm__(\"STR R3, [R11,#s]\");\n    \n    // Load s into R3\n    __asm__(\"LDR R3, [R11,#s]\");\n    \n    // Load first character of s into R3\n    __asm__(\"LDRB R3, [R3]\");\n    \n    // Compare R3 with 'x'\n    __asm__(\"CMP R3, #0x78\");\n    \n    // Branch if equal\n    __asm__(\"BEQ loc_10C920\");\n    \n    // Load s into R3\n    __asm__(\"LDR R3, [R11,#s]\");\n    \n    // Load first character of s into R3\n    __asm__(\"LDRB R3, [R3]\");\n    \n    // Compare R3 with 'X'\n    __asm__(\"CMP R3, #0x58\");\n    \n    // Branch if not equal\n    __asm__(\"BNE loc_10C928\");\n    \nloc_10C920:\n    // Set R3 to 0x10\n    __asm__(\"MOV R3, #0x10\");\n    \n    // Store R3 in radix\n    __asm__(\"STR R3, [R11,#radix]\");\n    \nloc_10C928:\n    // Load Bb.10702 into R2\n    __asm__(\"LDR R2, =Bb.10702\");\n    \n    // Load radix into R1\n    __asm__(\"LDR R1, [R11,#radix]\");\n    \n    // Load numstr into R0\n    __asm__(\"LDR R0, [R11,#s]\");\n    \n    // Call xstrtoull_sfx\n    __asm__(\"BL xstrtoull_sfx\");\n    \n    // Move R0 to R3\n    __asm__(\"MOV R3, R0\");\n    \n    // Move R1 to R4\n    __asm__(\"MOV R4, R1\");\n    \n    // Load offset into R2\n    __asm__(\"LDR R2, [R11,#offset]\");\n    \n    // Store R3 and R4 in [R2]\n    __asm__(\"STM R2, {R3,R4}\");\n    \n    // Load p into R3\n    __asm__(\"LDR R3, [R11,#p]\");\n    \n    // Compare R3 with 0\n    __asm__(\"CMP R3, #0\");\n    \n    // Branch if equal\n    __asm__(\"BEQ loc_10C960\");\n    \n    // Load p into R3\n    __asm__(\"LDR R3, [R11,#p]\");\n    \n    // Set R2 to '.'\n    __asm__(\"MOV R2, #0x2E\");\n    \n    // Store R2 in R3\n    __asm__(\"STRB R2, [R3]\");\n    \nloc_10C960:\n    // Load offset into R3\n    __asm__(\"LDR R3, [R11,#offset]\");\n    \n    // Load [R3] into R3 and R4\n    __asm__(\"LDM R3, {R3,R4}\");\n    \n    // Negate R3\n    __asm__(\"MVN R3, R4\");\n    \n    // Shift R3 right by 31 bits\n    __asm__(\"MOV R3, R3, LSR #31\");\n    \n    // Mask R3 with 0xFF\n    __asm__(\"AND R3, R3, #0xFF\");\n    \n    // Move R3 to R0\n    __asm__(\"MOV R0, R3\");\n    \n    // Restore stack pointer\n    __asm__(\"SUB SP, R11, #8\");\n    \n    // Restore registers\n    __asm__(\"POP {R4,R11,PC}\");\n}\n```"
    },
    {
        "func_name": "do_lzo_compress",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000E9D2C | 00 48 2D E9 | PUSH    {R11,LR}\n0x000E9D30 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000E9D34 | 13 DE 4D E2 | SUB     SP, SP, #0x130\n0x000E9D38 | 13 3E 4B E2 | SUB     R3, R11, #-header\n0x000E9D3C | 4B 2F A0 E3 | MOV     R2, #0x12C; n\n0x000E9D40 | 00 10 A0 E3 | MOV     R1, #0; c\n0x000E9D44 | 03 00 A0 E1 | MOV     R0, R3; s\n0x000E9D48 | 86 AE FC EB | BL      memset\n0x000E9D4C | 13 3E 4B E2 | SUB     R3, R11, #-header\n0x000E9D50 | 03 00 A0 E1 | MOV     R0, R3; h\n0x000E9D54 | D0 FF FF EB | BL      lzo_set_method\n0x000E9D58 | 8C 30 9F E5 | LDR     R3, =0x1010\n0x000E9D5C | 30 31 0B E5 | STR     R3, [R11,#header]\n0x000E9D60 | 25 3D A0 E3 | MOV     R3, #0x940\n0x000E9D64 | 28 31 0B E5 | STR     R3, [R11,#header.version_needed_to_extract]\n0x000E9D68 | 80 30 9F E5 | LDR     R3, =0x2030\n0x000E9D6C | 2C 31 0B E5 | STR     R3, [R11,#header.lib_version]\n0x000E9D70 | 03 34 A0 E3 | MOV     R3, #0x3000000\n0x000E9D74 | 24 31 0B E5 | STR     R3, [R11,#header.flags]\n0x000E9D78 | 74 30 9F E5 | LDR     R3, =option_mask32\n0x000E9D7C | 00 30 93 E5 | LDR     R3, [R3]\n0x000E9D80 | 02 39 03 E2 | AND     R3, R3, #0x8000\n0x000E9D84 | 00 00 53 E3 | CMP     R3, #0\n0x000E9D88 | 02 00 00 0A | BEQ     loc_E9D98\n0x000E9D8C | 08 31 5B E5 | LDRB    R3, [R11,#header.method]\n0x000E9D90 | 03 00 53 E3 | CMP     R3, #3\n0x000E9D94 | 0A 00 00 1A | BNE     loc_E9DC4\n0x000E9D98 | 24 31 1B E5 | LDR     R3, [R11,#header.flags]\n0x000E9D9C | 01 30 83 E3 | ORR     R3, R3, #1\n0x000E9DA0 | 24 31 0B E5 | STR     R3, [R11,#header.flags]\n0x000E9DA4 | 48 30 9F E5 | LDR     R3, =option_mask32\n0x000E9DA8 | 00 30 93 E5 | LDR     R3, [R3]\n0x000E9DAC | 01 39 03 E2 | AND     R3, R3, #0x4000\n0x000E9DB0 | 00 00 53 E3 | CMP     R3, #0\n0x000E9DB4 | 02 00 00 0A | BEQ     loc_E9DC4\n0x000E9DB8 | 24 31 1B E5 | LDR     R3, [R11,#header.flags]\n0x000E9DBC | 02 30 83 E3 | ORR     R3, R3, #2\n0x000E9DC0 | 24 31 0B E5 | STR     R3, [R11,#header.flags]\n0x000E9DC4 | 13 3E 4B E2 | SUB     R3, R11, #-header\n0x000E9DC8 | 03 00 A0 E1 | MOV     R0, R3; h\n0x000E9DCC | 92 FE FF EB | BL      write_header\n0x000E9DD0 | 13 3E 4B E2 | SUB     R3, R11, #-header\n0x000E9DD4 | 03 00 A0 E1 | MOV     R0, R3; h\n0x000E9DD8 | 9D FC FF EB | BL      lzo_compress\n0x000E9DDC | 00 30 A0 E1 | MOV     R3, R0\n0x000E9DE0 | 03 00 A0 E1 | MOV     R0, R3\n0x000E9DE4 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000E9DE8 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function() {\n    int header = 0x130;\n    int n = 0x12C;\n    int c = 0;\n    int s = header;\n    \n    memset(s, c, n);\n    \n    int h = header;\n    lzo_set_method(h);\n    \n    header.version_needed_to_extract = 0x940;\n    header.lib_version = 0x2030;\n    header.flags = 0x3000000;\n    \n    if (option_mask32 & 0x8000 == 0) {\n        if (header.method != 3) {\n            header.flags |= 1;\n        }\n    }\n    \n    if (option_mask32 & 0x4000 == 0) {\n        header.flags |= 2;\n    }\n    \n    write_header(h);\n    lzo_compress(h);\n}\n```"
    },
    {
        "func_name": "parse_next_rule",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000CD1A4 | 10 48 2D E9 | PUSH    {R4,R11,LR}\n0x000CD1A8 | 08 B0 8D E2 | ADD     R11, SP, #8\n0x000CD1AC | 34 D0 4D E2 | SUB     SP, SP, #0x34\n0x000CD1B0 | 0C 33 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD1B4 | 18 00 93 E5 | LDR     R0, [R3,#(qword_18F9F0 - 0x18F9D8)]; parser\n0x000CD1B8 | 34 10 4B E2 | SUB     R1, R11, #-tokens; tokens\n0x000CD1BC | 04 33 9F E5 | LDR     R3, =byte_175554; delims\n0x000CD1C0 | 04 23 9F E5 | LDR     R2, =0x70304; flags\n0x000CD1C4 | F9 F8 01 EB | BL      config_read\n0x000CD1C8 | 00 30 A0 E1 | MOV     R3, R0\n0x000CD1CC | 00 00 53 E3 | CMP     R3, #0\n0x000CD1D0 | 07 00 00 1A | BNE     loc_CD1F4\n0x000CD1D4 | E8 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD1D8 | 18 30 93 E5 | LDR     R3, [R3,#(qword_18F9F0 - 0x18F9D8)]\n0x000CD1DC | 03 00 A0 E1 | MOV     R0, R3; parser\n0x000CD1E0 | 68 F8 01 EB | BL      config_close\n0x000CD1E4 | D8 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD1E8 | 00 20 A0 E3 | MOV     R2, #0\n0x000CD1EC | 18 20 83 E5 | STR     R2, [R3,#(qword_18F9F0 - 0x18F9D8)]\n0x000CD1F0 | B1 00 00 EA | B       loc_CD4BC\n0x000CD1F4 | 34 30 1B E5 | LDR     R3, [R11,#tokens]\n0x000CD1F8 | 10 30 0B E5 | STR     R3, [R11,#val]\n0x000CD1FC | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD200 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000CD204 | B8 22 9F E5 | LDR     R2, =bb_common_bufsiz1\n0x000CD208 | 2D 00 53 E3 | CMP     R3, #0x2D ; '-'\n0x000CD20C | 01 30 A0 03 | MOVEQ   R3, #1\n0x000CD210 | 00 30 A0 13 | MOVNE   R3, #0\n0x000CD214 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x000CD218 | 24 30 C2 E5 | STRB    R3, [R2,#(qword_18F9F8+4 - 0x18F9D8)]\n0x000CD21C | A0 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD220 | 24 30 D3 E5 | LDRB    R3, [R3,#(qword_18F9F8+4 - 0x18F9D8)]\n0x000CD224 | 03 20 A0 E1 | MOV     R2, R3\n0x000CD228 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD22C | 02 30 83 E0 | ADD     R3, R3, R2\n0x000CD230 | 10 30 0B E5 | STR     R3, [R11,#val]\n0x000CD234 | 10 00 1B E5 | LDR     R0, [R11,#val]; val\n0x000CD238 | 91 FF FF EB | BL      parse_envmatch_pfx\n0x000CD23C | 10 00 0B E5 | STR     R0, [R11,#val]\n0x000CD240 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD244 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000CD248 | 40 00 53 E3 | CMP     R3, #0x40 ; '@'\n0x000CD24C | 1E 00 00 1A | BNE     loc_CD2CC\n0x000CD250 | 78 22 9F E5 | LDR     R2, =unk_18FA04\n0x000CD254 | 78 12 9F E5 | LDR     R1, =word_18FA08\n0x000CD258 | 78 32 9F E5 | LDR     R3, =byte_18FA0C\n0x000CD25C | 00 30 8D E5 | STR     R3, [SP,#0x3C+var_3C]\n0x000CD260 | 01 30 A0 E1 | MOV     R3, R1\n0x000CD264 | 70 12 9F E5 | LDR     R1, =aUUU_1; \"@%u,%u-%u\"\n0x000CD268 | 10 00 1B E5 | LDR     R0, [R11,#val]; s\n0x000CD26C | 09 22 FD EB | BL      sscanf\n0x000CD270 | 14 00 0B E5 | STR     R0, [R11,#sc]\n0x000CD274 | 14 30 1B E5 | LDR     R3, [R11,#sc]\n0x000CD278 | 01 00 53 E3 | CMP     R3, #1\n0x000CD27C | 03 00 00 DA | BLE     loc_CD290\n0x000CD280 | 3C 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD284 | 2C 30 93 E5 | LDR     R3, [R3,#(unk_18FA04 - 0x18F9D8)]\n0x000CD288 | 00 00 53 E3 | CMP     R3, #0\n0x000CD28C | 06 00 00 AA | BGE     loc_CD2AC\n0x000CD290 | 2C 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD294 | 18 30 93 E5 | LDR     R3, [R3,#(qword_18F9F0 - 0x18F9D8)]\n0x000CD298 | 18 30 93 E5 | LDR     R3, [R3,#0x18]\n0x000CD29C | 03 10 A0 E1 | MOV     R1, R3\n0x000CD2A0 | 38 02 9F E5 | LDR     R0, =aBadMajMinOnLin; \"bad @maj,min on line %d\"\n0x000CD2A4 | C6 2E FD EB | BL      bb_error_msg\n0x000CD2A8 | 80 00 00 EA | B       next_rule\n0x000CD2AC | 14 30 1B E5 | LDR     R3, [R11,#sc]\n0x000CD2B0 | 02 00 53 E3 | CMP     R3, #2\n0x000CD2B4 | 2D 00 00 1A | BNE     loc_CD370\n0x000CD2B8 | 04 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD2BC | 00 22 9F E5 | LDR     R2, =bb_common_bufsiz1\n0x000CD2C0 | 30 30 93 E5 | LDR     R3, [R3,#(word_18FA08 - 0x18F9D8)]\n0x000CD2C4 | 34 30 82 E5 | STR     R3, [R2,#(byte_18FA0C - 0x18F9D8)]\n0x000CD2C8 | 28 00 00 EA | B       loc_CD370\n0x000CD2CC | 3D 10 A0 E3 | MOV     R1, #0x3D ; '='; c\n0x000CD2D0 | 10 00 1B E5 | LDR     R0, [R11,#val]; s\n0x000CD2D4 | BD 20 FD EB | BL      strchr\n0x000CD2D8 | 18 00 0B E5 | STR     R0, [R11,#eq]\n0x000CD2DC | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD2E0 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000CD2E4 | 24 00 53 E3 | CMP     R3, #0x24 ; '$'\n0x000CD2E8 | 18 00 00 1A | BNE     loc_CD350\n0x000CD2EC | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD2F0 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000CD2F4 | 10 30 0B E5 | STR     R3, [R11,#val]\n0x000CD2F8 | 18 30 1B E5 | LDR     R3, [R11,#eq]\n0x000CD2FC | 00 00 53 E3 | CMP     R3, #0\n0x000CD300 | 06 00 00 1A | BNE     loc_CD320\n0x000CD304 | B8 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD308 | 18 30 93 E5 | LDR     R3, [R3,#(qword_18F9F0 - 0x18F9D8)]\n0x000CD30C | 18 30 93 E5 | LDR     R3, [R3,#0x18]\n0x000CD310 | 03 10 A0 E1 | MOV     R1, R3\n0x000CD314 | C8 01 9F E5 | LDR     R0, =aBadEnvvarRegex; \"bad $envvar=regex on line %d\"\n0x000CD318 | A9 2E FD EB | BL      bb_error_msg\n0x000CD31C | 63 00 00 EA | B       next_rule\n0x000CD320 | 18 20 1B E5 | LDR     R2, [R11,#eq]\n0x000CD324 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD328 | 03 30 42 E0 | SUB     R3, R2, R3\n0x000CD32C | 90 41 9F E5 | LDR     R4, =bb_common_bufsiz1\n0x000CD330 | 03 10 A0 E1 | MOV     R1, R3; n\n0x000CD334 | 10 00 1B E5 | LDR     R0, [R11,#val]; s\n0x000CD338 | 22 32 FD EB | BL      xstrndup\n0x000CD33C | 00 30 A0 E1 | MOV     R3, R0\n0x000CD340 | 40 30 84 E5 | STR     R3, [R4,#(byte_18FA0C+0xC - 0x18F9D8)]\n0x000CD344 | 18 30 1B E5 | LDR     R3, [R11,#eq]\n0x000CD348 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000CD34C | 10 30 0B E5 | STR     R3, [R11,#val]\n0x000CD350 | 90 31 9F E5 | LDR     R3, =(byte_18FA20+4)\n0x000CD354 | 01 20 A0 E3 | MOV     R2, #1; cflags\n0x000CD358 | 10 10 1B E5 | LDR     R1, [R11,#val]; regex\n0x000CD35C | 03 00 A0 E1 | MOV     R0, R3; preg\n0x000CD360 | 2C 27 02 EB | BL      xregcomp\n0x000CD364 | 58 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD368 | 01 20 A0 E3 | MOV     R2, #1\n0x000CD36C | 25 20 C3 E5 | STRB    R2, [R3,#(qword_18F9F8+5 - 0x18F9D8)]\n0x000CD370 | 74 01 9F E5 | LDR     R0, =(byte_18FA0C+4); u\n0x000CD374 | 30 30 1B E5 | LDR     R3, [R11,#tokens+4]\n0x000CD378 | 01 20 A0 E3 | MOV     R2, #1; numeric_ok\n0x000CD37C | 03 10 A0 E1 | MOV     R1, R3; ug\n0x000CD380 | B2 40 FD EB | BL      get_uidgid\n0x000CD384 | 00 30 A0 E1 | MOV     R3, R0\n0x000CD388 | 00 00 53 E3 | CMP     R3, #0\n0x000CD38C | 07 00 00 1A | BNE     loc_CD3B0\n0x000CD390 | 30 10 1B E5 | LDR     R1, [R11,#tokens+4]\n0x000CD394 | 28 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD398 | 18 30 93 E5 | LDR     R3, [R3,#(qword_18F9F0 - 0x18F9D8)]\n0x000CD39C | 18 30 93 E5 | LDR     R3, [R3,#0x18]\n0x000CD3A0 | 03 20 A0 E1 | MOV     R2, R3\n0x000CD3A4 | 44 01 9F E5 | LDR     R0, =aUnknownUserGro_1; \"unknown user/group '%s' on line %d\"\n0x000CD3A8 | 85 2E FD EB | BL      bb_error_msg\n0x000CD3AC | 3F 00 00 EA | B       next_rule\n0x000CD3B0 | 2C 30 1B E5 | LDR     R3, [R11,#tokens+8]\n0x000CD3B4 | 38 21 9F E5 | LDR     R2, =unk_18FA00\n0x000CD3B8 | 02 10 A0 E1 | MOV     R1, R2; current_mode\n0x000CD3BC | 03 00 A0 E1 | MOV     R0, R3; s\n0x000CD3C0 | 42 F9 01 EB | BL      bb_parse_mode\n0x000CD3C4 | 28 30 1B E5 | LDR     R3, [R11,#tokens+0xC]\n0x000CD3C8 | 10 30 0B E5 | STR     R3, [R11,#val]\n0x000CD3CC | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD3D0 | 00 00 53 E3 | CMP     R3, #0\n0x000CD3D4 | 16 00 00 0A | BEQ     loc_CD434\n0x000CD3D8 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD3DC | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000CD3E0 | 03 10 A0 E1 | MOV     R1, R3; c\n0x000CD3E4 | 0C 01 9F E5 | LDR     R0, =asc_1755C0; \">=!\"\n0x000CD3E8 | 78 20 FD EB | BL      strchr\n0x000CD3EC | 00 30 A0 E1 | MOV     R3, R0\n0x000CD3F0 | 00 00 53 E3 | CMP     R3, #0\n0x000CD3F4 | 0E 00 00 0A | BEQ     loc_CD434\n0x000CD3F8 | 10 00 1B E5 | LDR     R0, [R11,#val]; s\n0x000CD3FC | 81 2D FD EB | BL      skip_non_whitespace\n0x000CD400 | 1C 00 0B E5 | STR     R0, [R11,#s]\n0x000CD404 | 1C 20 1B E5 | LDR     R2, [R11,#s]\n0x000CD408 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD40C | 03 30 42 E0 | SUB     R3, R2, R3\n0x000CD410 | AC 40 9F E5 | LDR     R4, =bb_common_bufsiz1\n0x000CD414 | 03 10 A0 E1 | MOV     R1, R3; n\n0x000CD418 | 10 00 1B E5 | LDR     R0, [R11,#val]; s\n0x000CD41C | E9 31 FD EB | BL      xstrndup\n0x000CD420 | 00 30 A0 E1 | MOV     R3, R0\n0x000CD424 | 44 30 84 E5 | STR     R3, [R4,#(byte_18FA0C+0x10 - 0x18F9D8)]\n0x000CD428 | 1C 00 1B E5 | LDR     R0, [R11,#s]; s\n0x000CD42C | 5E 2D FD EB | BL      skip_whitespace\n0x000CD430 | 10 00 0B E5 | STR     R0, [R11,#val]\n0x000CD434 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD438 | 00 00 53 E3 | CMP     R3, #0\n0x000CD43C | 1D 00 00 0A | BEQ     loc_CD4B8\n0x000CD440 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD444 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000CD448 | 00 00 53 E3 | CMP     R3, #0\n0x000CD44C | 19 00 00 0A | BEQ     loc_CD4B8\n0x000CD450 | A4 30 9F E5 | LDR     R3, =asc_1755C4; \"$@*\"\n0x000CD454 | 20 30 0B E5 | STR     R3, [R11,#s_0]\n0x000CD458 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD45C | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000CD460 | 03 10 A0 E1 | MOV     R1, R3; c\n0x000CD464 | 20 00 1B E5 | LDR     R0, [R11,#s_0]; s\n0x000CD468 | 58 20 FD EB | BL      strchr\n0x000CD46C | 24 00 0B E5 | STR     R0, [R11,#s2]\n0x000CD470 | 24 30 1B E5 | LDR     R3, [R11,#s2]\n0x000CD474 | 00 00 53 E3 | CMP     R3, #0\n0x000CD478 | 06 00 00 1A | BNE     loc_CD498\n0x000CD47C | 40 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD480 | 18 30 93 E5 | LDR     R3, [R3,#(qword_18F9F0 - 0x18F9D8)]\n0x000CD484 | 18 30 93 E5 | LDR     R3, [R3,#0x18]\n0x000CD488 | 03 10 A0 E1 | MOV     R1, R3\n0x000CD48C | 6C 00 9F E5 | LDR     R0, =aBadLineU; \"bad line %u\"\n0x000CD490 | 4B 2E FD EB | BL      bb_error_msg\n0x000CD494 | 05 00 00 EA | B       next_rule\n0x000CD498 | 24 40 9F E5 | LDR     R4, =bb_common_bufsiz1\n0x000CD49C | 10 00 1B E5 | LDR     R0, [R11,#val]; s\n0x000CD4A0 | B1 31 FD EB | BL      xstrdup\n0x000CD4A4 | 00 30 A0 E1 | MOV     R3, R0\n0x000CD4A8 | 48 30 84 E5 | STR     R3, [R4,#(byte_18FA20 - 0x18F9D8)]\n0x000CD4AC | 02 00 00 EA | B       loc_CD4BC\n0x000CD4B0 | 9B FE FF EB | BL      clean_up_cur_rule\n0x000CD4B4 | 3D FF FF EA | B       loc_CD1B0\n0x000CD4B8 | 00 00 A0 E1 | NOP\n0x000CD4BC | 08 D0 4B E2 | SUB     SP, R11, #8\n0x000CD4C0 | 10 88 BD E8 | POP     {R4,R11,PC}",
        "output": "```c\nvoid function() {\n    int tokens;\n    int val;\n    char* parser;\n    char* delims;\n    int flags;\n    int result;\n\n    // Save registers\n    __asm__(\"PUSH {R4,R11,LR}\");\n\n    // Set up stack frame\n    __asm__(\"ADD R11, SP, #8\");\n\n    // Allocate space on the stack\n    __asm__(\"SUB SP, SP, #0x34\");\n\n    // Load address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Load address of parser into R0\n    __asm__(\"LDR R0, [R3, #(qword_18F9F0 - 0x18F9D8)]\");\n\n    // Calculate address of tokens and store in R1\n    __asm__(\"SUB R1, R11, #-tokens\");\n\n    // Load address of delims into R3\n    __asm__(\"LDR R3, =byte_175554\");\n\n    // Load flags into R2\n    __asm__(\"LDR R2, =0x70304\");\n\n    // Call config_read function\n    __asm__(\"BL config_read\");\n\n    // Move result to R3\n    __asm__(\"MOV R3, R0\");\n\n    // Compare R3 to 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch if not equal to loc_CD1F4\n    __asm__(\"BNE loc_CD1F4\");\n\n    // Load address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Load address of parser into R3\n    __asm__(\"LDR R3, [R3, #(qword_18F9F0 - 0x18F9D8)]\");\n\n    // Move parser to R0\n    __asm__(\"MOV R0, R3\");\n\n    // Call config_close function\n    __asm__(\"BL config_close\");\n\n    // Load address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Move 0 to R2\n    __asm__(\"MOV R2, #0\");\n\n    // Store 0 at address of parser\n    __asm__(\"STR R2, [R3, #(qword_18F9F0 - 0x18F9D8)]\");\n\n    // Branch to loc_CD4BC\n    __asm__(\"B loc_CD4BC\");\n\nloc_CD1F4:\n    // Load tokens into R3\n    __asm__(\"LDR R3, [R11, #tokens]\");\n\n    // Store tokens at address of val\n    __asm__(\"STR R3, [R11, #val]\");\n\n    // Load val into R3\n    __asm__(\"LDR R3, [R11, #val]\");\n\n    // Load byte at address in R3 into R3\n    __asm__(\"LDRB R3, [R3]\");\n\n    // Load address of bb_common_bufsiz1 into R2\n    __asm__(\"LDR R2, =bb_common_bufsiz1\");\n\n    // Compare R3 to 0x2D\n    __asm__(\"CMP R3, #0x2D\");\n\n    // Move 1 to R3 if equal\n    __asm__(\"MOVEQ R3, #1\");\n\n    // Move 0 to R3 if not equal\n    __asm__(\"MOVNE R3, #0\");\n\n    // Mask R3 with 0xFF\n    __asm__(\"AND R3, R3, #0xFF\");\n\n    // Store R3 at address of byte_18F9F8+4\n    __asm__(\"STRB R3, [R2, #(qword_18F9F8+4 - 0x18F9D8)]\");\n\n    // Load address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Load byte at address in R3 into R3\n    __asm__(\"LDRB R3, [R3, #(qword_18F9F8+4 - 0x18F9D8)]\");\n\n    // Move R3 to R2\n    __asm__(\"MOV R2, R3\");\n\n    // Load val into R3\n    __asm__(\"LDR R3, [R11, #val]\");\n\n    // Add R2 to R3 and store in R3\n    __asm__(\"ADD R3, R3, R2\");\n\n    // Store R3 at address of val\n    __asm__(\"STR R3, [R11, #val]\");\n\n    // Load val into R0\n    __asm__(\"LDR R0, [R11, #val]\");\n\n    // Call parse_envmatch_pfx function\n    __asm__(\"BL parse_envmatch_pfx\");\n\n    // Store R0 at address of val\n    __asm__(\"STR R0, [R11, #val]\");\n\n    // Load val into R3\n    __asm__(\"LDR R3, [R11, #val]\");\n\n    // Load byte at address in R3 into R3\n    __asm__(\"LDRB R3, [R3]\");\n\n    // Compare R3 to 0x40\n    __asm__(\"CMP R3, #0x40\");\n\n    // Branch if not equal to loc_CD2CC\n    __asm__(\"BNE loc_CD2CC\");\n\n    // Load address of unk_18FA04 into R2\n    __asm__(\"LDR R2, =unk_18FA04\");\n\n    // Load address of word_18FA08 into R1\n    __asm__(\"LDR R1, =word_18FA08\");\n\n    // Load address of byte_18FA0C into R3\n    __asm__(\"LDR R3, =byte_18FA0C\");\n\n    // Store R3 at SP+0x3C+var_3C\n    __asm__(\"STR R3, [SP, #0x3C+var_3C]\");\n\n    // Move R1 to R3\n    __asm__(\"MOV R3, R1\");\n\n    // Load address of aUUU_1 into R1\n    __asm__(\"LDR R1, =aUUU_1\");\n\n    // Load s into R0\n    __asm__(\"LDR R0, [R11, #val]\");\n\n    // Call sscanf function\n    __asm__(\"BL sscanf\");\n\n    // Store R0 at address of sc\n    __asm__(\"STR R0, [R11, #sc]\");\n\n    // Load sc into R3\n    __asm__(\"LDR R3, [R11, #sc]\");\n\n    // Compare R3 to 1\n    __asm__(\"CMP R3, #1\");\n\n    // Branch if less than or equal to loc_CD290\n    __asm__(\"BLE loc_CD290\");\n\n    // Load address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Load address of unk_18FA04 into R3\n    __asm__(\"LDR R3, [R3, #(unk_18FA04 - 0x18F9D8)]\");\n\n    // Compare R3 to 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch if greater than or equal to loc_CD2AC\n    __asm__(\"BGE loc_CD2AC\");\n\n    // Load address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Load address of qword_18F9F0 into R3\n    __asm__(\"LDR R3, [R3, #(qword_18F9F0 - 0x18F9D8)]\");\n\n    // Load 0x18 from address in R3 into R3\n    __asm__(\"LDR R3, [R3, #0x18]\");\n\n    // Move R3 to R1\n    __asm__(\"MOV R1, R3\");\n\n    // Load address of aBadMajMinOnLin into R0\n    __asm__(\"LDR R0, =aBadMajMinOnLin\");\n\n    // Call bb_error_msg function\n    __asm__(\"BL bb_error_msg\");\n\n    // Branch to next_rule\n    __asm__(\"B next_rule\");\n\nloc_CD2AC:\n    // Load sc into R3\n    __asm__(\"LDR R3, [R11, #sc]\");\n\n    // Compare R3 to 2\n    __asm__(\"CMP R3, #2\");\n\n    // Branch if not equal to loc_CD370\n    __asm__(\"BNE loc_CD370\");\n\n    // Load address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Load address of bb_common_bufsiz1 into R2\n    __asm__(\"LDR R2, =bb_common_bufsiz1\");\n\n    // Load word at address in R3 into R3\n    __asm__(\"LDR R3, [R3, #(word_18FA08 - 0x18F9D8)]\");\n\n    // Store R3 at address of byte_18FA0C\n    __asm__(\"STR R3, [R2, #(byte_18FA0C - 0x18F9D8)]\");\n\n    // Branch to loc_CD370\n    __asm__(\"B loc_CD370\");\n\nloc_CD2CC:\n    // Move 0x3D to R1\n    __asm__(\"MOV R1, #0x3D\");\n\n    // Load s into R0\n    __asm__(\"LDR R0, [R11, #val]\");\n\n    // Call strchr function\n    __asm__(\"BL strchr\");\n\n    // Store R0 at address of eq\n    __asm__(\"STR R0, [R11, #eq]\");\n\n    // Load val into R3\n    __asm__(\"LDR R3, [R11, #val]\");\n\n    // Load byte at address in R3 into R3\n    __asm__(\"LDRB R3, [R3]\");\n\n    // Compare R3 to 0x24\n    __asm__(\"CMP R3, #0x24\");\n\n    // Branch if not equal to loc_CD350\n    __asm__(\"BNE loc_CD350\");\n\n    // Load val into R3\n    __asm__(\"LDR R3, [R11, #val]\");\n\n    // Add 1 to R3\n    __asm__(\"ADD R3, R3, #1\");\n\n    // Store R3 at address of val\n    __asm__(\"STR R3, [R11, #val]\");\n\n    // Load eq into R3\n    __asm__(\"LDR R3, [R11, #eq]\");\n\n    // Compare R3 to 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch if not equal to loc_CD320\n    __asm__(\"BNE loc_CD320\");\n\n    // Load address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Load address of qword_18F9F0 into R3\n    __asm__(\"LDR R3, [R3, #(qword_18F9F0 - 0x18F9D8)]\");\n\n    // Load 0x18 from address in R3 into R3\n    __asm__(\"LDR R3, [R3, #0x18]\");\n\n    // Move R3 to R1\n    __asm__(\"MOV R1, R3\");\n\n    // Load address of aBadEnvvarRegex into R0\n    __asm__(\"LDR R0, =aBadEnvvarRegex\");\n\n    // Call bb_error_msg function\n    __asm__(\"BL bb_error_msg\");\n\n    // Branch to next_rule\n    __asm__(\"B next_rule\");\n\nloc_CD320:\n    // Load R2 from eq\n    __asm__(\"LDR R2, [R11, #eq]\");\n\n    // Load val into R3\n    __asm__(\"LDR R3, [R11, #val]\");\n\n    // Subtract R3 from R2 and store in R3\n    __asm__(\"SUB R3, R2, R3\");\n\n    // Load address of bb_common_bufsiz1 into R4\n    __asm__(\"LDR R4, =bb_common_bufsiz1\");\n\n    // Move R3 to R1\n    __asm__(\"MOV R1, R3\");\n\n    // Load s into R0\n    __asm__(\"LDR R0, [R11, #val]\");\n\n    // Call xstrndup function\n    __asm__(\"BL xstrndup\");\n\n    // Move R0 to R3\n    __asm__(\"MOV R3, R0\");\n\n    // Store R3 at address of byte_18FA0C+0xC\n    __asm__(\"STR R3, [R4, #(byte_18FA0C+0xC - 0x18F9D8)]\");\n\n    // Load eq into R3\n    __asm__(\"LDR R3, [R11, #eq]\");\n\n    // Add 1 to R3\n    __asm__(\"ADD R3, R3, #1\");\n\n    // Store R3 at address of val\n    __asm__(\"STR R3, [R11, #val]\");\n\nloc_CD350:\n    // Load address of byte_18FA20+4 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Move 1 to R2\n    __asm__(\"MOV R2, #1\");\n\n    // Load c into R1\n    __asm__(\"LDR R1, [R11, #val]\");\n\n    // Load preg into R0\n    __asm__(\"LDR R0, =aUnknownUserGro_1\");\n\n    // Call xregcomp function\n    __asm__(\"BL xregcomp\");\n\n    // Load address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Move 1 to R2\n    __asm__(\"MOV R2, #1\");\n\n    // Store 1 at address of qword_18F9F8+5\n    __asm__(\"STRB R2, [R3, #(qword_18F9F8+5 - 0x18F9D8)]\");\n\nloc_CD370:\n    // Load address of byte_18FA0C+4 into R0\n    __asm__(\"LDR R0, =byte_18FA0C+4\");\n\n    // Load tokens+4 into R3\n    __asm__(\"LDR R3, [R11, #tokens+4]\");\n\n    // Move 1 to R2\n    __asm__(\"MOV R2, #1\");\n\n    // Load ug into R1\n    __asm__(\"LDR R1, [R11, #val]\");\n\n    // Call get_uidgid function\n    __asm__(\"BL get_uidgid\");\n\n    // Move result to R3\n    __asm__(\"MOV R3, R0\");\n\n    // Compare R3 to 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch if not equal to loc_CD3B0\n    __asm__(\"BNE loc_CD3B0\");\n\n    // Load tokens+4 into R1\n    __asm__(\"LDR R1, [R11, #tokens+4]\");\n\n    // Load address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Load address of qword_18F9F0 into R3\n    __asm__(\"LDR R3, [R3, #(qword_18F9F0 - 0x18F9D8)]\");\n\n    // Load 0x18 from address in R3 into R3\n    __asm__(\"LDR R3, [R3, #0x18]\");\n\n    // Move R3 to R1\n    __asm__(\"MOV R1, R3\");\n\n    // Load address of aUnknownUserGro_1 into R0\n    __asm__(\"LDR R0, =aUnknownUserGro_1\");\n\n    // Call bb_error_msg function\n    __asm__(\"BL bb_error_msg\");\n\n    // Branch to next_rule\n    __asm__(\"B next_rule\");\n\nloc_CD3B0:\n    // Load tokens+8 into R3\n    __asm__(\"LDR R3, [R11, #tokens+8]\");\n\n    // Load address of unk_18FA00 into R2\n    __asm__(\"LDR R2, =unk_18FA00\");\n\n    // Move R2 to R1\n    __asm__(\"MOV R1, R2\");\n\n    // Load s into R0\n    __asm__(\"LDR R0, [R11, #tokens+8]\");\n\n    // Call bb_parse_mode function\n    __asm__(\"BL bb_parse_mode\");\n\n    // Load tokens+0xC into R3\n    __asm__(\"LDR R3, [R11, #tokens+0xC]\");\n\n    // Store R3 at address of val\n    __asm__(\"STR R3, [R11, #val]\");\n\n    // Load val into R3\n    __asm__(\"LDR R3, [R11, #val]\");\n\n    // Compare R3 to 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch if equal to loc_CD434\n    __asm__(\"BEQ loc_CD434\");\n\n    // Load val into R3\n    __asm__(\"LDR R3, [R11, #val]\");\n\n    // Load byte at address in R3 into R3\n    __asm__(\"LDRB R3, [R3]\");\n\n    // Move R3 to R1\n    __asm__(\"MOV R1, R3\");\n\n    // Load address of asc_1755C0 into R0\n    __asm__(\"LDR R0, =asc_1755C0\");\n\n    // Call strchr function\n    __asm__(\"BL strchr\");\n\n    // Store R0 at address of s\n    __asm__(\"STR R0, [R11, #s]\");\n\n    // Load s into R2\n    __asm__(\"LDR R2, [R11, #s]\");\n\n    // Load val into R3\n    __asm__(\"LDR R3, [R11, #val]\");\n\n    // Subtract R2 from R3 and store in R3\n    __asm__(\"SUB R3, R2, R3\");\n\n    // Load address of bb_common_bufsiz1 into R4\n    __asm__(\"LDR R4, =bb_common_bufsiz1\");\n\n    // Move R3 to R1\n    __asm__(\"MOV R1, R3\");\n\n    // Load s into R0\n    __asm__(\"LDR R0, [R11, #val]\");\n\n    // Call xstrndup function\n    __asm__(\"BL xstrndup\");\n\n    // Move R0 to R3\n    __asm__(\"MOV R3, R0\");\n\n    // Store R3 at address of byte_18FA0C+0x10\n    __asm__(\"STR R3, [R4, #(byte_18FA0C+0x10 - 0x18F9D8)]\");\n\n    // Load s into R0\n    __asm__(\"LDR R0, [R11, #s]\");\n\n    // Call skip_non_whitespace function\n    __asm__(\"BL skip_non_whitespace\");\n\n    // Store R0 at address of s\n    __asm__(\"STR R0, [R11, #s]\");\n\n    // Load s into R2\n    __asm__(\"LDR R2, [R11, #s]\");\n\n    // Load val into R3\n    __asm__(\"LDR R3, [R11, #val]\");\n\n    // Subtract R2 from R3 and store in R3\n    __asm__(\"SUB R3, R2, R3\");\n\n    // Load address of bb_common_bufsiz1 into R4\n    __asm__(\"LDR R4, =bb_common_bufsiz1\");\n\n    // Move R3 to R1\n    __asm__(\"MOV R1, R3\");\n\n    // Load s into R0\n    __asm__(\"LDR R0, [R11, #val]\");\n\n    // Call xstrndup function\n    __asm__(\"BL xstrndup\");\n\n    // Move R0 to R3\n    __asm__(\"MOV R3, R0\");\n\n    // Store R3 at address of byte_18FA20\n    __asm__(\"STR R3, [R4, #(byte_18FA20 - 0x18F9D8)]\");\n\n    // Branch to loc_CD4BC\n    __asm__(\"B loc_CD4BC\");\n\nloc_CD434:\n    // Load val into R3\n    __asm__(\"LDR R3, [R11, #val]\");\n\n    // Load byte at address in R3 into R3\n    __asm__(\"LDRB R3, [R3]\");\n\n    // Compare R3 to 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch if equal to loc_CD4B8\n    __asm__(\"BEQ loc_CD4B8\");\n\n    // Load val into R3\n    __asm__(\"LDR R3, [R11, #val]\");\n\n    // Load byte at address in R3 into R3\n    __asm__(\"LDRB R3, [R3]\");\n\n    // Compare R3 to 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch if equal to loc_CD4B8\n    __asm__(\"BEQ loc_CD4B8\");\n\n    // Load address of aBadLineU into R3\n    __asm__(\"LDR R3, =aBadLineU\");\n\n    // Move R3 to R0\n    __asm__(\"MOV R0, R3\");\n\n    // Call bb_error_msg function\n    __asm__(\"BL bb_error_msg\");\n\n    // Branch to next_rule\n    __asm__(\"B next_rule\");\n\nloc_CD4B8:\n    // No operation\n    __asm__(\"NOP\");\n\nloc_CD4BC:\n    // Clean up current rule\n    __asm__(\"BL clean_up_cur_rule\");\n\n    // Branch to loc_CD1B0\n    __asm__(\"B loc_CD1B0\");\n\n    // Restore registers\n    __asm__(\"POP {R4,R11,PC}\");\n}\n```"
    },
    {
        "func_name": "select_lease_time",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0007511C | 00 48 2D E9 | PUSH    {R11,LR}\n0x00075120 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00075124 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x00075128 | 10 00 0B E5 | STR     R0, [R11,#packet]\n0x0007512C | 98 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00075130 | 20 30 93 E5 | LDR     R3, [R3,#(unk_18F9F8 - 0x18F9D8)]\n0x00075134 | 0C 30 0B E5 | STR     R3, [R11,#lease_time_sec]\n0x00075138 | 33 10 A0 E3 | MOV     R1, #0x33 ; '3'; code\n0x0007513C | 10 00 1B E5 | LDR     R0, [R11,#packet]; packet\n0x00075140 | 7D 13 00 EB | BL      udhcp_get_option\n0x00075144 | 08 00 0B E5 | STR     R0, [R11,#lease_time_opt]\n0x00075148 | 08 30 1B E5 | LDR     R3, [R11,#lease_time_opt]\n0x0007514C | 00 00 53 E3 | CMP     R3, #0\n0x00075150 | 19 00 00 0A | BEQ     loc_751BC\n0x00075154 | 0C 30 4B E2 | SUB     R3, R11, #-lease_time_sec\n0x00075158 | 04 20 A0 E3 | MOV     R2, #4; n\n0x0007515C | 08 10 1B E5 | LDR     R1, [R11,#lease_time_opt]; src\n0x00075160 | 03 00 A0 E1 | MOV     R0, R3; dest\n0x00075164 | 6C 7F FE EB | BL      memcpy\n0x00075168 | 0C 30 1B E5 | LDR     R3, [R11,#lease_time_sec]\n0x0007516C | 03 00 A0 E1 | MOV     R0, R3; netlong\n0x00075170 | E6 80 FE EB | BL      ntohl\n0x00075174 | 00 30 A0 E1 | MOV     R3, R0\n0x00075178 | 0C 30 0B E5 | STR     R3, [R11,#lease_time_sec]\n0x0007517C | 48 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00075180 | 20 20 93 E5 | LDR     R2, [R3,#(unk_18F9F8 - 0x18F9D8)]\n0x00075184 | 0C 30 1B E5 | LDR     R3, [R11,#lease_time_sec]\n0x00075188 | 03 00 52 E1 | CMP     R2, R3\n0x0007518C | 02 00 00 2A | BCS     loc_7519C\n0x00075190 | 34 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00075194 | 20 30 93 E5 | LDR     R3, [R3,#(unk_18F9F8 - 0x18F9D8)]\n0x00075198 | 0C 30 0B E5 | STR     R3, [R11,#lease_time_sec]\n0x0007519C | 28 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000751A0 | 24 20 93 E5 | LDR     R2, [R3,#(unk_18F9FC - 0x18F9D8)]\n0x000751A4 | 0C 30 1B E5 | LDR     R3, [R11,#lease_time_sec]\n0x000751A8 | 03 00 52 E1 | CMP     R2, R3\n0x000751AC | 02 00 00 9A | BLS     loc_751BC\n0x000751B0 | 14 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000751B4 | 24 30 93 E5 | LDR     R3, [R3,#(unk_18F9FC - 0x18F9D8)]\n0x000751B8 | 0C 30 0B E5 | STR     R3, [R11,#lease_time_sec]\n0x000751BC | 0C 30 1B E5 | LDR     R3, [R11,#lease_time_sec]\n0x000751C0 | 03 00 A0 E1 | MOV     R0, R3\n0x000751C4 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000751C8 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function() {\n    int packet;\n    int lease_time_sec;\n    int lease_time_opt;\n    \n    // Save R11 and LR onto the stack\n    __asm__(\"PUSH {R11, LR}\");\n    \n    // Set R11 to point to the current stack frame\n    __asm__(\"ADD R11, SP, #4\");\n    \n    // Allocate space on the stack for local variables\n    __asm__(\"SUB SP, SP, #0x10\");\n    \n    // Store the value of R0 into the variable packet\n    packet = R0;\n    \n    // Load the address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n    \n    // Load the value at the address (bb_common_bufsiz1 + (unk_18F9F8 - 0x18F9D8)) into R3\n    __asm__(\"LDR R3, [R3, #(unk_18F9F8 - 0x18F9D8)]\");\n    \n    // Store the value of R3 into the variable lease_time_sec\n    lease_time_sec = R3;\n    \n    // Set R1 to 0x33\n    __asm__(\"MOV R1, #0x33\");\n    \n    // Load the value at the address (R11 + packet) into R0\n    __asm__(\"LDR R0, [R11, #packet]\");\n    \n    // Call the function udhcp_get_option\n    __asm__(\"BL udhcp_get_option\");\n    \n    // Store the return value of udhcp_get_option into the variable lease_time_opt\n    lease_time_opt = R0;\n    \n    // Compare the value of lease_time_opt with 0\n    __asm__(\"CMP R3, #0\");\n    \n    // If lease_time_opt is equal to 0, jump to loc_751BC\n    __asm__(\"BEQ loc_751BC\");\n    \n    // Calculate the address of lease_time_sec\n    R3 = R11 - lease_time_sec;\n    \n    // Set R2 to 4\n    __asm__(\"MOV R2, #4\");\n    \n    // Load the value at the address (R11 + lease_time_opt) into R1\n    __asm__(\"LDR R1, [R11, #lease_time_opt]\");\n    \n    // Copy the value from R1 to the address R3\n    __asm__(\"MOV R0, R3\");\n    \n    // Call the function memcpy\n    __asm__(\"BL memcpy\");\n    \n    // Load the value at the address (R11 + lease_time_sec) into R3\n    __asm__(\"LDR R3, [R11, #lease_time_sec]\");\n    \n    // Call the function ntohl with the value in R3 as the argument\n    __asm__(\"BL ntohl\");\n    \n    // Store the return value of ntohl into the variable lease_time_sec\n    lease_time_sec = R0;\n    \n    // Move the value in R0 to R3\n    __asm__(\"MOV R3, R0\");\n    \n    // Store the value of R3 into the variable lease_time_sec\n    __asm__(\"STR R3, [R11, #lease_time_sec]\");\n    \n    // Load the address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n    \n    // Load the value at the address (bb_common_bufsiz1 + (unk_18F9F8 - 0x18F9D8)) into R2\n    __asm__(\"LDR R2, [R3, #(unk_18F9F8 - 0x18F9D8)]\");\n    \n    // Load the value at the address (R11 + lease_time_sec) into R3\n    __asm__(\"LDR R3, [R11, #lease_time_sec]\");\n    \n    // Compare the value of R2 with R3\n    __asm__(\"CMP R2, R3\");\n    \n    // If R2 is greater than or equal to R3, jump to loc_7519C\n    __asm__(\"BCS loc_7519C\");\n    \n    // Load the address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n    \n    // Load the value at the address (bb_common_bufsiz1 + (unk_18F9F8 - 0x18F9D8)) into R3\n    __asm__(\"LDR R3, [R3, #(unk_18F9F8 - 0x18F9D8)]\");\n    \n    // Store the value of R3 into the variable lease_time_sec\n    lease_time_sec = R3;\n    \n    // Load the address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n    \n    // Load the value at the address (bb_common_bufsiz1 + (unk_18F9FC - 0x18F9D8)) into R2\n    __asm__(\"LDR R2, [R3, #(unk_18F9FC - 0x18F9D8)]\");\n    \n    // Load the value at the address (R11 + lease_time_sec) into R3\n    __asm__(\"LDR R3, [R11, #lease_time_sec]\");\n    \n    // Compare the value of R2 with R3\n    __asm__(\"CMP R2, R3\");\n    \n    // If R2 is less than or equal to R3, jump to loc_751BC\n    __asm__(\"BLS loc_751BC\");\n    \n    // Load the address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n    \n    // Load the value at the address (bb_common_bufsiz1 + (unk_18F9FC - 0x18F9D8)) into R3\n    __asm__(\"LDR R3, [R3, #(unk_18F9FC - 0x18F9D8)]\");\n    \n    // Store the value of R3 into the variable lease_time_sec\n    lease_time_sec = R3;\n    \n    // Load the value at the address (R11 + lease_time_sec) into R3\n    __asm__(\"LDR R3, [R11, #lease_time_sec]\");\n    \n    // Move the value in R3 to R0\n    __asm__(\"MOV R0, R3\");\n    \n    // Restore the stack pointer\n    __asm__(\"SUB SP, R11, #4\");\n    \n    // Restore R11 and PC from the stack\n    __asm__(\"POP {R11, PC}\");\n}\n```"
    },
    {
        "func_name": "reopen_config_file",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0004CD24 | 30 48 2D E9 | PUSH    {R4,R5,R11,LR}\n0x0004CD28 | 0C B0 8D E2 | ADD     R11, SP, #0xC\n0x0004CD2C | 78 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CD30 | 3C 30 93 E5 | LDR     R3, [R3,#(dst - 0x18F9D8)]\n0x0004CD34 | 03 00 A0 E1 | MOV     R0, R3; ptr\n0x0004CD38 | 5C 20 FF EB | BL      free\n0x0004CD3C | 68 40 9F E5 | LDR     R4, =bb_common_bufsiz1\n0x0004CD40 | 68 00 9F E5 | LDR     R0, =asc_1689E8; \"*\"\n0x0004CD44 | 88 33 FF EB | BL      xstrdup\n0x0004CD48 | 00 30 A0 E1 | MOV     R3, R0\n0x0004CD4C | 3C 30 84 E5 | STR     R3, [R4,#(dst - 0x18F9D8)]\n0x0004CD50 | 54 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CD54 | 38 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_ospeed - 0x18F9D8)]\n0x0004CD58 | 00 00 53 E3 | CMP     R3, #0\n0x0004CD5C | 03 00 00 0A | BEQ     loc_4CD70\n0x0004CD60 | 44 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CD64 | 38 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_ospeed - 0x18F9D8)]\n0x0004CD68 | 03 00 A0 E1 | MOV     R0, R3; parser\n0x0004CD6C | 85 F9 03 EB | BL      config_close\n0x0004CD70 | 34 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CD74 | 34 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_ispeed - 0x18F9D8)]\n0x0004CD78 | 2C 40 9F E5 | LDR     R4, =bb_common_bufsiz1\n0x0004CD7C | 03 00 A0 E1 | MOV     R0, R3; filename\n0x0004CD80 | 74 F9 03 EB | BL      config_open\n0x0004CD84 | 00 30 A0 E1 | MOV     R3, R0\n0x0004CD88 | 38 30 84 E5 | STR     R3, [R4,#(bb_common_bufsiz1.c_ospeed - 0x18F9D8)]\n0x0004CD8C | 18 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CD90 | 38 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_ospeed - 0x18F9D8)]\n0x0004CD94 | 00 00 53 E3 | CMP     R3, #0\n0x0004CD98 | 01 30 A0 13 | MOVNE   R3, #1\n0x0004CD9C | 00 30 A0 03 | MOVEQ   R3, #0\n0x0004CDA0 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x0004CDA4 | 03 00 A0 E1 | MOV     R0, R3\n0x0004CDA8 | 30 88 BD E8 | POP     {R4,R5,R11,PC}",
        "output": "```c\nvoid function() {\n    int bb_common_bufsiz1 = 0;\n    int dst = 0;\n    int c_ospeed = 0;\n    int c_ispeed = 0;\n    int filename = 0;\n    \n    bb_common_bufsiz1 = malloc(sizeof(int));\n    free(bb_common_bufsiz1);\n    \n    char* asc_1689E8 = \"*\";\n    char* ptr = xstrdup(asc_1689E8);\n    bb_common_bufsiz1[dst - 0x18F9D8] = ptr;\n    \n    if (bb_common_bufsiz1[c_ospeed - 0x18F9D8] != 0) {\n        config_close(bb_common_bufsiz1[c_ospeed - 0x18F9D8]);\n    }\n    \n    bb_common_bufsiz1[c_ispeed - 0x18F9D8] = config_open(filename);\n    \n    if (bb_common_bufsiz1[c_ospeed - 0x18F9D8] != 0) {\n        bb_common_bufsiz1[c_ospeed - 0x18F9D8] = 1;\n    } else {\n        bb_common_bufsiz1[c_ospeed - 0x18F9D8] = 0;\n    }\n}\n```"
    },
    {
        "func_name": "add",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000281B0 | 30 48 2D E9 | PUSH    {R4,R5,R11,LR}\n0x000281B4 | 0C B0 8D E2 | ADD     R11, SP, #0xC\n0x000281B8 | E5 FF FF EB | BL      pop\n0x000281BC | 00 40 A0 E1 | MOV     R4, R0\n0x000281C0 | 01 50 A0 E1 | MOV     R5, R1\n0x000281C4 | E2 FF FF EB | BL      pop\n0x000281C8 | 00 20 A0 E1 | MOV     R2, R0\n0x000281CC | 01 30 A0 E1 | MOV     R3, R1\n0x000281D0 | 04 00 A0 E1 | MOV     R0, R4\n0x000281D4 | 05 10 A0 E1 | MOV     R1, R5\n0x000281D8 | 1E BC 04 EB | BL      __aeabi_dadd\n0x000281DC | 00 30 A0 E1 | MOV     R3, R0\n0x000281E0 | 01 40 A0 E1 | MOV     R4, R1\n0x000281E4 | 03 00 A0 E1 | MOV     R0, R3; a\n0x000281E8 | 04 10 A0 E1 | MOV     R1, R4; a\n0x000281EC | BB FF FF EB | BL      push\n0x000281F0 | 00 00 A0 E1 | NOP\n0x000281F4 | 30 88 BD E8 | POP     {R4,R5,R11,PC}",
        "output": "```c\nvoid function() {\n    int R4, R5;\n    \n    // Save registers R4, R5, R11, and LR onto the stack\n    __asm__(\"PUSH {R4,R5,R11,LR}\");\n    \n    // Set R11 to the current stack pointer plus 0xC\n    __asm__(\"ADD R11, SP, #0xC\");\n    \n    // Call the function \"pop\" and store the return value in R4\n    __asm__(\"BL pop\");\n    __asm__(\"MOV R4, R0\");\n    \n    // Call the function \"pop\" and store the return value in R5\n    __asm__(\"BL pop\");\n    __asm__(\"MOV R5, R0\");\n    \n    // Call the function \"__aeabi_dadd\" with arguments R4 and R5\n    __aeabi_dadd(R4, R5);\n    \n    // Call the function \"push\" with arguments R4 and R5\n    __asm__(\"BL push\");\n    \n    // Restore registers R4, R5, R11, and PC from the stack\n    __asm__(\"POP {R4,R5,R11,PC}\");\n}\n```"
    },
    {
        "func_name": "fopen_or_warn_stdin",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00154CC0 | 00 48 2D E9 | PUSH    {R11,LR}\n0x00154CC4 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00154CC8 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x00154CCC | 10 00 0B E5 | STR     R0, [R11,#filename]\n0x00154CD0 | 58 30 9F E5 | LDR     R3, =stdin__GLIBC_2.4\n0x00154CD4 | 00 30 93 E5 | LDR     R3, [R3]\n0x00154CD8 | 08 30 0B E5 | STR     R3, [R11,#fp]\n0x00154CDC | 10 30 1B E5 | LDR     R3, [R11,#filename]\n0x00154CE0 | 4C 20 9F E5 | LDR     R2, =bb_msg_standard_input; \"standard input\"\n0x00154CE4 | 02 00 53 E1 | CMP     R3, R2\n0x00154CE8 | 0C 00 00 0A | BEQ     loc_154D20\n0x00154CEC | 10 30 1B E5 | LDR     R3, [R11,#filename]\n0x00154CF0 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x00154CF4 | 2D 00 53 E3 | CMP     R3, #0x2D ; '-'\n0x00154CF8 | 04 00 00 1A | BNE     loc_154D10\n0x00154CFC | 10 30 1B E5 | LDR     R3, [R11,#filename]\n0x00154D00 | 01 30 83 E2 | ADD     R3, R3, #1\n0x00154D04 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x00154D08 | 00 00 53 E3 | CMP     R3, #0\n0x00154D0C | 03 00 00 0A | BEQ     loc_154D20\n0x00154D10 | 20 10 9F E5 | LDR     R1, =aR_24; \"r\"\n0x00154D14 | 10 00 1B E5 | LDR     R0, [R11,#filename]; path\n0x00154D18 | 38 10 FB EB | BL      fopen_or_warn\n0x00154D1C | 08 00 0B E5 | STR     R0, [R11,#fp]\n0x00154D20 | 08 30 1B E5 | LDR     R3, [R11,#fp]\n0x00154D24 | 03 00 A0 E1 | MOV     R0, R3\n0x00154D28 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00154D2C | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(char* filename) {\n    int fp;\n    fp = fopen_or_warn(filename, \"r\");\n    if (fp == 0) {\n        fp = stdin;\n    }\n    // rest of the code\n}\n```"
    },
    {
        "func_name": "send_ACK",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0007546C | 00 48 2D E9 | PUSH    {R11,LR}\n0x00075470 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00075474 | 29 DE 4D E2 | SUB     SP, SP, #0x290\n0x00075478 | 88 02 0B E5 | STR     R0, [R11,#oldpacket]\n0x0007547C | 8C 12 0B E5 | STR     R1, [R11,#yiaddr]\n0x00075480 | 0A 3D 4B E2 | SUB     R3, R11, #-packet\n0x00075484 | 05 20 A0 E3 | MOV     R2, #5; type\n0x00075488 | 88 12 1B E5 | LDR     R1, [R11,#oldpacket]; oldpacket\n0x0007548C | 03 00 A0 E1 | MOV     R0, R3; packet\n0x00075490 | 4F FE FF EB | BL      init_packet_0\n0x00075494 | 8C 32 1B E5 | LDR     R3, [R11,#yiaddr]\n0x00075498 | 70 32 0B E5 | STR     R3, [R11,#packet.yiaddr]\n0x0007549C | 88 02 1B E5 | LDR     R0, [R11,#oldpacket]; packet\n0x000754A0 | 1D FF FF EB | BL      select_lease_time\n0x000754A4 | 08 00 0B E5 | STR     R0, [R11,#lease_time_sec]\n0x000754A8 | 08 00 1B E5 | LDR     R0, [R11,#lease_time_sec]; hostlong\n0x000754AC | 43 81 FE EB | BL      htonl\n0x000754B0 | 00 20 A0 E1 | MOV     R2, R0; data\n0x000754B4 | 0A 3D 4B E2 | SUB     R3, R11, #-packet\n0x000754B8 | 33 10 A0 E3 | MOV     R1, #0x33 ; '3'; code\n0x000754BC | 03 00 A0 E1 | MOV     R0, R3; packet\n0x000754C0 | 6F 13 00 EB | BL      udhcp_add_simple_option\n0x000754C4 | 0A 3D 4B E2 | SUB     R3, R11, #-packet\n0x000754C8 | 03 00 A0 E1 | MOV     R0, R3; packet\n0x000754CC | CB FE FF EB | BL      add_server_options\n0x000754D0 | 8C 32 1B E5 | LDR     R3, [R11,#yiaddr]\n0x000754D4 | 84 32 0B E5 | STR     R3, [R11,#addr]\n0x000754D8 | 84 02 1B E5 | LDR     R0, [R11,#addr]; in\n0x000754DC | C1 7E FE EB | BL      inet_ntoa\n0x000754E0 | 00 30 A0 E1 | MOV     R3, R0\n0x000754E4 | 03 10 A0 E1 | MOV     R1, R3\n0x000754E8 | 70 00 9F E5 | LDR     R0, =aSendingAckToS; \"Sending ACK to %s\"\n0x000754EC | B2 3F 03 EB | BL      bb_info_msg\n0x000754F0 | 0A 3D 4B E2 | SUB     R3, R11, #-packet\n0x000754F4 | 00 10 A0 E3 | MOV     R1, #0; force_broadcast\n0x000754F8 | 03 00 A0 E1 | MOV     R0, R3; dhcp_pkt\n0x000754FC | 19 FE FF EB | BL      send_packet\n0x00075500 | 0C 10 A0 E3 | MOV     R1, #0xC; code\n0x00075504 | 88 02 1B E5 | LDR     R0, [R11,#oldpacket]; packet\n0x00075508 | 8B 12 00 EB | BL      udhcp_get_option\n0x0007550C | 0C 00 0B E5 | STR     R0, [R11,#p_host_name]\n0x00075510 | 70 12 1B E5 | LDR     R1, [R11,#packet.yiaddr]; yiaddr\n0x00075514 | 0C 30 1B E5 | LDR     R3, [R11,#p_host_name]\n0x00075518 | 00 00 53 E3 | CMP     R3, #0\n0x0007551C | 04 00 00 0A | BEQ     loc_75534\n0x00075520 | 0C 30 1B E5 | LDR     R3, [R11,#p_host_name]\n0x00075524 | 01 30 43 E2 | SUB     R3, R3, #1\n0x00075528 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0007552C | 03 20 A0 E1 | MOV     R2, R3\n0x00075530 | 00 00 00 EA | B       loc_75538\n0x00075534 | 00 20 A0 E3 | MOV     R2, #0\n0x00075538 | 0A 3D 4B E2 | SUB     R3, R11, #-packet\n0x0007553C | 1C 00 83 E2 | ADD     R0, R3, #0x1C; chaddr\n0x00075540 | 00 20 8D E5 | STR     R2, [SP,#0x294+hostname_len]; hostname_len\n0x00075544 | 0C 30 1B E5 | LDR     R3, [R11,#p_host_name]; hostname\n0x00075548 | 08 20 1B E5 | LDR     R2, [R11,#lease_time_sec]; leasetime\n0x0007554C | 40 0B 00 EB | BL      add_lease\n0x00075550 | 13 09 00 EB | BL      write_leases\n0x00075554 | 00 00 A0 E1 | NOP\n0x00075558 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0007555C | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function() {\n    // Save R11 and LR onto the stack\n    __asm__(\"PUSH {R11, LR}\");\n\n    // Set up the stack frame\n    __asm__(\"ADD R11, SP, #4\");\n\n    // Allocate space on the stack for local variables\n    __asm__(\"SUB SP, SP, #0x290\");\n\n    // Store the value of R0 into the memory location pointed to by R11 + offset of oldpacket\n    __asm__(\"STR R0, [R11, #oldpacket]\");\n\n    // Store the value of R1 into the memory location pointed to by R11 + offset of yiaddr\n    __asm__(\"STR R1, [R11, #yiaddr]\");\n\n    // Calculate the address of the packet structure by subtracting the offset of packet from R11\n    __asm__(\"SUB R3, R11, #-packet\");\n\n    // Move the value 5 into R2\n    __asm__(\"MOV R2, #5\");\n\n    // Load the value from the memory location pointed to by R11 + offset of oldpacket into R1\n    __asm__(\"LDR R1, [R11, #oldpacket]\");\n\n    // Move the value of R3 into R0\n    __asm__(\"MOV R0, R3\");\n\n    // Call the function init_packet_0\n    __asm__(\"BL init_packet_0\");\n\n    // Load the value from the memory location pointed to by R11 + offset of yiaddr into R3\n    __asm__(\"LDR R3, [R11, #yiaddr]\");\n\n    // Store the value of R3 into the memory location pointed to by R11 + offset of packet.yiaddr\n    __asm__(\"STR R3, [R11, #packet.yiaddr]\");\n\n    // Load the value from the memory location pointed to by R11 + offset of oldpacket into R0\n    __asm__(\"LDR R0, [R11, #oldpacket]\");\n\n    // Call the function select_lease_time\n    __asm__(\"BL select_lease_time\");\n\n    // Store the value of R0 into the memory location pointed to by R11 + offset of lease_time_sec\n    __asm__(\"STR R0, [R11, #lease_time_sec]\");\n\n    // Load the value from the memory location pointed to by R11 + offset of lease_time_sec into R0\n    __asm__(\"LDR R0, [R11, #lease_time_sec]\");\n\n    // Call the function htonl\n    __asm__(\"BL htonl\");\n\n    // Move the value of R0 into R2\n    __asm__(\"MOV R2, R0\");\n\n    // Calculate the address of the packet structure by subtracting the offset of packet from R11\n    __asm__(\"SUB R3, R11, #-packet\");\n\n    // Move the value 0x33 into R1\n    __asm__(\"MOV R1, #0x33\");\n\n    // Move the value of R3 into R0\n    __asm__(\"MOV R0, R3\");\n\n    // Call the function udhcp_add_simple_option\n    __asm__(\"BL udhcp_add_simple_option\");\n\n    // Calculate the address of the packet structure by subtracting the offset of packet from R11\n    __asm__(\"SUB R3, R11, #-packet\");\n\n    // Move the value of R3 into R0\n    __asm__(\"MOV R0, R3\");\n\n    // Call the function add_server_options\n    __asm__(\"BL add_server_options\");\n\n    // Load the value from the memory location pointed to by R11 + offset of yiaddr into R3\n    __asm__(\"LDR R3, [R11, #yiaddr]\");\n\n    // Store the value of R3 into the memory location pointed to by R11 + offset of addr\n    __asm__(\"STR R3, [R11, #addr]\");\n\n    // Load the value from the memory location pointed to by R11 + offset of addr into R0\n    __asm__(\"LDR R0, [R11, #addr]\");\n\n    // Call the function inet_ntoa\n    __asm__(\"BL inet_ntoa\");\n\n    // Move the value of R0 into R3\n    __asm__(\"MOV R3, R0\");\n\n    // Move the value of R3 into R1\n    __asm__(\"MOV R1, R3\");\n\n    // Load the address of the string \"Sending ACK to %s\" into R0\n    __asm__(\"LDR R0, =aSendingAckToS\");\n\n    // Call the function bb_info_msg\n    __asm__(\"BL bb_info_msg\");\n\n    // Calculate the address of the packet structure by subtracting the offset of packet from R11\n    __asm__(\"SUB R3, R11, #-packet\");\n\n    // Move the value 0 into R1\n    __asm__(\"MOV R1, #0\");\n\n    // Move the value of R3 into R0\n    __asm__(\"MOV R0, R3\");\n\n    // Call the function send_packet\n    __asm__(\"BL send_packet\");\n\n    // Move the value 0xC into R1\n    __asm__(\"MOV R1, #0xC\");\n\n    // Load the value from the memory location pointed to by R11 + offset of oldpacket into R0\n    __asm__(\"LDR R0, [R11, #oldpacket]\");\n\n    // Call the function udhcp_get_option\n    __asm__(\"BL udhcp_get_option\");\n\n    // Store the value of R0 into the memory location pointed to by R11 + offset of p_host_name\n    __asm__(\"STR R0, [R11, #p_host_name]\");\n\n    // Load the value from the memory location pointed to by R11 + offset of packet.yiaddr into R1\n    __asm__(\"LDR R1, [R11, #packet.yiaddr]\");\n\n    // Load the value from the memory location pointed to by R11 + offset of p_host_name into R3\n    __asm__(\"LDR R3, [R11, #p_host_name]\");\n\n    // Compare the value of R3 with 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch to loc_75534 if the previous comparison was equal\n    __asm__(\"BEQ loc_75534\");\n\n    // Load the value from the memory location pointed to by R11 + offset of p_host_name into R3\n    __asm__(\"LDR R3, [R11, #p_host_name]\");\n\n    // Subtract 1 from the value of R3\n    __asm__(\"SUB R3, R3, #1\");\n\n    // Load the byte from the memory location pointed to by R3 into R3\n    __asm__(\"LDRB R3, [R3]\");\n\n    // Move the value of R3 into R2\n    __asm__(\"MOV R2, R3\");\n\n    // Branch to loc_75538\n    __asm__(\"B loc_75538\");\n\n    // Move the value 0 into R2\n    __asm__(\"MOV R2, #0\");\n\n    // Calculate the address of the packet structure by subtracting the offset of packet from R11\n    __asm__(\"SUB R3, R11, #-packet\");\n\n    // Calculate the address of the chaddr field by adding 0x1C to R3\n    __asm__(\"ADD R0, R3, #0x1C\");\n\n    // Store the value of R2 into the memory location pointed to by SP + offset of hostname_len\n    __asm__(\"STR R2, [SP, #0x294+hostname_len]\");\n\n    // Load the value from the memory location pointed to by R11 + offset of p_host_name into R3\n    __asm__(\"LDR R3, [R11, #p_host_name]\");\n\n    // Load the value from the memory location pointed to by R11 + offset of lease_time_sec into R2\n    __asm__(\"LDR R2, [R11, #lease_time_sec]\");\n\n    // Call the function add_lease\n    __asm__(\"BL add_lease\");\n\n    // Call the function write_leases\n    __asm__(\"BL write_leases\");\n\n    // No operation\n    __asm__(\"NOP\");\n\n    // Restore R11 and PC from the stack\n    __asm__(\"POP {R11, PC}\");\n}\n```"
    },
    {
        "func_name": "mkswap_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000D32C4 | 70 48 2D E9 | PUSH    {R4-R6,R11,LR}\n0x000D32C8 | 10 B0 8D E2 | ADD     R11, SP, #0x10\n0x000D32CC | 4C D0 4D E2 | SUB     SP, SP, #0x4C\n0x000D32D0 | 50 00 0B E5 | STR     R0, [R11,#argc]\n0x000D32D4 | 54 10 0B E5 | STR     R1, [R11,#argv]\n0x000D32D8 | DC 31 9F E5 | LDR     R3, =unk_175F64\n0x000D32DC | 2C 30 0B E5 | STR     R3, [R11,#label]\n0x000D32E0 | D8 31 9F E5 | LDR     R3, =opt_complementary\n0x000D32E4 | D8 21 9F E5 | LDR     R2, =unk_175F68\n0x000D32E8 | 00 20 83 E5 | STR     R2, [R3]\n0x000D32EC | 2C 30 4B E2 | SUB     R3, R11, #-label\n0x000D32F0 | 03 20 A0 E1 | MOV     R2, R3\n0x000D32F4 | CC 11 9F E5 | LDR     R1, =byte_175F6C; applet_opts\n0x000D32F8 | 54 00 1B E5 | LDR     R0, [R11,#argv]; argv\n0x000D32FC | 69 B7 01 EB | BL      getopt32\n0x000D3300 | C4 31 9F E5 | LDR     R3, =optind__GLIBC_2.4\n0x000D3304 | 00 30 93 E5 | LDR     R3, [R3]\n0x000D3308 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000D330C | 54 20 1B E5 | LDR     R2, [R11,#argv]\n0x000D3310 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000D3314 | 54 30 0B E5 | STR     R3, [R11,#argv]\n0x000D3318 | 54 30 1B E5 | LDR     R3, [R11,#argv]\n0x000D331C | 00 30 93 E5 | LDR     R3, [R3]\n0x000D3320 | 01 10 A0 E3 | MOV     R1, #1; flags\n0x000D3324 | 03 00 A0 E1 | MOV     R0, R3; pathname\n0x000D3328 | 87 1A FD EB | BL      xopen\n0x000D332C | 18 00 0B E5 | STR     R0, [R11,#fd]\n0x000D3330 | 54 30 1B E5 | LDR     R3, [R11,#argv]\n0x000D3334 | 04 30 83 E2 | ADD     R3, R3, #4\n0x000D3338 | 00 10 93 E5 | LDR     R1, [R3]; override\n0x000D333C | 01 30 A0 E3 | MOV     R3, #1; extend\n0x000D3340 | 01 2B A0 E3 | MOV     R2, #0x400; override_units\n0x000D3344 | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000D3348 | E3 B6 01 EB | BL      get_volume_size_in_bytes\n0x000D334C | 00 30 A0 E1 | MOV     R3, R0\n0x000D3350 | 01 40 A0 E1 | MOV     R4, R1\n0x000D3354 | 24 30 0B E5 | STR     R3, [R11,#len]\n0x000D3358 | 20 40 0B E5 | STR     R4, [R11,#len+4]\n0x000D335C | BC 08 FD EB | BL      getpagesize\n0x000D3360 | 00 30 A0 E1 | MOV     R3, R0\n0x000D3364 | 28 30 0B E5 | STR     R3, [R11,#pagesize]\n0x000D3368 | 28 30 1B E5 | LDR     R3, [R11,#pagesize]\n0x000D336C | 00 40 A0 E3 | MOV     R4, #0\n0x000D3370 | 24 20 4B E2 | SUB     R2, R11, #-len\n0x000D3374 | 06 00 92 E8 | LDM     R2, {R1,R2}\n0x000D3378 | 03 50 51 E0 | SUBS    R5, R1, R3\n0x000D337C | 04 60 C2 E0 | SBC     R6, R2, R4\n0x000D3380 | 24 50 0B E5 | STR     R5, [R11,#len]\n0x000D3384 | 20 60 0B E5 | STR     R6, [R11,#len+4]\n0x000D3388 | 24 30 4B E2 | SUB     R3, R11, #-len\n0x000D338C | 0C 00 93 E8 | LDM     R3, {R2,R3}\n0x000D3390 | 38 01 9F E5 | LDR     R0, =aSettingUpSwaps; \"Setting up swapspace version 1, size = \"...\n0x000D3394 | 8F 06 FD EB | BL      printf\n0x000D3398 | 01 2B A0 E3 | MOV     R2, #0x400; count\n0x000D339C | 30 11 9F E5 | LDR     R1, =bb_common_bufsiz1; buf\n0x000D33A0 | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000D33A4 | 10 1B FD EB | BL      xwrite\n0x000D33A8 | 24 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000D33AC | 01 20 A0 E3 | MOV     R2, #1\n0x000D33B0 | 00 20 83 E5 | STR     R2, [R3]\n0x000D33B4 | 24 10 4B E2 | SUB     R1, R11, #-len\n0x000D33B8 | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x000D33BC | 28 30 1B E5 | LDR     R3, [R11,#pagesize]\n0x000D33C0 | 00 40 A0 E3 | MOV     R4, #0\n0x000D33C4 | 03 20 A0 E1 | MOV     R2, R3\n0x000D33C8 | 04 30 A0 E1 | MOV     R3, R4\n0x000D33CC | D0 13 02 EB | BL      __aeabi_uldivmod\n0x000D33D0 | 00 30 A0 E1 | MOV     R3, R0\n0x000D33D4 | 01 40 A0 E1 | MOV     R4, R1\n0x000D33D8 | 03 10 A0 E1 | MOV     R1, R3\n0x000D33DC | 04 20 A0 E1 | MOV     R2, R4\n0x000D33E0 | EC 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000D33E4 | 01 20 A0 E1 | MOV     R2, R1\n0x000D33E8 | 04 20 83 E5 | STR     R2, [R3,#(unk_18F9DC - 0x18F9D8)]\n0x000D33EC | E4 30 9F E5 | LDR     R3, =byte_18F9E4\n0x000D33F0 | 03 00 A0 E1 | MOV     R0, R3; buf\n0x000D33F4 | 69 1D FD EB | BL      generate_uuid\n0x000D33F8 | D8 10 9F E5 | LDR     R1, =byte_18F9E4; cp\n0x000D33FC | 4C 30 4B E2 | SUB     R3, R11, #-uuid_string\n0x000D3400 | 10 20 A0 E3 | MOV     R2, #0x10; count\n0x000D3404 | 03 00 A0 E1 | MOV     R0, R3; p\n0x000D3408 | DF 17 FD EB | BL      bin2hex\n0x000D340C | 4C 10 4B E2 | SUB     R1, R11, #-uuid_string\n0x000D3410 | 08 10 81 E2 | ADD     R1, R1, #8\n0x000D3414 | 4C 00 4B E2 | SUB     R0, R11, #-uuid_string\n0x000D3418 | 0C 00 80 E2 | ADD     R0, R0, #0xC\n0x000D341C | 4C 30 4B E2 | SUB     R3, R11, #-uuid_string\n0x000D3420 | 10 30 83 E2 | ADD     R3, R3, #0x10\n0x000D3424 | 4C 20 4B E2 | SUB     R2, R11, #-uuid_string\n0x000D3428 | 14 20 82 E2 | ADD     R2, R2, #0x14\n0x000D342C | 4C C0 4B E2 | SUB     R12, R11, #-uuid_string\n0x000D3430 | 04 20 8D E5 | STR     R2, [SP,#0x5C+var_58]\n0x000D3434 | 00 30 8D E5 | STR     R3, [SP,#0x5C+whence]\n0x000D3438 | 00 30 A0 E1 | MOV     R3, R0\n0x000D343C | 01 20 A0 E1 | MOV     R2, R1\n0x000D3440 | 0C 10 A0 E1 | MOV     R1, R12\n0x000D3444 | 90 00 9F E5 | LDR     R0, =aUuid8s4s4s4s12; \"UUID=%.8s-%.4s-%.4s-%.4s-%.12s\\n\"\n0x000D3448 | 62 06 FD EB | BL      printf\n0x000D344C | 8C 00 9F E5 | LDR     R0, =(qword_18F9F0+4); dst\n0x000D3450 | 2C 30 1B E5 | LDR     R3, [R11,#label]\n0x000D3454 | 10 20 A0 E3 | MOV     R2, #0x10; size\n0x000D3458 | 03 10 A0 E1 | MOV     R1, R3; src\n0x000D345C | C0 F9 01 EB | BL      safe_strncpy\n0x000D3460 | 81 2F A0 E3 | MOV     R2, #0x204; count\n0x000D3464 | 68 10 9F E5 | LDR     R1, =bb_common_bufsiz1; buf\n0x000D3468 | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000D346C | DE 1A FD EB | BL      xwrite\n0x000D3470 | 28 30 1B E5 | LDR     R3, [R11,#pagesize]\n0x000D3474 | 0A 30 43 E2 | SUB     R3, R3, #0xA\n0x000D3478 | 00 40 A0 E3 | MOV     R4, #0\n0x000D347C | 00 20 A0 E3 | MOV     R2, #0\n0x000D3480 | 00 20 8D E5 | STR     R2, [SP,#0x5C+whence]; whence\n0x000D3484 | 03 20 A0 E1 | MOV     R2, R3; offset\n0x000D3488 | 04 30 A0 E1 | MOV     R3, R4; offset\n0x000D348C | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000D3490 | 0B 1B FD EB | BL      xlseek\n0x000D3494 | 0A 20 A0 E3 | MOV     R2, #0xA; count\n0x000D3498 | 44 10 9F E5 | LDR     R1, =SWAPSPACE2; buf\n0x000D349C | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000D34A0 | D1 1A FD EB | BL      xwrite\n0x000D34A4 | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000D34A8 | 1D 06 FD EB | BL      fsync\n0x000D34AC | 00 30 A0 E3 | MOV     R3, #0\n0x000D34B0 | 03 00 A0 E1 | MOV     R0, R3\n0x000D34B4 | 10 D0 4B E2 | SUB     SP, R11, #0x10\n0x000D34B8 | 70 88 BD E8 | POP     {R4-R6,R11,PC}",
        "output": "```c\n#include <stdio.h>\n\nvoid main(int argc, char** argv) {\n    int label;\n    int optind__GLIBC_2.4;\n    int fd;\n    int len;\n    int pagesize;\n    int uuid_string;\n    \n    label = unk_175F64;\n    optind__GLIBC_2.4 = optind;\n    \n    STR(R11, argc, R0);\n    STR(R11, argv, R1);\n    STR(R11, label, R3);\n    STR(R3, opt_complementary, R2);\n    STR(R11, argv, R3);\n    STR(R11, fd, R3);\n    STR(R11, len, R3);\n    STR(R11, len+4, R4);\n    STR(R11, pagesize, R3);\n    STR(R11, len, R5);\n    STR(R11, len+4, R6);\n    \n    printf(\"Setting up swapspace version 1, size = %d\\n\", bb_common_bufsiz1);\n    \n    STR(R11, len, R3);\n    STR(R11, len+4, R4);\n    \n    printf(\"UUID=%.8s-%.4s-%.4s-%.4s-%.12s\\n\", byte_18F9E4);\n    \n    safe_strncpy(qword_18F9F0+4, label, 0x10);\n    \n    STR(R11, fd, R2);\n    STR(R11, fd, R3);\n    \n    xlseek(R11, pagesize-0xA, 0);\n    \n    STR(R11, fd, R2);\n    STR(R11, fd, R3);\n    \n    xwrite(R11, SWAPSPACE2, 0xA);\n    \n    fsync(R11);\n}\n```"
    },
    {
        "func_name": "isrv_close_fd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00066200 | 00 48 2D E9 | PUSH    {R11,LR}\n0x00066204 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00066208 | 08 D0 4D E2 | SUB     SP, SP, #8\n0x0006620C | 08 00 0B E5 | STR     R0, [R11,#state]\n0x00066210 | 0C 10 0B E5 | STR     R1, [R11,#fd]\n0x00066214 | 0C 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x00066218 | BD BE FE EB | BL      close\n0x0006621C | 0C 10 1B E5 | LDR     R1, [R11,#fd]; fd\n0x00066220 | 08 00 1B E5 | LDR     R0, [R11,#state]; state\n0x00066224 | 57 FF FF EB | BL      isrv_dont_want_rd\n0x00066228 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x0006622C | 20 30 93 E5 | LDR     R3, [R3,#0x20]\n0x00066230 | 00 00 53 E3 | CMP     R3, #0\n0x00066234 | 02 00 00 0A | BEQ     loc_66244\n0x00066238 | 0C 10 1B E5 | LDR     R1, [R11,#fd]; fd\n0x0006623C | 08 00 1B E5 | LDR     R0, [R11,#state]; state\n0x00066240 | 73 FF FF EB | BL      isrv_dont_want_wr\n0x00066244 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x00066248 | 00 20 93 E5 | LDR     R2, [R3]\n0x0006624C | 0C 30 1B E5 | LDR     R3, [R11,#fd]\n0x00066250 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x00066254 | 03 30 82 E0 | ADD     R3, R2, R3\n0x00066258 | 00 20 E0 E3 | MOV     R2, #0xFFFFFFFF\n0x0006625C | B0 20 C3 E1 | STRH    R2, [R3]\n0x00066260 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x00066264 | 18 30 93 E5 | LDR     R3, [R3,#0x18]\n0x00066268 | 01 30 43 E2 | SUB     R3, R3, #1\n0x0006626C | 0C 20 1B E5 | LDR     R2, [R11,#fd]\n0x00066270 | 03 00 52 E1 | CMP     R2, R3\n0x00066274 | 1C 00 00 1A | BNE     loc_662EC\n0x00066278 | 0C 30 1B E5 | LDR     R3, [R11,#fd]\n0x0006627C | 01 30 43 E2 | SUB     R3, R3, #1\n0x00066280 | 0C 30 0B E5 | STR     R3, [R11,#fd]\n0x00066284 | 0C 30 1B E5 | LDR     R3, [R11,#fd]\n0x00066288 | 00 00 53 E3 | CMP     R3, #0\n0x0006628C | 07 00 00 BA | BLT     loc_662B0\n0x00066290 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x00066294 | 00 20 93 E5 | LDR     R2, [R3]\n0x00066298 | 0C 30 1B E5 | LDR     R3, [R11,#fd]\n0x0006629C | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000662A0 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000662A4 | F0 30 D3 E1 | LDRSH   R3, [R3]\n0x000662A8 | 01 00 73 E3 | CMN     R3, #1\n0x000662AC | F1 FF FF 0A | BEQ     loc_66278\n0x000662B0 | 0C 30 1B E5 | LDR     R3, [R11,#fd]\n0x000662B4 | 01 20 83 E2 | ADD     R2, R3, #1\n0x000662B8 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x000662BC | 18 20 83 E5 | STR     R2, [R3,#0x18]\n0x000662C0 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x000662C4 | 00 20 93 E5 | LDR     R2, [R3]\n0x000662C8 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x000662CC | 18 30 93 E5 | LDR     R3, [R3,#0x18]\n0x000662D0 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000662D4 | 03 10 A0 E1 | MOV     R1, R3; size\n0x000662D8 | 02 00 A0 E1 | MOV     R0, R2; ptr\n0x000662DC | FC CD FE EB | BL      xrealloc\n0x000662E0 | 00 20 A0 E1 | MOV     R2, R0\n0x000662E4 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x000662E8 | 00 20 83 E5 | STR     R2, [R3]\n0x000662EC | 00 00 A0 E1 | NOP\n0x000662F0 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000662F4 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(int state, int fd) {\n    state = state;\n    fd = fd;\n    close(fd);\n    isrv_dont_want_rd(state);\n    int* ptr = (int*)state;\n    int size = *(ptr + 0x18);\n    int* new_ptr = (int*)xrealloc(ptr, size * sizeof(int));\n    *(ptr + 0x18) = size + 1;\n    *(ptr) = new_ptr;\n}\n```"
    },
    {
        "func_name": "strcpy_and_process_escape_sequences",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0014C4D8 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0014C4DC | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0014C4E0 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x0014C4E4 | 10 00 0B E5 | STR     R0, [R11,#dst]\n0x0014C4E8 | 14 10 0B E5 | STR     R1, [R11,#src]\n0x0014C4EC | 14 30 1B E5 | LDR     R3, [R11,#src]\n0x0014C4F0 | 01 20 83 E2 | ADD     R2, R3, #1\n0x0014C4F4 | 14 20 0B E5 | STR     R2, [R11,#src]\n0x0014C4F8 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0014C4FC | 05 30 4B E5 | STRB    R3, [R11,#c1]\n0x0014C500 | 05 30 5B E5 | LDRB    R3, [R11,#c1]\n0x0014C504 | 06 30 4B E5 | STRB    R3, [R11,#c]\n0x0014C508 | 05 30 5B E5 | LDRB    R3, [R11,#c1]\n0x0014C50C | 5C 00 53 E3 | CMP     R3, #0x5C ; '\\'\n0x0014C510 | 04 00 00 1A | BNE     loc_14C528\n0x0014C514 | 14 30 4B E2 | SUB     R3, R11, #-src\n0x0014C518 | 03 00 A0 E1 | MOV     R0, R3; ptr\n0x0014C51C | 7D FF FF EB | BL      bb_process_escape_sequence\n0x0014C520 | 00 30 A0 E1 | MOV     R3, R0\n0x0014C524 | 05 30 4B E5 | STRB    R3, [R11,#c1]\n0x0014C528 | 10 30 1B E5 | LDR     R3, [R11,#dst]\n0x0014C52C | 05 20 5B E5 | LDRB    R2, [R11,#c1]\n0x0014C530 | 00 20 C3 E5 | STRB    R2, [R3]\n0x0014C534 | 06 30 5B E5 | LDRB    R3, [R11,#c]\n0x0014C538 | 00 00 53 E3 | CMP     R3, #0\n0x0014C53C | 01 00 00 1A | BNE     loc_14C548\n0x0014C540 | 10 30 1B E5 | LDR     R3, [R11,#dst]\n0x0014C544 | 03 00 00 EA | B       loc_14C558\n0x0014C548 | 10 30 1B E5 | LDR     R3, [R11,#dst]\n0x0014C54C | 01 30 83 E2 | ADD     R3, R3, #1\n0x0014C550 | 10 30 0B E5 | STR     R3, [R11,#dst]\n0x0014C554 | E4 FF FF EA | B       loc_14C4EC\n0x0014C558 | 03 00 A0 E1 | MOV     R0, R3\n0x0014C55C | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0014C560 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(int dst, int src, char c1, char c) {\n    int R11, LR;\n    R11 = dst;\n    LR = src;\n    int SP = R11 + 4;\n    SP = SP - 16;\n    *(int *)(R11) = R0;\n    *(int *)(R11 + 4) = R1;\n    int R3 = *(int *)(R11 + 4);\n    int R2 = R3 + 1;\n    *(int *)(R11 + 4) = R2;\n    char R3 = *(char *)(R3);\n    *(char *)(R11 + c1) = R3;\n    R3 = *(char *)(R11 + c1);\n    *(char *)(R11 + c) = R3;\n    R3 = *(char *)(R11 + c1);\n    if (R3 != 0x5C) {\n        int R3 = R11 - src;\n        R0 = R3;\n        bb_process_escape_sequence();\n        R3 = R0;\n        *(char *)(R11 + c1) = R3;\n    }\n    R3 = *(int *)(R11);\n    char R2 = *(char *)(R11 + c1);\n    *(char *)(R3) = R2;\n    R3 = *(char *)(R11 + c);\n    if (R3 != 0) {\n        R3 = *(int *)(R11);\n        R3 = R3 + 1;\n        *(int *)(R11) = R3;\n        goto loc_14C4EC;\n    }\n    R3 = *(int *)(R11);\n    goto loc_14C558;\n}\n```"
    },
    {
        "func_name": "setfont_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000FE550 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000FE554 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000FE558 | 40 D0 4D E2 | SUB     SP, SP, #0x40\n0x000FE55C | 40 00 0B E5 | STR     R0, [R11,#argc]\n0x000FE560 | 44 10 0B E5 | STR     R1, [R11,#argv]\n0x000FE564 | C0 32 9F E5 | LDR     R3, =aDevTty_7; \"/dev/tty\"\n0x000FE568 | 34 30 0B E5 | STR     R3, [R11,#tty_name]\n0x000FE56C | BC 32 9F E5 | LDR     R3, =opt_complementary\n0x000FE570 | BC 22 9F E5 | LDR     R2, =a1_22; \"=1\"\n0x000FE574 | 00 20 83 E5 | STR     R2, [R3]\n0x000FE578 | 34 30 4B E2 | SUB     R3, R11, #-tty_name\n0x000FE57C | 30 20 4B E2 | SUB     R2, R11, #-mapfilename\n0x000FE580 | B0 12 9F E5 | LDR     R1, =aMC; \"m:C:\"\n0x000FE584 | 44 00 1B E5 | LDR     R0, [R11,#argv]; argv\n0x000FE588 | C6 0A 01 EB | BL      getopt32\n0x000FE58C | 14 00 0B E5 | STR     R0, [R11,#opts]\n0x000FE590 | A4 32 9F E5 | LDR     R3, =optind__GLIBC_2.4\n0x000FE594 | 00 30 93 E5 | LDR     R3, [R3]\n0x000FE598 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000FE59C | 44 20 1B E5 | LDR     R2, [R11,#argv]\n0x000FE5A0 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000FE5A4 | 44 30 0B E5 | STR     R3, [R11,#argv]\n0x000FE5A8 | 34 30 1B E5 | LDR     R3, [R11,#tty_name]\n0x000FE5AC | 03 00 A0 E1 | MOV     R0, R3; pathname\n0x000FE5B0 | F3 6D FC EB | BL      xopen_nonblocking\n0x000FE5B4 | 18 00 0B E5 | STR     R0, [R11,#fd]\n0x000FE5B8 | 02 39 A0 E3 | MOV     R3, #0x8000\n0x000FE5BC | 2C 30 0B E5 | STR     R3, [R11,#len]\n0x000FE5C0 | 44 30 1B E5 | LDR     R3, [R11,#argv]\n0x000FE5C4 | 00 30 93 E5 | LDR     R3, [R3]\n0x000FE5C8 | 2C 20 4B E2 | SUB     R2, R11, #-len\n0x000FE5CC | 02 10 A0 E1 | MOV     R1, R2; maxsz_p\n0x000FE5D0 | 03 00 A0 E1 | MOV     R0, R3; fname\n0x000FE5D4 | B5 FB FF EB | BL      xmalloc_open_zipped_read_close\n0x000FE5D8 | 00 30 A0 E1 | MOV     R3, R0\n0x000FE5DC | 1C 30 0B E5 | STR     R3, [R11,#buffer]\n0x000FE5E0 | 1C 30 1B E5 | LDR     R3, [R11,#buffer]\n0x000FE5E4 | 00 00 53 E3 | CMP     R3, #0\n0x000FE5E8 | 03 00 00 1A | BNE     loc_FE5FC\n0x000FE5EC | 44 30 1B E5 | LDR     R3, [R11,#argv]\n0x000FE5F0 | 00 30 93 E5 | LDR     R3, [R3]\n0x000FE5F4 | 03 00 A0 E1 | MOV     R0, R3; s\n0x000FE5F8 | E3 68 FC EB | BL      bb_simple_perror_msg_and_die\n0x000FE5FC | 2C 30 1B E5 | LDR     R3, [R11,#len]\n0x000FE600 | 03 20 A0 E1 | MOV     R2, R3; len\n0x000FE604 | 1C 10 1B E5 | LDR     R1, [R11,#buffer]; buffer\n0x000FE608 | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000FE60C | BA FE FF EB | BL      do_load\n0x000FE610 | 14 30 1B E5 | LDR     R3, [R11,#opts]\n0x000FE614 | 01 30 03 E2 | AND     R3, R3, #1\n0x000FE618 | 00 00 53 E3 | CMP     R3, #0\n0x000FE61C | 7E 00 00 0A | BEQ     loc_FE81C\n0x000FE620 | 18 32 9F E5 | LDR     R3, =0x4B41\n0x000FE624 | 08 30 0B E5 | STR     R3, [R11,#mode]\n0x000FE628 | 30 30 1B E5 | LDR     R3, [R11,#mapfilename]\n0x000FE62C | 2C 20 4B E2 | SUB     R2, R11, #-len\n0x000FE630 | 02 10 A0 E1 | MOV     R1, R2; maxsz_p\n0x000FE634 | 03 00 A0 E1 | MOV     R0, R3; fname\n0x000FE638 | 9C FB FF EB | BL      xmalloc_open_zipped_read_close\n0x000FE63C | 00 30 A0 E1 | MOV     R3, R0\n0x000FE640 | 0C 30 0B E5 | STR     R3, [R11,#map]\n0x000FE644 | 0C 30 1B E5 | LDR     R3, [R11,#map]\n0x000FE648 | 00 00 53 E3 | CMP     R3, #0\n0x000FE64C | 02 00 00 1A | BNE     loc_FE65C\n0x000FE650 | 30 30 1B E5 | LDR     R3, [R11,#mapfilename]\n0x000FE654 | 03 00 A0 E1 | MOV     R0, R3; s\n0x000FE658 | CB 68 FC EB | BL      bb_simple_perror_msg_and_die\n0x000FE65C | 2C 30 1B E5 | LDR     R3, [R11,#len]\n0x000FE660 | 01 0C 53 E3 | CMP     R3, #0x100\n0x000FE664 | 02 00 00 0A | BEQ     loc_FE674\n0x000FE668 | 2C 30 1B E5 | LDR     R3, [R11,#len]\n0x000FE66C | 02 0C 53 E3 | CMP     R3, #0x200\n0x000FE670 | 05 00 00 1A | BNE     loc_FE68C\n0x000FE674 | 2C 30 1B E5 | LDR     R3, [R11,#len]\n0x000FE678 | 02 0C 53 E3 | CMP     R3, #0x200\n0x000FE67C | 61 00 00 1A | BNE     loc_FE808\n0x000FE680 | BC 31 9F E5 | LDR     R3, =0x4B6A\n0x000FE684 | 08 30 0B E5 | STR     R3, [R11,#mode]\n0x000FE688 | 5E 00 00 EA | B       loc_FE808\n0x000FE68C | 02 0C A0 E3 | MOV     R0, #0x200; size\n0x000FE690 | FA 6C FC EB | BL      xmalloc\n0x000FE694 | 00 30 A0 E1 | MOV     R3, R0\n0x000FE698 | 0C 30 0B E5 | STR     R3, [R11,#map]\n0x000FE69C | 00 30 A0 E3 | MOV     R3, #0\n0x000FE6A0 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x000FE6A4 | 0D 00 00 EA | B       loc_FE6E0\n0x000FE6A8 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE6AC | 03 38 A0 E1 | MOV     R3, R3,LSL#16\n0x000FE6B0 | 23 28 A0 E1 | MOV     R2, R3,LSR#16\n0x000FE6B4 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE6B8 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000FE6BC | 0C 10 1B E5 | LDR     R1, [R11,#map]\n0x000FE6C0 | 03 30 81 E0 | ADD     R3, R1, R3\n0x000FE6C4 | 01 2A 42 E2 | SUB     R2, R2, #0x1000\n0x000FE6C8 | 02 28 A0 E1 | MOV     R2, R2,LSL#16\n0x000FE6CC | 22 28 A0 E1 | MOV     R2, R2,LSR#16\n0x000FE6D0 | B0 20 C3 E1 | STRH    R2, [R3]\n0x000FE6D4 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE6D8 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000FE6DC | 10 30 0B E5 | STR     R3, [R11,#i]\n0x000FE6E0 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE6E4 | FF 00 53 E3 | CMP     R3, #0xFF\n0x000FE6E8 | EE FF FF DA | BLE     loc_FE6A8\n0x000FE6EC | 30 30 1B E5 | LDR     R3, [R11,#mapfilename]\n0x000FE6F0 | 03 00 A0 E1 | MOV     R0, R3; filename\n0x000FE6F4 | 17 33 01 EB | BL      config_open\n0x000FE6F8 | 20 00 0B E5 | STR     R0, [R11,#parser]\n0x000FE6FC | 22 00 00 EA | B       loc_FE78C\n0x000FE700 | 3C 30 1B E5 | LDR     R3, [R11,#token]\n0x000FE704 | 03 00 A0 E1 | MOV     R0, R3; s\n0x000FE708 | 56 FF FF EB | BL      ctoi\n0x000FE70C | 24 00 0B E5 | STR     R0, [R11,#a]\n0x000FE710 | 38 30 1B E5 | LDR     R3, [R11,#token+4]\n0x000FE714 | 03 00 A0 E1 | MOV     R0, R3; s\n0x000FE718 | 52 FF FF EB | BL      ctoi\n0x000FE71C | 28 00 0B E5 | STR     R0, [R11,#b]\n0x000FE720 | 24 30 1B E5 | LDR     R3, [R11,#a]\n0x000FE724 | 00 00 53 E3 | CMP     R3, #0\n0x000FE728 | 08 00 00 BA | BLT     loc_FE750\n0x000FE72C | 24 30 1B E5 | LDR     R3, [R11,#a]\n0x000FE730 | FF 00 53 E3 | CMP     R3, #0xFF\n0x000FE734 | 05 00 00 CA | BGT     loc_FE750\n0x000FE738 | 28 30 1B E5 | LDR     R3, [R11,#b]\n0x000FE73C | 00 00 53 E3 | CMP     R3, #0\n0x000FE740 | 02 00 00 BA | BLT     loc_FE750\n0x000FE744 | 28 30 1B E5 | LDR     R3, [R11,#b]\n0x000FE748 | 01 08 53 E3 | CMP     R3, #0x10000\n0x000FE74C | 01 00 00 BA | BLT     loc_FE758\n0x000FE750 | F0 00 9F E5 | LDR     R0, =aMapFormat; \"map format\"\n0x000FE754 | 8F 69 FC EB | BL      bb_error_msg_and_die\n0x000FE758 | 24 30 1B E5 | LDR     R3, [R11,#a]\n0x000FE75C | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000FE760 | 0C 20 1B E5 | LDR     R2, [R11,#map]\n0x000FE764 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000FE768 | 28 20 1B E5 | LDR     R2, [R11,#b]\n0x000FE76C | 02 28 A0 E1 | MOV     R2, R2,LSL#16\n0x000FE770 | 22 28 A0 E1 | MOV     R2, R2,LSR#16\n0x000FE774 | B0 20 C3 E1 | STRH    R2, [R3]\n0x000FE778 | 28 30 1B E5 | LDR     R3, [R11,#b]\n0x000FE77C | FF 00 53 E3 | CMP     R3, #0xFF\n0x000FE780 | 01 00 00 DA | BLE     loc_FE78C\n0x000FE784 | B8 30 9F E5 | LDR     R3, =0x4B6A\n0x000FE788 | 08 30 0B E5 | STR     R3, [R11,#mode]\n0x000FE78C | 3C 10 4B E2 | SUB     R1, R11, #-token; tokens\n0x000FE790 | B4 30 9F E5 | LDR     R3, =asc_1780FC; \"# \\t\"\n0x000FE794 | B4 20 9F E5 | LDR     R2, =0x570202; flags\n0x000FE798 | 20 00 1B E5 | LDR     R0, [R11,#parser]; parser\n0x000FE79C | 83 33 01 EB | BL      config_read\n0x000FE7A0 | 00 30 A0 E1 | MOV     R3, R0\n0x000FE7A4 | 00 00 53 E3 | CMP     R3, #0\n0x000FE7A8 | D4 FF FF 1A | BNE     loc_FE700\n0x000FE7AC | 08 30 1B E5 | LDR     R3, [R11,#mode]\n0x000FE7B0 | 8C 20 9F E5 | LDR     R2, =0x4B6A\n0x000FE7B4 | 02 00 53 E1 | CMP     R3, R2\n0x000FE7B8 | 12 00 00 0A | BEQ     loc_FE808\n0x000FE7BC | 00 30 A0 E3 | MOV     R3, #0\n0x000FE7C0 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x000FE7C4 | 0C 00 00 EA | B       loc_FE7FC\n0x000FE7C8 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE7CC | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000FE7D0 | 0C 20 1B E5 | LDR     R2, [R11,#map]\n0x000FE7D4 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000FE7D8 | B0 20 D3 E1 | LDRH    R2, [R3]\n0x000FE7DC | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE7E0 | 0C 10 1B E5 | LDR     R1, [R11,#map]\n0x000FE7E4 | 03 30 81 E0 | ADD     R3, R1, R3\n0x000FE7E8 | FF 20 02 E2 | AND     R2, R2, #0xFF\n0x000FE7EC | 00 20 C3 E5 | STRB    R2, [R3]\n0x000FE7F0 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE7F4 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000FE7F8 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x000FE7FC | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE800 | FF 00 53 E3 | CMP     R3, #0xFF\n0x000FE804 | EF FF FF DA | BLE     loc_FE7C8\n0x000FE808 | 44 30 9F E5 | LDR     R3, =aMode_2; \"mode\"\n0x000FE80C | 0C 20 1B E5 | LDR     R2, [R11,#map]; argp\n0x000FE810 | 08 10 1B E5 | LDR     R1, [R11,#mode]; request\n0x000FE814 | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000FE818 | 33 70 FC EB | BL      bb_xioctl\n0x000FE81C | 00 30 A0 E3 | MOV     R3, #0\n0x000FE820 | 03 00 A0 E1 | MOV     R0, R3\n0x000FE824 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000FE828 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n\nint main(int argc, char *argv[]) {\n    int fd, len;\n    char *tty_name, *mapfilename, *buffer;\n    int opts, optind;\n    char *parser;\n    int a, b;\n    int i;\n    \n    tty_name = \"/dev/tty\";\n    mapfilename = \"=1\";\n    \n    // Store argc and argv\n    argc = argc;\n    argv = argv;\n    \n    // Open non-blocking file\n    fd = xopen_nonblocking(tty_name);\n    \n    // Store file descriptor\n    opts = fd;\n    \n    // Get optind\n    optind = getopt32(argc, argv, \"m:C:\");\n    \n    // Store optind\n    opts = optind;\n    \n    // Load file\n    buffer = xmalloc_open_zipped_read_close(argv[optind]);\n    \n    // Store buffer\n    buffer = buffer;\n    \n    // Check if buffer is empty\n    if (buffer == NULL) {\n        bb_simple_perror_msg_and_die(argv[optind]);\n    }\n    \n    // Get length of buffer\n    len = strlen(buffer);\n    \n    // Store length\n    len = len;\n    \n    // Check length of buffer\n    if (len == 0x100) {\n        do_load(fd, buffer, len);\n    } else if (len == 0x200) {\n        do_load(fd, buffer, len);\n    } else if (len == 0x200) {\n        do_load(fd, buffer, len);\n    } else {\n        bb_simple_perror_msg_and_die(argv[optind]);\n    }\n    \n    // Read config file\n    parser = config_open(argv[optind]);\n    \n    // Store parser\n    parser = parser;\n    \n    // Read config\n    config_read(parser, \"# \\t\", 0x570202);\n    \n    // Check if config read was successful\n    if (config_read(parser, \"# \\t\", 0x570202) != 0) {\n        bb_error_msg_and_die(\"config read failed\");\n    }\n    \n    // Check mode\n    if (mode == 0x4B6A) {\n        // Do something\n    }\n    \n    // Loop through buffer\n    for (i = 0; i < len; i++) {\n        a = map[i] >> 16;\n        b = map[i] & 0xFFFF;\n        \n        // Check if a is within range\n        if (a >= 0 && a <= 0xFF) {\n            // Do something\n        }\n        \n        // Check if b is within range\n        if (b >= 0 && b <= 0x10000) {\n            // Do something\n        }\n    }\n    \n    // Set mode\n    mode = 0x4B6A;\n    \n    // Do something\n    \n    return 0;\n}\n```"
    },
    {
        "func_name": "vfork_child",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000FEB38 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000FEB3C | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000FEB40 | 08 D0 4D E2 | SUB     SP, SP, #8\n0x000FEB44 | 08 00 0B E5 | STR     R0, [R11,#argv]\n0x000FEB48 | 51 5B FC EB | BL      vfork\n0x000FEB4C | 00 30 A0 E1 | MOV     R3, R0\n0x000FEB50 | 00 00 53 E3 | CMP     R3, #0\n0x000FEB54 | 06 00 00 1A | BNE     loc_FEB74\n0x000FEB58 | 90 5A FC EB | BL      setsid\n0x000FEB5C | 00 20 A0 E3 | MOV     R2, #0\n0x000FEB60 | 18 10 9F E5 | LDR     R1, =0x540E; request\n0x000FEB64 | 00 00 A0 E3 | MOV     R0, #0; fd\n0x000FEB68 | BD 59 FC EB | BL      ioctl\n0x000FEB6C | 08 00 1B E5 | LDR     R0, [R11,#argv]; argv\n0x000FEB70 | 98 04 01 EB | BL      BB_EXECVP_or_die\n0x000FEB74 | 00 00 A0 E1 | NOP\n0x000FEB78 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000FEB7C | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(int argc, char** argv) {\n    PUSH    {R11,LR}\n    ADD     R11, SP, #4\n    SUB     SP, SP, #8\n    STR     R0, [R11,#argv]\n    BL      vfork\n    MOV     R3, R0\n    CMP     R3, #0\n    BNE     loc_FEB74\n    BL      setsid\n    MOV     R2, #0\n    LDR     R1, =0x540E; request\n    MOV     R0, #0; fd\n    BL      ioctl\n    LDR     R0, [R11,#argv]; argv\n    BL      BB_EXECVP_or_die\n    NOP\n    SUB     SP, R11, #4\n    POP     {R11,PC}\n}\n```"
    },
    {
        "func_name": "recalculate_maxsock",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0004C9E8 | 70 48 2D E9 | PUSH    {R4-R6,R11,LR}\n0x0004C9EC | 10 B0 8D E2 | ADD     R11, SP, #0x10\n0x0004C9F0 | 0C D0 4D E2 | SUB     SP, SP, #0xC\n0x0004C9F4 | 00 30 A0 E3 | MOV     R3, #0\n0x0004C9F8 | 18 30 0B E5 | STR     R3, [R11,#fd]\n0x0004C9FC | C8 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CA00 | 00 00 A0 E3 | MOV     R0, #0\n0x0004CA04 | 20 00 83 E5 | STR     R0, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x0004CA08 | 17 00 00 EA | B       loc_4CA6C\n0x0004CA0C | BC C0 9F E5 | LDR     R12, =dword_18FAA0\n0x0004CA10 | 18 30 1B E5 | LDR     R3, [R11,#fd]\n0x0004CA14 | 1F 00 83 E2 | ADD     R0, R3, #0x1F\n0x0004CA18 | 00 00 53 E3 | CMP     R3, #0\n0x0004CA1C | 00 30 A0 B1 | MOVLT   R3, R0\n0x0004CA20 | 03 30 A0 A1 | MOVGE   R3, R3\n0x0004CA24 | C3 32 A0 E1 | MOV     R3, R3,ASR#5\n0x0004CA28 | 03 01 9C E7 | LDR     R0, [R12,R3,LSL#2]\n0x0004CA2C | 18 30 1B E5 | LDR     R3, [R11,#fd]\n0x0004CA30 | 00 C0 73 E2 | RSBS    R12, R3, #0\n0x0004CA34 | 1F 30 03 E2 | AND     R3, R3, #0x1F\n0x0004CA38 | 1F C0 0C E2 | AND     R12, R12, #0x1F\n0x0004CA3C | 00 30 6C 52 | RSBPL   R3, R12, #0\n0x0004CA40 | 01 C0 A0 E3 | MOV     R12, #1\n0x0004CA44 | 1C 33 A0 E1 | MOV     R3, R12,LSL R3\n0x0004CA48 | 00 30 03 E0 | AND     R3, R3, R0\n0x0004CA4C | 00 00 53 E3 | CMP     R3, #0\n0x0004CA50 | 02 00 00 0A | BEQ     loc_4CA60\n0x0004CA54 | 70 00 9F E5 | LDR     R0, =bb_common_bufsiz1\n0x0004CA58 | 18 30 1B E5 | LDR     R3, [R11,#fd]\n0x0004CA5C | 20 30 80 E5 | STR     R3, [R0,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x0004CA60 | 18 30 1B E5 | LDR     R3, [R11,#fd]\n0x0004CA64 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0004CA68 | 18 30 0B E5 | STR     R3, [R11,#fd]\n0x0004CA6C | 58 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CA70 | 24 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0x13 - 0x18F9D8)]\n0x0004CA74 | 18 00 1B E5 | LDR     R0, [R11,#fd]\n0x0004CA78 | 03 00 50 E1 | CMP     R0, R3\n0x0004CA7C | E2 FF FF DA | BLE     loc_4CA0C\n0x0004CA80 | 44 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CA84 | 40 00 9F E5 | LDR     R0, =bb_common_bufsiz1\n0x0004CA88 | 20 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x0004CA8C | 24 30 80 E5 | STR     R3, [R0,#(bb_common_bufsiz1.c_cc+0x13 - 0x18F9D8)]\n0x0004CA90 | 34 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CA94 | 20 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x0004CA98 | 03 50 A0 E1 | MOV     R5, R3\n0x0004CA9C | C5 6F A0 E1 | MOV     R6, R5,ASR#31\n0x0004CAA0 | 24 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CAA4 | 18 00 93 E8 | LDM     R3, {R3,R4}\n0x0004CAA8 | 08 10 53 E2 | SUBS    R1, R3, #8\n0x0004CAAC | 00 20 C4 E2 | SBC     R2, R4, #0\n0x0004CAB0 | 02 00 56 E1 | CMP     R6, R2\n0x0004CAB4 | 01 00 55 01 | CMPEQ   R5, R1\n0x0004CAB8 | 00 00 00 9A | BLS     loc_4CAC0\n0x0004CABC | 29 FF FF EB | BL      bump_nofile\n0x0004CAC0 | 00 00 A0 E1 | NOP\n0x0004CAC4 | 10 D0 4B E2 | SUB     SP, R11, #0x10\n0x0004CAC8 | 70 88 BD E8 | POP     {R4-R6,R11,PC}",
        "output": "```c\nvoid function() {\n    int R3 = 0;\n    int* bb_common_bufsiz1 = &bb_common_bufsiz1;\n    bb_common_bufsiz1[0xF - 0x18F9D8] = 0;\n    loc_4CA6C:\n    int R12 = dword_18FAA0;\n    int R0 = R3 + 0x1F;\n    if (R3 < 0) {\n        R3 = R0;\n    } else {\n        R3 = R3 >> 5;\n        R3 = *(R12 + (R3 << 2));\n        int R12 = 1;\n        R3 = R12 << R3;\n        R3 = R3 & R0;\n        if (R3 != 0) {\n            goto loc_4CA60;\n        }\n        bb_common_bufsiz1[0xF - 0x18F9D8] = R3;\n        R3 = R3 + 1;\n        bb_common_bufsiz1[0xF - 0x18F9D8] = R3;\n        R3 = &bb_common_bufsiz1;\n        R3 = bb_common_bufsiz1[0x13 - 0x18F9D8];\n        R0 = R11[0xFD];\n        if (R0 <= R3) {\n            goto loc_4CA0C;\n        }\n        R3 = &bb_common_bufsiz1;\n        R0 = &bb_common_bufsiz1;\n        R3 = bb_common_bufsiz1[0xF - 0x18F9D8];\n        R0[0x13 - 0x18F9D8] = R3;\n        R3 = &bb_common_bufsiz1;\n        R3 = bb_common_bufsiz1[0xF - 0x18F9D8];\n        int R5 = R3;\n        int R6 = R5 >> 31;\n        R3 = &bb_common_bufsiz1;\n        R3 = R3[0];\n        int R1 = R3 - 8;\n        int R2 = 0;\n        if (R6 == R2) {\n            R5 = R1;\n        }\n        if (R6 <= R2) {\n            bump_nofile();\n        }\n    }\n    return;\n}\n```"
    },
    {
        "func_name": "reset_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000FED34 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000FED38 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000FED3C | 08 D0 4D E2 | SUB     SP, SP, #8\n0x000FED40 | 08 00 0B E5 | STR     R0, [R11,#argc]\n0x000FED44 | 0C 10 0B E5 | STR     R1, [R11,#argv]\n0x000FED48 | 01 00 A0 E3 | MOV     R0, #1; fd\n0x000FED4C | D5 5B FC EB | BL      isatty\n0x000FED50 | 00 30 A0 E1 | MOV     R3, R0\n0x000FED54 | 00 00 53 E3 | CMP     R3, #0\n0x000FED58 | 06 00 00 0A | BEQ     loc_FED78\n0x000FED5C | 24 00 9F E5 | LDR     R0, =aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x000FED60 | 1C 58 FC EB | BL      printf\n0x000FED64 | 20 10 9F E5 | LDR     R1, =args.10327; argv\n0x000FED68 | 02 00 A0 E3 | MOV     R0, #2; argc\n0x000FED6C | F3 50 00 EB | BL      stty_main\n0x000FED70 | 00 30 A0 E1 | MOV     R3, R0\n0x000FED74 | 00 00 00 EA | B       loc_FED7C\n0x000FED78 | 00 30 A0 E3 | MOV     R3, #0\n0x000FED7C | 03 00 A0 E1 | MOV     R0, R3\n0x000FED80 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000FED84 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdio.h>\n\nint main(int argc, char *argv[]) {\n    if (isatty(1)) {\n        printf(\"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\");\n    }\n    stty_main(2, argv);\n    return 0;\n}\n```"
    },
    {
        "func_name": "set_partition",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000BF198 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000BF19C | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000BF1A0 | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x000BF1A4 | 10 00 0B E5 | STR     R0, [R11,#i]\n0x000BF1A8 | 14 10 0B E5 | STR     R1, [R11,#doext]\n0x000BF1AC | 18 20 0B E5 | STR     R2, [R11,#start]\n0x000BF1B0 | 1C 30 0B E5 | STR     R3, [R11,#stop]\n0x000BF1B4 | 14 30 1B E5 | LDR     R3, [R11,#doext]\n0x000BF1B8 | 00 00 53 E3 | CMP     R3, #0\n0x000BF1BC | 10 00 00 0A | BEQ     loc_BF204\n0x000BF1C0 | 30 31 9F E5 | LDR     R3, =ptr_to_globals\n0x000BF1C4 | 00 10 93 E5 | LDR     R1, [R3]\n0x000BF1C8 | 10 20 1B E5 | LDR     R2, [R11,#i]\n0x000BF1CC | 02 30 A0 E1 | MOV     R3, R2\n0x000BF1D0 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF1D4 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000BF1D8 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF1DC | 03 30 81 E0 | ADD     R3, R1, R3\n0x000BF1E0 | A9 3E 83 E2 | ADD     R3, R3, #0xA90\n0x000BF1E4 | 04 30 83 E2 | ADD     R3, R3, #4\n0x000BF1E8 | 00 30 93 E5 | LDR     R3, [R3]\n0x000BF1EC | 08 30 0B E5 | STR     R3, [R11,#p]\n0x000BF1F0 | 00 31 9F E5 | LDR     R3, =ptr_to_globals\n0x000BF1F4 | 00 30 93 E5 | LDR     R3, [R3]\n0x000BF1F8 | 5C 30 93 E5 | LDR     R3, [R3,#0x5C]\n0x000BF1FC | 0C 30 0B E5 | STR     R3, [R11,#offset]\n0x000BF200 | 16 00 00 EA | B       loc_BF260\n0x000BF204 | EC 30 9F E5 | LDR     R3, =ptr_to_globals\n0x000BF208 | 00 10 93 E5 | LDR     R1, [R3]\n0x000BF20C | 10 20 1B E5 | LDR     R2, [R11,#i]\n0x000BF210 | 02 30 A0 E1 | MOV     R3, R2\n0x000BF214 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF218 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000BF21C | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF220 | 03 30 81 E0 | ADD     R3, R1, R3\n0x000BF224 | A9 3E 83 E2 | ADD     R3, R3, #0xA90\n0x000BF228 | 00 30 93 E5 | LDR     R3, [R3]\n0x000BF22C | 08 30 0B E5 | STR     R3, [R11,#p]\n0x000BF230 | C0 30 9F E5 | LDR     R3, =ptr_to_globals\n0x000BF234 | 00 10 93 E5 | LDR     R1, [R3]\n0x000BF238 | 10 20 1B E5 | LDR     R2, [R11,#i]\n0x000BF23C | 02 30 A0 E1 | MOV     R3, R2\n0x000BF240 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF244 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000BF248 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF24C | 03 30 81 E0 | ADD     R3, R1, R3\n0x000BF250 | A9 3E 83 E2 | ADD     R3, R3, #0xA90\n0x000BF254 | 08 30 83 E2 | ADD     R3, R3, #8\n0x000BF258 | 00 30 93 E5 | LDR     R3, [R3]\n0x000BF25C | 0C 30 0B E5 | STR     R3, [R11,#offset]\n0x000BF260 | 08 30 1B E5 | LDR     R3, [R11,#p]\n0x000BF264 | 00 20 A0 E3 | MOV     R2, #0\n0x000BF268 | 00 20 C3 E5 | STRB    R2, [R3]\n0x000BF26C | 04 30 9B E5 | LDR     R3, [R11,#sysid]\n0x000BF270 | FF 20 03 E2 | AND     R2, R3, #0xFF\n0x000BF274 | 08 30 1B E5 | LDR     R3, [R11,#p]\n0x000BF278 | 04 20 C3 E5 | STRB    R2, [R3,#4]\n0x000BF27C | 18 20 1B E5 | LDR     R2, [R11,#start]\n0x000BF280 | 0C 30 1B E5 | LDR     R3, [R11,#offset]\n0x000BF284 | 03 30 42 E0 | SUB     R3, R2, R3\n0x000BF288 | 03 10 A0 E1 | MOV     R1, R3; start_sect\n0x000BF28C | 08 00 1B E5 | LDR     R0, [R11,#p]; p\n0x000BF290 | 6D FD FF EB | BL      set_start_sect\n0x000BF294 | 1C 20 1B E5 | LDR     R2, [R11,#stop]\n0x000BF298 | 18 30 1B E5 | LDR     R3, [R11,#start]\n0x000BF29C | 03 30 42 E0 | SUB     R3, R2, R3\n0x000BF2A0 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000BF2A4 | 03 10 A0 E1 | MOV     R1, R3; nr_sects\n0x000BF2A8 | 08 00 1B E5 | LDR     R0, [R11,#p]; p\n0x000BF2AC | 73 FD FF EB | BL      set_nr_sects\n0x000BF2B0 | 1C 20 1B E5 | LDR     R2, [R11,#stop]; stop\n0x000BF2B4 | 18 10 1B E5 | LDR     R1, [R11,#start]; start\n0x000BF2B8 | 08 00 1B E5 | LDR     R0, [R11,#p]; p\n0x000BF2BC | 05 FF FF EB | BL      set_hsc_start_end\n0x000BF2C0 | 30 30 9F E5 | LDR     R3, =ptr_to_globals\n0x000BF2C4 | 00 10 93 E5 | LDR     R1, [R3]\n0x000BF2C8 | 10 20 1B E5 | LDR     R2, [R11,#i]\n0x000BF2CC | 02 30 A0 E1 | MOV     R3, R2\n0x000BF2D0 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF2D4 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000BF2D8 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF2DC | 03 30 81 E0 | ADD     R3, R1, R3\n0x000BF2E0 | AA 3E 83 E2 | ADD     R3, R3, #0xAA0\n0x000BF2E4 | 01 20 A0 E3 | MOV     R2, #1\n0x000BF2E8 | 00 20 C3 E5 | STRB    R2, [R3]\n0x000BF2EC | 00 00 A0 E1 | NOP\n0x000BF2F0 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000BF2F4 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(int i, int doext, int start, int stop, int p, int sysid, int start_sect, int nr_sects, int stop_sect) {\n    if (doext == 0) {\n        int* ptr_to_globals = 0x30;\n        int* p_value = ptr_to_globals;\n        int* doext_value = ptr_to_globals + 0x14;\n        int* start_value = ptr_to_globals + 0x18;\n        int* stop_value = ptr_to_globals + 0x1C;\n        if (*doext_value != 0) {\n            p_value = *ptr_to_globals;\n            int* p_offset = p_value + 0x08;\n            *p_offset = *ptr_to_globals + 0x5C;\n            goto loc_BF260;\n        }\n        else {\n            p_value = *ptr_to_globals;\n            int* p_offset = p_value + 0x08;\n            *p_offset = *ptr_to_globals + 0x5C;\n            goto loc_BF204;\n        }\n    }\n    else {\n        int* ptr_to_globals = 0x30;\n        int* p_value = ptr_to_globals;\n        int* doext_value = ptr_to_globals + 0x14;\n        int* start_value = ptr_to_globals + 0x18;\n        int* stop_value = ptr_to_globals + 0x1C;\n        if (*doext_value != 0) {\n            p_value = *ptr_to_globals;\n            int* p_offset = p_value + 0x08;\n            *p_offset = *ptr_to_globals + 0x5C;\n            goto loc_BF260;\n        }\n        else {\n            p_value = *ptr_to_globals;\n            int* p_offset = p_value + 0x08;\n            *p_offset = *ptr_to_globals + 0x5C;\n            goto loc_BF204;\n        }\n    }\n\nloc_BF204:\n    int* ptr_to_globals = 0x30;\n    int* p_value = ptr_to_globals;\n    int* doext_value = ptr_to_globals + 0x14;\n    int* start_value = ptr_to_globals + 0x18;\n    int* stop_value = ptr_to_globals + 0x1C;\n    p_value = *ptr_to_globals;\n    int* p_offset = p_value + 0x08;\n    *p_offset = *ptr_to_globals + 0x5C;\n    goto loc_BF260;\n\nloc_BF260:\n    int* p_value = ptr_to_globals;\n    int* p_offset = p_value + 0x08;\n    int* p_ptr = *p_offset;\n    *p_ptr = 0;\n    int* sysid_value = ptr_to_globals + 0x04;\n    int* sysid_ptr = sysid_value;\n    int* p_ptr = *p_offset;\n    *p_ptr = *sysid_ptr & 0xFF;\n    int* start_value = ptr_to_globals + 0x18;\n    int* stop_value = ptr_to_globals + 0x1C;\n    int* start_ptr = start_value;\n    int* stop_ptr = stop_value;\n    int* p_ptr = *p_offset;\n    int* offset_ptr = *p_offset + 0x0C;\n    int* nr_sects_ptr = *p_offset + 0x10;\n    *offset_ptr = *start_ptr - *stop_ptr;\n    *nr_sects_ptr = *offset_ptr + 1;\n    int* start_sect_ptr = *offset_ptr;\n    int* p_ptr = *p_offset;\n    *start_sect_ptr = *p_ptr;\n    int* stop_sect_ptr = *nr_sects_ptr;\n    int* p_ptr = *p_offset;\n    *stop_sect_ptr = *p_ptr;\n    int* ptr_to_globals = 0x30;\n    int* p_value = ptr_to_globals;\n    int* doext_value = ptr_to_globals + 0x14;\n    int* start_value = ptr_to_globals + 0x18;\n    int* stop_value = ptr_to_globals + 0x1C;\n    p_value = *ptr_to_globals;\n    int* p_offset = p_value + 0x08;\n    int* p_ptr = *p_offset;\n    *p_ptr = 1;\n}\n```"
    },
    {
        "func_name": "iprule_list",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0006C8A0 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0006C8A4 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0006C8A8 | 30 D0 4D E2 | SUB     SP, SP, #0x30\n0x0006C8AC | 30 00 0B E5 | STR     R0, [R11,#argv]\n0x0006C8B0 | 84 30 9F E5 | LDR     R3, =preferred_family\n0x0006C8B4 | D0 30 D3 E1 | LDRSB   R3, [R3]\n0x0006C8B8 | 08 30 0B E5 | STR     R3, [R11,#af]\n0x0006C8BC | 08 30 1B E5 | LDR     R3, [R11,#af]\n0x0006C8C0 | 00 00 53 E3 | CMP     R3, #0\n0x0006C8C4 | 01 00 00 1A | BNE     loc_6C8D0\n0x0006C8C8 | 02 30 A0 E3 | MOV     R3, #2\n0x0006C8CC | 08 30 0B E5 | STR     R3, [R11,#af]\n0x0006C8D0 | 30 30 1B E5 | LDR     R3, [R11,#argv]\n0x0006C8D4 | 00 30 93 E5 | LDR     R3, [R3]\n0x0006C8D8 | 00 00 53 E3 | CMP     R3, #0\n0x0006C8DC | 05 00 00 0A | BEQ     loc_6C8F8\n0x0006C8E0 | 30 30 1B E5 | LDR     R3, [R11,#argv]\n0x0006C8E4 | 00 30 93 E5 | LDR     R3, [R3]\n0x0006C8E8 | 03 00 A0 E1 | MOV     R0, R3; arg\n0x0006C8EC | E6 A0 03 EB | BL      bb_warn_ignoring_args\n0x0006C8F0 | 00 30 E0 E3 | MOV     R3, #0xFFFFFFFF\n0x0006C8F4 | 0D 00 00 EA | B       loc_6C930\n0x0006C8F8 | 2C 30 4B E2 | SUB     R3, R11, #-rth\n0x0006C8FC | 03 00 A0 E1 | MOV     R0, R3; rth\n0x0006C900 | E2 08 00 EB | BL      xrtnl_open\n0x0006C904 | 2C 30 4B E2 | SUB     R3, R11, #-rth\n0x0006C908 | 22 20 A0 E3 | MOV     R2, #0x22 ; '\"'; type\n0x0006C90C | 08 10 1B E5 | LDR     R1, [R11,#af]; family\n0x0006C910 | 03 00 A0 E1 | MOV     R0, R3; rth\n0x0006C914 | 09 09 00 EB | BL      xrtnl_wilddump_request\n0x0006C918 | 2C 30 4B E2 | SUB     R3, R11, #-rth\n0x0006C91C | 00 20 A0 E3 | MOV     R2, #0; arg1\n0x0006C920 | 18 10 9F E5 | LDR     R1, =print_rule; filter\n0x0006C924 | 03 00 A0 E1 | MOV     R0, R3; rth\n0x0006C928 | 43 0A 00 EB | BL      xrtnl_dump_filter\n0x0006C92C | 00 30 A0 E3 | MOV     R3, #0\n0x0006C930 | 03 00 A0 E1 | MOV     R0, R3\n0x0006C934 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0006C938 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(int* argv) {\n    int af = *argv;\n    if (af == 0) {\n        af = 2;\n    }\n    if (*argv != 0) {\n        int rth = af - 0xFFFFFFFF;\n        xrtnl_open(rth);\n        xrtnl_wilddump_request(rth, 0, print_rule);\n        xrtnl_dump_filter(rth, 0, print_rule);\n    }\n}\n```"
    },
    {
        "func_name": "svstatus_print",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0008EB4C | 10 48 2D E9 | PUSH    {R4,R11,LR}\n0x0008EB50 | 08 B0 8D E2 | ADD     R11, SP, #8\n0x0008EB54 | 8C D0 4D E2 | SUB     SP, SP, #0x8C\n0x0008EB58 | 90 00 0B E5 | STR     R0, [R11,#m]\n0x0008EB5C | 00 30 A0 E3 | MOV     R3, #0\n0x0008EB60 | 10 30 0B E5 | STR     R3, [R11,#normallyup]\n0x0008EB64 | 8C 30 4B E2 | SUB     R3, R11, #-s\n0x0008EB68 | 03 10 A0 E1 | MOV     R1, R3; buf\n0x0008EB6C | C0 01 9F E5 | LDR     R0, =aDown_3; \"down\"\n0x0008EB70 | 7F 26 03 EB | BL      stat64_0\n0x0008EB74 | 00 30 A0 E1 | MOV     R3, R0\n0x0008EB78 | 01 00 73 E3 | CMN     R3, #1\n0x0008EB7C | 0E 00 00 1A | BNE     loc_8EBBC\n0x0008EB80 | B0 31 9F E5 | LDR     R3, =bb_errno\n0x0008EB84 | 00 30 93 E5 | LDR     R3, [R3]\n0x0008EB88 | 00 30 93 E5 | LDR     R3, [R3]\n0x0008EB8C | 02 00 53 E3 | CMP     R3, #2\n0x0008EB90 | 07 00 00 0A | BEQ     loc_8EBB4\n0x0008EB94 | A0 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008EB98 | 04 30 93 E5 | LDR     R3, [R3,#(unk_18F9DC - 0x18F9D8)]\n0x0008EB9C | 00 30 93 E5 | LDR     R3, [R3]\n0x0008EBA0 | 03 10 A0 E1 | MOV     R1, R3\n0x0008EBA4 | 94 01 9F E5 | LDR     R0, =aWarningCanTSta; \"warning: can't stat %s/down\"\n0x0008EBA8 | 36 27 FE EB | BL      bb_perror_msg\n0x0008EBAC | 00 30 A0 E3 | MOV     R3, #0\n0x0008EBB0 | 5C 00 00 EA | B       loc_8ED28\n0x0008EBB4 | 01 30 A0 E3 | MOV     R3, #1\n0x0008EBB8 | 10 30 0B E5 | STR     R3, [R11,#normallyup]\n0x0008EBBC | 78 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008EBC0 | 2C 30 93 E5 | LDR     R3, [R3,#(unk_18FA04 - 0x18F9D8)]\n0x0008EBC4 | 14 30 0B E5 | STR     R3, [R11,#pid]\n0x0008EBC8 | 6C 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008EBCC | 20 40 83 E2 | ADD     R4, R3, #0x20 ; ' '\n0x0008EBD0 | 18 00 94 E8 | LDM     R4, {R3,R4}\n0x0008EBD4 | 03 00 A0 E1 | MOV     R0, R3; x\n0x0008EBD8 | 04 10 A0 E1 | MOV     R1, R4; x\n0x0008EBDC | EA B5 02 EB | BL      bb_bswap_64\n0x0008EBE0 | 1C 00 0B E5 | STR     R0, [R11,#timestamp]\n0x0008EBE4 | 18 10 0B E5 | STR     R1, [R11,#timestamp+4]\n0x0008EBE8 | 14 30 1B E5 | LDR     R3, [R11,#pid]\n0x0008EBEC | 00 00 53 E3 | CMP     R3, #0\n0x0008EBF0 | 11 00 00 0A | BEQ     loc_8EC3C\n0x0008EBF4 | 40 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008EBF8 | 33 30 D3 E5 | LDRB    R3, [R3,#(unk_18FA0B - 0x18F9D8)]\n0x0008EBFC | 01 00 53 E3 | CMP     R3, #1\n0x0008EC00 | 02 00 00 0A | BEQ     loc_8EC10\n0x0008EC04 | 02 00 53 E3 | CMP     R3, #2\n0x0008EC08 | 03 00 00 0A | BEQ     loc_8EC1C\n0x0008EC0C | 05 00 00 EA | B       loc_8EC28\n0x0008EC10 | 2C 01 9F E5 | LDR     R0, =aRun_1; \"run: \"\n0x0008EC14 | 6F 18 FE EB | BL      printf\n0x0008EC18 | 02 00 00 EA | B       loc_8EC28\n0x0008EC1C | 24 01 9F E5 | LDR     R0, =aFinish_1; \"finish: \"\n0x0008EC20 | 6C 18 FE EB | BL      printf\n0x0008EC24 | 00 00 A0 E1 | NOP\n0x0008EC28 | 14 20 1B E5 | LDR     R2, [R11,#pid]\n0x0008EC2C | 90 10 1B E5 | LDR     R1, [R11,#m]\n0x0008EC30 | 14 01 9F E5 | LDR     R0, =aSPidD; \"%s: (pid %d) \"\n0x0008EC34 | 67 18 FE EB | BL      printf\n0x0008EC38 | 02 00 00 EA | B       loc_8EC48\n0x0008EC3C | 90 10 1B E5 | LDR     R1, [R11,#m]\n0x0008EC40 | 08 01 9F E5 | LDR     R0, =aDownS; \"down: %s: \"\n0x0008EC44 | 63 18 FE EB | BL      printf\n0x0008EC48 | EC 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008EC4C | 18 40 83 E2 | ADD     R4, R3, #0x18\n0x0008EC50 | 18 00 94 E8 | LDM     R4, {R3,R4}\n0x0008EC54 | 03 20 A0 E1 | MOV     R2, R3\n0x0008EC58 | 1C 30 1B E5 | LDR     R3, [R11,#timestamp]\n0x0008EC5C | 03 30 42 E0 | SUB     R3, R2, R3\n0x0008EC60 | 20 30 0B E5 | STR     R3, [R11,#diff]\n0x0008EC64 | 20 30 1B E5 | LDR     R3, [R11,#diff]\n0x0008EC68 | C3 3F C3 E1 | BIC     R3, R3, R3,ASR#31\n0x0008EC6C | 03 10 A0 E1 | MOV     R1, R3\n0x0008EC70 | DC 00 9F E5 | LDR     R0, =aUs; \"%us\"\n0x0008EC74 | 57 18 FE EB | BL      printf\n0x0008EC78 | 14 30 1B E5 | LDR     R3, [R11,#pid]\n0x0008EC7C | 00 00 53 E3 | CMP     R3, #0\n0x0008EC80 | 17 00 00 0A | BEQ     loc_8ECE4\n0x0008EC84 | 10 30 1B E5 | LDR     R3, [R11,#normallyup]\n0x0008EC88 | 00 00 53 E3 | CMP     R3, #0\n0x0008EC8C | 01 00 00 1A | BNE     loc_8EC98\n0x0008EC90 | C0 00 9F E5 | LDR     R0, =aNormallyDown; \", normally down\"\n0x0008EC94 | 4F 18 FE EB | BL      printf\n0x0008EC98 | 9C 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008EC9C | 30 30 D3 E5 | LDRB    R3, [R3,#(word_18FA08 - 0x18F9D8)]\n0x0008ECA0 | 00 00 53 E3 | CMP     R3, #0\n0x0008ECA4 | 01 00 00 0A | BEQ     loc_8ECB0\n0x0008ECA8 | AC 00 9F E5 | LDR     R0, =aPaused_0; \", paused\"\n0x0008ECAC | 49 18 FE EB | BL      printf\n0x0008ECB0 | 84 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008ECB4 | 31 30 D3 E5 | LDRB    R3, [R3,#(word_18FA08+1 - 0x18F9D8)]\n0x0008ECB8 | 64 00 53 E3 | CMP     R3, #0x64 ; 'd'\n0x0008ECBC | 01 00 00 1A | BNE     loc_8ECC8\n0x0008ECC0 | 98 00 9F E5 | LDR     R0, =aWantDown_0; \", want down\"\n0x0008ECC4 | 43 18 FE EB | BL      printf\n0x0008ECC8 | 6C 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008ECCC | 32 30 D3 E5 | LDRB    R3, [R3,#(unk_18FA0A - 0x18F9D8)]\n0x0008ECD0 | 00 00 53 E3 | CMP     R3, #0\n0x0008ECD4 | 0D 00 00 0A | BEQ     loc_8ED10\n0x0008ECD8 | 84 00 9F E5 | LDR     R0, =aGotTerm_0; \", got TERM\"\n0x0008ECDC | 3D 18 FE EB | BL      printf\n0x0008ECE0 | 0A 00 00 EA | B       loc_8ED10\n0x0008ECE4 | 10 30 1B E5 | LDR     R3, [R11,#normallyup]\n0x0008ECE8 | 00 00 53 E3 | CMP     R3, #0\n0x0008ECEC | 01 00 00 0A | BEQ     loc_8ECF8\n0x0008ECF0 | 70 00 9F E5 | LDR     R0, =aNormallyUp; \", normally up\"\n0x0008ECF4 | 37 18 FE EB | BL      printf\n0x0008ECF8 | 3C 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008ECFC | 31 30 D3 E5 | LDRB    R3, [R3,#(word_18FA08+1 - 0x18F9D8)]\n0x0008ED00 | 75 00 53 E3 | CMP     R3, #0x75 ; 'u'\n0x0008ED04 | 01 00 00 1A | BNE     loc_8ED10\n0x0008ED08 | 5C 00 9F E5 | LDR     R0, =aWantUp; \", want up\"\n0x0008ED0C | 31 18 FE EB | BL      printf\n0x0008ED10 | 14 30 1B E5 | LDR     R3, [R11,#pid]\n0x0008ED14 | 00 00 53 E3 | CMP     R3, #0\n0x0008ED18 | 01 00 00 0A | BEQ     loc_8ED24\n0x0008ED1C | 01 30 A0 E3 | MOV     R3, #1\n0x0008ED20 | 00 00 00 EA | B       loc_8ED28\n0x0008ED24 | 02 30 A0 E3 | MOV     R3, #2\n0x0008ED28 | 03 00 A0 E1 | MOV     R0, R3\n0x0008ED2C | 08 D0 4B E2 | SUB     SP, R11, #8\n0x0008ED30 | 10 88 BD E8 | POP     {R4,R11,PC}",
        "output": "```c\nvoid function() {\n    int m;\n    int normallyup;\n    int s;\n    int pid;\n    int timestamp;\n    int diff;\n\n    // Save registers\n    __asm__(\"PUSH {R4,R11,LR}\");\n\n    // Set up stack frame\n    __asm__(\"ADD R11, SP, #8\");\n\n    // Allocate space on the stack\n    __asm__(\"SUB SP, SP, #0x8C\");\n\n    // Store R0 in m\n    __asm__(\"STR R0, [R11,#m]\");\n\n    // Set R3 to 0\n    __asm__(\"MOV R3, #0\");\n\n    // Store 0 in normallyup\n    __asm__(\"STR R3, [R11,#normallyup]\");\n\n    // Calculate R3 = R11 - s\n    __asm__(\"SUB R3, R11, #-s\");\n\n    // Set R1 to R3 (buf)\n    __asm__(\"MOV R1, R3\");\n\n    // Load \"down\" into R0\n    __asm__(\"LDR R0, =aDown_3\");\n\n    // Call stat64_0\n    __asm__(\"BL stat64_0\");\n\n    // Store R0 in R3\n    __asm__(\"MOV R3, R0\");\n\n    // Compare R3 with 1\n    __asm__(\"CMN R3, #1\");\n\n    // Branch if not equal to loc_8EBBC\n    __asm__(\"BNE loc_8EBBC\");\n\n    // Load bb_errno into R3\n    __asm__(\"LDR R3, =bb_errno\");\n\n    // Load [R3] into R3\n    __asm__(\"LDR R3, [R3]\");\n\n    // Load [R3] into R3\n    __asm__(\"LDR R3, [R3]\");\n\n    // Compare R3 with 2\n    __asm__(\"CMP R3, #2\");\n\n    // Branch if equal to loc_8EBB4\n    __asm__(\"BEQ loc_8EBB4\");\n\n    // Load bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Load [R3, #(unk_18F9DC - 0x18F9D8)] into R3\n    __asm__(\"LDR R3, [R3,#(unk_18F9DC - 0x18F9D8)]\");\n\n    // Load [R3] into R3\n    __asm__(\"LDR R3, [R3]\");\n\n    // Set R1 to R3\n    __asm__(\"MOV R1, R3\");\n\n    // Load \"warning: can't stat %s/down\" into R0\n    __asm__(\"LDR R0, =aWarningCanTSta\");\n\n    // Call bb_perror_msg\n    __asm__(\"BL bb_perror_msg\");\n\n    // Set R3 to 0\n    __asm__(\"MOV R3, #0\");\n\n    // Branch to loc_8ED28\n    __asm__(\"B loc_8ED28\");\n\nloc_8EBBC:\n    // Set R3 to 1\n    __asm__(\"MOV R3, #1\");\n\n    // Store 1 in normallyup\n    __asm__(\"STR R3, [R11,#normallyup]\");\n\nloc_8EBB4:\n    // Load bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Load [R3, #(unk_18FA04 - 0x18F9D8)] into R3\n    __asm__(\"LDR R3, [R3,#(unk_18FA04 - 0x18F9D8)]\");\n\n    // Store R3 in pid\n    __asm__(\"STR R3, [R11,#pid]\");\n\n    // Load bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Add 0x20 to R3\n    __asm__(\"ADD R4, R3, #0x20\");\n\n    // Load [R4] into R3 and R4\n    __asm__(\"LDM R4, {R3,R4}\");\n\n    // Set R0 to R3 (x)\n    __asm__(\"MOV R0, R3\");\n\n    // Set R1 to R4 (x)\n    __asm__(\"MOV R1, R4\");\n\n    // Call bb_bswap_64\n    __asm__(\"BL bb_bswap_64\");\n\n    // Store R0 in timestamp\n    __asm__(\"STR R0, [R11,#timestamp]\");\n\n    // Store R1 in timestamp+4\n    __asm__(\"STR R1, [R11,#timestamp+4]\");\n\n    // Load [R11,#pid] into R3\n    __asm__(\"LDR R3, [R11,#pid]\");\n\n    // Compare R3 with 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch if equal to loc_8EC3C\n    __asm__(\"BEQ loc_8EC3C\");\n\n    // Load bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Load [R3,#(unk_18FA0B - 0x18F9D8)] into R3\n    __asm__(\"LDRB R3, [R3,#(unk_18FA0B - 0x18F9D8)]\");\n\n    // Compare R3 with 1\n    __asm__(\"CMP R3, #1\");\n\n    // Branch if equal to loc_8EC10\n    __asm__(\"BEQ loc_8EC10\");\n\n    // Compare R3 with 2\n    __asm__(\"CMP R3, #2\");\n\n    // Branch if equal to loc_8EC1C\n    __asm__(\"BEQ loc_8EC1C\");\n\n    // Branch to loc_8EC28\n    __asm__(\"B loc_8EC28\");\n\nloc_8EC10:\n    // Load \"run: \" into R0\n    __asm__(\"LDR R0, =aRun_1\");\n\n    // Call printf\n    __asm__(\"BL printf\");\n\n    // Branch to loc_8EC28\n    __asm__(\"B loc_8EC28\");\n\nloc_8EC1C:\n    // Load \"finish: \" into R0\n    __asm__(\"LDR R0, =aFinish_1\");\n\n    // Call printf\n    __asm__(\"BL printf\");\n\n    // No operation\n    __asm__(\"NOP\");\n\nloc_8EC28:\n    // Load [R11,#pid] into R2\n    __asm__(\"LDR R2, [R11,#pid]\");\n\n    // Load [R11,#m] into R1\n    __asm__(\"LDR R1, [R11,#m]\");\n\n    // Load \"%s: (pid %d) \" into R0\n    __asm__(\"LDR R0, =aSPidD\");\n\n    // Call printf\n    __asm__(\"BL printf\");\n\n    // Branch to loc_8EC48\n    __asm__(\"B loc_8EC48\");\n\nloc_8EC3C:\n    // Load [R11,#m] into R1\n    __asm__(\"LDR R1, [R11,#m]\");\n\n    // Load \"down: %s: \" into R0\n    __asm__(\"LDR R0, =aDownS\");\n\n    // Call printf\n    __asm__(\"BL printf\");\n\nloc_8EC48:\n    // Load bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Add 0x18 to R3\n    __asm__(\"ADD R4, R3, #0x18\");\n\n    // Load [R4] into R3 and R4\n    __asm__(\"LDM R4, {R3,R4}\");\n\n    // Set R2 to R3\n    __asm__(\"MOV R2, R3\");\n\n    // Load [R11,#timestamp] into R3\n    __asm__(\"LDR R3, [R11,#timestamp]\");\n\n    // Subtract R3 from R2 and store in R3\n    __asm__(\"SUB R3, R2, R3\");\n\n    // Store R3 in diff\n    __asm__(\"STR R3, [R11,#diff]\");\n\n    // Load [R11,#diff] into R3\n    __asm__(\"LDR R3, [R11,#diff]\");\n\n    // Clear the sign bit of R3\n    __asm__(\"BIC R3, R3, R3,ASR#31\");\n\n    // Set R1 to R3\n    __asm__(\"MOV R1, R3\");\n\n    // Load \"%us\" into R0\n    __asm__(\"LDR R0, =aUs\");\n\n    // Call printf\n    __asm__(\"BL printf\");\n\n    // Load [R11,#pid] into R3\n    __asm__(\"LDR R3, [R11,#pid]\");\n\n    // Compare R3 with 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch if equal to loc_8ECE4\n    __asm__(\"BEQ loc_8ECE4\");\n\n    // Load bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Load [R3,#(word_18FA08 - 0x18F9D8)] into R3\n    __asm__(\"LDRB R3, [R3,#(word_18FA08 - 0x18F9D8)]\");\n\n    // Compare R3 with 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch if equal to loc_8ECB0\n    __asm__(\"BEQ loc_8ECB0\");\n\n    // Load \"paused\" into R0\n    __asm__(\"LDR R0, =aPaused_0\");\n\n    // Call printf\n    __asm__(\"BL printf\");\n\nloc_8ECB0:\n    // Load bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Load [R3,#(unk_18FA0A - 0x18F9D8)] into R3\n    __asm__(\"LDRB R3, [R3,#(unk_18FA0A - 0x18F9D8)]\");\n\n    // Compare R3 with 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch if equal to loc_8ED10\n    __asm__(\"BEQ loc_8ED10\");\n\n    // Load \"got TERM\" into R0\n    __asm__(\"LDR R0, =aGotTerm_0\");\n\n    // Call printf\n    __asm__(\"BL printf\");\n\n    // Branch to loc_8ED10\n    __asm__(\"B loc_8ED10\");\n\nloc_8ECE4:\n    // Load [R11,#normallyup] into R3\n    __asm__(\"LDR R3, [R11,#normallyup]\");\n\n    // Compare R3 with 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch if equal to loc_8ECF8\n    __asm__(\"BEQ loc_8ECF8\");\n\n    // Load \"normally up\" into R0\n    __asm__(\"LDR R0, =aNormallyUp\");\n\n    // Call printf\n    __asm__(\"BL printf\");\n\nloc_8ECF8:\n    // Load bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n\n    // Load [R3,#(word_18FA08+1 - 0x18F9D8)] into R3\n    __asm__(\"LDRB R3, [R3,#(word_18FA08+1 - 0x18F9D8)]\");\n\n    // Compare R3 with 0x75 ('u')\n    __asm__(\"CMP R3, #0x75\");\n\n    // Branch if equal to loc_8ED10\n    __asm__(\"BNE loc_8ED10\");\n\n    // Load \"want up\" into R0\n    __asm__(\"LDR R0, =aWantUp\");\n\n    // Call printf\n    __asm__(\"BL printf\");\n\nloc_8ED10:\n    // Load [R11,#pid] into R3\n    __asm__(\"LDR R3, [R11,#pid]\");\n\n    // Compare R3 with 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch if equal to loc_8ED24\n    __asm__(\"BEQ loc_8ED24\");\n\n    // Set R3 to 1\n    __asm__(\"MOV R3, #1\");\n\nloc_8ED28:\n    // Set R0 to R3\n    __asm__(\"MOV R0, R3\");\n\n    // Clean up stack frame\n    __asm__(\"SUB SP, R11, #8\");\n\n    // Restore registers\n    __asm__(\"POP {R4,R11,PC}\");\n}\n```"
    },
    {
        "func_name": "varcmp",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000948F8 | 04 B0 2D E5 | PUSH    {R11}\n0x000948FC | 00 B0 8D E2 | ADD     R11, SP, #0\n0x00094900 | 14 D0 4D E2 | SUB     SP, SP, #0x14\n0x00094904 | 10 00 0B E5 | STR     R0, [R11,#p]\n0x00094908 | 14 10 0B E5 | STR     R1, [R11,#q]\n0x0009490C | 0B 00 00 EA | B       loc_94940\n0x00094910 | 08 30 1B E5 | LDR     R3, [R11,#c]\n0x00094914 | 00 00 53 E3 | CMP     R3, #0\n0x00094918 | 1D 00 00 0A | BEQ     loc_94994\n0x0009491C | 08 30 1B E5 | LDR     R3, [R11,#c]\n0x00094920 | 3D 00 53 E3 | CMP     R3, #0x3D ; '='\n0x00094924 | 1A 00 00 0A | BEQ     loc_94994\n0x00094928 | 10 30 1B E5 | LDR     R3, [R11,#p]\n0x0009492C | 01 30 83 E2 | ADD     R3, R3, #1\n0x00094930 | 10 30 0B E5 | STR     R3, [R11,#p]\n0x00094934 | 14 30 1B E5 | LDR     R3, [R11,#q]\n0x00094938 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0009493C | 14 30 0B E5 | STR     R3, [R11,#q]\n0x00094940 | 10 30 1B E5 | LDR     R3, [R11,#p]\n0x00094944 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x00094948 | 08 30 0B E5 | STR     R3, [R11,#c]\n0x0009494C | 14 30 1B E5 | LDR     R3, [R11,#q]\n0x00094950 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x00094954 | 0C 30 0B E5 | STR     R3, [R11,#d]\n0x00094958 | 08 20 1B E5 | LDR     R2, [R11,#c]\n0x0009495C | 0C 30 1B E5 | LDR     R3, [R11,#d]\n0x00094960 | 03 00 52 E1 | CMP     R2, R3\n0x00094964 | E9 FF FF 0A | BEQ     loc_94910\n0x00094968 | 08 30 1B E5 | LDR     R3, [R11,#c]\n0x0009496C | 3D 00 53 E3 | CMP     R3, #0x3D ; '='\n0x00094970 | 01 00 00 1A | BNE     loc_9497C\n0x00094974 | 00 30 A0 E3 | MOV     R3, #0\n0x00094978 | 08 30 0B E5 | STR     R3, [R11,#c]\n0x0009497C | 0C 30 1B E5 | LDR     R3, [R11,#d]\n0x00094980 | 3D 00 53 E3 | CMP     R3, #0x3D ; '='\n0x00094984 | 04 00 00 1A | BNE     loc_9499C\n0x00094988 | 00 30 A0 E3 | MOV     R3, #0\n0x0009498C | 0C 30 0B E5 | STR     R3, [R11,#d]\n0x00094990 | 02 00 00 EA | B       out\n0x00094994 | 00 00 A0 E1 | NOP\n0x00094998 | 00 00 00 EA | B       out\n0x0009499C | 00 00 A0 E1 | NOP\n0x000949A0 | 08 20 1B E5 | LDR     R2, [R11,#c]\n0x000949A4 | 0C 30 1B E5 | LDR     R3, [R11,#d]\n0x000949A8 | 03 30 42 E0 | SUB     R3, R2, R3\n0x000949AC | 03 00 A0 E1 | MOV     R0, R3\n0x000949B0 | 00 D0 8B E2 | MOV     SP, R11\n0x000949B4 | 04 B0 9D E4 | POP     {R11}\n0x000949B8 | 1E FF 2F E1 | BX      LR",
        "output": "```c\nvoid function(int p, int q) {\n    int c = 0;\n    int d = 0;\n    \n    if (p == 0 || p == 0x3D) {\n        c = 0;\n    }\n    \n    if (q == 0 || q == 0x3D) {\n        d = 0;\n    }\n    \n    while (1) {\n        if (c == q) {\n            break;\n        }\n        \n        c++;\n        d++;\n        \n        if (c == 0x3D) {\n            c = 0;\n        }\n        \n        if (d == 0x3D) {\n            d = 0;\n        }\n    }\n    \n    int result = c - d;\n}\n```"
    },
    {
        "func_name": "initialize_group_array",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x001156B0 | 10 48 2D E9 | PUSH    {R4,R11,LR}\n0x001156B4 | 08 B0 8D E2 | ADD     R11, SP, #8\n0x001156B8 | 0C D0 4D E2 | SUB     SP, SP, #0xC\n0x001156BC | 90 30 9F E5 | LDR     R3, =test_ptr_to_statics\n0x001156C0 | 00 30 93 E5 | LDR     R3, [R3]\n0x001156C4 | 20 20 A0 E3 | MOV     R2, #0x20 ; ' '\n0x001156C8 | 0C 20 83 E5 | STR     R2, [R3,#0xC]\n0x001156CC | 80 30 9F E5 | LDR     R3, =test_ptr_to_statics\n0x001156D0 | 00 30 93 E5 | LDR     R3, [R3]\n0x001156D4 | 0C 30 93 E5 | LDR     R3, [R3,#0xC]\n0x001156D8 | 10 30 0B E5 | STR     R3, [R11,#n]\n0x001156DC | 70 30 9F E5 | LDR     R3, =test_ptr_to_statics\n0x001156E0 | 00 30 93 E5 | LDR     R3, [R3]\n0x001156E4 | 08 20 93 E5 | LDR     R2, [R3,#8]\n0x001156E8 | 10 30 1B E5 | LDR     R3, [R11,#n]\n0x001156EC | 03 11 A0 E1 | MOV     R1, R3,LSL#2; size\n0x001156F0 | 5C 30 9F E5 | LDR     R3, =test_ptr_to_statics\n0x001156F4 | 00 40 93 E5 | LDR     R4, [R3]\n0x001156F8 | 02 00 A0 E1 | MOV     R0, R2; ptr\n0x001156FC | F4 10 FC EB | BL      xrealloc\n0x00115700 | 00 30 A0 E1 | MOV     R3, R0\n0x00115704 | 08 30 84 E5 | STR     R3, [R4,#8]\n0x00115708 | 44 30 9F E5 | LDR     R3, =test_ptr_to_statics\n0x0011570C | 00 30 93 E5 | LDR     R3, [R3]\n0x00115710 | 08 20 93 E5 | LDR     R2, [R3,#8]\n0x00115714 | 38 30 9F E5 | LDR     R3, =test_ptr_to_statics\n0x00115718 | 00 40 93 E5 | LDR     R4, [R3]\n0x0011571C | 02 10 A0 E1 | MOV     R1, R2; list\n0x00115720 | 10 00 1B E5 | LDR     R0, [R11,#n]; size\n0x00115724 | F3 00 FC EB | BL      getgroups\n0x00115728 | 00 30 A0 E1 | MOV     R3, R0\n0x0011572C | 0C 30 84 E5 | STR     R3, [R4,#0xC]\n0x00115730 | 1C 30 9F E5 | LDR     R3, =test_ptr_to_statics\n0x00115734 | 00 30 93 E5 | LDR     R3, [R3]\n0x00115738 | 0C 30 93 E5 | LDR     R3, [R3,#0xC]\n0x0011573C | 10 20 1B E5 | LDR     R2, [R11,#n]\n0x00115740 | 03 00 52 E1 | CMP     R2, R3\n0x00115744 | E0 FF FF BA | BLT     loc_1156CC\n0x00115748 | 00 00 A0 E1 | NOP\n0x0011574C | 08 D0 4B E2 | SUB     SP, R11, #8\n0x00115750 | 10 88 BD E8 | POP     {R4,R11,PC}",
        "output": "```c\nvoid function() {\n    int* test_ptr_to_statics;\n    int n;\n    \n    // Save registers\n    __asm__(\"PUSH {R4,R11,LR}\");\n    \n    // Set up stack frame\n    __asm__(\"ADD R11, SP, #8\");\n    __asm__(\"SUB SP, SP, #0xC\");\n    \n    // Load address of test_ptr_to_statics into R3\n    __asm__(\"LDR R3, =test_ptr_to_statics\");\n    \n    // Load value at address stored in R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n    \n    // Set R2 to 0x20\n    __asm__(\"MOV R2, #0x20\");\n    \n    // Store R2 at offset 0xC from the address stored in R3\n    __asm__(\"STR R2, [R3,#0xC]\");\n    \n    // Load address of test_ptr_to_statics into R3\n    __asm__(\"LDR R3, =test_ptr_to_statics\");\n    \n    // Load value at address stored in R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n    \n    // Load value at offset 0xC from the address stored in R3 into R3\n    __asm__(\"LDR R3, [R3,#0xC]\");\n    \n    // Store R3 at offset n from R11\n    __asm__(\"STR R3, [R11,#n]\");\n    \n    // Load address of test_ptr_to_statics into R3\n    __asm__(\"LDR R3, =test_ptr_to_statics\");\n    \n    // Load value at address stored in R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n    \n    // Load value at offset 8 from the address stored in R3 into R2\n    __asm__(\"LDR R2, [R3,#8]\");\n    \n    // Load value at offset n from R11 into R3\n    __asm__(\"LDR R3, [R11,#n]\");\n    \n    // Set R1 to R3 shifted left by 2\n    __asm__(\"MOV R1, R3,LSL#2\");\n    \n    // Load address of test_ptr_to_statics into R3\n    __asm__(\"LDR R3, =test_ptr_to_statics\");\n    \n    // Load value at address stored in R3 into R4\n    __asm__(\"LDR R4, [R3]\");\n    \n    // Set R0 to R2\n    __asm__(\"MOV R0, R2\");\n    \n    // Call xrealloc\n    __asm__(\"BL xrealloc\");\n    \n    // Store return value in R3\n    __asm__(\"MOV R3, R0\");\n    \n    // Store R3 at offset 8 from the address stored in R4\n    __asm__(\"STR R3, [R4,#8]\");\n    \n    // Load address of test_ptr_to_statics into R3\n    __asm__(\"LDR R3, =test_ptr_to_statics\");\n    \n    // Load value at address stored in R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n    \n    // Load value at offset 8 from the address stored in R3 into R2\n    __asm__(\"LDR R2, [R3,#8]\");\n    \n    // Load address of test_ptr_to_statics into R3\n    __asm__(\"LDR R3, =test_ptr_to_statics\");\n    \n    // Load value at address stored in R3 into R4\n    __asm__(\"LDR R4, [R3]\");\n    \n    // Set R1 to R2\n    __asm__(\"MOV R1, R2\");\n    \n    // Load value at offset n from R11 into R0\n    __asm__(\"LDR R0, [R11,#n]\");\n    \n    // Call getgroups\n    __asm__(\"BL getgroups\");\n    \n    // Store return value in R3\n    __asm__(\"MOV R3, R0\");\n    \n    // Store R3 at offset 0xC from the address stored in R4\n    __asm__(\"STR R3, [R4,#0xC]\");\n    \n    // Load address of test_ptr_to_statics into R3\n    __asm__(\"LDR R3, =test_ptr_to_statics\");\n    \n    // Load value at address stored in R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n    \n    // Load value at offset 0xC from the address stored in R3 into R3\n    __asm__(\"LDR R3, [R3,#0xC]\");\n    \n    // Load value at offset n from R11 into R2\n    __asm__(\"LDR R2, [R11,#n]\");\n    \n    // Compare R2 and R3\n    __asm__(\"CMP R2, R3\");\n    \n    // Branch to loc_1156CC if R2 is less than R3\n    __asm__(\"BLT loc_1156CC\");\n    \n    // No operation\n    __asm__(\"NOP\");\n    \n    // Clean up stack frame\n    __asm__(\"SUB SP, R11, #8\");\n    \n    // Restore registers and return\n    __asm__(\"POP {R4,R11,PC}\");\n}\n```"
    },
    {
        "func_name": "header_verbose_list",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000FB3D8 | F0 48 2D E9 | PUSH    {R4-R7,R11,LR}\n0x000FB3DC | 14 B0 8D E2 | ADD     R11, SP, #0x14\n0x000FB3E0 | 78 D0 4D E2 | SUB     SP, SP, #0x78\n0x000FB3E4 | 60 00 0B E5 | STR     R0, [R11,#file_header]\n0x000FB3E8 | 4C 30 4B E2 | SUB     R3, R11, #-tm_time\n0x000FB3EC | 20 30 0B E5 | STR     R3, [R11,#ptm]\n0x000FB3F0 | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB3F4 | 24 30 83 E2 | ADD     R3, R3, #0x24 ; '$'\n0x000FB3F8 | 20 10 1B E5 | LDR     R1, [R11,#ptm]; tp\n0x000FB3FC | 03 00 A0 E1 | MOV     R0, R3; timer\n0x000FB400 | 4F 67 FC EB | BL      localtime_r\n0x000FB404 | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB408 | 08 30 93 E5 | LDR     R3, [R3,#8]\n0x000FB40C | 18 30 0B E5 | STR     R3, [R11,#user]\n0x000FB410 | 18 30 1B E5 | LDR     R3, [R11,#user]\n0x000FB414 | 00 00 53 E3 | CMP     R3, #0\n0x000FB418 | 07 00 00 1A | BNE     loc_FB43C\n0x000FB41C | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB420 | 18 20 93 E5 | LDR     R2, [R3,#0x18]\n0x000FB424 | 5C 30 4B E2 | SUB     R3, R11, #-uid\n0x000FB428 | 08 11 9F E5 | LDR     R1, =aU_22; \"%u\"\n0x000FB42C | 03 00 A0 E1 | MOV     R0, R3; s\n0x000FB430 | A1 69 FC EB | BL      sprintf\n0x000FB434 | 5C 30 4B E2 | SUB     R3, R11, #-uid\n0x000FB438 | 18 30 0B E5 | STR     R3, [R11,#user]\n0x000FB43C | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB440 | 0C 30 93 E5 | LDR     R3, [R3,#0xC]\n0x000FB444 | 1C 30 0B E5 | STR     R3, [R11,#group]\n0x000FB448 | 1C 30 1B E5 | LDR     R3, [R11,#group]\n0x000FB44C | 00 00 53 E3 | CMP     R3, #0\n0x000FB450 | 04 00 00 1A | BNE     loc_FB468\n0x000FB454 | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB458 | 1C 30 93 E5 | LDR     R3, [R3,#0x1C]\n0x000FB45C | 03 00 A0 E1 | MOV     R0, R3; n\n0x000FB460 | A9 77 FC EB | BL      utoa\n0x000FB464 | 1C 00 0B E5 | STR     R0, [R11,#group]\n0x000FB468 | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB46C | 20 30 93 E5 | LDR     R3, [R3,#0x20]\n0x000FB470 | 03 00 A0 E1 | MOV     R0, R3; mode\n0x000FB474 | 20 3E 01 EB | BL      bb_mode_string\n0x000FB478 | 00 70 A0 E1 | MOV     R7, R0\n0x000FB47C | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB480 | 10 20 83 E2 | ADD     R2, R3, #0x10\n0x000FB484 | 06 00 92 E8 | LDM     R2, {R1,R2}\n0x000FB488 | 20 30 1B E5 | LDR     R3, [R11,#ptm]\n0x000FB48C | 14 30 93 E5 | LDR     R3, [R3,#0x14]\n0x000FB490 | 76 3E 83 E2 | ADD     R3, R3, #0x760\n0x000FB494 | 0C 30 83 E2 | ADD     R3, R3, #0xC\n0x000FB498 | 20 00 1B E5 | LDR     R0, [R11,#ptm]\n0x000FB49C | 10 00 90 E5 | LDR     R0, [R0,#0x10]\n0x000FB4A0 | 01 00 80 E2 | ADD     R0, R0, #1\n0x000FB4A4 | 20 C0 1B E5 | LDR     R12, [R11,#ptm]\n0x000FB4A8 | 0C C0 9C E5 | LDR     R12, [R12,#0xC]\n0x000FB4AC | 20 E0 1B E5 | LDR     LR, [R11,#ptm]\n0x000FB4B0 | 08 E0 9E E5 | LDR     LR, [LR,#8]\n0x000FB4B4 | 20 40 1B E5 | LDR     R4, [R11,#ptm]\n0x000FB4B8 | 04 40 94 E5 | LDR     R4, [R4,#4]\n0x000FB4BC | 20 50 1B E5 | LDR     R5, [R11,#ptm]\n0x000FB4C0 | 00 50 95 E5 | LDR     R5, [R5]\n0x000FB4C4 | 60 60 1B E5 | LDR     R6, [R11,#file_header]\n0x000FB4C8 | 00 60 96 E5 | LDR     R6, [R6]\n0x000FB4CC | 20 60 8D E5 | STR     R6, [SP,#0x8C+var_6C]\n0x000FB4D0 | 1C 50 8D E5 | STR     R5, [SP,#0x8C+var_70]\n0x000FB4D4 | 18 40 8D E5 | STR     R4, [SP,#0x8C+var_74]\n0x000FB4D8 | 14 E0 8D E5 | STR     LR, [SP,#0x8C+var_78]\n0x000FB4DC | 10 C0 8D E5 | STR     R12, [SP,#0x8C+var_7C]\n0x000FB4E0 | 0C 00 8D E5 | STR     R0, [SP,#0x8C+var_80]\n0x000FB4E4 | 08 30 8D E5 | STR     R3, [SP,#0x8C+var_84]\n0x000FB4E8 | 06 00 8D E8 | STMEA   SP, {R1,R2}\n0x000FB4EC | 1C 30 1B E5 | LDR     R3, [R11,#group]\n0x000FB4F0 | 18 20 1B E5 | LDR     R2, [R11,#user]\n0x000FB4F4 | 07 10 A0 E1 | MOV     R1, R7\n0x000FB4F8 | 3C 00 9F E5 | LDR     R0, =aSSS9llu4u02u02; \"%s %s/%s %9llu %4u-%02u-%02u %02u:%02u:\"...\n0x000FB4FC | 35 66 FC EB | BL      printf\n0x000FB500 | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB504 | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000FB508 | 00 00 53 E3 | CMP     R3, #0\n0x000FB50C | 04 00 00 0A | BEQ     loc_FB524\n0x000FB510 | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB514 | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000FB518 | 03 10 A0 E1 | MOV     R1, R3\n0x000FB51C | 1C 00 9F E5 | LDR     R0, =aS_90; \" -> %s\"\n0x000FB520 | 2C 66 FC EB | BL      printf\n0x000FB524 | 0A 00 A0 E3 | MOV     R0, #0xA; ch\n0x000FB528 | 40 7B FC EB | BL      bb_putchar\n0x000FB52C | 00 00 A0 E1 | NOP\n0x000FB530 | 14 D0 4B E2 | SUB     SP, R11, #0x14\n0x000FB534 | F0 88 BD E8 | POP     {R4-R7,R11,PC}",
        "output": "```c\nvoid function() {\n    // Save registers\n    __asm__(\"PUSH    {R4-R7,R11,LR}\");\n    \n    // Set up stack frame\n    __asm__(\"ADD     R11, SP, #0x14\");\n    __asm__(\"SUB     SP, SP, #0x78\");\n    \n    // Store R0 in file_header\n    __asm__(\"STR     R0, [R11,#file_header]\");\n    \n    // Calculate address of ptm\n    __asm__(\"SUB     R3, R11, #-tm_time\");\n    __asm__(\"STR     R3, [R11,#ptm]\");\n    \n    // Load file_header into R3\n    __asm__(\"LDR     R3, [R11,#file_header]\");\n    \n    // Add offset to R3\n    __asm__(\"ADD     R3, R3, #0x24\");\n    \n    // Load ptm into R1\n    __asm__(\"LDR     R1, [R11,#ptm]\");\n    \n    // Move R3 to R0\n    __asm__(\"MOV     R0, R3\");\n    \n    // Call localtime_r\n    __asm__(\"BL      localtime_r\");\n    \n    // Load file_header into R3\n    __asm__(\"LDR     R3, [R11,#file_header]\");\n    \n    // Load value at offset 8 into R3\n    __asm__(\"LDR     R3, [R3,#8]\");\n    \n    // Store R3 in user\n    __asm__(\"STR     R3, [R11,#user]\");\n    \n    // Load value at user into R3\n    __asm__(\"LDR     R3, [R11,#user]\");\n    \n    // Compare R3 with 0\n    __asm__(\"CMP     R3, #0\");\n    \n    // Branch if not equal to loc_FB43C\n    __asm__(\"BNE     loc_FB43C\");\n    \n    // Load file_header into R3\n    __asm__(\"LDR     R3, [R11,#file_header]\");\n    \n    // Load value at offset 0x18 into R2\n    __asm__(\"LDR     R2, [R3,#0x18]\");\n    \n    // Calculate address of uid\n    __asm__(\"SUB     R3, R11, #-uid\");\n    \n    // Load address of aU_22 into R1\n    __asm__(\"LDR     R1, =aU_22\");\n    \n    // Move R3 to R0\n    __asm__(\"MOV     R0, R3\");\n    \n    // Call sprintf\n    __asm__(\"BL      sprintf\");\n    \n    // Calculate address of uid\n    __asm__(\"SUB     R3, R11, #-uid\");\n    \n    // Store R3 in user\n    __asm__(\"STR     R3, [R11,#user]\");\n    \n    // Load file_header into R3\n    __asm__(\"LDR     R3, [R11,#file_header]\");\n    \n    // Load value at offset 0xC into R3\n    __asm__(\"LDR     R3, [R3,#0xC]\");\n    \n    // Store R3 in group\n    __asm__(\"STR     R3, [R11,#group]\");\n    \n    // Load value at group into R3\n    __asm__(\"LDR     R3, [R11,#group]\");\n    \n    // Compare R3 with 0\n    __asm__(\"CMP     R3, #0\");\n    \n    // Branch if not equal to loc_FB468\n    __asm__(\"BNE     loc_FB468\");\n    \n    // Load file_header into R3\n    __asm__(\"LDR     R3, [R11,#file_header]\");\n    \n    // Load value at offset 0x1C into R3\n    __asm__(\"LDR     R3, [R3,#0x1C]\");\n    \n    // Move R3 to R0\n    __asm__(\"MOV     R0, R3\");\n    \n    // Call utoa\n    __asm__(\"BL      utoa\");\n    \n    // Store R0 in group\n    __asm__(\"STR     R0, [R11,#group]\");\n    \n    // Load file_header into R3\n    __asm__(\"LDR     R3, [R11,#file_header]\");\n    \n    // Load value at offset 0x20 into R3\n    __asm__(\"LDR     R3, [R3,#0x20]\");\n    \n    // Move R3 to R0\n    __asm__(\"MOV     R0, R3\");\n    \n    // Call bb_mode_string\n    __asm__(\"BL      bb_mode_string\");\n    \n    // Move return value to R7\n    __asm__(\"MOV     R7, R0\");\n    \n    // Load file_header into R3\n    __asm__(\"LDR     R3, [R11,#file_header]\");\n    \n    // Add offset to R3\n    __asm__(\"ADD     R2, R3, #0x10\");\n    \n    // Load values from R2 into R1 and R2\n    __asm__(\"LDM     R2, {R1,R2}\");\n    \n    // Load value at offset 0x14 into R3\n    __asm__(\"LDR     R3, [R11,#ptm]\");\n    __asm__(\"LDR     R3, [R3,#0x14]\");\n    \n    // Add offset to R3\n    __asm__(\"ADD     R3, R3, #0x760\");\n    __asm__(\"ADD     R3, R3, #0xC\");\n    \n    // Load value at ptm into R0\n    __asm__(\"LDR     R0, [R11,#ptm]\");\n    __asm__(\"LDR     R0, [R0,#0x10]\");\n    \n    // Increment R0 by 1\n    __asm__(\"ADD     R0, R0, #1\");\n    \n    // Load value at ptm into R12\n    __asm__(\"LDR     R12, [R11,#ptm]\");\n    __asm__(\"LDR     R12, [R12,#0xC]\");\n    \n    // Load value at ptm into LR\n    __asm__(\"LDR     LR, [R11,#ptm]\");\n    __asm__(\"LDR     LR, [LR,#8]\");\n    \n    // Load value at ptm into R4\n    __asm__(\"LDR     R4, [R11,#ptm]\");\n    __asm__(\"LDR     R4, [R4,#4]\");\n    \n    // Load value at ptm into R5\n    __asm__(\"LDR     R5, [R11,#ptm]\");\n    __asm__(\"LDR     R5, [R5]\");\n    \n    // Load value at file_header into R6\n    __asm__(\"LDR     R6, [R11,#file_header]\");\n    __asm__(\"LDR     R6, [R6]\");\n    \n    // Store R6 in var_6C\n    __asm__(\"STR     R6, [SP,#0x8C+var_6C]\");\n    \n    // Store R5 in var_70\n    __asm__(\"STR     R5, [SP,#0x8C+var_70]\");\n    \n    // Store R4 in var_74\n    __asm__(\"STR     R4, [SP,#0x8C+var_74]\");\n    \n    // Store LR in var_78\n    __asm__(\"STR     LR, [SP,#0x8C+var_78]\");\n    \n    // Store R12 in var_7C\n    __asm__(\"STR     R12, [SP,#0x8C+var_7C]\");\n    \n    // Store R0 in var_80\n    __asm__(\"STR     R0, [SP,#0x8C+var_80]\");\n    \n    // Store R3 in var_84\n    __asm__(\"STR     R3, [SP,#0x8C+var_84]\");\n    \n    // Store R1 and R2 in memory\n    __asm__(\"STMEA   SP, {R1,R2}\");\n    \n    // Load value at group into R3\n    __asm__(\"LDR     R3, [R11,#group]\");\n    \n    // Load value at user into R2\n    __asm__(\"LDR     R2, [R11,#user]\");\n    \n    // Move R7 to R1\n    __asm__(\"MOV     R1, R7\");\n    \n    // Load format string into R0\n    __asm__(\"LDR     R0, =aSSS9llu4u02u02\");\n    \n    // Call printf\n    __asm__(\"BL      printf\");\n    \n    // Load value at offset 4 into R3\n    __asm__(\"LDR     R3, [R11,#file_header]\");\n    __asm__(\"LDR     R3, [R3,#4]\");\n    \n    // Compare R3 with 0\n    __asm__(\"CMP     R3, #0\");\n    \n    // Branch if equal to loc_FB524\n    __asm__(\"BEQ     loc_FB524\");\n    \n    // Load value at offset 4 into R3\n    __asm__(\"LDR     R3, [R11,#file_header]\");\n    __asm__(\"LDR     R3, [R3,#4]\");\n    \n    // Move R3 to R1\n    __asm__(\"MOV     R1, R3\");\n    \n    // Load format string into R0\n    __asm__(\"LDR     R0, =aS_90\");\n    \n    // Call printf\n    __asm__(\"BL      printf\");\n    \n    // Move 0xA to R0\n    __asm__(\"MOV     R0, #0xA\");\n    \n    // Call bb_putchar\n    __asm__(\"BL      bb_putchar\");\n    \n    // Return\n    __asm__(\"NOP\");\n    \n    // Restore stack frame\n    __asm__(\"SUB     SP, R11, #0x14\");\n    \n    // Restore registers\n    __asm__(\"POP     {R4-R7,R11,PC}\");\n}\n```"
    },
    {
        "func_name": "retry_network_setup",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0004E218 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0004E21C | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0004E220 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x0004E224 | 10 00 0B E5 | STR     R0, [R11,#sig]\n0x0004E228 | 98 30 9F E5 | LDR     R3, =bb_errno\n0x0004E22C | 00 30 93 E5 | LDR     R3, [R3]\n0x0004E230 | 00 30 93 E5 | LDR     R3, [R3]\n0x0004E234 | 0C 30 0B E5 | STR     R3, [R11,#save_errno]\n0x0004E238 | 8C 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004E23C | 00 20 A0 E3 | MOV     R2, #0\n0x0004E240 | 2C 20 83 E5 | STR     R2, [R3,#(bb_common_bufsiz1.c_cc+0x1B - 0x18F9D8)]\n0x0004E244 | 80 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004E248 | 18 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+7 - 0x18F9D8)]\n0x0004E24C | 08 30 0B E5 | STR     R3, [R11,#sep]\n0x0004E250 | 12 00 00 EA | B       loc_4E2A0\n0x0004E254 | 08 30 1B E5 | LDR     R3, [R11,#sep]\n0x0004E258 | 00 30 93 E5 | LDR     R3, [R3]\n0x0004E25C | 01 00 73 E3 | CMN     R3, #1\n0x0004E260 | 0B 00 00 1A | BNE     loc_4E294\n0x0004E264 | 08 00 1B E5 | LDR     R0, [R11,#sep]; sep\n0x0004E268 | 19 FA FF EB | BL      prepare_socket_fd\n0x0004E26C | 08 30 1B E5 | LDR     R3, [R11,#sep]\n0x0004E270 | 00 30 93 E5 | LDR     R3, [R3]\n0x0004E274 | 01 00 73 E3 | CMN     R3, #1\n0x0004E278 | 05 00 00 0A | BEQ     loc_4E294\n0x0004E27C | 08 30 1B E5 | LDR     R3, [R11,#sep]\n0x0004E280 | 14 30 93 E5 | LDR     R3, [R3,#0x14]\n0x0004E284 | 00 00 53 E3 | CMP     R3, #0\n0x0004E288 | 01 00 00 0A | BEQ     loc_4E294\n0x0004E28C | 08 00 1B E5 | LDR     R0, [R11,#sep]; sep\n0x0004E290 | C0 F8 FF EB | BL      register_rpc\n0x0004E294 | 08 30 1B E5 | LDR     R3, [R11,#sep]\n0x0004E298 | 44 30 93 E5 | LDR     R3, [R3,#0x44]\n0x0004E29C | 08 30 0B E5 | STR     R3, [R11,#sep]\n0x0004E2A0 | 08 30 1B E5 | LDR     R3, [R11,#sep]\n0x0004E2A4 | 00 00 53 E3 | CMP     R3, #0\n0x0004E2A8 | E9 FF FF 1A | BNE     loc_4E254\n0x0004E2AC | 14 30 9F E5 | LDR     R3, =bb_errno\n0x0004E2B0 | 00 30 93 E5 | LDR     R3, [R3]\n0x0004E2B4 | 0C 20 1B E5 | LDR     R2, [R11,#save_errno]\n0x0004E2B8 | 00 20 83 E5 | STR     R2, [R3]\n0x0004E2BC | 00 00 A0 E1 | NOP\n0x0004E2C0 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0004E2C4 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function() {\n    int sig;\n    int save_errno;\n    int sep;\n    \n    // Save R11 and LR onto the stack\n    __asm__(\"PUSH {R11, LR}\");\n    \n    // Set R11 to the current stack pointer + 4\n    __asm__(\"ADD R11, SP, #4\");\n    \n    // Allocate space on the stack for local variables\n    __asm__(\"SUB SP, SP, #0x10\");\n    \n    // Store the value of R0 into the variable sig\n    sig = R0;\n    \n    // Load the address of bb_errno into R3\n    __asm__(\"LDR R3, =bb_errno\");\n    \n    // Load the value at the address stored in R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n    \n    // Load the value at the address stored in R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n    \n    // Store the value of R3 into the variable save_errno\n    save_errno = R3;\n    \n    // Load the address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n    \n    // Move the value 0 into R2\n    __asm__(\"MOV R2, #0\");\n    \n    // Store the value of R2 into the address calculated by R3 + (bb_common_bufsiz1.c_cc+0x1B - 0x18F9D8)\n    __asm__(\"STR R2, [R3, #(bb_common_bufsiz1.c_cc+0x1B - 0x18F9D8)]\");\n    \n    // Load the address of bb_common_bufsiz1 into R3\n    __asm__(\"LDR R3, =bb_common_bufsiz1\");\n    \n    // Load the value at the address stored in R3 + (bb_common_bufsiz1.c_cc+7 - 0x18F9D8) into R3\n    __asm__(\"LDR R3, [R3, #(bb_common_bufsiz1.c_cc+7 - 0x18F9D8)]\");\n    \n    // Store the value of R3 into the variable sep\n    sep = R3;\n    \n    // Branch to loc_4E2A0\n    __asm__(\"B loc_4E2A0\");\n    \nloc_4E2A0:\n    // Load the value at the address stored in R11 + sep into R3\n    __asm__(\"LDR R3, [R11, #sep]\");\n    \n    // Compare the value in R3 with 1\n    __asm__(\"CMN R3, #1\");\n    \n    // Branch to loc_4E294 if the result of the comparison is not equal\n    __asm__(\"BNE loc_4E294\");\n    \n    // Load the value at the address stored in R11 + sep into R0\n    __asm__(\"LDR R0, [R11, #sep]\");\n    \n    // Call the function prepare_socket_fd\n    __asm__(\"BL prepare_socket_fd\");\n    \n    // Load the value at the address stored in R11 + sep into R3\n    __asm__(\"LDR R3, [R11, #sep]\");\n    \n    // Load the value at the address stored in R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n    \n    // Compare the value in R3 with 1\n    __asm__(\"CMN R3, #1\");\n    \n    // Branch to loc_4E294 if the result of the comparison is equal\n    __asm__(\"BEQ loc_4E294\");\n    \n    // Load the value at the address stored in R11 + sep + 0x14 into R3\n    __asm__(\"LDR R3, [R11, #sep + 0x14]\");\n    \n    // Compare the value in R3 with 0\n    __asm__(\"CMP R3, #0\");\n    \n    // Branch to loc_4E294 if the result of the comparison is equal\n    __asm__(\"BEQ loc_4E294\");\n    \n    // Load the value at the address stored in R11 + sep into R0\n    __asm__(\"LDR R0, [R11, #sep]\");\n    \n    // Call the function register_rpc\n    __asm__(\"BL register_rpc\");\n    \nloc_4E294:\n    // Load the value at the address stored in R11 + sep into R3\n    __asm__(\"LDR R3, [R11, #sep]\");\n    \n    // Store the value of R3 into the variable sep\n    sep = R3;\n    \n    // Compare the value in R3 with 0\n    __asm__(\"CMP R3, #0\");\n    \n    // Branch to loc_4E254 if the result of the comparison is not equal\n    __asm__(\"BNE loc_4E254\");\n    \n    // Load the address of bb_errno into R3\n    __asm__(\"LDR R3, =bb_errno\");\n    \n    // Load the value at the address stored in R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n    \n    // Load the value at the address stored in R11 + save_errno into R2\n    __asm__(\"LDR R2, [R11, #save_errno]\");\n    \n    // Store the value of R2 into the address stored in R3\n    __asm__(\"STR R2, [R3]\");\n    \n    // No operation\n    __asm__(\"NOP\");\n    \n    // Restore SP to R11 - 4\n    __asm__(\"SUB SP, R11, #4\");\n    \n    // Restore R11 and PC from the stack\n    __asm__(\"POP {R11, PC}\");\n}\n```"
    },
    {
        "func_name": "evalcmd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000A75C8 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000A75CC | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000A75D0 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x000A75D4 | 10 00 0B E5 | STR     R0, [R11,#argc]\n0x000A75D8 | 14 10 0B E5 | STR     R1, [R11,#argv]\n0x000A75DC | 14 30 1B E5 | LDR     R3, [R11,#argv]\n0x000A75E0 | 04 30 83 E2 | ADD     R3, R3, #4\n0x000A75E4 | 00 30 93 E5 | LDR     R3, [R3]\n0x000A75E8 | 00 00 53 E3 | CMP     R3, #0\n0x000A75EC | 2E 00 00 0A | BEQ     loc_A76AC\n0x000A75F0 | 14 30 1B E5 | LDR     R3, [R11,#argv]\n0x000A75F4 | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000A75F8 | 08 30 0B E5 | STR     R3, [R11,#p]\n0x000A75FC | 14 30 1B E5 | LDR     R3, [R11,#argv]\n0x000A7600 | 08 30 83 E2 | ADD     R3, R3, #8\n0x000A7604 | 14 30 0B E5 | STR     R3, [R11,#argv]\n0x000A7608 | 14 30 1B E5 | LDR     R3, [R11,#argv]\n0x000A760C | 00 30 93 E5 | LDR     R3, [R3]\n0x000A7610 | 00 00 53 E3 | CMP     R3, #0\n0x000A7614 | 21 00 00 0A | BEQ     loc_A76A0\n0x000A7618 | A0 30 9F E5 | LDR     R3, =ash_ptr_to_globals_memstack\n0x000A761C | 00 30 93 E5 | LDR     R3, [R3]\n0x000A7620 | 08 30 93 E5 | LDR     R3, [R3,#8]\n0x000A7624 | 0C 30 0B E5 | STR     R3, [R11,#concat]\n0x000A7628 | 0C 10 1B E5 | LDR     R1, [R11,#concat]; p\n0x000A762C | 08 00 1B E5 | LDR     R0, [R11,#p]; s\n0x000A7630 | 22 B3 FF EB | BL      stack_putstr\n0x000A7634 | 0C 00 0B E5 | STR     R0, [R11,#concat]\n0x000A7638 | 14 30 1B E5 | LDR     R3, [R11,#argv]\n0x000A763C | 04 20 83 E2 | ADD     R2, R3, #4\n0x000A7640 | 14 20 0B E5 | STR     R2, [R11,#argv]\n0x000A7644 | 00 30 93 E5 | LDR     R3, [R3]\n0x000A7648 | 08 30 0B E5 | STR     R3, [R11,#p]\n0x000A764C | 08 30 1B E5 | LDR     R3, [R11,#p]\n0x000A7650 | 00 00 53 E3 | CMP     R3, #0\n0x000A7654 | 04 00 00 0A | BEQ     loc_A766C\n0x000A7658 | 0C 10 1B E5 | LDR     R1, [R11,#concat]; p\n0x000A765C | 20 00 A0 E3 | MOV     R0, #0x20 ; ' '; c\n0x000A7660 | 26 B3 FF EB | BL      _STPUTC\n0x000A7664 | 0C 00 0B E5 | STR     R0, [R11,#concat]\n0x000A7668 | EE FF FF EA | B       loc_A7628\n0x000A766C | 00 00 A0 E1 | NOP\n0x000A7670 | 0C 10 1B E5 | LDR     R1, [R11,#concat]; p\n0x000A7674 | 00 00 A0 E3 | MOV     R0, #0; c\n0x000A7678 | 20 B3 FF EB | BL      _STPUTC\n0x000A767C | 0C 00 0B E5 | STR     R0, [R11,#concat]\n0x000A7680 | 38 30 9F E5 | LDR     R3, =ash_ptr_to_globals_memstack\n0x000A7684 | 00 30 93 E5 | LDR     R3, [R3]\n0x000A7688 | 08 30 93 E5 | LDR     R3, [R3,#8]\n0x000A768C | 0C 20 1B E5 | LDR     R2, [R11,#concat]\n0x000A7690 | 03 30 42 E0 | SUB     R3, R2, R3\n0x000A7694 | 03 00 A0 E1 | MOV     R0, R3; nbytes\n0x000A7698 | F8 B0 FF EB | BL      stalloc\n0x000A769C | 08 00 0B E5 | STR     R0, [R11,#p]\n0x000A76A0 | 10 10 E0 E3 | MOV     R1, #0xFFFFFFEF; mask\n0x000A76A4 | 08 00 1B E5 | LDR     R0, [R11,#p]; s\n0x000A76A8 | 98 FF FF EB | BL      evalstring\n0x000A76AC | 10 30 9F E5 | LDR     R3, =exitstatus\n0x000A76B0 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000A76B4 | 03 00 A0 E1 | MOV     R0, R3\n0x000A76B8 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000A76BC | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdio.h>\n\nint main(int argc, char* argv[]) {\n    int* p = NULL;\n    char* concat = NULL;\n    \n    if (argv[1] != NULL) {\n        concat = argv[1];\n        stack_putstr(concat);\n    }\n    \n    if (argv[2] != NULL) {\n        p = argv[2];\n        while (*p != '\\0') {\n            _STPUTC(*p);\n            p++;\n        }\n    }\n    \n    return exitstatus;\n}\n```"
    },
    {
        "func_name": "getstatus",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000982A8 | 04 B0 2D E5 | PUSH    {R11}\n0x000982AC | 00 B0 8D E2 | ADD     R11, SP, #0\n0x000982B0 | 1C D0 4D E2 | SUB     SP, SP, #0x1C\n0x000982B4 | 18 00 0B E5 | STR     R0, [R11,#job]\n0x000982B8 | 18 30 1B E5 | LDR     R3, [R11,#job]\n0x000982BC | 0C 20 93 E5 | LDR     R2, [R3,#0xC]\n0x000982C0 | 18 30 1B E5 | LDR     R3, [R11,#job]\n0x000982C4 | B4 31 D3 E1 | LDRH    R3, [R3,#0x14]\n0x000982C8 | 03 10 A0 E1 | MOV     R1, R3\n0x000982CC | 01 30 A0 E1 | MOV     R3, R1\n0x000982D0 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000982D4 | 01 30 83 E0 | ADD     R3, R3, R1\n0x000982D8 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000982DC | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x000982E0 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000982E4 | 10 30 0B E5 | STR     R3, [R11,#ps]\n0x000982E8 | 10 30 1B E5 | LDR     R3, [R11,#ps]\n0x000982EC | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000982F0 | 08 30 0B E5 | STR     R3, [R11,#status]\n0x000982F4 | D0 30 9F E5 | LDR     R3, =ash_ptr_to_globals_misc\n0x000982F8 | 00 30 93 E5 | LDR     R3, [R3]\n0x000982FC | 3F 30 D3 E5 | LDRB    R3, [R3,#0x3F]\n0x00098300 | 00 00 53 E3 | CMP     R3, #0\n0x00098304 | 0E 00 00 0A | BEQ     loc_98344\n0x00098308 | 02 00 00 EA | B       loc_98318\n0x0009830C | 10 30 1B E5 | LDR     R3, [R11,#ps]\n0x00098310 | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x00098314 | 08 30 0B E5 | STR     R3, [R11,#status]\n0x00098318 | 08 30 1B E5 | LDR     R3, [R11,#status]\n0x0009831C | 00 00 53 E3 | CMP     R3, #0\n0x00098320 | 07 00 00 1A | BNE     loc_98344\n0x00098324 | 10 30 1B E5 | LDR     R3, [R11,#ps]\n0x00098328 | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x0009832C | 10 30 0B E5 | STR     R3, [R11,#ps]\n0x00098330 | 18 30 1B E5 | LDR     R3, [R11,#job]\n0x00098334 | 0C 30 93 E5 | LDR     R3, [R3,#0xC]\n0x00098338 | 10 20 1B E5 | LDR     R2, [R11,#ps]\n0x0009833C | 03 00 52 E1 | CMP     R2, R3\n0x00098340 | F1 FF FF 2A | BCS     loc_9830C\n0x00098344 | 08 30 1B E5 | LDR     R3, [R11,#status]\n0x00098348 | 43 34 A0 E1 | MOV     R3, R3,ASR#8\n0x0009834C | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x00098350 | 0C 30 0B E5 | STR     R3, [R11,#retval]\n0x00098354 | 08 30 1B E5 | LDR     R3, [R11,#status]\n0x00098358 | 7F 30 03 E2 | AND     R3, R3, #0x7F\n0x0009835C | 00 00 53 E3 | CMP     R3, #0\n0x00098360 | 14 00 00 0A | BEQ     loc_983B8\n0x00098364 | 08 30 1B E5 | LDR     R3, [R11,#status]\n0x00098368 | 43 34 A0 E1 | MOV     R3, R3,ASR#8\n0x0009836C | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x00098370 | 0C 30 0B E5 | STR     R3, [R11,#retval]\n0x00098374 | 08 30 1B E5 | LDR     R3, [R11,#status]\n0x00098378 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x0009837C | 7F 00 53 E3 | CMP     R3, #0x7F\n0x00098380 | 09 00 00 0A | BEQ     loc_983AC\n0x00098384 | 08 30 1B E5 | LDR     R3, [R11,#status]\n0x00098388 | 7F 30 03 E2 | AND     R3, R3, #0x7F\n0x0009838C | 0C 30 0B E5 | STR     R3, [R11,#retval]\n0x00098390 | 0C 30 1B E5 | LDR     R3, [R11,#retval]\n0x00098394 | 02 00 53 E3 | CMP     R3, #2\n0x00098398 | 03 00 00 1A | BNE     loc_983AC\n0x0009839C | 18 20 1B E5 | LDR     R2, [R11,#job]\n0x000983A0 | 17 30 D2 E5 | LDRB    R3, [R2,#0x17]\n0x000983A4 | 01 30 83 E3 | ORR     R3, R3, #1\n0x000983A8 | 17 30 C2 E5 | STRB    R3, [R2,#0x17]\n0x000983AC | 0C 30 1B E5 | LDR     R3, [R11,#retval]\n0x000983B0 | 80 30 83 E2 | ADD     R3, R3, #0x80\n0x000983B4 | 0C 30 0B E5 | STR     R3, [R11,#retval]\n0x000983B8 | 0C 30 1B E5 | LDR     R3, [R11,#retval]\n0x000983BC | 03 00 A0 E1 | MOV     R0, R3\n0x000983C0 | 00 D0 8B E2 | MOV     SP, R11\n0x000983C4 | 04 B0 9D E4 | POP     {R11}\n0x000983C8 | 1E FF 2F E1 | BX      LR",
        "output": "```c\nvoid function() {\n    int job;\n    int ps;\n    int status;\n    int retval;\n    \n    // Save R11\n    __asm__(\"PUSH {R11}\");\n    \n    // Set up R11\n    __asm__(\"ADD R11, SP, #0\");\n    \n    // Allocate space on the stack\n    __asm__(\"SUB SP, SP, #0x1C\");\n    \n    // Store R0 in job\n    __asm__(\"STR R0, [R11, #job]\");\n    \n    // Load job into R3\n    __asm__(\"LDR R3, [R11, #job]\");\n    \n    // Load [R3 + 0xC] into R2\n    __asm__(\"LDR R2, [R3, #0xC]\");\n    \n    // Load job into R3\n    __asm__(\"LDR R3, [R11, #job]\");\n    \n    // Load [R3 + 0x14] into R3\n    __asm__(\"LDRH R3, [R3, #0x14]\");\n    \n    // Move R3 to R1\n    __asm__(\"MOV R1, R3\");\n    \n    // Move R1 to R3\n    __asm__(\"MOV R3, R1\");\n    \n    // Shift R3 left by 1\n    __asm__(\"MOV R3, R3, LSL #1\");\n    \n    // Add R1 to R3\n    __asm__(\"ADD R3, R3, R1\");\n    \n    // Shift R3 left by 2\n    __asm__(\"MOV R3, R3, LSL #2\");\n    \n    // Subtract 0xC from R3\n    __asm__(\"SUB R3, R3, #0xC\");\n    \n    // Add R2 to R3\n    __asm__(\"ADD R3, R2, R3\");\n    \n    // Store R3 in ps\n    __asm__(\"STR R3, [R11, #ps]\");\n    \n    // Load ps into R3\n    __asm__(\"LDR R3, [R11, #ps]\");\n    \n    // Load [R3 + 4] into R3\n    __asm__(\"LDR R3, [R3, #4]\");\n    \n    // Store R3 in status\n    __asm__(\"STR R3, [R11, #status]\");\n    \n    // Load ash_ptr_to_globals_misc into R3\n    __asm__(\"LDR R3, =ash_ptr_to_globals_misc\");\n    \n    // Load [R3] into R3\n    __asm__(\"LDR R3, [R3]\");\n    \n    // Load [R3 + 0x3F] into R3\n    __asm__(\"LDRB R3, [R3, #0x3F]\");\n    \n    // Compare R3 to 0\n    __asm__(\"CMP R3, #0\");\n    \n    // Branch if equal to loc_98344\n    __asm__(\"BEQ loc_98344\");\n    \n    // Branch to loc_98318\n    __asm__(\"B loc_98318\");\n    \nloc_9830C:\n    // Load ps into R3\n    __asm__(\"LDR R3, [R11, #ps]\");\n    \n    // Load [R3 + 4] into R3\n    __asm__(\"LDR R3, [R3, #4]\");\n    \n    // Store R3 in status\n    __asm__(\"STR R3, [R11, #status]\");\n    \nloc_98318:\n    // Load status into R3\n    __asm__(\"LDR R3, [R11, #status]\");\n    \n    // Compare R3 to 0\n    __asm__(\"CMP R3, #0\");\n    \n    // Branch if not equal to loc_98344\n    __asm__(\"BNE loc_98344\");\n    \n    // Load ps into R3\n    __asm__(\"LDR R3, [R11, #ps]\");\n    \n    // Subtract 0xC from R3\n    __asm__(\"SUB R3, R3, #0xC\");\n    \n    // Store R3 in ps\n    __asm__(\"STR R3, [R11, #ps]\");\n    \n    // Load job into R3\n    __asm__(\"LDR R3, [R11, #job]\");\n    \n    // Load [R3 + 0xC] into R3\n    __asm__(\"LDR R3, [R3, #0xC]\");\n    \n    // Load ps into R2\n    __asm__(\"LDR R2, [R11, #ps]\");\n    \n    // Compare R2 to R3\n    __asm__(\"CMP R2, R3\");\n    \n    // Branch if carry set to loc_9830C\n    __asm__(\"BCS loc_9830C\");\n    \nloc_98344:\n    // Load status into R3\n    __asm__(\"LDR R3, [R11, #status]\");\n    \n    // Shift R3 right by 8\n    __asm__(\"MOV R3, R3, ASR #8\");\n    \n    // Mask R3 with 0xFF\n    __asm__(\"AND R3, R3, #0xFF\");\n    \n    // Store R3 in retval\n    __asm__(\"STR R3, [R11, #retval]\");\n    \n    // Load status into R3\n    __asm__(\"LDR R3, [R11, #status]\");\n    \n    // Mask R3 with 0x7F\n    __asm__(\"AND R3, R3, #0x7F\");\n    \n    // Compare R3 to 0\n    __asm__(\"CMP R3, #0\");\n    \n    // Branch if equal to loc_983B8\n    __asm__(\"BEQ loc_983B8\");\n    \n    // Load status into R3\n    __asm__(\"LDR R3, [R11, #status]\");\n    \n    // Shift R3 right by 8\n    __asm__(\"MOV R3, R3, ASR #8\");\n    \n    // Mask R3 with 0xFF\n    __asm__(\"AND R3, R3, #0xFF\");\n    \n    // Store R3 in retval\n    __asm__(\"STR R3, [R11, #retval]\");\n    \n    // Load status into R3\n    __asm__(\"LDR R3, [R11, #status]\");\n    \n    // Mask R3 with 0xFF\n    __asm__(\"AND R3, R3, #0xFF\");\n    \n    // Compare R3 to 0x7F\n    __asm__(\"CMP R3, #0x7F\");\n    \n    // Branch if equal to loc_983AC\n    __asm__(\"BEQ loc_983AC\");\n    \n    // Load status into R3\n    __asm__(\"LDR R3, [R11, #status]\");\n    \n    // Mask R3 with 0x7F\n    __asm__(\"AND R3, R3, #0x7F\");\n    \n    // Store R3 in retval\n    __asm__(\"STR R3, [R11, #retval]\");\n    \n    // Load retval into R3\n    __asm__(\"LDR R3, [R11, #retval]\");\n    \n    // Compare R3 to 2\n    __asm__(\"CMP R3, #2\");\n    \n    // Branch if not equal to loc_983AC\n    __asm__(\"BNE loc_983AC\");\n    \n    // Load job into R2\n    __asm__(\"LDR R2, [R11, #job]\");\n    \n    // Load [R2 + 0x17] into R3\n    __asm__(\"LDRB R3, [R2, #0x17]\");\n    \n    // Set bit 0 of R3\n    __asm__(\"ORR R3, R3, #1\");\n    \n    // Store R3 in [R2 + 0x17]\n    __asm__(\"STRB R3, [R2, #0x17]\");\n    \nloc_983AC:\n    // Load retval into R3\n    __asm__(\"LDR R3, [R11, #retval]\");\n    \n    // Add 0x80 to R3\n    __asm__(\"ADD R3, R3, #0x80\");\n    \n    // Store R3 in retval\n    __asm__(\"STR R3, [R11, #retval]\");\n    \nloc_983B8:\n    // Load retval into R3\n    __asm__(\"LDR R3, [R11, #retval]\");\n    \n    // Move R3 to R0\n    __asm__(\"MOV R0, R3\");\n    \n    // Restore SP\n    __asm__(\"MOV SP, R11\");\n    \n    // Restore R11\n    __asm__(\"POP {R11}\");\n    \n    // Return\n    __asm__(\"BX LR\");\n}\n```"
    },
    {
        "func_name": "validate_tm_time",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0001BBE8 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0001BBEC | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0001BBF0 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x0001BBF4 | 10 00 0B E5 | STR     R0, [R11,#date_str]\n0x0001BBF8 | 14 10 0B E5 | STR     R1, [R11,#ptm]\n0x0001BBFC | 14 00 1B E5 | LDR     R0, [R11,#ptm]; tp\n0x0001BC00 | 8F E4 FF EB | BL      mktime\n0x0001BC04 | 08 00 0B E5 | STR     R0, [R11,#t]\n0x0001BC08 | 08 30 1B E5 | LDR     R3, [R11,#t]\n0x0001BC0C | 01 00 73 E3 | CMN     R3, #1\n0x0001BC10 | 02 00 00 1A | BNE     loc_1BC20\n0x0001BC14 | 10 10 1B E5 | LDR     R1, [R11,#date_str]\n0x0001BC18 | 10 00 9F E5 | LDR     R0, =bb_msg_invalid_date; \"invalid date '%s'\"\n0x0001BC1C | 5D F4 FF EB | BL      bb_error_msg_and_die\n0x0001BC20 | 08 30 1B E5 | LDR     R3, [R11,#t]\n0x0001BC24 | 03 00 A0 E1 | MOV     R0, R3\n0x0001BC28 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0001BC2C | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function() {\n    // Save R11 and LR onto the stack\n    __asm__(\"PUSH {R11, LR}\");\n\n    // Set R11 to the current stack pointer plus 4\n    __asm__(\"ADD R11, SP, #4\");\n\n    // Allocate space on the stack for local variables\n    __asm__(\"SUB SP, SP, #0x10\");\n\n    // Store the value of R0 into the memory location pointed to by R11 + offset of date_str\n    __asm__(\"STR R0, [R11, #date_str]\");\n\n    // Store the value of R1 into the memory location pointed to by R11 + offset of ptm\n    __asm__(\"STR R1, [R11, #ptm]\");\n\n    // Load the value from the memory location pointed to by R11 + offset of ptm into R0\n    __asm__(\"LDR R0, [R11, #ptm]\");\n\n    // Call the mktime function\n    __asm__(\"BL mktime\");\n\n    // Store the return value of mktime into the memory location pointed to by R11 + offset of t\n    __asm__(\"STR R0, [R11, #t]\");\n\n    // Load the value from the memory location pointed to by R11 + offset of t into R3\n    __asm__(\"LDR R3, [R11, #t]\");\n\n    // Compare the value of R3 with 1\n    __asm__(\"CMN R3, #1\");\n\n    // Branch to loc_1BC20 if the result of the comparison is not equal\n    __asm__(\"BNE loc_1BC20\");\n\n    // Load the value from the memory location pointed to by R11 + offset of date_str into R1\n    __asm__(\"LDR R1, [R11, #date_str]\");\n\n    // Load the address of bb_msg_invalid_date into R0\n    __asm__(\"LDR R0, =bb_msg_invalid_date\");\n\n    // Call the bb_error_msg_and_die function\n    __asm__(\"BL bb_error_msg_and_die\");\n\nloc_1BC20:\n    // Load the value from the memory location pointed to by R11 + offset of t into R3\n    __asm__(\"LDR R3, [R11, #t]\");\n\n    // Move the value of R3 into R0\n    __asm__(\"MOV R0, R3\");\n\n    // Restore the stack pointer to the value of R11 - 4\n    __asm__(\"SUB SP, R11, #4\");\n\n    // Restore R11 and PC from the stack\n    __asm__(\"POP {R11, PC}\");\n}\n```"
    },
    {
        "func_name": "print_stats_and_exit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00058E0C | 70 48 2D E9 | PUSH    {R4-R6,R11,LR}\n0x00058E10 | 10 B0 8D E2 | ADD     R11, SP, #0x10\n0x00058E14 | 24 D0 4D E2 | SUB     SP, SP, #0x24\n0x00058E18 | 20 00 0B E5 | STR     R0, [R11,#junk]\n0x00058E1C | 01 10 A0 E3 | MOV     R1, #1; handler\n0x00058E20 | 02 00 A0 E3 | MOV     R0, #2; sig\n0x00058E24 | 51 F0 FE EB | BL      signal\n0x00058E28 | 48 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058E2C | 58 30 93 E5 | LDR     R3, [R3,#(dword_18FA30 - 0x18F9D8)]\n0x00058E30 | 03 10 A0 E1 | MOV     R1, R3\n0x00058E34 | 40 02 9F E5 | LDR     R0, =aSPingStatistic; \"\\n--- %s ping statistics ---\\n\"\n0x00058E38 | E6 EF FE EB | BL      printf\n0x00058E3C | 34 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058E40 | 1C 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xB - 0x18F9D8)]\n0x00058E44 | 03 10 A0 E1 | MOV     R1, R3\n0x00058E48 | 30 02 9F E5 | LDR     R0, =aLuPacketsTrans; \"%lu packets transmitted, \"\n0x00058E4C | E1 EF FE EB | BL      printf\n0x00058E50 | 20 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058E54 | 20 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x00058E58 | 03 10 A0 E1 | MOV     R1, R3\n0x00058E5C | 20 02 9F E5 | LDR     R0, =aLuPacketsRecei; \"%lu packets received, \"\n0x00058E60 | DC EF FE EB | BL      printf\n0x00058E64 | 0C 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058E68 | 24 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0x13 - 0x18F9D8)]\n0x00058E6C | 00 00 53 E3 | CMP     R3, #0\n0x00058E70 | 04 00 00 0A | BEQ     loc_58E88\n0x00058E74 | FC 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058E78 | 24 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0x13 - 0x18F9D8)]\n0x00058E7C | 03 10 A0 E1 | MOV     R1, R3\n0x00058E80 | 00 02 9F E5 | LDR     R0, =aLuDuplicates; \"%lu duplicates, \"\n0x00058E84 | D3 EF FE EB | BL      printf\n0x00058E88 | E8 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058E8C | 1C 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xB - 0x18F9D8)]\n0x00058E90 | 00 00 53 E3 | CMP     R3, #0\n0x00058E94 | 13 00 00 0A | BEQ     loc_58EE8\n0x00058E98 | D8 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058E9C | 1C 20 93 E5 | LDR     R2, [R3,#(bb_common_bufsiz1.c_cc+0xB - 0x18F9D8)]\n0x00058EA0 | D0 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058EA4 | 20 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x00058EA8 | 03 20 42 E0 | SUB     R2, R2, R3\n0x00058EAC | 02 30 A0 E1 | MOV     R3, R2\n0x00058EB0 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00058EB4 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00058EB8 | 03 21 A0 E1 | MOV     R2, R3,LSL#2\n0x00058EBC | 02 30 83 E0 | ADD     R3, R3, R2\n0x00058EC0 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00058EC4 | 03 20 A0 E1 | MOV     R2, R3\n0x00058EC8 | A8 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058ECC | 1C 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xB - 0x18F9D8)]\n0x00058ED0 | A0 41 9F E5 | LDR     R4, =bb_common_bufsiz1\n0x00058ED4 | 03 10 A0 E1 | MOV     R1, R3\n0x00058ED8 | 02 00 A0 E1 | MOV     R0, R2\n0x00058EDC | 69 F8 03 EB | BL      __udivsi3\n0x00058EE0 | 00 30 A0 E1 | MOV     R3, R0\n0x00058EE4 | 1C 30 84 E5 | STR     R3, [R4,#(bb_common_bufsiz1.c_cc+0xB - 0x18F9D8)]\n0x00058EE8 | 88 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058EEC | 1C 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xB - 0x18F9D8)]\n0x00058EF0 | 03 10 A0 E1 | MOV     R1, R3\n0x00058EF4 | 90 01 9F E5 | LDR     R0, =aLuPacketLoss; \"%lu%% packet loss\\n\"\n0x00058EF8 | B6 EF FE EB | BL      printf\n0x00058EFC | 74 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058F00 | 2C 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0x1B - 0x18F9D8)]\n0x00058F04 | 01 00 73 E3 | CMN     R3, #1\n0x00058F08 | 47 00 00 0A | BEQ     loc_5902C\n0x00058F0C | 64 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058F10 | 38 10 83 E2 | ADD     R1, R3, #0x38 ; '8'\n0x00058F14 | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x00058F18 | 58 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058F1C | 20 20 93 E5 | LDR     R2, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x00058F20 | 50 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058F24 | 24 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0x13 - 0x18F9D8)]\n0x00058F28 | 03 30 82 E0 | ADD     R3, R2, R3\n0x00058F2C | 00 40 A0 E3 | MOV     R4, #0\n0x00058F30 | 03 20 A0 E1 | MOV     R2, R3\n0x00058F34 | 04 30 A0 E1 | MOV     R3, R4\n0x00058F38 | F5 FC 03 EB | BL      __aeabi_uldivmod\n0x00058F3C | 00 30 A0 E1 | MOV     R3, R0\n0x00058F40 | 01 40 A0 E1 | MOV     R4, R1\n0x00058F44 | 18 30 0B E5 | STR     R3, [R11,#tavg]\n0x00058F48 | 28 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058F4C | 2C 00 93 E5 | LDR     R0, [R3,#(bb_common_bufsiz1.c_cc+0x1B - 0x18F9D8)]\n0x00058F50 | 38 21 9F E5 | LDR     R2, =0x10624DD3\n0x00058F54 | 92 10 83 E0 | UMULL   R1, R3, R2, R0\n0x00058F58 | 23 43 A0 E1 | MOV     R4, R3,LSR#6\n0x00058F5C | 14 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058F60 | 2C 20 93 E5 | LDR     R2, [R3,#(bb_common_bufsiz1.c_cc+0x1B - 0x18F9D8)]\n0x00058F64 | 24 31 9F E5 | LDR     R3, =0x10624DD3\n0x00058F68 | 92 13 80 E0 | UMULL   R1, R0, R2, R3\n0x00058F6C | 20 03 A0 E1 | MOV     R0, R0,LSR#6\n0x00058F70 | 00 30 A0 E1 | MOV     R3, R0\n0x00058F74 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x00058F78 | 00 30 43 E0 | SUB     R3, R3, R0\n0x00058F7C | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00058F80 | 00 30 83 E0 | ADD     R3, R3, R0\n0x00058F84 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x00058F88 | 03 00 42 E0 | SUB     R0, R2, R3\n0x00058F8C | 18 C0 1B E5 | LDR     R12, [R11,#tavg]\n0x00058F90 | F8 20 9F E5 | LDR     R2, =0x10624DD3\n0x00058F94 | 92 1C 83 E0 | UMULL   R1, R3, R2, R12\n0x00058F98 | 23 53 A0 E1 | MOV     R5, R3,LSR#6\n0x00058F9C | 18 10 1B E5 | LDR     R1, [R11,#tavg]\n0x00058FA0 | E8 30 9F E5 | LDR     R3, =0x10624DD3\n0x00058FA4 | 91 23 8C E0 | UMULL   R2, R12, R1, R3\n0x00058FA8 | 2C 23 A0 E1 | MOV     R2, R12,LSR#6\n0x00058FAC | 02 30 A0 E1 | MOV     R3, R2\n0x00058FB0 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x00058FB4 | 02 30 43 E0 | SUB     R3, R3, R2\n0x00058FB8 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00058FBC | 02 30 83 E0 | ADD     R3, R3, R2\n0x00058FC0 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x00058FC4 | 03 20 41 E0 | SUB     R2, R1, R3\n0x00058FC8 | A8 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058FCC | 30 E0 93 E5 | LDR     LR, [R3,#(bb_common_bufsiz1.c_cc+0x1F - 0x18F9D8)]\n0x00058FD0 | B8 10 9F E5 | LDR     R1, =0x10624DD3\n0x00058FD4 | 91 CE 83 E0 | UMULL   R12, R3, R1, LR\n0x00058FD8 | 23 E3 A0 E1 | MOV     LR, R3,LSR#6\n0x00058FDC | 94 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058FE0 | 30 C0 93 E5 | LDR     R12, [R3,#(bb_common_bufsiz1.c_cc+0x1F - 0x18F9D8)]\n0x00058FE4 | A4 30 9F E5 | LDR     R3, =0x10624DD3\n0x00058FE8 | 9C 13 86 E0 | UMULL   R1, R6, R12, R3\n0x00058FEC | 26 13 A0 E1 | MOV     R1, R6,LSR#6\n0x00058FF0 | 01 30 A0 E1 | MOV     R3, R1\n0x00058FF4 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x00058FF8 | 01 30 43 E0 | SUB     R3, R3, R1\n0x00058FFC | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00059000 | 01 30 83 E0 | ADD     R3, R3, R1\n0x00059004 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x00059008 | 03 10 4C E0 | SUB     R1, R12, R3\n0x0005900C | 08 10 8D E5 | STR     R1, [SP,#0x34+var_2C]\n0x00059010 | 04 E0 8D E5 | STR     LR, [SP,#0x34+var_30]\n0x00059014 | 00 20 8D E5 | STR     R2, [SP,#0x34+var_34]\n0x00059018 | 05 30 A0 E1 | MOV     R3, R5\n0x0005901C | 00 20 A0 E1 | MOV     R2, R0\n0x00059020 | 04 10 A0 E1 | MOV     R1, R4\n0x00059024 | 68 00 9F E5 | LDR     R0, =aRoundTripMinAv; \"round-trip min/avg/max = %u.%03u/%u.%03\"...\n0x00059028 | 6A EF FE EB | BL      printf\n0x0005902C | 44 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00059030 | 20 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x00059034 | 00 00 53 E3 | CMP     R3, #0\n0x00059038 | 09 00 00 0A | BEQ     loc_59064\n0x0005903C | 34 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00059040 | 40 30 93 E5 | LDR     R3, [R3,#(dst.data - 0x18F9D8)]\n0x00059044 | 00 00 53 E3 | CMP     R3, #0\n0x00059048 | 07 00 00 0A | BEQ     loc_5906C\n0x0005904C | 24 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00059050 | 20 20 93 E5 | LDR     R2, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x00059054 | 1C 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00059058 | 14 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+3 - 0x18F9D8)]\n0x0005905C | 03 00 52 E1 | CMP     R2, R3\n0x00059060 | 01 00 00 2A | BCS     loc_5906C\n0x00059064 | 01 30 A0 E3 | MOV     R3, #1\n0x00059068 | 00 00 00 EA | B       loc_59070\n0x0005906C | 00 30 A0 E3 | MOV     R3, #0\n0x00059070 | 03 00 A0 E1 | MOV     R0, R3; status\n0x00059074 | 2E F1 FE EB | BL      exit",
        "output": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid signal_handler(int sig) {\n    printf(\"\\n--- %s ping statistics ---\\n\", \"junk\");\n    printf(\"%lu packets transmitted, \", bb_common_bufsiz1.c_cc + 0xB);\n    printf(\"%lu packets received, \", bb_common_bufsiz1.c_cc + 0xF);\n    printf(\"%lu duplicates, \", bb_common_bufsiz1.c_cc + 0x13);\n    \n    if (bb_common_bufsiz1.c_cc + 0x13 != 0) {\n        printf(\"%lu%% packet loss\\n\", __udivsi3(bb_common_bufsiz1.c_cc + 0xB, bb_common_bufsiz1.c_cc + 0x13));\n    } else {\n        printf(\"0%% packet loss\\n\");\n    }\n    \n    if (bb_common_bufsiz1.c_cc + 0xB != 0) {\n        unsigned int tavg = bb_common_bufsiz1.c_cc + 0xB;\n        unsigned int tmin = 0x10624DD3 * bb_common_bufsiz1.c_cc + 0x1B / tavg;\n        unsigned int tmax = 0x10624DD3 * bb_common_bufsiz1.c_cc + 0x1F / tavg;\n        unsigned int tavg_sec = tavg >> 6;\n        unsigned int tavg_msec = (tavg & 0x3F) * 1000 / tavg;\n        unsigned int tmin_sec = tmin >> 6;\n        unsigned int tmin_msec = (tmin & 0x3F) * 1000 / tmin;\n        unsigned int tmax_sec = tmax >> 6;\n        unsigned int tmax_msec = (tmax & 0x3F) * 1000 / tmax;\n        \n        printf(\"round-trip min/avg/max = %u.%03u/%u.%03u/%u.%03u ms\\n\", tmin_sec, tmin_msec, tavg_sec, tavg_msec, tmax_sec, tmax_msec);\n    }\n    \n    if (bb_common_bufsiz1.c_cc + 0xF != 0) {\n        if (bb_common_bufsiz1.c_cc + 0x1B > 1) {\n            unsigned int dst_data = bb_common_bufsiz1.c_cc + 0xF;\n            unsigned int dst_len = bb_common_bufsiz1.c_cc + 3;\n            \n            if (dst_data <= dst_len) {\n                printf(\"WARNING: packet size too small, %u bytes < %u bytes\\n\", dst_data, dst_len);\n            }\n        }\n    }\n    \n    exit(0);\n}\n```"
    },
    {
        "func_name": "fb_setpal",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0002914C | 00 48 2D E9 | PUSH    {R11,LR}\n0x00029150 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00029154 | 62 DE 4D E2 | SUB     SP, SP, #0x620\n0x00029158 | 08 D0 4D E2 | SUB     SP, SP, #8\n0x0002915C | 28 06 0B E5 | STR     R0, [R11,#fd]\n0x00029160 | 00 30 A0 E3 | MOV     R3, #0\n0x00029164 | 08 30 0B E5 | STR     R3, [R11,#i]\n0x00029168 | 44 00 00 EA | B       loc_29280\n0x0002916C | 08 30 1B E5 | LDR     R3, [R11,#i]\n0x00029170 | A3 22 A0 E1 | MOV     R2, R3,LSR#5\n0x00029174 | 02 30 A0 E1 | MOV     R3, R2\n0x00029178 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x0002917C | 02 30 83 E0 | ADD     R3, R3, R2\n0x00029180 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x00029184 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00029188 | 83 24 A0 E1 | MOV     R2, R3,LSL#9\n0x0002918C | 02 30 83 E0 | ADD     R3, R3, R2\n0x00029190 | 23 31 A0 E1 | MOV     R3, R3,LSR#2\n0x00029194 | 03 38 A0 E1 | MOV     R3, R3,LSL#16\n0x00029198 | 23 28 A0 E1 | MOV     R2, R3,LSR#16\n0x0002919C | 04 30 4B E2 | SUB     R3, R11, #-var_4\n0x000291A0 | 87 1F 43 E2 | SUB     R1, R3, #0x21C\n0x000291A4 | 08 30 1B E5 | LDR     R3, [R11,#i]\n0x000291A8 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000291AC | 03 30 81 E0 | ADD     R3, R1, R3\n0x000291B0 | B0 20 C3 E1 | STRH    R2, [R3]\n0x000291B4 | 08 30 1B E5 | LDR     R3, [R11,#i]\n0x000291B8 | 23 31 A0 E1 | MOV     R3, R3,LSR#2\n0x000291BC | 07 20 03 E2 | AND     R2, R3, #7\n0x000291C0 | 02 30 A0 E1 | MOV     R3, R2\n0x000291C4 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x000291C8 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000291CC | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x000291D0 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000291D4 | 83 24 A0 E1 | MOV     R2, R3,LSL#9\n0x000291D8 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000291DC | 23 31 A0 E1 | MOV     R3, R3,LSR#2\n0x000291E0 | 03 38 A0 E1 | MOV     R3, R3,LSL#16\n0x000291E4 | 23 28 A0 E1 | MOV     R2, R3,LSR#16\n0x000291E8 | 04 30 4B E2 | SUB     R3, R11, #-var_4\n0x000291EC | 41 3E 43 E2 | SUB     R3, R3, #0x410\n0x000291F0 | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x000291F4 | 08 10 1B E5 | LDR     R1, [R11,#i]\n0x000291F8 | 81 10 A0 E1 | MOV     R1, R1,LSL#1\n0x000291FC | 01 30 83 E0 | ADD     R3, R3, R1\n0x00029200 | B0 20 C3 E1 | STRH    R2, [R3]\n0x00029204 | 08 30 1B E5 | LDR     R3, [R11,#i]\n0x00029208 | 03 38 A0 E1 | MOV     R3, R3,LSL#16\n0x0002920C | 23 38 A0 E1 | MOV     R3, R3,LSR#16\n0x00029210 | 03 30 03 E2 | AND     R3, R3, #3\n0x00029214 | 03 38 A0 E1 | MOV     R3, R3,LSL#16\n0x00029218 | 23 38 A0 E1 | MOV     R3, R3,LSR#16\n0x0002921C | 03 20 A0 E1 | MOV     R2, R3\n0x00029220 | 02 21 A0 E1 | MOV     R2, R2,LSL#2\n0x00029224 | 03 30 82 E0 | ADD     R3, R2, R3\n0x00029228 | 03 20 A0 E1 | MOV     R2, R3\n0x0002922C | 02 12 A0 E1 | MOV     R1, R2,LSL#4\n0x00029230 | 03 20 A0 E1 | MOV     R2, R3\n0x00029234 | 01 30 A0 E1 | MOV     R3, R1\n0x00029238 | 03 30 82 E0 | ADD     R3, R2, R3\n0x0002923C | 03 20 A0 E1 | MOV     R2, R3\n0x00029240 | 02 14 A0 E1 | MOV     R1, R2,LSL#8\n0x00029244 | 03 20 A0 E1 | MOV     R2, R3\n0x00029248 | 01 30 A0 E1 | MOV     R3, R1\n0x0002924C | 03 30 82 E0 | ADD     R3, R2, R3\n0x00029250 | 03 38 A0 E1 | MOV     R3, R3,LSL#16\n0x00029254 | 23 28 A0 E1 | MOV     R2, R3,LSR#16\n0x00029258 | 04 30 4B E2 | SUB     R3, R11, #-var_4\n0x0002925C | 61 3E 43 E2 | SUB     R3, R3, #0x610\n0x00029260 | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x00029264 | 08 10 1B E5 | LDR     R1, [R11,#i]\n0x00029268 | 81 10 A0 E1 | MOV     R1, R1,LSL#1\n0x0002926C | 01 30 83 E0 | ADD     R3, R3, R1\n0x00029270 | B0 20 C3 E1 | STRH    R2, [R3]\n0x00029274 | 08 30 1B E5 | LDR     R3, [R11,#i]\n0x00029278 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0002927C | 08 30 0B E5 | STR     R3, [R11,#i]\n0x00029280 | 08 30 1B E5 | LDR     R3, [R11,#i]\n0x00029284 | FF 00 53 E3 | CMP     R3, #0xFF\n0x00029288 | B7 FF FF 9A | BLS     loc_2916C\n0x0002928C | 00 30 A0 E3 | MOV     R3, #0\n0x00029290 | 20 30 0B E5 | STR     R3, [R11,#cmap]\n0x00029294 | 01 3C A0 E3 | MOV     R3, #0x100\n0x00029298 | 1C 30 0B E5 | STR     R3, [R11,#cmap.len]\n0x0002929C | 22 3E 4B E2 | SUB     R3, R11, #-red\n0x000292A0 | 18 30 0B E5 | STR     R3, [R11,#cmap.red]\n0x000292A4 | 41 3E 4B E2 | SUB     R3, R11, #-(green+0x10)\n0x000292A8 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000292AC | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x000292B0 | 14 30 0B E5 | STR     R3, [R11,#cmap.green]\n0x000292B4 | 61 3E 4B E2 | SUB     R3, R11, #-(blue+0x10)\n0x000292B8 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000292BC | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x000292C0 | 10 30 0B E5 | STR     R3, [R11,#cmap.blue]\n0x000292C4 | 00 30 A0 E3 | MOV     R3, #0\n0x000292C8 | 0C 30 0B E5 | STR     R3, [R11,#cmap.transp]\n0x000292CC | 20 20 4B E2 | SUB     R2, R11, #-cmap; argp\n0x000292D0 | 14 30 9F E5 | LDR     R3, =aFbioputcmap; \"FBIOPUTCMAP\"\n0x000292D4 | 14 10 9F E5 | LDR     R1, =0x4605; request\n0x000292D8 | 28 06 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000292DC | 82 C5 FF EB | BL      bb_xioctl\n0x000292E0 | 00 00 A0 E1 | NOP\n0x000292E4 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000292E8 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function() {\n    int i;\n    int cmap;\n    int red;\n    int green;\n    int blue;\n    int transp;\n    \n    // Initialize variables\n    cmap = 0;\n    cmap.len = 0x100;\n    cmap.red = &red;\n    cmap.green = &green;\n    cmap.blue = &blue;\n    cmap.transp = &transp;\n    \n    // Loop\n    for (i = 0; i <= 0xFF; i++) {\n        // Calculate color values\n        red = (i >> 5) + ((i >> 5) << 3) + ((i >> 5) << 9);\n        green = ((i >> 2) & 7) + (((i >> 2) & 7) << 3) + (((i >> 2) & 7) << 9);\n        blue = (i & 3) + ((i & 3) << 3) + ((i & 3) << 9);\n        \n        // Set color values in cmap\n        cmap.red[i] = red;\n        cmap.green[i] = green;\n        cmap.blue[i] = blue;\n    }\n    \n    // Call ioctl function\n    bb_xioctl(fd, 0x4605, &cmap);\n}\n```"
    },
    {
        "func_name": "blocking_wait_with_raise_on_sig",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00097D88 | 00 48 2D E9 | PUSH    {R11,LR}\n0x00097D8C | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00097D90 | 08 D0 4D E2 | SUB     SP, SP, #8\n0x00097D94 | 00 10 A0 E3 | MOV     R1, #0; job\n0x00097D98 | 00 00 A0 E3 | MOV     R0, #0; wait_flags\n0x00097D9C | 44 FF FF EB | BL      dowait\n0x00097DA0 | 08 00 0B E5 | STR     R0, [R11,#pid]\n0x00097DA4 | 08 30 1B E5 | LDR     R3, [R11,#pid]\n0x00097DA8 | 00 00 53 E3 | CMP     R3, #0\n0x00097DAC | 06 00 00 CA | BGT     loc_97DCC\n0x00097DB0 | 24 30 9F E5 | LDR     R3, =ash_ptr_to_globals_misc\n0x00097DB4 | 00 30 93 E5 | LDR     R3, [R3]\n0x00097DB8 | 24 30 93 E5 | LDR     R3, [R3,#0x24]\n0x00097DBC | 00 00 53 E3 | CMP     R3, #0\n0x00097DC0 | 01 00 00 0A | BEQ     loc_97DCC\n0x00097DC4 | 05 00 A0 E3 | MOV     R0, #5; e\n0x00097DC8 | A7 ED FF EB | BL      raise_exception\n0x00097DCC | 08 30 1B E5 | LDR     R3, [R11,#pid]\n0x00097DD0 | 03 00 A0 E1 | MOV     R0, R3\n0x00097DD4 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00097DD8 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function() {\n    int job = 0;\n    int wait_flags = 0;\n    \n    dowait();\n    \n    int pid = wait_flags;\n    \n    if (pid > 0) {\n        int* ash_ptr_to_globals_misc = (int*)0x24;\n        int* ash_ptr = (int*)ash_ptr_to_globals_misc[0];\n        \n        if (ash_ptr != 0) {\n            int e = 5;\n            raise_exception(e);\n        }\n    }\n    \n    int result = pid;\n}\n```"
    },
    {
        "func_name": "read_to_buf",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0014C7B4 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0014C7B8 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0014C7BC | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x0014C7C0 | 10 00 0B E5 | STR     R0, [R11,#filename]\n0x0014C7C4 | 14 10 0B E5 | STR     R1, [R11,#buf]\n0x0014C7C8 | 00 30 E0 E3 | MOV     R3, #0xFFFFFFFF\n0x0014C7CC | 08 30 0B E5 | STR     R3, [R11,#ret]\n0x0014C7D0 | 00 10 A0 E3 | MOV     R1, #0\n0x0014C7D4 | 10 00 1B E5 | LDR     R0, [R11,#filename]\n0x0014C7D8 | EF 22 FB EB | BL      open64\n0x0014C7DC | 0C 00 0B E5 | STR     R0, [R11,#fd]\n0x0014C7E0 | 0C 30 1B E5 | LDR     R3, [R11,#fd]\n0x0014C7E4 | 00 00 53 E3 | CMP     R3, #0\n0x0014C7E8 | 06 00 00 BA | BLT     loc_14C808\n0x0014C7EC | 40 20 9F E5 | LDR     R2, =0x3FF; nbytes\n0x0014C7F0 | 14 10 1B E5 | LDR     R1, [R11,#buf]; buf\n0x0014C7F4 | 0C 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x0014C7F8 | 88 21 FB EB | BL      read\n0x0014C7FC | 08 00 0B E5 | STR     R0, [R11,#ret]\n0x0014C800 | 0C 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x0014C804 | 42 25 FB EB | BL      close\n0x0014C808 | 08 30 1B E5 | LDR     R3, [R11,#ret]\n0x0014C80C | C3 3F C3 E1 | BIC     R3, R3, R3,ASR#31\n0x0014C810 | 03 20 A0 E1 | MOV     R2, R3\n0x0014C814 | 14 30 1B E5 | LDR     R3, [R11,#buf]\n0x0014C818 | 02 30 83 E0 | ADD     R3, R3, R2\n0x0014C81C | 00 20 A0 E3 | MOV     R2, #0\n0x0014C820 | 00 20 C3 E5 | STRB    R2, [R3]\n0x0014C824 | 08 30 1B E5 | LDR     R3, [R11,#ret]\n0x0014C828 | 03 00 A0 E1 | MOV     R0, R3\n0x0014C82C | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0014C830 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(char* filename, char* buf) {\n    int ret;\n    int fd;\n    \n    fd = open64(filename, 0);\n    if (fd < 0) {\n        return;\n    }\n    \n    ret = read(fd, buf, 0x3FF);\n    close(fd);\n    \n    ret = ret & ~(ret >> 31);\n    \n    for (int i = 0; i < ret; i++) {\n        buf[i] = 0;\n    }\n}\n```"
    },
    {
        "func_name": "get_cached",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0014C608 | 10 48 2D E9 | PUSH    {R4,R11,LR}\n0x0014C60C | 08 B0 8D E2 | ADD     R11, SP, #8\n0x0014C610 | 1C D0 4D E2 | SUB     SP, SP, #0x1C\n0x0014C614 | 18 00 0B E5 | STR     R0, [R11,#cp]\n0x0014C618 | 1C 10 0B E5 | STR     R1, [R11,#id]\n0x0014C61C | 20 20 0B E5 | STR     R2, [R11,#x2x_utoa]\n0x0014C620 | 00 30 A0 E3 | MOV     R3, #0\n0x0014C624 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x0014C628 | 12 00 00 EA | B       loc_14C678\n0x0014C62C | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C630 | 00 20 93 E5 | LDR     R2, [R3]\n0x0014C634 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x0014C638 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x0014C63C | 03 30 82 E0 | ADD     R3, R2, R3\n0x0014C640 | 00 30 93 E5 | LDR     R3, [R3]\n0x0014C644 | 1C 20 1B E5 | LDR     R2, [R11,#id]\n0x0014C648 | 03 00 52 E1 | CMP     R2, R3\n0x0014C64C | 06 00 00 1A | BNE     loc_14C66C\n0x0014C650 | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C654 | 00 20 93 E5 | LDR     R2, [R3]\n0x0014C658 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x0014C65C | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x0014C660 | 03 30 82 E0 | ADD     R3, R2, R3\n0x0014C664 | 04 30 83 E2 | ADD     R3, R3, #4\n0x0014C668 | 31 00 00 EA | B       loc_14C734\n0x0014C66C | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x0014C670 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0014C674 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x0014C678 | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C67C | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x0014C680 | 10 20 1B E5 | LDR     R2, [R11,#i]\n0x0014C684 | 03 00 52 E1 | CMP     R2, R3\n0x0014C688 | E7 FF FF BA | BLT     loc_14C62C\n0x0014C68C | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C690 | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x0014C694 | 01 10 83 E2 | ADD     R1, R3, #1\n0x0014C698 | 18 20 1B E5 | LDR     R2, [R11,#cp]\n0x0014C69C | 04 10 82 E5 | STR     R1, [R2,#4]\n0x0014C6A0 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x0014C6A4 | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C6A8 | 00 30 93 E5 | LDR     R3, [R3]\n0x0014C6AC | 10 20 1B E5 | LDR     R2, [R11,#i]; idx\n0x0014C6B0 | 88 10 9F E5 | LDR     R1, =0x2002; sizeof_and_shift\n0x0014C6B4 | 03 00 A0 E1 | MOV     R0, R3; vector\n0x0014C6B8 | 01 2A 00 EB | BL      xrealloc_vector_helper\n0x0014C6BC | 00 20 A0 E1 | MOV     R2, R0\n0x0014C6C0 | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C6C4 | 00 20 83 E5 | STR     R2, [R3]\n0x0014C6C8 | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C6CC | 00 20 93 E5 | LDR     R2, [R3]\n0x0014C6D0 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x0014C6D4 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x0014C6D8 | 03 30 82 E0 | ADD     R3, R2, R3\n0x0014C6DC | 1C 20 1B E5 | LDR     R2, [R11,#id]\n0x0014C6E0 | 00 20 83 E5 | STR     R2, [R3]\n0x0014C6E4 | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C6E8 | 00 20 93 E5 | LDR     R2, [R3]\n0x0014C6EC | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x0014C6F0 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x0014C6F4 | 03 30 82 E0 | ADD     R3, R2, R3\n0x0014C6F8 | 04 40 83 E2 | ADD     R4, R3, #4\n0x0014C6FC | 20 30 1B E5 | LDR     R3, [R11,#x2x_utoa]\n0x0014C700 | 1C 00 1B E5 | LDR     R0, [R11,#id]\n0x0014C704 | 33 FF 2F E1 | BLX     R3\n0x0014C708 | 00 30 A0 E1 | MOV     R3, R0\n0x0014C70C | 1C 20 A0 E3 | MOV     R2, #0x1C; size\n0x0014C710 | 03 10 A0 E1 | MOV     R1, R3; src\n0x0014C714 | 04 00 A0 E1 | MOV     R0, R4; dst\n0x0014C718 | 11 15 00 EB | BL      safe_strncpy\n0x0014C71C | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C720 | 00 20 93 E5 | LDR     R2, [R3]\n0x0014C724 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x0014C728 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x0014C72C | 03 30 82 E0 | ADD     R3, R2, R3\n0x0014C730 | 04 30 83 E2 | ADD     R3, R3, #4\n0x0014C734 | 03 00 A0 E1 | MOV     R0, R3\n0x0014C738 | 08 D0 4B E2 | SUB     SP, R11, #8\n0x0014C73C | 10 88 BD E8 | POP     {R4,R11,PC}",
        "output": "```c\nvoid function(int* cp, int* id, int* x2x_utoa) {\n    int i = 0;\n    while (1) {\n        int* cp_val = cp;\n        int* id_val = id;\n        int* x2x_utoa_val = x2x_utoa;\n        int cp_val_4 = cp_val[1];\n        int id_val_i = id_val[i];\n        int* id_val_i_ptr = &id_val_i;\n        int* cp_val_4_ptr = &cp_val_4;\n        if (id_val_i != cp_val_4) {\n            int* cp_val_4_ptr_4 = cp_val_4_ptr + 1;\n            int* id_val_i_ptr_2 = id_val_i_ptr;\n            int* cp_val_4_ptr_4_ptr = cp_val_4_ptr_4;\n            int* id_val_i_ptr_2_ptr = id_val_i_ptr_2;\n            int* cp_val_4_ptr_4_ptr_2 = cp_val_4_ptr_4_ptr;\n            int* id_val_i_ptr_2_ptr_2 = id_val_i_ptr_2_ptr;\n            int* cp_val_4_ptr_4_ptr_2_ptr = cp_val_4_ptr_4_ptr_2;\n            int* id_val_i_ptr_2_ptr_2_ptr = id_val_i_ptr_2_ptr_2;\n            int* cp_val_4_ptr_4_ptr_2_ptr_2 = cp_val_4_ptr_4_ptr_2_ptr;\n            int* id_val_i_ptr_2_ptr_2_ptr_2 = id_val_i_ptr_2_ptr_2_ptr;\n            int* cp_val_4_ptr_4_ptr_2_ptr_2_ptr = cp_val_4_ptr_4_ptr_2_ptr_2;\n            int* id_val_i_ptr_2_ptr_2_ptr_2_ptr = id_val_i_ptr_2_ptr_2_ptr_2;\n            int* cp_val_4_ptr_4_ptr_2_ptr_2_ptr_2 = cp_val_4_ptr_4_ptr_2_ptr_2_ptr;\n            int* id_val_i_ptr_2_ptr_2_ptr_2_ptr_2 = id_val_i_ptr_2_ptr_2_ptr_2_ptr;\n            int* cp_val_4_ptr_4_ptr_2_ptr_2_ptr_2_ptr = cp_val_4_ptr_4_ptr_2_ptr_2_ptr_2;\n            int* id_val_i_ptr_2_ptr_2_ptr_2_ptr_2_ptr = id_val_i_ptr_2_ptr_2_ptr_2_ptr_2;\n            int* cp_val_4_ptr_4_ptr_2_ptr_2_ptr_2_ptr_2 = cp_val_4_ptr_4_ptr_2_ptr_2_ptr_2_ptr;\n            int* id_val_i_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2 = id_val_i_ptr_2_ptr_2_ptr_2_ptr_2_ptr;\n            int* cp_val_4_ptr_4_ptr_2_ptr_2_ptr_2_ptr_2_ptr = cp_val_4_ptr_4_ptr_2_ptr_2_ptr_2_ptr_2;\n            int* id_val_i_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2_ptr = id_val_i_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2;\n            int* cp_val_4_ptr_4_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2 = cp_val_4_ptr_4_ptr_2_ptr_2_ptr_2_ptr_2_ptr;\n            int* id_val_i_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2 = id_val_i_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2_ptr;\n            int* cp_val_4_ptr_4_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2_ptr = cp_val_4_ptr_4_ptr_2_ptr_2_ptr_2_ptr_2_ptr;\n            int* id_val_i_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2_ptr = id_val_i_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2_ptr;\n            int* cp_val_4_ptr_4_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2 = cp_val_4_ptr_4_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2;\n            int* id_val_i_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2_ptr_2 = id_val_i_ptr_2_ptr_2_ptr"
    },
    {
        "func_name": "dotrap",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000A0210 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000A0214 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000A0218 | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x000A021C | 08 31 9F E5 | LDR     R3, =exitstatus\n0x000A0220 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000A0224 | 0D 30 4B E5 | STRB    R3, [R11,#savestatus]\n0x000A0228 | 00 31 9F E5 | LDR     R3, =ash_ptr_to_globals_misc\n0x000A022C | 00 30 93 E5 | LDR     R3, [R3]\n0x000A0230 | 00 20 A0 E3 | MOV     R2, #0\n0x000A0234 | 24 20 83 E5 | STR     R2, [R3,#0x24]\n0x000A0238 | 01 30 A0 E3 | MOV     R3, #1\n0x000A023C | 0C 30 0B E5 | STR     R3, [R11,#sig]\n0x000A0240 | E8 30 9F E5 | LDR     R3, =ash_ptr_to_globals_misc\n0x000A0244 | 00 30 93 E5 | LDR     R3, [R3]\n0x000A0248 | 80 30 83 E2 | ADD     R3, R3, #0x80\n0x000A024C | 08 30 0B E5 | STR     R3, [R11,#g]\n0x000A0250 | 2E 00 00 EA | B       loc_A0310\n0x000A0254 | 08 30 1B E5 | LDR     R3, [R11,#g]\n0x000A0258 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000A025C | 00 00 53 E3 | CMP     R3, #0\n0x000A0260 | 1F 00 00 0A | BEQ     loc_A02E4\n0x000A0264 | C4 30 9F E5 | LDR     R3, =ash_ptr_to_globals_misc\n0x000A0268 | 00 20 93 E5 | LDR     R2, [R3]\n0x000A026C | 0C 30 1B E5 | LDR     R3, [R11,#sig]\n0x000A0270 | 30 30 83 E2 | ADD     R3, R3, #0x30 ; '0'\n0x000A0274 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000A0278 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000A027C | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000A0280 | 14 30 0B E5 | STR     R3, [R11,#t]\n0x000A0284 | 0C 30 1B E5 | LDR     R3, [R11,#sig]\n0x000A0288 | 02 00 53 E3 | CMP     R3, #2\n0x000A028C | 02 00 00 1A | BNE     loc_A029C\n0x000A0290 | 14 30 1B E5 | LDR     R3, [R11,#t]\n0x000A0294 | 00 00 53 E3 | CMP     R3, #0\n0x000A0298 | 13 00 00 0A | BEQ     loc_A02EC\n0x000A029C | 08 30 1B E5 | LDR     R3, [R11,#g]\n0x000A02A0 | 00 20 A0 E3 | MOV     R2, #0\n0x000A02A4 | 00 20 C3 E5 | STRB    R2, [R3]\n0x000A02A8 | 14 30 1B E5 | LDR     R3, [R11,#t]\n0x000A02AC | 00 00 53 E3 | CMP     R3, #0\n0x000A02B0 | 0F 00 00 0A | BEQ     loc_A02F4\n0x000A02B4 | 10 10 A0 E3 | MOV     R1, #0x10; mask\n0x000A02B8 | 14 00 1B E5 | LDR     R0, [R11,#t]; s\n0x000A02BC | 93 1C 00 EB | BL      evalstring\n0x000A02C0 | 18 00 0B E5 | STR     R0, [R11,#want_exexit]\n0x000A02C4 | 60 20 9F E5 | LDR     R2, =exitstatus\n0x000A02C8 | 0D 30 5B E5 | LDRB    R3, [R11,#savestatus]\n0x000A02CC | 00 30 C2 E5 | STRB    R3, [R2]\n0x000A02D0 | 18 30 1B E5 | LDR     R3, [R11,#want_exexit]\n0x000A02D4 | 00 00 53 E3 | CMP     R3, #0\n0x000A02D8 | 06 00 00 0A | BEQ     loc_A02F8\n0x000A02DC | 18 30 1B E5 | LDR     R3, [R11,#want_exexit]\n0x000A02E0 | 0E 00 00 EA | B       loc_A0320\n0x000A02E4 | 00 00 A0 E1 | NOP\n0x000A02E8 | 02 00 00 EA | B       loc_A02F8\n0x000A02EC | 00 00 A0 E1 | NOP\n0x000A02F0 | 00 00 00 EA | B       loc_A02F8\n0x000A02F4 | 00 00 A0 E1 | NOP\n0x000A02F8 | 0C 30 1B E5 | LDR     R3, [R11,#sig]\n0x000A02FC | 01 30 83 E2 | ADD     R3, R3, #1\n0x000A0300 | 0C 30 0B E5 | STR     R3, [R11,#sig]\n0x000A0304 | 08 30 1B E5 | LDR     R3, [R11,#g]\n0x000A0308 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000A030C | 08 30 0B E5 | STR     R3, [R11,#g]\n0x000A0310 | 0C 30 1B E5 | LDR     R3, [R11,#sig]\n0x000A0314 | 40 00 53 E3 | CMP     R3, #0x40 ; '@'\n0x000A0318 | CD FF FF DA | BLE     loc_A0254\n0x000A031C | 00 30 A0 E3 | MOV     R3, #0\n0x000A0320 | 03 00 A0 E1 | MOV     R0, R3\n0x000A0324 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000A0328 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function() {\n    int exitstatus = *(char*)0x000A0220;\n    *(char*)(0x000A0224 + R11) = exitstatus;\n    int* ash_ptr_to_globals_misc = *(int*)0x000A0228;\n    *(ash_ptr_to_globals_misc + 0x24) = 0;\n    int sig = 1;\n    *(sig + R11) = sig;\n    ash_ptr_to_globals_misc = *(int*)0x000A0240;\n    int* g = *(ash_ptr_to_globals_misc + 0x80);\n    *(g + R11) = g;\n    loc_A0310:\n    int* g = *(g + R11);\n    if (*(char*)g == 0) {\n        loc_A02E4:\n        ash_ptr_to_globals_misc = *(int*)0x000A0264;\n        int* s = *(ash_ptr_to_globals_misc);\n        sig = *(sig + R11);\n        int* t = *(s + (sig + 0x30) * 4);\n        *(t + R11) = t;\n        if (sig == 2) {\n            if (*t == 0) {\n                loc_A02EC:\n                *(char*)g = 0;\n                if (*t != 0) {\n                    loc_A02F4:\n                    int mask = 0x10;\n                    int* s = *(s + R11);\n                    int exitstatus = evalstring(s, mask);\n                    *(exitstatus + R11) = exitstatus;\n                    int* want_exexit = *(int*)0x000A02C0;\n                    *(char*)want_exexit = *(char*)(0x000A02CC + R11);\n                    want_exexit = *(want_exexit + R11);\n                    if (want_exexit != 0) {\n                        loc_A02F8:\n                        sig = *(sig + R11) + 1;\n                        *(sig + R11) = sig;\n                        g = *(g + R11) + 1;\n                        *(g + R11) = g;\n                        sig = *(sig + R11);\n                        if (sig <= 0x40) {\n                            loc_A0254:\n                            sig = 0;\n                            loc_A0320:\n                            int exitstatus = sig;\n                            return exitstatus;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"
    },
    {
        "func_name": "open_next_file",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0010B0A8 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0010B0AC | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0010B0B0 | 94 30 9F E5 | LDR     R3, =file_list\n0x0010B0B4 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010B0B8 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010B0BC | 00 00 53 E3 | CMP     R3, #0\n0x0010B0C0 | 1F 00 00 0A | BEQ     loc_10B144\n0x0010B0C4 | 80 30 9F E5 | LDR     R3, =file_list\n0x0010B0C8 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010B0CC | 04 20 83 E2 | ADD     R2, R3, #4\n0x0010B0D0 | 74 10 9F E5 | LDR     R1, =file_list\n0x0010B0D4 | 00 20 81 E5 | STR     R2, [R1]\n0x0010B0D8 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010B0DC | 03 00 A0 E1 | MOV     R0, R3; filename\n0x0010B0E0 | F6 26 01 EB | BL      fopen_or_warn_stdin\n0x0010B0E4 | 00 20 A0 E1 | MOV     R2, R0\n0x0010B0E8 | 60 30 9F E5 | LDR     R3, =in_stream\n0x0010B0EC | 00 20 83 E5 | STR     R2, [R3]\n0x0010B0F0 | 58 30 9F E5 | LDR     R3, =in_stream\n0x0010B0F4 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010B0F8 | 00 00 53 E3 | CMP     R3, #0\n0x0010B0FC | 03 00 00 1A | BNE     loc_10B110\n0x0010B100 | 4C 30 9F E5 | LDR     R3, =exit_code\n0x0010B104 | 01 20 A0 E3 | MOV     R2, #1\n0x0010B108 | 00 20 83 E5 | STR     R2, [R3]\n0x0010B10C | E7 FF FF EA | B       loc_10B0B0\n0x0010B110 | 00 00 A0 E1 | NOP\n0x0010B114 | 3C 30 9F E5 | LDR     R3, =option_mask32\n0x0010B118 | 00 20 93 E5 | LDR     R2, [R3]\n0x0010B11C | 38 30 9F E5 | LDR     R3, =0x10002\n0x0010B120 | 02 30 03 E0 | AND     R3, R3, R2\n0x0010B124 | 02 00 53 E3 | CMP     R3, #2\n0x0010B128 | 00 88 BD 18 | POPNE   {R11,PC}\n0x0010B12C | 1C 30 9F E5 | LDR     R3, =in_stream\n0x0010B130 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010B134 | 00 10 A0 E3 | MOV     R1, #0; buf\n0x0010B138 | 03 00 A0 E1 | MOV     R0, R3; stream\n0x0010B13C | FB 26 FC EB | BL      setbuf\n0x0010B140 | 00 88 BD E8 | POP     {R11,PC}\n0x0010B144 | 00 00 A0 E1 | NOP\n0x0010B148 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function() {\n    // Save R11 and LR onto the stack\n    __asm__(\"PUSH {R11, LR}\");\n\n    // Set up R11 as the frame pointer\n    __asm__(\"ADD R11, SP, #4}\");\n\n    // Load the address of file_list into R3\n    __asm__(\"LDR R3, =file_list\");\n\n    // Load the value at the address stored in R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n\n    // Load the value at the address stored in R3 into R3 again\n    __asm__(\"LDR R3, [R3]\");\n\n    // Compare R3 with 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch to loc_10B144 if R3 is equal to 0\n    __asm__(\"BEQ loc_10B144\");\n\n    // Load the address of file_list into R3\n    __asm__(\"LDR R3, =file_list\");\n\n    // Load the value at the address stored in R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n\n    // Add 4 to the value in R3 and store the result in R2\n    __asm__(\"ADD R2, R3, #4\");\n\n    // Load the address of file_list into R1\n    __asm__(\"LDR R1, =file_list\");\n\n    // Store the value in R2 at the address stored in R1\n    __asm__(\"STR R2, [R1]\");\n\n    // Load the value at the address stored in R3 into R3 again\n    __asm__(\"LDR R3, [R3]\");\n\n    // Move the value in R3 to R0\n    __asm__(\"MOV R0, R3\");\n\n    // Call the function fopen_or_warn_stdin with R0 as the argument\n    __asm__(\"BL fopen_or_warn_stdin\");\n\n    // Move the return value of fopen_or_warn_stdin to R2\n    __asm__(\"MOV R2, R0\");\n\n    // Load the address of in_stream into R3\n    __asm__(\"LDR R3, =in_stream\");\n\n    // Store the value in R2 at the address stored in R3\n    __asm__(\"STR R2, [R3]\");\n\n    // Load the address of in_stream into R3\n    __asm__(\"LDR R3, =in_stream\");\n\n    // Load the value at the address stored in R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n\n    // Compare R3 with 0\n    __asm__(\"CMP R3, #0\");\n\n    // Branch to loc_10B110 if R3 is not equal to 0\n    __asm__(\"BNE loc_10B110\");\n\n    // Load the address of exit_code into R3\n    __asm__(\"LDR R3, =exit_code\");\n\n    // Move the value 1 to R2\n    __asm__(\"MOV R2, #1\");\n\n    // Store the value in R2 at the address stored in R3\n    __asm__(\"STR R2, [R3]\");\n\n    // Branch to loc_10B0B0\n    __asm__(\"B loc_10B0B0\");\n\nloc_10B110:\n    // No operation\n\n    // Load the address of option_mask32 into R3\n    __asm__(\"LDR R3, =option_mask32\");\n\n    // Load the value at the address stored in R3 into R2\n    __asm__(\"LDR R2, [R3]\");\n\n    // Load the value 0x10002 into R3\n    __asm__(\"LDR R3, =0x10002\");\n\n    // Perform a bitwise AND operation between R3 and R2 and store the result in R3\n    __asm__(\"AND R3, R3, R2\");\n\n    // Compare R3 with 2\n    __asm__(\"CMP R3, #2\");\n\n    // Pop R11 and PC from the stack if the previous comparison was not equal\n    __asm__(\"POPNE {R11, PC}\");\n\n    // Load the address of in_stream into R3\n    __asm__(\"LDR R3, =in_stream\");\n\n    // Load the value at the address stored in R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n\n    // Move the value 0 to R1\n    __asm__(\"MOV R1, #0\");\n\n    // Move the value in R3 to R0\n    __asm__(\"MOV R0, R3\");\n\n    // Call the function setbuf with R0 and R1 as the arguments\n    __asm__(\"BL setbuf\");\n\n    // Pop R11 and PC from the stack\n    __asm__(\"POP {R11, PC}\");\n}\n```"
    },
    {
        "func_name": "prepend_new_eth_table",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000524B4 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000524B8 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000524BC | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x000524C0 | 10 00 0B E5 | STR     R0, [R11,#clist]\n0x000524C4 | 14 10 0B E5 | STR     R1, [R11,#ifname]\n0x000524C8 | 18 20 0B E5 | STR     R2, [R11,#selector]\n0x000524CC | 14 00 1B E5 | LDR     R0, [R11,#ifname]; s\n0x000524D0 | 2C 0C FF EB | BL      strlen\n0x000524D4 | 00 30 A0 E1 | MOV     R3, R0\n0x000524D8 | 0F 00 53 E3 | CMP     R3, #0xF\n0x000524DC | 02 00 00 9A | BLS     loc_524EC\n0x000524E0 | 14 10 1B E5 | LDR     R1, [R11,#ifname]\n0x000524E4 | 7C 00 9F E5 | LDR     R0, =aInterfaceNameS; \"interface name '%s' too long\"\n0x000524E8 | 2A 1A FF EB | BL      bb_error_msg_and_die\n0x000524EC | 1C 00 A0 E3 | MOV     R0, #0x1C; size\n0x000524F0 | 8D 1D FF EB | BL      xzalloc\n0x000524F4 | 00 30 A0 E1 | MOV     R3, R0\n0x000524F8 | 08 30 0B E5 | STR     R3, [R11,#ch]\n0x000524FC | 14 00 1B E5 | LDR     R0, [R11,#ifname]; s\n0x00052500 | 99 1D FF EB | BL      xstrdup\n0x00052504 | 00 30 A0 E1 | MOV     R3, R0\n0x00052508 | 03 20 A0 E1 | MOV     R2, R3\n0x0005250C | 08 30 1B E5 | LDR     R3, [R11,#ch]\n0x00052510 | 08 20 83 E5 | STR     R2, [R3,#8]\n0x00052514 | 18 10 1B E5 | LDR     R1, [R11,#selector]; selector\n0x00052518 | 08 00 1B E5 | LDR     R0, [R11,#ch]; ch\n0x0005251C | 55 FF FF EB | BL      nameif_parse_selector\n0x00052520 | 10 30 1B E5 | LDR     R3, [R11,#clist]\n0x00052524 | 00 20 93 E5 | LDR     R2, [R3]\n0x00052528 | 08 30 1B E5 | LDR     R3, [R11,#ch]\n0x0005252C | 00 20 83 E5 | STR     R2, [R3]\n0x00052530 | 10 30 1B E5 | LDR     R3, [R11,#clist]\n0x00052534 | 00 30 93 E5 | LDR     R3, [R3]\n0x00052538 | 00 00 53 E3 | CMP     R3, #0\n0x0005253C | 03 00 00 0A | BEQ     loc_52550\n0x00052540 | 10 30 1B E5 | LDR     R3, [R11,#clist]\n0x00052544 | 00 30 93 E5 | LDR     R3, [R3]\n0x00052548 | 08 20 1B E5 | LDR     R2, [R11,#ch]\n0x0005254C | 04 20 83 E5 | STR     R2, [R3,#4]\n0x00052550 | 10 30 1B E5 | LDR     R3, [R11,#clist]\n0x00052554 | 08 20 1B E5 | LDR     R2, [R11,#ch]\n0x00052558 | 00 20 83 E5 | STR     R2, [R3]\n0x0005255C | 00 00 A0 E1 | NOP\n0x00052560 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00052564 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(char* ifname, char* selector, char* clist) {\n    // Save registers\n    PUSH    {R11,LR}\n    \n    // Set up stack frame\n    ADD     R11, SP, #4\n    \n    // Allocate space on the stack\n    SUB     SP, SP, #0x18\n    \n    // Store arguments on the stack\n    STR     R0, [R11,#clist]\n    STR     R1, [R11,#ifname]\n    STR     R2, [R11,#selector]\n    \n    // Check if the length of ifname is greater than 15\n    LDR     R0, [R11,#ifname]\n    BL      strlen\n    MOV     R3, R0\n    CMP     R3, #0xF\n    BLS     loc_524EC\n    \n    // Print error message and exit if ifname is too long\n    LDR     R1, [R11,#ifname]\n    LDR     R0, =aInterfaceNameS\n    BL      bb_error_msg_and_die\n    \n    // Allocate memory for ch\n    MOV     R0, #0x1C\n    BL      xzalloc\n    MOV     R3, R0\n    STR     R3, [R11,#ch]\n    \n    // Duplicate ifname and store it in ch\n    LDR     R0, [R11,#ifname]\n    BL      xstrdup\n    MOV     R3, R0\n    MOV     R2, R3\n    LDR     R3, [R11,#ch]\n    STR     R2, [R3,#8]\n    \n    // Parse the selector\n    LDR     R1, [R11,#selector]\n    LDR     R0, [R11,#ch]\n    BL      nameif_parse_selector\n    \n    // Store the first element of clist in ch\n    LDR     R3, [R11,#clist]\n    LDR     R2, [R3]\n    LDR     R3, [R11,#ch]\n    STR     R2, [R3]\n    \n    // Check if clist is empty\n    LDR     R3, [R11,#clist]\n    LDR     R3, [R3]\n    CMP     R3, #0\n    BEQ     loc_52550\n    \n    // Store ch in the second element of clist\n    LDR     R3, [R11,#clist]\n    LDR     R3, [R3]\n    LDR     R2, [R11,#ch]\n    STR     R2, [R3,#4]\n    \n    // Store ch in the third element of clist\n    LDR     R3, [R11,#clist]\n    LDR     R2, [R11,#ch]\n    STR     R2, [R3]\n    \n    // Clean up stack frame\n    SUB     SP, R11, #4\n    \n    // Restore registers and return\n    POP     {R11,PC}\n}\n```"
    },
    {
        "func_name": "dict_flush",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000F4FBC | 00 48 2D E9 | PUSH    {R11,LR}\n0x000F4FC0 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000F4FC4 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x000F4FC8 | 10 00 0B E5 | STR     R0, [R11,#dict]\n0x000F4FCC | 14 10 0B E5 | STR     R1, [R11,#b]\n0x000F4FD0 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F4FD4 | 08 20 93 E5 | LDR     R2, [R3,#8]\n0x000F4FD8 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F4FDC | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000F4FE0 | 03 30 42 E0 | SUB     R3, R2, R3\n0x000F4FE4 | 08 30 0B E5 | STR     R3, [R11,#copy_size]\n0x000F4FE8 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F4FEC | 08 20 93 E5 | LDR     R2, [R3,#8]\n0x000F4FF0 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F4FF4 | 14 30 93 E5 | LDR     R3, [R3,#0x14]\n0x000F4FF8 | 03 00 52 E1 | CMP     R2, R3\n0x000F4FFC | 02 00 00 1A | BNE     loc_F500C\n0x000F5000 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F5004 | 00 20 A0 E3 | MOV     R2, #0\n0x000F5008 | 08 20 83 E5 | STR     R2, [R3,#8]\n0x000F500C | 14 30 1B E5 | LDR     R3, [R11,#b]\n0x000F5010 | 0C 20 93 E5 | LDR     R2, [R3,#0xC]\n0x000F5014 | 14 30 1B E5 | LDR     R3, [R11,#b]\n0x000F5018 | 10 30 93 E5 | LDR     R3, [R3,#0x10]\n0x000F501C | 03 00 82 E0 | ADD     R0, R2, R3; dest\n0x000F5020 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F5024 | 00 20 93 E5 | LDR     R2, [R3]\n0x000F5028 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F502C | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000F5030 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000F5034 | 08 20 1B E5 | LDR     R2, [R11,#copy_size]; n\n0x000F5038 | 03 10 A0 E1 | MOV     R1, R3; src\n0x000F503C | B6 7F FC EB | BL      memcpy\n0x000F5040 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F5044 | 08 20 93 E5 | LDR     R2, [R3,#8]\n0x000F5048 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F504C | 04 20 83 E5 | STR     R2, [R3,#4]\n0x000F5050 | 14 30 1B E5 | LDR     R3, [R11,#b]\n0x000F5054 | 10 20 93 E5 | LDR     R2, [R3,#0x10]\n0x000F5058 | 08 30 1B E5 | LDR     R3, [R11,#copy_size]\n0x000F505C | 03 20 82 E0 | ADD     R2, R2, R3\n0x000F5060 | 14 30 1B E5 | LDR     R3, [R11,#b]\n0x000F5064 | 10 20 83 E5 | STR     R2, [R3,#0x10]\n0x000F5068 | 08 30 1B E5 | LDR     R3, [R11,#copy_size]\n0x000F506C | 03 00 A0 E1 | MOV     R0, R3\n0x000F5070 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000F5074 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(int* dict, int* b, int copy_size) {\n    dict[0] = dict;\n    b[0] = b;\n    int* dict_ptr = dict;\n    int* b_ptr = b;\n    int diff = dict_ptr[1] - dict_ptr[0];\n    copy_size = diff;\n    dict_ptr[1] = 0;\n    int* b_ptr2 = b_ptr[3];\n    int* b_ptr3 = b_ptr[4];\n    if (b_ptr2 != b_ptr3) {\n        dict_ptr[1] = b_ptr2;\n        int* b_ptr4 = b_ptr[5];\n        int* b_ptr5 = b_ptr[6];\n        int dest = b_ptr4 + b_ptr5;\n        int* dict_ptr2 = dict_ptr[0];\n        int* dict_ptr3 = dict_ptr[1];\n        int src = dict_ptr2 + dict_ptr3;\n        memcpy(dest, src, copy_size);\n        dict_ptr[1] = b_ptr4;\n    }\n    int* b_ptr6 = b_ptr[6];\n    int* b_ptr7 = b_ptr[7];\n    int n = b_ptr6 + b_ptr7;\n    b_ptr[4] = n;\n    int* copy_size_ptr = copy_size;\n    int* b_ptr8 = b_ptr[5];\n    int* b_ptr9 = b_ptr[6];\n    int src = b_ptr8 + b_ptr9;\n    memcpy(dict_ptr, src, copy_size_ptr);\n}\n```"
    },
    {
        "func_name": "fmt_100percent_8",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00089514 | 00 48 2D E9 | PUSH    {R11,LR}\n0x00089518 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0008951C | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x00089520 | 10 00 0B E5 | STR     R0, [R11,#pbuf]\n0x00089524 | 14 10 0B E5 | STR     R1, [R11,#value]\n0x00089528 | 18 20 0B E5 | STR     R2, [R11,#total]\n0x0008952C | 14 20 1B E5 | LDR     R2, [R11,#value]\n0x00089530 | 18 30 1B E5 | LDR     R3, [R11,#total]\n0x00089534 | 03 00 52 E1 | CMP     R2, R3\n0x00089538 | 08 00 00 3A | BCC     loc_89560\n0x0008953C | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x00089540 | 7C 21 9F E5 | LDR     R2, =a100; \"  100% \"\n0x00089544 | 03 00 A0 E1 | MOV     R0, R3; dest\n0x00089548 | 02 10 A0 E1 | MOV     R1, R2; src\n0x0008954C | 08 30 A0 E3 | MOV     R3, #8\n0x00089550 | 03 20 A0 E1 | MOV     R2, R3; n\n0x00089554 | 70 2E FE EB | BL      memcpy\n0x00089558 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x0008955C | 55 00 00 EA | B       loc_896B8\n0x00089560 | 14 20 1B E5 | LDR     R2, [R11,#value]\n0x00089564 | 02 30 A0 E1 | MOV     R3, R2\n0x00089568 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x0008956C | 02 30 43 E0 | SUB     R3, R3, R2\n0x00089570 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00089574 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00089578 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x0008957C | 18 10 1B E5 | LDR     R1, [R11,#total]\n0x00089580 | 03 00 A0 E1 | MOV     R0, R3\n0x00089584 | BF 36 03 EB | BL      __udivsi3\n0x00089588 | 00 30 A0 E1 | MOV     R3, R0\n0x0008958C | 14 30 0B E5 | STR     R3, [R11,#value]\n0x00089590 | 14 00 1B E5 | LDR     R0, [R11,#value]\n0x00089594 | 2C 21 9F E5 | LDR     R2, =0x51EB851F\n0x00089598 | 92 10 83 E0 | UMULL   R1, R3, R2, R0\n0x0008959C | A3 32 A0 E1 | MOV     R3, R3,LSR#5\n0x000895A0 | 08 30 0B E5 | STR     R3, [R11,#t]\n0x000895A4 | 14 20 1B E5 | LDR     R2, [R11,#value]\n0x000895A8 | 18 31 9F E5 | LDR     R3, =0x51EB851F\n0x000895AC | 92 13 80 E0 | UMULL   R1, R0, R2, R3\n0x000895B0 | A0 12 A0 E1 | MOV     R1, R0,LSR#5\n0x000895B4 | 01 30 A0 E1 | MOV     R3, R1\n0x000895B8 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000895BC | 01 30 83 E0 | ADD     R3, R3, R1\n0x000895C0 | 03 11 A0 E1 | MOV     R1, R3,LSL#2\n0x000895C4 | 01 30 83 E0 | ADD     R3, R3, R1\n0x000895C8 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000895CC | 03 30 42 E0 | SUB     R3, R2, R3\n0x000895D0 | 14 30 0B E5 | STR     R3, [R11,#value]\n0x000895D4 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x000895D8 | 20 20 A0 E3 | MOV     R2, #0x20 ; ' '\n0x000895DC | 00 20 C3 E5 | STRB    R2, [R3]\n0x000895E0 | 08 30 1B E5 | LDR     R3, [R11,#t]\n0x000895E4 | 00 00 53 E3 | CMP     R3, #0\n0x000895E8 | 04 00 00 0A | BEQ     loc_89600\n0x000895EC | 08 30 1B E5 | LDR     R3, [R11,#t]\n0x000895F0 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x000895F4 | 30 30 83 E2 | ADD     R3, R3, #0x30 ; '0'\n0x000895F8 | FF 20 03 E2 | AND     R2, R3, #0xFF\n0x000895FC | 00 00 00 EA | B       loc_89604\n0x00089600 | 20 20 A0 E3 | MOV     R2, #0x20 ; ' '\n0x00089604 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x00089608 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0008960C | 00 20 C3 E5 | STRB    R2, [R3]\n0x00089610 | 14 00 1B E5 | LDR     R0, [R11,#value]\n0x00089614 | B0 20 9F E5 | LDR     R2, =0xCCCCCCCD\n0x00089618 | 92 10 83 E0 | UMULL   R1, R3, R2, R0\n0x0008961C | A3 31 A0 E1 | MOV     R3, R3,LSR#3\n0x00089620 | FF 20 03 E2 | AND     R2, R3, #0xFF\n0x00089624 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x00089628 | 02 30 83 E2 | ADD     R3, R3, #2\n0x0008962C | 30 20 82 E2 | ADD     R2, R2, #0x30 ; '0'\n0x00089630 | FF 20 02 E2 | AND     R2, R2, #0xFF\n0x00089634 | 00 20 C3 E5 | STRB    R2, [R3]\n0x00089638 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x0008963C | 03 30 83 E2 | ADD     R3, R3, #3\n0x00089640 | 2E 20 A0 E3 | MOV     R2, #0x2E ; '.'\n0x00089644 | 00 20 C3 E5 | STRB    R2, [R3]\n0x00089648 | 14 10 1B E5 | LDR     R1, [R11,#value]\n0x0008964C | 78 30 9F E5 | LDR     R3, =0xCCCCCCCD\n0x00089650 | 91 23 80 E0 | UMULL   R2, R0, R1, R3\n0x00089654 | A0 21 A0 E1 | MOV     R2, R0,LSR#3\n0x00089658 | 02 30 A0 E1 | MOV     R3, R2\n0x0008965C | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00089660 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00089664 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x00089668 | 03 20 41 E0 | SUB     R2, R1, R3\n0x0008966C | FF 20 02 E2 | AND     R2, R2, #0xFF\n0x00089670 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x00089674 | 04 30 83 E2 | ADD     R3, R3, #4\n0x00089678 | 30 20 82 E2 | ADD     R2, R2, #0x30 ; '0'\n0x0008967C | FF 20 02 E2 | AND     R2, R2, #0xFF\n0x00089680 | 00 20 C3 E5 | STRB    R2, [R3]\n0x00089684 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x00089688 | 05 30 83 E2 | ADD     R3, R3, #5\n0x0008968C | 25 20 A0 E3 | MOV     R2, #0x25 ; '%'\n0x00089690 | 00 20 C3 E5 | STRB    R2, [R3]\n0x00089694 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x00089698 | 06 30 83 E2 | ADD     R3, R3, #6\n0x0008969C | 20 20 A0 E3 | MOV     R2, #0x20 ; ' '\n0x000896A0 | 00 20 C3 E5 | STRB    R2, [R3]\n0x000896A4 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x000896A8 | 07 30 83 E2 | ADD     R3, R3, #7\n0x000896AC | 00 20 A0 E3 | MOV     R2, #0\n0x000896B0 | 00 20 C3 E5 | STRB    R2, [R3]\n0x000896B4 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x000896B8 | 03 00 A0 E1 | MOV     R0, R3\n0x000896BC | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000896C0 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(int pbuf, int value, int total) {\n    pbuf = 0;\n    value = 0;\n    total = 0;\n    \n    if (value <= total) {\n        memcpy(pbuf, \"  100% \", 8);\n    } else {\n        int t = value - total;\n        int t_divided = t / 0xCCCCCCCD;\n        value = t_divided;\n        \n        int t_mod = t % 0xCCCCCCCD;\n        int t_mod_divided = t_mod / 0x51EB851F;\n        int t_mod_mod = t_mod % 0x51EB851F;\n        \n        pbuf[0] = ' ';\n        pbuf[1] = t_mod_divided + '0';\n        pbuf[2] = '.';\n        pbuf[3] = t_mod_mod / 0x51EB851F + '0';\n        pbuf[4] = '%';\n        pbuf[5] = ' ';\n        pbuf[6] = 0;\n    }\n}\n```"
    },
    {
        "func_name": "show_min_max",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000246DC | 00 48 2D E9 | PUSH    {R11,LR}\n0x000246E0 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000246E4 | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x000246E8 | 18 00 0B E5 | STR     R0, [R11,#pol]\n0x000246EC | 64 30 9F E5 | LDR     R3, =aSMinMaxPriorit; \"%s min/max priority\\t: %u/%u\\n\"\n0x000246F0 | 08 30 0B E5 | STR     R3, [R11,#fmt]\n0x000246F4 | 18 00 1B E5 | LDR     R0, [R11,#pol]; algorithm\n0x000246F8 | 2A C3 FF EB | BL      sched_get_priority_max\n0x000246FC | 0C 00 0B E5 | STR     R0, [R11,#max]\n0x00024700 | 18 00 1B E5 | LDR     R0, [R11,#pol]; algorithm\n0x00024704 | 5C C1 FF EB | BL      sched_get_priority_min\n0x00024708 | 10 00 0B E5 | STR     R0, [R11,#min]\n0x0002470C | 0C 20 1B E5 | LDR     R2, [R11,#max]\n0x00024710 | 10 30 1B E5 | LDR     R3, [R11,#min]\n0x00024714 | 03 30 82 E1 | ORR     R3, R2, R3\n0x00024718 | 00 00 53 E3 | CMP     R3, #0\n0x0002471C | 01 00 00 AA | BGE     loc_24728\n0x00024720 | 34 30 9F E5 | LDR     R3, =aSNotSupported; \"%s not supported\\n\"\n0x00024724 | 08 30 0B E5 | STR     R3, [R11,#fmt]\n0x00024728 | 18 30 1B E5 | LDR     R3, [R11,#pol]\n0x0002472C | 03 32 A0 E1 | MOV     R3, R3,LSL#4\n0x00024730 | 28 20 9F E5 | LDR     R2, =policies\n0x00024734 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00024738 | 04 10 83 E2 | ADD     R1, R3, #4\n0x0002473C | 0C 30 1B E5 | LDR     R3, [R11,#max]\n0x00024740 | 10 20 1B E5 | LDR     R2, [R11,#min]\n0x00024744 | 08 00 1B E5 | LDR     R0, [R11,#fmt]; format\n0x00024748 | A2 C1 FF EB | BL      printf\n0x0002474C | 00 00 A0 E1 | NOP\n0x00024750 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00024754 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function() {\n    int pol = 0;\n    int max, min;\n    char* fmt;\n    \n    max = sched_get_priority_max(pol);\n    min = sched_get_priority_min(pol);\n    \n    if (max + min > 0) {\n        fmt = \"%s min/max priority\\t: %u/%u\\n\";\n    } else {\n        fmt = \"%s not supported\\n\";\n    }\n    \n    printf(fmt, pol, min, max);\n}\n```"
    },
    {
        "func_name": "dmesg_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000BC898 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000BC89C | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000BC8A0 | 20 D0 4D E2 | SUB     SP, SP, #0x20\n0x000BC8A4 | 20 00 0B E5 | STR     R0, [R11,#argc]\n0x000BC8A8 | 24 10 0B E5 | STR     R1, [R11,#argv]\n0x000BC8AC | EC 31 9F E5 | LDR     R3, =opt_complementary\n0x000BC8B0 | EC 21 9F E5 | LDR     R2, =aSN; \"s+:n+\"\n0x000BC8B4 | 00 20 83 E5 | STR     R2, [R3]\n0x000BC8B8 | 1C 30 4B E2 | SUB     R3, R11, #-level\n0x000BC8BC | 18 20 4B E2 | SUB     R2, R11, #-len\n0x000BC8C0 | E0 11 9F E5 | LDR     R1, =aCsN; \"cs:n:\"\n0x000BC8C4 | 24 00 1B E5 | LDR     R0, [R11,#argv]; argv\n0x000BC8C8 | F6 11 02 EB | BL      getopt32\n0x000BC8CC | 10 00 0B E5 | STR     R0, [R11,#opts]\n0x000BC8D0 | 10 30 1B E5 | LDR     R3, [R11,#opts]\n0x000BC8D4 | 04 30 03 E2 | AND     R3, R3, #4\n0x000BC8D8 | 00 00 53 E3 | CMP     R3, #0\n0x000BC8DC | 0B 00 00 0A | BEQ     loc_BC910\n0x000BC8E0 | 1C 30 1B E5 | LDR     R3, [R11,#level]\n0x000BC8E4 | 03 20 A0 E1 | MOV     R2, R3; len\n0x000BC8E8 | 00 10 A0 E3 | MOV     R1, #0; bufp\n0x000BC8EC | 08 00 A0 E3 | MOV     R0, #8; type\n0x000BC8F0 | 81 63 FD EB | BL      klogctl\n0x000BC8F4 | 00 30 A0 E1 | MOV     R3, R0\n0x000BC8F8 | 00 00 53 E3 | CMP     R3, #0\n0x000BC8FC | 01 00 00 0A | BEQ     loc_BC908\n0x000BC900 | A4 01 9F E5 | LDR     R0, =aKlogctl_0; \"klogctl\"\n0x000BC904 | FC 6F FD EB | BL      bb_perror_msg_and_die\n0x000BC908 | 00 30 A0 E3 | MOV     R3, #0\n0x000BC90C | 60 00 00 EA | B       loc_BCA94\n0x000BC910 | 10 30 1B E5 | LDR     R3, [R11,#opts]\n0x000BC914 | 02 30 03 E2 | AND     R3, R3, #2\n0x000BC918 | 00 00 53 E3 | CMP     R3, #0\n0x000BC91C | 05 00 00 1A | BNE     loc_BC938\n0x000BC920 | 00 20 A0 E3 | MOV     R2, #0; len\n0x000BC924 | 00 10 A0 E3 | MOV     R1, #0; bufp\n0x000BC928 | 0A 00 A0 E3 | MOV     R0, #0xA; type\n0x000BC92C | 72 63 FD EB | BL      klogctl\n0x000BC930 | 00 30 A0 E1 | MOV     R3, R0\n0x000BC934 | 18 30 0B E5 | STR     R3, [R11,#len]\n0x000BC938 | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BC93C | 01 09 53 E3 | CMP     R3, #0x4000\n0x000BC940 | 01 00 00 AA | BGE     loc_BC94C\n0x000BC944 | 01 39 A0 E3 | MOV     R3, #0x4000\n0x000BC948 | 18 30 0B E5 | STR     R3, [R11,#len]\n0x000BC94C | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BC950 | 01 04 53 E3 | CMP     R3, #0x1000000\n0x000BC954 | 01 00 00 DA | BLE     loc_BC960\n0x000BC958 | 01 34 A0 E3 | MOV     R3, #0x1000000\n0x000BC95C | 18 30 0B E5 | STR     R3, [R11,#len]\n0x000BC960 | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BC964 | 03 00 A0 E1 | MOV     R0, R3; size\n0x000BC968 | 44 74 FD EB | BL      xmalloc\n0x000BC96C | 00 30 A0 E1 | MOV     R3, R0\n0x000BC970 | 14 30 0B E5 | STR     R3, [R11,#buf]\n0x000BC974 | 10 30 1B E5 | LDR     R3, [R11,#opts]\n0x000BC978 | 01 30 03 E2 | AND     R3, R3, #1\n0x000BC97C | 03 30 83 E2 | ADD     R3, R3, #3\n0x000BC980 | 03 00 A0 E1 | MOV     R0, R3; type\n0x000BC984 | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BC988 | 03 20 A0 E1 | MOV     R2, R3; len\n0x000BC98C | 14 10 1B E5 | LDR     R1, [R11,#buf]; bufp\n0x000BC990 | 59 63 FD EB | BL      klogctl\n0x000BC994 | 00 30 A0 E1 | MOV     R3, R0\n0x000BC998 | 18 30 0B E5 | STR     R3, [R11,#len]\n0x000BC99C | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BC9A0 | 00 00 53 E3 | CMP     R3, #0\n0x000BC9A4 | 01 00 00 AA | BGE     loc_BC9B0\n0x000BC9A8 | FC 00 9F E5 | LDR     R0, =aKlogctl_0; \"klogctl\"\n0x000BC9AC | D2 6F FD EB | BL      bb_perror_msg_and_die\n0x000BC9B0 | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BC9B4 | 00 00 53 E3 | CMP     R3, #0\n0x000BC9B8 | 01 00 00 1A | BNE     loc_BC9C4\n0x000BC9BC | 00 30 A0 E3 | MOV     R3, #0\n0x000BC9C0 | 33 00 00 EA | B       loc_BCA94\n0x000BC9C4 | 0A 30 A0 E3 | MOV     R3, #0xA\n0x000BC9C8 | 08 30 0B E5 | STR     R3, [R11,#last]\n0x000BC9CC | 00 30 A0 E3 | MOV     R3, #0\n0x000BC9D0 | 0C 30 0B E5 | STR     R3, [R11,#in]\n0x000BC9D4 | 08 30 1B E5 | LDR     R3, [R11,#last]\n0x000BC9D8 | 0A 00 53 E3 | CMP     R3, #0xA\n0x000BC9DC | 14 00 00 1A | BNE     loc_BCA34\n0x000BC9E0 | 0C 30 1B E5 | LDR     R3, [R11,#in]\n0x000BC9E4 | 14 20 1B E5 | LDR     R2, [R11,#buf]\n0x000BC9E8 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000BC9EC | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000BC9F0 | 3C 00 53 E3 | CMP     R3, #0x3C ; '<'\n0x000BC9F4 | 0E 00 00 1A | BNE     loc_BCA34\n0x000BC9F8 | 00 00 A0 E1 | NOP\n0x000BC9FC | 0C 30 1B E5 | LDR     R3, [R11,#in]\n0x000BCA00 | 01 20 83 E2 | ADD     R2, R3, #1\n0x000BCA04 | 0C 20 0B E5 | STR     R2, [R11,#in]\n0x000BCA08 | 03 20 A0 E1 | MOV     R2, R3\n0x000BCA0C | 14 30 1B E5 | LDR     R3, [R11,#buf]\n0x000BCA10 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000BCA14 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000BCA18 | 3E 00 53 E3 | CMP     R3, #0x3E ; '>'\n0x000BCA1C | 0F 00 00 0A | BEQ     loc_BCA60\n0x000BCA20 | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BCA24 | 0C 20 1B E5 | LDR     R2, [R11,#in]\n0x000BCA28 | 03 00 52 E1 | CMP     R2, R3\n0x000BCA2C | F2 FF FF BA | BLT     loc_BC9FC\n0x000BCA30 | 0A 00 00 EA | B       loc_BCA60\n0x000BCA34 | 0C 30 1B E5 | LDR     R3, [R11,#in]\n0x000BCA38 | 01 20 83 E2 | ADD     R2, R3, #1\n0x000BCA3C | 0C 20 0B E5 | STR     R2, [R11,#in]\n0x000BCA40 | 03 20 A0 E1 | MOV     R2, R3\n0x000BCA44 | 14 30 1B E5 | LDR     R3, [R11,#buf]\n0x000BCA48 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000BCA4C | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000BCA50 | 08 30 0B E5 | STR     R3, [R11,#last]\n0x000BCA54 | 08 00 1B E5 | LDR     R0, [R11,#last]; c\n0x000BCA58 | CB 64 FD EB | BL      putchar_unlocked\n0x000BCA5C | 00 00 00 EA | B       loc_BCA64\n0x000BCA60 | 00 00 A0 E1 | NOP\n0x000BCA64 | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BCA68 | 0C 20 1B E5 | LDR     R2, [R11,#in]\n0x000BCA6C | 03 00 52 E1 | CMP     R2, R3\n0x000BCA70 | 00 00 00 AA | BGE     loc_BCA78\n0x000BCA74 | D6 FF FF EA | B       loc_BC9D4\n0x000BCA78 | 00 00 A0 E1 | NOP\n0x000BCA7C | 08 30 1B E5 | LDR     R3, [R11,#last]\n0x000BCA80 | 0A 00 53 E3 | CMP     R3, #0xA\n0x000BCA84 | 01 00 00 0A | BEQ     loc_BCA90\n0x000BCA88 | 0A 00 A0 E3 | MOV     R0, #0xA; ch\n0x000BCA8C | E7 75 FD EB | BL      bb_putchar\n0x000BCA90 | 00 30 A0 E3 | MOV     R3, #0\n0x000BCA94 | 03 00 A0 E1 | MOV     R0, R3\n0x000BCA98 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000BCA9C | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdio.h>\n\nvoid function(int argc, char** argv) {\n    int level = argc;\n    int len = argc;\n    char* opt_complementary = \"s+:n+\";\n    char* opt_string = \"cs:n:\";\n    char* bufp = 0;\n    int type = 8;\n    int opts = getopt32(argc, argv, opt_string);\n    int opts_flag = opts & 4;\n    \n    if (opts_flag == 0) {\n        int buf_size = klogctl(type, bufp, len);\n        if (buf_size != 0) {\n            bb_perror_msg_and_die(\"klogctl\");\n        }\n    }\n    \n    int opts_flag2 = opts & 2;\n    if (opts_flag2 != 0) {\n        int buf_size = klogctl(0xA, bufp, 0);\n        len = buf_size;\n        if (len > 0x4000) {\n            len = 0x4000;\n        }\n        if (len > 0x1000000) {\n            len = 0x1000000;\n        }\n        char* buf = xmalloc(len);\n        int buf_size2 = klogctl(type, buf, len);\n        if (buf_size2 != 0) {\n            bb_perror_msg_and_die(\"klogctl\");\n        }\n        if (buf_size2 > 0) {\n            int i;\n            for (i = 0; i < buf_size2; i++) {\n                putchar_unlocked(buf[i]);\n            }\n        }\n    }\n    \n    int opts_flag3 = opts & 1;\n    opts_flag3 += 3;\n    int buf_size = klogctl(opts_flag3, len, bufp);\n    if (buf_size != 0) {\n        bb_perror_msg_and_die(\"klogctl\");\n    }\n    \n    if (len == 0) {\n        bb_perror_msg_and_die(\"klogctl\");\n    }\n    \n    if (last == 0xA) {\n        int in = 0;\n        int last = 0;\n        while (1) {\n            if (buf[in] == '<') {\n                in++;\n                if (buf[in] == '>') {\n                    break;\n                }\n            }\n            last = buf[in];\n            putchar_unlocked(last);\n            in++;\n        }\n    }\n    \n    if (last != 0xA) {\n        putchar_unlocked(0xA);\n    }\n    \n    return;\n}\n```"
    },
    {
        "func_name": "make_default_cur_rule",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000CCEE0 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000CCEE4 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000CCEE8 | 2C 30 9F E5 | LDR     R3, =(qword_18F9F8+4)\n0x000CCEEC | 4C 20 A0 E3 | MOV     R2, #0x4C ; 'L'; n\n0x000CCEF0 | 00 10 A0 E3 | MOV     R1, #0; c\n0x000CCEF4 | 03 00 A0 E1 | MOV     R0, R3; s\n0x000CCEF8 | 1A 22 FD EB | BL      memset\n0x000CCEFC | 1C 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CCF00 | 00 20 E0 E3 | MOV     R2, #0xFFFFFFFF\n0x000CCF04 | 2C 20 83 E5 | STR     R2, [R3,#(unk_18FA04 - 0x18F9D8)]\n0x000CCF08 | 10 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CCF0C | 1B 2E A0 E3 | MOV     R2, #0x1B0\n0x000CCF10 | 28 20 83 E5 | STR     R2, [R3,#(unk_18FA00 - 0x18F9D8)]\n0x000CCF14 | 00 00 A0 E1 | NOP\n0x000CCF18 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function() {\n    int* qword_18F9F8 = (int*)0x18F9F8;\n    int* bb_common_bufsiz1 = (int*)0x18FA04;\n    \n    int n = 0x4C;\n    int c = 0;\n    \n    memset(qword_18F9F8 + 4, c, n);\n    \n    *bb_common_bufsiz1 = 0xFFFFFFFF;\n    *(bb_common_bufsiz1 + (0x18FA04 - 0x18F9D8)) = *bb_common_bufsiz1;\n    \n    *bb_common_bufsiz1 = 0x1B0;\n    *(bb_common_bufsiz1 + (0x18FA00 - 0x18F9D8)) = *bb_common_bufsiz1;\n}\n```"
    },
    {
        "func_name": "branch_to",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0012D55C | 00 48 2D E9 | PUSH    {R11,LR}\n0x0012D560 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0012D564 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x0012D568 | 10 00 0B E5 | STR     R0, [R11,#label]\n0x0012D56C | 80 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0012D570 | 74 30 93 E5 | LDR     R3, [R3,#(byte_18FA48+4 - 0x18F9D8)]\n0x0012D574 | 08 30 0B E5 | STR     R3, [R11,#sed_cmd]\n0x0012D578 | 14 00 00 EA | B       loc_12D5D0\n0x0012D57C | 08 30 1B E5 | LDR     R3, [R11,#sed_cmd]\n0x0012D580 | 2A 30 D3 E5 | LDRB    R3, [R3,#0x2A]\n0x0012D584 | 3A 00 53 E3 | CMP     R3, #0x3A ; ':'\n0x0012D588 | 0D 00 00 1A | BNE     loc_12D5C4\n0x0012D58C | 08 30 1B E5 | LDR     R3, [R11,#sed_cmd]\n0x0012D590 | 20 30 93 E5 | LDR     R3, [R3,#0x20]\n0x0012D594 | 00 00 53 E3 | CMP     R3, #0\n0x0012D598 | 09 00 00 0A | BEQ     loc_12D5C4\n0x0012D59C | 08 30 1B E5 | LDR     R3, [R11,#sed_cmd]\n0x0012D5A0 | 20 30 93 E5 | LDR     R3, [R3,#0x20]\n0x0012D5A4 | 10 10 1B E5 | LDR     R1, [R11,#label]; s2\n0x0012D5A8 | 03 00 A0 E1 | MOV     R0, R3; s1\n0x0012D5AC | E8 9D FB EB | BL      strcmp\n0x0012D5B0 | 00 30 A0 E1 | MOV     R3, R0\n0x0012D5B4 | 00 00 53 E3 | CMP     R3, #0\n0x0012D5B8 | 01 00 00 1A | BNE     loc_12D5C4\n0x0012D5BC | 08 30 1B E5 | LDR     R3, [R11,#sed_cmd]\n0x0012D5C0 | 08 00 00 EA | B       loc_12D5E8\n0x0012D5C4 | 08 30 1B E5 | LDR     R3, [R11,#sed_cmd]\n0x0012D5C8 | 00 30 93 E5 | LDR     R3, [R3]\n0x0012D5CC | 08 30 0B E5 | STR     R3, [R11,#sed_cmd]\n0x0012D5D0 | 08 30 1B E5 | LDR     R3, [R11,#sed_cmd]\n0x0012D5D4 | 00 00 53 E3 | CMP     R3, #0\n0x0012D5D8 | E7 FF FF 1A | BNE     loc_12D57C\n0x0012D5DC | 10 10 1B E5 | LDR     R1, [R11,#label]\n0x0012D5E0 | 10 00 9F E5 | LDR     R0, =aCanTFindLabelF; \"can't find label for jump to '%s'\"\n0x0012D5E4 | EB AD FB EB | BL      bb_error_msg_and_die\n0x0012D5E8 | 03 00 A0 E1 | MOV     R0, R3\n0x0012D5EC | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0012D5F0 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(int sed_cmd, char* label) {\n    PUSH    {R11,LR}\n    ADD     R11, SP, #4\n    SUB     SP, SP, #0x10\n    STR     R0, [R11,#label]\n    LDR     R3, =bb_common_bufsiz1\n    LDR     R3, [R3,#(byte_18FA48+4 - 0x18F9D8)]\n    STR     R3, [R11,#sed_cmd]\n    B       loc_12D5D0\nloc_12D5C4:\n    LDR     R3, [R11,#sed_cmd]\n    LDRB    R3, [R3,#0x2A]\n    CMP     R3, #0x3A ; ':'\n    BNE     loc_12D5C4\n    LDR     R3, [R11,#sed_cmd]\n    LDR     R3, [R3,#0x20]\n    CMP     R3, #0\n    BEQ     loc_12D5C4\n    LDR     R3, [R11,#sed_cmd]\n    LDR     R3, [R3,#0x20]\n    LDR     R1, [R11,#label]; s2\n    MOV     R0, R3; s1\n    BL      strcmp\n    MOV     R3, R0\n    CMP     R3, #0\n    BNE     loc_12D5C4\n    LDR     R3, [R11,#sed_cmd]\n    B       loc_12D5E8\nloc_12D5D0:\n    LDR     R3, [R11,#sed_cmd]\n    CMP     R3, #0\n    BNE     loc_12D5C4\n    LDR     R1, [R11,#label]\n    LDR     R0, =aCanTFindLabelF; \"can't find label for jump to '%s'\"\n    BL      bb_error_msg_and_die\nloc_12D5E8:\n    MOV     R0, R3\n    SUB     SP, R11, #4\n    POP     {R11,PC}\n}\n```"
    },
    {
        "func_name": "add_inode",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0007C020 | 10 48 2D E9 | PUSH    {R4,R11,LR}\n0x0007C024 | 08 B0 8D E2 | ADD     R11, SP, #8\n0x0007C028 | 14 D0 4D E2 | SUB     SP, SP, #0x14\n0x0007C02C | 18 00 0B E5 | STR     R0, [R11,#st]\n0x0007C030 | C8 30 9F E5 | LDR     R3, =unk_18F9E0\n0x0007C034 | 10 30 0B E5 | STR     R3, [R11,#curr]\n0x0007C038 | 15 00 00 EA | B       loc_7C094\n0x0007C03C | 10 30 1B E5 | LDR     R3, [R11,#curr]\n0x0007C040 | 00 30 93 E5 | LDR     R3, [R3]\n0x0007C044 | 10 20 83 E2 | ADD     R2, R3, #0x10\n0x0007C048 | 06 00 92 E8 | LDM     R2, {R1,R2}\n0x0007C04C | 18 30 1B E5 | LDR     R3, [R11,#st]\n0x0007C050 | 18 00 93 E8 | LDM     R3, {R3,R4}\n0x0007C054 | 04 00 52 E1 | CMP     R2, R4\n0x0007C058 | 03 00 51 01 | CMPEQ   R1, R3\n0x0007C05C | 09 00 00 1A | BNE     loc_7C088\n0x0007C060 | 10 30 1B E5 | LDR     R3, [R11,#curr]\n0x0007C064 | 00 30 93 E5 | LDR     R3, [R3]\n0x0007C068 | 08 20 83 E2 | ADD     R2, R3, #8\n0x0007C06C | 06 00 92 E8 | LDM     R2, {R1,R2}\n0x0007C070 | 18 30 1B E5 | LDR     R3, [R11,#st]\n0x0007C074 | 60 40 83 E2 | ADD     R4, R3, #0x60 ; '`'\n0x0007C078 | 18 00 94 E8 | LDM     R4, {R3,R4}\n0x0007C07C | 04 00 52 E1 | CMP     R2, R4\n0x0007C080 | 03 00 51 01 | CMPEQ   R1, R3\n0x0007C084 | 1A 00 00 0A | BEQ     loc_7C0F4\n0x0007C088 | 10 30 1B E5 | LDR     R3, [R11,#curr]\n0x0007C08C | 00 30 93 E5 | LDR     R3, [R3]\n0x0007C090 | 10 30 0B E5 | STR     R3, [R11,#curr]\n0x0007C094 | 10 30 1B E5 | LDR     R3, [R11,#curr]\n0x0007C098 | 00 30 93 E5 | LDR     R3, [R3]\n0x0007C09C | 00 00 53 E3 | CMP     R3, #0\n0x0007C0A0 | E5 FF FF 1A | BNE     loc_7C03C\n0x0007C0A4 | 18 00 A0 E3 | MOV     R0, #0x18; size\n0x0007C0A8 | 9F 76 FE EB | BL      xzalloc\n0x0007C0AC | 00 30 A0 E1 | MOV     R3, R0\n0x0007C0B0 | 03 20 A0 E1 | MOV     R2, R3\n0x0007C0B4 | 10 30 1B E5 | LDR     R3, [R11,#curr]\n0x0007C0B8 | 00 20 83 E5 | STR     R2, [R3]\n0x0007C0BC | 10 30 1B E5 | LDR     R3, [R11,#curr]\n0x0007C0C0 | 00 20 93 E5 | LDR     R2, [R3]\n0x0007C0C4 | 18 30 1B E5 | LDR     R3, [R11,#st]\n0x0007C0C8 | 18 00 93 E8 | LDM     R3, {R3,R4}\n0x0007C0CC | 10 30 82 E5 | STR     R3, [R2,#0x10]\n0x0007C0D0 | 14 40 82 E5 | STR     R4, [R2,#0x14]\n0x0007C0D4 | 10 30 1B E5 | LDR     R3, [R11,#curr]\n0x0007C0D8 | 00 20 93 E5 | LDR     R2, [R3]\n0x0007C0DC | 18 30 1B E5 | LDR     R3, [R11,#st]\n0x0007C0E0 | 60 40 83 E2 | ADD     R4, R3, #0x60 ; '`'\n0x0007C0E4 | 18 00 94 E8 | LDM     R4, {R3,R4}\n0x0007C0E8 | 08 30 82 E5 | STR     R3, [R2,#8]\n0x0007C0EC | 0C 40 82 E5 | STR     R4, [R2,#0xC]\n0x0007C0F0 | 00 00 00 EA | B       loc_7C0F8\n0x0007C0F4 | 00 00 A0 E1 | NOP\n0x0007C0F8 | 08 D0 4B E2 | SUB     SP, R11, #8\n0x0007C0FC | 10 88 BD E8 | POP     {R4,R11,PC}",
        "output": "```c\nvoid function() {\n    int st;\n    int curr;\n    \n    // Save registers\n    __asm__(\"PUSH {R4,R11,LR}\");\n    \n    // Set up stack frame\n    __asm__(\"ADD R11, SP, #8\");\n    __asm__(\"SUB SP, SP, #0x14\");\n    \n    // Store R0 in st\n    __asm__(\"STR R0, [R11,#st]\");\n    \n    // Load address of unk_18F9E0 into R3\n    __asm__(\"LDR R3, =unk_18F9E0\");\n    \n    // Store R3 in curr\n    __asm__(\"STR R3, [R11,#curr]\");\n    \n    // Jump to loc_7C094\n    __asm__(\"B loc_7C094\");\n    \nloc_7C094:\n    // Load value at curr into R3\n    __asm__(\"LDR R3, [R11,#curr]\");\n    \n    // Load value at R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n    \n    // Add 0x10 to R3 and store in R2\n    __asm__(\"ADD R2, R3, #0x10\");\n    \n    // Load values at R2 into R1 and R2\n    __asm__(\"LDM R2, {R1,R2}\");\n    \n    // Load value at st into R3\n    __asm__(\"LDR R3, [R11,#st]\");\n    \n    // Load values at R3 into R3 and R4\n    __asm__(\"LDM R3, {R3,R4}\");\n    \n    // Compare R2 and R4\n    __asm__(\"CMP R2, R4\");\n    \n    // Compare R1 and R3 if R2 and R4 are equal\n    __asm__(\"CMPEQ R1, R3\");\n    \n    // Branch to loc_7C088 if R1 and R3 are not equal\n    __asm__(\"BNE loc_7C088\");\n    \n    // Load value at curr into R3\n    __asm__(\"LDR R3, [R11,#curr]\");\n    \n    // Load value at R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n    \n    // Add 0x8 to R3 and store in R2\n    __asm__(\"ADD R2, R3, #0x8\");\n    \n    // Load values at R2 into R1 and R2\n    __asm__(\"LDM R2, {R1,R2}\");\n    \n    // Load value at st into R3\n    __asm__(\"LDR R3, [R11,#st]\");\n    \n    // Add 0x60 to R3 and store in R4\n    __asm__(\"ADD R4, R3, #0x60\");\n    \n    // Load values at R4 into R3 and R4\n    __asm__(\"LDM R4, {R3,R4}\");\n    \n    // Compare R2 and R4\n    __asm__(\"CMP R2, R4\");\n    \n    // Compare R1 and R3 if R2 and R4 are equal\n    __asm__(\"CMPEQ R1, R3\");\n    \n    // Branch to loc_7C0F4 if R1 and R3 are equal\n    __asm__(\"BEQ loc_7C0F4\");\n    \nloc_7C088:\n    // Load value at curr into R3\n    __asm__(\"LDR R3, [R11,#curr]\");\n    \n    // Load value at R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n    \n    // Store R3 in curr\n    __asm__(\"STR R3, [R11,#curr]\");\n    \n    // Load value at curr into R3\n    __asm__(\"LDR R3, [R11,#curr]\");\n    \n    // Load value at R3 into R3\n    __asm__(\"LDR R3, [R3]\");\n    \n    // Compare R3 with 0\n    __asm__(\"CMP R3, #0\");\n    \n    // Branch to loc_7C03C if R3 is not equal to 0\n    __asm__(\"BNE loc_7C03C\");\n    \n    // Move 0x18 into R0\n    __asm__(\"MOV R0, #0x18\");\n    \n    // Call xzalloc\n    __asm__(\"BL xzalloc\");\n    \n    // Move return value into R3\n    __asm__(\"MOV R3, R0\");\n    \n    // Move R3 into R2\n    __asm__(\"MOV R2, R3\");\n    \n    // Load value at curr into R3\n    __asm__(\"LDR R3, [R11,#curr]\");\n    \n    // Store R2 in R3\n    __asm__(\"STR R2, [R3]\");\n    \n    // Load value at curr into R3\n    __asm__(\"LDR R3, [R11,#curr]\");\n    \n    // Load value at R3 into R2\n    __asm__(\"LDR R2, [R3]\");\n    \n    // Load value at st into R3\n    __asm__(\"LDR R3, [R11,#st]\");\n    \n    // Load values at R3 into R3 and R4\n    __asm__(\"LDM R3, {R3,R4}\");\n    \n    // Store R3 in [R2+0x10]\n    __asm__(\"STR R3, [R2,#0x10]\");\n    \n    // Store R4 in [R2+0x14]\n    __asm__(\"STR R4, [R2,#0x14]\");\n    \n    // Load value at curr into R3\n    __asm__(\"LDR R3, [R11,#curr]\");\n    \n    // Load value at R3 into R2\n    __asm__(\"LDR R2, [R3]\");\n    \n    // Load value at st into R3\n    __asm__(\"LDR R3, [R11,#st]\");\n    \n    // Add 0x60 to R3 and store in R4\n    __asm__(\"ADD R4, R3, #0x60\");\n    \n    // Load values at R4 into R3 and R4\n    __asm__(\"LDM R4, {R3,R4}\");\n    \n    // Store R3 in [R2+0x8]\n    __asm__(\"STR R3, [R2,#8]\");\n    \n    // Store R4 in [R2+0xC]\n    __asm__(\"STR R4, [R2,#0xC]\");\n    \nloc_7C0F4:\n    // No operation\n    \nloc_7C0F8:\n    // Clean up stack frame\n    __asm__(\"SUB SP, R11, #8\");\n    \n    // Restore registers and return\n    __asm__(\"POP {R4,R11,PC}\");\n}\n```"
    }
]
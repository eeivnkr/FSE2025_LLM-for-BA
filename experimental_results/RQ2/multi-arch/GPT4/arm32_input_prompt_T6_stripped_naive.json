[
    {
        "func_name": "bb_info_msg",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x001453BC | 0F 00 2D E9 | PUSH    {R0-R3}\n0x001453C0 | 00 48 2D E9 | PUSH    {R11,LR}\n0x001453C4 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x001453C8 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x001453CC | D0 30 9F E5 | LDR     R3, =logmode\n0x001453D0 | 00 30 93 E5 | LDR     R3, [R3]\n0x001453D4 | 00 00 53 E3 | CMP     R3, #0\n0x001453D8 | 2A 00 00 0A | BEQ     loc_145488\n0x001453DC | 08 30 8B E2 | ADD     R3, R11, #8\n0x001453E0 | 10 30 0B E5 | STR     R3, [R11,#p]\n0x001453E4 | 0C 30 4B E2 | SUB     R3, R11, #-msg\n0x001453E8 | 10 20 1B E5 | LDR     R2, [R11,#p]; va_list\n0x001453EC | 04 10 9B E5 | LDR     R1, [R11,#s]; char *\n0x001453F0 | 03 00 A0 E1 | MOV     R0, R3; char **\n0x001453F4 | 35 3E FB EB | BL      vasprintf\n0x001453F8 | 08 00 0B E5 | STR     R0, [R11,#used]\n0x001453FC | 08 30 1B E5 | LDR     R3, [R11,#used]\n0x00145400 | 00 00 53 E3 | CMP     R3, #0\n0x00145404 | 21 00 00 BA | BLT     loc_145490\n0x00145408 | 94 30 9F E5 | LDR     R3, =logmode\n0x0014540C | 00 30 93 E5 | LDR     R3, [R3]\n0x00145410 | 02 30 03 E2 | AND     R3, R3, #2\n0x00145414 | 00 00 53 E3 | CMP     R3, #0\n0x00145418 | 04 00 00 0A | BEQ     loc_145430\n0x0014541C | 0C 30 1B E5 | LDR     R3, [R11,#msg]\n0x00145420 | 03 20 A0 E1 | MOV     R2, R3\n0x00145424 | 7C 10 9F E5 | LDR     R1, =aS_122; \"%s\"\n0x00145428 | 06 00 A0 E3 | MOV     R0, #6; pri\n0x0014542C | 8D 41 FB EB | BL      syslog\n0x00145430 | 6C 30 9F E5 | LDR     R3, =logmode\n0x00145434 | 00 30 93 E5 | LDR     R3, [R3]\n0x00145438 | 01 30 03 E2 | AND     R3, R3, #1\n0x0014543C | 00 00 53 E3 | CMP     R3, #0\n0x00145440 | 0C 00 00 0A | BEQ     loc_145478\n0x00145444 | 72 53 FB EB | BL      fflush_all\n0x00145448 | 0C 20 1B E5 | LDR     R2, [R11,#msg]\n0x0014544C | 08 30 1B E5 | LDR     R3, [R11,#used]\n0x00145450 | 01 10 83 E2 | ADD     R1, R3, #1\n0x00145454 | 08 10 0B E5 | STR     R1, [R11,#used]\n0x00145458 | 03 30 82 E0 | ADD     R3, R2, R3\n0x0014545C | 0A 20 A0 E3 | MOV     R2, #0xA\n0x00145460 | 00 20 C3 E5 | STRB    R2, [R3]\n0x00145464 | 0C 30 1B E5 | LDR     R3, [R11,#msg]\n0x00145468 | 08 20 1B E5 | LDR     R2, [R11,#used]; len\n0x0014546C | 03 10 A0 E1 | MOV     R1, R3; buf\n0x00145470 | 01 00 A0 E3 | MOV     R0, #1; fd\n0x00145474 | 6F 57 FB EB | BL      full_write\n0x00145478 | 0C 30 1B E5 | LDR     R3, [R11,#msg]\n0x0014547C | 03 00 A0 E1 | MOV     R0, R3; ptr\n0x00145480 | 8A 3E FB EB | BL      free\n0x00145484 | 02 00 00 EA | B       loc_145494\n0x00145488 | 00 00 A0 E1 | NOP\n0x0014548C | 00 00 00 EA | B       loc_145494\n0x00145490 | 00 00 A0 E1 | NOP\n0x00145494 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00145498 | 00 48 BD E8 | POP     {R11,LR}\n0x0014549C | 10 D0 8D E2 | ADD     SP, SP, #0x10\n0x001454A0 | 1E FF 2F E1 | BX      LR",
        "output": "```c\n#include <stdarg.h>\n#include <syslog.h>\n#include <stdlib.h>\n\nextern int logmode;\nextern void fflush_all(void);\nextern int full_write(int fd, const char *buf, int len);\nextern int vasprintf(char **strp, const char *fmt, va_list ap);\n\nvoid log_and_write(int pri, const char *fmt, ...) {\n    va_list p;\n    char *msg;\n    int used;\n\n    va_start(p, fmt);\n    if (logmode) {\n        used = vasprintf(&msg, fmt, p);\n        if (used >= 0) {\n            if (logmode & 2) {\n                syslog(pri, \"%s\", msg);\n            }\n            if (logmode & 1) {\n                fflush_all();\n            }\n            msg[used] = '\\n';\n            full_write(1, msg, used + 1);\n            free(msg);\n        }\n    }\n    va_end(p);\n}\n```"
    },
    {
        "func_name": "chargen_stream",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0004F1A8 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0004F1AC | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0004F1B0 | 60 D0 4D E2 | SUB     SP, SP, #0x60\n0x0004F1B4 | 60 00 0B E5 | STR     R0, [R11,#s]\n0x0004F1B8 | 64 10 0B E5 | STR     R1, [R11,#sep]\n0x0004F1BC | D8 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004F1C0 | 40 30 93 E5 | LDR     R3, [R3,#(dst.data - 0x18F9D8)]\n0x0004F1C4 | 00 00 53 E3 | CMP     R3, #0\n0x0004F1C8 | 02 00 00 1A | BNE     loc_4F1D8\n0x0004F1CC | D9 FF FF EB | BL      init_ring\n0x0004F1D0 | C8 30 9F E5 | LDR     R3, =(dst.data+8)\n0x0004F1D4 | 08 30 0B E5 | STR     R3, [R11,#rs]\n0x0004F1D8 | 0D 30 A0 E3 | MOV     R3, #0xD\n0x0004F1DC | 10 30 4B E5 | STRB    R3, [R11,#text+0x48]\n0x0004F1E0 | 0A 30 A0 E3 | MOV     R3, #0xA\n0x0004F1E4 | 0F 30 4B E5 | STRB    R3, [R11,#text+0x49]\n0x0004F1E8 | B0 30 9F E5 | LDR     R3, =(dst.data+8)\n0x0004F1EC | 08 30 0B E5 | STR     R3, [R11,#rs]\n0x0004F1F0 | A4 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004F1F4 | 40 20 93 E5 | LDR     R2, [R3,#(dst.data - 0x18F9D8)]\n0x0004F1F8 | 08 30 1B E5 | LDR     R3, [R11,#rs]\n0x0004F1FC | 03 30 42 E0 | SUB     R3, R2, R3\n0x0004F200 | 0C 30 0B E5 | STR     R3, [R11,#len]\n0x0004F204 | 0C 30 1B E5 | LDR     R3, [R11,#len]\n0x0004F208 | 47 00 53 E3 | CMP     R3, #0x47 ; 'G'\n0x0004F20C | 05 00 00 DA | BLE     loc_4F228\n0x0004F210 | 58 30 4B E2 | SUB     R3, R11, #-text\n0x0004F214 | 48 20 A0 E3 | MOV     R2, #0x48 ; 'H'; n\n0x0004F218 | 08 10 1B E5 | LDR     R1, [R11,#rs]; src\n0x0004F21C | 03 00 A0 E1 | MOV     R0, R3; dest\n0x0004F220 | 1C 17 FF EB | BL      memmove\n0x0004F224 | 0C 00 00 EA | B       loc_4F25C\n0x0004F228 | 0C 20 1B E5 | LDR     R2, [R11,#len]; n\n0x0004F22C | 58 30 4B E2 | SUB     R3, R11, #-text\n0x0004F230 | 08 10 1B E5 | LDR     R1, [R11,#rs]; src\n0x0004F234 | 03 00 A0 E1 | MOV     R0, R3; dest\n0x0004F238 | 16 17 FF EB | BL      memmove\n0x0004F23C | 0C 30 1B E5 | LDR     R3, [R11,#len]\n0x0004F240 | 58 20 4B E2 | SUB     R2, R11, #-text\n0x0004F244 | 03 00 82 E0 | ADD     R0, R2, R3; dest\n0x0004F248 | 50 10 9F E5 | LDR     R1, =(dst.data+8); src\n0x0004F24C | 0C 30 1B E5 | LDR     R3, [R11,#len]\n0x0004F250 | 48 30 63 E2 | RSB     R3, R3, #0x48 ; 'H'\n0x0004F254 | 03 20 A0 E1 | MOV     R2, R3; n\n0x0004F258 | 0E 17 FF EB | BL      memmove\n0x0004F25C | 08 30 1B E5 | LDR     R3, [R11,#rs]\n0x0004F260 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0004F264 | 08 30 0B E5 | STR     R3, [R11,#rs]\n0x0004F268 | 2C 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004F26C | 40 30 93 E5 | LDR     R3, [R3,#(dst.data - 0x18F9D8)]\n0x0004F270 | 08 20 1B E5 | LDR     R2, [R11,#rs]\n0x0004F274 | 03 00 52 E1 | CMP     R2, R3\n0x0004F278 | 01 00 00 1A | BNE     loc_4F284\n0x0004F27C | 1C 30 9F E5 | LDR     R3, =(dst.data+8)\n0x0004F280 | 08 30 0B E5 | STR     R3, [R11,#rs]\n0x0004F284 | 58 30 4B E2 | SUB     R3, R11, #-text\n0x0004F288 | 4A 20 A0 E3 | MOV     R2, #0x4A ; 'J'; count\n0x0004F28C | 03 10 A0 E1 | MOV     R1, R3; buf\n0x0004F290 | 60 00 1B E5 | LDR     R0, [R11,#s]; fd\n0x0004F294 | 54 2B FF EB | BL      xwrite\n0x0004F298 | D4 FF FF EA | B       loc_4F1F0",
        "output": "```c\nvoid function(char *s, char *sep) {\n    extern int bb_common_bufsiz1;\n    extern void init_ring(void);\n    extern void *memmove(void *dest, const void *src, size_t n);\n    extern ssize_t xwrite(int fd, const void *buf, size_t count);\n    char text[72];\n    char *rs;\n    int len;\n\n    if (bb_common_bufsiz1 == 0) {\n        init_ring();\n    }\n    rs = dst.data + 8;\n    text[48] = '\\r';\n    text[49] = '\\n';\n    len = bb_common_bufsiz1 - (rs - dst.data);\n    if (len > 'G') {\n        memmove(text, rs, 'H');\n    } else {\n        memmove(text, rs, len);\n        memmove(text + len, dst.data + 8, 'H' - len);\n    }\n    rs++;\n    if (rs - dst.data >= bb_common_bufsiz1) {\n        rs = dst.data + 8;\n    }\n    xwrite(s, text, 'J');\n    goto function + 0x48; // This is a jump back to the address 0x0004F1F0\n}\n```"
    },
    {
        "func_name": "out_char",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00086E80 | 00 48 2D E9 | PUSH    {R11,LR}\n0x00086E84 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00086E88 | 08 D0 4D E2 | SUB     SP, SP, #8\n0x00086E8C | 00 30 A0 E1 | MOV     R3, R0\n0x00086E90 | 05 30 4B E5 | STRB    R3, [R11,#c]\n0x00086E94 | 70 30 9F E5 | LDR     R3, =ptr_to_globals\n0x00086E98 | 00 30 93 E5 | LDR     R3, [R3]\n0x00086E9C | 00 20 93 E5 | LDR     R2, [R3]\n0x00086EA0 | 01 20 82 E2 | ADD     R2, R2, #1\n0x00086EA4 | 00 20 83 E5 | STR     R2, [R3]\n0x00086EA8 | 5C 30 9F E5 | LDR     R3, =ptr_to_globals\n0x00086EAC | 00 30 93 E5 | LDR     R3, [R3]\n0x00086EB0 | 00 20 93 E5 | LDR     R2, [R3]\n0x00086EB4 | 50 30 9F E5 | LDR     R3, =ptr_to_globals\n0x00086EB8 | 00 30 93 E5 | LDR     R3, [R3]\n0x00086EBC | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x00086EC0 | 03 00 52 E1 | CMP     R2, R3\n0x00086EC4 | 0D 00 00 8A | BHI     loc_86F00\n0x00086EC8 | 3C 30 9F E5 | LDR     R3, =ptr_to_globals\n0x00086ECC | 00 30 93 E5 | LDR     R3, [R3]\n0x00086ED0 | 00 20 93 E5 | LDR     R2, [R3]\n0x00086ED4 | 30 30 9F E5 | LDR     R3, =ptr_to_globals\n0x00086ED8 | 00 30 93 E5 | LDR     R3, [R3]\n0x00086EDC | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x00086EE0 | 03 00 52 E1 | CMP     R2, R3\n0x00086EE4 | 01 00 00 1A | BNE     loc_86EF0\n0x00086EE8 | 2B 30 A0 E3 | MOV     R3, #0x2B ; '+'\n0x00086EEC | 05 30 4B E5 | STRB    R3, [R11,#c]\n0x00086EF0 | 05 30 5B E5 | LDRB    R3, [R11,#c]\n0x00086EF4 | 03 00 A0 E1 | MOV     R0, R3; c\n0x00086EF8 | A3 3B FE EB | BL      putchar_unlocked\n0x00086EFC | 00 00 00 EA | B       loc_86F04\n0x00086F00 | 00 00 A0 E1 | NOP\n0x00086F04 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00086F08 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdio.h>\n\nextern int* ptr_to_globals;\n\nvoid function(char c) {\n    static char local_c;\n    local_c = c;\n    int* globals = ptr_to_globals;\n    int value = *globals;\n    value += 1;\n    *globals = value;\n\n    if (value <= globals[1]) {\n        putchar_unlocked(local_c);\n    } else {\n        local_c = '+';\n        putchar_unlocked(local_c);\n    }\n}\n```"
    },
    {
        "func_name": "mesg_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0013BEB8 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0013BEBC | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0013BEC0 | 78 D0 4D E2 | SUB     SP, SP, #0x78\n0x0013BEC4 | 78 00 0B E5 | STR     R0, [R11,#argc]\n0x0013BEC8 | 7C 10 0B E5 | STR     R1, [R11,#argv]\n0x0013BECC | 00 30 A0 E3 | MOV     R3, #0\n0x0013BED0 | 05 30 4B E5 | STRB    R3, [R11,#c]\n0x0013BED4 | 7C 30 1B E5 | LDR     R3, [R11,#argv]\n0x0013BED8 | 04 30 83 E2 | ADD     R3, R3, #4\n0x0013BEDC | 7C 30 0B E5 | STR     R3, [R11,#argv]\n0x0013BEE0 | 7C 30 1B E5 | LDR     R3, [R11,#argv]\n0x0013BEE4 | 00 30 93 E5 | LDR     R3, [R3]\n0x0013BEE8 | 00 00 53 E3 | CMP     R3, #0\n0x0013BEEC | 0F 00 00 0A | BEQ     loc_13BF30\n0x0013BEF0 | 7C 30 1B E5 | LDR     R3, [R11,#argv]\n0x0013BEF4 | 04 30 83 E2 | ADD     R3, R3, #4\n0x0013BEF8 | 00 30 93 E5 | LDR     R3, [R3]\n0x0013BEFC | 00 00 53 E3 | CMP     R3, #0\n0x0013BF00 | 09 00 00 1A | BNE     loc_13BF2C\n0x0013BF04 | 7C 30 1B E5 | LDR     R3, [R11,#argv]\n0x0013BF08 | 00 30 93 E5 | LDR     R3, [R3]\n0x0013BF0C | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0013BF10 | 05 30 4B E5 | STRB    R3, [R11,#c]\n0x0013BF14 | 05 30 5B E5 | LDRB    R3, [R11,#c]\n0x0013BF18 | 79 00 53 E3 | CMP     R3, #0x79 ; 'y'\n0x0013BF1C | 03 00 00 0A | BEQ     loc_13BF30\n0x0013BF20 | 05 30 5B E5 | LDRB    R3, [R11,#c]\n0x0013BF24 | 6E 00 53 E3 | CMP     R3, #0x6E ; 'n'\n0x0013BF28 | 00 00 00 0A | BEQ     loc_13BF30\n0x0013BF2C | 6E 6C FB EB | BL      bb_show_usage\n0x0013BF30 | 00 00 A0 E3 | MOV     R0, #0; fd\n0x0013BF34 | 5B 67 FB EB | BL      isatty\n0x0013BF38 | 00 30 A0 E1 | MOV     R3, R0\n0x0013BF3C | 00 00 53 E3 | CMP     R3, #0\n0x0013BF40 | 01 00 00 1A | BNE     loc_13BF4C\n0x0013BF44 | 9C 00 9F E5 | LDR     R0, =aNotATty_1; \"not a tty\"\n0x0013BF48 | 92 73 FB EB | BL      bb_error_msg_and_die\n0x0013BF4C | 74 30 4B E2 | SUB     R3, R11, #-sb\n0x0013BF50 | 94 20 9F E5 | LDR     R2, =aStderr_0; \"stderr\"\n0x0013BF54 | 03 10 A0 E1 | MOV     R1, R3; stat_buf\n0x0013BF58 | 00 00 A0 E3 | MOV     R0, #0; fd\n0x0013BF5C | F2 79 FB EB | BL      xfstat\n0x0013BF60 | 05 30 5B E5 | LDRB    R3, [R11,#c]\n0x0013BF64 | 00 00 53 E3 | CMP     R3, #0\n0x0013BF68 | 0A 00 00 1A | BNE     loc_13BF98\n0x0013BF6C | 64 30 1B E5 | LDR     R3, [R11,#sb.st_mode]\n0x0013BF70 | 12 30 03 E2 | AND     R3, R3, #0x12\n0x0013BF74 | 00 00 53 E3 | CMP     R3, #0\n0x0013BF78 | 01 00 00 0A | BEQ     loc_13BF84\n0x0013BF7C | 6C 30 9F E5 | LDR     R3, =aIsY; \"is y\"\n0x0013BF80 | 00 00 00 EA | B       loc_13BF88\n0x0013BF84 | 68 30 9F E5 | LDR     R3, =aIsN; \"is n\"\n0x0013BF88 | 03 00 A0 E1 | MOV     R0, R3; s\n0x0013BF8C | 11 65 FB EB | BL      puts\n0x0013BF90 | 00 30 A0 E3 | MOV     R3, #0\n0x0013BF94 | 10 00 00 EA | B       loc_13BFDC\n0x0013BF98 | 05 30 5B E5 | LDRB    R3, [R11,#c]\n0x0013BF9C | 79 00 53 E3 | CMP     R3, #0x79 ; 'y'\n0x0013BFA0 | 02 00 00 1A | BNE     loc_13BFB0\n0x0013BFA4 | 64 30 1B E5 | LDR     R3, [R11,#sb.st_mode]\n0x0013BFA8 | 10 30 83 E3 | ORR     R3, R3, #0x10\n0x0013BFAC | 01 00 00 EA | B       loc_13BFB8\n0x0013BFB0 | 64 30 1B E5 | LDR     R3, [R11,#sb.st_mode]\n0x0013BFB4 | 12 30 C3 E3 | BIC     R3, R3, #0x12\n0x0013BFB8 | 0C 30 0B E5 | STR     R3, [R11,#m]\n0x0013BFBC | 0C 10 1B E5 | LDR     R1, [R11,#m]; mode\n0x0013BFC0 | 00 00 A0 E3 | MOV     R0, #0; fd\n0x0013BFC4 | 76 67 FB EB | BL      fchmod\n0x0013BFC8 | 00 30 A0 E1 | MOV     R3, R0\n0x0013BFCC | 00 00 53 E3 | CMP     R3, #0\n0x0013BFD0 | 00 00 00 0A | BEQ     loc_13BFD8\n0x0013BFD4 | C5 3F 00 EB | BL      bb_perror_nomsg_and_die\n0x0013BFD8 | 00 30 A0 E3 | MOV     R3, #0\n0x0013BFDC | 03 00 A0 E1 | MOV     R0, R3\n0x0013BFE0 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0013BFE4 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdio.h>\n\nvoid bb_show_usage(void);\nvoid bb_error_msg_and_die(const char *s);\nvoid xfstat(int fd, struct stat *stat_buf, const char *name);\nvoid bb_perror_nomsg_and_die(void);\nint isatty(int fd);\n\nint main(int argc, char **argv) {\n    char c = 0;\n    argv++;\n\n    if (*argv == NULL || **argv == '\\0') {\n        bb_show_usage();\n    }\n\n    c = **argv;\n    if (c == 'y' || c == 'n') {\n        // Do nothing, just proceed\n    } else {\n        bb_show_usage();\n    }\n\n    if (!isatty(0)) {\n        bb_error_msg_and_die(\"not a tty\");\n    }\n\n    struct stat sb;\n    xfstat(0, &sb, \"stderr\");\n\n    if (c == '\\0') {\n        if ((sb.st_mode & 0x12) == 0) {\n            puts(\"is n\");\n        } else {\n            puts(\"is y\");\n        }\n    } else {\n        if (c == 'y') {\n            sb.st_mode |= 0x10;\n        } else {\n            sb.st_mode &= ~0x12;\n        }\n        if (fchmod(0, sb.st_mode) != 0) {\n            bb_perror_nomsg_and_die();\n        }\n    }\n\n    return 0;\n}\n```"
    },
    {
        "func_name": "filter_datapoints",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00055640 | 30 48 2D E9 | PUSH    {R4,R5,R11,LR}\n0x00055644 | 0C B0 8D E2 | ADD     R11, SP, #0xC\n0x00055648 | 28 D0 4D E2 | SUB     SP, SP, #0x28\n0x0005564C | 30 00 0B E5 | STR     R0, [R11,#p]\n0x00055650 | 30 30 1B E5 | LDR     R3, [R11,#p]\n0x00055654 | 60 30 83 E2 | ADD     R3, R3, #0x60 ; '`'\n0x00055658 | 28 30 0B E5 | STR     R3, [R11,#fdp]\n0x0005565C | 30 30 1B E5 | LDR     R3, [R11,#p]\n0x00055660 | 0C 30 93 E5 | LDR     R3, [R3,#0xC]\n0x00055664 | 14 30 0B E5 | STR     R3, [R11,#idx]\n0x00055668 | 14 20 1B E5 | LDR     R2, [R11,#idx]\n0x0005566C | 02 30 A0 E1 | MOV     R3, R2\n0x00055670 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x00055674 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00055678 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x0005567C | 03 20 A0 E1 | MOV     R2, R3\n0x00055680 | 28 30 1B E5 | LDR     R3, [R11,#fdp]\n0x00055684 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00055688 | 18 00 93 E8 | LDM     R3, {R3,R4}\n0x0005568C | 30 20 1B E5 | LDR     R2, [R11,#p]\n0x00055690 | 48 30 82 E5 | STR     R3, [R2,#0x48]\n0x00055694 | 4C 40 82 E5 | STR     R4, [R2,#0x4C]\n0x00055698 | 00 30 A0 E3 | MOV     R3, #0\n0x0005569C | 00 40 A0 E3 | MOV     R4, #0\n0x000556A0 | 24 30 0B E5 | STR     R3, [R11,#wavg]\n0x000556A4 | 20 40 0B E5 | STR     R4, [R11,#wavg+4]\n0x000556A8 | 00 30 A0 E3 | MOV     R3, #0\n0x000556AC | 00 40 A0 E3 | MOV     R4, #0\n0x000556B0 | 1C 30 0B E5 | STR     R3, [R11,#sum]\n0x000556B4 | 18 40 0B E5 | STR     R4, [R11,#sum+4]\n0x000556B8 | 00 30 A0 E3 | MOV     R3, #0\n0x000556BC | 10 30 0B E5 | STR     R3, [R11,#i]\n0x000556C0 | 39 00 00 EA | B       loc_557AC\n0x000556C4 | 14 20 1B E5 | LDR     R2, [R11,#idx]\n0x000556C8 | 02 30 A0 E1 | MOV     R3, R2\n0x000556CC | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000556D0 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000556D4 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x000556D8 | 03 20 A0 E1 | MOV     R2, R3\n0x000556DC | 28 30 1B E5 | LDR     R3, [R11,#fdp]\n0x000556E0 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000556E4 | 03 00 A0 E1 | MOV     R0, R3; dp\n0x000556E8 | 3E FF FF EB | BL      dispersion\n0x000556EC | 00 40 A0 E1 | MOV     R4, R0\n0x000556F0 | 01 50 A0 E1 | MOV     R5, R1\n0x000556F4 | 02 20 A0 E3 | MOV     R2, #2\n0x000556F8 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000556FC | 12 33 A0 E1 | MOV     R3, R2,LSL R3\n0x00055700 | 03 00 A0 E1 | MOV     R0, R3\n0x00055704 | 87 07 04 EB | BL      __floatsidf\n0x00055708 | 00 20 A0 E1 | MOV     R2, R0\n0x0005570C | 01 30 A0 E1 | MOV     R3, R1\n0x00055710 | 04 00 A0 E1 | MOV     R0, R4\n0x00055714 | 05 10 A0 E1 | MOV     R1, R5\n0x00055718 | 56 08 04 EB | BL      __divdf3\n0x0005571C | 00 30 A0 E1 | MOV     R3, R0\n0x00055720 | 01 40 A0 E1 | MOV     R4, R1\n0x00055724 | 03 20 A0 E1 | MOV     R2, R3\n0x00055728 | 04 30 A0 E1 | MOV     R3, R4\n0x0005572C | 1C 10 4B E2 | SUB     R1, R11, #-sum\n0x00055730 | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x00055734 | C7 06 04 EB | BL      __aeabi_dadd\n0x00055738 | 00 30 A0 E1 | MOV     R3, R0\n0x0005573C | 01 40 A0 E1 | MOV     R4, R1\n0x00055740 | 1C 30 0B E5 | STR     R3, [R11,#sum]\n0x00055744 | 18 40 0B E5 | STR     R4, [R11,#sum+4]\n0x00055748 | 14 20 1B E5 | LDR     R2, [R11,#idx]\n0x0005574C | 02 30 A0 E1 | MOV     R3, R2\n0x00055750 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x00055754 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00055758 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x0005575C | 03 20 A0 E1 | MOV     R2, R3\n0x00055760 | 28 30 1B E5 | LDR     R3, [R11,#fdp]\n0x00055764 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00055768 | 18 00 93 E8 | LDM     R3, {R3,R4}\n0x0005576C | 03 20 A0 E1 | MOV     R2, R3\n0x00055770 | 04 30 A0 E1 | MOV     R3, R4\n0x00055774 | 24 10 4B E2 | SUB     R1, R11, #-wavg\n0x00055778 | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x0005577C | B5 06 04 EB | BL      __aeabi_dadd\n0x00055780 | 00 30 A0 E1 | MOV     R3, R0\n0x00055784 | 01 40 A0 E1 | MOV     R4, R1\n0x00055788 | 24 30 0B E5 | STR     R3, [R11,#wavg]\n0x0005578C | 20 40 0B E5 | STR     R4, [R11,#wavg+4]\n0x00055790 | 14 30 1B E5 | LDR     R3, [R11,#idx]\n0x00055794 | 01 30 43 E2 | SUB     R3, R3, #1\n0x00055798 | 07 30 03 E2 | AND     R3, R3, #7\n0x0005579C | 14 30 0B E5 | STR     R3, [R11,#idx]\n0x000557A0 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000557A4 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000557A8 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x000557AC | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000557B0 | 07 00 53 E3 | CMP     R3, #7\n0x000557B4 | C2 FF FF DA | BLE     loc_556C4\n0x000557B8 | 00 20 A0 E3 | MOV     R2, #0\n0x000557BC | 54 31 9F E5 | LDR     R3, =0x40200000\n0x000557C0 | 24 10 4B E2 | SUB     R1, R11, #-wavg\n0x000557C4 | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x000557C8 | 2A 08 04 EB | BL      __divdf3\n0x000557CC | 00 30 A0 E1 | MOV     R3, R0\n0x000557D0 | 01 40 A0 E1 | MOV     R4, R1\n0x000557D4 | 24 30 0B E5 | STR     R3, [R11,#wavg]\n0x000557D8 | 20 40 0B E5 | STR     R4, [R11,#wavg+4]\n0x000557DC | 30 20 1B E5 | LDR     R2, [R11,#p]\n0x000557E0 | 1C 40 4B E2 | SUB     R4, R11, #-sum\n0x000557E4 | 18 00 94 E8 | LDM     R4, {R3,R4}\n0x000557E8 | 50 30 82 E5 | STR     R3, [R2,#0x50]\n0x000557EC | 54 40 82 E5 | STR     R4, [R2,#0x54]\n0x000557F0 | 00 30 A0 E3 | MOV     R3, #0\n0x000557F4 | 00 40 A0 E3 | MOV     R4, #0\n0x000557F8 | 1C 30 0B E5 | STR     R3, [R11,#sum]\n0x000557FC | 18 40 0B E5 | STR     R4, [R11,#sum+4]\n0x00055800 | 00 30 A0 E3 | MOV     R3, #0\n0x00055804 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x00055808 | 20 00 00 EA | B       loc_55890\n0x0005580C | 10 20 1B E5 | LDR     R2, [R11,#i]\n0x00055810 | 02 30 A0 E1 | MOV     R3, R2\n0x00055814 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x00055818 | 02 30 83 E0 | ADD     R3, R3, R2\n0x0005581C | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x00055820 | 03 20 A0 E1 | MOV     R2, R3\n0x00055824 | 28 30 1B E5 | LDR     R3, [R11,#fdp]\n0x00055828 | 02 30 83 E0 | ADD     R3, R3, R2\n0x0005582C | 18 00 93 E8 | LDM     R3, {R3,R4}\n0x00055830 | 03 20 A0 E1 | MOV     R2, R3\n0x00055834 | 04 30 A0 E1 | MOV     R3, R4\n0x00055838 | 24 10 4B E2 | SUB     R1, R11, #-wavg\n0x0005583C | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x00055840 | 83 06 04 EB | BL      __subdf3\n0x00055844 | 00 30 A0 E1 | MOV     R3, R0\n0x00055848 | 01 40 A0 E1 | MOV     R4, R1\n0x0005584C | 03 00 A0 E1 | MOV     R0, R3; x\n0x00055850 | 04 10 A0 E1 | MOV     R1, R4; x\n0x00055854 | 3E FD FF EB | BL      SQUARE\n0x00055858 | 00 30 A0 E1 | MOV     R3, R0\n0x0005585C | 01 40 A0 E1 | MOV     R4, R1\n0x00055860 | 03 20 A0 E1 | MOV     R2, R3\n0x00055864 | 04 30 A0 E1 | MOV     R3, R4\n0x00055868 | 1C 10 4B E2 | SUB     R1, R11, #-sum\n0x0005586C | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x00055870 | 78 06 04 EB | BL      __aeabi_dadd\n0x00055874 | 00 30 A0 E1 | MOV     R3, R0\n0x00055878 | 01 40 A0 E1 | MOV     R4, R1\n0x0005587C | 1C 30 0B E5 | STR     R3, [R11,#sum]\n0x00055880 | 18 40 0B E5 | STR     R4, [R11,#sum+4]\n0x00055884 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x00055888 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0005588C | 10 30 0B E5 | STR     R3, [R11,#i]\n0x00055890 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x00055894 | 07 00 53 E3 | CMP     R3, #7\n0x00055898 | DB FF FF DA | BLE     loc_5580C\n0x0005589C | 00 20 A0 E3 | MOV     R2, #0\n0x000558A0 | 70 30 9F E5 | LDR     R3, =0x40200000\n0x000558A4 | 1C 10 4B E2 | SUB     R1, R11, #-sum\n0x000558A8 | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x000558AC | F1 07 04 EB | BL      __divdf3\n0x000558B0 | 00 30 A0 E1 | MOV     R3, R0\n0x000558B4 | 01 40 A0 E1 | MOV     R4, R1\n0x000558B8 | 03 00 A0 E1 | MOV     R0, R3; X\n0x000558BC | 04 10 A0 E1 | MOV     R1, R4; X\n0x000558C0 | 96 FD FF EB | BL      SQRT\n0x000558C4 | 1C 00 0B E5 | STR     R0, [R11,#sum]\n0x000558C8 | 18 10 0B E5 | STR     R1, [R11,#sum+4]\n0x000558CC | 48 20 9F E5 | LDR     R2, =0xD2F1A9FC\n0x000558D0 | 48 30 9F E5 | LDR     R3, =0x3F60624D\n0x000558D4 | 1C 10 4B E2 | SUB     R1, R11, #-sum\n0x000558D8 | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x000558DC | AC 08 04 EB | BL      __aeabi_dcmpgt\n0x000558E0 | 00 30 A0 E1 | MOV     R3, R0\n0x000558E4 | 00 00 53 E3 | CMP     R3, #0\n0x000558E8 | 02 00 00 0A | BEQ     loc_558F8\n0x000558EC | 1C 40 4B E2 | SUB     R4, R11, #-sum\n0x000558F0 | 18 00 94 E8 | LDM     R4, {R3,R4}\n0x000558F4 | 01 00 00 EA | B       loc_55900\n0x000558F8 | 1C 30 9F E5 | LDR     R3, =0xD2F1A9FC\n0x000558FC | 1C 40 9F E5 | LDR     R4, =0x3F60624D\n0x00055900 | 30 20 1B E5 | LDR     R2, [R11,#p]\n0x00055904 | 58 30 82 E5 | STR     R3, [R2,#0x58]\n0x00055908 | 5C 40 82 E5 | STR     R4, [R2,#0x5C]\n0x0005590C | 00 00 A0 E1 | NOP\n0x00055910 | 0C D0 4B E2 | SUB     SP, R11, #0xC\n0x00055914 | 30 88 BD E8 | POP     {R4,R5,R11,PC}",
        "output": "```c\nvoid function(int *p) {\n    int idx, i;\n    double wavg[2] = {0.0, 0.0};\n    double sum[2] = {0.0, 0.0};\n    int *fdp = p + 24; // Assuming p is an array of integers and 24 is an offset\n\n    for (i = 0; i < 8; i++) {\n        int dp = fdp[idx * 9];\n        int d1 = fdp[idx * 9 + 1];\n        p[18] = dp;\n        p[19] = d1;\n\n        double dispersion = dispersion(dp);\n        double x = (double)(1 << i);\n        double result = dispersion / x;\n        sum[0] += result;\n        sum[1] += result;\n\n        wavg[0] += dp;\n        wavg[1] += d1;\n\n        idx = (idx - 1) & 7;\n    }\n\n    wavg[0] /= 8.0;\n    wavg[1] /= 8.0;\n    p[20] = sum[0];\n    p[21] = sum[1];\n\n    sum[0] = 0.0;\n    sum[1] = 0.0;\n    for (i = 0; i < 8; i++) {\n        int dp = fdp[idx * 9];\n        int d1 = fdp[idx * 9 + 1];\n        double x = dp - wavg[0];\n        double y = d1 - wavg[1];\n        double square = SQUARE(x, y);\n        sum[0] += square;\n        sum[1] += square;\n    }\n\n    double variance = sum[0] / 8.0;\n    double stddev = SQRT(variance);\n    sum[0] = stddev;\n    sum[1] = stddev;\n\n    if (__aeabi_dcmpgt(sum[0], sum[1])) {\n        p[22] = sum[0];\n        p[23] = sum[1];\n    } else {\n        sum[0] = 0x3F60624D; // Assuming these are double constants\n        sum[1] = 0xD2F1A9FC; // Assuming these are double constants\n        p[22] = sum[0];\n        p[23] = sum[1];\n    }\n}\n```"
    },
    {
        "func_name": "ln_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x001073E8 | 00 48 2D E9 | PUSH    {R11,LR}\n0x001073EC | 04 B0 8D E2 | ADD     R11, SP, #4\n0x001073F0 | 90 D0 4D E2 | SUB     SP, SP, #0x90\n0x001073F4 | 90 00 0B E5 | STR     R0, [R11,#argc]\n0x001073F8 | 94 10 0B E5 | STR     R1, [R11,#argv]\n0x001073FC | 00 30 A0 E3 | MOV     R3, #0\n0x00107400 | 08 30 0B E5 | STR     R3, [R11,#status]\n0x00107404 | 4C 33 9F E5 | LDR     R3, =asc_178DE0; \"~\"\n0x00107408 | 24 30 0B E5 | STR     R3, [R11,#suffix]\n0x0010740C | 48 33 9F E5 | LDR     R3, =opt_complementary\n0x00107410 | 48 23 9F E5 | LDR     R2, =a1_24; \"-1\"\n0x00107414 | 00 20 83 E5 | STR     R2, [R3]\n0x00107418 | 24 30 4B E2 | SUB     R3, R11, #-suffix\n0x0010741C | 03 20 A0 E1 | MOV     R2, R3\n0x00107420 | 3C 13 9F E5 | LDR     R1, =aSfnbsVt; \"sfnbS:vT\"\n0x00107424 | 94 00 1B E5 | LDR     R0, [R11,#argv]; argv\n0x00107428 | 1E E7 00 EB | BL      getopt32\n0x0010742C | 00 30 A0 E1 | MOV     R3, R0\n0x00107430 | 1C 30 0B E5 | STR     R3, [R11,#opts]\n0x00107434 | 90 30 1B E5 | LDR     R3, [R11,#argc]\n0x00107438 | 07 31 43 E2 | SUB     R3, R3, #0xC0000001\n0x0010743C | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00107440 | 94 20 1B E5 | LDR     R2, [R11,#argv]\n0x00107444 | 03 30 82 E0 | ADD     R3, R2, R3\n0x00107448 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010744C | 0C 30 0B E5 | STR     R3, [R11,#last]\n0x00107450 | 10 33 9F E5 | LDR     R3, =optind__GLIBC_2.4\n0x00107454 | 00 30 93 E5 | LDR     R3, [R3]\n0x00107458 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x0010745C | 94 20 1B E5 | LDR     R2, [R11,#argv]\n0x00107460 | 03 30 82 E0 | ADD     R3, R2, R3\n0x00107464 | 94 30 0B E5 | STR     R3, [R11,#argv]\n0x00107468 | F8 32 9F E5 | LDR     R3, =optind__GLIBC_2.4\n0x0010746C | 00 30 93 E5 | LDR     R3, [R3]\n0x00107470 | 90 20 1B E5 | LDR     R2, [R11,#argc]\n0x00107474 | 03 30 42 E0 | SUB     R3, R2, R3\n0x00107478 | 90 30 0B E5 | STR     R3, [R11,#argc]\n0x0010747C | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x00107480 | 40 30 03 E2 | AND     R3, R3, #0x40\n0x00107484 | 00 00 53 E3 | CMP     R3, #0\n0x00107488 | 04 00 00 0A | BEQ     loc_1074A0\n0x0010748C | 90 30 1B E5 | LDR     R3, [R11,#argc]\n0x00107490 | 02 00 53 E3 | CMP     R3, #2\n0x00107494 | 01 00 00 DA | BLE     loc_1074A0\n0x00107498 | CC 02 9F E5 | LDR     R0, =aTAccepts2ArgsM; \"-T accepts 2 args max\"\n0x0010749C | 3D 46 FC EB | BL      bb_error_msg_and_die\n0x001074A0 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x001074A4 | 04 30 83 E2 | ADD     R3, R3, #4\n0x001074A8 | 00 30 93 E5 | LDR     R3, [R3]\n0x001074AC | 00 00 53 E3 | CMP     R3, #0\n0x001074B0 | 0B 00 00 1A | BNE     loc_1074E4\n0x001074B4 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x001074B8 | 04 30 43 E2 | SUB     R3, R3, #4\n0x001074BC | 94 30 0B E5 | STR     R3, [R11,#argv]\n0x001074C0 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x001074C4 | 0C 20 1B E5 | LDR     R2, [R11,#last]\n0x001074C8 | 00 20 83 E5 | STR     R2, [R3]\n0x001074CC | 0C 00 1B E5 | LDR     R0, [R11,#last]; s\n0x001074D0 | A5 49 FC EB | BL      xstrdup\n0x001074D4 | 00 30 A0 E1 | MOV     R3, R0\n0x001074D8 | 03 00 A0 E1 | MOV     R0, R3; path\n0x001074DC | F7 43 FC EB | BL      bb_get_last_path_component_strip\n0x001074E0 | 0C 00 0B E5 | STR     R0, [R11,#last]\n0x001074E4 | 00 30 A0 E3 | MOV     R3, #0\n0x001074E8 | 10 30 0B E5 | STR     R3, [R11,#src_name]\n0x001074EC | 0C 30 1B E5 | LDR     R3, [R11,#last]\n0x001074F0 | 14 30 0B E5 | STR     R3, [R11,#src]\n0x001074F4 | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x001074F8 | 03 30 E0 E1 | MVN     R3, R3\n0x001074FC | 04 30 03 E2 | AND     R3, R3, #4\n0x00107500 | 03 10 A0 E1 | MOV     R1, R3; followLinks\n0x00107504 | 14 00 1B E5 | LDR     R0, [R11,#src]; fileName\n0x00107508 | A6 F8 00 EB | BL      is_directory\n0x0010750C | 00 30 A0 E1 | MOV     R3, R0\n0x00107510 | 00 00 53 E3 | CMP     R3, #0\n0x00107514 | 17 00 00 0A | BEQ     loc_107578\n0x00107518 | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x0010751C | 40 30 03 E2 | AND     R3, R3, #0x40\n0x00107520 | 00 00 53 E3 | CMP     R3, #0\n0x00107524 | 02 00 00 0A | BEQ     loc_107534\n0x00107528 | 14 10 1B E5 | LDR     R1, [R11,#src]\n0x0010752C | 3C 02 9F E5 | LDR     R0, =aSIsADirectory; \"'%s' is a directory\"\n0x00107530 | 18 46 FC EB | BL      bb_error_msg_and_die\n0x00107534 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x00107538 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010753C | 03 00 A0 E1 | MOV     R0, R3; s\n0x00107540 | 89 49 FC EB | BL      xstrdup\n0x00107544 | 00 30 A0 E1 | MOV     R3, R0\n0x00107548 | 10 30 0B E5 | STR     R3, [R11,#src_name]\n0x0010754C | 10 00 1B E5 | LDR     R0, [R11,#src_name]; path\n0x00107550 | DA 43 FC EB | BL      bb_get_last_path_component_strip\n0x00107554 | 00 30 A0 E1 | MOV     R3, R0\n0x00107558 | 03 10 A0 E1 | MOV     R1, R3; filename\n0x0010755C | 14 00 1B E5 | LDR     R0, [R11,#src]; path\n0x00107560 | 82 43 FC EB | BL      concat_path_file\n0x00107564 | 14 00 0B E5 | STR     R0, [R11,#src]\n0x00107568 | 10 00 1B E5 | LDR     R0, [R11,#src_name]; ptr\n0x0010756C | 4F 36 FC EB | BL      free\n0x00107570 | 14 30 1B E5 | LDR     R3, [R11,#src]\n0x00107574 | 10 30 0B E5 | STR     R3, [R11,#src_name]\n0x00107578 | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x0010757C | 01 30 03 E2 | AND     R3, R3, #1\n0x00107580 | 00 00 53 E3 | CMP     R3, #0\n0x00107584 | 1E 00 00 1A | BNE     loc_107604\n0x00107588 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x0010758C | 00 30 93 E5 | LDR     R3, [R3]\n0x00107590 | 8C 20 4B E2 | SUB     R2, R11, #-statbuf\n0x00107594 | 02 10 A0 E1 | MOV     R1, R2; buf\n0x00107598 | 03 00 A0 E1 | MOV     R0, R3; file\n0x0010759C | F4 43 01 EB | BL      stat64_0\n0x001075A0 | 00 30 A0 E1 | MOV     R3, R0\n0x001075A4 | 00 00 53 E3 | CMP     R3, #0\n0x001075A8 | 15 00 00 0A | BEQ     loc_107604\n0x001075AC | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x001075B0 | 00 30 93 E5 | LDR     R3, [R3]\n0x001075B4 | 8C 20 4B E2 | SUB     R2, R11, #-statbuf\n0x001075B8 | 02 10 A0 E1 | MOV     R1, R2; buf\n0x001075BC | 03 00 A0 E1 | MOV     R0, R3; file\n0x001075C0 | F3 43 01 EB | BL      lstat64\n0x001075C4 | 00 30 A0 E1 | MOV     R3, R0\n0x001075C8 | 00 00 53 E3 | CMP     R3, #0\n0x001075CC | 03 00 00 1A | BNE     loc_1075E0\n0x001075D0 | 7C 30 1B E5 | LDR     R3, [R11,#statbuf.st_mode]\n0x001075D4 | 0F 3A 03 E2 | AND     R3, R3, #0xF000\n0x001075D8 | 0A 0A 53 E3 | CMP     R3, #0xA000\n0x001075DC | 08 00 00 0A | BEQ     loc_107604\n0x001075E0 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x001075E4 | 00 30 93 E5 | LDR     R3, [R3]\n0x001075E8 | 03 00 A0 E1 | MOV     R0, R3; s\n0x001075EC | DB 44 FC EB | BL      bb_simple_perror_msg\n0x001075F0 | 01 30 A0 E3 | MOV     R3, #1\n0x001075F4 | 08 30 0B E5 | STR     R3, [R11,#status]\n0x001075F8 | 10 00 1B E5 | LDR     R0, [R11,#src_name]; ptr\n0x001075FC | 2B 36 FC EB | BL      free\n0x00107600 | 48 00 00 EA | B       loc_107728\n0x00107604 | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x00107608 | 08 30 03 E2 | AND     R3, R3, #8\n0x0010760C | 00 00 53 E3 | CMP     R3, #0\n0x00107610 | 1D 00 00 0A | BEQ     loc_10768C\n0x00107614 | 24 30 1B E5 | LDR     R3, [R11,#suffix]\n0x00107618 | 03 20 A0 E1 | MOV     R2, R3\n0x0010761C | 14 10 1B E5 | LDR     R1, [R11,#src]\n0x00107620 | 4C 01 9F E5 | LDR     R0, =aSS_55; \"%s%s\"\n0x00107624 | 23 4B FC EB | BL      xasprintf\n0x00107628 | 00 30 A0 E1 | MOV     R3, R0\n0x0010762C | 20 30 0B E5 | STR     R3, [R11,#backup]\n0x00107630 | 20 10 1B E5 | LDR     R1, [R11,#backup]; new\n0x00107634 | 14 00 1B E5 | LDR     R0, [R11,#src]; old\n0x00107638 | AB 37 FC EB | BL      rename\n0x0010763C | 00 30 A0 E1 | MOV     R3, R0\n0x00107640 | 00 00 53 E3 | CMP     R3, #0\n0x00107644 | 0B 00 00 AA | BGE     loc_107678\n0x00107648 | 28 31 9F E5 | LDR     R3, =bb_errno\n0x0010764C | 00 30 93 E5 | LDR     R3, [R3]\n0x00107650 | 00 30 93 E5 | LDR     R3, [R3]\n0x00107654 | 02 00 53 E3 | CMP     R3, #2\n0x00107658 | 06 00 00 0A | BEQ     loc_107678\n0x0010765C | 14 00 1B E5 | LDR     R0, [R11,#src]; s\n0x00107660 | BE 44 FC EB | BL      bb_simple_perror_msg\n0x00107664 | 01 30 A0 E3 | MOV     R3, #1\n0x00107668 | 08 30 0B E5 | STR     R3, [R11,#status]\n0x0010766C | 20 00 1B E5 | LDR     R0, [R11,#backup]; ptr\n0x00107670 | 0E 36 FC EB | BL      free\n0x00107674 | 2B 00 00 EA | B       loc_107728\n0x00107678 | 20 00 1B E5 | LDR     R0, [R11,#backup]; ptr\n0x0010767C | 0B 36 FC EB | BL      free\n0x00107680 | 14 00 1B E5 | LDR     R0, [R11,#src]; name\n0x00107684 | 8D 36 FC EB | BL      unlink\n0x00107688 | 05 00 00 EA | B       loc_1076A4\n0x0010768C | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x00107690 | 02 30 03 E2 | AND     R3, R3, #2\n0x00107694 | 00 00 53 E3 | CMP     R3, #0\n0x00107698 | 01 00 00 0A | BEQ     loc_1076A4\n0x0010769C | 14 00 1B E5 | LDR     R0, [R11,#src]; name\n0x001076A0 | 86 36 FC EB | BL      unlink\n0x001076A4 | D0 30 9F E5 | LDR     R3, =link\n0x001076A8 | 18 30 0B E5 | STR     R3, [R11,#link_func]\n0x001076AC | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x001076B0 | 01 30 03 E2 | AND     R3, R3, #1\n0x001076B4 | 00 00 53 E3 | CMP     R3, #0\n0x001076B8 | 01 00 00 0A | BEQ     loc_1076C4\n0x001076BC | BC 30 9F E5 | LDR     R3, =symlink\n0x001076C0 | 18 30 0B E5 | STR     R3, [R11,#link_func]\n0x001076C4 | 1C 30 1B E5 | LDR     R3, [R11,#opts]\n0x001076C8 | 20 30 03 E2 | AND     R3, R3, #0x20\n0x001076CC | 00 00 53 E3 | CMP     R3, #0\n0x001076D0 | 05 00 00 0A | BEQ     loc_1076EC\n0x001076D4 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x001076D8 | 00 30 93 E5 | LDR     R3, [R3]\n0x001076DC | 03 20 A0 E1 | MOV     R2, R3\n0x001076E0 | 14 10 1B E5 | LDR     R1, [R11,#src]\n0x001076E4 | 98 00 9F E5 | LDR     R0, =aSS_56; \"'%s' -> '%s'\\n\"\n0x001076E8 | BA 35 FC EB | BL      printf\n0x001076EC | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x001076F0 | 00 20 93 E5 | LDR     R2, [R3]\n0x001076F4 | 18 30 1B E5 | LDR     R3, [R11,#link_func]\n0x001076F8 | 14 10 1B E5 | LDR     R1, [R11,#src]\n0x001076FC | 02 00 A0 E1 | MOV     R0, R2\n0x00107700 | 33 FF 2F E1 | BLX     R3\n0x00107704 | 00 30 A0 E1 | MOV     R3, R0\n0x00107708 | 00 00 53 E3 | CMP     R3, #0\n0x0010770C | 03 00 00 0A | BEQ     loc_107720\n0x00107710 | 14 00 1B E5 | LDR     R0, [R11,#src]; s\n0x00107714 | 91 44 FC EB | BL      bb_simple_perror_msg\n0x00107718 | 01 30 A0 E3 | MOV     R3, #1\n0x0010771C | 08 30 0B E5 | STR     R3, [R11,#status]\n0x00107720 | 10 00 1B E5 | LDR     R0, [R11,#src_name]; ptr\n0x00107724 | E1 35 FC EB | BL      free\n0x00107728 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x0010772C | 04 30 83 E2 | ADD     R3, R3, #4\n0x00107730 | 94 30 0B E5 | STR     R3, [R11,#argv]\n0x00107734 | 94 30 1B E5 | LDR     R3, [R11,#argv]\n0x00107738 | 04 30 83 E2 | ADD     R3, R3, #4\n0x0010773C | 00 30 93 E5 | LDR     R3, [R3]\n0x00107740 | 00 00 53 E3 | CMP     R3, #0\n0x00107744 | 66 FF FF 1A | BNE     loc_1074E4\n0x00107748 | 08 30 1B E5 | LDR     R3, [R11,#status]\n0x0010774C | 03 00 A0 E1 | MOV     R0, R3\n0x00107750 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00107754 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    int status = 0;\n    char *suffix = \"~\";\n    char *opts;\n    char *last;\n    char *src_name = NULL;\n    char *src;\n    char *backup = NULL;\n    bool followLinks = false;\n    int (*link_func)(const char *, const char *);\n\n    getopt32(argv, \"sfnbS:vT\");\n    argv += optind__GLIBC_2_4;\n    argc -= optind__GLIBC_2_4;\n\n    last = argv[argc - 1];\n    src = xstrdup(bb_get_last_path_component_strip(last));\n\n    if (is_directory(src, followLinks)) {\n        if (opts & 0x40) {\n            bb_error_msg_and_die(\"'%s' is a directory\", src);\n        }\n        src_name = xstrdup(argv[0]);\n        src = concat_path_file(src, bb_get_last_path_component_strip(src_name));\n        free(src_name);\n    }\n\n    if (!(opts & 1)) {\n        struct stat statbuf;\n        if (stat64_0(argv[0], &statbuf) != 0) {\n            if (lstat64(argv[0], &statbuf) != 0) {\n                bb_simple_perror_msg(argv[0]);\n                status = 1;\n                free(src_name);\n                goto end;\n            }\n            if ((statbuf.st_mode & 0xF000) == 0xA000) {\n                goto end;\n            }\n        }\n    }\n\n    if (opts & 8) {\n        backup = xasprintf(\"%s%s\", src, suffix);\n        if (rename(src, backup) < 0) {\n            if (errno != ENOENT) {\n                bb_simple_perror_msg(src);\n                status = 1;\n                free(backup);\n                goto end;\n            }\n        } else {\n            free(backup);\n        }\n    }\n\n    if (opts & 2) {\n        unlink(src);\n    }\n\n    link_func = (opts & 1) ? symlink : link;\n\n    if (opts & 0x20) {\n        printf(\"'%s' -> '%s'\\n\", argv[0], src);\n    }\n\n    if (link_func(argv[0], src) < 0) {\n        bb_simple_perror_msg(src);\n        status = 1;\n    }\n\n    free(src_name);\n\nend:\n    while (*(++argv)) {\n        if (!*argv) {\n            break;\n        }\n    }\n\n    return status;\n}\n```"
    },
    {
        "func_name": "get_local_var_value",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000AA928 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000AA92C | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000AA930 | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x000AA934 | 18 00 0B E5 | STR     R0, [R11,#name]\n0x000AA938 | 18 00 1B E5 | LDR     R0, [R11,#name]; s\n0x000AA93C | 11 AB FD EB | BL      strlen\n0x000AA940 | 0C 00 0B E5 | STR     R0, [R11,#len]\n0x000AA944 | 4C 31 9F E5 | LDR     R3, =ptr_to_globals\n0x000AA948 | 00 30 93 E5 | LDR     R3, [R3]\n0x000AA94C | 6C 30 93 E5 | LDR     R3, [R3,#0x6C]\n0x000AA950 | 00 00 53 E3 | CMP     R3, #0\n0x000AA954 | 20 00 00 0A | BEQ     loc_AA9DC\n0x000AA958 | 38 31 9F E5 | LDR     R3, =ptr_to_globals\n0x000AA95C | 00 30 93 E5 | LDR     R3, [R3]\n0x000AA960 | 6C 30 93 E5 | LDR     R3, [R3,#0x6C]\n0x000AA964 | 08 30 0B E5 | STR     R3, [R11,#cpp]\n0x000AA968 | 17 00 00 EA | B       loc_AA9CC\n0x000AA96C | 08 30 1B E5 | LDR     R3, [R11,#cpp]\n0x000AA970 | 00 30 93 E5 | LDR     R3, [R3]\n0x000AA974 | 10 30 0B E5 | STR     R3, [R11,#cp]\n0x000AA978 | 0C 20 1B E5 | LDR     R2, [R11,#len]; n\n0x000AA97C | 18 10 1B E5 | LDR     R1, [R11,#name]; s2\n0x000AA980 | 10 00 1B E5 | LDR     R0, [R11,#cp]; s1\n0x000AA984 | D0 AC FD EB | BL      strncmp\n0x000AA988 | 00 30 A0 E1 | MOV     R3, R0\n0x000AA98C | 00 00 53 E3 | CMP     R3, #0\n0x000AA990 | 0A 00 00 1A | BNE     loc_AA9C0\n0x000AA994 | 10 20 1B E5 | LDR     R2, [R11,#cp]\n0x000AA998 | 0C 30 1B E5 | LDR     R3, [R11,#len]\n0x000AA99C | 03 30 82 E0 | ADD     R3, R2, R3\n0x000AA9A0 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000AA9A4 | 3D 00 53 E3 | CMP     R3, #0x3D ; '='\n0x000AA9A8 | 04 00 00 1A | BNE     loc_AA9C0\n0x000AA9AC | 0C 30 1B E5 | LDR     R3, [R11,#len]\n0x000AA9B0 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000AA9B4 | 10 20 1B E5 | LDR     R2, [R11,#cp]\n0x000AA9B8 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000AA9BC | 32 00 00 EA | B       loc_AAA8C\n0x000AA9C0 | 08 30 1B E5 | LDR     R3, [R11,#cpp]\n0x000AA9C4 | 04 30 83 E2 | ADD     R3, R3, #4\n0x000AA9C8 | 08 30 0B E5 | STR     R3, [R11,#cpp]\n0x000AA9CC | 08 30 1B E5 | LDR     R3, [R11,#cpp]\n0x000AA9D0 | 00 30 93 E5 | LDR     R3, [R3]\n0x000AA9D4 | 00 00 53 E3 | CMP     R3, #0\n0x000AA9D8 | E3 FF FF 1A | BNE     loc_AA96C\n0x000AA9DC | 0C 10 1B E5 | LDR     R1, [R11,#len]; len\n0x000AA9E0 | 18 00 1B E5 | LDR     R0, [R11,#name]; name\n0x000AA9E4 | A6 FF FF EB | BL      get_ptr_to_local_var\n0x000AA9E8 | 14 00 0B E5 | STR     R0, [R11,#vpp]\n0x000AA9EC | 14 30 1B E5 | LDR     R3, [R11,#vpp]\n0x000AA9F0 | 00 00 53 E3 | CMP     R3, #0\n0x000AA9F4 | 06 00 00 0A | BEQ     loc_AAA14\n0x000AA9F8 | 14 30 1B E5 | LDR     R3, [R11,#vpp]\n0x000AA9FC | 00 30 93 E5 | LDR     R3, [R3]\n0x000AAA00 | 04 20 93 E5 | LDR     R2, [R3,#4]\n0x000AAA04 | 0C 30 1B E5 | LDR     R3, [R11,#len]\n0x000AAA08 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000AAA0C | 03 30 82 E0 | ADD     R3, R2, R3\n0x000AAA10 | 1D 00 00 EA | B       loc_AAA8C\n0x000AAA14 | 80 10 9F E5 | LDR     R1, =aPpid_1; \"PPID\"\n0x000AAA18 | 18 00 1B E5 | LDR     R0, [R11,#name]; s1\n0x000AAA1C | CC A8 FD EB | BL      strcmp\n0x000AAA20 | 00 30 A0 E1 | MOV     R3, R0\n0x000AAA24 | 00 00 53 E3 | CMP     R3, #0\n0x000AAA28 | 06 00 00 1A | BNE     loc_AAA48\n0x000AAA2C | 64 30 9F E5 | LDR     R3, =ptr_to_globals\n0x000AAA30 | 00 30 93 E5 | LDR     R3, [R3]\n0x000AAA34 | 14 30 93 E5 | LDR     R3, [R3,#0x14]\n0x000AAA38 | 03 00 A0 E1 | MOV     R0, R3; n\n0x000AAA3C | 32 BA FD EB | BL      utoa\n0x000AAA40 | 00 30 A0 E1 | MOV     R3, R0\n0x000AAA44 | 10 00 00 EA | B       loc_AAA8C\n0x000AAA48 | 50 10 9F E5 | LDR     R1, =aRandom; \"RANDOM\"\n0x000AAA4C | 18 00 1B E5 | LDR     R0, [R11,#name]; s1\n0x000AAA50 | BF A8 FD EB | BL      strcmp\n0x000AAA54 | 00 30 A0 E1 | MOV     R3, R0\n0x000AAA58 | 00 00 53 E3 | CMP     R3, #0\n0x000AAA5C | 09 00 00 1A | BNE     loc_AAA88\n0x000AAA60 | 30 30 9F E5 | LDR     R3, =ptr_to_globals\n0x000AAA64 | 00 30 93 E5 | LDR     R3, [R3]\n0x000AAA68 | 1C 30 83 E2 | ADD     R3, R3, #0x1C\n0x000AAA6C | 03 00 A0 E1 | MOV     R0, R3; rnd\n0x000AAA70 | CE 35 00 EB | BL      next_random\n0x000AAA74 | 00 30 A0 E1 | MOV     R3, R0\n0x000AAA78 | 03 00 A0 E1 | MOV     R0, R3; n\n0x000AAA7C | 22 BA FD EB | BL      utoa\n0x000AAA80 | 00 30 A0 E1 | MOV     R3, R0\n0x000AAA84 | 00 00 00 EA | B       loc_AAA8C\n0x000AAA88 | 00 30 A0 E3 | MOV     R3, #0\n0x000AAA8C | 03 00 A0 E1 | MOV     R0, R3\n0x000AAA90 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000AAA94 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nchar *function(char *name) {\n    int len = strlen(name);\n    char **cpp = ptr_to_globals->unk_6C;\n    if (cpp == NULL) {\n        char *vpp = get_ptr_to_local_var(name, len);\n        if (vpp != NULL) {\n            return vpp + len + 1;\n        }\n        if (strcmp(name, \"PPID\") == 0) {\n            return utoa(ptr_to_globals->unk_14);\n        }\n        if (strcmp(name, \"RANDOM\") == 0) {\n            return utoa(next_random(ptr_to_globals->unk_1C));\n        }\n        return NULL;\n    }\n    while (*cpp) {\n        if (strncmp(*cpp, name, len) == 0 && (*cpp)[len] == '=') {\n            return *cpp + len + 1;\n        }\n        cpp++;\n    }\n    return NULL;\n}\n```"
    },
    {
        "func_name": "find_list_entry2",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000F9914 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000F9918 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000F991C | 01 DA 4D E2 | SUB     SP, SP, #0x1000\n0x000F9920 | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x000F9924 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9928 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F992C | 14 00 03 E5 | STR     R0, [R3,#-0x14]\n0x000F9930 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9934 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9938 | 18 10 03 E5 | STR     R1, [R3,#-0x18]\n0x000F993C | 59 00 00 EA | B       loc_F9AA8\n0x000F9940 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9944 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9948 | 14 30 13 E5 | LDR     R3, [R3,#-0x14]\n0x000F994C | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000F9950 | 0C 30 0B E5 | STR     R3, [R11,#c]\n0x000F9954 | 00 30 A0 E3 | MOV     R3, #0\n0x000F9958 | 08 30 0B E5 | STR     R3, [R11,#pattern_slash_cnt]\n0x000F995C | 08 00 00 EA | B       loc_F9984\n0x000F9960 | 0C 30 1B E5 | LDR     R3, [R11,#c]\n0x000F9964 | 01 20 83 E2 | ADD     R2, R3, #1\n0x000F9968 | 0C 20 0B E5 | STR     R2, [R11,#c]\n0x000F996C | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000F9970 | 2F 00 53 E3 | CMP     R3, #0x2F ; '/'\n0x000F9974 | 02 00 00 1A | BNE     loc_F9984\n0x000F9978 | 08 30 1B E5 | LDR     R3, [R11,#pattern_slash_cnt]\n0x000F997C | 01 30 83 E2 | ADD     R3, R3, #1\n0x000F9980 | 08 30 0B E5 | STR     R3, [R11,#pattern_slash_cnt]\n0x000F9984 | 0C 30 1B E5 | LDR     R3, [R11,#c]\n0x000F9988 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000F998C | 00 00 53 E3 | CMP     R3, #0\n0x000F9990 | F2 FF FF 1A | BNE     loc_F9960\n0x000F9994 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9998 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F999C | 18 30 13 E5 | LDR     R3, [R3,#-0x18]\n0x000F99A0 | 0C 30 0B E5 | STR     R3, [R11,#c]\n0x000F99A4 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F99A8 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F99AC | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x000F99B0 | 10 30 0B E5 | STR     R3, [R11,#d]\n0x000F99B4 | 11 00 00 EA | B       loc_F9A00\n0x000F99B8 | 0C 30 1B E5 | LDR     R3, [R11,#c]\n0x000F99BC | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000F99C0 | 2F 00 53 E3 | CMP     R3, #0x2F ; '/'\n0x000F99C4 | 05 00 00 1A | BNE     loc_F99E0\n0x000F99C8 | 08 30 1B E5 | LDR     R3, [R11,#pattern_slash_cnt]\n0x000F99CC | 01 30 43 E2 | SUB     R3, R3, #1\n0x000F99D0 | 08 30 0B E5 | STR     R3, [R11,#pattern_slash_cnt]\n0x000F99D4 | 08 30 1B E5 | LDR     R3, [R11,#pattern_slash_cnt]\n0x000F99D8 | 00 00 53 E3 | CMP     R3, #0\n0x000F99DC | 14 00 00 BA | BLT     loc_F9A34\n0x000F99E0 | 0C 20 1B E5 | LDR     R2, [R11,#c]\n0x000F99E4 | 01 30 82 E2 | ADD     R3, R2, #1\n0x000F99E8 | 0C 30 0B E5 | STR     R3, [R11,#c]\n0x000F99EC | 10 30 1B E5 | LDR     R3, [R11,#d]\n0x000F99F0 | 01 10 83 E2 | ADD     R1, R3, #1\n0x000F99F4 | 10 10 0B E5 | STR     R1, [R11,#d]\n0x000F99F8 | 00 20 D2 E5 | LDRB    R2, [R2]\n0x000F99FC | 00 20 C3 E5 | STRB    R2, [R3]\n0x000F9A00 | 0C 30 1B E5 | LDR     R3, [R11,#c]\n0x000F9A04 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000F9A08 | 00 00 53 E3 | CMP     R3, #0\n0x000F9A0C | 09 00 00 0A | BEQ     loc_F9A38\n0x000F9A10 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9A14 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9A18 | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x000F9A1C | FF 3E 83 E2 | ADD     R3, R3, #0xFF0\n0x000F9A20 | 0F 30 83 E2 | ADD     R3, R3, #0xF\n0x000F9A24 | 10 20 1B E5 | LDR     R2, [R11,#d]\n0x000F9A28 | 03 00 52 E1 | CMP     R2, R3\n0x000F9A2C | E1 FF FF 1A | BNE     loc_F99B8\n0x000F9A30 | 00 00 00 EA | B       loc_F9A38\n0x000F9A34 | 00 00 A0 E1 | NOP\n0x000F9A38 | 10 30 1B E5 | LDR     R3, [R11,#d]\n0x000F9A3C | 00 20 A0 E3 | MOV     R2, #0\n0x000F9A40 | 00 20 C3 E5 | STRB    R2, [R3]\n0x000F9A44 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9A48 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9A4C | 14 30 13 E5 | LDR     R3, [R3,#-0x14]\n0x000F9A50 | 04 00 93 E5 | LDR     R0, [R3,#4]; pattern\n0x000F9A54 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9A58 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9A5C | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x000F9A60 | 00 20 A0 E3 | MOV     R2, #0; flags\n0x000F9A64 | 03 10 A0 E1 | MOV     R1, R3; name\n0x000F9A68 | 48 6E FC EB | BL      fnmatch\n0x000F9A6C | 00 30 A0 E1 | MOV     R3, R0\n0x000F9A70 | 00 00 53 E3 | CMP     R3, #0\n0x000F9A74 | 03 00 00 1A | BNE     loc_F9A88\n0x000F9A78 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9A7C | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9A80 | 14 30 13 E5 | LDR     R3, [R3,#-0x14]\n0x000F9A84 | 0D 00 00 EA | B       loc_F9AC0\n0x000F9A88 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9A8C | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9A90 | 03 20 A0 E1 | MOV     R2, R3\n0x000F9A94 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9A98 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9A9C | 14 30 13 E5 | LDR     R3, [R3,#-0x14]\n0x000F9AA0 | 00 30 93 E5 | LDR     R3, [R3]\n0x000F9AA4 | 14 30 02 E5 | STR     R3, [R2,#-0x14]\n0x000F9AA8 | 01 3A 4B E2 | SUB     R3, R11, #-(buf+0x10)\n0x000F9AAC | 04 30 43 E2 | SUB     R3, R3, #4\n0x000F9AB0 | 14 30 13 E5 | LDR     R3, [R3,#-0x14]\n0x000F9AB4 | 00 00 53 E3 | CMP     R3, #0\n0x000F9AB8 | A0 FF FF 1A | BNE     loc_F9940\n0x000F9ABC | 00 30 A0 E3 | MOV     R3, #0\n0x000F9AC0 | 03 00 A0 E1 | MOV     R0, R3\n0x000F9AC4 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000F9AC8 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stddef.h>\n\nint process_pattern(char *buf, const char *pattern) {\n    char *name = buf;\n    int pattern_slash_cnt = 0;\n    int c = 0;\n    int d = 0;\n\n    // Count slashes in pattern\n    while (buf[c] != '\\0') {\n        if (buf[c] == '/') {\n            pattern_slash_cnt++;\n        }\n        c++;\n    }\n\n    // Copy name up to the last slash based on the count\n    while (buf[c] != '\\0') {\n        if (buf[c] == '/') {\n            if (pattern_slash_cnt == 0) {\n                break;\n            }\n            pattern_slash_cnt--;\n        }\n        buf[d++] = buf[c++];\n    }\n    buf[d] = '\\0';\n\n    // Match the pattern\n    if (fnmatch(pattern, name, 0) == 0) {\n        return 0;\n    }\n\n    // If no match, reset name pointer\n    name = NULL;\n    return name;\n}\n```"
    },
    {
        "func_name": "sprint_status",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00097928 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0009792C | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00097930 | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x00097934 | 10 00 0B E5 | STR     R0, [R11,#s]\n0x00097938 | 14 10 0B E5 | STR     R1, [R11,#status]\n0x0009793C | 18 20 0B E5 | STR     R2, [R11,#sigonly]\n0x00097940 | 00 30 A0 E3 | MOV     R3, #0\n0x00097944 | 08 30 0B E5 | STR     R3, [R11,#col]\n0x00097948 | 14 30 1B E5 | LDR     R3, [R11,#status]\n0x0009794C | 7F 30 03 E2 | AND     R3, R3, #0x7F\n0x00097950 | 00 00 53 E3 | CMP     R3, #0\n0x00097954 | 33 00 00 0A | BEQ     loc_97A28\n0x00097958 | 14 30 1B E5 | LDR     R3, [R11,#status]\n0x0009795C | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x00097960 | 7F 00 53 E3 | CMP     R3, #0x7F\n0x00097964 | 04 00 00 1A | BNE     loc_9797C\n0x00097968 | 14 30 1B E5 | LDR     R3, [R11,#status]\n0x0009796C | 43 34 A0 E1 | MOV     R3, R3,ASR#8\n0x00097970 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x00097974 | 0C 30 0B E5 | STR     R3, [R11,#st]\n0x00097978 | 02 00 00 EA | B       loc_97988\n0x0009797C | 14 30 1B E5 | LDR     R3, [R11,#status]\n0x00097980 | 7F 30 03 E2 | AND     R3, R3, #0x7F\n0x00097984 | 0C 30 0B E5 | STR     R3, [R11,#st]\n0x00097988 | 18 30 1B E5 | LDR     R3, [R11,#sigonly]\n0x0009798C | 00 00 53 E3 | CMP     R3, #0\n0x00097990 | 09 00 00 0A | BEQ     loc_979BC\n0x00097994 | 0C 30 1B E5 | LDR     R3, [R11,#st]\n0x00097998 | 02 00 53 E3 | CMP     R3, #2\n0x0009799C | 38 00 00 0A | BEQ     loc_97A84\n0x000979A0 | 0C 30 1B E5 | LDR     R3, [R11,#st]\n0x000979A4 | 0D 00 53 E3 | CMP     R3, #0xD\n0x000979A8 | 35 00 00 0A | BEQ     loc_97A84\n0x000979AC | 14 30 1B E5 | LDR     R3, [R11,#status]\n0x000979B0 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x000979B4 | 7F 00 53 E3 | CMP     R3, #0x7F\n0x000979B8 | 33 00 00 0A | BEQ     loc_97A8C\n0x000979BC | 0C 30 1B E5 | LDR     R3, [R11,#st]\n0x000979C0 | 7F 30 03 E2 | AND     R3, R3, #0x7F\n0x000979C4 | 0C 30 0B E5 | STR     R3, [R11,#st]\n0x000979C8 | 0C 00 1B E5 | LDR     R0, [R11,#st]\n0x000979CC | FA F5 FD EB | BL      strsignal\n0x000979D0 | 00 30 A0 E1 | MOV     R3, R0\n0x000979D4 | 03 20 A0 E1 | MOV     R2, R3; fmt\n0x000979D8 | 20 10 A0 E3 | MOV     R1, #0x20 ; ' '; length\n0x000979DC | 10 00 1B E5 | LDR     R0, [R11,#s]; outbuf\n0x000979E0 | 48 EF FF EB | BL      fmtstr\n0x000979E4 | 08 00 0B E5 | STR     R0, [R11,#col]\n0x000979E8 | 14 30 1B E5 | LDR     R3, [R11,#status]\n0x000979EC | 80 30 03 E2 | AND     R3, R3, #0x80\n0x000979F0 | 00 00 53 E3 | CMP     R3, #0\n0x000979F4 | 27 00 00 0A | BEQ     out\n0x000979F8 | 08 30 1B E5 | LDR     R3, [R11,#col]\n0x000979FC | 10 20 1B E5 | LDR     R2, [R11,#s]\n0x00097A00 | 03 30 82 E0 | ADD     R3, R2, R3\n0x00097A04 | 9C 20 9F E5 | LDR     R2, =aCoreDumped; \" (core dumped)\"\n0x00097A08 | 10 10 A0 E3 | MOV     R1, #0x10; length\n0x00097A0C | 03 00 A0 E1 | MOV     R0, R3; outbuf\n0x00097A10 | 3C EF FF EB | BL      fmtstr\n0x00097A14 | 00 20 A0 E1 | MOV     R2, R0\n0x00097A18 | 08 30 1B E5 | LDR     R3, [R11,#col]\n0x00097A1C | 02 30 83 E0 | ADD     R3, R3, R2\n0x00097A20 | 08 30 0B E5 | STR     R3, [R11,#col]\n0x00097A24 | 1B 00 00 EA | B       out\n0x00097A28 | 18 30 1B E5 | LDR     R3, [R11,#sigonly]\n0x00097A2C | 00 00 53 E3 | CMP     R3, #0\n0x00097A30 | 17 00 00 1A | BNE     loc_97A94\n0x00097A34 | 14 30 1B E5 | LDR     R3, [R11,#status]\n0x00097A38 | 43 34 A0 E1 | MOV     R3, R3,ASR#8\n0x00097A3C | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x00097A40 | 0C 30 0B E5 | STR     R3, [R11,#st]\n0x00097A44 | 0C 30 1B E5 | LDR     R3, [R11,#st]\n0x00097A48 | 00 00 53 E3 | CMP     R3, #0\n0x00097A4C | 06 00 00 0A | BEQ     loc_97A6C\n0x00097A50 | 0C 30 1B E5 | LDR     R3, [R11,#st]\n0x00097A54 | 50 20 9F E5 | LDR     R2, =aDoneD; \"Done(%d)\"\n0x00097A58 | 10 10 A0 E3 | MOV     R1, #0x10; length\n0x00097A5C | 10 00 1B E5 | LDR     R0, [R11,#s]; outbuf\n0x00097A60 | 28 EF FF EB | BL      fmtstr\n0x00097A64 | 08 00 0B E5 | STR     R0, [R11,#col]\n0x00097A68 | 0A 00 00 EA | B       out\n0x00097A6C | 3C 20 9F E5 | LDR     R2, =aDone_0; \"Done\"\n0x00097A70 | 10 10 A0 E3 | MOV     R1, #0x10; length\n0x00097A74 | 10 00 1B E5 | LDR     R0, [R11,#s]; outbuf\n0x00097A78 | 22 EF FF EB | BL      fmtstr\n0x00097A7C | 08 00 0B E5 | STR     R0, [R11,#col]\n0x00097A80 | 04 00 00 EA | B       out\n0x00097A84 | 00 00 A0 E1 | NOP\n0x00097A88 | 02 00 00 EA | B       out\n0x00097A8C | 00 00 A0 E1 | NOP\n0x00097A90 | 00 00 00 EA | B       out\n0x00097A94 | 00 00 A0 E1 | NOP\n0x00097A98 | 08 30 1B E5 | LDR     R3, [R11,#col]\n0x00097A9C | 03 00 A0 E1 | MOV     R0, R3\n0x00097AA0 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00097AA4 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid format_signal(int s, int status, int sigonly) {\n    char outbuf[32];\n    int col = 0;\n    int st;\n\n    if ((status & 0x7F) == 0) {\n        if (sigonly == 0) {\n            st = (status >> 8) & 0xFF;\n            if (st != 0) {\n                snprintf(outbuf, sizeof(outbuf), \"Done(%d)\", st);\n                col = strlen(outbuf);\n            } else {\n                snprintf(outbuf, sizeof(outbuf), \"Done\");\n                col = strlen(outbuf);\n            }\n        }\n    } else {\n        if ((status & 0xFF) == 0x7F) {\n            st = (status >> 8) & 0xFF;\n        } else {\n            st = status & 0x7F;\n        }\n        strsignal(st);\n        snprintf(outbuf, sizeof(outbuf), \" %c\", ' ');\n        col = strlen(outbuf);\n        if ((status & 0x80) != 0) {\n            strcat(outbuf, \" (core dumped)\");\n            col += strlen(\" (core dumped)\");\n        }\n    }\n\n    // The 'col' variable seems to be used to track the current output column\n    // after formatting the output, but since we don't have the actual\n    // implementation of 'strsignal' and 'fmtstr', we can't replicate the exact\n    // behavior. The 'col' variable would be used to determine where to append\n    // additional strings if needed.\n}\n```"
    },
    {
        "func_name": "write_str_to_file",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0008440C | 00 48 2D E9 | PUSH    {R11,LR}\n0x00084410 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00084414 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x00084418 | 10 00 0B E5 | STR     R0, [R11,#fname]\n0x0008441C | 14 10 0B E5 | STR     R1, [R11,#str]\n0x00084420 | 10 00 1B E5 | LDR     R0, [R11,#fname]; path\n0x00084424 | 9F 52 FE EB | BL      fopen_for_write\n0x00084428 | 08 00 0B E5 | STR     R0, [R11,#fp]\n0x0008442C | 08 30 1B E5 | LDR     R3, [R11,#fp]\n0x00084430 | 00 00 53 E3 | CMP     R3, #0\n0x00084434 | 01 00 00 1A | BNE     loc_84440\n0x00084438 | 01 30 A0 E3 | MOV     R3, #1\n0x0008443C | 05 00 00 EA | B       loc_84458\n0x00084440 | 08 10 1B E5 | LDR     R1, [R11,#fp]\n0x00084444 | 14 00 1B E5 | LDR     R0, [R11,#str]\n0x00084448 | 0E 42 FE EB | BL      fputs_unlocked\n0x0008444C | 08 00 1B E5 | LDR     R0, [R11,#fp]; stream\n0x00084450 | 1E 45 FE EB | BL      fclose\n0x00084454 | 00 30 A0 E3 | MOV     R3, #0\n0x00084458 | 03 00 A0 E1 | MOV     R0, R3\n0x0008445C | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00084460 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdio.h>\n\nint write_string_to_file(const char *fname, const char *str) {\n    FILE *fp = fopen(fname, \"w\");\n    if (fp == NULL) {\n        return 1;\n    }\n    fputs(str, fp);\n    fclose(fp);\n    return 0;\n}\n```"
    },
    {
        "func_name": "parse_old_offset",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0010C85C | 10 48 2D E9 | PUSH    {R4,R11,LR}\n0x0010C860 | 08 B0 8D E2 | ADD     R11, SP, #8\n0x0010C864 | 14 D0 4D E2 | SUB     SP, SP, #0x14\n0x0010C868 | 18 00 0B E5 | STR     R0, [R11,#s]\n0x0010C86C | 1C 10 0B E5 | STR     R1, [R11,#offset]\n0x0010C870 | 18 30 1B E5 | LDR     R3, [R11,#s]\n0x0010C874 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0010C878 | 2B 00 53 E3 | CMP     R3, #0x2B ; '+'\n0x0010C87C | 02 00 00 1A | BNE     loc_10C88C\n0x0010C880 | 18 30 1B E5 | LDR     R3, [R11,#s]\n0x0010C884 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0010C888 | 18 30 0B E5 | STR     R3, [R11,#s]\n0x0010C88C | 18 30 1B E5 | LDR     R3, [R11,#s]\n0x0010C890 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0010C894 | 30 30 43 E2 | SUB     R3, R3, #0x30 ; '0'\n0x0010C898 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x0010C89C | 09 00 53 E3 | CMP     R3, #9\n0x0010C8A0 | 01 00 00 9A | BLS     loc_10C8AC\n0x0010C8A4 | 00 30 A0 E3 | MOV     R3, #0\n0x0010C8A8 | 31 00 00 EA | B       loc_10C974\n0x0010C8AC | 2E 10 A0 E3 | MOV     R1, #0x2E ; '.'; c\n0x0010C8B0 | 18 00 1B E5 | LDR     R0, [R11,#s]; s\n0x0010C8B4 | 45 23 FC EB | BL      strchr\n0x0010C8B8 | 14 00 0B E5 | STR     R0, [R11,#p]\n0x0010C8BC | 08 30 A0 E3 | MOV     R3, #8\n0x0010C8C0 | 10 30 0B E5 | STR     R3, [R11,#radix]\n0x0010C8C4 | 14 30 1B E5 | LDR     R3, [R11,#p]\n0x0010C8C8 | 00 00 53 E3 | CMP     R3, #0\n0x0010C8CC | 05 00 00 0A | BEQ     loc_10C8E8\n0x0010C8D0 | 14 30 1B E5 | LDR     R3, [R11,#p]\n0x0010C8D4 | 00 20 A0 E3 | MOV     R2, #0\n0x0010C8D8 | 00 20 C3 E5 | STRB    R2, [R3]\n0x0010C8DC | 0A 30 A0 E3 | MOV     R3, #0xA\n0x0010C8E0 | 10 30 0B E5 | STR     R3, [R11,#radix]\n0x0010C8E4 | 0F 00 00 EA | B       loc_10C928\n0x0010C8E8 | 18 30 1B E5 | LDR     R3, [R11,#s]\n0x0010C8EC | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0010C8F0 | 30 00 53 E3 | CMP     R3, #0x30 ; '0'\n0x0010C8F4 | 0B 00 00 1A | BNE     loc_10C928\n0x0010C8F8 | 18 30 1B E5 | LDR     R3, [R11,#s]\n0x0010C8FC | 01 30 83 E2 | ADD     R3, R3, #1\n0x0010C900 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0010C904 | 78 00 53 E3 | CMP     R3, #0x78 ; 'x'\n0x0010C908 | 04 00 00 0A | BEQ     loc_10C920\n0x0010C90C | 18 30 1B E5 | LDR     R3, [R11,#s]\n0x0010C910 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0010C914 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0010C918 | 58 00 53 E3 | CMP     R3, #0x58 ; 'X'\n0x0010C91C | 01 00 00 1A | BNE     loc_10C928\n0x0010C920 | 10 30 A0 E3 | MOV     R3, #0x10\n0x0010C924 | 10 30 0B E5 | STR     R3, [R11,#radix]\n0x0010C928 | 50 20 9F E5 | LDR     R2, =Bb.10702; suffixes\n0x0010C92C | 10 10 1B E5 | LDR     R1, [R11,#radix]; base\n0x0010C930 | 18 00 1B E5 | LDR     R0, [R11,#s]; numstr\n0x0010C934 | 4A 22 01 EB | BL      xstrtoull_sfx\n0x0010C938 | 00 30 A0 E1 | MOV     R3, R0\n0x0010C93C | 01 40 A0 E1 | MOV     R4, R1\n0x0010C940 | 1C 20 1B E5 | LDR     R2, [R11,#offset]\n0x0010C944 | 18 00 82 E8 | STM     R2, {R3,R4}\n0x0010C948 | 14 30 1B E5 | LDR     R3, [R11,#p]\n0x0010C94C | 00 00 53 E3 | CMP     R3, #0\n0x0010C950 | 02 00 00 0A | BEQ     loc_10C960\n0x0010C954 | 14 30 1B E5 | LDR     R3, [R11,#p]\n0x0010C958 | 2E 20 A0 E3 | MOV     R2, #0x2E ; '.'\n0x0010C95C | 00 20 C3 E5 | STRB    R2, [R3]\n0x0010C960 | 1C 30 1B E5 | LDR     R3, [R11,#offset]\n0x0010C964 | 18 00 93 E8 | LDM     R3, {R3,R4}\n0x0010C968 | 04 30 E0 E1 | MVN     R3, R4\n0x0010C96C | A3 3F A0 E1 | MOV     R3, R3,LSR#31\n0x0010C970 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x0010C974 | 03 00 A0 E1 | MOV     R0, R3\n0x0010C978 | 08 D0 4B E2 | SUB     SP, R11, #8\n0x0010C97C | 10 88 BD E8 | POP     {R4,R11,PC}",
        "output": "```c\n#include <stdbool.h>\n\nunsigned int parse_number(const char **s, unsigned int *offset) {\n    const char *numstr = *s;\n    unsigned int base = 10;\n    bool has_suffix = false;\n    unsigned int result, result_high;\n\n    if (*numstr == '+') {\n        numstr++;\n    }\n\n    if (*numstr == '0') {\n        numstr++;\n        if (*numstr == 'x' || *numstr == 'X') {\n            base = 16;\n            numstr++;\n        }\n    } else {\n        const char *p = strchr(numstr, '.');\n        if (p) {\n            *p = '\\0'; // terminate the string at the dot\n            base = 10;\n            has_suffix = true;\n        }\n    }\n\n    result = xstrtoull_sfx(numstr, &result_high, base);\n\n    if (has_suffix) {\n        *(strchr(numstr, '\\0')) = '.'; // restore the dot\n    }\n\n    *offset += result_high;\n    *s += result_high;\n\n    return result | (result_high == 0 ? 0 : 0xFFFFFFFF);\n}\n```"
    },
    {
        "func_name": "do_lzo_compress",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000E9D2C | 00 48 2D E9 | PUSH    {R11,LR}\n0x000E9D30 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000E9D34 | 13 DE 4D E2 | SUB     SP, SP, #0x130\n0x000E9D38 | 13 3E 4B E2 | SUB     R3, R11, #-header\n0x000E9D3C | 4B 2F A0 E3 | MOV     R2, #0x12C; n\n0x000E9D40 | 00 10 A0 E3 | MOV     R1, #0; c\n0x000E9D44 | 03 00 A0 E1 | MOV     R0, R3; s\n0x000E9D48 | 86 AE FC EB | BL      memset\n0x000E9D4C | 13 3E 4B E2 | SUB     R3, R11, #-header\n0x000E9D50 | 03 00 A0 E1 | MOV     R0, R3; h\n0x000E9D54 | D0 FF FF EB | BL      lzo_set_method\n0x000E9D58 | 8C 30 9F E5 | LDR     R3, =0x1010\n0x000E9D5C | 30 31 0B E5 | STR     R3, [R11,#header]\n0x000E9D60 | 25 3D A0 E3 | MOV     R3, #0x940\n0x000E9D64 | 28 31 0B E5 | STR     R3, [R11,#header.version_needed_to_extract]\n0x000E9D68 | 80 30 9F E5 | LDR     R3, =0x2030\n0x000E9D6C | 2C 31 0B E5 | STR     R3, [R11,#header.lib_version]\n0x000E9D70 | 03 34 A0 E3 | MOV     R3, #0x3000000\n0x000E9D74 | 24 31 0B E5 | STR     R3, [R11,#header.flags]\n0x000E9D78 | 74 30 9F E5 | LDR     R3, =option_mask32\n0x000E9D7C | 00 30 93 E5 | LDR     R3, [R3]\n0x000E9D80 | 02 39 03 E2 | AND     R3, R3, #0x8000\n0x000E9D84 | 00 00 53 E3 | CMP     R3, #0\n0x000E9D88 | 02 00 00 0A | BEQ     loc_E9D98\n0x000E9D8C | 08 31 5B E5 | LDRB    R3, [R11,#header.method]\n0x000E9D90 | 03 00 53 E3 | CMP     R3, #3\n0x000E9D94 | 0A 00 00 1A | BNE     loc_E9DC4\n0x000E9D98 | 24 31 1B E5 | LDR     R3, [R11,#header.flags]\n0x000E9D9C | 01 30 83 E3 | ORR     R3, R3, #1\n0x000E9DA0 | 24 31 0B E5 | STR     R3, [R11,#header.flags]\n0x000E9DA4 | 48 30 9F E5 | LDR     R3, =option_mask32\n0x000E9DA8 | 00 30 93 E5 | LDR     R3, [R3]\n0x000E9DAC | 01 39 03 E2 | AND     R3, R3, #0x4000\n0x000E9DB0 | 00 00 53 E3 | CMP     R3, #0\n0x000E9DB4 | 02 00 00 0A | BEQ     loc_E9DC4\n0x000E9DB8 | 24 31 1B E5 | LDR     R3, [R11,#header.flags]\n0x000E9DBC | 02 30 83 E3 | ORR     R3, R3, #2\n0x000E9DC0 | 24 31 0B E5 | STR     R3, [R11,#header.flags]\n0x000E9DC4 | 13 3E 4B E2 | SUB     R3, R11, #-header\n0x000E9DC8 | 03 00 A0 E1 | MOV     R0, R3; h\n0x000E9DCC | 92 FE FF EB | BL      write_header\n0x000E9DD0 | 13 3E 4B E2 | SUB     R3, R11, #-header\n0x000E9DD4 | 03 00 A0 E1 | MOV     R0, R3; h\n0x000E9DD8 | 9D FC FF EB | BL      lzo_compress\n0x000E9DDC | 00 30 A0 E1 | MOV     R3, R0\n0x000E9DE0 | 03 00 A0 E1 | MOV     R0, R3\n0x000E9DE4 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000E9DE8 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <string.h>\n\ntypedef struct {\n    unsigned int version_needed_to_extract;\n    unsigned int lib_version;\n    unsigned int flags;\n    unsigned char method;\n} header_t;\n\nextern void lzo_set_method(header_t *h);\nextern void write_header(header_t *h);\nextern int lzo_compress(header_t *h);\nextern unsigned int option_mask32;\n\nint function() {\n    header_t header;\n    memset(&header, 0, sizeof(header));\n\n    lzo_set_method(&header);\n\n    header.version_needed_to_extract = 0x940;\n    header.lib_version = 0x2030;\n    header.flags = 0x3000000;\n\n    if (option_mask32 & 0x8000) {\n        if (header.method == 3) {\n            header.flags |= 1;\n        }\n    }\n\n    if (option_mask32 & 0x4000) {\n        header.flags |= 2;\n    }\n\n    write_header(&header);\n    return lzo_compress(&header);\n}\n```"
    },
    {
        "func_name": "parse_next_rule",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000CD1A4 | 10 48 2D E9 | PUSH    {R4,R11,LR}\n0x000CD1A8 | 08 B0 8D E2 | ADD     R11, SP, #8\n0x000CD1AC | 34 D0 4D E2 | SUB     SP, SP, #0x34\n0x000CD1B0 | 0C 33 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD1B4 | 18 00 93 E5 | LDR     R0, [R3,#(qword_18F9F0 - 0x18F9D8)]; parser\n0x000CD1B8 | 34 10 4B E2 | SUB     R1, R11, #-tokens; tokens\n0x000CD1BC | 04 33 9F E5 | LDR     R3, =byte_175554; delims\n0x000CD1C0 | 04 23 9F E5 | LDR     R2, =0x70304; flags\n0x000CD1C4 | F9 F8 01 EB | BL      config_read\n0x000CD1C8 | 00 30 A0 E1 | MOV     R3, R0\n0x000CD1CC | 00 00 53 E3 | CMP     R3, #0\n0x000CD1D0 | 07 00 00 1A | BNE     loc_CD1F4\n0x000CD1D4 | E8 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD1D8 | 18 30 93 E5 | LDR     R3, [R3,#(qword_18F9F0 - 0x18F9D8)]\n0x000CD1DC | 03 00 A0 E1 | MOV     R0, R3; parser\n0x000CD1E0 | 68 F8 01 EB | BL      config_close\n0x000CD1E4 | D8 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD1E8 | 00 20 A0 E3 | MOV     R2, #0\n0x000CD1EC | 18 20 83 E5 | STR     R2, [R3,#(qword_18F9F0 - 0x18F9D8)]\n0x000CD1F0 | B1 00 00 EA | B       loc_CD4BC\n0x000CD1F4 | 34 30 1B E5 | LDR     R3, [R11,#tokens]\n0x000CD1F8 | 10 30 0B E5 | STR     R3, [R11,#val]\n0x000CD1FC | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD200 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000CD204 | B8 22 9F E5 | LDR     R2, =bb_common_bufsiz1\n0x000CD208 | 2D 00 53 E3 | CMP     R3, #0x2D ; '-'\n0x000CD20C | 01 30 A0 03 | MOVEQ   R3, #1\n0x000CD210 | 00 30 A0 13 | MOVNE   R3, #0\n0x000CD214 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x000CD218 | 24 30 C2 E5 | STRB    R3, [R2,#(qword_18F9F8+4 - 0x18F9D8)]\n0x000CD21C | A0 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD220 | 24 30 D3 E5 | LDRB    R3, [R3,#(qword_18F9F8+4 - 0x18F9D8)]\n0x000CD224 | 03 20 A0 E1 | MOV     R2, R3\n0x000CD228 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD22C | 02 30 83 E0 | ADD     R3, R3, R2\n0x000CD230 | 10 30 0B E5 | STR     R3, [R11,#val]\n0x000CD234 | 10 00 1B E5 | LDR     R0, [R11,#val]; val\n0x000CD238 | 91 FF FF EB | BL      parse_envmatch_pfx\n0x000CD23C | 10 00 0B E5 | STR     R0, [R11,#val]\n0x000CD240 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD244 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000CD248 | 40 00 53 E3 | CMP     R3, #0x40 ; '@'\n0x000CD24C | 1E 00 00 1A | BNE     loc_CD2CC\n0x000CD250 | 78 22 9F E5 | LDR     R2, =unk_18FA04\n0x000CD254 | 78 12 9F E5 | LDR     R1, =word_18FA08\n0x000CD258 | 78 32 9F E5 | LDR     R3, =byte_18FA0C\n0x000CD25C | 00 30 8D E5 | STR     R3, [SP,#0x3C+var_3C]\n0x000CD260 | 01 30 A0 E1 | MOV     R3, R1\n0x000CD264 | 70 12 9F E5 | LDR     R1, =aUUU_1; \"@%u,%u-%u\"\n0x000CD268 | 10 00 1B E5 | LDR     R0, [R11,#val]; s\n0x000CD26C | 09 22 FD EB | BL      sscanf\n0x000CD270 | 14 00 0B E5 | STR     R0, [R11,#sc]\n0x000CD274 | 14 30 1B E5 | LDR     R3, [R11,#sc]\n0x000CD278 | 01 00 53 E3 | CMP     R3, #1\n0x000CD27C | 03 00 00 DA | BLE     loc_CD290\n0x000CD280 | 3C 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD284 | 2C 30 93 E5 | LDR     R3, [R3,#(unk_18FA04 - 0x18F9D8)]\n0x000CD288 | 00 00 53 E3 | CMP     R3, #0\n0x000CD28C | 06 00 00 AA | BGE     loc_CD2AC\n0x000CD290 | 2C 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD294 | 18 30 93 E5 | LDR     R3, [R3,#(qword_18F9F0 - 0x18F9D8)]\n0x000CD298 | 18 30 93 E5 | LDR     R3, [R3,#0x18]\n0x000CD29C | 03 10 A0 E1 | MOV     R1, R3\n0x000CD2A0 | 38 02 9F E5 | LDR     R0, =aBadMajMinOnLin; \"bad @maj,min on line %d\"\n0x000CD2A4 | C6 2E FD EB | BL      bb_error_msg\n0x000CD2A8 | 80 00 00 EA | B       next_rule\n0x000CD2AC | 14 30 1B E5 | LDR     R3, [R11,#sc]\n0x000CD2B0 | 02 00 53 E3 | CMP     R3, #2\n0x000CD2B4 | 2D 00 00 1A | BNE     loc_CD370\n0x000CD2B8 | 04 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD2BC | 00 22 9F E5 | LDR     R2, =bb_common_bufsiz1\n0x000CD2C0 | 30 30 93 E5 | LDR     R3, [R3,#(word_18FA08 - 0x18F9D8)]\n0x000CD2C4 | 34 30 82 E5 | STR     R3, [R2,#(byte_18FA0C - 0x18F9D8)]\n0x000CD2C8 | 28 00 00 EA | B       loc_CD370\n0x000CD2CC | 3D 10 A0 E3 | MOV     R1, #0x3D ; '='; c\n0x000CD2D0 | 10 00 1B E5 | LDR     R0, [R11,#val]; s\n0x000CD2D4 | BD 20 FD EB | BL      strchr\n0x000CD2D8 | 18 00 0B E5 | STR     R0, [R11,#eq]\n0x000CD2DC | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD2E0 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000CD2E4 | 24 00 53 E3 | CMP     R3, #0x24 ; '$'\n0x000CD2E8 | 18 00 00 1A | BNE     loc_CD350\n0x000CD2EC | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD2F0 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000CD2F4 | 10 30 0B E5 | STR     R3, [R11,#val]\n0x000CD2F8 | 18 30 1B E5 | LDR     R3, [R11,#eq]\n0x000CD2FC | 00 00 53 E3 | CMP     R3, #0\n0x000CD300 | 06 00 00 1A | BNE     loc_CD320\n0x000CD304 | B8 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD308 | 18 30 93 E5 | LDR     R3, [R3,#(qword_18F9F0 - 0x18F9D8)]\n0x000CD30C | 18 30 93 E5 | LDR     R3, [R3,#0x18]\n0x000CD310 | 03 10 A0 E1 | MOV     R1, R3\n0x000CD314 | C8 01 9F E5 | LDR     R0, =aBadEnvvarRegex; \"bad $envvar=regex on line %d\"\n0x000CD318 | A9 2E FD EB | BL      bb_error_msg\n0x000CD31C | 63 00 00 EA | B       next_rule\n0x000CD320 | 18 20 1B E5 | LDR     R2, [R11,#eq]\n0x000CD324 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD328 | 03 30 42 E0 | SUB     R3, R2, R3\n0x000CD32C | 90 41 9F E5 | LDR     R4, =bb_common_bufsiz1\n0x000CD330 | 03 10 A0 E1 | MOV     R1, R3; n\n0x000CD334 | 10 00 1B E5 | LDR     R0, [R11,#val]; s\n0x000CD338 | 22 32 FD EB | BL      xstrndup\n0x000CD33C | 00 30 A0 E1 | MOV     R3, R0\n0x000CD340 | 40 30 84 E5 | STR     R3, [R4,#(byte_18FA0C+0xC - 0x18F9D8)]\n0x000CD344 | 18 30 1B E5 | LDR     R3, [R11,#eq]\n0x000CD348 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000CD34C | 10 30 0B E5 | STR     R3, [R11,#val]\n0x000CD350 | 90 31 9F E5 | LDR     R3, =(byte_18FA20+4)\n0x000CD354 | 01 20 A0 E3 | MOV     R2, #1; cflags\n0x000CD358 | 10 10 1B E5 | LDR     R1, [R11,#val]; regex\n0x000CD35C | 03 00 A0 E1 | MOV     R0, R3; preg\n0x000CD360 | 2C 27 02 EB | BL      xregcomp\n0x000CD364 | 58 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD368 | 01 20 A0 E3 | MOV     R2, #1\n0x000CD36C | 25 20 C3 E5 | STRB    R2, [R3,#(qword_18F9F8+5 - 0x18F9D8)]\n0x000CD370 | 74 01 9F E5 | LDR     R0, =(byte_18FA0C+4); u\n0x000CD374 | 30 30 1B E5 | LDR     R3, [R11,#tokens+4]\n0x000CD378 | 01 20 A0 E3 | MOV     R2, #1; numeric_ok\n0x000CD37C | 03 10 A0 E1 | MOV     R1, R3; ug\n0x000CD380 | B2 40 FD EB | BL      get_uidgid\n0x000CD384 | 00 30 A0 E1 | MOV     R3, R0\n0x000CD388 | 00 00 53 E3 | CMP     R3, #0\n0x000CD38C | 07 00 00 1A | BNE     loc_CD3B0\n0x000CD390 | 30 10 1B E5 | LDR     R1, [R11,#tokens+4]\n0x000CD394 | 28 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD398 | 18 30 93 E5 | LDR     R3, [R3,#(qword_18F9F0 - 0x18F9D8)]\n0x000CD39C | 18 30 93 E5 | LDR     R3, [R3,#0x18]\n0x000CD3A0 | 03 20 A0 E1 | MOV     R2, R3\n0x000CD3A4 | 44 01 9F E5 | LDR     R0, =aUnknownUserGro_1; \"unknown user/group '%s' on line %d\"\n0x000CD3A8 | 85 2E FD EB | BL      bb_error_msg\n0x000CD3AC | 3F 00 00 EA | B       next_rule\n0x000CD3B0 | 2C 30 1B E5 | LDR     R3, [R11,#tokens+8]\n0x000CD3B4 | 38 21 9F E5 | LDR     R2, =unk_18FA00\n0x000CD3B8 | 02 10 A0 E1 | MOV     R1, R2; current_mode\n0x000CD3BC | 03 00 A0 E1 | MOV     R0, R3; s\n0x000CD3C0 | 42 F9 01 EB | BL      bb_parse_mode\n0x000CD3C4 | 28 30 1B E5 | LDR     R3, [R11,#tokens+0xC]\n0x000CD3C8 | 10 30 0B E5 | STR     R3, [R11,#val]\n0x000CD3CC | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD3D0 | 00 00 53 E3 | CMP     R3, #0\n0x000CD3D4 | 16 00 00 0A | BEQ     loc_CD434\n0x000CD3D8 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD3DC | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000CD3E0 | 03 10 A0 E1 | MOV     R1, R3; c\n0x000CD3E4 | 0C 01 9F E5 | LDR     R0, =asc_1755C0; \">=!\"\n0x000CD3E8 | 78 20 FD EB | BL      strchr\n0x000CD3EC | 00 30 A0 E1 | MOV     R3, R0\n0x000CD3F0 | 00 00 53 E3 | CMP     R3, #0\n0x000CD3F4 | 0E 00 00 0A | BEQ     loc_CD434\n0x000CD3F8 | 10 00 1B E5 | LDR     R0, [R11,#val]; s\n0x000CD3FC | 81 2D FD EB | BL      skip_non_whitespace\n0x000CD400 | 1C 00 0B E5 | STR     R0, [R11,#s]\n0x000CD404 | 1C 20 1B E5 | LDR     R2, [R11,#s]\n0x000CD408 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD40C | 03 30 42 E0 | SUB     R3, R2, R3\n0x000CD410 | AC 40 9F E5 | LDR     R4, =bb_common_bufsiz1\n0x000CD414 | 03 10 A0 E1 | MOV     R1, R3; n\n0x000CD418 | 10 00 1B E5 | LDR     R0, [R11,#val]; s\n0x000CD41C | E9 31 FD EB | BL      xstrndup\n0x000CD420 | 00 30 A0 E1 | MOV     R3, R0\n0x000CD424 | 44 30 84 E5 | STR     R3, [R4,#(byte_18FA0C+0x10 - 0x18F9D8)]\n0x000CD428 | 1C 00 1B E5 | LDR     R0, [R11,#s]; s\n0x000CD42C | 5E 2D FD EB | BL      skip_whitespace\n0x000CD430 | 10 00 0B E5 | STR     R0, [R11,#val]\n0x000CD434 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD438 | 00 00 53 E3 | CMP     R3, #0\n0x000CD43C | 1D 00 00 0A | BEQ     loc_CD4B8\n0x000CD440 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD444 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000CD448 | 00 00 53 E3 | CMP     R3, #0\n0x000CD44C | 19 00 00 0A | BEQ     loc_CD4B8\n0x000CD450 | A4 30 9F E5 | LDR     R3, =asc_1755C4; \"$@*\"\n0x000CD454 | 20 30 0B E5 | STR     R3, [R11,#s_0]\n0x000CD458 | 10 30 1B E5 | LDR     R3, [R11,#val]\n0x000CD45C | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000CD460 | 03 10 A0 E1 | MOV     R1, R3; c\n0x000CD464 | 20 00 1B E5 | LDR     R0, [R11,#s_0]; s\n0x000CD468 | 58 20 FD EB | BL      strchr\n0x000CD46C | 24 00 0B E5 | STR     R0, [R11,#s2]\n0x000CD470 | 24 30 1B E5 | LDR     R3, [R11,#s2]\n0x000CD474 | 00 00 53 E3 | CMP     R3, #0\n0x000CD478 | 06 00 00 1A | BNE     loc_CD498\n0x000CD47C | 40 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CD480 | 18 30 93 E5 | LDR     R3, [R3,#(qword_18F9F0 - 0x18F9D8)]\n0x000CD484 | 18 30 93 E5 | LDR     R3, [R3,#0x18]\n0x000CD488 | 03 10 A0 E1 | MOV     R1, R3\n0x000CD48C | 6C 00 9F E5 | LDR     R0, =aBadLineU; \"bad line %u\"\n0x000CD490 | 4B 2E FD EB | BL      bb_error_msg\n0x000CD494 | 05 00 00 EA | B       next_rule\n0x000CD498 | 24 40 9F E5 | LDR     R4, =bb_common_bufsiz1\n0x000CD49C | 10 00 1B E5 | LDR     R0, [R11,#val]; s\n0x000CD4A0 | B1 31 FD EB | BL      xstrdup\n0x000CD4A4 | 00 30 A0 E1 | MOV     R3, R0\n0x000CD4A8 | 48 30 84 E5 | STR     R3, [R4,#(byte_18FA20 - 0x18F9D8)]\n0x000CD4AC | 02 00 00 EA | B       loc_CD4BC\n0x000CD4B0 | 9B FE FF EB | BL      clean_up_cur_rule\n0x000CD4B4 | 3D FF FF EA | B       loc_CD1B0\n0x000CD4B8 | 00 00 A0 E1 | NOP\n0x000CD4BC | 08 D0 4B E2 | SUB     SP, R11, #8\n0x000CD4C0 | 10 88 BD E8 | POP     {R4,R11,PC}",
        "output": "```c\nvoid function() {\n    char *val, *s, *s_0, *s2;\n    int tokens, sc, eq, u, ug;\n    int result;\n    char c;\n    char *parser;\n    char delims;\n    int flags;\n    char *current_mode;\n    int numeric_ok;\n    char *preg;\n    char *regex;\n    int cflags;\n\n    parser = bb_common_bufsiz1;\n    tokens = -tokens;\n    delims = byte_175554;\n    flags = 0x70304;\n    result = config_read(parser, tokens, delims, flags);\n    if (result == 0) {\n        parser = bb_common_bufsiz1;\n        config_close(parser);\n        bb_common_bufsiz1 = 0;\n        goto loc_CD4BC;\n    }\n\n    val = tokens;\n    val = val;\n    c = *val;\n    if (c == '-') {\n        bb_common_bufsiz1 = 1;\n    } else {\n        bb_common_bufsiz1 = 0;\n    }\n\n    c = bb_common_bufsiz1;\n    val += c;\n    val = parse_envmatch_pfx(val);\n    c = *val;\n    if (c == '@') {\n        sscanf(val, \"@%u,%u-%u\", &unk_18FA04, &word_18FA08, &byte_18FA0C);\n        sc = result;\n        if (sc > 1) {\n            if (unk_18FA04 < 0) {\n                parser = bb_common_bufsiz1;\n                bb_error_msg(\"bad @maj,min on line %d\", parser);\n                goto next_rule;\n            }\n        } else if (sc == 2) {\n            word_18FA08 = unk_18FA04;\n            goto loc_CD370;\n        }\n    } else {\n        eq = strchr(val, '=');\n        if (*val == '$') {\n            val++;\n            if (eq == NULL) {\n                parser = bb_common_bufsiz1;\n                bb_error_msg(\"bad $envvar=regex on line %d\", parser);\n                goto next_rule;\n            }\n            regex = xstrndup(val, eq - val);\n            val = eq + 1;\n        }\n        preg = (byte_18FA20 + 4);\n        regex = val;\n        cflags = 1;\n        xregcomp(preg, regex, cflags);\n        bb_common_bufsiz1 = 1;\n    }\n\n    loc_CD370:\n    u = (byte_18FA0C + 4);\n    ug = tokens + 4;\n    numeric_ok = 1;\n    get_uidgid(&u, ug, numeric_ok);\n    if (result == 0) {\n        ug = tokens + 4;\n        parser = bb_common_bufsiz1;\n        bb_error_msg(\"unknown user/group '%s' on line %d\", ug, parser);\n        goto next_rule;\n    }\n\n    current_mode = bb_parse_mode(tokens + 8);\n    val = tokens + 0xC;\n    if (val == NULL) {\n        goto loc_CD4B8;\n    }\n\n    c = *val;\n    if (strchr(\">=!\", c) != NULL) {\n        s = skip_non_whitespace(val);\n        s2 = xstrndup(val, s - val);\n        s = skip_whitespace(s);\n        val = s;\n    }\n\n    if (val == NULL || *val == '\\0') {\n        goto loc_CD4B8;\n    }\n\n    c = *val;\n    if (strchr(\"$@*\", c) == NULL) {\n        parser = bb_common_bufsiz1;\n        bb_error_msg(\"bad line %u\", parser);\n        goto next_rule;\n    }\n\n    s = xstrdup(val);\n\n    loc_CD4BC:\n    // Cleanup and return from function\n    clean_up_cur_rule();\n    return;\n\n    next_rule:\n    // Handle the next rule\n    // This label is used for jumping to the next iteration of a loop or similar structure\n    // The actual implementation would depend on the surrounding code, which is not provided here\n    // For the purpose of this decompilation, we will treat it as a return to indicate the end of processing\n    return;\n\n    loc_CD4B8:\n    // This label is used for a specific check and jump operation\n    // Since there is no operation between loc_CD4B8 and loc_CD4BC, we can ignore this label\n}\n```"
    },
    {
        "func_name": "select_lease_time",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0007511C | 00 48 2D E9 | PUSH    {R11,LR}\n0x00075120 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00075124 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x00075128 | 10 00 0B E5 | STR     R0, [R11,#packet]\n0x0007512C | 98 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00075130 | 20 30 93 E5 | LDR     R3, [R3,#(unk_18F9F8 - 0x18F9D8)]\n0x00075134 | 0C 30 0B E5 | STR     R3, [R11,#lease_time_sec]\n0x00075138 | 33 10 A0 E3 | MOV     R1, #0x33 ; '3'; code\n0x0007513C | 10 00 1B E5 | LDR     R0, [R11,#packet]; packet\n0x00075140 | 7D 13 00 EB | BL      udhcp_get_option\n0x00075144 | 08 00 0B E5 | STR     R0, [R11,#lease_time_opt]\n0x00075148 | 08 30 1B E5 | LDR     R3, [R11,#lease_time_opt]\n0x0007514C | 00 00 53 E3 | CMP     R3, #0\n0x00075150 | 19 00 00 0A | BEQ     loc_751BC\n0x00075154 | 0C 30 4B E2 | SUB     R3, R11, #-lease_time_sec\n0x00075158 | 04 20 A0 E3 | MOV     R2, #4; n\n0x0007515C | 08 10 1B E5 | LDR     R1, [R11,#lease_time_opt]; src\n0x00075160 | 03 00 A0 E1 | MOV     R0, R3; dest\n0x00075164 | 6C 7F FE EB | BL      memcpy\n0x00075168 | 0C 30 1B E5 | LDR     R3, [R11,#lease_time_sec]\n0x0007516C | 03 00 A0 E1 | MOV     R0, R3; netlong\n0x00075170 | E6 80 FE EB | BL      ntohl\n0x00075174 | 00 30 A0 E1 | MOV     R3, R0\n0x00075178 | 0C 30 0B E5 | STR     R3, [R11,#lease_time_sec]\n0x0007517C | 48 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00075180 | 20 20 93 E5 | LDR     R2, [R3,#(unk_18F9F8 - 0x18F9D8)]\n0x00075184 | 0C 30 1B E5 | LDR     R3, [R11,#lease_time_sec]\n0x00075188 | 03 00 52 E1 | CMP     R2, R3\n0x0007518C | 02 00 00 2A | BCS     loc_7519C\n0x00075190 | 34 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00075194 | 20 30 93 E5 | LDR     R3, [R3,#(unk_18F9F8 - 0x18F9D8)]\n0x00075198 | 0C 30 0B E5 | STR     R3, [R11,#lease_time_sec]\n0x0007519C | 28 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000751A0 | 24 20 93 E5 | LDR     R2, [R3,#(unk_18F9FC - 0x18F9D8)]\n0x000751A4 | 0C 30 1B E5 | LDR     R3, [R11,#lease_time_sec]\n0x000751A8 | 03 00 52 E1 | CMP     R2, R3\n0x000751AC | 02 00 00 9A | BLS     loc_751BC\n0x000751B0 | 14 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000751B4 | 24 30 93 E5 | LDR     R3, [R3,#(unk_18F9FC - 0x18F9D8)]\n0x000751B8 | 0C 30 0B E5 | STR     R3, [R11,#lease_time_sec]\n0x000751BC | 0C 30 1B E5 | LDR     R3, [R11,#lease_time_sec]\n0x000751C0 | 03 00 A0 E1 | MOV     R0, R3\n0x000751C4 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000751C8 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdint.h>\n#include <string.h>\n\nuint32_t bb_common_bufsiz1;\nuint32_t unk_18F9F8;\nuint32_t unk_18F9FC;\n\nuint32_t udhcp_get_option(uint32_t packet, uint8_t code);\nuint32_t ntohl(uint32_t netlong);\n\nuint32_t function(uint32_t packet) {\n    uint32_t lease_time_sec = bb_common_bufsiz1;\n    uint32_t lease_time_opt = udhcp_get_option(packet, 0x33);\n\n    if (lease_time_opt != 0) {\n        memcpy(&lease_time_sec, &lease_time_opt, 4);\n        lease_time_sec = ntohl(lease_time_sec);\n    }\n\n    if (lease_time_sec > bb_common_bufsiz1) {\n        lease_time_sec = bb_common_bufsiz1;\n    }\n\n    if (lease_time_sec < unk_18F9FC) {\n        lease_time_sec = unk_18F9FC;\n    }\n\n    return lease_time_sec;\n}\n```"
    },
    {
        "func_name": "reopen_config_file",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0004CD24 | 30 48 2D E9 | PUSH    {R4,R5,R11,LR}\n0x0004CD28 | 0C B0 8D E2 | ADD     R11, SP, #0xC\n0x0004CD2C | 78 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CD30 | 3C 30 93 E5 | LDR     R3, [R3,#(dst - 0x18F9D8)]\n0x0004CD34 | 03 00 A0 E1 | MOV     R0, R3; ptr\n0x0004CD38 | 5C 20 FF EB | BL      free\n0x0004CD3C | 68 40 9F E5 | LDR     R4, =bb_common_bufsiz1\n0x0004CD40 | 68 00 9F E5 | LDR     R0, =asc_1689E8; \"*\"\n0x0004CD44 | 88 33 FF EB | BL      xstrdup\n0x0004CD48 | 00 30 A0 E1 | MOV     R3, R0\n0x0004CD4C | 3C 30 84 E5 | STR     R3, [R4,#(dst - 0x18F9D8)]\n0x0004CD50 | 54 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CD54 | 38 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_ospeed - 0x18F9D8)]\n0x0004CD58 | 00 00 53 E3 | CMP     R3, #0\n0x0004CD5C | 03 00 00 0A | BEQ     loc_4CD70\n0x0004CD60 | 44 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CD64 | 38 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_ospeed - 0x18F9D8)]\n0x0004CD68 | 03 00 A0 E1 | MOV     R0, R3; parser\n0x0004CD6C | 85 F9 03 EB | BL      config_close\n0x0004CD70 | 34 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CD74 | 34 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_ispeed - 0x18F9D8)]\n0x0004CD78 | 2C 40 9F E5 | LDR     R4, =bb_common_bufsiz1\n0x0004CD7C | 03 00 A0 E1 | MOV     R0, R3; filename\n0x0004CD80 | 74 F9 03 EB | BL      config_open\n0x0004CD84 | 00 30 A0 E1 | MOV     R3, R0\n0x0004CD88 | 38 30 84 E5 | STR     R3, [R4,#(bb_common_bufsiz1.c_ospeed - 0x18F9D8)]\n0x0004CD8C | 18 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CD90 | 38 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_ospeed - 0x18F9D8)]\n0x0004CD94 | 00 00 53 E3 | CMP     R3, #0\n0x0004CD98 | 01 30 A0 13 | MOVNE   R3, #1\n0x0004CD9C | 00 30 A0 03 | MOVEQ   R3, #0\n0x0004CDA0 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x0004CDA4 | 03 00 A0 E1 | MOV     R0, R3\n0x0004CDA8 | 30 88 BD E8 | POP     {R4,R5,R11,PC}",
        "output": "```c\nvoid function() {\n    char **bb_common_bufsiz1;\n    char *ptr;\n    char *parser;\n    char *filename;\n    int result;\n\n    ptr = *bb_common_bufsiz1;\n    free(ptr);\n\n    *bb_common_bufsiz1 = xstrdup(\"*\");\n\n    parser = bb_common_bufsiz1[1];\n    if (parser != NULL) {\n        config_close(parser);\n    }\n\n    filename = bb_common_bufsiz1[2];\n    bb_common_bufsiz1[1] = config_open(filename);\n\n    result = bb_common_bufsiz1[1] != NULL ? 1 : 0;\n}\n```"
    },
    {
        "func_name": "add",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000281B0 | 30 48 2D E9 | PUSH    {R4,R5,R11,LR}\n0x000281B4 | 0C B0 8D E2 | ADD     R11, SP, #0xC\n0x000281B8 | E5 FF FF EB | BL      pop\n0x000281BC | 00 40 A0 E1 | MOV     R4, R0\n0x000281C0 | 01 50 A0 E1 | MOV     R5, R1\n0x000281C4 | E2 FF FF EB | BL      pop\n0x000281C8 | 00 20 A0 E1 | MOV     R2, R0\n0x000281CC | 01 30 A0 E1 | MOV     R3, R1\n0x000281D0 | 04 00 A0 E1 | MOV     R0, R4\n0x000281D4 | 05 10 A0 E1 | MOV     R1, R5\n0x000281D8 | 1E BC 04 EB | BL      __aeabi_dadd\n0x000281DC | 00 30 A0 E1 | MOV     R3, R0\n0x000281E0 | 01 40 A0 E1 | MOV     R4, R1\n0x000281E4 | 03 00 A0 E1 | MOV     R0, R3; a\n0x000281E8 | 04 10 A0 E1 | MOV     R1, R4; a\n0x000281EC | BB FF FF EB | BL      push\n0x000281F0 | 00 00 A0 E1 | NOP\n0x000281F4 | 30 88 BD E8 | POP     {R4,R5,R11,PC}",
        "output": "```c\ndouble pop(); // Forward declaration for the function 'pop' which is called by BL instruction.\nvoid push(double); // Forward declaration for the function 'push' which is called by BL instruction.\n\ndouble __aeabi_dadd(double a, double b); // Forward declaration for the function '__aeabi_dadd' which performs double precision floating point addition.\n\ndouble function() {\n    double a, b, c, d, result;\n    a = pop();\n    b = pop();\n    result = __aeabi_dadd(a, b);\n    push(result);\n    return result;\n}\n```"
    },
    {
        "func_name": "fopen_or_warn_stdin",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00154CC0 | 00 48 2D E9 | PUSH    {R11,LR}\n0x00154CC4 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00154CC8 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x00154CCC | 10 00 0B E5 | STR     R0, [R11,#filename]\n0x00154CD0 | 58 30 9F E5 | LDR     R3, =stdin__GLIBC_2.4\n0x00154CD4 | 00 30 93 E5 | LDR     R3, [R3]\n0x00154CD8 | 08 30 0B E5 | STR     R3, [R11,#fp]\n0x00154CDC | 10 30 1B E5 | LDR     R3, [R11,#filename]\n0x00154CE0 | 4C 20 9F E5 | LDR     R2, =bb_msg_standard_input; \"standard input\"\n0x00154CE4 | 02 00 53 E1 | CMP     R3, R2\n0x00154CE8 | 0C 00 00 0A | BEQ     loc_154D20\n0x00154CEC | 10 30 1B E5 | LDR     R3, [R11,#filename]\n0x00154CF0 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x00154CF4 | 2D 00 53 E3 | CMP     R3, #0x2D ; '-'\n0x00154CF8 | 04 00 00 1A | BNE     loc_154D10\n0x00154CFC | 10 30 1B E5 | LDR     R3, [R11,#filename]\n0x00154D00 | 01 30 83 E2 | ADD     R3, R3, #1\n0x00154D04 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x00154D08 | 00 00 53 E3 | CMP     R3, #0\n0x00154D0C | 03 00 00 0A | BEQ     loc_154D20\n0x00154D10 | 20 10 9F E5 | LDR     R1, =aR_24; \"r\"\n0x00154D14 | 10 00 1B E5 | LDR     R0, [R11,#filename]; path\n0x00154D18 | 38 10 FB EB | BL      fopen_or_warn\n0x00154D1C | 08 00 0B E5 | STR     R0, [R11,#fp]\n0x00154D20 | 08 30 1B E5 | LDR     R3, [R11,#fp]\n0x00154D24 | 03 00 A0 E1 | MOV     R0, R3\n0x00154D28 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00154D2C | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdio.h>\n\nFILE *function(const char *filename) {\n    FILE *fp = stdin;\n    if (filename != \"standard input\") {\n        if (filename[0] == '-' && filename[1] == '\\0') {\n            // filename is \"-\", use stdin\n        } else {\n            fp = fopen_or_warn(filename, \"r\");\n        }\n    }\n    return fp;\n}\n```"
    },
    {
        "func_name": "send_ACK",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0007546C | 00 48 2D E9 | PUSH    {R11,LR}\n0x00075470 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00075474 | 29 DE 4D E2 | SUB     SP, SP, #0x290\n0x00075478 | 88 02 0B E5 | STR     R0, [R11,#oldpacket]\n0x0007547C | 8C 12 0B E5 | STR     R1, [R11,#yiaddr]\n0x00075480 | 0A 3D 4B E2 | SUB     R3, R11, #-packet\n0x00075484 | 05 20 A0 E3 | MOV     R2, #5; type\n0x00075488 | 88 12 1B E5 | LDR     R1, [R11,#oldpacket]; oldpacket\n0x0007548C | 03 00 A0 E1 | MOV     R0, R3; packet\n0x00075490 | 4F FE FF EB | BL      init_packet_0\n0x00075494 | 8C 32 1B E5 | LDR     R3, [R11,#yiaddr]\n0x00075498 | 70 32 0B E5 | STR     R3, [R11,#packet.yiaddr]\n0x0007549C | 88 02 1B E5 | LDR     R0, [R11,#oldpacket]; packet\n0x000754A0 | 1D FF FF EB | BL      select_lease_time\n0x000754A4 | 08 00 0B E5 | STR     R0, [R11,#lease_time_sec]\n0x000754A8 | 08 00 1B E5 | LDR     R0, [R11,#lease_time_sec]; hostlong\n0x000754AC | 43 81 FE EB | BL      htonl\n0x000754B0 | 00 20 A0 E1 | MOV     R2, R0; data\n0x000754B4 | 0A 3D 4B E2 | SUB     R3, R11, #-packet\n0x000754B8 | 33 10 A0 E3 | MOV     R1, #0x33 ; '3'; code\n0x000754BC | 03 00 A0 E1 | MOV     R0, R3; packet\n0x000754C0 | 6F 13 00 EB | BL      udhcp_add_simple_option\n0x000754C4 | 0A 3D 4B E2 | SUB     R3, R11, #-packet\n0x000754C8 | 03 00 A0 E1 | MOV     R0, R3; packet\n0x000754CC | CB FE FF EB | BL      add_server_options\n0x000754D0 | 8C 32 1B E5 | LDR     R3, [R11,#yiaddr]\n0x000754D4 | 84 32 0B E5 | STR     R3, [R11,#addr]\n0x000754D8 | 84 02 1B E5 | LDR     R0, [R11,#addr]; in\n0x000754DC | C1 7E FE EB | BL      inet_ntoa\n0x000754E0 | 00 30 A0 E1 | MOV     R3, R0\n0x000754E4 | 03 10 A0 E1 | MOV     R1, R3\n0x000754E8 | 70 00 9F E5 | LDR     R0, =aSendingAckToS; \"Sending ACK to %s\"\n0x000754EC | B2 3F 03 EB | BL      bb_info_msg\n0x000754F0 | 0A 3D 4B E2 | SUB     R3, R11, #-packet\n0x000754F4 | 00 10 A0 E3 | MOV     R1, #0; force_broadcast\n0x000754F8 | 03 00 A0 E1 | MOV     R0, R3; dhcp_pkt\n0x000754FC | 19 FE FF EB | BL      send_packet\n0x00075500 | 0C 10 A0 E3 | MOV     R1, #0xC; code\n0x00075504 | 88 02 1B E5 | LDR     R0, [R11,#oldpacket]; packet\n0x00075508 | 8B 12 00 EB | BL      udhcp_get_option\n0x0007550C | 0C 00 0B E5 | STR     R0, [R11,#p_host_name]\n0x00075510 | 70 12 1B E5 | LDR     R1, [R11,#packet.yiaddr]; yiaddr\n0x00075514 | 0C 30 1B E5 | LDR     R3, [R11,#p_host_name]\n0x00075518 | 00 00 53 E3 | CMP     R3, #0\n0x0007551C | 04 00 00 0A | BEQ     loc_75534\n0x00075520 | 0C 30 1B E5 | LDR     R3, [R11,#p_host_name]\n0x00075524 | 01 30 43 E2 | SUB     R3, R3, #1\n0x00075528 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0007552C | 03 20 A0 E1 | MOV     R2, R3\n0x00075530 | 00 00 00 EA | B       loc_75538\n0x00075534 | 00 20 A0 E3 | MOV     R2, #0\n0x00075538 | 0A 3D 4B E2 | SUB     R3, R11, #-packet\n0x0007553C | 1C 00 83 E2 | ADD     R0, R3, #0x1C; chaddr\n0x00075540 | 00 20 8D E5 | STR     R2, [SP,#0x294+hostname_len]; hostname_len\n0x00075544 | 0C 30 1B E5 | LDR     R3, [R11,#p_host_name]; hostname\n0x00075548 | 08 20 1B E5 | LDR     R2, [R11,#lease_time_sec]; leasetime\n0x0007554C | 40 0B 00 EB | BL      add_lease\n0x00075550 | 13 09 00 EB | BL      write_leases\n0x00075554 | 00 00 A0 E1 | NOP\n0x00075558 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0007555C | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(unsigned char *oldpacket, uint32_t yiaddr) {\n    struct packet_struct packet;\n    uint32_t lease_time_sec;\n    uint32_t addr;\n    char *p_host_name;\n    uint32_t hostname_len;\n\n    init_packet_0(&packet, oldpacket, 5);\n    packet.yiaddr = yiaddr;\n    lease_time_sec = select_lease_time(oldpacket);\n    lease_time_sec = htonl(lease_time_sec);\n    udhcp_add_simple_option(&packet, 0x33, &lease_time_sec);\n    add_server_options(&packet);\n    addr = yiaddr;\n    char *ip_str = inet_ntoa(addr);\n    bb_info_msg(\"Sending ACK to %s\", ip_str);\n    send_packet(&packet, 0);\n    p_host_name = udhcp_get_option(oldpacket, 0xC);\n    if (p_host_name) {\n        hostname_len = p_host_name[strlen(p_host_name) - 1];\n    } else {\n        hostname_len = 0;\n    }\n    add_lease(&packet.chaddr, yiaddr, lease_time_sec, p_host_name, hostname_len);\n    write_leases();\n}\n```"
    },
    {
        "func_name": "mkswap_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000D32C4 | 70 48 2D E9 | PUSH    {R4-R6,R11,LR}\n0x000D32C8 | 10 B0 8D E2 | ADD     R11, SP, #0x10\n0x000D32CC | 4C D0 4D E2 | SUB     SP, SP, #0x4C\n0x000D32D0 | 50 00 0B E5 | STR     R0, [R11,#argc]\n0x000D32D4 | 54 10 0B E5 | STR     R1, [R11,#argv]\n0x000D32D8 | DC 31 9F E5 | LDR     R3, =unk_175F64\n0x000D32DC | 2C 30 0B E5 | STR     R3, [R11,#label]\n0x000D32E0 | D8 31 9F E5 | LDR     R3, =opt_complementary\n0x000D32E4 | D8 21 9F E5 | LDR     R2, =unk_175F68\n0x000D32E8 | 00 20 83 E5 | STR     R2, [R3]\n0x000D32EC | 2C 30 4B E2 | SUB     R3, R11, #-label\n0x000D32F0 | 03 20 A0 E1 | MOV     R2, R3\n0x000D32F4 | CC 11 9F E5 | LDR     R1, =byte_175F6C; applet_opts\n0x000D32F8 | 54 00 1B E5 | LDR     R0, [R11,#argv]; argv\n0x000D32FC | 69 B7 01 EB | BL      getopt32\n0x000D3300 | C4 31 9F E5 | LDR     R3, =optind__GLIBC_2.4\n0x000D3304 | 00 30 93 E5 | LDR     R3, [R3]\n0x000D3308 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000D330C | 54 20 1B E5 | LDR     R2, [R11,#argv]\n0x000D3310 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000D3314 | 54 30 0B E5 | STR     R3, [R11,#argv]\n0x000D3318 | 54 30 1B E5 | LDR     R3, [R11,#argv]\n0x000D331C | 00 30 93 E5 | LDR     R3, [R3]\n0x000D3320 | 01 10 A0 E3 | MOV     R1, #1; flags\n0x000D3324 | 03 00 A0 E1 | MOV     R0, R3; pathname\n0x000D3328 | 87 1A FD EB | BL      xopen\n0x000D332C | 18 00 0B E5 | STR     R0, [R11,#fd]\n0x000D3330 | 54 30 1B E5 | LDR     R3, [R11,#argv]\n0x000D3334 | 04 30 83 E2 | ADD     R3, R3, #4\n0x000D3338 | 00 10 93 E5 | LDR     R1, [R3]; override\n0x000D333C | 01 30 A0 E3 | MOV     R3, #1; extend\n0x000D3340 | 01 2B A0 E3 | MOV     R2, #0x400; override_units\n0x000D3344 | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000D3348 | E3 B6 01 EB | BL      get_volume_size_in_bytes\n0x000D334C | 00 30 A0 E1 | MOV     R3, R0\n0x000D3350 | 01 40 A0 E1 | MOV     R4, R1\n0x000D3354 | 24 30 0B E5 | STR     R3, [R11,#len]\n0x000D3358 | 20 40 0B E5 | STR     R4, [R11,#len+4]\n0x000D335C | BC 08 FD EB | BL      getpagesize\n0x000D3360 | 00 30 A0 E1 | MOV     R3, R0\n0x000D3364 | 28 30 0B E5 | STR     R3, [R11,#pagesize]\n0x000D3368 | 28 30 1B E5 | LDR     R3, [R11,#pagesize]\n0x000D336C | 00 40 A0 E3 | MOV     R4, #0\n0x000D3370 | 24 20 4B E2 | SUB     R2, R11, #-len\n0x000D3374 | 06 00 92 E8 | LDM     R2, {R1,R2}\n0x000D3378 | 03 50 51 E0 | SUBS    R5, R1, R3\n0x000D337C | 04 60 C2 E0 | SBC     R6, R2, R4\n0x000D3380 | 24 50 0B E5 | STR     R5, [R11,#len]\n0x000D3384 | 20 60 0B E5 | STR     R6, [R11,#len+4]\n0x000D3388 | 24 30 4B E2 | SUB     R3, R11, #-len\n0x000D338C | 0C 00 93 E8 | LDM     R3, {R2,R3}\n0x000D3390 | 38 01 9F E5 | LDR     R0, =aSettingUpSwaps; \"Setting up swapspace version 1, size = \"...\n0x000D3394 | 8F 06 FD EB | BL      printf\n0x000D3398 | 01 2B A0 E3 | MOV     R2, #0x400; count\n0x000D339C | 30 11 9F E5 | LDR     R1, =bb_common_bufsiz1; buf\n0x000D33A0 | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000D33A4 | 10 1B FD EB | BL      xwrite\n0x000D33A8 | 24 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000D33AC | 01 20 A0 E3 | MOV     R2, #1\n0x000D33B0 | 00 20 83 E5 | STR     R2, [R3]\n0x000D33B4 | 24 10 4B E2 | SUB     R1, R11, #-len\n0x000D33B8 | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x000D33BC | 28 30 1B E5 | LDR     R3, [R11,#pagesize]\n0x000D33C0 | 00 40 A0 E3 | MOV     R4, #0\n0x000D33C4 | 03 20 A0 E1 | MOV     R2, R3\n0x000D33C8 | 04 30 A0 E1 | MOV     R3, R4\n0x000D33CC | D0 13 02 EB | BL      __aeabi_uldivmod\n0x000D33D0 | 00 30 A0 E1 | MOV     R3, R0\n0x000D33D4 | 01 40 A0 E1 | MOV     R4, R1\n0x000D33D8 | 03 10 A0 E1 | MOV     R1, R3\n0x000D33DC | 04 20 A0 E1 | MOV     R2, R4\n0x000D33E0 | EC 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000D33E4 | 01 20 A0 E1 | MOV     R2, R1\n0x000D33E8 | 04 20 83 E5 | STR     R2, [R3,#(unk_18F9DC - 0x18F9D8)]\n0x000D33EC | E4 30 9F E5 | LDR     R3, =byte_18F9E4\n0x000D33F0 | 03 00 A0 E1 | MOV     R0, R3; buf\n0x000D33F4 | 69 1D FD EB | BL      generate_uuid\n0x000D33F8 | D8 10 9F E5 | LDR     R1, =byte_18F9E4; cp\n0x000D33FC | 4C 30 4B E2 | SUB     R3, R11, #-uuid_string\n0x000D3400 | 10 20 A0 E3 | MOV     R2, #0x10; count\n0x000D3404 | 03 00 A0 E1 | MOV     R0, R3; p\n0x000D3408 | DF 17 FD EB | BL      bin2hex\n0x000D340C | 4C 10 4B E2 | SUB     R1, R11, #-uuid_string\n0x000D3410 | 08 10 81 E2 | ADD     R1, R1, #8\n0x000D3414 | 4C 00 4B E2 | SUB     R0, R11, #-uuid_string\n0x000D3418 | 0C 00 80 E2 | ADD     R0, R0, #0xC\n0x000D341C | 4C 30 4B E2 | SUB     R3, R11, #-uuid_string\n0x000D3420 | 10 30 83 E2 | ADD     R3, R3, #0x10\n0x000D3424 | 4C 20 4B E2 | SUB     R2, R11, #-uuid_string\n0x000D3428 | 14 20 82 E2 | ADD     R2, R2, #0x14\n0x000D342C | 4C C0 4B E2 | SUB     R12, R11, #-uuid_string\n0x000D3430 | 04 20 8D E5 | STR     R2, [SP,#0x5C+var_58]\n0x000D3434 | 00 30 8D E5 | STR     R3, [SP,#0x5C+whence]\n0x000D3438 | 00 30 A0 E1 | MOV     R3, R0\n0x000D343C | 01 20 A0 E1 | MOV     R2, R1\n0x000D3440 | 0C 10 A0 E1 | MOV     R1, R12\n0x000D3444 | 90 00 9F E5 | LDR     R0, =aUuid8s4s4s4s12; \"UUID=%.8s-%.4s-%.4s-%.4s-%.12s\\n\"\n0x000D3448 | 62 06 FD EB | BL      printf\n0x000D344C | 8C 00 9F E5 | LDR     R0, =(qword_18F9F0+4); dst\n0x000D3450 | 2C 30 1B E5 | LDR     R3, [R11,#label]\n0x000D3454 | 10 20 A0 E3 | MOV     R2, #0x10; size\n0x000D3458 | 03 10 A0 E1 | MOV     R1, R3; src\n0x000D345C | C0 F9 01 EB | BL      safe_strncpy\n0x000D3460 | 81 2F A0 E3 | MOV     R2, #0x204; count\n0x000D3464 | 68 10 9F E5 | LDR     R1, =bb_common_bufsiz1; buf\n0x000D3468 | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000D346C | DE 1A FD EB | BL      xwrite\n0x000D3470 | 28 30 1B E5 | LDR     R3, [R11,#pagesize]\n0x000D3474 | 0A 30 43 E2 | SUB     R3, R3, #0xA\n0x000D3478 | 00 40 A0 E3 | MOV     R4, #0\n0x000D347C | 00 20 A0 E3 | MOV     R2, #0\n0x000D3480 | 00 20 8D E5 | STR     R2, [SP,#0x5C+whence]; whence\n0x000D3484 | 03 20 A0 E1 | MOV     R2, R3; offset\n0x000D3488 | 04 30 A0 E1 | MOV     R3, R4; offset\n0x000D348C | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000D3490 | 0B 1B FD EB | BL      xlseek\n0x000D3494 | 0A 20 A0 E3 | MOV     R2, #0xA; count\n0x000D3498 | 44 10 9F E5 | LDR     R1, =SWAPSPACE2; buf\n0x000D349C | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000D34A0 | D1 1A FD EB | BL      xwrite\n0x000D34A4 | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000D34A8 | 1D 06 FD EB | BL      fsync\n0x000D34AC | 00 30 A0 E3 | MOV     R3, #0\n0x000D34B0 | 03 00 A0 E1 | MOV     R0, R3\n0x000D34B4 | 10 D0 4B E2 | SUB     SP, R11, #0x10\n0x000D34B8 | 70 88 BD E8 | POP     {R4-R6,R11,PC}",
        "output": "```c\nvoid function(int argc, char **argv) {\n    int fd;\n    char *pathname;\n    unsigned int pagesize;\n    unsigned long long len;\n    char *label = unk_175F64;\n    opt_complementary = unk_175F68;\n    applet_opts = byte_175F6C;\n    getopt32(argv, applet_opts);\n    argv += optind__GLIBC_2.4;\n    pathname = *argv;\n    fd = xopen(pathname, 1);\n    argv++;\n    int override = *argv;\n    int extend = 1;\n    unsigned int override_units = 0x400;\n    get_volume_size_in_bytes(fd, override, extend, override_units);\n    len = (unsigned long long)R0 | ((unsigned long long)R1 << 32);\n    pagesize = getpagesize();\n    len -= pagesize;\n    printf(\"Setting up swapspace version 1, size = %llu bytes\\n\", len);\n    xwrite(fd, bb_common_bufsiz1, 0x400);\n    bb_common_bufsiz1 = 1;\n    __aeabi_uldivmod(len, pagesize);\n    len = (unsigned long long)R0 | ((unsigned long long)R1 << 32);\n    bb_common_bufsiz1 = (unsigned int)len;\n    generate_uuid(byte_18F9E4);\n    char uuid_string[37];\n    bin2hex(byte_18F9E4, uuid_string, 16);\n    printf(\"UUID=%.8s-%.4s-%.4s-%.4s-%.12s\\n\", uuid_string, uuid_string + 8, uuid_string + 12, uuid_string + 16, uuid_string + 20);\n    safe_strncpy((qword_18F9F0 + 4), label, 16);\n    xwrite(fd, bb_common_bufsiz1, 0x204);\n    xlseek(fd, pagesize - 10, SEEK_SET);\n    xwrite(fd, SWAPSPACE2, 10);\n    fsync(fd);\n    close(fd);\n}\n```"
    },
    {
        "func_name": "isrv_close_fd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00066200 | 00 48 2D E9 | PUSH    {R11,LR}\n0x00066204 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00066208 | 08 D0 4D E2 | SUB     SP, SP, #8\n0x0006620C | 08 00 0B E5 | STR     R0, [R11,#state]\n0x00066210 | 0C 10 0B E5 | STR     R1, [R11,#fd]\n0x00066214 | 0C 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x00066218 | BD BE FE EB | BL      close\n0x0006621C | 0C 10 1B E5 | LDR     R1, [R11,#fd]; fd\n0x00066220 | 08 00 1B E5 | LDR     R0, [R11,#state]; state\n0x00066224 | 57 FF FF EB | BL      isrv_dont_want_rd\n0x00066228 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x0006622C | 20 30 93 E5 | LDR     R3, [R3,#0x20]\n0x00066230 | 00 00 53 E3 | CMP     R3, #0\n0x00066234 | 02 00 00 0A | BEQ     loc_66244\n0x00066238 | 0C 10 1B E5 | LDR     R1, [R11,#fd]; fd\n0x0006623C | 08 00 1B E5 | LDR     R0, [R11,#state]; state\n0x00066240 | 73 FF FF EB | BL      isrv_dont_want_wr\n0x00066244 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x00066248 | 00 20 93 E5 | LDR     R2, [R3]\n0x0006624C | 0C 30 1B E5 | LDR     R3, [R11,#fd]\n0x00066250 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x00066254 | 03 30 82 E0 | ADD     R3, R2, R3\n0x00066258 | 00 20 E0 E3 | MOV     R2, #0xFFFFFFFF\n0x0006625C | B0 20 C3 E1 | STRH    R2, [R3]\n0x00066260 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x00066264 | 18 30 93 E5 | LDR     R3, [R3,#0x18]\n0x00066268 | 01 30 43 E2 | SUB     R3, R3, #1\n0x0006626C | 0C 20 1B E5 | LDR     R2, [R11,#fd]\n0x00066270 | 03 00 52 E1 | CMP     R2, R3\n0x00066274 | 1C 00 00 1A | BNE     loc_662EC\n0x00066278 | 0C 30 1B E5 | LDR     R3, [R11,#fd]\n0x0006627C | 01 30 43 E2 | SUB     R3, R3, #1\n0x00066280 | 0C 30 0B E5 | STR     R3, [R11,#fd]\n0x00066284 | 0C 30 1B E5 | LDR     R3, [R11,#fd]\n0x00066288 | 00 00 53 E3 | CMP     R3, #0\n0x0006628C | 07 00 00 BA | BLT     loc_662B0\n0x00066290 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x00066294 | 00 20 93 E5 | LDR     R2, [R3]\n0x00066298 | 0C 30 1B E5 | LDR     R3, [R11,#fd]\n0x0006629C | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000662A0 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000662A4 | F0 30 D3 E1 | LDRSH   R3, [R3]\n0x000662A8 | 01 00 73 E3 | CMN     R3, #1\n0x000662AC | F1 FF FF 0A | BEQ     loc_66278\n0x000662B0 | 0C 30 1B E5 | LDR     R3, [R11,#fd]\n0x000662B4 | 01 20 83 E2 | ADD     R2, R3, #1\n0x000662B8 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x000662BC | 18 20 83 E5 | STR     R2, [R3,#0x18]\n0x000662C0 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x000662C4 | 00 20 93 E5 | LDR     R2, [R3]\n0x000662C8 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x000662CC | 18 30 93 E5 | LDR     R3, [R3,#0x18]\n0x000662D0 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000662D4 | 03 10 A0 E1 | MOV     R1, R3; size\n0x000662D8 | 02 00 A0 E1 | MOV     R0, R2; ptr\n0x000662DC | FC CD FE EB | BL      xrealloc\n0x000662E0 | 00 20 A0 E1 | MOV     R2, R0\n0x000662E4 | 08 30 1B E5 | LDR     R3, [R11,#state]\n0x000662E8 | 00 20 83 E5 | STR     R2, [R3]\n0x000662EC | 00 00 A0 E1 | NOP\n0x000662F0 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000662F4 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(int *state, int fd) {\n    close(fd);\n    isrv_dont_want_rd(state, fd);\n\n    if (state[8] != 0) {\n        isrv_dont_want_wr(state, fd);\n    }\n\n    state[fd * 2] = -1;\n\n    if (fd == state[6] - 1) {\n        do {\n            fd--;\n            if (fd < 0) {\n                state[6] = fd + 1;\n                int size = (state[6] * 2) * sizeof(*state);\n                state = xrealloc(state, size);\n                break;\n            }\n        } while (state[fd * 2] == -1);\n    }\n}\n```"
    },
    {
        "func_name": "strcpy_and_process_escape_sequences",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0014C4D8 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0014C4DC | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0014C4E0 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x0014C4E4 | 10 00 0B E5 | STR     R0, [R11,#dst]\n0x0014C4E8 | 14 10 0B E5 | STR     R1, [R11,#src]\n0x0014C4EC | 14 30 1B E5 | LDR     R3, [R11,#src]\n0x0014C4F0 | 01 20 83 E2 | ADD     R2, R3, #1\n0x0014C4F4 | 14 20 0B E5 | STR     R2, [R11,#src]\n0x0014C4F8 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x0014C4FC | 05 30 4B E5 | STRB    R3, [R11,#c1]\n0x0014C500 | 05 30 5B E5 | LDRB    R3, [R11,#c1]\n0x0014C504 | 06 30 4B E5 | STRB    R3, [R11,#c]\n0x0014C508 | 05 30 5B E5 | LDRB    R3, [R11,#c1]\n0x0014C50C | 5C 00 53 E3 | CMP     R3, #0x5C ; '\\'\n0x0014C510 | 04 00 00 1A | BNE     loc_14C528\n0x0014C514 | 14 30 4B E2 | SUB     R3, R11, #-src\n0x0014C518 | 03 00 A0 E1 | MOV     R0, R3; ptr\n0x0014C51C | 7D FF FF EB | BL      bb_process_escape_sequence\n0x0014C520 | 00 30 A0 E1 | MOV     R3, R0\n0x0014C524 | 05 30 4B E5 | STRB    R3, [R11,#c1]\n0x0014C528 | 10 30 1B E5 | LDR     R3, [R11,#dst]\n0x0014C52C | 05 20 5B E5 | LDRB    R2, [R11,#c1]\n0x0014C530 | 00 20 C3 E5 | STRB    R2, [R3]\n0x0014C534 | 06 30 5B E5 | LDRB    R3, [R11,#c]\n0x0014C538 | 00 00 53 E3 | CMP     R3, #0\n0x0014C53C | 01 00 00 1A | BNE     loc_14C548\n0x0014C540 | 10 30 1B E5 | LDR     R3, [R11,#dst]\n0x0014C544 | 03 00 00 EA | B       loc_14C558\n0x0014C548 | 10 30 1B E5 | LDR     R3, [R11,#dst]\n0x0014C54C | 01 30 83 E2 | ADD     R3, R3, #1\n0x0014C550 | 10 30 0B E5 | STR     R3, [R11,#dst]\n0x0014C554 | E4 FF FF EA | B       loc_14C4EC\n0x0014C558 | 03 00 A0 E1 | MOV     R0, R3\n0x0014C55C | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0014C560 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid process_string(char *dst, const char *src) {\n    char c, c1;\n    do {\n        c1 = *src++;\n        if (c1 == '\\\\') {\n            c1 = bb_process_escape_sequence(&src);\n        }\n        *dst++ = c1;\n        c = c1;\n    } while (c != '\\0');\n}\n```"
    },
    {
        "func_name": "setfont_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000FE550 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000FE554 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000FE558 | 40 D0 4D E2 | SUB     SP, SP, #0x40\n0x000FE55C | 40 00 0B E5 | STR     R0, [R11,#argc]\n0x000FE560 | 44 10 0B E5 | STR     R1, [R11,#argv]\n0x000FE564 | C0 32 9F E5 | LDR     R3, =aDevTty_7; \"/dev/tty\"\n0x000FE568 | 34 30 0B E5 | STR     R3, [R11,#tty_name]\n0x000FE56C | BC 32 9F E5 | LDR     R3, =opt_complementary\n0x000FE570 | BC 22 9F E5 | LDR     R2, =a1_22; \"=1\"\n0x000FE574 | 00 20 83 E5 | STR     R2, [R3]\n0x000FE578 | 34 30 4B E2 | SUB     R3, R11, #-tty_name\n0x000FE57C | 30 20 4B E2 | SUB     R2, R11, #-mapfilename\n0x000FE580 | B0 12 9F E5 | LDR     R1, =aMC; \"m:C:\"\n0x000FE584 | 44 00 1B E5 | LDR     R0, [R11,#argv]; argv\n0x000FE588 | C6 0A 01 EB | BL      getopt32\n0x000FE58C | 14 00 0B E5 | STR     R0, [R11,#opts]\n0x000FE590 | A4 32 9F E5 | LDR     R3, =optind__GLIBC_2.4\n0x000FE594 | 00 30 93 E5 | LDR     R3, [R3]\n0x000FE598 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000FE59C | 44 20 1B E5 | LDR     R2, [R11,#argv]\n0x000FE5A0 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000FE5A4 | 44 30 0B E5 | STR     R3, [R11,#argv]\n0x000FE5A8 | 34 30 1B E5 | LDR     R3, [R11,#tty_name]\n0x000FE5AC | 03 00 A0 E1 | MOV     R0, R3; pathname\n0x000FE5B0 | F3 6D FC EB | BL      xopen_nonblocking\n0x000FE5B4 | 18 00 0B E5 | STR     R0, [R11,#fd]\n0x000FE5B8 | 02 39 A0 E3 | MOV     R3, #0x8000\n0x000FE5BC | 2C 30 0B E5 | STR     R3, [R11,#len]\n0x000FE5C0 | 44 30 1B E5 | LDR     R3, [R11,#argv]\n0x000FE5C4 | 00 30 93 E5 | LDR     R3, [R3]\n0x000FE5C8 | 2C 20 4B E2 | SUB     R2, R11, #-len\n0x000FE5CC | 02 10 A0 E1 | MOV     R1, R2; maxsz_p\n0x000FE5D0 | 03 00 A0 E1 | MOV     R0, R3; fname\n0x000FE5D4 | B5 FB FF EB | BL      xmalloc_open_zipped_read_close\n0x000FE5D8 | 00 30 A0 E1 | MOV     R3, R0\n0x000FE5DC | 1C 30 0B E5 | STR     R3, [R11,#buffer]\n0x000FE5E0 | 1C 30 1B E5 | LDR     R3, [R11,#buffer]\n0x000FE5E4 | 00 00 53 E3 | CMP     R3, #0\n0x000FE5E8 | 03 00 00 1A | BNE     loc_FE5FC\n0x000FE5EC | 44 30 1B E5 | LDR     R3, [R11,#argv]\n0x000FE5F0 | 00 30 93 E5 | LDR     R3, [R3]\n0x000FE5F4 | 03 00 A0 E1 | MOV     R0, R3; s\n0x000FE5F8 | E3 68 FC EB | BL      bb_simple_perror_msg_and_die\n0x000FE5FC | 2C 30 1B E5 | LDR     R3, [R11,#len]\n0x000FE600 | 03 20 A0 E1 | MOV     R2, R3; len\n0x000FE604 | 1C 10 1B E5 | LDR     R1, [R11,#buffer]; buffer\n0x000FE608 | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000FE60C | BA FE FF EB | BL      do_load\n0x000FE610 | 14 30 1B E5 | LDR     R3, [R11,#opts]\n0x000FE614 | 01 30 03 E2 | AND     R3, R3, #1\n0x000FE618 | 00 00 53 E3 | CMP     R3, #0\n0x000FE61C | 7E 00 00 0A | BEQ     loc_FE81C\n0x000FE620 | 18 32 9F E5 | LDR     R3, =0x4B41\n0x000FE624 | 08 30 0B E5 | STR     R3, [R11,#mode]\n0x000FE628 | 30 30 1B E5 | LDR     R3, [R11,#mapfilename]\n0x000FE62C | 2C 20 4B E2 | SUB     R2, R11, #-len\n0x000FE630 | 02 10 A0 E1 | MOV     R1, R2; maxsz_p\n0x000FE634 | 03 00 A0 E1 | MOV     R0, R3; fname\n0x000FE638 | 9C FB FF EB | BL      xmalloc_open_zipped_read_close\n0x000FE63C | 00 30 A0 E1 | MOV     R3, R0\n0x000FE640 | 0C 30 0B E5 | STR     R3, [R11,#map]\n0x000FE644 | 0C 30 1B E5 | LDR     R3, [R11,#map]\n0x000FE648 | 00 00 53 E3 | CMP     R3, #0\n0x000FE64C | 02 00 00 1A | BNE     loc_FE65C\n0x000FE650 | 30 30 1B E5 | LDR     R3, [R11,#mapfilename]\n0x000FE654 | 03 00 A0 E1 | MOV     R0, R3; s\n0x000FE658 | CB 68 FC EB | BL      bb_simple_perror_msg_and_die\n0x000FE65C | 2C 30 1B E5 | LDR     R3, [R11,#len]\n0x000FE660 | 01 0C 53 E3 | CMP     R3, #0x100\n0x000FE664 | 02 00 00 0A | BEQ     loc_FE674\n0x000FE668 | 2C 30 1B E5 | LDR     R3, [R11,#len]\n0x000FE66C | 02 0C 53 E3 | CMP     R3, #0x200\n0x000FE670 | 05 00 00 1A | BNE     loc_FE68C\n0x000FE674 | 2C 30 1B E5 | LDR     R3, [R11,#len]\n0x000FE678 | 02 0C 53 E3 | CMP     R3, #0x200\n0x000FE67C | 61 00 00 1A | BNE     loc_FE808\n0x000FE680 | BC 31 9F E5 | LDR     R3, =0x4B6A\n0x000FE684 | 08 30 0B E5 | STR     R3, [R11,#mode]\n0x000FE688 | 5E 00 00 EA | B       loc_FE808\n0x000FE68C | 02 0C A0 E3 | MOV     R0, #0x200; size\n0x000FE690 | FA 6C FC EB | BL      xmalloc\n0x000FE694 | 00 30 A0 E1 | MOV     R3, R0\n0x000FE698 | 0C 30 0B E5 | STR     R3, [R11,#map]\n0x000FE69C | 00 30 A0 E3 | MOV     R3, #0\n0x000FE6A0 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x000FE6A4 | 0D 00 00 EA | B       loc_FE6E0\n0x000FE6A8 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE6AC | 03 38 A0 E1 | MOV     R3, R3,LSL#16\n0x000FE6B0 | 23 28 A0 E1 | MOV     R2, R3,LSR#16\n0x000FE6B4 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE6B8 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000FE6BC | 0C 10 1B E5 | LDR     R1, [R11,#map]\n0x000FE6C0 | 03 30 81 E0 | ADD     R3, R1, R3\n0x000FE6C4 | 01 2A 42 E2 | SUB     R2, R2, #0x1000\n0x000FE6C8 | 02 28 A0 E1 | MOV     R2, R2,LSL#16\n0x000FE6CC | 22 28 A0 E1 | MOV     R2, R2,LSR#16\n0x000FE6D0 | B0 20 C3 E1 | STRH    R2, [R3]\n0x000FE6D4 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE6D8 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000FE6DC | 10 30 0B E5 | STR     R3, [R11,#i]\n0x000FE6E0 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE6E4 | FF 00 53 E3 | CMP     R3, #0xFF\n0x000FE6E8 | EE FF FF DA | BLE     loc_FE6A8\n0x000FE6EC | 30 30 1B E5 | LDR     R3, [R11,#mapfilename]\n0x000FE6F0 | 03 00 A0 E1 | MOV     R0, R3; filename\n0x000FE6F4 | 17 33 01 EB | BL      config_open\n0x000FE6F8 | 20 00 0B E5 | STR     R0, [R11,#parser]\n0x000FE6FC | 22 00 00 EA | B       loc_FE78C\n0x000FE700 | 3C 30 1B E5 | LDR     R3, [R11,#token]\n0x000FE704 | 03 00 A0 E1 | MOV     R0, R3; s\n0x000FE708 | 56 FF FF EB | BL      ctoi\n0x000FE70C | 24 00 0B E5 | STR     R0, [R11,#a]\n0x000FE710 | 38 30 1B E5 | LDR     R3, [R11,#token+4]\n0x000FE714 | 03 00 A0 E1 | MOV     R0, R3; s\n0x000FE718 | 52 FF FF EB | BL      ctoi\n0x000FE71C | 28 00 0B E5 | STR     R0, [R11,#b]\n0x000FE720 | 24 30 1B E5 | LDR     R3, [R11,#a]\n0x000FE724 | 00 00 53 E3 | CMP     R3, #0\n0x000FE728 | 08 00 00 BA | BLT     loc_FE750\n0x000FE72C | 24 30 1B E5 | LDR     R3, [R11,#a]\n0x000FE730 | FF 00 53 E3 | CMP     R3, #0xFF\n0x000FE734 | 05 00 00 CA | BGT     loc_FE750\n0x000FE738 | 28 30 1B E5 | LDR     R3, [R11,#b]\n0x000FE73C | 00 00 53 E3 | CMP     R3, #0\n0x000FE740 | 02 00 00 BA | BLT     loc_FE750\n0x000FE744 | 28 30 1B E5 | LDR     R3, [R11,#b]\n0x000FE748 | 01 08 53 E3 | CMP     R3, #0x10000\n0x000FE74C | 01 00 00 BA | BLT     loc_FE758\n0x000FE750 | F0 00 9F E5 | LDR     R0, =aMapFormat; \"map format\"\n0x000FE754 | 8F 69 FC EB | BL      bb_error_msg_and_die\n0x000FE758 | 24 30 1B E5 | LDR     R3, [R11,#a]\n0x000FE75C | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000FE760 | 0C 20 1B E5 | LDR     R2, [R11,#map]\n0x000FE764 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000FE768 | 28 20 1B E5 | LDR     R2, [R11,#b]\n0x000FE76C | 02 28 A0 E1 | MOV     R2, R2,LSL#16\n0x000FE770 | 22 28 A0 E1 | MOV     R2, R2,LSR#16\n0x000FE774 | B0 20 C3 E1 | STRH    R2, [R3]\n0x000FE778 | 28 30 1B E5 | LDR     R3, [R11,#b]\n0x000FE77C | FF 00 53 E3 | CMP     R3, #0xFF\n0x000FE780 | 01 00 00 DA | BLE     loc_FE78C\n0x000FE784 | B8 30 9F E5 | LDR     R3, =0x4B6A\n0x000FE788 | 08 30 0B E5 | STR     R3, [R11,#mode]\n0x000FE78C | 3C 10 4B E2 | SUB     R1, R11, #-token; tokens\n0x000FE790 | B4 30 9F E5 | LDR     R3, =asc_1780FC; \"# \\t\"\n0x000FE794 | B4 20 9F E5 | LDR     R2, =0x570202; flags\n0x000FE798 | 20 00 1B E5 | LDR     R0, [R11,#parser]; parser\n0x000FE79C | 83 33 01 EB | BL      config_read\n0x000FE7A0 | 00 30 A0 E1 | MOV     R3, R0\n0x000FE7A4 | 00 00 53 E3 | CMP     R3, #0\n0x000FE7A8 | D4 FF FF 1A | BNE     loc_FE700\n0x000FE7AC | 08 30 1B E5 | LDR     R3, [R11,#mode]\n0x000FE7B0 | 8C 20 9F E5 | LDR     R2, =0x4B6A\n0x000FE7B4 | 02 00 53 E1 | CMP     R3, R2\n0x000FE7B8 | 12 00 00 0A | BEQ     loc_FE808\n0x000FE7BC | 00 30 A0 E3 | MOV     R3, #0\n0x000FE7C0 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x000FE7C4 | 0C 00 00 EA | B       loc_FE7FC\n0x000FE7C8 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE7CC | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000FE7D0 | 0C 20 1B E5 | LDR     R2, [R11,#map]\n0x000FE7D4 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000FE7D8 | B0 20 D3 E1 | LDRH    R2, [R3]\n0x000FE7DC | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE7E0 | 0C 10 1B E5 | LDR     R1, [R11,#map]\n0x000FE7E4 | 03 30 81 E0 | ADD     R3, R1, R3\n0x000FE7E8 | FF 20 02 E2 | AND     R2, R2, #0xFF\n0x000FE7EC | 00 20 C3 E5 | STRB    R2, [R3]\n0x000FE7F0 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE7F4 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000FE7F8 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x000FE7FC | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x000FE800 | FF 00 53 E3 | CMP     R3, #0xFF\n0x000FE804 | EF FF FF DA | BLE     loc_FE7C8\n0x000FE808 | 44 30 9F E5 | LDR     R3, =aMode_2; \"mode\"\n0x000FE80C | 0C 20 1B E5 | LDR     R2, [R11,#map]; argp\n0x000FE810 | 08 10 1B E5 | LDR     R1, [R11,#mode]; request\n0x000FE814 | 18 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000FE818 | 33 70 FC EB | BL      bb_xioctl\n0x000FE81C | 00 30 A0 E3 | MOV     R3, #0\n0x000FE820 | 03 00 A0 E1 | MOV     R0, R3\n0x000FE824 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000FE828 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdint.h>\n\nvoid function(int argc, char **argv) {\n    const char *tty_name = \"/dev/tty\";\n    const char *opt_complementary = \"=1\";\n    const char *aMC = \"m:C:\";\n    int opts;\n    char **new_argv;\n    int fd;\n    uint32_t len = 0x8000;\n    void *buffer;\n    uint32_t mode;\n    const char *mapfilename;\n    void *map;\n    int i;\n    const char *token;\n    int a, b;\n    void *parser;\n\n    opts = getopt32(argc, argv, aMC);\n    new_argv = argv + optind__GLIBC_2_4;\n    fd = xopen_nonblocking(tty_name);\n    buffer = xmalloc_open_zipped_read_close(*new_argv, &len);\n    if (!buffer) {\n        bb_simple_perror_msg_and_die(*new_argv);\n    }\n    do_load(fd, buffer, len);\n\n    if (opts & 1) {\n        mode = 0x4B41;\n        map = xmalloc_open_zipped_read_close(mapfilename, &len);\n        if (!map) {\n            bb_simple_perror_msg_and_die(mapfilename);\n        }\n        if (len == 0x100 || len == 0x200) {\n            if (len == 0x200) {\n                mode = 0x4B6A;\n            }\n        } else {\n            map = xmalloc(0x200);\n            for (i = 0; i <= 0xFF; i++) {\n                uint16_t *map_ptr = (uint16_t *)map + i;\n                *map_ptr = (uint16_t)(i - 0x1000);\n            }\n        }\n        config_open(mapfilename);\n        while ((token = config_read(parser, \"# \\t\", 0x570202))) {\n            a = ctoi(token);\n            b = ctoi(token + 4);\n            if (a < 0 || a > 0xFF || b < 0 || b >= 0x10000) {\n                bb_error_msg_and_die(\"map format\");\n            }\n            ((uint16_t *)map)[a] = (uint16_t)b;\n            if (b > 0xFF) {\n                mode = 0x4B6A;\n            }\n        }\n        if (mode != 0x4B6A) {\n            for (i = 0; i <= 0xFF; i++) {\n                uint8_t *map_byte_ptr = (uint8_t *)map + i;\n                *map_byte_ptr = ((uint16_t *)map)[i] & 0xFF;\n            }\n        }\n    }\n    bb_xioctl(fd, \"mode\", map, mode);\n}\n```"
    },
    {
        "func_name": "vfork_child",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000FEB38 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000FEB3C | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000FEB40 | 08 D0 4D E2 | SUB     SP, SP, #8\n0x000FEB44 | 08 00 0B E5 | STR     R0, [R11,#argv]\n0x000FEB48 | 51 5B FC EB | BL      vfork\n0x000FEB4C | 00 30 A0 E1 | MOV     R3, R0\n0x000FEB50 | 00 00 53 E3 | CMP     R3, #0\n0x000FEB54 | 06 00 00 1A | BNE     loc_FEB74\n0x000FEB58 | 90 5A FC EB | BL      setsid\n0x000FEB5C | 00 20 A0 E3 | MOV     R2, #0\n0x000FEB60 | 18 10 9F E5 | LDR     R1, =0x540E; request\n0x000FEB64 | 00 00 A0 E3 | MOV     R0, #0; fd\n0x000FEB68 | BD 59 FC EB | BL      ioctl\n0x000FEB6C | 08 00 1B E5 | LDR     R0, [R11,#argv]; argv\n0x000FEB70 | 98 04 01 EB | BL      BB_EXECVP_or_die\n0x000FEB74 | 00 00 A0 E1 | NOP\n0x000FEB78 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000FEB7C | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <unistd.h>\n#include <sys/ioctl.h>\n\nvoid function(char **argv) {\n    pid_t pid = vfork();\n    if (pid == 0) {\n        setsid();\n        ioctl(0, 0x540E, 0);\n        BB_EXECVP_or_die(argv);\n    }\n}\n```"
    },
    {
        "func_name": "recalculate_maxsock",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0004C9E8 | 70 48 2D E9 | PUSH    {R4-R6,R11,LR}\n0x0004C9EC | 10 B0 8D E2 | ADD     R11, SP, #0x10\n0x0004C9F0 | 0C D0 4D E2 | SUB     SP, SP, #0xC\n0x0004C9F4 | 00 30 A0 E3 | MOV     R3, #0\n0x0004C9F8 | 18 30 0B E5 | STR     R3, [R11,#fd]\n0x0004C9FC | C8 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CA00 | 00 00 A0 E3 | MOV     R0, #0\n0x0004CA04 | 20 00 83 E5 | STR     R0, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x0004CA08 | 17 00 00 EA | B       loc_4CA6C\n0x0004CA0C | BC C0 9F E5 | LDR     R12, =dword_18FAA0\n0x0004CA10 | 18 30 1B E5 | LDR     R3, [R11,#fd]\n0x0004CA14 | 1F 00 83 E2 | ADD     R0, R3, #0x1F\n0x0004CA18 | 00 00 53 E3 | CMP     R3, #0\n0x0004CA1C | 00 30 A0 B1 | MOVLT   R3, R0\n0x0004CA20 | 03 30 A0 A1 | MOVGE   R3, R3\n0x0004CA24 | C3 32 A0 E1 | MOV     R3, R3,ASR#5\n0x0004CA28 | 03 01 9C E7 | LDR     R0, [R12,R3,LSL#2]\n0x0004CA2C | 18 30 1B E5 | LDR     R3, [R11,#fd]\n0x0004CA30 | 00 C0 73 E2 | RSBS    R12, R3, #0\n0x0004CA34 | 1F 30 03 E2 | AND     R3, R3, #0x1F\n0x0004CA38 | 1F C0 0C E2 | AND     R12, R12, #0x1F\n0x0004CA3C | 00 30 6C 52 | RSBPL   R3, R12, #0\n0x0004CA40 | 01 C0 A0 E3 | MOV     R12, #1\n0x0004CA44 | 1C 33 A0 E1 | MOV     R3, R12,LSL R3\n0x0004CA48 | 00 30 03 E0 | AND     R3, R3, R0\n0x0004CA4C | 00 00 53 E3 | CMP     R3, #0\n0x0004CA50 | 02 00 00 0A | BEQ     loc_4CA60\n0x0004CA54 | 70 00 9F E5 | LDR     R0, =bb_common_bufsiz1\n0x0004CA58 | 18 30 1B E5 | LDR     R3, [R11,#fd]\n0x0004CA5C | 20 30 80 E5 | STR     R3, [R0,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x0004CA60 | 18 30 1B E5 | LDR     R3, [R11,#fd]\n0x0004CA64 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0004CA68 | 18 30 0B E5 | STR     R3, [R11,#fd]\n0x0004CA6C | 58 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CA70 | 24 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0x13 - 0x18F9D8)]\n0x0004CA74 | 18 00 1B E5 | LDR     R0, [R11,#fd]\n0x0004CA78 | 03 00 50 E1 | CMP     R0, R3\n0x0004CA7C | E2 FF FF DA | BLE     loc_4CA0C\n0x0004CA80 | 44 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CA84 | 40 00 9F E5 | LDR     R0, =bb_common_bufsiz1\n0x0004CA88 | 20 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x0004CA8C | 24 30 80 E5 | STR     R3, [R0,#(bb_common_bufsiz1.c_cc+0x13 - 0x18F9D8)]\n0x0004CA90 | 34 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CA94 | 20 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x0004CA98 | 03 50 A0 E1 | MOV     R5, R3\n0x0004CA9C | C5 6F A0 E1 | MOV     R6, R5,ASR#31\n0x0004CAA0 | 24 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004CAA4 | 18 00 93 E8 | LDM     R3, {R3,R4}\n0x0004CAA8 | 08 10 53 E2 | SUBS    R1, R3, #8\n0x0004CAAC | 00 20 C4 E2 | SBC     R2, R4, #0\n0x0004CAB0 | 02 00 56 E1 | CMP     R6, R2\n0x0004CAB4 | 01 00 55 01 | CMPEQ   R5, R1\n0x0004CAB8 | 00 00 00 9A | BLS     loc_4CAC0\n0x0004CABC | 29 FF FF EB | BL      bump_nofile\n0x0004CAC0 | 00 00 A0 E1 | NOP\n0x0004CAC4 | 10 D0 4B E2 | SUB     SP, R11, #0x10\n0x0004CAC8 | 70 88 BD E8 | POP     {R4-R6,R11,PC}",
        "output": "```c\nvoid function() {\n    static int bb_common_bufsiz1;\n    static int dword_18FAA0[32];\n    int fd = 0;\n\n    bb_common_bufsiz1.c_cc[15] = 0;\n\n    do {\n        int value = dword_18FAA0[fd >> 5];\n        int mask = 1 << (fd & 0x1F);\n        if (value & mask) {\n            bb_common_bufsiz1.c_cc[15] = fd;\n        }\n        fd++;\n    } while (fd <= bb_common_bufsiz1.c_cc[19]);\n\n    bb_common_bufsiz1.c_cc[19] = bb_common_bufsiz1.c_cc[15];\n\n    int r5 = bb_common_bufsiz1.c_cc[15];\n    int r6 = r5 >> 31;\n    int r1, r2;\n    asm(\"subs %0, %2, #8\" : \"=r\"(r1) : \"r\"(bb_common_bufsiz1), \"r\"(r5));\n    asm(\"sbc %0, %2, #0\" : \"=r\"(r2) : \"r\"(bb_common_bufsiz1 + 4), \"r\"(r6));\n\n    if (r6 > r2 || (r6 == r2 && r5 <= r1)) {\n        bump_nofile();\n    }\n}\n```"
    },
    {
        "func_name": "reset_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000FED34 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000FED38 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000FED3C | 08 D0 4D E2 | SUB     SP, SP, #8\n0x000FED40 | 08 00 0B E5 | STR     R0, [R11,#argc]\n0x000FED44 | 0C 10 0B E5 | STR     R1, [R11,#argv]\n0x000FED48 | 01 00 A0 E3 | MOV     R0, #1; fd\n0x000FED4C | D5 5B FC EB | BL      isatty\n0x000FED50 | 00 30 A0 E1 | MOV     R3, R0\n0x000FED54 | 00 00 53 E3 | CMP     R3, #0\n0x000FED58 | 06 00 00 0A | BEQ     loc_FED78\n0x000FED5C | 24 00 9F E5 | LDR     R0, =aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x000FED60 | 1C 58 FC EB | BL      printf\n0x000FED64 | 20 10 9F E5 | LDR     R1, =args.10327; argv\n0x000FED68 | 02 00 A0 E3 | MOV     R0, #2; argc\n0x000FED6C | F3 50 00 EB | BL      stty_main\n0x000FED70 | 00 30 A0 E1 | MOV     R3, R0\n0x000FED74 | 00 00 00 EA | B       loc_FED7C\n0x000FED78 | 00 30 A0 E3 | MOV     R3, #0\n0x000FED7C | 03 00 A0 E1 | MOV     R0, R3\n0x000FED80 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000FED84 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdio.h>\n#include <unistd.h>\n\nint main(int argc, char **argv) {\n    int isTerminal;\n    int result;\n\n    isTerminal = isatty(1); // file descriptor 1 is stdout\n    if (isTerminal) {\n        printf(\"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\");\n        result = stty_main(2, args.10327);\n    } else {\n        result = 0;\n    }\n\n    return result;\n}\n```"
    },
    {
        "func_name": "set_partition",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000BF198 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000BF19C | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000BF1A0 | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x000BF1A4 | 10 00 0B E5 | STR     R0, [R11,#i]\n0x000BF1A8 | 14 10 0B E5 | STR     R1, [R11,#doext]\n0x000BF1AC | 18 20 0B E5 | STR     R2, [R11,#start]\n0x000BF1B0 | 1C 30 0B E5 | STR     R3, [R11,#stop]\n0x000BF1B4 | 14 30 1B E5 | LDR     R3, [R11,#doext]\n0x000BF1B8 | 00 00 53 E3 | CMP     R3, #0\n0x000BF1BC | 10 00 00 0A | BEQ     loc_BF204\n0x000BF1C0 | 30 31 9F E5 | LDR     R3, =ptr_to_globals\n0x000BF1C4 | 00 10 93 E5 | LDR     R1, [R3]\n0x000BF1C8 | 10 20 1B E5 | LDR     R2, [R11,#i]\n0x000BF1CC | 02 30 A0 E1 | MOV     R3, R2\n0x000BF1D0 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF1D4 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000BF1D8 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF1DC | 03 30 81 E0 | ADD     R3, R1, R3\n0x000BF1E0 | A9 3E 83 E2 | ADD     R3, R3, #0xA90\n0x000BF1E4 | 04 30 83 E2 | ADD     R3, R3, #4\n0x000BF1E8 | 00 30 93 E5 | LDR     R3, [R3]\n0x000BF1EC | 08 30 0B E5 | STR     R3, [R11,#p]\n0x000BF1F0 | 00 31 9F E5 | LDR     R3, =ptr_to_globals\n0x000BF1F4 | 00 30 93 E5 | LDR     R3, [R3]\n0x000BF1F8 | 5C 30 93 E5 | LDR     R3, [R3,#0x5C]\n0x000BF1FC | 0C 30 0B E5 | STR     R3, [R11,#offset]\n0x000BF200 | 16 00 00 EA | B       loc_BF260\n0x000BF204 | EC 30 9F E5 | LDR     R3, =ptr_to_globals\n0x000BF208 | 00 10 93 E5 | LDR     R1, [R3]\n0x000BF20C | 10 20 1B E5 | LDR     R2, [R11,#i]\n0x000BF210 | 02 30 A0 E1 | MOV     R3, R2\n0x000BF214 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF218 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000BF21C | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF220 | 03 30 81 E0 | ADD     R3, R1, R3\n0x000BF224 | A9 3E 83 E2 | ADD     R3, R3, #0xA90\n0x000BF228 | 00 30 93 E5 | LDR     R3, [R3]\n0x000BF22C | 08 30 0B E5 | STR     R3, [R11,#p]\n0x000BF230 | C0 30 9F E5 | LDR     R3, =ptr_to_globals\n0x000BF234 | 00 10 93 E5 | LDR     R1, [R3]\n0x000BF238 | 10 20 1B E5 | LDR     R2, [R11,#i]\n0x000BF23C | 02 30 A0 E1 | MOV     R3, R2\n0x000BF240 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF244 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000BF248 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF24C | 03 30 81 E0 | ADD     R3, R1, R3\n0x000BF250 | A9 3E 83 E2 | ADD     R3, R3, #0xA90\n0x000BF254 | 08 30 83 E2 | ADD     R3, R3, #8\n0x000BF258 | 00 30 93 E5 | LDR     R3, [R3]\n0x000BF25C | 0C 30 0B E5 | STR     R3, [R11,#offset]\n0x000BF260 | 08 30 1B E5 | LDR     R3, [R11,#p]\n0x000BF264 | 00 20 A0 E3 | MOV     R2, #0\n0x000BF268 | 00 20 C3 E5 | STRB    R2, [R3]\n0x000BF26C | 04 30 9B E5 | LDR     R3, [R11,#sysid]\n0x000BF270 | FF 20 03 E2 | AND     R2, R3, #0xFF\n0x000BF274 | 08 30 1B E5 | LDR     R3, [R11,#p]\n0x000BF278 | 04 20 C3 E5 | STRB    R2, [R3,#4]\n0x000BF27C | 18 20 1B E5 | LDR     R2, [R11,#start]\n0x000BF280 | 0C 30 1B E5 | LDR     R3, [R11,#offset]\n0x000BF284 | 03 30 42 E0 | SUB     R3, R2, R3\n0x000BF288 | 03 10 A0 E1 | MOV     R1, R3; start_sect\n0x000BF28C | 08 00 1B E5 | LDR     R0, [R11,#p]; p\n0x000BF290 | 6D FD FF EB | BL      set_start_sect\n0x000BF294 | 1C 20 1B E5 | LDR     R2, [R11,#stop]\n0x000BF298 | 18 30 1B E5 | LDR     R3, [R11,#start]\n0x000BF29C | 03 30 42 E0 | SUB     R3, R2, R3\n0x000BF2A0 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000BF2A4 | 03 10 A0 E1 | MOV     R1, R3; nr_sects\n0x000BF2A8 | 08 00 1B E5 | LDR     R0, [R11,#p]; p\n0x000BF2AC | 73 FD FF EB | BL      set_nr_sects\n0x000BF2B0 | 1C 20 1B E5 | LDR     R2, [R11,#stop]; stop\n0x000BF2B4 | 18 10 1B E5 | LDR     R1, [R11,#start]; start\n0x000BF2B8 | 08 00 1B E5 | LDR     R0, [R11,#p]; p\n0x000BF2BC | 05 FF FF EB | BL      set_hsc_start_end\n0x000BF2C0 | 30 30 9F E5 | LDR     R3, =ptr_to_globals\n0x000BF2C4 | 00 10 93 E5 | LDR     R1, [R3]\n0x000BF2C8 | 10 20 1B E5 | LDR     R2, [R11,#i]\n0x000BF2CC | 02 30 A0 E1 | MOV     R3, R2\n0x000BF2D0 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF2D4 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000BF2D8 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000BF2DC | 03 30 81 E0 | ADD     R3, R1, R3\n0x000BF2E0 | AA 3E 83 E2 | ADD     R3, R3, #0xAA0\n0x000BF2E4 | 01 20 A0 E3 | MOV     R2, #1\n0x000BF2E8 | 00 20 C3 E5 | STRB    R2, [R3]\n0x000BF2EC | 00 00 A0 E1 | NOP\n0x000BF2F0 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000BF2F4 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(int i, int doext, int start, int stop) {\n    int *ptr_to_globals;\n    char *p;\n    int offset;\n    int sysid = 0; // Placeholder for sysid, actual value not provided in assembly\n\n    if (doext) {\n        p = *(char **)(*(int *)ptr_to_globals + i * 20 + 0xA94);\n        offset = *(int *)(*(int *)ptr_to_globals + 0x5C);\n    } else {\n        p = *(char **)(*(int *)ptr_to_globals + i * 20 + 0xA90);\n        offset = *(int *)(*(int *)ptr_to_globals + i * 20 + 0xA98);\n    }\n\n    p[0] = 0;\n    p[4] = sysid & 0xFF;\n\n    int start_sect = start - offset;\n    set_start_sect(p, start_sect);\n\n    int nr_sects = stop - start + 1;\n    set_nr_sects(p, nr_sects);\n\n    set_hsc_start_end(p, start, stop);\n\n    *(char *)(*(int *)ptr_to_globals + i * 20 + 0xAA0) = 1;\n}\n```"
    },
    {
        "func_name": "iprule_list",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0006C8A0 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0006C8A4 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0006C8A8 | 30 D0 4D E2 | SUB     SP, SP, #0x30\n0x0006C8AC | 30 00 0B E5 | STR     R0, [R11,#argv]\n0x0006C8B0 | 84 30 9F E5 | LDR     R3, =preferred_family\n0x0006C8B4 | D0 30 D3 E1 | LDRSB   R3, [R3]\n0x0006C8B8 | 08 30 0B E5 | STR     R3, [R11,#af]\n0x0006C8BC | 08 30 1B E5 | LDR     R3, [R11,#af]\n0x0006C8C0 | 00 00 53 E3 | CMP     R3, #0\n0x0006C8C4 | 01 00 00 1A | BNE     loc_6C8D0\n0x0006C8C8 | 02 30 A0 E3 | MOV     R3, #2\n0x0006C8CC | 08 30 0B E5 | STR     R3, [R11,#af]\n0x0006C8D0 | 30 30 1B E5 | LDR     R3, [R11,#argv]\n0x0006C8D4 | 00 30 93 E5 | LDR     R3, [R3]\n0x0006C8D8 | 00 00 53 E3 | CMP     R3, #0\n0x0006C8DC | 05 00 00 0A | BEQ     loc_6C8F8\n0x0006C8E0 | 30 30 1B E5 | LDR     R3, [R11,#argv]\n0x0006C8E4 | 00 30 93 E5 | LDR     R3, [R3]\n0x0006C8E8 | 03 00 A0 E1 | MOV     R0, R3; arg\n0x0006C8EC | E6 A0 03 EB | BL      bb_warn_ignoring_args\n0x0006C8F0 | 00 30 E0 E3 | MOV     R3, #0xFFFFFFFF\n0x0006C8F4 | 0D 00 00 EA | B       loc_6C930\n0x0006C8F8 | 2C 30 4B E2 | SUB     R3, R11, #-rth\n0x0006C8FC | 03 00 A0 E1 | MOV     R0, R3; rth\n0x0006C900 | E2 08 00 EB | BL      xrtnl_open\n0x0006C904 | 2C 30 4B E2 | SUB     R3, R11, #-rth\n0x0006C908 | 22 20 A0 E3 | MOV     R2, #0x22 ; '\"'; type\n0x0006C90C | 08 10 1B E5 | LDR     R1, [R11,#af]; family\n0x0006C910 | 03 00 A0 E1 | MOV     R0, R3; rth\n0x0006C914 | 09 09 00 EB | BL      xrtnl_wilddump_request\n0x0006C918 | 2C 30 4B E2 | SUB     R3, R11, #-rth\n0x0006C91C | 00 20 A0 E3 | MOV     R2, #0; arg1\n0x0006C920 | 18 10 9F E5 | LDR     R1, =print_rule; filter\n0x0006C924 | 03 00 A0 E1 | MOV     R0, R3; rth\n0x0006C928 | 43 0A 00 EB | BL      xrtnl_dump_filter\n0x0006C92C | 00 30 A0 E3 | MOV     R3, #0\n0x0006C930 | 03 00 A0 E1 | MOV     R0, R3\n0x0006C934 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0006C938 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nint preferred_family; // assumed to be a global variable\nvoid bb_warn_ignoring_args(char *arg);\nvoid xrtnl_open(char *rth);\nvoid xrtnl_wilddump_request(char *rth, int family, char type);\nvoid xrtnl_dump_filter(char *rth, void *filter, int arg1);\nvoid *print_rule; // assumed to be a global variable or function pointer\n\nint function(char **argv) {\n    int af = preferred_family;\n    if (af == 0) {\n        af = 2;\n    }\n\n    if (argv[0] != NULL) {\n        bb_warn_ignoring_args(argv[0]);\n        return -1;\n    }\n\n    char rth[0x30]; // assuming rth is a buffer of 0x30 bytes\n    xrtnl_open(rth);\n    xrtnl_wilddump_request(rth, af, 0x22);\n    xrtnl_dump_filter(rth, print_rule, 0);\n\n    return 0;\n}\n```"
    },
    {
        "func_name": "svstatus_print",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0008EB4C | 10 48 2D E9 | PUSH    {R4,R11,LR}\n0x0008EB50 | 08 B0 8D E2 | ADD     R11, SP, #8\n0x0008EB54 | 8C D0 4D E2 | SUB     SP, SP, #0x8C\n0x0008EB58 | 90 00 0B E5 | STR     R0, [R11,#m]\n0x0008EB5C | 00 30 A0 E3 | MOV     R3, #0\n0x0008EB60 | 10 30 0B E5 | STR     R3, [R11,#normallyup]\n0x0008EB64 | 8C 30 4B E2 | SUB     R3, R11, #-s\n0x0008EB68 | 03 10 A0 E1 | MOV     R1, R3; buf\n0x0008EB6C | C0 01 9F E5 | LDR     R0, =aDown_3; \"down\"\n0x0008EB70 | 7F 26 03 EB | BL      stat64_0\n0x0008EB74 | 00 30 A0 E1 | MOV     R3, R0\n0x0008EB78 | 01 00 73 E3 | CMN     R3, #1\n0x0008EB7C | 0E 00 00 1A | BNE     loc_8EBBC\n0x0008EB80 | B0 31 9F E5 | LDR     R3, =bb_errno\n0x0008EB84 | 00 30 93 E5 | LDR     R3, [R3]\n0x0008EB88 | 00 30 93 E5 | LDR     R3, [R3]\n0x0008EB8C | 02 00 53 E3 | CMP     R3, #2\n0x0008EB90 | 07 00 00 0A | BEQ     loc_8EBB4\n0x0008EB94 | A0 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008EB98 | 04 30 93 E5 | LDR     R3, [R3,#(unk_18F9DC - 0x18F9D8)]\n0x0008EB9C | 00 30 93 E5 | LDR     R3, [R3]\n0x0008EBA0 | 03 10 A0 E1 | MOV     R1, R3\n0x0008EBA4 | 94 01 9F E5 | LDR     R0, =aWarningCanTSta; \"warning: can't stat %s/down\"\n0x0008EBA8 | 36 27 FE EB | BL      bb_perror_msg\n0x0008EBAC | 00 30 A0 E3 | MOV     R3, #0\n0x0008EBB0 | 5C 00 00 EA | B       loc_8ED28\n0x0008EBB4 | 01 30 A0 E3 | MOV     R3, #1\n0x0008EBB8 | 10 30 0B E5 | STR     R3, [R11,#normallyup]\n0x0008EBBC | 78 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008EBC0 | 2C 30 93 E5 | LDR     R3, [R3,#(unk_18FA04 - 0x18F9D8)]\n0x0008EBC4 | 14 30 0B E5 | STR     R3, [R11,#pid]\n0x0008EBC8 | 6C 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008EBCC | 20 40 83 E2 | ADD     R4, R3, #0x20 ; ' '\n0x0008EBD0 | 18 00 94 E8 | LDM     R4, {R3,R4}\n0x0008EBD4 | 03 00 A0 E1 | MOV     R0, R3; x\n0x0008EBD8 | 04 10 A0 E1 | MOV     R1, R4; x\n0x0008EBDC | EA B5 02 EB | BL      bb_bswap_64\n0x0008EBE0 | 1C 00 0B E5 | STR     R0, [R11,#timestamp]\n0x0008EBE4 | 18 10 0B E5 | STR     R1, [R11,#timestamp+4]\n0x0008EBE8 | 14 30 1B E5 | LDR     R3, [R11,#pid]\n0x0008EBEC | 00 00 53 E3 | CMP     R3, #0\n0x0008EBF0 | 11 00 00 0A | BEQ     loc_8EC3C\n0x0008EBF4 | 40 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008EBF8 | 33 30 D3 E5 | LDRB    R3, [R3,#(unk_18FA0B - 0x18F9D8)]\n0x0008EBFC | 01 00 53 E3 | CMP     R3, #1\n0x0008EC00 | 02 00 00 0A | BEQ     loc_8EC10\n0x0008EC04 | 02 00 53 E3 | CMP     R3, #2\n0x0008EC08 | 03 00 00 0A | BEQ     loc_8EC1C\n0x0008EC0C | 05 00 00 EA | B       loc_8EC28\n0x0008EC10 | 2C 01 9F E5 | LDR     R0, =aRun_1; \"run: \"\n0x0008EC14 | 6F 18 FE EB | BL      printf\n0x0008EC18 | 02 00 00 EA | B       loc_8EC28\n0x0008EC1C | 24 01 9F E5 | LDR     R0, =aFinish_1; \"finish: \"\n0x0008EC20 | 6C 18 FE EB | BL      printf\n0x0008EC24 | 00 00 A0 E1 | NOP\n0x0008EC28 | 14 20 1B E5 | LDR     R2, [R11,#pid]\n0x0008EC2C | 90 10 1B E5 | LDR     R1, [R11,#m]\n0x0008EC30 | 14 01 9F E5 | LDR     R0, =aSPidD; \"%s: (pid %d) \"\n0x0008EC34 | 67 18 FE EB | BL      printf\n0x0008EC38 | 02 00 00 EA | B       loc_8EC48\n0x0008EC3C | 90 10 1B E5 | LDR     R1, [R11,#m]\n0x0008EC40 | 08 01 9F E5 | LDR     R0, =aDownS; \"down: %s: \"\n0x0008EC44 | 63 18 FE EB | BL      printf\n0x0008EC48 | EC 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008EC4C | 18 40 83 E2 | ADD     R4, R3, #0x18\n0x0008EC50 | 18 00 94 E8 | LDM     R4, {R3,R4}\n0x0008EC54 | 03 20 A0 E1 | MOV     R2, R3\n0x0008EC58 | 1C 30 1B E5 | LDR     R3, [R11,#timestamp]\n0x0008EC5C | 03 30 42 E0 | SUB     R3, R2, R3\n0x0008EC60 | 20 30 0B E5 | STR     R3, [R11,#diff]\n0x0008EC64 | 20 30 1B E5 | LDR     R3, [R11,#diff]\n0x0008EC68 | C3 3F C3 E1 | BIC     R3, R3, R3,ASR#31\n0x0008EC6C | 03 10 A0 E1 | MOV     R1, R3\n0x0008EC70 | DC 00 9F E5 | LDR     R0, =aUs; \"%us\"\n0x0008EC74 | 57 18 FE EB | BL      printf\n0x0008EC78 | 14 30 1B E5 | LDR     R3, [R11,#pid]\n0x0008EC7C | 00 00 53 E3 | CMP     R3, #0\n0x0008EC80 | 17 00 00 0A | BEQ     loc_8ECE4\n0x0008EC84 | 10 30 1B E5 | LDR     R3, [R11,#normallyup]\n0x0008EC88 | 00 00 53 E3 | CMP     R3, #0\n0x0008EC8C | 01 00 00 1A | BNE     loc_8EC98\n0x0008EC90 | C0 00 9F E5 | LDR     R0, =aNormallyDown; \", normally down\"\n0x0008EC94 | 4F 18 FE EB | BL      printf\n0x0008EC98 | 9C 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008EC9C | 30 30 D3 E5 | LDRB    R3, [R3,#(word_18FA08 - 0x18F9D8)]\n0x0008ECA0 | 00 00 53 E3 | CMP     R3, #0\n0x0008ECA4 | 01 00 00 0A | BEQ     loc_8ECB0\n0x0008ECA8 | AC 00 9F E5 | LDR     R0, =aPaused_0; \", paused\"\n0x0008ECAC | 49 18 FE EB | BL      printf\n0x0008ECB0 | 84 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008ECB4 | 31 30 D3 E5 | LDRB    R3, [R3,#(word_18FA08+1 - 0x18F9D8)]\n0x0008ECB8 | 64 00 53 E3 | CMP     R3, #0x64 ; 'd'\n0x0008ECBC | 01 00 00 1A | BNE     loc_8ECC8\n0x0008ECC0 | 98 00 9F E5 | LDR     R0, =aWantDown_0; \", want down\"\n0x0008ECC4 | 43 18 FE EB | BL      printf\n0x0008ECC8 | 6C 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008ECCC | 32 30 D3 E5 | LDRB    R3, [R3,#(unk_18FA0A - 0x18F9D8)]\n0x0008ECD0 | 00 00 53 E3 | CMP     R3, #0\n0x0008ECD4 | 0D 00 00 0A | BEQ     loc_8ED10\n0x0008ECD8 | 84 00 9F E5 | LDR     R0, =aGotTerm_0; \", got TERM\"\n0x0008ECDC | 3D 18 FE EB | BL      printf\n0x0008ECE0 | 0A 00 00 EA | B       loc_8ED10\n0x0008ECE4 | 10 30 1B E5 | LDR     R3, [R11,#normallyup]\n0x0008ECE8 | 00 00 53 E3 | CMP     R3, #0\n0x0008ECEC | 01 00 00 0A | BEQ     loc_8ECF8\n0x0008ECF0 | 70 00 9F E5 | LDR     R0, =aNormallyUp; \", normally up\"\n0x0008ECF4 | 37 18 FE EB | BL      printf\n0x0008ECF8 | 3C 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0008ECFC | 31 30 D3 E5 | LDRB    R3, [R3,#(word_18FA08+1 - 0x18F9D8)]\n0x0008ED00 | 75 00 53 E3 | CMP     R3, #0x75 ; 'u'\n0x0008ED04 | 01 00 00 1A | BNE     loc_8ED10\n0x0008ED08 | 5C 00 9F E5 | LDR     R0, =aWantUp; \", want up\"\n0x0008ED0C | 31 18 FE EB | BL      printf\n0x0008ED10 | 14 30 1B E5 | LDR     R3, [R11,#pid]\n0x0008ED14 | 00 00 53 E3 | CMP     R3, #0\n0x0008ED18 | 01 00 00 0A | BEQ     loc_8ED24\n0x0008ED1C | 01 30 A0 E3 | MOV     R3, #1\n0x0008ED20 | 00 00 00 EA | B       loc_8ED28\n0x0008ED24 | 02 30 A0 E3 | MOV     R3, #2\n0x0008ED28 | 03 00 A0 E1 | MOV     R0, R3\n0x0008ED2C | 08 D0 4B E2 | SUB     SP, R11, #8\n0x0008ED30 | 10 88 BD E8 | POP     {R4,R11,PC}",
        "output": "```c\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n\nextern int bb_errno;\nextern char bb_common_bufsiz1[];\nextern const char aDown_3[];\nextern const char aWarningCanTSta[];\nextern const char aRun_1[];\nextern const char aFinish_1[];\nextern const char aSPidD[];\nextern const char aDownS[];\nextern const char aNormallyDown[];\nextern const char aPaused_0[];\nextern const char aWantDown_0[];\nextern const char aGotTerm_0[];\nextern const char aNormallyUp[];\nextern const char aWantUp[];\n\nint function(const char *m) {\n    struct stat64 stat_buf;\n    int normallyup = 0;\n    int pid;\n    unsigned long long timestamp;\n    int diff;\n    int result;\n\n    if (stat64(\"down\", &stat_buf) != 0) {\n        if (bb_errno == 2) {\n            normallyup = 1;\n        } else {\n            printf(\"warning: can't stat %s/down\", m);\n            return 0;\n        }\n    }\n\n    pid = *(int *)(bb_common_bufsiz1 + 44);\n    timestamp = bb_bswap_64(*(unsigned long long *)(bb_common_bufsiz1 + 32));\n\n    if (pid != 0) {\n        switch (*(bb_common_bufsiz1 + 51)) {\n            case 1:\n                printf(\"run: \");\n                break;\n            case 2:\n                printf(\"finish: \");\n                break;\n        }\n        printf(\"%s: (pid %d) \", m, pid);\n    } else {\n        printf(\"down: %s: \", m);\n    }\n\n    diff = (int)(*(unsigned long long *)(bb_common_bufsiz1 + 24) - timestamp);\n    diff &= ~(diff >> 31);\n    printf(\"%us\", diff);\n\n    if (pid != 0) {\n        if (!normallyup) {\n            printf(\", normally down\");\n        }\n        if (*(bb_common_bufsiz1 + 48) != 0) {\n            printf(\", paused\");\n        }\n        if (*(bb_common_bufsiz1 + 49) == 'd') {\n            printf(\", want down\");\n        }\n        if (*(bb_common_bufsiz1 + 50) != 0) {\n            printf(\", got TERM\");\n        }\n    } else {\n        if (normallyup) {\n            printf(\", normally up\");\n        }\n        if (*(bb_common_bufsiz1 + 49) == 'u') {\n            printf(\", want up\");\n        }\n    }\n\n    result = (pid != 0) ? 1 : 2;\n    return result;\n}\n```"
    },
    {
        "func_name": "varcmp",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000948F8 | 04 B0 2D E5 | PUSH    {R11}\n0x000948FC | 00 B0 8D E2 | ADD     R11, SP, #0\n0x00094900 | 14 D0 4D E2 | SUB     SP, SP, #0x14\n0x00094904 | 10 00 0B E5 | STR     R0, [R11,#p]\n0x00094908 | 14 10 0B E5 | STR     R1, [R11,#q]\n0x0009490C | 0B 00 00 EA | B       loc_94940\n0x00094910 | 08 30 1B E5 | LDR     R3, [R11,#c]\n0x00094914 | 00 00 53 E3 | CMP     R3, #0\n0x00094918 | 1D 00 00 0A | BEQ     loc_94994\n0x0009491C | 08 30 1B E5 | LDR     R3, [R11,#c]\n0x00094920 | 3D 00 53 E3 | CMP     R3, #0x3D ; '='\n0x00094924 | 1A 00 00 0A | BEQ     loc_94994\n0x00094928 | 10 30 1B E5 | LDR     R3, [R11,#p]\n0x0009492C | 01 30 83 E2 | ADD     R3, R3, #1\n0x00094930 | 10 30 0B E5 | STR     R3, [R11,#p]\n0x00094934 | 14 30 1B E5 | LDR     R3, [R11,#q]\n0x00094938 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0009493C | 14 30 0B E5 | STR     R3, [R11,#q]\n0x00094940 | 10 30 1B E5 | LDR     R3, [R11,#p]\n0x00094944 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x00094948 | 08 30 0B E5 | STR     R3, [R11,#c]\n0x0009494C | 14 30 1B E5 | LDR     R3, [R11,#q]\n0x00094950 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x00094954 | 0C 30 0B E5 | STR     R3, [R11,#d]\n0x00094958 | 08 20 1B E5 | LDR     R2, [R11,#c]\n0x0009495C | 0C 30 1B E5 | LDR     R3, [R11,#d]\n0x00094960 | 03 00 52 E1 | CMP     R2, R3\n0x00094964 | E9 FF FF 0A | BEQ     loc_94910\n0x00094968 | 08 30 1B E5 | LDR     R3, [R11,#c]\n0x0009496C | 3D 00 53 E3 | CMP     R3, #0x3D ; '='\n0x00094970 | 01 00 00 1A | BNE     loc_9497C\n0x00094974 | 00 30 A0 E3 | MOV     R3, #0\n0x00094978 | 08 30 0B E5 | STR     R3, [R11,#c]\n0x0009497C | 0C 30 1B E5 | LDR     R3, [R11,#d]\n0x00094980 | 3D 00 53 E3 | CMP     R3, #0x3D ; '='\n0x00094984 | 04 00 00 1A | BNE     loc_9499C\n0x00094988 | 00 30 A0 E3 | MOV     R3, #0\n0x0009498C | 0C 30 0B E5 | STR     R3, [R11,#d]\n0x00094990 | 02 00 00 EA | B       out\n0x00094994 | 00 00 A0 E1 | NOP\n0x00094998 | 00 00 00 EA | B       out\n0x0009499C | 00 00 A0 E1 | NOP\n0x000949A0 | 08 20 1B E5 | LDR     R2, [R11,#c]\n0x000949A4 | 0C 30 1B E5 | LDR     R3, [R11,#d]\n0x000949A8 | 03 30 42 E0 | SUB     R3, R2, R3\n0x000949AC | 03 00 A0 E1 | MOV     R0, R3\n0x000949B0 | 00 D0 8B E2 | MOV     SP, R11\n0x000949B4 | 04 B0 9D E4 | POP     {R11}\n0x000949B8 | 1E FF 2F E1 | BX      LR",
        "output": "```c\nint function(char *p, char *q) {\n    char c, d;\n    do {\n        c = *p++;\n        if (c == '\\0' || c == '=') {\n            c = '\\0';\n        }\n        d = *q++;\n        if (d == '\\0' || d == '=') {\n            d = '\\0';\n        }\n    } while (c == d && c != '\\0');\n\n    return c - d;\n}\n```"
    },
    {
        "func_name": "initialize_group_array",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x001156B0 | 10 48 2D E9 | PUSH    {R4,R11,LR}\n0x001156B4 | 08 B0 8D E2 | ADD     R11, SP, #8\n0x001156B8 | 0C D0 4D E2 | SUB     SP, SP, #0xC\n0x001156BC | 90 30 9F E5 | LDR     R3, =test_ptr_to_statics\n0x001156C0 | 00 30 93 E5 | LDR     R3, [R3]\n0x001156C4 | 20 20 A0 E3 | MOV     R2, #0x20 ; ' '\n0x001156C8 | 0C 20 83 E5 | STR     R2, [R3,#0xC]\n0x001156CC | 80 30 9F E5 | LDR     R3, =test_ptr_to_statics\n0x001156D0 | 00 30 93 E5 | LDR     R3, [R3]\n0x001156D4 | 0C 30 93 E5 | LDR     R3, [R3,#0xC]\n0x001156D8 | 10 30 0B E5 | STR     R3, [R11,#n]\n0x001156DC | 70 30 9F E5 | LDR     R3, =test_ptr_to_statics\n0x001156E0 | 00 30 93 E5 | LDR     R3, [R3]\n0x001156E4 | 08 20 93 E5 | LDR     R2, [R3,#8]\n0x001156E8 | 10 30 1B E5 | LDR     R3, [R11,#n]\n0x001156EC | 03 11 A0 E1 | MOV     R1, R3,LSL#2; size\n0x001156F0 | 5C 30 9F E5 | LDR     R3, =test_ptr_to_statics\n0x001156F4 | 00 40 93 E5 | LDR     R4, [R3]\n0x001156F8 | 02 00 A0 E1 | MOV     R0, R2; ptr\n0x001156FC | F4 10 FC EB | BL      xrealloc\n0x00115700 | 00 30 A0 E1 | MOV     R3, R0\n0x00115704 | 08 30 84 E5 | STR     R3, [R4,#8]\n0x00115708 | 44 30 9F E5 | LDR     R3, =test_ptr_to_statics\n0x0011570C | 00 30 93 E5 | LDR     R3, [R3]\n0x00115710 | 08 20 93 E5 | LDR     R2, [R3,#8]\n0x00115714 | 38 30 9F E5 | LDR     R3, =test_ptr_to_statics\n0x00115718 | 00 40 93 E5 | LDR     R4, [R3]\n0x0011571C | 02 10 A0 E1 | MOV     R1, R2; list\n0x00115720 | 10 00 1B E5 | LDR     R0, [R11,#n]; size\n0x00115724 | F3 00 FC EB | BL      getgroups\n0x00115728 | 00 30 A0 E1 | MOV     R3, R0\n0x0011572C | 0C 30 84 E5 | STR     R3, [R4,#0xC]\n0x00115730 | 1C 30 9F E5 | LDR     R3, =test_ptr_to_statics\n0x00115734 | 00 30 93 E5 | LDR     R3, [R3]\n0x00115738 | 0C 30 93 E5 | LDR     R3, [R3,#0xC]\n0x0011573C | 10 20 1B E5 | LDR     R2, [R11,#n]\n0x00115740 | 03 00 52 E1 | CMP     R2, R3\n0x00115744 | E0 FF FF BA | BLT     loc_1156CC\n0x00115748 | 00 00 A0 E1 | NOP\n0x0011574C | 08 D0 4B E2 | SUB     SP, R11, #8\n0x00115750 | 10 88 BD E8 | POP     {R4,R11,PC}",
        "output": "```c\n#include <stddef.h>\n\nextern void *xrealloc(void *ptr, size_t size);\nextern int getgroups(int size, int *list);\n\nstatic int *test_ptr_to_statics;\n\nvoid function() {\n    test_ptr_to_statics[3] = 0x20;\n\n    int size = test_ptr_to_statics[3] << 2;\n    int *ptr = &test_ptr_to_statics[2];\n    ptr = xrealloc(ptr, size);\n\n    test_ptr_to_statics[2] = (int)ptr;\n\n    int list = test_ptr_to_statics[2];\n    size = getgroups(size, &list);\n\n    test_ptr_to_statics[3] = size;\n\n    if (size < test_ptr_to_statics[3]) {\n        // This branch will never be taken since size is set to test_ptr_to_statics[3] before the comparison.\n        // The original assembly code seems to have a redundant branch that does nothing.\n        // The code at loc_1156CC is not provided, but it would be the target of the branch if the condition were true.\n    }\n}\n```"
    },
    {
        "func_name": "header_verbose_list",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000FB3D8 | F0 48 2D E9 | PUSH    {R4-R7,R11,LR}\n0x000FB3DC | 14 B0 8D E2 | ADD     R11, SP, #0x14\n0x000FB3E0 | 78 D0 4D E2 | SUB     SP, SP, #0x78\n0x000FB3E4 | 60 00 0B E5 | STR     R0, [R11,#file_header]\n0x000FB3E8 | 4C 30 4B E2 | SUB     R3, R11, #-tm_time\n0x000FB3EC | 20 30 0B E5 | STR     R3, [R11,#ptm]\n0x000FB3F0 | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB3F4 | 24 30 83 E2 | ADD     R3, R3, #0x24 ; '$'\n0x000FB3F8 | 20 10 1B E5 | LDR     R1, [R11,#ptm]; tp\n0x000FB3FC | 03 00 A0 E1 | MOV     R0, R3; timer\n0x000FB400 | 4F 67 FC EB | BL      localtime_r\n0x000FB404 | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB408 | 08 30 93 E5 | LDR     R3, [R3,#8]\n0x000FB40C | 18 30 0B E5 | STR     R3, [R11,#user]\n0x000FB410 | 18 30 1B E5 | LDR     R3, [R11,#user]\n0x000FB414 | 00 00 53 E3 | CMP     R3, #0\n0x000FB418 | 07 00 00 1A | BNE     loc_FB43C\n0x000FB41C | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB420 | 18 20 93 E5 | LDR     R2, [R3,#0x18]\n0x000FB424 | 5C 30 4B E2 | SUB     R3, R11, #-uid\n0x000FB428 | 08 11 9F E5 | LDR     R1, =aU_22; \"%u\"\n0x000FB42C | 03 00 A0 E1 | MOV     R0, R3; s\n0x000FB430 | A1 69 FC EB | BL      sprintf\n0x000FB434 | 5C 30 4B E2 | SUB     R3, R11, #-uid\n0x000FB438 | 18 30 0B E5 | STR     R3, [R11,#user]\n0x000FB43C | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB440 | 0C 30 93 E5 | LDR     R3, [R3,#0xC]\n0x000FB444 | 1C 30 0B E5 | STR     R3, [R11,#group]\n0x000FB448 | 1C 30 1B E5 | LDR     R3, [R11,#group]\n0x000FB44C | 00 00 53 E3 | CMP     R3, #0\n0x000FB450 | 04 00 00 1A | BNE     loc_FB468\n0x000FB454 | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB458 | 1C 30 93 E5 | LDR     R3, [R3,#0x1C]\n0x000FB45C | 03 00 A0 E1 | MOV     R0, R3; n\n0x000FB460 | A9 77 FC EB | BL      utoa\n0x000FB464 | 1C 00 0B E5 | STR     R0, [R11,#group]\n0x000FB468 | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB46C | 20 30 93 E5 | LDR     R3, [R3,#0x20]\n0x000FB470 | 03 00 A0 E1 | MOV     R0, R3; mode\n0x000FB474 | 20 3E 01 EB | BL      bb_mode_string\n0x000FB478 | 00 70 A0 E1 | MOV     R7, R0\n0x000FB47C | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB480 | 10 20 83 E2 | ADD     R2, R3, #0x10\n0x000FB484 | 06 00 92 E8 | LDM     R2, {R1,R2}\n0x000FB488 | 20 30 1B E5 | LDR     R3, [R11,#ptm]\n0x000FB48C | 14 30 93 E5 | LDR     R3, [R3,#0x14]\n0x000FB490 | 76 3E 83 E2 | ADD     R3, R3, #0x760\n0x000FB494 | 0C 30 83 E2 | ADD     R3, R3, #0xC\n0x000FB498 | 20 00 1B E5 | LDR     R0, [R11,#ptm]\n0x000FB49C | 10 00 90 E5 | LDR     R0, [R0,#0x10]\n0x000FB4A0 | 01 00 80 E2 | ADD     R0, R0, #1\n0x000FB4A4 | 20 C0 1B E5 | LDR     R12, [R11,#ptm]\n0x000FB4A8 | 0C C0 9C E5 | LDR     R12, [R12,#0xC]\n0x000FB4AC | 20 E0 1B E5 | LDR     LR, [R11,#ptm]\n0x000FB4B0 | 08 E0 9E E5 | LDR     LR, [LR,#8]\n0x000FB4B4 | 20 40 1B E5 | LDR     R4, [R11,#ptm]\n0x000FB4B8 | 04 40 94 E5 | LDR     R4, [R4,#4]\n0x000FB4BC | 20 50 1B E5 | LDR     R5, [R11,#ptm]\n0x000FB4C0 | 00 50 95 E5 | LDR     R5, [R5]\n0x000FB4C4 | 60 60 1B E5 | LDR     R6, [R11,#file_header]\n0x000FB4C8 | 00 60 96 E5 | LDR     R6, [R6]\n0x000FB4CC | 20 60 8D E5 | STR     R6, [SP,#0x8C+var_6C]\n0x000FB4D0 | 1C 50 8D E5 | STR     R5, [SP,#0x8C+var_70]\n0x000FB4D4 | 18 40 8D E5 | STR     R4, [SP,#0x8C+var_74]\n0x000FB4D8 | 14 E0 8D E5 | STR     LR, [SP,#0x8C+var_78]\n0x000FB4DC | 10 C0 8D E5 | STR     R12, [SP,#0x8C+var_7C]\n0x000FB4E0 | 0C 00 8D E5 | STR     R0, [SP,#0x8C+var_80]\n0x000FB4E4 | 08 30 8D E5 | STR     R3, [SP,#0x8C+var_84]\n0x000FB4E8 | 06 00 8D E8 | STMEA   SP, {R1,R2}\n0x000FB4EC | 1C 30 1B E5 | LDR     R3, [R11,#group]\n0x000FB4F0 | 18 20 1B E5 | LDR     R2, [R11,#user]\n0x000FB4F4 | 07 10 A0 E1 | MOV     R1, R7\n0x000FB4F8 | 3C 00 9F E5 | LDR     R0, =aSSS9llu4u02u02; \"%s %s/%s %9llu %4u-%02u-%02u %02u:%02u:\"...\n0x000FB4FC | 35 66 FC EB | BL      printf\n0x000FB500 | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB504 | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000FB508 | 00 00 53 E3 | CMP     R3, #0\n0x000FB50C | 04 00 00 0A | BEQ     loc_FB524\n0x000FB510 | 60 30 1B E5 | LDR     R3, [R11,#file_header]\n0x000FB514 | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000FB518 | 03 10 A0 E1 | MOV     R1, R3\n0x000FB51C | 1C 00 9F E5 | LDR     R0, =aS_90; \" -> %s\"\n0x000FB520 | 2C 66 FC EB | BL      printf\n0x000FB524 | 0A 00 A0 E3 | MOV     R0, #0xA; ch\n0x000FB528 | 40 7B FC EB | BL      bb_putchar\n0x000FB52C | 00 00 A0 E1 | NOP\n0x000FB530 | 14 D0 4B E2 | SUB     SP, R11, #0x14\n0x000FB534 | F0 88 BD E8 | POP     {R4-R7,R11,PC}",
        "output": "```c\n#include <stdio.h>\n#include <time.h>\n\nstruct file_header {\n    unsigned long long size;\n    unsigned int mode;\n    unsigned int uid;\n    unsigned int gid;\n    unsigned int mtime;\n    char *linkname;\n    // other fields might be here\n};\n\nvoid display_file_info(struct file_header *header) {\n    struct tm *ptm;\n    char user[32], group[32];\n    char *mode_str;\n    time_t mtime = header->mtime;\n    ptm = localtime_r(&mtime, &ptm);\n\n    if (header->uid) {\n        sprintf(user, \"%u\", header->uid);\n    } else {\n        user[0] = '\\0';\n    }\n\n    if (header->gid) {\n        group[0] = '\\0'; // Assuming utoa() stores the result in group\n    } else {\n        group[0] = '\\0';\n    }\n\n    mode_str = bb_mode_string(header->mode);\n\n    printf(\"%s %s/%s %9llu %4u-%02u-%02u %02u:%02u:%02u.%06u %s\",\n           mode_str,\n           user,\n           group,\n           header->size,\n           ptm->tm_year + 1900,\n           ptm->tm_mon + 1,\n           ptm->tm_mday,\n           ptm->tm_hour,\n           ptm->tm_min,\n           ptm->tm_sec,\n           0, // Assuming missing nanoseconds field\n           header->linkname ? \" -> \" : \"\");\n\n    if (header->linkname) {\n        printf(\" -> %s\", header->linkname);\n    }\n\n    bb_putchar('\\n');\n}\n```"
    },
    {
        "func_name": "retry_network_setup",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0004E218 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0004E21C | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0004E220 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x0004E224 | 10 00 0B E5 | STR     R0, [R11,#sig]\n0x0004E228 | 98 30 9F E5 | LDR     R3, =bb_errno\n0x0004E22C | 00 30 93 E5 | LDR     R3, [R3]\n0x0004E230 | 00 30 93 E5 | LDR     R3, [R3]\n0x0004E234 | 0C 30 0B E5 | STR     R3, [R11,#save_errno]\n0x0004E238 | 8C 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004E23C | 00 20 A0 E3 | MOV     R2, #0\n0x0004E240 | 2C 20 83 E5 | STR     R2, [R3,#(bb_common_bufsiz1.c_cc+0x1B - 0x18F9D8)]\n0x0004E244 | 80 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0004E248 | 18 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+7 - 0x18F9D8)]\n0x0004E24C | 08 30 0B E5 | STR     R3, [R11,#sep]\n0x0004E250 | 12 00 00 EA | B       loc_4E2A0\n0x0004E254 | 08 30 1B E5 | LDR     R3, [R11,#sep]\n0x0004E258 | 00 30 93 E5 | LDR     R3, [R3]\n0x0004E25C | 01 00 73 E3 | CMN     R3, #1\n0x0004E260 | 0B 00 00 1A | BNE     loc_4E294\n0x0004E264 | 08 00 1B E5 | LDR     R0, [R11,#sep]; sep\n0x0004E268 | 19 FA FF EB | BL      prepare_socket_fd\n0x0004E26C | 08 30 1B E5 | LDR     R3, [R11,#sep]\n0x0004E270 | 00 30 93 E5 | LDR     R3, [R3]\n0x0004E274 | 01 00 73 E3 | CMN     R3, #1\n0x0004E278 | 05 00 00 0A | BEQ     loc_4E294\n0x0004E27C | 08 30 1B E5 | LDR     R3, [R11,#sep]\n0x0004E280 | 14 30 93 E5 | LDR     R3, [R3,#0x14]\n0x0004E284 | 00 00 53 E3 | CMP     R3, #0\n0x0004E288 | 01 00 00 0A | BEQ     loc_4E294\n0x0004E28C | 08 00 1B E5 | LDR     R0, [R11,#sep]; sep\n0x0004E290 | C0 F8 FF EB | BL      register_rpc\n0x0004E294 | 08 30 1B E5 | LDR     R3, [R11,#sep]\n0x0004E298 | 44 30 93 E5 | LDR     R3, [R3,#0x44]\n0x0004E29C | 08 30 0B E5 | STR     R3, [R11,#sep]\n0x0004E2A0 | 08 30 1B E5 | LDR     R3, [R11,#sep]\n0x0004E2A4 | 00 00 53 E3 | CMP     R3, #0\n0x0004E2A8 | E9 FF FF 1A | BNE     loc_4E254\n0x0004E2AC | 14 30 9F E5 | LDR     R3, =bb_errno\n0x0004E2B0 | 00 30 93 E5 | LDR     R3, [R3]\n0x0004E2B4 | 0C 20 1B E5 | LDR     R2, [R11,#save_errno]\n0x0004E2B8 | 00 20 83 E5 | STR     R2, [R3]\n0x0004E2BC | 00 00 A0 E1 | NOP\n0x0004E2C0 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0004E2C4 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <errno.h>\n\nextern int bb_errno;\nextern char bb_common_bufsiz1;\nextern void prepare_socket_fd(int);\nextern void register_rpc(int);\n\nvoid function(int sig) {\n    int save_errno = errno;\n    bb_common_bufsiz1.c_cc[0x1B - 0x18F9D8] = 0;\n    int sep = bb_common_bufsiz1.c_cc[7 - 0x18F9D8];\n\n    do {\n        if (sep != 0) {\n            if (sep == 1) {\n                prepare_socket_fd(sep);\n            } else if (*(int *)(sep + 0x14) != 0) {\n                register_rpc(sep);\n            }\n            sep = *(int *)(sep + 0x44);\n        }\n    } while (sep != 0);\n\n    errno = save_errno;\n}\n```"
    },
    {
        "func_name": "evalcmd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000A75C8 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000A75CC | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000A75D0 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x000A75D4 | 10 00 0B E5 | STR     R0, [R11,#argc]\n0x000A75D8 | 14 10 0B E5 | STR     R1, [R11,#argv]\n0x000A75DC | 14 30 1B E5 | LDR     R3, [R11,#argv]\n0x000A75E0 | 04 30 83 E2 | ADD     R3, R3, #4\n0x000A75E4 | 00 30 93 E5 | LDR     R3, [R3]\n0x000A75E8 | 00 00 53 E3 | CMP     R3, #0\n0x000A75EC | 2E 00 00 0A | BEQ     loc_A76AC\n0x000A75F0 | 14 30 1B E5 | LDR     R3, [R11,#argv]\n0x000A75F4 | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000A75F8 | 08 30 0B E5 | STR     R3, [R11,#p]\n0x000A75FC | 14 30 1B E5 | LDR     R3, [R11,#argv]\n0x000A7600 | 08 30 83 E2 | ADD     R3, R3, #8\n0x000A7604 | 14 30 0B E5 | STR     R3, [R11,#argv]\n0x000A7608 | 14 30 1B E5 | LDR     R3, [R11,#argv]\n0x000A760C | 00 30 93 E5 | LDR     R3, [R3]\n0x000A7610 | 00 00 53 E3 | CMP     R3, #0\n0x000A7614 | 21 00 00 0A | BEQ     loc_A76A0\n0x000A7618 | A0 30 9F E5 | LDR     R3, =ash_ptr_to_globals_memstack\n0x000A761C | 00 30 93 E5 | LDR     R3, [R3]\n0x000A7620 | 08 30 93 E5 | LDR     R3, [R3,#8]\n0x000A7624 | 0C 30 0B E5 | STR     R3, [R11,#concat]\n0x000A7628 | 0C 10 1B E5 | LDR     R1, [R11,#concat]; p\n0x000A762C | 08 00 1B E5 | LDR     R0, [R11,#p]; s\n0x000A7630 | 22 B3 FF EB | BL      stack_putstr\n0x000A7634 | 0C 00 0B E5 | STR     R0, [R11,#concat]\n0x000A7638 | 14 30 1B E5 | LDR     R3, [R11,#argv]\n0x000A763C | 04 20 83 E2 | ADD     R2, R3, #4\n0x000A7640 | 14 20 0B E5 | STR     R2, [R11,#argv]\n0x000A7644 | 00 30 93 E5 | LDR     R3, [R3]\n0x000A7648 | 08 30 0B E5 | STR     R3, [R11,#p]\n0x000A764C | 08 30 1B E5 | LDR     R3, [R11,#p]\n0x000A7650 | 00 00 53 E3 | CMP     R3, #0\n0x000A7654 | 04 00 00 0A | BEQ     loc_A766C\n0x000A7658 | 0C 10 1B E5 | LDR     R1, [R11,#concat]; p\n0x000A765C | 20 00 A0 E3 | MOV     R0, #0x20 ; ' '; c\n0x000A7660 | 26 B3 FF EB | BL      _STPUTC\n0x000A7664 | 0C 00 0B E5 | STR     R0, [R11,#concat]\n0x000A7668 | EE FF FF EA | B       loc_A7628\n0x000A766C | 00 00 A0 E1 | NOP\n0x000A7670 | 0C 10 1B E5 | LDR     R1, [R11,#concat]; p\n0x000A7674 | 00 00 A0 E3 | MOV     R0, #0; c\n0x000A7678 | 20 B3 FF EB | BL      _STPUTC\n0x000A767C | 0C 00 0B E5 | STR     R0, [R11,#concat]\n0x000A7680 | 38 30 9F E5 | LDR     R3, =ash_ptr_to_globals_memstack\n0x000A7684 | 00 30 93 E5 | LDR     R3, [R3]\n0x000A7688 | 08 30 93 E5 | LDR     R3, [R3,#8]\n0x000A768C | 0C 20 1B E5 | LDR     R2, [R11,#concat]\n0x000A7690 | 03 30 42 E0 | SUB     R3, R2, R3\n0x000A7694 | 03 00 A0 E1 | MOV     R0, R3; nbytes\n0x000A7698 | F8 B0 FF EB | BL      stalloc\n0x000A769C | 08 00 0B E5 | STR     R0, [R11,#p]\n0x000A76A0 | 10 10 E0 E3 | MOV     R1, #0xFFFFFFEF; mask\n0x000A76A4 | 08 00 1B E5 | LDR     R0, [R11,#p]; s\n0x000A76A8 | 98 FF FF EB | BL      evalstring\n0x000A76AC | 10 30 9F E5 | LDR     R3, =exitstatus\n0x000A76B0 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000A76B4 | 03 00 A0 E1 | MOV     R0, R3\n0x000A76B8 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000A76BC | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stddef.h>\n\nextern char *ash_ptr_to_globals_memstack;\nextern char exitstatus;\nextern void stack_putstr(char **p, char *s);\nextern void _STPUTC(char c, char **p);\nextern void *stalloc(size_t nbytes);\nextern void evalstring(char *s, int mask);\n\nint main(int argc, char **argv) {\n    char **p;\n    char *concat;\n    if (argv[1] == NULL) {\n        return exitstatus;\n    }\n    argv += 2;\n    p = argv;\n    if (*p == NULL) {\n        return exitstatus;\n    }\n    do {\n        concat = ash_ptr_to_globals_memstack + 8;\n        stack_putstr(&concat, *p);\n        argv++;\n        p = argv;\n        if (*p != NULL) {\n            _STPUTC(' ', &concat);\n        }\n    } while (*p != NULL);\n    _STPUTC('\\0', &concat);\n    char *s = stalloc(concat - (ash_ptr_to_globals_memstack + 8));\n    evalstring(s, 0xFFFFFFEF);\n    return exitstatus;\n}\n```"
    },
    {
        "func_name": "getstatus",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000982A8 | 04 B0 2D E5 | PUSH    {R11}\n0x000982AC | 00 B0 8D E2 | ADD     R11, SP, #0\n0x000982B0 | 1C D0 4D E2 | SUB     SP, SP, #0x1C\n0x000982B4 | 18 00 0B E5 | STR     R0, [R11,#job]\n0x000982B8 | 18 30 1B E5 | LDR     R3, [R11,#job]\n0x000982BC | 0C 20 93 E5 | LDR     R2, [R3,#0xC]\n0x000982C0 | 18 30 1B E5 | LDR     R3, [R11,#job]\n0x000982C4 | B4 31 D3 E1 | LDRH    R3, [R3,#0x14]\n0x000982C8 | 03 10 A0 E1 | MOV     R1, R3\n0x000982CC | 01 30 A0 E1 | MOV     R3, R1\n0x000982D0 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000982D4 | 01 30 83 E0 | ADD     R3, R3, R1\n0x000982D8 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000982DC | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x000982E0 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000982E4 | 10 30 0B E5 | STR     R3, [R11,#ps]\n0x000982E8 | 10 30 1B E5 | LDR     R3, [R11,#ps]\n0x000982EC | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000982F0 | 08 30 0B E5 | STR     R3, [R11,#status]\n0x000982F4 | D0 30 9F E5 | LDR     R3, =ash_ptr_to_globals_misc\n0x000982F8 | 00 30 93 E5 | LDR     R3, [R3]\n0x000982FC | 3F 30 D3 E5 | LDRB    R3, [R3,#0x3F]\n0x00098300 | 00 00 53 E3 | CMP     R3, #0\n0x00098304 | 0E 00 00 0A | BEQ     loc_98344\n0x00098308 | 02 00 00 EA | B       loc_98318\n0x0009830C | 10 30 1B E5 | LDR     R3, [R11,#ps]\n0x00098310 | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x00098314 | 08 30 0B E5 | STR     R3, [R11,#status]\n0x00098318 | 08 30 1B E5 | LDR     R3, [R11,#status]\n0x0009831C | 00 00 53 E3 | CMP     R3, #0\n0x00098320 | 07 00 00 1A | BNE     loc_98344\n0x00098324 | 10 30 1B E5 | LDR     R3, [R11,#ps]\n0x00098328 | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x0009832C | 10 30 0B E5 | STR     R3, [R11,#ps]\n0x00098330 | 18 30 1B E5 | LDR     R3, [R11,#job]\n0x00098334 | 0C 30 93 E5 | LDR     R3, [R3,#0xC]\n0x00098338 | 10 20 1B E5 | LDR     R2, [R11,#ps]\n0x0009833C | 03 00 52 E1 | CMP     R2, R3\n0x00098340 | F1 FF FF 2A | BCS     loc_9830C\n0x00098344 | 08 30 1B E5 | LDR     R3, [R11,#status]\n0x00098348 | 43 34 A0 E1 | MOV     R3, R3,ASR#8\n0x0009834C | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x00098350 | 0C 30 0B E5 | STR     R3, [R11,#retval]\n0x00098354 | 08 30 1B E5 | LDR     R3, [R11,#status]\n0x00098358 | 7F 30 03 E2 | AND     R3, R3, #0x7F\n0x0009835C | 00 00 53 E3 | CMP     R3, #0\n0x00098360 | 14 00 00 0A | BEQ     loc_983B8\n0x00098364 | 08 30 1B E5 | LDR     R3, [R11,#status]\n0x00098368 | 43 34 A0 E1 | MOV     R3, R3,ASR#8\n0x0009836C | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x00098370 | 0C 30 0B E5 | STR     R3, [R11,#retval]\n0x00098374 | 08 30 1B E5 | LDR     R3, [R11,#status]\n0x00098378 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x0009837C | 7F 00 53 E3 | CMP     R3, #0x7F\n0x00098380 | 09 00 00 0A | BEQ     loc_983AC\n0x00098384 | 08 30 1B E5 | LDR     R3, [R11,#status]\n0x00098388 | 7F 30 03 E2 | AND     R3, R3, #0x7F\n0x0009838C | 0C 30 0B E5 | STR     R3, [R11,#retval]\n0x00098390 | 0C 30 1B E5 | LDR     R3, [R11,#retval]\n0x00098394 | 02 00 53 E3 | CMP     R3, #2\n0x00098398 | 03 00 00 1A | BNE     loc_983AC\n0x0009839C | 18 20 1B E5 | LDR     R2, [R11,#job]\n0x000983A0 | 17 30 D2 E5 | LDRB    R3, [R2,#0x17]\n0x000983A4 | 01 30 83 E3 | ORR     R3, R3, #1\n0x000983A8 | 17 30 C2 E5 | STRB    R3, [R2,#0x17]\n0x000983AC | 0C 30 1B E5 | LDR     R3, [R11,#retval]\n0x000983B0 | 80 30 83 E2 | ADD     R3, R3, #0x80\n0x000983B4 | 0C 30 0B E5 | STR     R3, [R11,#retval]\n0x000983B8 | 0C 30 1B E5 | LDR     R3, [R11,#retval]\n0x000983BC | 03 00 A0 E1 | MOV     R0, R3\n0x000983C0 | 00 D0 8B E2 | MOV     SP, R11\n0x000983C4 | 04 B0 9D E4 | POP     {R11}\n0x000983C8 | 1E FF 2F E1 | BX      LR",
        "output": "```c\nint function(int job) {\n    int status, retval;\n    int *ps = (int *)(*(int *)(job + 0xC) + (((*(short *)(job + 0x14) * 9) - 12) << 2));\n    status = *(ps + 1);\n    if (*(char *)(*ash_ptr_to_globals_misc + 0x3F) != 0) {\n        do {\n            status = *(ps + 1);\n            ps -= 3;\n        } while (ps >= (int *)(*(int *)(job + 0xC)));\n    }\n    retval = (status >> 8) & 0xFF;\n    if ((status & 0x7F) != 0) {\n        retval = (status >> 8) & 0xFF;\n        if ((status & 0xFF) != 0x7F) {\n            retval = status & 0x7F;\n            if (retval == 2) {\n                char *job_byte = (char *)job + 0x17;\n                *job_byte |= 1;\n            }\n        }\n        retval += 0x80;\n    }\n    return retval;\n}\n```"
    },
    {
        "func_name": "validate_tm_time",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0001BBE8 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0001BBEC | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0001BBF0 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x0001BBF4 | 10 00 0B E5 | STR     R0, [R11,#date_str]\n0x0001BBF8 | 14 10 0B E5 | STR     R1, [R11,#ptm]\n0x0001BBFC | 14 00 1B E5 | LDR     R0, [R11,#ptm]; tp\n0x0001BC00 | 8F E4 FF EB | BL      mktime\n0x0001BC04 | 08 00 0B E5 | STR     R0, [R11,#t]\n0x0001BC08 | 08 30 1B E5 | LDR     R3, [R11,#t]\n0x0001BC0C | 01 00 73 E3 | CMN     R3, #1\n0x0001BC10 | 02 00 00 1A | BNE     loc_1BC20\n0x0001BC14 | 10 10 1B E5 | LDR     R1, [R11,#date_str]\n0x0001BC18 | 10 00 9F E5 | LDR     R0, =bb_msg_invalid_date; \"invalid date '%s'\"\n0x0001BC1C | 5D F4 FF EB | BL      bb_error_msg_and_die\n0x0001BC20 | 08 30 1B E5 | LDR     R3, [R11,#t]\n0x0001BC24 | 03 00 A0 E1 | MOV     R0, R3\n0x0001BC28 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0001BC2C | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <time.h>\n\nvoid function(char *date_str, struct tm *ptm) {\n    time_t t = mktime(ptm);\n    if (t == (time_t)-1) {\n        bb_error_msg_and_die(\"invalid date '%s'\", date_str);\n    }\n}\n```"
    },
    {
        "func_name": "print_stats_and_exit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00058E0C | 70 48 2D E9 | PUSH    {R4-R6,R11,LR}\n0x00058E10 | 10 B0 8D E2 | ADD     R11, SP, #0x10\n0x00058E14 | 24 D0 4D E2 | SUB     SP, SP, #0x24\n0x00058E18 | 20 00 0B E5 | STR     R0, [R11,#junk]\n0x00058E1C | 01 10 A0 E3 | MOV     R1, #1; handler\n0x00058E20 | 02 00 A0 E3 | MOV     R0, #2; sig\n0x00058E24 | 51 F0 FE EB | BL      signal\n0x00058E28 | 48 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058E2C | 58 30 93 E5 | LDR     R3, [R3,#(dword_18FA30 - 0x18F9D8)]\n0x00058E30 | 03 10 A0 E1 | MOV     R1, R3\n0x00058E34 | 40 02 9F E5 | LDR     R0, =aSPingStatistic; \"\\n--- %s ping statistics ---\\n\"\n0x00058E38 | E6 EF FE EB | BL      printf\n0x00058E3C | 34 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058E40 | 1C 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xB - 0x18F9D8)]\n0x00058E44 | 03 10 A0 E1 | MOV     R1, R3\n0x00058E48 | 30 02 9F E5 | LDR     R0, =aLuPacketsTrans; \"%lu packets transmitted, \"\n0x00058E4C | E1 EF FE EB | BL      printf\n0x00058E50 | 20 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058E54 | 20 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x00058E58 | 03 10 A0 E1 | MOV     R1, R3\n0x00058E5C | 20 02 9F E5 | LDR     R0, =aLuPacketsRecei; \"%lu packets received, \"\n0x00058E60 | DC EF FE EB | BL      printf\n0x00058E64 | 0C 32 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058E68 | 24 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0x13 - 0x18F9D8)]\n0x00058E6C | 00 00 53 E3 | CMP     R3, #0\n0x00058E70 | 04 00 00 0A | BEQ     loc_58E88\n0x00058E74 | FC 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058E78 | 24 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0x13 - 0x18F9D8)]\n0x00058E7C | 03 10 A0 E1 | MOV     R1, R3\n0x00058E80 | 00 02 9F E5 | LDR     R0, =aLuDuplicates; \"%lu duplicates, \"\n0x00058E84 | D3 EF FE EB | BL      printf\n0x00058E88 | E8 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058E8C | 1C 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xB - 0x18F9D8)]\n0x00058E90 | 00 00 53 E3 | CMP     R3, #0\n0x00058E94 | 13 00 00 0A | BEQ     loc_58EE8\n0x00058E98 | D8 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058E9C | 1C 20 93 E5 | LDR     R2, [R3,#(bb_common_bufsiz1.c_cc+0xB - 0x18F9D8)]\n0x00058EA0 | D0 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058EA4 | 20 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x00058EA8 | 03 20 42 E0 | SUB     R2, R2, R3\n0x00058EAC | 02 30 A0 E1 | MOV     R3, R2\n0x00058EB0 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00058EB4 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00058EB8 | 03 21 A0 E1 | MOV     R2, R3,LSL#2\n0x00058EBC | 02 30 83 E0 | ADD     R3, R3, R2\n0x00058EC0 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00058EC4 | 03 20 A0 E1 | MOV     R2, R3\n0x00058EC8 | A8 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058ECC | 1C 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xB - 0x18F9D8)]\n0x00058ED0 | A0 41 9F E5 | LDR     R4, =bb_common_bufsiz1\n0x00058ED4 | 03 10 A0 E1 | MOV     R1, R3\n0x00058ED8 | 02 00 A0 E1 | MOV     R0, R2\n0x00058EDC | 69 F8 03 EB | BL      __udivsi3\n0x00058EE0 | 00 30 A0 E1 | MOV     R3, R0\n0x00058EE4 | 1C 30 84 E5 | STR     R3, [R4,#(bb_common_bufsiz1.c_cc+0xB - 0x18F9D8)]\n0x00058EE8 | 88 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058EEC | 1C 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xB - 0x18F9D8)]\n0x00058EF0 | 03 10 A0 E1 | MOV     R1, R3\n0x00058EF4 | 90 01 9F E5 | LDR     R0, =aLuPacketLoss; \"%lu%% packet loss\\n\"\n0x00058EF8 | B6 EF FE EB | BL      printf\n0x00058EFC | 74 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058F00 | 2C 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0x1B - 0x18F9D8)]\n0x00058F04 | 01 00 73 E3 | CMN     R3, #1\n0x00058F08 | 47 00 00 0A | BEQ     loc_5902C\n0x00058F0C | 64 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058F10 | 38 10 83 E2 | ADD     R1, R3, #0x38 ; '8'\n0x00058F14 | 03 00 91 E8 | LDM     R1, {R0,R1}\n0x00058F18 | 58 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058F1C | 20 20 93 E5 | LDR     R2, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x00058F20 | 50 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058F24 | 24 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0x13 - 0x18F9D8)]\n0x00058F28 | 03 30 82 E0 | ADD     R3, R2, R3\n0x00058F2C | 00 40 A0 E3 | MOV     R4, #0\n0x00058F30 | 03 20 A0 E1 | MOV     R2, R3\n0x00058F34 | 04 30 A0 E1 | MOV     R3, R4\n0x00058F38 | F5 FC 03 EB | BL      __aeabi_uldivmod\n0x00058F3C | 00 30 A0 E1 | MOV     R3, R0\n0x00058F40 | 01 40 A0 E1 | MOV     R4, R1\n0x00058F44 | 18 30 0B E5 | STR     R3, [R11,#tavg]\n0x00058F48 | 28 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058F4C | 2C 00 93 E5 | LDR     R0, [R3,#(bb_common_bufsiz1.c_cc+0x1B - 0x18F9D8)]\n0x00058F50 | 38 21 9F E5 | LDR     R2, =0x10624DD3\n0x00058F54 | 92 10 83 E0 | UMULL   R1, R3, R2, R0\n0x00058F58 | 23 43 A0 E1 | MOV     R4, R3,LSR#6\n0x00058F5C | 14 31 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058F60 | 2C 20 93 E5 | LDR     R2, [R3,#(bb_common_bufsiz1.c_cc+0x1B - 0x18F9D8)]\n0x00058F64 | 24 31 9F E5 | LDR     R3, =0x10624DD3\n0x00058F68 | 92 13 80 E0 | UMULL   R1, R0, R2, R3\n0x00058F6C | 20 03 A0 E1 | MOV     R0, R0,LSR#6\n0x00058F70 | 00 30 A0 E1 | MOV     R3, R0\n0x00058F74 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x00058F78 | 00 30 43 E0 | SUB     R3, R3, R0\n0x00058F7C | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00058F80 | 00 30 83 E0 | ADD     R3, R3, R0\n0x00058F84 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x00058F88 | 03 00 42 E0 | SUB     R0, R2, R3\n0x00058F8C | 18 C0 1B E5 | LDR     R12, [R11,#tavg]\n0x00058F90 | F8 20 9F E5 | LDR     R2, =0x10624DD3\n0x00058F94 | 92 1C 83 E0 | UMULL   R1, R3, R2, R12\n0x00058F98 | 23 53 A0 E1 | MOV     R5, R3,LSR#6\n0x00058F9C | 18 10 1B E5 | LDR     R1, [R11,#tavg]\n0x00058FA0 | E8 30 9F E5 | LDR     R3, =0x10624DD3\n0x00058FA4 | 91 23 8C E0 | UMULL   R2, R12, R1, R3\n0x00058FA8 | 2C 23 A0 E1 | MOV     R2, R12,LSR#6\n0x00058FAC | 02 30 A0 E1 | MOV     R3, R2\n0x00058FB0 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x00058FB4 | 02 30 43 E0 | SUB     R3, R3, R2\n0x00058FB8 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00058FBC | 02 30 83 E0 | ADD     R3, R3, R2\n0x00058FC0 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x00058FC4 | 03 20 41 E0 | SUB     R2, R1, R3\n0x00058FC8 | A8 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058FCC | 30 E0 93 E5 | LDR     LR, [R3,#(bb_common_bufsiz1.c_cc+0x1F - 0x18F9D8)]\n0x00058FD0 | B8 10 9F E5 | LDR     R1, =0x10624DD3\n0x00058FD4 | 91 CE 83 E0 | UMULL   R12, R3, R1, LR\n0x00058FD8 | 23 E3 A0 E1 | MOV     LR, R3,LSR#6\n0x00058FDC | 94 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00058FE0 | 30 C0 93 E5 | LDR     R12, [R3,#(bb_common_bufsiz1.c_cc+0x1F - 0x18F9D8)]\n0x00058FE4 | A4 30 9F E5 | LDR     R3, =0x10624DD3\n0x00058FE8 | 9C 13 86 E0 | UMULL   R1, R6, R12, R3\n0x00058FEC | 26 13 A0 E1 | MOV     R1, R6,LSR#6\n0x00058FF0 | 01 30 A0 E1 | MOV     R3, R1\n0x00058FF4 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x00058FF8 | 01 30 43 E0 | SUB     R3, R3, R1\n0x00058FFC | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00059000 | 01 30 83 E0 | ADD     R3, R3, R1\n0x00059004 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x00059008 | 03 10 4C E0 | SUB     R1, R12, R3\n0x0005900C | 08 10 8D E5 | STR     R1, [SP,#0x34+var_2C]\n0x00059010 | 04 E0 8D E5 | STR     LR, [SP,#0x34+var_30]\n0x00059014 | 00 20 8D E5 | STR     R2, [SP,#0x34+var_34]\n0x00059018 | 05 30 A0 E1 | MOV     R3, R5\n0x0005901C | 00 20 A0 E1 | MOV     R2, R0\n0x00059020 | 04 10 A0 E1 | MOV     R1, R4\n0x00059024 | 68 00 9F E5 | LDR     R0, =aRoundTripMinAv; \"round-trip min/avg/max = %u.%03u/%u.%03\"...\n0x00059028 | 6A EF FE EB | BL      printf\n0x0005902C | 44 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00059030 | 20 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x00059034 | 00 00 53 E3 | CMP     R3, #0\n0x00059038 | 09 00 00 0A | BEQ     loc_59064\n0x0005903C | 34 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00059040 | 40 30 93 E5 | LDR     R3, [R3,#(dst.data - 0x18F9D8)]\n0x00059044 | 00 00 53 E3 | CMP     R3, #0\n0x00059048 | 07 00 00 0A | BEQ     loc_5906C\n0x0005904C | 24 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00059050 | 20 20 93 E5 | LDR     R2, [R3,#(bb_common_bufsiz1.c_cc+0xF - 0x18F9D8)]\n0x00059054 | 1C 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x00059058 | 14 30 93 E5 | LDR     R3, [R3,#(bb_common_bufsiz1.c_cc+3 - 0x18F9D8)]\n0x0005905C | 03 00 52 E1 | CMP     R2, R3\n0x00059060 | 01 00 00 2A | BCS     loc_5906C\n0x00059064 | 01 30 A0 E3 | MOV     R3, #1\n0x00059068 | 00 00 00 EA | B       loc_59070\n0x0005906C | 00 30 A0 E3 | MOV     R3, #0\n0x00059070 | 03 00 A0 E1 | MOV     R0, R3; status\n0x00059074 | 2E F1 FE EB | BL      exit",
        "output": "```c\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nunsigned int bb_common_bufsiz1;\nunsigned int tavg;\n\nvoid print_statistics() {\n    signal(2, (void *)1);\n    printf(\"\\n--- %s ping statistics ---\\n\", bb_common_bufsiz1);\n    printf(\"%lu packets transmitted, \", bb_common_bufsiz1.c_cc[11]);\n    printf(\"%lu packets received, \", bb_common_bufsiz1.c_cc[15]);\n    if (bb_common_bufsiz1.c_cc[19] != 0) {\n        printf(\"%lu duplicates, \", bb_common_bufsiz1.c_cc[19]);\n    }\n    if (bb_common_bufsiz1.c_cc[11] != 0) {\n        unsigned int lost_packets = bb_common_bufsiz1.c_cc[11] - bb_common_bufsiz1.c_cc[15];\n        lost_packets = lost_packets * 100;\n        lost_packets = lost_packets / bb_common_bufsiz1.c_cc[11];\n        bb_common_bufsiz1.c_cc[11] = lost_packets;\n    }\n    printf(\"%lu%% packet loss\\n\", bb_common_bufsiz1.c_cc[11]);\n    if (bb_common_bufsiz1.c_cc[27] >= 1) {\n        unsigned int min, avg, max;\n        min = bb_common_bufsiz1.c_cc[27];\n        unsigned int total = bb_common_bufsiz1.c_cc[15] + bb_common_bufsiz1.c_cc[19];\n        unsigned int count = 0;\n        __aeabi_uldivmod(total, count, &avg, &count);\n        tavg = avg;\n        unsigned int temp = bb_common_bufsiz1.c_cc[27] * 0x10624DD3;\n        max = (temp >> 6) - (temp >> 31);\n        printf(\"round-trip min/avg/max = %u.%03u/%u.%03u/%u.%03u ms\\n\", min, avg, max);\n    }\n    if (bb_common_bufsiz1.c_cc[15] != 0) {\n        if (bb_common_bufsiz1.dst.data != 0) {\n            if (bb_common_bufsiz1.c_cc[15] < bb_common_bufsiz1.c_cc[3]) {\n                exit(1);\n            }\n        }\n    }\n    exit(0);\n}\n```"
    },
    {
        "func_name": "fb_setpal",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0002914C | 00 48 2D E9 | PUSH    {R11,LR}\n0x00029150 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00029154 | 62 DE 4D E2 | SUB     SP, SP, #0x620\n0x00029158 | 08 D0 4D E2 | SUB     SP, SP, #8\n0x0002915C | 28 06 0B E5 | STR     R0, [R11,#fd]\n0x00029160 | 00 30 A0 E3 | MOV     R3, #0\n0x00029164 | 08 30 0B E5 | STR     R3, [R11,#i]\n0x00029168 | 44 00 00 EA | B       loc_29280\n0x0002916C | 08 30 1B E5 | LDR     R3, [R11,#i]\n0x00029170 | A3 22 A0 E1 | MOV     R2, R3,LSR#5\n0x00029174 | 02 30 A0 E1 | MOV     R3, R2\n0x00029178 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x0002917C | 02 30 83 E0 | ADD     R3, R3, R2\n0x00029180 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x00029184 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00029188 | 83 24 A0 E1 | MOV     R2, R3,LSL#9\n0x0002918C | 02 30 83 E0 | ADD     R3, R3, R2\n0x00029190 | 23 31 A0 E1 | MOV     R3, R3,LSR#2\n0x00029194 | 03 38 A0 E1 | MOV     R3, R3,LSL#16\n0x00029198 | 23 28 A0 E1 | MOV     R2, R3,LSR#16\n0x0002919C | 04 30 4B E2 | SUB     R3, R11, #-var_4\n0x000291A0 | 87 1F 43 E2 | SUB     R1, R3, #0x21C\n0x000291A4 | 08 30 1B E5 | LDR     R3, [R11,#i]\n0x000291A8 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x000291AC | 03 30 81 E0 | ADD     R3, R1, R3\n0x000291B0 | B0 20 C3 E1 | STRH    R2, [R3]\n0x000291B4 | 08 30 1B E5 | LDR     R3, [R11,#i]\n0x000291B8 | 23 31 A0 E1 | MOV     R3, R3,LSR#2\n0x000291BC | 07 20 03 E2 | AND     R2, R3, #7\n0x000291C0 | 02 30 A0 E1 | MOV     R3, R2\n0x000291C4 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x000291C8 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000291CC | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x000291D0 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000291D4 | 83 24 A0 E1 | MOV     R2, R3,LSL#9\n0x000291D8 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000291DC | 23 31 A0 E1 | MOV     R3, R3,LSR#2\n0x000291E0 | 03 38 A0 E1 | MOV     R3, R3,LSL#16\n0x000291E4 | 23 28 A0 E1 | MOV     R2, R3,LSR#16\n0x000291E8 | 04 30 4B E2 | SUB     R3, R11, #-var_4\n0x000291EC | 41 3E 43 E2 | SUB     R3, R3, #0x410\n0x000291F0 | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x000291F4 | 08 10 1B E5 | LDR     R1, [R11,#i]\n0x000291F8 | 81 10 A0 E1 | MOV     R1, R1,LSL#1\n0x000291FC | 01 30 83 E0 | ADD     R3, R3, R1\n0x00029200 | B0 20 C3 E1 | STRH    R2, [R3]\n0x00029204 | 08 30 1B E5 | LDR     R3, [R11,#i]\n0x00029208 | 03 38 A0 E1 | MOV     R3, R3,LSL#16\n0x0002920C | 23 38 A0 E1 | MOV     R3, R3,LSR#16\n0x00029210 | 03 30 03 E2 | AND     R3, R3, #3\n0x00029214 | 03 38 A0 E1 | MOV     R3, R3,LSL#16\n0x00029218 | 23 38 A0 E1 | MOV     R3, R3,LSR#16\n0x0002921C | 03 20 A0 E1 | MOV     R2, R3\n0x00029220 | 02 21 A0 E1 | MOV     R2, R2,LSL#2\n0x00029224 | 03 30 82 E0 | ADD     R3, R2, R3\n0x00029228 | 03 20 A0 E1 | MOV     R2, R3\n0x0002922C | 02 12 A0 E1 | MOV     R1, R2,LSL#4\n0x00029230 | 03 20 A0 E1 | MOV     R2, R3\n0x00029234 | 01 30 A0 E1 | MOV     R3, R1\n0x00029238 | 03 30 82 E0 | ADD     R3, R2, R3\n0x0002923C | 03 20 A0 E1 | MOV     R2, R3\n0x00029240 | 02 14 A0 E1 | MOV     R1, R2,LSL#8\n0x00029244 | 03 20 A0 E1 | MOV     R2, R3\n0x00029248 | 01 30 A0 E1 | MOV     R3, R1\n0x0002924C | 03 30 82 E0 | ADD     R3, R2, R3\n0x00029250 | 03 38 A0 E1 | MOV     R3, R3,LSL#16\n0x00029254 | 23 28 A0 E1 | MOV     R2, R3,LSR#16\n0x00029258 | 04 30 4B E2 | SUB     R3, R11, #-var_4\n0x0002925C | 61 3E 43 E2 | SUB     R3, R3, #0x610\n0x00029260 | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x00029264 | 08 10 1B E5 | LDR     R1, [R11,#i]\n0x00029268 | 81 10 A0 E1 | MOV     R1, R1,LSL#1\n0x0002926C | 01 30 83 E0 | ADD     R3, R3, R1\n0x00029270 | B0 20 C3 E1 | STRH    R2, [R3]\n0x00029274 | 08 30 1B E5 | LDR     R3, [R11,#i]\n0x00029278 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0002927C | 08 30 0B E5 | STR     R3, [R11,#i]\n0x00029280 | 08 30 1B E5 | LDR     R3, [R11,#i]\n0x00029284 | FF 00 53 E3 | CMP     R3, #0xFF\n0x00029288 | B7 FF FF 9A | BLS     loc_2916C\n0x0002928C | 00 30 A0 E3 | MOV     R3, #0\n0x00029290 | 20 30 0B E5 | STR     R3, [R11,#cmap]\n0x00029294 | 01 3C A0 E3 | MOV     R3, #0x100\n0x00029298 | 1C 30 0B E5 | STR     R3, [R11,#cmap.len]\n0x0002929C | 22 3E 4B E2 | SUB     R3, R11, #-red\n0x000292A0 | 18 30 0B E5 | STR     R3, [R11,#cmap.red]\n0x000292A4 | 41 3E 4B E2 | SUB     R3, R11, #-(green+0x10)\n0x000292A8 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000292AC | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x000292B0 | 14 30 0B E5 | STR     R3, [R11,#cmap.green]\n0x000292B4 | 61 3E 4B E2 | SUB     R3, R11, #-(blue+0x10)\n0x000292B8 | 04 30 43 E2 | SUB     R3, R3, #4\n0x000292BC | 0C 30 43 E2 | SUB     R3, R3, #0xC\n0x000292C0 | 10 30 0B E5 | STR     R3, [R11,#cmap.blue]\n0x000292C4 | 00 30 A0 E3 | MOV     R3, #0\n0x000292C8 | 0C 30 0B E5 | STR     R3, [R11,#cmap.transp]\n0x000292CC | 20 20 4B E2 | SUB     R2, R11, #-cmap; argp\n0x000292D0 | 14 30 9F E5 | LDR     R3, =aFbioputcmap; \"FBIOPUTCMAP\"\n0x000292D4 | 14 10 9F E5 | LDR     R1, =0x4605; request\n0x000292D8 | 28 06 1B E5 | LDR     R0, [R11,#fd]; fd\n0x000292DC | 82 C5 FF EB | BL      bb_xioctl\n0x000292E0 | 00 00 A0 E1 | NOP\n0x000292E4 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000292E8 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(int fd) {\n    struct {\n        void *cmap;\n        int len;\n        void *red;\n        void *green;\n        void *blue;\n        void *transp;\n    } cmap;\n    unsigned short i, r, g, b;\n\n    for (i = 0; i <= 0xFF; i++) {\n        r = (i >> 2) & 0x3F;\n        r |= r << 6;\n        cmap.red = (void *)((char *)&cmap - 0x21C + (i << 1));\n        *(unsigned short *)cmap.red = r;\n\n        g = (i >> 2) & 0x07;\n        g |= (g << 3) | (g << 6) | (g << 9);\n        cmap.green = (void *)((char *)&cmap - 0x41C + (i << 1));\n        *(unsigned short *)cmap.green = g;\n\n        b = i & 0x03;\n        b |= (b << 2) | (b << 4) | (b << 6) | (b << 8);\n        cmap.blue = (void *)((char *)&cmap - 0x61C + (i << 1));\n        *(unsigned short *)cmap.blue = b;\n    }\n\n    cmap.cmap = 0;\n    cmap.len = 0x100;\n    cmap.red = (void *)((char *)&cmap - 0x21C);\n    cmap.green = (void *)((char *)&cmap - 0x41C);\n    cmap.blue = (void *)((char *)&cmap - 0x61C);\n    cmap.transp = 0;\n\n    bb_xioctl(fd, 0x4605, &cmap);\n}\n```"
    },
    {
        "func_name": "blocking_wait_with_raise_on_sig",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00097D88 | 00 48 2D E9 | PUSH    {R11,LR}\n0x00097D8C | 04 B0 8D E2 | ADD     R11, SP, #4\n0x00097D90 | 08 D0 4D E2 | SUB     SP, SP, #8\n0x00097D94 | 00 10 A0 E3 | MOV     R1, #0; job\n0x00097D98 | 00 00 A0 E3 | MOV     R0, #0; wait_flags\n0x00097D9C | 44 FF FF EB | BL      dowait\n0x00097DA0 | 08 00 0B E5 | STR     R0, [R11,#pid]\n0x00097DA4 | 08 30 1B E5 | LDR     R3, [R11,#pid]\n0x00097DA8 | 00 00 53 E3 | CMP     R3, #0\n0x00097DAC | 06 00 00 CA | BGT     loc_97DCC\n0x00097DB0 | 24 30 9F E5 | LDR     R3, =ash_ptr_to_globals_misc\n0x00097DB4 | 00 30 93 E5 | LDR     R3, [R3]\n0x00097DB8 | 24 30 93 E5 | LDR     R3, [R3,#0x24]\n0x00097DBC | 00 00 53 E3 | CMP     R3, #0\n0x00097DC0 | 01 00 00 0A | BEQ     loc_97DCC\n0x00097DC4 | 05 00 A0 E3 | MOV     R0, #5; e\n0x00097DC8 | A7 ED FF EB | BL      raise_exception\n0x00097DCC | 08 30 1B E5 | LDR     R3, [R11,#pid]\n0x00097DD0 | 03 00 A0 E1 | MOV     R0, R3\n0x00097DD4 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00097DD8 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nint dowait(int job, int wait_flags);\n\nvoid raise_exception(int e);\n\nstruct globals_misc {\n    // other members\n    int some_member_at_offset_24;\n    // other members\n};\n\nextern struct globals_misc *ash_ptr_to_globals_misc;\n\nint main() {\n    int pid = dowait(0, 0);\n    if (pid > 0) {\n        return pid;\n    }\n\n    if (ash_ptr_to_globals_misc->some_member_at_offset_24 != 0) {\n        raise_exception(5);\n    }\n\n    return pid;\n}\n```"
    },
    {
        "func_name": "read_to_buf",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0014C7B4 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0014C7B8 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0014C7BC | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x0014C7C0 | 10 00 0B E5 | STR     R0, [R11,#filename]\n0x0014C7C4 | 14 10 0B E5 | STR     R1, [R11,#buf]\n0x0014C7C8 | 00 30 E0 E3 | MOV     R3, #0xFFFFFFFF\n0x0014C7CC | 08 30 0B E5 | STR     R3, [R11,#ret]\n0x0014C7D0 | 00 10 A0 E3 | MOV     R1, #0\n0x0014C7D4 | 10 00 1B E5 | LDR     R0, [R11,#filename]\n0x0014C7D8 | EF 22 FB EB | BL      open64\n0x0014C7DC | 0C 00 0B E5 | STR     R0, [R11,#fd]\n0x0014C7E0 | 0C 30 1B E5 | LDR     R3, [R11,#fd]\n0x0014C7E4 | 00 00 53 E3 | CMP     R3, #0\n0x0014C7E8 | 06 00 00 BA | BLT     loc_14C808\n0x0014C7EC | 40 20 9F E5 | LDR     R2, =0x3FF; nbytes\n0x0014C7F0 | 14 10 1B E5 | LDR     R1, [R11,#buf]; buf\n0x0014C7F4 | 0C 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x0014C7F8 | 88 21 FB EB | BL      read\n0x0014C7FC | 08 00 0B E5 | STR     R0, [R11,#ret]\n0x0014C800 | 0C 00 1B E5 | LDR     R0, [R11,#fd]; fd\n0x0014C804 | 42 25 FB EB | BL      close\n0x0014C808 | 08 30 1B E5 | LDR     R3, [R11,#ret]\n0x0014C80C | C3 3F C3 E1 | BIC     R3, R3, R3,ASR#31\n0x0014C810 | 03 20 A0 E1 | MOV     R2, R3\n0x0014C814 | 14 30 1B E5 | LDR     R3, [R11,#buf]\n0x0014C818 | 02 30 83 E0 | ADD     R3, R3, R2\n0x0014C81C | 00 20 A0 E3 | MOV     R2, #0\n0x0014C820 | 00 20 C3 E5 | STRB    R2, [R3]\n0x0014C824 | 08 30 1B E5 | LDR     R3, [R11,#ret]\n0x0014C828 | 03 00 A0 E1 | MOV     R0, R3\n0x0014C82C | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0014C830 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nint read_file(const char *filename, char *buf) {\n    int fd = open64(filename, 0);\n    if (fd < 0) {\n        return -1;\n    }\n    int nbytes = 0x3FF;\n    int ret = read(fd, buf, nbytes);\n    close(fd);\n    if (ret >= 0) {\n        buf[ret] = '\\0';\n    }\n    return ret;\n}\n```"
    },
    {
        "func_name": "get_cached",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0014C608 | 10 48 2D E9 | PUSH    {R4,R11,LR}\n0x0014C60C | 08 B0 8D E2 | ADD     R11, SP, #8\n0x0014C610 | 1C D0 4D E2 | SUB     SP, SP, #0x1C\n0x0014C614 | 18 00 0B E5 | STR     R0, [R11,#cp]\n0x0014C618 | 1C 10 0B E5 | STR     R1, [R11,#id]\n0x0014C61C | 20 20 0B E5 | STR     R2, [R11,#x2x_utoa]\n0x0014C620 | 00 30 A0 E3 | MOV     R3, #0\n0x0014C624 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x0014C628 | 12 00 00 EA | B       loc_14C678\n0x0014C62C | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C630 | 00 20 93 E5 | LDR     R2, [R3]\n0x0014C634 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x0014C638 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x0014C63C | 03 30 82 E0 | ADD     R3, R2, R3\n0x0014C640 | 00 30 93 E5 | LDR     R3, [R3]\n0x0014C644 | 1C 20 1B E5 | LDR     R2, [R11,#id]\n0x0014C648 | 03 00 52 E1 | CMP     R2, R3\n0x0014C64C | 06 00 00 1A | BNE     loc_14C66C\n0x0014C650 | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C654 | 00 20 93 E5 | LDR     R2, [R3]\n0x0014C658 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x0014C65C | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x0014C660 | 03 30 82 E0 | ADD     R3, R2, R3\n0x0014C664 | 04 30 83 E2 | ADD     R3, R3, #4\n0x0014C668 | 31 00 00 EA | B       loc_14C734\n0x0014C66C | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x0014C670 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0014C674 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x0014C678 | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C67C | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x0014C680 | 10 20 1B E5 | LDR     R2, [R11,#i]\n0x0014C684 | 03 00 52 E1 | CMP     R2, R3\n0x0014C688 | E7 FF FF BA | BLT     loc_14C62C\n0x0014C68C | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C690 | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x0014C694 | 01 10 83 E2 | ADD     R1, R3, #1\n0x0014C698 | 18 20 1B E5 | LDR     R2, [R11,#cp]\n0x0014C69C | 04 10 82 E5 | STR     R1, [R2,#4]\n0x0014C6A0 | 10 30 0B E5 | STR     R3, [R11,#i]\n0x0014C6A4 | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C6A8 | 00 30 93 E5 | LDR     R3, [R3]\n0x0014C6AC | 10 20 1B E5 | LDR     R2, [R11,#i]; idx\n0x0014C6B0 | 88 10 9F E5 | LDR     R1, =0x2002; sizeof_and_shift\n0x0014C6B4 | 03 00 A0 E1 | MOV     R0, R3; vector\n0x0014C6B8 | 01 2A 00 EB | BL      xrealloc_vector_helper\n0x0014C6BC | 00 20 A0 E1 | MOV     R2, R0\n0x0014C6C0 | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C6C4 | 00 20 83 E5 | STR     R2, [R3]\n0x0014C6C8 | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C6CC | 00 20 93 E5 | LDR     R2, [R3]\n0x0014C6D0 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x0014C6D4 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x0014C6D8 | 03 30 82 E0 | ADD     R3, R2, R3\n0x0014C6DC | 1C 20 1B E5 | LDR     R2, [R11,#id]\n0x0014C6E0 | 00 20 83 E5 | STR     R2, [R3]\n0x0014C6E4 | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C6E8 | 00 20 93 E5 | LDR     R2, [R3]\n0x0014C6EC | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x0014C6F0 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x0014C6F4 | 03 30 82 E0 | ADD     R3, R2, R3\n0x0014C6F8 | 04 40 83 E2 | ADD     R4, R3, #4\n0x0014C6FC | 20 30 1B E5 | LDR     R3, [R11,#x2x_utoa]\n0x0014C700 | 1C 00 1B E5 | LDR     R0, [R11,#id]\n0x0014C704 | 33 FF 2F E1 | BLX     R3\n0x0014C708 | 00 30 A0 E1 | MOV     R3, R0\n0x0014C70C | 1C 20 A0 E3 | MOV     R2, #0x1C; size\n0x0014C710 | 03 10 A0 E1 | MOV     R1, R3; src\n0x0014C714 | 04 00 A0 E1 | MOV     R0, R4; dst\n0x0014C718 | 11 15 00 EB | BL      safe_strncpy\n0x0014C71C | 18 30 1B E5 | LDR     R3, [R11,#cp]\n0x0014C720 | 00 20 93 E5 | LDR     R2, [R3]\n0x0014C724 | 10 30 1B E5 | LDR     R3, [R11,#i]\n0x0014C728 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x0014C72C | 03 30 82 E0 | ADD     R3, R2, R3\n0x0014C730 | 04 30 83 E2 | ADD     R3, R3, #4\n0x0014C734 | 03 00 A0 E1 | MOV     R0, R3\n0x0014C738 | 08 D0 4B E2 | SUB     SP, R11, #8\n0x0014C73C | 10 88 BD E8 | POP     {R4,R11,PC}",
        "output": "```c\n#include <stddef.h>\n\nvoid *xrealloc_vector_helper(void *vector, unsigned int sizeof_and_shift, size_t idx);\nvoid safe_strncpy(char *dst, const char *src, size_t size);\n\nvoid function(char **cp, int id, void (*x2x_utoa)(unsigned int, char *)) {\n    int i = 0;\n    while (i < (*cp)[4]) {\n        if ((*cp)[i << 5] == id) {\n            break;\n        }\n        i++;\n    }\n    if (i == (*cp)[4]) {\n        (*cp)[4]++;\n        *cp = xrealloc_vector_helper(*cp, 0x2002, i);\n    }\n    (*cp)[(i << 5)] = id;\n    x2x_utoa(id, &(*cp)[(i << 5) + 4]);\n    safe_strncpy(&(*cp)[(i << 5) + 4], (char *)x2x_utoa, 0x1C);\n}\n```"
    },
    {
        "func_name": "dotrap",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000A0210 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000A0214 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000A0218 | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x000A021C | 08 31 9F E5 | LDR     R3, =exitstatus\n0x000A0220 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000A0224 | 0D 30 4B E5 | STRB    R3, [R11,#savestatus]\n0x000A0228 | 00 31 9F E5 | LDR     R3, =ash_ptr_to_globals_misc\n0x000A022C | 00 30 93 E5 | LDR     R3, [R3]\n0x000A0230 | 00 20 A0 E3 | MOV     R2, #0\n0x000A0234 | 24 20 83 E5 | STR     R2, [R3,#0x24]\n0x000A0238 | 01 30 A0 E3 | MOV     R3, #1\n0x000A023C | 0C 30 0B E5 | STR     R3, [R11,#sig]\n0x000A0240 | E8 30 9F E5 | LDR     R3, =ash_ptr_to_globals_misc\n0x000A0244 | 00 30 93 E5 | LDR     R3, [R3]\n0x000A0248 | 80 30 83 E2 | ADD     R3, R3, #0x80\n0x000A024C | 08 30 0B E5 | STR     R3, [R11,#g]\n0x000A0250 | 2E 00 00 EA | B       loc_A0310\n0x000A0254 | 08 30 1B E5 | LDR     R3, [R11,#g]\n0x000A0258 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000A025C | 00 00 53 E3 | CMP     R3, #0\n0x000A0260 | 1F 00 00 0A | BEQ     loc_A02E4\n0x000A0264 | C4 30 9F E5 | LDR     R3, =ash_ptr_to_globals_misc\n0x000A0268 | 00 20 93 E5 | LDR     R2, [R3]\n0x000A026C | 0C 30 1B E5 | LDR     R3, [R11,#sig]\n0x000A0270 | 30 30 83 E2 | ADD     R3, R3, #0x30 ; '0'\n0x000A0274 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000A0278 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000A027C | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000A0280 | 14 30 0B E5 | STR     R3, [R11,#t]\n0x000A0284 | 0C 30 1B E5 | LDR     R3, [R11,#sig]\n0x000A0288 | 02 00 53 E3 | CMP     R3, #2\n0x000A028C | 02 00 00 1A | BNE     loc_A029C\n0x000A0290 | 14 30 1B E5 | LDR     R3, [R11,#t]\n0x000A0294 | 00 00 53 E3 | CMP     R3, #0\n0x000A0298 | 13 00 00 0A | BEQ     loc_A02EC\n0x000A029C | 08 30 1B E5 | LDR     R3, [R11,#g]\n0x000A02A0 | 00 20 A0 E3 | MOV     R2, #0\n0x000A02A4 | 00 20 C3 E5 | STRB    R2, [R3]\n0x000A02A8 | 14 30 1B E5 | LDR     R3, [R11,#t]\n0x000A02AC | 00 00 53 E3 | CMP     R3, #0\n0x000A02B0 | 0F 00 00 0A | BEQ     loc_A02F4\n0x000A02B4 | 10 10 A0 E3 | MOV     R1, #0x10; mask\n0x000A02B8 | 14 00 1B E5 | LDR     R0, [R11,#t]; s\n0x000A02BC | 93 1C 00 EB | BL      evalstring\n0x000A02C0 | 18 00 0B E5 | STR     R0, [R11,#want_exexit]\n0x000A02C4 | 60 20 9F E5 | LDR     R2, =exitstatus\n0x000A02C8 | 0D 30 5B E5 | LDRB    R3, [R11,#savestatus]\n0x000A02CC | 00 30 C2 E5 | STRB    R3, [R2]\n0x000A02D0 | 18 30 1B E5 | LDR     R3, [R11,#want_exexit]\n0x000A02D4 | 00 00 53 E3 | CMP     R3, #0\n0x000A02D8 | 06 00 00 0A | BEQ     loc_A02F8\n0x000A02DC | 18 30 1B E5 | LDR     R3, [R11,#want_exexit]\n0x000A02E0 | 0E 00 00 EA | B       loc_A0320\n0x000A02E4 | 00 00 A0 E1 | NOP\n0x000A02E8 | 02 00 00 EA | B       loc_A02F8\n0x000A02EC | 00 00 A0 E1 | NOP\n0x000A02F0 | 00 00 00 EA | B       loc_A02F8\n0x000A02F4 | 00 00 A0 E1 | NOP\n0x000A02F8 | 0C 30 1B E5 | LDR     R3, [R11,#sig]\n0x000A02FC | 01 30 83 E2 | ADD     R3, R3, #1\n0x000A0300 | 0C 30 0B E5 | STR     R3, [R11,#sig]\n0x000A0304 | 08 30 1B E5 | LDR     R3, [R11,#g]\n0x000A0308 | 01 30 83 E2 | ADD     R3, R3, #1\n0x000A030C | 08 30 0B E5 | STR     R3, [R11,#g]\n0x000A0310 | 0C 30 1B E5 | LDR     R3, [R11,#sig]\n0x000A0314 | 40 00 53 E3 | CMP     R3, #0x40 ; '@'\n0x000A0318 | CD FF FF DA | BLE     loc_A0254\n0x000A031C | 00 30 A0 E3 | MOV     R3, #0\n0x000A0320 | 03 00 A0 E1 | MOV     R0, R3\n0x000A0324 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000A0328 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function() {\n    static int exitstatus;\n    static void *ash_ptr_to_globals_misc;\n    int savestatus, sig, g, t, want_exexit;\n\n    savestatus = exitstatus;\n    *((int *)(ash_ptr_to_globals_misc) + 9) = 0;\n    sig = 1;\n    g = (char *)(ash_ptr_to_globals_misc) + 0x80;\n\n    do {\n        if (*g) {\n            t = *((int *)(ash_ptr_to_globals_misc) + (sig * 4) + 12);\n            if (sig == 2) {\n                if (t == 0) {\n                    break;\n                }\n            } else {\n                *g = 0;\n                if (t != 0) {\n                    want_exexit = evalstring(t, 0x10);\n                    exitstatus = savestatus;\n                    if (want_exexit != 0) {\n                        return want_exexit;\n                    }\n                }\n            }\n        }\n        sig++;\n        g++;\n    } while (sig < 0x40);\n\n    return 0;\n}\n```"
    },
    {
        "func_name": "open_next_file",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0010B0A8 | 00 48 2D E9 | PUSH    {R11,LR}\n0x0010B0AC | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0010B0B0 | 94 30 9F E5 | LDR     R3, =file_list\n0x0010B0B4 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010B0B8 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010B0BC | 00 00 53 E3 | CMP     R3, #0\n0x0010B0C0 | 1F 00 00 0A | BEQ     loc_10B144\n0x0010B0C4 | 80 30 9F E5 | LDR     R3, =file_list\n0x0010B0C8 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010B0CC | 04 20 83 E2 | ADD     R2, R3, #4\n0x0010B0D0 | 74 10 9F E5 | LDR     R1, =file_list\n0x0010B0D4 | 00 20 81 E5 | STR     R2, [R1]\n0x0010B0D8 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010B0DC | 03 00 A0 E1 | MOV     R0, R3; filename\n0x0010B0E0 | F6 26 01 EB | BL      fopen_or_warn_stdin\n0x0010B0E4 | 00 20 A0 E1 | MOV     R2, R0\n0x0010B0E8 | 60 30 9F E5 | LDR     R3, =in_stream\n0x0010B0EC | 00 20 83 E5 | STR     R2, [R3]\n0x0010B0F0 | 58 30 9F E5 | LDR     R3, =in_stream\n0x0010B0F4 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010B0F8 | 00 00 53 E3 | CMP     R3, #0\n0x0010B0FC | 03 00 00 1A | BNE     loc_10B110\n0x0010B100 | 4C 30 9F E5 | LDR     R3, =exit_code\n0x0010B104 | 01 20 A0 E3 | MOV     R2, #1\n0x0010B108 | 00 20 83 E5 | STR     R2, [R3]\n0x0010B10C | E7 FF FF EA | B       loc_10B0B0\n0x0010B110 | 00 00 A0 E1 | NOP\n0x0010B114 | 3C 30 9F E5 | LDR     R3, =option_mask32\n0x0010B118 | 00 20 93 E5 | LDR     R2, [R3]\n0x0010B11C | 38 30 9F E5 | LDR     R3, =0x10002\n0x0010B120 | 02 30 03 E0 | AND     R3, R3, R2\n0x0010B124 | 02 00 53 E3 | CMP     R3, #2\n0x0010B128 | 00 88 BD 18 | POPNE   {R11,PC}\n0x0010B12C | 1C 30 9F E5 | LDR     R3, =in_stream\n0x0010B130 | 00 30 93 E5 | LDR     R3, [R3]\n0x0010B134 | 00 10 A0 E3 | MOV     R1, #0; buf\n0x0010B138 | 03 00 A0 E1 | MOV     R0, R3; stream\n0x0010B13C | FB 26 FC EB | BL      setbuf\n0x0010B140 | 00 88 BD E8 | POP     {R11,PC}\n0x0010B144 | 00 00 A0 E1 | NOP\n0x0010B148 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdio.h>\n\nFILE *in_stream;\nint exit_code;\nunsigned int option_mask32;\nvoid *file_list;\n\nvoid function() {\n    FILE *file;\n    void **next_file;\n\n    next_file = file_list;\n    if (*next_file == NULL) {\n        exit_code = 1;\n        return;\n    }\n\n    next_file = (void **)(*next_file + 1);\n    file_list = next_file;\n    file = fopen_or_warn_stdin(*next_file);\n    in_stream = file;\n\n    if (in_stream == NULL) {\n        exit_code = 1;\n        return;\n    }\n\n    if (option_mask32 & 0x10002) {\n        return;\n    }\n\n    setbuf(in_stream, NULL);\n}\n```"
    },
    {
        "func_name": "prepend_new_eth_table",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000524B4 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000524B8 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000524BC | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x000524C0 | 10 00 0B E5 | STR     R0, [R11,#clist]\n0x000524C4 | 14 10 0B E5 | STR     R1, [R11,#ifname]\n0x000524C8 | 18 20 0B E5 | STR     R2, [R11,#selector]\n0x000524CC | 14 00 1B E5 | LDR     R0, [R11,#ifname]; s\n0x000524D0 | 2C 0C FF EB | BL      strlen\n0x000524D4 | 00 30 A0 E1 | MOV     R3, R0\n0x000524D8 | 0F 00 53 E3 | CMP     R3, #0xF\n0x000524DC | 02 00 00 9A | BLS     loc_524EC\n0x000524E0 | 14 10 1B E5 | LDR     R1, [R11,#ifname]\n0x000524E4 | 7C 00 9F E5 | LDR     R0, =aInterfaceNameS; \"interface name '%s' too long\"\n0x000524E8 | 2A 1A FF EB | BL      bb_error_msg_and_die\n0x000524EC | 1C 00 A0 E3 | MOV     R0, #0x1C; size\n0x000524F0 | 8D 1D FF EB | BL      xzalloc\n0x000524F4 | 00 30 A0 E1 | MOV     R3, R0\n0x000524F8 | 08 30 0B E5 | STR     R3, [R11,#ch]\n0x000524FC | 14 00 1B E5 | LDR     R0, [R11,#ifname]; s\n0x00052500 | 99 1D FF EB | BL      xstrdup\n0x00052504 | 00 30 A0 E1 | MOV     R3, R0\n0x00052508 | 03 20 A0 E1 | MOV     R2, R3\n0x0005250C | 08 30 1B E5 | LDR     R3, [R11,#ch]\n0x00052510 | 08 20 83 E5 | STR     R2, [R3,#8]\n0x00052514 | 18 10 1B E5 | LDR     R1, [R11,#selector]; selector\n0x00052518 | 08 00 1B E5 | LDR     R0, [R11,#ch]; ch\n0x0005251C | 55 FF FF EB | BL      nameif_parse_selector\n0x00052520 | 10 30 1B E5 | LDR     R3, [R11,#clist]\n0x00052524 | 00 20 93 E5 | LDR     R2, [R3]\n0x00052528 | 08 30 1B E5 | LDR     R3, [R11,#ch]\n0x0005252C | 00 20 83 E5 | STR     R2, [R3]\n0x00052530 | 10 30 1B E5 | LDR     R3, [R11,#clist]\n0x00052534 | 00 30 93 E5 | LDR     R3, [R3]\n0x00052538 | 00 00 53 E3 | CMP     R3, #0\n0x0005253C | 03 00 00 0A | BEQ     loc_52550\n0x00052540 | 10 30 1B E5 | LDR     R3, [R11,#clist]\n0x00052544 | 00 30 93 E5 | LDR     R3, [R3]\n0x00052548 | 08 20 1B E5 | LDR     R2, [R11,#ch]\n0x0005254C | 04 20 83 E5 | STR     R2, [R3,#4]\n0x00052550 | 10 30 1B E5 | LDR     R3, [R11,#clist]\n0x00052554 | 08 20 1B E5 | LDR     R2, [R11,#ch]\n0x00052558 | 00 20 83 E5 | STR     R2, [R3]\n0x0005255C | 00 00 A0 E1 | NOP\n0x00052560 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00052564 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char *ifname;\n    void *selector;\n    void *next;\n} ch_struct;\n\nvoid bb_error_msg_and_die(const char *msg, ...);\nvoid *xzalloc(size_t size);\nchar *xstrdup(const char *s);\nvoid nameif_parse_selector(ch_struct *ch, void *selector);\n\nvoid function(char **clist, char *ifname, void *selector) {\n    if (strlen(ifname) > 15) {\n        bb_error_msg_and_die(\"interface name '%s' too long\", ifname);\n    }\n\n    ch_struct *ch = xzalloc(sizeof(ch_struct));\n    ch->ifname = xstrdup(ifname);\n    nameif_parse_selector(ch, selector);\n\n    if (*clist) {\n        ((ch_struct *)(*clist))->next = ch;\n    }\n    *clist = ch;\n}\n```"
    },
    {
        "func_name": "dict_flush",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000F4FBC | 00 48 2D E9 | PUSH    {R11,LR}\n0x000F4FC0 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000F4FC4 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x000F4FC8 | 10 00 0B E5 | STR     R0, [R11,#dict]\n0x000F4FCC | 14 10 0B E5 | STR     R1, [R11,#b]\n0x000F4FD0 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F4FD4 | 08 20 93 E5 | LDR     R2, [R3,#8]\n0x000F4FD8 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F4FDC | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000F4FE0 | 03 30 42 E0 | SUB     R3, R2, R3\n0x000F4FE4 | 08 30 0B E5 | STR     R3, [R11,#copy_size]\n0x000F4FE8 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F4FEC | 08 20 93 E5 | LDR     R2, [R3,#8]\n0x000F4FF0 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F4FF4 | 14 30 93 E5 | LDR     R3, [R3,#0x14]\n0x000F4FF8 | 03 00 52 E1 | CMP     R2, R3\n0x000F4FFC | 02 00 00 1A | BNE     loc_F500C\n0x000F5000 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F5004 | 00 20 A0 E3 | MOV     R2, #0\n0x000F5008 | 08 20 83 E5 | STR     R2, [R3,#8]\n0x000F500C | 14 30 1B E5 | LDR     R3, [R11,#b]\n0x000F5010 | 0C 20 93 E5 | LDR     R2, [R3,#0xC]\n0x000F5014 | 14 30 1B E5 | LDR     R3, [R11,#b]\n0x000F5018 | 10 30 93 E5 | LDR     R3, [R3,#0x10]\n0x000F501C | 03 00 82 E0 | ADD     R0, R2, R3; dest\n0x000F5020 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F5024 | 00 20 93 E5 | LDR     R2, [R3]\n0x000F5028 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F502C | 04 30 93 E5 | LDR     R3, [R3,#4]\n0x000F5030 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000F5034 | 08 20 1B E5 | LDR     R2, [R11,#copy_size]; n\n0x000F5038 | 03 10 A0 E1 | MOV     R1, R3; src\n0x000F503C | B6 7F FC EB | BL      memcpy\n0x000F5040 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F5044 | 08 20 93 E5 | LDR     R2, [R3,#8]\n0x000F5048 | 10 30 1B E5 | LDR     R3, [R11,#dict]\n0x000F504C | 04 20 83 E5 | STR     R2, [R3,#4]\n0x000F5050 | 14 30 1B E5 | LDR     R3, [R11,#b]\n0x000F5054 | 10 20 93 E5 | LDR     R2, [R3,#0x10]\n0x000F5058 | 08 30 1B E5 | LDR     R3, [R11,#copy_size]\n0x000F505C | 03 20 82 E0 | ADD     R2, R2, R3\n0x000F5060 | 14 30 1B E5 | LDR     R3, [R11,#b]\n0x000F5064 | 10 20 83 E5 | STR     R2, [R3,#0x10]\n0x000F5068 | 08 30 1B E5 | LDR     R3, [R11,#copy_size]\n0x000F506C | 03 00 A0 E1 | MOV     R0, R3\n0x000F5070 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000F5074 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <string.h>\n\nvoid function(char *dict, char *b) {\n    int copy_size = *(int *)(dict + 8) - *(int *)(dict + 4);\n    if (*(int *)(dict + 8) == *(int *)(dict + 0x14)) {\n        *(int *)(dict + 8) = 0;\n    }\n    char *dest = b + *(int *)(b + 0xC) + *(int *)(b + 0x10);\n    char *src = dict + *(int *)(dict);\n    memcpy(dest, src + *(int *)(dict + 4), copy_size);\n    *(int *)(dict + 4) = *(int *)(dict + 8);\n    *(int *)(b + 0x10) += copy_size;\n}\n```"
    },
    {
        "func_name": "fmt_100percent_8",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00089514 | 00 48 2D E9 | PUSH    {R11,LR}\n0x00089518 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0008951C | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x00089520 | 10 00 0B E5 | STR     R0, [R11,#pbuf]\n0x00089524 | 14 10 0B E5 | STR     R1, [R11,#value]\n0x00089528 | 18 20 0B E5 | STR     R2, [R11,#total]\n0x0008952C | 14 20 1B E5 | LDR     R2, [R11,#value]\n0x00089530 | 18 30 1B E5 | LDR     R3, [R11,#total]\n0x00089534 | 03 00 52 E1 | CMP     R2, R3\n0x00089538 | 08 00 00 3A | BCC     loc_89560\n0x0008953C | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x00089540 | 7C 21 9F E5 | LDR     R2, =a100; \"  100% \"\n0x00089544 | 03 00 A0 E1 | MOV     R0, R3; dest\n0x00089548 | 02 10 A0 E1 | MOV     R1, R2; src\n0x0008954C | 08 30 A0 E3 | MOV     R3, #8\n0x00089550 | 03 20 A0 E1 | MOV     R2, R3; n\n0x00089554 | 70 2E FE EB | BL      memcpy\n0x00089558 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x0008955C | 55 00 00 EA | B       loc_896B8\n0x00089560 | 14 20 1B E5 | LDR     R2, [R11,#value]\n0x00089564 | 02 30 A0 E1 | MOV     R3, R2\n0x00089568 | 83 32 A0 E1 | MOV     R3, R3,LSL#5\n0x0008956C | 02 30 43 E0 | SUB     R3, R3, R2\n0x00089570 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00089574 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00089578 | 83 31 A0 E1 | MOV     R3, R3,LSL#3\n0x0008957C | 18 10 1B E5 | LDR     R1, [R11,#total]\n0x00089580 | 03 00 A0 E1 | MOV     R0, R3\n0x00089584 | BF 36 03 EB | BL      __udivsi3\n0x00089588 | 00 30 A0 E1 | MOV     R3, R0\n0x0008958C | 14 30 0B E5 | STR     R3, [R11,#value]\n0x00089590 | 14 00 1B E5 | LDR     R0, [R11,#value]\n0x00089594 | 2C 21 9F E5 | LDR     R2, =0x51EB851F\n0x00089598 | 92 10 83 E0 | UMULL   R1, R3, R2, R0\n0x0008959C | A3 32 A0 E1 | MOV     R3, R3,LSR#5\n0x000895A0 | 08 30 0B E5 | STR     R3, [R11,#t]\n0x000895A4 | 14 20 1B E5 | LDR     R2, [R11,#value]\n0x000895A8 | 18 31 9F E5 | LDR     R3, =0x51EB851F\n0x000895AC | 92 13 80 E0 | UMULL   R1, R0, R2, R3\n0x000895B0 | A0 12 A0 E1 | MOV     R1, R0,LSR#5\n0x000895B4 | 01 30 A0 E1 | MOV     R3, R1\n0x000895B8 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000895BC | 01 30 83 E0 | ADD     R3, R3, R1\n0x000895C0 | 03 11 A0 E1 | MOV     R1, R3,LSL#2\n0x000895C4 | 01 30 83 E0 | ADD     R3, R3, R1\n0x000895C8 | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x000895CC | 03 30 42 E0 | SUB     R3, R2, R3\n0x000895D0 | 14 30 0B E5 | STR     R3, [R11,#value]\n0x000895D4 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x000895D8 | 20 20 A0 E3 | MOV     R2, #0x20 ; ' '\n0x000895DC | 00 20 C3 E5 | STRB    R2, [R3]\n0x000895E0 | 08 30 1B E5 | LDR     R3, [R11,#t]\n0x000895E4 | 00 00 53 E3 | CMP     R3, #0\n0x000895E8 | 04 00 00 0A | BEQ     loc_89600\n0x000895EC | 08 30 1B E5 | LDR     R3, [R11,#t]\n0x000895F0 | FF 30 03 E2 | AND     R3, R3, #0xFF\n0x000895F4 | 30 30 83 E2 | ADD     R3, R3, #0x30 ; '0'\n0x000895F8 | FF 20 03 E2 | AND     R2, R3, #0xFF\n0x000895FC | 00 00 00 EA | B       loc_89604\n0x00089600 | 20 20 A0 E3 | MOV     R2, #0x20 ; ' '\n0x00089604 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x00089608 | 01 30 83 E2 | ADD     R3, R3, #1\n0x0008960C | 00 20 C3 E5 | STRB    R2, [R3]\n0x00089610 | 14 00 1B E5 | LDR     R0, [R11,#value]\n0x00089614 | B0 20 9F E5 | LDR     R2, =0xCCCCCCCD\n0x00089618 | 92 10 83 E0 | UMULL   R1, R3, R2, R0\n0x0008961C | A3 31 A0 E1 | MOV     R3, R3,LSR#3\n0x00089620 | FF 20 03 E2 | AND     R2, R3, #0xFF\n0x00089624 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x00089628 | 02 30 83 E2 | ADD     R3, R3, #2\n0x0008962C | 30 20 82 E2 | ADD     R2, R2, #0x30 ; '0'\n0x00089630 | FF 20 02 E2 | AND     R2, R2, #0xFF\n0x00089634 | 00 20 C3 E5 | STRB    R2, [R3]\n0x00089638 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x0008963C | 03 30 83 E2 | ADD     R3, R3, #3\n0x00089640 | 2E 20 A0 E3 | MOV     R2, #0x2E ; '.'\n0x00089644 | 00 20 C3 E5 | STRB    R2, [R3]\n0x00089648 | 14 10 1B E5 | LDR     R1, [R11,#value]\n0x0008964C | 78 30 9F E5 | LDR     R3, =0xCCCCCCCD\n0x00089650 | 91 23 80 E0 | UMULL   R2, R0, R1, R3\n0x00089654 | A0 21 A0 E1 | MOV     R2, R0,LSR#3\n0x00089658 | 02 30 A0 E1 | MOV     R3, R2\n0x0008965C | 03 31 A0 E1 | MOV     R3, R3,LSL#2\n0x00089660 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00089664 | 83 30 A0 E1 | MOV     R3, R3,LSL#1\n0x00089668 | 03 20 41 E0 | SUB     R2, R1, R3\n0x0008966C | FF 20 02 E2 | AND     R2, R2, #0xFF\n0x00089670 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x00089674 | 04 30 83 E2 | ADD     R3, R3, #4\n0x00089678 | 30 20 82 E2 | ADD     R2, R2, #0x30 ; '0'\n0x0008967C | FF 20 02 E2 | AND     R2, R2, #0xFF\n0x00089680 | 00 20 C3 E5 | STRB    R2, [R3]\n0x00089684 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x00089688 | 05 30 83 E2 | ADD     R3, R3, #5\n0x0008968C | 25 20 A0 E3 | MOV     R2, #0x25 ; '%'\n0x00089690 | 00 20 C3 E5 | STRB    R2, [R3]\n0x00089694 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x00089698 | 06 30 83 E2 | ADD     R3, R3, #6\n0x0008969C | 20 20 A0 E3 | MOV     R2, #0x20 ; ' '\n0x000896A0 | 00 20 C3 E5 | STRB    R2, [R3]\n0x000896A4 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x000896A8 | 07 30 83 E2 | ADD     R3, R3, #7\n0x000896AC | 00 20 A0 E3 | MOV     R2, #0\n0x000896B0 | 00 20 C3 E5 | STRB    R2, [R3]\n0x000896B4 | 10 30 1B E5 | LDR     R3, [R11,#pbuf]\n0x000896B8 | 03 00 A0 E1 | MOV     R0, R3\n0x000896BC | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000896C0 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(char *pbuf, unsigned int value, unsigned int total) {\n    if (value >= total) {\n        memcpy(pbuf, \"  100% \", 8);\n    } else {\n        unsigned int t, v;\n        value = (value * 100) / total;\n        v = value * 0x51EB851F;\n        t = v >> 5;\n        pbuf[0] = ' ';\n        if (t != 0) {\n            pbuf[1] = (t & 0xFF) + '0';\n        } else {\n            pbuf[1] = ' ';\n        }\n        v = value * 0xCCCCCCCD;\n        pbuf[2] = ((v >> 35) & 0xFF) + '0';\n        pbuf[3] = '.';\n        v = value * 0xCCCCCCCD;\n        pbuf[4] = ((v >> 35) & 0xFF) + '0';\n        pbuf[5] = '%';\n        pbuf[6] = ' ';\n        pbuf[7] = '\\0';\n    }\n}\n```"
    },
    {
        "func_name": "show_min_max",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000246DC | 00 48 2D E9 | PUSH    {R11,LR}\n0x000246E0 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000246E4 | 18 D0 4D E2 | SUB     SP, SP, #0x18\n0x000246E8 | 18 00 0B E5 | STR     R0, [R11,#pol]\n0x000246EC | 64 30 9F E5 | LDR     R3, =aSMinMaxPriorit; \"%s min/max priority\\t: %u/%u\\n\"\n0x000246F0 | 08 30 0B E5 | STR     R3, [R11,#fmt]\n0x000246F4 | 18 00 1B E5 | LDR     R0, [R11,#pol]; algorithm\n0x000246F8 | 2A C3 FF EB | BL      sched_get_priority_max\n0x000246FC | 0C 00 0B E5 | STR     R0, [R11,#max]\n0x00024700 | 18 00 1B E5 | LDR     R0, [R11,#pol]; algorithm\n0x00024704 | 5C C1 FF EB | BL      sched_get_priority_min\n0x00024708 | 10 00 0B E5 | STR     R0, [R11,#min]\n0x0002470C | 0C 20 1B E5 | LDR     R2, [R11,#max]\n0x00024710 | 10 30 1B E5 | LDR     R3, [R11,#min]\n0x00024714 | 03 30 82 E1 | ORR     R3, R2, R3\n0x00024718 | 00 00 53 E3 | CMP     R3, #0\n0x0002471C | 01 00 00 AA | BGE     loc_24728\n0x00024720 | 34 30 9F E5 | LDR     R3, =aSNotSupported; \"%s not supported\\n\"\n0x00024724 | 08 30 0B E5 | STR     R3, [R11,#fmt]\n0x00024728 | 18 30 1B E5 | LDR     R3, [R11,#pol]\n0x0002472C | 03 32 A0 E1 | MOV     R3, R3,LSL#4\n0x00024730 | 28 20 9F E5 | LDR     R2, =policies\n0x00024734 | 02 30 83 E0 | ADD     R3, R3, R2\n0x00024738 | 04 10 83 E2 | ADD     R1, R3, #4\n0x0002473C | 0C 30 1B E5 | LDR     R3, [R11,#max]\n0x00024740 | 10 20 1B E5 | LDR     R2, [R11,#min]\n0x00024744 | 08 00 1B E5 | LDR     R0, [R11,#fmt]; format\n0x00024748 | A2 C1 FF EB | BL      printf\n0x0002474C | 00 00 A0 E1 | NOP\n0x00024750 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x00024754 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdio.h>\n#include <sched.h>\n\nvoid display_policy_info(int policy) {\n    unsigned int max_priority, min_priority;\n    const char *format;\n    const char *policy_name;\n\n    max_priority = sched_get_priority_max(policy);\n    min_priority = sched_get_priority_min(policy);\n\n    if (max_priority | min_priority) {\n        format = \"%s min/max priority\\t: %u/%u\\n\";\n    } else {\n        format = \"%s not supported\\n\";\n    }\n\n    policy_name = policies[policy << 4] + 4;\n    printf(format, policy_name, min_priority, max_priority);\n}\n```"
    },
    {
        "func_name": "dmesg_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000BC898 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000BC89C | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000BC8A0 | 20 D0 4D E2 | SUB     SP, SP, #0x20\n0x000BC8A4 | 20 00 0B E5 | STR     R0, [R11,#argc]\n0x000BC8A8 | 24 10 0B E5 | STR     R1, [R11,#argv]\n0x000BC8AC | EC 31 9F E5 | LDR     R3, =opt_complementary\n0x000BC8B0 | EC 21 9F E5 | LDR     R2, =aSN; \"s+:n+\"\n0x000BC8B4 | 00 20 83 E5 | STR     R2, [R3]\n0x000BC8B8 | 1C 30 4B E2 | SUB     R3, R11, #-level\n0x000BC8BC | 18 20 4B E2 | SUB     R2, R11, #-len\n0x000BC8C0 | E0 11 9F E5 | LDR     R1, =aCsN; \"cs:n:\"\n0x000BC8C4 | 24 00 1B E5 | LDR     R0, [R11,#argv]; argv\n0x000BC8C8 | F6 11 02 EB | BL      getopt32\n0x000BC8CC | 10 00 0B E5 | STR     R0, [R11,#opts]\n0x000BC8D0 | 10 30 1B E5 | LDR     R3, [R11,#opts]\n0x000BC8D4 | 04 30 03 E2 | AND     R3, R3, #4\n0x000BC8D8 | 00 00 53 E3 | CMP     R3, #0\n0x000BC8DC | 0B 00 00 0A | BEQ     loc_BC910\n0x000BC8E0 | 1C 30 1B E5 | LDR     R3, [R11,#level]\n0x000BC8E4 | 03 20 A0 E1 | MOV     R2, R3; len\n0x000BC8E8 | 00 10 A0 E3 | MOV     R1, #0; bufp\n0x000BC8EC | 08 00 A0 E3 | MOV     R0, #8; type\n0x000BC8F0 | 81 63 FD EB | BL      klogctl\n0x000BC8F4 | 00 30 A0 E1 | MOV     R3, R0\n0x000BC8F8 | 00 00 53 E3 | CMP     R3, #0\n0x000BC8FC | 01 00 00 0A | BEQ     loc_BC908\n0x000BC900 | A4 01 9F E5 | LDR     R0, =aKlogctl_0; \"klogctl\"\n0x000BC904 | FC 6F FD EB | BL      bb_perror_msg_and_die\n0x000BC908 | 00 30 A0 E3 | MOV     R3, #0\n0x000BC90C | 60 00 00 EA | B       loc_BCA94\n0x000BC910 | 10 30 1B E5 | LDR     R3, [R11,#opts]\n0x000BC914 | 02 30 03 E2 | AND     R3, R3, #2\n0x000BC918 | 00 00 53 E3 | CMP     R3, #0\n0x000BC91C | 05 00 00 1A | BNE     loc_BC938\n0x000BC920 | 00 20 A0 E3 | MOV     R2, #0; len\n0x000BC924 | 00 10 A0 E3 | MOV     R1, #0; bufp\n0x000BC928 | 0A 00 A0 E3 | MOV     R0, #0xA; type\n0x000BC92C | 72 63 FD EB | BL      klogctl\n0x000BC930 | 00 30 A0 E1 | MOV     R3, R0\n0x000BC934 | 18 30 0B E5 | STR     R3, [R11,#len]\n0x000BC938 | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BC93C | 01 09 53 E3 | CMP     R3, #0x4000\n0x000BC940 | 01 00 00 AA | BGE     loc_BC94C\n0x000BC944 | 01 39 A0 E3 | MOV     R3, #0x4000\n0x000BC948 | 18 30 0B E5 | STR     R3, [R11,#len]\n0x000BC94C | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BC950 | 01 04 53 E3 | CMP     R3, #0x1000000\n0x000BC954 | 01 00 00 DA | BLE     loc_BC960\n0x000BC958 | 01 34 A0 E3 | MOV     R3, #0x1000000\n0x000BC95C | 18 30 0B E5 | STR     R3, [R11,#len]\n0x000BC960 | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BC964 | 03 00 A0 E1 | MOV     R0, R3; size\n0x000BC968 | 44 74 FD EB | BL      xmalloc\n0x000BC96C | 00 30 A0 E1 | MOV     R3, R0\n0x000BC970 | 14 30 0B E5 | STR     R3, [R11,#buf]\n0x000BC974 | 10 30 1B E5 | LDR     R3, [R11,#opts]\n0x000BC978 | 01 30 03 E2 | AND     R3, R3, #1\n0x000BC97C | 03 30 83 E2 | ADD     R3, R3, #3\n0x000BC980 | 03 00 A0 E1 | MOV     R0, R3; type\n0x000BC984 | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BC988 | 03 20 A0 E1 | MOV     R2, R3; len\n0x000BC98C | 14 10 1B E5 | LDR     R1, [R11,#buf]; bufp\n0x000BC990 | 59 63 FD EB | BL      klogctl\n0x000BC994 | 00 30 A0 E1 | MOV     R3, R0\n0x000BC998 | 18 30 0B E5 | STR     R3, [R11,#len]\n0x000BC99C | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BC9A0 | 00 00 53 E3 | CMP     R3, #0\n0x000BC9A4 | 01 00 00 AA | BGE     loc_BC9B0\n0x000BC9A8 | FC 00 9F E5 | LDR     R0, =aKlogctl_0; \"klogctl\"\n0x000BC9AC | D2 6F FD EB | BL      bb_perror_msg_and_die\n0x000BC9B0 | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BC9B4 | 00 00 53 E3 | CMP     R3, #0\n0x000BC9B8 | 01 00 00 1A | BNE     loc_BC9C4\n0x000BC9BC | 00 30 A0 E3 | MOV     R3, #0\n0x000BC9C0 | 33 00 00 EA | B       loc_BCA94\n0x000BC9C4 | 0A 30 A0 E3 | MOV     R3, #0xA\n0x000BC9C8 | 08 30 0B E5 | STR     R3, [R11,#last]\n0x000BC9CC | 00 30 A0 E3 | MOV     R3, #0\n0x000BC9D0 | 0C 30 0B E5 | STR     R3, [R11,#in]\n0x000BC9D4 | 08 30 1B E5 | LDR     R3, [R11,#last]\n0x000BC9D8 | 0A 00 53 E3 | CMP     R3, #0xA\n0x000BC9DC | 14 00 00 1A | BNE     loc_BCA34\n0x000BC9E0 | 0C 30 1B E5 | LDR     R3, [R11,#in]\n0x000BC9E4 | 14 20 1B E5 | LDR     R2, [R11,#buf]\n0x000BC9E8 | 03 30 82 E0 | ADD     R3, R2, R3\n0x000BC9EC | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000BC9F0 | 3C 00 53 E3 | CMP     R3, #0x3C ; '<'\n0x000BC9F4 | 0E 00 00 1A | BNE     loc_BCA34\n0x000BC9F8 | 00 00 A0 E1 | NOP\n0x000BC9FC | 0C 30 1B E5 | LDR     R3, [R11,#in]\n0x000BCA00 | 01 20 83 E2 | ADD     R2, R3, #1\n0x000BCA04 | 0C 20 0B E5 | STR     R2, [R11,#in]\n0x000BCA08 | 03 20 A0 E1 | MOV     R2, R3\n0x000BCA0C | 14 30 1B E5 | LDR     R3, [R11,#buf]\n0x000BCA10 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000BCA14 | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000BCA18 | 3E 00 53 E3 | CMP     R3, #0x3E ; '>'\n0x000BCA1C | 0F 00 00 0A | BEQ     loc_BCA60\n0x000BCA20 | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BCA24 | 0C 20 1B E5 | LDR     R2, [R11,#in]\n0x000BCA28 | 03 00 52 E1 | CMP     R2, R3\n0x000BCA2C | F2 FF FF BA | BLT     loc_BC9FC\n0x000BCA30 | 0A 00 00 EA | B       loc_BCA60\n0x000BCA34 | 0C 30 1B E5 | LDR     R3, [R11,#in]\n0x000BCA38 | 01 20 83 E2 | ADD     R2, R3, #1\n0x000BCA3C | 0C 20 0B E5 | STR     R2, [R11,#in]\n0x000BCA40 | 03 20 A0 E1 | MOV     R2, R3\n0x000BCA44 | 14 30 1B E5 | LDR     R3, [R11,#buf]\n0x000BCA48 | 02 30 83 E0 | ADD     R3, R3, R2\n0x000BCA4C | 00 30 D3 E5 | LDRB    R3, [R3]\n0x000BCA50 | 08 30 0B E5 | STR     R3, [R11,#last]\n0x000BCA54 | 08 00 1B E5 | LDR     R0, [R11,#last]; c\n0x000BCA58 | CB 64 FD EB | BL      putchar_unlocked\n0x000BCA5C | 00 00 00 EA | B       loc_BCA64\n0x000BCA60 | 00 00 A0 E1 | NOP\n0x000BCA64 | 18 30 1B E5 | LDR     R3, [R11,#len]\n0x000BCA68 | 0C 20 1B E5 | LDR     R2, [R11,#in]\n0x000BCA6C | 03 00 52 E1 | CMP     R2, R3\n0x000BCA70 | 00 00 00 AA | BGE     loc_BCA78\n0x000BCA74 | D6 FF FF EA | B       loc_BC9D4\n0x000BCA78 | 00 00 A0 E1 | NOP\n0x000BCA7C | 08 30 1B E5 | LDR     R3, [R11,#last]\n0x000BCA80 | 0A 00 53 E3 | CMP     R3, #0xA\n0x000BCA84 | 01 00 00 0A | BEQ     loc_BCA90\n0x000BCA88 | 0A 00 A0 E3 | MOV     R0, #0xA; ch\n0x000BCA8C | E7 75 FD EB | BL      bb_putchar\n0x000BCA90 | 00 30 A0 E3 | MOV     R3, #0\n0x000BCA94 | 03 00 A0 E1 | MOV     R0, R3\n0x000BCA98 | 04 D0 4B E2 | SUB     SP, R11, #4\n0x000BCA9C | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <stdlib.h>\n\nint main(int argc, char **argv) {\n    int opts;\n    int level;\n    int len;\n    char *buf;\n    char last;\n    int in;\n    getopt32(argv, \"cs:n:\", &level, &len);\n    opts = getopt32(argv, \"s+:n+\");\n    if (opts & 4) {\n        len = klogctl(8, NULL, 0);\n        if (len < 0) {\n            bb_perror_msg_and_die(\"klogctl\");\n        }\n    } else {\n        len = klogctl(10, NULL, 0);\n        if (len < 0x4000) {\n            len = 0x4000;\n        }\n        if (len > 0x1000000) {\n            len = 0x1000000;\n        }\n        buf = xmalloc(len);\n        opts |= 3;\n        len = klogctl(opts, buf, len);\n        if (len < 0) {\n            bb_perror_msg_and_die(\"klogctl\");\n        }\n    }\n    if (len == 0) {\n        return 0;\n    }\n    last = '\\n';\n    in = 0;\n    while (1) {\n        if (last == '\\n') {\n            if (buf[in] == '<') {\n                in++;\n                if (buf[in] == '>') {\n                    break;\n                }\n                continue;\n            }\n        }\n        if (in >= len) {\n            break;\n        }\n        last = buf[in++];\n        putchar_unlocked(last);\n    }\n    if (last != '\\n') {\n        bb_putchar('\\n');\n    }\n    return 0;\n}\n```"
    },
    {
        "func_name": "make_default_cur_rule",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x000CCEE0 | 00 48 2D E9 | PUSH    {R11,LR}\n0x000CCEE4 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x000CCEE8 | 2C 30 9F E5 | LDR     R3, =(qword_18F9F8+4)\n0x000CCEEC | 4C 20 A0 E3 | MOV     R2, #0x4C ; 'L'; n\n0x000CCEF0 | 00 10 A0 E3 | MOV     R1, #0; c\n0x000CCEF4 | 03 00 A0 E1 | MOV     R0, R3; s\n0x000CCEF8 | 1A 22 FD EB | BL      memset\n0x000CCEFC | 1C 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CCF00 | 00 20 E0 E3 | MOV     R2, #0xFFFFFFFF\n0x000CCF04 | 2C 20 83 E5 | STR     R2, [R3,#(unk_18FA04 - 0x18F9D8)]\n0x000CCF08 | 10 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x000CCF0C | 1B 2E A0 E3 | MOV     R2, #0x1B0\n0x000CCF10 | 28 20 83 E5 | STR     R2, [R3,#(unk_18FA00 - 0x18F9D8)]\n0x000CCF14 | 00 00 A0 E1 | NOP\n0x000CCF18 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\n#include <string.h>\n\nvoid function() {\n    char *s = (char *)(qword_18F9F8 + 4);\n    memset(s, 0, 0x4C);\n\n    *bb_common_bufsiz1 = -1;\n    *(bb_common_bufsiz1 + 4) = 0x1B0;\n}\n```"
    },
    {
        "func_name": "branch_to",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0012D55C | 00 48 2D E9 | PUSH    {R11,LR}\n0x0012D560 | 04 B0 8D E2 | ADD     R11, SP, #4\n0x0012D564 | 10 D0 4D E2 | SUB     SP, SP, #0x10\n0x0012D568 | 10 00 0B E5 | STR     R0, [R11,#label]\n0x0012D56C | 80 30 9F E5 | LDR     R3, =bb_common_bufsiz1\n0x0012D570 | 74 30 93 E5 | LDR     R3, [R3,#(byte_18FA48+4 - 0x18F9D8)]\n0x0012D574 | 08 30 0B E5 | STR     R3, [R11,#sed_cmd]\n0x0012D578 | 14 00 00 EA | B       loc_12D5D0\n0x0012D57C | 08 30 1B E5 | LDR     R3, [R11,#sed_cmd]\n0x0012D580 | 2A 30 D3 E5 | LDRB    R3, [R3,#0x2A]\n0x0012D584 | 3A 00 53 E3 | CMP     R3, #0x3A ; ':'\n0x0012D588 | 0D 00 00 1A | BNE     loc_12D5C4\n0x0012D58C | 08 30 1B E5 | LDR     R3, [R11,#sed_cmd]\n0x0012D590 | 20 30 93 E5 | LDR     R3, [R3,#0x20]\n0x0012D594 | 00 00 53 E3 | CMP     R3, #0\n0x0012D598 | 09 00 00 0A | BEQ     loc_12D5C4\n0x0012D59C | 08 30 1B E5 | LDR     R3, [R11,#sed_cmd]\n0x0012D5A0 | 20 30 93 E5 | LDR     R3, [R3,#0x20]\n0x0012D5A4 | 10 10 1B E5 | LDR     R1, [R11,#label]; s2\n0x0012D5A8 | 03 00 A0 E1 | MOV     R0, R3; s1\n0x0012D5AC | E8 9D FB EB | BL      strcmp\n0x0012D5B0 | 00 30 A0 E1 | MOV     R3, R0\n0x0012D5B4 | 00 00 53 E3 | CMP     R3, #0\n0x0012D5B8 | 01 00 00 1A | BNE     loc_12D5C4\n0x0012D5BC | 08 30 1B E5 | LDR     R3, [R11,#sed_cmd]\n0x0012D5C0 | 08 00 00 EA | B       loc_12D5E8\n0x0012D5C4 | 08 30 1B E5 | LDR     R3, [R11,#sed_cmd]\n0x0012D5C8 | 00 30 93 E5 | LDR     R3, [R3]\n0x0012D5CC | 08 30 0B E5 | STR     R3, [R11,#sed_cmd]\n0x0012D5D0 | 08 30 1B E5 | LDR     R3, [R11,#sed_cmd]\n0x0012D5D4 | 00 00 53 E3 | CMP     R3, #0\n0x0012D5D8 | E7 FF FF 1A | BNE     loc_12D57C\n0x0012D5DC | 10 10 1B E5 | LDR     R1, [R11,#label]\n0x0012D5E0 | 10 00 9F E5 | LDR     R0, =aCanTFindLabelF; \"can't find label for jump to '%s'\"\n0x0012D5E4 | EB AD FB EB | BL      bb_error_msg_and_die\n0x0012D5E8 | 03 00 A0 E1 | MOV     R0, R3\n0x0012D5EC | 04 D0 4B E2 | SUB     SP, R11, #4\n0x0012D5F0 | 00 88 BD E8 | POP     {R11,PC}",
        "output": "```c\nvoid function(char *label) {\n    char *sed_cmd = bb_common_bufsiz1 + 4;\n    do {\n        if (sed_cmd[0x2A] == ':') {\n            if (sed_cmd[0x20] != 0 && strcmp(sed_cmd[0x20], label) == 0) {\n                return;\n            }\n        }\n        sed_cmd = *sed_cmd;\n    } while (sed_cmd != 0);\n    bb_error_msg_and_die(\"can't find label for jump to '%s'\", label);\n}\n```"
    },
    {
        "func_name": "add_inode",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the ARM-32 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0007C020 | 10 48 2D E9 | PUSH    {R4,R11,LR}\n0x0007C024 | 08 B0 8D E2 | ADD     R11, SP, #8\n0x0007C028 | 14 D0 4D E2 | SUB     SP, SP, #0x14\n0x0007C02C | 18 00 0B E5 | STR     R0, [R11,#st]\n0x0007C030 | C8 30 9F E5 | LDR     R3, =unk_18F9E0\n0x0007C034 | 10 30 0B E5 | STR     R3, [R11,#curr]\n0x0007C038 | 15 00 00 EA | B       loc_7C094\n0x0007C03C | 10 30 1B E5 | LDR     R3, [R11,#curr]\n0x0007C040 | 00 30 93 E5 | LDR     R3, [R3]\n0x0007C044 | 10 20 83 E2 | ADD     R2, R3, #0x10\n0x0007C048 | 06 00 92 E8 | LDM     R2, {R1,R2}\n0x0007C04C | 18 30 1B E5 | LDR     R3, [R11,#st]\n0x0007C050 | 18 00 93 E8 | LDM     R3, {R3,R4}\n0x0007C054 | 04 00 52 E1 | CMP     R2, R4\n0x0007C058 | 03 00 51 01 | CMPEQ   R1, R3\n0x0007C05C | 09 00 00 1A | BNE     loc_7C088\n0x0007C060 | 10 30 1B E5 | LDR     R3, [R11,#curr]\n0x0007C064 | 00 30 93 E5 | LDR     R3, [R3]\n0x0007C068 | 08 20 83 E2 | ADD     R2, R3, #8\n0x0007C06C | 06 00 92 E8 | LDM     R2, {R1,R2}\n0x0007C070 | 18 30 1B E5 | LDR     R3, [R11,#st]\n0x0007C074 | 60 40 83 E2 | ADD     R4, R3, #0x60 ; '`'\n0x0007C078 | 18 00 94 E8 | LDM     R4, {R3,R4}\n0x0007C07C | 04 00 52 E1 | CMP     R2, R4\n0x0007C080 | 03 00 51 01 | CMPEQ   R1, R3\n0x0007C084 | 1A 00 00 0A | BEQ     loc_7C0F4\n0x0007C088 | 10 30 1B E5 | LDR     R3, [R11,#curr]\n0x0007C08C | 00 30 93 E5 | LDR     R3, [R3]\n0x0007C090 | 10 30 0B E5 | STR     R3, [R11,#curr]\n0x0007C094 | 10 30 1B E5 | LDR     R3, [R11,#curr]\n0x0007C098 | 00 30 93 E5 | LDR     R3, [R3]\n0x0007C09C | 00 00 53 E3 | CMP     R3, #0\n0x0007C0A0 | E5 FF FF 1A | BNE     loc_7C03C\n0x0007C0A4 | 18 00 A0 E3 | MOV     R0, #0x18; size\n0x0007C0A8 | 9F 76 FE EB | BL      xzalloc\n0x0007C0AC | 00 30 A0 E1 | MOV     R3, R0\n0x0007C0B0 | 03 20 A0 E1 | MOV     R2, R3\n0x0007C0B4 | 10 30 1B E5 | LDR     R3, [R11,#curr]\n0x0007C0B8 | 00 20 83 E5 | STR     R2, [R3]\n0x0007C0BC | 10 30 1B E5 | LDR     R3, [R11,#curr]\n0x0007C0C0 | 00 20 93 E5 | LDR     R2, [R3]\n0x0007C0C4 | 18 30 1B E5 | LDR     R3, [R11,#st]\n0x0007C0C8 | 18 00 93 E8 | LDM     R3, {R3,R4}\n0x0007C0CC | 10 30 82 E5 | STR     R3, [R2,#0x10]\n0x0007C0D0 | 14 40 82 E5 | STR     R4, [R2,#0x14]\n0x0007C0D4 | 10 30 1B E5 | LDR     R3, [R11,#curr]\n0x0007C0D8 | 00 20 93 E5 | LDR     R2, [R3]\n0x0007C0DC | 18 30 1B E5 | LDR     R3, [R11,#st]\n0x0007C0E0 | 60 40 83 E2 | ADD     R4, R3, #0x60 ; '`'\n0x0007C0E4 | 18 00 94 E8 | LDM     R4, {R3,R4}\n0x0007C0E8 | 08 30 82 E5 | STR     R3, [R2,#8]\n0x0007C0EC | 0C 40 82 E5 | STR     R4, [R2,#0xC]\n0x0007C0F0 | 00 00 00 EA | B       loc_7C0F8\n0x0007C0F4 | 00 00 A0 E1 | NOP\n0x0007C0F8 | 08 D0 4B E2 | SUB     SP, R11, #8\n0x0007C0FC | 10 88 BD E8 | POP     {R4,R11,PC}",
        "output": "```c\n#include <stddef.h>\n\ntypedef struct {\n    int field_0;\n    int field_4;\n    int field_8;\n    int field_C;\n    int field_10;\n    int field_14;\n} StructType;\n\nvoid *xzalloc(size_t size);\n\nStructType *func(StructType *st) {\n    StructType *curr = (StructType *)0x18F9E0;\n    while (curr->field_0) {\n        if (curr->field_10 == st->field_4 && curr->field_14 == st->field_0) {\n            return curr;\n        }\n        if (curr->field_8 == st->field_C && curr->field_C == st->field_8) {\n            return curr;\n        }\n        curr = (StructType *)curr->field_0;\n    }\n\n    StructType *new_struct = (StructType *)xzalloc(0x18);\n    new_struct->field_10 = st->field_0;\n    new_struct->field_14 = st->field_4;\n    new_struct->field_8 = st->field_8;\n    new_struct->field_C = st->field_C;\n    curr->field_0 = (int)new_struct;\n\n    return new_struct;\n}\n```"
    }
]
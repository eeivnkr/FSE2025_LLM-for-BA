[
    {
        "func_name": "crc32_block_endian0",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0051D194 | FF C3 00 D1 | SUB             SP, SP, #0x30\n0x0051D198 | E0 1F 00 B9 | STR             W0, [SP,#0x30+val]\n0x0051D19C | E1 0B 00 F9 | STR             X1, [SP,#0x30+buf]\n0x0051D1A0 | E2 1B 00 B9 | STR             W2, [SP,#0x30+len]\n0x0051D1A4 | E3 07 00 F9 | STR             X3, [SP,#0x30+crc_table]\n0x0051D1A8 | E0 1B 40 B9 | LDR             W0, [SP,#0x30+len]\n0x0051D1AC | E1 0B 40 F9 | LDR             X1, [SP,#0x30+buf]\n0x0051D1B0 | 20 00 00 8B | ADD             X0, X1, X0\n0x0051D1B4 | E0 17 00 F9 | STR             X0, [SP,#0x30+end]\n0x0051D1B8 | 12 00 00 14 | B               loc_51D200\n0x0051D1BC | E0 1F 40 B9 | LDR             W0, [SP,#0x30+val]\n0x0051D1C0 | 01 5C 18 53 | LSL             W1, W0, #8\n0x0051D1C4 | E2 1F 40 B9 | LDR             W2, [SP,#0x30+val]\n0x0051D1C8 | 40 7C 18 53 | LSR             W0, W2, #0x18\n0x0051D1CC | E2 0B 40 F9 | LDR             X2, [SP,#0x30+buf]\n0x0051D1D0 | 42 00 40 39 | LDRB            W2, [X2]\n0x0051D1D4 | 00 00 02 4A | EOR             W0, W0, W2\n0x0051D1D8 | E0 03 00 2A | MOV             W0, W0\n0x0051D1DC | 00 F4 7E D3 | LSL             X0, X0, #2\n0x0051D1E0 | E2 07 40 F9 | LDR             X2, [SP,#0x30+crc_table]\n0x0051D1E4 | 40 00 00 8B | ADD             X0, X2, X0\n0x0051D1E8 | 00 00 40 B9 | LDR             W0, [X0]\n0x0051D1EC | 20 00 00 4A | EOR             W0, W1, W0\n0x0051D1F0 | E0 1F 00 B9 | STR             W0, [SP,#0x30+val]\n0x0051D1F4 | E0 0B 40 F9 | LDR             X0, [SP,#0x30+buf]\n0x0051D1F8 | 00 04 00 91 | ADD             X0, X0, #1\n0x0051D1FC | E0 0B 00 F9 | STR             X0, [SP,#0x30+buf]\n0x0051D200 | E1 0B 40 F9 | LDR             X1, [SP,#0x30+buf]\n0x0051D204 | E0 17 40 F9 | LDR             X0, [SP,#0x30+end]\n0x0051D208 | 3F 00 00 EB | CMP             X1, X0\n0x0051D20C | 81 FD FF 54 | B.NE            loc_51D1BC\n0x0051D210 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+val]\n0x0051D214 | FF C3 00 91 | ADD             SP, SP, #0x30 ; '0'\n0x0051D218 | C0 03 5F D6 | RET\n\n Output decompiled code:\nuint32_t FAST_FUNC crc32_block_endian1(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table)\n{\n\tconst void *end = (uint8_t*)buf + len;\n\n\twhile (buf != end) {\n\t\tval = (val << 8) ^ crc_table[(val >> 24) ^ *(uint8_t*)buf];\n\t\tbuf = (uint8_t*)buf + 1;\n\t}\n\treturn val;\n}\n\n## Example:\n\n Input assembly code:\n0x00525D2C | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x00525D30 | E0 07 00 F9 | STR             X0, [SP,#0x10+int_buf]\n0x00525D34 | E1 07 00 B9 | STR             W1, [SP,#0x10+beg]\n0x00525D38 | E2 03 00 B9 | STR             W2, [SP,#0x10+end]\n0x00525D3C | E1 07 40 B9 | LDR             W1, [SP,#0x10+beg]\n0x00525D40 | E0 03 40 B9 | LDR             W0, [SP,#0x10+end]\n0x00525D44 | 3F 00 00 6B | CMP             W1, W0\n0x00525D48 | C0 02 00 54 | B.EQ            loc_525DA0\n0x00525D4C | 07 00 00 14 | B               loc_525D68\n0x00525D50 | E0 07 40 B9 | LDR             W0, [SP,#0x10+beg]\n0x00525D54 | 00 04 00 11 | ADD             W0, W0, #1\n0x00525D58 | E0 07 00 B9 | STR             W0, [SP,#0x10+beg]\n0x00525D5C | E0 03 40 B9 | LDR             W0, [SP,#0x10+end]\n0x00525D60 | 00 04 00 11 | ADD             W0, W0, #1\n0x00525D64 | E0 03 00 B9 | STR             W0, [SP,#0x10+end]\n0x00525D68 | E0 03 80 B9 | LDRSW           X0, [SP,#0x10+end]\n0x00525D6C | 00 F8 7F D3 | LSL             X0, X0, #1\n0x00525D70 | E1 07 40 F9 | LDR             X1, [SP,#0x10+int_buf]\n0x00525D74 | 21 00 00 8B | ADD             X1, X1, X0\n0x00525D78 | E0 07 80 B9 | LDRSW           X0, [SP,#0x10+beg]\n0x00525D7C | 00 F8 7F D3 | LSL             X0, X0, #1\n0x00525D80 | E2 07 40 F9 | LDR             X2, [SP,#0x10+int_buf]\n0x00525D84 | 40 00 00 8B | ADD             X0, X2, X0\n0x00525D88 | 21 00 C0 79 | LDRSH           W1, [X1]\n0x00525D8C | 01 00 00 79 | STRH            W1, [X0]\n0x00525D90 | 00 00 C0 79 | LDRSH           W0, [X0]\n0x00525D94 | 1F 00 00 71 | CMP             W0, #0\n0x00525D98 | C1 FD FF 54 | B.NE            loc_525D50\n0x00525D9C | 02 00 00 14 | B               loc_525DA4\n0x00525DA0 | 1F 20 03 D5 | NOP\n0x00525DA4 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x00525DA8 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void remove_chunk(int16_t *int_buf, int beg, int end)\n{\n\t/* beg must be <= end */\n\tif (beg == end)\n\t\treturn;\n\n\twhile ((int_buf[beg] = int_buf[end]) != 0)\n\t\tbeg++, end++;\n\n\tif (dbg_bmp) {\n\t\tint i;\n\t\tfor (i = 0; int_buf[i]; i++)\n\t\t\tbb_putchar((unsigned char)int_buf[i]);\n\t\tbb_putchar('\\n');\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x005142D8 | FF 83 00 D1 | SUB             SP, SP, #0x20\n0x005142DC | E0 07 00 F9 | STR             X0, [SP,#0x20+buf]\n0x005142E0 | E1 07 00 B9 | STR             W1, [SP,#0x20+count]\n0x005142E4 | FF 1F 00 B9 | STR             WZR, [SP,#0x20+sum]\n0x005142E8 | E0 07 80 B9 | LDRSW           X0, [SP,#0x20+count]\n0x005142EC | E1 07 40 F9 | LDR             X1, [SP,#0x20+buf]\n0x005142F0 | 20 00 00 8B | ADD             X0, X1, X0\n0x005142F4 | E0 0B 00 F9 | STR             X0, [SP,#0x20+e]\n0x005142F8 | 09 00 00 14 | B               loc_51431C\n0x005142FC | E0 07 40 F9 | LDR             X0, [SP,#0x20+buf]\n0x00514300 | 01 04 00 91 | ADD             X1, X0, #1\n0x00514304 | E1 07 00 F9 | STR             X1, [SP,#0x20+buf]\n0x00514308 | 00 00 40 39 | LDRB            W0, [X0]\n0x0051430C | E1 03 00 2A | MOV             W1, W0\n0x00514310 | E0 1F 40 B9 | LDR             W0, [SP,#0x20+sum]\n0x00514314 | 00 00 01 0B | ADD             W0, W0, W1\n0x00514318 | E0 1F 00 B9 | STR             W0, [SP,#0x20+sum]\n0x0051431C | E1 07 40 F9 | LDR             X1, [SP,#0x20+buf]\n0x00514320 | E0 0B 40 F9 | LDR             X0, [SP,#0x20+e]\n0x00514324 | 3F 00 00 EB | CMP             X1, X0\n0x00514328 | A3 FE FF 54 | B.CC            loc_5142FC\n0x0051432C | E0 1F 40 B9 | LDR             W0, [SP,#0x20+sum]\n0x00514330 | FF 83 00 91 | ADD             SP, SP, #0x20 ; ' '\n0x00514334 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int bufsum(char *buf, int count)\n{\n\tint sum = 0;\n\tchar *e = buf + count;\n\n\twhile (buf < e)\n\t\tsum += (unsigned char) *buf++;\n\treturn sum;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0051D21C | FF C3 00 D1 | SUB             SP, SP, #0x30\n0x0051D220 | E0 1F 00 B9 | STR             W0, [SP,#0x30+val]\n0x0051D224 | E1 0B 00 F9 | STR             X1, [SP,#0x30+buf]\n0x0051D228 | E2 1B 00 B9 | STR             W2, [SP,#0x30+len]\n0x0051D22C | E3 07 00 F9 | STR             X3, [SP,#0x30+crc_table]\n0x0051D230 | E0 1B 40 B9 | LDR             W0, [SP,#0x30+len]\n0x0051D234 | E1 0B 40 F9 | LDR             X1, [SP,#0x30+buf]\n0x0051D238 | 20 00 00 8B | ADD             X0, X1, X0\n0x0051D23C | E0 17 00 F9 | STR             X0, [SP,#0x30+end]\n0x0051D240 | 13 00 00 14 | B               loc_51D28C\n0x0051D244 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+val]\n0x0051D248 | 01 1C 00 12 | AND             W1, W0, #0xFF\n0x0051D24C | E0 0B 40 F9 | LDR             X0, [SP,#0x30+buf]\n0x0051D250 | 00 00 40 39 | LDRB            W0, [X0]\n0x0051D254 | 20 00 00 4A | EOR             W0, W1, W0\n0x0051D258 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x0051D25C | 00 1C 40 92 | AND             X0, X0, #0xFF\n0x0051D260 | 00 F4 7E D3 | LSL             X0, X0, #2\n0x0051D264 | E1 07 40 F9 | LDR             X1, [SP,#0x30+crc_table]\n0x0051D268 | 20 00 00 8B | ADD             X0, X1, X0\n0x0051D26C | 01 00 40 B9 | LDR             W1, [X0]\n0x0051D270 | E2 1F 40 B9 | LDR             W2, [SP,#0x30+val]\n0x0051D274 | 40 7C 08 53 | LSR             W0, W2, #8\n0x0051D278 | 20 00 00 4A | EOR             W0, W1, W0\n0x0051D27C | E0 1F 00 B9 | STR             W0, [SP,#0x30+val]\n0x0051D280 | E0 0B 40 F9 | LDR             X0, [SP,#0x30+buf]\n0x0051D284 | 00 04 00 91 | ADD             X0, X0, #1\n0x0051D288 | E0 0B 00 F9 | STR             X0, [SP,#0x30+buf]\n0x0051D28C | E1 0B 40 F9 | LDR             X1, [SP,#0x30+buf]\n0x0051D290 | E0 17 40 F9 | LDR             X0, [SP,#0x30+end]\n0x0051D294 | 3F 00 00 EB | CMP             X1, X0\n0x0051D298 | 61 FD FF 54 | B.NE            loc_51D244\n0x0051D29C | E0 1F 40 B9 | LDR             W0, [SP,#0x30+val]\n0x0051D2A0 | FF C3 00 91 | ADD             SP, SP, #0x30 ; '0'\n0x0051D2A4 | C0 03 5F D6 | RET",
        "output": "```c\nuint32_t crc32_byte(uint32_t val, const void *buf, unsigned len, const uint32_t *crc_table)\n{\n    const uint8_t *end = (const uint8_t *)buf + len;\n    const uint8_t *ptr = (const uint8_t *)buf;\n\n    while (ptr < end) {\n        val = (val >> 8) ^ crc_table[(val & 0xFF) ^ *ptr++];\n    }\n\n    return val;\n}\n```"
    },
    {
        "func_name": "rc_do_normalize",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004D7AA4 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x004D7AA8 | FD 03 00 91 | MOV             X29, SP\n0x004D7AAC | E0 0F 00 F9 | STR             X0, [SP,#0x20+rc]\n0x004D7AB0 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]; rc\n0x004D7AB4 | 99 FF FF 97 | BL              rc_normalize\n0x004D7AB8 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7ABC | 00 1C 40 B9 | LDR             W0, [X0,#0x1C]\n0x004D7AC0 | 01 7C 01 53 | LSR             W1, W0, #1\n0x004D7AC4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7AC8 | 01 1C 00 B9 | STR             W1, [X0,#0x1C]\n0x004D7ACC | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7AD0 | 01 18 40 B9 | LDR             W1, [X0,#0x18]\n0x004D7AD4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7AD8 | 00 1C 40 B9 | LDR             W0, [X0,#0x1C]\n0x004D7ADC | 3F 00 00 6B | CMP             W1, W0\n0x004D7AE0 | 43 01 00 54 | B.CC            loc_4D7B08\n0x004D7AE4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7AE8 | 01 18 40 B9 | LDR             W1, [X0,#0x18]\n0x004D7AEC | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7AF0 | 00 1C 40 B9 | LDR             W0, [X0,#0x1C]\n0x004D7AF4 | 21 00 00 4B | SUB             W1, W1, W0\n0x004D7AF8 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7AFC | 01 18 00 B9 | STR             W1, [X0,#0x18]\n0x004D7B00 | 20 00 80 52 | MOV             W0, #1\n0x004D7B04 | 02 00 00 14 | B               loc_4D7B0C\n0x004D7B08 | 00 00 80 52 | MOV             W0, #0\n0x004D7B0C | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004D7B10 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic ALWAYS_INLINE int rc_direct_bit(rc_t *rc)\n{\n\trc_normalize(rc);\n\trc->range >>= 1;\n\tif (rc->code >= rc->range) {\n\t\trc->code -= rc->range;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x004941C4 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x004941C8 | FD 03 00 91 | MOV             X29, SP\n0x004941CC | E0 0F 00 F9 | STR             X0, [SP,#0x20+o]\n0x004941D0 | E1 17 00 B9 | STR             W1, [SP,#0x20+len]\n0x004941D4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x004941D8 | 01 08 40 B9 | LDR             W1, [X0,#8]\n0x004941DC | E0 17 40 B9 | LDR             W0, [SP,#0x20+len]\n0x004941E0 | 21 00 00 0B | ADD             W1, W1, W0\n0x004941E4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x004941E8 | 00 0C 40 B9 | LDR             W0, [X0,#0xC]\n0x004941EC | 3F 00 00 6B | CMP             W1, W0\n0x004941F0 | 2D 03 00 54 | B.LE            loc_494254\n0x004941F4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x004941F8 | 00 0C 40 B9 | LDR             W0, [X0,#0xC]\n0x004941FC | E2 03 00 2A | MOV             W2, W0\n0x00494200 | E0 17 40 B9 | LDR             W0, [SP,#0x20+len]\n0x00494204 | 00 78 1F 53 | LSL             W0, W0, #1\n0x00494208 | 01 20 80 52 | MOV             W1, #0x100\n0x0049420C | 1F 00 04 71 | CMP             W0, #0x100\n0x00494210 | 00 20 81 1A | CSEL            W0, W0, W1, CS\n0x00494214 | 40 00 00 0B | ADD             W0, W2, W0\n0x00494218 | E1 03 00 2A | MOV             W1, W0\n0x0049421C | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x00494220 | 01 0C 00 B9 | STR             W1, [X0,#0xC]\n0x00494224 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x00494228 | 02 00 40 F9 | LDR             X2, [X0]\n0x0049422C | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x00494230 | 00 0C 40 B9 | LDR             W0, [X0,#0xC]\n0x00494234 | 00 04 00 11 | ADD             W0, W0, #1\n0x00494238 | 00 7C 40 93 | SXTW            X0, W0\n0x0049423C | E1 03 00 AA | MOV             X1, X0; size\n0x00494240 | E0 03 02 AA | MOV             X0, X2; ptr\n0x00494244 | BA D9 FD 97 | BL              xrealloc\n0x00494248 | E1 03 00 AA | MOV             X1, X0\n0x0049424C | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x00494250 | 01 00 00 F9 | STR             X1, [X0]\n0x00494254 | 1F 20 03 D5 | NOP\n0x00494258 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0049425C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void o_grow_by(o_string *o, int len)\n{\n\tif (o->length + len > o->maxlen) {\n\t\to->maxlen += (2*len > B_CHUNK ? 2*len : B_CHUNK);\n\t\to->data = xrealloc(o->data, 1 + o->maxlen);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x004DC074 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x004DC078 | E0 07 00 F9 | STR             X0, [SP,#0x10+s]\n0x004DC07C | E1 03 00 F9 | STR             X1, [SP,#0x10+b]\n0x004DC080 | E0 03 40 F9 | LDR             X0, [SP,#0x10+b]\n0x004DC084 | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x004DC088 | E0 03 40 F9 | LDR             X0, [SP,#0x10+b]\n0x004DC08C | 00 08 40 F9 | LDR             X0, [X0,#0x10]\n0x004DC090 | 3F 00 00 EB | CMP             X1, X0\n0x004DC094 | 61 00 00 54 | B.NE            loc_4DC0A0\n0x004DC098 | 00 00 80 52 | MOV             W0, #0\n0x004DC09C | 22 00 00 14 | B               loc_4DC124\n0x004DC0A0 | E0 07 40 F9 | LDR             X0, [SP,#0x10+s]\n0x004DC0A4 | 01 20 40 B9 | LDR             W1, [X0,#0x20]\n0x004DC0A8 | E0 07 40 F9 | LDR             X0, [SP,#0x10+s]\n0x004DC0AC | 00 04 40 B9 | LDR             W0, [X0,#4]\n0x004DC0B0 | 20 24 C0 1A | LSR             W0, W1, W0\n0x004DC0B4 | 01 1C 00 12 | AND             W1, W0, #0xFF\n0x004DC0B8 | E0 03 40 F9 | LDR             X0, [SP,#0x10+b]\n0x004DC0BC | 02 00 40 F9 | LDR             X2, [X0]\n0x004DC0C0 | E0 03 40 F9 | LDR             X0, [SP,#0x10+b]\n0x004DC0C4 | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x004DC0C8 | 04 04 00 91 | ADD             X4, X0, #1\n0x004DC0CC | E3 03 40 F9 | LDR             X3, [SP,#0x10+b]\n0x004DC0D0 | 64 04 00 F9 | STR             X4, [X3,#8]\n0x004DC0D4 | 40 00 00 8B | ADD             X0, X2, X0\n0x004DC0D8 | 00 00 40 39 | LDRB            W0, [X0]\n0x004DC0DC | 3F 00 00 6B | CMP             W1, W0\n0x004DC0E0 | 60 00 00 54 | B.EQ            loc_4DC0EC\n0x004DC0E4 | E0 00 80 52 | MOV             W0, #7\n0x004DC0E8 | 0F 00 00 14 | B               loc_4DC124\n0x004DC0EC | E0 07 40 F9 | LDR             X0, [SP,#0x10+s]\n0x004DC0F0 | 00 04 40 B9 | LDR             W0, [X0,#4]\n0x004DC0F4 | 01 20 00 11 | ADD             W1, W0, #8\n0x004DC0F8 | E0 07 40 F9 | LDR             X0, [SP,#0x10+s]\n0x004DC0FC | 01 04 00 B9 | STR             W1, [X0,#4]\n0x004DC100 | E0 07 40 F9 | LDR             X0, [SP,#0x10+s]\n0x004DC104 | 00 04 40 B9 | LDR             W0, [X0,#4]\n0x004DC108 | 1F 7C 00 71 | CMP             W0, #0x1F\n0x004DC10C | A9 FB FF 54 | B.LS            loc_4DC080\n0x004DC110 | E0 07 40 F9 | LDR             X0, [SP,#0x10+s]\n0x004DC114 | 1F 20 00 B9 | STR             WZR, [X0,#0x20]\n0x004DC118 | E0 07 40 F9 | LDR             X0, [SP,#0x10+s]\n0x004DC11C | 1F 04 00 B9 | STR             WZR, [X0,#4]\n0x004DC120 | 20 00 80 52 | MOV             W0, #1\n0x004DC124 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x004DC128 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic enum xz_ret XZ_FUNC crc32_validate(struct xz_dec *s, struct xz_buf *b)\n{\n\tdo {\n\t\tif (b->in_pos == b->in_size)\n\t\t\treturn XZ_OK;\n\n\t\tif (((s->crc32 >> s->pos) & 0xFF) != b->in[b->in_pos++])\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\ts->pos += 8;\n\n\t} while (s->pos < 32);\n\n\ts->crc32 = 0;\n\ts->pos = 0;\n\n\treturn XZ_STREAM_END;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004D7814 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x004D7818 | FD 03 00 91 | MOV             X29, SP\n0x004D781C | E0 0F 00 F9 | STR             X0, [SP,#0x20+rc]\n0x004D7820 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7824 | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x004D7828 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D782C | 00 08 40 F9 | LDR             X0, [X0,#0x10]\n0x004D7830 | 3F 00 00 EB | CMP             X1, X0\n0x004D7834 | 63 00 00 54 | B.CC            loc_4D7840\n0x004D7838 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]; rc\n0x004D783C | D7 FF FF 97 | BL              rc_read\n0x004D7840 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7844 | 00 1C 40 B9 | LDR             W0, [X0,#0x1C]\n0x004D7848 | 01 5C 18 53 | LSL             W1, W0, #8\n0x004D784C | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7850 | 01 1C 00 B9 | STR             W1, [X0,#0x1C]\n0x004D7854 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7858 | 00 18 40 B9 | LDR             W0, [X0,#0x18]\n0x004D785C | 01 5C 18 53 | LSL             W1, W0, #8\n0x004D7860 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7864 | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x004D7868 | 03 04 00 91 | ADD             X3, X0, #1\n0x004D786C | E2 0F 40 F9 | LDR             X2, [SP,#0x20+rc]\n0x004D7870 | 43 04 00 F9 | STR             X3, [X2,#8]\n0x004D7874 | 00 00 40 39 | LDRB            W0, [X0]\n0x004D7878 | 21 00 00 2A | ORR             W1, W1, W0\n0x004D787C | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7880 | 01 18 00 B9 | STR             W1, [X0,#0x18]\n0x004D7884 | 1F 20 03 D5 | NOP\n0x004D7888 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004D788C | C0 03 5F D6 | RET",
        "output": "```c\nstatic void rc_direct_shift(rc_t *rc)\n{\n    if (rc->ptr >= rc->limit)\n        rc_read(rc);\n    rc->range <<= 8;\n    rc->code = (rc->code << 8) | *rc->ptr++;\n}\n```"
    },
    {
        "func_name": "pop",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0046FB64 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0046FB68 | FD 03 00 91 | MOV             X29, SP\n0x0046FB6C | F3 0B 00 F9 | STR             X19, [SP,#0x20+var_10]\n0x0046FB70 | 20 09 00 90 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0046FB78 | 00 24 40 B9 | LDR             W0, [X0,#(bb_common_bufsiz1+0x24 - 0x593290)]\n0x0046FB7C | 1F 00 00 71 | CMP             W0, #0\n0x0046FB80 | A0 00 00 54 | B.EQ            loc_46FB94\n0x0046FB84 | 20 09 00 90 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0046FB8C | 00 24 40 B9 | LDR             W0, [X0,#(bb_common_bufsiz1+0x24 - 0x593290)]\n0x0046FB90 | 18 00 00 14 | B               loc_46FBF0\n0x0046FB94 | 20 02 80 D2 | MOV             X0, #0x11; findme\n0x0046FB98 | D0 FF FF 97 | BL              find_elf_note\n0x0046FB9C | E1 03 00 AA | MOV             X1, X0\n0x0046FBA0 | 20 09 00 90 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0046FBA8 | 01 24 00 B9 | STR             W1, [X0,#(bb_common_bufsiz1+0x24 - 0x593290)]\n0x0046FBAC | 20 09 00 90 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0046FBB4 | 00 24 40 B9 | LDR             W0, [X0,#(bb_common_bufsiz1+0x24 - 0x593290)]\n0x0046FBB8 | 1F 04 00 31 | CMN             W0, #1\n0x0046FBBC | A1 00 00 54 | B.NE            loc_46FBD0\n0x0046FBC0 | 20 09 00 90 | ADRP            X0, #bb_common_bufsiz1@PAGE\n0x0046FBC4 | 13 40 0A 91 | ADD             X19, X0, #bb_common_bufsiz1@PAGEOFF\n0x0046FBC8 | E5 FF FF 97 | BL              get_HZ_by_waiting\n0x0046FBCC | 60 26 00 B9 | STR             W0, [X19,#(bb_common_bufsiz1+0x24 - 0x593290)]\n0x0046FBD0 | B7 FF FF 97 | BL              get_uptime_0\n0x0046FBD4 | E1 03 00 AA | MOV             X1, X0\n0x0046FBD8 | 20 09 00 90 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0046FBE0 | 01 14 00 F9 | STR             X1, [X0,#(bb_common_bufsiz1+0x28 - 0x593290)]\n0x0046FBE4 | 20 09 00 90 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0046FBEC | 00 24 40 B9 | LDR             W0, [X0,#(bb_common_bufsiz1+0x24 - 0x593290)]\n0x0046FBF0 | F3 0B 40 F9 | LDR             X19, [SP,#0x20+var_10]\n0x0046FBF4 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0046FBF8 | C0 03 5F D6 | RET\n\n Output decompiled code:\nendif\n\nstatic unsigned get_kernel_HZ(void)\n{\n\n\tif (kernel_HZ)\n\t\treturn kernel_HZ;\n\n\t/* Works for ELF only, Linux 2.4.0+ */\n\tkernel_HZ = find_elf_note(AT_CLKTCK);\n\tif (kernel_HZ == (unsigned)-1)\n\t\tkernel_HZ = get_HZ_by_waiting();\n\n\tseconds_since_boot = get_uptime();\n\n\treturn kernel_HZ;\n}\n\n## Example:\n\n Input assembly code:\n0x00418840 | FD 7B BF A9 | STP             X29, X30, [SP,#-0x10+var_s0]!\n0x00418844 | FD 03 00 91 | MOV             X29, SP\n0x00418848 | C0 0B 00 F0 | ADRP            X0, #bb_common_bufsiz1@PAGE\n0x0041884C | 01 40 0A 91 | ADD             X1, X0, #bb_common_bufsiz1@PAGEOFF\n0x00418850 | C0 0B 00 F0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x00418858 | 00 00 40 B9 | LDR             W0, [X0]\n0x0041885C | 00 04 00 51 | SUB             W0, W0, #1\n0x00418860 | E0 03 00 2A | MOV             W0, W0\n0x00418864 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00418868 | 20 00 00 8B | ADD             X0, X1, X0\n0x0041886C | 00 04 40 FD | LDR             D0, [X0,#8]; print\n0x00418870 | 90 FF FF 97 | BL              print_base\n0x00418874 | 1F 20 03 D5 | NOP\n0x00418878 | FD 7B C1 A8 | LDP             X29, X30, [SP+var_s0],#0x10\n0x0041887C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void print_no_pop(void)\n{\n\tprint_base(stack[pointer-1]);\n}\n\n## Example:\n\n Input assembly code:\n0x0044A1E8 | FD 7B BF A9 | STP             X29, X30, [SP,#-0x10+var_s0]!\n0x0044A1EC | FD 03 00 91 | MOV             X29, SP\n0x0044A1F0 | 40 0A 00 B0 | ADRP            X0, #(bb_common_bufsiz1+0xA8)@PAGE\n0x0044A1F4 | 01 E0 0C 91 | ADD             X1, X0, #(bb_common_bufsiz1+0xA8)@PAGEOFF; buf\n0x0044A1F8 | 40 0A 00 B0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0044A200 | 00 00 40 B9 | LDR             W0, [X0]\n0x0044A204 | 00 7C 40 93 | SXTW            X0, W0\n0x0044A208 | E2 03 00 AA | MOV             X2, X0; n\n0x0044A20C | 60 00 80 52 | MOV             W0, #3; fd\n0x0044A210 | 1C F4 FE 97 | BL              .write\n0x0044A214 | 40 0A 00 B0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0044A21C | 1F 00 00 B9 | STR             WZR, [X0]\n0x0044A220 | 1F 20 03 D5 | NOP\n0x0044A224 | FD 7B C1 A8 | LDP             X29, X30, [SP+var_s0],#0x10\n0x0044A228 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void iac_flush(void)\n{\n\twrite(netfd, G.iacbuf, G.iaclen);\n\tG.iaclen = 0;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004183C4 | FD 7B BF A9 | STP             X29, X30, [SP,#-0x10+var_s0]!\n0x004183C8 | FD 03 00 91 | MOV             X29, SP\n0x004183CC | C0 0B 00 F0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x004183D4 | 00 00 40 B9 | LDR             W0, [X0]\n0x004183D8 | 1F 00 00 71 | CMP             W0, #0\n0x004183DC | 81 00 00 54 | B.NE            loc_4183EC\n0x004183E0 | 20 09 00 F0 00 60 3E 91 | ADRL            X0, aStackUnderflow; \"stack underflow\"\n0x004183E8 | 23 C6 FF 97 | BL              bb_error_msg_and_die\n0x004183EC | C0 0B 00 F0 | ADRP            X0, #bb_common_bufsiz1@PAGE\n0x004183F0 | 01 40 0A 91 | ADD             X1, X0, #bb_common_bufsiz1@PAGEOFF\n0x004183F4 | C0 0B 00 F0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x004183FC | 02 00 40 B9 | LDR             W2, [X0]\n0x00418400 | 42 04 00 51 | SUB             W2, W2, #1\n0x00418404 | 02 00 00 B9 | STR             W2, [X0]\n0x00418408 | 00 00 40 B9 | LDR             W0, [X0]\n0x0041840C | E0 03 00 2A | MOV             W0, W0\n0x00418410 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00418414 | 20 00 00 8B | ADD             X0, X1, X0\n0x00418418 | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x0041841C | 00 00 67 9E | FMOV            D0, X0\n0x00418420 | FD 7B C1 A8 | LDP             X29, X30, [SP+var_s0],#0x10\n0x00418424 | C0 03 5F D6 | RET",
        "output": "```c\nstatic double pop(void)\n{\n    if (stackptr == 0)\n        bb_error_msg_and_die(\"stack underflow\");\n\n    stackptr--;\n    return stack[stackptr];\n}\n```"
    },
    {
        "func_name": "unset_func",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004B12BC | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x004B12C0 | FD 03 00 91 | MOV             X29, SP\n0x004B12C4 | E0 0F 00 F9 | STR             X0, [SP,#0x40+dumper]\n0x004B12C8 | E1 0B 00 F9 | STR             X1, [SP,#0x40+name]\n0x004B12CC | E0 0B 40 F9 | LDR             X0, [SP,#0x40+name]; path\n0x004B12D0 | D4 62 FD 97 | BL              xfopen_for_read\n0x004B12D4 | E0 1F 00 F9 | STR             X0, [SP,#0x40+fp]\n0x004B12D8 | 11 00 00 14 | B               loc_4B131C\n0x004B12DC | E0 1B 40 F9 | LDR             X0, [SP,#0x40+buf]; s\n0x004B12E0 | 6D 61 FD 97 | BL              skip_whitespace\n0x004B12E4 | E0 17 00 F9 | STR             X0, [SP,#0x40+p]\n0x004B12E8 | E0 17 40 F9 | LDR             X0, [SP,#0x40+p]\n0x004B12EC | 00 00 40 39 | LDRB            W0, [X0]\n0x004B12F0 | 1F 00 00 71 | CMP             W0, #0\n0x004B12F4 | 00 01 00 54 | B.EQ            loc_4B1314\n0x004B12F8 | E0 17 40 F9 | LDR             X0, [SP,#0x40+p]\n0x004B12FC | 00 00 40 39 | LDRB            W0, [X0]\n0x004B1300 | 1F 8C 00 71 | CMP             W0, #0x23 ; '#'\n0x004B1304 | 80 00 00 54 | B.EQ            loc_4B1314\n0x004B1308 | E1 17 40 F9 | LDR             X1, [SP,#0x40+p]; fmt\n0x004B130C | E0 0F 40 F9 | LDR             X0, [SP,#0x40+dumper]; pub_dumper\n0x004B1310 | FF B6 01 94 | BL              bb_dump_add\n0x004B1314 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+buf]; ptr\n0x004B1318 | 72 58 FD 97 | BL              .free\n0x004B131C | E0 1F 40 F9 | LDR             X0, [SP,#0x40+fp]; file\n0x004B1320 | E3 BB 01 94 | BL              xmalloc_fgetline\n0x004B1324 | E0 1B 00 F9 | STR             X0, [SP,#0x40+buf]\n0x004B1328 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+buf]\n0x004B132C | 1F 00 00 F1 | CMP             X0, #0\n0x004B1330 | 61 FD FF 54 | B.NE            loc_4B12DC\n0x004B1334 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+fp]; stream\n0x004B1338 | 8A 56 FD 97 | BL              .fclose\n0x004B133C | 1F 20 03 D5 | NOP\n0x004B1340 | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x004B1344 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void bb_dump_addfile(dumper_t *dumper, char *name)\n{\n\tchar *p;\n\tFILE *fp;\n\tchar *buf;\n\n\tfp = xfopen_for_read(name);\n\twhile ((buf = xmalloc_fgetline(fp)) != NULL) {\n\t\tp = skip_whitespace(buf);\n\t\tif (*p && (*p != '#')) {\n\t\t\tbb_dump_add(dumper, p);\n\t\t}\n\t\tfree(buf);\n\t}\n\tfclose(fp);\n}\n\n## Example:\n\n Input assembly code:\n0x00499F40 | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x00499F44 | FD 03 00 91 | MOV             X29, SP\n0x00499F48 | E0 0F 00 F9 | STR             X0, [SP,#0x40+name]\n0x00499F4C | E0 0F 40 F9 | LDR             X0, [SP,#0x40+name]; name\n0x00499F50 | D5 FF FF 97 | BL              find_function_slot\n0x00499F54 | E0 1B 00 F9 | STR             X0, [SP,#0x40+funcpp]\n0x00499F58 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+funcpp]\n0x00499F5C | 00 00 40 F9 | LDR             X0, [X0]\n0x00499F60 | E0 1F 00 F9 | STR             X0, [SP,#0x40+funcp]\n0x00499F64 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x00499F68 | 1F 00 00 F1 | CMP             X0, #0\n0x00499F6C | 80 03 00 54 | B.EQ            loc_499FDC\n0x00499F70 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x00499F74 | 00 08 40 F9 | LDR             X0, [X0,#0x10]\n0x00499F78 | E0 17 00 F9 | STR             X0, [SP,#0x40+cmd]\n0x00499F7C | E0 17 40 F9 | LDR             X0, [SP,#0x40+cmd]\n0x00499F80 | 1F 00 00 F1 | CMP             X0, #0\n0x00499F84 | 81 01 00 54 | B.NE            loc_499FB4\n0x00499F88 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x00499F8C | 00 04 40 F9 | LDR             X0, [X0,#8]; ptr\n0x00499F90 | 54 B5 FD 97 | BL              .free\n0x00499F94 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x00499F98 | 00 0C 40 F9 | LDR             X0, [X0,#0x18]\n0x00499F9C | 1F 00 00 F1 | CMP             X0, #0\n0x00499FA0 | E0 02 00 54 | B.EQ            loc_499FFC\n0x00499FA4 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x00499FA8 | 00 0C 40 F9 | LDR             X0, [X0,#0x18]; pi\n0x00499FAC | 6D EC FF 97 | BL              free_pipe_list\n0x00499FB0 | 13 00 00 14 | B               loc_499FFC\n0x00499FB4 | E0 17 40 F9 | LDR             X0, [SP,#0x40+cmd]\n0x00499FB8 | 00 10 40 F9 | LDR             X0, [X0,#0x20]\n0x00499FBC | E1 1F 40 F9 | LDR             X1, [SP,#0x40+funcp]\n0x00499FC0 | 21 04 40 F9 | LDR             X1, [X1,#8]\n0x00499FC4 | 01 00 00 F9 | STR             X1, [X0]\n0x00499FC8 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x00499FCC | 01 0C 40 F9 | LDR             X1, [X0,#0x18]\n0x00499FD0 | E0 17 40 F9 | LDR             X0, [SP,#0x40+cmd]\n0x00499FD4 | 01 08 00 F9 | STR             X1, [X0,#0x10]\n0x00499FD8 | 09 00 00 14 | B               loc_499FFC\n0x00499FDC | 00 04 80 D2 | MOV             X0, #0x20 ; ' '; size\n0x00499FE0 | 67 C2 FD 97 | BL              xzalloc\n0x00499FE4 | E1 03 00 AA | MOV             X1, X0\n0x00499FE8 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+funcpp]\n0x00499FEC | 01 00 00 F9 | STR             X1, [X0]\n0x00499FF0 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+funcpp]\n0x00499FF4 | 00 00 40 F9 | LDR             X0, [X0]\n0x00499FF8 | E0 1F 00 F9 | STR             X0, [SP,#0x40+funcp]\n0x00499FFC | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x0049A000 | E1 0F 40 F9 | LDR             X1, [SP,#0x40+name]\n0x0049A004 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x0049A008 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x0049A00C | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x0049A010 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic struct function *new_function(char *name)\n{\n\tstruct function **funcpp = find_function_slot(name);\n\tstruct function *funcp = *funcpp;\n\n\tif (funcp != NULL) {\n\t\tstruct command *cmd = funcp->parent_cmd;\n\t\tdebug_printf_exec(\"func %p parent_cmd %p\\n\", funcp, cmd);\n\t\tif (!cmd) {\n\t\t\tdebug_printf_exec(\"freeing & replacing function '%s'\\n\", funcp->name);\n\t\t\tfree(funcp->name);\n\t\t\t/* Note: if !funcp->body, do not free body_as_string!\n\t\t\t * This is a special case of \"-F name body\" function:\n\t\t\t * body_as_string was not malloced! */\n\t\t\tif (funcp->body) {\n\t\t\t\tfree_pipe_list(funcp->body);\n# if !BB_MMU\n\t\t\t\tfree(funcp->body_as_string);\n# endif\n\t\t\t}\n\t\t} else {\n\t\t\tdebug_printf_exec(\"reinserting in tree & replacing function '%s'\\n\", funcp->name);\n\t\t\tcmd->argv[0] = funcp->name;\n\t\t\tcmd->group = funcp->body;\n# if !BB_MMU\n\t\t\tcmd->group_as_string = funcp->body_as_string;\n# endif\n\t\t}\n\t} else {\n\t\tdebug_printf_exec(\"remembering new function '%s'\\n\", name);\n\t\tfuncp = *funcpp = xzalloc(sizeof(*funcp));\n\t\t/*funcp->next = NULL;*/\n\t}\n\n\tfuncp->name = name;\n\treturn funcp;\n}\n\n## Example:\n\n Input assembly code:\n0x004939CC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004939D0 | FD 03 00 91 | MOV             X29, SP\n0x004939D4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+strings]\n0x004939D8 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+strings]\n0x004939DC | 1F 00 00 F1 | CMP             X0, #0\n0x004939E0 | 80 03 00 54 | B.EQ            loc_493A50\n0x004939E4 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+strings]\n0x004939E8 | E0 17 00 F9 | STR             X0, [SP,#0x30+v]\n0x004939EC | 12 00 00 14 | B               loc_493A34\n0x004939F0 | E0 17 40 F9 | LDR             X0, [SP,#0x30+v]\n0x004939F4 | 00 00 40 F9 | LDR             X0, [X0]; s\n0x004939F8 | A1 07 80 52 | MOV             W1, #0x3D ; '='; c\n0x004939FC | F5 CF FD 97 | BL              .strchrnul\n0x00493A00 | E0 13 00 F9 | STR             X0, [SP,#0x30+eq]\n0x00493A04 | E0 17 40 F9 | LDR             X0, [SP,#0x30+v]\n0x00493A08 | 02 00 40 F9 | LDR             X2, [X0]\n0x00493A0C | E0 17 40 F9 | LDR             X0, [SP,#0x30+v]\n0x00493A10 | 00 00 40 F9 | LDR             X0, [X0]\n0x00493A14 | E1 13 40 F9 | LDR             X1, [SP,#0x30+eq]\n0x00493A18 | 20 00 00 CB | SUB             X0, X1, X0\n0x00493A1C | E1 03 00 2A | MOV             W1, W0; name_len\n0x00493A20 | E0 03 02 AA | MOV             X0, X2; name\n0x00493A24 | 8C FF FF 97 | BL              unset_local_var_len\n0x00493A28 | E0 17 40 F9 | LDR             X0, [SP,#0x30+v]\n0x00493A2C | 00 20 00 91 | ADD             X0, X0, #8\n0x00493A30 | E0 17 00 F9 | STR             X0, [SP,#0x30+v]\n0x00493A34 | E0 17 40 F9 | LDR             X0, [SP,#0x30+v]\n0x00493A38 | 00 00 40 F9 | LDR             X0, [X0]\n0x00493A3C | 1F 00 00 F1 | CMP             X0, #0\n0x00493A40 | 81 FD FF 54 | B.NE            loc_4939F0\n0x00493A44 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+strings]; ptr\n0x00493A48 | A6 CE FD 97 | BL              .free\n0x00493A4C | 02 00 00 14 | B               loc_493A54\n0x00493A50 | 1F 20 03 D5 | NOP\n0x00493A54 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00493A58 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void unset_vars(char **strings)\n{\n\tchar **v;\n\n\tif (!strings)\n\t\treturn;\n\tv = strings;\n\twhile (*v) {\n\t\tconst char *eq = strchrnul(*v, '=');\n\t\tunset_local_var_len(*v, (int)(eq - *v));\n\t\tv++;\n\t}\n\tfree(strings);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0049A014 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0049A018 | FD 03 00 91 | MOV             X29, SP\n0x0049A01C | E0 0F 00 F9 | STR             X0, [SP,#0x30+name]\n0x0049A020 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+name]; name\n0x0049A024 | A0 FF FF 97 | BL              find_function_slot\n0x0049A028 | E0 17 00 F9 | STR             X0, [SP,#0x30+funcpp]\n0x0049A02C | E0 17 40 F9 | LDR             X0, [SP,#0x30+funcpp]\n0x0049A030 | 00 00 40 F9 | LDR             X0, [X0]\n0x0049A034 | E0 13 00 F9 | STR             X0, [SP,#0x30+funcp]\n0x0049A038 | E0 13 40 F9 | LDR             X0, [SP,#0x30+funcp]\n0x0049A03C | 1F 00 00 F1 | CMP             X0, #0\n0x0049A040 | 20 02 00 54 | B.EQ            loc_49A084\n0x0049A044 | E0 13 40 F9 | LDR             X0, [SP,#0x30+funcp]\n0x0049A048 | 01 00 40 F9 | LDR             X1, [X0]\n0x0049A04C | E0 17 40 F9 | LDR             X0, [SP,#0x30+funcpp]\n0x0049A050 | 01 00 00 F9 | STR             X1, [X0]\n0x0049A054 | E0 13 40 F9 | LDR             X0, [SP,#0x30+funcp]\n0x0049A058 | 00 0C 40 F9 | LDR             X0, [X0,#0x18]\n0x0049A05C | 1F 00 00 F1 | CMP             X0, #0\n0x0049A060 | E0 00 00 54 | B.EQ            loc_49A07C\n0x0049A064 | E0 13 40 F9 | LDR             X0, [SP,#0x30+funcp]\n0x0049A068 | 00 0C 40 F9 | LDR             X0, [X0,#0x18]; pi\n0x0049A06C | 3D EC FF 97 | BL              free_pipe_list\n0x0049A070 | E0 13 40 F9 | LDR             X0, [SP,#0x30+funcp]\n0x0049A074 | 00 04 40 F9 | LDR             X0, [X0,#8]; ptr\n0x0049A078 | 1A B5 FD 97 | BL              .free\n0x0049A07C | E0 13 40 F9 | LDR             X0, [SP,#0x30+funcp]; ptr\n0x0049A080 | 18 B5 FD 97 | BL              .free\n0x0049A084 | 1F 20 03 D5 | NOP\n0x0049A088 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0049A08C | C0 03 5F D6 | RET",
        "output": "```c\nstatic void delete_function(char *name)\n{\n    struct function **funcpp = find_function_slot(name);\n    struct function *funcp = *funcpp;\n\n    if (funcp != NULL) {\n        free_pipe_list(funcp->body);\n        free(funcp->name);\n        free(funcp);\n        *funcpp = NULL;\n    }\n}\n```"
    },
    {
        "func_name": "ll_init_map",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0042B088 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0042B08C | FD 03 00 91 | MOV             X29, SP\n0x0042B090 | E0 0F 00 F9 | STR             X0, [SP,#0x20+s]\n0x0042B094 | E2 0B 80 52 | MOV             W2, #0x5F ; '_'; with\n0x0042B098 | A1 05 80 52 | MOV             W1, #0x2D ; '-'; what\n0x0042B09C | E0 0F 40 F9 | LDR             X0, [SP,#0x20+s]; s\n0x0042B0A0 | E3 FF FF 97 | BL              replace_0\n0x0042B0A4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+s]\n0x0042B0A8 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0042B0AC | C0 03 5F D6 | RET\n\n Output decompiled code:\nFAST_FUNC replace_underscores(char *s)\n{\n\treplace(s, '-', '_');\n\treturn s;\n}\n\n## Example:\n\n Input assembly code:\n0x0042EE34 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0042EE38 | FD 03 00 91 | MOV             X29, SP\n0x0042EE3C | E0 0F 00 F9 | STR             X0, [SP,#0x20+str]\n0x0042EE40 | A0 08 00 D0 | ADRP            X0, #asc_544D20@PAGE; \"\\r\\n\"\n0x0042EE44 | 01 80 34 91 | ADD             X1, X0, #asc_544D20@PAGEOFF; \"\\r\\n\"\n0x0042EE48 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+str]; s\n0x0042EE4C | 59 63 FF 97 | BL              .strcspn\n0x0042EE50 | E2 0F 40 F9 | LDR             X2, [SP,#0x20+str]\n0x0042EE54 | E1 03 00 2A | MOV             W1, W0\n0x0042EE58 | A0 08 00 D0 00 A0 34 91 | ADRL            X0, aS_14; \"%.*s\"\n0x0042EE60 | AD 6B FF 97 | BL              bb_error_msg\n0x0042EE64 | 1F 20 03 D5 | NOP\n0x0042EE68 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0042EE6C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void\nverbose_log(const char *str)\n{\n\tbb_error_msg(\"%.*s\", (int)strcspn(str, \"\\r\\n\"), str);\n}\n\n## Example:\n\n Input assembly code:\n0x0041EB04 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0041EB08 | FD 03 00 91 | MOV             X29, SP\n0x0041EB0C | E0 0F 00 F9 | STR             X0, [SP,#0x20+value]\n0x0041EB10 | 02 00 B0 12 | MOV             W2, #0x7FFFFFFF; max\n0x0041EB14 | 01 00 80 52 | MOV             W1, #0; min\n0x0041EB18 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+value]; value\n0x0041EB1C | CF FF FF 97 | BL              parse_opts\n0x0041EB20 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0041EB24 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int parse_opts_0_INTMAX(unsigned long *value)\n{\n\treturn parse_opts(value, 0, INT_MAX);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0045C50C | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0045C510 | FD 03 00 91 | MOV             X29, SP\n0x0045C514 | E0 0F 00 F9 | STR             X0, [SP,#0x20+rth]\n0x0045C518 | 42 02 80 52 | MOV             W2, #0x12; type\n0x0045C51C | 01 00 80 52 | MOV             W1, #0; family\n0x0045C520 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rth]; rth\n0x0045C524 | F3 FA FF 97 | BL              xrtnl_wilddump_request\n0x0045C528 | 02 00 80 D2 | MOV             X2, #0; arg1\n0x0045C52C | 00 00 00 90 | ADRP            X0, #ll_remember_index@PAGE\n0x0045C530 | 01 20 05 91 | ADD             X1, X0, #ll_remember_index@PAGEOFF; filter\n0x0045C534 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rth]; rth\n0x0045C538 | 13 FC FF 97 | BL              xrtnl_dump_filter\n0x0045C53C | 00 00 80 52 | MOV             W0, #0\n0x0045C540 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0045C544 | C0 03 5F D6 | RET",
        "output": "```c\nvoid dump_routing_table(struct rt_handle *rth)\n{\n    xrtnl_wilddump_request(rth, AF_UNSPEC, RTM_GETROUTE);\n    xrtnl_dump_filter(rth, &ll_remember_index, NULL);\n}\n```"
    },
    {
        "func_name": "same_serv_addr_proto",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00470E2C | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00470E30 | FD 03 00 91 | MOV             X29, SP\n0x00470E34 | E0 0F 00 F9 | STR             X0, [SP,#0x30+a]\n0x00470E38 | E1 0B 00 F9 | STR             X1, [SP,#0x30+b]\n0x00470E3C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+a]; s1\n0x00470E40 | E1 0B 40 F9 | LDR             X1, [SP,#0x30+b]; s2\n0x00470E44 | 63 59 FE 97 | BL              .strcmp\n0x00470E48 | 1F 00 00 71 | CMP             W0, #0\n0x00470E4C | 60 00 00 54 | B.EQ            loc_470E58\n0x00470E50 | 00 00 80 52 | MOV             W0, #0\n0x00470E54 | 35 00 00 14 | B               loc_470F28\n0x00470E58 | 20 09 00 B0 00 A0 10 91 | ADRL            X0, option_mask32\n0x00470E60 | 00 00 40 B9 | LDR             W0, [X0]\n0x00470E64 | 1F 00 00 71 | CMP             W0, #0\n0x00470E68 | 20 01 00 54 | B.EQ            loc_470E8C\n0x00470E6C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+a]\n0x00470E70 | 01 14 40 B9 | LDR             W1, [X0,#0x14]\n0x00470E74 | E0 0B 40 F9 | LDR             X0, [SP,#0x30+b]\n0x00470E78 | 00 14 40 B9 | LDR             W0, [X0,#0x14]\n0x00470E7C | 3F 00 00 6B | CMP             W1, W0\n0x00470E80 | 60 00 00 54 | B.EQ            loc_470E8C\n0x00470E84 | 00 00 80 52 | MOV             W0, #0\n0x00470E88 | 28 00 00 14 | B               loc_470F28\n0x00470E8C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+a]\n0x00470E90 | 00 10 40 F9 | LDR             X0, [X0,#0x20]\n0x00470E94 | E0 17 00 F9 | STR             X0, [SP,#0x30+walk_a]\n0x00470E98 | E0 0B 40 F9 | LDR             X0, [SP,#0x30+b]\n0x00470E9C | 00 10 40 F9 | LDR             X0, [X0,#0x20]\n0x00470EA0 | E0 13 00 F9 | STR             X0, [SP,#0x30+walk_b]\n0x00470EA4 | 12 00 00 14 | B               loc_470EEC\n0x00470EA8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+walk_a]\n0x00470EAC | 02 00 40 F9 | LDR             X2, [X0]\n0x00470EB0 | E0 13 40 F9 | LDR             X0, [SP,#0x30+walk_b]\n0x00470EB4 | 00 00 40 F9 | LDR             X0, [X0]\n0x00470EB8 | E1 03 00 AA | MOV             X1, X0; b\n0x00470EBC | E0 03 02 AA | MOV             X0, X2; a\n0x00470EC0 | DB FF FF 97 | BL              tree_equal\n0x00470EC4 | 1F 00 00 71 | CMP             W0, #0\n0x00470EC8 | 61 00 00 54 | B.NE            loc_470ED4\n0x00470ECC | 00 00 80 52 | MOV             W0, #0\n0x00470ED0 | 16 00 00 14 | B               loc_470F28\n0x00470ED4 | E0 17 40 F9 | LDR             X0, [SP,#0x30+walk_a]\n0x00470ED8 | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x00470EDC | E0 17 00 F9 | STR             X0, [SP,#0x30+walk_a]\n0x00470EE0 | E0 13 40 F9 | LDR             X0, [SP,#0x30+walk_b]\n0x00470EE4 | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x00470EE8 | E0 13 00 F9 | STR             X0, [SP,#0x30+walk_b]\n0x00470EEC | E0 17 40 F9 | LDR             X0, [SP,#0x30+walk_a]\n0x00470EF0 | 1F 00 00 F1 | CMP             X0, #0\n0x00470EF4 | 80 00 00 54 | B.EQ            loc_470F04\n0x00470EF8 | E0 13 40 F9 | LDR             X0, [SP,#0x30+walk_b]\n0x00470EFC | 1F 00 00 F1 | CMP             X0, #0\n0x00470F00 | 41 FD FF 54 | B.NE            loc_470EA8\n0x00470F04 | E0 17 40 F9 | LDR             X0, [SP,#0x30+walk_a]\n0x00470F08 | 1F 00 00 F1 | CMP             X0, #0\n0x00470F0C | C1 00 00 54 | B.NE            loc_470F24\n0x00470F10 | E0 13 40 F9 | LDR             X0, [SP,#0x30+walk_b]\n0x00470F14 | 1F 00 00 F1 | CMP             X0, #0\n0x00470F18 | 61 00 00 54 | B.NE            loc_470F24\n0x00470F1C | 20 00 80 52 | MOV             W0, #1\n0x00470F20 | 02 00 00 14 | B               loc_470F28\n0x00470F24 | 00 00 80 52 | MOV             W0, #0\n0x00470F28 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00470F2C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int tree_equal(const PROC *a, const PROC *b)\n{\n\tconst CHILD *walk_a, *walk_b;\n\n\tif (strcmp(a->comm, b->comm) != 0)\n\t\treturn 0;\n\tif ((option_mask32 /*& OPT_PID*/) && a->pid != b->pid)\n\t\treturn 0;\n\n\tfor (walk_a = a->children, walk_b = b->children;\n\t  walk_a && walk_b;\n\t  walk_a = walk_a->next, walk_b = walk_b->next\n\t) {\n\t\tif (!tree_equal(walk_a->child, walk_b->child))\n\t\t\treturn 0;\n\t}\n\n\treturn !(walk_a || walk_b);\n}\n\n## Example:\n\n Input assembly code:\n0x0050D458 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0050D45C | FD 03 00 91 | MOV             X29, SP\n0x0050D460 | E0 0F 00 F9 | STR             X0, [SP,#0x30+sed_cmd]\n0x0050D464 | E1 0B 00 F9 | STR             X1, [SP,#0x30+pattern_space]\n0x0050D468 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+sed_cmd]\n0x0050D46C | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x0050D470 | 1F 00 00 F1 | CMP             X0, #0\n0x0050D474 | 80 01 00 54 | B.EQ            loc_50D4A4\n0x0050D478 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+sed_cmd]\n0x0050D47C | 00 04 40 F9 | LDR             X0, [X0,#8]; preg\n0x0050D480 | 04 00 80 52 | MOV             W4, #0; eflags\n0x0050D484 | 03 00 80 D2 | MOV             X3, #0; pmatch\n0x0050D488 | 02 00 80 D2 | MOV             X2, #0; nmatch\n0x0050D48C | E1 0B 40 F9 | LDR             X1, [SP,#0x30+pattern_space]; string\n0x0050D490 | 78 E9 FB 97 | BL              .regexec\n0x0050D494 | 1F 00 00 71 | CMP             W0, #0\n0x0050D498 | 61 00 00 54 | B.NE            loc_50D4A4\n0x0050D49C | 20 00 80 52 | MOV             W0, #1\n0x0050D4A0 | 02 00 00 14 | B               loc_50D4A8\n0x0050D4A4 | 00 00 80 52 | MOV             W0, #0\n0x0050D4A8 | E0 2F 00 B9 | STR             W0, [SP,#0x30+retval]\n0x0050D4AC | E0 2F 40 B9 | LDR             W0, [SP,#0x30+retval]\n0x0050D4B0 | 1F 00 00 71 | CMP             W0, #0\n0x0050D4B4 | C0 00 00 54 | B.EQ            loc_50D4CC\n0x0050D4B8 | 20 04 00 D0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0050D4C0 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+sed_cmd]\n0x0050D4C4 | 21 04 40 F9 | LDR             X1, [X1,#8]\n0x0050D4C8 | 01 40 00 F9 | STR             X1, [X0,#(bb_common_bufsiz1+0x80 - 0x593290)]\n0x0050D4CC | E0 2F 40 B9 | LDR             W0, [SP,#0x30+retval]\n0x0050D4D0 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0050D4D4 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int beg_match(sed_cmd_t *sed_cmd, const char *pattern_space)\n{\n\tint retval = sed_cmd->beg_match && !regexec(sed_cmd->beg_match, pattern_space, 0, NULL, 0);\n\tif (retval)\n\t\tG.previous_regex_ptr = sed_cmd->beg_match;\n\treturn retval;\n}\n\n## Example:\n\n Input assembly code:\n0x004BE360 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004BE364 | FD 03 00 91 | MOV             X29, SP\n0x004BE368 | E0 0F 00 F9 | STR             X0, [SP,#0x30+spec]\n0x004BE36C | 20 00 80 52 | MOV             W0, #1; scan_devices\n0x004BE370 | 8B FF FF 97 | BL              uuidcache_init\n0x004BE374 | E0 17 00 F9 | STR             X0, [SP,#0x30+uc]\n0x004BE378 | 14 00 00 14 | B               loc_4BE3C8\n0x004BE37C | E0 17 40 F9 | LDR             X0, [SP,#0x30+uc]\n0x004BE380 | 00 08 40 F9 | LDR             X0, [X0,#0x10]\n0x004BE384 | 00 00 40 39 | LDRB            W0, [X0]\n0x004BE388 | 1F 00 00 71 | CMP             W0, #0\n0x004BE38C | 80 01 00 54 | B.EQ            loc_4BE3BC\n0x004BE390 | E0 17 40 F9 | LDR             X0, [SP,#0x30+uc]\n0x004BE394 | 00 08 40 F9 | LDR             X0, [X0,#0x10]\n0x004BE398 | E1 03 00 AA | MOV             X1, X0; s2\n0x004BE39C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+spec]; s1\n0x004BE3A0 | 0C 24 FD 97 | BL              .strcmp\n0x004BE3A4 | 1F 00 00 71 | CMP             W0, #0\n0x004BE3A8 | A1 00 00 54 | B.NE            loc_4BE3BC\n0x004BE3AC | E0 17 40 F9 | LDR             X0, [SP,#0x30+uc]\n0x004BE3B0 | 00 04 40 F9 | LDR             X0, [X0,#8]; s\n0x004BE3B4 | 7F 31 FD 97 | BL              xstrdup\n0x004BE3B8 | 08 00 00 14 | B               loc_4BE3D8\n0x004BE3BC | E0 17 40 F9 | LDR             X0, [SP,#0x30+uc]\n0x004BE3C0 | 00 00 40 F9 | LDR             X0, [X0]\n0x004BE3C4 | E0 17 00 F9 | STR             X0, [SP,#0x30+uc]\n0x004BE3C8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+uc]\n0x004BE3CC | 1F 00 00 F1 | CMP             X0, #0\n0x004BE3D0 | 61 FD FF 54 | B.NE            loc_4BE37C\n0x004BE3D4 | 00 00 80 D2 | MOV             X0, #0\n0x004BE3D8 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004BE3DC | C0 03 5F D6 | RET\n\n Output decompiled code:\nchar *get_devname_from_label(const char *spec)\n{\n\tstruct uuidCache_s *uc;\n\n\tuc = uuidcache_init(/*scan_devices:*/ 1);\n\twhile (uc) {\n\t\tif (uc->label[0] && strcmp(spec, uc->label) == 0) {\n\t\t\treturn xstrdup(uc->device);\n\t\t}\n\t\tuc = uc->next;\n\t}\n\treturn NULL;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043BF88 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0043BF8C | FD 03 00 91 | MOV             X29, SP\n0x0043BF90 | E0 0F 00 F9 | STR             X0, [SP,#0x20+old]\n0x0043BF94 | E1 0B 00 F9 | STR             X1, [SP,#0x20+new]\n0x0043BF98 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+old]\n0x0043BF9C | 02 04 40 F9 | LDR             X2, [X0,#8]\n0x0043BFA0 | E0 0B 40 F9 | LDR             X0, [SP,#0x20+new]\n0x0043BFA4 | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x0043BFA8 | E1 03 00 AA | MOV             X1, X0; s2\n0x0043BFAC | E0 03 02 AA | MOV             X0, X2; s1\n0x0043BFB0 | 08 2D FF 97 | BL              .strcmp\n0x0043BFB4 | 1F 00 00 71 | CMP             W0, #0\n0x0043BFB8 | 60 00 00 54 | B.EQ            loc_43BFC4\n0x0043BFBC | 00 00 80 52 | MOV             W0, #0\n0x0043BFC0 | 18 00 00 14 | B               loc_43C020\n0x0043BFC4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+old]\n0x0043BFC8 | 02 08 40 F9 | LDR             X2, [X0,#0x10]\n0x0043BFCC | E0 0B 40 F9 | LDR             X0, [SP,#0x20+new]\n0x0043BFD0 | 00 08 40 F9 | LDR             X0, [X0,#0x10]\n0x0043BFD4 | E1 03 00 AA | MOV             X1, X0; s2\n0x0043BFD8 | E0 03 02 AA | MOV             X0, X2; s1\n0x0043BFDC | FD 2C FF 97 | BL              .strcmp\n0x0043BFE0 | 1F 00 00 71 | CMP             W0, #0\n0x0043BFE4 | 60 00 00 54 | B.EQ            loc_43BFF0\n0x0043BFE8 | 00 00 80 52 | MOV             W0, #0\n0x0043BFEC | 0D 00 00 14 | B               loc_43C020\n0x0043BFF0 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+old]\n0x0043BFF4 | 02 0C 40 F9 | LDR             X2, [X0,#0x18]\n0x0043BFF8 | E0 0B 40 F9 | LDR             X0, [SP,#0x20+new]\n0x0043BFFC | 00 0C 40 F9 | LDR             X0, [X0,#0x18]\n0x0043C000 | E1 03 00 AA | MOV             X1, X0; s2\n0x0043C004 | E0 03 02 AA | MOV             X0, X2; s1\n0x0043C008 | F2 2C FF 97 | BL              .strcmp\n0x0043C00C | 1F 00 00 71 | CMP             W0, #0\n0x0043C010 | 60 00 00 54 | B.EQ            loc_43C01C\n0x0043C014 | 00 00 80 52 | MOV             W0, #0\n0x0043C018 | 02 00 00 14 | B               loc_43C020\n0x0043C01C | 20 00 80 52 | MOV             W0, #1\n0x0043C020 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0043C024 | C0 03 5F D6 | RET",
        "output": "```c\nint compare_entries(const ENTRY *old, const ENTRY *new)\n{\n    if (strcmp(old->field1, new->field1) != 0)\n        return 0;\n    if (strcmp(old->field2, new->field2) != 0)\n        return 0;\n    if (strcmp(old->field3, new->field3) != 0)\n        return 0;\n    return 1;\n}\n```"
    },
    {
        "func_name": "bsPutU32",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004C5C6C | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x004C5C70 | FD 03 00 91 | MOV             X29, SP\n0x004C5C74 | E0 0F 00 F9 | STR             X0, [SP,#0x20+s]\n0x004C5C78 | E1 17 00 B9 | STR             W1, [SP,#0x20+u]\n0x004C5C7C | E0 17 40 B9 | LDR             W0, [SP,#0x20+u]\n0x004C5C80 | 00 7C 08 53 | LSR             W0, W0, #8\n0x004C5C84 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x004C5C88 | E2 03 00 2A | MOV             W2, W0; v\n0x004C5C8C | 01 01 80 52 | MOV             W1, #8; n\n0x004C5C90 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+s]; s\n0x004C5C94 | 9C FF FF 97 | BL              bsW\n0x004C5C98 | E0 17 40 B9 | LDR             W0, [SP,#0x20+u]\n0x004C5C9C | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x004C5CA0 | E2 03 00 2A | MOV             W2, W0; v\n0x004C5CA4 | 01 01 80 52 | MOV             W1, #8; n\n0x004C5CA8 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+s]; s\n0x004C5CAC | 96 FF FF 97 | BL              bsW\n0x004C5CB0 | 1F 20 03 D5 | NOP\n0x004C5CB4 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004C5CB8 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic\nvoid bsPutU16(EState* s, unsigned u)\n{\n\tbsW(s, 8, (u >>  8) & 0xff);\n\tbsW(s, 8,  u        & 0xff);\n}\n\n## Example:\n\n Input assembly code:\n0x004E30B8 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004E30BC | FD 03 00 91 | MOV             X29, SP\n0x004E30C0 | E0 0F 00 F9 | STR             X0, [SP,#0x30+str]\n0x004E30C4 | E1 17 00 B9 | STR             W1, [SP,#0x30+len]\n0x004E30C8 | E2 13 00 B9 | STR             W2, [SP,#0x30+separate]\n0x004E30CC | E0 0F 40 F9 | LDR             X0, [SP,#0x30+str]; s\n0x004E30D0 | A0 8D FC 97 | BL              .strlen\n0x004E30D4 | E0 2F 00 B9 | STR             W0, [SP,#0x30+n]\n0x004E30D8 | E1 17 40 B9 | LDR             W1, [SP,#0x30+len]\n0x004E30DC | E0 2F 40 B9 | LDR             W0, [SP,#0x30+n]\n0x004E30E0 | 20 00 00 4B | SUB             W0, W1, W0\n0x004E30E4 | E0 17 00 B9 | STR             W0, [SP,#0x30+len]\n0x004E30E8 | E0 17 40 B9 | LDR             W0, [SP,#0x30+len]\n0x004E30EC | 01 7C 01 53 | LSR             W1, W0, #1\n0x004E30F0 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+n]\n0x004E30F4 | 25 00 00 0B | ADD             W5, W1, W0\n0x004E30F8 | E0 17 40 B9 | LDR             W0, [SP,#0x30+len]\n0x004E30FC | 01 7C 01 53 | LSR             W1, W0, #1\n0x004E3100 | E0 17 40 B9 | LDR             W0, [SP,#0x30+len]\n0x004E3104 | 00 00 00 12 | AND             W0, W0, #1\n0x004E3108 | 21 00 00 0B | ADD             W1, W1, W0\n0x004E310C | E0 13 40 B9 | LDR             W0, [SP,#0x30+separate]\n0x004E3110 | 21 00 00 0B | ADD             W1, W1, W0\n0x004E3114 | A0 03 00 D0 | ADRP            X0, #byte_5590E8@PAGE\n0x004E3118 | 04 A0 03 91 | ADD             X4, X0, #byte_5590E8@PAGEOFF\n0x004E311C | E3 03 01 2A | MOV             W3, W1\n0x004E3120 | E2 0F 40 F9 | LDR             X2, [SP,#0x30+str]\n0x004E3124 | E1 03 05 2A | MOV             W1, W5\n0x004E3128 | A0 03 00 D0 00 A0 04 91 | ADRL            X0, aSS_34; \"%*s%*s\"\n0x004E3130 | A8 92 FC 97 | BL              .printf\n0x004E3134 | 1F 20 03 D5 | NOP\n0x004E3138 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004E313C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void center(char *str, unsigned len, unsigned separate)\n{\n\tunsigned n = strlen(str);\n\tlen -= n;\n\tprintf(\"%*s%*s\", (len/2) + n, str, (len/2) + (len % 2) + separate, \"\");\n}\n\n## Example:\n\n Input assembly code:\n0x004EAEB0 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x004EAEB4 | FD 03 00 91 | MOV             X29, SP\n0x004EAEB8 | E0 0F 00 F9 | STR             X0, [SP,#0x20+dn]\n0x004EAEBC | E1 17 00 B9 | STR             W1, [SP,#0x20+nfiles]\n0x004EAEC0 | E0 17 40 B9 | LDR             W0, [SP,#0x20+nfiles]\n0x004EAEC4 | E1 03 00 2A | MOV             W1, W0; size\n0x004EAEC8 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+dn]; dn\n0x004EAECC | EC FF FF 97 | BL              dnsort\n0x004EAED0 | E1 17 40 B9 | LDR             W1, [SP,#0x20+nfiles]; nfiles\n0x004EAED4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+dn]; dn\n0x004EAED8 | 6E FD FF 97 | BL              display_files\n0x004EAEDC | 1F 20 03 D5 | NOP\n0x004EAEE0 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004EAEE4 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void sort_and_display_files(struct dnode **dn, unsigned nfiles)\n{\n\tdnsort(dn, nfiles);\n\tdisplay_files(dn, nfiles);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C5BE8 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x004C5BEC | FD 03 00 91 | MOV             X29, SP\n0x004C5BF0 | E0 0F 00 F9 | STR             X0, [SP,#0x20+s]\n0x004C5BF4 | E1 17 00 B9 | STR             W1, [SP,#0x20+u]\n0x004C5BF8 | E0 17 40 B9 | LDR             W0, [SP,#0x20+u]\n0x004C5BFC | 01 7C 18 53 | LSR             W1, W0, #0x18\n0x004C5C00 | E2 03 01 2A | MOV             W2, W1; v\n0x004C5C04 | 01 01 80 52 | MOV             W1, #8; n\n0x004C5C08 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+s]; s\n0x004C5C0C | BE FF FF 97 | BL              bsW\n0x004C5C10 | E0 17 40 B9 | LDR             W0, [SP,#0x20+u]\n0x004C5C14 | 00 7C 10 53 | LSR             W0, W0, #0x10\n0x004C5C18 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x004C5C1C | E2 03 00 2A | MOV             W2, W0; v\n0x004C5C20 | 01 01 80 52 | MOV             W1, #8; n\n0x004C5C24 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+s]; s\n0x004C5C28 | B7 FF FF 97 | BL              bsW\n0x004C5C2C | E0 17 40 B9 | LDR             W0, [SP,#0x20+u]\n0x004C5C30 | 00 7C 08 53 | LSR             W0, W0, #8\n0x004C5C34 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x004C5C38 | E2 03 00 2A | MOV             W2, W0; v\n0x004C5C3C | 01 01 80 52 | MOV             W1, #8; n\n0x004C5C40 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+s]; s\n0x004C5C44 | B0 FF FF 97 | BL              bsW\n0x004C5C48 | E0 17 40 B9 | LDR             W0, [SP,#0x20+u]\n0x004C5C4C | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x004C5C50 | E2 03 00 2A | MOV             W2, W0; v\n0x004C5C54 | 01 01 80 52 | MOV             W1, #8; n\n0x004C5C58 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+s]; s\n0x004C5C5C | AA FF FF 97 | BL              bsW\n0x004C5C60 | 1F 20 03 D5 | NOP\n0x004C5C64 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004C5C68 | C0 03 5F D6 | RET",
        "output": "```c\nstatic void bsPutU32(EState* s, unsigned u)\n{\n    bsW(s, 8, (u >> 24) & 0xff);\n    bsW(s, 8, (u >> 16) & 0xff);\n    bsW(s, 8, (u >>  8) & 0xff);\n    bsW(s, 8,  u        & 0xff);\n}\n```"
    },
    {
        "func_name": "send_r_n",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0049D524 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0049D528 | FD 03 00 91 | MOV             X29, SP\n0x0049D52C | E0 0F 00 F9 | STR             X0, [SP,#0x20+argv]\n0x0049D530 | C0 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0049D538 | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D53C | 00 A8 40 B9 | LDR             W0, [X0,#0xA8]\n0x0049D540 | 1F 00 00 71 | CMP             W0, #0\n0x0049D544 | 21 01 00 54 | B.NE            loc_49D568\n0x0049D548 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+argv]\n0x0049D54C | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D550 | E1 03 00 AA | MOV             X1, X0\n0x0049D554 | A0 05 00 90 00 00 15 91 | ADRL            X0, aSNotInAFunctio_0; \"%s: not in a function\"\n0x0049D55C | EE B1 FD 97 | BL              bb_error_msg\n0x0049D560 | 20 00 80 52 | MOV             W0, #1\n0x0049D564 | 0A 00 00 14 | B               loc_49D58C\n0x0049D568 | C0 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0049D570 | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D574 | 00 A8 40 B9 | LDR             W0, [X0,#0xA8]\n0x0049D578 | E2 03 00 2A | MOV             W2, W0; lvl\n0x0049D57C | 01 00 80 52 | MOV             W1, #0; exp\n0x0049D580 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+argv]; argv\n0x0049D584 | 49 FF FF 97 | BL              helper_export_local\n0x0049D588 | 00 00 80 52 | MOV             W0, #0\n0x0049D58C | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0049D590 | C0 03 5F D6 | RET\n\n Output decompiled code:\nif ENABLE_HUSH_LOCAL\nstatic int FAST_FUNC builtin_local(char **argv)\n{\n\tif (G.func_nest_level == 0) {\n\t\tbb_error_msg(\"%s: not in a function\", argv[0]);\n\t\treturn EXIT_FAILURE; /* bash compat */\n\t}\n\thelper_export_local(argv, 0, G.func_nest_level);\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input assembly code:\n0x00460B34 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00460B38 | FD 03 00 91 | MOV             X29, SP\n0x00460B3C | E0 0F 00 F9 | STR             X0, [SP,#0x20+dhcp_pkt]\n0x00460B40 | A0 09 00 B0 00 10 11 91 | ADRL            X0, dhcp_verbose\n0x00460B48 | 00 00 40 B9 | LDR             W0, [X0]\n0x00460B4C | 1F 00 00 71 | CMP             W0, #0\n0x00460B50 | 80 00 00 54 | B.EQ            loc_460B60\n0x00460B54 | 40 07 00 F0 00 60 3B 91 | ADRL            X0, aForwardingPack; \"Forwarding packet to relay\"\n0x00460B5C | 54 0F 03 94 | BL              bb_info_msg\n0x00460B60 | 80 09 00 F0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x00460B68 | 01 0C 40 B9 | LDR             W1, [X0,#(bb_common_bufsiz1+0xC - 0x593290)]; source_nip\n0x00460B6C | E0 0F 40 F9 | LDR             X0, [SP,#0x20+dhcp_pkt]\n0x00460B70 | 00 18 40 B9 | LDR             W0, [X0,#0x18]\n0x00460B74 | 64 08 80 52 | MOV             W4, #0x43 ; 'C'; dest_port\n0x00460B78 | E3 03 00 2A | MOV             W3, W0; dest_nip\n0x00460B7C | 62 08 80 52 | MOV             W2, #0x43 ; 'C'; source_port\n0x00460B80 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+dhcp_pkt]; dhcp_pkt\n0x00460B84 | C5 0D 00 94 | BL              udhcp_send_kernel_packet\n0x00460B88 | 1F 20 03 D5 | NOP\n0x00460B8C | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00460B90 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void send_packet_to_relay(struct dhcp_packet *dhcp_pkt)\n{\n\tlog1(\"Forwarding packet to relay\");\n\n\tudhcp_send_kernel_packet(dhcp_pkt,\n\t\t\tserver_config.server_nip, SERVER_PORT,\n\t\t\tdhcp_pkt->gateway_nip, SERVER_PORT);\n}\n\n## Example:\n\n Input assembly code:\n0x0040B224 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0040B228 | FD 03 00 91 | MOV             X29, SP\n0x0040B22C | E0 0F 00 F9 | STR             X0, [SP,#0x20+path]\n0x0040B230 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+path]; path\n0x0040B234 | 7F F1 FF 97 | BL              .chroot\n0x0040B238 | 1F 00 00 71 | CMP             W0, #0\n0x0040B23C | A0 00 00 54 | B.EQ            loc_40B250\n0x0040B240 | E1 0F 40 F9 | LDR             X1, [SP,#0x20+path]\n0x0040B244 | 80 09 00 F0 00 20 0F 91 | ADRL            X0, aCanTChangeRoot; \"can't change root directory to '%s'\"\n0x0040B24C | 4B F9 FF 97 | BL              bb_perror_msg_and_die\n0x0040B250 | 80 09 00 F0 00 C0 0F 91 | ADRL            X0, asc_53E3F0; \"/\"\n0x0040B258 | E5 FF FF 97 | BL              xchdir\n0x0040B25C | 1F 20 03 D5 | NOP\n0x0040B260 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0040B264 | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid FAST_FUNC xchroot(const char *path)\n{\n\tif (chroot(path))\n\t\tbb_perror_msg_and_die(\"can't change root directory to '%s'\", path);\n\txchdir(\"/\");\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00412AC4 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00412AC8 | FD 03 00 91 | MOV             X29, SP\n0x00412ACC | E0 0F 00 F9 | STR             X0, [SP,#0x20+s]\n0x00412AD0 | 00 0C 00 F0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00412AD8 | 00 00 40 F9 | LDR             X0, [X0]\n0x00412ADC | 00 08 40 B9 | LDR             W0, [X0,#8]\n0x00412AE0 | 1F 00 00 71 | CMP             W0, #0\n0x00412AE4 | A0 00 00 54 | B.EQ            loc_412AF8\n0x00412AE8 | E1 0F 40 F9 | LDR             X1, [SP,#0x20+s]\n0x00412AEC | 60 09 00 B0 00 60 10 91 | ADRL            X0, aSendS; \"send:'%s'\"\n0x00412AF4 | 88 DC FF 97 | BL              bb_error_msg\n0x00412AF8 | E1 0F 40 F9 | LDR             X1, [SP,#0x20+s]\n0x00412AFC | 60 09 00 B0 00 A0 10 91 | ADRL            X0, aS_2; \"%s\\r\\n\"\n0x00412B04 | 33 D4 FF 97 | BL              .printf\n0x00412B08 | 1F 20 03 D5 | NOP\n0x00412B0C | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00412B10 | C0 03 5F D6 | RET",
        "output": "```c\nvoid send_msg(const char *s)\n{\n    if (ptr_to_globals->flag == 0) {\n        bb_error_msg(\"send:'%s'\", s);\n    }\n    printf(\"%s\\r\\n\", s);\n}\n```"
    },
    {
        "func_name": "read_to_buf",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00529540 | FD 7B AE A9 | STP             X29, X30, [SP,#var_120]!\n0x00529544 | FD 03 00 91 | MOV             X29, SP\n0x00529548 | E0 0F 00 F9 | STR             X0, [SP,#0x120+device]\n0x0052954C | FF 8F 00 F9 | STR             XZR, [SP,#0x120+dev]\n0x00529550 | 01 00 80 52 | MOV             W1, #0; oflag\n0x00529554 | E0 0F 40 F9 | LDR             X0, [SP,#0x120+device]; file\n0x00529558 | F2 78 FB 97 | BL              .open64\n0x0052955C | E0 17 01 B9 | STR             W0, [SP,#0x120+fd]\n0x00529560 | E0 17 41 B9 | LDR             W0, [SP,#0x120+fd]\n0x00529564 | 1F 00 00 71 | CMP             W0, #0\n0x00529568 | 6B 02 00 54 | B.LT            loc_5295B4\n0x0052956C | E0 A3 00 91 | ADD             X0, SP, #0x120+loopinfo\n0x00529570 | E2 03 00 AA | MOV             X2, X0\n0x00529574 | A1 80 89 D2 | MOV             X1, #0x4C05; request\n0x00529578 | E0 17 41 B9 | LDR             W0, [SP,#0x120+fd]; fd\n0x0052957C | 05 7A FB 97 | BL              .ioctl\n0x00529580 | 1F 00 00 71 | CMP             W0, #0\n0x00529584 | 41 01 00 54 | B.NE            loc_5295AC\n0x00529588 | E0 23 40 F9 | LDR             X0, [SP,#0x120+loopinfo.lo_offset]\n0x0052958C | E1 03 00 AA | MOV             X1, X0\n0x00529590 | E0 A3 00 91 | ADD             X0, SP, #0x120+loopinfo\n0x00529594 | 00 E0 00 91 | ADD             X0, X0, #0x38 ; '8'\n0x00529598 | E2 03 00 AA | MOV             X2, X0\n0x0052959C | A0 01 00 D0 00 C0 2B 91 | ADRL            X0, aLuS; \"%lu %s\"\n0x005295A4 | 93 86 FB 97 | BL              xasprintf\n0x005295A8 | E0 8F 00 F9 | STR             X0, [SP,#0x120+dev]\n0x005295AC | E0 17 41 B9 | LDR             W0, [SP,#0x120+fd]; fd\n0x005295B0 | 10 77 FB 97 | BL              .close\n0x005295B4 | E0 8F 40 F9 | LDR             X0, [SP,#0x120+dev]\n0x005295B8 | FD 7B D2 A8 | LDP             X29, X30, [SP+0x120+var_120],#0x120\n0x005295BC | C0 03 5F D6 | RET\n\n Output decompiled code:\nFAST_FUNC query_loop(const char *device)\n{\n\tint fd;\n\tbb_loop_info loopinfo;\n\tchar *dev = NULL;\n\n\tfd = open(device, O_RDONLY);\n\tif (fd >= 0) {\n\t\tif (ioctl(fd, BB_LOOP_GET_STATUS, &loopinfo) == 0) {\n\t\t\tdev = xasprintf(\"%\"OFF_FMT\"u %s\", (off_t) loopinfo.lo_offset,\n\t\t\t\t\t(char *)loopinfo.lo_file_name);\n\t\t}\n\t\tclose(fd);\n\t}\n\n\treturn dev;\n}\n\n## Example:\n\n Input assembly code:\n0x0052FFA4 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0052FFA8 | FD 03 00 91 | MOV             X29, SP\n0x0052FFAC | E0 0F 00 F9 | STR             X0, [SP,#0x30+filename]\n0x0052FFB0 | E1 0B 00 F9 | STR             X1, [SP,#0x30+maxsz_p]\n0x0052FFB4 | 01 00 80 52 | MOV             W1, #0; oflag\n0x0052FFB8 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+filename]; file\n0x0052FFBC | 59 5E FB 97 | BL              .open64\n0x0052FFC0 | E0 2F 00 B9 | STR             W0, [SP,#0x30+fd]\n0x0052FFC4 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+fd]\n0x0052FFC8 | 1F 00 00 71 | CMP             W0, #0\n0x0052FFCC | 6A 00 00 54 | B.GE            loc_52FFD8\n0x0052FFD0 | 00 00 80 D2 | MOV             X0, #0\n0x0052FFD4 | 08 00 00 14 | B               loc_52FFF4\n0x0052FFD8 | E1 0B 40 F9 | LDR             X1, [SP,#0x30+maxsz_p]; maxsz_p\n0x0052FFDC | E0 2F 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x0052FFE0 | 8C FF FF 97 | BL              xmalloc_read\n0x0052FFE4 | E0 13 00 F9 | STR             X0, [SP,#0x30+buf]\n0x0052FFE8 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x0052FFEC | 81 5C FB 97 | BL              .close\n0x0052FFF0 | E0 13 40 F9 | LDR             X0, [SP,#0x30+buf]\n0x0052FFF4 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0052FFF8 | C0 03 5F D6 | RET\n\n Output decompiled code:\nFAST_FUNC xmalloc_open_read_close(const char *filename, size_t *maxsz_p)\n{\n\tchar *buf;\n\tsize_t size;\n\tint fd;\n\toff_t len;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\t/* /proc/N/stat files report len 0 here */\n\t/* In order to make such files readable, we add small const */\n\tsize = 0x3ff; /* read only 1k on unseekable files */\n\tlen = lseek(fd, 0, SEEK_END) | 0x3ff; /* + up to 1k */\n\tif (len != (off_t)-1) {\n\t\txlseek(fd, 0, SEEK_SET);\n\t\tsize = maxsz_p ? *maxsz_p : (INT_MAX - 4095);\n\t\tif (len < size)\n\t\t\tsize = len;\n\t}\n\n\tbuf = xmalloc(size + 1);\n\tsize = read_close(fd, buf, size);\n\tif ((ssize_t)size < 0) {\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tbuf = xrealloc(buf, size + 1);\n\tbuf[size] = '\\0';\n\n\tif (maxsz_p)\n\t\t*maxsz_p = size;\n\treturn buf;\n}\n\n## Example:\n\n Input assembly code:\n0x004654F0 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004654F4 | FD 03 00 91 | MOV             X29, SP\n0x004654F8 | E0 0F 00 F9 | STR             X0, [SP,#0x30+str]\n0x004654FC | E1 0B 00 F9 | STR             X1, [SP,#0x30+arg]\n0x00465500 | 42 00 80 52 | MOV             W2, #2; af\n0x00465504 | 01 00 80 52 | MOV             W1, #0; port\n0x00465508 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+str]; host\n0x0046550C | 6F 3E 03 94 | BL              host_and_af2sockaddr\n0x00465510 | E0 17 00 F9 | STR             X0, [SP,#0x30+lsa]\n0x00465514 | E0 17 40 F9 | LDR             X0, [SP,#0x30+lsa]\n0x00465518 | 1F 00 00 F1 | CMP             X0, #0\n0x0046551C | 61 00 00 54 | B.NE            loc_465528\n0x00465520 | 00 00 80 52 | MOV             W0, #0\n0x00465524 | 0A 00 00 14 | B               loc_46554C\n0x00465528 | E0 17 40 F9 | LDR             X0, [SP,#0x30+lsa]\n0x0046552C | 00 08 40 B9 | LDR             W0, [X0,#8]\n0x00465530 | E0 27 00 B9 | STR             W0, [SP,#0x30+__t]\n0x00465534 | E1 27 40 B9 | LDR             W1, [SP,#0x30+__t]\n0x00465538 | E0 0B 40 F9 | LDR             X0, [SP,#0x30+arg]\n0x0046553C | 01 00 00 B9 | STR             W1, [X0]\n0x00465540 | E0 17 40 F9 | LDR             X0, [SP,#0x30+lsa]; ptr\n0x00465544 | E7 87 FE 97 | BL              .free\n0x00465548 | 20 00 80 52 | MOV             W0, #1\n0x0046554C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00465550 | C0 03 5F D6 | RET\n\n Output decompiled code:\nint FAST_FUNC udhcp_str2nip(const char *str, void *arg)\n{\n\tlen_and_sockaddr *lsa;\n\n\tlsa = host_and_af2sockaddr(str, 0, AF_INET);\n\tif (!lsa)\n\t\treturn 0;\n\t/* arg maybe unaligned */\n\tmove_to_unaligned32((uint32_t*)arg, lsa->u.sin.sin_addr.s_addr);\n\tfree(lsa);\n\treturn 1;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0052B6C0 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0052B6C4 | FD 03 00 91 | MOV             X29, SP\n0x0052B6C8 | E0 0F 00 F9 | STR             X0, [SP,#0x30+filename]\n0x0052B6CC | E1 0B 00 F9 | STR             X1, [SP,#0x30+buf]\n0x0052B6D0 | 00 00 80 92 | MOV             X0, #0xFFFFFFFFFFFFFFFF\n0x0052B6D4 | E0 17 00 F9 | STR             X0, [SP,#0x30+ret]\n0x0052B6D8 | 01 00 80 52 | MOV             W1, #0; oflag\n0x0052B6DC | E0 0F 40 F9 | LDR             X0, [SP,#0x30+filename]; file\n0x0052B6E0 | 90 70 FB 97 | BL              .open64\n0x0052B6E4 | E0 27 00 B9 | STR             W0, [SP,#0x30+fd]\n0x0052B6E8 | E0 27 40 B9 | LDR             W0, [SP,#0x30+fd]\n0x0052B6EC | 1F 00 00 71 | CMP             W0, #0\n0x0052B6F0 | 0B 01 00 54 | B.LT            loc_52B710\n0x0052B6F4 | E2 7F 80 D2 | MOV             X2, #0x3FF; nbytes\n0x0052B6F8 | E1 0B 40 F9 | LDR             X1, [SP,#0x30+buf]; buf\n0x0052B6FC | E0 27 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x0052B700 | 6C 70 FB 97 | BL              .read\n0x0052B704 | E0 17 00 F9 | STR             X0, [SP,#0x30+ret]\n0x0052B708 | E0 27 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x0052B70C | B9 6E FB 97 | BL              .close\n0x0052B710 | E1 17 40 F9 | LDR             X1, [SP,#0x30+ret]\n0x0052B714 | E0 17 40 F9 | LDR             X0, [SP,#0x30+ret]\n0x0052B718 | 02 00 80 D2 | MOV             X2, #0\n0x0052B71C | 3F 00 00 F1 | CMP             X1, #0\n0x0052B720 | 00 A0 82 9A | CSEL            X0, X0, X2, GE\n0x0052B724 | E1 03 00 AA | MOV             X1, X0\n0x0052B728 | E0 0B 40 F9 | LDR             X0, [SP,#0x30+buf]\n0x0052B72C | 00 00 01 8B | ADD             X0, X0, X1\n0x0052B730 | 1F 00 00 39 | STRB            WZR, [X0]\n0x0052B734 | E0 17 40 F9 | LDR             X0, [SP,#0x30+ret]\n0x0052B738 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0052B73C | C0 03 5F D6 | RET",
        "output": "```c\nssize_t read_file_to_buffer(const char *filename, char *buf)\n{\n    int fd;\n    ssize_t ret = -1;\n\n    fd = open64(filename, O_RDONLY);\n    if (fd >= 0) {\n        ret = read(fd, buf, 0x3FF);\n        close(fd);\n    }\n\n    if (ret >= 0) {\n        buf[ret] = '\\0';\n    }\n\n    return ret;\n}\n```"
    },
    {
        "func_name": "free_llist",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004CFFCC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004CFFD0 | FD 03 00 91 | MOV             X29, SP\n0x004CFFD4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+hlInfoHeadPtr]\n0x004CFFD8 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+hlInfoHeadPtr]\n0x004CFFDC | 1F 00 00 F1 | CMP             X0, #0\n0x004CFFE0 | 20 02 00 54 | B.EQ            loc_4D0024\n0x004CFFE4 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+hlInfoHeadPtr]\n0x004CFFE8 | 00 00 40 F9 | LDR             X0, [X0]\n0x004CFFEC | E0 17 00 F9 | STR             X0, [SP,#0x30+hlInfo]\n0x004CFFF0 | 08 00 00 14 | B               loc_4D0010\n0x004CFFF4 | E0 17 40 F9 | LDR             X0, [SP,#0x30+hlInfo]\n0x004CFFF8 | 00 00 40 F9 | LDR             X0, [X0]\n0x004CFFFC | E0 13 00 F9 | STR             X0, [SP,#0x30+hlInfoNext]\n0x004D0000 | E0 17 40 F9 | LDR             X0, [SP,#0x30+hlInfo]; ptr\n0x004D0004 | 37 DD FC 97 | BL              .free\n0x004D0008 | E0 13 40 F9 | LDR             X0, [SP,#0x30+hlInfoNext]\n0x004D000C | E0 17 00 F9 | STR             X0, [SP,#0x30+hlInfo]\n0x004D0010 | E0 17 40 F9 | LDR             X0, [SP,#0x30+hlInfo]\n0x004D0014 | 1F 00 00 F1 | CMP             X0, #0\n0x004D0018 | E1 FE FF 54 | B.NE            loc_4CFFF4\n0x004D001C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+hlInfoHeadPtr]\n0x004D0020 | 1F 00 00 F9 | STR             XZR, [X0]\n0x004D0024 | 1F 20 03 D5 | NOP\n0x004D0028 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004D002C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void freeHardLinkInfo(HardLinkInfo **hlInfoHeadPtr)\n{\n\tHardLinkInfo *hlInfo;\n\tHardLinkInfo *hlInfoNext;\n\n\tif (hlInfoHeadPtr) {\n\t\thlInfo = *hlInfoHeadPtr;\n\t\twhile (hlInfo) {\n\t\t\thlInfoNext = hlInfo->next;\n\t\t\tfree(hlInfo);\n\t\t\thlInfo = hlInfoNext;\n\t\t}\n\t\t*hlInfoHeadPtr = NULL;\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x004094D4 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004094D8 | FD 03 00 91 | MOV             X29, SP\n0x004094DC | E0 0F 00 F9 | STR             X0, [SP,#0x30+head]\n0x004094E0 | FF 17 00 F9 | STR             XZR, [SP,#0x30+data]\n0x004094E4 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+head]\n0x004094E8 | 00 00 40 F9 | LDR             X0, [X0]\n0x004094EC | E0 13 00 F9 | STR             X0, [SP,#0x30+temp]\n0x004094F0 | E0 13 40 F9 | LDR             X0, [SP,#0x30+temp]\n0x004094F4 | 1F 00 00 F1 | CMP             X0, #0\n0x004094F8 | 40 01 00 54 | B.EQ            loc_409520\n0x004094FC | E0 13 40 F9 | LDR             X0, [SP,#0x30+temp]\n0x00409500 | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x00409504 | E0 17 00 F9 | STR             X0, [SP,#0x30+data]\n0x00409508 | E0 13 40 F9 | LDR             X0, [SP,#0x30+temp]\n0x0040950C | 01 00 40 F9 | LDR             X1, [X0]\n0x00409510 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+head]\n0x00409514 | 01 00 00 F9 | STR             X1, [X0]\n0x00409518 | E0 13 40 F9 | LDR             X0, [SP,#0x30+temp]; ptr\n0x0040951C | F1 F7 FF 97 | BL              .free\n0x00409520 | E0 17 40 F9 | LDR             X0, [SP,#0x30+data]\n0x00409524 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00409528 | C0 03 5F D6 | RET\n\n Output decompiled code:\nFAST_FUNC llist_pop(llist_t **head)\n{\n\tvoid *data = NULL;\n\tllist_t *temp = *head;\n\n\tif (temp) {\n\t\tdata = temp->data;\n\t\t*head = temp->link;\n\t\tfree(temp);\n\t}\n\treturn data;\n}\n\n## Example:\n\n Input assembly code:\n0x00518618 | FD 7B BB A9 | STP             X29, X30, [SP,#var_50]!\n0x0051861C | FD 03 00 91 | MOV             X29, SP\n0x00518620 | F3 0B 00 F9 | STR             X19, [SP,#0x50+var_40]\n0x00518624 | E0 17 00 F9 | STR             X0, [SP,#0x50+fopt]\n0x00518628 | 1E 00 00 14 | B               loc_5186A0\n0x0051862C | E0 17 40 F9 | LDR             X0, [SP,#0x50+fopt]\n0x00518630 | E0 27 00 F9 | STR             X0, [SP,#0x50+cur]\n0x00518634 | E0 27 40 F9 | LDR             X0, [SP,#0x50+cur]\n0x00518638 | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x0051863C | E0 23 00 F9 | STR             X0, [SP,#0x50+ffile]\n0x00518640 | E0 27 40 F9 | LDR             X0, [SP,#0x50+cur]\n0x00518644 | 00 00 40 F9 | LDR             X0, [X0]\n0x00518648 | E0 17 00 F9 | STR             X0, [SP,#0x50+fopt]\n0x0051864C | E0 27 40 F9 | LDR             X0, [SP,#0x50+cur]; ptr\n0x00518650 | A4 BB FB 97 | BL              .free\n0x00518654 | E0 23 40 F9 | LDR             X0, [SP,#0x50+ffile]; filename\n0x00518658 | E8 6C 00 94 | BL              xfopen_stdin\n0x0051865C | E0 1F 00 F9 | STR             X0, [SP,#0x50+fp]\n0x00518660 | 08 00 00 14 | B               loc_518680\n0x00518664 | C0 03 00 F0 | ADRP            X0, #(bb_common_bufsiz1+0x30)@PAGE\n0x00518668 | 13 00 0B 91 | ADD             X19, X0, #(bb_common_bufsiz1+0x30)@PAGEOFF\n0x0051866C | E0 1B 40 F9 | LDR             X0, [SP,#0x50+line]; pattern\n0x00518670 | DE FF FF 97 | BL              add_grep_list_data\n0x00518674 | E1 03 00 AA | MOV             X1, X0; data\n0x00518678 | E0 03 13 AA | MOV             X0, X19; old_head\n0x0051867C | 6A C3 FB 97 | BL              llist_add_to\n0x00518680 | E0 1F 40 F9 | LDR             X0, [SP,#0x50+fp]; file\n0x00518684 | 0A 1F 00 94 | BL              xmalloc_fgetline\n0x00518688 | E0 1B 00 F9 | STR             X0, [SP,#0x50+line]\n0x0051868C | E0 1B 40 F9 | LDR             X0, [SP,#0x50+line]\n0x00518690 | 1F 00 00 F1 | CMP             X0, #0\n0x00518694 | 81 FE FF 54 | B.NE            loc_518664\n0x00518698 | E0 1F 40 F9 | LDR             X0, [SP,#0x50+fp]; f\n0x0051869C | 9A 1B 00 94 | BL              fclose_if_not_stdin\n0x005186A0 | E0 17 40 F9 | LDR             X0, [SP,#0x50+fopt]\n0x005186A4 | 1F 00 00 F1 | CMP             X0, #0\n0x005186A8 | 21 FC FF 54 | B.NE            loc_51862C\n0x005186AC | 1F 20 03 D5 | NOP\n0x005186B0 | F3 0B 40 F9 | LDR             X19, [SP,#0x50+var_40]\n0x005186B4 | FD 7B C5 A8 | LDP             X29, X30, [SP+0x50+var_50],#0x50\n0x005186B8 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void load_regexes_from_file(llist_t *fopt)\n{\n\twhile (fopt) {\n\t\tchar *line;\n\t\tFILE *fp;\n\t\tllist_t *cur = fopt;\n\t\tchar *ffile = cur->data;\n\n\t\tfopt = cur->link;\n\t\tfree(cur);\n\t\tfp = xfopen_stdin(ffile);\n\t\twhile ((line = xmalloc_fgetline(fp)) != NULL) {\n\t\t\tllist_add_to(&pattern_head,\n\t\t\t\tnew_grep_list_data(line, ALLOCATED));\n\t\t}\n\t\tfclose_if_not_stdin(fp);\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004317DC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004317E0 | FD 03 00 91 | MOV             X29, SP\n0x004317E4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+pptr]\n0x004317E8 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+pptr]\n0x004317EC | 00 00 40 F9 | LDR             X0, [X0]\n0x004317F0 | E0 17 00 F9 | STR             X0, [SP,#0x30+cur]\n0x004317F4 | 08 00 00 14 | B               loc_431814\n0x004317F8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cur]\n0x004317FC | E0 13 00 F9 | STR             X0, [SP,#0x30+t]\n0x00431800 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cur]\n0x00431804 | 00 00 40 F9 | LDR             X0, [X0]\n0x00431808 | E0 17 00 F9 | STR             X0, [SP,#0x30+cur]\n0x0043180C | E0 13 40 F9 | LDR             X0, [SP,#0x30+t]; ptr\n0x00431810 | 34 57 FF 97 | BL              .free\n0x00431814 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cur]\n0x00431818 | 1F 00 00 F1 | CMP             X0, #0\n0x0043181C | E1 FE FF 54 | B.NE            loc_4317F8\n0x00431820 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+pptr]\n0x00431824 | 1F 00 00 F9 | STR             XZR, [X0]\n0x00431828 | 1F 20 03 D5 | NOP\n0x0043182C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00431830 | C0 03 5F D6 | RET",
        "output": "```c\nvoid free_list(void **pptr)\n{\n    void *cur, *t;\n\n    if (pptr) {\n        cur = *pptr;\n        while (cur) {\n            t = cur;\n            cur = *(void **)cur;\n            free(t);\n        }\n        *pptr = NULL;\n    }\n}\n```"
    },
    {
        "func_name": "send_packet",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00494F00 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00494F04 | FD 03 00 91 | MOV             X29, SP\n0x00494F08 | E0 0F 00 F9 | STR             X0, [SP,#0x20+o]\n0x00494F0C | E1 17 00 B9 | STR             W1, [SP,#0x20+n]\n0x00494F10 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x00494F14 | 00 10 40 B9 | LDR             W0, [X0,#0x10]\n0x00494F18 | 00 00 1F 12 | AND             W0, W0, #2\n0x00494F1C | 1F 00 00 71 | CMP             W0, #0\n0x00494F20 | 20 01 00 54 | B.EQ            loc_494F44\n0x00494F24 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x00494F28 | 00 18 40 B9 | LDR             W0, [X0,#0x18]\n0x00494F2C | 1F 00 00 71 | CMP             W0, #0\n0x00494F30 | A1 00 00 54 | B.NE            loc_494F44\n0x00494F34 | E1 17 40 B9 | LDR             W1, [SP,#0x20+n]; n\n0x00494F38 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]; o\n0x00494F3C | B6 FF FF 97 | BL              perform_glob\n0x00494F40 | 04 00 00 14 | B               loc_494F50\n0x00494F44 | E1 17 40 B9 | LDR             W1, [SP,#0x20+n]; n\n0x00494F48 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]; o\n0x00494F4C | 15 FE FF 97 | BL              o_save_ptr_helper\n0x00494F50 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00494F54 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int o_save_ptr(o_string *o, int n)\n{\n\tif (o->o_expflags & EXP_FLAG_GLOB) {\n\t\t/* If o->has_empty_slot, list[n] was already globbed\n\t\t * (if it was requested back then when it was filled)\n\t\t * so don't do that again! */\n\t\tif (!o->has_empty_slot)\n\t\t\treturn perform_glob(o, n); /* o_save_ptr_helper is inside */\n\t}\n\treturn o_save_ptr_helper(o, n);\n}\n\n## Example:\n\n Input assembly code:\n0x00530870 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00530874 | FD 03 00 91 | MOV             X29, SP\n0x00530878 | E0 0F 00 F9 | STR             X0, [SP,#0x20+ptm]\n0x0053087C | E1 17 00 B9 | STR             W1, [SP,#0x20+fd]\n0x00530880 | 02 07 80 D2 | MOV             X2, #0x38 ; '8'; n\n0x00530884 | 01 00 80 52 | MOV             W1, #0; c\n0x00530888 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+ptm]; s\n0x0053088C | A1 59 FB 97 | BL              .memset\n0x00530890 | 80 01 00 90 | ADRP            X0, #aRtcRdTime@PAGE; \"RTC_RD_TIME\"\n0x00530894 | 03 C0 06 91 | ADD             X3, X0, #aRtcRdTime@PAGEOFF; \"RTC_RD_TIME\"\n0x00530898 | E2 0F 40 F9 | LDR             X2, [SP,#0x20+ptm]; argp\n0x0053089C | 21 01 8E 52 81 04 B0 72 | MOV             W1, #0x80247009; request\n0x005308A4 | E0 17 40 B9 | LDR             W0, [SP,#0x20+fd]; fd\n0x005308A8 | 88 6B FB 97 | BL              bb_xioctl\n0x005308AC | E0 0F 40 F9 | LDR             X0, [SP,#0x20+ptm]\n0x005308B0 | 01 00 80 12 | MOV             W1, #0xFFFFFFFF\n0x005308B4 | 01 20 00 B9 | STR             W1, [X0,#0x20]\n0x005308B8 | 1F 20 03 D5 | NOP\n0x005308BC | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x005308C0 | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid FAST_FUNC rtc_read_tm(struct tm *ptm, int fd)\n{\n\tmemset(ptm, 0, sizeof(*ptm));\n\txioctl(fd, RTC_RD_TIME, ptm);\n\tptm->tm_isdst = -1; /* \"not known\" */\n}\n\n## Example:\n\n Input assembly code:\n0x0048402C | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00484030 | FD 03 00 91 | MOV             X29, SP\n0x00484034 | E0 0F 00 F9 | STR             X0, [SP,#0x20+p]\n0x00484038 | E1 17 00 B9 | STR             W1, [SP,#0x20+syntax]\n0x0048403C | E2 13 00 B9 | STR             W2, [SP,#0x20+quotes]\n0x00484040 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+p]; s\n0x00484044 | C3 09 FE 97 | BL              .strlen\n0x00484048 | E3 13 40 B9 | LDR             W3, [SP,#0x20+quotes]; quotes\n0x0048404C | E2 17 40 B9 | LDR             W2, [SP,#0x20+syntax]; syntax\n0x00484050 | E1 03 00 AA | MOV             X1, X0; len\n0x00484054 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+p]; p\n0x00484058 | B4 FF FF 97 | BL              memtodest\n0x0048405C | 1F 20 03 D5 | NOP\n0x00484060 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00484064 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void\nstrtodest(const char *p, int syntax, int quotes)\n{\n\tmemtodest(p, strlen(p), syntax, quotes);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00460B94 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00460B98 | FD 03 00 91 | MOV             X29, SP\n0x00460B9C | E0 0F 00 F9 | STR             X0, [SP,#0x20+dhcp_pkt]\n0x00460BA0 | E1 17 00 B9 | STR             W1, [SP,#0x20+force_broadcast]\n0x00460BA4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+dhcp_pkt]\n0x00460BA8 | 00 18 40 B9 | LDR             W0, [X0,#0x18]\n0x00460BAC | 1F 00 00 71 | CMP             W0, #0\n0x00460BB0 | 80 00 00 54 | B.EQ            loc_460BC0\n0x00460BB4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+dhcp_pkt]; dhcp_pkt\n0x00460BB8 | DF FF FF 97 | BL              send_packet_to_relay\n0x00460BBC | 04 00 00 14 | B               loc_460BCC\n0x00460BC0 | E1 17 40 B9 | LDR             W1, [SP,#0x20+force_broadcast]; force_broadcast\n0x00460BC4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+dhcp_pkt]; dhcp_pkt\n0x00460BC8 | 99 FF FF 97 | BL              send_packet_to_client\n0x00460BCC | 1F 20 03 D5 | NOP\n0x00460BD0 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00460BD4 | C0 03 5F D6 | RET",
        "output": "```c\nvoid send_dhcp_packet(struct dhcp_packet *dhcp_pkt, int force_broadcast)\n{\n    if (dhcp_pkt->gateway_ip_addr != 0) {\n        send_packet_to_relay(dhcp_pkt);\n    } else {\n        send_packet_to_client(dhcp_pkt, force_broadcast);\n    }\n}\n```"
    },
    {
        "func_name": "ndelay_off",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00409FC8 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00409FCC | FD 03 00 91 | MOV             X29, SP\n0x00409FD0 | E0 1F 00 B9 | STR             W0, [SP,#0x30+fd]\n0x00409FD4 | 61 00 80 52 | MOV             W1, #3; cmd\n0x00409FD8 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x00409FDC | E5 F5 FF 97 | BL              .fcntl\n0x00409FE0 | E0 2F 00 B9 | STR             W0, [SP,#0x30+flags]\n0x00409FE4 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+flags]\n0x00409FE8 | 00 00 15 12 | AND             W0, W0, #0x800\n0x00409FEC | 1F 00 00 71 | CMP             W0, #0\n0x00409FF0 | 01 01 00 54 | B.NE            loc_40A010\n0x00409FF4 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+flags]\n0x00409FF8 | 00 00 15 32 | ORR             W0, W0, #0x800\n0x00409FFC | E2 03 00 2A | MOV             W2, W0\n0x0040A000 | 81 00 80 52 | MOV             W1, #4; cmd\n0x0040A004 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x0040A008 | DA F5 FF 97 | BL              .fcntl\n0x0040A00C | 02 00 00 14 | B               loc_40A014\n0x0040A010 | 1F 20 03 D5 | NOP\n0x0040A014 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0040A018 | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid FAST_FUNC ndelay_on(int fd)\n{\n\tint flags = fcntl(fd, F_GETFL);\n\tif (flags & O_NONBLOCK)\n\t\treturn;\n\tfcntl(fd, F_SETFL, flags | O_NONBLOCK);\n}\n\n## Example:\n\n Input assembly code:\n0x00418F38 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00418F3C | FD 03 00 91 | MOV             X29, SP\n0x00418F40 | E0 1F 00 B9 | STR             W0, [SP,#0x30+flags]\n0x00418F44 | E1 0B 00 F9 | STR             X1, [SP,#0x30+dev]\n0x00418F48 | 20 61 8A 52 | MOV             W0, #0x5309\n0x00418F4C | E0 2F 00 B9 | STR             W0, [SP,#0x30+cmd]\n0x00418F50 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+flags]\n0x00418F54 | 00 00 00 12 | AND             W0, W0, #1\n0x00418F58 | 1F 00 00 71 | CMP             W0, #0\n0x00418F5C | 41 01 00 54 | B.NE            loc_418F84\n0x00418F60 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+flags]\n0x00418F64 | 00 00 1F 12 | AND             W0, W0, #2\n0x00418F68 | 1F 00 00 71 | CMP             W0, #0\n0x00418F6C | 00 01 00 54 | B.EQ            loc_418F8C\n0x00418F70 | C1 64 8A D2 | MOV             X1, #0x5326; request\n0x00418F74 | 60 00 80 52 | MOV             W0, #3; fd\n0x00418F78 | 86 BB FF 97 | BL              .ioctl\n0x00418F7C | 1F 08 00 71 | CMP             W0, #2\n0x00418F80 | 61 00 00 54 | B.NE            loc_418F8C\n0x00418F84 | 20 63 8A 52 | MOV             W0, #0x5319\n0x00418F88 | E0 2F 00 B9 | STR             W0, [SP,#0x30+cmd]\n0x00418F8C | E1 2F 40 B9 | LDR             W1, [SP,#0x30+cmd]; request\n0x00418F90 | E4 0B 40 F9 | LDR             X4, [SP,#0x30+dev]\n0x00418F94 | 40 09 00 90 | ADRP            X0, #aS_88@PAGE; \"%s\"\n0x00418F98 | 03 00 07 91 | ADD             X3, X0, #aS_88@PAGEOFF; \"%s\"\n0x00418F9C | 02 00 80 D2 | MOV             X2, #0; argp\n0x00418FA0 | 60 00 80 52 | MOV             W0, #3; fd\n0x00418FA4 | 42 C9 FF 97 | BL              ioctl_or_perror_and_die\n0x00418FA8 | 1F 20 03 D5 | NOP\n0x00418FAC | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00418FB0 | C0 03 5F D6 | RET\n\n Output decompiled code:\ndefine FLAG_SCSI   4\n\nstatic void eject_cdrom(unsigned flags, const char *dev)\n{\n\tint cmd = CDROMEJECT;\n\n\tif (flags & FLAG_CLOSE\n\t || ((flags & FLAG_SMART) && ioctl(dev_fd, CDROM_DRIVE_STATUS) == CDS_TRAY_OPEN)\n\t) {\n\t\tcmd = CDROMCLOSETRAY;\n\t}\n\n\tioctl_or_perror_and_die(dev_fd, cmd, NULL, \"%s\", dev);\n}\n\n## Example:\n\n Input assembly code:\n0x00459748 | FD 7B BB A9 | STP             X29, X30, [SP,#var_50]!\n0x0045974C | FD 03 00 91 | MOV             X29, SP\n0x00459750 | E0 1F 00 B9 | STR             W0, [SP,#0x50+idx]\n0x00459754 | E0 1F 40 B9 | LDR             W0, [SP,#0x50+idx]\n0x00459758 | E0 33 00 B9 | STR             W0, [SP,#0x50+ifr.ifr_ifru]\n0x0045975C | 02 00 80 52 | MOV             W2, #0; protocol\n0x00459760 | 41 00 80 52 | MOV             W1, #2; type\n0x00459764 | 40 00 80 52 | MOV             W0, #2; domain\n0x00459768 | E0 C6 FE 97 | BL              xsocket\n0x0045976C | E0 4F 00 B9 | STR             W0, [SP,#0x50+fd]\n0x00459770 | E1 83 00 91 | ADD             X1, SP, #0x50+ifr\n0x00459774 | 80 07 00 B0 | ADRP            X0, #aSiocgifname@PAGE; \"SIOCGIFNAME\"\n0x00459778 | 03 00 2F 91 | ADD             X3, X0, #aSiocgifname@PAGEOFF; \"SIOCGIFNAME\"\n0x0045977C | E2 03 01 AA | MOV             X2, X1; argp\n0x00459780 | 01 22 91 52 | MOV             W1, #0x8910; request\n0x00459784 | E0 4F 40 B9 | LDR             W0, [SP,#0x50+fd]; fd\n0x00459788 | BC C7 FE 97 | BL              bb_ioctl_or_warn\n0x0045978C | E0 4B 00 B9 | STR             W0, [SP,#0x50+err]\n0x00459790 | E0 4F 40 B9 | LDR             W0, [SP,#0x50+fd]; fd\n0x00459794 | 97 B6 FE 97 | BL              .close\n0x00459798 | E0 4B 40 B9 | LDR             W0, [SP,#0x50+err]\n0x0045979C | 1F 00 00 71 | CMP             W0, #0\n0x004597A0 | A1 00 00 54 | B.NE            loc_4597B4\n0x004597A4 | E0 83 00 91 | ADD             X0, SP, #0x50+ifr; s\n0x004597A8 | 01 02 80 52 | MOV             W1, #0x10; n\n0x004597AC | 95 C4 FE 97 | BL              xstrndup\n0x004597B0 | 02 00 00 14 | B               loc_4597B8\n0x004597B4 | 00 00 80 D2 | MOV             X0, #0\n0x004597B8 | FD 7B C5 A8 | LDP             X29, X30, [SP+0x50+var_50],#0x50\n0x004597BC | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic char *do_ioctl_get_ifname(int idx)\n{\n\tstruct ifreq ifr;\n\tint fd;\n\tint err;\n\n\tifr.ifr_ifindex = idx;\n\tfd = xsocket(AF_INET, SOCK_DGRAM, 0);\n\terr = ioctl_or_warn(fd, SIOCGIFNAME, &ifr);\n\tclose(fd);\n\treturn err ? NULL : xstrndup(ifr.ifr_name, sizeof(ifr.ifr_name));\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040A01C | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0040A020 | FD 03 00 91 | MOV             X29, SP\n0x0040A024 | E0 1F 00 B9 | STR             W0, [SP,#0x30+fd]\n0x0040A028 | 61 00 80 52 | MOV             W1, #3; cmd\n0x0040A02C | E0 1F 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x0040A030 | D0 F5 FF 97 | BL              .fcntl\n0x0040A034 | E0 2F 00 B9 | STR             W0, [SP,#0x30+flags]\n0x0040A038 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+flags]\n0x0040A03C | 00 00 15 12 | AND             W0, W0, #0x800\n0x0040A040 | 1F 00 00 71 | CMP             W0, #0\n0x0040A044 | 00 01 00 54 | B.EQ            loc_40A064\n0x0040A048 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+flags]\n0x0040A04C | 00 78 14 12 | AND             W0, W0, #0xFFFFF7FF\n0x0040A050 | E2 03 00 2A | MOV             W2, W0\n0x0040A054 | 81 00 80 52 | MOV             W1, #4; cmd\n0x0040A058 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x0040A05C | C5 F5 FF 97 | BL              .fcntl\n0x0040A060 | 02 00 00 14 | B               loc_40A068\n0x0040A064 | 1F 20 03 D5 | NOP\n0x0040A068 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0040A06C | C0 03 5F D6 | RET",
        "output": "```c\nvoid FAST_FUNC ndelay_off(int fd)\n{\n\tint flags = fcntl(fd, F_GETFL);\n\tif (!(flags & O_NONBLOCK))\n\t\treturn;\n\tfcntl(fd, F_SETFL, flags & ~O_NONBLOCK);\n}\n```"
    },
    {
        "func_name": "LOG2D",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0043AFB8 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x0043AFBC | E0 0F 00 B9 | STR             W0, [SP,#0x10+fd]\n0x0043AFC0 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x0043AFC4 | 1F 00 00 71 | CMP             W0, #0\n0x0043AFC8 | 8B 03 00 54 | B.LT            loc_43B038\n0x0043AFCC | C0 0A 00 B0 | ADRP            X0, #(bb_common_bufsiz1+0xE0)@PAGE\n0x0043AFD0 | 01 C0 0D 91 | ADD             X1, X0, #(bb_common_bufsiz1+0xE0)@PAGEOFF\n0x0043AFD4 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x0043AFD8 | 02 FC 00 11 | ADD             W2, W0, #0x3F ; '?'\n0x0043AFDC | 1F 00 00 71 | CMP             W0, #0\n0x0043AFE0 | 40 B0 80 1A | CSEL            W0, W2, W0, LT\n0x0043AFE4 | 00 7C 06 13 | ASR             W0, W0, #6\n0x0043AFE8 | E3 03 00 2A | MOV             W3, W0\n0x0043AFEC | 60 7C 40 93 | SXTW            X0, W3\n0x0043AFF0 | 22 78 60 F8 | LDR             X2, [X1,X0,LSL#3]\n0x0043AFF4 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x0043AFF8 | E1 03 00 6B | NEGS            W1, W0\n0x0043AFFC | 00 14 00 12 | AND             W0, W0, #0x3F\n0x0043B000 | 21 14 00 12 | AND             W1, W1, #0x3F\n0x0043B004 | 00 44 81 5A | CSNEG           W0, W0, W1, MI\n0x0043B008 | 21 00 80 D2 | MOV             X1, #1\n0x0043B00C | 20 20 C0 9A | LSL             X0, X1, X0\n0x0043B010 | E1 03 20 AA | MVN             X1, X0\n0x0043B014 | C0 0A 00 90 00 C0 0D 91 | ADRL            X0, (bb_common_bufsiz1+0xE0)\n0x0043B01C | 42 00 01 8A | AND             X2, X2, X1\n0x0043B020 | 61 7C 40 93 | SXTW            X1, W3\n0x0043B024 | 02 78 21 F8 | STR             X2, [X0,X1,LSL#3]\n0x0043B028 | C0 0A 00 90 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043B030 | 01 00 80 12 | MOV             W1, #0xFFFFFFFF\n0x0043B034 | 01 24 00 B9 | STR             W1, [X0,#(bb_common_bufsiz1+0x24 - 0x593290)]\n0x0043B038 | 1F 20 03 D5 | NOP\n0x0043B03C | FF 43 00 91 | ADD             SP, SP, #0x10\n0x0043B040 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void remove_fd_from_set(int fd)\n{\n\tif (fd >= 0) {\n\t\tFD_CLR(fd, &allsock);\n\t\tdbg(\"stopped listening on fd:%d\\n\", fd);\n\t\tmaxsock = -1;\n\t\tdbg(\"maxsock:%d\\n\", maxsock);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x0043B044 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0043B048 | FD 03 00 91 | MOV             X29, SP\n0x0043B04C | E0 1F 00 B9 | STR             W0, [SP,#0x20+fd]\n0x0043B050 | E0 1F 40 B9 | LDR             W0, [SP,#0x20+fd]\n0x0043B054 | 1F 00 00 71 | CMP             W0, #0\n0x0043B058 | 6B 06 00 54 | B.LT            loc_43B124\n0x0043B05C | C0 0A 00 90 | ADRP            X0, #(bb_common_bufsiz1+0xE0)@PAGE\n0x0043B060 | 01 C0 0D 91 | ADD             X1, X0, #(bb_common_bufsiz1+0xE0)@PAGEOFF\n0x0043B064 | E0 1F 40 B9 | LDR             W0, [SP,#0x20+fd]\n0x0043B068 | 02 FC 00 11 | ADD             W2, W0, #0x3F ; '?'\n0x0043B06C | 1F 00 00 71 | CMP             W0, #0\n0x0043B070 | 40 B0 80 1A | CSEL            W0, W2, W0, LT\n0x0043B074 | 00 7C 06 13 | ASR             W0, W0, #6\n0x0043B078 | E3 03 00 2A | MOV             W3, W0\n0x0043B07C | 60 7C 40 93 | SXTW            X0, W3\n0x0043B080 | 21 78 60 F8 | LDR             X1, [X1,X0,LSL#3]\n0x0043B084 | E0 1F 40 B9 | LDR             W0, [SP,#0x20+fd]\n0x0043B088 | E2 03 00 6B | NEGS            W2, W0\n0x0043B08C | 00 14 00 12 | AND             W0, W0, #0x3F\n0x0043B090 | 42 14 00 12 | AND             W2, W2, #0x3F\n0x0043B094 | 00 44 82 5A | CSNEG           W0, W0, W2, MI\n0x0043B098 | 22 00 80 D2 | MOV             X2, #1\n0x0043B09C | 40 20 C0 9A | LSL             X0, X2, X0\n0x0043B0A0 | E2 03 00 AA | MOV             X2, X0\n0x0043B0A4 | C0 0A 00 90 00 C0 0D 91 | ADRL            X0, (bb_common_bufsiz1+0xE0)\n0x0043B0AC | 22 00 02 AA | ORR             X2, X1, X2\n0x0043B0B0 | 61 7C 40 93 | SXTW            X1, W3\n0x0043B0B4 | 02 78 21 F8 | STR             X2, [X0,X1,LSL#3]\n0x0043B0B8 | C0 0A 00 90 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043B0C0 | 00 24 40 B9 | LDR             W0, [X0,#(bb_common_bufsiz1+0x24 - 0x593290)]\n0x0043B0C4 | 1F 00 00 71 | CMP             W0, #0\n0x0043B0C8 | EB 02 00 54 | B.LT            loc_43B124\n0x0043B0CC | C0 0A 00 90 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043B0D4 | 00 24 40 B9 | LDR             W0, [X0,#(bb_common_bufsiz1+0x24 - 0x593290)]\n0x0043B0D8 | E1 1F 40 B9 | LDR             W1, [SP,#0x20+fd]\n0x0043B0DC | 3F 00 00 6B | CMP             W1, W0\n0x0043B0E0 | 2D 02 00 54 | B.LE            loc_43B124\n0x0043B0E4 | C0 0A 00 90 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043B0EC | E1 1F 40 B9 | LDR             W1, [SP,#0x20+fd]\n0x0043B0F0 | 01 24 00 B9 | STR             W1, [X0,#(bb_common_bufsiz1+0x24 - 0x593290)]\n0x0043B0F4 | C1 0A 00 90 21 40 0A 91 | ADRL            X1, bb_common_bufsiz1\n0x0043B0FC | 00 24 40 B9 | LDR             W0, [X0,#(bb_common_bufsiz1+0x24 - 0x593290)]\n0x0043B100 | 20 28 00 B9 | STR             W0, [X1,#(bb_common_bufsiz1+0x28 - 0x593290)]\n0x0043B104 | E1 1F 80 B9 | LDRSW           X1, [SP,#0x20+fd]\n0x0043B108 | C0 0A 00 90 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043B110 | 00 00 40 F9 | LDR             X0, [X0]\n0x0043B114 | 00 20 00 D1 | SUB             X0, X0, #8\n0x0043B118 | 3F 00 00 EB | CMP             X1, X0\n0x0043B11C | 49 00 00 54 | B.LS            loc_43B124\n0x0043B120 | 78 FF FF 97 | BL              bump_nofile\n0x0043B124 | 1F 20 03 D5 | NOP\n0x0043B128 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0043B12C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void add_fd_to_set(int fd)\n{\n\tif (fd >= 0) {\n\t\tFD_SET(fd, &allsock);\n\t\tdbg(\"started listening on fd:%d\\n\", fd);\n\t\tif (maxsock >= 0 && fd > maxsock) {\n\t\t\tprev_maxsock = maxsock = fd;\n\t\t\tdbg(\"maxsock:%d\\n\", maxsock);\n\t\t\tif ((rlim_t)fd > rlim_ofile_cur - FD_MARGIN)\n\t\t\t\tbump_nofile();\n\t\t}\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x004E262C | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x004E2630 | E0 0F 00 B9 | STR             W0, [SP,#0x10+yr]\n0x004E2634 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+yr]\n0x004E2638 | 1F 60 1B 71 | CMP             W0, #0x6D8\n0x004E263C | E8 00 00 54 | B.HI            loc_4E2658\n0x004E2640 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+yr]\n0x004E2644 | 00 04 00 12 | AND             W0, W0, #3\n0x004E2648 | 1F 00 00 71 | CMP             W0, #0\n0x004E264C | E0 17 9F 1A | CSET            W0, EQ\n0x004E2650 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x004E2654 | 1E 00 00 14 | B               loc_4E26CC\n0x004E2658 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+yr]\n0x004E265C | 00 04 00 12 | AND             W0, W0, #3\n0x004E2660 | 1F 00 00 71 | CMP             W0, #0\n0x004E2664 | 81 01 00 54 | B.NE            loc_4E2694\n0x004E2668 | E1 0F 40 B9 | LDR             W1, [SP,#0x10+yr]\n0x004E266C | E0 A3 90 52 60 3D AA 72 | MOV             W0, #0x51EB851F\n0x004E2674 | 20 7C A0 9B | UMULL           X0, W1, W0\n0x004E2678 | 00 FC 60 D3 | LSR             X0, X0, #0x20 ; ' '\n0x004E267C | 00 7C 05 53 | LSR             W0, W0, #5\n0x004E2680 | 82 0C 80 52 | MOV             W2, #0x64 ; 'd'\n0x004E2684 | 00 7C 02 1B | MUL             W0, W0, W2\n0x004E2688 | 20 00 00 4B | SUB             W0, W1, W0\n0x004E268C | 1F 00 00 71 | CMP             W0, #0\n0x004E2690 | 81 01 00 54 | B.NE            loc_4E26C0\n0x004E2694 | E1 0F 40 B9 | LDR             W1, [SP,#0x10+yr]\n0x004E2698 | E0 A3 90 52 60 3D AA 72 | MOV             W0, #0x51EB851F\n0x004E26A0 | 20 7C A0 9B | UMULL           X0, W1, W0\n0x004E26A4 | 00 FC 60 D3 | LSR             X0, X0, #0x20 ; ' '\n0x004E26A8 | 00 7C 07 53 | LSR             W0, W0, #7\n0x004E26AC | 02 32 80 52 | MOV             W2, #0x190\n0x004E26B0 | 00 7C 02 1B | MUL             W0, W0, W2\n0x004E26B4 | 20 00 00 4B | SUB             W0, W1, W0\n0x004E26B8 | 1F 00 00 71 | CMP             W0, #0\n0x004E26BC | 61 00 00 54 | B.NE            loc_4E26C8\n0x004E26C0 | 20 00 80 52 | MOV             W0, #1\n0x004E26C4 | 02 00 00 14 | B               loc_4E26CC\n0x004E26C8 | 00 00 80 52 | MOV             W0, #0\n0x004E26CC | FF 43 00 91 | ADD             SP, SP, #0x10\n0x004E26D0 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int leap_year(unsigned yr)\n{\n\tif (yr <= 1752)\n\t\treturn !(yr % 4);\n\treturn (!(yr % 4) && (yr % 100)) || !(yr % 400);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00442C68 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x00442C6C | E0 0F 00 B9 | STR             W0, [SP,#0x10+a]\n0x00442C70 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+a]\n0x00442C74 | 1F 00 00 71 | CMP             W0, #0\n0x00442C78 | 2A 01 00 54 | B.GE            loc_442C9C\n0x00442C7C | E0 0F 40 B9 | LDR             W0, [SP,#0x10+a]\n0x00442C80 | E0 03 00 4B | NEG             W0, W0\n0x00442C84 | 21 00 80 D2 | MOV             X1, #1\n0x00442C88 | 20 20 C0 9A | LSL             X0, X1, X0\n0x00442C8C | 00 00 63 9E | UCVTF           D0, X0\n0x00442C90 | 01 10 6E 1E | FMOV            D1, #1.0\n0x00442C94 | 20 18 60 1E | FDIV            D0, D1, D0\n0x00442C98 | 05 00 00 14 | B               loc_442CAC\n0x00442C9C | E0 0F 40 B9 | LDR             W0, [SP,#0x10+a]\n0x00442CA0 | 21 00 80 D2 | MOV             X1, #1\n0x00442CA4 | 20 20 C0 9A | LSL             X0, X1, X0\n0x00442CA8 | 00 00 63 9E | UCVTF           D0, X0\n0x00442CAC | FF 43 00 91 | ADD             SP, SP, #0x10\n0x00442CB0 | C0 03 5F D6 | RET",
        "output": "```c\ndouble calculate_inverse(int a)\n{\n    if (a < 0) {\n        a = -a;\n        return 1.0 / (double)(1ULL << a);\n    }\n    return (double)(1ULL << a);\n}\n```"
    },
    {
        "func_name": "xset1",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00437128 | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x0043712C | FD 03 00 91 | MOV             X29, SP\n0x00437130 | E0 2F 00 B9 | STR             W0, [SP,#0x40+request]\n0x00437134 | E1 13 00 F9 | STR             X1, [SP,#0x40+data]\n0x00437138 | E2 0F 00 F9 | STR             X2, [SP,#0x40+errmsg]\n0x0043713C | E0 2F 80 B9 | LDRSW           X0, [SP,#0x40+request]\n0x00437140 | E2 13 40 F9 | LDR             X2, [SP,#0x40+data]\n0x00437144 | E1 03 00 AA | MOV             X1, X0; request\n0x00437148 | 60 00 80 52 | MOV             W0, #3; fd\n0x0043714C | 11 43 FF 97 | BL              .ioctl\n0x00437150 | E0 3F 00 B9 | STR             W0, [SP,#0x40+r]\n0x00437154 | E0 3F 40 B9 | LDR             W0, [SP,#0x40+r]\n0x00437158 | 1F 00 00 71 | CMP             W0, #0\n0x0043715C | 0A 01 00 54 | B.GE            loc_43717C\n0x00437160 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+errmsg]\n0x00437164 | 1F 00 00 F1 | CMP             X0, #0\n0x00437168 | A0 00 00 54 | B.EQ            loc_43717C\n0x0043716C | E1 0F 40 F9 | LDR             X1, [SP,#0x40+errmsg]\n0x00437170 | 60 08 00 F0 00 20 02 91 | ADRL            X0, aSFailed_0; \"%s failed\"\n0x00437178 | 48 49 FF 97 | BL              bb_perror_msg\n0x0043717C | E0 3F 40 B9 | LDR             W0, [SP,#0x40+r]\n0x00437180 | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x00437184 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int network_ioctl(int request, void* data, const char *errmsg)\n{\n\tint r = ioctl(ioctl_fd, request, data);\n\tif (r < 0 && errmsg)\n\t\tbb_perror_msg(\"%s failed\", errmsg);\n\treturn r;\n}\n\n## Example:\n\n Input assembly code:\n0x00534728 | FD 7B BB A9 | STP             X29, X30, [SP,#var_50]!\n0x0053472C | FD 03 00 91 | MOV             X29, SP\n0x00534730 | E0 1F 00 B9 | STR             W0, [SP,#0x50+fd]\n0x00534734 | E1 0B 00 F9 | STR             X1, [SP,#0x50+iface]\n0x00534738 | E0 83 00 91 | ADD             X0, SP, #0x50+ifr; dst\n0x0053473C | E1 0B 40 F9 | LDR             X1, [SP,#0x50+iface]; src\n0x00534740 | 56 56 FB 97 | BL              strncpy_IFNAMSIZ\n0x00534744 | E0 83 00 91 | ADD             X0, SP, #0x50+ifr\n0x00534748 | 04 05 80 52 | MOV             W4, #0x28 ; '('; optlen\n0x0053474C | E3 03 00 AA | MOV             X3, X0; optval\n0x00534750 | 22 03 80 52 | MOV             W2, #0x19; optname\n0x00534754 | 21 00 80 52 | MOV             W1, #1; level\n0x00534758 | E0 1F 40 B9 | LDR             W0, [SP,#0x50+fd]; fd\n0x0053475C | A9 49 FB 97 | BL              .setsockopt\n0x00534760 | E0 4F 00 B9 | STR             W0, [SP,#0x50+r]\n0x00534764 | E0 4F 40 B9 | LDR             W0, [SP,#0x50+r]\n0x00534768 | 1F 00 00 71 | CMP             W0, #0\n0x0053476C | A0 00 00 54 | B.EQ            loc_534780\n0x00534770 | E1 0B 40 F9 | LDR             X1, [SP,#0x50+iface]\n0x00534774 | 60 01 00 90 00 60 19 91 | ADRL            X0, aCanTBindToInte; \"can't bind to interface %s\"\n0x0053477C | C7 53 FB 97 | BL              bb_perror_msg\n0x00534780 | E0 4F 40 B9 | LDR             W0, [SP,#0x50+r]\n0x00534784 | FD 7B C5 A8 | LDP             X29, X30, [SP+0x50+var_50],#0x50\n0x00534788 | C0 03 5F D6 | RET\n\n Output decompiled code:\nifdef SO_BINDTODEVICE\nint FAST_FUNC setsockopt_bindtodevice(int fd, const char *iface)\n{\n\tint r;\n\tstruct ifreq ifr;\n\tstrncpy_IFNAMSIZ(ifr.ifr_name, iface);\n\t/* NB: passing (iface, strlen(iface) + 1) does not work!\n\t * (maybe it works on _some_ kernels, but not on 2.6.26)\n\t * Actually, ifr_name is at offset 0, and in practice\n\t * just giving char[IFNAMSIZ] instead of struct ifreq works too.\n\t * But just in case it's not true on some obscure arch... */\n\tr = setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr));\n\tif (r)\n\t\tbb_perror_msg(\"can't bind to interface %s\", iface);\n\treturn r;\n}\n\n## Example:\n\n Input assembly code:\n0x0041A3A8 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0041A3AC | FD 03 00 91 | MOV             X29, SP\n0x0041A3B0 | E0 2F 00 B9 | STR             W0, [SP,#0x30+get_arg]\n0x0041A3B4 | E1 13 00 F9 | STR             X1, [SP,#0x30+s]\n0x0041A3B8 | E2 0F 00 F9 | STR             X2, [SP,#0x30+arg]\n0x0041A3BC | E0 2F 40 B9 | LDR             W0, [SP,#0x30+get_arg]\n0x0041A3C0 | 1F 00 00 71 | CMP             W0, #0\n0x0041A3C4 | 00 01 00 54 | B.EQ            loc_41A3E4\n0x0041A3C8 | E2 0F 40 F9 | LDR             X2, [SP,#0x30+arg]\n0x0041A3CC | E1 13 40 F9 | LDR             X1, [SP,#0x30+s]\n0x0041A3D0 | 20 09 00 D0 00 C0 0C 91 | ADRL            X0, aSettingSToLd_0; \" setting %s to %ld\"\n0x0041A3D8 | FE B5 FF 97 | BL              .printf\n0x0041A3DC | E0 0F 40 F9 | LDR             X0, [SP,#0x30+arg]; value\n0x0041A3E0 | E3 FF FF 97 | BL              on_off\n0x0041A3E4 | 1F 20 03 D5 | NOP\n0x0041A3E8 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0041A3EC | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void print_flag_on_off(int get_arg, const char *s, unsigned long arg)\n{\n\tif (get_arg) {\n\t\tprintf(\" setting %s to %ld\", s, arg);\n\t\ton_off(arg);\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00424C44 | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x00424C48 | FD 03 00 91 | MOV             X29, SP\n0x00424C4C | E0 2F 00 B9 | STR             W0, [SP,#0x40+fd]\n0x00424C50 | E1 13 00 F9 | STR             X1, [SP,#0x40+tio]\n0x00424C54 | E2 0F 00 F9 | STR             X2, [SP,#0x40+device]\n0x00424C58 | E2 13 40 F9 | LDR             X2, [SP,#0x40+tio]; termios_p\n0x00424C5C | 41 00 80 52 | MOV             W1, #2; optional_actions\n0x00424C60 | E0 2F 40 B9 | LDR             W0, [SP,#0x40+fd]; fd\n0x00424C64 | 1B 8B FF 97 | BL              .tcsetattr\n0x00424C68 | E0 3F 00 B9 | STR             W0, [SP,#0x40+ret]\n0x00424C6C | E0 3F 40 B9 | LDR             W0, [SP,#0x40+ret]\n0x00424C70 | 1F 00 00 71 | CMP             W0, #0\n0x00424C74 | A0 00 00 54 | B.EQ            loc_424C88\n0x00424C78 | E1 0F 40 F9 | LDR             X1, [SP,#0x40+device]\n0x00424C7C | E0 08 00 F0 00 A0 01 91 | ADRL            X0, aCanTTcsetattrF; \"can't tcsetattr for %s\"\n0x00424C84 | 85 92 FF 97 | BL              bb_perror_msg\n0x00424C88 | E0 3F 40 B9 | LDR             W0, [SP,#0x40+ret]\n0x00424C8C | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x00424C90 | C0 03 5F D6 | RET",
        "output": "```c\nint set_terminal_settings(int fd, struct termios *tio, const char *device)\n{\n\tint ret = tcsetattr(fd, TCSANOW, tio);\n\tif (ret != 0)\n\t\tbb_perror_msg(\"can't tcsetattr for %s\", device);\n\treturn ret;\n}\n```"
    },
    {
        "func_name": "put_iac2",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0044A9C0 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0044A9C4 | FD 03 00 91 | MOV             X29, SP\n0x0044A9C8 | E0 7F 00 39 | STRB            W0, [SP,#0x20+c]\n0x0044A9CC | E1 1B 00 B9 | STR             W1, [SP,#0x20+x]\n0x0044A9D0 | E2 17 00 B9 | STR             W2, [SP,#0x20+y]\n0x0044A9D4 | 40 0A 00 B0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0044A9DC | 00 00 40 B9 | LDR             W0, [X0]\n0x0044A9E0 | 1F DC 01 71 | CMP             W0, #0x77 ; 'w'\n0x0044A9E4 | 4D 00 00 54 | B.LE            loc_44A9EC\n0x0044A9E8 | 00 FE FF 97 | BL              iac_flush\n0x0044A9EC | E0 1F 80 52 | MOV             W0, #0xFF; c\n0x0044A9F0 | 68 FF FF 97 | BL              put_iac\n0x0044A9F4 | 40 1F 80 52 | MOV             W0, #0xFA; c\n0x0044A9F8 | 66 FF FF 97 | BL              put_iac\n0x0044A9FC | E0 7F 40 39 | LDRB            W0, [SP,#0x20+c]; c\n0x0044AA00 | 64 FF FF 97 | BL              put_iac\n0x0044AA04 | E0 1B 40 B9 | LDR             W0, [SP,#0x20+x]\n0x0044AA08 | 00 7C 08 13 | ASR             W0, W0, #8\n0x0044AA0C | 00 1C 00 12 | AND             W0, W0, #0xFF; c\n0x0044AA10 | 60 FF FF 97 | BL              put_iac\n0x0044AA14 | E0 1B 40 B9 | LDR             W0, [SP,#0x20+x]\n0x0044AA18 | 00 1C 00 12 | AND             W0, W0, #0xFF; c\n0x0044AA1C | 5D FF FF 97 | BL              put_iac\n0x0044AA20 | E0 17 40 B9 | LDR             W0, [SP,#0x20+y]\n0x0044AA24 | 00 7C 08 13 | ASR             W0, W0, #8\n0x0044AA28 | 00 1C 00 12 | AND             W0, W0, #0xFF; c\n0x0044AA2C | 59 FF FF 97 | BL              put_iac\n0x0044AA30 | E0 17 40 B9 | LDR             W0, [SP,#0x20+y]\n0x0044AA34 | 00 1C 00 12 | AND             W0, W0, #0xFF; c\n0x0044AA38 | 56 FF FF 97 | BL              put_iac\n0x0044AA3C | E0 1F 80 52 | MOV             W0, #0xFF; c\n0x0044AA40 | 54 FF FF 97 | BL              put_iac\n0x0044AA44 | 00 1E 80 52 | MOV             W0, #0xF0; c\n0x0044AA48 | 52 FF FF 97 | BL              put_iac\n0x0044AA4C | 1F 20 03 D5 | NOP\n0x0044AA50 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0044AA54 | C0 03 5F D6 | RET\n\n Output decompiled code:\nif ENABLE_FEATURE_AUTOWIDTH\nstatic void put_iac_naws(byte c, int x, int y)\n{\n\tif (G.iaclen + 9 > IACBUFSIZE)\n\t\tiac_flush();\n\n\tput_iac(IAC);\n\tput_iac(SB);\n\tput_iac(c);\n\n\tput_iac((x >> 8) & 0xff);\n\tput_iac(x & 0xff);\n\tput_iac((y >> 8) & 0xff);\n\tput_iac(y & 0xff);\n\n\tput_iac(IAC);\n\tput_iac(SE);\n}\n\n## Example:\n\n Input assembly code:\n0x0040AD1C | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0040AD20 | FD 03 00 91 | MOV             X29, SP\n0x0040AD24 | E0 1F 00 B9 | STR             W0, [SP,#0x20+from]\n0x0040AD28 | E1 1B 00 B9 | STR             W1, [SP,#0x20+to]\n0x0040AD2C | E1 1B 40 B9 | LDR             W1, [SP,#0x20+to]; fd2\n0x0040AD30 | E0 1F 40 B9 | LDR             W0, [SP,#0x20+from]; fd\n0x0040AD34 | 7F F3 FF 97 | BL              .dup2\n0x0040AD38 | E1 03 00 2A | MOV             W1, W0\n0x0040AD3C | E0 1B 40 B9 | LDR             W0, [SP,#0x20+to]\n0x0040AD40 | 1F 00 01 6B | CMP             W0, W1\n0x0040AD44 | 80 00 00 54 | B.EQ            loc_40AD54\n0x0040AD48 | A0 09 00 90 00 40 0C 91 | ADRL            X0, aCanTDuplicateF; \"can't duplicate file descriptor\"\n0x0040AD50 | 8A FA FF 97 | BL              bb_perror_msg_and_die\n0x0040AD54 | 1F 20 03 D5 | NOP\n0x0040AD58 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0040AD5C | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid FAST_FUNC xdup2(int from, int to)\n{\n\tif (dup2(from, to) != to)\n\t\tbb_perror_msg_and_die(\"can't duplicate file descriptor\");\n}\n\n## Example:\n\n Input assembly code:\n0x0044AE90 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0044AE94 | FD 03 00 91 | MOV             X29, SP\n0x0044AE98 | E0 7F 00 39 | STRB            W0, [SP,#0x20+c]\n0x0044AE9C | E0 7F 40 39 | LDRB            W0, [SP,#0x20+c]\n0x0044AEA0 | 1F 60 00 71 | CMP             W0, #0x18\n0x0044AEA4 | 20 02 00 54 | B.EQ            loc_44AEE8\n0x0044AEA8 | 1F 60 00 71 | CMP             W0, #0x18\n0x0044AEAC | CC 00 00 54 | B.GT            loc_44AEC4\n0x0044AEB0 | 1F 04 00 71 | CMP             W0, #1\n0x0044AEB4 | 20 01 00 54 | B.EQ            loc_44AED8\n0x0044AEB8 | 1F 0C 00 71 | CMP             W0, #3\n0x0044AEBC | 20 01 00 54 | B.EQ            loc_44AEE0\n0x0044AEC0 | 1A 00 00 14 | B               loc_44AF28\n0x0044AEC4 | 1F 7C 00 71 | CMP             W0, #0x1F\n0x0044AEC8 | 80 01 00 54 | B.EQ            loc_44AEF8\n0x0044AECC | 1F 9C 00 71 | CMP             W0, #0x27 ; '''\n0x0044AED0 | 00 01 00 54 | B.EQ            loc_44AEF0\n0x0044AED4 | 15 00 00 14 | B               loc_44AF28\n0x0044AED8 | 53 FF FF 97 | BL              to_echo\n0x0044AEDC | 16 00 00 14 | B               loc_44AF34\n0x0044AEE0 | 96 FF FF 97 | BL              to_sga\n0x0044AEE4 | 14 00 00 14 | B               loc_44AF34\n0x0044AEE8 | C0 FF FF 97 | BL              to_ttype\n0x0044AEEC | 12 00 00 14 | B               loc_44AF34\n0x0044AEF0 | CF FF FF 97 | BL              to_new_environ\n0x0044AEF4 | 10 00 00 14 | B               loc_44AF34\n0x0044AEF8 | DE FF FF 97 | BL              to_naws\n0x0044AEFC | 40 0A 00 B0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0044AF04 | 00 20 40 B9 | LDR             W0, [X0,#(bb_common_bufsiz1+0x20 - 0x593290)]\n0x0044AF08 | E1 03 00 2A | MOV             W1, W0; x\n0x0044AF0C | 40 0A 00 B0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0044AF14 | 00 24 40 B9 | LDR             W0, [X0,#(bb_common_bufsiz1+0x24 - 0x593290)]\n0x0044AF18 | E2 03 00 2A | MOV             W2, W0; y\n0x0044AF1C | E0 7F 40 39 | LDRB            W0, [SP,#0x20+c]; c\n0x0044AF20 | A8 FE FF 97 | BL              put_iac_naws\n0x0044AF24 | 04 00 00 14 | B               loc_44AF34\n0x0044AF28 | E0 7F 40 39 | LDRB            W0, [SP,#0x20+c]; c\n0x0044AF2C | 27 FF FF 97 | BL              to_notsup\n0x0044AF30 | 1F 20 03 D5 | NOP\n0x0044AF34 | 1F 20 03 D5 | NOP\n0x0044AF38 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0044AF3C | C0 03 5F D6 | RET\n\n Output decompiled code:\nendif\n\nstatic void telopt(byte c)\n{\n\tswitch (c) {\n\tcase TELOPT_ECHO:\n\t\tto_echo(); break;\n\tcase TELOPT_SGA:\n\t\tto_sga(); break;\n#if ENABLE_FEATURE_TELNET_TTYPE\n\tcase TELOPT_TTYPE:\n\t\tto_ttype(); break;\n#endif\n#if ENABLE_FEATURE_TELNET_AUTOLOGIN\n\tcase TELOPT_NEW_ENVIRON:\n\t\tto_new_environ(); break;\n#endif\n#if ENABLE_FEATURE_AUTOWIDTH\n\tcase TELOPT_NAWS:\n\t\tto_naws();\n\t\tput_iac_naws(c, G.win_width, G.win_height);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tto_notsup(c);\n\t\tbreak;\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0044A7D8 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0044A7DC | FD 03 00 91 | MOV             X29, SP\n0x0044A7E0 | E0 7F 00 39 | STRB            W0, [SP,#0x20+wwdd]\n0x0044A7E4 | E1 7B 00 39 | STRB            W1, [SP,#0x20+c]\n0x0044A7E8 | 40 0A 00 B0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0044A7F0 | 00 00 40 B9 | LDR             W0, [X0]\n0x0044A7F4 | 1F F4 01 71 | CMP             W0, #0x7D ; '}'\n0x0044A7F8 | 4D 00 00 54 | B.LE            loc_44A800\n0x0044A7FC | 7B FE FF 97 | BL              iac_flush\n0x0044A800 | E0 1F 80 52 | MOV             W0, #0xFF; c\n0x0044A804 | E3 FF FF 97 | BL              put_iac\n0x0044A808 | E0 7F 40 39 | LDRB            W0, [SP,#0x20+wwdd]; c\n0x0044A80C | E1 FF FF 97 | BL              put_iac\n0x0044A810 | E0 7B 40 39 | LDRB            W0, [SP,#0x20+c]; c\n0x0044A814 | DF FF FF 97 | BL              put_iac\n0x0044A818 | 1F 20 03 D5 | NOP\n0x0044A81C | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0044A820 | C0 03 5F D6 | RET",
        "output": "```c\nstatic void put_iac_wwdd(byte wwdd, byte c)\n{\n\tif (G.iaclen + 3 > IACBUFSIZE)\n\t\tiac_flush();\n\n\tput_iac(IAC);\n\tput_iac(wwdd);\n\tput_iac(c);\n}\n```"
    },
    {
        "func_name": "raidautorun_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004B3D84 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x004B3D88 | FD 03 00 91 | MOV             X29, SP\n0x004B3D8C | E0 1F 00 B9 | STR             W0, [SP,#0x20+argc]\n0x004B3D90 | E1 0B 00 F9 | STR             X1, [SP,#0x20+argv]\n0x004B3D94 | 00 05 00 D0 | ADRP            X0, #aMknv@PAGE; \"mknv\"\n0x004B3D98 | 01 40 2D 91 | ADD             X1, X0, #aMknv@PAGEOFF; \"mknv\"\n0x004B3D9C | E0 0B 40 F9 | LDR             X0, [SP,#0x20+argv]; argv\n0x004B3DA0 | CF B1 01 94 | BL              getopt32\n0x004B3DA4 | 05 00 80 52 | MOV             W5, #0; depth\n0x004B3DA8 | 04 00 80 D2 | MOV             X4, #0; userData\n0x004B3DAC | 03 00 80 D2 | MOV             X3, #0; dirAction\n0x004B3DB0 | 00 00 00 90 | ADRP            X0, #fileAction_0@PAGE\n0x004B3DB4 | 02 10 2C 91 | ADD             X2, X0, #fileAction_0@PAGEOFF; fileAction\n0x004B3DB8 | 21 00 80 52 | MOV             W1, #1; flags\n0x004B3DBC | 00 05 00 D0 00 60 2D 91 | ADRL            X0, aSysBusPciDevic; \"/sys/bus/pci/devices\"\n0x004B3DC4 | CA F0 01 94 | BL              recursive_action\n0x004B3DC8 | 00 00 80 52 | MOV             W0, #0\n0x004B3DCC | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004B3DD0 | C0 03 5F D6 | RET\n\n Output decompiled code:\nint lspci_main(int argc UNUSED_PARAM, char **argv)\n{\n\tgetopt32(argv, \"m\" /*non-compat:*/ \"k\" /*ignored:*/ \"nv\");\n\n\trecursive_action(\"/sys/bus/pci/devices\",\n\t\t\tACTION_RECURSE,\n\t\t\tfileAction,\n\t\t\tNULL, /* dirAction */\n\t\t\tNULL, /* userData */\n\t\t\t0 /* depth */);\n\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input assembly code:\n0x004E077C | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004E0780 | FD 03 00 91 | MOV             X29, SP\n0x004E0784 | E0 1F 00 B9 | STR             W0, [SP,#0x30+argc]\n0x004E0788 | E1 0B 00 F9 | STR             X1, [SP,#0x30+argv]\n0x004E078C | E0 0B 40 F9 | LDR             X0, [SP,#0x30+argv]; argv\n0x004E0790 | ED 42 01 94 | BL              single_argv\n0x004E0794 | E2 07 80 52 | MOV             W2, #0x3F ; '?'; upper\n0x004E0798 | 21 00 80 52 | MOV             W1, #1; lower\n0x004E079C | 0C 4F 01 94 | BL              xatou_range\n0x004E07A0 | E0 2F 00 B9 | STR             W0, [SP,#0x30+num]\n0x004E07A4 | E9 FD 00 94 | BL              get_console_fd_or_die\n0x004E07A8 | E1 2F 40 B9 | LDR             W1, [SP,#0x30+num]; vt_num\n0x004E07AC | 16 FE 00 94 | BL              console_make_active\n0x004E07B0 | 00 00 80 52 | MOV             W0, #0\n0x004E07B4 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004E07B8 | C0 03 5F D6 | RET\n\n Output decompiled code:\nint chvt_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint num = xatou_range(single_argv(argv), 1, 63);\n\tconsole_make_active(get_console_fd_or_die(), num);\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input assembly code:\n0x004363D8 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x004363DC | FD 03 00 91 | MOV             X29, SP\n0x004363E0 | E0 1F 00 B9 | STR             W0, [SP,#0x20+request]\n0x004363E4 | E1 0B 00 F9 | STR             X1, [SP,#0x20+ifr]\n0x004363E8 | E0 1F 40 B9 | LDR             W0, [SP,#0x20+request]\n0x004363EC | E2 0B 40 F9 | LDR             X2, [SP,#0x20+ifr]\n0x004363F0 | E1 03 00 AA | MOV             X1, X0; request\n0x004363F4 | 60 00 80 52 | MOV             W0, #3; fd\n0x004363F8 | 66 46 FF 97 | BL              .ioctl\n0x004363FC | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00436400 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int ioctl_on_skfd(unsigned request, struct ifreq *ifr)\n{\n\treturn ioctl(skfd, request, ifr);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00425E40 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00425E44 | FD 03 00 91 | MOV             X29, SP\n0x00425E48 | E0 1F 00 B9 | STR             W0, [SP,#0x20+argc]\n0x00425E4C | E1 0B 00 F9 | STR             X1, [SP,#0x20+argv]\n0x00425E50 | E0 0B 40 F9 | LDR             X0, [SP,#0x20+argv]; argv\n0x00425E54 | 3C 2D 04 94 | BL              single_argv\n0x00425E58 | 01 00 80 52 | MOV             W1, #0; flags\n0x00425E5C | 41 93 FF 97 | BL              xopen\n0x00425E60 | E4 03 00 2A | MOV             W4, W0\n0x00425E64 | E0 08 00 D0 | ADRP            X0, #aRaidAutorun@PAGE; \"RAID_AUTORUN\"\n0x00425E68 | 03 C0 0F 91 | ADD             X3, X0, #aRaidAutorun@PAGEOFF; \"RAID_AUTORUN\"\n0x00425E6C | 02 00 80 D2 | MOV             X2, #0; argp\n0x00425E70 | 81 22 81 52 | MOV             W1, #0x914; request\n0x00425E74 | E0 03 04 2A | MOV             W0, W4; fd\n0x00425E78 | 14 96 FF 97 | BL              bb_xioctl\n0x00425E7C | 00 00 80 52 | MOV             W0, #0\n0x00425E80 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00425E84 | C0 03 5F D6 | RET",
        "output": "```c\nint setraid_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint fd = xopen(single_argv(argv), O_RDONLY);\n\tbb_xioctl(fd, RAID_AUTORUN, NULL);\n\treturn EXIT_SUCCESS;\n}\n```"
    },
    {
        "func_name": "pgetc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004AC704 | 40 07 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004AC70C | 00 00 40 F9 | LDR             X0, [X0]\n0x004AC710 | 01 68 40 B9 | LDR             W1, [X0,#0x68]\n0x004AC714 | 21 04 00 51 | SUB             W1, W1, #1\n0x004AC718 | 01 68 00 B9 | STR             W1, [X0,#0x68]\n0x004AC71C | 40 07 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004AC724 | 00 00 40 F9 | LDR             X0, [X0]\n0x004AC728 | 00 68 40 B9 | LDR             W0, [X0,#0x68]\n0x004AC72C | 1F 7C 00 71 | CMP             W0, #0x1F\n0x004AC730 | AC 03 00 54 | B.GT            loc_4AC7A4\n0x004AC734 | 40 07 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004AC73C | 00 00 40 F9 | LDR             X0, [X0]\n0x004AC740 | 41 07 00 B0 21 80 0A 91 | ADRL            X1, ptr_to_globals\n0x004AC748 | 21 00 40 F9 | LDR             X1, [X1]\n0x004AC74C | 21 68 40 B9 | LDR             W1, [X1,#0x68]\n0x004AC750 | 21 7C 40 93 | SXTW            X1, W1\n0x004AC754 | 21 38 00 91 | ADD             X1, X1, #0xE\n0x004AC758 | 00 78 61 F8 | LDR             X0, [X0,X1,LSL#3]\n0x004AC75C | 1F 00 00 39 | STRB            WZR, [X0]\n0x004AC760 | 40 07 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004AC768 | 00 00 40 F9 | LDR             X0, [X0]\n0x004AC76C | 00 68 40 B9 | LDR             W0, [X0,#0x68]\n0x004AC770 | 1F 00 00 71 | CMP             W0, #0\n0x004AC774 | 81 01 00 54 | B.NE            loc_4AC7A4\n0x004AC778 | 40 07 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004AC780 | 00 00 40 F9 | LDR             X0, [X0]\n0x004AC784 | 00 04 40 91 | ADD             X0, X0, #1,LSL#12\n0x004AC788 | E1 05 80 52 | MOV             W1, #0x2F ; '/'\n0x004AC78C | 01 D0 16 39 | STRB            W1, [X0,#0x5B4]\n0x004AC790 | 40 07 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004AC798 | 00 00 40 F9 | LDR             X0, [X0]\n0x004AC79C | 00 04 40 91 | ADD             X0, X0, #1,LSL#12\n0x004AC7A0 | 1F D4 16 39 | STRB            WZR, [X0,#0x5B5]\n0x004AC7A4 | 1F 20 03 D5 | NOP\n0x004AC7A8 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void pop_filename(void)\n{\n\tname_depth--;\n\tif (name_depth < MAX_DEPTH) {\n\t\t*name_component[name_depth] = '\\0';\n\t\tif (!name_depth) {\n\t\t\tcurrent_name[0] = '/';\n\t\t\tcurrent_name[1] = '\\0';\n\t\t}\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x0047C948 | FD 7B BF A9 | STP             X29, X30, [SP,#-0x10+var_s0]!\n0x0047C94C | FD 03 00 91 | MOV             X29, SP\n0x0047C950 | C0 08 00 B0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x0047C958 | 01 00 40 F9 | LDR             X1, [X0]\n0x0047C95C | 20 30 40 B9 | LDR             W0, [X1,#0x30]\n0x0047C960 | 00 04 00 51 | SUB             W0, W0, #1\n0x0047C964 | 20 30 00 B9 | STR             W0, [X1,#0x30]\n0x0047C968 | 1F 00 00 71 | CMP             W0, #0\n0x0047C96C | 01 01 00 54 | B.NE            loc_47C98C\n0x0047C970 | C0 08 00 B0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x0047C978 | 00 00 40 F9 | LDR             X0, [X0]\n0x0047C97C | 00 34 40 B9 | LDR             W0, [X0,#0x34]\n0x0047C980 | 1F 00 00 71 | CMP             W0, #0\n0x0047C984 | 40 00 00 54 | B.EQ            loc_47C98C\n0x0047C988 | C6 FF FF 97 | BL              raise_interrupt\n0x0047C98C | 1F 20 03 D5 | NOP\n0x0047C990 | FD 7B C1 A8 | LDP             X29, X30, [SP+var_s0],#0x10\n0x0047C994 | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid\nint_on(void)\n{\n\txbarrier();\n\tif (--suppress_int == 0 && pending_int) {\n\t\traise_interrupt();\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x0048BC90 | 20 08 00 F0 00 40 2F 91 | ADRL            X0, g_parsefile\n0x0048BC98 | 00 00 40 F9 | LDR             X0, [X0]; basepf\n0x0048BC9C | 01 10 40 B9 | LDR             W1, [X0,#(basepf.left_in_line - 0x592F50)]\n0x0048BCA0 | 21 04 00 11 | ADD             W1, W1, #1\n0x0048BCA4 | 01 10 00 B9 | STR             W1, [X0,#(basepf.left_in_line - 0x592F50)]\n0x0048BCA8 | 20 08 00 F0 00 40 2F 91 | ADRL            X0, g_parsefile\n0x0048BCB0 | 00 00 40 F9 | LDR             X0, [X0]; basepf\n0x0048BCB4 | 01 0C 40 F9 | LDR             X1, [X0,#(basepf.next_to_pgetc - 0x592F50)]\n0x0048BCB8 | 21 04 00 D1 | SUB             X1, X1, #1\n0x0048BCBC | 01 0C 00 F9 | STR             X1, [X0,#(basepf.next_to_pgetc - 0x592F50)]\n0x0048BCC0 | 1F 20 03 D5 | NOP\n0x0048BCC4 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void\npungetc(void)\n{\n\tg_parsefile->left_in_line++;\n\tg_parsefile->next_to_pgetc--;\n\tpgetc_debug(\"pushed back to %d:%p'%s'\",\n\t\t\tg_parsefile->left_in_line,\n\t\t\tg_parsefile->next_to_pgetc,\n\t\t\tg_parsefile->next_to_pgetc);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0048BB60 | FD 7B BF A9 | STP             X29, X30, [SP,#-0x10+var_s0]!\n0x0048BB64 | FD 03 00 91 | MOV             X29, SP\n0x0048BB68 | 20 08 00 F0 00 40 2F 91 | ADRL            X0, g_parsefile\n0x0048BB70 | 00 00 40 F9 | LDR             X0, [X0]; basepf\n0x0048BB74 | 01 10 40 B9 | LDR             W1, [X0,#(basepf.left_in_line - 0x592F50)]\n0x0048BB78 | 21 04 00 51 | SUB             W1, W1, #1\n0x0048BB7C | 01 10 00 B9 | STR             W1, [X0,#(basepf.left_in_line - 0x592F50)]\n0x0048BB80 | 00 10 40 B9 | LDR             W0, [X0,#(basepf.left_in_line - 0x592F50)]\n0x0048BB84 | 1F 00 00 71 | CMP             W0, #0\n0x0048BB88 | 2B 01 00 54 | B.LT            loc_48BBAC\n0x0048BB8C | 20 08 00 F0 00 40 2F 91 | ADRL            X0, g_parsefile\n0x0048BB94 | 01 00 40 F9 | LDR             X1, [X0]; basepf\n0x0048BB98 | 20 0C 40 F9 | LDR             X0, [X1,#(basepf.next_to_pgetc - 0x592F50)]\n0x0048BB9C | 02 04 00 91 | ADD             X2, X0, #1\n0x0048BBA0 | 22 0C 00 F9 | STR             X2, [X1,#(basepf.next_to_pgetc - 0x592F50)]\n0x0048BBA4 | 00 00 40 39 | LDRB            W0, [X0]\n0x0048BBA8 | 02 00 00 14 | B               loc_48BBB0\n0x0048BBAC | 25 FF FF 97 | BL              preadbuffer\n0x0048BBB0 | FD 7B C1 A8 | LDP             X29, X30, [SP+var_s0],#0x10\n0x0048BBB4 | C0 03 5F D6 | RET",
        "output": "```c\nstatic int\npgetc(void)\n{\n\tg_parsefile->left_in_line--;\n\tif (g_parsefile->left_in_line < 0) {\n\t\tpreadbuffer();\n\t}\n\tg_parsefile->next_to_pgetc++;\n\treturn (unsigned char)*g_parsefile->next_to_pgetc;\n}\n```"
    },
    {
        "func_name": "getopt_mk_fifo_nod",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004365E4 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004365E8 | FD 03 00 91 | MOV             X29, SP\n0x004365EC | E0 0F 00 F9 | STR             X0, [SP,#0x30+ifname]\n0x004365F0 | E1 17 00 B9 | STR             W1, [SP,#0x30+flags]\n0x004365F4 | E0 17 40 B9 | LDR             W0, [SP,#0x30+flags]\n0x004365F8 | 00 78 1F 12 | AND             W0, W0, #0xFFFFFFFE\n0x004365FC | E1 03 00 2A | MOV             W1, W0; flags\n0x00436600 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+ifname]; ifname\n0x00436604 | D6 FF FF 97 | BL              set_if_flags\n0x00436608 | E0 2F 00 B9 | STR             W0, [SP,#0x30+res]\n0x0043660C | E0 2F 40 B9 | LDR             W0, [SP,#0x30+res]\n0x00436610 | 1F 00 00 71 | CMP             W0, #0\n0x00436614 | A0 00 00 54 | B.EQ            loc_436628\n0x00436618 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+ifname]\n0x0043661C | 60 08 00 F0 00 E0 39 91 | ADRL            X0, aSCanTDown; \"%s: can't down\"\n0x00436624 | 1D 4C FF 97 | BL              bb_perror_msg\n0x00436628 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+res]\n0x0043662C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00436630 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int set_if_down(char *ifname, int flags)\n{\n\tint res = set_if_flags(ifname, flags & ~IFF_UP);\n\tif (res)\n\t\tbb_perror_msg(\"%s: can't down\", ifname);\n\treturn res;\n}\n\n## Example:\n\n Input assembly code:\n0x0042A8B8 | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x0042A8BC | FD 03 00 91 | MOV             X29, SP\n0x0042A8C0 | E0 0F 00 F9 | STR             X0, [SP,#0x40+name]\n0x0042A8C4 | FF 3F 00 B9 | STR             WZR, [SP,#0x40+ret]\n0x0042A8C8 | E0 FE FF F0 | ADRP            X0, #xfopen_for_read@PAGE\n0x0042A8CC | 01 80 38 91 | ADD             X1, X0, #xfopen_for_read@PAGEOFF; fopen_func\n0x0042A8D0 | C0 08 00 D0 00 C0 0A 91 | ADRL            X0, aProcModules; \"/proc/modules\"\n0x0042A8D8 | 88 FE 03 94 | BL              config_open2\n0x0042A8DC | E0 1B 00 F9 | STR             X0, [SP,#0x40+parser]\n0x0042A8E0 | 09 00 00 14 | B               loc_42A904\n0x0042A8E4 | E0 17 40 F9 | LDR             X0, [SP,#0x40+s]; s1\n0x0042A8E8 | E1 0F 40 F9 | LDR             X1, [SP,#0x40+name]; s2\n0x0042A8EC | B9 72 FF 97 | BL              .strcmp\n0x0042A8F0 | 1F 00 00 71 | CMP             W0, #0\n0x0042A8F4 | 81 00 00 54 | B.NE            loc_42A904\n0x0042A8F8 | 20 00 80 52 | MOV             W0, #1\n0x0042A8FC | E0 3F 00 B9 | STR             W0, [SP,#0x40+ret]\n0x0042A900 | 0A 00 00 14 | B               loc_42A928\n0x0042A904 | E1 A3 00 91 | ADD             X1, SP, #0x40+s; tokens\n0x0042A908 | C0 08 00 D0 | ADRP            X0, #asc_5442C0@PAGE; \"# \\t\"\n0x0042A90C | 03 00 0B 91 | ADD             X3, X0, #asc_5442C0@PAGEOFF; \"# \\t\"\n0x0042A910 | 22 20 80 52 62 08 A0 72 | MOV             W2, #0x430101; flags\n0x0042A918 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+parser]; parser\n0x0042A91C | 1C FF 03 94 | BL              config_read\n0x0042A920 | 1F 00 00 71 | CMP             W0, #0\n0x0042A924 | 01 FE FF 54 | B.NE            loc_42A8E4\n0x0042A928 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+parser]; parser\n0x0042A92C | 92 FE 03 94 | BL              config_close\n0x0042A930 | E0 3F 40 B9 | LDR             W0, [SP,#0x40+ret]\n0x0042A934 | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x0042A938 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int already_loaded(const char *name)\n{\n\tint ret = 0;\n\tchar *s;\n\tparser_t *parser = config_open2(\"/proc/modules\", xfopen_for_read);\n\twhile (config_read(parser, &s, 1, 1, \"# \\t\", PARSE_NORMAL & ~PARSE_GREEDY)) {\n\t\tif (strcmp(s, name) == 0) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig_close(parser);\n\treturn ret;\n}\n\n## Example:\n\n Input assembly code:\n0x00529540 | FD 7B AE A9 | STP             X29, X30, [SP,#var_120]!\n0x00529544 | FD 03 00 91 | MOV             X29, SP\n0x00529548 | E0 0F 00 F9 | STR             X0, [SP,#0x120+device]\n0x0052954C | FF 8F 00 F9 | STR             XZR, [SP,#0x120+dev]\n0x00529550 | 01 00 80 52 | MOV             W1, #0; oflag\n0x00529554 | E0 0F 40 F9 | LDR             X0, [SP,#0x120+device]; file\n0x00529558 | F2 78 FB 97 | BL              .open64\n0x0052955C | E0 17 01 B9 | STR             W0, [SP,#0x120+fd]\n0x00529560 | E0 17 41 B9 | LDR             W0, [SP,#0x120+fd]\n0x00529564 | 1F 00 00 71 | CMP             W0, #0\n0x00529568 | 6B 02 00 54 | B.LT            loc_5295B4\n0x0052956C | E0 A3 00 91 | ADD             X0, SP, #0x120+loopinfo\n0x00529570 | E2 03 00 AA | MOV             X2, X0\n0x00529574 | A1 80 89 D2 | MOV             X1, #0x4C05; request\n0x00529578 | E0 17 41 B9 | LDR             W0, [SP,#0x120+fd]; fd\n0x0052957C | 05 7A FB 97 | BL              .ioctl\n0x00529580 | 1F 00 00 71 | CMP             W0, #0\n0x00529584 | 41 01 00 54 | B.NE            loc_5295AC\n0x00529588 | E0 23 40 F9 | LDR             X0, [SP,#0x120+loopinfo.lo_offset]\n0x0052958C | E1 03 00 AA | MOV             X1, X0\n0x00529590 | E0 A3 00 91 | ADD             X0, SP, #0x120+loopinfo\n0x00529594 | 00 E0 00 91 | ADD             X0, X0, #0x38 ; '8'\n0x00529598 | E2 03 00 AA | MOV             X2, X0\n0x0052959C | A0 01 00 D0 00 C0 2B 91 | ADRL            X0, aLuS; \"%lu %s\"\n0x005295A4 | 93 86 FB 97 | BL              xasprintf\n0x005295A8 | E0 8F 00 F9 | STR             X0, [SP,#0x120+dev]\n0x005295AC | E0 17 41 B9 | LDR             W0, [SP,#0x120+fd]; fd\n0x005295B0 | 10 77 FB 97 | BL              .close\n0x005295B4 | E0 8F 40 F9 | LDR             X0, [SP,#0x120+dev]\n0x005295B8 | FD 7B D2 A8 | LDP             X29, X30, [SP+0x120+var_120],#0x120\n0x005295BC | C0 03 5F D6 | RET\n\n Output decompiled code:\nFAST_FUNC query_loop(const char *device)\n{\n\tint fd;\n\tbb_loop_info loopinfo;\n\tchar *dev = NULL;\n\n\tfd = open(device, O_RDONLY);\n\tif (fd >= 0) {\n\t\tif (ioctl(fd, BB_LOOP_GET_STATUS, &loopinfo) == 0) {\n\t\t\tdev = xasprintf(\"%\"OFF_FMT\"u %s\", (off_t) loopinfo.lo_offset,\n\t\t\t\t\t(char *)loopinfo.lo_file_name);\n\t\t}\n\t\tclose(fd);\n\t}\n\n\treturn dev;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F98CC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004F98D0 | FD 03 00 91 | MOV             X29, SP\n0x004F98D4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+argv]\n0x004F98D8 | C0 36 80 52 | MOV             W0, #0x1B6\n0x004F98DC | E0 2B 00 B9 | STR             W0, [SP,#0x30+mode]\n0x004F98E0 | FF 13 00 F9 | STR             XZR, [SP,#0x30+smode]\n0x004F98E4 | E0 83 00 91 | ADD             X0, SP, #0x30+smode\n0x004F98E8 | E2 03 00 AA | MOV             X2, X0\n0x004F98EC | 00 03 00 D0 | ADRP            X0, #aM_3@PAGE; \"m:\"\n0x004F98F0 | 01 60 37 91 | ADD             X1, X0, #aM_3@PAGEOFF; \"m:\"\n0x004F98F4 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+argv]; argv\n0x004F98F8 | F9 9A 00 94 | BL              getopt32\n0x004F98FC | E0 2F 00 B9 | STR             W0, [SP,#0x30+opt]\n0x004F9900 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+opt]\n0x004F9904 | 00 00 00 12 | AND             W0, W0, #1\n0x004F9908 | 1F 00 00 71 | CMP             W0, #0\n0x004F990C | 00 01 00 54 | B.EQ            loc_4F992C\n0x004F9910 | E0 13 40 F9 | LDR             X0, [SP,#0x30+smode]; s\n0x004F9914 | E1 A3 00 91 | ADD             X1, SP, #0x30+mode; current_mode\n0x004F9918 | DD C3 00 94 | BL              bb_parse_mode\n0x004F991C | 1F 00 00 71 | CMP             W0, #0\n0x004F9920 | 60 00 00 54 | B.EQ            loc_4F992C\n0x004F9924 | 00 00 80 52 | MOV             W0, #0; mask\n0x004F9928 | 9E 38 FC 97 | BL              .umask\n0x004F992C | E0 2B 40 B9 | LDR             W0, [SP,#0x30+mode]\n0x004F9930 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004F9934 | C0 03 5F D6 | RET",
        "output": "```c\n#include <sys/stat.h>\n\nint main(int argc, char **argv)\n{\n    unsigned int mode = 0666;\n    unsigned int smode = 0;\n    unsigned int opt;\n    char *s;\n\n    opt = getopt32(argv, \"m:\", &smode);\n    if (opt & 1) {\n        if (bb_parse_mode((const char *)smode, &mode) == 0) {\n            umask(0);\n        }\n    }\n\n    return mode;\n}\n```"
    },
    {
        "func_name": "llist_unlink",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00530C5C | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x00530C60 | E0 07 00 F9 | STR             X0, [SP,#0x10+dst]\n0x00530C64 | E1 03 00 F9 | STR             X1, [SP,#0x10+src]\n0x00530C68 | E1 07 40 F9 | LDR             X1, [SP,#0x10+dst]\n0x00530C6C | E0 03 40 F9 | LDR             X0, [SP,#0x10+src]\n0x00530C70 | 3F 00 00 EB | CMP             X1, X0\n0x00530C74 | 00 02 00 54 | B.EQ            loc_530CB4\n0x00530C78 | 07 00 00 14 | B               loc_530C94\n0x00530C7C | E0 07 40 F9 | LDR             X0, [SP,#0x10+dst]\n0x00530C80 | 00 04 00 91 | ADD             X0, X0, #1\n0x00530C84 | E0 07 00 F9 | STR             X0, [SP,#0x10+dst]\n0x00530C88 | E0 03 40 F9 | LDR             X0, [SP,#0x10+src]\n0x00530C8C | 00 04 00 91 | ADD             X0, X0, #1\n0x00530C90 | E0 03 00 F9 | STR             X0, [SP,#0x10+src]\n0x00530C94 | E0 03 40 F9 | LDR             X0, [SP,#0x10+src]\n0x00530C98 | 01 00 40 39 | LDRB            W1, [X0]\n0x00530C9C | E0 07 40 F9 | LDR             X0, [SP,#0x10+dst]\n0x00530CA0 | 01 00 00 39 | STRB            W1, [X0]\n0x00530CA4 | E0 07 40 F9 | LDR             X0, [SP,#0x10+dst]\n0x00530CA8 | 00 00 40 39 | LDRB            W0, [X0]\n0x00530CAC | 1F 00 00 71 | CMP             W0, #0\n0x00530CB0 | 61 FE FF 54 | B.NE            loc_530C7C\n0x00530CB4 | 1F 20 03 D5 | NOP\n0x00530CB8 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x00530CBC | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid FAST_FUNC overlapping_strcpy(char *dst, const char *src)\n{\n\t/* Cheap optimization for dst == src case -\n\t * better to have it here than in many callers.\n\t */\n\tif (dst != src) {\n\t\twhile ((*dst = *src) != '\\0') {\n\t\t\tdst++;\n\t\t\tsrc++;\n\t\t}\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x00409474 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00409478 | FD 03 00 91 | MOV             X29, SP\n0x0040947C | E0 0F 00 F9 | STR             X0, [SP,#0x20+list_head]\n0x00409480 | E1 0B 00 F9 | STR             X1, [SP,#0x20+data]\n0x00409484 | 04 00 00 14 | B               loc_409494\n0x00409488 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+list_head]\n0x0040948C | 00 00 40 F9 | LDR             X0, [X0]\n0x00409490 | E0 0F 00 F9 | STR             X0, [SP,#0x20+list_head]\n0x00409494 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+list_head]\n0x00409498 | 00 00 40 F9 | LDR             X0, [X0]\n0x0040949C | 1F 00 00 F1 | CMP             X0, #0\n0x004094A0 | 41 FF FF 54 | B.NE            loc_409488\n0x004094A4 | 00 02 80 D2 | MOV             X0, #0x10; size\n0x004094A8 | 35 05 00 94 | BL              xzalloc\n0x004094AC | E1 03 00 AA | MOV             X1, X0\n0x004094B0 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+list_head]\n0x004094B4 | 01 00 00 F9 | STR             X1, [X0]\n0x004094B8 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+list_head]\n0x004094BC | 00 00 40 F9 | LDR             X0, [X0]\n0x004094C0 | E1 0B 40 F9 | LDR             X1, [SP,#0x20+data]\n0x004094C4 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x004094C8 | 1F 20 03 D5 | NOP\n0x004094CC | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004094D0 | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid FAST_FUNC llist_add_to_end(llist_t **list_head, void *data)\n{\n\twhile (*list_head)\n\t\tlist_head = &(*list_head)->link;\n\t*list_head = xzalloc(sizeof(llist_t));\n\t(*list_head)->data = data;\n\t/*(*list_head)->link = NULL;*/\n}\n\n## Example:\n\n Input assembly code:\n0x004D0030 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x004D0034 | E0 07 00 F9 | STR             X0, [SP,#0x10+hlInfo]\n0x004D0038 | E1 03 00 F9 | STR             X1, [SP,#0x10+statbuf]\n0x004D003C | 10 00 00 14 | B               loc_4D007C\n0x004D0040 | E0 03 40 F9 | LDR             X0, [SP,#0x10+statbuf]\n0x004D0044 | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x004D0048 | E0 07 40 F9 | LDR             X0, [SP,#0x10+hlInfo]\n0x004D004C | 00 08 40 F9 | LDR             X0, [X0,#0x10]\n0x004D0050 | 3F 00 00 EB | CMP             X1, X0\n0x004D0054 | E1 00 00 54 | B.NE            loc_4D0070\n0x004D0058 | E0 03 40 F9 | LDR             X0, [SP,#0x10+statbuf]\n0x004D005C | 01 00 40 F9 | LDR             X1, [X0]\n0x004D0060 | E0 07 40 F9 | LDR             X0, [SP,#0x10+hlInfo]\n0x004D0064 | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x004D0068 | 3F 00 00 EB | CMP             X1, X0\n0x004D006C | 00 01 00 54 | B.EQ            loc_4D008C\n0x004D0070 | E0 07 40 F9 | LDR             X0, [SP,#0x10+hlInfo]\n0x004D0074 | 00 00 40 F9 | LDR             X0, [X0]\n0x004D0078 | E0 07 00 F9 | STR             X0, [SP,#0x10+hlInfo]\n0x004D007C | E0 07 40 F9 | LDR             X0, [SP,#0x10+hlInfo]\n0x004D0080 | 1F 00 00 F1 | CMP             X0, #0\n0x004D0084 | E1 FD FF 54 | B.NE            loc_4D0040\n0x004D0088 | 02 00 00 14 | B               loc_4D0090\n0x004D008C | 1F 20 03 D5 | NOP\n0x004D0090 | E0 07 40 F9 | LDR             X0, [SP,#0x10+hlInfo]\n0x004D0094 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x004D0098 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic HardLinkInfo *findHardLinkInfo(HardLinkInfo *hlInfo, struct stat *statbuf)\n{\n\twhile (hlInfo) {\n\t\tif (statbuf->st_ino == hlInfo->ino\n\t\t && statbuf->st_dev == hlInfo->dev\n\t\t) {\n\t\t\tDBG(\"found hardlink:'%s'\", hlInfo->name);\n\t\t\tbreak;\n\t\t}\n\t\thlInfo = hlInfo->next;\n\t}\n\treturn hlInfo;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040952C | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x00409530 | E0 07 00 F9 | STR             X0, [SP,#0x10+head]\n0x00409534 | E1 03 00 F9 | STR             X1, [SP,#0x10+elm]\n0x00409538 | E0 03 40 F9 | LDR             X0, [SP,#0x10+elm]\n0x0040953C | 1F 00 00 F1 | CMP             X0, #0\n0x00409540 | A0 02 00 54 | B.EQ            loc_409594\n0x00409544 | 0F 00 00 14 | B               loc_409580\n0x00409548 | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x0040954C | 00 00 40 F9 | LDR             X0, [X0]\n0x00409550 | E1 03 40 F9 | LDR             X1, [SP,#0x10+elm]\n0x00409554 | 3F 00 00 EB | CMP             X1, X0\n0x00409558 | E1 00 00 54 | B.NE            loc_409574\n0x0040955C | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x00409560 | 00 00 40 F9 | LDR             X0, [X0]\n0x00409564 | 01 00 40 F9 | LDR             X1, [X0]\n0x00409568 | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x0040956C | 01 00 00 F9 | STR             X1, [X0]\n0x00409570 | 0A 00 00 14 | B               loc_409598\n0x00409574 | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x00409578 | 00 00 40 F9 | LDR             X0, [X0]\n0x0040957C | E0 07 00 F9 | STR             X0, [SP,#0x10+head]\n0x00409580 | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x00409584 | 00 00 40 F9 | LDR             X0, [X0]\n0x00409588 | 1F 00 00 F1 | CMP             X0, #0\n0x0040958C | E1 FD FF 54 | B.NE            loc_409548\n0x00409590 | 02 00 00 14 | B               loc_409598\n0x00409594 | 1F 20 03 D5 | NOP\n0x00409598 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x0040959C | C0 03 5F D6 | RET",
        "output": "```c\nvoid delete_from_list(node_t **head, node_t *elm)\n{\n    if (elm == NULL)\n        return;\n\n    while (*head) {\n        if (*head == elm) {\n            *head = (*head)->next;\n            break;\n        }\n        head = &(*head)->next;\n    }\n}\n```"
    },
    {
        "func_name": "display_window_size",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0045A564 | FD 7B BA A9 | STP             X29, X30, [SP,#var_60]!\n0x0045A568 | FD 03 00 91 | MOV             X29, SP\n0x0045A56C | E0 1F 00 B9 | STR             W0, [SP,#0x60+cmd]\n0x0045A570 | E1 0B 00 F9 | STR             X1, [SP,#0x60+argv]\n0x0045A574 | E0 A3 00 91 | ADD             X0, SP, #0x60+p\n0x0045A578 | E2 03 00 AA | MOV             X2, X0; p\n0x0045A57C | E1 1F 40 B9 | LDR             W1, [SP,#0x60+cmd]; cmd\n0x0045A580 | E0 0B 40 F9 | LDR             X0, [SP,#0x60+argv]; argv\n0x0045A584 | FF FC FF 97 | BL              parse_args_0\n0x0045A588 | E0 43 41 39 | LDRB            W0, [SP,#0x60+p.iph.ttl]\n0x0045A58C | 1F 00 00 71 | CMP             W0, #0\n0x0045A590 | E0 00 00 54 | B.EQ            loc_45A5AC\n0x0045A594 | E0 9F 40 79 | LDRH            W0, [SP,#0x60+p.iph.frag_off]\n0x0045A598 | 1F 00 00 71 | CMP             W0, #0\n0x0045A59C | 81 00 00 54 | B.NE            loc_45A5AC\n0x0045A5A0 | 80 07 00 90 00 40 34 91 | ADRL            X0, aTtl0AndNoptmud; \"ttl != 0 and noptmudisc are incompatibl\"...\n0x0045A5A8 | B3 BD FE 97 | BL              bb_error_msg_and_die\n0x0045A5AC | E0 47 41 39 | LDRB            W0, [SP,#0x60+p.iph.protocol]\n0x0045A5B0 | 1F A4 00 71 | CMP             W0, #0x29 ; ')'\n0x0045A5B4 | 60 02 00 54 | B.EQ            loc_45A600\n0x0045A5B8 | 1F BC 00 71 | CMP             W0, #0x2F ; '/'\n0x0045A5BC | 40 01 00 54 | B.EQ            loc_45A5E4\n0x0045A5C0 | 1F 10 00 71 | CMP             W0, #4\n0x0045A5C4 | C1 02 00 54 | B.NE            loc_45A61C\n0x0045A5C8 | E0 A3 00 91 | ADD             X0, SP, #0x60+p\n0x0045A5CC | E2 03 00 AA | MOV             X2, X0; p\n0x0045A5D0 | 80 07 00 90 | ADRP            X0, #aTunl0@PAGE; \"tunl0\"\n0x0045A5D4 | 01 00 35 91 | ADD             X1, X0, #aTunl0@PAGEOFF; \"tunl0\"\n0x0045A5D8 | E0 1F 40 B9 | LDR             W0, [SP,#0x60+cmd]; cmd\n0x0045A5DC | 94 FC FF 97 | BL              do_add_ioctl\n0x0045A5E0 | 12 00 00 14 | B               loc_45A628\n0x0045A5E4 | E0 A3 00 91 | ADD             X0, SP, #0x60+p\n0x0045A5E8 | E2 03 00 AA | MOV             X2, X0; p\n0x0045A5EC | 80 07 00 90 | ADRP            X0, #aGre0@PAGE; \"gre0\"\n0x0045A5F0 | 01 20 35 91 | ADD             X1, X0, #aGre0@PAGEOFF; \"gre0\"\n0x0045A5F4 | E0 1F 40 B9 | LDR             W0, [SP,#0x60+cmd]; cmd\n0x0045A5F8 | 8D FC FF 97 | BL              do_add_ioctl\n0x0045A5FC | 0B 00 00 14 | B               loc_45A628\n0x0045A600 | E0 A3 00 91 | ADD             X0, SP, #0x60+p\n0x0045A604 | E2 03 00 AA | MOV             X2, X0; p\n0x0045A608 | 80 07 00 90 | ADRP            X0, #aSit0@PAGE; \"sit0\"\n0x0045A60C | 01 40 35 91 | ADD             X1, X0, #aSit0@PAGEOFF; \"sit0\"\n0x0045A610 | E0 1F 40 B9 | LDR             W0, [SP,#0x60+cmd]; cmd\n0x0045A614 | 86 FC FF 97 | BL              do_add_ioctl\n0x0045A618 | 04 00 00 14 | B               loc_45A628\n0x0045A61C | 80 07 00 90 00 60 35 91 | ADRL            X0, aCanTDetermineT; \"can't determine tunnel mode (ipip, gre \"...\n0x0045A624 | 94 BD FE 97 | BL              bb_error_msg_and_die\n0x0045A628 | FD 7B C6 A8 | LDP             X29, X30, [SP+0x60+var_60],#0x60\n0x0045A62C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int do_add(int cmd, char **argv)\n{\n\tstruct ip_tunnel_parm p;\n\n\tparse_args(argv, cmd, &p);\n\n\tif (p.iph.ttl && p.iph.frag_off == 0) {\n\t\tbb_error_msg_and_die(\"ttl != 0 and noptmudisc are incompatible\");\n\t}\n\n\tswitch (p.iph.protocol) {\n\tcase IPPROTO_IPIP:\n\t\treturn do_add_ioctl(cmd, \"tunl0\", &p);\n\tcase IPPROTO_GRE:\n\t\treturn do_add_ioctl(cmd, \"gre0\", &p);\n\tcase IPPROTO_IPV6:\n\t\treturn do_add_ioctl(cmd, \"sit0\", &p);\n\tdefault:\n\t\tbb_error_msg_and_die(\"can't determine tunnel mode (ipip, gre or sit)\");\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x0045C388 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0045C38C | FD 03 00 91 | MOV             X29, SP\n0x0045C390 | E0 1F 00 B9 | STR             W0, [SP,#0x30+idx]\n0x0045C394 | E1 0B 00 F9 | STR             X1, [SP,#0x30+buf]\n0x0045C398 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+idx]\n0x0045C39C | 1F 00 00 71 | CMP             W0, #0\n0x0045C3A0 | 81 00 00 54 | B.NE            loc_45C3B0\n0x0045C3A4 | 60 07 00 F0 00 E0 05 91 | ADRL            X0, asc_54B178; \"*\"\n0x0045C3AC | 11 00 00 14 | B               loc_45C3F0\n0x0045C3B0 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+idx]; idx\n0x0045C3B4 | 43 FF FF 97 | BL              find_by_index\n0x0045C3B8 | E0 17 00 F9 | STR             X0, [SP,#0x30+im]\n0x0045C3BC | E0 17 40 F9 | LDR             X0, [SP,#0x30+im]\n0x0045C3C0 | 1F 00 00 F1 | CMP             X0, #0\n0x0045C3C4 | 80 00 00 54 | B.EQ            loc_45C3D4\n0x0045C3C8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+im]\n0x0045C3CC | 00 80 00 91 | ADD             X0, X0, #0x20 ; ' '\n0x0045C3D0 | 08 00 00 14 | B               loc_45C3F0\n0x0045C3D4 | E3 1F 40 B9 | LDR             W3, [SP,#0x30+idx]\n0x0045C3D8 | 60 07 00 F0 | ADRP            X0, #aIfD@PAGE; \"if%d\"\n0x0045C3DC | 02 00 06 91 | ADD             X2, X0, #aIfD@PAGEOFF; \"if%d\"\n0x0045C3E0 | 01 02 80 D2 | MOV             X1, #0x10; maxlen\n0x0045C3E4 | E0 0B 40 F9 | LDR             X0, [SP,#0x30+buf]; s\n0x0045C3E8 | 22 AA FE 97 | BL              .snprintf\n0x0045C3EC | E0 0B 40 F9 | LDR             X0, [SP,#0x30+buf]\n0x0045C3F0 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0045C3F4 | C0 03 5F D6 | RET\n\n Output decompiled code:\nconst char FAST_FUNC *ll_idx_n2a(int idx, char *buf)\n{\n\tstruct idxmap *im;\n\n\tif (idx == 0)\n\t\treturn \"*\";\n\tim = find_by_index(idx);\n\tif (im)\n\t\treturn im->name;\n\tsnprintf(buf, 16, \"if%d\", idx);\n\treturn buf;\n}\n\n## Example:\n\n Input assembly code:\n0x005093D0 | FF C3 10 D1 | SUB             SP, SP, #0x430\n0x005093D4 | FD 7B 00 A9 | STP             X29, X30, [SP,#0x430+var_430]\n0x005093D8 | FD 03 00 91 | MOV             X29, SP\n0x005093DC | E0 1F 00 B9 | STR             W0, [SP,#0x430+num]\n0x005093E0 | E0 A3 00 91 | ADD             X0, SP, #0x430+buf\n0x005093E4 | 04 00 80 12 | MOV             W4, #0xFFFFFFFF; timeout\n0x005093E8 | 23 80 80 52 | MOV             W3, #0x401; maxsize\n0x005093EC | E2 03 00 AA | MOV             X2, X0; command\n0x005093F0 | A0 02 00 90 | ADRP            X0, #byte_55D350@PAGE\n0x005093F4 | 01 40 0D 91 | ADD             X1, X0, #byte_55D350@PAGEOFF; prompt\n0x005093F8 | 00 00 80 D2 | MOV             X0, #0; st\n0x005093FC | A9 7C 00 94 | BL              read_line_input\n0x00509400 | E0 2F 04 B9 | STR             W0, [SP,#0x430+len]\n0x00509404 | E0 2F 44 B9 | LDR             W0, [SP,#0x430+len]\n0x00509408 | 1F 00 00 71 | CMP             W0, #0\n0x0050940C | 6D 02 00 54 | B.LE            loc_509458\n0x00509410 | E0 A3 40 39 | LDRB            W0, [SP,#0x430+buf]\n0x00509414 | 1F B8 00 71 | CMP             W0, #0x2E ; '.'\n0x00509418 | E1 00 00 54 | B.NE            loc_509434\n0x0050941C | E0 A7 40 39 | LDRB            W0, [SP,#0x430+buf+1]\n0x00509420 | 1F 28 00 71 | CMP             W0, #0xA\n0x00509424 | 81 00 00 54 | B.NE            loc_509434\n0x00509428 | E0 AB 40 39 | LDRB            W0, [SP,#0x430+buf+2]\n0x0050942C | 1F 00 00 71 | CMP             W0, #0\n0x00509430 | 80 01 00 54 | B.EQ            loc_509460\n0x00509434 | E0 1F 40 B9 | LDR             W0, [SP,#0x430+num]; num\n0x00509438 | 01 04 00 11 | ADD             W1, W0, #1\n0x0050943C | E1 1F 00 B9 | STR             W1, [SP,#0x430+num]\n0x00509440 | E1 A3 00 91 | ADD             X1, SP, #0x430+buf; data\n0x00509444 | E2 2F 44 B9 | LDR             W2, [SP,#0x430+len]; len\n0x00509448 | E7 02 00 94 | BL              insertLine\n0x0050944C | 1F 00 00 71 | CMP             W0, #0\n0x00509450 | C0 00 00 54 | B.EQ            loc_509468\n0x00509454 | E3 FF FF 17 | B               loc_5093E0\n0x00509458 | 1F 20 03 D5 | NOP\n0x0050945C | 04 00 00 14 | B               loc_50946C\n0x00509460 | 1F 20 03 D5 | NOP\n0x00509464 | 02 00 00 14 | B               loc_50946C\n0x00509468 | 1F 20 03 D5 | NOP\n0x0050946C | FD 7B 40 A9 | LDP             X29, X30, [SP,#0x430+var_430]\n0x00509470 | FF C3 10 91 | ADD             SP, SP, #0x430\n0x00509474 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void addLines(int num)\n{\n\tint len;\n\tchar buf[USERSIZE + 1];\n\n\twhile (1) {\n\t\t/* Returns:\n\t\t * -1 on read errors or EOF, or on bare Ctrl-D.\n\t\t * 0  on ctrl-C,\n\t\t * >0 length of input string, including terminating '\\n'\n\t\t */\n\t\tlen = read_line_input(NULL, \"\", buf, sizeof(buf), /*timeout*/ -1);\n\t\tif (len <= 0) {\n\t\t\t/* Previously, ctrl-C was exiting to shell.\n\t\t\t * Now we exit to ed prompt. Is in important? */\n\t\t\treturn;\n\t\t}\n\t\tif ((buf[0] == '.') && (buf[1] == '\\n') && (buf[2] == '\\0'))\n\t\t\treturn;\n\t\tif (!insertLine(num++, buf, len))\n\t\t\treturn;\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F3478 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004F347C | FD 03 00 91 | MOV             X29, SP\n0x004F3480 | E0 1F 00 B9 | STR             W0, [SP,#0x30+fancy]\n0x004F3484 | 40 03 00 90 00 20 16 91 | ADRL            X0, aS_80; \"%s\"\n0x004F348C | E0 17 00 F9 | STR             X0, [SP,#0x30+fmt_str]\n0x004F3490 | E1 83 00 91 | ADD             X1, SP, #0x30+height\n0x004F3494 | E0 93 00 91 | ADD             X0, SP, #0x30+width\n0x004F3498 | E2 03 01 AA | MOV             X2, X1; height\n0x004F349C | E1 03 00 AA | MOV             X1, X0; width\n0x004F34A0 | 00 00 80 52 | MOV             W0, #0; fd\n0x004F34A4 | 75 5C FC 97 | BL              get_terminal_width_height\n0x004F34A8 | 1F 00 00 71 | CMP             W0, #0\n0x004F34AC | 00 02 00 54 | B.EQ            loc_4F34EC\n0x004F34B0 | 00 05 00 D0 00 60 0A 91 | ADRL            X0, bb_errno\n0x004F34B8 | 00 00 40 F9 | LDR             X0, [X0]\n0x004F34BC | 00 00 40 B9 | LDR             W0, [X0]\n0x004F34C0 | 1F 58 00 71 | CMP             W0, #0x16\n0x004F34C4 | E1 00 00 54 | B.NE            loc_4F34E0\n0x004F34C8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+fmt_str]\n0x004F34CC | 00 08 00 91 | ADD             X0, X0, #2\n0x004F34D0 | E0 17 00 F9 | STR             X0, [SP,#0x30+fmt_str]\n0x004F34D4 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+fancy]\n0x004F34D8 | 1F 00 00 71 | CMP             W0, #0\n0x004F34DC | E1 01 00 54 | B.NE            loc_4F3518\n0x004F34E0 | E0 17 40 F9 | LDR             X0, [SP,#0x30+fmt_str]; fmt\n0x004F34E4 | 2F FF FF 97 | BL              perror_on_device\n0x004F34E8 | 0C 00 00 14 | B               loc_4F3518\n0x004F34EC | E0 1F 40 B9 | LDR             W0, [SP,#0x30+fancy]\n0x004F34F0 | 1F 00 00 71 | CMP             W0, #0\n0x004F34F4 | 80 00 00 54 | B.EQ            loc_4F3504\n0x004F34F8 | 40 03 00 90 00 E0 16 91 | ADRL            X0, aRowsUColumnsU; \"rows %u; columns %u;\"\n0x004F3500 | 03 00 00 14 | B               loc_4F350C\n0x004F3504 | 40 03 00 90 00 40 17 91 | ADRL            X0, aUU_2; \"%u %u\\n\"\n0x004F350C | E1 23 40 B9 | LDR             W1, [SP,#0x30+height]\n0x004F3510 | E2 27 40 B9 | LDR             W2, [SP,#0x30+width]\n0x004F3514 | 2F FF FF 97 | BL              wrapf\n0x004F3518 | 1F 20 03 D5 | NOP\n0x004F351C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004F3520 | C0 03 5F D6 | RET",
        "output": "```c\n#include <stdio.h>\n#include <errno.h>\n\nvoid print_terminal_size(int fancy) {\n    unsigned width, height;\n    const char *fmt_str = \"%s\";\n    if (get_terminal_width_height(0, &width, &height) == 0) {\n        if (errno == EBADF) {\n            fmt_str += 2;\n            if (!fancy) {\n                perror_on_device(fmt_str);\n                return;\n            }\n        }\n    } else {\n        if (!fancy) {\n            fmt_str = \"%u %u\\n\";\n        } else {\n            fmt_str = \"rows %u; columns %u;\";\n        }\n        wrapf(fmt_str, height, width);\n    }\n}\n```"
    },
    {
        "func_name": "do_if_fetch",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0049D0E0 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0049D0E4 | FD 03 00 91 | MOV             X29, SP\n0x0049D0E8 | E0 0F 00 F9 | STR             X0, [SP,#0x20+argv]\n0x0049D0EC | E0 0F 40 F9 | LDR             X0, [SP,#0x20+argv]; argv\n0x0049D0F0 | 9B FF FF 97 | BL              skip_dash_dash\n0x0049D0F4 | E0 0F 00 F9 | STR             X0, [SP,#0x20+argv]\n0x0049D0F8 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+argv]\n0x0049D0FC | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D100 | 1F 00 00 F1 | CMP             X0, #0\n0x0049D104 | 61 00 00 54 | B.NE            loc_49D110\n0x0049D108 | 00 00 80 52 | MOV             W0, #0\n0x0049D10C | 1C 00 00 14 | B               loc_49D17C\n0x0049D110 | C0 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0049D118 | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D11C | 00 3C 40 B9 | LDR             W0, [X0,#0x3C]\n0x0049D120 | 1F 00 00 71 | CMP             W0, #0\n0x0049D124 | 80 02 00 54 | B.EQ            loc_49D174\n0x0049D128 | 22 A7 FD 97 | BL              .getpid\n0x0049D12C | E1 03 00 2A | MOV             W1, W0\n0x0049D130 | C0 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0049D138 | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D13C | 00 20 40 B9 | LDR             W0, [X0,#0x20]\n0x0049D140 | 3F 00 00 6B | CMP             W1, W0\n0x0049D144 | 81 01 00 54 | B.NE            loc_49D174\n0x0049D148 | C0 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0049D150 | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D154 | 02 00 40 B9 | LDR             W2, [X0]\n0x0049D158 | C0 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0049D160 | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D164 | 00 3C 40 B9 | LDR             W0, [X0,#0x3C]\n0x0049D168 | E1 03 00 2A | MOV             W1, W0; pgrp_id\n0x0049D16C | E0 03 02 2A | MOV             W0, W2; fd\n0x0049D170 | A4 A5 FD 97 | BL              .tcsetpgrp\n0x0049D174 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+argv]; argv\n0x0049D178 | 53 F4 FF 97 | BL              execvp_or_die\n0x0049D17C | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0049D180 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int FAST_FUNC builtin_exec(char **argv)\n{\n\targv = skip_dash_dash(argv);\n\tif (argv[0] == NULL)\n\t\treturn EXIT_SUCCESS; /* bash does this */\n\n\t/* Careful: we can end up here after [v]fork. Do not restore\n\t * tty pgrp then, only top-level shell process does that */\n\tif (G_saved_tty_pgrp && getpid() == G.root_pid)\n\t\ttcsetpgrp(G_interactive_fd, G_saved_tty_pgrp);\n\n\t/* TODO: if exec fails, bash does NOT exit! We do.\n\t * We'll need to undo trap cleanup (it's inside execvp_or_die)\n\t * and tcsetpgrp, and this is inherently racy.\n\t */\n\texecvp_or_die(argv);\n}\n\n## Example:\n\n Input assembly code:\n0x00495D98 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00495D9C | FD 03 00 91 | MOV             X29, SP\n0x00495DA0 | E0 0F 00 F9 | STR             X0, [SP,#0x30+o]\n0x00495DA4 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+o]\n0x00495DA8 | 00 00 40 F9 | LDR             X0, [X0]\n0x00495DAC | 1F 00 00 F1 | CMP             X0, #0\n0x00495DB0 | 61 00 00 54 | B.NE            loc_495DBC\n0x00495DB4 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x00495DB8 | 15 00 00 14 | B               loc_495E0C\n0x00495DBC | E0 0F 40 F9 | LDR             X0, [SP,#0x30+o]\n0x00495DC0 | 00 00 40 F9 | LDR             X0, [X0]; arg\n0x00495DC4 | 42 01 80 52 | MOV             W2, #0xA; base\n0x00495DC8 | 01 00 80 D2 | MOV             X1, #0; endp\n0x00495DCC | 2F DB FD 97 | BL              bb_strtou\n0x00495DD0 | E0 2F 00 B9 | STR             W0, [SP,#0x30+num]\n0x00495DD4 | 00 08 00 90 00 60 0A 91 | ADRL            X0, bb_errno\n0x00495DDC | 00 00 40 F9 | LDR             X0, [X0]\n0x00495DE0 | 00 00 40 B9 | LDR             W0, [X0]\n0x00495DE4 | 1F 00 00 71 | CMP             W0, #0\n0x00495DE8 | 81 00 00 54 | B.NE            loc_495DF8\n0x00495DEC | E0 2F 40 B9 | LDR             W0, [SP,#0x30+num]\n0x00495DF0 | 1F 00 00 71 | CMP             W0, #0\n0x00495DF4 | 6A 00 00 54 | B.GE            loc_495E00\n0x00495DF8 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x00495DFC | 04 00 00 14 | B               loc_495E0C\n0x00495E00 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+o]; o\n0x00495E04 | CA F8 FF 97 | BL              o_reset_to_empty_unquoted\n0x00495E08 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+num]\n0x00495E0C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00495E10 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int redirect_opt_num(o_string *o)\n{\n\tint num;\n\n\tif (o->data == NULL)\n\t\treturn -1;\n\tnum = bb_strtou(o->data, NULL, 10);\n\tif (errno || num < 0)\n\t\treturn -1;\n\to_reset_to_empty_unquoted(o);\n\treturn num;\n}\n\n## Example:\n\n Input assembly code:\n0x0040BAAC | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x0040BAB0 | FD 03 00 91 | MOV             X29, SP\n0x0040BAB4 | E0 0F 00 F9 | STR             X0, [SP,#0x40+path]\n0x0040BAB8 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+path]; path\n0x0040BABC | 87 FF FF 97 | BL              xmalloc_readlink\n0x0040BAC0 | E0 1B 00 F9 | STR             X0, [SP,#0x40+buf]\n0x0040BAC4 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+buf]\n0x0040BAC8 | 1F 00 00 F1 | CMP             X0, #0\n0x0040BACC | 81 02 00 54 | B.NE            loc_40BB1C\n0x0040BAD0 | 80 09 00 F0 00 80 11 91 | ADRL            X0, aNotASymlink; \"not a symlink\"\n0x0040BAD8 | E0 1F 00 F9 | STR             X0, [SP,#0x40+errmsg]\n0x0040BADC | 40 0C 00 D0 00 60 0A 91 | ADRL            X0, bb_errno\n0x0040BAE4 | 00 00 40 F9 | LDR             X0, [X0]\n0x0040BAE8 | 00 00 40 B9 | LDR             W0, [X0]\n0x0040BAEC | E0 2F 00 B9 | STR             W0, [SP,#0x40+err]\n0x0040BAF0 | E0 2F 40 B9 | LDR             W0, [SP,#0x40+err]\n0x0040BAF4 | 1F 58 00 71 | CMP             W0, #0x16\n0x0040BAF8 | 80 00 00 54 | B.EQ            loc_40BB08\n0x0040BAFC | E0 2F 40 B9 | LDR             W0, [SP,#0x40+err]; errnum\n0x0040BB00 | B4 ED FF 97 | BL              .strerror\n0x0040BB04 | E0 1F 00 F9 | STR             X0, [SP,#0x40+errmsg]\n0x0040BB08 | E2 1F 40 F9 | LDR             X2, [SP,#0x40+errmsg]\n0x0040BB0C | E1 0F 40 F9 | LDR             X1, [SP,#0x40+path]\n0x0040BB10 | 80 09 00 F0 00 C0 11 91 | ADRL            X0, aSCannotReadLin; \"%s: cannot read link: %s\"\n0x0040BB18 | 7F F8 FF 97 | BL              bb_error_msg\n0x0040BB1C | E0 1B 40 F9 | LDR             X0, [SP,#0x40+buf]\n0x0040BB20 | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x0040BB24 | C0 03 5F D6 | RET\n\n Output decompiled code:\nFAST_FUNC xmalloc_readlink_or_warn(const char *path)\n{\n\tchar *buf = xmalloc_readlink(path);\n\tif (!buf) {\n\t\t/* EINVAL => \"file: Invalid argument\" => puzzled user */\n\t\tconst char *errmsg = \"not a symlink\";\n\t\tint err = errno;\n\t\tif (err != EINVAL)\n\t\t\terrmsg = strerror(err);\n\t\tbb_error_msg(\"%s: cannot read link: %s\", path, errmsg);\n\t}\n\treturn buf;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043EA78 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0043EA7C | FD 03 00 91 | MOV             X29, SP\n0x0043EA80 | E0 0F 00 F9 | STR             X0, [SP,#0x30+ife]\n0x0043EA84 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+ife]; ife\n0x0043EA88 | 2E FF FF 97 | BL              if_fetch\n0x0043EA8C | 1F 00 00 71 | CMP             W0, #0\n0x0043EA90 | 4A 03 00 54 | B.GE            loc_43EAF8\n0x0043EA94 | A0 0A 00 F0 00 60 0A 91 | ADRL            X0, bb_errno\n0x0043EA9C | 00 00 40 F9 | LDR             X0, [X0]\n0x0043EAA0 | 00 00 40 B9 | LDR             W0, [X0]\n0x0043EAA4 | 1F 4C 00 71 | CMP             W0, #0x13\n0x0043EAA8 | A1 00 00 54 | B.NE            loc_43EABC\n0x0043EAAC | 40 08 00 B0 00 80 11 91 | ADRL            X0, aDeviceNotFound; \"Device not found\"\n0x0043EAB4 | E0 17 00 F9 | STR             X0, [SP,#0x30+errmsg]\n0x0043EAB8 | 07 00 00 14 | B               loc_43EAD4\n0x0043EABC | A0 0A 00 F0 00 60 0A 91 | ADRL            X0, bb_errno\n0x0043EAC4 | 00 00 40 F9 | LDR             X0, [X0]\n0x0043EAC8 | 00 00 40 B9 | LDR             W0, [X0]; errnum\n0x0043EACC | C1 21 FF 97 | BL              .strerror\n0x0043EAD0 | E0 17 00 F9 | STR             X0, [SP,#0x30+errmsg]\n0x0043EAD4 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+ife]\n0x0043EAD8 | 00 40 00 91 | ADD             X0, X0, #0x10\n0x0043EADC | E2 17 40 F9 | LDR             X2, [SP,#0x30+errmsg]\n0x0043EAE0 | E1 03 00 AA | MOV             X1, X0\n0x0043EAE4 | 40 08 00 B0 00 E0 11 91 | ADRL            X0, aSErrorFetching; \"%s: error fetching interface informatio\"...\n0x0043EAEC | 8A 2C FF 97 | BL              bb_error_msg\n0x0043EAF0 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x0043EAF4 | 02 00 00 14 | B               loc_43EAFC\n0x0043EAF8 | 00 00 80 52 | MOV             W0, #0\n0x0043EAFC | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0043EB00 | C0 03 5F D6 | RET",
        "output": "```c\nstatic int if_fetch_and_error_msg(interface_t *ife)\n{\n    if (if_fetch(ife) < 0) {\n        const char *errmsg;\n        if (errno == ENODEV)\n            errmsg = \"Device not found\";\n        else\n            errmsg = strerror(errno);\n        bb_error_msg(\"%s: error fetching interface information: %s\", ife->name, errmsg);\n        return -1;\n    }\n    return 0;\n}\n```"
    },
    {
        "func_name": "print_esc_string",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004082A8 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004082AC | FD 03 00 91 | MOV             X29, SP\n0x004082B0 | E0 0F 00 F9 | STR             X0, [SP,#0x30+s]\n0x004082B4 | E1 0B 00 F9 | STR             X1, [SP,#0x30+e]\n0x004082B8 | 10 00 00 14 | B               loc_4082F8\n0x004082BC | E0 0B 40 F9 | LDR             X0, [SP,#0x30+e]\n0x004082C0 | 00 00 40 39 | LDRB            W0, [X0]\n0x004082C4 | 00 24 00 51 | SUB             W0, W0, #9\n0x004082C8 | E0 BF 00 39 | STRB            W0, [SP,#0x30+bb__isspace]\n0x004082CC | E0 BF 40 39 | LDRB            W0, [SP,#0x30+bb__isspace]\n0x004082D0 | 1F 5C 00 71 | CMP             W0, #0x17\n0x004082D4 | 80 00 00 54 | B.EQ            loc_4082E4\n0x004082D8 | E0 BF 40 39 | LDRB            W0, [SP,#0x30+bb__isspace]\n0x004082DC | 1F 10 00 71 | CMP             W0, #4\n0x004082E0 | 68 00 00 54 | B.HI            loc_4082EC\n0x004082E4 | 20 00 80 52 | MOV             W0, #1\n0x004082E8 | 02 00 00 14 | B               loc_4082F0\n0x004082EC | 00 00 80 52 | MOV             W0, #0\n0x004082F0 | 1F 00 00 71 | CMP             W0, #0\n0x004082F4 | 00 01 00 54 | B.EQ            loc_408314\n0x004082F8 | E0 0B 40 F9 | LDR             X0, [SP,#0x30+e]\n0x004082FC | 01 04 00 D1 | SUB             X1, X0, #1\n0x00408300 | E1 0B 00 F9 | STR             X1, [SP,#0x30+e]\n0x00408304 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+s]\n0x00408308 | 3F 00 00 EB | CMP             X1, X0\n0x0040830C | 83 FD FF 54 | B.CC            loc_4082BC\n0x00408310 | 02 00 00 14 | B               loc_408318\n0x00408314 | 1F 20 03 D5 | NOP\n0x00408318 | E0 0B 40 F9 | LDR             X0, [SP,#0x30+e]\n0x0040831C | 00 04 00 91 | ADD             X0, X0, #1\n0x00408320 | 1F 00 00 39 | STRB            WZR, [X0]\n0x00408324 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+s]; s\n0x00408328 | 5B 05 00 94 | BL              skip_whitespace\n0x0040832C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00408330 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic char *get_trimmed_slice(char *s, char *e)\n{\n\t/* First, consider the value at e to be nul and back up until we\n\t * reach a non-space char.  Set the char after that (possibly at\n\t * the original e) to nul. */\n\twhile (e-- > s) {\n\t\tif (!isspace(*e)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\te[1] = '\\0';\n\n\t/* Next, advance past all leading space and return a ptr to the\n\t * first non-space char; possibly the terminating nul. */\n\treturn skip_whitespace(s);\n}\n\n## Example:\n\n Input assembly code:\n0x0048D740 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0048D744 | FD 03 00 91 | MOV             X29, SP\n0x0048D748 | E0 0F 00 F9 | STR             X0, [SP,#0x30+text]\n0x0048D74C | 13 00 00 14 | B               loc_48D798\n0x0048D750 | E0 BF 40 39 | LDRB            W0, [SP,#0x30+c]\n0x0048D754 | 1F 20 02 71 | CMP             W0, #0x88\n0x0048D758 | 41 00 00 54 | B.NE            loc_48D760\n0x0048D75C | 0F 00 00 14 | B               loc_48D798\n0x0048D760 | E0 BF 40 39 | LDRB            W0, [SP,#0x30+c]\n0x0048D764 | 1F 04 02 71 | CMP             W0, #0x81\n0x0048D768 | A1 00 00 54 | B.NE            loc_48D77C\n0x0048D76C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+text]\n0x0048D770 | 00 04 00 91 | ADD             X0, X0, #1\n0x0048D774 | E0 0F 00 F9 | STR             X0, [SP,#0x30+text]\n0x0048D778 | 08 00 00 14 | B               loc_48D798\n0x0048D77C | E0 BF 40 39 | LDRB            W0, [SP,#0x30+c]; c\n0x0048D780 | 01 00 80 52 | MOV             W1, #0; syntax\n0x0048D784 | 99 C7 FF 97 | BL              SIT\n0x0048D788 | 1F 30 00 71 | CMP             W0, #0xC\n0x0048D78C | 61 00 00 54 | B.NE            loc_48D798\n0x0048D790 | 00 00 80 52 | MOV             W0, #0\n0x0048D794 | 0A 00 00 14 | B               loc_48D7BC\n0x0048D798 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+text]\n0x0048D79C | 01 04 00 91 | ADD             X1, X0, #1\n0x0048D7A0 | E1 0F 00 F9 | STR             X1, [SP,#0x30+text]\n0x0048D7A4 | 00 00 40 39 | LDRB            W0, [X0]\n0x0048D7A8 | E0 BF 00 39 | STRB            W0, [SP,#0x30+c]\n0x0048D7AC | E0 BF 40 39 | LDRB            W0, [SP,#0x30+c]\n0x0048D7B0 | 1F 00 00 71 | CMP             W0, #0\n0x0048D7B4 | E1 FC FF 54 | B.NE            loc_48D750\n0x0048D7B8 | 20 00 80 52 | MOV             W0, #1\n0x0048D7BC | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0048D7C0 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int\nnoexpand(const char *text)\n{\n\tunsigned char c;\n\n\twhile ((c = *text++) != '\\0') {\n\t\tif (c == CTLQUOTEMARK)\n\t\t\tcontinue;\n\t\tif (c == CTLESC)\n\t\t\ttext++;\n\t\telse if (SIT(c, BASESYNTAX) == CCTL)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n## Example:\n\n Input assembly code:\n0x00494A2C | FF 83 00 D1 | SUB             SP, SP, #0x20\n0x00494A30 | E0 07 00 F9 | STR             X0, [SP,#0x20+cp]\n0x00494A34 | FF 1F 00 B9 | STR             WZR, [SP,#0x20+depth]\n0x00494A38 | E0 07 40 F9 | LDR             X0, [SP,#0x20+cp]\n0x00494A3C | 00 04 00 91 | ADD             X0, X0, #1\n0x00494A40 | E0 07 00 F9 | STR             X0, [SP,#0x20+cp]\n0x00494A44 | 29 00 00 14 | B               loc_494AE8\n0x00494A48 | E0 07 40 F9 | LDR             X0, [SP,#0x20+cp]\n0x00494A4C | 00 00 40 39 | LDRB            W0, [X0]\n0x00494A50 | 1F 70 01 71 | CMP             W0, #0x5C ; '\\'\n0x00494A54 | 81 01 00 54 | B.NE            loc_494A84\n0x00494A58 | E0 07 40 F9 | LDR             X0, [SP,#0x20+cp]\n0x00494A5C | 00 04 00 91 | ADD             X0, X0, #1\n0x00494A60 | E0 07 00 F9 | STR             X0, [SP,#0x20+cp]\n0x00494A64 | E0 07 40 F9 | LDR             X0, [SP,#0x20+cp]\n0x00494A68 | 00 00 40 39 | LDRB            W0, [X0]\n0x00494A6C | 1F 00 00 71 | CMP             W0, #0\n0x00494A70 | 60 04 00 54 | B.EQ            loc_494AFC\n0x00494A74 | E0 07 40 F9 | LDR             X0, [SP,#0x20+cp]\n0x00494A78 | 00 04 00 91 | ADD             X0, X0, #1\n0x00494A7C | E0 07 00 F9 | STR             X0, [SP,#0x20+cp]\n0x00494A80 | 1A 00 00 14 | B               loc_494AE8\n0x00494A84 | E0 07 40 F9 | LDR             X0, [SP,#0x20+cp]\n0x00494A88 | 00 00 40 39 | LDRB            W0, [X0]\n0x00494A8C | 1F F4 01 71 | CMP             W0, #0x7D ; '}'\n0x00494A90 | C1 00 00 54 | B.NE            loc_494AA8\n0x00494A94 | E0 1F 40 B9 | LDR             W0, [SP,#0x20+depth]\n0x00494A98 | 01 04 00 51 | SUB             W1, W0, #1\n0x00494A9C | E1 1F 00 B9 | STR             W1, [SP,#0x20+depth]\n0x00494AA0 | 1F 00 00 71 | CMP             W0, #0\n0x00494AA4 | E0 02 00 54 | B.EQ            loc_494B00\n0x00494AA8 | E0 07 40 F9 | LDR             X0, [SP,#0x20+cp]\n0x00494AAC | 00 00 40 39 | LDRB            W0, [X0]\n0x00494AB0 | 1F B0 00 71 | CMP             W0, #0x2C ; ','\n0x00494AB4 | 81 00 00 54 | B.NE            loc_494AC4\n0x00494AB8 | E0 1F 40 B9 | LDR             W0, [SP,#0x20+depth]\n0x00494ABC | 1F 00 00 71 | CMP             W0, #0\n0x00494AC0 | 00 02 00 54 | B.EQ            loc_494B00\n0x00494AC4 | E0 07 40 F9 | LDR             X0, [SP,#0x20+cp]\n0x00494AC8 | 01 04 00 91 | ADD             X1, X0, #1\n0x00494ACC | E1 07 00 F9 | STR             X1, [SP,#0x20+cp]\n0x00494AD0 | 00 00 40 39 | LDRB            W0, [X0]\n0x00494AD4 | 1F EC 01 71 | CMP             W0, #0x7B ; '{'\n0x00494AD8 | 81 00 00 54 | B.NE            loc_494AE8\n0x00494ADC | E0 1F 40 B9 | LDR             W0, [SP,#0x20+depth]\n0x00494AE0 | 00 04 00 11 | ADD             W0, W0, #1\n0x00494AE4 | E0 1F 00 B9 | STR             W0, [SP,#0x20+depth]\n0x00494AE8 | E0 07 40 F9 | LDR             X0, [SP,#0x20+cp]\n0x00494AEC | 00 00 40 39 | LDRB            W0, [X0]\n0x00494AF0 | 1F 00 00 71 | CMP             W0, #0\n0x00494AF4 | A1 FA FF 54 | B.NE            loc_494A48\n0x00494AF8 | 02 00 00 14 | B               loc_494B00\n0x00494AFC | 1F 20 03 D5 | NOP\n0x00494B00 | E0 07 40 F9 | LDR             X0, [SP,#0x20+cp]\n0x00494B04 | 00 00 40 39 | LDRB            W0, [X0]\n0x00494B08 | 1F 00 00 71 | CMP             W0, #0\n0x00494B0C | 60 00 00 54 | B.EQ            loc_494B18\n0x00494B10 | E0 07 40 F9 | LDR             X0, [SP,#0x20+cp]\n0x00494B14 | 02 00 00 14 | B               loc_494B1C\n0x00494B18 | 00 00 80 D2 | MOV             X0, #0\n0x00494B1C | FF 83 00 91 | ADD             SP, SP, #0x20 ; ' '\n0x00494B20 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic const char *next_brace_sub(const char *cp)\n{\n\tunsigned depth = 0;\n\tcp++;\n\twhile (*cp != '\\0') {\n\t\tif (*cp == '\\\\') {\n\t\t\tif (*++cp == '\\0')\n\t\t\t\tbreak;\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif ((*cp == '}' && depth-- == 0) || (*cp == ',' && depth == 0))\n\t\t\tbreak;\n\t\tif (*cp++ == '{')\n\t\t\tdepth++;\n\t}\n\n\treturn *cp != '\\0' ? cp : NULL;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004EF1F0 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004EF1F4 | FD 03 00 91 | MOV             X29, SP\n0x004EF1F8 | E0 0F 00 F9 | STR             X0, [SP,#0x30+str]\n0x004EF1FC | 1E 00 00 14 | B               loc_4EF274\n0x004EF200 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+str]\n0x004EF204 | 00 04 00 91 | ADD             X0, X0, #1\n0x004EF208 | E0 0F 00 F9 | STR             X0, [SP,#0x30+str]\n0x004EF20C | E0 BF 40 39 | LDRB            W0, [SP,#0x30+c]\n0x004EF210 | 1F 70 01 71 | CMP             W0, #0x5C ; '\\'\n0x004EF214 | C1 02 00 54 | B.NE            loc_4EF26C\n0x004EF218 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+str]\n0x004EF21C | 00 00 40 39 | LDRB            W0, [X0]\n0x004EF220 | 1F C0 00 71 | CMP             W0, #0x30 ; '0'\n0x004EF224 | 61 01 00 54 | B.NE            loc_4EF250\n0x004EF228 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+str]\n0x004EF22C | 00 04 00 91 | ADD             X0, X0, #1\n0x004EF230 | 00 00 40 39 | LDRB            W0, [X0]\n0x004EF234 | 00 C0 00 51 | SUB             W0, W0, #0x30 ; '0'\n0x004EF238 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x004EF23C | 1F 1C 00 71 | CMP             W0, #7\n0x004EF240 | 88 00 00 54 | B.HI            loc_4EF250\n0x004EF244 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+str]\n0x004EF248 | 00 04 00 91 | ADD             X0, X0, #1\n0x004EF24C | E0 0F 00 F9 | STR             X0, [SP,#0x30+str]\n0x004EF250 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+str]\n0x004EF254 | E0 13 00 F9 | STR             X0, [SP,#0x30+z]\n0x004EF258 | E0 83 00 91 | ADD             X0, SP, #0x30+z; ptr\n0x004EF25C | 16 F0 00 94 | BL              bb_process_escape_sequence\n0x004EF260 | E0 BF 00 39 | STRB            W0, [SP,#0x30+c]\n0x004EF264 | E0 13 40 F9 | LDR             X0, [SP,#0x30+z]\n0x004EF268 | E0 0F 00 F9 | STR             X0, [SP,#0x30+str]\n0x004EF26C | E0 BF 40 39 | LDRB            W0, [SP,#0x30+c]; c\n0x004EF270 | 74 5F FC 97 | BL              .putchar_unlocked\n0x004EF274 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+str]\n0x004EF278 | 00 00 40 39 | LDRB            W0, [X0]\n0x004EF27C | E0 BF 00 39 | STRB            W0, [SP,#0x30+c]\n0x004EF280 | E0 BF 40 39 | LDRB            W0, [SP,#0x30+c]\n0x004EF284 | 1F 00 00 71 | CMP             W0, #0\n0x004EF288 | C1 FB FF 54 | B.NE            loc_4EF200\n0x004EF28C | 1F 20 03 D5 | NOP\n0x004EF290 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004EF294 | C0 03 5F D6 | RET",
        "output": "```c\nvoid print_escaped(const char *str) {\n    char c;\n\n    while ((c = *str) != '\\0') {\n        if (c == '\\\\') {\n            str++;\n            if (*str >= '0' && *str <= '7') {\n                const char *ptr = str;\n                c = bb_process_escape_sequence(&ptr);\n                str = ptr;\n            }\n        }\n        putchar_unlocked(c);\n        str++;\n    }\n}\n```"
    },
    {
        "func_name": "bad_nums",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0051AD18 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0051AD1C | FD 03 00 91 | MOV             X29, SP\n0x0051AD20 | E0 1F 00 B9 | STR             W0, [SP,#0x30+pid]\n0x0051AD24 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+pid]\n0x0051AD28 | 1F 00 00 71 | CMP             W0, #0\n0x0051AD2C | 6D 03 00 54 | B.LE            loc_51AD98\n0x0051AD30 | 04 00 80 D2 | MOV             X4, #0; hostname\n0x0051AD34 | 03 00 80 D2 | MOV             X3, #0; username\n0x0051AD38 | 02 00 80 D2 | MOV             X2, #0; tty_name\n0x0051AD3C | 01 01 80 52 | MOV             W1, #8; new_type\n0x0051AD40 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+pid]; pid\n0x0051AD44 | B4 60 00 94 | BL              update_utmp\n0x0051AD48 | C0 03 00 B0 00 80 07 91 | ADRL            X0, init_action_list\n0x0051AD50 | 00 00 40 F9 | LDR             X0, [X0]\n0x0051AD54 | E0 17 00 F9 | STR             X0, [SP,#0x30+a]\n0x0051AD58 | 0D 00 00 14 | B               loc_51AD8C\n0x0051AD5C | E0 17 40 F9 | LDR             X0, [SP,#0x30+a]\n0x0051AD60 | 00 08 40 B9 | LDR             W0, [X0,#8]\n0x0051AD64 | E1 1F 40 B9 | LDR             W1, [SP,#0x30+pid]\n0x0051AD68 | 3F 00 00 6B | CMP             W1, W0\n0x0051AD6C | A1 00 00 54 | B.NE            loc_51AD80\n0x0051AD70 | E0 17 40 F9 | LDR             X0, [SP,#0x30+a]\n0x0051AD74 | 1F 08 00 B9 | STR             WZR, [X0,#8]\n0x0051AD78 | E0 17 40 F9 | LDR             X0, [SP,#0x30+a]\n0x0051AD7C | 08 00 00 14 | B               loc_51AD9C\n0x0051AD80 | E0 17 40 F9 | LDR             X0, [SP,#0x30+a]\n0x0051AD84 | 00 00 40 F9 | LDR             X0, [X0]\n0x0051AD88 | E0 17 00 F9 | STR             X0, [SP,#0x30+a]\n0x0051AD8C | E0 17 40 F9 | LDR             X0, [SP,#0x30+a]\n0x0051AD90 | 1F 00 00 F1 | CMP             X0, #0\n0x0051AD94 | 41 FE FF 54 | B.NE            loc_51AD5C\n0x0051AD98 | 00 00 80 D2 | MOV             X0, #0\n0x0051AD9C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0051ADA0 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic struct init_action *mark_terminated(pid_t pid)\n{\n\tstruct init_action *a;\n\n\tif (pid > 0) {\n\t\tupdate_utmp(pid, DEAD_PROCESS,\n\t\t\t\t/*tty_name:*/ NULL,\n\t\t\t\t/*username:*/ NULL,\n\t\t\t\t/*hostname:*/ NULL\n\t\t);\n\t\tfor (a = init_action_list; a; a = a->next) {\n\t\t\tif (a->pid == pid) {\n\t\t\t\ta->pid = 0;\n\t\t\t\treturn a;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n## Example:\n\n Input assembly code:\n0x0045DC00 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0045DC04 | FD 03 00 91 | MOV             X29, SP\n0x0045DC08 | E0 2F 00 B9 | STR             W0, [SP,#0x30+af]\n0x0045DC0C | E1 13 00 F9 | STR             X1, [SP,#0x30+addr]\n0x0045DC10 | E2 0F 00 F9 | STR             X2, [SP,#0x30+buf]\n0x0045DC14 | E3 2B 00 B9 | STR             W3, [SP,#0x30+buflen]\n0x0045DC18 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+af]\n0x0045DC1C | 1F 08 00 71 | CMP             W0, #2\n0x0045DC20 | 80 00 00 54 | B.EQ            loc_45DC30\n0x0045DC24 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+af]\n0x0045DC28 | 1F 28 00 71 | CMP             W0, #0xA\n0x0045DC2C | 01 01 00 54 | B.NE            loc_45DC4C\n0x0045DC30 | E0 2B 40 B9 | LDR             W0, [SP,#0x30+buflen]\n0x0045DC34 | E3 03 00 2A | MOV             W3, W0; len\n0x0045DC38 | E2 0F 40 F9 | LDR             X2, [SP,#0x30+buf]; buf\n0x0045DC3C | E1 13 40 F9 | LDR             X1, [SP,#0x30+addr]; cp\n0x0045DC40 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+af]; af\n0x0045DC44 | 47 A8 FE 97 | BL              .inet_ntop\n0x0045DC48 | 03 00 00 14 | B               loc_45DC54\n0x0045DC4C | 60 07 00 D0 00 40 19 91 | ADRL            X0, asc_54B650; \"???\"\n0x0045DC54 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0045DC58 | C0 03 5F D6 | RET\n\n Output decompiled code:\nconst char *rt_addr_n2a(int af,\n\t\tvoid *addr, char *buf, int buflen)\n{\n\tswitch (af) {\n\tcase AF_INET:\n\tcase AF_INET6:\n\t\treturn inet_ntop(af, addr, buf, buflen);\n\tdefault:\n\t\treturn \"???\";\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x0048D114 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0048D118 | FD 03 00 91 | MOV             X29, SP\n0x0048D11C | E0 0F 00 F9 | STR             X0, [SP,#0x20+buf]\n0x0048D120 | E1 17 00 B9 | STR             W1, [SP,#0x20+tok]\n0x0048D124 | E0 17 40 B9 | LDR             W0, [SP,#0x20+tok]\n0x0048D128 | 1F 0C 00 71 | CMP             W0, #3\n0x0048D12C | EC 00 00 54 | B.GT            loc_48D148\n0x0048D130 | 00 06 00 D0 00 40 3D 91 | ADRL            X0, tokname_array\n0x0048D138 | E1 17 80 B9 | LDRSW           X1, [SP,#0x20+tok]\n0x0048D13C | 00 78 61 F8 | LDR             X0, [X0,X1,LSL#3]\n0x0048D140 | 00 04 00 91 | ADD             X0, X0, #1\n0x0048D144 | 0C 00 00 14 | B               loc_48D174\n0x0048D148 | 00 06 00 D0 00 40 3D 91 | ADRL            X0, tokname_array\n0x0048D150 | E1 17 80 B9 | LDRSW           X1, [SP,#0x20+tok]\n0x0048D154 | 00 78 61 F8 | LDR             X0, [X0,X1,LSL#3]\n0x0048D158 | 00 04 00 91 | ADD             X0, X0, #1\n0x0048D15C | E2 03 00 AA | MOV             X2, X0\n0x0048D160 | 00 06 00 F0 | ADRP            X0, #aS_109@PAGE; \"\\\"%s\\\"\"\n0x0048D164 | 01 A0 1C 91 | ADD             X1, X0, #aS_109@PAGEOFF; \"\\\"%s\\\"\"\n0x0048D168 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+buf]; s\n0x0048D16C | 4D E6 FD 97 | BL              .sprintf\n0x0048D170 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+buf]\n0x0048D174 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0048D178 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic const char *\ntokname(char *buf, int tok)\n{\n\tif (tok < TSEMI)\n\t\treturn tokname_array[tok] + 1;\n\tsprintf(buf, \"\\\"%s\\\"\", tokname_array[tok] + 1);\n\treturn buf;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0050815C | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00508160 | FD 03 00 91 | MOV             X29, SP\n0x00508164 | E0 1F 00 B9 | STR             W0, [SP,#0x20+num1]\n0x00508168 | E1 1B 00 B9 | STR             W1, [SP,#0x20+num2]\n0x0050816C | E2 0B 00 F9 | STR             X2, [SP,#0x20+for_what]\n0x00508170 | E0 1F 40 B9 | LDR             W0, [SP,#0x20+num1]\n0x00508174 | 1F 00 00 71 | CMP             W0, #0\n0x00508178 | 8D 01 00 54 | B.LE            loc_5081A8\n0x0050817C | 60 04 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00508184 | 00 00 40 F9 | LDR             X0, [X0]\n0x00508188 | 00 04 40 B9 | LDR             W0, [X0,#4]\n0x0050818C | E1 1B 40 B9 | LDR             W1, [SP,#0x20+num2]\n0x00508190 | 3F 00 00 6B | CMP             W1, W0\n0x00508194 | AC 00 00 54 | B.GT            loc_5081A8\n0x00508198 | E1 1F 40 B9 | LDR             W1, [SP,#0x20+num1]\n0x0050819C | E0 1B 40 B9 | LDR             W0, [SP,#0x20+num2]\n0x005081A0 | 3F 00 00 6B | CMP             W1, W0\n0x005081A4 | ED 00 00 54 | B.LE            loc_5081C0\n0x005081A8 | E1 0B 40 F9 | LDR             X1, [SP,#0x20+for_what]\n0x005081AC | A0 02 00 90 00 C0 3F 91 | ADRL            X0, aBadLineRangeFo; \"bad line range for %s\"\n0x005081B4 | D8 06 FC 97 | BL              bb_error_msg\n0x005081B8 | 20 00 80 52 | MOV             W0, #1\n0x005081BC | 02 00 00 14 | B               loc_5081C4\n0x005081C0 | 00 00 80 52 | MOV             W0, #0\n0x005081C4 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x005081C8 | C0 03 5F D6 | RET",
        "output": "```c\nstatic int check_line_range(int num1, int num2, const char *for_what)\n{\n    if (num1 <= 0)\n        goto bad_range;\n    if (num2 < globals->max_line)\n        if (num1 <= num2)\n            return 0;\n\nbad_range:\n    bb_error_msg(\"bad line range for %s\", for_what);\n    return 1;\n}\n```"
    },
    {
        "func_name": "unalias",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0049D0E0 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0049D0E4 | FD 03 00 91 | MOV             X29, SP\n0x0049D0E8 | E0 0F 00 F9 | STR             X0, [SP,#0x20+argv]\n0x0049D0EC | E0 0F 40 F9 | LDR             X0, [SP,#0x20+argv]; argv\n0x0049D0F0 | 9B FF FF 97 | BL              skip_dash_dash\n0x0049D0F4 | E0 0F 00 F9 | STR             X0, [SP,#0x20+argv]\n0x0049D0F8 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+argv]\n0x0049D0FC | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D100 | 1F 00 00 F1 | CMP             X0, #0\n0x0049D104 | 61 00 00 54 | B.NE            loc_49D110\n0x0049D108 | 00 00 80 52 | MOV             W0, #0\n0x0049D10C | 1C 00 00 14 | B               loc_49D17C\n0x0049D110 | C0 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0049D118 | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D11C | 00 3C 40 B9 | LDR             W0, [X0,#0x3C]\n0x0049D120 | 1F 00 00 71 | CMP             W0, #0\n0x0049D124 | 80 02 00 54 | B.EQ            loc_49D174\n0x0049D128 | 22 A7 FD 97 | BL              .getpid\n0x0049D12C | E1 03 00 2A | MOV             W1, W0\n0x0049D130 | C0 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0049D138 | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D13C | 00 20 40 B9 | LDR             W0, [X0,#0x20]\n0x0049D140 | 3F 00 00 6B | CMP             W1, W0\n0x0049D144 | 81 01 00 54 | B.NE            loc_49D174\n0x0049D148 | C0 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0049D150 | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D154 | 02 00 40 B9 | LDR             W2, [X0]\n0x0049D158 | C0 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0049D160 | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D164 | 00 3C 40 B9 | LDR             W0, [X0,#0x3C]\n0x0049D168 | E1 03 00 2A | MOV             W1, W0; pgrp_id\n0x0049D16C | E0 03 02 2A | MOV             W0, W2; fd\n0x0049D170 | A4 A5 FD 97 | BL              .tcsetpgrp\n0x0049D174 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+argv]; argv\n0x0049D178 | 53 F4 FF 97 | BL              execvp_or_die\n0x0049D17C | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0049D180 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int FAST_FUNC builtin_exec(char **argv)\n{\n\targv = skip_dash_dash(argv);\n\tif (argv[0] == NULL)\n\t\treturn EXIT_SUCCESS; /* bash does this */\n\n\t/* Careful: we can end up here after [v]fork. Do not restore\n\t * tty pgrp then, only top-level shell process does that */\n\tif (G_saved_tty_pgrp && getpid() == G.root_pid)\n\t\ttcsetpgrp(G_interactive_fd, G_saved_tty_pgrp);\n\n\t/* TODO: if exec fails, bash does NOT exit! We do.\n\t * We'll need to undo trap cleanup (it's inside execvp_or_die)\n\t * and tcsetpgrp, and this is inherently racy.\n\t */\n\texecvp_or_die(argv);\n}\n\n## Example:\n\n Input assembly code:\n0x0049CFDC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0049CFE0 | FD 03 00 91 | MOV             X29, SP\n0x0049CFE4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+argv]\n0x0049CFE8 | FF 2F 00 B9 | STR             WZR, [SP,#0x30+rcode]\n0x0049CFEC | E0 0F 40 F9 | LDR             X0, [SP,#0x30+argv]; argv\n0x0049CFF0 | DB FF FF 97 | BL              skip_dash_dash\n0x0049CFF4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+argv]\n0x0049CFF8 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+argv]\n0x0049CFFC | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D000 | 1F 00 00 F1 | CMP             X0, #0\n0x0049D004 | A0 01 00 54 | B.EQ            loc_49D038\n0x0049D008 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+argv]; argv\n0x0049D00C | 17 F0 FF 97 | BL              expand_strvec_to_string\n0x0049D010 | E0 13 00 F9 | STR             X0, [SP,#0x30+str]\n0x0049D014 | E0 13 40 F9 | LDR             X0, [SP,#0x30+str]; s\n0x0049D018 | 82 F1 FF 97 | BL              parse_and_run_string\n0x0049D01C | E0 13 40 F9 | LDR             X0, [SP,#0x30+str]; ptr\n0x0049D020 | 30 A9 FD 97 | BL              .free\n0x0049D024 | C0 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0049D02C | 00 00 40 F9 | LDR             X0, [X0]\n0x0049D030 | 00 5C 40 B9 | LDR             W0, [X0,#0x5C]\n0x0049D034 | E0 2F 00 B9 | STR             W0, [SP,#0x30+rcode]\n0x0049D038 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+rcode]\n0x0049D03C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0049D040 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int FAST_FUNC builtin_eval(char **argv)\n{\n\tint rcode = EXIT_SUCCESS;\n\n\targv = skip_dash_dash(argv);\n\tif (*argv) {\n\t\tchar *str = expand_strvec_to_string(argv);\n\t\t/* bash:\n\t\t * eval \"echo Hi; done\" (\"done\" is syntax error):\n\t\t * \"echo Hi\" will not execute too.\n\t\t */\n\t\tparse_and_run_string(str);\n\t\tfree(str);\n\t\trcode = G.last_exitcode;\n\t}\n\treturn rcode;\n}\n\n## Example:\n\n Input assembly code:\n0x0047E1EC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0047E1F0 | FD 03 00 91 | MOV             X29, SP\n0x0047E1F4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+name]\n0x0047E1F8 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+name]; p\n0x0047E1FC | 83 FF FF 97 | BL              hashvar\n0x0047E200 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+name]; name\n0x0047E204 | E2 FF FF 97 | BL              findvar\n0x0047E208 | 00 00 40 F9 | LDR             X0, [X0]\n0x0047E20C | E0 17 00 F9 | STR             X0, [SP,#0x30+v]\n0x0047E210 | E0 17 40 F9 | LDR             X0, [SP,#0x30+v]\n0x0047E214 | 1F 00 00 F1 | CMP             X0, #0\n0x0047E218 | 60 02 00 54 | B.EQ            loc_47E264\n0x0047E21C | E0 17 40 F9 | LDR             X0, [SP,#0x30+v]\n0x0047E220 | 00 08 40 B9 | LDR             W0, [X0,#8]\n0x0047E224 | 00 00 17 12 | AND             W0, W0, #0x200\n0x0047E228 | 1F 00 00 71 | CMP             W0, #0\n0x0047E22C | A0 00 00 54 | B.EQ            loc_47E240\n0x0047E230 | E0 17 40 F9 | LDR             X0, [SP,#0x30+v]\n0x0047E234 | 01 0C 40 F9 | LDR             X1, [X0,#0x18]\n0x0047E238 | 00 00 80 D2 | MOV             X0, #0\n0x0047E23C | 20 00 3F D6 | BLR             X1\n0x0047E240 | E0 17 40 F9 | LDR             X0, [SP,#0x30+v]\n0x0047E244 | 00 08 40 B9 | LDR             W0, [X0,#8]\n0x0047E248 | 00 00 1B 12 | AND             W0, W0, #0x20\n0x0047E24C | 1F 00 00 71 | CMP             W0, #0\n0x0047E250 | A1 00 00 54 | B.NE            loc_47E264\n0x0047E254 | E0 17 40 F9 | LDR             X0, [SP,#0x30+v]\n0x0047E258 | 00 08 40 F9 | LDR             X0, [X0,#0x10]; var\n0x0047E25C | 6B F9 FF 97 | BL              var_end\n0x0047E260 | 02 00 00 14 | B               loc_47E268\n0x0047E264 | 00 00 80 D2 | MOV             X0, #0\n0x0047E268 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0047E26C | C0 03 5F D6 | RET\n\n Output decompiled code:\nFAST_FUNC\nlookupvar(const char *name)\n{\n\tstruct var *v;\n\n\tv = *findvar(hashvar(name), name);\n\tif (v) {\n#if ENABLE_ASH_RANDOM_SUPPORT\n\t/*\n\t * Dynamic variables are implemented roughly the same way they are\n\t * in bash. Namely, they're \"special\" so long as they aren't unset.\n\t * As soon as they're unset, they're no longer dynamic, and dynamic\n\t * lookup will no longer happen at that point. -- PFM.\n\t */\n\t\tif (v->flags & VDYNAMIC)\n\t\t\tv->var_func(NULL);\n#endif\n\t\tif (!(v->flags & VUNSET))\n\t\t\treturn var_end(v->var_text);\n\t}\n\treturn NULL;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0047F980 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0047F984 | FD 03 00 91 | MOV             X29, SP\n0x0047F988 | E0 0F 00 F9 | STR             X0, [SP,#0x30+name]\n0x0047F98C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+name]; name\n0x0047F990 | 4C FF FF 97 | BL              __lookupalias\n0x0047F994 | E0 17 00 F9 | STR             X0, [SP,#0x30+app]\n0x0047F998 | E0 17 40 F9 | LDR             X0, [SP,#0x30+app]\n0x0047F99C | 00 00 40 F9 | LDR             X0, [X0]\n0x0047F9A0 | 1F 00 00 F1 | CMP             X0, #0\n0x0047F9A4 | 00 02 00 54 | B.EQ            loc_47F9E4\n0x0047F9A8 | A0 08 00 D0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x0047F9B0 | 00 00 40 F9 | LDR             X0, [X0]\n0x0047F9B4 | 01 30 40 B9 | LDR             W1, [X0,#0x30]\n0x0047F9B8 | 21 04 00 11 | ADD             W1, W1, #1\n0x0047F9BC | 01 30 00 B9 | STR             W1, [X0,#0x30]\n0x0047F9C0 | E0 17 40 F9 | LDR             X0, [SP,#0x30+app]\n0x0047F9C4 | 00 00 40 F9 | LDR             X0, [X0]; ap\n0x0047F9C8 | 97 FF FF 97 | BL              freealias\n0x0047F9CC | E1 03 00 AA | MOV             X1, X0\n0x0047F9D0 | E0 17 40 F9 | LDR             X0, [SP,#0x30+app]\n0x0047F9D4 | 01 00 00 F9 | STR             X1, [X0]\n0x0047F9D8 | DC F3 FF 97 | BL              int_on\n0x0047F9DC | 00 00 80 52 | MOV             W0, #0\n0x0047F9E0 | 02 00 00 14 | B               loc_47F9E8\n0x0047F9E4 | 20 00 80 52 | MOV             W0, #1\n0x0047F9E8 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0047F9EC | C0 03 5F D6 | RET",
        "output": "```c\nint FAST_FUNC unset_alias(const char *name)\n{\n\tstruct alias *app;\n\n\tapp = __lookupalias(name);\n\tif (app && app->name) {\n\t\tash_ptr_to_globals_misc->num_aliases++;\n\t\tfreealias(app->name);\n\t\tapp->name = NULL;\n\t\tint_on();\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n```"
    },
    {
        "func_name": "volume_id_probe_cramfs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004BFEE0 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004BFEE4 | FD 03 00 91 | MOV             X29, SP\n0x004BFEE8 | E0 0F 00 F9 | STR             X0, [SP,#0x30+id]\n0x004BFEEC | 02 4A 80 D2 | MOV             X2, #0x250; len\n0x004BFEF0 | 01 00 80 D2 | MOV             X1, #0; off\n0x004BFEF4 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+id]; id\n0x004BFEF8 | 90 04 00 94 | BL              volume_id_get_buffer\n0x004BFEFC | E0 17 00 F9 | STR             X0, [SP,#0x30+header]\n0x004BFF00 | E0 17 40 F9 | LDR             X0, [SP,#0x30+header]\n0x004BFF04 | 1F 00 00 F1 | CMP             X0, #0\n0x004BFF08 | 61 00 00 54 | B.NE            loc_4BFF14\n0x004BFF0C | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004BFF10 | 12 00 00 14 | B               loc_4BFF58\n0x004BFF14 | E3 17 40 F9 | LDR             X3, [SP,#0x30+header]\n0x004BFF18 | C2 00 80 D2 | MOV             X2, #6; n\n0x004BFF1C | C0 04 00 90 | ADRP            X0, #LUKS_MAGIC@PAGE\n0x004BFF20 | 01 80 12 91 | ADD             X1, X0, #LUKS_MAGIC@PAGEOFF; s2\n0x004BFF24 | E0 03 03 AA | MOV             X0, X3; s1\n0x004BFF28 | 0A 1D FD 97 | BL              .memcmp\n0x004BFF2C | 1F 00 00 71 | CMP             W0, #0\n0x004BFF30 | 60 00 00 54 | B.EQ            loc_4BFF3C\n0x004BFF34 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004BFF38 | 08 00 00 14 | B               loc_4BFF58\n0x004BFF3C | E0 17 40 F9 | LDR             X0, [SP,#0x30+header]\n0x004BFF40 | 00 A0 02 91 | ADD             X0, X0, #0xA8\n0x004BFF44 | 62 00 80 52 | MOV             W2, #3; format\n0x004BFF48 | E1 03 00 AA | MOV             X1, X0; buf\n0x004BFF4C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+id]; id\n0x004BFF50 | AA 03 00 94 | BL              volume_id_set_uuid\n0x004BFF54 | 00 00 80 52 | MOV             W0, #0\n0x004BFF58 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004BFF5C | C0 03 5F D6 | RET\n\n Output decompiled code:\nint FAST_FUNC volume_id_probe_luks(struct volume_id *id /*,uint64_t off*/)\n{\n#define off ((uint64_t)0)\n\tstruct luks_phdr *header;\n\n\theader = volume_id_get_buffer(id, off, sizeof(*header));\n\tif (header == NULL)\n\t\treturn -1;\n\n\tif (memcmp(header->magic, LUKS_MAGIC, LUKS_MAGIC_L))\n\t\treturn -1;\n\n//\tvolume_id_set_usage(id, VOLUME_ID_CRYPTO);\n\tvolume_id_set_uuid(id, header->uuid, UUID_DCE_STRING);\n\tIF_FEATURE_BLKID_TYPE(id->type = \"crypto_LUKS\";)\n\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x004BEB14 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004BEB18 | FD 03 00 91 | MOV             X29, SP\n0x004BEB1C | E0 0F 00 F9 | STR             X0, [SP,#0x30+id]\n0x004BEB20 | 02 40 80 D2 | MOV             X2, #0x200; len\n0x004BEB24 | 01 80 80 D2 | MOV             X1, #0x400; off\n0x004BEB28 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+id]; id\n0x004BEB2C | 83 09 00 94 | BL              volume_id_get_buffer\n0x004BEB30 | E0 17 00 F9 | STR             X0, [SP,#0x30+es]\n0x004BEB34 | E0 17 40 F9 | LDR             X0, [SP,#0x30+es]\n0x004BEB38 | 1F 00 00 F1 | CMP             X0, #0\n0x004BEB3C | 61 00 00 54 | B.NE            loc_4BEB48\n0x004BEB40 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004BEB44 | 15 00 00 14 | B               loc_4BEB98\n0x004BEB48 | E0 17 40 F9 | LDR             X0, [SP,#0x30+es]\n0x004BEB4C | 01 70 40 79 | LDRH            W1, [X0,#0x38]\n0x004BEB50 | 60 EA 9D 52 | MOV             W0, #0xEF53\n0x004BEB54 | 3F 00 00 6B | CMP             W1, W0\n0x004BEB58 | 60 00 00 54 | B.EQ            loc_4BEB64\n0x004BEB5C | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004BEB60 | 0E 00 00 14 | B               loc_4BEB98\n0x004BEB64 | E0 17 40 F9 | LDR             X0, [SP,#0x30+es]\n0x004BEB68 | 00 E0 01 91 | ADD             X0, X0, #0x78 ; 'x'\n0x004BEB6C | 02 02 80 D2 | MOV             X2, #0x10; count\n0x004BEB70 | E1 03 00 AA | MOV             X1, X0; buf\n0x004BEB74 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+id]; id\n0x004BEB78 | 5F 08 00 94 | BL              volume_id_set_label_string\n0x004BEB7C | E0 17 40 F9 | LDR             X0, [SP,#0x30+es]\n0x004BEB80 | 00 A0 01 91 | ADD             X0, X0, #0x68 ; 'h'\n0x004BEB84 | 42 00 80 52 | MOV             W2, #2; format\n0x004BEB88 | E1 03 00 AA | MOV             X1, X0; buf\n0x004BEB8C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+id]; id\n0x004BEB90 | 9A 08 00 94 | BL              volume_id_set_uuid\n0x004BEB94 | 00 00 80 52 | MOV             W0, #0\n0x004BEB98 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004BEB9C | C0 03 5F D6 | RET\n\n Output decompiled code:\ndefine EXT_SUPERBLOCK_OFFSET\t\t\t0x400\n\nint FAST_FUNC volume_id_probe_ext(struct volume_id *id /*,uint64_t off*/)\n{\n#define off ((uint64_t)0)\n\tstruct ext2_super_block *es;\n\n\tdbg(\"ext: probing at offset 0x%llx\", (unsigned long long) off);\n\n\tes = volume_id_get_buffer(id, off + EXT_SUPERBLOCK_OFFSET, 0x200);\n\tif (es == NULL)\n\t\treturn -1;\n\n\tif (es->s_magic != cpu_to_le16(EXT2_SUPER_MAGIC)) {\n\t\tdbg(\"ext: no magic found\");\n\t\treturn -1;\n\t}\n\n//\tvolume_id_set_usage(id, VOLUME_ID_FILESYSTEM);\n//\tvolume_id_set_label_raw(id, es->volume_name, 16);\n\tvolume_id_set_label_string(id, (void*)es->s_volume_name, 16);\n\tvolume_id_set_uuid(id, es->s_uuid, UUID_DCE);\n\tdbg(\"ext: label '%s' uuid '%s'\", id->label, id->uuid);\n\n#if ENABLE_FEATURE_BLKID_TYPE\n\tif ((es->s_feature_ro_compat & cpu_to_le32(EXT4_FEATURE_RO_COMPAT_HUGE_FILE | EXT4_FEATURE_RO_COMPAT_DIR_NLINK))\n\t || (es->s_feature_incompat & cpu_to_le32(EXT4_FEATURE_INCOMPAT_EXTENTS | EXT4_FEATURE_INCOMPAT_64BIT))\n\t) {\n\t\tid->type = \"ext4\";\n\t}\n\telse if (es->s_feature_compat & cpu_to_le32(EXT3_FEATURE_COMPAT_HAS_JOURNAL))\n\t\tid->type = \"ext3\";\n\telse\n\t\tid->type = \"ext2\";\n#endif\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x004BFF60 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004BFF64 | FD 03 00 91 | MOV             X29, SP\n0x004BFF68 | E0 0F 00 F9 | STR             X0, [SP,#0x30+id]\n0x004BFF6C | 02 1F 80 D2 | MOV             X2, #0xF8; len\n0x004BFF70 | 01 80 80 D2 | MOV             X1, #0x400; off\n0x004BFF74 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+id]; id\n0x004BFF78 | 70 04 00 94 | BL              volume_id_get_buffer\n0x004BFF7C | E0 17 00 F9 | STR             X0, [SP,#0x30+sb]\n0x004BFF80 | E0 17 40 F9 | LDR             X0, [SP,#0x30+sb]\n0x004BFF84 | 1F 00 00 F1 | CMP             X0, #0\n0x004BFF88 | 61 00 00 54 | B.NE            loc_4BFF94\n0x004BFF8C | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004BFF90 | 15 00 00 14 | B               loc_4BFFE4\n0x004BFF94 | E0 17 40 F9 | LDR             X0, [SP,#0x30+sb]\n0x004BFF98 | 01 0C 40 79 | LDRH            W1, [X0,#6]\n0x004BFF9C | 80 86 86 52 | MOV             W0, #0x3434\n0x004BFFA0 | 3F 00 00 6B | CMP             W1, W0\n0x004BFFA4 | 60 00 00 54 | B.EQ            loc_4BFFB0\n0x004BFFA8 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004BFFAC | 0E 00 00 14 | B               loc_4BFFE4\n0x004BFFB0 | E0 17 40 F9 | LDR             X0, [SP,#0x30+sb]\n0x004BFFB4 | 00 A0 02 91 | ADD             X0, X0, #0xA8\n0x004BFFB8 | 02 08 80 D2 | MOV             X2, #0x40 ; '@'; count\n0x004BFFBC | E1 03 00 AA | MOV             X1, X0; buf\n0x004BFFC0 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+id]; id\n0x004BFFC4 | 4C 03 00 94 | BL              volume_id_set_label_string\n0x004BFFC8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+sb]\n0x004BFFCC | 00 60 02 91 | ADD             X0, X0, #0x98\n0x004BFFD0 | 42 00 80 52 | MOV             W2, #2; format\n0x004BFFD4 | E1 03 00 AA | MOV             X1, X0; buf\n0x004BFFD8 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+id]; id\n0x004BFFDC | 87 03 00 94 | BL              volume_id_set_uuid\n0x004BFFE0 | 00 00 80 52 | MOV             W0, #0\n0x004BFFE4 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004BFFE8 | C0 03 5F D6 | RET\n\n Output decompiled code:\nint FAST_FUNC volume_id_probe_nilfs(struct volume_id *id /*,uint64_t off*/)\n{\n\tstruct nilfs2_super_block *sb;\n\n\t// Primary super block\n\tdbg(\"nilfs: probing at offset 0x%x\", NILFS_SB1_OFFSET);\n\n\tsb = volume_id_get_buffer(id, NILFS_SB1_OFFSET, sizeof(*sb));\n\n\tif (sb == NULL)\n\t\treturn -1;\n\n\tif (sb->s_magic != NILFS_MAGIC)\n\t\treturn -1;\n\n\t// The secondary superblock is not always used, so ignore it for now.\n\t// When used it is at 4K from the end of the partition (sb->s_dev_size - NILFS_SB2_OFFSET).\n\n\tvolume_id_set_label_string(id, sb->s_volume_name, NILFS_LABEL_SIZE < VOLUME_ID_LABEL_SIZE ?\n\t\t\t\tNILFS_LABEL_SIZE : VOLUME_ID_LABEL_SIZE);\n\tvolume_id_set_uuid(id, sb->s_uuid, UUID_DCE);\n\n\tif (sb->s_rev_level == 2)\n\t\tIF_FEATURE_BLKID_TYPE(id->type = \"nilfs2\");\n\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004BE8AC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004BE8B0 | FD 03 00 91 | MOV             X29, SP\n0x004BE8B4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+id]\n0x004BE8B8 | 02 40 80 D2 | MOV             X2, #0x200; len\n0x004BE8BC | 01 00 80 D2 | MOV             X1, #0; off\n0x004BE8C0 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+id]; id\n0x004BE8C4 | 1D 0A 00 94 | BL              volume_id_get_buffer\n0x004BE8C8 | E0 17 00 F9 | STR             X0, [SP,#0x30+cs]\n0x004BE8CC | E0 17 40 F9 | LDR             X0, [SP,#0x30+cs]\n0x004BE8D0 | 1F 00 00 F1 | CMP             X0, #0\n0x004BE8D4 | 61 00 00 54 | B.NE            loc_4BE8E0\n0x004BE8D8 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004BE8DC | 10 00 00 14 | B               loc_4BE91C\n0x004BE8E0 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cs]\n0x004BE8E4 | 01 00 40 B9 | LDR             W1, [X0]\n0x004BE8E8 | A0 A8 87 52 A0 19 A5 72 | MOV             W0, #0x28CD3D45\n0x004BE8F0 | 3F 00 00 6B | CMP             W1, W0\n0x004BE8F4 | 21 01 00 54 | B.NE            loc_4BE918\n0x004BE8F8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cs]\n0x004BE8FC | 00 C0 00 91 | ADD             X0, X0, #0x30 ; '0'\n0x004BE900 | 02 02 80 D2 | MOV             X2, #0x10; count\n0x004BE904 | E1 03 00 AA | MOV             X1, X0; buf\n0x004BE908 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+id]; id\n0x004BE90C | FA 08 00 94 | BL              volume_id_set_label_string\n0x004BE910 | 00 00 80 52 | MOV             W0, #0\n0x004BE914 | 02 00 00 14 | B               loc_4BE91C\n0x004BE918 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004BE91C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004BE920 | C0 03 5F D6 | RET",
        "output": "```c\nint FAST_FUNC volume_id_probe_cramfs(struct volume_id *id /*,uint64_t off*/)\n{\n\tstruct cramfs_super *cs;\n\n\tcs = volume_id_get_buffer(id, off, 0x200);\n\tif (cs == NULL)\n\t\treturn -1;\n\n\tif (cs->magic != CRAMFS_MAGIC)\n\t\treturn -1;\n\n\tvolume_id_set_label_string(id, cs->name, CRAMFS_NAMELEN);\n\n\treturn 0;\n}\n```"
    },
    {
        "func_name": "stack_nputstr",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0047D92C | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0047D930 | FD 03 00 91 | MOV             X29, SP\n0x0047D934 | E0 17 00 F9 | STR             X0, [SP,#0x30+s]\n0x0047D938 | E1 13 00 F9 | STR             X1, [SP,#0x30+n]\n0x0047D93C | E2 0F 00 F9 | STR             X2, [SP,#0x30+p]\n0x0047D940 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+p]; p\n0x0047D944 | E0 13 40 F9 | LDR             X0, [SP,#0x30+n]; newlen\n0x0047D948 | D1 FF FF 97 | BL              makestrspace\n0x0047D94C | E0 0F 00 F9 | STR             X0, [SP,#0x30+p]\n0x0047D950 | E2 13 40 F9 | LDR             X2, [SP,#0x30+n]; n\n0x0047D954 | E1 17 40 F9 | LDR             X1, [SP,#0x30+s]; src\n0x0047D958 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+p]; dest\n0x0047D95C | 3D 23 FE 97 | BL              .memcpy\n0x0047D960 | E1 03 00 AA | MOV             X1, X0\n0x0047D964 | E0 13 40 F9 | LDR             X0, [SP,#0x30+n]\n0x0047D968 | 20 00 00 8B | ADD             X0, X1, X0\n0x0047D96C | E0 0F 00 F9 | STR             X0, [SP,#0x30+p]\n0x0047D970 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+p]\n0x0047D974 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0047D978 | C0 03 5F D6 | RET",
        "output": "```c\nchar *makestrspace(char *dest, const char *src, size_t n) {\n    dest = makestrspace(dest, n);\n    memcpy(dest, src, n);\n    dest += n;\n    return dest;\n}\n```"
    },
    {
        "func_name": "dot_end",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x005116D8 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x005116DC | FD 03 00 91 | MOV             X29, SP\n0x005116E0 | F3 0B 00 F9 | STR             X19, [SP,#0x20+var_10]\n0x005116E4 | 20 04 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x005116EC | 00 00 40 F9 | LDR             X0, [X0]\n0x005116F0 | 01 08 40 F9 | LDR             X1, [X0,#0x10]\n0x005116F4 | 20 04 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x005116FC | 13 00 40 F9 | LDR             X19, [X0]\n0x00511700 | E0 03 01 AA | MOV             X0, X1; p\n0x00511704 | CC FE FF 97 | BL              begin_line\n0x00511708 | 60 0A 00 F9 | STR             X0, [X19,#0x10]\n0x0051170C | 1F 20 03 D5 | NOP\n0x00511710 | F3 0B 40 F9 | LDR             X19, [SP,#0x20+var_10]\n0x00511714 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00511718 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void dot_begin(void)\n{\n\tdot = begin_line(dot);\t// return pointer to first char cur line\n}\n\n## Example:\n\n Input assembly code:\n0x0051171C | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00511720 | FD 03 00 91 | MOV             X29, SP\n0x00511724 | F3 0B 00 F9 | STR             X19, [SP,#0x20+var_10]\n0x00511728 | 20 04 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00511730 | 00 00 40 F9 | LDR             X0, [X0]\n0x00511734 | 01 08 40 F9 | LDR             X1, [X0,#0x10]\n0x00511738 | 20 04 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00511740 | 13 00 40 F9 | LDR             X19, [X0]\n0x00511744 | E0 03 01 AA | MOV             X0, X1; p\n0x00511748 | E2 FE FF 97 | BL              end_line\n0x0051174C | 60 0A 00 F9 | STR             X0, [X19,#0x10]\n0x00511750 | 1F 20 03 D5 | NOP\n0x00511754 | F3 0B 40 F9 | LDR             X19, [SP,#0x20+var_10]\n0x00511758 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0051175C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void dot_end(void)\n{\n\tdot = end_line(dot);\t// return pointer to last char cur line\n}\n\n## Example:\n\n Input assembly code:\n0x00511838 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0051183C | FD 03 00 91 | MOV             X29, SP\n0x00511840 | F3 0B 00 F9 | STR             X19, [SP,#0x20+var_10]\n0x00511844 | 20 04 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0051184C | 00 00 40 F9 | LDR             X0, [X0]\n0x00511850 | 01 08 40 F9 | LDR             X1, [X0,#0x10]\n0x00511854 | 20 04 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0051185C | 13 00 40 F9 | LDR             X19, [X0]\n0x00511860 | E0 03 01 AA | MOV             X0, X1; p\n0x00511864 | F0 FE FF 97 | BL              next_line\n0x00511868 | 60 0A 00 F9 | STR             X0, [X19,#0x10]\n0x0051186C | 1F 20 03 D5 | NOP\n0x00511870 | F3 0B 40 F9 | LDR             X19, [SP,#0x20+var_10]\n0x00511874 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00511878 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void dot_next(void)\n{\n\tdot = next_line(dot);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0051171C | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00511720 | FD 03 00 91 | MOV             X29, SP\n0x00511724 | F3 0B 00 F9 | STR             X19, [SP,#0x20+var_10]\n0x00511728 | 20 04 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00511730 | 00 00 40 F9 | LDR             X0, [X0]\n0x00511734 | 01 08 40 F9 | LDR             X1, [X0,#0x10]\n0x00511738 | 20 04 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00511740 | 13 00 40 F9 | LDR             X19, [X0]\n0x00511744 | E0 03 01 AA | MOV             X0, X1; p\n0x00511748 | E2 FE FF 97 | BL              end_line\n0x0051174C | 60 0A 00 F9 | STR             X0, [X19,#0x10]\n0x00511750 | 1F 20 03 D5 | NOP\n0x00511754 | F3 0B 40 F9 | LDR             X19, [SP,#0x20+var_10]\n0x00511758 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0051175C | C0 03 5F D6 | RET",
        "output": "```c\nstatic void dot_end(void)\n{\n\tdot = end_line(dot);\t// return pointer to last char cur line\n}\n```"
    },
    {
        "func_name": "strtodest",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004EAEB0 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x004EAEB4 | FD 03 00 91 | MOV             X29, SP\n0x004EAEB8 | E0 0F 00 F9 | STR             X0, [SP,#0x20+dn]\n0x004EAEBC | E1 17 00 B9 | STR             W1, [SP,#0x20+nfiles]\n0x004EAEC0 | E0 17 40 B9 | LDR             W0, [SP,#0x20+nfiles]\n0x004EAEC4 | E1 03 00 2A | MOV             W1, W0; size\n0x004EAEC8 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+dn]; dn\n0x004EAECC | EC FF FF 97 | BL              dnsort\n0x004EAED0 | E1 17 40 B9 | LDR             W1, [SP,#0x20+nfiles]; nfiles\n0x004EAED4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+dn]; dn\n0x004EAED8 | 6E FD FF 97 | BL              display_files\n0x004EAEDC | 1F 20 03 D5 | NOP\n0x004EAEE0 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004EAEE4 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void sort_and_display_files(struct dnode **dn, unsigned nfiles)\n{\n\tdnsort(dn, nfiles);\n\tdisplay_files(dn, nfiles);\n}\n\n## Example:\n\n Input assembly code:\n0x0046FE64 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0046FE68 | FD 03 00 91 | MOV             X29, SP\n0x0046FE6C | E0 17 00 F9 | STR             X0, [SP,#0x30+buf]\n0x0046FE70 | E1 27 00 B9 | STR             W1, [SP,#0x30+size]\n0x0046FE74 | E2 0F 00 F9 | STR             X2, [SP,#0x30+ps]\n0x0046FE78 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+ps]\n0x0046FE7C | 00 18 40 F9 | LDR             X0, [X0,#0x30]\n0x0046FE80 | E2 03 00 AA | MOV             X2, X0; u\n0x0046FE84 | E1 27 40 B9 | LDR             W1, [SP,#0x30+size]; size\n0x0046FE88 | E0 17 40 F9 | LDR             X0, [SP,#0x30+buf]; buf\n0x0046FE8C | E1 FF FF 97 | BL              put_lu\n0x0046FE90 | 1F 20 03 D5 | NOP\n0x0046FE94 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0046FE98 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void func_vsz(char *buf, int size, const procps_status_t *ps)\n{\n\tput_lu(buf, size, ps->vsz);\n}\n\n## Example:\n\n Input assembly code:\n0x0046FE9C | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0046FEA0 | FD 03 00 91 | MOV             X29, SP\n0x0046FEA4 | E0 17 00 F9 | STR             X0, [SP,#0x30+buf]\n0x0046FEA8 | E1 27 00 B9 | STR             W1, [SP,#0x30+size]\n0x0046FEAC | E2 0F 00 F9 | STR             X2, [SP,#0x30+ps]\n0x0046FEB0 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+ps]\n0x0046FEB4 | 00 1C 40 F9 | LDR             X0, [X0,#0x38]\n0x0046FEB8 | E2 03 00 AA | MOV             X2, X0; u\n0x0046FEBC | E1 27 40 B9 | LDR             W1, [SP,#0x30+size]; size\n0x0046FEC0 | E0 17 40 F9 | LDR             X0, [SP,#0x30+buf]; buf\n0x0046FEC4 | D3 FF FF 97 | BL              put_lu\n0x0046FEC8 | 1F 20 03 D5 | NOP\n0x0046FECC | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0046FED0 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void func_rss(char *buf, int size, const procps_status_t *ps)\n{\n\tput_lu(buf, size, ps->rss);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0048402C | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00484030 | FD 03 00 91 | MOV             X29, SP\n0x00484034 | E0 0F 00 F9 | STR             X0, [SP,#0x20+p]\n0x00484038 | E1 17 00 B9 | STR             W1, [SP,#0x20+syntax]\n0x0048403C | E2 13 00 B9 | STR             W2, [SP,#0x20+quotes]\n0x00484040 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+p]; s\n0x00484044 | C3 09 FE 97 | BL              .strlen\n0x00484048 | E3 13 40 B9 | LDR             W3, [SP,#0x20+quotes]; quotes\n0x0048404C | E2 17 40 B9 | LDR             W2, [SP,#0x20+syntax]; syntax\n0x00484050 | E1 03 00 AA | MOV             X1, X0; len\n0x00484054 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+p]; p\n0x00484058 | B4 FF FF 97 | BL              memtodest\n0x0048405C | 1F 20 03 D5 | NOP\n0x00484060 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00484064 | C0 03 5F D6 | RET",
        "output": "```c\nstatic void process_string(char *p, int syntax, int quotes)\n{\n\tsize_t len = strlen(p);\n\tmemtodest(p, len, syntax, quotes);\n}\n```"
    },
    {
        "func_name": "syntax_error",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00412D34 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00412D38 | FD 03 00 91 | MOV             X29, SP\n0x00412D3C | E0 0F 00 F9 | STR             X0, [SP,#0x20+s]\n0x00412D40 | 02 00 80 12 | MOV             W2, #0xFFFFFFFF; code\n0x00412D44 | E1 0F 40 F9 | LDR             X1, [SP,#0x20+s]; param\n0x00412D48 | 60 09 00 B0 00 40 11 91 | ADRL            X0, aRcptToS; \"RCPT TO:<%s>\"\n0x00412D50 | 71 FF FF 97 | BL              smtp_checkp\n0x00412D54 | 1F E8 03 71 | CMP             W0, #0xFA\n0x00412D58 | A0 00 00 54 | B.EQ            loc_412D6C\n0x00412D5C | E1 0F 40 F9 | LDR             X1, [SP,#0x20+s]\n0x00412D60 | 60 09 00 B0 00 80 11 91 | ADRL            X0, aBadRecipientS; \"Bad recipient: <%s>\"\n0x00412D68 | EB DB FF 97 | BL              bb_error_msg\n0x00412D6C | 1F 20 03 D5 | NOP\n0x00412D70 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00412D74 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void rcptto(const char *s)\n{\n\t// N.B. we don't die if recipient is rejected, for the other recipients may be accepted\n\tif (250 != smtp_checkp(\"RCPT TO:<%s>\", s, -1))\n\t\tbb_error_msg(\"Bad recipient: <%s>\", s);\n}\n\n## Example:\n\n Input assembly code:\n0x0040AC20 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0040AC24 | FD 03 00 91 | MOV             X29, SP\n0x0040AC28 | E0 0F 00 F9 | STR             X0, [SP,#0x20+pathname]\n0x0040AC2C | E0 0F 40 F9 | LDR             X0, [SP,#0x20+pathname]; name\n0x0040AC30 | 34 F4 FF 97 | BL              .unlink\n0x0040AC34 | 1F 00 00 71 | CMP             W0, #0\n0x0040AC38 | A0 00 00 54 | B.EQ            loc_40AC4C\n0x0040AC3C | E1 0F 40 F9 | LDR             X1, [SP,#0x20+pathname]\n0x0040AC40 | A0 09 00 90 00 20 0B 91 | ADRL            X0, aCanTRemoveFile; \"can't remove file '%s'\"\n0x0040AC48 | CC FA FF 97 | BL              bb_perror_msg_and_die\n0x0040AC4C | 1F 20 03 D5 | NOP\n0x0040AC50 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0040AC54 | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid FAST_FUNC xunlink(const char *pathname)\n{\n\tif (unlink(pathname))\n\t\tbb_perror_msg_and_die(\"can't remove file '%s'\", pathname);\n}\n\n## Example:\n\n Input assembly code:\n0x0040B1EC | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0040B1F0 | FD 03 00 91 | MOV             X29, SP\n0x0040B1F4 | E0 0F 00 F9 | STR             X0, [SP,#0x20+path]\n0x0040B1F8 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+path]; path\n0x0040B1FC | B5 F0 FF 97 | BL              .chdir\n0x0040B200 | 1F 00 00 71 | CMP             W0, #0\n0x0040B204 | A0 00 00 54 | B.EQ            loc_40B218\n0x0040B208 | E1 0F 40 F9 | LDR             X1, [SP,#0x20+path]\n0x0040B20C | 80 09 00 F0 00 A0 0E 91 | ADRL            X0, aCanTChangeDire; \"can't change directory to '%s'\"\n0x0040B214 | 59 F9 FF 97 | BL              bb_perror_msg_and_die\n0x0040B218 | 1F 20 03 D5 | NOP\n0x0040B21C | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0040B220 | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid FAST_FUNC xchdir(const char *path)\n{\n\tif (chdir(path))\n\t\tbb_perror_msg_and_die(\"can't change directory to '%s'\", path);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0049281C | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00492820 | FD 03 00 91 | MOV             X29, SP\n0x00492824 | E0 0F 00 F9 | STR             X0, [SP,#0x20+msg]\n0x00492828 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+msg]\n0x0049282C | 1F 00 00 F1 | CMP             X0, #0\n0x00492830 | C0 00 00 54 | B.EQ            loc_492848\n0x00492834 | E1 0F 40 F9 | LDR             X1, [SP,#0x20+msg]\n0x00492838 | E0 05 00 F0 00 40 05 91 | ADRL            X0, aSyntaxErrorS_0; \"syntax error: %s\"\n0x00492840 | 35 DD FD 97 | BL              bb_error_msg\n0x00492844 | 04 00 00 14 | B               loc_492854\n0x00492848 | E0 05 00 F0 00 A0 05 91 | ADRL            X0, aSyntaxError; \"syntax error\"\n0x00492850 | 31 DD FD 97 | BL              bb_error_msg\n0x00492854 | 1F 20 03 D5 | NOP\n0x00492858 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0049285C | C0 03 5F D6 | RET",
        "output": "```c\nvoid syntax_error_message(const char *msg)\n{\n\tif (msg == NULL)\n\t\tbb_error_msg(\"syntax error\");\n\telse\n\t\tbb_error_msg(\"syntax error: %s\", msg);\n}\n```"
    },
    {
        "func_name": "print_raw",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0046E400 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0046E404 | FD 03 00 91 | MOV             X29, SP\n0x0046E408 | 20 09 00 F0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0046E410 | 00 00 40 F9 | LDR             X0, [X0]\n0x0046E414 | 00 00 40 F9 | LDR             X0, [X0]\n0x0046E418 | 1F 00 00 F1 | CMP             X0, #0\n0x0046E41C | 60 04 00 54 | B.EQ            loc_46E4A8\n0x0046E420 | FF 1F 00 B9 | STR             WZR, [SP,#0x20+i]\n0x0046E424 | 0D 00 00 14 | B               loc_46E458\n0x0046E428 | 20 09 00 F0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0046E430 | 00 00 40 F9 | LDR             X0, [X0]\n0x0046E434 | 01 00 40 F9 | LDR             X1, [X0]\n0x0046E438 | E0 1F 80 B9 | LDRSW           X0, [SP,#0x20+i]\n0x0046E43C | 00 EC 7C D3 | LSL             X0, X0, #4\n0x0046E440 | 20 00 00 8B | ADD             X0, X1, X0\n0x0046E444 | 00 00 40 F9 | LDR             X0, [X0]; ptr\n0x0046E448 | 26 64 FE 97 | BL              .free\n0x0046E44C | E0 1F 40 B9 | LDR             W0, [SP,#0x20+i]\n0x0046E450 | 00 04 00 11 | ADD             W0, W0, #1\n0x0046E454 | E0 1F 00 B9 | STR             W0, [SP,#0x20+i]\n0x0046E458 | 20 09 00 F0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0046E460 | 00 00 40 F9 | LDR             X0, [X0]\n0x0046E464 | 00 08 40 B9 | LDR             W0, [X0,#8]\n0x0046E468 | E1 1F 40 B9 | LDR             W1, [SP,#0x20+i]\n0x0046E46C | 3F 00 00 6B | CMP             W1, W0\n0x0046E470 | CB FD FF 54 | B.LT            loc_46E428\n0x0046E474 | 20 09 00 F0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0046E47C | 00 00 40 F9 | LDR             X0, [X0]\n0x0046E480 | 00 00 40 F9 | LDR             X0, [X0]; ptr\n0x0046E484 | 17 64 FE 97 | BL              .free\n0x0046E488 | 20 09 00 F0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0046E490 | 00 00 40 F9 | LDR             X0, [X0]\n0x0046E494 | 1F 08 00 B9 | STR             WZR, [X0,#8]\n0x0046E498 | 20 09 00 F0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0046E4A0 | 00 00 40 F9 | LDR             X0, [X0]\n0x0046E4A4 | 1F 00 00 F9 | STR             XZR, [X0]\n0x0046E4A8 | 1F 20 03 D5 | NOP\n0x0046E4AC | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0046E4B0 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic NOINLINE void clear_lines(void)\n{\n\tint i;\n\tif (G.lines) {\n\t\tfor (i = 0; i < G.lines_cnt; i++)\n\t\t\tfree(G.lines[i].string);\n\t\tfree(G.lines);\n\t\tG.lines_cnt = 0;\n\t\tG.lines = NULL;\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x0046B810 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0046B814 | FD 03 00 91 | MOV             X29, SP\n0x0046B818 | 40 09 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0046B820 | 00 00 40 F9 | LDR             X0, [X0]\n0x0046B824 | 01 08 40 F9 | LDR             X1, [X0,#0x10]\n0x0046B828 | 40 09 00 90 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0046B830 | 20 00 00 CB | SUB             X0, X1, X0\n0x0046B834 | E0 1F 00 B9 | STR             W0, [SP,#0x20+sz]\n0x0046B838 | E0 1F 40 B9 | LDR             W0, [SP,#0x20+sz]\n0x0046B83C | 1F 00 00 71 | CMP             W0, #0\n0x0046B840 | AD 01 00 54 | B.LE            loc_46B874\n0x0046B844 | E0 1F 80 B9 | LDRSW           X0, [SP,#0x20+sz]\n0x0046B848 | E2 03 00 AA | MOV             X2, X0; count\n0x0046B84C | 40 09 00 90 | ADRP            X0, #bb_common_bufsiz1@PAGE\n0x0046B850 | 01 40 0A 91 | ADD             X1, X0, #bb_common_bufsiz1@PAGEOFF; buf\n0x0046B854 | 20 00 80 52 | MOV             W0, #1; fd\n0x0046B858 | 53 7D FE 97 | BL              xwrite\n0x0046B85C | 40 09 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0046B864 | 00 00 40 F9 | LDR             X0, [X0]\n0x0046B868 | 41 09 00 90 21 40 0A 91 | ADRL            X1, bb_common_bufsiz1\n0x0046B870 | 01 08 00 F9 | STR             X1, [X0,#0x10]\n0x0046B874 | 1F 20 03 D5 | NOP\n0x0046B878 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0046B87C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void print_outbuf(void)\n{\n\tint sz = cur_outbuf - outbuf;\n\tif (sz > 0) {\n\t\txwrite(STDOUT_FILENO, outbuf, sz);\n\t\tcur_outbuf = outbuf;\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x00421C38 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00421C3C | FD 03 00 91 | MOV             X29, SP\n0x00421C40 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421C48 | 00 00 40 F9 | LDR             X0, [X0]\n0x00421C4C | 00 28 40 F9 | LDR             X0, [X0,#0x50]\n0x00421C50 | 1F 00 00 F1 | CMP             X0, #0\n0x00421C54 | 00 04 00 54 | B.EQ            loc_421CD4\n0x00421C58 | FF 1F 00 B9 | STR             WZR, [SP,#0x20+i]\n0x00421C5C | 0E 00 00 14 | B               loc_421C94\n0x00421C60 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421C68 | 00 00 40 F9 | LDR             X0, [X0]\n0x00421C6C | 01 28 40 F9 | LDR             X1, [X0,#0x50]\n0x00421C70 | E0 1F 40 B9 | LDR             W0, [SP,#0x20+i]\n0x00421C74 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00421C78 | 20 00 00 8B | ADD             X0, X1, X0\n0x00421C7C | 00 00 40 F9 | LDR             X0, [X0]\n0x00421C80 | 00 10 00 D1 | SUB             X0, X0, #4; ptr\n0x00421C84 | 17 96 FF 97 | BL              .free\n0x00421C88 | E0 1F 40 B9 | LDR             W0, [SP,#0x20+i]\n0x00421C8C | 00 04 00 11 | ADD             W0, W0, #1\n0x00421C90 | E0 1F 00 B9 | STR             W0, [SP,#0x20+i]\n0x00421C94 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421C9C | 00 00 40 F9 | LDR             X0, [X0]\n0x00421CA0 | 00 18 40 B9 | LDR             W0, [X0,#0x18]\n0x00421CA4 | E1 1F 40 B9 | LDR             W1, [SP,#0x20+i]\n0x00421CA8 | 3F 00 00 6B | CMP             W1, W0\n0x00421CAC | A9 FD FF 54 | B.LS            loc_421C60\n0x00421CB0 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421CB8 | 00 00 40 F9 | LDR             X0, [X0]\n0x00421CBC | 00 28 40 F9 | LDR             X0, [X0,#0x50]; ptr\n0x00421CC0 | 08 96 FF 97 | BL              .free\n0x00421CC4 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421CCC | 00 00 40 F9 | LDR             X0, [X0]\n0x00421CD0 | 1F 28 00 F9 | STR             XZR, [X0,#0x50]\n0x00421CD4 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421CDC | 00 00 40 F9 | LDR             X0, [X0]\n0x00421CE0 | 01 00 80 12 | MOV             W1, #0xFFFFFFFF\n0x00421CE4 | 01 18 00 B9 | STR             W1, [X0,#0x18]\n0x00421CE8 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421CF0 | 00 00 40 F9 | LDR             X0, [X0]\n0x00421CF4 | 1F 00 00 B9 | STR             WZR, [X0]\n0x00421CF8 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421D00 | 00 00 40 F9 | LDR             X0, [X0]\n0x00421D04 | 1F 1C 00 B9 | STR             WZR, [X0,#0x1C]\n0x00421D08 | 9D FF FF 97 | BL              open_file_and_read_lines\n0x00421D0C | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421D14 | 00 00 40 F9 | LDR             X0, [X0]\n0x00421D18 | 00 54 41 B9 | LDR             W0, [X0,#0x154]\n0x00421D1C | 1F 00 00 71 | CMP             W0, #0\n0x00421D20 | 80 00 00 54 | B.EQ            loc_421D30\n0x00421D24 | 00 09 00 B0 00 80 20 91 | ADRL            X0, a999999h6n; \"\\x1B[999;999H\\x1B[6n\"\n0x00421D2C | A9 97 FF 97 | BL              .printf\n0x00421D30 | A1 FE FF 97 | BL              buffer_fill_and_print\n0x00421D34 | 1F 20 03 D5 | NOP\n0x00421D38 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00421D3C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void reinitialize(void)\n{\n\tunsigned i;\n\n\tif (flines) {\n\t\tfor (i = 0; i <= max_fline; i++)\n\t\t\tfree(MEMPTR(flines[i]));\n\t\tfree(flines);\n\t\tflines = NULL;\n\t}\n\n\tmax_fline = -1;\n\tcur_fline = 0;\n\tmax_lineno = 0;\n\topen_file_and_read_lines();\n#if ENABLE_FEATURE_LESS_ASK_TERMINAL\n\tif (G.winsize_err)\n\t\tprintf(\"\\033[999;999H\" \"\\033[6n\");\n#endif\n\tbuffer_fill_and_print();\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004AB33C | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x004AB340 | FD 03 00 91 | MOV             X29, SP\n0x004AB344 | 40 07 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004AB34C | 00 00 40 F9 | LDR             X0, [X0]\n0x004AB350 | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x004AB354 | E1 03 00 AA | MOV             X1, X0\n0x004AB358 | 40 05 00 B0 00 20 02 91 | ADRL            X0, aDeviceS; \"Device: %s\\n\"\n0x004AB360 | 1C 72 FD 97 | BL              .printf\n0x004AB364 | 60 00 80 52 | MOV             W0, #3\n0x004AB368 | E0 1F 00 B9 | STR             W0, [SP,#0x20+i]\n0x004AB36C | 0F 00 00 14 | B               loc_4AB3A8\n0x004AB370 | 40 07 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004AB378 | 02 00 40 F9 | LDR             X2, [X0]\n0x004AB37C | E1 1F 80 B9 | LDRSW           X1, [SP,#0x20+i]\n0x004AB380 | E0 03 01 AA | MOV             X0, X1\n0x004AB384 | 00 F4 7E D3 | LSL             X0, X0, #2\n0x004AB388 | 00 00 01 8B | ADD             X0, X0, X1\n0x004AB38C | 00 F0 7D D3 | LSL             X0, X0, #3\n0x004AB390 | 40 00 00 8B | ADD             X0, X2, X0\n0x004AB394 | 00 30 45 F9 | LDR             X0, [X0,#0xA60]; pbuffer\n0x004AB398 | B6 FF FF 97 | BL              print_buffer\n0x004AB39C | E0 1F 40 B9 | LDR             W0, [SP,#0x20+i]\n0x004AB3A0 | 00 04 00 11 | ADD             W0, W0, #1\n0x004AB3A4 | E0 1F 00 B9 | STR             W0, [SP,#0x20+i]\n0x004AB3A8 | 40 07 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004AB3B0 | 00 00 40 F9 | LDR             X0, [X0]\n0x004AB3B4 | 00 10 40 B9 | LDR             W0, [X0,#0x10]\n0x004AB3B8 | E1 1F 40 B9 | LDR             W1, [SP,#0x20+i]\n0x004AB3BC | 3F 00 00 6B | CMP             W1, W0\n0x004AB3C0 | 8B FD FF 54 | B.LT            loc_4AB370\n0x004AB3C4 | 1F 20 03 D5 | NOP\n0x004AB3C8 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004AB3CC | C0 03 5F D6 | RET",
        "output": "```c\nstatic void print_device_buffers(void)\n{\n    int i;\n    printf(\"Device: %s\\n\", G.device_name);\n    for (i = 0; i < G.buffer_count; i++) {\n        print_buffer(&G.buffers[i]);\n    }\n}\n```"
    },
    {
        "func_name": "open_a_console",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x005295C0 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x005295C4 | FD 03 00 91 | MOV             X29, SP\n0x005295C8 | E0 0F 00 F9 | STR             X0, [SP,#0x30+device]\n0x005295CC | 01 00 80 52 | MOV             W1, #0; oflag\n0x005295D0 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+device]; file\n0x005295D4 | D3 78 FB 97 | BL              .open64\n0x005295D8 | E0 2F 00 B9 | STR             W0, [SP,#0x30+fd]\n0x005295DC | E0 2F 40 B9 | LDR             W0, [SP,#0x30+fd]\n0x005295E0 | 1F 00 00 71 | CMP             W0, #0\n0x005295E4 | 6A 00 00 54 | B.GE            loc_5295F0\n0x005295E8 | 20 00 80 52 | MOV             W0, #1\n0x005295EC | 09 00 00 14 | B               loc_529610\n0x005295F0 | 02 00 80 52 | MOV             W2, #0\n0x005295F4 | 21 80 89 D2 | MOV             X1, #0x4C01; request\n0x005295F8 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x005295FC | E5 79 FB 97 | BL              .ioctl\n0x00529600 | E0 2B 00 B9 | STR             W0, [SP,#0x30+rc]\n0x00529604 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x00529608 | FA 76 FB 97 | BL              .close\n0x0052960C | E0 2B 40 B9 | LDR             W0, [SP,#0x30+rc]\n0x00529610 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00529614 | C0 03 5F D6 | RET\n\n Output decompiled code:\nint FAST_FUNC del_loop(const char *device)\n{\n\tint fd, rc;\n\n\tfd = open(device, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 1;\n\trc = ioctl(fd, LOOP_CLR_FD, 0);\n\tclose(fd);\n\n\treturn rc;\n}\n\n## Example:\n\n Input assembly code:\n0x005336DC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x005336E0 | FD 03 00 91 | MOV             X29, SP\n0x005336E4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+argv]\n0x005336E8 | 25 5E FB 97 | BL              fflush_all\n0x005336EC | FF 2B 00 B9 | STR             WZR, [SP,#0x30+failed]\n0x005336F0 | 2C 4E FB 97 | BL              .vfork\n0x005336F4 | E0 2F 00 B9 | STR             W0, [SP,#0x30+pid]\n0x005336F8 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+pid]\n0x005336FC | 1F 00 00 71 | CMP             W0, #0\n0x00533700 | 6A 00 00 54 | B.GE            loc_53370C\n0x00533704 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+pid]\n0x00533708 | 1E 00 00 14 | B               loc_533780\n0x0053370C | E0 2F 40 B9 | LDR             W0, [SP,#0x30+pid]\n0x00533710 | 1F 00 00 71 | CMP             W0, #0\n0x00533714 | 81 01 00 54 | B.NE            loc_533744\n0x00533718 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+argv]\n0x0053371C | 00 00 40 F9 | LDR             X0, [X0]; file\n0x00533720 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+argv]; argv\n0x00533724 | 13 4F FB 97 | BL              .execvp\n0x00533728 | 00 03 00 D0 00 60 0A 91 | ADRL            X0, bb_errno\n0x00533730 | 00 00 40 F9 | LDR             X0, [X0]\n0x00533734 | 00 00 40 B9 | LDR             W0, [X0]\n0x00533738 | E0 2B 00 B9 | STR             W0, [SP,#0x30+failed]\n0x0053373C | E0 0D 80 52 | MOV             W0, #0x6F ; 'o'; status\n0x00533740 | E8 4B FB 97 | BL              ._exit\n0x00533744 | E0 2B 40 B9 | LDR             W0, [SP,#0x30+failed]\n0x00533748 | 1F 00 00 71 | CMP             W0, #0\n0x0053374C | 80 01 00 54 | B.EQ            loc_53377C\n0x00533750 | 02 00 80 52 | MOV             W2, #0; options\n0x00533754 | 01 00 80 D2 | MOV             X1, #0; wstat\n0x00533758 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+pid]; pid\n0x0053375C | 06 5C FB 97 | BL              safe_waitpid\n0x00533760 | 00 03 00 D0 00 60 0A 91 | ADRL            X0, bb_errno\n0x00533768 | 00 00 40 F9 | LDR             X0, [X0]\n0x0053376C | E1 2B 40 B9 | LDR             W1, [SP,#0x30+failed]\n0x00533770 | 01 00 00 B9 | STR             W1, [X0]\n0x00533774 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x00533778 | 02 00 00 14 | B               loc_533780\n0x0053377C | E0 2F 40 B9 | LDR             W0, [SP,#0x30+pid]\n0x00533780 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00533784 | C0 03 5F D6 | RET\n\n Output decompiled code:\npid_t FAST_FUNC spawn(char **argv)\n{\n\t/* Compiler should not optimize stores here */\n\tvolatile int failed;\n\tpid_t pid;\n\n\tfflush_all();\n\n\t/* Be nice to nommu machines. */\n\tfailed = 0;\n\tpid = vfork();\n\tif (pid < 0) /* error */\n\t\treturn pid;\n\tif (!pid) { /* child */\n\t\t/* This macro is ok - it doesn't do NOEXEC/NOFORK tricks */\n\t\tBB_EXECVP(argv[0], argv);\n\n\t\t/* We are (maybe) sharing a stack with blocked parent,\n\t\t * let parent know we failed and then exit to unblock parent\n\t\t * (but don't run atexit() stuff, which would screw up parent.)\n\t\t */\n\t\tfailed = errno;\n\t\t/* mount, for example, does not want the message */\n\t\t/*bb_perror_msg(\"can't execute '%s'\", argv[0]);*/\n\t\t_exit(111);\n\t}\n\t/* parent */\n\t/* Unfortunately, this is not reliable: according to standards\n\t * vfork() can be equivalent to fork() and we won't see value\n\t * of 'failed'.\n\t * Interested party can wait on pid and learn exit code.\n\t * If 111 - then it (most probably) failed to exec */\n\tif (failed) {\n\t\tsafe_waitpid(pid, NULL, 0); /* prevent zombie */\n\t\terrno = failed;\n\t\treturn -1;\n\t}\n\treturn pid;\n}\n\n## Example:\n\n Input assembly code:\n0x004E059C | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004E05A0 | FD 03 00 91 | MOV             X29, SP\n0x004E05A4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+fname]\n0x004E05A8 | E1 0B 00 F9 | STR             X1, [SP,#0x30+maxsz_p]\n0x004E05AC | E0 0F 40 F9 | LDR             X0, [SP,#0x30+fname]; fname\n0x004E05B0 | C1 FF FF 97 | BL              open_zipped\n0x004E05B4 | E0 2F 00 B9 | STR             W0, [SP,#0x30+fd]\n0x004E05B8 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+fd]\n0x004E05BC | 1F 00 00 71 | CMP             W0, #0\n0x004E05C0 | 6A 00 00 54 | B.GE            loc_4E05CC\n0x004E05C4 | 00 00 80 D2 | MOV             X0, #0\n0x004E05C8 | 0F 00 00 14 | B               loc_4E0604\n0x004E05CC | E1 0B 40 F9 | LDR             X1, [SP,#0x30+maxsz_p]; maxsz_p\n0x004E05D0 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x004E05D4 | 0F 3E 01 94 | BL              xmalloc_read\n0x004E05D8 | E0 13 00 F9 | STR             X0, [SP,#0x30+image]\n0x004E05DC | E0 13 40 F9 | LDR             X0, [SP,#0x30+image]\n0x004E05E0 | 1F 00 00 F1 | CMP             X0, #0\n0x004E05E4 | A1 00 00 54 | B.NE            loc_4E05F8\n0x004E05E8 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+fname]\n0x004E05EC | C0 03 00 90 00 E0 2B 91 | ADRL            X0, aReadErrorFromS; \"read error from '%s'\"\n0x004E05F4 | 29 A4 FC 97 | BL              bb_perror_msg\n0x004E05F8 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x004E05FC | FD 9A FC 97 | BL              .close\n0x004E0600 | E0 13 40 F9 | LDR             X0, [SP,#0x30+image]\n0x004E0604 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004E0608 | C0 03 5F D6 | RET\n\n Output decompiled code:\nFAST_FUNC xmalloc_open_zipped_read_close(const char *fname, size_t *maxsz_p)\n{\n\tint fd;\n\tchar *image;\n\n\tfd = open_zipped(fname);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\timage = xmalloc_read(fd, maxsz_p);\n\tif (!image)\n\t\tbb_perror_msg(\"read error from '%s'\", fname);\n\tclose(fd);\n\n\treturn image;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0051FEB8 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0051FEBC | FD 03 00 91 | MOV             X29, SP\n0x0051FEC0 | E0 0F 00 F9 | STR             X0, [SP,#0x30+fnam]\n0x0051FEC4 | 41 00 80 52 | MOV             W1, #2; oflag\n0x0051FEC8 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+fnam]; file\n0x0051FECC | 95 9E FB 97 | BL              .open64\n0x0051FED0 | E0 2F 00 B9 | STR             W0, [SP,#0x30+fd]\n0x0051FED4 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+fd]\n0x0051FED8 | 1F 00 00 71 | CMP             W0, #0\n0x0051FEDC | 6A 01 00 54 | B.GE            loc_51FF08\n0x0051FEE0 | A0 03 00 D0 00 60 0A 91 | ADRL            X0, bb_errno\n0x0051FEE8 | 00 00 40 F9 | LDR             X0, [X0]\n0x0051FEEC | 00 00 40 B9 | LDR             W0, [X0]\n0x0051FEF0 | 1F 34 00 71 | CMP             W0, #0xD\n0x0051FEF4 | A1 00 00 54 | B.NE            loc_51FF08\n0x0051FEF8 | 01 00 80 52 | MOV             W1, #0; oflag\n0x0051FEFC | E0 0F 40 F9 | LDR             X0, [SP,#0x30+fnam]; file\n0x0051FF00 | 88 9E FB 97 | BL              .open64\n0x0051FF04 | E0 2F 00 B9 | STR             W0, [SP,#0x30+fd]\n0x0051FF08 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+fd]\n0x0051FF0C | 1F 00 00 71 | CMP             W0, #0\n0x0051FF10 | 6A 01 00 54 | B.GE            loc_51FF3C\n0x0051FF14 | A0 03 00 D0 00 60 0A 91 | ADRL            X0, bb_errno\n0x0051FF1C | 00 00 40 F9 | LDR             X0, [X0]\n0x0051FF20 | 00 00 40 B9 | LDR             W0, [X0]\n0x0051FF24 | 1F 34 00 71 | CMP             W0, #0xD\n0x0051FF28 | A1 00 00 54 | B.NE            loc_51FF3C\n0x0051FF2C | 21 00 80 52 | MOV             W1, #1; oflag\n0x0051FF30 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+fnam]; file\n0x0051FF34 | 7B 9E FB 97 | BL              .open64\n0x0051FF38 | E0 2F 00 B9 | STR             W0, [SP,#0x30+fd]\n0x0051FF3C | E0 2F 40 B9 | LDR             W0, [SP,#0x30+fd]\n0x0051FF40 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0051FF44 | C0 03 5F D6 | RET",
        "output": "```c\nint FAST_FUNC open_or_warn(const char *fnam, int oflag)\n{\n\tint fd;\n\n\tfd = open64(fnam, oflag);\n\tif (fd < 0 && errno == ENOENT) {\n\t\toflag &= ~O_CREAT;\n\t\tfd = open64(fnam, oflag);\n\t\tif (fd < 0 && errno == ENOENT) {\n\t\t\toflag |= O_CREAT;\n\t\t\tfd = open64(fnam, oflag);\n\t\t}\n\t}\n\n\treturn fd;\n}\n```"
    },
    {
        "func_name": "strstatus",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0042674C | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x00426750 | E0 0F 00 B9 | STR             W0, [SP,#0x10+cmd]\n0x00426754 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+cmd]\n0x00426758 | 1F 14 00 71 | CMP             W0, #5\n0x0042675C | CD 00 00 54 | B.LE            loc_426774\n0x00426760 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+cmd]\n0x00426764 | 1F 3C 00 71 | CMP             W0, #0xF\n0x00426768 | 6C 00 00 54 | B.GT            loc_426774\n0x0042676C | 20 00 80 52 | MOV             W0, #1\n0x00426770 | 02 00 00 14 | B               loc_426778\n0x00426774 | 00 00 80 52 | MOV             W0, #0\n0x00426778 | 00 00 00 12 | AND             W0, W0, #1\n0x0042677C | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x00426780 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x00426784 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic bool cmd_is_flag(int cmd)\n{\n\treturn (cmd >= CMD_FLAG_FIRST && cmd <= CMD_FLAG_LAST);\n}\n\n## Example:\n\n Input assembly code:\n0x00426788 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x0042678C | E0 0F 00 B9 | STR             W0, [SP,#0x10+cmd]\n0x00426790 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+cmd]\n0x00426794 | 1F 3C 00 71 | CMP             W0, #0xF\n0x00426798 | CD 00 00 54 | B.LE            loc_4267B0\n0x0042679C | E0 0F 40 B9 | LDR             W0, [SP,#0x10+cmd]\n0x004267A0 | 1F 58 00 71 | CMP             W0, #0x16\n0x004267A4 | 6C 00 00 54 | B.GT            loc_4267B0\n0x004267A8 | 20 00 80 52 | MOV             W0, #1\n0x004267AC | 02 00 00 14 | B               loc_4267B4\n0x004267B0 | 00 00 80 52 | MOV             W0, #0\n0x004267B4 | 00 00 00 12 | AND             W0, W0, #1\n0x004267B8 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x004267BC | FF 43 00 91 | ADD             SP, SP, #0x10\n0x004267C0 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic bool cmd_need_arg(int cmd)\n{\n\treturn (cmd >= CMD_PORT && cmd <= CMD_WAIT);\n}\n\n## Example:\n\n Input assembly code:\n0x00426710 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x00426714 | E0 0F 00 B9 | STR             W0, [SP,#0x10+cmd]\n0x00426718 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+cmd]\n0x0042671C | 1F 20 00 71 | CMP             W0, #8\n0x00426720 | CD 00 00 54 | B.LE            loc_426738\n0x00426724 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+cmd]\n0x00426728 | 1F 38 00 71 | CMP             W0, #0xE\n0x0042672C | 6C 00 00 54 | B.GT            loc_426738\n0x00426730 | 20 00 80 52 | MOV             W0, #1\n0x00426734 | 02 00 00 14 | B               loc_42673C\n0x00426738 | 00 00 80 52 | MOV             W0, #0\n0x0042673C | 00 00 00 12 | AND             W0, W0, #1\n0x00426740 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x00426744 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x00426748 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic bool cmd_noprint(int cmd)\n{\n\treturn (cmd >= CMD_FLAG_SKIP_TEST && cmd <= CMD_FLAG_CALLOUT_NOHUP);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00437478 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x0043747C | E0 0F 00 B9 | STR             W0, [SP,#0x10+status]\n0x00437480 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+status]\n0x00437484 | 1F 04 00 31 | CMN             W0, #1\n0x00437488 | 81 00 00 54 | B.NE            loc_437498\n0x0043748C | 60 08 00 F0 00 80 06 91 | ADRL            X0, aError_1; \"error\"\n0x00437494 | 09 00 00 14 | B               loc_4374B8\n0x00437498 | E1 0F 40 B9 | LDR             W1, [SP,#0x10+status]\n0x0043749C | E0 03 01 2A | MOV             W0, W1\n0x004374A0 | 00 74 1E 53 | LSL             W0, W0, #2\n0x004374A4 | 00 00 01 0B | ADD             W0, W0, W1\n0x004374A8 | 01 7C 40 93 | SXTW            X1, W0\n0x004374AC | 60 08 00 F0 00 A0 06 91 | ADRL            X0, aDown_0; \"down\"\n0x004374B4 | 20 00 00 8B | ADD             X0, X1, X0\n0x004374B8 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x004374BC | C0 03 5F D6 | RET",
        "output": "```c\nstatic const char* get_status_message(int status)\n{\n    if (status != 1)\n    {\n        return \"down\" + status * 5;\n    }\n    return \"error\";\n}\n```"
    },
    {
        "func_name": "bold",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004E9AD8 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x004E9ADC | E0 0F 00 B9 | STR             W0, [SP,#0x10+mode]\n0x004E9AE0 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+mode]\n0x004E9AE4 | 00 0C 14 12 | AND             W0, W0, #0xF000\n0x004E9AE8 | 1F 20 40 71 | CMP             W0, #8,LSL#12\n0x004E9AEC | 01 01 00 54 | B.NE            loc_4E9B0C\n0x004E9AF0 | E1 0F 40 B9 | LDR             W1, [SP,#0x10+mode]\n0x004E9AF4 | 20 09 80 52 | MOV             W0, #0x49 ; 'I'\n0x004E9AF8 | 20 00 00 0A | AND             W0, W1, W0\n0x004E9AFC | 1F 00 00 71 | CMP             W0, #0\n0x004E9B00 | 60 00 00 54 | B.EQ            loc_4E9B0C\n0x004E9B04 | 00 04 80 52 | MOV             W0, #0x20 ; ' '\n0x004E9B08 | 08 00 00 14 | B               loc_4E9B28\n0x004E9B0C | E0 0F 40 B9 | LDR             W0, [SP,#0x10+mode]\n0x004E9B10 | 00 7C 0C 53 | LSR             W0, W0, #0xC\n0x004E9B14 | 02 0C 00 12 | AND             W2, W0, #0xF\n0x004E9B18 | 80 03 00 90 | ADRP            X0, #byte_559D78@PAGE\n0x004E9B1C | 01 E0 35 91 | ADD             X1, X0, #byte_559D78@PAGEOFF\n0x004E9B20 | E0 03 02 2A | MOV             W0, W2\n0x004E9B24 | 20 68 60 38 | LDRB            W0, [X1,X0]\n0x004E9B28 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x004E9B2C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic char fgcolor(mode_t mode)\n{\n\tif (S_ISREG(mode) && (mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n\t\treturn COLOR(0xF000);\t/* File is executable ... */\n\treturn COLOR(mode);\n}\n\n## Example:\n\n Input assembly code:\n0x004E9B88 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x004E9B8C | E0 0F 00 B9 | STR             W0, [SP,#0x10+mode]\n0x004E9B90 | 40 05 00 D0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x004E9B98 | 00 08 40 B9 | LDR             W0, [X0,#(bb_common_bufsiz1+8 - 0x593290)]\n0x004E9B9C | 00 00 15 12 | AND             W0, W0, #0x800\n0x004E9BA0 | 1F 00 00 71 | CMP             W0, #0\n0x004E9BA4 | 61 00 00 54 | B.NE            loc_4E9BB0\n0x004E9BA8 | 00 00 80 52 | MOV             W0, #0\n0x004E9BAC | 21 00 00 14 | B               loc_4E9C30\n0x004E9BB0 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+mode]\n0x004E9BB4 | 00 0C 14 12 | AND             W0, W0, #0xF000\n0x004E9BB8 | 1F 10 40 71 | CMP             W0, #4,LSL#12\n0x004E9BBC | 61 00 00 54 | B.NE            loc_4E9BC8\n0x004E9BC0 | E0 05 80 52 | MOV             W0, #0x2F ; '/'\n0x004E9BC4 | 1B 00 00 14 | B               loc_4E9C30\n0x004E9BC8 | 40 05 00 D0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x004E9BD0 | 00 08 40 B9 | LDR             W0, [X0,#(bb_common_bufsiz1+8 - 0x593290)]\n0x004E9BD4 | 00 00 14 12 | AND             W0, W0, #0x1000\n0x004E9BD8 | 1F 00 00 71 | CMP             W0, #0\n0x004E9BDC | 61 00 00 54 | B.NE            loc_4E9BE8\n0x004E9BE0 | 00 00 80 52 | MOV             W0, #0\n0x004E9BE4 | 13 00 00 14 | B               loc_4E9C30\n0x004E9BE8 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+mode]\n0x004E9BEC | 00 0C 14 12 | AND             W0, W0, #0xF000\n0x004E9BF0 | 1F 20 40 71 | CMP             W0, #8,LSL#12\n0x004E9BF4 | 01 01 00 54 | B.NE            loc_4E9C14\n0x004E9BF8 | E1 0F 40 B9 | LDR             W1, [SP,#0x10+mode]\n0x004E9BFC | 20 09 80 52 | MOV             W0, #0x49 ; 'I'\n0x004E9C00 | 20 00 00 0A | AND             W0, W1, W0\n0x004E9C04 | 1F 00 00 71 | CMP             W0, #0\n0x004E9C08 | 60 00 00 54 | B.EQ            loc_4E9C14\n0x004E9C0C | 40 05 80 52 | MOV             W0, #0x2A ; '*'\n0x004E9C10 | 08 00 00 14 | B               loc_4E9C30\n0x004E9C14 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+mode]\n0x004E9C18 | 00 7C 0C 53 | LSR             W0, W0, #0xC\n0x004E9C1C | 02 0C 00 12 | AND             W2, W0, #0xF\n0x004E9C20 | 80 03 00 90 | ADRP            X0, #byte_559DA8@PAGE\n0x004E9C24 | 01 A0 36 91 | ADD             X1, X0, #byte_559DA8@PAGEOFF\n0x004E9C28 | E0 03 02 2A | MOV             W0, W2\n0x004E9C2C | 20 68 60 38 | LDRB            W0, [X1,X0]\n0x004E9C30 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x004E9C34 | C0 03 5F D6 | RET\n\n Output decompiled code:\nif ENABLE_FEATURE_LS_FILETYPES\nstatic char append_char(mode_t mode)\n{\n\tif (!(G.all_fmt & LIST_FILETYPE))\n\t\treturn '\\0';\n\tif (S_ISDIR(mode))\n\t\treturn '/';\n\tif (!(G.all_fmt & LIST_CLASSIFY))\n\t\treturn '\\0';\n\tif (S_ISREG(mode) && (mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n\t\treturn '*';\n\treturn APPCHAR(mode);\n}\n\n## Example:\n\n Input assembly code:\n0x004E262C | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x004E2630 | E0 0F 00 B9 | STR             W0, [SP,#0x10+yr]\n0x004E2634 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+yr]\n0x004E2638 | 1F 60 1B 71 | CMP             W0, #0x6D8\n0x004E263C | E8 00 00 54 | B.HI            loc_4E2658\n0x004E2640 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+yr]\n0x004E2644 | 00 04 00 12 | AND             W0, W0, #3\n0x004E2648 | 1F 00 00 71 | CMP             W0, #0\n0x004E264C | E0 17 9F 1A | CSET            W0, EQ\n0x004E2650 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x004E2654 | 1E 00 00 14 | B               loc_4E26CC\n0x004E2658 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+yr]\n0x004E265C | 00 04 00 12 | AND             W0, W0, #3\n0x004E2660 | 1F 00 00 71 | CMP             W0, #0\n0x004E2664 | 81 01 00 54 | B.NE            loc_4E2694\n0x004E2668 | E1 0F 40 B9 | LDR             W1, [SP,#0x10+yr]\n0x004E266C | E0 A3 90 52 60 3D AA 72 | MOV             W0, #0x51EB851F\n0x004E2674 | 20 7C A0 9B | UMULL           X0, W1, W0\n0x004E2678 | 00 FC 60 D3 | LSR             X0, X0, #0x20 ; ' '\n0x004E267C | 00 7C 05 53 | LSR             W0, W0, #5\n0x004E2680 | 82 0C 80 52 | MOV             W2, #0x64 ; 'd'\n0x004E2684 | 00 7C 02 1B | MUL             W0, W0, W2\n0x004E2688 | 20 00 00 4B | SUB             W0, W1, W0\n0x004E268C | 1F 00 00 71 | CMP             W0, #0\n0x004E2690 | 81 01 00 54 | B.NE            loc_4E26C0\n0x004E2694 | E1 0F 40 B9 | LDR             W1, [SP,#0x10+yr]\n0x004E2698 | E0 A3 90 52 60 3D AA 72 | MOV             W0, #0x51EB851F\n0x004E26A0 | 20 7C A0 9B | UMULL           X0, W1, W0\n0x004E26A4 | 00 FC 60 D3 | LSR             X0, X0, #0x20 ; ' '\n0x004E26A8 | 00 7C 07 53 | LSR             W0, W0, #7\n0x004E26AC | 02 32 80 52 | MOV             W2, #0x190\n0x004E26B0 | 00 7C 02 1B | MUL             W0, W0, W2\n0x004E26B4 | 20 00 00 4B | SUB             W0, W1, W0\n0x004E26B8 | 1F 00 00 71 | CMP             W0, #0\n0x004E26BC | 61 00 00 54 | B.NE            loc_4E26C8\n0x004E26C0 | 20 00 80 52 | MOV             W0, #1\n0x004E26C4 | 02 00 00 14 | B               loc_4E26CC\n0x004E26C8 | 00 00 80 52 | MOV             W0, #0\n0x004E26CC | FF 43 00 91 | ADD             SP, SP, #0x10\n0x004E26D0 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int leap_year(unsigned yr)\n{\n\tif (yr <= 1752)\n\t\treturn !(yr % 4);\n\treturn (!(yr % 4) && (yr % 100)) || !(yr % 400);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004E9B30 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x004E9B34 | E0 0F 00 B9 | STR             W0, [SP,#0x10+mode]\n0x004E9B38 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+mode]\n0x004E9B3C | 00 0C 14 12 | AND             W0, W0, #0xF000\n0x004E9B40 | 1F 20 40 71 | CMP             W0, #8,LSL#12\n0x004E9B44 | 01 01 00 54 | B.NE            loc_4E9B64\n0x004E9B48 | E1 0F 40 B9 | LDR             W1, [SP,#0x10+mode]\n0x004E9B4C | 20 09 80 52 | MOV             W0, #0x49 ; 'I'\n0x004E9B50 | 20 00 00 0A | AND             W0, W1, W0\n0x004E9B54 | 1F 00 00 71 | CMP             W0, #0\n0x004E9B58 | 60 00 00 54 | B.EQ            loc_4E9B64\n0x004E9B5C | 20 00 80 52 | MOV             W0, #1\n0x004E9B60 | 08 00 00 14 | B               loc_4E9B80\n0x004E9B64 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+mode]\n0x004E9B68 | 00 7C 0C 53 | LSR             W0, W0, #0xC\n0x004E9B6C | 02 0C 00 12 | AND             W2, W0, #0xF\n0x004E9B70 | 80 03 00 90 | ADRP            X0, #byte_559D90@PAGE\n0x004E9B74 | 01 40 36 91 | ADD             X1, X0, #byte_559D90@PAGEOFF\n0x004E9B78 | E0 03 02 2A | MOV             W0, W2\n0x004E9B7C | 20 68 60 38 | LDRB            W0, [X1,X0]\n0x004E9B80 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x004E9B84 | C0 03 5F D6 | RET",
        "output": "```c\nstatic int is_executable(mode_t mode)\n{\n    if ((mode & S_IFMT) == S_IFREG && (mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n        return 1;\n    return COLOR(mode);\n}\n```"
    },
    {
        "func_name": "ststrdup",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0040A97C | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0040A980 | FD 03 00 91 | MOV             X29, SP\n0x0040A984 | E0 0F 00 F9 | STR             X0, [SP,#0x30+size]\n0x0040A988 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+size]; size\n0x0040A98C | D6 FF FF 97 | BL              xmalloc\n0x0040A990 | E0 17 00 F9 | STR             X0, [SP,#0x30+ptr]\n0x0040A994 | E2 0F 40 F9 | LDR             X2, [SP,#0x30+size]; n\n0x0040A998 | 01 00 80 52 | MOV             W1, #0; c\n0x0040A99C | E0 17 40 F9 | LDR             X0, [SP,#0x30+ptr]; s\n0x0040A9A0 | 5C F1 FF 97 | BL              .memset\n0x0040A9A4 | E0 17 40 F9 | LDR             X0, [SP,#0x30+ptr]\n0x0040A9A8 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0040A9AC | C0 03 5F D6 | RET\n\n Output decompiled code:\nFAST_FUNC xzalloc(size_t size)\n{\n\tvoid *ptr = xmalloc(size);\n\tmemset(ptr, 0, size);\n\treturn ptr;\n}\n\n## Example:\n\n Input assembly code:\n0x0040B0F4 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0040B0F8 | FD 03 00 91 | MOV             X29, SP\n0x0040B0FC | E0 0F 00 F9 | STR             X0, [SP,#0x30+var]\n0x0040B100 | A1 07 80 52 | MOV             W1, #0x3D ; '='; c\n0x0040B104 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+var]; s\n0x0040B108 | 5A F1 FF 97 | BL              .strchr\n0x0040B10C | E0 17 00 F9 | STR             X0, [SP,#0x30+tp]\n0x0040B110 | E0 17 40 F9 | LDR             X0, [SP,#0x30+tp]\n0x0040B114 | 1F 00 00 F1 | CMP             X0, #0\n0x0040B118 | 81 00 00 54 | B.NE            loc_40B128\n0x0040B11C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+var]; name\n0x0040B120 | CC F1 FF 97 | BL              .unsetenv\n0x0040B124 | 0C 00 00 14 | B               loc_40B154\n0x0040B128 | E1 17 40 F9 | LDR             X1, [SP,#0x30+tp]\n0x0040B12C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+var]\n0x0040B130 | 20 00 00 CB | SUB             X0, X1, X0\n0x0040B134 | E1 03 00 2A | MOV             W1, W0; n\n0x0040B138 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+var]; s\n0x0040B13C | 31 FE FF 97 | BL              xstrndup\n0x0040B140 | E0 17 00 F9 | STR             X0, [SP,#0x30+tp]\n0x0040B144 | E0 17 40 F9 | LDR             X0, [SP,#0x30+tp]; name\n0x0040B148 | C2 F1 FF 97 | BL              .unsetenv\n0x0040B14C | E0 17 40 F9 | LDR             X0, [SP,#0x30+tp]; ptr\n0x0040B150 | E4 F0 FF 97 | BL              .free\n0x0040B154 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0040B158 | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid FAST_FUNC bb_unsetenv(const char *var)\n{\n\tchar *tp = strchr(var, '=');\n\n\tif (!tp) {\n\t\tunsetenv(var);\n\t\treturn;\n\t}\n\n\t/* In case var was putenv'ed, we can't replace '='\n\t * with NUL and unsetenv(var) - it won't work,\n\t * env is modified by the replacement, unsetenv\n\t * sees \"VAR\" instead of \"VAR=VAL\" and does not remove it!\n\t * horror :( */\n\ttp = xstrndup(var, tp - var);\n\tunsetenv(tp);\n\tfree(tp);\n}\n\n## Example:\n\n Input assembly code:\n0x0043F984 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0043F988 | FD 03 00 91 | MOV             X29, SP\n0x0043F98C | E0 0F 00 F9 | STR             X0, [SP,#0x20+ip_func]\n0x0043F990 | E1 0B 00 F9 | STR             X1, [SP,#0x20+argv]\n0x0043F994 | E0 0B 40 F9 | LDR             X0, [SP,#0x20+argv]\n0x0043F998 | 00 20 00 91 | ADD             X0, X0, #8; argv\n0x0043F99C | D0 4E 00 94 | BL              ip_parse_common_args\n0x0043F9A0 | E0 0B 00 F9 | STR             X0, [SP,#0x20+argv]\n0x0043F9A4 | E1 0F 40 F9 | LDR             X1, [SP,#0x20+ip_func]\n0x0043F9A8 | E0 0B 40 F9 | LDR             X0, [SP,#0x20+argv]\n0x0043F9AC | 20 00 3F D6 | BLR             X1\n0x0043F9B0 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0043F9B4 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int ip_do(ip_func_ptr_t ip_func, char **argv)\n{\n\targv = ip_parse_common_args(argv + 1);\n\treturn ip_func(argv);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0047D2F8 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0047D2FC | FD 03 00 91 | MOV             X29, SP\n0x0047D300 | E0 0F 00 F9 | STR             X0, [SP,#0x30+p]\n0x0047D304 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+p]; s\n0x0047D308 | 12 25 FE 97 | BL              .strlen\n0x0047D30C | 00 04 00 91 | ADD             X0, X0, #1\n0x0047D310 | E0 17 00 F9 | STR             X0, [SP,#0x30+len]\n0x0047D314 | E0 17 40 F9 | LDR             X0, [SP,#0x30+len]; nbytes\n0x0047D318 | 6F FF FF 97 | BL              stalloc\n0x0047D31C | E2 17 40 F9 | LDR             X2, [SP,#0x30+len]; n\n0x0047D320 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+p]; src\n0x0047D324 | CB 24 FE 97 | BL              .memcpy\n0x0047D328 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0047D32C | C0 03 5F D6 | RET",
        "output": "```c\nchar *FAST_FUNC stpcpy(char *p, const char *s)\n{\n\tsize_t len = strlen(s) + 1;\n\tchar *dest = stalloc(len);\n\treturn memcpy(dest, s, len);\n}\n```"
    },
    {
        "func_name": "o_addstr_with_NUL",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00494364 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00494368 | FD 03 00 91 | MOV             X29, SP\n0x0049436C | E0 0F 00 F9 | STR             X0, [SP,#0x20+o]\n0x00494370 | E1 0B 00 F9 | STR             X1, [SP,#0x20+str]\n0x00494374 | E0 0B 40 F9 | LDR             X0, [SP,#0x20+str]; s\n0x00494378 | F6 C8 FD 97 | BL              .strlen\n0x0049437C | E2 03 00 2A | MOV             W2, W0; len\n0x00494380 | E1 0B 40 F9 | LDR             X1, [SP,#0x20+str]; str\n0x00494384 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]; o\n0x00494388 | D5 FF FF 97 | BL              o_addblock\n0x0049438C | 1F 20 03 D5 | NOP\n0x00494390 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00494394 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void o_addstr(o_string *o, const char *str)\n{\n\to_addblock(o, str, strlen(str));\n}\n\n## Example:\n\n Input assembly code:\n0x0049476C | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00494770 | FD 03 00 91 | MOV             X29, SP\n0x00494774 | E0 0F 00 F9 | STR             X0, [SP,#0x20+o]\n0x00494778 | E1 0B 00 F9 | STR             X1, [SP,#0x20+str]\n0x0049477C | E0 0B 40 F9 | LDR             X0, [SP,#0x20+str]; s\n0x00494780 | F4 C7 FD 97 | BL              .strlen\n0x00494784 | E2 03 00 2A | MOV             W2, W0; len\n0x00494788 | E1 0B 40 F9 | LDR             X1, [SP,#0x20+str]; str\n0x0049478C | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]; o\n0x00494790 | E2 FF FF 97 | BL              o_addQblock\n0x00494794 | 1F 20 03 D5 | NOP\n0x00494798 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0049479C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void o_addQstr(o_string *o, const char *str)\n{\n\to_addQblock(o, str, strlen(str));\n}\n\n## Example:\n\n Input assembly code:\n0x00473E50 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00473E54 | FD 03 00 91 | MOV             X29, SP\n0x00473E58 | E0 0F 00 F9 | STR             X0, [SP,#0x20+ul]\n0x00473E5C | E1 0B 00 F9 | STR             X1, [SP,#0x20+buf]\n0x00473E60 | C0 06 00 F0 | ADRP            X0, #aMgtpezy_0@PAGE; \" mgtpezy\"\n0x00473E64 | 02 C0 0C 91 | ADD             X2, X0, #aMgtpezy_0@PAGEOFF; \" mgtpezy\"\n0x00473E68 | E1 0B 40 F9 | LDR             X1, [SP,#0x20+buf]; buf\n0x00473E6C | E0 0F 40 F9 | LDR             X0, [SP,#0x20+ul]; ul\n0x00473E70 | F6 BE 02 94 | BL              smart_ulltoa5\n0x00473E74 | E0 0B 40 F9 | LDR             X0, [SP,#0x20+buf]\n0x00473E78 | 00 14 00 91 | ADD             X0, X0, #5\n0x00473E7C | 01 04 80 52 | MOV             W1, #0x20 ; ' '\n0x00473E80 | 01 00 00 39 | STRB            W1, [X0]\n0x00473E84 | 1F 20 03 D5 | NOP\n0x00473E88 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00473E8C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void ulltoa6_and_space(unsigned long long ul, char buf[6])\n{\n\t/* see http://en.wikipedia.org/wiki/Tera */\n\tsmart_ulltoa5(ul, buf, \" mgtpezy\");\n\tbuf[5] = ' ';\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00494398 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0049439C | FD 03 00 91 | MOV             X29, SP\n0x004943A0 | E0 0F 00 F9 | STR             X0, [SP,#0x20+o]\n0x004943A4 | E1 0B 00 F9 | STR             X1, [SP,#0x20+str]\n0x004943A8 | E0 0B 40 F9 | LDR             X0, [SP,#0x20+str]; s\n0x004943AC | E9 C8 FD 97 | BL              .strlen\n0x004943B0 | 00 04 00 11 | ADD             W0, W0, #1\n0x004943B4 | E2 03 00 2A | MOV             W2, W0; len\n0x004943B8 | E1 0B 40 F9 | LDR             X1, [SP,#0x20+str]; str\n0x004943BC | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]; o\n0x004943C0 | C7 FF FF 97 | BL              o_addblock\n0x004943C4 | 1F 20 03 D5 | NOP\n0x004943C8 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004943CC | C0 03 5F D6 | RET",
        "output": "```c\nstatic void o_addstr_with_null(o_string *o, const char *str)\n{\n\to_addblock(o, str, strlen(str) + 1);\n}\n```"
    },
    {
        "func_name": "xzalloc_lsa",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004DB868 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004DB86C | FD 03 00 91 | MOV             X29, SP\n0x004DB870 | E0 1F 00 B9 | STR             W0, [SP,#0x30+mode]\n0x004DB874 | E1 1B 00 B9 | STR             W1, [SP,#0x30+dict_max]\n0x004DB878 | 00 EA 8D D2 | MOV             X0, #0x6F50; size\n0x004DB87C | 5D AD FC 97 | BL              .malloc\n0x004DB880 | E0 17 00 F9 | STR             X0, [SP,#0x30+s]\n0x004DB884 | E0 17 40 F9 | LDR             X0, [SP,#0x30+s]\n0x004DB888 | 1F 00 00 F1 | CMP             X0, #0\n0x004DB88C | 61 00 00 54 | B.NE            loc_4DB898\n0x004DB890 | 00 00 80 D2 | MOV             X0, #0\n0x004DB894 | 0F 00 00 14 | B               loc_4DB8D0\n0x004DB898 | E0 17 40 F9 | LDR             X0, [SP,#0x30+s]\n0x004DB89C | E1 1F 40 B9 | LDR             W1, [SP,#0x30+mode]\n0x004DB8A0 | 01 64 00 B9 | STR             W1, [X0,#0x64]\n0x004DB8A4 | E0 17 40 F9 | LDR             X0, [SP,#0x30+s]\n0x004DB8A8 | E1 1B 40 B9 | LDR             W1, [SP,#0x30+dict_max]\n0x004DB8AC | 01 5C 00 B9 | STR             W1, [X0,#0x5C]\n0x004DB8B0 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+mode]\n0x004DB8B4 | 1F 08 00 71 | CMP             W0, #2\n0x004DB8B8 | A1 00 00 54 | B.NE            loc_4DB8CC\n0x004DB8BC | E0 17 40 F9 | LDR             X0, [SP,#0x30+s]\n0x004DB8C0 | 1F 14 00 F9 | STR             XZR, [X0,#0x28]\n0x004DB8C4 | E0 17 40 F9 | LDR             X0, [SP,#0x30+s]\n0x004DB8C8 | 1F 60 00 B9 | STR             WZR, [X0,#0x60]\n0x004DB8CC | E0 17 40 F9 | LDR             X0, [SP,#0x30+s]\n0x004DB8D0 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004DB8D4 | C0 03 5F D6 | RET\n\n Output decompiled code:\nXZ_FUNC xz_dec_lzma2_create(\n\t\tenum xz_mode mode, uint32_t dict_max)\n{\n\tstruct xz_dec_lzma2 *s = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (s == NULL)\n\t\treturn NULL;\n\n\ts->dict.mode = mode;\n\ts->dict.size_max = dict_max;\n\n\tif (DEC_IS_PREALLOC(mode)) {\n\t\ts->dict.buf = vmalloc(dict_max);\n\t\tif (s->dict.buf == NULL) {\n\t\t\tkfree(s);\n\t\t\treturn NULL;\n\t\t}\n\t} else if (DEC_IS_DYNALLOC(mode)) {\n\t\ts->dict.buf = NULL;\n\t\ts->dict.allocated = 0;\n\t}\n\n\treturn s;\n}\n\n## Example:\n\n Input assembly code:\n0x0045C388 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0045C38C | FD 03 00 91 | MOV             X29, SP\n0x0045C390 | E0 1F 00 B9 | STR             W0, [SP,#0x30+idx]\n0x0045C394 | E1 0B 00 F9 | STR             X1, [SP,#0x30+buf]\n0x0045C398 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+idx]\n0x0045C39C | 1F 00 00 71 | CMP             W0, #0\n0x0045C3A0 | 81 00 00 54 | B.NE            loc_45C3B0\n0x0045C3A4 | 60 07 00 F0 00 E0 05 91 | ADRL            X0, asc_54B178; \"*\"\n0x0045C3AC | 11 00 00 14 | B               loc_45C3F0\n0x0045C3B0 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+idx]; idx\n0x0045C3B4 | 43 FF FF 97 | BL              find_by_index\n0x0045C3B8 | E0 17 00 F9 | STR             X0, [SP,#0x30+im]\n0x0045C3BC | E0 17 40 F9 | LDR             X0, [SP,#0x30+im]\n0x0045C3C0 | 1F 00 00 F1 | CMP             X0, #0\n0x0045C3C4 | 80 00 00 54 | B.EQ            loc_45C3D4\n0x0045C3C8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+im]\n0x0045C3CC | 00 80 00 91 | ADD             X0, X0, #0x20 ; ' '\n0x0045C3D0 | 08 00 00 14 | B               loc_45C3F0\n0x0045C3D4 | E3 1F 40 B9 | LDR             W3, [SP,#0x30+idx]\n0x0045C3D8 | 60 07 00 F0 | ADRP            X0, #aIfD@PAGE; \"if%d\"\n0x0045C3DC | 02 00 06 91 | ADD             X2, X0, #aIfD@PAGEOFF; \"if%d\"\n0x0045C3E0 | 01 02 80 D2 | MOV             X1, #0x10; maxlen\n0x0045C3E4 | E0 0B 40 F9 | LDR             X0, [SP,#0x30+buf]; s\n0x0045C3E8 | 22 AA FE 97 | BL              .snprintf\n0x0045C3EC | E0 0B 40 F9 | LDR             X0, [SP,#0x30+buf]\n0x0045C3F0 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0045C3F4 | C0 03 5F D6 | RET\n\n Output decompiled code:\nconst char FAST_FUNC *ll_idx_n2a(int idx, char *buf)\n{\n\tstruct idxmap *im;\n\n\tif (idx == 0)\n\t\treturn \"*\";\n\tim = find_by_index(idx);\n\tif (im)\n\t\treturn im->name;\n\tsnprintf(buf, 16, \"if%d\", idx);\n\treturn buf;\n}\n\n## Example:\n\n Input assembly code:\n0x00418F38 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00418F3C | FD 03 00 91 | MOV             X29, SP\n0x00418F40 | E0 1F 00 B9 | STR             W0, [SP,#0x30+flags]\n0x00418F44 | E1 0B 00 F9 | STR             X1, [SP,#0x30+dev]\n0x00418F48 | 20 61 8A 52 | MOV             W0, #0x5309\n0x00418F4C | E0 2F 00 B9 | STR             W0, [SP,#0x30+cmd]\n0x00418F50 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+flags]\n0x00418F54 | 00 00 00 12 | AND             W0, W0, #1\n0x00418F58 | 1F 00 00 71 | CMP             W0, #0\n0x00418F5C | 41 01 00 54 | B.NE            loc_418F84\n0x00418F60 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+flags]\n0x00418F64 | 00 00 1F 12 | AND             W0, W0, #2\n0x00418F68 | 1F 00 00 71 | CMP             W0, #0\n0x00418F6C | 00 01 00 54 | B.EQ            loc_418F8C\n0x00418F70 | C1 64 8A D2 | MOV             X1, #0x5326; request\n0x00418F74 | 60 00 80 52 | MOV             W0, #3; fd\n0x00418F78 | 86 BB FF 97 | BL              .ioctl\n0x00418F7C | 1F 08 00 71 | CMP             W0, #2\n0x00418F80 | 61 00 00 54 | B.NE            loc_418F8C\n0x00418F84 | 20 63 8A 52 | MOV             W0, #0x5319\n0x00418F88 | E0 2F 00 B9 | STR             W0, [SP,#0x30+cmd]\n0x00418F8C | E1 2F 40 B9 | LDR             W1, [SP,#0x30+cmd]; request\n0x00418F90 | E4 0B 40 F9 | LDR             X4, [SP,#0x30+dev]\n0x00418F94 | 40 09 00 90 | ADRP            X0, #aS_88@PAGE; \"%s\"\n0x00418F98 | 03 00 07 91 | ADD             X3, X0, #aS_88@PAGEOFF; \"%s\"\n0x00418F9C | 02 00 80 D2 | MOV             X2, #0; argp\n0x00418FA0 | 60 00 80 52 | MOV             W0, #3; fd\n0x00418FA4 | 42 C9 FF 97 | BL              ioctl_or_perror_and_die\n0x00418FA8 | 1F 20 03 D5 | NOP\n0x00418FAC | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00418FB0 | C0 03 5F D6 | RET\n\n Output decompiled code:\ndefine FLAG_SCSI   4\n\nstatic void eject_cdrom(unsigned flags, const char *dev)\n{\n\tint cmd = CDROMEJECT;\n\n\tif (flags & FLAG_CLOSE\n\t || ((flags & FLAG_SMART) && ioctl(dev_fd, CDROM_DRIVE_STATUS) == CDS_TRAY_OPEN)\n\t) {\n\t\tcmd = CDROMCLOSETRAY;\n\t}\n\n\tioctl_or_perror_and_die(dev_fd, cmd, NULL, \"%s\", dev);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043AC14 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0043AC18 | FD 03 00 91 | MOV             X29, SP\n0x0043AC1C | E0 1F 00 B9 | STR             W0, [SP,#0x30+family]\n0x0043AC20 | 00 02 80 52 | MOV             W0, #0x10\n0x0043AC24 | E0 2F 00 B9 | STR             W0, [SP,#0x30+sz]\n0x0043AC28 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+family]\n0x0043AC2C | 1F 04 00 71 | CMP             W0, #1\n0x0043AC30 | 61 00 00 54 | B.NE            loc_43AC3C\n0x0043AC34 | C0 0D 80 52 | MOV             W0, #0x6E ; 'n'\n0x0043AC38 | E0 2F 00 B9 | STR             W0, [SP,#0x30+sz]\n0x0043AC3C | E0 1F 40 B9 | LDR             W0, [SP,#0x30+family]\n0x0043AC40 | 1F 28 00 71 | CMP             W0, #0xA\n0x0043AC44 | 61 00 00 54 | B.NE            loc_43AC50\n0x0043AC48 | 80 03 80 52 | MOV             W0, #0x1C\n0x0043AC4C | E0 2F 00 B9 | STR             W0, [SP,#0x30+sz]\n0x0043AC50 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+sz]\n0x0043AC54 | 00 10 00 11 | ADD             W0, W0, #4\n0x0043AC58 | 00 7C 40 93 | SXTW            X0, W0; size\n0x0043AC5C | 48 3F FF 97 | BL              xzalloc\n0x0043AC60 | E0 13 00 F9 | STR             X0, [SP,#0x30+lsa]\n0x0043AC64 | E1 2F 40 B9 | LDR             W1, [SP,#0x30+sz]\n0x0043AC68 | E0 13 40 F9 | LDR             X0, [SP,#0x30+lsa]\n0x0043AC6C | 01 00 00 B9 | STR             W1, [X0]\n0x0043AC70 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+family]\n0x0043AC74 | 01 3C 00 12 | AND             W1, W0, #0xFFFF\n0x0043AC78 | E0 13 40 F9 | LDR             X0, [SP,#0x30+lsa]\n0x0043AC7C | 01 08 00 79 | STRH            W1, [X0,#4]\n0x0043AC80 | E0 13 40 F9 | LDR             X0, [SP,#0x30+lsa]\n0x0043AC84 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0043AC88 | C0 03 5F D6 | RET",
        "output": "```c\nstruct lsa_struct {\n    int sz;\n    short family;\n};\n\nstruct lsa_struct *create_lsa(int family) {\n    struct lsa_struct *lsa;\n    int sz;\n\n    if (family == AF_INET) {\n        sz = sizeof(struct sockaddr_in);\n    } else if (family == AF_INET6) {\n        sz = sizeof(struct sockaddr_in6);\n    } else {\n        sz = 16;\n    }\n\n    lsa = xzalloc(sz + sizeof(int));\n    lsa->sz = sz;\n    lsa->family = family;\n\n    return lsa;\n}\n```"
    },
    {
        "func_name": "o_addchr",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004942DC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004942E0 | FD 03 00 91 | MOV             X29, SP\n0x004942E4 | E0 17 00 F9 | STR             X0, [SP,#0x30+o]\n0x004942E8 | E1 13 00 F9 | STR             X1, [SP,#0x30+str]\n0x004942EC | E2 1F 00 B9 | STR             W2, [SP,#0x30+len]\n0x004942F0 | E1 1F 40 B9 | LDR             W1, [SP,#0x30+len]; len\n0x004942F4 | E0 17 40 F9 | LDR             X0, [SP,#0x30+o]; o\n0x004942F8 | B3 FF FF 97 | BL              o_grow_by\n0x004942FC | E0 17 40 F9 | LDR             X0, [SP,#0x30+o]\n0x00494300 | 01 00 40 F9 | LDR             X1, [X0]\n0x00494304 | E0 17 40 F9 | LDR             X0, [SP,#0x30+o]\n0x00494308 | 00 08 40 B9 | LDR             W0, [X0,#8]\n0x0049430C | 00 7C 40 93 | SXTW            X0, W0\n0x00494310 | 20 00 00 8B | ADD             X0, X1, X0; dest\n0x00494314 | E1 1F 80 B9 | LDRSW           X1, [SP,#0x30+len]\n0x00494318 | E2 03 01 AA | MOV             X2, X1; n\n0x0049431C | E1 13 40 F9 | LDR             X1, [SP,#0x30+str]; src\n0x00494320 | CC C8 FD 97 | BL              .memcpy\n0x00494324 | E0 17 40 F9 | LDR             X0, [SP,#0x30+o]\n0x00494328 | 01 08 40 B9 | LDR             W1, [X0,#8]\n0x0049432C | E0 1F 40 B9 | LDR             W0, [SP,#0x30+len]\n0x00494330 | 21 00 00 0B | ADD             W1, W1, W0\n0x00494334 | E0 17 40 F9 | LDR             X0, [SP,#0x30+o]\n0x00494338 | 01 08 00 B9 | STR             W1, [X0,#8]\n0x0049433C | E0 17 40 F9 | LDR             X0, [SP,#0x30+o]\n0x00494340 | 01 00 40 F9 | LDR             X1, [X0]\n0x00494344 | E0 17 40 F9 | LDR             X0, [SP,#0x30+o]\n0x00494348 | 00 08 40 B9 | LDR             W0, [X0,#8]\n0x0049434C | 00 7C 40 93 | SXTW            X0, W0\n0x00494350 | 20 00 00 8B | ADD             X0, X1, X0\n0x00494354 | 1F 00 00 39 | STRB            WZR, [X0]\n0x00494358 | 1F 20 03 D5 | NOP\n0x0049435C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00494360 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void o_addblock(o_string *o, const char *str, int len)\n{\n\to_grow_by(o, len);\n\tmemcpy(&o->data[o->length], str, len);\n\to->length += len;\n\to->data[o->length] = '\\0';\n}\n\n## Example:\n\n Input assembly code:\n0x0046FED4 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0046FED8 | FD 03 00 91 | MOV             X29, SP\n0x0046FEDC | E0 17 00 F9 | STR             X0, [SP,#0x30+buf]\n0x0046FEE0 | E1 27 00 B9 | STR             W1, [SP,#0x30+size]\n0x0046FEE4 | E2 0F 00 F9 | STR             X2, [SP,#0x30+ps]\n0x0046FEE8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+buf]\n0x0046FEEC | E1 07 80 52 | MOV             W1, #0x3F ; '?'\n0x0046FEF0 | 01 00 00 39 | STRB            W1, [X0]\n0x0046FEF4 | E0 17 40 F9 | LDR             X0, [SP,#0x30+buf]\n0x0046FEF8 | 00 04 00 91 | ADD             X0, X0, #1\n0x0046FEFC | 1F 00 00 39 | STRB            WZR, [X0]\n0x0046FF00 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+ps]\n0x0046FF04 | 00 7C 40 B9 | LDR             W0, [X0,#0x7C]\n0x0046FF08 | 1F 00 00 71 | CMP             W0, #0\n0x0046FF0C | C0 01 00 54 | B.EQ            loc_46FF44\n0x0046FF10 | E0 27 40 B9 | LDR             W0, [SP,#0x30+size]\n0x0046FF14 | 00 04 00 11 | ADD             W0, W0, #1\n0x0046FF18 | 01 7C 40 93 | SXTW            X1, W0; maxlen\n0x0046FF1C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+ps]\n0x0046FF20 | 02 7C 40 B9 | LDR             W2, [X0,#0x7C]\n0x0046FF24 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+ps]\n0x0046FF28 | 00 80 40 B9 | LDR             W0, [X0,#0x80]\n0x0046FF2C | E4 03 00 2A | MOV             W4, W0\n0x0046FF30 | E3 03 02 2A | MOV             W3, W2\n0x0046FF34 | E0 06 00 D0 | ADRP            X0, #aUU_3@PAGE; \"%u,%u\"\n0x0046FF38 | 02 80 2C 91 | ADD             X2, X0, #aUU_3@PAGEOFF; \"%u,%u\"\n0x0046FF3C | E0 17 40 F9 | LDR             X0, [SP,#0x30+buf]; s\n0x0046FF40 | 4C 5B FE 97 | BL              .snprintf\n0x0046FF44 | 1F 20 03 D5 | NOP\n0x0046FF48 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0046FF4C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void func_tty(char *buf, int size, const procps_status_t *ps)\n{\n\tbuf[0] = '?';\n\tbuf[1] = '\\0';\n\tif (ps->tty_major) /* tty field of \"0\" means \"no tty\" */\n\t\tsnprintf(buf, size+1, \"%u,%u\", ps->tty_major, ps->tty_minor);\n}\n\n## Example:\n\n Input assembly code:\n0x00487EA8 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00487EAC | FD 03 00 91 | MOV             X29, SP\n0x00487EB0 | E0 0F 00 F9 | STR             X0, [SP,#0x30+name]\n0x00487EB4 | E1 0B 00 F9 | STR             X1, [SP,#0x30+entry]\n0x00487EB8 | 21 00 80 52 | MOV             W1, #1; add\n0x00487EBC | E0 0F 40 F9 | LDR             X0, [SP,#0x30+name]; name\n0x00487EC0 | 7A FF FF 97 | BL              cmdlookup\n0x00487EC4 | E0 17 00 F9 | STR             X0, [SP,#0x30+cmdp]\n0x00487EC8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cmdp]\n0x00487ECC | 00 10 40 B9 | LDR             W0, [X0,#0x10]\n0x00487ED0 | 1F 04 00 71 | CMP             W0, #1\n0x00487ED4 | 81 00 00 54 | B.NE            loc_487EE4\n0x00487ED8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cmdp]\n0x00487EDC | 00 04 40 F9 | LDR             X0, [X0,#8]; f\n0x00487EE0 | 6C D3 FF 97 | BL              freefunc\n0x00487EE4 | E0 0B 40 F9 | LDR             X0, [SP,#0x30+entry]\n0x00487EE8 | 01 00 40 B9 | LDR             W1, [X0]\n0x00487EEC | E0 17 40 F9 | LDR             X0, [SP,#0x30+cmdp]\n0x00487EF0 | 01 10 00 B9 | STR             W1, [X0,#0x10]\n0x00487EF4 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cmdp]\n0x00487EF8 | E1 0B 40 F9 | LDR             X1, [SP,#0x30+entry]\n0x00487EFC | 21 04 40 F9 | LDR             X1, [X1,#8]\n0x00487F00 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x00487F04 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cmdp]\n0x00487F08 | 1F 50 00 39 | STRB            WZR, [X0,#0x14]\n0x00487F0C | 1F 20 03 D5 | NOP\n0x00487F10 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00487F14 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void\naddcmdentry(char *name, struct cmdentry *entry)\n{\n\tstruct tblentry *cmdp;\n\n\tcmdp = cmdlookup(name, 1);\n\tif (cmdp->cmdtype == CMDFUNCTION) {\n\t\tfreefunc(cmdp->param.func);\n\t}\n\tcmdp->cmdtype = entry->cmdtype;\n\tcmdp->param = entry->u;\n\tcmdp->rehash = 0;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00494260 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00494264 | FD 03 00 91 | MOV             X29, SP\n0x00494268 | E0 0F 00 F9 | STR             X0, [SP,#0x20+o]\n0x0049426C | E1 17 00 B9 | STR             W1, [SP,#0x20+ch]\n0x00494270 | 21 00 80 52 | MOV             W1, #1; len\n0x00494274 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]; o\n0x00494278 | D3 FF FF 97 | BL              o_grow_by\n0x0049427C | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x00494280 | 01 00 40 F9 | LDR             X1, [X0]\n0x00494284 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x00494288 | 00 08 40 B9 | LDR             W0, [X0,#8]\n0x0049428C | 00 7C 40 93 | SXTW            X0, W0\n0x00494290 | 20 00 00 8B | ADD             X0, X1, X0\n0x00494294 | E1 17 40 B9 | LDR             W1, [SP,#0x20+ch]\n0x00494298 | 21 1C 00 12 | AND             W1, W1, #0xFF\n0x0049429C | 01 00 00 39 | STRB            W1, [X0]\n0x004942A0 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x004942A4 | 00 08 40 B9 | LDR             W0, [X0,#8]\n0x004942A8 | 01 04 00 11 | ADD             W1, W0, #1\n0x004942AC | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x004942B0 | 01 08 00 B9 | STR             W1, [X0,#8]\n0x004942B4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x004942B8 | 01 00 40 F9 | LDR             X1, [X0]\n0x004942BC | E0 0F 40 F9 | LDR             X0, [SP,#0x20+o]\n0x004942C0 | 00 08 40 B9 | LDR             W0, [X0,#8]\n0x004942C4 | 00 7C 40 93 | SXTW            X0, W0\n0x004942C8 | 20 00 00 8B | ADD             X0, X1, X0\n0x004942CC | 1F 00 00 39 | STRB            WZR, [X0]\n0x004942D0 | 1F 20 03 D5 | NOP\n0x004942D4 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004942D8 | C0 03 5F D6 | RET",
        "output": "```c\nstatic void o_addchar(o_string *o, char ch)\n{\n    o_grow_by(o, 1);\n    o->data[o->length] = ch & 0xFF;\n    o->length += 1;\n    o->data[o->length] = '\\0';\n}\n```"
    },
    {
        "func_name": "do_lzo_compress",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004372A8 | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x004372AC | FD 03 00 91 | MOV             X29, SP\n0x004372B0 | E0 63 00 91 | ADD             X0, SP, #0x40+ifreq; ifreq\n0x004372B4 | 8B FF FF 97 | BL              set_ifreq_to_ifname\n0x004372B8 | 40 01 80 52 | MOV             W0, #0xA\n0x004372BC | E0 13 00 B9 | STR             W0, [SP,#0x40+edata]\n0x004372C0 | E0 43 00 91 | ADD             X0, SP, #0x40+edata\n0x004372C4 | E0 17 00 F9 | STR             X0, [SP,#0x40+ifreq.ifr_ifru]\n0x004372C8 | E1 63 00 91 | ADD             X1, SP, #0x40+ifreq; data\n0x004372CC | 60 08 00 F0 | ADRP            X0, #aEthtoolGlink@PAGE; \"ETHTOOL_GLINK\"\n0x004372D0 | 02 80 03 91 | ADD             X2, X0, #aEthtoolGlink@PAGEOFF; \"ETHTOOL_GLINK\"\n0x004372D4 | C0 28 91 52 | MOV             W0, #0x8946; request\n0x004372D8 | 94 FF FF 97 | BL              network_ioctl\n0x004372DC | 1F 00 00 71 | CMP             W0, #0\n0x004372E0 | 6A 00 00 54 | B.GE            loc_4372EC\n0x004372E4 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004372E8 | 05 00 00 14 | B               loc_4372FC\n0x004372EC | E0 17 40 B9 | LDR             W0, [SP,#0x40+edata.data]\n0x004372F0 | 1F 00 00 71 | CMP             W0, #0\n0x004372F4 | E0 07 9F 1A | CSET            W0, NE\n0x004372F8 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x004372FC | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x00437300 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic smallint detect_link_ethtool(void)\n{\n\tstruct ifreq ifreq;\n\tstruct ethtool_value edata;\n\n\tset_ifreq_to_ifname(&ifreq);\n\n\tedata.cmd = ETHTOOL_GLINK;\n\tifreq.ifr_data = (void*) &edata;\n\n\tif (network_ioctl(SIOCETHTOOL, &ifreq, \"ETHTOOL_GLINK\") < 0) {\n\t\treturn IFSTATUS_ERR;\n\t}\n\n\treturn edata.data ? IFSTATUS_UP : IFSTATUS_DOWN;\n}\n\n## Example:\n\n Input assembly code:\n0x00437390 | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x00437394 | FD 03 00 91 | MOV             X29, SP\n0x00437398 | E0 63 00 91 | ADD             X0, SP, #0x40+iwrequest; s\n0x0043739C | 02 04 80 D2 | MOV             X2, #0x20 ; ' '; n\n0x004373A0 | 01 00 80 52 | MOV             W1, #0; c\n0x004373A4 | DB 3E FF 97 | BL              .memset\n0x004373A8 | E0 0A 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004373B0 | 00 00 40 F9 | LDR             X0, [X0]\n0x004373B4 | 01 10 40 F9 | LDR             X1, [X0,#0x20]; src\n0x004373B8 | E0 63 00 91 | ADD             X0, SP, #0x40+iwrequest; dst\n0x004373BC | 37 4B FF 97 | BL              strncpy_IFNAMSIZ\n0x004373C0 | E1 63 00 91 | ADD             X1, SP, #0x40+iwrequest; data\n0x004373C4 | 60 08 00 F0 | ADRP            X0, #aSiocgiwap@PAGE; \"SIOCGIWAP\"\n0x004373C8 | 02 00 04 91 | ADD             X2, X0, #aSiocgiwap@PAGEOFF; \"SIOCGIWAP\"\n0x004373CC | A0 62 91 52 | MOV             W0, #0x8B15; request\n0x004373D0 | 56 FF FF 97 | BL              network_ioctl\n0x004373D4 | 1F 00 00 71 | CMP             W0, #0\n0x004373D8 | 6A 00 00 54 | B.GE            loc_4373E4\n0x004373DC | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004373E0 | 24 00 00 14 | B               loc_437470\n0x004373E4 | E0 43 00 91 | ADD             X0, SP, #0x40+mac\n0x004373E8 | E1 AB 00 91 | ADD             X1, SP, #0x40+iwrequest.u+2\n0x004373EC | 22 00 40 B9 | LDR             W2, [X1]\n0x004373F0 | 02 00 00 B9 | STR             W2, [X0]\n0x004373F4 | 21 20 40 B8 | LDUR            W1, [X1,#2]\n0x004373F8 | 01 20 00 B8 | STUR            W1, [X0,#2]\n0x004373FC | E0 43 40 39 | LDRB            W0, [SP,#0x40+mac]\n0x00437400 | 1F FC 03 71 | CMP             W0, #0xFF\n0x00437404 | E0 00 00 54 | B.EQ            loc_437420\n0x00437408 | E0 43 40 39 | LDRB            W0, [SP,#0x40+mac]\n0x0043740C | 1F 10 01 71 | CMP             W0, #0x44 ; 'D'\n0x00437410 | 80 00 00 54 | B.EQ            loc_437420\n0x00437414 | E0 43 40 39 | LDRB            W0, [SP,#0x40+mac]\n0x00437418 | 1F 00 00 71 | CMP             W0, #0\n0x0043741C | 81 02 00 54 | B.NE            loc_43746C\n0x00437420 | 20 00 80 52 | MOV             W0, #1\n0x00437424 | E0 3F 00 B9 | STR             W0, [SP,#0x40+i]\n0x00437428 | 0C 00 00 14 | B               loc_437458\n0x0043742C | E0 3F 80 B9 | LDRSW           X0, [SP,#0x40+i]\n0x00437430 | E1 43 00 91 | ADD             X1, SP, #0x40+mac\n0x00437434 | 21 68 60 38 | LDRB            W1, [X1,X0]\n0x00437438 | E0 43 40 39 | LDRB            W0, [SP,#0x40+mac]\n0x0043743C | 3F 00 00 6B | CMP             W1, W0\n0x00437440 | 60 00 00 54 | B.EQ            loc_43744C\n0x00437444 | 20 00 80 52 | MOV             W0, #1\n0x00437448 | 0A 00 00 14 | B               loc_437470\n0x0043744C | E0 3F 40 B9 | LDR             W0, [SP,#0x40+i]\n0x00437450 | 00 04 00 11 | ADD             W0, W0, #1\n0x00437454 | E0 3F 00 B9 | STR             W0, [SP,#0x40+i]\n0x00437458 | E0 3F 40 B9 | LDR             W0, [SP,#0x40+i]\n0x0043745C | 1F 14 00 71 | CMP             W0, #5\n0x00437460 | 6D FE FF 54 | B.LE            loc_43742C\n0x00437464 | 00 00 80 52 | MOV             W0, #0\n0x00437468 | 02 00 00 14 | B               loc_437470\n0x0043746C | 20 00 80 52 | MOV             W0, #1\n0x00437470 | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x00437474 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic smallint detect_link_wlan(void)\n{\n\tint i;\n\tstruct iwreq iwrequest;\n\tuint8_t mac[ETH_ALEN];\n\n\tmemset(&iwrequest, 0, sizeof(iwrequest));\n\tstrncpy_IFNAMSIZ(iwrequest.ifr_ifrn.ifrn_name, G.iface);\n\n\tif (network_ioctl(SIOCGIWAP, &iwrequest, \"SIOCGIWAP\") < 0) {\n\t\treturn IFSTATUS_ERR;\n\t}\n\n\tmemcpy(mac, &iwrequest.u.ap_addr.sa_data, ETH_ALEN);\n\n\tif (mac[0] == 0xFF || mac[0] == 0x44 || mac[0] == 0x00) {\n\t\tfor (i = 1; i < ETH_ALEN; ++i) {\n\t\t\tif (mac[i] != mac[0])\n\t\t\t\treturn IFSTATUS_UP;\n\t\t}\n\t\treturn IFSTATUS_DOWN;\n\t}\n\n\treturn IFSTATUS_UP;\n}\n\n## Example:\n\n Input assembly code:\n0x00524D64 | FD 7B A4 A9 | STP             X29, X30, [SP,#var_1C0]!\n0x00524D68 | FD 03 00 91 | MOV             X29, SP\n0x00524D6C | F3 0B 00 F9 | STR             X19, [SP,#0x1C0+var_1B0]\n0x00524D70 | E0 83 00 91 | ADD             X0, SP, #0x1C0+name; name\n0x00524D74 | AF 8B FB 97 | BL              .uname\n0x00524D78 | E0 83 00 91 | ADD             X0, SP, #0x1C0+name\n0x00524D7C | 00 08 02 91 | ADD             X0, X0, #0x82\n0x00524D80 | E0 DF 00 F9 | STR             X0, [SP,#0x1C0+s]\n0x00524D84 | FF B3 01 B9 | STR             WZR, [SP,#0x1C0+r]\n0x00524D88 | FF B7 01 B9 | STR             WZR, [SP,#0x1C0+i]\n0x00524D8C | 15 00 00 14 | B               loc_524DE0\n0x00524D90 | C0 01 00 F0 | ADRP            X0, #asc_55F628@PAGE; \".\"\n0x00524D94 | 01 A0 18 91 | ADD             X1, X0, #asc_55F628@PAGEOFF; \".\"\n0x00524D98 | E0 DF 40 F9 | LDR             X0, [SP,#0x1C0+s]; s\n0x00524D9C | 61 86 FB 97 | BL              .strtok\n0x00524DA0 | E0 D7 00 F9 | STR             X0, [SP,#0x1C0+t]\n0x00524DA4 | E0 B3 41 B9 | LDR             W0, [SP,#0x1C0+r]\n0x00524DA8 | 13 5C 18 53 | LSL             W19, W0, #8\n0x00524DAC | E0 D7 40 F9 | LDR             X0, [SP,#0x1C0+t]\n0x00524DB0 | 1F 00 00 F1 | CMP             X0, #0\n0x00524DB4 | 80 00 00 54 | B.EQ            loc_524DC4\n0x00524DB8 | E0 D7 40 F9 | LDR             X0, [SP,#0x1C0+t]; nptr\n0x00524DBC | F5 87 FB 97 | BL              .atoi\n0x00524DC0 | 02 00 00 14 | B               loc_524DC8\n0x00524DC4 | 00 00 80 52 | MOV             W0, #0\n0x00524DC8 | 00 00 13 0B | ADD             W0, W0, W19\n0x00524DCC | E0 B3 01 B9 | STR             W0, [SP,#0x1C0+r]\n0x00524DD0 | FF DF 00 F9 | STR             XZR, [SP,#0x1C0+s]\n0x00524DD4 | E0 B7 41 B9 | LDR             W0, [SP,#0x1C0+i]\n0x00524DD8 | 00 04 00 11 | ADD             W0, W0, #1\n0x00524DDC | E0 B7 01 B9 | STR             W0, [SP,#0x1C0+i]\n0x00524DE0 | E0 B7 41 B9 | LDR             W0, [SP,#0x1C0+i]\n0x00524DE4 | 1F 08 00 71 | CMP             W0, #2\n0x00524DE8 | 4D FD FF 54 | B.LE            loc_524D90\n0x00524DEC | E0 B3 41 B9 | LDR             W0, [SP,#0x1C0+r]\n0x00524DF0 | F3 0B 40 F9 | LDR             X19, [SP,#0x1C0+var_1B0]\n0x00524DF4 | FD 7B DC A8 | LDP             X29, X30, [SP+0x1C0+var_1C0],#0x1C0\n0x00524DF8 | C0 03 5F D6 | RET\n\n Output decompiled code:\nint FAST_FUNC get_linux_version_code(void)\n{\n\tstruct utsname name;\n\tchar *s, *t;\n\tint i, r;\n\n\tuname(&name); /* never fails */\n\ts = name.release;\n\tr = 0;\n\tfor (i = 0; i < 3; i++) {\n\t\tt = strtok(s, \".\");\n\t\tr = r * 256 + (t ? atoi(t) : 0);\n\t\ts = NULL;\n\t}\n\treturn r;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004CED74 | FD 7B AC A9 | STP             X29, X30, [SP,#var_140]!\n0x004CED78 | FD 03 00 91 | MOV             X29, SP\n0x004CED7C | E0 43 00 91 | ADD             X0, SP, #0x140+header; s\n0x004CED80 | 82 25 80 D2 | MOV             X2, #0x12C; n\n0x004CED84 | 01 00 80 52 | MOV             W1, #0; c\n0x004CED88 | 62 E0 FC 97 | BL              .memset\n0x004CED8C | E0 43 00 91 | ADD             X0, SP, #0x140+header; h\n0x004CED90 | D5 FF FF 97 | BL              lzo_set_method\n0x004CED94 | 00 02 82 52 | MOV             W0, #0x1010\n0x004CED98 | E0 13 00 B9 | STR             W0, [SP,#0x140+header]\n0x004CED9C | 00 28 81 52 | MOV             W0, #0x940\n0x004CEDA0 | E0 1B 00 B9 | STR             W0, [SP,#0x140+header.version_needed_to_extract]\n0x004CEDA4 | 00 06 84 52 | MOV             W0, #0x2030\n0x004CEDA8 | E0 17 00 B9 | STR             W0, [SP,#0x140+header.lib_version]\n0x004CEDAC | 00 60 A0 52 | MOV             W0, #0x3000000\n0x004CEDB0 | E0 1F 00 B9 | STR             W0, [SP,#0x140+header.flags]\n0x004CEDB4 | 20 06 00 F0 00 A0 10 91 | ADRL            X0, option_mask32\n0x004CEDBC | 00 00 40 B9 | LDR             W0, [X0]\n0x004CEDC0 | 00 00 11 12 | AND             W0, W0, #0x8000\n0x004CEDC4 | 1F 00 00 71 | CMP             W0, #0\n0x004CEDC8 | 80 00 00 54 | B.EQ            loc_4CEDD8\n0x004CEDCC | E0 E3 40 39 | LDRB            W0, [SP,#0x140+header.method]\n0x004CEDD0 | 1F 0C 00 71 | CMP             W0, #3\n0x004CEDD4 | A1 01 00 54 | B.NE            loc_4CEE08\n0x004CEDD8 | E0 1F 40 B9 | LDR             W0, [SP,#0x140+header.flags]\n0x004CEDDC | 00 00 00 32 | ORR             W0, W0, #1\n0x004CEDE0 | E0 1F 00 B9 | STR             W0, [SP,#0x140+header.flags]\n0x004CEDE4 | 20 06 00 F0 00 A0 10 91 | ADRL            X0, option_mask32\n0x004CEDEC | 00 00 40 B9 | LDR             W0, [X0]\n0x004CEDF0 | 00 00 12 12 | AND             W0, W0, #0x4000\n0x004CEDF4 | 1F 00 00 71 | CMP             W0, #0\n0x004CEDF8 | 80 00 00 54 | B.EQ            loc_4CEE08\n0x004CEDFC | E0 1F 40 B9 | LDR             W0, [SP,#0x140+header.flags]\n0x004CEE00 | 00 00 1F 32 | ORR             W0, W0, #2\n0x004CEE04 | E0 1F 00 B9 | STR             W0, [SP,#0x140+header.flags]\n0x004CEE08 | E0 43 00 91 | ADD             X0, SP, #0x140+header; h\n0x004CEE0C | AF FE FF 97 | BL              write_header\n0x004CEE10 | E0 43 00 91 | ADD             X0, SP, #0x140+header; h\n0x004CEE14 | C0 FC FF 97 | BL              lzo_compress\n0x004CEE18 | FD 7B D4 A8 | LDP             X29, X30, [SP+0x140+var_140],#0x140\n0x004CEE1C | C0 03 5F D6 | RET",
        "output": "```c\nvoid compress_lzo(void)\n{\n    struct lzo_header header;\n    memset(&header, 0, sizeof(header));\n    lzo_set_method(&header);\n\n    header.magic = 0x1010;\n    header.version_needed_to_extract = 0x940;\n    header.lib_version = 0x2030;\n    header.flags = 0x3000000;\n\n    if (option_mask32 & 0x8000) {\n        if (header.method != 3) {\n            header.flags |= 1;\n        }\n    }\n\n    if (option_mask32 & 0x4000) {\n        header.flags |= 2;\n    }\n\n    write_header(&header);\n    lzo_compress(&header);\n}\n```"
    },
    {
        "func_name": "addfname",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004E7410 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004E7414 | FD 03 00 91 | MOV             X29, SP\n0x004E7418 | E0 0F 00 F9 | STR             X0, [SP,#0x30+s]\n0x004E741C | 00 02 80 D2 | MOV             X0, #0x10; size\n0x004E7420 | 57 8D FC 97 | BL              xzalloc\n0x004E7424 | E0 17 00 F9 | STR             X0, [SP,#0x30+v]\n0x004E7428 | E0 17 40 F9 | LDR             X0, [SP,#0x30+v]\n0x004E742C | 21 00 80 52 | MOV             W1, #1\n0x004E7430 | 01 00 00 B9 | STR             W1, [X0]\n0x004E7434 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+s]; s\n0x004E7438 | 5E 8D FC 97 | BL              xstrdup\n0x004E743C | E1 03 00 AA | MOV             X1, X0\n0x004E7440 | E0 17 40 F9 | LDR             X0, [SP,#0x30+v]\n0x004E7444 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x004E7448 | E0 17 40 F9 | LDR             X0, [SP,#0x30+v]\n0x004E744C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004E7450 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic VALUE *str_value(const char *s)\n{\n\tVALUE *v;\n\n\tv = xzalloc(sizeof(VALUE));\n\tif (STRING) /* otherwise xzaaloc did it already */\n\t\tv->type = STRING;\n\tv->u.s = xstrdup(s);\n\treturn v;\n}\n\n## Example:\n\n Input assembly code:\n0x00409424 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00409428 | FD 03 00 91 | MOV             X29, SP\n0x0040942C | E0 0F 00 F9 | STR             X0, [SP,#0x30+old_head]\n0x00409430 | E1 0B 00 F9 | STR             X1, [SP,#0x30+data]\n0x00409434 | 00 02 80 D2 | MOV             X0, #0x10; size\n0x00409438 | 2B 05 00 94 | BL              xmalloc\n0x0040943C | E0 17 00 F9 | STR             X0, [SP,#0x30+new_head]\n0x00409440 | E0 17 40 F9 | LDR             X0, [SP,#0x30+new_head]\n0x00409444 | E1 0B 40 F9 | LDR             X1, [SP,#0x30+data]\n0x00409448 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x0040944C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+old_head]\n0x00409450 | 01 00 40 F9 | LDR             X1, [X0]\n0x00409454 | E0 17 40 F9 | LDR             X0, [SP,#0x30+new_head]\n0x00409458 | 01 00 00 F9 | STR             X1, [X0]\n0x0040945C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+old_head]\n0x00409460 | E1 17 40 F9 | LDR             X1, [SP,#0x30+new_head]\n0x00409464 | 01 00 00 F9 | STR             X1, [X0]\n0x00409468 | 1F 20 03 D5 | NOP\n0x0040946C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00409470 | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid FAST_FUNC llist_add_to(llist_t **old_head, void *data)\n{\n\tllist_t *new_head = xmalloc(sizeof(llist_t));\n\n\tnew_head->data = data;\n\tnew_head->link = *old_head;\n\t*old_head = new_head;\n}\n\n## Example:\n\n Input assembly code:\n0x0047F980 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0047F984 | FD 03 00 91 | MOV             X29, SP\n0x0047F988 | E0 0F 00 F9 | STR             X0, [SP,#0x30+name]\n0x0047F98C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+name]; name\n0x0047F990 | 4C FF FF 97 | BL              __lookupalias\n0x0047F994 | E0 17 00 F9 | STR             X0, [SP,#0x30+app]\n0x0047F998 | E0 17 40 F9 | LDR             X0, [SP,#0x30+app]\n0x0047F99C | 00 00 40 F9 | LDR             X0, [X0]\n0x0047F9A0 | 1F 00 00 F1 | CMP             X0, #0\n0x0047F9A4 | 00 02 00 54 | B.EQ            loc_47F9E4\n0x0047F9A8 | A0 08 00 D0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x0047F9B0 | 00 00 40 F9 | LDR             X0, [X0]\n0x0047F9B4 | 01 30 40 B9 | LDR             W1, [X0,#0x30]\n0x0047F9B8 | 21 04 00 11 | ADD             W1, W1, #1\n0x0047F9BC | 01 30 00 B9 | STR             W1, [X0,#0x30]\n0x0047F9C0 | E0 17 40 F9 | LDR             X0, [SP,#0x30+app]\n0x0047F9C4 | 00 00 40 F9 | LDR             X0, [X0]; ap\n0x0047F9C8 | 97 FF FF 97 | BL              freealias\n0x0047F9CC | E1 03 00 AA | MOV             X1, X0\n0x0047F9D0 | E0 17 40 F9 | LDR             X0, [SP,#0x30+app]\n0x0047F9D4 | 01 00 00 F9 | STR             X1, [X0]\n0x0047F9D8 | DC F3 FF 97 | BL              int_on\n0x0047F9DC | 00 00 80 52 | MOV             W0, #0\n0x0047F9E0 | 02 00 00 14 | B               loc_47F9E8\n0x0047F9E4 | 20 00 80 52 | MOV             W0, #1\n0x0047F9E8 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0047F9EC | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int\nunalias(const char *name)\n{\n\tstruct alias **app;\n\n\tapp = __lookupalias(name);\n\n\tif (*app) {\n\t\tINT_OFF;\n\t\t*app = freealias(*app);\n\t\tINT_ON;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00486B88 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00486B8C | FD 03 00 91 | MOV             X29, SP\n0x00486B90 | E0 0F 00 F9 | STR             X0, [SP,#0x30+name]\n0x00486B94 | 00 02 80 D2 | MOV             X0, #0x10; nbytes\n0x00486B98 | B4 D9 FF 97 | BL              stzalloc\n0x00486B9C | E0 17 00 F9 | STR             X0, [SP,#0x30+sp]\n0x00486BA0 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+name]; p\n0x00486BA4 | D5 D9 FF 97 | BL              ststrdup\n0x00486BA8 | E1 03 00 AA | MOV             X1, X0\n0x00486BAC | E0 17 40 F9 | LDR             X0, [SP,#0x30+sp]\n0x00486BB0 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x00486BB4 | 60 08 00 B0 00 A0 01 91 | ADRL            X0, exparg\n0x00486BBC | 00 04 40 F9 | LDR             X0, [X0,#(exparg.lastp - 0x593068)]\n0x00486BC0 | E1 17 40 F9 | LDR             X1, [SP,#0x30+sp]\n0x00486BC4 | 01 00 00 F9 | STR             X1, [X0]\n0x00486BC8 | E1 17 40 F9 | LDR             X1, [SP,#0x30+sp]\n0x00486BCC | 60 08 00 B0 00 A0 01 91 | ADRL            X0, exparg\n0x00486BD4 | 01 04 00 F9 | STR             X1, [X0,#(exparg.lastp - 0x593068)]\n0x00486BD8 | 1F 20 03 D5 | NOP\n0x00486BDC | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00486BE0 | C0 03 5F D6 | RET",
        "output": "```c\nstatic void *stzalloc_and_strdup(const char *name)\n{\n\tvoid *sp;\n\n\tsp = stzalloc(0x10);\n\t*(char **)(sp + 8) = ststrdup(name);\n\texparg.lastp = sp;\n\treturn sp;\n}\n```"
    },
    {
        "func_name": "get_nport",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0041FAC4 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x0041FAC8 | E0 07 00 F9 | STR             X0, [SP,#0x10+ut]\n0x0041FACC | E0 07 40 F9 | LDR             X0, [SP,#0x10+ut]\n0x0041FAD0 | 00 04 40 B9 | LDR             W0, [X0,#4]\n0x0041FAD4 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x0041FAD8 | 1F C0 00 71 | CMP             W0, #0x30 ; '0'\n0x0041FADC | C0 00 00 54 | B.EQ            loc_41FAF4\n0x0041FAE0 | E0 07 40 F9 | LDR             X0, [SP,#0x10+ut]\n0x0041FAE4 | 00 04 40 B9 | LDR             W0, [X0,#4]\n0x0041FAE8 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x0041FAEC | 1F D8 00 71 | CMP             W0, #0x36 ; '6'\n0x0041FAF0 | 61 00 00 54 | B.NE            loc_41FAFC\n0x0041FAF4 | 20 00 80 52 | MOV             W0, #1\n0x0041FAF8 | 02 00 00 14 | B               loc_41FB00\n0x0041FAFC | 00 00 80 52 | MOV             W0, #0\n0x0041FB00 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x0041FB04 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int is_runlevel_shutdown(struct utmp *ut)\n{\n\tif (((ut->ut_pid & 255) == '0') || ((ut->ut_pid & 255) == '6')) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x00454F5C | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x00454F60 | E0 07 00 F9 | STR             X0, [SP,#0x10+lcl]\n0x00454F64 | E0 07 40 F9 | LDR             X0, [SP,#0x10+lcl]\n0x00454F68 | 00 00 40 39 | LDRB            W0, [X0]\n0x00454F6C | 1F 08 00 71 | CMP             W0, #2\n0x00454F70 | 81 01 00 54 | B.NE            loc_454FA0\n0x00454F74 | E0 07 40 F9 | LDR             X0, [SP,#0x10+lcl]\n0x00454F78 | 00 04 40 39 | LDRB            W0, [X0,#1]\n0x00454F7C | 1F 00 00 71 | CMP             W0, #0\n0x00454F80 | 00 01 00 54 | B.EQ            loc_454FA0\n0x00454F84 | E0 07 40 F9 | LDR             X0, [SP,#0x10+lcl]\n0x00454F88 | 00 10 00 91 | ADD             X0, X0, #4\n0x00454F8C | 00 00 40 39 | LDRB            W0, [X0]\n0x00454F90 | 1F FC 01 71 | CMP             W0, #0x7F\n0x00454F94 | 61 00 00 54 | B.NE            loc_454FA0\n0x00454F98 | C0 1F 80 52 | MOV             W0, #0xFE\n0x00454F9C | 02 00 00 14 | B               loc_454FA4\n0x00454FA0 | 00 00 80 52 | MOV             W0, #0\n0x00454FA4 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x00454FA8 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int default_scope(inet_prefix *lcl)\n{\n\tif (lcl->family == AF_INET) {\n\t\tif (lcl->bytelen >= 1 && *(uint8_t*)&lcl->data == 127)\n\t\t\treturn RT_SCOPE_HOST;\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x004FDCB4 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x004FDCB8 | E0 07 00 F9 | STR             X0, [SP,#0x10+p]\n0x004FDCBC | E0 07 40 F9 | LDR             X0, [SP,#0x10+p]\n0x004FDCC0 | 00 00 40 39 | LDRB            W0, [X0]\n0x004FDCC4 | 1F 70 01 71 | CMP             W0, #0x5C ; '\\'\n0x004FDCC8 | 01 02 00 54 | B.NE            loc_4FDD08\n0x004FDCCC | E0 07 40 F9 | LDR             X0, [SP,#0x10+p]\n0x004FDCD0 | 00 04 00 91 | ADD             X0, X0, #1\n0x004FDCD4 | 00 00 40 39 | LDRB            W0, [X0]\n0x004FDCD8 | 1F 28 00 71 | CMP             W0, #0xA\n0x004FDCDC | 61 01 00 54 | B.NE            loc_4FDD08\n0x004FDCE0 | E0 07 40 F9 | LDR             X0, [SP,#0x10+p]\n0x004FDCE4 | 00 04 00 91 | ADD             X0, X0, #1\n0x004FDCE8 | E0 07 00 F9 | STR             X0, [SP,#0x10+p]\n0x004FDCEC | C0 04 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004FDCF4 | 00 00 40 F9 | LDR             X0, [X0]\n0x004FDCF8 | 01 10 40 B9 | LDR             W1, [X0,#0x10]\n0x004FDCFC | 21 04 00 11 | ADD             W1, W1, #1\n0x004FDD00 | 01 10 00 B9 | STR             W1, [X0,#0x10]\n0x004FDD04 | 09 00 00 14 | B               loc_4FDD28\n0x004FDD08 | E0 07 40 F9 | LDR             X0, [SP,#0x10+p]\n0x004FDD0C | 00 00 40 39 | LDRB            W0, [X0]\n0x004FDD10 | 1F 80 00 71 | CMP             W0, #0x20 ; ' '\n0x004FDD14 | A0 00 00 54 | B.EQ            loc_4FDD28\n0x004FDD18 | E0 07 40 F9 | LDR             X0, [SP,#0x10+p]\n0x004FDD1C | 00 00 40 39 | LDRB            W0, [X0]\n0x004FDD20 | 1F 24 00 71 | CMP             W0, #9\n0x004FDD24 | A1 00 00 54 | B.NE            loc_4FDD38\n0x004FDD28 | E0 07 40 F9 | LDR             X0, [SP,#0x10+p]\n0x004FDD2C | 00 04 00 91 | ADD             X0, X0, #1\n0x004FDD30 | E0 07 00 F9 | STR             X0, [SP,#0x10+p]\n0x004FDD34 | E2 FF FF 17 | B               loc_4FDCBC\n0x004FDD38 | 1F 20 03 D5 | NOP\n0x004FDD3C | E0 07 40 F9 | LDR             X0, [SP,#0x10+p]\n0x004FDD40 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x004FDD44 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic char *skip_spaces(char *p)\n{\n\twhile (1) {\n\t\tif (*p == '\\\\' && p[1] == '\\n') {\n\t\t\tp++;\n\t\t\tt_lineno++;\n\t\t} else if (*p != ' ' && *p != '\\t') {\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x005349EC | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x005349F0 | E0 07 00 F9 | STR             X0, [SP,#0x10+sa]\n0x005349F4 | E0 07 40 F9 | LDR             X0, [SP,#0x10+sa]\n0x005349F8 | 00 00 40 79 | LDRH            W0, [X0]\n0x005349FC | 1F 28 00 71 | CMP             W0, #0xA\n0x00534A00 | 81 00 00 54 | B.NE            loc_534A10\n0x00534A04 | E0 07 40 F9 | LDR             X0, [SP,#0x10+sa]\n0x00534A08 | 00 04 40 79 | LDRH            W0, [X0,#2]\n0x00534A0C | 09 00 00 14 | B               loc_534A30\n0x00534A10 | E0 07 40 F9 | LDR             X0, [SP,#0x10+sa]\n0x00534A14 | 00 00 40 79 | LDRH            W0, [X0]\n0x00534A18 | 1F 08 00 71 | CMP             W0, #2\n0x00534A1C | 81 00 00 54 | B.NE            loc_534A2C\n0x00534A20 | E0 07 40 F9 | LDR             X0, [SP,#0x10+sa]\n0x00534A24 | 00 04 40 79 | LDRH            W0, [X0,#2]\n0x00534A28 | 02 00 00 14 | B               loc_534A30\n0x00534A2C | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x00534A30 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x00534A34 | C0 03 5F D6 | RET",
        "output": "```c\nstatic int get_port_number(struct sockaddr *sa)\n{\n    if (((unsigned short *)sa)[0] == 0x0A) {\n        return ((unsigned short *)sa)[1];\n    } else if (((unsigned short *)sa)[0] == 0x02) {\n        return ((unsigned short *)sa)[1];\n    }\n    return -1;\n}\n```"
    },
    {
        "func_name": "spawn_and_wait",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0043F948 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0043F94C | FD 03 00 91 | MOV             X29, SP\n0x0043F950 | E0 0F 00 F9 | STR             X0, [SP,#0x30+ifname]\n0x0043F954 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+ifname]; ifname\n0x0043F958 | B9 FF FF 97 | BL              if_print\n0x0043F95C | E0 2F 00 B9 | STR             W0, [SP,#0x30+status]\n0x0043F960 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+status]\n0x0043F964 | 00 7C 1F 53 | LSR             W0, W0, #0x1F\n0x0043F968 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x0043F96C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0043F970 | C0 03 5F D6 | RET\n\n Output decompiled code:\nendif\n\nint FAST_FUNC display_interfaces(char *ifname)\n{\n\tint status;\n\n\tstatus = if_print(ifname);\n\n\treturn (status < 0); /* status < 0 == 1 -- error */\n}\n\n## Example:\n\n Input assembly code:\n0x0051C130 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0051C134 | FD 03 00 91 | MOV             X29, SP\n0x0051C138 | E0 0F 00 F9 | STR             X0, [SP,#0x30+name]\n0x0051C13C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+name]; name\n0x0051C140 | 6C FF FF 97 | BL              xgetpwnam\n0x0051C144 | E0 17 00 F9 | STR             X0, [SP,#0x30+myuser]\n0x0051C148 | E0 17 40 F9 | LDR             X0, [SP,#0x30+myuser]\n0x0051C14C | 00 10 40 B9 | LDR             W0, [X0,#0x10]\n0x0051C150 | E0 03 00 2A | MOV             W0, W0\n0x0051C154 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0051C158 | C0 03 5F D6 | RET\n\n Output decompiled code:\nlong FAST_FUNC xuname2uid(const char *name)\n{\n\tstruct passwd *myuser;\n\n\tmyuser = xgetpwnam(name);\n\treturn myuser->pw_uid;\n}\n\n## Example:\n\n Input assembly code:\n0x0051C15C | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0051C160 | FD 03 00 91 | MOV             X29, SP\n0x0051C164 | E0 0F 00 F9 | STR             X0, [SP,#0x30+name]\n0x0051C168 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+name]; name\n0x0051C16C | 71 FF FF 97 | BL              xgetgrnam\n0x0051C170 | E0 17 00 F9 | STR             X0, [SP,#0x30+mygroup]\n0x0051C174 | E0 17 40 F9 | LDR             X0, [SP,#0x30+mygroup]\n0x0051C178 | 00 10 40 B9 | LDR             W0, [X0,#0x10]\n0x0051C17C | E0 03 00 2A | MOV             W0, W0\n0x0051C180 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0051C184 | C0 03 5F D6 | RET\n\n Output decompiled code:\nlong FAST_FUNC xgroup2gid(const char *name)\n{\n\tstruct group *mygroup;\n\n\tmygroup = xgetgrnam(name);\n\treturn mygroup->gr_gid;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x005337C4 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x005337C8 | FD 03 00 91 | MOV             X29, SP\n0x005337CC | E0 0F 00 F9 | STR             X0, [SP,#0x30+argv]\n0x005337D0 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+argv]; argv\n0x005337D4 | C2 FF FF 97 | BL              spawn\n0x005337D8 | E0 2F 00 B9 | STR             W0, [SP,#0x30+rc]\n0x005337DC | E0 2F 40 B9 | LDR             W0, [SP,#0x30+rc]; pid\n0x005337E0 | 04 5C FB 97 | BL              wait4pid\n0x005337E4 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x005337E8 | C0 03 5F D6 | RET",
        "output": "int FAST_FUNC spawn_and_wait(char **argv)\n{\n\tint rc;\n\tpid_t pid;\n\n\tpid = spawn(argv);\n\trc = wait4pid(pid);\n\n\treturn rc;\n}"
    },
    {
        "func_name": "is_hpet_irq",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004BE8AC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004BE8B0 | FD 03 00 91 | MOV             X29, SP\n0x004BE8B4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+id]\n0x004BE8B8 | 02 40 80 D2 | MOV             X2, #0x200; len\n0x004BE8BC | 01 00 80 D2 | MOV             X1, #0; off\n0x004BE8C0 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+id]; id\n0x004BE8C4 | 1D 0A 00 94 | BL              volume_id_get_buffer\n0x004BE8C8 | E0 17 00 F9 | STR             X0, [SP,#0x30+cs]\n0x004BE8CC | E0 17 40 F9 | LDR             X0, [SP,#0x30+cs]\n0x004BE8D0 | 1F 00 00 F1 | CMP             X0, #0\n0x004BE8D4 | 61 00 00 54 | B.NE            loc_4BE8E0\n0x004BE8D8 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004BE8DC | 10 00 00 14 | B               loc_4BE91C\n0x004BE8E0 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cs]\n0x004BE8E4 | 01 00 40 B9 | LDR             W1, [X0]\n0x004BE8E8 | A0 A8 87 52 A0 19 A5 72 | MOV             W0, #0x28CD3D45\n0x004BE8F0 | 3F 00 00 6B | CMP             W1, W0\n0x004BE8F4 | 21 01 00 54 | B.NE            loc_4BE918\n0x004BE8F8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cs]\n0x004BE8FC | 00 C0 00 91 | ADD             X0, X0, #0x30 ; '0'\n0x004BE900 | 02 02 80 D2 | MOV             X2, #0x10; count\n0x004BE904 | E1 03 00 AA | MOV             X1, X0; buf\n0x004BE908 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+id]; id\n0x004BE90C | FA 08 00 94 | BL              volume_id_set_label_string\n0x004BE910 | 00 00 80 52 | MOV             W0, #0\n0x004BE914 | 02 00 00 14 | B               loc_4BE91C\n0x004BE918 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004BE91C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004BE920 | C0 03 5F D6 | RET\n\n Output decompiled code:\nint FAST_FUNC volume_id_probe_cramfs(struct volume_id *id /*,uint64_t off*/)\n{\n#define off ((uint64_t)0)\n\tstruct cramfs_super *cs;\n\n\tdbg(\"probing at offset 0x%llx\", (unsigned long long) off);\n\n\tcs = volume_id_get_buffer(id, off, 0x200);\n\tif (cs == NULL)\n\t\treturn -1;\n\n\tif (cs->magic == cpu_to_be32(0x453dcd28)) {\n//\t\tvolume_id_set_label_raw(id, cs->name, 16);\n\t\tvolume_id_set_label_string(id, cs->name, 16);\n\n//\t\tvolume_id_set_usage(id, VOLUME_ID_FILESYSTEM);\n\t\tIF_FEATURE_BLKID_TYPE(id->type = \"cramfs\";)\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\n## Example:\n\n Input assembly code:\n0x004BFEE0 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004BFEE4 | FD 03 00 91 | MOV             X29, SP\n0x004BFEE8 | E0 0F 00 F9 | STR             X0, [SP,#0x30+id]\n0x004BFEEC | 02 4A 80 D2 | MOV             X2, #0x250; len\n0x004BFEF0 | 01 00 80 D2 | MOV             X1, #0; off\n0x004BFEF4 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+id]; id\n0x004BFEF8 | 90 04 00 94 | BL              volume_id_get_buffer\n0x004BFEFC | E0 17 00 F9 | STR             X0, [SP,#0x30+header]\n0x004BFF00 | E0 17 40 F9 | LDR             X0, [SP,#0x30+header]\n0x004BFF04 | 1F 00 00 F1 | CMP             X0, #0\n0x004BFF08 | 61 00 00 54 | B.NE            loc_4BFF14\n0x004BFF0C | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004BFF10 | 12 00 00 14 | B               loc_4BFF58\n0x004BFF14 | E3 17 40 F9 | LDR             X3, [SP,#0x30+header]\n0x004BFF18 | C2 00 80 D2 | MOV             X2, #6; n\n0x004BFF1C | C0 04 00 90 | ADRP            X0, #LUKS_MAGIC@PAGE\n0x004BFF20 | 01 80 12 91 | ADD             X1, X0, #LUKS_MAGIC@PAGEOFF; s2\n0x004BFF24 | E0 03 03 AA | MOV             X0, X3; s1\n0x004BFF28 | 0A 1D FD 97 | BL              .memcmp\n0x004BFF2C | 1F 00 00 71 | CMP             W0, #0\n0x004BFF30 | 60 00 00 54 | B.EQ            loc_4BFF3C\n0x004BFF34 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004BFF38 | 08 00 00 14 | B               loc_4BFF58\n0x004BFF3C | E0 17 40 F9 | LDR             X0, [SP,#0x30+header]\n0x004BFF40 | 00 A0 02 91 | ADD             X0, X0, #0xA8\n0x004BFF44 | 62 00 80 52 | MOV             W2, #3; format\n0x004BFF48 | E1 03 00 AA | MOV             X1, X0; buf\n0x004BFF4C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+id]; id\n0x004BFF50 | AA 03 00 94 | BL              volume_id_set_uuid\n0x004BFF54 | 00 00 80 52 | MOV             W0, #0\n0x004BFF58 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004BFF5C | C0 03 5F D6 | RET\n\n Output decompiled code:\nint FAST_FUNC volume_id_probe_luks(struct volume_id *id /*,uint64_t off*/)\n{\n#define off ((uint64_t)0)\n\tstruct luks_phdr *header;\n\n\theader = volume_id_get_buffer(id, off, sizeof(*header));\n\tif (header == NULL)\n\t\treturn -1;\n\n\tif (memcmp(header->magic, LUKS_MAGIC, LUKS_MAGIC_L))\n\t\treturn -1;\n\n//\tvolume_id_set_usage(id, VOLUME_ID_CRYPTO);\n\tvolume_id_set_uuid(id, header->uuid, UUID_DCE_STRING);\n\tIF_FEATURE_BLKID_TYPE(id->type = \"crypto_LUKS\";)\n\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x00409340 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00409344 | FD 03 00 91 | MOV             X29, SP\n0x00409348 | E0 0F 00 F9 | STR             X0, [SP,#0x30+path]\n0x0040934C | E1 05 80 52 | MOV             W1, #0x2F ; '/'; c\n0x00409350 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+path]; s\n0x00409354 | 16 00 00 94 | BL              last_char_is\n0x00409358 | E0 17 00 F9 | STR             X0, [SP,#0x30+slash]\n0x0040935C | E0 17 40 F9 | LDR             X0, [SP,#0x30+slash]\n0x00409360 | 1F 00 00 F1 | CMP             X0, #0\n0x00409364 | C0 01 00 54 | B.EQ            loc_40939C\n0x00409368 | 05 00 00 14 | B               loc_40937C\n0x0040936C | E0 17 40 F9 | LDR             X0, [SP,#0x30+slash]\n0x00409370 | 01 04 00 D1 | SUB             X1, X0, #1\n0x00409374 | E1 17 00 F9 | STR             X1, [SP,#0x30+slash]\n0x00409378 | 1F 00 00 39 | STRB            WZR, [X0]\n0x0040937C | E0 17 40 F9 | LDR             X0, [SP,#0x30+slash]\n0x00409380 | 00 00 40 39 | LDRB            W0, [X0]\n0x00409384 | 1F BC 00 71 | CMP             W0, #0x2F ; '/'\n0x00409388 | A1 00 00 54 | B.NE            loc_40939C\n0x0040938C | E1 17 40 F9 | LDR             X1, [SP,#0x30+slash]\n0x00409390 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+path]\n0x00409394 | 3F 00 00 EB | CMP             X1, X0\n0x00409398 | A1 FE FF 54 | B.NE            loc_40936C\n0x0040939C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+path]; path\n0x004093A0 | CF FF FF 97 | BL              bb_get_last_path_component_nostrip\n0x004093A4 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004093A8 | C0 03 5F D6 | RET\n\n Output decompiled code:\nFAST_FUNC bb_get_last_path_component_strip(char *path)\n{\n\tchar *slash = last_char_is(path, '/');\n\n\tif (slash)\n\t\twhile (*slash == '/' && slash != path)\n\t\t\t*slash-- = '\\0';\n\n\treturn bb_get_last_path_component_nostrip(path);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0046E988 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0046E98C | FD 03 00 91 | MOV             X29, SP\n0x0046E990 | E0 0F 00 F9 | STR             X0, [SP,#0x30+name]\n0x0046E994 | E0 06 00 F0 | ADRP            X0, #aHpet@PAGE; \"hpet\"\n0x0046E998 | 01 A0 20 91 | ADD             X1, X0, #aHpet@PAGEOFF; \"hpet\"\n0x0046E99C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+name]; haystack\n0x0046E9A0 | 14 64 FE 97 | BL              .strstr\n0x0046E9A4 | E0 17 00 F9 | STR             X0, [SP,#0x30+p]\n0x0046E9A8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+p]\n0x0046E9AC | 1F 00 00 F1 | CMP             X0, #0\n0x0046E9B0 | 61 00 00 54 | B.NE            loc_46E9BC\n0x0046E9B4 | 00 00 80 52 | MOV             W0, #0\n0x0046E9B8 | 0D 00 00 14 | B               loc_46E9EC\n0x0046E9BC | E0 17 40 F9 | LDR             X0, [SP,#0x30+p]\n0x0046E9C0 | 00 10 00 91 | ADD             X0, X0, #4\n0x0046E9C4 | E0 17 00 F9 | STR             X0, [SP,#0x30+p]\n0x0046E9C8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+p]\n0x0046E9CC | 00 00 40 39 | LDRB            W0, [X0]\n0x0046E9D0 | 00 C0 00 51 | SUB             W0, W0, #0x30 ; '0'\n0x0046E9D4 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x0046E9D8 | 1F 24 00 71 | CMP             W0, #9\n0x0046E9DC | 69 00 00 54 | B.LS            loc_46E9E8\n0x0046E9E0 | 00 00 80 52 | MOV             W0, #0\n0x0046E9E4 | 02 00 00 14 | B               loc_46E9EC\n0x0046E9E8 | 20 00 80 52 | MOV             W0, #1\n0x0046E9EC | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0046E9F0 | C0 03 5F D6 | RET",
        "output": "```c\nint check_hpet_presence(char *name)\n{\n    char *p;\n\n    p = strstr(name, \"hpet\");\n    if (p == NULL)\n        return 0;\n\n    p += 4;\n    if ((unsigned char)(*p - '0') <= 9)\n        return 1;\n\n    return 0;\n}\n```"
    },
    {
        "func_name": "not",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00418558 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0041855C | FD 03 00 91 | MOV             X29, SP\n0x00418560 | E8 0B 00 FD | STR             D8, [SP,#0x20+var_10]\n0x00418564 | 98 FF FF 97 | BL              pop\n0x00418568 | 08 B8 E1 7E | FCVTZU          D8, D0\n0x0041856C | 96 FF FF 97 | BL              pop\n0x00418570 | 00 B8 E1 7E | FCVTZU          D0, D0\n0x00418574 | 00 1D 20 0E | AND             V0.8B, V8.8B, V0.8B\n0x00418578 | 00 00 66 9E | FMOV            X0, D0\n0x0041857C | 00 00 63 9E | UCVTF           D0, X0; a\n0x00418580 | 77 FF FF 97 | BL              push\n0x00418584 | 1F 20 03 D5 | NOP\n0x00418588 | E8 0B 40 FD | LDR             D8, [SP,#0x20+var_10]\n0x0041858C | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00418590 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void and(void)\n{\n\tpush((data_t) pop() & (data_t) pop());\n}\n\n## Example:\n\n Input assembly code:\n0x00418594 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00418598 | FD 03 00 91 | MOV             X29, SP\n0x0041859C | E8 0B 00 FD | STR             D8, [SP,#0x20+var_10]\n0x004185A0 | 89 FF FF 97 | BL              pop\n0x004185A4 | 08 B8 E1 7E | FCVTZU          D8, D0\n0x004185A8 | 87 FF FF 97 | BL              pop\n0x004185AC | 00 B8 E1 7E | FCVTZU          D0, D0\n0x004185B0 | 00 1D A0 0E | ORR             V0.8B, V8.8B, V0.8B\n0x004185B4 | 00 00 66 9E | FMOV            X0, D0\n0x004185B8 | 00 00 63 9E | UCVTF           D0, X0; a\n0x004185BC | 68 FF FF 97 | BL              push\n0x004185C0 | 1F 20 03 D5 | NOP\n0x004185C4 | E8 0B 40 FD | LDR             D8, [SP,#0x20+var_10]\n0x004185C8 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004185CC | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void or(void)\n{\n\tpush((data_t) pop() | (data_t) pop());\n}\n\n## Example:\n\n Input assembly code:\n0x00418514 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00418518 | FD 03 00 91 | MOV             X29, SP\n0x0041851C | AA FF FF 97 | BL              pop\n0x00418520 | 00 B8 E1 7E | FCVTZU          D0, D0\n0x00418524 | E0 0F 00 FD | STR             D0, [SP,#0x20+d]\n0x00418528 | A7 FF FF 97 | BL              pop\n0x0041852C | 00 00 79 9E | FCVTZU          X0, D0\n0x00418530 | E1 0F 40 F9 | LDR             X1, [SP,#0x20+d]\n0x00418534 | 02 08 C1 9A | UDIV            X2, X0, X1\n0x00418538 | E1 0F 40 F9 | LDR             X1, [SP,#0x20+d]\n0x0041853C | 41 7C 01 9B | MUL             X1, X2, X1\n0x00418540 | 00 00 01 CB | SUB             X0, X0, X1\n0x00418544 | 00 00 63 9E | UCVTF           D0, X0; a\n0x00418548 | 85 FF FF 97 | BL              push\n0x0041854C | 1F 20 03 D5 | NOP\n0x00418550 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00418554 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void mod(void)\n{\n\tdata_t d = pop();\n\n\tpush((data_t) pop() % d);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0041860C | FD 7B BF A9 | STP             X29, X30, [SP,#-0x10+var_s0]!\n0x00418610 | FD 03 00 91 | MOV             X29, SP\n0x00418614 | 6C FF FF 97 | BL              pop\n0x00418618 | 00 B8 E1 7E | FCVTZU          D0, D0\n0x0041861C | 00 00 66 9E | FMOV            X0, D0\n0x00418620 | E0 03 20 AA | MVN             X0, X0\n0x00418624 | 00 00 63 9E | UCVTF           D0, X0; a\n0x00418628 | 4D FF FF 97 | BL              push\n0x0041862C | 1F 20 03 D5 | NOP\n0x00418630 | FD 7B C1 A8 | LDP             X29, X30, [SP+var_s0],#0x10\n0x00418634 | C0 03 5F D6 | RET",
        "output": "```c\nstatic void not(void)\n{\n\tpush(~(data_t) pop());\n}\n```"
    },
    {
        "func_name": "get_uart",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0040AED0 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0040AED4 | FD 03 00 91 | MOV             X29, SP\n0x0040AED8 | E0 0F 00 F9 | STR             X0, [SP,#0x30+template]\n0x0040AEDC | E0 0F 40 F9 | LDR             X0, [SP,#0x30+template]; template\n0x0040AEE0 | D0 EF FF 97 | BL              .mkstemp64\n0x0040AEE4 | E0 2F 00 B9 | STR             W0, [SP,#0x30+fd]\n0x0040AEE8 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+fd]\n0x0040AEEC | 1F 00 00 71 | CMP             W0, #0\n0x0040AEF0 | AA 00 00 54 | B.GE            loc_40AF04\n0x0040AEF4 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+template]\n0x0040AEF8 | A0 09 00 90 00 A0 0D 91 | ADRL            X0, aCanTCreateTemp; \"can't create temp file '%s'\"\n0x0040AF00 | 1E FA FF 97 | BL              bb_perror_msg_and_die\n0x0040AF04 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+fd]\n0x0040AF08 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0040AF0C | C0 03 5F D6 | RET\n\n Output decompiled code:\nint FAST_FUNC xmkstemp(char *template)\n{\n\tint fd = mkstemp(template);\n\tif (fd < 0)\n\t\tbb_perror_msg_and_die(\"can't create temp file '%s'\", template);\n\treturn fd;\n}\n\n## Example:\n\n Input assembly code:\n0x004269DC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004269E0 | FD 03 00 91 | MOV             X29, SP\n0x004269E4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+arg]\n0x004269E8 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+arg]; name\n0x004269EC | A2 FF FF 97 | BL              uart_id\n0x004269F0 | E0 2F 00 B9 | STR             W0, [SP,#0x30+uart]\n0x004269F4 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+uart]\n0x004269F8 | 1F 00 00 71 | CMP             W0, #0\n0x004269FC | AA 00 00 54 | B.GE            loc_426A10\n0x00426A00 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+arg]\n0x00426A04 | E0 08 00 B0 00 C0 1A 91 | ADRL            X0, aIllegalUartTyp; \"illegal UART type: %s\"\n0x00426A0C | 9A 8C FF 97 | BL              bb_error_msg_and_die\n0x00426A10 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+uart]\n0x00426A14 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00426A18 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int get_uart(const char *arg)\n{\n\tint uart = uart_id(arg);\n\n\tif (uart < 0)\n\t\tbb_error_msg_and_die(\"illegal UART type: %s\", arg);\n\n\treturn uart;\n}\n\n## Example:\n\n Input assembly code:\n0x00426F64 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00426F68 | FD 03 00 91 | MOV             X29, SP\n0x00426F6C | E0 0F 00 F9 | STR             X0, [SP,#0x30+cmd]\n0x00426F70 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+cmd]; key\n0x00426F74 | E0 08 00 B0 00 E0 15 91 | ADRL            X0, commands; strings\n0x00426F7C | 21 FE FF 97 | BL              index_in_strings_case_insensitive\n0x00426F80 | E0 2F 00 B9 | STR             W0, [SP,#0x30+idx]\n0x00426F84 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+idx]\n0x00426F88 | 1F 00 00 71 | CMP             W0, #0\n0x00426F8C | AA 00 00 54 | B.GE            loc_426FA0\n0x00426F90 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+cmd]\n0x00426F94 | E0 08 00 B0 00 60 21 91 | ADRL            X0, aInvalidFlagS; \"invalid flag: %s\"\n0x00426F9C | 36 8B FF 97 | BL              bb_error_msg_and_die\n0x00426FA0 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+idx]\n0x00426FA4 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00426FA8 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic int find_cmd(const char *cmd)\n{\n\tint idx;\n\n\tidx = index_in_strings_case_insensitive(commands, cmd);\n\tif (idx < 0)\n\t\tbb_error_msg_and_die(\"invalid flag: %s\", cmd);\n\n\treturn idx;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004269DC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004269E0 | FD 03 00 91 | MOV             X29, SP\n0x004269E4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+arg]\n0x004269E8 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+arg]; name\n0x004269EC | A2 FF FF 97 | BL              uart_id\n0x004269F0 | E0 2F 00 B9 | STR             W0, [SP,#0x30+uart]\n0x004269F4 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+uart]\n0x004269F8 | 1F 00 00 71 | CMP             W0, #0\n0x004269FC | AA 00 00 54 | B.GE            loc_426A10\n0x00426A00 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+arg]\n0x00426A04 | E0 08 00 B0 00 C0 1A 91 | ADRL            X0, aIllegalUartTyp; \"illegal UART type: %s\"\n0x00426A0C | 9A 8C FF 97 | BL              bb_error_msg_and_die\n0x00426A10 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+uart]\n0x00426A14 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00426A18 | C0 03 5F D6 | RET",
        "output": "```c\nstatic int get_uart(const char *name)\n{\n\tint uart = uart_id(name);\n\n\tif (uart < 0)\n\t\tbb_error_msg_and_die(\"illegal UART type: %s\", name);\n\n\treturn uart;\n}\n```"
    },
    {
        "func_name": "maybe_up_new_iface",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004A6758 | FD 7B BF A9 | STP             X29, X30, [SP,#-0x10+var_s0]!\n0x004A675C | FD 03 00 91 | MOV             X29, SP\n0x004A6760 | 60 07 00 F0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004A6768 | 00 00 40 F9 | LDR             X0, [X0]\n0x004A676C | 00 30 40 B9 | LDR             W0, [X0,#0x30]\n0x004A6770 | 1F 00 00 71 | CMP             W0, #0\n0x004A6774 | A1 02 00 54 | B.NE            loc_4A67C8\n0x004A6778 | 60 07 00 F0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004A6780 | 00 00 40 F9 | LDR             X0, [X0]\n0x004A6784 | 00 2C 40 B9 | LDR             W0, [X0,#0x2C]\n0x004A6788 | 1F 00 10 71 | CMP             W0, #0x400\n0x004A678C | E9 01 00 54 | B.LS            loc_4A67C8\n0x004A6790 | 60 07 00 F0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004A6798 | 00 00 40 F9 | LDR             X0, [X0]\n0x004A679C | 00 40 40 B9 | LDR             W0, [X0,#0x40]\n0x004A67A0 | 1F 00 00 71 | CMP             W0, #0\n0x004A67A4 | 21 01 00 54 | B.NE            loc_4A67C8\n0x004A67A8 | 60 07 00 F0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004A67B0 | 00 00 40 F9 | LDR             X0, [X0]\n0x004A67B4 | 00 2C 40 B9 | LDR             W0, [X0,#0x2C]\n0x004A67B8 | E1 03 00 2A | MOV             W1, W0\n0x004A67BC | 60 05 00 B0 00 E0 0C 91 | ADRL            X0, aTheNumberOfCyl; \"\\nThe number of cylinders for this disk\"...\n0x004A67C4 | 03 85 FD 97 | BL              .printf\n0x004A67C8 | 1F 20 03 D5 | NOP\n0x004A67CC | FD 7B C1 A8 | LDP             X29, X30, [SP+var_s0],#0x10\n0x004A67D0 | C0 03 5F D6 | RET\n\n Output decompiled code:\nif ENABLE_FEATURE_FDISK_WRITABLE\nstatic void\nwarn_cylinders(void)\n{\n\tif (LABEL_IS_DOS && g_cylinders > 1024 && !nowarn)\n\t\tprintf(\"\\n\"\n\"The number of cylinders for this disk is set to %u.\\n\"\n\"There is nothing wrong with that, but this is larger than 1024,\\n\"\n\"and could in certain setups cause problems with:\\n\"\n\"1) software that runs at boot time (e.g., old versions of LILO)\\n\"\n\"2) booting and partitioning software from other OSs\\n\"\n\"   (e.g., DOS FDISK, OS/2 FDISK)\\n\",\n\t\t\tg_cylinders);\n}\n\n## Example:\n\n Input assembly code:\n0x00514248 | FD 7B BF A9 | STP             X29, X30, [SP,#-0x10+var_s0]!\n0x0051424C | FD 03 00 91 | MOV             X29, SP\n0x00514250 | 00 04 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00514258 | 00 00 40 F9 | LDR             X0, [X0]\n0x0051425C | 00 1C 40 B9 | LDR             W0, [X0,#0x1C]\n0x00514260 | 00 00 1D 12 | AND             W0, W0, #8\n0x00514264 | 1F 00 00 71 | CMP             W0, #0\n0x00514268 | A1 00 00 54 | B.NE            loc_51427C\n0x0051426C | 40 02 00 B0 00 40 3C 91 | ADRL            X0, asc_55DF10; \"\\a\"\n0x00514274 | 47 E9 FF 97 | BL              write1\n0x00514278 | 03 00 00 14 | B               loc_514284\n0x0051427C | 40 01 80 52 | MOV             W0, #0xA; h\n0x00514280 | E4 FF FF 97 | BL              flash\n0x00514284 | 1F 20 03 D5 | NOP\n0x00514288 | FD 7B C1 A8 | LDP             X29, X30, [SP+var_s0],#0x10\n0x0051428C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void Indicate_Error(void)\n{\n#if ENABLE_FEATURE_VI_CRASHME\n\tif (crashme > 0)\n\t\treturn;\t\t\t// generate a random command\n#endif\n\tif (!err_method) {\n\t\twrite1(ESC_BELL);\n\t} else {\n\t\tflash(10);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x0042982C | 60 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00429834 | 00 00 40 F9 | LDR             X0, [X0]\n0x00429838 | 00 20 40 B9 | LDR             W0, [X0,#0x20]\n0x0042983C | 1F 00 00 71 | CMP             W0, #0\n0x00429840 | E0 00 00 54 | B.EQ            loc_42985C\n0x00429844 | 60 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0042984C | 00 00 40 F9 | LDR             X0, [X0]\n0x00429850 | 01 20 40 B9 | LDR             W1, [X0,#0x20]\n0x00429854 | 21 04 00 51 | SUB             W1, W1, #1\n0x00429858 | 01 20 00 B9 | STR             W1, [X0,#0x20]\n0x0042985C | 1F 20 03 D5 | NOP\n0x00429860 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void bksp(void)\n{\n\tif (stringbuf_idx)\n\t\tstringbuf_idx--;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004376E4 | FD 7B BF A9 | STP             X29, X30, [SP,#-0x10+var_s0]!\n0x004376E8 | FD 03 00 91 | MOV             X29, SP\n0x004376EC | E0 0A 00 D0 00 A0 10 91 | ADRL            X0, option_mask32\n0x004376F4 | 00 00 40 B9 | LDR             W0, [X0]\n0x004376F8 | 00 00 00 12 | AND             W0, W0, #1\n0x004376FC | 1F 00 00 71 | CMP             W0, #0\n0x00437700 | 41 00 00 54 | B.NE            loc_437708\n0x00437704 | CB FF FF 97 | BL              up_iface\n0x00437708 | E0 0A 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00437710 | 00 00 40 F9 | LDR             X0, [X0]\n0x00437714 | 00 14 40 F9 | LDR             X0, [X0,#0x28]\n0x00437718 | 00 00 40 39 | LDRB            W0, [X0]\n0x0043771C | 1F 84 01 71 | CMP             W0, #0x61 ; 'a'\n0x00437720 | C1 00 00 54 | B.NE            loc_437738\n0x00437724 | E0 0A 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x0043772C | 00 00 40 F9 | LDR             X0, [X0]\n0x00437730 | A1 00 80 52 | MOV             W1, #5\n0x00437734 | 01 0C 00 B9 | STR             W1, [X0,#0xC]\n0x00437738 | 1F 20 03 D5 | NOP\n0x0043773C | FD 7B C1 A8 | LDP             X29, X30, [SP+var_s0],#0x10\n0x00437740 | C0 03 5F D6 | RET",
        "output": "```c\nvoid configure_interface(void)\n{\n    if (!(option_mask32 & 1))\n        up_iface();\n    if (*ptr_to_globals->field_28 == 'a')\n        ptr_to_globals->field_C = 5;\n}\n```"
    },
    {
        "func_name": "xread",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0040ADA4 | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x0040ADA8 | FD 03 00 91 | MOV             X29, SP\n0x0040ADAC | E0 2F 00 B9 | STR             W0, [SP,#0x40+fd]\n0x0040ADB0 | E1 13 00 F9 | STR             X1, [SP,#0x40+buf]\n0x0040ADB4 | E2 0F 00 F9 | STR             X2, [SP,#0x40+count]\n0x0040ADB8 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+count]\n0x0040ADBC | 1F 00 00 F1 | CMP             X0, #0\n0x0040ADC0 | A0 01 00 54 | B.EQ            loc_40ADF4\n0x0040ADC4 | E2 0F 40 F9 | LDR             X2, [SP,#0x40+count]; len\n0x0040ADC8 | E1 13 40 F9 | LDR             X1, [SP,#0x40+buf]; buf\n0x0040ADCC | E0 2F 40 B9 | LDR             W0, [SP,#0x40+fd]; fd\n0x0040ADD0 | FE 03 00 94 | BL              full_write\n0x0040ADD4 | E0 1F 00 F9 | STR             X0, [SP,#0x40+size]\n0x0040ADD8 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+count]\n0x0040ADDC | E1 1F 40 F9 | LDR             X1, [SP,#0x40+size]\n0x0040ADE0 | 3F 00 00 EB | CMP             X1, X0\n0x0040ADE4 | 80 00 00 54 | B.EQ            loc_40ADF4\n0x0040ADE8 | A0 09 00 90 00 C0 0C 91 | ADRL            X0, aShortWrite; \"short write\"\n0x0040ADF0 | A1 FB FF 97 | BL              bb_error_msg_and_die\n0x0040ADF4 | 1F 20 03 D5 | NOP\n0x0040ADF8 | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x0040ADFC | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid FAST_FUNC xwrite(int fd, const void *buf, size_t count)\n{\n\tif (count) {\n\t\tssize_t size = full_write(fd, buf, count);\n\t\tif ((size_t)size != count)\n\t\t\tbb_error_msg_and_die(\"short write\");\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x0052FFFC | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x00530000 | FD 03 00 91 | MOV             X29, SP\n0x00530004 | E0 2F 00 B9 | STR             W0, [SP,#0x40+fd]\n0x00530008 | E1 13 00 F9 | STR             X1, [SP,#0x40+buf]\n0x0053000C | E2 0F 00 F9 | STR             X2, [SP,#0x40+count]\n0x00530010 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+count]\n0x00530014 | 1F 00 00 F1 | CMP             X0, #0\n0x00530018 | A0 01 00 54 | B.EQ            loc_53004C\n0x0053001C | E2 0F 40 F9 | LDR             X2, [SP,#0x40+count]; len\n0x00530020 | E1 13 40 F9 | LDR             X1, [SP,#0x40+buf]; buf\n0x00530024 | E0 2F 40 B9 | LDR             W0, [SP,#0x40+fd]; fd\n0x00530028 | A6 6F FB 97 | BL              full_read\n0x0053002C | E0 1F 00 F9 | STR             X0, [SP,#0x40+size]\n0x00530030 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+count]\n0x00530034 | E1 1F 40 F9 | LDR             X1, [SP,#0x40+size]\n0x00530038 | 3F 00 00 EB | CMP             X1, X0\n0x0053003C | 80 00 00 54 | B.EQ            loc_53004C\n0x00530040 | 80 01 00 90 00 40 02 91 | ADRL            X0, aShortRead_4; \"short read\"\n0x00530048 | 0B 67 FB 97 | BL              bb_error_msg_and_die\n0x0053004C | 1F 20 03 D5 | NOP\n0x00530050 | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x00530054 | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid FAST_FUNC xread(int fd, void *buf, size_t count)\n{\n\tif (count) {\n\t\tssize_t size = full_read(fd, buf, count);\n\t\tif ((size_t)size != count)\n\t\t\tbb_error_msg_and_die(\"short read\");\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x0041A3A8 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0041A3AC | FD 03 00 91 | MOV             X29, SP\n0x0041A3B0 | E0 2F 00 B9 | STR             W0, [SP,#0x30+get_arg]\n0x0041A3B4 | E1 13 00 F9 | STR             X1, [SP,#0x30+s]\n0x0041A3B8 | E2 0F 00 F9 | STR             X2, [SP,#0x30+arg]\n0x0041A3BC | E0 2F 40 B9 | LDR             W0, [SP,#0x30+get_arg]\n0x0041A3C0 | 1F 00 00 71 | CMP             W0, #0\n0x0041A3C4 | 00 01 00 54 | B.EQ            loc_41A3E4\n0x0041A3C8 | E2 0F 40 F9 | LDR             X2, [SP,#0x30+arg]\n0x0041A3CC | E1 13 40 F9 | LDR             X1, [SP,#0x30+s]\n0x0041A3D0 | 20 09 00 D0 00 C0 0C 91 | ADRL            X0, aSettingSToLd_0; \" setting %s to %ld\"\n0x0041A3D8 | FE B5 FF 97 | BL              .printf\n0x0041A3DC | E0 0F 40 F9 | LDR             X0, [SP,#0x30+arg]; value\n0x0041A3E0 | E3 FF FF 97 | BL              on_off\n0x0041A3E4 | 1F 20 03 D5 | NOP\n0x0041A3E8 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0041A3EC | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic void print_flag_on_off(int get_arg, const char *s, unsigned long arg)\n{\n\tif (get_arg) {\n\t\tprintf(\" setting %s to %ld\", s, arg);\n\t\ton_off(arg);\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0052FFFC | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x00530000 | FD 03 00 91 | MOV             X29, SP\n0x00530004 | E0 2F 00 B9 | STR             W0, [SP,#0x40+fd]\n0x00530008 | E1 13 00 F9 | STR             X1, [SP,#0x40+buf]\n0x0053000C | E2 0F 00 F9 | STR             X2, [SP,#0x40+count]\n0x00530010 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+count]\n0x00530014 | 1F 00 00 F1 | CMP             X0, #0\n0x00530018 | A0 01 00 54 | B.EQ            loc_53004C\n0x0053001C | E2 0F 40 F9 | LDR             X2, [SP,#0x40+count]; len\n0x00530020 | E1 13 40 F9 | LDR             X1, [SP,#0x40+buf]; buf\n0x00530024 | E0 2F 40 B9 | LDR             W0, [SP,#0x40+fd]; fd\n0x00530028 | A6 6F FB 97 | BL              full_read\n0x0053002C | E0 1F 00 F9 | STR             X0, [SP,#0x40+size]\n0x00530030 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+count]\n0x00530034 | E1 1F 40 F9 | LDR             X1, [SP,#0x40+size]\n0x00530038 | 3F 00 00 EB | CMP             X1, X0\n0x0053003C | 80 00 00 54 | B.EQ            loc_53004C\n0x00530040 | 80 01 00 90 00 40 02 91 | ADRL            X0, aShortRead_4; \"short read\"\n0x00530048 | 0B 67 FB 97 | BL              bb_error_msg_and_die\n0x0053004C | 1F 20 03 D5 | NOP\n0x00530050 | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x00530054 | C0 03 5F D6 | RET",
        "output": "```c\nvoid FAST_FUNC xread(int fd, void *buf, size_t count)\n{\n\tif (count) {\n\t\tssize_t size = full_read(fd, buf, count);\n\t\tif ((size_t)size != count)\n\t\t\tbb_error_msg_and_die(\"short read\");\n\t}\n}\n```"
    },
    {
        "func_name": "isrv_want_rd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004528A0 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x004528A4 | E0 07 00 F9 | STR             X0, [SP,#0x10+state]\n0x004528A8 | E1 07 00 B9 | STR             W1, [SP,#0x10+fd]\n0x004528AC | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x004528B0 | 01 FC 00 11 | ADD             W1, W0, #0x3F ; '?'\n0x004528B4 | 1F 00 00 71 | CMP             W0, #0\n0x004528B8 | 20 B0 80 1A | CSEL            W0, W1, W0, LT\n0x004528BC | 00 7C 06 13 | ASR             W0, W0, #6\n0x004528C0 | E3 03 00 2A | MOV             W3, W0\n0x004528C4 | E1 07 40 F9 | LDR             X1, [SP,#0x10+state]\n0x004528C8 | 60 7C 40 93 | SXTW            X0, W3\n0x004528CC | 00 18 00 91 | ADD             X0, X0, #6\n0x004528D0 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x004528D4 | 20 00 00 8B | ADD             X0, X1, X0\n0x004528D8 | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x004528DC | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x004528E0 | E2 03 00 6B | NEGS            W2, W0\n0x004528E4 | 00 14 00 12 | AND             W0, W0, #0x3F\n0x004528E8 | 42 14 00 12 | AND             W2, W2, #0x3F\n0x004528EC | 00 44 82 5A | CSNEG           W0, W0, W2, MI\n0x004528F0 | 22 00 80 D2 | MOV             X2, #1\n0x004528F4 | 40 20 C0 9A | LSL             X0, X2, X0\n0x004528F8 | E0 03 20 AA | MVN             X0, X0\n0x004528FC | 21 00 00 8A | AND             X1, X1, X0\n0x00452900 | E2 07 40 F9 | LDR             X2, [SP,#0x10+state]\n0x00452904 | 60 7C 40 93 | SXTW            X0, W3\n0x00452908 | 00 18 00 91 | ADD             X0, X0, #6\n0x0045290C | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00452910 | 40 00 00 8B | ADD             X0, X2, X0\n0x00452914 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x00452918 | 1F 20 03 D5 | NOP\n0x0045291C | FF 43 00 91 | ADD             SP, SP, #0x10\n0x00452920 | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid isrv_dont_want_rd(isrv_state_t *state, int fd)\n{\n\tFD_CLR(fd, &state->rd);\n}\n\n## Example:\n\n Input assembly code:\n0x004527B8 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x004527BC | E0 07 00 F9 | STR             X0, [SP,#0x10+state]\n0x004527C0 | E1 07 00 B9 | STR             W1, [SP,#0x10+fd]\n0x004527C4 | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x004527C8 | 01 FC 00 11 | ADD             W1, W0, #0x3F ; '?'\n0x004527CC | 1F 00 00 71 | CMP             W0, #0\n0x004527D0 | 20 B0 80 1A | CSEL            W0, W1, W0, LT\n0x004527D4 | 00 7C 06 13 | ASR             W0, W0, #6\n0x004527D8 | E1 07 40 F9 | LDR             X1, [SP,#0x10+state]\n0x004527DC | 00 7C 40 93 | SXTW            X0, W0\n0x004527E0 | 00 58 00 91 | ADD             X0, X0, #0x16\n0x004527E4 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x004527E8 | 20 00 00 8B | ADD             X0, X1, X0\n0x004527EC | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x004527F0 | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x004527F4 | E2 03 00 6B | NEGS            W2, W0\n0x004527F8 | 00 14 00 12 | AND             W0, W0, #0x3F\n0x004527FC | 42 14 00 12 | AND             W2, W2, #0x3F\n0x00452800 | 00 44 82 5A | CSNEG           W0, W0, W2, MI\n0x00452804 | 22 00 80 D2 | MOV             X2, #1\n0x00452808 | 40 20 C0 9A | LSL             X0, X2, X0\n0x0045280C | 20 00 00 8A | AND             X0, X1, X0\n0x00452810 | 1F 00 00 F1 | CMP             X0, #0\n0x00452814 | 01 04 00 54 | B.NE            loc_452894\n0x00452818 | E0 07 40 F9 | LDR             X0, [SP,#0x10+state]\n0x0045281C | 00 34 40 B9 | LDR             W0, [X0,#0x34]\n0x00452820 | 01 04 00 11 | ADD             W1, W0, #1\n0x00452824 | E0 07 40 F9 | LDR             X0, [SP,#0x10+state]\n0x00452828 | 01 34 00 B9 | STR             W1, [X0,#0x34]\n0x0045282C | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x00452830 | 01 FC 00 11 | ADD             W1, W0, #0x3F ; '?'\n0x00452834 | 1F 00 00 71 | CMP             W0, #0\n0x00452838 | 20 B0 80 1A | CSEL            W0, W1, W0, LT\n0x0045283C | 00 7C 06 13 | ASR             W0, W0, #6\n0x00452840 | E3 03 00 2A | MOV             W3, W0\n0x00452844 | E1 07 40 F9 | LDR             X1, [SP,#0x10+state]\n0x00452848 | 60 7C 40 93 | SXTW            X0, W3\n0x0045284C | 00 58 00 91 | ADD             X0, X0, #0x16\n0x00452850 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00452854 | 20 00 00 8B | ADD             X0, X1, X0\n0x00452858 | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x0045285C | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x00452860 | E2 03 00 6B | NEGS            W2, W0\n0x00452864 | 00 14 00 12 | AND             W0, W0, #0x3F\n0x00452868 | 42 14 00 12 | AND             W2, W2, #0x3F\n0x0045286C | 00 44 82 5A | CSNEG           W0, W0, W2, MI\n0x00452870 | 22 00 80 D2 | MOV             X2, #1\n0x00452874 | 40 20 C0 9A | LSL             X0, X2, X0\n0x00452878 | 21 00 00 AA | ORR             X1, X1, X0\n0x0045287C | E2 07 40 F9 | LDR             X2, [SP,#0x10+state]\n0x00452880 | 60 7C 40 93 | SXTW            X0, W3\n0x00452884 | 00 58 00 91 | ADD             X0, X0, #0x16\n0x00452888 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x0045288C | 40 00 00 8B | ADD             X0, X2, X0\n0x00452890 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x00452894 | 1F 20 03 D5 | NOP\n0x00452898 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x0045289C | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid isrv_want_wr(isrv_state_t *state, int fd)\n{\n\tif (!FD_ISSET(fd, &state->wr)) {\n\t\tWR_COUNT++;\n\t\tFD_SET(fd, &state->wr);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x00452924 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x00452928 | E0 07 00 F9 | STR             X0, [SP,#0x10+state]\n0x0045292C | E1 07 00 B9 | STR             W1, [SP,#0x10+fd]\n0x00452930 | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x00452934 | 01 FC 00 11 | ADD             W1, W0, #0x3F ; '?'\n0x00452938 | 1F 00 00 71 | CMP             W0, #0\n0x0045293C | 20 B0 80 1A | CSEL            W0, W1, W0, LT\n0x00452940 | 00 7C 06 13 | ASR             W0, W0, #6\n0x00452944 | E1 07 40 F9 | LDR             X1, [SP,#0x10+state]\n0x00452948 | 00 7C 40 93 | SXTW            X0, W0\n0x0045294C | 00 58 00 91 | ADD             X0, X0, #0x16\n0x00452950 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00452954 | 20 00 00 8B | ADD             X0, X1, X0\n0x00452958 | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x0045295C | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x00452960 | E2 03 00 6B | NEGS            W2, W0\n0x00452964 | 00 14 00 12 | AND             W0, W0, #0x3F\n0x00452968 | 42 14 00 12 | AND             W2, W2, #0x3F\n0x0045296C | 00 44 82 5A | CSNEG           W0, W0, W2, MI\n0x00452970 | 22 00 80 D2 | MOV             X2, #1\n0x00452974 | 40 20 C0 9A | LSL             X0, X2, X0\n0x00452978 | 20 00 00 8A | AND             X0, X1, X0\n0x0045297C | 1F 00 00 F1 | CMP             X0, #0\n0x00452980 | 20 04 00 54 | B.EQ            loc_452A04\n0x00452984 | E0 07 40 F9 | LDR             X0, [SP,#0x10+state]\n0x00452988 | 00 34 40 B9 | LDR             W0, [X0,#0x34]\n0x0045298C | 01 04 00 51 | SUB             W1, W0, #1\n0x00452990 | E0 07 40 F9 | LDR             X0, [SP,#0x10+state]\n0x00452994 | 01 34 00 B9 | STR             W1, [X0,#0x34]\n0x00452998 | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x0045299C | 01 FC 00 11 | ADD             W1, W0, #0x3F ; '?'\n0x004529A0 | 1F 00 00 71 | CMP             W0, #0\n0x004529A4 | 20 B0 80 1A | CSEL            W0, W1, W0, LT\n0x004529A8 | 00 7C 06 13 | ASR             W0, W0, #6\n0x004529AC | E3 03 00 2A | MOV             W3, W0\n0x004529B0 | E1 07 40 F9 | LDR             X1, [SP,#0x10+state]\n0x004529B4 | 60 7C 40 93 | SXTW            X0, W3\n0x004529B8 | 00 58 00 91 | ADD             X0, X0, #0x16\n0x004529BC | 00 F0 7D D3 | LSL             X0, X0, #3\n0x004529C0 | 20 00 00 8B | ADD             X0, X1, X0\n0x004529C4 | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x004529C8 | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x004529CC | E2 03 00 6B | NEGS            W2, W0\n0x004529D0 | 00 14 00 12 | AND             W0, W0, #0x3F\n0x004529D4 | 42 14 00 12 | AND             W2, W2, #0x3F\n0x004529D8 | 00 44 82 5A | CSNEG           W0, W0, W2, MI\n0x004529DC | 22 00 80 D2 | MOV             X2, #1\n0x004529E0 | 40 20 C0 9A | LSL             X0, X2, X0\n0x004529E4 | E0 03 20 AA | MVN             X0, X0\n0x004529E8 | 21 00 00 8A | AND             X1, X1, X0\n0x004529EC | E2 07 40 F9 | LDR             X2, [SP,#0x10+state]\n0x004529F0 | 60 7C 40 93 | SXTW            X0, W3\n0x004529F4 | 00 58 00 91 | ADD             X0, X0, #0x16\n0x004529F8 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x004529FC | 40 00 00 8B | ADD             X0, X2, X0\n0x00452A00 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x00452A04 | 1F 20 03 D5 | NOP\n0x00452A08 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x00452A0C | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid isrv_dont_want_wr(isrv_state_t *state, int fd)\n{\n\tif (FD_ISSET(fd, &state->wr)) {\n\t\tWR_COUNT--;\n\t\tFD_CLR(fd, &state->wr);\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00452738 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x0045273C | E0 07 00 F9 | STR             X0, [SP,#0x10+state]\n0x00452740 | E1 07 00 B9 | STR             W1, [SP,#0x10+fd]\n0x00452744 | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x00452748 | 01 FC 00 11 | ADD             W1, W0, #0x3F ; '?'\n0x0045274C | 1F 00 00 71 | CMP             W0, #0\n0x00452750 | 20 B0 80 1A | CSEL            W0, W1, W0, LT\n0x00452754 | 00 7C 06 13 | ASR             W0, W0, #6\n0x00452758 | E3 03 00 2A | MOV             W3, W0\n0x0045275C | E1 07 40 F9 | LDR             X1, [SP,#0x10+state]\n0x00452760 | 60 7C 40 93 | SXTW            X0, W3\n0x00452764 | 00 18 00 91 | ADD             X0, X0, #6\n0x00452768 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x0045276C | 20 00 00 8B | ADD             X0, X1, X0\n0x00452770 | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x00452774 | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x00452778 | E2 03 00 6B | NEGS            W2, W0\n0x0045277C | 00 14 00 12 | AND             W0, W0, #0x3F\n0x00452780 | 42 14 00 12 | AND             W2, W2, #0x3F\n0x00452784 | 00 44 82 5A | CSNEG           W0, W0, W2, MI\n0x00452788 | 22 00 80 D2 | MOV             X2, #1\n0x0045278C | 40 20 C0 9A | LSL             X0, X2, X0\n0x00452790 | 21 00 00 AA | ORR             X1, X1, X0\n0x00452794 | E2 07 40 F9 | LDR             X2, [SP,#0x10+state]\n0x00452798 | 60 7C 40 93 | SXTW            X0, W3\n0x0045279C | 00 18 00 91 | ADD             X0, X0, #6\n0x004527A0 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x004527A4 | 40 00 00 8B | ADD             X0, X2, X0\n0x004527A8 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x004527AC | 1F 20 03 D5 | NOP\n0x004527B0 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x004527B4 | C0 03 5F D6 | RET",
        "output": "```c\nvoid isrv_want_rd(isrv_state_t *state, int fd)\n{\n\tFD_SET(fd, &state->rd);\n}\n```"
    },
    {
        "func_name": "overlapping_strcpy",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0040952C | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x00409530 | E0 07 00 F9 | STR             X0, [SP,#0x10+head]\n0x00409534 | E1 03 00 F9 | STR             X1, [SP,#0x10+elm]\n0x00409538 | E0 03 40 F9 | LDR             X0, [SP,#0x10+elm]\n0x0040953C | 1F 00 00 F1 | CMP             X0, #0\n0x00409540 | A0 02 00 54 | B.EQ            loc_409594\n0x00409544 | 0F 00 00 14 | B               loc_409580\n0x00409548 | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x0040954C | 00 00 40 F9 | LDR             X0, [X0]\n0x00409550 | E1 03 40 F9 | LDR             X1, [SP,#0x10+elm]\n0x00409554 | 3F 00 00 EB | CMP             X1, X0\n0x00409558 | E1 00 00 54 | B.NE            loc_409574\n0x0040955C | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x00409560 | 00 00 40 F9 | LDR             X0, [X0]\n0x00409564 | 01 00 40 F9 | LDR             X1, [X0]\n0x00409568 | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x0040956C | 01 00 00 F9 | STR             X1, [X0]\n0x00409570 | 0A 00 00 14 | B               loc_409598\n0x00409574 | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x00409578 | 00 00 40 F9 | LDR             X0, [X0]\n0x0040957C | E0 07 00 F9 | STR             X0, [SP,#0x10+head]\n0x00409580 | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x00409584 | 00 00 40 F9 | LDR             X0, [X0]\n0x00409588 | 1F 00 00 F1 | CMP             X0, #0\n0x0040958C | E1 FD FF 54 | B.NE            loc_409548\n0x00409590 | 02 00 00 14 | B               loc_409598\n0x00409594 | 1F 20 03 D5 | NOP\n0x00409598 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x0040959C | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid FAST_FUNC llist_unlink(llist_t **head, llist_t *elm)\n{\n\tif (!elm)\n\t\treturn;\n\twhile (*head) {\n\t\tif (*head == elm) {\n\t\t\t*head = (*head)->link;\n\t\t\tbreak;\n\t\t}\n\t\thead = &(*head)->link;\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x0047DA04 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x0047DA08 | E0 07 00 F9 | STR             X0, [SP,#0x10+string]\n0x0047DA0C | E1 03 00 F9 | STR             X1, [SP,#0x10+pfx]\n0x0047DA10 | 0D 00 00 14 | B               loc_47DA44\n0x0047DA14 | E0 03 40 F9 | LDR             X0, [SP,#0x10+pfx]\n0x0047DA18 | 01 04 00 91 | ADD             X1, X0, #1\n0x0047DA1C | E1 03 00 F9 | STR             X1, [SP,#0x10+pfx]\n0x0047DA20 | 01 00 40 39 | LDRB            W1, [X0]\n0x0047DA24 | E0 07 40 F9 | LDR             X0, [SP,#0x10+string]\n0x0047DA28 | 02 04 00 91 | ADD             X2, X0, #1\n0x0047DA2C | E2 07 00 F9 | STR             X2, [SP,#0x10+string]\n0x0047DA30 | 00 00 40 39 | LDRB            W0, [X0]\n0x0047DA34 | 3F 00 00 6B | CMP             W1, W0\n0x0047DA38 | 60 00 00 54 | B.EQ            loc_47DA44\n0x0047DA3C | 00 00 80 D2 | MOV             X0, #0\n0x0047DA40 | 06 00 00 14 | B               loc_47DA58\n0x0047DA44 | E0 03 40 F9 | LDR             X0, [SP,#0x10+pfx]\n0x0047DA48 | 00 00 40 39 | LDRB            W0, [X0]\n0x0047DA4C | 1F 00 00 71 | CMP             W0, #0\n0x0047DA50 | 21 FE FF 54 | B.NE            loc_47DA14\n0x0047DA54 | E0 07 40 F9 | LDR             X0, [SP,#0x10+string]\n0x0047DA58 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x0047DA5C | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic char *\nprefix(const char *string, const char *pfx)\n{\n\twhile (*pfx) {\n\t\tif (*pfx++ != *string++)\n\t\t\treturn NULL;\n\t}\n\treturn (char *) string;\n}\n\n## Example:\n\n Input assembly code:\n0x00530C00 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00530C04 | FD 03 00 91 | MOV             X29, SP\n0x00530C08 | E0 17 00 F9 | STR             X0, [SP,#0x30+dst]\n0x00530C0C | E1 13 00 F9 | STR             X1, [SP,#0x30+src]\n0x00530C10 | E2 0F 00 F9 | STR             X2, [SP,#0x30+size]\n0x00530C14 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+size]\n0x00530C18 | 1F 00 00 F1 | CMP             X0, #0\n0x00530C1C | 61 00 00 54 | B.NE            loc_530C28\n0x00530C20 | E0 17 40 F9 | LDR             X0, [SP,#0x30+dst]\n0x00530C24 | 0C 00 00 14 | B               loc_530C54\n0x00530C28 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+size]\n0x00530C2C | 00 04 00 D1 | SUB             X0, X0, #1\n0x00530C30 | E0 0F 00 F9 | STR             X0, [SP,#0x30+size]\n0x00530C34 | E1 17 40 F9 | LDR             X1, [SP,#0x30+dst]\n0x00530C38 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+size]\n0x00530C3C | 20 00 00 8B | ADD             X0, X1, X0\n0x00530C40 | 1F 00 00 39 | STRB            WZR, [X0]\n0x00530C44 | E2 0F 40 F9 | LDR             X2, [SP,#0x30+size]; n\n0x00530C48 | E1 13 40 F9 | LDR             X1, [SP,#0x30+src]; src\n0x00530C4C | E0 17 40 F9 | LDR             X0, [SP,#0x30+dst]; dest\n0x00530C50 | C0 5B FB 97 | BL              .strncpy\n0x00530C54 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00530C58 | C0 03 5F D6 | RET\n\n Output decompiled code:\nFAST_FUNC safe_strncpy(char *dst, const char *src, size_t size)\n{\n\tif (!size) return dst;\n\tdst[--size] = '\\0';\n\treturn strncpy(dst, src, size);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00530C5C | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x00530C60 | E0 07 00 F9 | STR             X0, [SP,#0x10+dst]\n0x00530C64 | E1 03 00 F9 | STR             X1, [SP,#0x10+src]\n0x00530C68 | E1 07 40 F9 | LDR             X1, [SP,#0x10+dst]\n0x00530C6C | E0 03 40 F9 | LDR             X0, [SP,#0x10+src]\n0x00530C70 | 3F 00 00 EB | CMP             X1, X0\n0x00530C74 | 00 02 00 54 | B.EQ            loc_530CB4\n0x00530C78 | 07 00 00 14 | B               loc_530C94\n0x00530C7C | E0 07 40 F9 | LDR             X0, [SP,#0x10+dst]\n0x00530C80 | 00 04 00 91 | ADD             X0, X0, #1\n0x00530C84 | E0 07 00 F9 | STR             X0, [SP,#0x10+dst]\n0x00530C88 | E0 03 40 F9 | LDR             X0, [SP,#0x10+src]\n0x00530C8C | 00 04 00 91 | ADD             X0, X0, #1\n0x00530C90 | E0 03 00 F9 | STR             X0, [SP,#0x10+src]\n0x00530C94 | E0 03 40 F9 | LDR             X0, [SP,#0x10+src]\n0x00530C98 | 01 00 40 39 | LDRB            W1, [X0]\n0x00530C9C | E0 07 40 F9 | LDR             X0, [SP,#0x10+dst]\n0x00530CA0 | 01 00 00 39 | STRB            W1, [X0]\n0x00530CA4 | E0 07 40 F9 | LDR             X0, [SP,#0x10+dst]\n0x00530CA8 | 00 00 40 39 | LDRB            W0, [X0]\n0x00530CAC | 1F 00 00 71 | CMP             W0, #0\n0x00530CB0 | 61 FE FF 54 | B.NE            loc_530C7C\n0x00530CB4 | 1F 20 03 D5 | NOP\n0x00530CB8 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x00530CBC | C0 03 5F D6 | RET",
        "output": "```c\nvoid strcpy(char *dst, const char *src)\n{\n    if (dst == src)\n        return;\n\n    do {\n        *dst = *src++;\n    } while (*dst++ != '\\0');\n}\n```"
    },
    {
        "func_name": "isrv_want_wr",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00452924 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x00452928 | E0 07 00 F9 | STR             X0, [SP,#0x10+state]\n0x0045292C | E1 07 00 B9 | STR             W1, [SP,#0x10+fd]\n0x00452930 | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x00452934 | 01 FC 00 11 | ADD             W1, W0, #0x3F ; '?'\n0x00452938 | 1F 00 00 71 | CMP             W0, #0\n0x0045293C | 20 B0 80 1A | CSEL            W0, W1, W0, LT\n0x00452940 | 00 7C 06 13 | ASR             W0, W0, #6\n0x00452944 | E1 07 40 F9 | LDR             X1, [SP,#0x10+state]\n0x00452948 | 00 7C 40 93 | SXTW            X0, W0\n0x0045294C | 00 58 00 91 | ADD             X0, X0, #0x16\n0x00452950 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00452954 | 20 00 00 8B | ADD             X0, X1, X0\n0x00452958 | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x0045295C | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x00452960 | E2 03 00 6B | NEGS            W2, W0\n0x00452964 | 00 14 00 12 | AND             W0, W0, #0x3F\n0x00452968 | 42 14 00 12 | AND             W2, W2, #0x3F\n0x0045296C | 00 44 82 5A | CSNEG           W0, W0, W2, MI\n0x00452970 | 22 00 80 D2 | MOV             X2, #1\n0x00452974 | 40 20 C0 9A | LSL             X0, X2, X0\n0x00452978 | 20 00 00 8A | AND             X0, X1, X0\n0x0045297C | 1F 00 00 F1 | CMP             X0, #0\n0x00452980 | 20 04 00 54 | B.EQ            loc_452A04\n0x00452984 | E0 07 40 F9 | LDR             X0, [SP,#0x10+state]\n0x00452988 | 00 34 40 B9 | LDR             W0, [X0,#0x34]\n0x0045298C | 01 04 00 51 | SUB             W1, W0, #1\n0x00452990 | E0 07 40 F9 | LDR             X0, [SP,#0x10+state]\n0x00452994 | 01 34 00 B9 | STR             W1, [X0,#0x34]\n0x00452998 | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x0045299C | 01 FC 00 11 | ADD             W1, W0, #0x3F ; '?'\n0x004529A0 | 1F 00 00 71 | CMP             W0, #0\n0x004529A4 | 20 B0 80 1A | CSEL            W0, W1, W0, LT\n0x004529A8 | 00 7C 06 13 | ASR             W0, W0, #6\n0x004529AC | E3 03 00 2A | MOV             W3, W0\n0x004529B0 | E1 07 40 F9 | LDR             X1, [SP,#0x10+state]\n0x004529B4 | 60 7C 40 93 | SXTW            X0, W3\n0x004529B8 | 00 58 00 91 | ADD             X0, X0, #0x16\n0x004529BC | 00 F0 7D D3 | LSL             X0, X0, #3\n0x004529C0 | 20 00 00 8B | ADD             X0, X1, X0\n0x004529C4 | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x004529C8 | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x004529CC | E2 03 00 6B | NEGS            W2, W0\n0x004529D0 | 00 14 00 12 | AND             W0, W0, #0x3F\n0x004529D4 | 42 14 00 12 | AND             W2, W2, #0x3F\n0x004529D8 | 00 44 82 5A | CSNEG           W0, W0, W2, MI\n0x004529DC | 22 00 80 D2 | MOV             X2, #1\n0x004529E0 | 40 20 C0 9A | LSL             X0, X2, X0\n0x004529E4 | E0 03 20 AA | MVN             X0, X0\n0x004529E8 | 21 00 00 8A | AND             X1, X1, X0\n0x004529EC | E2 07 40 F9 | LDR             X2, [SP,#0x10+state]\n0x004529F0 | 60 7C 40 93 | SXTW            X0, W3\n0x004529F4 | 00 58 00 91 | ADD             X0, X0, #0x16\n0x004529F8 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x004529FC | 40 00 00 8B | ADD             X0, X2, X0\n0x00452A00 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x00452A04 | 1F 20 03 D5 | NOP\n0x00452A08 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x00452A0C | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid isrv_dont_want_wr(isrv_state_t *state, int fd)\n{\n\tif (FD_ISSET(fd, &state->wr)) {\n\t\tWR_COUNT--;\n\t\tFD_CLR(fd, &state->wr);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x004528A0 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x004528A4 | E0 07 00 F9 | STR             X0, [SP,#0x10+state]\n0x004528A8 | E1 07 00 B9 | STR             W1, [SP,#0x10+fd]\n0x004528AC | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x004528B0 | 01 FC 00 11 | ADD             W1, W0, #0x3F ; '?'\n0x004528B4 | 1F 00 00 71 | CMP             W0, #0\n0x004528B8 | 20 B0 80 1A | CSEL            W0, W1, W0, LT\n0x004528BC | 00 7C 06 13 | ASR             W0, W0, #6\n0x004528C0 | E3 03 00 2A | MOV             W3, W0\n0x004528C4 | E1 07 40 F9 | LDR             X1, [SP,#0x10+state]\n0x004528C8 | 60 7C 40 93 | SXTW            X0, W3\n0x004528CC | 00 18 00 91 | ADD             X0, X0, #6\n0x004528D0 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x004528D4 | 20 00 00 8B | ADD             X0, X1, X0\n0x004528D8 | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x004528DC | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x004528E0 | E2 03 00 6B | NEGS            W2, W0\n0x004528E4 | 00 14 00 12 | AND             W0, W0, #0x3F\n0x004528E8 | 42 14 00 12 | AND             W2, W2, #0x3F\n0x004528EC | 00 44 82 5A | CSNEG           W0, W0, W2, MI\n0x004528F0 | 22 00 80 D2 | MOV             X2, #1\n0x004528F4 | 40 20 C0 9A | LSL             X0, X2, X0\n0x004528F8 | E0 03 20 AA | MVN             X0, X0\n0x004528FC | 21 00 00 8A | AND             X1, X1, X0\n0x00452900 | E2 07 40 F9 | LDR             X2, [SP,#0x10+state]\n0x00452904 | 60 7C 40 93 | SXTW            X0, W3\n0x00452908 | 00 18 00 91 | ADD             X0, X0, #6\n0x0045290C | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00452910 | 40 00 00 8B | ADD             X0, X2, X0\n0x00452914 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x00452918 | 1F 20 03 D5 | NOP\n0x0045291C | FF 43 00 91 | ADD             SP, SP, #0x10\n0x00452920 | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid isrv_dont_want_rd(isrv_state_t *state, int fd)\n{\n\tFD_CLR(fd, &state->rd);\n}\n\n## Example:\n\n Input assembly code:\n0x00452738 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x0045273C | E0 07 00 F9 | STR             X0, [SP,#0x10+state]\n0x00452740 | E1 07 00 B9 | STR             W1, [SP,#0x10+fd]\n0x00452744 | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x00452748 | 01 FC 00 11 | ADD             W1, W0, #0x3F ; '?'\n0x0045274C | 1F 00 00 71 | CMP             W0, #0\n0x00452750 | 20 B0 80 1A | CSEL            W0, W1, W0, LT\n0x00452754 | 00 7C 06 13 | ASR             W0, W0, #6\n0x00452758 | E3 03 00 2A | MOV             W3, W0\n0x0045275C | E1 07 40 F9 | LDR             X1, [SP,#0x10+state]\n0x00452760 | 60 7C 40 93 | SXTW            X0, W3\n0x00452764 | 00 18 00 91 | ADD             X0, X0, #6\n0x00452768 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x0045276C | 20 00 00 8B | ADD             X0, X1, X0\n0x00452770 | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x00452774 | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x00452778 | E2 03 00 6B | NEGS            W2, W0\n0x0045277C | 00 14 00 12 | AND             W0, W0, #0x3F\n0x00452780 | 42 14 00 12 | AND             W2, W2, #0x3F\n0x00452784 | 00 44 82 5A | CSNEG           W0, W0, W2, MI\n0x00452788 | 22 00 80 D2 | MOV             X2, #1\n0x0045278C | 40 20 C0 9A | LSL             X0, X2, X0\n0x00452790 | 21 00 00 AA | ORR             X1, X1, X0\n0x00452794 | E2 07 40 F9 | LDR             X2, [SP,#0x10+state]\n0x00452798 | 60 7C 40 93 | SXTW            X0, W3\n0x0045279C | 00 18 00 91 | ADD             X0, X0, #6\n0x004527A0 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x004527A4 | 40 00 00 8B | ADD             X0, X2, X0\n0x004527A8 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x004527AC | 1F 20 03 D5 | NOP\n0x004527B0 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x004527B4 | C0 03 5F D6 | RET\n\n Output decompiled code:\nvoid isrv_want_rd(isrv_state_t *state, int fd)\n{\n\tFD_SET(fd, &state->rd);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004527B8 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x004527BC | E0 07 00 F9 | STR             X0, [SP,#0x10+state]\n0x004527C0 | E1 07 00 B9 | STR             W1, [SP,#0x10+fd]\n0x004527C4 | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x004527C8 | 01 FC 00 11 | ADD             W1, W0, #0x3F ; '?'\n0x004527CC | 1F 00 00 71 | CMP             W0, #0\n0x004527D0 | 20 B0 80 1A | CSEL            W0, W1, W0, LT\n0x004527D4 | 00 7C 06 13 | ASR             W0, W0, #6\n0x004527D8 | E1 07 40 F9 | LDR             X1, [SP,#0x10+state]\n0x004527DC | 00 7C 40 93 | SXTW            X0, W0\n0x004527E0 | 00 58 00 91 | ADD             X0, X0, #0x16\n0x004527E4 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x004527E8 | 20 00 00 8B | ADD             X0, X1, X0\n0x004527EC | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x004527F0 | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x004527F4 | E2 03 00 6B | NEGS            W2, W0\n0x004527F8 | 00 14 00 12 | AND             W0, W0, #0x3F\n0x004527FC | 42 14 00 12 | AND             W2, W2, #0x3F\n0x00452800 | 00 44 82 5A | CSNEG           W0, W0, W2, MI\n0x00452804 | 22 00 80 D2 | MOV             X2, #1\n0x00452808 | 40 20 C0 9A | LSL             X0, X2, X0\n0x0045280C | 20 00 00 8A | AND             X0, X1, X0\n0x00452810 | 1F 00 00 F1 | CMP             X0, #0\n0x00452814 | 01 04 00 54 | B.NE            loc_452894\n0x00452818 | E0 07 40 F9 | LDR             X0, [SP,#0x10+state]\n0x0045281C | 00 34 40 B9 | LDR             W0, [X0,#0x34]\n0x00452820 | 01 04 00 11 | ADD             W1, W0, #1\n0x00452824 | E0 07 40 F9 | LDR             X0, [SP,#0x10+state]\n0x00452828 | 01 34 00 B9 | STR             W1, [X0,#0x34]\n0x0045282C | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x00452830 | 01 FC 00 11 | ADD             W1, W0, #0x3F ; '?'\n0x00452834 | 1F 00 00 71 | CMP             W0, #0\n0x00452838 | 20 B0 80 1A | CSEL            W0, W1, W0, LT\n0x0045283C | 00 7C 06 13 | ASR             W0, W0, #6\n0x00452840 | E3 03 00 2A | MOV             W3, W0\n0x00452844 | E1 07 40 F9 | LDR             X1, [SP,#0x10+state]\n0x00452848 | 60 7C 40 93 | SXTW            X0, W3\n0x0045284C | 00 58 00 91 | ADD             X0, X0, #0x16\n0x00452850 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00452854 | 20 00 00 8B | ADD             X0, X1, X0\n0x00452858 | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x0045285C | E0 07 40 B9 | LDR             W0, [SP,#0x10+fd]\n0x00452860 | E2 03 00 6B | NEGS            W2, W0\n0x00452864 | 00 14 00 12 | AND             W0, W0, #0x3F\n0x00452868 | 42 14 00 12 | AND             W2, W2, #0x3F\n0x0045286C | 00 44 82 5A | CSNEG           W0, W0, W2, MI\n0x00452870 | 22 00 80 D2 | MOV             X2, #1\n0x00452874 | 40 20 C0 9A | LSL             X0, X2, X0\n0x00452878 | 21 00 00 AA | ORR             X1, X1, X0\n0x0045287C | E2 07 40 F9 | LDR             X2, [SP,#0x10+state]\n0x00452880 | 60 7C 40 93 | SXTW            X0, W3\n0x00452884 | 00 58 00 91 | ADD             X0, X0, #0x16\n0x00452888 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x0045288C | 40 00 00 8B | ADD             X0, X2, X0\n0x00452890 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x00452894 | 1F 20 03 D5 | NOP\n0x00452898 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x0045289C | C0 03 5F D6 | RET",
        "output": "```c\nvoid isrv_want_wr(isrv_state_t *state, int fd)\n{\n\tif (!FD_ISSET(fd, &state->wr)) {\n\t\tWR_COUNT++;\n\t\tFD_SET(fd, &state->wr);\n\t}\n}\n```"
    },
    {
        "func_name": "my_xstrtod",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0040A098 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0040A09C | FD 03 00 91 | MOV             X29, SP\n0x0040A0A0 | E0 0F 00 F9 | STR             X0, [SP,#0x20+dst]\n0x0040A0A4 | E1 0B 00 F9 | STR             X1, [SP,#0x20+src]\n0x0040A0A8 | 02 02 80 D2 | MOV             X2, #0x10; n\n0x0040A0AC | E1 0B 40 F9 | LDR             X1, [SP,#0x20+src]; src\n0x0040A0B0 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+dst]; dest\n0x0040A0B4 | A7 F6 FF 97 | BL              .strncpy\n0x0040A0B8 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0040A0BC | C0 03 5F D6 | RET\n\n Output decompiled code:\nFAST_FUNC strncpy_IFNAMSIZ(char *dst, const char *src)\n{\n#ifndef IFNAMSIZ\n\tenum { IFNAMSIZ = 16 };\n#endif\n\treturn strncpy(dst, src, IFNAMSIZ);\n}\n\n## Example:\n\n Input assembly code:\n0x004F98A0 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x004F98A4 | FD 03 00 91 | MOV             X29, SP\n0x004F98A8 | E0 0F 00 F9 | STR             X0, [SP,#0x20+fn]\n0x004F98AC | E1 0B 00 F9 | STR             X1, [SP,#0x20+fn_stat]\n0x004F98B0 | 60 F8 FF D0 | ADRP            X0, #stat64_0@PAGE\n0x004F98B4 | 02 C0 3A 91 | ADD             X2, X0, #stat64_0@PAGEOFF; sf\n0x004F98B8 | E1 0B 40 F9 | LDR             X1, [SP,#0x20+fn_stat]; fn_stat\n0x004F98BC | E0 0F 40 F9 | LDR             X0, [SP,#0x20+fn]; fn\n0x004F98C0 | D5 FF FF 97 | BL              cp_mv_stat2\n0x004F98C4 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004F98C8 | C0 03 5F D6 | RET\n\n Output decompiled code:\nint FAST_FUNC cp_mv_stat(const char *fn, struct stat *fn_stat)\n{\n\treturn cp_mv_stat2(fn, fn_stat, stat);\n}\n\n## Example:\n\n Input assembly code:\n0x004EF150 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004EF154 | FD 03 00 91 | MOV             X29, SP\n0x004EF158 | E0 0F 00 F9 | STR             X0, [SP,#0x30+arg]\n0x004EF15C | E1 A3 00 91 | ADD             X1, SP, #0x30+result; result\n0x004EF160 | 00 00 00 90 | ADRP            X0, #conv_strtoull@PAGE\n0x004EF164 | 02 30 01 91 | ADD             X2, X0, #conv_strtoull@PAGEOFF; convert\n0x004EF168 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+arg]; arg\n0x004EF16C | 8F FF FF 97 | BL              multiconvert\n0x004EF170 | 1F 00 00 71 | CMP             W0, #0\n0x004EF174 | 40 00 00 54 | B.EQ            loc_4EF17C\n0x004EF178 | FF 17 00 F9 | STR             XZR, [SP,#0x30+result]\n0x004EF17C | E0 17 40 F9 | LDR             X0, [SP,#0x30+result]\n0x004EF180 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004EF184 | C0 03 5F D6 | RET\n\n Output decompiled code:\nstatic unsigned long long my_xstrtoull(const char *arg)\n{\n\tunsigned long long result;\n\tif (multiconvert(arg, &result, conv_strtoull))\n\t\tresult = 0;\n\treturn result;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004EF1C0 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004EF1C4 | FD 03 00 91 | MOV             X29, SP\n0x004EF1C8 | E0 0F 00 F9 | STR             X0, [SP,#0x30+arg]\n0x004EF1CC | E1 A3 00 91 | ADD             X1, SP, #0x30+result; result\n0x004EF1D0 | 00 00 00 90 | ADRP            X0, #conv_strtod@PAGE\n0x004EF1D4 | 02 C0 03 91 | ADD             X2, X0, #conv_strtod@PAGEOFF; convert\n0x004EF1D8 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+arg]; arg\n0x004EF1DC | 73 FF FF 97 | BL              multiconvert\n0x004EF1E0 | E0 17 40 F9 | LDR             X0, [SP,#0x30+result]\n0x004EF1E4 | 00 00 67 9E | FMOV            D0, X0\n0x004EF1E8 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004EF1EC | C0 03 5F D6 | RET",
        "output": "```c\nstatic double my_xstrtod(const char *arg)\n{\n\tdouble result;\n\tmulticonvert(arg, &result, conv_strtod);\n\treturn result;\n}\n```"
    }
]
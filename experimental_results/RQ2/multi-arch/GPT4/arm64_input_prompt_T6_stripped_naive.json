[
    {
        "func_name": "base64_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F8C90 | FD 7B B3 A9 | STP             X29, X30, [SP,#var_D0]!\n0x004F8C94 | FD 03 00 91 | MOV             X29, SP\n0x004F8C98 | E0 1F 00 B9 | STR             W0, [SP,#0xD0+argc]\n0x004F8C9C | E1 0B 00 F9 | STR             X1, [SP,#0xD0+argv]\n0x004F8CA0 | E0 04 00 B0 00 60 10 91 | ADRL            X0, opt_complementary\n0x004F8CA8 | 01 03 00 F0 21 80 31 91 | ADRL            X1, a1_18; \"?1\"\n0x004F8CB0 | 01 00 00 F9 | STR             X1, [X0]\n0x004F8CB4 | 00 03 00 F0 | ADRP            X0, #aD_31@PAGE; \"d\"\n0x004F8CB8 | 01 80 32 91 | ADD             X1, X0, #aD_31@PAGEOFF; \"d\"\n0x004F8CBC | E0 0B 40 F9 | LDR             X0, [SP,#0xD0+argv]; argv\n0x004F8CC0 | 07 9E 00 94 | BL              getopt32\n0x004F8CC4 | E0 CF 00 B9 | STR             W0, [SP,#0xD0+opts]\n0x004F8CC8 | C0 04 00 D0 00 40 39 91 | ADRL            X0, optind__GLIBC_2.17\n0x004F8CD0 | 00 00 40 B9 | LDR             W0, [X0]\n0x004F8CD4 | 00 7C 40 93 | SXTW            X0, W0\n0x004F8CD8 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x004F8CDC | E1 0B 40 F9 | LDR             X1, [SP,#0xD0+argv]\n0x004F8CE0 | 20 00 00 8B | ADD             X0, X1, X0\n0x004F8CE4 | E0 0B 00 F9 | STR             X0, [SP,#0xD0+argv]\n0x004F8CE8 | E0 0B 40 F9 | LDR             X0, [SP,#0xD0+argv]\n0x004F8CEC | 00 00 40 F9 | LDR             X0, [X0]\n0x004F8CF0 | 1F 00 00 F1 | CMP             X0, #0\n0x004F8CF4 | 01 01 00 54 | B.NE            loc_4F8D14\n0x004F8CF8 | E0 0B 40 F9 | LDR             X0, [SP,#0xD0+argv]\n0x004F8CFC | 00 20 00 D1 | SUB             X0, X0, #8\n0x004F8D00 | E0 0B 00 F9 | STR             X0, [SP,#0xD0+argv]\n0x004F8D04 | E0 0B 40 F9 | LDR             X0, [SP,#0xD0+argv]\n0x004F8D08 | 01 03 00 F0 21 C0 31 91 | ADRL            X1, asc_55BC70; \"-\"\n0x004F8D10 | 01 00 00 F9 | STR             X1, [X0]\n0x004F8D14 | E0 0B 40 F9 | LDR             X0, [SP,#0xD0+argv]\n0x004F8D18 | 00 00 40 F9 | LDR             X0, [X0]; filename\n0x004F8D1C | 37 EB 00 94 | BL              xfopen_stdin\n0x004F8D20 | E0 63 00 F9 | STR             X0, [SP,#0xD0+src_stream]\n0x004F8D24 | E0 CF 40 B9 | LDR             W0, [SP,#0xD0+opts]\n0x004F8D28 | 1F 00 00 71 | CMP             W0, #0\n0x004F8D2C | 20 01 00 54 | B.EQ            loc_4F8D50\n0x004F8D30 | C0 04 00 D0 00 60 39 91 | ADRL            X0, stdout__GLIBC_2.17\n0x004F8D38 | 00 00 40 F9 | LDR             X0, [X0]\n0x004F8D3C | E2 1F 80 52 | MOV             W2, #0xFF; flags\n0x004F8D40 | E1 03 00 AA | MOV             X1, X0; dst_stream\n0x004F8D44 | E0 63 40 F9 | LDR             X0, [SP,#0xD0+src_stream]; src_stream\n0x004F8D48 | 02 EA 00 94 | BL              read_base64\n0x004F8D4C | 2F 00 00 14 | B               loc_4F8E08\n0x004F8D50 | E0 63 40 F9 | LDR             X0, [SP,#0xD0+src_stream]; stream\n0x004F8D54 | DF 37 FC 97 | BL              .fileno\n0x004F8D58 | E0 BF 00 B9 | STR             W0, [SP,#0xD0+src_fd]\n0x004F8D5C | E0 83 00 91 | ADD             X0, SP, #0xD0+src_buf\n0x004F8D60 | 22 07 80 D2 | MOV             X2, #0x39 ; '9'; len\n0x004F8D64 | E1 03 00 AA | MOV             X1, X0; buf\n0x004F8D68 | E0 BF 40 B9 | LDR             W0, [SP,#0xD0+src_fd]; fd\n0x004F8D6C | 55 4C FC 97 | BL              full_read\n0x004F8D70 | E0 5B 00 F9 | STR             X0, [SP,#0xD0+size]\n0x004F8D74 | E0 5B 40 F9 | LDR             X0, [SP,#0xD0+size]\n0x004F8D78 | 1F 00 00 F1 | CMP             X0, #0\n0x004F8D7C | 40 04 00 54 | B.EQ            loc_4F8E04\n0x004F8D80 | E0 5B 40 F9 | LDR             X0, [SP,#0xD0+size]\n0x004F8D84 | 1F 00 00 F1 | CMP             X0, #0\n0x004F8D88 | 8A 00 00 54 | B.GE            loc_4F8D98\n0x004F8D8C | 00 03 00 F0 00 A0 32 91 | ADRL            X0, aReadError_11; \"read error\"\n0x004F8D94 | 79 42 FC 97 | BL              bb_perror_msg_and_die\n0x004F8D98 | E0 5B 40 F9 | LDR             X0, [SP,#0xD0+size]\n0x004F8D9C | E2 03 00 2A | MOV             W2, W0; length\n0x004F8DA0 | E1 83 00 91 | ADD             X1, SP, #0xD0+src_buf; src\n0x004F8DA4 | E4 83 01 91 | ADD             X4, SP, #0xD0+dst_buf\n0x004F8DA8 | 40 03 00 90 | ADRP            X0, #bb_uuenc_tbl_base64@PAGE; \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm\"...\n0x004F8DAC | 03 40 14 91 | ADD             X3, X0, #bb_uuenc_tbl_base64@PAGEOFF; \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm\"...\n0x004F8DB0 | E0 03 04 AA | MOV             X0, X4; p\n0x004F8DB4 | 10 E9 00 94 | BL              bb_uuencode\n0x004F8DB8 | E0 5B 40 F9 | LDR             X0, [SP,#0xD0+size]\n0x004F8DBC | 01 08 00 91 | ADD             X1, X0, #2\n0x004F8DC0 | E0 F3 01 B2 60 55 95 F2 | MOV             X0, #0xAAAAAAAAAAAAAAAB\n0x004F8DC8 | 20 7C C0 9B | UMULH           X0, X1, X0\n0x004F8DCC | 00 FC 41 D3 | LSR             X0, X0, #1\n0x004F8DD0 | 01 F4 7E D3 | LSL             X1, X0, #2\n0x004F8DD4 | E0 83 01 91 | ADD             X0, SP, #0xD0+dst_buf\n0x004F8DD8 | E2 03 01 AA | MOV             X2, X1; count\n0x004F8DDC | E1 03 00 AA | MOV             X1, X0; buf\n0x004F8DE0 | 20 00 80 52 | MOV             W0, #1; fd\n0x004F8DE4 | F0 47 FC 97 | BL              xwrite\n0x004F8DE8 | 40 01 80 52 | MOV             W0, #0xA; ch\n0x004F8DEC | 6A 48 FC 97 | BL              bb_putchar\n0x004F8DF0 | C0 04 00 D0 00 60 39 91 | ADRL            X0, stdout__GLIBC_2.17\n0x004F8DF8 | 00 00 40 F9 | LDR             X0, [X0]; stream\n0x004F8DFC | 7D 3A FC 97 | BL              .fflush\n0x004F8E00 | D7 FF FF 17 | B               loc_4F8D5C\n0x004F8E04 | 1F 20 03 D5 | NOP\n0x004F8E08 | 00 00 80 52 | MOV             W0, #0; retval\n0x004F8E0C | DB 99 00 94 | BL              fflush_stdout_and_exit",
        "output": "```c\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n\nextern char **environ;\nextern char *optarg;\nextern int optind, opterr, optopt;\nextern int getopt(int argc, char * const argv[], const char *optstring);\n\nextern void getopt32(void);\nextern void xfopen_stdin(void);\nextern void read_base64(void);\nextern void full_read(void);\nextern void bb_perror_msg_and_die(void);\nextern void bb_uuencode(void);\nextern void xwrite(void);\nextern void bb_putchar(void);\nextern void fflush_stdout_and_exit(void);\n\nint main(int argc, char **argv) {\n    char *opt_complementary = \"?1\";\n    char *a1_18 = \"?1\";\n    char *aD_31 = \"d\";\n    char *optind__GLIBC_2_17;\n    char *stdout__GLIBC_2_17;\n    char *asc_55BC70 = \"-\";\n    char *aReadError_11 = \"read error\";\n    char *bb_uuenc_tbl_base64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    char *src_buf, *dst_buf;\n    int opts, src_fd, src_stream, size;\n    FILE *stream;\n\n    argv[0] = aD_31;\n    getopt32();\n    opts = optind;\n    optind__GLIBC_2_17 = (char *)((long)argv + ((long)optind << 3));\n    argv = (char **)optind__GLIBC_2_17;\n    if (*argv == NULL) {\n        argv--;\n        *argv = asc_55BC70;\n    }\n    filename = *argv;\n    xfopen_stdin();\n    src_stream = (int)filename;\n    if (opts == 0) {\n        stream = (FILE *)src_stream;\n        src_fd = fileno(stream);\n        src_buf = (char *)malloc(57);\n        size = full_read(src_fd, src_buf, 57);\n        if (size == 0) {\n            free(src_buf);\n            fflush_stdout_and_exit();\n        }\n        if (size < 0) {\n            bb_perror_msg_and_die();\n        }\n        dst_buf = (char *)malloc(((size + 2) / 3) * 4);\n        bb_uuencode(dst_buf, src_buf, size, bb_uuenc_tbl_base64);\n        xwrite(1, dst_buf, ((size + 2) / 3) * 4);\n        bb_putchar('\\n');\n        stdout__GLIBC_2_17 = (char *)stdout;\n        fflush(stdout__GLIBC_2_17);\n        free(src_buf);\n        free(dst_buf);\n        goto loc_4F8D5C;\n    } else {\n        stdout__GLIBC_2_17 = (char *)stdout;\n        src_stream = (int)filename;\n        read_base64(src_stream, stdout__GLIBC_2_17, 0xFF);\n    }\n    fflush_stdout_and_exit();\n}\n```"
    },
    {
        "func_name": "open_file_and_read_lines",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00421B7C | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00421B80 | FD 03 00 91 | MOV             X29, SP\n0x00421B84 | F3 0B 00 F9 | STR             X19, [SP,#0x20+var_10]\n0x00421B88 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421B90 | 00 00 40 F9 | LDR             X0, [X0]\n0x00421B94 | 00 34 40 F9 | LDR             X0, [X0,#0x68]\n0x00421B98 | 1F 00 00 F1 | CMP             X0, #0\n0x00421B9C | 40 01 00 54 | B.EQ            loc_421BC4\n0x00421BA0 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421BA8 | 00 00 40 F9 | LDR             X0, [X0]\n0x00421BAC | 00 34 40 F9 | LDR             X0, [X0,#0x68]; pathname\n0x00421BB0 | 01 00 80 52 | MOV             W1, #0; flags\n0x00421BB4 | EB A3 FF 97 | BL              xopen\n0x00421BB8 | 01 00 80 52 | MOV             W1, #0; to\n0x00421BBC | 69 A4 FF 97 | BL              xmove_fd\n0x00421BC0 | 08 00 00 14 | B               loc_421BE0\n0x00421BC4 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421BCC | 13 00 40 F9 | LDR             X19, [X0]\n0x00421BD0 | E0 09 00 F0 00 64 1F 91 | ADRL            X0, bb_msg_standard_input; \"standard input\"\n0x00421BD8 | 76 A3 FF 97 | BL              xstrdup\n0x00421BDC | 60 36 00 F9 | STR             X0, [X19,#0x68]\n0x00421BE0 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421BE8 | 00 00 40 F9 | LDR             X0, [X0]\n0x00421BEC | 1F 1C 00 F9 | STR             XZR, [X0,#0x38]\n0x00421BF0 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421BF8 | 00 00 40 F9 | LDR             X0, [X0]\n0x00421BFC | 1F 20 00 F9 | STR             XZR, [X0,#0x40]\n0x00421C00 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421C08 | 00 00 40 F9 | LDR             X0, [X0]\n0x00421C0C | 1F 08 00 F9 | STR             XZR, [X0,#0x10]\n0x00421C10 | A0 0B 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00421C18 | 00 00 40 F9 | LDR             X0, [X0]\n0x00421C1C | 21 00 80 52 | MOV             W1, #1\n0x00421C20 | 01 58 01 B9 | STR             W1, [X0,#0x158]\n0x00421C24 | EC F9 FF 97 | BL              read_lines\n0x00421C28 | 1F 20 03 D5 | NOP\n0x00421C2C | F3 0B 40 F9 | LDR             X19, [SP,#0x20+var_10]\n0x00421C30 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00421C34 | C0 03 5F D6 | RET",
        "output": "```c\n#include <stddef.h>\n\nextern void xopen(const char *pathname, int flags);\nextern void xmove_fd(int fd, int to);\nextern char *xstrdup(const char *s);\nextern void read_lines(void);\n\ntypedef struct {\n    char *ptr_to_globals;\n    char padding1[0x38 - sizeof(char *)];\n    int zero1;\n    int zero2;\n    char padding2[0x10 - sizeof(int)];\n    int one;\n    char padding3[0x158 - 0x10 - sizeof(int)];\n    int read_lines_flag;\n} Globals;\n\nGlobals globals;\n\nvoid function() {\n    if (globals.ptr_to_globals) {\n        char *pathname = globals.ptr_to_globals;\n        xopen(pathname, 0);\n        xmove_fd(0, 0);\n    } else {\n        globals.ptr_to_globals = xstrdup(\"standard input\");\n    }\n\n    globals.zero1 = 0;\n    globals.zero2 = 0;\n    globals.one = 0;\n    globals.read_lines_flag = 1;\n\n    read_lines();\n}\n```"
    },
    {
        "func_name": "crc32_block_endian0",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0051D21C | FF C3 00 D1 | SUB             SP, SP, #0x30\n0x0051D220 | E0 1F 00 B9 | STR             W0, [SP,#0x30+val]\n0x0051D224 | E1 0B 00 F9 | STR             X1, [SP,#0x30+buf]\n0x0051D228 | E2 1B 00 B9 | STR             W2, [SP,#0x30+len]\n0x0051D22C | E3 07 00 F9 | STR             X3, [SP,#0x30+crc_table]\n0x0051D230 | E0 1B 40 B9 | LDR             W0, [SP,#0x30+len]\n0x0051D234 | E1 0B 40 F9 | LDR             X1, [SP,#0x30+buf]\n0x0051D238 | 20 00 00 8B | ADD             X0, X1, X0\n0x0051D23C | E0 17 00 F9 | STR             X0, [SP,#0x30+end]\n0x0051D240 | 13 00 00 14 | B               loc_51D28C\n0x0051D244 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+val]\n0x0051D248 | 01 1C 00 12 | AND             W1, W0, #0xFF\n0x0051D24C | E0 0B 40 F9 | LDR             X0, [SP,#0x30+buf]\n0x0051D250 | 00 00 40 39 | LDRB            W0, [X0]\n0x0051D254 | 20 00 00 4A | EOR             W0, W1, W0\n0x0051D258 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x0051D25C | 00 1C 40 92 | AND             X0, X0, #0xFF\n0x0051D260 | 00 F4 7E D3 | LSL             X0, X0, #2\n0x0051D264 | E1 07 40 F9 | LDR             X1, [SP,#0x30+crc_table]\n0x0051D268 | 20 00 00 8B | ADD             X0, X1, X0\n0x0051D26C | 01 00 40 B9 | LDR             W1, [X0]\n0x0051D270 | E2 1F 40 B9 | LDR             W2, [SP,#0x30+val]\n0x0051D274 | 40 7C 08 53 | LSR             W0, W2, #8\n0x0051D278 | 20 00 00 4A | EOR             W0, W1, W0\n0x0051D27C | E0 1F 00 B9 | STR             W0, [SP,#0x30+val]\n0x0051D280 | E0 0B 40 F9 | LDR             X0, [SP,#0x30+buf]\n0x0051D284 | 00 04 00 91 | ADD             X0, X0, #1\n0x0051D288 | E0 0B 00 F9 | STR             X0, [SP,#0x30+buf]\n0x0051D28C | E1 0B 40 F9 | LDR             X1, [SP,#0x30+buf]\n0x0051D290 | E0 17 40 F9 | LDR             X0, [SP,#0x30+end]\n0x0051D294 | 3F 00 00 EB | CMP             X1, X0\n0x0051D298 | 61 FD FF 54 | B.NE            loc_51D244\n0x0051D29C | E0 1F 40 B9 | LDR             W0, [SP,#0x30+val]\n0x0051D2A0 | FF C3 00 91 | ADD             SP, SP, #0x30 ; '0'\n0x0051D2A4 | C0 03 5F D6 | RET",
        "output": "```c\nunsigned int calculate_crc(unsigned int val, unsigned char *buf, unsigned int len, unsigned int *crc_table) {\n    unsigned char *end = buf + len;\n    while (buf < end) {\n        val = crc_table[(val ^ *buf++) & 0xFF] ^ (val >> 8);\n    }\n    return val;\n}\n```"
    },
    {
        "func_name": "write_new_utmp",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00532EB8 | FD 7B A3 A9 | STP             X29, X30, [SP,#var_1D0]!\n0x00532EBC | FD 03 00 91 | MOV             X29, SP\n0x00532EC0 | E0 2F 00 B9 | STR             W0, [SP,#0x1D0+pid]\n0x00532EC4 | E1 2B 00 B9 | STR             W1, [SP,#0x1D0+new_type]\n0x00532EC8 | E2 13 00 F9 | STR             X2, [SP,#0x1D0+tty_name]\n0x00532ECC | E3 0F 00 F9 | STR             X3, [SP,#0x1D0+username]\n0x00532ED0 | E4 0B 00 F9 | STR             X4, [SP,#0x1D0+hostname]\n0x00532ED4 | E0 C3 00 91 | ADD             X0, SP, #0x1D0+utent; s\n0x00532ED8 | 02 32 80 D2 | MOV             X2, #0x190; n\n0x00532EDC | 01 00 80 52 | MOV             W1, #0; c\n0x00532EE0 | 0C 50 FB 97 | BL              .memset\n0x00532EE4 | E0 2F 40 B9 | LDR             W0, [SP,#0x1D0+pid]\n0x00532EE8 | E0 37 00 B9 | STR             W0, [SP,#0x1D0+utent.ut_pid]\n0x00532EEC | E0 2B 40 B9 | LDR             W0, [SP,#0x1D0+new_type]\n0x00532EF0 | 00 3C 00 13 | SXTH            W0, W0\n0x00532EF4 | E0 63 00 79 | STRH            W0, [SP,#0x1D0+utent]\n0x00532EF8 | E0 13 40 F9 | LDR             X0, [SP,#0x1D0+tty_name]; tty_name\n0x00532EFC | 90 5A FB 97 | BL              skip_dev_pfx\n0x00532F00 | E0 13 00 F9 | STR             X0, [SP,#0x1D0+tty_name]\n0x00532F04 | E0 C3 00 91 | ADD             X0, SP, #0x1D0+utent\n0x00532F08 | 00 20 00 91 | ADD             X0, X0, #8; dst\n0x00532F0C | 02 04 80 D2 | MOV             X2, #0x20 ; ' '; size\n0x00532F10 | E1 13 40 F9 | LDR             X1, [SP,#0x1D0+tty_name]; src\n0x00532F14 | 3B F7 FF 97 | BL              safe_strncpy\n0x00532F18 | E0 0F 40 F9 | LDR             X0, [SP,#0x1D0+username]\n0x00532F1C | 1F 00 00 F1 | CMP             X0, #0\n0x00532F20 | C0 00 00 54 | B.EQ            loc_532F38\n0x00532F24 | E0 C3 00 91 | ADD             X0, SP, #0x1D0+utent\n0x00532F28 | 00 B0 00 91 | ADD             X0, X0, #0x2C ; ','; dst\n0x00532F2C | 02 04 80 D2 | MOV             X2, #0x20 ; ' '; size\n0x00532F30 | E1 0F 40 F9 | LDR             X1, [SP,#0x1D0+username]; src\n0x00532F34 | 33 F7 FF 97 | BL              safe_strncpy\n0x00532F38 | E0 0B 40 F9 | LDR             X0, [SP,#0x1D0+hostname]\n0x00532F3C | 1F 00 00 F1 | CMP             X0, #0\n0x00532F40 | C0 00 00 54 | B.EQ            loc_532F58\n0x00532F44 | E0 C3 00 91 | ADD             X0, SP, #0x1D0+utent\n0x00532F48 | 00 30 01 91 | ADD             X0, X0, #0x4C ; 'L'; dst\n0x00532F4C | 02 20 80 D2 | MOV             X2, #0x100; size\n0x00532F50 | E1 0B 40 F9 | LDR             X1, [SP,#0x1D0+hostname]; src\n0x00532F54 | 2B F7 FF 97 | BL              safe_strncpy\n0x00532F58 | 00 00 80 D2 | MOV             X0, #0; timer\n0x00532F5C | 9D 4F FB 97 | BL              .time\n0x00532F60 | E0 C7 00 F9 | STR             X0, [SP,#0x1D0+utent.ut_tv]\n0x00532F64 | E0 C3 00 91 | ADD             X0, SP, #0x1D0+utent\n0x00532F68 | 00 A0 00 91 | ADD             X0, X0, #0x28 ; '('\n0x00532F6C | E0 E7 00 F9 | STR             X0, [SP,#0x1D0+id]\n0x00532F70 | 80 00 80 52 | MOV             W0, #4\n0x00532F74 | E0 C7 01 B9 | STR             W0, [SP,#0x1D0+width]\n0x00532F78 | E0 13 40 F9 | LDR             X0, [SP,#0x1D0+tty_name]\n0x00532F7C | 00 00 40 39 | LDRB            W0, [X0]\n0x00532F80 | 1F C0 01 71 | CMP             W0, #0x70 ; 'p'\n0x00532F84 | 21 01 00 54 | B.NE            loc_532FA8\n0x00532F88 | E0 E7 40 F9 | LDR             X0, [SP,#0x1D0+id]\n0x00532F8C | 01 04 00 91 | ADD             X1, X0, #1\n0x00532F90 | E1 E7 00 F9 | STR             X1, [SP,#0x1D0+id]\n0x00532F94 | 01 0E 80 52 | MOV             W1, #0x70 ; 'p'\n0x00532F98 | 01 00 00 39 | STRB            W1, [X0]\n0x00532F9C | E0 C7 41 B9 | LDR             W0, [SP,#0x1D0+width]\n0x00532FA0 | 00 04 00 51 | SUB             W0, W0, #1\n0x00532FA4 | E0 C7 01 B9 | STR             W0, [SP,#0x1D0+width]\n0x00532FA8 | E0 13 40 F9 | LDR             X0, [SP,#0x1D0+tty_name]; s\n0x00532FAC | E9 4D FB 97 | BL              .strlen\n0x00532FB0 | 1F 0C 00 F1 | CMP             X0, #3\n0x00532FB4 | 89 00 00 54 | B.LS            loc_532FC4\n0x00532FB8 | E0 13 40 F9 | LDR             X0, [SP,#0x1D0+tty_name]\n0x00532FBC | 00 0C 00 91 | ADD             X0, X0, #3\n0x00532FC0 | E0 13 00 F9 | STR             X0, [SP,#0x1D0+tty_name]\n0x00532FC4 | E0 C7 41 B9 | LDR             W0, [SP,#0x1D0+width]\n0x00532FC8 | E2 03 00 AA | MOV             X2, X0; n\n0x00532FCC | E1 13 40 F9 | LDR             X1, [SP,#0x1D0+tty_name]; src\n0x00532FD0 | E0 E7 40 F9 | LDR             X0, [SP,#0x1D0+id]; dest\n0x00532FD4 | DF 52 FB 97 | BL              .strncpy\n0x00532FD8 | 60 01 00 D0 00 00 14 91 | ADRL            X0, aVarRunUtmp; \"/var/run/utmp\"\n0x00532FE0 | A6 FF FF 97 | BL              touch\n0x00532FE4 | 6B 4E FB 97 | BL              .setutent\n0x00532FE8 | E0 C3 00 91 | ADD             X0, SP, #0x1D0+utent; utmp_ptr\n0x00532FEC | A9 4D FB 97 | BL              .pututline\n0x00532FF0 | A4 51 FB 97 | BL              .endutent\n0x00532FF4 | E0 C3 00 91 | ADD             X0, SP, #0x1D0+utent\n0x00532FF8 | E1 03 00 AA | MOV             X1, X0; utmp\n0x00532FFC | 60 01 00 D0 00 30 21 91 | ADRL            X0, bb_path_wtmp_file; \"/var/log/wtmp\"\n0x00533004 | F3 51 FB 97 | BL              .updwtmp\n0x00533008 | 1F 20 03 D5 | NOP\n0x0053300C | FD 7B DD A8 | LDP             X29, X30, [SP+0x1D0+var_1D0],#0x1D0\n0x00533010 | C0 03 5F D6 | RET",
        "output": "```c\n#include <stdint.h>\n#include <string.h>\n#include <time.h>\n\nstruct utmp {\n    short ut_type;\n    pid_t ut_pid;\n    char ut_line[32];\n    char ut_id[4];\n    char ut_user[32];\n    char ut_host[256];\n    struct timeval ut_tv;\n    int32_t ut_session;\n    int32_t ut_addr_v6[4];\n    char __unused[20];\n};\n\nvoid process_entry(pid_t pid, int new_type, const char *tty_name, const char *username, const char *hostname) {\n    struct utmp utent;\n    memset(&utent, 0, sizeof(utent));\n\n    utent.ut_pid = pid;\n    utent.ut_type = (short)new_type;\n\n    tty_name = skip_dev_pfx(tty_name);\n    safe_strncpy(utent.ut_line, tty_name, sizeof(utent.ut_line));\n\n    if (username && *username) {\n        safe_strncpy(utent.ut_user, username, sizeof(utent.ut_user));\n    }\n\n    if (hostname && *hostname) {\n        safe_strncpy(utent.ut_host, hostname, sizeof(utent.ut_host));\n    }\n\n    utent.ut_tv.tv_sec = time(NULL);\n    strncpy(utent.ut_id, \"(\", 1);\n    utent.ut_session = 4;\n\n    if (utent.ut_line[0] == 'p') {\n        utent.ut_id[1] = 'p';\n        utent.ut_session--;\n    }\n\n    if (strlen(tty_name) > 3) {\n        tty_name += 3;\n    }\n\n    strncpy(utent.ut_id + 1, tty_name, utent.ut_session);\n\n    touch(\"/var/run/utmp\");\n    setutent();\n    pututline(&utent);\n    endutent();\n\n    updwtmp(\"/var/log/wtmp\", &utent);\n}\n```"
    },
    {
        "func_name": "klogd_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004A0ABC | FD 7B BB A9 | STP             X29, X30, [SP,#var_50]!\n0x004A0AC0 | FD 03 00 91 | MOV             X29, SP\n0x004A0AC4 | E0 1F 00 B9 | STR             W0, [SP,#0x50+argc]\n0x004A0AC8 | E1 0B 00 F9 | STR             X1, [SP,#0x50+argv]\n0x004A0ACC | FF 4F 00 B9 | STR             WZR, [SP,#0x50+i]\n0x004A0AD0 | E0 A3 00 91 | ADD             X0, SP, #0x50+opt_c\n0x004A0AD4 | E2 03 00 AA | MOV             X2, X0\n0x004A0AD8 | 80 05 00 B0 | ADRP            X0, #aCN@PAGE; \"c:n\"\n0x004A0ADC | 01 80 32 91 | ADD             X1, X0, #aCN@PAGEOFF; \"c:n\"\n0x004A0AE0 | E0 0B 40 F9 | LDR             X0, [SP,#0x50+argv]; argv\n0x004A0AE4 | 7E FE 01 94 | BL              getopt32\n0x004A0AE8 | E0 37 00 B9 | STR             W0, [SP,#0x50+opt]\n0x004A0AEC | E0 37 40 B9 | LDR             W0, [SP,#0x50+opt]\n0x004A0AF0 | 00 00 00 12 | AND             W0, W0, #1\n0x004A0AF4 | 1F 00 00 71 | CMP             W0, #0\n0x004A0AF8 | C0 00 00 54 | B.EQ            loc_4A0B10\n0x004A0AFC | E0 17 40 F9 | LDR             X0, [SP,#0x50+opt_c]; numstr\n0x004A0B00 | 02 01 80 52 | MOV             W2, #8; upper\n0x004A0B04 | 21 00 80 52 | MOV             W1, #1; lower\n0x004A0B08 | 31 4E 02 94 | BL              xatou_range\n0x004A0B0C | E0 4F 00 B9 | STR             W0, [SP,#0x50+i]\n0x004A0B10 | E0 37 40 B9 | LDR             W0, [SP,#0x50+opt]\n0x004A0B14 | 00 00 1F 12 | AND             W0, W0, #2\n0x004A0B18 | 1F 00 00 71 | CMP             W0, #0\n0x004A0B1C | 61 00 00 54 | B.NE            loc_4A0B28\n0x004A0B20 | 20 00 80 52 | MOV             W0, #1; flags\n0x004A0B24 | 32 4B 02 94 | BL              bb_daemonize_or_rexec\n0x004A0B28 | 80 07 00 D0 00 00 2F 91 | ADRL            X0, logmode\n0x004A0B30 | 41 00 80 52 | MOV             W1, #2\n0x004A0B34 | 01 00 00 B9 | STR             W1, [X0]\n0x004A0B38 | B7 FF FF 97 | BL              klogd_open\n0x004A0B3C | 02 00 80 52 | MOV             W2, #0; facility\n0x004A0B40 | 01 00 80 52 | MOV             W1, #0; option\n0x004A0B44 | 80 05 00 B0 00 A0 32 91 | ADRL            X0, aKernel_0; \"kernel\"\n0x004A0B4C | DD 99 FD 97 | BL              .openlog\n0x004A0B50 | E0 4F 40 B9 | LDR             W0, [SP,#0x50+i]\n0x004A0B54 | 1F 00 00 71 | CMP             W0, #0\n0x004A0B58 | 60 00 00 54 | B.EQ            loc_4A0B64\n0x004A0B5C | E0 4F 40 B9 | LDR             W0, [SP,#0x50+i]; lvl\n0x004A0B60 | B6 FF FF 97 | BL              klogd_setloglevel\n0x004A0B64 | 21 00 80 D2 | MOV             X1, #1; handler\n0x004A0B68 | 20 00 80 52 | MOV             W0, #1; sig\n0x004A0B6C | 71 98 FD 97 | BL              .signal\n0x004A0B70 | 80 04 00 90 | ADRP            X0, #record_signo@PAGE\n0x004A0B74 | 01 80 39 91 | ADD             X1, X0, #record_signo@PAGEOFF; f\n0x004A0B78 | C0 89 9E 52 00 E0 A0 72 | MOV             W0, #0x700F44E; sigs\n0x004A0B80 | F7 40 02 94 | BL              bb_signals_recursive_norestart\n0x004A0B84 | 00 06 00 90 | ADRP            X0, #bb_banner@PAGE; \"BusyBox v1.21.1 (2018-10-20 06:23:14 KS\"...\n0x004A0B88 | 02 10 1C 91 | ADD             X2, X0, #bb_banner@PAGEOFF; \"BusyBox v1.21.1 (2018-10-20 06:23:14 KS\"...\n0x004A0B8C | 80 05 00 B0 | ADRP            X0, #aKlogdStartedS@PAGE; \"klogd started: %s\"\n0x004A0B90 | 01 C0 32 91 | ADD             X1, X0, #aKlogdStartedS@PAGEOFF; \"klogd started: %s\"\n0x004A0B94 | A0 00 80 52 | MOV             W0, #5; pri\n0x004A0B98 | FA 96 FD 97 | BL              .syslog\n0x004A0B9C | 80 05 00 B0 00 20 33 91 | ADRL            X0, aVarRunKlogdPid; \"/var/run/klogd.pid\"\n0x004A0BA4 | C5 28 02 94 | BL              write_pidfile\n0x004A0BA8 | FF 4B 00 B9 | STR             WZR, [SP,#0x50+used]\n0x004A0BAC | 6B 00 00 14 | B               loc_4A0D58\n0x004A0BB0 | E1 4B 80 B9 | LDRSW           X1, [SP,#0x50+used]\n0x004A0BB4 | 80 07 00 F0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x004A0BBC | 20 00 00 8B | ADD             X0, X1, X0\n0x004A0BC0 | E0 13 00 F9 | STR             X0, [SP,#0x50+start]\n0x004A0BC4 | E2 13 40 F9 | LDR             X2, [SP,#0x50+start]\n0x004A0BC8 | 01 00 84 52 | MOV             W1, #0x2000\n0x004A0BCC | E0 4B 40 B9 | LDR             W0, [SP,#0x50+used]\n0x004A0BD0 | 20 00 00 4B | SUB             W0, W1, W0\n0x004A0BD4 | E1 03 00 2A | MOV             W1, W0; len\n0x004A0BD8 | E0 03 02 AA | MOV             X0, X2; bufp\n0x004A0BDC | A1 FF FF 97 | BL              klogd_read\n0x004A0BE0 | E0 33 00 B9 | STR             W0, [SP,#0x50+n]\n0x004A0BE4 | E0 33 40 B9 | LDR             W0, [SP,#0x50+n]\n0x004A0BE8 | 1F 00 00 71 | CMP             W0, #0\n0x004A0BEC | 8A 01 00 54 | B.GE            loc_4A0C1C\n0x004A0BF0 | A0 07 00 B0 00 60 0A 91 | ADRL            X0, bb_errno\n0x004A0BF8 | 00 00 40 F9 | LDR             X0, [X0]\n0x004A0BFC | 00 00 40 B9 | LDR             W0, [X0]\n0x004A0C00 | 1F 10 00 71 | CMP             W0, #4\n0x004A0C04 | 41 00 00 54 | B.NE            loc_4A0C0C\n0x004A0C08 | 54 00 00 14 | B               loc_4A0D58\n0x004A0C0C | 80 05 00 B0 00 80 33 91 | ADRL            X0, aKlogctl2Error; \"klogctl(2) error\"\n0x004A0C14 | A1 A2 FD 97 | BL              bb_perror_msg\n0x004A0C18 | 55 00 00 14 | B               loc_4A0D6C\n0x004A0C1C | E1 13 40 F9 | LDR             X1, [SP,#0x50+start]\n0x004A0C20 | E0 33 80 B9 | LDRSW           X0, [SP,#0x50+n]\n0x004A0C24 | 20 00 00 8B | ADD             X0, X1, X0\n0x004A0C28 | 1F 00 00 39 | STRB            WZR, [X0]\n0x004A0C2C | 80 07 00 F0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x004A0C34 | E0 13 00 F9 | STR             X0, [SP,#0x50+start]\n0x004A0C38 | E0 13 40 F9 | LDR             X0, [SP,#0x50+start]; s\n0x004A0C3C | 41 01 80 52 | MOV             W1, #0xA; c\n0x004A0C40 | 64 9B FD 97 | BL              .strchrnul\n0x004A0C44 | E0 1F 00 F9 | STR             X0, [SP,#0x50+newline]\n0x004A0C48 | E0 1F 40 F9 | LDR             X0, [SP,#0x50+newline]\n0x004A0C4C | 00 00 40 39 | LDRB            W0, [X0]\n0x004A0C50 | 1F 00 00 71 | CMP             W0, #0\n0x004A0C54 | 21 02 00 54 | B.NE            loc_4A0C98\n0x004A0C58 | E0 13 40 F9 | LDR             X0, [SP,#0x50+start]\n0x004A0C5C | E1 03 00 AA | MOV             X1, X0; src\n0x004A0C60 | 80 07 00 F0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1; dst\n0x004A0C68 | FD 3F 02 94 | BL              overlapping_strcpy\n0x004A0C6C | E0 13 40 F9 | LDR             X0, [SP,#0x50+start]\n0x004A0C70 | E1 1F 40 F9 | LDR             X1, [SP,#0x50+newline]\n0x004A0C74 | 20 00 00 CB | SUB             X0, X1, X0\n0x004A0C78 | E0 4B 00 B9 | STR             W0, [SP,#0x50+used]\n0x004A0C7C | E1 4B 40 B9 | LDR             W1, [SP,#0x50+used]\n0x004A0C80 | E0 FF 83 52 | MOV             W0, #0x1FFF\n0x004A0C84 | 3F 00 00 6B | CMP             W1, W0\n0x004A0C88 | 2D 06 00 54 | B.LE            loc_4A0D4C\n0x004A0C8C | FF 4B 00 B9 | STR             WZR, [SP,#0x50+used]\n0x004A0C90 | FF 1F 00 F9 | STR             XZR, [SP,#0x50+newline]\n0x004A0C94 | 05 00 00 14 | B               loc_4A0CA8\n0x004A0C98 | E0 1F 40 F9 | LDR             X0, [SP,#0x50+newline]\n0x004A0C9C | 01 04 00 91 | ADD             X1, X0, #1\n0x004A0CA0 | E1 1F 00 F9 | STR             X1, [SP,#0x50+newline]\n0x004A0CA4 | 1F 00 00 39 | STRB            WZR, [X0]\n0x004A0CA8 | C0 00 80 52 | MOV             W0, #6\n0x004A0CAC | E0 47 00 B9 | STR             W0, [SP,#0x50+priority]\n0x004A0CB0 | E0 13 40 F9 | LDR             X0, [SP,#0x50+start]\n0x004A0CB4 | 00 00 40 39 | LDRB            W0, [X0]\n0x004A0CB8 | 1F F0 00 71 | CMP             W0, #0x3C ; '<'\n0x004A0CBC | 81 02 00 54 | B.NE            loc_4A0D0C\n0x004A0CC0 | E0 13 40 F9 | LDR             X0, [SP,#0x50+start]\n0x004A0CC4 | 00 04 00 91 | ADD             X0, X0, #1\n0x004A0CC8 | E0 13 00 F9 | STR             X0, [SP,#0x50+start]\n0x004A0CCC | E0 13 40 F9 | LDR             X0, [SP,#0x50+start]\n0x004A0CD0 | 00 00 40 39 | LDRB            W0, [X0]\n0x004A0CD4 | 1F 00 00 71 | CMP             W0, #0\n0x004A0CD8 | C0 00 00 54 | B.EQ            loc_4A0CF0\n0x004A0CDC | E0 13 40 F9 | LDR             X0, [SP,#0x50+start]; nptr\n0x004A0CE0 | E1 83 00 91 | ADD             X1, SP, #0x50+start; endptr\n0x004A0CE4 | 42 01 80 52 | MOV             W2, #0xA; base\n0x004A0CE8 | 96 96 FD 97 | BL              .strtoul\n0x004A0CEC | E0 47 00 B9 | STR             W0, [SP,#0x50+priority]\n0x004A0CF0 | E0 13 40 F9 | LDR             X0, [SP,#0x50+start]\n0x004A0CF4 | 00 00 40 39 | LDRB            W0, [X0]\n0x004A0CF8 | 1F F8 00 71 | CMP             W0, #0x3E ; '>'\n0x004A0CFC | 81 00 00 54 | B.NE            loc_4A0D0C\n0x004A0D00 | E0 13 40 F9 | LDR             X0, [SP,#0x50+start]\n0x004A0D04 | 00 04 00 91 | ADD             X0, X0, #1\n0x004A0D08 | E0 13 00 F9 | STR             X0, [SP,#0x50+start]\n0x004A0D0C | E0 13 40 F9 | LDR             X0, [SP,#0x50+start]\n0x004A0D10 | 00 00 40 39 | LDRB            W0, [X0]\n0x004A0D14 | 1F 00 00 71 | CMP             W0, #0\n0x004A0D18 | E0 00 00 54 | B.EQ            loc_4A0D34\n0x004A0D1C | E0 13 40 F9 | LDR             X0, [SP,#0x50+start]\n0x004A0D20 | E2 03 00 AA | MOV             X2, X0\n0x004A0D24 | 80 05 00 B0 | ADRP            X0, #aS_112@PAGE; \"%s\"\n0x004A0D28 | 01 E0 33 91 | ADD             X1, X0, #aS_112@PAGEOFF; \"%s\"\n0x004A0D2C | E0 47 40 B9 | LDR             W0, [SP,#0x50+priority]; pri\n0x004A0D30 | 94 96 FD 97 | BL              .syslog\n0x004A0D34 | E0 1F 40 F9 | LDR             X0, [SP,#0x50+newline]\n0x004A0D38 | 1F 00 00 F1 | CMP             X0, #0\n0x004A0D3C | C0 00 00 54 | B.EQ            loc_4A0D54\n0x004A0D40 | E0 1F 40 F9 | LDR             X0, [SP,#0x50+newline]\n0x004A0D44 | E0 13 00 F9 | STR             X0, [SP,#0x50+start]\n0x004A0D48 | BC FF FF 17 | B               loc_4A0C38\n0x004A0D4C | 1F 20 03 D5 | NOP\n0x004A0D50 | 02 00 00 14 | B               loc_4A0D58\n0x004A0D54 | 1F 20 03 D5 | NOP\n0x004A0D58 | A0 07 00 B0 00 30 11 91 | ADRL            X0, bb_got_signal\n0x004A0D60 | 00 00 40 B9 | LDR             W0, [X0]\n0x004A0D64 | 1F 00 00 71 | CMP             W0, #0\n0x004A0D68 | 40 F2 FF 54 | B.EQ            loc_4A0BB0\n0x004A0D6C | 47 FF FF 97 | BL              klogd_close\n0x004A0D70 | 80 05 00 B0 | ADRP            X0, #aKlogdExiting@PAGE; \"klogd: exiting\"\n0x004A0D74 | 01 00 34 91 | ADD             X1, X0, #aKlogdExiting@PAGEOFF; \"klogd: exiting\"\n0x004A0D78 | A0 00 80 52 | MOV             W0, #5; pri\n0x004A0D7C | 81 96 FD 97 | BL              .syslog\n0x004A0D80 | A0 07 00 B0 00 20 11 91 | ADRL            X0, wrote_pidfile\n0x004A0D88 | 00 00 40 B9 | LDR             W0, [X0]\n0x004A0D8C | 1F 00 00 71 | CMP             W0, #0\n0x004A0D90 | 80 00 00 54 | B.EQ            loc_4A0DA0\n0x004A0D94 | 80 05 00 B0 00 20 33 91 | ADRL            X0, aVarRunKlogdPid; \"/var/run/klogd.pid\"\n0x004A0D9C | D9 9B FD 97 | BL              .unlink\n0x004A0DA0 | A0 07 00 B0 00 30 11 91 | ADRL            X0, bb_got_signal\n0x004A0DA8 | 00 00 40 B9 | LDR             W0, [X0]\n0x004A0DAC | 1F 00 00 71 | CMP             W0, #0\n0x004A0DB0 | A0 00 00 54 | B.EQ            loc_4A0DC4\n0x004A0DB4 | A0 07 00 B0 00 30 11 91 | ADRL            X0, bb_got_signal\n0x004A0DBC | 00 00 40 B9 | LDR             W0, [X0]; sig\n0x004A0DC0 | B7 40 02 94 | BL              kill_myself_with_sig\n0x004A0DC4 | 20 00 80 52 | MOV             W0, #1\n0x004A0DC8 | FD 7B C5 A8 | LDP             X29, X30, [SP+0x50+var_50],#0x50\n0x004A0DCC | C0 03 5F D6 | RET",
        "output": "```c\n#include <signal.h>\n#include <unistd.h>\n#include <syslog.h>\n#include <stdlib.h>\n\nint main(int argc, char **argv) {\n    int opt, i = 0;\n    char *opt_c;\n    getopt32(argv, \"c:n\");\n    opt = _res;\n    if (opt & 1) {\n        xatou_range(opt_c, 1, 8);\n        i = _res;\n    }\n    if (!(opt & 2)) {\n        bb_daemonize_or_rexec(1);\n    }\n    logmode = 2;\n    klogd_open();\n    openlog(\"kernel\", 0, 0);\n    if (i != 0) {\n        klogd_setloglevel(i);\n    }\n    signal(1, handler);\n    bb_signals_recursive_norestart(0x700F44E, record_signo);\n    syslog(5, \"klogd started: %s\", \"BusyBox v1.21.1 (2018-10-20 06:23:14 KS\");\n    write_pidfile(\"/var/run/klogd.pid\");\n    int used = 0;\n    char *start = bb_common_bufsiz1;\n    while (1) {\n        char *bufp = start + used;\n        int len = 0x2000 - used;\n        int n = klogd_read(bufp, len);\n        if (n < 0) {\n            if (errno == EINTR) continue;\n            bb_perror_msg(\"klogctl(2) error\");\n            break;\n        }\n        if (n == 0) break;\n        bufp[n] = '\\0';\n        char *newline = strchrnul(start, '\\n');\n        if (*newline == '\\0') {\n            if (used + n > 0x1FFF) {\n                used = 0;\n                newline = NULL;\n            }\n            continue;\n        }\n        *newline = '\\0';\n        int priority = 6;\n        if (*start == '<') {\n            start++;\n            if (*start) {\n                priority = strtoul(start, &start, 10);\n            }\n        }\n        if (*start == '>') {\n            start++;\n        }\n        if (*start) {\n            syslog(priority, \"%s\", start);\n        }\n        if (newline[1] == '\\0') {\n            start = bb_common_bufsiz1;\n            used = 0;\n        } else {\n            start = newline + 1;\n            used = start - bb_common_bufsiz1;\n        }\n    }\n    if (bb_got_signal) {\n        klogd_close();\n        syslog(5, \"klogd: exiting\");\n        if (wrote_pidfile) {\n            unlink(\"/var/run/klogd.pid\");\n        }\n        if (bb_got_signal) {\n            kill_myself_with_sig(bb_got_signal);\n        }\n    }\n    return 1;\n}\n```"
    },
    {
        "func_name": "gethdr",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0045036C | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x00450370 | FD 03 00 91 | MOV             X29, SP\n0x00450374 | E0 0F 00 F9 | STR             X0, [SP,#0x40+fp]\n0x00450378 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+fp]; fp\n0x0045037C | EE FE FF 97 | BL              fgets_and_trim\n0x00450380 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x00450384 | E0 37 00 B9 | STR             W0, [SP,#0x40+c]\n0x00450388 | 20 0A 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00450390 | 00 00 40 F9 | LDR             X0, [X0]\n0x00450394 | 00 20 42 39 | LDRB            W0, [X0,#0x88]\n0x00450398 | 1F 00 00 71 | CMP             W0, #0\n0x0045039C | 61 00 00 54 | B.NE            loc_4503A8\n0x004503A0 | 00 00 80 D2 | MOV             X0, #0\n0x004503A4 | 45 00 00 14 | B               loc_4504B8\n0x004503A8 | 20 0A 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004503B0 | 00 00 40 F9 | LDR             X0, [X0]\n0x004503B4 | 00 20 02 91 | ADD             X0, X0, #0x88\n0x004503B8 | E0 1F 00 F9 | STR             X0, [SP,#0x40+s]\n0x004503BC | 0A 00 00 14 | B               loc_4503E4\n0x004503C0 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+s]\n0x004503C4 | 00 00 40 39 | LDRB            W0, [X0]\n0x004503C8 | 00 00 1B 32 | ORR             W0, W0, #0x20\n0x004503CC | 01 1C 00 12 | AND             W1, W0, #0xFF\n0x004503D0 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+s]\n0x004503D4 | 01 00 00 39 | STRB            W1, [X0]\n0x004503D8 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+s]\n0x004503DC | 00 04 00 91 | ADD             X0, X0, #1\n0x004503E0 | E0 1F 00 F9 | STR             X0, [SP,#0x40+s]\n0x004503E4 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+s]\n0x004503E8 | 00 00 40 39 | LDRB            W0, [X0]; a\n0x004503EC | F4 FD FF 97 | BL              bb_ascii_isalnum_3\n0x004503F0 | 1F 00 00 71 | CMP             W0, #0\n0x004503F4 | 61 FE FF 54 | B.NE            loc_4503C0\n0x004503F8 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+s]\n0x004503FC | 00 00 40 39 | LDRB            W0, [X0]\n0x00450400 | 1F B4 00 71 | CMP             W0, #0x2D ; '-'\n0x00450404 | E0 FD FF 54 | B.EQ            loc_4503C0\n0x00450408 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+s]\n0x0045040C | 00 00 40 39 | LDRB            W0, [X0]\n0x00450410 | 1F B8 00 71 | CMP             W0, #0x2E ; '.'\n0x00450414 | 60 FD FF 54 | B.EQ            loc_4503C0\n0x00450418 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+s]\n0x0045041C | 00 00 40 39 | LDRB            W0, [X0]\n0x00450420 | 1F E8 00 71 | CMP             W0, #0x3A ; ':'\n0x00450424 | 40 01 00 54 | B.EQ            loc_45044C\n0x00450428 | 20 0A 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00450430 | 00 00 40 F9 | LDR             X0, [X0]\n0x00450434 | 00 20 02 91 | ADD             X0, X0, #0x88; s\n0x00450438 | 9A FE FF 97 | BL              sanitize_string\n0x0045043C | E1 03 00 AA | MOV             X1, X0\n0x00450440 | C0 07 00 B0 00 A0 2F 91 | ADRL            X0, aBadHeaderLineS; \"bad header line: %s\"\n0x00450448 | 0B E6 FE 97 | BL              bb_error_msg_and_die\n0x0045044C | E0 1F 40 F9 | LDR             X0, [SP,#0x40+s]\n0x00450450 | 01 04 00 91 | ADD             X1, X0, #1\n0x00450454 | E1 1F 00 F9 | STR             X1, [SP,#0x40+s]\n0x00450458 | 1F 00 00 39 | STRB            WZR, [X0]\n0x0045045C | E0 1F 40 F9 | LDR             X0, [SP,#0x40+s]; s\n0x00450460 | 0D E5 FE 97 | BL              skip_whitespace\n0x00450464 | E0 17 00 F9 | STR             X0, [SP,#0x40+hdrval]\n0x00450468 | E0 37 40 B9 | LDR             W0, [SP,#0x40+c]\n0x0045046C | 1F 28 00 71 | CMP             W0, #0xA\n0x00450470 | 20 02 00 54 | B.EQ            loc_4504B4\n0x00450474 | 02 00 00 14 | B               loc_45047C\n0x00450478 | 1F 20 03 D5 | NOP\n0x0045047C | E0 0F 40 F9 | LDR             X0, [SP,#0x40+fp]; stream\n0x00450480 | 50 DB FE 97 | BL              .getc_unlocked\n0x00450484 | E0 37 00 B9 | STR             W0, [SP,#0x40+c]\n0x00450488 | E0 37 40 B9 | LDR             W0, [SP,#0x40+c]\n0x0045048C | 1F 04 00 31 | CMN             W0, #1\n0x00450490 | C0 00 00 54 | B.EQ            loc_4504A8\n0x00450494 | E0 37 40 B9 | LDR             W0, [SP,#0x40+c]\n0x00450498 | 1F 28 00 71 | CMP             W0, #0xA\n0x0045049C | 60 00 00 54 | B.EQ            loc_4504A8\n0x004504A0 | 20 00 80 52 | MOV             W0, #1\n0x004504A4 | 02 00 00 14 | B               loc_4504AC\n0x004504A8 | 00 00 80 52 | MOV             W0, #0\n0x004504AC | 1F 00 00 71 | CMP             W0, #0\n0x004504B0 | 41 FE FF 54 | B.NE            loc_450478\n0x004504B4 | E0 17 40 F9 | LDR             X0, [SP,#0x40+hdrval]\n0x004504B8 | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x004504BC | C0 03 5F D6 | RET",
        "output": "```c\nchar *fgets_and_trim(char *s);\nint bb_ascii_isalnum_3(int c);\nvoid sanitize_string(char *s);\nvoid bb_error_msg_and_die(const char *fmt, ...);\nchar *skip_whitespace(char *s);\nint getc_unlocked(FILE *stream);\n\nvoid function(char *fp) {\n    char c;\n    char *s, *hdrval;\n    FILE *stream = (FILE *)fp;\n\n    fgets_and_trim(fp);\n    c = c & 0xFF;\n    if (ptr_to_globals[0x88] == 0) {\n        return;\n    }\n\n    s = &ptr_to_globals[0x88];\n    do {\n        c = *s | 0x20;\n        *s = c;\n        s++;\n        if (!bb_ascii_isalnum_3(*s) && *s != '-' && *s != '.' && *s != ':') {\n            sanitize_string(&ptr_to_globals[0x88]);\n            bb_error_msg_and_die(\"bad header line: %s\", &ptr_to_globals[0x88]);\n        }\n    } while (*s != '\\0');\n\n    s++;\n    *s = '\\0';\n    hdrval = skip_whitespace(s);\n    c = c & 0xFF;\n    if (c == '\\n') {\n        return hdrval;\n    }\n\n    while (1) {\n        c = getc_unlocked(stream);\n        if (c == EOF || c == '\\n') {\n            break;\n        }\n    }\n\n    return hdrval;\n}\n```"
    },
    {
        "func_name": "redirectsafe",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004839B8 | FD 7B A9 A9 | STP             X29, X30, [SP,#var_170]!\n0x004839BC | FD 03 00 91 | MOV             X29, SP\n0x004839C0 | E0 0F 00 F9 | STR             X0, [SP,#0x170+redir]\n0x004839C4 | E1 17 00 B9 | STR             W1, [SP,#0x170+flags]\n0x004839C8 | 80 08 00 D0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x004839D0 | 00 00 40 F9 | LDR             X0, [X0]\n0x004839D4 | 00 14 40 F9 | LDR             X0, [X0,#0x28]\n0x004839D8 | E0 B3 00 F9 | STR             X0, [SP,#0x170+savehandler]\n0x004839DC | 80 08 00 D0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x004839E4 | 00 00 40 F9 | LDR             X0, [X0]\n0x004839E8 | 00 30 40 B9 | LDR             W0, [X0,#0x30]\n0x004839EC | E0 6B 01 B9 | STR             W0, [SP,#0x170+saveint]\n0x004839F0 | E0 A3 00 91 | ADD             X0, SP, #0x170+jmploc; env\n0x004839F4 | 6B 0B FE 97 | BL              ._setjmp\n0x004839F8 | E0 6F 01 B9 | STR             W0, [SP,#0x170+err]\n0x004839FC | E0 6F 41 B9 | LDR             W0, [SP,#0x170+err]\n0x00483A00 | 1F 00 00 71 | CMP             W0, #0\n0x00483A04 | 21 01 00 54 | B.NE            loc_483A28\n0x00483A08 | 80 08 00 D0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00483A10 | 00 00 40 F9 | LDR             X0, [X0]\n0x00483A14 | E1 A3 00 91 | ADD             X1, SP, #0x170+jmploc\n0x00483A18 | 01 14 00 F9 | STR             X1, [X0,#0x28]\n0x00483A1C | E1 17 40 B9 | LDR             W1, [SP,#0x170+flags]; flags\n0x00483A20 | E0 0F 40 F9 | LDR             X0, [SP,#0x170+redir]; redir\n0x00483A24 | 39 FE FF 97 | BL              redirect\n0x00483A28 | 80 08 00 D0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00483A30 | 00 00 40 F9 | LDR             X0, [X0]\n0x00483A34 | E1 B3 40 F9 | LDR             X1, [SP,#0x170+savehandler]\n0x00483A38 | 01 14 00 F9 | STR             X1, [X0,#0x28]\n0x00483A3C | E0 6F 41 B9 | LDR             W0, [SP,#0x170+err]\n0x00483A40 | 1F 00 00 71 | CMP             W0, #0\n0x00483A44 | A0 01 00 54 | B.EQ            loc_483A78\n0x00483A48 | 80 08 00 D0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00483A50 | 00 00 40 F9 | LDR             X0, [X0]\n0x00483A54 | 00 3C 40 B9 | LDR             W0, [X0,#0x3C]\n0x00483A58 | 1F 04 00 71 | CMP             W0, #1\n0x00483A5C | E0 00 00 54 | B.EQ            loc_483A78\n0x00483A60 | 80 08 00 D0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00483A68 | 00 00 40 F9 | LDR             X0, [X0]\n0x00483A6C | 00 14 40 F9 | LDR             X0, [X0,#0x28]; env\n0x00483A70 | 21 00 80 52 | MOV             W1, #1; val\n0x00483A74 | 1B 10 FE 97 | BL              .longjmp\n0x00483A78 | 80 08 00 D0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00483A80 | 00 00 40 F9 | LDR             X0, [X0]\n0x00483A84 | E1 6B 41 B9 | LDR             W1, [SP,#0x170+saveint]\n0x00483A88 | 01 30 00 B9 | STR             W1, [X0,#0x30]\n0x00483A8C | 80 08 00 D0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00483A94 | 00 00 40 F9 | LDR             X0, [X0]\n0x00483A98 | 00 30 40 B9 | LDR             W0, [X0,#0x30]\n0x00483A9C | 1F 00 00 71 | CMP             W0, #0\n0x00483AA0 | 01 01 00 54 | B.NE            loc_483AC0\n0x00483AA4 | 80 08 00 D0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00483AAC | 00 00 40 F9 | LDR             X0, [X0]\n0x00483AB0 | 00 34 40 B9 | LDR             W0, [X0,#0x34]\n0x00483AB4 | 1F 00 00 71 | CMP             W0, #0\n0x00483AB8 | 40 00 00 54 | B.EQ            loc_483AC0\n0x00483ABC | 79 E3 FF 97 | BL              raise_interrupt\n0x00483AC0 | E0 6F 41 B9 | LDR             W0, [SP,#0x170+err]\n0x00483AC4 | FD 7B D7 A8 | LDP             X29, X30, [SP+0x170+var_170],#0x170\n0x00483AC8 | C0 03 5F D6 | RET",
        "output": "```c\n#include <setjmp.h>\n\ntypedef struct {\n    void *redir;\n    int flags;\n    void *savehandler;\n    int saveint;\n    int err;\n} Globals;\n\nGlobals *ash_ptr_to_globals_misc;\n\nvoid redirect(void *redir, int flags);\nvoid raise_interrupt();\nvoid longjmp(void *env, int val);\n\nint function() {\n    jmp_buf jmploc;\n    int err = setjmp(jmploc);\n    if (err != 0) {\n        if (ash_ptr_to_globals_misc->savehandler != NULL) {\n            ash_ptr_to_globals_misc->savehandler = ash_ptr_to_globals_misc->savehandler;\n        }\n        if (err != 1) {\n            longjmp(ash_ptr_to_globals_misc->savehandler, 1);\n        }\n        ash_ptr_to_globals_misc->saveint = ash_ptr_to_globals_misc->saveint;\n        if (ash_ptr_to_globals_misc->saveint != 0) {\n            raise_interrupt();\n        }\n        return err;\n    }\n\n    ash_ptr_to_globals_misc->savehandler = jmploc;\n    redirect(ash_ptr_to_globals_misc->redir, ash_ptr_to_globals_misc->flags);\n    ash_ptr_to_globals_misc->savehandler = ash_ptr_to_globals_misc->savehandler;\n    ash_ptr_to_globals_misc->saveint = ash_ptr_to_globals_misc->saveint;\n    return 0;\n}\n```"
    },
    {
        "func_name": "new_function",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00499F40 | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x00499F44 | FD 03 00 91 | MOV             X29, SP\n0x00499F48 | E0 0F 00 F9 | STR             X0, [SP,#0x40+name]\n0x00499F4C | E0 0F 40 F9 | LDR             X0, [SP,#0x40+name]; name\n0x00499F50 | D5 FF FF 97 | BL              find_function_slot\n0x00499F54 | E0 1B 00 F9 | STR             X0, [SP,#0x40+funcpp]\n0x00499F58 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+funcpp]\n0x00499F5C | 00 00 40 F9 | LDR             X0, [X0]\n0x00499F60 | E0 1F 00 F9 | STR             X0, [SP,#0x40+funcp]\n0x00499F64 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x00499F68 | 1F 00 00 F1 | CMP             X0, #0\n0x00499F6C | 80 03 00 54 | B.EQ            loc_499FDC\n0x00499F70 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x00499F74 | 00 08 40 F9 | LDR             X0, [X0,#0x10]\n0x00499F78 | E0 17 00 F9 | STR             X0, [SP,#0x40+cmd]\n0x00499F7C | E0 17 40 F9 | LDR             X0, [SP,#0x40+cmd]\n0x00499F80 | 1F 00 00 F1 | CMP             X0, #0\n0x00499F84 | 81 01 00 54 | B.NE            loc_499FB4\n0x00499F88 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x00499F8C | 00 04 40 F9 | LDR             X0, [X0,#8]; ptr\n0x00499F90 | 54 B5 FD 97 | BL              .free\n0x00499F94 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x00499F98 | 00 0C 40 F9 | LDR             X0, [X0,#0x18]\n0x00499F9C | 1F 00 00 F1 | CMP             X0, #0\n0x00499FA0 | E0 02 00 54 | B.EQ            loc_499FFC\n0x00499FA4 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x00499FA8 | 00 0C 40 F9 | LDR             X0, [X0,#0x18]; pi\n0x00499FAC | 6D EC FF 97 | BL              free_pipe_list\n0x00499FB0 | 13 00 00 14 | B               loc_499FFC\n0x00499FB4 | E0 17 40 F9 | LDR             X0, [SP,#0x40+cmd]\n0x00499FB8 | 00 10 40 F9 | LDR             X0, [X0,#0x20]\n0x00499FBC | E1 1F 40 F9 | LDR             X1, [SP,#0x40+funcp]\n0x00499FC0 | 21 04 40 F9 | LDR             X1, [X1,#8]\n0x00499FC4 | 01 00 00 F9 | STR             X1, [X0]\n0x00499FC8 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x00499FCC | 01 0C 40 F9 | LDR             X1, [X0,#0x18]\n0x00499FD0 | E0 17 40 F9 | LDR             X0, [SP,#0x40+cmd]\n0x00499FD4 | 01 08 00 F9 | STR             X1, [X0,#0x10]\n0x00499FD8 | 09 00 00 14 | B               loc_499FFC\n0x00499FDC | 00 04 80 D2 | MOV             X0, #0x20 ; ' '; size\n0x00499FE0 | 67 C2 FD 97 | BL              xzalloc\n0x00499FE4 | E1 03 00 AA | MOV             X1, X0\n0x00499FE8 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+funcpp]\n0x00499FEC | 01 00 00 F9 | STR             X1, [X0]\n0x00499FF0 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+funcpp]\n0x00499FF4 | 00 00 40 F9 | LDR             X0, [X0]\n0x00499FF8 | E0 1F 00 F9 | STR             X0, [SP,#0x40+funcp]\n0x00499FFC | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x0049A000 | E1 0F 40 F9 | LDR             X1, [SP,#0x40+name]\n0x0049A004 | 01 04 00 F9 | STR             X1, [X0,#8]\n0x0049A008 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+funcp]\n0x0049A00C | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x0049A010 | C0 03 5F D6 | RET",
        "output": "```c\nvoid *function(const char *name) {\n    void **funcpp;\n    void *funcp;\n    void *cmd;\n    void *ptr;\n    void *pi;\n    size_t size;\n\n    funcp = find_function_slot(name);\n    funcpp = &funcp;\n\n    if (funcp != NULL) {\n        cmd = *((void **)((char *)funcp + 0x10));\n        if (cmd != NULL) {\n            ptr = *((void **)((char *)funcp + 0x8));\n            *((void **)((char *)cmd + 0x20)) = ptr;\n            pi = *((void **)((char *)funcp + 0x18));\n            *((void **)((char *)cmd + 0x10)) = pi;\n        } else {\n            ptr = *((void **)((char *)funcp + 0x8));\n            free(ptr);\n            pi = *((void **)((char *)funcp + 0x18));\n            if (pi != NULL) {\n                free_pipe_list(pi);\n            }\n        }\n    } else {\n        size = 0x20;\n        funcp = xzalloc(size);\n        *funcpp = funcp;\n        *((void **)((char *)funcp + 0x8)) = (void *)name;\n    }\n\n    return funcp;\n}\n```"
    },
    {
        "func_name": "rc_do_normalize",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004D7814 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x004D7818 | FD 03 00 91 | MOV             X29, SP\n0x004D781C | E0 0F 00 F9 | STR             X0, [SP,#0x20+rc]\n0x004D7820 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7824 | 01 04 40 F9 | LDR             X1, [X0,#8]\n0x004D7828 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D782C | 00 08 40 F9 | LDR             X0, [X0,#0x10]\n0x004D7830 | 3F 00 00 EB | CMP             X1, X0\n0x004D7834 | 63 00 00 54 | B.CC            loc_4D7840\n0x004D7838 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]; rc\n0x004D783C | D7 FF FF 97 | BL              rc_read\n0x004D7840 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7844 | 00 1C 40 B9 | LDR             W0, [X0,#0x1C]\n0x004D7848 | 01 5C 18 53 | LSL             W1, W0, #8\n0x004D784C | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7850 | 01 1C 00 B9 | STR             W1, [X0,#0x1C]\n0x004D7854 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7858 | 00 18 40 B9 | LDR             W0, [X0,#0x18]\n0x004D785C | 01 5C 18 53 | LSL             W1, W0, #8\n0x004D7860 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7864 | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x004D7868 | 03 04 00 91 | ADD             X3, X0, #1\n0x004D786C | E2 0F 40 F9 | LDR             X2, [SP,#0x20+rc]\n0x004D7870 | 43 04 00 F9 | STR             X3, [X2,#8]\n0x004D7874 | 00 00 40 39 | LDRB            W0, [X0]\n0x004D7878 | 21 00 00 2A | ORR             W1, W1, W0\n0x004D787C | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rc]\n0x004D7880 | 01 18 00 B9 | STR             W1, [X0,#0x18]\n0x004D7884 | 1F 20 03 D5 | NOP\n0x004D7888 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004D788C | C0 03 5F D6 | RET",
        "output": "```c\nvoid function(unsigned long *rc) {\n    unsigned long *ptr = rc;\n    unsigned long val1 = ptr[1];\n    unsigned long val2 = ptr[2];\n\n    if (val1 >= val2) {\n        rc_read();\n    }\n\n    unsigned int val3 = *((unsigned int *)ptr + 7);\n    val3 <<= 8;\n    *((unsigned int *)ptr + 7) = val3;\n\n    unsigned int val4 = *((unsigned int *)ptr + 6);\n    val4 <<= 8;\n    val4 |= *((unsigned char *)ptr + 1);\n    *((unsigned int *)ptr + 6) = val4;\n}\n```"
    },
    {
        "func_name": "inflate_get_next_window",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004D6608 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004D660C | FD 03 00 91 | MOV             X29, SP\n0x004D6610 | E0 0F 00 F9 | STR             X0, [SP,#0x30+state]\n0x004D6614 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]\n0x004D6618 | 1F 10 00 B9 | STR             WZR, [X0,#0x10]\n0x004D661C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]\n0x004D6620 | 00 88 40 B9 | LDR             W0, [X0,#0x88]\n0x004D6624 | 1F 00 00 71 | CMP             W0, #0\n0x004D6628 | A0 02 00 54 | B.EQ            loc_4D667C\n0x004D662C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]\n0x004D6630 | 00 8C 40 B9 | LDR             W0, [X0,#0x8C]\n0x004D6634 | 1F 00 00 71 | CMP             W0, #0\n0x004D6638 | E0 00 00 54 | B.EQ            loc_4D6654\n0x004D663C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]; state\n0x004D6640 | D6 FF FF 97 | BL              calculate_gunzip_crc\n0x004D6644 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]\n0x004D6648 | 1F 8C 00 B9 | STR             WZR, [X0,#0x8C]\n0x004D664C | 00 00 80 52 | MOV             W0, #0\n0x004D6650 | 26 00 00 14 | B               loc_4D66E8\n0x004D6654 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]\n0x004D6658 | 00 30 02 91 | ADD             X0, X0, #0x8C\n0x004D665C | E1 03 00 AA | MOV             X1, X0; e\n0x004D6660 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]; state\n0x004D6664 | 67 FD FF 97 | BL              inflate_block\n0x004D6668 | E1 03 00 2A | MOV             W1, W0\n0x004D666C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]\n0x004D6670 | 01 84 00 B9 | STR             W1, [X0,#0x84]\n0x004D6674 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]\n0x004D6678 | 1F 88 00 B9 | STR             WZR, [X0,#0x88]\n0x004D667C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]\n0x004D6680 | 00 84 40 B9 | LDR             W0, [X0,#0x84]\n0x004D6684 | 1F 08 00 31 | CMN             W0, #2\n0x004D6688 | E0 00 00 54 | B.EQ            loc_4D66A4\n0x004D668C | 1F 04 00 31 | CMN             W0, #1\n0x004D6690 | 21 01 00 54 | B.NE            loc_4D66B4\n0x004D6694 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]; state\n0x004D6698 | 07 FD FF 97 | BL              inflate_stored\n0x004D669C | E0 2F 00 B9 | STR             W0, [SP,#0x30+ret]\n0x004D66A0 | 07 00 00 14 | B               loc_4D66BC\n0x004D66A4 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]; state\n0x004D66A8 | 22 FB FF 97 | BL              inflate_codes\n0x004D66AC | E0 2F 00 B9 | STR             W0, [SP,#0x30+ret]\n0x004D66B0 | 03 00 00 14 | B               loc_4D66BC\n0x004D66B4 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]; state\n0x004D66B8 | 47 F8 FF 97 | BL              abort_unzip\n0x004D66BC | E0 2F 40 B9 | LDR             W0, [SP,#0x30+ret]\n0x004D66C0 | 1F 04 00 71 | CMP             W0, #1\n0x004D66C4 | A1 00 00 54 | B.NE            loc_4D66D8\n0x004D66C8 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]; state\n0x004D66CC | B3 FF FF 97 | BL              calculate_gunzip_crc\n0x004D66D0 | 20 00 80 52 | MOV             W0, #1\n0x004D66D4 | 05 00 00 14 | B               loc_4D66E8\n0x004D66D8 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+state]\n0x004D66DC | 21 00 80 52 | MOV             W1, #1\n0x004D66E0 | 01 88 00 B9 | STR             W1, [X0,#0x88]\n0x004D66E4 | CE FF FF 17 | B               loc_4D661C\n0x004D66E8 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004D66EC | C0 03 5F D6 | RET",
        "output": "```c\nvoid function(uint64_t *state) {\n    state[4] = 0;\n\n    if (state[34] == 0) {\n        goto loc_4D667C;\n    }\n\n    if (state[35] != 0) {\n        calculate_gunzip_crc(state);\n        state[35] = 0;\n        return;\n    }\n\n    uint64_t *e = &state[35];\n    int ret = inflate_block(state, e);\n    state[33] = ret;\n    state[34] = 0;\n\nloc_4D667C:\n    if (state[33] == 2) {\n        goto loc_4D66A4;\n    }\n\n    if (state[33] != 1) {\n        abort_unzip(state);\n    } else {\n        inflate_stored(state);\n        return;\n    }\n\nloc_4D66A4:\n    inflate_codes(state);\n    return;\n\nloc_4D66D8:\n    if (state[33] == 1) {\n        calculate_gunzip_crc(state);\n        return;\n    } else {\n        state[34] = 1;\n        goto loc_4D661C;\n    }\n}\n```"
    },
    {
        "func_name": "pop",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004183C4 | FD 7B BF A9 | STP             X29, X30, [SP,#-0x10+var_s0]!\n0x004183C8 | FD 03 00 91 | MOV             X29, SP\n0x004183CC | C0 0B 00 F0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x004183D4 | 00 00 40 B9 | LDR             W0, [X0]\n0x004183D8 | 1F 00 00 71 | CMP             W0, #0\n0x004183DC | 81 00 00 54 | B.NE            loc_4183EC\n0x004183E0 | 20 09 00 F0 00 60 3E 91 | ADRL            X0, aStackUnderflow; \"stack underflow\"\n0x004183E8 | 23 C6 FF 97 | BL              bb_error_msg_and_die\n0x004183EC | C0 0B 00 F0 | ADRP            X0, #bb_common_bufsiz1@PAGE\n0x004183F0 | 01 40 0A 91 | ADD             X1, X0, #bb_common_bufsiz1@PAGEOFF\n0x004183F4 | C0 0B 00 F0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x004183FC | 02 00 40 B9 | LDR             W2, [X0]\n0x00418400 | 42 04 00 51 | SUB             W2, W2, #1\n0x00418404 | 02 00 00 B9 | STR             W2, [X0]\n0x00418408 | 00 00 40 B9 | LDR             W0, [X0]\n0x0041840C | E0 03 00 2A | MOV             W0, W0\n0x00418410 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00418414 | 20 00 00 8B | ADD             X0, X1, X0\n0x00418418 | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x0041841C | 00 00 67 9E | FMOV            D0, X0\n0x00418420 | FD 7B C1 A8 | LDP             X29, X30, [SP+var_s0],#0x10\n0x00418424 | C0 03 5F D6 | RET",
        "output": "```c\ndouble bb_common_bufsiz1_function() {\n    if (bb_common_bufsiz1 == 0) {\n        bb_error_msg_and_die(\"stack underflow\");\n    }\n    bb_common_bufsiz1--;\n    double* buf = (double*)((uintptr_t)bb_common_bufsiz1 + (bb_common_bufsiz1 << 3));\n    return buf[1];\n}\n```"
    },
    {
        "func_name": "unset_func",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0049A014 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0049A018 | FD 03 00 91 | MOV             X29, SP\n0x0049A01C | E0 0F 00 F9 | STR             X0, [SP,#0x30+name]\n0x0049A020 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+name]; name\n0x0049A024 | A0 FF FF 97 | BL              find_function_slot\n0x0049A028 | E0 17 00 F9 | STR             X0, [SP,#0x30+funcpp]\n0x0049A02C | E0 17 40 F9 | LDR             X0, [SP,#0x30+funcpp]\n0x0049A030 | 00 00 40 F9 | LDR             X0, [X0]\n0x0049A034 | E0 13 00 F9 | STR             X0, [SP,#0x30+funcp]\n0x0049A038 | E0 13 40 F9 | LDR             X0, [SP,#0x30+funcp]\n0x0049A03C | 1F 00 00 F1 | CMP             X0, #0\n0x0049A040 | 20 02 00 54 | B.EQ            loc_49A084\n0x0049A044 | E0 13 40 F9 | LDR             X0, [SP,#0x30+funcp]\n0x0049A048 | 01 00 40 F9 | LDR             X1, [X0]\n0x0049A04C | E0 17 40 F9 | LDR             X0, [SP,#0x30+funcpp]\n0x0049A050 | 01 00 00 F9 | STR             X1, [X0]\n0x0049A054 | E0 13 40 F9 | LDR             X0, [SP,#0x30+funcp]\n0x0049A058 | 00 0C 40 F9 | LDR             X0, [X0,#0x18]\n0x0049A05C | 1F 00 00 F1 | CMP             X0, #0\n0x0049A060 | E0 00 00 54 | B.EQ            loc_49A07C\n0x0049A064 | E0 13 40 F9 | LDR             X0, [SP,#0x30+funcp]\n0x0049A068 | 00 0C 40 F9 | LDR             X0, [X0,#0x18]; pi\n0x0049A06C | 3D EC FF 97 | BL              free_pipe_list\n0x0049A070 | E0 13 40 F9 | LDR             X0, [SP,#0x30+funcp]\n0x0049A074 | 00 04 40 F9 | LDR             X0, [X0,#8]; ptr\n0x0049A078 | 1A B5 FD 97 | BL              .free\n0x0049A07C | E0 13 40 F9 | LDR             X0, [SP,#0x30+funcp]; ptr\n0x0049A080 | 18 B5 FD 97 | BL              .free\n0x0049A084 | 1F 20 03 D5 | NOP\n0x0049A088 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0049A08C | C0 03 5F D6 | RET",
        "output": "```c\nvoid function(char *name) {\n    char **funcpp;\n    char *funcp;\n\n    funcp = find_function_slot(name);\n    funcpp = &funcp;\n\n    if (funcp != NULL) {\n        *funcpp = *funcp;\n        if (*(funcp + 0x18) != NULL) {\n            free_pipe_list(*(funcp + 0x18));\n            free(*(funcp + 0x8));\n        }\n        free(funcp);\n    }\n}\n```"
    },
    {
        "func_name": "rtnl_a2n",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0045C6AC | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x0045C6B0 | FD 03 00 91 | MOV             X29, SP\n0x0045C6B4 | E0 17 00 F9 | STR             X0, [SP,#0x40+tab]\n0x0045C6B8 | E1 13 00 F9 | STR             X1, [SP,#0x40+id]\n0x0045C6BC | E2 0F 00 F9 | STR             X2, [SP,#0x40+arg]\n0x0045C6C0 | E3 17 00 B9 | STR             W3, [SP,#0x40+base]\n0x0045C6C4 | E0 17 40 F9 | LDR             X0, [SP,#0x40+tab]\n0x0045C6C8 | 00 00 40 F9 | LDR             X0, [X0]\n0x0045C6CC | 1F 00 00 F1 | CMP             X0, #0\n0x0045C6D0 | A0 01 00 54 | B.EQ            loc_45C704\n0x0045C6D4 | E0 17 40 F9 | LDR             X0, [SP,#0x40+tab]\n0x0045C6D8 | 00 00 40 F9 | LDR             X0, [X0]; s1\n0x0045C6DC | E1 0F 40 F9 | LDR             X1, [SP,#0x40+arg]; s2\n0x0045C6E0 | 3C AB FE 97 | BL              .strcmp\n0x0045C6E4 | 1F 00 00 71 | CMP             W0, #0\n0x0045C6E8 | E1 00 00 54 | B.NE            loc_45C704\n0x0045C6EC | E0 17 40 F9 | LDR             X0, [SP,#0x40+tab]\n0x0045C6F0 | 01 08 40 B9 | LDR             W1, [X0,#8]\n0x0045C6F4 | E0 13 40 F9 | LDR             X0, [SP,#0x40+id]\n0x0045C6F8 | 01 00 00 B9 | STR             W1, [X0]\n0x0045C6FC | 00 00 80 52 | MOV             W0, #0\n0x0045C700 | 33 00 00 14 | B               loc_45C7CC\n0x0045C704 | FF 3F 00 B9 | STR             WZR, [SP,#0x40+i]\n0x0045C708 | 20 00 00 14 | B               loc_45C788\n0x0045C70C | E0 17 40 F9 | LDR             X0, [SP,#0x40+tab]\n0x0045C710 | E1 3F 40 B9 | LDR             W1, [SP,#0x40+i]\n0x0045C714 | 21 08 00 91 | ADD             X1, X1, #2\n0x0045C718 | 00 78 61 F8 | LDR             X0, [X0,X1,LSL#3]\n0x0045C71C | 1F 00 00 F1 | CMP             X0, #0\n0x0045C720 | E0 02 00 54 | B.EQ            loc_45C77C\n0x0045C724 | E0 17 40 F9 | LDR             X0, [SP,#0x40+tab]\n0x0045C728 | E1 3F 40 B9 | LDR             W1, [SP,#0x40+i]\n0x0045C72C | 21 08 00 91 | ADD             X1, X1, #2\n0x0045C730 | 00 78 61 F8 | LDR             X0, [X0,X1,LSL#3]; s1\n0x0045C734 | E1 0F 40 F9 | LDR             X1, [SP,#0x40+arg]; s2\n0x0045C738 | 26 AB FE 97 | BL              .strcmp\n0x0045C73C | 1F 00 00 71 | CMP             W0, #0\n0x0045C740 | E1 01 00 54 | B.NE            loc_45C77C\n0x0045C744 | E0 17 40 F9 | LDR             X0, [SP,#0x40+tab]\n0x0045C748 | E1 3F 40 B9 | LDR             W1, [SP,#0x40+i]\n0x0045C74C | 21 08 00 91 | ADD             X1, X1, #2\n0x0045C750 | 01 78 61 F8 | LDR             X1, [X0,X1,LSL#3]\n0x0045C754 | E0 17 40 F9 | LDR             X0, [SP,#0x40+tab]\n0x0045C758 | 01 00 00 F9 | STR             X1, [X0]\n0x0045C75C | E0 17 40 F9 | LDR             X0, [SP,#0x40+tab]\n0x0045C760 | E1 3F 40 B9 | LDR             W1, [SP,#0x40+i]\n0x0045C764 | 01 08 00 B9 | STR             W1, [X0,#8]\n0x0045C768 | E0 13 40 F9 | LDR             X0, [SP,#0x40+id]\n0x0045C76C | E1 3F 40 B9 | LDR             W1, [SP,#0x40+i]\n0x0045C770 | 01 00 00 B9 | STR             W1, [X0]\n0x0045C774 | 00 00 80 52 | MOV             W0, #0\n0x0045C778 | 15 00 00 14 | B               loc_45C7CC\n0x0045C77C | E0 3F 40 B9 | LDR             W0, [SP,#0x40+i]\n0x0045C780 | 00 04 00 11 | ADD             W0, W0, #1\n0x0045C784 | E0 3F 00 B9 | STR             W0, [SP,#0x40+i]\n0x0045C788 | E0 3F 40 B9 | LDR             W0, [SP,#0x40+i]\n0x0045C78C | 1F FC 03 71 | CMP             W0, #0xFF\n0x0045C790 | E9 FB FF 54 | B.LS            loc_45C70C\n0x0045C794 | E2 17 40 B9 | LDR             W2, [SP,#0x40+base]; base\n0x0045C798 | 01 00 80 D2 | MOV             X1, #0; endp\n0x0045C79C | E0 0F 40 F9 | LDR             X0, [SP,#0x40+arg]; arg\n0x0045C7A0 | BA C0 FE 97 | BL              bb_strtou\n0x0045C7A4 | E0 3F 00 B9 | STR             W0, [SP,#0x40+i]\n0x0045C7A8 | E0 3F 40 B9 | LDR             W0, [SP,#0x40+i]\n0x0045C7AC | 1F FC 03 71 | CMP             W0, #0xFF\n0x0045C7B0 | 69 00 00 54 | B.LS            loc_45C7BC\n0x0045C7B4 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x0045C7B8 | 05 00 00 14 | B               loc_45C7CC\n0x0045C7BC | E0 13 40 F9 | LDR             X0, [SP,#0x40+id]\n0x0045C7C0 | E1 3F 40 B9 | LDR             W1, [SP,#0x40+i]\n0x0045C7C4 | 01 00 00 B9 | STR             W1, [X0]\n0x0045C7C8 | 00 00 80 52 | MOV             W0, #0\n0x0045C7CC | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x0045C7D0 | C0 03 5F D6 | RET",
        "output": "```c\nunsigned int func(unsigned long long *tab, unsigned long long *id, const char *arg, unsigned int base) {\n    if (!*tab) {\n        return -1;\n    }\n\n    if (strcmp((const char *)*tab, arg) == 0) {\n        *id = *(unsigned int *)(*tab + 8);\n        return 0;\n    }\n\n    for (unsigned int i = 0; i <= 0xFF; ++i) {\n        if (!tab[i + 2]) {\n            break;\n        }\n\n        if (strcmp((const char *)tab[i + 2], arg) == 0) {\n            *tab = tab[i + 2];\n            *(unsigned int *)(*tab + 8) = i;\n            *id = i;\n            return 0;\n        }\n    }\n\n    unsigned int i = bb_strtou(arg, NULL, base);\n    if (i <= 0xFF) {\n        *id = i;\n        return 0;\n    }\n\n    return -1;\n}\n```"
    },
    {
        "func_name": "ll_init_map",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0045C50C | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0045C510 | FD 03 00 91 | MOV             X29, SP\n0x0045C514 | E0 0F 00 F9 | STR             X0, [SP,#0x20+rth]\n0x0045C518 | 42 02 80 52 | MOV             W2, #0x12; type\n0x0045C51C | 01 00 80 52 | MOV             W1, #0; family\n0x0045C520 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rth]; rth\n0x0045C524 | F3 FA FF 97 | BL              xrtnl_wilddump_request\n0x0045C528 | 02 00 80 D2 | MOV             X2, #0; arg1\n0x0045C52C | 00 00 00 90 | ADRP            X0, #ll_remember_index@PAGE\n0x0045C530 | 01 20 05 91 | ADD             X1, X0, #ll_remember_index@PAGEOFF; filter\n0x0045C534 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+rth]; rth\n0x0045C538 | 13 FC FF 97 | BL              xrtnl_dump_filter\n0x0045C53C | 00 00 80 52 | MOV             W0, #0\n0x0045C540 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0045C544 | C0 03 5F D6 | RET",
        "output": "```c\nvoid function(uint64_t rth) {\n    uint32_t type = 0x12;\n    uint32_t family = 0;\n    xrtnl_wilddump_request(rth, family, type);\n    uint64_t arg1 = 0;\n    uint64_t filter = (uint64_t)&ll_remember_index;\n    xrtnl_dump_filter(rth, filter, arg1);\n    return 0;\n}\n```"
    },
    {
        "func_name": "strip_unsafe_prefix",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004DD804 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004DD808 | FD 03 00 91 | MOV             X29, SP\n0x004DD80C | E0 0F 00 F9 | STR             X0, [SP,#0x30+str]\n0x004DD810 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+str]\n0x004DD814 | E0 17 00 F9 | STR             X0, [SP,#0x30+cp]\n0x004DD818 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cp]\n0x004DD81C | 00 00 40 39 | LDRB            W0, [X0]\n0x004DD820 | 1F BC 00 71 | CMP             W0, #0x2F ; '/'\n0x004DD824 | A1 00 00 54 | B.NE            loc_4DD838\n0x004DD828 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cp]\n0x004DD82C | 00 04 00 91 | ADD             X0, X0, #1\n0x004DD830 | E0 17 00 F9 | STR             X0, [SP,#0x30+cp]\n0x004DD834 | 18 00 00 14 | B               loc_4DD894\n0x004DD838 | C0 03 00 F0 00 A4 20 91 | ADRL            X0, (asc_558828+1); \"../\"\n0x004DD840 | 62 00 80 D2 | MOV             X2, #3; n\n0x004DD844 | E1 03 00 AA | MOV             X1, X0; s2\n0x004DD848 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cp]; s1\n0x004DD84C | 8D A5 FC 97 | BL              .strncmp\n0x004DD850 | 1F 00 00 71 | CMP             W0, #0\n0x004DD854 | A1 00 00 54 | B.NE            loc_4DD868\n0x004DD858 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cp]\n0x004DD85C | 00 0C 00 91 | ADD             X0, X0, #3\n0x004DD860 | E0 17 00 F9 | STR             X0, [SP,#0x30+cp]\n0x004DD864 | 0C 00 00 14 | B               loc_4DD894\n0x004DD868 | C0 03 00 F0 | ADRP            X0, #asc_558828@PAGE; \"/../\"\n0x004DD86C | 01 A0 20 91 | ADD             X1, X0, #asc_558828@PAGEOFF; \"/../\"\n0x004DD870 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cp]; haystack\n0x004DD874 | 5F A8 FC 97 | BL              .strstr\n0x004DD878 | E0 13 00 F9 | STR             X0, [SP,#0x30+cp2]\n0x004DD87C | E0 13 40 F9 | LDR             X0, [SP,#0x30+cp2]\n0x004DD880 | 1F 00 00 F1 | CMP             X0, #0\n0x004DD884 | A0 00 00 54 | B.EQ            loc_4DD898\n0x004DD888 | E0 13 40 F9 | LDR             X0, [SP,#0x30+cp2]\n0x004DD88C | 00 10 00 91 | ADD             X0, X0, #4\n0x004DD890 | E0 17 00 F9 | STR             X0, [SP,#0x30+cp]\n0x004DD894 | E1 FF FF 17 | B               loc_4DD818\n0x004DD898 | 1F 20 03 D5 | NOP\n0x004DD89C | E1 17 40 F9 | LDR             X1, [SP,#0x30+cp]\n0x004DD8A0 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+str]\n0x004DD8A4 | 3F 00 00 EB | CMP             X1, X0\n0x004DD8A8 | 40 02 00 54 | B.EQ            loc_4DD8F0\n0x004DD8AC | A0 05 00 D0 00 F0 09 91 | ADRL            X0, warned.9679\n0x004DD8B4 | 00 00 40 B9 | LDR             W0, [X0]\n0x004DD8B8 | 1F 00 00 71 | CMP             W0, #0\n0x004DD8BC | A1 01 00 54 | B.NE            loc_4DD8F0\n0x004DD8C0 | A0 05 00 D0 00 F0 09 91 | ADRL            X0, warned.9679\n0x004DD8C8 | 21 00 80 52 | MOV             W1, #1\n0x004DD8CC | 01 00 00 B9 | STR             W1, [X0]\n0x004DD8D0 | E1 17 40 F9 | LDR             X1, [SP,#0x30+cp]\n0x004DD8D4 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+str]\n0x004DD8D8 | 20 00 00 CB | SUB             X0, X1, X0\n0x004DD8DC | E2 0F 40 F9 | LDR             X2, [SP,#0x30+str]\n0x004DD8E0 | E1 03 00 2A | MOV             W1, W0\n0x004DD8E4 | C0 03 00 F0 00 C0 20 91 | ADRL            X0, aRemovingLeadin; \"removing leading '%.*s' from member nam\"...\n0x004DD8EC | 0A B1 FC 97 | BL              bb_error_msg\n0x004DD8F0 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cp]\n0x004DD8F4 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004DD8F8 | C0 03 5F D6 | RET",
        "output": "```c\nchar *cp;\nchar *str;\nchar *cp2;\nconst char *warned_9679;\n\ncp = str;\ndo {\n    if (*cp == '/') {\n        cp++;\n        continue;\n    }\n    if (strncmp(cp, \"../\", 3) == 0) {\n        cp += 3;\n        continue;\n    }\n    if (strstr(cp, \"/../\") != NULL) {\n        cp2 = strstr(cp, \"/../\") + 4;\n        cp = cp2;\n        continue;\n    }\n    break;\n} while (1);\n\nif (cp != str) {\n    if (!warned_9679) {\n        warned_9679 = 1;\n        bb_error_msg(\"removing leading '%.*s' from member name\", cp - str, str);\n    }\n}\nreturn cp;\n```"
    },
    {
        "func_name": "read_line",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004A57AC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004A57B0 | FD 03 00 91 | MOV             X29, SP\n0x004A57B4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+prompt]\n0x004A57B8 | 80 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004A57C0 | 00 00 40 F9 | LDR             X0, [X0]\n0x004A57C4 | 00 A0 06 91 | ADD             X0, X0, #0x1A8\n0x004A57C8 | 04 00 80 12 | MOV             W4, #0xFFFFFFFF; timeout\n0x004A57CC | 03 0A 80 52 | MOV             W3, #0x50 ; 'P'; maxsize\n0x004A57D0 | E2 03 00 AA | MOV             X2, X0; command\n0x004A57D4 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+prompt]; prompt\n0x004A57D8 | 00 00 80 D2 | MOV             X0, #0; st\n0x004A57DC | B1 0B 02 94 | BL              read_line_input\n0x004A57E0 | E0 2F 00 B9 | STR             W0, [SP,#0x30+sz]\n0x004A57E4 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+sz]\n0x004A57E8 | 1F 00 00 71 | CMP             W0, #0\n0x004A57EC | 6C 00 00 54 | B.GT            loc_4A57F8\n0x004A57F0 | 00 00 80 52 | MOV             W0, #0; status\n0x004A57F4 | E7 83 FD 97 | BL              .exit\n0x004A57F8 | 80 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004A5800 | 01 00 40 F9 | LDR             X1, [X0]\n0x004A5804 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+sz]\n0x004A5808 | 00 04 00 51 | SUB             W0, W0, #1\n0x004A580C | 00 7C 40 93 | SXTW            X0, W0\n0x004A5810 | 20 00 00 8B | ADD             X0, X1, X0\n0x004A5814 | 00 A0 46 39 | LDRB            W0, [X0,#0x1A8]\n0x004A5818 | 1F 28 00 71 | CMP             W0, #0xA\n0x004A581C | 41 01 00 54 | B.NE            loc_4A5844\n0x004A5820 | 80 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004A5828 | 01 00 40 F9 | LDR             X1, [X0]\n0x004A582C | E0 2F 40 B9 | LDR             W0, [SP,#0x30+sz]\n0x004A5830 | 00 04 00 51 | SUB             W0, W0, #1\n0x004A5834 | E0 2F 00 B9 | STR             W0, [SP,#0x30+sz]\n0x004A5838 | E0 2F 80 B9 | LDRSW           X0, [SP,#0x30+sz]\n0x004A583C | 20 00 00 8B | ADD             X0, X1, X0\n0x004A5840 | 1F A0 06 39 | STRB            WZR, [X0,#0x1A8]\n0x004A5844 | 80 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004A584C | 01 00 40 F9 | LDR             X1, [X0]\n0x004A5850 | 80 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004A5858 | 00 00 40 F9 | LDR             X0, [X0]\n0x004A585C | 21 A0 06 91 | ADD             X1, X1, #0x1A8\n0x004A5860 | 01 00 00 F9 | STR             X1, [X0]\n0x004A5864 | 07 00 00 14 | B               loc_4A5880\n0x004A5868 | 80 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004A5870 | 00 00 40 F9 | LDR             X0, [X0]\n0x004A5874 | 01 00 40 F9 | LDR             X1, [X0]\n0x004A5878 | 21 04 00 91 | ADD             X1, X1, #1\n0x004A587C | 01 00 00 F9 | STR             X1, [X0]\n0x004A5880 | 80 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004A5888 | 00 00 40 F9 | LDR             X0, [X0]\n0x004A588C | 00 00 40 F9 | LDR             X0, [X0]\n0x004A5890 | 00 00 40 39 | LDRB            W0, [X0]\n0x004A5894 | 1F 00 00 71 | CMP             W0, #0\n0x004A5898 | 00 01 00 54 | B.EQ            loc_4A58B8\n0x004A589C | 80 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004A58A4 | 00 00 40 F9 | LDR             X0, [X0]\n0x004A58A8 | 00 00 40 F9 | LDR             X0, [X0]\n0x004A58AC | 00 00 40 39 | LDRB            W0, [X0]\n0x004A58B0 | 1F 80 00 71 | CMP             W0, #0x20 ; ' '\n0x004A58B4 | A9 FD FF 54 | B.LS            loc_4A5868\n0x004A58B8 | 80 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004A58C0 | 00 00 40 F9 | LDR             X0, [X0]\n0x004A58C4 | 00 00 40 F9 | LDR             X0, [X0]\n0x004A58C8 | 00 00 40 39 | LDRB            W0, [X0]\n0x004A58CC | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004A58D0 | C0 03 5F D6 | RET",
        "output": "```c\nvoid read_line_input(char *prompt, char *command, int maxsize, int timeout);\n\nvoid function(char *prompt) {\n    char *command = ptr_to_globals + 0x1A8;\n    int sz = read_line_input(prompt, command, 0x50, -1);\n\n    if (sz > 0) {\n        if (command[sz - 1] == '\\n') {\n            command[sz - 1] = '\\0';\n        }\n        ptr_to_globals[0x1A8] = ptr_to_globals + 0x1A8;\n    }\n\n    char *ptr = ptr_to_globals;\n    while (*ptr) {\n        if (*ptr <= ' ') {\n            ptr++;\n        } else {\n            break;\n        }\n    }\n}\n```"
    },
    {
        "func_name": "conv_c",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0051E6A0 | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x0051E6A4 | FD 03 00 91 | MOV             X29, SP\n0x0051E6A8 | E0 0F 00 F9 | STR             X0, [SP,#0x40+pr]\n0x0051E6AC | E1 0B 00 F9 | STR             X1, [SP,#0x40+p]\n0x0051E6B0 | 00 02 00 90 00 58 3A 91 | ADRL            X0, conv_str\n0x0051E6B8 | E0 1F 00 F9 | STR             X0, [SP,#0x40+str]\n0x0051E6BC | E0 0B 40 F9 | LDR             X0, [SP,#0x40+p]\n0x0051E6C0 | 01 00 40 39 | LDRB            W1, [X0]\n0x0051E6C4 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+str]\n0x0051E6C8 | 00 00 40 39 | LDRB            W0, [X0]\n0x0051E6CC | 3F 00 00 6B | CMP             W1, W0\n0x0051E6D0 | A1 00 00 54 | B.NE            loc_51E6E4\n0x0051E6D4 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+str]\n0x0051E6D8 | 00 04 00 91 | ADD             X0, X0, #1\n0x0051E6DC | E0 1F 00 F9 | STR             X0, [SP,#0x40+str]\n0x0051E6E0 | 23 00 00 14 | B               strpr\n0x0051E6E4 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+str]\n0x0051E6E8 | 00 10 00 91 | ADD             X0, X0, #4\n0x0051E6EC | E0 1F 00 F9 | STR             X0, [SP,#0x40+str]\n0x0051E6F0 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+str]\n0x0051E6F4 | 00 00 40 39 | LDRB            W0, [X0]\n0x0051E6F8 | 1F 00 00 71 | CMP             W0, #0\n0x0051E6FC | 01 FE FF 54 | B.NE            loc_51E6BC\n0x0051E700 | E0 0B 40 F9 | LDR             X0, [SP,#0x40+p]\n0x0051E704 | 00 00 40 39 | LDRB            W0, [X0]\n0x0051E708 | 00 80 00 51 | SUB             W0, W0, #0x20 ; ' '\n0x0051E70C | 1F 78 01 71 | CMP             W0, #0x5E ; '^'\n0x0051E710 | A8 01 00 54 | B.HI            loc_51E744\n0x0051E714 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+pr]\n0x0051E718 | 00 08 40 F9 | LDR             X0, [X0,#0x10]\n0x0051E71C | 61 0C 80 52 | MOV             W1, #0x63 ; 'c'\n0x0051E720 | 01 00 00 39 | STRB            W1, [X0]\n0x0051E724 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+pr]\n0x0051E728 | 02 0C 40 F9 | LDR             X2, [X0,#0x18]\n0x0051E72C | E0 0B 40 F9 | LDR             X0, [SP,#0x40+p]\n0x0051E730 | 00 00 40 39 | LDRB            W0, [X0]\n0x0051E734 | E1 03 00 2A | MOV             W1, W0\n0x0051E738 | E0 03 02 AA | MOV             X0, X2; format\n0x0051E73C | 25 A5 FB 97 | BL              .printf\n0x0051E740 | 13 00 00 14 | B               loc_51E78C\n0x0051E744 | E0 0B 40 F9 | LDR             X0, [SP,#0x40+p]\n0x0051E748 | 00 00 40 39 | LDRB            W0, [X0]\n0x0051E74C | E3 A3 00 91 | ADD             X3, SP, #0x40+buf\n0x0051E750 | E2 03 00 2A | MOV             W2, W0\n0x0051E754 | 00 02 00 90 | ADRP            X0, #a03o_0@PAGE; \"%03o\"\n0x0051E758 | 01 E0 3A 91 | ADD             X1, X0, #a03o_0@PAGEOFF; \"%03o\"\n0x0051E75C | E0 03 03 AA | MOV             X0, X3; s\n0x0051E760 | D0 A0 FB 97 | BL              .sprintf\n0x0051E764 | E0 A3 00 91 | ADD             X0, SP, #0x40+buf\n0x0051E768 | E0 1F 00 F9 | STR             X0, [SP,#0x40+str]\n0x0051E76C | E0 0F 40 F9 | LDR             X0, [SP,#0x40+pr]\n0x0051E770 | 00 08 40 F9 | LDR             X0, [X0,#0x10]\n0x0051E774 | 61 0E 80 52 | MOV             W1, #0x73 ; 's'\n0x0051E778 | 01 00 00 39 | STRB            W1, [X0]\n0x0051E77C | E0 0F 40 F9 | LDR             X0, [SP,#0x40+pr]\n0x0051E780 | 00 0C 40 F9 | LDR             X0, [X0,#0x18]; format\n0x0051E784 | E1 1F 40 F9 | LDR             X1, [SP,#0x40+str]\n0x0051E788 | 12 A5 FB 97 | BL              .printf\n0x0051E78C | 1F 20 03 D5 | NOP\n0x0051E790 | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x0051E794 | C0 03 5F D6 | RET",
        "output": "```c\n#include <stdio.h>\n\nvoid function(char *p, char *pr) {\n    char *str = \"conv_str\";\n    char buf[4];\n\n    while (*p == *str) {\n        str++;\n    }\n\n    if (*p <= ' ') {\n        pr[0x10] = 'c';\n        pr[0x18] = *p;\n        printf(\"%c\", *p);\n    } else {\n        sprintf(buf, \"%03o\", *p);\n        str = buf;\n        pr[0x10] = 's';\n        printf(\"%s\", str);\n    }\n}\n```"
    },
    {
        "func_name": "set_vars_and_save_old",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00493B24 | FD 7B BB A9 | STP             X29, X30, [SP,#var_50]!\n0x00493B28 | FD 03 00 91 | MOV             X29, SP\n0x00493B2C | E0 0F 00 F9 | STR             X0, [SP,#0x50+strings]\n0x00493B30 | FF 23 00 F9 | STR             XZR, [SP,#0x50+old]\n0x00493B34 | E0 0F 40 F9 | LDR             X0, [SP,#0x50+strings]\n0x00493B38 | 1F 00 00 F1 | CMP             X0, #0\n0x00493B3C | 61 00 00 54 | B.NE            loc_493B48\n0x00493B40 | E0 23 40 F9 | LDR             X0, [SP,#0x50+old]\n0x00493B44 | 32 00 00 14 | B               loc_493C0C\n0x00493B48 | E0 0F 40 F9 | LDR             X0, [SP,#0x50+strings]\n0x00493B4C | E0 27 00 F9 | STR             X0, [SP,#0x50+s]\n0x00493B50 | 2A 00 00 14 | B               loc_493BF8\n0x00493B54 | E0 27 40 F9 | LDR             X0, [SP,#0x50+s]\n0x00493B58 | 00 00 40 F9 | LDR             X0, [X0]; s\n0x00493B5C | A1 07 80 52 | MOV             W1, #0x3D ; '='; c\n0x00493B60 | C4 CE FD 97 | BL              .strchr\n0x00493B64 | E0 1F 00 F9 | STR             X0, [SP,#0x50+eq]\n0x00493B68 | E0 1F 40 F9 | LDR             X0, [SP,#0x50+eq]\n0x00493B6C | 1F 00 00 F1 | CMP             X0, #0\n0x00493B70 | E0 03 00 54 | B.EQ            loc_493BEC\n0x00493B74 | E0 27 40 F9 | LDR             X0, [SP,#0x50+s]\n0x00493B78 | 02 00 40 F9 | LDR             X2, [X0]\n0x00493B7C | E0 27 40 F9 | LDR             X0, [SP,#0x50+s]\n0x00493B80 | 00 00 40 F9 | LDR             X0, [X0]\n0x00493B84 | E1 1F 40 F9 | LDR             X1, [SP,#0x50+eq]\n0x00493B88 | 20 00 00 CB | SUB             X0, X1, X0\n0x00493B8C | E1 03 00 2A | MOV             W1, W0; len\n0x00493B90 | E0 03 02 AA | MOV             X0, X2; name\n0x00493B94 | E5 FD FF 97 | BL              get_ptr_to_local_var\n0x00493B98 | E0 1B 00 F9 | STR             X0, [SP,#0x50+var_pp]\n0x00493B9C | E0 1B 40 F9 | LDR             X0, [SP,#0x50+var_pp]\n0x00493BA0 | 1F 00 00 F1 | CMP             X0, #0\n0x00493BA4 | A0 01 00 54 | B.EQ            loc_493BD8\n0x00493BA8 | E0 1B 40 F9 | LDR             X0, [SP,#0x50+var_pp]\n0x00493BAC | 00 00 40 F9 | LDR             X0, [X0]\n0x00493BB0 | E0 17 00 F9 | STR             X0, [SP,#0x50+var_p]\n0x00493BB4 | E0 17 40 F9 | LDR             X0, [SP,#0x50+var_p]\n0x00493BB8 | 01 00 40 F9 | LDR             X1, [X0]\n0x00493BBC | E0 1B 40 F9 | LDR             X0, [SP,#0x50+var_pp]\n0x00493BC0 | 01 00 00 F9 | STR             X1, [X0]\n0x00493BC4 | E0 17 40 F9 | LDR             X0, [SP,#0x50+var_p]\n0x00493BC8 | E1 23 40 F9 | LDR             X1, [SP,#0x50+old]\n0x00493BCC | 01 00 00 F9 | STR             X1, [X0]\n0x00493BD0 | E0 17 40 F9 | LDR             X0, [SP,#0x50+var_p]\n0x00493BD4 | E0 23 00 F9 | STR             X0, [SP,#0x50+old]\n0x00493BD8 | E0 27 40 F9 | LDR             X0, [SP,#0x50+s]\n0x00493BDC | 00 00 40 F9 | LDR             X0, [X0]; str\n0x00493BE0 | 02 00 80 52 | MOV             W2, #0; local_lvl\n0x00493BE4 | 21 00 80 52 | MOV             W1, #1; flg_export\n0x00493BE8 | 4E FE FF 97 | BL              set_local_var\n0x00493BEC | E0 27 40 F9 | LDR             X0, [SP,#0x50+s]\n0x00493BF0 | 00 20 00 91 | ADD             X0, X0, #8\n0x00493BF4 | E0 27 00 F9 | STR             X0, [SP,#0x50+s]\n0x00493BF8 | E0 27 40 F9 | LDR             X0, [SP,#0x50+s]\n0x00493BFC | 00 00 40 F9 | LDR             X0, [X0]\n0x00493C00 | 1F 00 00 F1 | CMP             X0, #0\n0x00493C04 | 81 FA FF 54 | B.NE            loc_493B54\n0x00493C08 | E0 23 40 F9 | LDR             X0, [SP,#0x50+old]\n0x00493C0C | FD 7B C5 A8 | LDP             X29, X30, [SP+0x50+var_50],#0x50\n0x00493C10 | C0 03 5F D6 | RET",
        "output": "```c\nvoid function(char *strings) {\n    char *s = strings;\n    char *old = NULL;\n    char *eq;\n    char **var_pp;\n    char *var_p;\n\n    while (*s) {\n        eq = strchr(s, '=');\n        if (eq) {\n            char *name = s;\n            int len = eq - s;\n            var_pp = get_ptr_to_local_var(name, len);\n            if (var_pp) {\n                var_p = *var_pp;\n                *var_pp = old;\n                old = var_p;\n            }\n            s = eq + 1;\n            set_local_var(s, 1, 0);\n        } else {\n            s += 8;\n        }\n    }\n    return old;\n}\n```"
    },
    {
        "func_name": "same_serv_addr_proto",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043BF88 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0043BF8C | FD 03 00 91 | MOV             X29, SP\n0x0043BF90 | E0 0F 00 F9 | STR             X0, [SP,#0x20+old]\n0x0043BF94 | E1 0B 00 F9 | STR             X1, [SP,#0x20+new]\n0x0043BF98 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+old]\n0x0043BF9C | 02 04 40 F9 | LDR             X2, [X0,#8]\n0x0043BFA0 | E0 0B 40 F9 | LDR             X0, [SP,#0x20+new]\n0x0043BFA4 | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x0043BFA8 | E1 03 00 AA | MOV             X1, X0; s2\n0x0043BFAC | E0 03 02 AA | MOV             X0, X2; s1\n0x0043BFB0 | 08 2D FF 97 | BL              .strcmp\n0x0043BFB4 | 1F 00 00 71 | CMP             W0, #0\n0x0043BFB8 | 60 00 00 54 | B.EQ            loc_43BFC4\n0x0043BFBC | 00 00 80 52 | MOV             W0, #0\n0x0043BFC0 | 18 00 00 14 | B               loc_43C020\n0x0043BFC4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+old]\n0x0043BFC8 | 02 08 40 F9 | LDR             X2, [X0,#0x10]\n0x0043BFCC | E0 0B 40 F9 | LDR             X0, [SP,#0x20+new]\n0x0043BFD0 | 00 08 40 F9 | LDR             X0, [X0,#0x10]\n0x0043BFD4 | E1 03 00 AA | MOV             X1, X0; s2\n0x0043BFD8 | E0 03 02 AA | MOV             X0, X2; s1\n0x0043BFDC | FD 2C FF 97 | BL              .strcmp\n0x0043BFE0 | 1F 00 00 71 | CMP             W0, #0\n0x0043BFE4 | 60 00 00 54 | B.EQ            loc_43BFF0\n0x0043BFE8 | 00 00 80 52 | MOV             W0, #0\n0x0043BFEC | 0D 00 00 14 | B               loc_43C020\n0x0043BFF0 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+old]\n0x0043BFF4 | 02 0C 40 F9 | LDR             X2, [X0,#0x18]\n0x0043BFF8 | E0 0B 40 F9 | LDR             X0, [SP,#0x20+new]\n0x0043BFFC | 00 0C 40 F9 | LDR             X0, [X0,#0x18]\n0x0043C000 | E1 03 00 AA | MOV             X1, X0; s2\n0x0043C004 | E0 03 02 AA | MOV             X0, X2; s1\n0x0043C008 | F2 2C FF 97 | BL              .strcmp\n0x0043C00C | 1F 00 00 71 | CMP             W0, #0\n0x0043C010 | 60 00 00 54 | B.EQ            loc_43C01C\n0x0043C014 | 00 00 80 52 | MOV             W0, #0\n0x0043C018 | 02 00 00 14 | B               loc_43C020\n0x0043C01C | 20 00 80 52 | MOV             W0, #1\n0x0043C020 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0043C024 | C0 03 5F D6 | RET",
        "output": "```c\nint compare_structs(void* old, void* new) {\n    if (strcmp(((char**)old)[1], ((char**)new)[1]) != 0) {\n        return 0;\n    }\n    if (strcmp(((char**)old)[2], ((char**)new)[2]) != 0) {\n        return 0;\n    }\n    if (strcmp(((char**)old)[3], ((char**)new)[3]) != 0) {\n        return 0;\n    }\n    return 1;\n}\n```"
    },
    {
        "func_name": "bsPutU32",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C5BE8 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x004C5BEC | FD 03 00 91 | MOV             X29, SP\n0x004C5BF0 | E0 0F 00 F9 | STR             X0, [SP,#0x20+s]\n0x004C5BF4 | E1 17 00 B9 | STR             W1, [SP,#0x20+u]\n0x004C5BF8 | E0 17 40 B9 | LDR             W0, [SP,#0x20+u]\n0x004C5BFC | 01 7C 18 53 | LSR             W1, W0, #0x18\n0x004C5C00 | E2 03 01 2A | MOV             W2, W1; v\n0x004C5C04 | 01 01 80 52 | MOV             W1, #8; n\n0x004C5C08 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+s]; s\n0x004C5C0C | BE FF FF 97 | BL              bsW\n0x004C5C10 | E0 17 40 B9 | LDR             W0, [SP,#0x20+u]\n0x004C5C14 | 00 7C 10 53 | LSR             W0, W0, #0x10\n0x004C5C18 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x004C5C1C | E2 03 00 2A | MOV             W2, W0; v\n0x004C5C20 | 01 01 80 52 | MOV             W1, #8; n\n0x004C5C24 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+s]; s\n0x004C5C28 | B7 FF FF 97 | BL              bsW\n0x004C5C2C | E0 17 40 B9 | LDR             W0, [SP,#0x20+u]\n0x004C5C30 | 00 7C 08 53 | LSR             W0, W0, #8\n0x004C5C34 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x004C5C38 | E2 03 00 2A | MOV             W2, W0; v\n0x004C5C3C | 01 01 80 52 | MOV             W1, #8; n\n0x004C5C40 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+s]; s\n0x004C5C44 | B0 FF FF 97 | BL              bsW\n0x004C5C48 | E0 17 40 B9 | LDR             W0, [SP,#0x20+u]\n0x004C5C4C | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x004C5C50 | E2 03 00 2A | MOV             W2, W0; v\n0x004C5C54 | 01 01 80 52 | MOV             W1, #8; n\n0x004C5C58 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+s]; s\n0x004C5C5C | AA FF FF 97 | BL              bsW\n0x004C5C60 | 1F 20 03 D5 | NOP\n0x004C5C64 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004C5C68 | C0 03 5F D6 | RET",
        "output": "```c\nvoid function(unsigned char *s, unsigned int u) {\n    unsigned char v;\n    unsigned int n = 8;\n\n    v = u >> 24;\n    bsW(s, n, v);\n\n    v = (u >> 16) & 0xFF;\n    bsW(s, n, v);\n\n    v = (u >> 8) & 0xFF;\n    bsW(s, n, v);\n\n    v = u & 0xFF;\n    bsW(s, n, v);\n}\n```"
    },
    {
        "func_name": "xconnect_ftpdata",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00430EE0 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00430EE4 | FD 03 00 91 | MOV             X29, SP\n0x00430EE8 | F3 0B 00 F9 | STR             X19, [SP,#0x30+var_20]\n0x00430EEC | 01 00 80 D2 | MOV             X1, #0; s2\n0x00430EF0 | A0 08 00 B0 00 00 00 91 | ADRL            X0, aPasv; \"PASV\"\n0x00430EF8 | 68 FF FF 97 | BL              ftpcmd\n0x00430EFC | 1F 8C 03 71 | CMP             W0, #0xE3\n0x00430F00 | 80 00 00 54 | B.EQ            loc_430F10\n0x00430F04 | A0 08 00 B0 00 00 00 91 | ADRL            X0, aPasv; \"PASV\"\n0x00430F0C | 38 FF FF 97 | BL              ftp_die\n0x00430F10 | 00 0B 00 F0 00 E0 0A 91 | ADRL            X0, (bb_common_bufsiz1+0x28); s\n0x00430F18 | 21 05 80 52 | MOV             W1, #0x29 ; ')'; c\n0x00430F1C | C1 58 FF 97 | BL              .strrchr\n0x00430F20 | E0 17 00 F9 | STR             X0, [SP,#0x30+buf_ptr]\n0x00430F24 | E0 17 40 F9 | LDR             X0, [SP,#0x30+buf_ptr]\n0x00430F28 | 1F 00 00 F1 | CMP             X0, #0\n0x00430F2C | 60 00 00 54 | B.EQ            loc_430F38\n0x00430F30 | E0 17 40 F9 | LDR             X0, [SP,#0x30+buf_ptr]\n0x00430F34 | 1F 00 00 39 | STRB            WZR, [X0]\n0x00430F38 | 00 0B 00 F0 00 E0 0A 91 | ADRL            X0, (bb_common_bufsiz1+0x28); s\n0x00430F40 | 81 05 80 52 | MOV             W1, #0x2C ; ','; c\n0x00430F44 | B7 58 FF 97 | BL              .strrchr\n0x00430F48 | E0 17 00 F9 | STR             X0, [SP,#0x30+buf_ptr]\n0x00430F4C | E0 17 40 F9 | LDR             X0, [SP,#0x30+buf_ptr]\n0x00430F50 | 1F 00 00 39 | STRB            WZR, [X0]\n0x00430F54 | E0 17 40 F9 | LDR             X0, [SP,#0x30+buf_ptr]\n0x00430F58 | 00 04 00 91 | ADD             X0, X0, #1; str\n0x00430F5C | E2 1F 80 D2 | MOV             X2, #0xFF; u\n0x00430F60 | 01 00 80 D2 | MOV             X1, #0; l\n0x00430F64 | 17 FF FF 97 | BL              xatoul_range_0\n0x00430F68 | E0 27 00 B9 | STR             W0, [SP,#0x30+port_num]\n0x00430F6C | 00 0B 00 F0 00 E0 0A 91 | ADRL            X0, (bb_common_bufsiz1+0x28); s\n0x00430F74 | 81 05 80 52 | MOV             W1, #0x2C ; ','; c\n0x00430F78 | AA 58 FF 97 | BL              .strrchr\n0x00430F7C | E0 17 00 F9 | STR             X0, [SP,#0x30+buf_ptr]\n0x00430F80 | E0 17 40 F9 | LDR             X0, [SP,#0x30+buf_ptr]\n0x00430F84 | 1F 00 00 39 | STRB            WZR, [X0]\n0x00430F88 | E0 17 40 F9 | LDR             X0, [SP,#0x30+buf_ptr]\n0x00430F8C | 00 04 00 91 | ADD             X0, X0, #1; str\n0x00430F90 | E2 1F 80 D2 | MOV             X2, #0xFF; u\n0x00430F94 | 01 00 80 D2 | MOV             X1, #0; l\n0x00430F98 | 0A FF FF 97 | BL              xatoul_range_0\n0x00430F9C | 00 DC 78 D3 | LSL             X0, X0, #8\n0x00430FA0 | E1 03 00 2A | MOV             W1, W0\n0x00430FA4 | E0 27 40 B9 | LDR             W0, [SP,#0x30+port_num]\n0x00430FA8 | 00 00 01 0B | ADD             W0, W0, W1\n0x00430FAC | E0 27 00 B9 | STR             W0, [SP,#0x30+port_num]\n0x00430FB0 | 00 0B 00 F0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x00430FB8 | 00 08 40 F9 | LDR             X0, [X0,#(bb_common_bufsiz1+0x10 - 0x593290)]\n0x00430FBC | 13 10 00 91 | ADD             X19, X0, #4\n0x00430FC0 | E0 27 40 B9 | LDR             W0, [SP,#0x30+port_num]\n0x00430FC4 | 00 3C 00 12 | AND             W0, W0, #0xFFFF; hostshort\n0x00430FC8 | 52 58 FF 97 | BL              .htons\n0x00430FCC | 00 3C 00 12 | AND             W0, W0, #0xFFFF\n0x00430FD0 | E1 03 00 2A | MOV             W1, W0; port\n0x00430FD4 | E0 03 13 AA | MOV             X0, X19; sa\n0x00430FD8 | 98 0E 04 94 | BL              set_nport\n0x00430FDC | 00 0B 00 F0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x00430FE4 | 00 08 40 F9 | LDR             X0, [X0,#(bb_common_bufsiz1+0x10 - 0x593290)]; lsa\n0x00430FE8 | 98 10 04 94 | BL              xconnect_stream\n0x00430FEC | F3 0B 40 F9 | LDR             X19, [SP,#0x30+var_20]\n0x00430FF0 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00430FF4 | C0 03 5F D6 | RET",
        "output": "```c\n#include <stdint.h>\n\nvoid function() {\n    char *buf_ptr;\n    uint32_t port_num;\n    char *s = (char *)(bb_common_bufsiz1 + 0x28);\n    char c;\n    uint32_t u, l;\n\n    if (ftpcmd(\"PASV\", 0) != 0xE3) {\n        ftp_die(\"PASV\");\n    }\n\n    buf_ptr = strrchr(s, ')');\n    if (buf_ptr) {\n        *buf_ptr = '\\0';\n    }\n\n    buf_ptr = strrchr(s, ',');\n    if (buf_ptr) {\n        *buf_ptr = '\\0';\n    }\n\n    buf_ptr++;\n    u = xatoul_range_0(buf_ptr, 0, 0xFF);\n    port_num = u;\n\n    buf_ptr = strrchr(s, ',');\n    if (buf_ptr) {\n        *buf_ptr = '\\0';\n    }\n\n    buf_ptr++;\n    l = xatoul_range_0(buf_ptr, 0, 0xFF);\n    port_num = (port_num << 8) + l;\n\n    struct sockaddr *sa = (struct sockaddr *)(bb_common_bufsiz1 + 0x10);\n    sa->sa_family = AF_INET;\n    ((struct sockaddr_in *)sa)->sin_port = htons(port_num & 0xFFFF);\n\n    xconnect_stream(sa);\n}\n```"
    },
    {
        "func_name": "put_16bit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C88B0 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x004C88B4 | FD 03 00 91 | MOV             X29, SP\n0x004C88B8 | E0 3F 00 79 | STRH            W0, [SP,#0x20+w]\n0x004C88BC | 60 06 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004C88C4 | 00 00 40 F9 | LDR             X0, [X0]\n0x004C88C8 | 00 60 01 D1 | SUB             X0, X0, #0x58 ; 'X'\n0x004C88CC | 01 44 40 B9 | LDR             W1, [X0,#0x44]\n0x004C88D0 | A0 FF 83 52 | MOV             W0, #0x1FFD\n0x004C88D4 | 3F 00 00 6B | CMP             W1, W0\n0x004C88D8 | C8 04 00 54 | B.HI            loc_4C8970\n0x004C88DC | 60 06 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004C88E4 | 00 00 40 F9 | LDR             X0, [X0]\n0x004C88E8 | 00 60 01 D1 | SUB             X0, X0, #0x58 ; 'X'\n0x004C88EC | 02 14 40 F9 | LDR             X2, [X0,#0x28]\n0x004C88F0 | 60 06 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004C88F8 | 00 00 40 F9 | LDR             X0, [X0]\n0x004C88FC | 00 60 01 D1 | SUB             X0, X0, #0x58 ; 'X'\n0x004C8900 | 01 44 40 B9 | LDR             W1, [X0,#0x44]\n0x004C8904 | 23 04 00 11 | ADD             W3, W1, #1\n0x004C8908 | 03 44 00 B9 | STR             W3, [X0,#0x44]\n0x004C890C | E0 03 01 2A | MOV             W0, W1\n0x004C8910 | 40 00 00 8B | ADD             X0, X2, X0\n0x004C8914 | E1 3F 40 79 | LDRH            W1, [SP,#0x20+w]\n0x004C8918 | 21 1C 00 12 | AND             W1, W1, #0xFF\n0x004C891C | 01 00 00 39 | STRB            W1, [X0]\n0x004C8920 | E0 3F 40 79 | LDRH            W0, [SP,#0x20+w]\n0x004C8924 | 00 7C 08 53 | LSR             W0, W0, #8\n0x004C8928 | 04 3C 00 12 | AND             W4, W0, #0xFFFF\n0x004C892C | 60 06 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004C8934 | 00 00 40 F9 | LDR             X0, [X0]\n0x004C8938 | 00 60 01 D1 | SUB             X0, X0, #0x58 ; 'X'\n0x004C893C | 02 14 40 F9 | LDR             X2, [X0,#0x28]\n0x004C8940 | 60 06 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004C8948 | 00 00 40 F9 | LDR             X0, [X0]\n0x004C894C | 00 60 01 D1 | SUB             X0, X0, #0x58 ; 'X'\n0x004C8950 | 01 44 40 B9 | LDR             W1, [X0,#0x44]\n0x004C8954 | 23 04 00 11 | ADD             W3, W1, #1\n0x004C8958 | 03 44 00 B9 | STR             W3, [X0,#0x44]\n0x004C895C | E0 03 01 2A | MOV             W0, W1\n0x004C8960 | 40 00 00 8B | ADD             X0, X2, X0\n0x004C8964 | 81 1C 00 12 | AND             W1, W4, #0xFF\n0x004C8968 | 01 00 00 39 | STRB            W1, [X0]\n0x004C896C | 35 00 00 14 | B               loc_4C8A40\n0x004C8970 | 60 06 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004C8978 | 00 00 40 F9 | LDR             X0, [X0]\n0x004C897C | 00 60 01 D1 | SUB             X0, X0, #0x58 ; 'X'\n0x004C8980 | 02 14 40 F9 | LDR             X2, [X0,#0x28]\n0x004C8984 | 60 06 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004C898C | 00 00 40 F9 | LDR             X0, [X0]\n0x004C8990 | 00 60 01 D1 | SUB             X0, X0, #0x58 ; 'X'\n0x004C8994 | 01 44 40 B9 | LDR             W1, [X0,#0x44]\n0x004C8998 | 23 04 00 11 | ADD             W3, W1, #1\n0x004C899C | 03 44 00 B9 | STR             W3, [X0,#0x44]\n0x004C89A0 | E0 03 01 2A | MOV             W0, W1\n0x004C89A4 | 40 00 00 8B | ADD             X0, X2, X0\n0x004C89A8 | E1 3F 40 79 | LDRH            W1, [SP,#0x20+w]\n0x004C89AC | 21 1C 00 12 | AND             W1, W1, #0xFF\n0x004C89B0 | 01 00 00 39 | STRB            W1, [X0]\n0x004C89B4 | 60 06 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004C89BC | 00 00 40 F9 | LDR             X0, [X0]\n0x004C89C0 | 00 60 01 D1 | SUB             X0, X0, #0x58 ; 'X'\n0x004C89C4 | 00 44 40 B9 | LDR             W0, [X0,#0x44]\n0x004C89C8 | 1F 08 40 71 | CMP             W0, #2,LSL#12\n0x004C89CC | 41 00 00 54 | B.NE            loc_4C89D4\n0x004C89D0 | 98 FF FF 97 | BL              flush_outbuf\n0x004C89D4 | E0 3F 40 79 | LDRH            W0, [SP,#0x20+w]\n0x004C89D8 | 00 7C 08 53 | LSR             W0, W0, #8\n0x004C89DC | 04 3C 00 12 | AND             W4, W0, #0xFFFF\n0x004C89E0 | 60 06 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004C89E8 | 00 00 40 F9 | LDR             X0, [X0]\n0x004C89EC | 00 60 01 D1 | SUB             X0, X0, #0x58 ; 'X'\n0x004C89F0 | 02 14 40 F9 | LDR             X2, [X0,#0x28]\n0x004C89F4 | 60 06 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004C89FC | 00 00 40 F9 | LDR             X0, [X0]\n0x004C8A00 | 00 60 01 D1 | SUB             X0, X0, #0x58 ; 'X'\n0x004C8A04 | 01 44 40 B9 | LDR             W1, [X0,#0x44]\n0x004C8A08 | 23 04 00 11 | ADD             W3, W1, #1\n0x004C8A0C | 03 44 00 B9 | STR             W3, [X0,#0x44]\n0x004C8A10 | E0 03 01 2A | MOV             W0, W1\n0x004C8A14 | 40 00 00 8B | ADD             X0, X2, X0\n0x004C8A18 | 81 1C 00 12 | AND             W1, W4, #0xFF\n0x004C8A1C | 01 00 00 39 | STRB            W1, [X0]\n0x004C8A20 | 60 06 00 B0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004C8A28 | 00 00 40 F9 | LDR             X0, [X0]\n0x004C8A2C | 00 60 01 D1 | SUB             X0, X0, #0x58 ; 'X'\n0x004C8A30 | 00 44 40 B9 | LDR             W0, [X0,#0x44]\n0x004C8A34 | 1F 08 40 71 | CMP             W0, #2,LSL#12\n0x004C8A38 | 41 00 00 54 | B.NE            loc_4C8A40\n0x004C8A3C | 7D FF FF 97 | BL              flush_outbuf\n0x004C8A40 | 1F 20 03 D5 | NOP\n0x004C8A44 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x004C8A48 | C0 03 5F D6 | RET",
        "output": "```c\nvoid function(unsigned short w) {\n    extern void flush_outbuf(void);\n    extern unsigned int* ptr_to_globals;\n    unsigned int* globals = ptr_to_globals - 0x58;\n    unsigned int counter = globals[0x44 / 4];\n    unsigned char* buffer = (unsigned char*)(globals[0x28 / 4]);\n\n    if (counter > 0x1FFD) {\n        flush_outbuf();\n    }\n\n    globals[0x44 / 4] = counter + 1;\n    buffer[counter] = w & 0xFF;\n\n    counter = globals[0x44 / 4];\n    globals[0x44 / 4] = counter + 1;\n    buffer[counter] = (w >> 8) & 0xFF;\n\n    if (globals[0x44 / 4] == (2 << 12)) {\n        flush_outbuf();\n    }\n}\n```"
    },
    {
        "func_name": "send_r_n",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00412AC4 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00412AC8 | FD 03 00 91 | MOV             X29, SP\n0x00412ACC | E0 0F 00 F9 | STR             X0, [SP,#0x20+s]\n0x00412AD0 | 00 0C 00 F0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00412AD8 | 00 00 40 F9 | LDR             X0, [X0]\n0x00412ADC | 00 08 40 B9 | LDR             W0, [X0,#8]\n0x00412AE0 | 1F 00 00 71 | CMP             W0, #0\n0x00412AE4 | A0 00 00 54 | B.EQ            loc_412AF8\n0x00412AE8 | E1 0F 40 F9 | LDR             X1, [SP,#0x20+s]\n0x00412AEC | 60 09 00 B0 00 60 10 91 | ADRL            X0, aSendS; \"send:'%s'\"\n0x00412AF4 | 88 DC FF 97 | BL              bb_error_msg\n0x00412AF8 | E1 0F 40 F9 | LDR             X1, [SP,#0x20+s]\n0x00412AFC | 60 09 00 B0 00 A0 10 91 | ADRL            X0, aS_2; \"%s\\r\\n\"\n0x00412B04 | 33 D4 FF 97 | BL              .printf\n0x00412B08 | 1F 20 03 D5 | NOP\n0x00412B0C | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00412B10 | C0 03 5F D6 | RET",
        "output": "```c\n#include <stdio.h>\n\nvoid function(char *s) {\n    struct {\n        char *ptr_to_globals;\n        char *aSendS;\n        char *aS_2;\n    } *globals;\n\n    globals = (void *)ptr_to_globals;\n    if (globals->ptr_to_globals[8] == 0) {\n        goto loc_412AF8;\n    } else {\n        bb_error_msg(\"send:'%s'\", s);\n    }\n\nloc_412AF8:\n    printf(\"%s\\r\\n\", s);\n}\n```"
    },
    {
        "func_name": "read_to_buf",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0052B6C0 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0052B6C4 | FD 03 00 91 | MOV             X29, SP\n0x0052B6C8 | E0 0F 00 F9 | STR             X0, [SP,#0x30+filename]\n0x0052B6CC | E1 0B 00 F9 | STR             X1, [SP,#0x30+buf]\n0x0052B6D0 | 00 00 80 92 | MOV             X0, #0xFFFFFFFFFFFFFFFF\n0x0052B6D4 | E0 17 00 F9 | STR             X0, [SP,#0x30+ret]\n0x0052B6D8 | 01 00 80 52 | MOV             W1, #0; oflag\n0x0052B6DC | E0 0F 40 F9 | LDR             X0, [SP,#0x30+filename]; file\n0x0052B6E0 | 90 70 FB 97 | BL              .open64\n0x0052B6E4 | E0 27 00 B9 | STR             W0, [SP,#0x30+fd]\n0x0052B6E8 | E0 27 40 B9 | LDR             W0, [SP,#0x30+fd]\n0x0052B6EC | 1F 00 00 71 | CMP             W0, #0\n0x0052B6F0 | 0B 01 00 54 | B.LT            loc_52B710\n0x0052B6F4 | E2 7F 80 D2 | MOV             X2, #0x3FF; nbytes\n0x0052B6F8 | E1 0B 40 F9 | LDR             X1, [SP,#0x30+buf]; buf\n0x0052B6FC | E0 27 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x0052B700 | 6C 70 FB 97 | BL              .read\n0x0052B704 | E0 17 00 F9 | STR             X0, [SP,#0x30+ret]\n0x0052B708 | E0 27 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x0052B70C | B9 6E FB 97 | BL              .close\n0x0052B710 | E1 17 40 F9 | LDR             X1, [SP,#0x30+ret]\n0x0052B714 | E0 17 40 F9 | LDR             X0, [SP,#0x30+ret]\n0x0052B718 | 02 00 80 D2 | MOV             X2, #0\n0x0052B71C | 3F 00 00 F1 | CMP             X1, #0\n0x0052B720 | 00 A0 82 9A | CSEL            X0, X0, X2, GE\n0x0052B724 | E1 03 00 AA | MOV             X1, X0\n0x0052B728 | E0 0B 40 F9 | LDR             X0, [SP,#0x30+buf]\n0x0052B72C | 00 00 01 8B | ADD             X0, X0, X1\n0x0052B730 | 1F 00 00 39 | STRB            WZR, [X0]\n0x0052B734 | E0 17 40 F9 | LDR             X0, [SP,#0x30+ret]\n0x0052B738 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0052B73C | C0 03 5F D6 | RET",
        "output": "```c\n#include <fcntl.h>\n#include <unistd.h>\n\nssize_t custom_read_file(const char *filename, char *buf) {\n    ssize_t ret = -1;\n    int fd = open64(filename, O_RDONLY);\n    if (fd >= 0) {\n        ret = read(fd, buf, 0x3FF);\n        close(fd);\n    }\n    if (ret >= 0) {\n        buf[ret] = '\\0';\n    }\n    return ret;\n}\n```"
    },
    {
        "func_name": "free_llist",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004317DC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004317E0 | FD 03 00 91 | MOV             X29, SP\n0x004317E4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+pptr]\n0x004317E8 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+pptr]\n0x004317EC | 00 00 40 F9 | LDR             X0, [X0]\n0x004317F0 | E0 17 00 F9 | STR             X0, [SP,#0x30+cur]\n0x004317F4 | 08 00 00 14 | B               loc_431814\n0x004317F8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cur]\n0x004317FC | E0 13 00 F9 | STR             X0, [SP,#0x30+t]\n0x00431800 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cur]\n0x00431804 | 00 00 40 F9 | LDR             X0, [X0]\n0x00431808 | E0 17 00 F9 | STR             X0, [SP,#0x30+cur]\n0x0043180C | E0 13 40 F9 | LDR             X0, [SP,#0x30+t]; ptr\n0x00431810 | 34 57 FF 97 | BL              .free\n0x00431814 | E0 17 40 F9 | LDR             X0, [SP,#0x30+cur]\n0x00431818 | 1F 00 00 F1 | CMP             X0, #0\n0x0043181C | E1 FE FF 54 | B.NE            loc_4317F8\n0x00431820 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+pptr]\n0x00431824 | 1F 00 00 F9 | STR             XZR, [X0]\n0x00431828 | 1F 20 03 D5 | NOP\n0x0043182C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00431830 | C0 03 5F D6 | RET",
        "output": "```c\nvoid function(void **pptr) {\n    void *cur = *pptr;\n    do {\n        void *t = cur;\n        cur = *(void **)cur;\n        free(t);\n    } while (cur != NULL);\n    *pptr = NULL;\n}\n```"
    },
    {
        "func_name": "send_packet",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00460B94 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00460B98 | FD 03 00 91 | MOV             X29, SP\n0x00460B9C | E0 0F 00 F9 | STR             X0, [SP,#0x20+dhcp_pkt]\n0x00460BA0 | E1 17 00 B9 | STR             W1, [SP,#0x20+force_broadcast]\n0x00460BA4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+dhcp_pkt]\n0x00460BA8 | 00 18 40 B9 | LDR             W0, [X0,#0x18]\n0x00460BAC | 1F 00 00 71 | CMP             W0, #0\n0x00460BB0 | 80 00 00 54 | B.EQ            loc_460BC0\n0x00460BB4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+dhcp_pkt]; dhcp_pkt\n0x00460BB8 | DF FF FF 97 | BL              send_packet_to_relay\n0x00460BBC | 04 00 00 14 | B               loc_460BCC\n0x00460BC0 | E1 17 40 B9 | LDR             W1, [SP,#0x20+force_broadcast]; force_broadcast\n0x00460BC4 | E0 0F 40 F9 | LDR             X0, [SP,#0x20+dhcp_pkt]; dhcp_pkt\n0x00460BC8 | 99 FF FF 97 | BL              send_packet_to_client\n0x00460BCC | 1F 20 03 D5 | NOP\n0x00460BD0 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00460BD4 | C0 03 5F D6 | RET",
        "output": "```c\nvoid func(uint8_t *dhcp_pkt, int force_broadcast) {\n    if (dhcp_pkt[0x18] != 0) {\n        send_packet_to_relay(dhcp_pkt);\n    } else {\n        send_packet_to_client(dhcp_pkt, force_broadcast);\n    }\n}\n```"
    },
    {
        "func_name": "ndelay_off",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040A01C | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0040A020 | FD 03 00 91 | MOV             X29, SP\n0x0040A024 | E0 1F 00 B9 | STR             W0, [SP,#0x30+fd]\n0x0040A028 | 61 00 80 52 | MOV             W1, #3; cmd\n0x0040A02C | E0 1F 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x0040A030 | D0 F5 FF 97 | BL              .fcntl\n0x0040A034 | E0 2F 00 B9 | STR             W0, [SP,#0x30+flags]\n0x0040A038 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+flags]\n0x0040A03C | 00 00 15 12 | AND             W0, W0, #0x800\n0x0040A040 | 1F 00 00 71 | CMP             W0, #0\n0x0040A044 | 00 01 00 54 | B.EQ            loc_40A064\n0x0040A048 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+flags]\n0x0040A04C | 00 78 14 12 | AND             W0, W0, #0xFFFFF7FF\n0x0040A050 | E2 03 00 2A | MOV             W2, W0\n0x0040A054 | 81 00 80 52 | MOV             W1, #4; cmd\n0x0040A058 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+fd]; fd\n0x0040A05C | C5 F5 FF 97 | BL              .fcntl\n0x0040A060 | 02 00 00 14 | B               loc_40A068\n0x0040A064 | 1F 20 03 D5 | NOP\n0x0040A068 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0040A06C | C0 03 5F D6 | RET",
        "output": "```c\n#include <fcntl.h>\n\nvoid func(int fd) {\n    int flags = fcntl(fd, F_GETFL, 0);\n    if (flags & O_APPEND) {\n        flags &= ~O_APPEND;\n        fcntl(fd, F_SETFL, flags);\n    }\n}\n```"
    },
    {
        "func_name": "LOG2D",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00442C68 | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x00442C6C | E0 0F 00 B9 | STR             W0, [SP,#0x10+a]\n0x00442C70 | E0 0F 40 B9 | LDR             W0, [SP,#0x10+a]\n0x00442C74 | 1F 00 00 71 | CMP             W0, #0\n0x00442C78 | 2A 01 00 54 | B.GE            loc_442C9C\n0x00442C7C | E0 0F 40 B9 | LDR             W0, [SP,#0x10+a]\n0x00442C80 | E0 03 00 4B | NEG             W0, W0\n0x00442C84 | 21 00 80 D2 | MOV             X1, #1\n0x00442C88 | 20 20 C0 9A | LSL             X0, X1, X0\n0x00442C8C | 00 00 63 9E | UCVTF           D0, X0\n0x00442C90 | 01 10 6E 1E | FMOV            D1, #1.0\n0x00442C94 | 20 18 60 1E | FDIV            D0, D1, D0\n0x00442C98 | 05 00 00 14 | B               loc_442CAC\n0x00442C9C | E0 0F 40 B9 | LDR             W0, [SP,#0x10+a]\n0x00442CA0 | 21 00 80 D2 | MOV             X1, #1\n0x00442CA4 | 20 20 C0 9A | LSL             X0, X1, X0\n0x00442CA8 | 00 00 63 9E | UCVTF           D0, X0\n0x00442CAC | FF 43 00 91 | ADD             SP, SP, #0x10\n0x00442CB0 | C0 03 5F D6 | RET",
        "output": "```c\ndouble function(int a) {\n    double result;\n    if (a < 0) {\n        result = 1.0 / (double)(1ULL << -a);\n    } else {\n        result = (double)(1ULL << a);\n    }\n    return result;\n}\n```"
    },
    {
        "func_name": "check_context",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x005133F0 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x005133F4 | FD 03 00 91 | MOV             X29, SP\n0x005133F8 | F3 0B 00 F9 | STR             X19, [SP,#0x30+var_20]\n0x005133FC | E0 BF 00 39 | STRB            W0, [SP,#0x30+cmd]\n0x00513400 | 00 04 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00513408 | 00 00 40 F9 | LDR             X0, [X0]\n0x0051340C | 01 08 40 F9 | LDR             X1, [X0,#0x10]\n0x00513410 | 00 04 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00513418 | 00 00 40 F9 | LDR             X0, [X0]\n0x0051341C | 00 44 41 F9 | LDR             X0, [X0,#0x288]\n0x00513420 | 3F 00 00 EB | CMP             X1, X0\n0x00513424 | 63 01 00 54 | B.CC            loc_513450\n0x00513428 | 00 04 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00513430 | 00 00 40 F9 | LDR             X0, [X0]\n0x00513434 | 01 08 40 F9 | LDR             X1, [X0,#0x10]\n0x00513438 | 00 04 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00513440 | 00 00 40 F9 | LDR             X0, [X0]\n0x00513444 | 00 48 41 F9 | LDR             X0, [X0,#0x290]\n0x00513448 | 3F 00 00 EB | CMP             X1, X0\n0x0051344C | 09 06 00 54 | B.LS            loc_51350C\n0x00513450 | E0 BF 40 39 | LDRB            W0, [SP,#0x30+cmd]\n0x00513454 | E1 03 00 2A | MOV             W1, W0; c\n0x00513458 | 40 02 00 D0 00 20 23 91 | ADRL            X0, modifying_cmds; s\n0x00513460 | 84 D0 FB 97 | BL              .strchr\n0x00513464 | 1F 00 00 F1 | CMP             X0, #0\n0x00513468 | 20 05 00 54 | B.EQ            loc_51350C\n0x0051346C | 00 04 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00513474 | 01 00 40 F9 | LDR             X1, [X0]\n0x00513478 | 00 04 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00513480 | 00 00 40 F9 | LDR             X0, [X0]\n0x00513484 | 21 3C 41 F9 | LDR             X1, [X1,#0x278]\n0x00513488 | 01 40 01 F9 | STR             X1, [X0,#0x280]\n0x0051348C | 00 04 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x00513494 | 01 00 40 F9 | LDR             X1, [X0]\n0x00513498 | 00 04 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x005134A0 | 00 00 40 F9 | LDR             X0, [X0]\n0x005134A4 | 21 08 40 F9 | LDR             X1, [X1,#0x10]\n0x005134A8 | 01 3C 01 F9 | STR             X1, [X0,#0x278]\n0x005134AC | 00 04 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x005134B4 | 00 00 40 F9 | LDR             X0, [X0]\n0x005134B8 | 00 08 40 F9 | LDR             X0, [X0,#0x10]; p\n0x005134BC | BF F7 FF 97 | BL              prev_line\n0x005134C0 | E1 03 00 AA | MOV             X1, X0\n0x005134C4 | 00 04 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x005134CC | 13 00 40 F9 | LDR             X19, [X0]\n0x005134D0 | E0 03 01 AA | MOV             X0, X1; p\n0x005134D4 | B9 F7 FF 97 | BL              prev_line\n0x005134D8 | 60 46 01 F9 | STR             X0, [X19,#0x288]\n0x005134DC | 00 04 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x005134E4 | 00 00 40 F9 | LDR             X0, [X0]\n0x005134E8 | 00 08 40 F9 | LDR             X0, [X0,#0x10]; p\n0x005134EC | CE F7 FF 97 | BL              next_line\n0x005134F0 | E1 03 00 AA | MOV             X1, X0\n0x005134F4 | 00 04 00 D0 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x005134FC | 13 00 40 F9 | LDR             X19, [X0]\n0x00513500 | E0 03 01 AA | MOV             X0, X1; p\n0x00513504 | C8 F7 FF 97 | BL              next_line\n0x00513508 | 60 4A 01 F9 | STR             X0, [X19,#0x290]\n0x0051350C | 1F 20 03 D5 | NOP\n0x00513510 | F3 0B 40 F9 | LDR             X19, [SP,#0x30+var_20]\n0x00513514 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00513518 | C0 03 5F D6 | RET",
        "output": "```c\n#include <stdbool.h>\n\nextern char *strchr(const char *s, int c);\nextern void prev_line(void);\nextern void next_line(void);\n\ntypedef struct {\n    char *p;\n    char *prev_line_p;\n    char *next_line_p;\n    char cmd;\n    // Other fields are unknown\n} Globals;\n\nGlobals globals;\n\nbool modify_command(char cmd) {\n    if (globals.p[0x10] != globals.prev_line_p) {\n        return false;\n    }\n    if (globals.p[0x10] != globals.next_line_p) {\n        return true;\n    }\n\n    char *found = strchr(\"modifying_cmds\", cmd);\n    if (found == NULL) {\n        return true;\n    }\n\n    globals.p[0x278] = globals.p[0x280];\n    globals.p[0x10] = globals.p[0x278];\n    globals.prev_line_p = prev_line();\n    globals.p[0x288] = globals.prev_line_p;\n    globals.next_line_p = next_line();\n    globals.p[0x290] = globals.next_line_p;\n\n    return true;\n}\n```"
    },
    {
        "func_name": "clean_up_and_exit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043C90C | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x0043C910 | FD 03 00 91 | MOV             X29, SP\n0x0043C914 | E0 1F 00 B9 | STR             W0, [SP,#0x30+sig]\n0x0043C918 | A0 0A 00 F0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043C920 | 00 0C 40 F9 | LDR             X0, [X0,#(bb_common_bufsiz1+0x18 - 0x593290)]\n0x0043C924 | E0 17 00 F9 | STR             X0, [SP,#0x30+sep]\n0x0043C928 | 1F 00 00 14 | B               loc_43C9A4\n0x0043C92C | E0 17 40 F9 | LDR             X0, [SP,#0x30+sep]\n0x0043C930 | 00 00 40 B9 | LDR             W0, [X0]\n0x0043C934 | 1F 04 00 31 | CMN             W0, #1\n0x0043C938 | A0 02 00 54 | B.EQ            loc_43C98C\n0x0043C93C | E0 17 40 F9 | LDR             X0, [SP,#0x30+sep]\n0x0043C940 | 00 C4 C0 39 | LDRSB           W0, [X0,#0x31]\n0x0043C944 | 1F 04 00 71 | CMP             W0, #1\n0x0043C948 | A1 00 00 54 | B.NE            loc_43C95C\n0x0043C94C | E0 17 40 F9 | LDR             X0, [SP,#0x30+sep]\n0x0043C950 | 00 08 40 F9 | LDR             X0, [X0,#0x10]; name\n0x0043C954 | EB 2C FF 97 | BL              .unlink\n0x0043C958 | 10 00 00 14 | B               loc_43C998\n0x0043C95C | E0 17 40 F9 | LDR             X0, [SP,#0x30+sep]\n0x0043C960 | 00 2C 40 B9 | LDR             W0, [X0,#0x2C]\n0x0043C964 | 1F 04 00 71 | CMP             W0, #1\n0x0043C968 | 61 01 00 54 | B.NE            loc_43C994\n0x0043C96C | E0 17 40 F9 | LDR             X0, [SP,#0x30+sep]\n0x0043C970 | 00 24 40 B9 | LDR             W0, [X0,#0x24]\n0x0043C974 | 1F 00 00 71 | CMP             W0, #0\n0x0043C978 | E0 00 00 54 | B.EQ            loc_43C994\n0x0043C97C | E0 17 40 F9 | LDR             X0, [SP,#0x30+sep]; sep\n0x0043C980 | 40 F9 FF 97 | BL              unregister_rpc\n0x0043C984 | 1F 20 03 D5 | NOP\n0x0043C988 | 03 00 00 14 | B               loc_43C994\n0x0043C98C | 1F 20 03 D5 | NOP\n0x0043C990 | 02 00 00 14 | B               loc_43C998\n0x0043C994 | 1F 20 03 D5 | NOP\n0x0043C998 | E0 17 40 F9 | LDR             X0, [SP,#0x30+sep]\n0x0043C99C | 00 30 40 F9 | LDR             X0, [X0,#0x60]\n0x0043C9A0 | E0 17 00 F9 | STR             X0, [SP,#0x30+sep]\n0x0043C9A4 | E0 17 40 F9 | LDR             X0, [SP,#0x30+sep]\n0x0043C9A8 | 1F 00 00 F1 | CMP             X0, #0\n0x0043C9AC | 01 FC FF 54 | B.NE            loc_43C92C\n0x0043C9B0 | C0 0A 00 B0 00 20 11 91 | ADRL            X0, wrote_pidfile\n0x0043C9B8 | 00 00 40 B9 | LDR             W0, [X0]\n0x0043C9BC | 1F 00 00 71 | CMP             W0, #0\n0x0043C9C0 | 80 00 00 54 | B.EQ            loc_43C9D0\n0x0043C9C4 | 40 08 00 F0 00 60 03 91 | ADRL            X0, aVarRunInetdPid; \"/var/run/inetd.pid\"\n0x0043C9CC | CD 2C FF 97 | BL              .unlink\n0x0043C9D0 | 00 00 80 52 | MOV             W0, #0; status\n0x0043C9D4 | 6F 27 FF 97 | BL              .exit",
        "output": "```c\n#include <stdbool.h>\n\ntypedef struct {\n    char name[16];\n    int sig;\n    bool unlink_flag;\n    bool unregister_flag;\n    int some_value;\n    void *next;\n} sep_t;\n\nextern void unlink(const char *pathname);\nextern void unregister_rpc(sep_t *sep);\nextern void exit(int status);\n\nbool bb_common_bufsiz1;\nbool wrote_pidfile;\n\nvoid func() {\n    sep_t *sep = (sep_t *)&bb_common_bufsiz1 + 0x18;\n    sep->sig = 0;\n\n    do {\n        if (sep->sig == 1) {\n            break;\n        }\n\n        if (sep->unlink_flag) {\n            unlink(sep->name);\n            continue;\n        }\n\n        if (sep->unregister_flag && sep->some_value != 0) {\n            unregister_rpc(sep);\n        }\n\n        sep = sep->next;\n    } while (sep != NULL);\n\n    if (wrote_pidfile) {\n        unlink(\"/var/run/inetd.pid\");\n    }\n\n    exit(0);\n}\n```"
    },
    {
        "func_name": "bb_process_escape_sequence",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0052B2B4 | FF 03 01 D1 | SUB             SP, SP, #0x40\n0x0052B2B8 | E0 07 00 F9 | STR             X0, [SP,#0x40+ptr]\n0x0052B2BC | FF 33 00 B9 | STR             WZR, [SP,#0x40+n]\n0x0052B2C0 | E0 33 40 B9 | LDR             W0, [SP,#0x40+n]\n0x0052B2C4 | E0 37 00 B9 | STR             W0, [SP,#0x40+num_digits]\n0x0052B2C8 | 00 01 80 52 | MOV             W0, #8\n0x0052B2CC | E0 2F 00 B9 | STR             W0, [SP,#0x40+base]\n0x0052B2D0 | E0 07 40 F9 | LDR             X0, [SP,#0x40+ptr]\n0x0052B2D4 | 00 00 40 F9 | LDR             X0, [X0]\n0x0052B2D8 | E0 1F 00 F9 | STR             X0, [SP,#0x40+q]\n0x0052B2DC | E0 1F 40 F9 | LDR             X0, [SP,#0x40+q]\n0x0052B2E0 | 00 00 40 39 | LDRB            W0, [X0]\n0x0052B2E4 | 1F E0 01 71 | CMP             W0, #0x78 ; 'x'\n0x0052B2E8 | 21 01 00 54 | B.NE            loc_52B30C\n0x0052B2EC | E0 1F 40 F9 | LDR             X0, [SP,#0x40+q]\n0x0052B2F0 | 00 04 00 91 | ADD             X0, X0, #1\n0x0052B2F4 | E0 1F 00 F9 | STR             X0, [SP,#0x40+q]\n0x0052B2F8 | 00 02 80 52 | MOV             W0, #0x10\n0x0052B2FC | E0 2F 00 B9 | STR             W0, [SP,#0x40+base]\n0x0052B300 | E0 37 40 B9 | LDR             W0, [SP,#0x40+num_digits]\n0x0052B304 | 00 04 00 11 | ADD             W0, W0, #1\n0x0052B308 | E0 37 00 B9 | STR             W0, [SP,#0x40+num_digits]\n0x0052B30C | E0 1F 40 F9 | LDR             X0, [SP,#0x40+q]\n0x0052B310 | 00 00 40 39 | LDRB            W0, [X0]\n0x0052B314 | 00 00 1B 32 | ORR             W0, W0, #0x20\n0x0052B318 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x0052B31C | 00 C0 00 51 | SUB             W0, W0, #0x30 ; '0'\n0x0052B320 | E0 2B 00 B9 | STR             W0, [SP,#0x40+d]\n0x0052B324 | E0 2B 40 B9 | LDR             W0, [SP,#0x40+d]\n0x0052B328 | 1F 24 00 71 | CMP             W0, #9\n0x0052B32C | 89 00 00 54 | B.LS            loc_52B33C\n0x0052B330 | E0 2B 40 B9 | LDR             W0, [SP,#0x40+d]\n0x0052B334 | 00 9C 00 51 | SUB             W0, W0, #0x27 ; '''\n0x0052B338 | E0 2B 00 B9 | STR             W0, [SP,#0x40+d]\n0x0052B33C | E1 2B 40 B9 | LDR             W1, [SP,#0x40+d]\n0x0052B340 | E0 2F 40 B9 | LDR             W0, [SP,#0x40+base]\n0x0052B344 | 3F 00 00 6B | CMP             W1, W0\n0x0052B348 | 83 01 00 54 | B.CC            loc_52B378\n0x0052B34C | E0 2F 40 B9 | LDR             W0, [SP,#0x40+base]\n0x0052B350 | 1F 40 00 71 | CMP             W0, #0x10\n0x0052B354 | C1 03 00 54 | B.NE            loc_52B3CC\n0x0052B358 | E0 37 40 B9 | LDR             W0, [SP,#0x40+num_digits]\n0x0052B35C | 00 04 00 51 | SUB             W0, W0, #1\n0x0052B360 | E0 37 00 B9 | STR             W0, [SP,#0x40+num_digits]\n0x0052B364 | E0 37 40 B9 | LDR             W0, [SP,#0x40+num_digits]\n0x0052B368 | 1F 00 00 71 | CMP             W0, #0\n0x0052B36C | 01 03 00 54 | B.NE            loc_52B3CC\n0x0052B370 | 80 0B 80 52 | MOV             W0, #0x5C ; '\\'\n0x0052B374 | 39 00 00 14 | B               loc_52B458\n0x0052B378 | E1 33 40 B9 | LDR             W1, [SP,#0x40+n]\n0x0052B37C | E0 2F 40 B9 | LDR             W0, [SP,#0x40+base]\n0x0052B380 | 20 7C 00 1B | MUL             W0, W1, W0\n0x0052B384 | E1 2B 40 B9 | LDR             W1, [SP,#0x40+d]\n0x0052B388 | 20 00 00 0B | ADD             W0, W1, W0\n0x0052B38C | E0 1F 00 B9 | STR             W0, [SP,#0x40+r]\n0x0052B390 | E0 1F 40 B9 | LDR             W0, [SP,#0x40+r]\n0x0052B394 | 1F FC 03 71 | CMP             W0, #0xFF\n0x0052B398 | E8 01 00 54 | B.HI            loc_52B3D4\n0x0052B39C | E0 1F 40 B9 | LDR             W0, [SP,#0x40+r]\n0x0052B3A0 | E0 33 00 B9 | STR             W0, [SP,#0x40+n]\n0x0052B3A4 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+q]\n0x0052B3A8 | 00 04 00 91 | ADD             X0, X0, #1\n0x0052B3AC | E0 1F 00 F9 | STR             X0, [SP,#0x40+q]\n0x0052B3B0 | E0 37 40 B9 | LDR             W0, [SP,#0x40+num_digits]\n0x0052B3B4 | 00 04 00 11 | ADD             W0, W0, #1\n0x0052B3B8 | E0 37 00 B9 | STR             W0, [SP,#0x40+num_digits]\n0x0052B3BC | E0 37 40 B9 | LDR             W0, [SP,#0x40+num_digits]\n0x0052B3C0 | 1F 08 00 71 | CMP             W0, #2\n0x0052B3C4 | 49 FA FF 54 | B.LS            loc_52B30C\n0x0052B3C8 | 04 00 00 14 | B               loc_52B3D8\n0x0052B3CC | 1F 20 03 D5 | NOP\n0x0052B3D0 | 02 00 00 14 | B               loc_52B3D8\n0x0052B3D4 | 1F 20 03 D5 | NOP\n0x0052B3D8 | E0 37 40 B9 | LDR             W0, [SP,#0x40+num_digits]\n0x0052B3DC | 1F 00 00 71 | CMP             W0, #0\n0x0052B3E0 | 21 03 00 54 | B.NE            loc_52B444\n0x0052B3E4 | A0 01 00 B0 00 68 21 91 | ADRL            X0, charmap.9488; \"abefnrtv\\\\\"\n0x0052B3EC | E0 13 00 F9 | STR             X0, [SP,#0x40+p]\n0x0052B3F0 | E0 13 40 F9 | LDR             X0, [SP,#0x40+p]\n0x0052B3F4 | 01 00 40 39 | LDRB            W1, [X0]\n0x0052B3F8 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+q]\n0x0052B3FC | 00 00 40 39 | LDRB            W0, [X0]\n0x0052B400 | 3F 00 00 6B | CMP             W1, W0\n0x0052B404 | A1 00 00 54 | B.NE            loc_52B418\n0x0052B408 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+q]\n0x0052B40C | 00 04 00 91 | ADD             X0, X0, #1\n0x0052B410 | E0 1F 00 F9 | STR             X0, [SP,#0x40+q]\n0x0052B414 | 08 00 00 14 | B               loc_52B434\n0x0052B418 | E0 13 40 F9 | LDR             X0, [SP,#0x40+p]\n0x0052B41C | 00 04 00 91 | ADD             X0, X0, #1\n0x0052B420 | E0 13 00 F9 | STR             X0, [SP,#0x40+p]\n0x0052B424 | E0 13 40 F9 | LDR             X0, [SP,#0x40+p]\n0x0052B428 | 00 00 40 39 | LDRB            W0, [X0]\n0x0052B42C | 1F 00 00 71 | CMP             W0, #0\n0x0052B430 | 01 FE FF 54 | B.NE            loc_52B3F0\n0x0052B434 | E0 13 40 F9 | LDR             X0, [SP,#0x40+p]\n0x0052B438 | 00 28 00 91 | ADD             X0, X0, #0xA\n0x0052B43C | 00 00 40 39 | LDRB            W0, [X0]\n0x0052B440 | E0 33 00 B9 | STR             W0, [SP,#0x40+n]\n0x0052B444 | E0 07 40 F9 | LDR             X0, [SP,#0x40+ptr]\n0x0052B448 | E1 1F 40 F9 | LDR             X1, [SP,#0x40+q]\n0x0052B44C | 01 00 00 F9 | STR             X1, [X0]\n0x0052B450 | E0 33 40 B9 | LDR             W0, [SP,#0x40+n]\n0x0052B454 | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x0052B458 | FF 03 01 91 | ADD             SP, SP, #0x40 ; '@'\n0x0052B45C | C0 03 5F D6 | RET",
        "output": "```c\nunsigned int parse_hex(const char **ptr) {\n    unsigned int n = 0;\n    unsigned int num_digits = 0;\n    unsigned int base = 8;\n    const char *q = *ptr;\n    char d;\n\n    if (*q == 'x') {\n        q++;\n        base = 16;\n        num_digits++;\n    }\n\n    while (1) {\n        d = *q | 0x20; // Convert to lowercase\n        d -= '0'; // Convert ASCII to number\n\n        if (d > 9) {\n            d -= 'a' - '0' - 10; // Adjust for hex letters\n        }\n\n        if (d >= base) {\n            if (base == 16 && num_digits == 0) {\n                // Invalid hex number (no digits after 'x')\n                return '\\\\';\n            }\n            break;\n        }\n\n        if (n > 0xFF) {\n            // Overflow\n            break;\n        }\n\n        n = n * base + d;\n        q++;\n        num_digits++;\n\n        if (base == 8 && num_digits >= 2) {\n            break;\n        }\n    }\n\n    if (num_digits == 0) {\n        // Special characters handling\n        const char *charmap = \"abefnrtv\\\\\";\n        const char *p = charmap;\n        while (*p) {\n            if (*p == *q) {\n                q++;\n                n = *(p + 10); // Get the special character value\n                break;\n            }\n            p++;\n        }\n    }\n\n    *ptr = q;\n    return n & 0xFF;\n}\n```"
    },
    {
        "func_name": "xset1",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00424C44 | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x00424C48 | FD 03 00 91 | MOV             X29, SP\n0x00424C4C | E0 2F 00 B9 | STR             W0, [SP,#0x40+fd]\n0x00424C50 | E1 13 00 F9 | STR             X1, [SP,#0x40+tio]\n0x00424C54 | E2 0F 00 F9 | STR             X2, [SP,#0x40+device]\n0x00424C58 | E2 13 40 F9 | LDR             X2, [SP,#0x40+tio]; termios_p\n0x00424C5C | 41 00 80 52 | MOV             W1, #2; optional_actions\n0x00424C60 | E0 2F 40 B9 | LDR             W0, [SP,#0x40+fd]; fd\n0x00424C64 | 1B 8B FF 97 | BL              .tcsetattr\n0x00424C68 | E0 3F 00 B9 | STR             W0, [SP,#0x40+ret]\n0x00424C6C | E0 3F 40 B9 | LDR             W0, [SP,#0x40+ret]\n0x00424C70 | 1F 00 00 71 | CMP             W0, #0\n0x00424C74 | A0 00 00 54 | B.EQ            loc_424C88\n0x00424C78 | E1 0F 40 F9 | LDR             X1, [SP,#0x40+device]\n0x00424C7C | E0 08 00 F0 00 A0 01 91 | ADRL            X0, aCanTTcsetattrF; \"can't tcsetattr for %s\"\n0x00424C84 | 85 92 FF 97 | BL              bb_perror_msg\n0x00424C88 | E0 3F 40 B9 | LDR             W0, [SP,#0x40+ret]\n0x00424C8C | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x00424C90 | C0 03 5F D6 | RET",
        "output": "```c\n#include <termios.h>\n\nint set_termios(int fd, struct termios *tio, void *device) {\n    int ret = tcsetattr(fd, TCSANOW, tio);\n    if (ret != 0) {\n        bb_perror_msg(\"can't tcsetattr for %s\", device);\n    }\n    return ret;\n}\n```"
    },
    {
        "func_name": "find_lease_by_mac",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00463A38 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00463A3C | FD 03 00 91 | MOV             X29, SP\n0x00463A40 | E0 0F 00 F9 | STR             X0, [SP,#0x30+mac]\n0x00463A44 | FF 2F 00 B9 | STR             WZR, [SP,#0x30+i]\n0x00463A48 | 1D 00 00 14 | B               loc_463ABC\n0x00463A4C | 80 09 00 D0 00 A0 0F 91 | ADRL            X0, g_leases\n0x00463A54 | 02 00 40 F9 | LDR             X2, [X0]\n0x00463A58 | E1 2F 40 B9 | LDR             W1, [SP,#0x30+i]\n0x00463A5C | E0 03 01 AA | MOV             X0, X1\n0x00463A60 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00463A64 | 00 00 01 8B | ADD             X0, X0, X1\n0x00463A68 | 00 F4 7E D3 | LSL             X0, X0, #2\n0x00463A6C | 40 00 00 8B | ADD             X0, X2, X0\n0x00463A70 | 00 20 00 91 | ADD             X0, X0, #8; s1\n0x00463A74 | C2 00 80 D2 | MOV             X2, #6; n\n0x00463A78 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+mac]; s2\n0x00463A7C | 35 8E FE 97 | BL              .memcmp\n0x00463A80 | 1F 00 00 71 | CMP             W0, #0\n0x00463A84 | 61 01 00 54 | B.NE            loc_463AB0\n0x00463A88 | 80 09 00 D0 00 A0 0F 91 | ADRL            X0, g_leases\n0x00463A90 | 02 00 40 F9 | LDR             X2, [X0]\n0x00463A94 | E1 2F 40 B9 | LDR             W1, [SP,#0x30+i]\n0x00463A98 | E0 03 01 AA | MOV             X0, X1\n0x00463A9C | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00463AA0 | 00 00 01 8B | ADD             X0, X0, X1\n0x00463AA4 | 00 F4 7E D3 | LSL             X0, X0, #2\n0x00463AA8 | 40 00 00 8B | ADD             X0, X2, X0\n0x00463AAC | 0B 00 00 14 | B               loc_463AD8\n0x00463AB0 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+i]\n0x00463AB4 | 00 04 00 11 | ADD             W0, W0, #1\n0x00463AB8 | E0 2F 00 B9 | STR             W0, [SP,#0x30+i]\n0x00463ABC | 80 09 00 90 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x00463AC4 | 00 30 40 B9 | LDR             W0, [X0,#(bb_common_bufsiz1+0x30 - 0x593290)]\n0x00463AC8 | E1 2F 40 B9 | LDR             W1, [SP,#0x30+i]\n0x00463ACC | 3F 00 00 6B | CMP             W1, W0\n0x00463AD0 | E3 FB FF 54 | B.CC            loc_463A4C\n0x00463AD4 | 00 00 80 D2 | MOV             X0, #0\n0x00463AD8 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00463ADC | C0 03 5F D6 | RET",
        "output": "```c\nint func() {\n    int i = 0;\n    do {\n        uint8_t *mac = (uint8_t *)(g_leases + (i * 8 + i) * 4 + 8);\n        if (memcmp(mac, s2, 6) == 0) {\n            return i;\n        }\n        i++;\n    } while (i < bb_common_bufsiz1);\n    return 0;\n}\n```"
    },
    {
        "func_name": "unzip_extract",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004D1960 | FD 7B BB A9 | STP             X29, X30, [SP,#var_50]!\n0x004D1964 | FD 03 00 91 | MOV             X29, SP\n0x004D1968 | E0 0F 00 F9 | STR             X0, [SP,#0x50+zip_header]\n0x004D196C | E1 17 00 B9 | STR             W1, [SP,#0x50+dst_fd]\n0x004D1970 | E0 0F 40 F9 | LDR             X0, [SP,#0x50+zip_header]\n0x004D1974 | 00 08 40 79 | LDRH            W0, [X0,#4]\n0x004D1978 | 1F 00 00 71 | CMP             W0, #0\n0x004D197C | A1 01 00 54 | B.NE            loc_4D19B0\n0x004D1980 | E0 0F 40 F9 | LDR             X0, [SP,#0x50+zip_header]\n0x004D1984 | 00 20 41 B8 | LDUR            W0, [X0,#0x12]\n0x004D1988 | E0 03 00 2A | MOV             W0, W0\n0x004D198C | E0 27 00 F9 | STR             X0, [SP,#0x50+size]\n0x004D1990 | E0 27 40 F9 | LDR             X0, [SP,#0x50+size]\n0x004D1994 | 1F 00 00 F1 | CMP             X0, #0\n0x004D1998 | E0 04 00 54 | B.EQ            loc_4D1A34\n0x004D199C | E2 27 40 F9 | LDR             X2, [SP,#0x50+size]; size\n0x004D19A0 | E1 17 40 B9 | LDR             W1, [SP,#0x50+dst_fd]; fd2\n0x004D19A4 | 60 00 80 52 | MOV             W0, #3; fd1\n0x004D19A8 | E4 E8 FC 97 | BL              bb_copyfd_exact_size\n0x004D19AC | 22 00 00 14 | B               loc_4D1A34\n0x004D19B0 | E0 83 00 91 | ADD             X0, SP, #0x50+aux; aux\n0x004D19B4 | 0D 3A 00 94 | BL              init_transformer_aux_data\n0x004D19B8 | E0 0F 40 F9 | LDR             X0, [SP,#0x50+zip_header]\n0x004D19BC | 00 E0 40 B8 | LDUR            W0, [X0,#0xE]\n0x004D19C0 | E0 03 00 2A | MOV             W0, W0\n0x004D19C4 | E0 1B 00 F9 | STR             X0, [SP,#0x50+aux.bytes_in]\n0x004D19C8 | E0 83 00 91 | ADD             X0, SP, #0x50+aux; aux\n0x004D19CC | E2 17 40 B9 | LDR             W2, [SP,#0x50+dst_fd]; out\n0x004D19D0 | 61 00 80 52 | MOV             W1, #3; in\n0x004D19D4 | C4 13 00 94 | BL              inflate_unzip\n0x004D19D8 | 1F 00 00 F1 | CMP             X0, #0\n0x004D19DC | 8A 00 00 54 | B.GE            loc_4D19EC\n0x004D19E0 | 20 04 00 D0 00 00 3D 91 | ADRL            X0, aInflateError; \"inflate error\"\n0x004D19E8 | A3 E0 FC 97 | BL              bb_error_msg_and_die\n0x004D19EC | E0 0F 40 F9 | LDR             X0, [SP,#0x50+zip_header]\n0x004D19F0 | 01 A0 40 B8 | LDUR            W1, [X0,#0xA]\n0x004D19F4 | E0 3B 40 B9 | LDR             W0, [SP,#0x50+aux.crc32]\n0x004D19F8 | E0 03 20 2A | MVN             W0, W0\n0x004D19FC | 3F 00 00 6B | CMP             W1, W0\n0x004D1A00 | 80 00 00 54 | B.EQ            loc_4D1A10\n0x004D1A04 | 20 04 00 D0 00 40 3D 91 | ADRL            X0, aCrcError; \"crc error\"\n0x004D1A0C | 9A E0 FC 97 | BL              bb_error_msg_and_die\n0x004D1A10 | E0 0F 40 F9 | LDR             X0, [SP,#0x50+zip_header]\n0x004D1A14 | 00 20 41 B8 | LDUR            W0, [X0,#0x12]\n0x004D1A18 | E1 03 00 2A | MOV             W1, W0\n0x004D1A1C | E0 17 40 F9 | LDR             X0, [SP,#0x50+aux.bytes_out]\n0x004D1A20 | 3F 00 00 EB | CMP             X1, X0\n0x004D1A24 | 80 00 00 54 | B.EQ            loc_4D1A34\n0x004D1A28 | 20 04 00 D0 00 80 3D 91 | ADRL            X0, aBadLength_0; \"bad length\"\n0x004D1A30 | B9 E0 FC 97 | BL              bb_error_msg\n0x004D1A34 | 1F 20 03 D5 | NOP\n0x004D1A38 | FD 7B C5 A8 | LDP             X29, X30, [SP+0x50+var_50],#0x50\n0x004D1A3C | C0 03 5F D6 | RET",
        "output": "```c\n#include <stdint.h>\n\nstruct aux_data {\n    uint64_t bytes_in;\n    uint64_t bytes_out;\n    uint32_t crc32;\n    // other fields might be present, but are not relevant to this function\n};\n\nvoid bb_copyfd_exact_size(int fd1, int fd2, uint64_t size);\nvoid init_transformer_aux_data(struct aux_data *aux);\nvoid inflate_unzip(int in, int out, struct aux_data *aux);\nvoid bb_error_msg_and_die(const char *s);\nvoid bb_error_msg(const char *s);\n\nvoid function(uint8_t *zip_header, int dst_fd) {\n    struct aux_data aux;\n    uint16_t header_field = *(uint16_t *)(zip_header + 4);\n    if (header_field != 0) {\n        init_transformer_aux_data(&aux);\n        uint16_t method = *(uint16_t *)(zip_header + 0xE);\n        aux.bytes_in = method;\n        if (inflate_unzip(3, dst_fd, &aux) < 0) {\n            bb_error_msg_and_die(\"inflate error\");\n        }\n        uint32_t crc = *(uint32_t *)(zip_header + 0xA);\n        if (crc != ~aux.crc32) {\n            bb_error_msg_and_die(\"crc error\");\n        }\n        uint32_t size = *(uint32_t *)(zip_header + 0x12);\n        if (size != aux.bytes_out) {\n            bb_error_msg(\"bad length\");\n        }\n    } else {\n        uint32_t size = *(uint32_t *)(zip_header + 0x12);\n        bb_copyfd_exact_size(3, dst_fd, size);\n    }\n}\n```"
    },
    {
        "func_name": "common64_end",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x005214A4 | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x005214A8 | FD 03 00 91 | MOV             X29, SP\n0x005214AC | E0 0F 00 F9 | STR             X0, [SP,#0x40+ctx]\n0x005214B0 | E1 17 00 B9 | STR             W1, [SP,#0x40+swap_needed]\n0x005214B4 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+ctx]\n0x005214B8 | 00 24 40 F9 | LDR             X0, [X0,#0x48]\n0x005214BC | 00 14 00 12 | AND             W0, W0, #0x3F\n0x005214C0 | E0 3F 00 B9 | STR             W0, [SP,#0x40+bufpos]\n0x005214C4 | E0 3F 40 B9 | LDR             W0, [SP,#0x40+bufpos]\n0x005214C8 | 01 04 00 11 | ADD             W1, W0, #1\n0x005214CC | E1 3F 00 B9 | STR             W1, [SP,#0x40+bufpos]\n0x005214D0 | E1 0F 40 F9 | LDR             X1, [SP,#0x40+ctx]\n0x005214D4 | E0 03 00 2A | MOV             W0, W0\n0x005214D8 | E2 0F 80 12 | MOV             W2, #0xFFFFFF80\n0x005214DC | 22 68 20 38 | STRB            W2, [X1,X0]\n0x005214E0 | 01 08 80 52 | MOV             W1, #0x40 ; '@'\n0x005214E4 | E0 3F 40 B9 | LDR             W0, [SP,#0x40+bufpos]\n0x005214E8 | 20 00 00 4B | SUB             W0, W1, W0\n0x005214EC | E0 2F 00 B9 | STR             W0, [SP,#0x40+remaining]\n0x005214F0 | E1 0F 40 F9 | LDR             X1, [SP,#0x40+ctx]\n0x005214F4 | E0 3F 40 B9 | LDR             W0, [SP,#0x40+bufpos]\n0x005214F8 | 20 00 00 8B | ADD             X0, X1, X0; s\n0x005214FC | E1 2F 40 B9 | LDR             W1, [SP,#0x40+remaining]\n0x00521500 | E2 03 01 AA | MOV             X2, X1; n\n0x00521504 | 01 00 80 52 | MOV             W1, #0; c\n0x00521508 | 82 96 FB 97 | BL              .memset\n0x0052150C | E0 2F 40 B9 | LDR             W0, [SP,#0x40+remaining]\n0x00521510 | 1F 1C 00 71 | CMP             W0, #7\n0x00521514 | E9 01 00 54 | B.LS            loc_521550\n0x00521518 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+ctx]\n0x0052151C | 00 24 40 F9 | LDR             X0, [X0,#0x48]\n0x00521520 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00521524 | E0 1B 00 F9 | STR             X0, [SP,#0x40+t]\n0x00521528 | E0 17 40 B9 | LDR             W0, [SP,#0x40+swap_needed]\n0x0052152C | 1F 00 00 71 | CMP             W0, #0\n0x00521530 | 80 00 00 54 | B.EQ            loc_521540\n0x00521534 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+t]; __bsx\n0x00521538 | 78 FF FF 97 | BL              __bswap_64_4\n0x0052153C | E0 1B 00 F9 | STR             X0, [SP,#0x40+t]\n0x00521540 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+ctx]\n0x00521544 | 00 E0 00 91 | ADD             X0, X0, #0x38 ; '8'\n0x00521548 | E1 1B 40 F9 | LDR             X1, [SP,#0x40+t]\n0x0052154C | 01 00 00 F9 | STR             X1, [X0]\n0x00521550 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+ctx]\n0x00521554 | 01 20 40 F9 | LDR             X1, [X0,#0x40]\n0x00521558 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+ctx]\n0x0052155C | 20 00 3F D6 | BLR             X1\n0x00521560 | E0 2F 40 B9 | LDR             W0, [SP,#0x40+remaining]\n0x00521564 | 1F 1C 00 71 | CMP             W0, #7\n0x00521568 | 68 00 00 54 | B.HI            loc_521574\n0x0052156C | FF 3F 00 B9 | STR             WZR, [SP,#0x40+bufpos]\n0x00521570 | DC FF FF 17 | B               loc_5214E0\n0x00521574 | 1F 20 03 D5 | NOP\n0x00521578 | 1F 20 03 D5 | NOP\n0x0052157C | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x00521580 | C0 03 5F D6 | RET",
        "output": "```c\nvoid function(uint64_t *ctx, int swap_needed) {\n    uint64_t t;\n    int bufpos = ctx[9] & 0x3F;\n    ctx[9] = bufpos + 1;\n    uint8_t *s = (uint8_t *)ctx + bufpos;\n    int remaining = 0x40 - bufpos;\n    memset(s, 0x80, remaining);\n    if (remaining <= 7) {\n        if (swap_needed) {\n            t = __bswap_64_4(ctx[9]);\n            ctx[9] = t;\n        }\n        ctx[7] = ctx[9] << 3;\n        ctx[8] = t;\n        ctx[ctx[8]]();\n        bufpos = 0;\n        goto loc_5214E0;\n    } else {\n        // NOPs (No operation)\n    }\n    // Restore stack frame and return\n}\n```"
    },
    {
        "func_name": "parse_and_run_stream",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004994FC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00499500 | FD 03 00 91 | MOV             X29, SP\n0x00499504 | E0 0F 00 F9 | STR             X0, [SP,#0x30+inp]\n0x00499508 | E1 17 00 B9 | STR             W1, [SP,#0x30+end_trigger]\n0x0049950C | 20 00 80 52 | MOV             W0, #1\n0x00499510 | E0 BF 00 39 | STRB            W0, [SP,#0x30+empty]\n0x00499514 | E0 17 40 B9 | LDR             W0, [SP,#0x30+end_trigger]\n0x00499518 | 1F EC 00 71 | CMP             W0, #0x3B ; ';'\n0x0049951C | 61 00 00 54 | B.NE            loc_499528\n0x00499520 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+inp]\n0x00499524 | 1F 0C 00 B9 | STR             WZR, [X0,#0xC]\n0x00499528 | E1 17 40 B9 | LDR             W1, [SP,#0x30+end_trigger]; end_trigger\n0x0049952C | E0 0F 40 F9 | LDR             X0, [SP,#0x30+inp]; input\n0x00499530 | 43 F6 FF 97 | BL              parse_stream\n0x00499534 | E0 13 00 F9 | STR             X0, [SP,#0x30+pipe_list]\n0x00499538 | E0 13 40 F9 | LDR             X0, [SP,#0x30+pipe_list]\n0x0049953C | 1F 00 00 F1 | CMP             X0, #0\n0x00499540 | 80 00 00 54 | B.EQ            loc_499550\n0x00499544 | E0 13 40 F9 | LDR             X0, [SP,#0x30+pipe_list]\n0x00499548 | 1F 04 00 F1 | CMP             X0, #1\n0x0049954C | A1 04 00 54 | B.NE            loc_4995E0\n0x00499550 | E0 13 40 F9 | LDR             X0, [SP,#0x30+pipe_list]\n0x00499554 | 1F 04 00 F1 | CMP             X0, #1\n0x00499558 | E1 02 00 54 | B.NE            loc_4995B4\n0x0049955C | E0 17 40 B9 | LDR             W0, [SP,#0x30+end_trigger]\n0x00499560 | 1F EC 00 71 | CMP             W0, #0x3B ; ';'\n0x00499564 | 81 02 00 54 | B.NE            loc_4995B4\n0x00499568 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+inp]\n0x0049956C | 00 10 40 B9 | LDR             W0, [X0,#0x10]\n0x00499570 | E0 2B 00 B9 | STR             W0, [SP,#0x30+ch]\n0x00499574 | 06 00 00 14 | B               loc_49958C\n0x00499578 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+inp]\n0x0049957C | 01 10 40 F9 | LDR             X1, [X0,#0x20]\n0x00499580 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+inp]\n0x00499584 | 20 00 3F D6 | BLR             X1\n0x00499588 | E0 2B 00 B9 | STR             W0, [SP,#0x30+ch]\n0x0049958C | E0 2B 40 B9 | LDR             W0, [SP,#0x30+ch]\n0x00499590 | 1F 04 00 31 | CMN             W0, #1\n0x00499594 | 80 00 00 54 | B.EQ            loc_4995A4\n0x00499598 | E0 2B 40 B9 | LDR             W0, [SP,#0x30+ch]\n0x0049959C | 1F 28 00 71 | CMP             W0, #0xA\n0x004995A0 | C1 FE FF 54 | B.NE            loc_499578\n0x004995A4 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+inp]\n0x004995A8 | 1F 00 00 F9 | STR             XZR, [X0]\n0x004995AC | FF BF 00 39 | STRB            WZR, [SP,#0x30+empty]\n0x004995B0 | 15 00 00 14 | B               loc_499604\n0x004995B4 | E0 13 40 F9 | LDR             X0, [SP,#0x30+pipe_list]\n0x004995B8 | 1F 00 00 F1 | CMP             X0, #0\n0x004995BC | 61 02 00 54 | B.NE            loc_499608\n0x004995C0 | E0 BF 40 39 | LDRB            W0, [SP,#0x30+empty]\n0x004995C4 | 1F 00 00 71 | CMP             W0, #0\n0x004995C8 | 00 02 00 54 | B.EQ            loc_499608\n0x004995CC | E0 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004995D4 | 00 00 40 F9 | LDR             X0, [X0]\n0x004995D8 | 1F 5C 00 B9 | STR             WZR, [X0,#0x5C]\n0x004995DC | 0B 00 00 14 | B               loc_499608\n0x004995E0 | E0 13 40 F9 | LDR             X0, [SP,#0x30+pipe_list]; pi\n0x004995E4 | E9 0A 00 94 | BL              run_and_free_list\n0x004995E8 | FF BF 00 39 | STRB            WZR, [SP,#0x30+empty]\n0x004995EC | E0 07 00 90 00 80 0A 91 | ADRL            X0, ptr_to_globals\n0x004995F4 | 00 00 40 F9 | LDR             X0, [X0]\n0x004995F8 | 00 54 40 B9 | LDR             W0, [X0,#0x54]\n0x004995FC | 1F 04 00 71 | CMP             W0, #1\n0x00499600 | 80 00 00 54 | B.EQ            loc_499610\n0x00499604 | C4 FF FF 17 | B               loc_499514\n0x00499608 | 1F 20 03 D5 | NOP\n0x0049960C | 02 00 00 14 | B               loc_499614\n0x00499610 | 1F 20 03 D5 | NOP\n0x00499614 | 1F 20 03 D5 | NOP\n0x00499618 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x0049961C | C0 03 5F D6 | RET",
        "output": "```c\nvoid function(char *inp, int end_trigger) {\n    char empty = 1;\n    void *pipe_list = NULL;\n    char ch;\n\n    if (end_trigger != ';') {\n        inp[0xC] = 0;\n    }\n\n    pipe_list = parse_stream(inp, end_trigger);\n\n    if (pipe_list == NULL) {\n        if (empty) {\n            ptr_to_globals[0x5C] = 0;\n        }\n    } else if (pipe_list == (void *)1) {\n        if (end_trigger == ';') {\n            ch = inp[0x10];\n        } else {\n            ch = ((int (*)(void *, void *))inp[0x20])(inp, inp[0x20]);\n        }\n\n        if (ch == 1) {\n            inp[0] = 0;\n            empty = 0;\n        } else if (ch == 10) {\n            goto loc_499578;\n        }\n    } else {\n        run_and_free_list(pipe_list);\n        empty = 0;\n        if (ptr_to_globals[0x54] == 1) {\n            return;\n        }\n    }\n\nloc_499578:\n    inp[0] = 0;\n    empty = 0;\n}\n```"
    },
    {
        "func_name": "chargen_dg",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043D89C | FD 7B B8 A9 | STP             X29, X30, [SP,#var_80]!\n0x0043D8A0 | FD 03 00 91 | MOV             X29, SP\n0x0043D8A4 | A0 1F 00 B9 | STR             W0, [X29,#0x80+s]\n0x0043D8A8 | A1 0B 00 F9 | STR             X1, [X29,#0x80+sep]\n0x0043D8AC | A0 0B 40 F9 | LDR             X0, [X29,#0x80+sep]\n0x0043D8B0 | 00 34 40 F9 | LDR             X0, [X0,#0x68]\n0x0043D8B4 | 00 00 40 B9 | LDR             W0, [X0]\n0x0043D8B8 | 00 10 00 11 | ADD             W0, W0, #4\n0x0043D8BC | E0 03 00 2A | MOV             W0, W0\n0x0043D8C0 | 00 3C 00 91 | ADD             X0, X0, #0xF\n0x0043D8C4 | 00 FC 44 D3 | LSR             X0, X0, #4\n0x0043D8C8 | 00 EC 7C D3 | LSL             X0, X0, #4\n0x0043D8CC | FF 63 20 CB | SUB             SP, SP, X0\n0x0043D8D0 | E0 03 00 91 | MOV             X0, SP\n0x0043D8D4 | 00 3C 00 91 | ADD             X0, X0, #0xF\n0x0043D8D8 | 00 FC 44 D3 | LSR             X0, X0, #4\n0x0043D8DC | 00 EC 7C D3 | LSL             X0, X0, #4\n0x0043D8E0 | A0 3F 00 F9 | STR             X0, [X29,#0x80+lsa]\n0x0043D8E4 | A0 0B 40 F9 | LDR             X0, [X29,#0x80+sep]\n0x0043D8E8 | 00 34 40 F9 | LDR             X0, [X0,#0x68]\n0x0043D8EC | 01 00 40 B9 | LDR             W1, [X0]\n0x0043D8F0 | A0 3F 40 F9 | LDR             X0, [X29,#0x80+lsa]\n0x0043D8F4 | 01 00 00 B9 | STR             W1, [X0]\n0x0043D8F8 | A0 3F 40 F9 | LDR             X0, [X29,#0x80+lsa]\n0x0043D8FC | 00 10 00 91 | ADD             X0, X0, #4\n0x0043D900 | E2 03 00 AA | MOV             X2, X0\n0x0043D904 | A1 3F 40 F9 | LDR             X1, [X29,#0x80+lsa]\n0x0043D908 | A0 A3 00 91 | ADD             X0, X29, #0x28 ; '('\n0x0043D90C | E5 03 01 AA | MOV             X5, X1; addr_len\n0x0043D910 | E4 03 02 AA | MOV             X4, X2; addr\n0x0043D914 | 03 08 80 52 | MOV             W3, #0x40 ; '@'; flags\n0x0043D918 | 42 09 80 D2 | MOV             X2, #0x4A ; 'J'; n\n0x0043D91C | E1 03 00 AA | MOV             X1, X0; buf\n0x0043D920 | A0 1F 40 B9 | LDR             W0, [X29,#0x80+s]; fd\n0x0043D924 | 5F 25 FF 97 | BL              .recvfrom\n0x0043D928 | 1F 00 00 F1 | CMP             X0, #0\n0x0043D92C | 6B 0A 00 54 | B.LT            loc_43DA78\n0x0043D930 | A0 0A 00 D0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043D938 | 00 28 40 F9 | LDR             X0, [X0,#(bb_common_bufsiz1+0x50 - 0x593290)]\n0x0043D93C | 1F 00 00 F1 | CMP             X0, #0\n0x0043D940 | E1 00 00 54 | B.NE            loc_43D95C\n0x0043D944 | 76 FF FF 97 | BL              init_ring\n0x0043D948 | A0 0A 00 D0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043D950 | A1 0A 00 D0 21 C0 0B 91 | ADRL            X1, (bb_common_bufsiz1+0x60)\n0x0043D958 | 01 2C 00 F9 | STR             X1, [X0,#(bb_common_bufsiz1+0x58 - 0x593290)]\n0x0043D95C | A0 0A 00 D0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043D964 | 01 28 40 F9 | LDR             X1, [X0,#(bb_common_bufsiz1+0x50 - 0x593290)]\n0x0043D968 | A0 0A 00 D0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043D970 | 00 2C 40 F9 | LDR             X0, [X0,#(bb_common_bufsiz1+0x58 - 0x593290)]\n0x0043D974 | 20 00 00 CB | SUB             X0, X1, X0\n0x0043D978 | A0 77 00 B9 | STR             W0, [X29,#0x80+len]\n0x0043D97C | A0 77 40 B9 | LDR             W0, [X29,#0x80+len]\n0x0043D980 | 1F 1C 01 71 | CMP             W0, #0x47 ; 'G'\n0x0043D984 | 0D 01 00 54 | B.LE            loc_43D9A4\n0x0043D988 | A0 0A 00 D0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043D990 | 01 2C 40 F9 | LDR             X1, [X0,#(bb_common_bufsiz1+0x58 - 0x593290)]; src\n0x0043D994 | A0 A3 00 91 | ADD             X0, X29, #0x28 ; '('; dest\n0x0043D998 | 02 09 80 D2 | MOV             X2, #0x48 ; 'H'; n\n0x0043D99C | 39 23 FF 97 | BL              .memmove\n0x0043D9A0 | 14 00 00 14 | B               loc_43D9F0\n0x0043D9A4 | A0 0A 00 D0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043D9AC | 01 2C 40 F9 | LDR             X1, [X0,#(bb_common_bufsiz1+0x58 - 0x593290)]; src\n0x0043D9B0 | A2 77 80 B9 | LDRSW           X2, [X29,#0x80+len]; n\n0x0043D9B4 | A0 A3 00 91 | ADD             X0, X29, #0x28 ; '('; dest\n0x0043D9B8 | 32 23 FF 97 | BL              .memmove\n0x0043D9BC | A0 77 80 B9 | LDRSW           X0, [X29,#0x80+len]\n0x0043D9C0 | A1 A3 00 91 | ADD             X1, X29, #0x28 ; '('\n0x0043D9C4 | 23 00 00 8B | ADD             X3, X1, X0\n0x0043D9C8 | A0 0A 00 D0 | ADRP            X0, #(bb_common_bufsiz1+0x60)@PAGE\n0x0043D9CC | 04 C0 0B 91 | ADD             X4, X0, #(bb_common_bufsiz1+0x60)@PAGEOFF\n0x0043D9D0 | 01 09 80 52 | MOV             W1, #0x48 ; 'H'\n0x0043D9D4 | A0 77 40 B9 | LDR             W0, [X29,#0x80+len]\n0x0043D9D8 | 20 00 00 4B | SUB             W0, W1, W0\n0x0043D9DC | 00 7C 40 93 | SXTW            X0, W0\n0x0043D9E0 | E2 03 00 AA | MOV             X2, X0; n\n0x0043D9E4 | E1 03 04 AA | MOV             X1, X4; src\n0x0043D9E8 | E0 03 03 AA | MOV             X0, X3; dest\n0x0043D9EC | 25 23 FF 97 | BL              .memmove\n0x0043D9F0 | A0 0A 00 D0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043D9F8 | 01 2C 40 F9 | LDR             X1, [X0,#(bb_common_bufsiz1+0x58 - 0x593290)]\n0x0043D9FC | 21 04 00 91 | ADD             X1, X1, #1\n0x0043DA00 | 01 2C 00 F9 | STR             X1, [X0,#(bb_common_bufsiz1+0x58 - 0x593290)]\n0x0043DA04 | 01 2C 40 F9 | LDR             X1, [X0,#(bb_common_bufsiz1+0x58 - 0x593290)]\n0x0043DA08 | A0 0A 00 D0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043DA10 | 00 28 40 F9 | LDR             X0, [X0,#(bb_common_bufsiz1+0x50 - 0x593290)]\n0x0043DA14 | 3F 00 00 EB | CMP             X1, X0\n0x0043DA18 | C1 00 00 54 | B.NE            loc_43DA30\n0x0043DA1C | A0 0A 00 D0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0043DA24 | A1 0A 00 D0 21 C0 0B 91 | ADRL            X1, (bb_common_bufsiz1+0x60)\n0x0043DA2C | 01 2C 00 F9 | STR             X1, [X0,#(bb_common_bufsiz1+0x58 - 0x593290)]\n0x0043DA30 | A0 01 80 52 | MOV             W0, #0xD\n0x0043DA34 | A0 C3 01 39 | STRB            W0, [X29,#0x80+text+0x48]\n0x0043DA38 | 40 01 80 52 | MOV             W0, #0xA\n0x0043DA3C | A0 C7 01 39 | STRB            W0, [X29,#0x80+text+0x49]\n0x0043DA40 | A0 3F 40 F9 | LDR             X0, [X29,#0x80+lsa]\n0x0043DA44 | 00 10 00 91 | ADD             X0, X0, #4\n0x0043DA48 | E2 03 00 AA | MOV             X2, X0\n0x0043DA4C | A0 3F 40 F9 | LDR             X0, [X29,#0x80+lsa]\n0x0043DA50 | 01 00 40 B9 | LDR             W1, [X0]\n0x0043DA54 | A0 A3 00 91 | ADD             X0, X29, #0x28 ; '('\n0x0043DA58 | E5 03 01 2A | MOV             W5, W1; addr_len\n0x0043DA5C | E4 03 02 AA | MOV             X4, X2; addr\n0x0043DA60 | 03 00 80 52 | MOV             W3, #0; flags\n0x0043DA64 | 42 09 80 D2 | MOV             X2, #0x4A ; 'J'; n\n0x0043DA68 | E1 03 00 AA | MOV             X1, X0; buf\n0x0043DA6C | A0 1F 40 B9 | LDR             W0, [X29,#0x80+s]; fd\n0x0043DA70 | 10 23 FF 97 | BL              .sendto\n0x0043DA74 | 02 00 00 14 | B               loc_43DA7C\n0x0043DA78 | 1F 20 03 D5 | NOP\n0x0043DA7C | BF 03 00 91 | MOV             SP, X29\n0x0043DA80 | FD 7B C8 A8 | LDP             X29, X30, [SP+0x80+var_80],#0x80\n0x0043DA84 | C0 03 5F D6 | RET",
        "output": "```c\nvoid function(int s, struct sockaddr *sep) {\n    int len;\n    struct sockaddr *lsa;\n    char *buf = (char *)(sep + 1);\n    char *text = buf + 0x48;\n\n    len = *(int *)(*sep + 0x68);\n    len += 4;\n    lsa = (struct sockaddr *)(((((unsigned long)sep + 0x68) & ~0xF) + 0xF) & ~0xF);\n    *(int *)lsa = len;\n    lsa = (struct sockaddr *)(((((unsigned long)lsa + 4) & ~0xF) + 0xF) & ~0xF);\n\n    if (recvfrom(s, buf, 0x4A, 0x40, lsa, &lsa->sa_len) < 0) {\n        return;\n    }\n\n    if (!bb_common_bufsiz1) {\n        init_ring();\n        bb_common_bufsiz1 = bb_common_bufsiz1 + 0x60;\n    }\n\n    int available = bb_common_bufsiz1 - *(bb_common_bufsiz1 + 0x58);\n    len = *(int *)(sep + 1);\n    if (len > 0x47) {\n        memmove(buf, *(bb_common_bufsiz1 + 0x58), 0x48);\n    } else {\n        memmove(buf, *(bb_common_bufsiz1 + 0x58), len);\n        memmove(buf + len, bb_common_bufsiz1 + 0x60, 0x48 - len);\n    }\n\n    *(bb_common_bufsiz1 + 0x58) += 1;\n    if (*(bb_common_bufsiz1 + 0x58) == bb_common_bufsiz1) {\n        *(bb_common_bufsiz1 + 0x58) = bb_common_bufsiz1 + 0x60;\n    }\n\n    text[0] = 0xD;\n    text[1] = 0xA;\n    sendto(s, buf, 0x4A, 0, lsa, lsa->sa_len);\n}\n```"
    },
    {
        "func_name": "procargs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00491AA0 | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x00491AA4 | FD 03 00 91 | MOV             X29, SP\n0x00491AA8 | E0 0F 00 F9 | STR             X0, [SP,#0x40+argv]\n0x00491AAC | E0 0F 40 F9 | LDR             X0, [SP,#0x40+argv]\n0x00491AB0 | E0 1B 00 F9 | STR             X0, [SP,#0x40+xargv]\n0x00491AB4 | 20 08 00 90 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00491ABC | 00 00 40 F9 | LDR             X0, [X0]\n0x00491AC0 | E1 1B 40 F9 | LDR             X1, [SP,#0x40+xargv]\n0x00491AC4 | 21 00 40 F9 | LDR             X1, [X1]\n0x00491AC8 | 01 10 00 F9 | STR             X1, [X0,#0x20]\n0x00491ACC | E0 1B 40 F9 | LDR             X0, [SP,#0x40+xargv]\n0x00491AD0 | 00 20 00 91 | ADD             X0, X0, #8\n0x00491AD4 | E0 1B 00 F9 | STR             X0, [SP,#0x40+xargv]\n0x00491AD8 | FF 3F 00 B9 | STR             WZR, [SP,#0x40+i]\n0x00491ADC | 0B 00 00 14 | B               loc_491B08\n0x00491AE0 | 20 08 00 90 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00491AE8 | 01 00 40 F9 | LDR             X1, [X0]\n0x00491AEC | E0 3F 80 B9 | LDRSW           X0, [SP,#0x40+i]\n0x00491AF0 | 20 00 00 8B | ADD             X0, X1, X0\n0x00491AF4 | 41 00 80 52 | MOV             W1, #2\n0x00491AF8 | 01 14 01 39 | STRB            W1, [X0,#0x45]\n0x00491AFC | E0 3F 40 B9 | LDR             W0, [SP,#0x40+i]\n0x00491B00 | 00 04 00 11 | ADD             W0, W0, #1\n0x00491B04 | E0 3F 00 B9 | STR             W0, [SP,#0x40+i]\n0x00491B08 | E0 3F 40 B9 | LDR             W0, [SP,#0x40+i]\n0x00491B0C | 1F 38 00 71 | CMP             W0, #0xE\n0x00491B10 | 8D FE FF 54 | B.LE            loc_491AE0\n0x00491B14 | 00 08 00 B0 00 20 3F 91 | ADRL            X0, argptr\n0x00491B1C | E1 1B 40 F9 | LDR             X1, [SP,#0x40+xargv]\n0x00491B20 | 01 00 00 F9 | STR             X1, [X0]\n0x00491B24 | 20 00 80 52 | MOV             W0, #1; cmdline\n0x00491B28 | 31 EA FF 97 | BL              options\n0x00491B2C | 1F 00 00 71 | CMP             W0, #0\n0x00491B30 | 60 00 00 54 | B.EQ            loc_491B3C\n0x00491B34 | 20 00 80 52 | MOV             W0, #1; e\n0x00491B38 | 46 AB FF 97 | BL              raise_exception\n0x00491B3C | 00 08 00 B0 00 20 3F 91 | ADRL            X0, argptr\n0x00491B44 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491B48 | E0 1B 00 F9 | STR             X0, [SP,#0x40+xargv]\n0x00491B4C | 20 08 00 90 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00491B54 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491B58 | 00 04 40 F9 | LDR             X0, [X0,#8]\n0x00491B5C | E0 17 00 F9 | STR             X0, [SP,#0x40+xminusc]\n0x00491B60 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+xargv]\n0x00491B64 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491B68 | 1F 00 00 F1 | CMP             X0, #0\n0x00491B6C | C1 01 00 54 | B.NE            loc_491BA4\n0x00491B70 | E0 17 40 F9 | LDR             X0, [SP,#0x40+xminusc]\n0x00491B74 | 1F 00 00 F1 | CMP             X0, #0\n0x00491B78 | C0 00 00 54 | B.EQ            loc_491B90\n0x00491B7C | E0 05 00 F0 | ADRP            X0, #aC_9@PAGE; \"-c\"\n0x00491B80 | 01 20 26 91 | ADD             X1, X0, #aC_9@PAGEOFF; \"-c\"\n0x00491B84 | 60 06 00 F0 00 8C 1E 91 | ADRL            X0, bb_msg_requires_arg; \"%s requires an argument\"\n0x00491B8C | C4 AC FF 97 | BL              ash_msg_and_raise_error\n0x00491B90 | 20 08 00 90 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00491B98 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491B9C | 21 00 80 52 | MOV             W1, #1\n0x00491BA0 | 01 2C 01 39 | STRB            W1, [X0,#0x4B]\n0x00491BA4 | 20 08 00 90 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00491BAC | 00 00 40 F9 | LDR             X0, [X0]\n0x00491BB0 | 00 20 41 39 | LDRB            W0, [X0,#0x48]\n0x00491BB4 | 1F 08 00 71 | CMP             W0, #2\n0x00491BB8 | 81 02 00 54 | B.NE            loc_491C08\n0x00491BBC | 20 08 00 90 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00491BC4 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491BC8 | 00 2C 41 39 | LDRB            W0, [X0,#0x4B]\n0x00491BCC | 1F 04 00 71 | CMP             W0, #1\n0x00491BD0 | C1 01 00 54 | B.NE            loc_491C08\n0x00491BD4 | 00 00 80 52 | MOV             W0, #0; fd\n0x00491BD8 | 42 D7 FD 97 | BL              .isatty\n0x00491BDC | 1F 00 00 71 | CMP             W0, #0\n0x00491BE0 | 40 01 00 54 | B.EQ            loc_491C08\n0x00491BE4 | 20 00 80 52 | MOV             W0, #1; fd\n0x00491BE8 | 3E D7 FD 97 | BL              .isatty\n0x00491BEC | 1F 00 00 71 | CMP             W0, #0\n0x00491BF0 | C0 00 00 54 | B.EQ            loc_491C08\n0x00491BF4 | 20 08 00 90 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00491BFC | 00 00 40 F9 | LDR             X0, [X0]\n0x00491C00 | 21 00 80 52 | MOV             W1, #1\n0x00491C04 | 01 20 01 39 | STRB            W1, [X0,#0x48]\n0x00491C08 | 20 08 00 90 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00491C10 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491C14 | 00 24 41 39 | LDRB            W0, [X0,#0x49]\n0x00491C18 | 1F 08 00 71 | CMP             W0, #2\n0x00491C1C | 21 01 00 54 | B.NE            loc_491C40\n0x00491C20 | 20 08 00 90 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00491C28 | 01 00 40 F9 | LDR             X1, [X0]\n0x00491C2C | 20 08 00 90 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00491C34 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491C38 | 21 20 41 39 | LDRB            W1, [X1,#0x48]\n0x00491C3C | 01 24 01 39 | STRB            W1, [X0,#0x49]\n0x00491C40 | FF 3F 00 B9 | STR             WZR, [SP,#0x40+i]\n0x00491C44 | 12 00 00 14 | B               loc_491C8C\n0x00491C48 | 20 08 00 90 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00491C50 | 01 00 40 F9 | LDR             X1, [X0]\n0x00491C54 | E0 3F 80 B9 | LDRSW           X0, [SP,#0x40+i]\n0x00491C58 | 20 00 00 8B | ADD             X0, X1, X0\n0x00491C5C | 00 14 41 39 | LDRB            W0, [X0,#0x45]\n0x00491C60 | 1F 08 00 71 | CMP             W0, #2\n0x00491C64 | E1 00 00 54 | B.NE            loc_491C80\n0x00491C68 | 20 08 00 90 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00491C70 | 01 00 40 F9 | LDR             X1, [X0]\n0x00491C74 | E0 3F 80 B9 | LDRSW           X0, [SP,#0x40+i]\n0x00491C78 | 20 00 00 8B | ADD             X0, X1, X0\n0x00491C7C | 1F 14 01 39 | STRB            WZR, [X0,#0x45]\n0x00491C80 | E0 3F 40 B9 | LDR             W0, [SP,#0x40+i]\n0x00491C84 | 00 04 00 11 | ADD             W0, W0, #1\n0x00491C88 | E0 3F 00 B9 | STR             W0, [SP,#0x40+i]\n0x00491C8C | E0 3F 40 B9 | LDR             W0, [SP,#0x40+i]\n0x00491C90 | 1F 38 00 71 | CMP             W0, #0xE\n0x00491C94 | AD FD FF 54 | B.LE            loc_491C48\n0x00491C98 | E0 17 40 F9 | LDR             X0, [SP,#0x40+xminusc]\n0x00491C9C | 1F 00 00 F1 | CMP             X0, #0\n0x00491CA0 | C0 01 00 54 | B.EQ            loc_491CD8\n0x00491CA4 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+xargv]\n0x00491CA8 | 01 20 00 91 | ADD             X1, X0, #8\n0x00491CAC | E1 1B 00 F9 | STR             X1, [SP,#0x40+xargv]\n0x00491CB0 | 21 08 00 90 21 C0 0F 91 | ADRL            X1, ash_ptr_to_globals_misc\n0x00491CB8 | 21 00 40 F9 | LDR             X1, [X1]\n0x00491CBC | 00 00 40 F9 | LDR             X0, [X0]\n0x00491CC0 | 20 04 00 F9 | STR             X0, [X1,#8]\n0x00491CC4 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+xargv]\n0x00491CC8 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491CCC | 1F 00 00 F1 | CMP             X0, #0\n0x00491CD0 | 60 03 00 54 | B.EQ            loc_491D3C\n0x00491CD4 | 0B 00 00 14 | B               setarg0\n0x00491CD8 | 20 08 00 90 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00491CE0 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491CE4 | 00 2C 41 39 | LDRB            W0, [X0,#0x4B]\n0x00491CE8 | 1F 00 00 71 | CMP             W0, #0\n0x00491CEC | 81 02 00 54 | B.NE            loc_491D3C\n0x00491CF0 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+xargv]\n0x00491CF4 | 00 00 40 F9 | LDR             X0, [X0]; fname\n0x00491CF8 | 01 00 80 52 | MOV             W1, #0; flags\n0x00491CFC | 82 E8 FF 97 | BL              setinputfile\n0x00491D00 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+xargv]\n0x00491D04 | 01 20 00 91 | ADD             X1, X0, #8\n0x00491D08 | E1 1B 00 F9 | STR             X1, [SP,#0x40+xargv]\n0x00491D0C | 21 08 00 90 21 C0 0F 91 | ADRL            X1, ash_ptr_to_globals_misc\n0x00491D14 | 21 00 40 F9 | LDR             X1, [X1]\n0x00491D18 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491D1C | 20 10 00 F9 | STR             X0, [X1,#0x20]\n0x00491D20 | 20 08 00 90 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00491D28 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491D2C | 01 10 40 F9 | LDR             X1, [X0,#0x20]\n0x00491D30 | 00 08 00 B0 00 C0 3E 91 | ADRL            X0, commandname\n0x00491D38 | 01 00 00 F9 | STR             X1, [X0]\n0x00491D3C | 20 08 00 90 00 E0 0F 91 | ADRL            X0, ash_ptr_to_globals_var\n0x00491D44 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491D48 | E1 1B 40 F9 | LDR             X1, [SP,#0x40+xargv]\n0x00491D4C | 01 08 00 F9 | STR             X1, [X0,#0x10]\n0x00491D50 | 20 08 00 90 00 E0 0F 91 | ADRL            X0, ash_ptr_to_globals_var\n0x00491D58 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491D5C | 21 00 80 52 | MOV             W1, #1\n0x00491D60 | 01 04 00 B9 | STR             W1, [X0,#4]\n0x00491D64 | 20 08 00 90 00 E0 0F 91 | ADRL            X0, ash_ptr_to_globals_var\n0x00491D6C | 00 00 40 F9 | LDR             X0, [X0]\n0x00491D70 | 01 00 80 12 | MOV             W1, #0xFFFFFFFF\n0x00491D74 | 01 08 00 B9 | STR             W1, [X0,#8]\n0x00491D78 | 0A 00 00 14 | B               loc_491DA0\n0x00491D7C | 20 08 00 90 00 E0 0F 91 | ADRL            X0, ash_ptr_to_globals_var\n0x00491D84 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491D88 | 01 00 40 B9 | LDR             W1, [X0]\n0x00491D8C | 21 04 00 11 | ADD             W1, W1, #1\n0x00491D90 | 01 00 00 B9 | STR             W1, [X0]\n0x00491D94 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+xargv]\n0x00491D98 | 00 20 00 91 | ADD             X0, X0, #8\n0x00491D9C | E0 1B 00 F9 | STR             X0, [SP,#0x40+xargv]\n0x00491DA0 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+xargv]\n0x00491DA4 | 00 00 40 F9 | LDR             X0, [X0]\n0x00491DA8 | 1F 00 00 F1 | CMP             X0, #0\n0x00491DAC | 81 FE FF 54 | B.NE            loc_491D7C\n0x00491DB0 | 9C E0 FF 97 | BL              optschanged\n0x00491DB4 | 1F 20 03 D5 | NOP\n0x00491DB8 | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x00491DBC | C0 03 5F D6 | RET",
        "output": "```c\nvoid function(char **argv) {\n    char **xargv = argv;\n    void *ash_ptr_to_globals_misc = get_ash_ptr_to_globals_misc();\n    void *argptr = get_argptr();\n\n    for (int i = 0; i <= 0xE; ++i) {\n        ash_ptr_to_globals_misc->field_0x45[i] = 2;\n    }\n\n    argptr->field_0x0 = xargv;\n\n    if (options(1) == 0) {\n        raise_exception(1);\n    }\n\n    xargv = argptr->field_0x0;\n    char *xminusc = ash_ptr_to_globals_misc->field_0x8;\n\n    if (*xargv == NULL && xminusc == NULL) {\n        ash_ptr_to_globals_misc->field_0x4B = 1;\n    } else if (*xargv == NULL) {\n        ash_msg_and_raise_error(\"%s requires an argument\", \"-c\");\n    }\n\n    if (ash_ptr_to_globals_misc->field_0x48 == 2 && ash_ptr_to_globals_misc->field_0x4B == 1) {\n        if (.isatty(0) && .isatty(1)) {\n            ash_ptr_to_globals_misc->field_0x48 = 1;\n        }\n    }\n\n    if (ash_ptr_to_globals_misc->field_0x49 == 2) {\n        ash_ptr_to_globals_misc->field_0x49 = ash_ptr_to_globals_misc->field_0x48;\n    }\n\n    for (int i = 0; i <= 0xE; ++i) {\n        if (ash_ptr_to_globals_misc->field_0x45[i] == 2) {\n            ash_ptr_to_globals_misc->field_0x45[i] = 0;\n        }\n    }\n\n    if (xminusc != NULL) {\n        xargv++;\n        ash_ptr_to_globals_misc->field_0x8 = *xargv;\n        if (*xargv != NULL) {\n            setarg0();\n        }\n    }\n\n    if (ash_ptr_to_globals_misc->field_0x4B == 0) {\n        setinputfile(*xargv, 0);\n        xargv++;\n        ash_ptr_to_globals_misc->field_0x20 = *xargv;\n        commandname = ash_ptr_to_globals_misc->field_0x20;\n    }\n\n    void *ash_ptr_to_globals_var = get_ash_ptr_to_globals_var();\n    ash_ptr_to_globals_var->field_0x10 = xargv;\n    ash_ptr_to_globals_var->field_0x4 = 1;\n    ash_ptr_to_globals_var->field_0x8 = -1;\n\n    while (*xargv != NULL) {\n        ash_ptr_to_globals_var->field_0x0++;\n        xargv++;\n    }\n\n    optschanged();\n}\n```"
    },
    {
        "func_name": "put_iac2",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0044A7D8 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x0044A7DC | FD 03 00 91 | MOV             X29, SP\n0x0044A7E0 | E0 7F 00 39 | STRB            W0, [SP,#0x20+wwdd]\n0x0044A7E4 | E1 7B 00 39 | STRB            W1, [SP,#0x20+c]\n0x0044A7E8 | 40 0A 00 B0 00 40 0A 91 | ADRL            X0, bb_common_bufsiz1\n0x0044A7F0 | 00 00 40 B9 | LDR             W0, [X0]\n0x0044A7F4 | 1F F4 01 71 | CMP             W0, #0x7D ; '}'\n0x0044A7F8 | 4D 00 00 54 | B.LE            loc_44A800\n0x0044A7FC | 7B FE FF 97 | BL              iac_flush\n0x0044A800 | E0 1F 80 52 | MOV             W0, #0xFF; c\n0x0044A804 | E3 FF FF 97 | BL              put_iac\n0x0044A808 | E0 7F 40 39 | LDRB            W0, [SP,#0x20+wwdd]; c\n0x0044A80C | E1 FF FF 97 | BL              put_iac\n0x0044A810 | E0 7B 40 39 | LDRB            W0, [SP,#0x20+c]; c\n0x0044A814 | DF FF FF 97 | BL              put_iac\n0x0044A818 | 1F 20 03 D5 | NOP\n0x0044A81C | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x0044A820 | C0 03 5F D6 | RET",
        "output": "```c\nvoid function(unsigned char wwdd, unsigned char c) {\n    unsigned int bb_common_bufsiz1;\n    extern void iac_flush(void);\n    extern void put_iac(unsigned char);\n\n    if (bb_common_bufsiz1 <= 0x7D) {\n        iac_flush();\n    }\n\n    put_iac(0xFF);\n    put_iac(wwdd);\n    put_iac(c);\n}\n```"
    },
    {
        "func_name": "raidautorun_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00425E40 | FD 7B BE A9 | STP             X29, X30, [SP,#var_20]!\n0x00425E44 | FD 03 00 91 | MOV             X29, SP\n0x00425E48 | E0 1F 00 B9 | STR             W0, [SP,#0x20+argc]\n0x00425E4C | E1 0B 00 F9 | STR             X1, [SP,#0x20+argv]\n0x00425E50 | E0 0B 40 F9 | LDR             X0, [SP,#0x20+argv]; argv\n0x00425E54 | 3C 2D 04 94 | BL              single_argv\n0x00425E58 | 01 00 80 52 | MOV             W1, #0; flags\n0x00425E5C | 41 93 FF 97 | BL              xopen\n0x00425E60 | E4 03 00 2A | MOV             W4, W0\n0x00425E64 | E0 08 00 D0 | ADRP            X0, #aRaidAutorun@PAGE; \"RAID_AUTORUN\"\n0x00425E68 | 03 C0 0F 91 | ADD             X3, X0, #aRaidAutorun@PAGEOFF; \"RAID_AUTORUN\"\n0x00425E6C | 02 00 80 D2 | MOV             X2, #0; argp\n0x00425E70 | 81 22 81 52 | MOV             W1, #0x914; request\n0x00425E74 | E0 03 04 2A | MOV             W0, W4; fd\n0x00425E78 | 14 96 FF 97 | BL              bb_xioctl\n0x00425E7C | 00 00 80 52 | MOV             W0, #0\n0x00425E80 | FD 7B C2 A8 | LDP             X29, X30, [SP+0x20+var_20],#0x20\n0x00425E84 | C0 03 5F D6 | RET",
        "output": "```c\n#include <unistd.h>\n#include <fcntl.h>\n\nextern void single_argv(char **argv);\nextern int xopen(const char *pathname, int flags);\nextern int bb_xioctl(int fd, unsigned long request, void *argp);\n\nint main(int argc, char **argv) {\n    single_argv(argv);\n    int fd = xopen(*argv, 0);\n    bb_xioctl(fd, 0x914, \"RAID_AUTORUN\");\n    return 0;\n}\n```"
    },
    {
        "func_name": "pgetc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0048BB60 | FD 7B BF A9 | STP             X29, X30, [SP,#-0x10+var_s0]!\n0x0048BB64 | FD 03 00 91 | MOV             X29, SP\n0x0048BB68 | 20 08 00 F0 00 40 2F 91 | ADRL            X0, g_parsefile\n0x0048BB70 | 00 00 40 F9 | LDR             X0, [X0]; basepf\n0x0048BB74 | 01 10 40 B9 | LDR             W1, [X0,#(basepf.left_in_line - 0x592F50)]\n0x0048BB78 | 21 04 00 51 | SUB             W1, W1, #1\n0x0048BB7C | 01 10 00 B9 | STR             W1, [X0,#(basepf.left_in_line - 0x592F50)]\n0x0048BB80 | 00 10 40 B9 | LDR             W0, [X0,#(basepf.left_in_line - 0x592F50)]\n0x0048BB84 | 1F 00 00 71 | CMP             W0, #0\n0x0048BB88 | 2B 01 00 54 | B.LT            loc_48BBAC\n0x0048BB8C | 20 08 00 F0 00 40 2F 91 | ADRL            X0, g_parsefile\n0x0048BB94 | 01 00 40 F9 | LDR             X1, [X0]; basepf\n0x0048BB98 | 20 0C 40 F9 | LDR             X0, [X1,#(basepf.next_to_pgetc - 0x592F50)]\n0x0048BB9C | 02 04 00 91 | ADD             X2, X0, #1\n0x0048BBA0 | 22 0C 00 F9 | STR             X2, [X1,#(basepf.next_to_pgetc - 0x592F50)]\n0x0048BBA4 | 00 00 40 39 | LDRB            W0, [X0]\n0x0048BBA8 | 02 00 00 14 | B               loc_48BBB0\n0x0048BBAC | 25 FF FF 97 | BL              preadbuffer\n0x0048BBB0 | FD 7B C1 A8 | LDP             X29, X30, [SP+var_s0],#0x10\n0x0048BBB4 | C0 03 5F D6 | RET",
        "output": "```c\nint g_parsefile(void);\n\nvoid preadbuffer(void);\n\nint function_48BB60() {\n    g_parsefile->left_in_line -= 1;\n    if (g_parsefile->left_in_line < 0) {\n        preadbuffer();\n    } else {\n        g_parsefile->next_to_pgetc += 1;\n    }\n    return (unsigned char) *g_parsefile->next_to_pgetc;\n}\n```"
    },
    {
        "func_name": "execable_file",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0051F320 | FD 7B B6 A9 | STP             X29, X30, [SP,#var_A0]!\n0x0051F324 | FD 03 00 91 | MOV             X29, SP\n0x0051F328 | E0 0F 00 F9 | STR             X0, [SP,#0xA0+name]\n0x0051F32C | 21 00 80 52 | MOV             W1, #1; type\n0x0051F330 | E0 0F 40 F9 | LDR             X0, [SP,#0xA0+name]; name\n0x0051F334 | EF 9F FB 97 | BL              .access\n0x0051F338 | 1F 00 00 71 | CMP             W0, #0\n0x0051F33C | A1 01 00 54 | B.NE            loc_51F370\n0x0051F340 | E0 83 00 91 | ADD             X0, SP, #0xA0+s\n0x0051F344 | E1 03 00 AA | MOV             X1, X0; buf\n0x0051F348 | E0 0F 40 F9 | LDR             X0, [SP,#0xA0+name]; file\n0x0051F34C | D9 A2 FB 97 | BL              stat64_0\n0x0051F350 | 1F 00 00 71 | CMP             W0, #0\n0x0051F354 | E1 00 00 54 | B.NE            loc_51F370\n0x0051F358 | E0 33 40 B9 | LDR             W0, [SP,#0xA0+s.st_mode]\n0x0051F35C | 00 0C 14 12 | AND             W0, W0, #0xF000\n0x0051F360 | 1F 20 40 71 | CMP             W0, #8,LSL#12\n0x0051F364 | 61 00 00 54 | B.NE            loc_51F370\n0x0051F368 | 20 00 80 52 | MOV             W0, #1\n0x0051F36C | 02 00 00 14 | B               loc_51F374\n0x0051F370 | 00 00 80 52 | MOV             W0, #0\n0x0051F374 | FD 7B CA A8 | LDP             X29, X30, [SP+0xA0+var_A0],#0xA0\n0x0051F378 | C0 03 5F D6 | RET",
        "output": "```c\nint check_file_access_and_type(const char *name) {\n    struct stat s;\n    if (access(name, 1) != 0) {\n        return 0;\n    }\n    if (stat64_0(name, &s) != 0) {\n        return 0;\n    }\n    if ((s.st_mode & 0xF000) != (8 << 12)) {\n        return 0;\n    }\n    return 1;\n}\n```"
    },
    {
        "func_name": "touch_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F7434 | FD 7B B1 A9 | STP             X29, X30, [SP,#var_F0]!\n0x004F7438 | FD 03 00 91 | MOV             X29, SP\n0x004F743C | E0 1F 00 B9 | STR             W0, [SP,#0xF0+argc]\n0x004F7440 | E1 0B 00 F9 | STR             X1, [SP,#0xF0+argv]\n0x004F7444 | FF EF 00 B9 | STR             WZR, [SP,#0xF0+status]\n0x004F7448 | FF 6F 00 F9 | STR             XZR, [SP,#0xF0+reference_file]\n0x004F744C | FF 6B 00 F9 | STR             XZR, [SP,#0xF0+date_str]\n0x004F7450 | FF 5F 00 F9 | STR             XZR, [SP,#0xF0+timebuf.tv_usec]\n0x004F7454 | E0 5F 40 F9 | LDR             X0, [SP,#0xF0+timebuf.tv_usec]\n0x004F7458 | E0 67 00 F9 | STR             X0, [SP,#0xF0+timebuf.tv_usec+0x10]\n0x004F745C | E0 04 00 D0 00 80 10 91 | ADRL            X0, applet_long_options\n0x004F7464 | 21 03 00 90 21 EC 29 91 | ADRL            X1, touch_longopts.9487; \"no-create\"\n0x004F746C | 01 00 00 F9 | STR             X1, [X0]\n0x004F7470 | E2 43 03 91 | ADD             X2, SP, #0xF0+date_str\n0x004F7474 | E1 43 03 91 | ADD             X1, SP, #0xF0+date_str\n0x004F7478 | E0 63 03 91 | ADD             X0, SP, #0xF0+reference_file\n0x004F747C | E4 03 02 AA | MOV             X4, X2\n0x004F7480 | E3 03 01 AA | MOV             X3, X1\n0x004F7484 | E2 03 00 AA | MOV             X2, X0\n0x004F7488 | 20 03 00 90 | ADRP            X0, #aCrDTFma@PAGE; \"cr:d:t:fma\"\n0x004F748C | 01 C0 29 91 | ADD             X1, X0, #aCrDTFma@PAGEOFF; \"cr:d:t:fma\"\n0x004F7490 | E0 0B 40 F9 | LDR             X0, [SP,#0xF0+argv]; argv\n0x004F7494 | 12 A4 00 94 | BL              getopt32\n0x004F7498 | E0 EB 00 B9 | STR             W0, [SP,#0xF0+opts]\n0x004F749C | E0 EB 40 B9 | LDR             W0, [SP,#0xF0+opts]\n0x004F74A0 | 00 00 00 12 | AND             W0, W0, #1\n0x004F74A4 | E0 EB 00 B9 | STR             W0, [SP,#0xF0+opts]\n0x004F74A8 | C0 04 00 F0 00 40 39 91 | ADRL            X0, optind__GLIBC_2.17\n0x004F74B0 | 00 00 40 B9 | LDR             W0, [X0]\n0x004F74B4 | 00 7C 40 93 | SXTW            X0, W0\n0x004F74B8 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x004F74BC | E1 0B 40 F9 | LDR             X1, [SP,#0xF0+argv]\n0x004F74C0 | 20 00 00 8B | ADD             X0, X1, X0\n0x004F74C4 | E0 0B 00 F9 | STR             X0, [SP,#0xF0+argv]\n0x004F74C8 | E0 0B 40 F9 | LDR             X0, [SP,#0xF0+argv]\n0x004F74CC | 00 00 40 F9 | LDR             X0, [X0]\n0x004F74D0 | 1F 00 00 F1 | CMP             X0, #0\n0x004F74D4 | 41 00 00 54 | B.NE            loc_4F74DC\n0x004F74D8 | E0 42 FC 97 | BL              bb_show_usage\n0x004F74DC | E0 6F 40 F9 | LDR             X0, [SP,#0xF0+reference_file]\n0x004F74E0 | 1F 00 00 F1 | CMP             X0, #0\n0x004F74E4 | 00 01 00 54 | B.EQ            loc_4F7504\n0x004F74E8 | E0 6F 40 F9 | LDR             X0, [SP,#0xF0+reference_file]; name\n0x004F74EC | E1 A3 00 91 | ADD             X1, SP, #0xF0+tm_time; stat_buf\n0x004F74F0 | CB 4F FC 97 | BL              xstat\n0x004F74F4 | E0 43 40 F9 | LDR             X0, [SP,#0xF0+var_70]\n0x004F74F8 | E0 5B 00 F9 | STR             X0, [SP,#0xF0+timebuf]\n0x004F74FC | E0 5B 40 F9 | LDR             X0, [SP,#0xF0+timebuf]\n0x004F7500 | E0 63 00 F9 | STR             X0, [SP,#0xF0+timebuf.tv_sec+0x10]\n0x004F7504 | E0 6B 40 F9 | LDR             X0, [SP,#0xF0+date_str]\n0x004F7508 | 1F 00 00 F1 | CMP             X0, #0\n0x004F750C | 60 02 00 54 | B.EQ            loc_4F7558\n0x004F7510 | E0 A3 02 91 | ADD             X0, SP, #0xF0+t; timer\n0x004F7514 | 2F 3E FC 97 | BL              .time\n0x004F7518 | E1 A3 00 91 | ADD             X1, SP, #0xF0+tm_time; tp\n0x004F751C | E0 A3 02 91 | ADD             X0, SP, #0xF0+t; timer\n0x004F7520 | 34 3D FC 97 | BL              .localtime_r\n0x004F7524 | E0 6B 40 F9 | LDR             X0, [SP,#0xF0+date_str]; date_str\n0x004F7528 | E1 A3 00 91 | ADD             X1, SP, #0xF0+tm_time; ptm\n0x004F752C | D6 52 FC 97 | BL              parse_datestr\n0x004F7530 | 00 00 80 12 | MOV             W0, #0xFFFFFFFF\n0x004F7534 | E0 4B 00 B9 | STR             W0, [SP,#0xF0+tm_time.tm_isdst]\n0x004F7538 | E0 6B 40 F9 | LDR             X0, [SP,#0xF0+date_str]; date_str\n0x004F753C | E1 A3 00 91 | ADD             X1, SP, #0xF0+tm_time; ptm\n0x004F7540 | 73 54 FC 97 | BL              validate_tm_time\n0x004F7544 | E0 57 00 F9 | STR             X0, [SP,#0xF0+t]\n0x004F7548 | E0 57 40 F9 | LDR             X0, [SP,#0xF0+t]\n0x004F754C | E0 5B 00 F9 | STR             X0, [SP,#0xF0+timebuf]\n0x004F7550 | E0 5B 40 F9 | LDR             X0, [SP,#0xF0+timebuf]\n0x004F7554 | E0 63 00 F9 | STR             X0, [SP,#0xF0+timebuf.tv_sec+0x10]\n0x004F7558 | E0 0B 40 F9 | LDR             X0, [SP,#0xF0+argv]\n0x004F755C | 02 00 40 F9 | LDR             X2, [X0]\n0x004F7560 | E0 6F 40 F9 | LDR             X0, [SP,#0xF0+reference_file]\n0x004F7564 | 1F 00 00 F1 | CMP             X0, #0\n0x004F7568 | 81 00 00 54 | B.NE            loc_4F7578\n0x004F756C | E0 6B 40 F9 | LDR             X0, [SP,#0xF0+date_str]\n0x004F7570 | 1F 00 00 F1 | CMP             X0, #0\n0x004F7574 | 60 00 00 54 | B.EQ            loc_4F7580\n0x004F7578 | E0 C3 02 91 | ADD             X0, SP, #0xF0+timebuf\n0x004F757C | 02 00 00 14 | B               loc_4F7584\n0x004F7580 | 00 00 80 D2 | MOV             X0, #0\n0x004F7584 | E1 03 00 AA | MOV             X1, X0; tvp\n0x004F7588 | E0 03 02 AA | MOV             X0, X2; file\n0x004F758C | FD 40 FC 97 | BL              .utimes\n0x004F7590 | 1F 00 00 71 | CMP             W0, #0\n0x004F7594 | 20 05 00 54 | B.EQ            loc_4F7638\n0x004F7598 | E0 04 00 D0 00 60 0A 91 | ADRL            X0, bb_errno\n0x004F75A0 | 00 00 40 F9 | LDR             X0, [X0]\n0x004F75A4 | 00 00 40 B9 | LDR             W0, [X0]\n0x004F75A8 | 1F 08 00 71 | CMP             W0, #2\n0x004F75AC | 41 03 00 54 | B.NE            loc_4F7614\n0x004F75B0 | E0 EB 40 B9 | LDR             W0, [SP,#0xF0+opts]\n0x004F75B4 | 1F 00 00 71 | CMP             W0, #0\n0x004F75B8 | A1 03 00 54 | B.NE            loc_4F762C\n0x004F75BC | E0 0B 40 F9 | LDR             X0, [SP,#0xF0+argv]\n0x004F75C0 | 00 00 40 F9 | LDR             X0, [X0]; file\n0x004F75C4 | C2 36 80 52 | MOV             W2, #0x1B6\n0x004F75C8 | 41 08 80 52 | MOV             W1, #0x42 ; 'B'; oflag\n0x004F75CC | D5 40 FC 97 | BL              .open64\n0x004F75D0 | E0 E7 00 B9 | STR             W0, [SP,#0xF0+fd]\n0x004F75D4 | E0 E7 40 B9 | LDR             W0, [SP,#0xF0+fd]\n0x004F75D8 | 1F 00 00 71 | CMP             W0, #0\n0x004F75DC | CB 01 00 54 | B.LT            loc_4F7614\n0x004F75E0 | E0 E7 40 B9 | LDR             W0, [SP,#0xF0+fd]; fd\n0x004F75E4 | 14 4E FC 97 | BL              xclose\n0x004F75E8 | E0 6F 40 F9 | LDR             X0, [SP,#0xF0+reference_file]\n0x004F75EC | 1F 00 00 F1 | CMP             X0, #0\n0x004F75F0 | 81 00 00 54 | B.NE            loc_4F7600\n0x004F75F4 | E0 6B 40 F9 | LDR             X0, [SP,#0xF0+date_str]\n0x004F75F8 | 1F 00 00 F1 | CMP             X0, #0\n0x004F75FC | C0 01 00 54 | B.EQ            loc_4F7634\n0x004F7600 | E0 0B 40 F9 | LDR             X0, [SP,#0xF0+argv]\n0x004F7604 | 00 00 40 F9 | LDR             X0, [X0]; file\n0x004F7608 | E1 C3 02 91 | ADD             X1, SP, #0xF0+timebuf; tvp\n0x004F760C | DD 40 FC 97 | BL              .utimes\n0x004F7610 | 09 00 00 14 | B               loc_4F7634\n0x004F7614 | 20 00 80 52 | MOV             W0, #1\n0x004F7618 | E0 EF 00 B9 | STR             W0, [SP,#0xF0+status]\n0x004F761C | E0 0B 40 F9 | LDR             X0, [SP,#0xF0+argv]\n0x004F7620 | 00 00 40 F9 | LDR             X0, [X0]; s\n0x004F7624 | 8B 48 FC 97 | BL              bb_simple_perror_msg\n0x004F7628 | 04 00 00 14 | B               loc_4F7638\n0x004F762C | 1F 20 03 D5 | NOP\n0x004F7630 | 02 00 00 14 | B               loc_4F7638\n0x004F7634 | 1F 20 03 D5 | NOP\n0x004F7638 | E0 0B 40 F9 | LDR             X0, [SP,#0xF0+argv]\n0x004F763C | 00 20 00 91 | ADD             X0, X0, #8\n0x004F7640 | E0 0B 00 F9 | STR             X0, [SP,#0xF0+argv]\n0x004F7644 | E0 0B 40 F9 | LDR             X0, [SP,#0xF0+argv]\n0x004F7648 | 00 00 40 F9 | LDR             X0, [X0]\n0x004F764C | 1F 00 00 F1 | CMP             X0, #0\n0x004F7650 | 41 F8 FF 54 | B.NE            loc_4F7558\n0x004F7654 | E0 EF 40 B9 | LDR             W0, [SP,#0xF0+status]\n0x004F7658 | FD 7B CF A8 | LDP             X29, X30, [SP+0xF0+var_F0],#0xF0\n0x004F765C | C0 03 5F D6 | RET",
        "output": "```c\nint main(int argc, char **argv) {\n    int status = 0;\n    char *reference_file = NULL;\n    char *date_str = NULL;\n    struct timeval timebuf = {0};\n    int opts;\n\n    getopt32(argv, \"cr:d:t:fma\");\n    opts = getopt32(argv, \"cr:d:t:fma\");\n    opts &= 1;\n\n    if (optind__GLIBC_2.17 < argc) {\n        argv += optind__GLIBC_2.17;\n    } else {\n        bb_show_usage();\n    }\n\n    if (reference_file) {\n        struct stat stat_buf;\n        xstat(reference_file, &stat_buf);\n        timebuf.tv_sec = stat_buf.st_mtime;\n    }\n\n    if (date_str) {\n        time_t t = time(NULL);\n        struct tm tm_time;\n        localtime_r(&t, &tm_time);\n        parse_datestr(date_str, &tm_time);\n        tm_time.tm_isdst = -1;\n        validate_tm_time(date_str, &tm_time);\n        t = mktime(&tm_time);\n        timebuf.tv_sec = t;\n    }\n\n    if (!reference_file && !date_str) {\n        utimes(*argv, NULL);\n    } else {\n        utimes(*argv, &timebuf);\n    }\n\n    if (errno == ENOENT && !(opts & 1)) {\n        int fd = open64(*argv, O_CREAT | O_WRONLY, 0666);\n        if (fd >= 0) {\n            xclose(fd);\n            if (!reference_file && !date_str) {\n                utimes(*argv, NULL);\n            } else {\n                utimes(*argv, &timebuf);\n            }\n        } else {\n            status = 1;\n            bb_simple_perror_msg(*argv);\n        }\n    } else if (errno != ENOENT) {\n        status = 1;\n        bb_simple_perror_msg(*argv);\n    }\n\n    argv++;\n    if (*argv) {\n        goto repeat;\n    }\n\n    return status;\n}\n```"
    },
    {
        "func_name": "add_cmd_block",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0050E0B4 | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x0050E0B8 | FD 03 00 91 | MOV             X29, SP\n0x0050E0BC | E0 0F 00 F9 | STR             X0, [SP,#0x40+cmdstr]\n0x0050E0C0 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+cmdstr]; s\n0x0050E0C4 | 3B F2 FB 97 | BL              xstrdup\n0x0050E0C8 | E0 13 00 F9 | STR             X0, [SP,#0x40+sv]\n0x0050E0CC | E0 13 40 F9 | LDR             X0, [SP,#0x40+sv]\n0x0050E0D0 | E0 0F 00 F9 | STR             X0, [SP,#0x40+cmdstr]\n0x0050E0D4 | 41 01 80 52 | MOV             W1, #0xA; c\n0x0050E0D8 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+cmdstr]; s\n0x0050E0DC | 65 E5 FB 97 | BL              .strchr\n0x0050E0E0 | E0 1F 00 F9 | STR             X0, [SP,#0x40+eol]\n0x0050E0E4 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+eol]\n0x0050E0E8 | 1F 00 00 F1 | CMP             X0, #0\n0x0050E0EC | 40 04 00 54 | B.EQ            loc_50E174\n0x0050E0F0 | FF 37 00 B9 | STR             WZR, [SP,#0x40+slashes]\n0x0050E0F4 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+eol]\n0x0050E0F8 | E0 17 00 F9 | STR             X0, [SP,#0x40+sl]\n0x0050E0FC | 04 00 00 14 | B               loc_50E10C\n0x0050E100 | E0 37 40 B9 | LDR             W0, [SP,#0x40+slashes]\n0x0050E104 | 00 04 00 11 | ADD             W0, W0, #1\n0x0050E108 | E0 37 00 B9 | STR             W0, [SP,#0x40+slashes]\n0x0050E10C | E1 17 40 F9 | LDR             X1, [SP,#0x40+sl]\n0x0050E110 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+cmdstr]\n0x0050E114 | 3F 00 00 EB | CMP             X1, X0\n0x0050E118 | 00 01 00 54 | B.EQ            loc_50E138\n0x0050E11C | E0 17 40 F9 | LDR             X0, [SP,#0x40+sl]\n0x0050E120 | 00 04 00 D1 | SUB             X0, X0, #1\n0x0050E124 | E0 17 00 F9 | STR             X0, [SP,#0x40+sl]\n0x0050E128 | E0 17 40 F9 | LDR             X0, [SP,#0x40+sl]\n0x0050E12C | 00 00 40 39 | LDRB            W0, [X0]\n0x0050E130 | 1F 70 01 71 | CMP             W0, #0x5C ; '\\'\n0x0050E134 | 60 FE FF 54 | B.EQ            loc_50E100\n0x0050E138 | E0 37 40 B9 | LDR             W0, [SP,#0x40+slashes]\n0x0050E13C | 00 00 00 12 | AND             W0, W0, #1\n0x0050E140 | 1F 00 00 71 | CMP             W0, #0\n0x0050E144 | 40 01 00 54 | B.EQ            loc_50E16C\n0x0050E148 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+eol]\n0x0050E14C | 00 04 00 D1 | SUB             X0, X0, #1; dst\n0x0050E150 | E1 1F 40 F9 | LDR             X1, [SP,#0x40+eol]; src\n0x0050E154 | C2 8A 00 94 | BL              overlapping_strcpy\n0x0050E158 | 41 01 80 52 | MOV             W1, #0xA; c\n0x0050E15C | E0 1F 40 F9 | LDR             X0, [SP,#0x40+eol]; s\n0x0050E160 | 44 E5 FB 97 | BL              .strchr\n0x0050E164 | E0 1F 00 F9 | STR             X0, [SP,#0x40+eol]\n0x0050E168 | DF FF FF 17 | B               next\n0x0050E16C | E0 1F 40 F9 | LDR             X0, [SP,#0x40+eol]\n0x0050E170 | 1F 00 00 39 | STRB            WZR, [X0]\n0x0050E174 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+cmdstr]; cmdstr\n0x0050E178 | 68 F9 FF 97 | BL              add_cmd\n0x0050E17C | E0 1F 40 F9 | LDR             X0, [SP,#0x40+eol]\n0x0050E180 | 00 04 00 91 | ADD             X0, X0, #1\n0x0050E184 | E0 0F 00 F9 | STR             X0, [SP,#0x40+cmdstr]\n0x0050E188 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+eol]\n0x0050E18C | 1F 00 00 F1 | CMP             X0, #0\n0x0050E190 | 21 FA FF 54 | B.NE            loc_50E0D4\n0x0050E194 | E0 13 40 F9 | LDR             X0, [SP,#0x40+sv]; ptr\n0x0050E198 | D2 E4 FB 97 | BL              .free\n0x0050E19C | 1F 20 03 D5 | NOP\n0x0050E1A0 | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x0050E1A4 | C0 03 5F D6 | RET",
        "output": "```c\nvoid process_command(char *cmdstr) {\n    char *sv = xstrdup(cmdstr);\n    char *eol = strchr(cmdstr, '\\n');\n    if (eol) {\n        int slashes = 0;\n        char *sl = eol;\n        do {\n            sl--;\n            if (*sl == '\\\\') {\n                slashes++;\n            }\n        } while (sl != cmdstr && *sl == '\\\\');\n\n        if (slashes % 2) {\n            eol--;\n            overlapping_strcpy(eol, eol + 1);\n            eol = strchr(eol, '\\n');\n        } else {\n            *eol = '\\0';\n        }\n        add_cmd(cmdstr);\n        cmdstr = eol + 1;\n        while (*cmdstr) {\n            eol = strchr(cmdstr, '\\n');\n            if (!eol) break;\n            if ((eol - cmdstr) % 2) {\n                eol--;\n                overlapping_strcpy(eol, eol + 1);\n                eol = strchr(eol, '\\n');\n            } else {\n                *eol = '\\0';\n            }\n            add_cmd(cmdstr);\n            cmdstr = eol + 1;\n        }\n    }\n    free(sv);\n}\n```"
    },
    {
        "func_name": "getopt_mk_fifo_nod",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F98CC | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004F98D0 | FD 03 00 91 | MOV             X29, SP\n0x004F98D4 | E0 0F 00 F9 | STR             X0, [SP,#0x30+argv]\n0x004F98D8 | C0 36 80 52 | MOV             W0, #0x1B6\n0x004F98DC | E0 2B 00 B9 | STR             W0, [SP,#0x30+mode]\n0x004F98E0 | FF 13 00 F9 | STR             XZR, [SP,#0x30+smode]\n0x004F98E4 | E0 83 00 91 | ADD             X0, SP, #0x30+smode\n0x004F98E8 | E2 03 00 AA | MOV             X2, X0\n0x004F98EC | 00 03 00 D0 | ADRP            X0, #aM_3@PAGE; \"m:\"\n0x004F98F0 | 01 60 37 91 | ADD             X1, X0, #aM_3@PAGEOFF; \"m:\"\n0x004F98F4 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+argv]; argv\n0x004F98F8 | F9 9A 00 94 | BL              getopt32\n0x004F98FC | E0 2F 00 B9 | STR             W0, [SP,#0x30+opt]\n0x004F9900 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+opt]\n0x004F9904 | 00 00 00 12 | AND             W0, W0, #1\n0x004F9908 | 1F 00 00 71 | CMP             W0, #0\n0x004F990C | 00 01 00 54 | B.EQ            loc_4F992C\n0x004F9910 | E0 13 40 F9 | LDR             X0, [SP,#0x30+smode]; s\n0x004F9914 | E1 A3 00 91 | ADD             X1, SP, #0x30+mode; current_mode\n0x004F9918 | DD C3 00 94 | BL              bb_parse_mode\n0x004F991C | 1F 00 00 71 | CMP             W0, #0\n0x004F9920 | 60 00 00 54 | B.EQ            loc_4F992C\n0x004F9924 | 00 00 80 52 | MOV             W0, #0; mask\n0x004F9928 | 9E 38 FC 97 | BL              .umask\n0x004F992C | E0 2B 40 B9 | LDR             W0, [SP,#0x30+mode]\n0x004F9930 | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004F9934 | C0 03 5F D6 | RET",
        "output": "```c\n#include <stdint.h>\n\nint main(int argc, char **argv) {\n    uint32_t mode = 0x1B6;\n    uint64_t smode = 0;\n    uint32_t opt;\n\n    opt = getopt32(argc, argv, \"m:\");\n    if (opt & 1) {\n        if (bb_parse_mode(smode, &mode) == 0) {\n            umask(0);\n        }\n    }\n\n    return mode;\n}\n```"
    },
    {
        "func_name": "llist_unlink",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040952C | FF 43 00 D1 | SUB             SP, SP, #0x10\n0x00409530 | E0 07 00 F9 | STR             X0, [SP,#0x10+head]\n0x00409534 | E1 03 00 F9 | STR             X1, [SP,#0x10+elm]\n0x00409538 | E0 03 40 F9 | LDR             X0, [SP,#0x10+elm]\n0x0040953C | 1F 00 00 F1 | CMP             X0, #0\n0x00409540 | A0 02 00 54 | B.EQ            loc_409594\n0x00409544 | 0F 00 00 14 | B               loc_409580\n0x00409548 | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x0040954C | 00 00 40 F9 | LDR             X0, [X0]\n0x00409550 | E1 03 40 F9 | LDR             X1, [SP,#0x10+elm]\n0x00409554 | 3F 00 00 EB | CMP             X1, X0\n0x00409558 | E1 00 00 54 | B.NE            loc_409574\n0x0040955C | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x00409560 | 00 00 40 F9 | LDR             X0, [X0]\n0x00409564 | 01 00 40 F9 | LDR             X1, [X0]\n0x00409568 | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x0040956C | 01 00 00 F9 | STR             X1, [X0]\n0x00409570 | 0A 00 00 14 | B               loc_409598\n0x00409574 | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x00409578 | 00 00 40 F9 | LDR             X0, [X0]\n0x0040957C | E0 07 00 F9 | STR             X0, [SP,#0x10+head]\n0x00409580 | E0 07 40 F9 | LDR             X0, [SP,#0x10+head]\n0x00409584 | 00 00 40 F9 | LDR             X0, [X0]\n0x00409588 | 1F 00 00 F1 | CMP             X0, #0\n0x0040958C | E1 FD FF 54 | B.NE            loc_409548\n0x00409590 | 02 00 00 14 | B               loc_409598\n0x00409594 | 1F 20 03 D5 | NOP\n0x00409598 | FF 43 00 91 | ADD             SP, SP, #0x10\n0x0040959C | C0 03 5F D6 | RET",
        "output": "```c\nvoid func(void **head, void *elm) {\n    if (elm == NULL) {\n        return;\n    }\n\n    while (*head) {\n        if (*head == elm) {\n            *head = **(void ***)head;\n            return;\n        }\n        head = *head;\n    }\n}\n```"
    },
    {
        "func_name": "waitforjob",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00482B7C | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x00482B80 | FD 03 00 91 | MOV             X29, SP\n0x00482B84 | E0 0F 00 F9 | STR             X0, [SP,#0x30+jp]\n0x00482B88 | 80 08 00 F0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00482B90 | 00 00 40 F9 | LDR             X0, [X0]\n0x00482B94 | 01 30 40 B9 | LDR             W1, [X0,#0x30]\n0x00482B98 | 21 04 00 11 | ADD             W1, W1, #1\n0x00482B9C | 01 30 00 B9 | STR             W1, [X0,#0x30]\n0x00482BA0 | 04 00 00 14 | B               loc_482BB0\n0x00482BA4 | E1 0F 40 F9 | LDR             X1, [SP,#0x30+jp]; job\n0x00482BA8 | 00 00 80 52 | MOV             W0, #0; wait_flags\n0x00482BAC | C6 F8 FF 97 | BL              dowait\n0x00482BB0 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+jp]\n0x00482BB4 | 00 78 40 39 | LDRB            W0, [X0,#0x1E]\n0x00482BB8 | 1F 00 00 71 | CMP             W0, #0\n0x00482BBC | 40 FF FF 54 | B.EQ            loc_482BA4\n0x00482BC0 | 62 E7 FF 97 | BL              int_on\n0x00482BC4 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+jp]; job\n0x00482BC8 | A7 FA FF 97 | BL              getstatus\n0x00482BCC | E0 2F 00 B9 | STR             W0, [SP,#0x30+st]\n0x00482BD0 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+jp]\n0x00482BD4 | 00 7C 40 39 | LDRB            W0, [X0,#0x1F]\n0x00482BD8 | 00 00 1F 12 | AND             W0, W0, #2\n0x00482BDC | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x00482BE0 | 1F 00 00 71 | CMP             W0, #0\n0x00482BE4 | 60 02 00 54 | B.EQ            loc_482C30\n0x00482BE8 | 80 08 00 90 00 60 2F 91 | ADRL            X0, ttyfd\n0x00482BF0 | 02 00 40 B9 | LDR             W2, [X0]\n0x00482BF4 | 80 08 00 F0 00 C0 0F 91 | ADRL            X0, ash_ptr_to_globals_misc\n0x00482BFC | 00 00 40 F9 | LDR             X0, [X0]\n0x00482C00 | 00 00 40 B9 | LDR             W0, [X0]\n0x00482C04 | E1 03 00 2A | MOV             W1, W0; pgrp\n0x00482C08 | E0 03 02 2A | MOV             W0, W2; fd\n0x00482C0C | 85 F6 FF 97 | BL              xtcsetpgrp\n0x00482C10 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+jp]\n0x00482C14 | 00 7C 40 39 | LDRB            W0, [X0,#0x1F]\n0x00482C18 | 00 00 00 12 | AND             W0, W0, #1\n0x00482C1C | 00 1C 00 12 | AND             W0, W0, #0xFF\n0x00482C20 | 1F 00 00 71 | CMP             W0, #0\n0x00482C24 | 60 00 00 54 | B.EQ            loc_482C30\n0x00482C28 | 40 00 80 52 | MOV             W0, #2; sig\n0x00482C2C | E1 0E FE 97 | BL              .raise\n0x00482C30 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+jp]\n0x00482C34 | 00 78 40 39 | LDRB            W0, [X0,#0x1E]\n0x00482C38 | 1F 08 00 71 | CMP             W0, #2\n0x00482C3C | 61 00 00 54 | B.NE            loc_482C48\n0x00482C40 | E0 0F 40 F9 | LDR             X0, [SP,#0x30+jp]; jp\n0x00482C44 | 40 F6 FF 97 | BL              freejob\n0x00482C48 | E0 2F 40 B9 | LDR             W0, [SP,#0x30+st]\n0x00482C4C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x00482C50 | C0 03 5F D6 | RET",
        "output": "```c\nvoid function() {\n    int wait_flags = 0;\n    int sig;\n    struct job *job;\n    int st;\n    int pgrp;\n    int fd;\n    int ttyfd;\n\n    job = ash_ptr_to_globals_misc->jp;\n    ash_ptr_to_globals_misc->counter += 1;\n\n    do {\n        dowait(0, job);\n        if (job->field_1E == 0) {\n            int_on();\n            st = getstatus(job);\n            if ((job->field_1F & 2) != 0) {\n                fd = ttyfd;\n                pgrp = ash_ptr_to_globals_misc->field_0;\n                xtcsetpgrp(fd, pgrp);\n            }\n            if ((job->field_1F & 1) != 0) {\n                sig = 2; // SIGINT\n                raise(sig);\n            }\n        }\n    } while (job->field_1E == 2);\n\n    if (job->field_1E == 2) {\n        freejob(job);\n    }\n\n    return st;\n}\n```"
    },
    {
        "func_name": "display_window_size",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F3478 | FD 7B BD A9 | STP             X29, X30, [SP,#var_30]!\n0x004F347C | FD 03 00 91 | MOV             X29, SP\n0x004F3480 | E0 1F 00 B9 | STR             W0, [SP,#0x30+fancy]\n0x004F3484 | 40 03 00 90 00 20 16 91 | ADRL            X0, aS_80; \"%s\"\n0x004F348C | E0 17 00 F9 | STR             X0, [SP,#0x30+fmt_str]\n0x004F3490 | E1 83 00 91 | ADD             X1, SP, #0x30+height\n0x004F3494 | E0 93 00 91 | ADD             X0, SP, #0x30+width\n0x004F3498 | E2 03 01 AA | MOV             X2, X1; height\n0x004F349C | E1 03 00 AA | MOV             X1, X0; width\n0x004F34A0 | 00 00 80 52 | MOV             W0, #0; fd\n0x004F34A4 | 75 5C FC 97 | BL              get_terminal_width_height\n0x004F34A8 | 1F 00 00 71 | CMP             W0, #0\n0x004F34AC | 00 02 00 54 | B.EQ            loc_4F34EC\n0x004F34B0 | 00 05 00 D0 00 60 0A 91 | ADRL            X0, bb_errno\n0x004F34B8 | 00 00 40 F9 | LDR             X0, [X0]\n0x004F34BC | 00 00 40 B9 | LDR             W0, [X0]\n0x004F34C0 | 1F 58 00 71 | CMP             W0, #0x16\n0x004F34C4 | E1 00 00 54 | B.NE            loc_4F34E0\n0x004F34C8 | E0 17 40 F9 | LDR             X0, [SP,#0x30+fmt_str]\n0x004F34CC | 00 08 00 91 | ADD             X0, X0, #2\n0x004F34D0 | E0 17 00 F9 | STR             X0, [SP,#0x30+fmt_str]\n0x004F34D4 | E0 1F 40 B9 | LDR             W0, [SP,#0x30+fancy]\n0x004F34D8 | 1F 00 00 71 | CMP             W0, #0\n0x004F34DC | E1 01 00 54 | B.NE            loc_4F3518\n0x004F34E0 | E0 17 40 F9 | LDR             X0, [SP,#0x30+fmt_str]; fmt\n0x004F34E4 | 2F FF FF 97 | BL              perror_on_device\n0x004F34E8 | 0C 00 00 14 | B               loc_4F3518\n0x004F34EC | E0 1F 40 B9 | LDR             W0, [SP,#0x30+fancy]\n0x004F34F0 | 1F 00 00 71 | CMP             W0, #0\n0x004F34F4 | 80 00 00 54 | B.EQ            loc_4F3504\n0x004F34F8 | 40 03 00 90 00 E0 16 91 | ADRL            X0, aRowsUColumnsU; \"rows %u; columns %u;\"\n0x004F3500 | 03 00 00 14 | B               loc_4F350C\n0x004F3504 | 40 03 00 90 00 40 17 91 | ADRL            X0, aUU_2; \"%u %u\\n\"\n0x004F350C | E1 23 40 B9 | LDR             W1, [SP,#0x30+height]\n0x004F3510 | E2 27 40 B9 | LDR             W2, [SP,#0x30+width]\n0x004F3514 | 2F FF FF 97 | BL              wrapf\n0x004F3518 | 1F 20 03 D5 | NOP\n0x004F351C | FD 7B C3 A8 | LDP             X29, X30, [SP+0x30+var_30],#0x30\n0x004F3520 | C0 03 5F D6 | RET",
        "output": "```c\n#include <stdio.h>\n#include <errno.h>\n\nextern void get_terminal_width_height(int *width, int *height);\nextern void perror_on_device(const char *fmt);\nextern void wrapf(const char *fmt, unsigned int height, unsigned int width);\n\nvoid function(int fancy) {\n    int width, height;\n    const char *fmt_str = \"%s\";\n    if (get_terminal_width_height(&width, &height) == 0) {\n        if (errno == 22) { // EINVAL\n            fmt_str += 2;\n            if (fancy == 0) {\n                perror_on_device(fmt_str);\n                return;\n            }\n        }\n    } else {\n        if (fancy == 0) {\n            fmt_str = \"%u %u\\n\";\n        } else {\n            fmt_str = \"rows %u; columns %u;\";\n        }\n        wrapf(fmt_str, height, width);\n    }\n}\n```"
    },
    {
        "func_name": "filter_datapoints",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00443114 | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x00443118 | FD 03 00 91 | MOV             X29, SP\n0x0044311C | E0 0F 00 F9 | STR             X0, [SP,#0x40+p]\n0x00443120 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+p]\n0x00443124 | 00 A0 01 91 | ADD             X0, X0, #0x68 ; 'h'\n0x00443128 | E0 13 00 F9 | STR             X0, [SP,#0x40+fdp]\n0x0044312C | E0 0F 40 F9 | LDR             X0, [SP,#0x40+p]\n0x00443130 | 00 14 40 B9 | LDR             W0, [X0,#0x14]\n0x00443134 | E0 3B 00 B9 | STR             W0, [SP,#0x40+idx]\n0x00443138 | E1 3B 80 B9 | LDRSW           X1, [SP,#0x40+idx]\n0x0044313C | E0 03 01 AA | MOV             X0, X1\n0x00443140 | 00 F8 7F D3 | LSL             X0, X0, #1\n0x00443144 | 00 00 01 8B | ADD             X0, X0, X1\n0x00443148 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x0044314C | E1 03 00 AA | MOV             X1, X0\n0x00443150 | E0 13 40 F9 | LDR             X0, [SP,#0x40+fdp]\n0x00443154 | 00 00 01 8B | ADD             X0, X0, X1\n0x00443158 | 01 00 40 F9 | LDR             X1, [X0]\n0x0044315C | E0 0F 40 F9 | LDR             X0, [SP,#0x40+p]\n0x00443160 | 01 28 00 F9 | STR             X1, [X0,#0x50]\n0x00443164 | FF 17 00 F9 | STR             XZR, [SP,#0x40+wavg]\n0x00443168 | FF 1B 00 F9 | STR             XZR, [SP,#0x40+sum]\n0x0044316C | FF 3F 00 B9 | STR             WZR, [SP,#0x40+i]\n0x00443170 | 26 00 00 14 | B               loc_443208\n0x00443174 | E1 3B 80 B9 | LDRSW           X1, [SP,#0x40+idx]\n0x00443178 | E0 03 01 AA | MOV             X0, X1\n0x0044317C | 00 F8 7F D3 | LSL             X0, X0, #1\n0x00443180 | 00 00 01 8B | ADD             X0, X0, X1\n0x00443184 | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00443188 | E1 03 00 AA | MOV             X1, X0\n0x0044318C | E0 13 40 F9 | LDR             X0, [SP,#0x40+fdp]\n0x00443190 | 00 00 01 8B | ADD             X0, X0, X1; dp\n0x00443194 | 9B FF FF 97 | BL              dispersion\n0x00443198 | 01 40 60 1E | FMOV            D1, D0\n0x0044319C | E0 3F 40 B9 | LDR             W0, [SP,#0x40+i]\n0x004431A0 | 41 00 80 52 | MOV             W1, #2\n0x004431A4 | 20 20 C0 1A | LSL             W0, W1, W0\n0x004431A8 | 00 00 62 1E | SCVTF           D0, W0\n0x004431AC | 20 18 60 1E | FDIV            D0, D1, D0\n0x004431B0 | E1 1B 40 FD | LDR             D1, [SP,#0x40+sum]\n0x004431B4 | 20 28 60 1E | FADD            D0, D1, D0\n0x004431B8 | E0 1B 00 FD | STR             D0, [SP,#0x40+sum]\n0x004431BC | E1 3B 80 B9 | LDRSW           X1, [SP,#0x40+idx]\n0x004431C0 | E0 03 01 AA | MOV             X0, X1\n0x004431C4 | 00 F8 7F D3 | LSL             X0, X0, #1\n0x004431C8 | 00 00 01 8B | ADD             X0, X0, X1\n0x004431CC | 00 F0 7D D3 | LSL             X0, X0, #3\n0x004431D0 | E1 03 00 AA | MOV             X1, X0\n0x004431D4 | E0 13 40 F9 | LDR             X0, [SP,#0x40+fdp]\n0x004431D8 | 00 00 01 8B | ADD             X0, X0, X1\n0x004431DC | 00 00 40 FD | LDR             D0, [X0]\n0x004431E0 | E1 17 40 FD | LDR             D1, [SP,#0x40+wavg]\n0x004431E4 | 20 28 60 1E | FADD            D0, D1, D0\n0x004431E8 | E0 17 00 FD | STR             D0, [SP,#0x40+wavg]\n0x004431EC | E0 3B 40 B9 | LDR             W0, [SP,#0x40+idx]\n0x004431F0 | 00 04 00 51 | SUB             W0, W0, #1\n0x004431F4 | 00 08 00 12 | AND             W0, W0, #7\n0x004431F8 | E0 3B 00 B9 | STR             W0, [SP,#0x40+idx]\n0x004431FC | E0 3F 40 B9 | LDR             W0, [SP,#0x40+i]\n0x00443200 | 00 04 00 11 | ADD             W0, W0, #1\n0x00443204 | E0 3F 00 B9 | STR             W0, [SP,#0x40+i]\n0x00443208 | E0 3F 40 B9 | LDR             W0, [SP,#0x40+i]\n0x0044320C | 1F 1C 00 71 | CMP             W0, #7\n0x00443210 | 2D FB FF 54 | B.LE            loc_443174\n0x00443214 | 00 10 64 1E | FMOV            D0, #8.0\n0x00443218 | E1 17 40 FD | LDR             D1, [SP,#0x40+wavg]\n0x0044321C | 20 18 60 1E | FDIV            D0, D1, D0\n0x00443220 | E0 17 00 FD | STR             D0, [SP,#0x40+wavg]\n0x00443224 | E0 0F 40 F9 | LDR             X0, [SP,#0x40+p]\n0x00443228 | E1 1B 40 F9 | LDR             X1, [SP,#0x40+sum]\n0x0044322C | 01 2C 00 F9 | STR             X1, [X0,#0x58]\n0x00443230 | FF 1B 00 F9 | STR             XZR, [SP,#0x40+sum]\n0x00443234 | FF 3F 00 B9 | STR             WZR, [SP,#0x40+i]\n0x00443238 | 14 00 00 14 | B               loc_443288\n0x0044323C | E1 3F 80 B9 | LDRSW           X1, [SP,#0x40+i]\n0x00443240 | E0 03 01 AA | MOV             X0, X1\n0x00443244 | 00 F8 7F D3 | LSL             X0, X0, #1\n0x00443248 | 00 00 01 8B | ADD             X0, X0, X1\n0x0044324C | 00 F0 7D D3 | LSL             X0, X0, #3\n0x00443250 | E1 03 00 AA | MOV             X1, X0\n0x00443254 | E0 13 40 F9 | LDR             X0, [SP,#0x40+fdp]\n0x00443258 | 00 00 01 8B | ADD             X0, X0, X1\n0x0044325C | 00 00 40 FD | LDR             D0, [X0]\n0x00443260 | E1 17 40 FD | LDR             D1, [SP,#0x40+wavg]\n0x00443264 | 20 38 60 1E | FSUB            D0, D1, D0; x\n0x00443268 | 93 FE FF 97 | BL              SQUARE\n0x0044326C | 01 40 60 1E | FMOV            D1, D0\n0x00443270 | E0 1B 40 FD | LDR             D0, [SP,#0x40+sum]\n0x00443274 | 00 28 61 1E | FADD            D0, D0, D1\n0x00443278 | E0 1B 00 FD | STR             D0, [SP,#0x40+sum]\n0x0044327C | E0 3F 40 B9 | LDR             W0, [SP,#0x40+i]\n0x00443280 | 00 04 00 11 | ADD             W0, W0, #1\n0x00443284 | E0 3F 00 B9 | STR             W0, [SP,#0x40+i]\n0x00443288 | E0 3F 40 B9 | LDR             W0, [SP,#0x40+i]\n0x0044328C | 1F 1C 00 71 | CMP             W0, #7\n0x00443290 | 6D FD FF 54 | B.LE            loc_44323C\n0x00443294 | 00 10 64 1E | FMOV            D0, #8.0\n0x00443298 | E1 1B 40 FD | LDR             D1, [SP,#0x40+sum]\n0x0044329C | 20 18 60 1E | FDIV            D0, D1, D0; X\n0x004432A0 | BA FE FF 97 | BL              SQRT\n0x004432A4 | E0 1B 00 FD | STR             D0, [SP,#0x40+sum]\n0x004432A8 | E0 1B 40 FD | LDR             D0, [SP,#0x40+sum]\n0x004432AC | 20 08 00 B0 | ADRP            X0, #qword_5486E8@PAGE\n0x004432B0 | 01 74 43 FD | LDR             D1, [X0,#qword_5486E8@PAGEOFF]\n0x004432B4 | 10 20 61 1E | FCMPE           D0, D1\n0x004432B8 | 6D 00 00 54 | B.LE            loc_4432C4\n0x004432BC | E0 1B 40 F9 | LDR             X0, [SP,#0x40+sum]\n0x004432C0 | 03 00 00 14 | B               loc_4432CC\n0x004432C4 | 20 08 00 B0 | ADRP            X0, #qword_5486E8@PAGE\n0x004432C8 | 00 74 43 F9 | LDR             X0, [X0,#qword_5486E8@PAGEOFF]\n0x004432CC | E1 0F 40 F9 | LDR             X1, [SP,#0x40+p]\n0x004432D0 | 20 30 00 F9 | STR             X0, [X1,#0x60]\n0x004432D4 | 1F 20 03 D5 | NOP\n0x004432D8 | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x004432DC | C0 03 5F D6 | RET",
        "output": "```c\ndouble dispersion(int *p) {\n    // Function prototype assumed based on usage\n}\n\ndouble SQUARE(double x) {\n    // Function prototype assumed based on usage\n}\n\ndouble SQRT(double X) {\n    // Function prototype assumed based on usage\n}\n\nvoid function(int *p) {\n    int idx = *(p + 5);\n    int i = 0;\n    double sum = 0.0;\n    double wavg = 0.0;\n    do {\n        int dp = ((idx << 1) + idx) << 3;\n        dispersion(p + dp);\n        double x = (double)(2 << i);\n        sum += *(double *)(p + 14) / x;\n        wavg += *(double *)(p + dp);\n        idx = (idx - 1) & 7;\n        i++;\n    } while (i <= 7);\n\n    wavg /= 8.0;\n    *(p + 11) = sum;\n    sum = 0.0;\n    i = 0;\n\n    do {\n        int dp = ((idx << 1) + idx) << 3;\n        double x = wavg - *(double *)(p + dp);\n        sum += SQUARE(x);\n        i++;\n    } while (i <= 7);\n\n    sum /= 8.0;\n    sum = SQRT(sum);\n\n    double threshold = *(double *)0x5486E8; // Address assumed based on usage\n    if (sum <= threshold) {\n        *(p + 12) = *(int *)0x5486E8;\n    } else {\n        *(p + 12) = sum;\n    }\n}\n```"
    },
    {
        "func_name": "print_bytes_scaled",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the AArch64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043EEAC | FD 7B BC A9 | STP             X29, X30, [SP,#var_40]!\n0x0043EEB0 | FD 03 00 91 | MOV             X29, SP\n0x0043EEB4 | E0 0F 00 F9 | STR             X0, [SP,#0x40+ull]\n0x0043EEB8 | E1 0B 00 F9 | STR             X1, [SP,#0x40+end]\n0x0043EEBC | FF 2F 00 B9 | STR             WZR, [SP,#0x40+frac_part]\n0x0043EEC0 | 40 08 00 B0 00 A0 1D 91 | ADRL            X0, TRext\n0x0043EEC8 | E0 1B 00 F9 | STR             X0, [SP,#0x40+ext]\n0x0043EECC | E0 0F 40 F9 | LDR             X0, [SP,#0x40+ull]\n0x0043EED0 | E0 1F 00 F9 | STR             X0, [SP,#0x40+int_part]\n0x0043EED4 | 80 00 80 52 | MOV             W0, #4\n0x0043EED8 | E0 2B 00 B9 | STR             W0, [SP,#0x40+i]\n0x0043EEDC | E0 1F 40 F9 | LDR             X0, [SP,#0x40+int_part]\n0x0043EEE0 | 1F FC 0F F1 | CMP             X0, #0x3FF\n0x0043EEE4 | E9 01 00 54 | B.LS            loc_43EF20\n0x0043EEE8 | E0 1F 40 F9 | LDR             X0, [SP,#0x40+int_part]\n0x0043EEEC | 01 24 00 12 | AND             W1, W0, #0x3FF\n0x0043EEF0 | E0 03 01 2A | MOV             W0, W1\n0x0043EEF4 | 00 74 1E 53 | LSL             W0, W0, #2\n0x0043EEF8 | 00 00 01 0B | ADD             W0, W0, W1\n0x0043EEFC | 00 78 1F 53 | LSL             W0, W0, #1\n0x0043EF00 | 00 7C 0A 53 | LSR             W0, W0, #0xA\n0x0043EF04 | E0 2F 00 B9 | STR             W0, [SP,#0x40+frac_part]\n0x0043EF08 | E1 1F 40 F9 | LDR             X1, [SP,#0x40+int_part]\n0x0043EF0C | 20 FC 4A D3 | LSR             X0, X1, #0xA\n0x0043EF10 | E0 1F 00 F9 | STR             X0, [SP,#0x40+int_part]\n0x0043EF14 | E0 1B 40 F9 | LDR             X0, [SP,#0x40+ext]\n0x0043EF18 | 00 0C 00 91 | ADD             X0, X0, #3\n0x0043EF1C | E0 1B 00 F9 | STR             X0, [SP,#0x40+ext]\n0x0043EF20 | E0 2B 40 B9 | LDR             W0, [SP,#0x40+i]\n0x0043EF24 | 00 04 00 51 | SUB             W0, W0, #1\n0x0043EF28 | E0 2B 00 B9 | STR             W0, [SP,#0x40+i]\n0x0043EF2C | E0 2B 40 B9 | LDR             W0, [SP,#0x40+i]\n0x0043EF30 | 1F 00 00 71 | CMP             W0, #0\n0x0043EF34 | 41 FD FF 54 | B.NE            loc_43EEDC\n0x0043EF38 | E5 0B 40 F9 | LDR             X5, [SP,#0x40+end]\n0x0043EF3C | E4 1B 40 F9 | LDR             X4, [SP,#0x40+ext]\n0x0043EF40 | E3 2F 40 B9 | LDR             W3, [SP,#0x40+frac_part]\n0x0043EF44 | E2 1F 40 F9 | LDR             X2, [SP,#0x40+int_part]\n0x0043EF48 | E1 0F 40 F9 | LDR             X1, [SP,#0x40+ull]\n0x0043EF4C | 40 08 00 B0 00 E0 1D 91 | ADRL            X0, aXBytesLluLluUS; \"X bytes:%llu (%llu.%u %sB)%s\"\n0x0043EF54 | 1F 23 FF 97 | BL              .printf\n0x0043EF58 | 1F 20 03 D5 | NOP\n0x0043EF5C | FD 7B C4 A8 | LDP             X29, X30, [SP+0x40+var_40],#0x40\n0x0043EF60 | C0 03 5F D6 | RET",
        "output": "```c\n#include <stdint.h>\n\nvoid function(uint64_t ull, const char *end) {\n    uint64_t int_part = ull;\n    uint32_t frac_part = 0;\n    const char *ext = \"TRext\";\n    int i = 4;\n\n    do {\n        if (int_part <= 0x3FF) {\n            break;\n        }\n\n        uint32_t temp = (int_part & 0x3FF) << 2;\n        temp = (temp + (temp >> 10)) << 1;\n        frac_part = temp >> 10;\n\n        int_part >>= 10;\n        ext += 3;\n        i--;\n    } while (i != 0);\n\n    printf(\"X bytes:%llu (%llu.%u %sB)%s\", ull, int_part, frac_part, ext, end);\n}\n```"
    }
]
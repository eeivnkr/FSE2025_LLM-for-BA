[
    {
        "func_name": "ip_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0042BA15 | 53 | push    rbx\n0x0042BA16 | 48 8D 7E 08 | lea     rdi, [rsi+8]\n0x0042BA1A | E8 88 CC 00 00 | call    sub_4386A7\n0x0042BA1F | 48 89 C3 | mov     rbx, rax\n0x0042BA22 | 48 8B 30 | mov     rsi, [rax]; s2\n0x0042BA25 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x0042BA2A | 48 85 F6 | test    rsi, rsi\n0x0042BA2D | 74 0E | jz      short loc_42BA3D\n0x0042BA2F | 48 83 C3 08 | add     rbx, 8\n0x0042BA33 | BF 60 B7 4C 00 | mov     edi, offset aAddress; \"address\"\n0x0042BA38 | E8 27 65 08 00 | call    sub_4B1F64\n0x0042BA3D | 83 C0 01 | add     eax, 1\n0x0042BA40 | 48 98 | cdqe\n0x0042BA42 | 48 89 DF | mov     rdi, rbx\n0x0042BA45 | FF 14 C5 20 B7 4C 00 | call    ds:funcs_42BA45[rax*8]",
        "output": "```c\nvoid function(void* rsi) {\n    // push rbx\n    // lea rdi, [rsi+8]\n    void* rbx = sub_4386A7(rsi + 8);\n    // mov rbx, rax\n    void* s2 = rbx;\n    // mov eax, 0xFFFFFFFF\n    int eax = 0xFFFFFFFF;\n    // test rsi, rsi\n    if (s2 != NULL) {\n        // add rbx, 8\n        rbx += 8;\n        // mov edi, offset aAddress; \"address\"\n        sub_4B1F64(\"address\");\n    }\n    // add eax, 1\n    eax += 1;\n    // cdqe\n    // mov rdi, rbx\n    void* rdi = rbx;\n    // call ds:funcs_42BA45[rax*8]\n    funcs_42BA45[eax*8](rdi);\n}\n```"
    },
    {
        "func_name": "rc_is_bit_1",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0048817B | 55 | push    rbp\n0x0048817C | 53 | push    rbx\n0x0048817D | 48 83 EC 08 | sub     rsp, 8\n0x00488181 | 48 89 FB | mov     rbx, rdi\n0x00488184 | 48 89 F5 | mov     rbp, rsi\n0x00488187 | 81 7F 1C FF FF FF 00 | cmp     dword ptr [rdi+1Ch], 0FFFFFFh\n0x0048818E | 76 3F | jbe     short loc_4881CF\n0x00488190 | 8B 4B 1C | mov     ecx, [rbx+1Ch]\n0x00488193 | 0F B7 45 00 | movzx   eax, word ptr [rbp+0]\n0x00488197 | 89 CA | mov     edx, ecx\n0x00488199 | C1 EA 0B | shr     edx, 0Bh\n0x0048819C | 0F AF C2 | imul    eax, edx\n0x0048819F | 89 43 20 | mov     [rbx+20h], eax\n0x004881A2 | 8B 53 18 | mov     edx, [rbx+18h]\n0x004881A5 | 39 D0 | cmp     eax, edx\n0x004881A7 | 77 2D | ja      short loc_4881D6\n0x004881A9 | 29 C1 | sub     ecx, eax\n0x004881AB | 89 4B 1C | mov     [rbx+1Ch], ecx\n0x004881AE | 29 C2 | sub     edx, eax\n0x004881B0 | 89 53 18 | mov     [rbx+18h], edx\n0x004881B3 | 0F B7 45 00 | movzx   eax, word ptr [rbp+0]\n0x004881B7 | 89 C2 | mov     edx, eax\n0x004881B9 | 66 C1 EA 05 | shr     dx, 5\n0x004881BD | 29 D0 | sub     eax, edx\n0x004881BF | 66 89 45 00 | mov     [rbp+0], ax\n0x004881C3 | B8 01 00 00 00 | mov     eax, 1\n0x004881C8 | 48 83 C4 08 | add     rsp, 8\n0x004881CC | 5B | pop     rbx\n0x004881CD | 5D | pop     rbp\n0x004881CE | C3 | retn\n0x004881CF | E8 38 FF FF FF | call    sub_48810C\n0x004881D4 | EB BA | jmp     short loc_488190\n0x004881D6 | 89 43 1C | mov     [rbx+1Ch], eax\n0x004881D9 | 0F B7 55 00 | movzx   edx, word ptr [rbp+0]\n0x004881DD | 0F B7 CA | movzx   ecx, dx\n0x004881E0 | B8 00 08 00 00 | mov     eax, 800h\n0x004881E5 | 29 C8 | sub     eax, ecx\n0x004881E7 | C1 F8 05 | sar     eax, 5\n0x004881EA | 01 D0 | add     eax, edx\n0x004881EC | 66 89 45 00 | mov     [rbp+0], ax\n0x004881F0 | B8 00 00 00 00 | mov     eax, 0\n0x004881F5 | EB D1 | jmp     short loc_4881C8",
        "output": "```c\nvoid function(int* rbx, int* rbp) {\n    if (*(rbx + 0x1C) <= 0xFFFFFF) {\n        int ecx = *(rbx + 0x1C);\n        int eax = *(rbp + 0) & 0xFFFF;\n        int edx = ecx >> 0xB;\n        eax *= edx;\n        *(rbx + 0x20) = eax;\n        edx = *(rbx + 0x18);\n        if (eax <= edx) {\n            ecx -= eax;\n            *(rbx + 0x1C) = ecx;\n            edx -= eax;\n            *(rbx + 0x18) = edx;\n            eax = *(rbp + 0) & 0xFFFF;\n            edx = eax;\n            edx >>= 5;\n            eax -= edx;\n            *(rbp + 0) = eax;\n            return;\n        }\n    }\n    sub_48810C();\n    return;\n}\n```"
    },
    {
        "func_name": "launch_helper",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040F040 | 55 | push    rbp\n0x0040F041 | 53 | push    rbx\n0x0040F042 | 48 83 EC 28 | sub     rsp, 28h\n0x0040F046 | 48 89 7C 24 08 | mov     [rsp+38h+argv], rdi\n0x0040F04B | 48 8D 7C 24 10 | lea     rdi, [rsp+38h+fd]\n0x0040F050 | E8 CB A3 FF FF | call    sub_409420\n0x0040F055 | 48 8D 7C 24 18 | lea     rdi, [rsp+38h+var_20]\n0x0040F05A | E8 C1 A3 FF FF | call    sub_409420\n0x0040F05F | BE B5 EF 40 00 | mov     esi, offset sub_40EFB5\n0x0040F064 | BF 00 40 02 00 | mov     edi, 24000h\n0x0040F069 | E8 4E F1 0A 00 | call    sub_4BE1BC\n0x0040F06E | E8 8D 83 FF FF | call    _vfork\n0x0040F073 | 85 C0 | test    eax, eax\n0x0040F075 | 78 71 | js      short loc_40F0E8\n0x0040F077 | 48 8B 2D EA E2 2F 00 | mov     rbp, cs:qword_70D368\n0x0040F07E | 89 45 00 | mov     [rbp+0], eax\n0x0040F081 | 0F 94 C3 | setz    bl\n0x0040F084 | 0F B6 DB | movzx   ebx, bl\n0x0040F087 | 01 DB | add     ebx, ebx\n0x0040F089 | 8D 43 01 | lea     eax, [rbx+1]\n0x0040F08C | 48 98 | cdqe\n0x0040F08E | 8B 7C 84 10 | mov     edi, [rsp+rax*4+38h+fd]; fd\n0x0040F092 | E8 19 79 FF FF | call    _close\n0x0040F097 | B8 02 00 00 00 | mov     eax, 2\n0x0040F09C | 29 D8 | sub     eax, ebx\n0x0040F09E | 48 98 | cdqe\n0x0040F0A0 | 8B 7C 84 10 | mov     edi, [rsp+rax*4+38h+fd]; fd\n0x0040F0A4 | E8 07 79 FF FF | call    _close\n0x0040F0A9 | 48 63 C3 | movsxd  rax, ebx\n0x0040F0AC | 8B 7C 84 10 | mov     edi, [rsp+rax*4+38h+fd]; fd\n0x0040F0B0 | BE 00 00 00 00 | mov     esi, 0\n0x0040F0B5 | E8 A4 A3 FF FF | call    sub_40945E\n0x0040F0BA | B8 03 00 00 00 | mov     eax, 3\n0x0040F0BF | 29 D8 | sub     eax, ebx\n0x0040F0C1 | 48 98 | cdqe\n0x0040F0C3 | 8B 7C 84 10 | mov     edi, [rsp+rax*4+38h+fd]; fd\n0x0040F0C7 | BE 01 00 00 00 | mov     esi, 1\n0x0040F0CC | E8 8D A3 FF FF | call    sub_40945E\n0x0040F0D1 | 83 7D 00 00 | cmp     dword ptr [rbp+0], 0\n0x0040F0D5 | 74 20 | jz      short loc_40F0F7\n0x0040F0D7 | BF 93 EF 40 00 | mov     edi, offset sub_40EF93\n0x0040F0DC | E8 CF 87 FF FF | call    sub_4078B0\n0x0040F0E1 | 48 83 C4 28 | add     rsp, 28h\n0x0040F0E5 | 5B | pop     rbx\n0x0040F0E6 | 5D | pop     rbp\n0x0040F0E7 | C3 | retn\n0x0040F0E8 | BF 00 E5 4D 00 | mov     edi, offset unk_4DE500\n0x0040F0ED | B8 00 00 00 00 | mov     eax, 0\n0x0040F0F2 | E8 BD 96 FF FF | call    sub_4087B4\n0x0040F0F7 | 48 8B 7C 24 08 | mov     rdi, [rsp+38h+argv]; argv\n0x0040F0FC | E8 A9 4E 0A 00 | call    sub_4B3FAA",
        "output": "```c\nvoid function(int* argv) {\n    int fd = open(\"file.txt\", O_RDONLY);\n    int var_20 = open(\"file.txt\", O_RDONLY);\n    int result = vfork();\n    if (result == 0) {\n        close(fd);\n        int ebx = 0;\n        int eax = 2 - ebx;\n        int fd2 = argv[eax];\n        close(fd2);\n        int rax = ebx;\n        int fd3 = argv[rax];\n        sub_40945E(fd3, 0);\n    } else {\n        if (result > 0) {\n            int ebx = 1;\n            int eax = 3 - ebx;\n            int fd4 = argv[eax];\n            sub_40945E(fd4, 1);\n        } else {\n            sub_4078B0();\n        }\n    }\n    return;\n}\n```"
    },
    {
        "func_name": "chpasswd_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040BCD1 | 41 55 | push    r13\n0x0040BCD3 | 41 54 | push    r12\n0x0040BCD5 | 55 | push    rbp\n0x0040BCD6 | 53 | push    rbx\n0x0040BCD7 | 48 83 EC 18 | sub     rsp, 18h\n0x0040BCDB | 48 89 F3 | mov     rbx, rsi\n0x0040BCDE | E8 CD A9 FF FF | call    _getuid\n0x0040BCE3 | 85 C0 | test    eax, eax\n0x0040BCE5 | 75 30 | jnz     short loc_40BD17\n0x0040BCE7 | 48 C7 05 AE 16 30 00 A4 DC 4D 00 | mov     cs:qword_70D3A0, offset aMEEM; \"m--e:e--m\"\n0x0040BCF2 | 48 C7 05 AB 16 30 00 DD DC 4D 00 | mov     cs:qword_70D3A8, offset aEncrypted; \"encrypted\"\n0x0040BCFD | BE 19 20 4E 00 | mov     esi, (offset aParamProblem+0Bh); \"em\"\n0x0040BD02 | 48 89 DF | mov     rdi, rbx; argv\n0x0040BD05 | B8 00 00 00 00 | mov     eax, 0\n0x0040BD0A | E8 09 8D 0A 00 | call    sub_4B4A18\n0x0040BD0F | 41 89 C4 | mov     r12d, eax\n0x0040BD12 | E9 C3 00 00 00 | jmp     loc_40BDDA\n0x0040BD17 | BF D2 D6 4D 00 | mov     edi, offset aPermissionDeni; \"permission denied (are you root?)\"\n0x0040BD1C | B8 00 00 00 00 | mov     eax, 0\n0x0040BD21 | E8 C9 CD FF FF | call    sub_408AEF\n0x0040BD26 | BF AE DC 4D 00 | mov     edi, offset aMissingNewPass; \"missing new password\"\n0x0040BD2B | E8 BF CD FF FF | call    sub_408AEF\n0x0040BD30 | BE 01 00 00 00 | mov     esi, 1\n0x0040BD35 | 48 8D 7C 24 04 | lea     rdi, [rsp+38h+var_34]\n0x0040BD3A | E8 4B 0F 0B 00 | call    sub_4BCC8A\n0x0040BD3F | 41 F6 C4 02 | test    r12b, 2\n0x0040BD43 | 75 1D | jnz     short loc_40BD62\n0x0040BD45 | BA 00 00 00 00 | mov     edx, 0\n0x0040BD4A | 48 8D 74 24 04 | lea     rsi, [rsp+38h+var_34]\n0x0040BD4F | 48 89 EF | mov     rdi, rbp\n0x0040BD52 | E8 05 10 0B 00 | call    sub_4BCD5C\n0x0040BD57 | 48 89 C5 | mov     rbp, rax\n0x0040BD5A | 49 89 C5 | mov     r13, rax\n0x0040BD5D | E9 C1 00 00 00 | jmp     loc_40BE23\n0x0040BD62 | C6 44 24 04 24 | mov     [rsp+38h+var_34], 24h ; '$'\n0x0040BD67 | C6 44 24 05 31 | mov     [rsp+38h+var_33], 31h ; '1'\n0x0040BD6C | C6 44 24 06 24 | mov     [rsp+38h+var_32], 24h ; '$'\n0x0040BD71 | 48 8D 7C 24 07 | lea     rdi, [rsp+38h+var_31]\n0x0040BD76 | BE 04 00 00 00 | mov     esi, 4\n0x0040BD7B | E8 0A 0F 0B 00 | call    sub_4BCC8A\n0x0040BD80 | EB C3 | jmp     short loc_40BD45\n0x0040BD82 | 74 19 | jz      short loc_40BD9D\n0x0040BD84 | C6 05 15 F0 2F 00 03 | mov     cs:byte_70ADA0, 3\n0x0040BD8B | 48 89 DE | mov     rsi, rbx\n0x0040BD8E | BF B8 29 4D 00 | mov     edi, offset aAnErrorOccurre; \"an error occurred updating password for\"...\n0x0040BD93 | B8 00 00 00 00 | mov     eax, 0\n0x0040BD98 | E8 52 CD FF FF | call    sub_408AEF\n0x0040BD9D | B9 00 00 00 00 | mov     ecx, 0\n0x0040BDA2 | 48 89 EA | mov     rdx, rbp\n0x0040BDA5 | 48 89 DE | mov     rsi, rbx\n0x0040BDA8 | BF 01 DB 4D 00 | mov     edi, offset aEtcPasswd; \"/etc/passwd\"\n0x0040BDAD | E8 A2 31 0B 00 | call    sub_4BEF54\n0x0040BDB2 | C6 05 E7 EF 2F 00 03 | mov     cs:byte_70ADA0, 3\n0x0040BDB9 | 85 C0 | test    eax, eax\n0x0040BDBB | 78 CE | js      short loc_40BD8B\n0x0040BDBD | 0F 85 87 00 00 00 | jnz     loc_40BE4A\n0x0040BDC3 | C6 05 D6 EF 2F 00 01 | mov     cs:byte_70ADA0, 1\n0x0040BDCA | 48 89 DF | mov     rdi, rbx; ptr\n0x0040BDCD | E8 7E A4 FF FF | call    _free\n0x0040BDD2 | 4C 89 EF | mov     rdi, r13; ptr\n0x0040BDD5 | E8 76 A4 FF FF | call    _free\n0x0040BDDA | 48 8B 3D 0F F0 2F 00 | mov     rdi, cs:stdin\n0x0040BDE1 | E8 E7 8A 0A 00 | call    sub_4B48CD\n0x0040BDE6 | 48 89 C3 | mov     rbx, rax\n0x0040BDE9 | 48 85 C0 | test    rax, rax\n0x0040BDEC | 74 73 | jz      short loc_40BE61\n0x0040BDEE | BE 3A 00 00 00 | mov     esi, 3Ah ; ':'; c\n0x0040BDF3 | 48 89 DF | mov     rdi, rbx; s\n0x0040BDF6 | E8 65 A9 FF FF | call    _strchr\n0x0040BDFB | 48 85 C0 | test    rax, rax\n0x0040BDFE | 0F 84 22 FF FF FF | jz      loc_40BD26\n0x0040BE04 | 48 8D 68 01 | lea     rbp, [rax+1]\n0x0040BE08 | C6 00 00 | mov     byte ptr [rax], 0\n0x0040BE0B | 48 89 DF | mov     rdi, rbx\n0x0040BE0E | E8 C1 5F 0A 00 | call    sub_4B1DD4\n0x0040BE13 | 41 BD 00 00 00 00 | mov     r13d, 0\n0x0040BE19 | 41 F6 C4 01 | test    r12b, 1\n0x0040BE1D | 0F 84 0D FF FF FF | jz      loc_40BD30\n0x0040BE23 | B9 00 00 00 00 | mov     ecx, 0\n0x0040BE28 | 48 89 EA | mov     rdx, rbp\n0x0040BE2B | 48 89 DE | mov     rsi, rbx\n0x0040BE2E | BF 0D DB 4D 00 | mov     edi, offset aEtcShadow; \"/etc/shadow\"\n0x0040BE33 | E8 1C 31 0B 00 | call    sub_4BEF54\n0x0040BE38 | 85 C0 | test    eax, eax\n0x0040BE3A | 0F 8E 42 FF FF FF | jle     loc_40BD82\n0x0040BE40 | BD 58 31 4E 00 | mov     ebp, (offset aFoundStaticLea+15h); \"x\"\n0x0040BE45 | E9 53 FF FF FF | jmp     loc_40BD9D\n0x0040BE4A | 48 89 DE | mov     rsi, rbx\n0x0040BE4D | BF C3 DC 4D 00 | mov     edi, offset f; \"Password for '%s' changed\"\n0x0040BE52 | B8 00 00 00 00 | mov     eax, 0\n0x0040BE57 | E8 9E AD 0A 00 | call    sub_4B6BFA\n0x0040BE5C | E9 62 FF FF FF | jmp     loc_40BDC3\n0x0040BE61 | B8 00 00 00 00 | mov     eax, 0\n0x0040BE66 | 48 83 C4 18 | add     rsp, 18h\n0x0040BE6A | 5B | pop     rbx\n0x0040BE6B | 5D | pop     rbp\n0x0040BE6C | 41 5C | pop     r12\n0x0040BE6E | 41 5D | pop     r13\n0x0040BE70 | C3 | retn",
        "output": "```c\nvoid function(char* argv) {\n    // Save registers\n    __asm__(\"push r13\");\n    __asm__(\"push r12\");\n    __asm__(\"push rbp\");\n    __asm__(\"push rbx\");\n    __asm__(\"sub rsp, 0x18\");\n\n    // Call _getuid\n    __asm__(\"mov rbx, rsi\");\n    __asm__(\"call _getuid\");\n\n    // Check if eax is zero\n    __asm__(\"test eax, eax\");\n    __asm__(\"jnz loc_40BD17\");\n\n    // Set values in memory\n    __asm__(\"mov cs:qword_70D3A0, offset aMEEM\");\n    __asm__(\"mov cs:qword_70D3A8, offset aEncrypted\");\n\n    // Set esi and rdi\n    __asm__(\"mov esi, offset aParamProblem+0Bh\");\n    __asm__(\"mov rdi, rbx\");\n\n    // Call sub_4B4A18\n    __asm__(\"mov eax, 0\");\n    __asm__(\"call sub_4B4A18\");\n\n    // Save return value in r12d\n    __asm__(\"mov r12d, eax\");\n\n    // Jump to loc_40BDDA\n    __asm__(\"jmp loc_40BDDA\");\n\nloc_40BD17:\n    // Set edi to offset aPermissionDeni\n    __asm__(\"mov edi, offset aPermissionDeni\");\n\n    // Set eax to 0\n    __asm__(\"mov eax, 0\");\n\n    // Call sub_408AEF\n    __asm__(\"call sub_408AEF\");\n\nloc_40BDDA:\n    // Set rdi to cs:stdin\n    __asm__(\"mov rdi, cs:stdin\");\n\n    // Call sub_4B48CD\n    __asm__(\"call sub_4B48CD\");\n\n    // Check if rax is zero\n    __asm__(\"test rax, rax\");\n    __asm__(\"jz short loc_40BE61\");\n\n    // Set esi to 0x3A\n    __asm__(\"mov esi, 0x3A\");\n\n    // Set rdi to rbx\n    __asm__(\"mov rdi, rbx\");\n\n    // Call _strchr\n    __asm__(\"call _strchr\");\n\n    // Check if rax is zero\n    __asm__(\"test rax, rax\");\n    __asm__(\"jz loc_40BD26\");\n\n    // Set rbp to rax + 1\n    __asm__(\"lea rbp, [rax+1]\");\n\n    // Set byte ptr [rax] to 0\n    __asm__(\"mov byte ptr [rax], 0\");\n\n    // Call sub_4B1DD4\n    __asm__(\"call sub_4B1DD4\");\n\n    // Set r13d to 0\n    __asm__(\"mov r13d, 0\");\n\n    // Check if r12b is 1\n    __asm__(\"test r12b, 1\");\n    __asm__(\"jz loc_40BD30\");\n\n    // Set ecx to 0\n    __asm__(\"mov ecx, 0\");\n\n    // Set rdx to rbp\n    __asm__(\"mov rdx, rbp\");\n\n    // Set rsi to rbx\n    __asm__(\"mov rsi, rbx\");\n\n    // Set edi to offset aEtcShadow\n    __asm__(\"mov edi, offset aEtcShadow\");\n\n    // Call sub_4BEF54\n    __asm__(\"call sub_4BEF54\");\n\n    // Check if eax is less than or equal to 0\n    __asm__(\"jle loc_40BD82\");\n\n    // Set ebp to offset aFoundStaticLea+15h\n    __asm__(\"mov ebp, offset aFoundStaticLea+15h\");\n\n    // Jump to loc_40BD9D\n    __asm__(\"jmp loc_40BD9D\");\n\nloc_40BE61:\n    // Set eax to 0\n    __asm__(\"mov eax, 0\");\n\n    // Add 0x18 to rsp\n    __asm__(\"add rsp, 0x18\");\n\n    // Pop registers\n    __asm__(\"pop rbx\");\n    __asm__(\"pop rbp\");\n    __asm__(\"pop r12\");\n    __asm__(\"pop r13\");\n\n    // Return\n    __asm__(\"retn\");\n}\n```"
    },
    {
        "func_name": "volume_id_probe_luks",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0047B1C0 | 41 54 | push    r12\n0x0047B1C2 | 55 | push    rbp\n0x0047B1C3 | 53 | push    rbx\n0x0047B1C4 | 48 89 FD | mov     rbp, rdi\n0x0047B1C7 | BA 50 02 00 00 | mov     edx, 250h\n0x0047B1CC | BE 00 00 00 00 | mov     esi, 0\n0x0047B1D1 | E8 26 0B 00 00 | call    sub_47BCFC\n0x0047B1D6 | 48 85 C0 | test    rax, rax\n0x0047B1D9 | 74 38 | jz      short loc_47B213\n0x0047B1DB | 48 89 C3 | mov     rbx, rax\n0x0047B1DE | BA 06 00 00 00 | mov     edx, 6; n\n0x0047B1E3 | BE 7C 71 4E 00 | mov     esi, offset unk_4E717C; s2\n0x0047B1E8 | 48 89 C7 | mov     rdi, rax; s1\n0x0047B1EB | E8 10 B9 F8 FF | call    _memcmp\n0x0047B1F0 | 41 89 C4 | mov     r12d, eax\n0x0047B1F3 | 85 C0 | test    eax, eax\n0x0047B1F5 | 75 24 | jnz     short loc_47B21B\n0x0047B1F7 | 48 8D B3 A8 00 00 00 | lea     rsi, [rbx+0A8h]\n0x0047B1FE | BA 03 00 00 00 | mov     edx, 3\n0x0047B203 | 48 89 EF | mov     rdi, rbp\n0x0047B206 | E8 42 09 00 00 | call    sub_47BB4D\n0x0047B20B | 44 89 E0 | mov     eax, r12d\n0x0047B20E | 5B | pop     rbx\n0x0047B20F | 5D | pop     rbp\n0x0047B210 | 41 5C | pop     r12\n0x0047B212 | C3 | retn\n0x0047B213 | 41 BC FF FF FF FF | mov     r12d, 0FFFFFFFFh\n0x0047B219 | EB F0 | jmp     short loc_47B20B\n0x0047B21B | 41 BC FF FF FF FF | mov     r12d, 0FFFFFFFFh\n0x0047B221 | EB E8 | jmp     short loc_47B20B",
        "output": "```c\nvoid function(int rdi) {\n    push r12;\n    push rbp;\n    push rbx;\n    rbp = rdi;\n    edx = 0x250;\n    esi = 0;\n    sub_47BCFC();\n    if (rax == 0) {\n        rbx = rax;\n        edx = 6;\n        esi = &unk_4E717C;\n        rdi = rax;\n        _memcmp();\n        r12d = eax;\n        if (eax == 0) {\n            rsi = rbx + 0xA8;\n            edx = 3;\n            rdi = rbp;\n            sub_47BB4D();\n            eax = r12d;\n        }\n    }\n    pop rbx;\n    pop rbp;\n    pop r12;\n    return;\n}\n```"
    },
    {
        "func_name": "bb_basename",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004084F5 | 53 | push    rbx\n0x004084F6 | 48 89 FB | mov     rbx, rdi\n0x004084F9 | BE 2F 00 00 00 | mov     esi, 2Fh ; '/'; c\n0x004084FE | E8 DD E2 FF FF | call    _strrchr\n0x00408503 | 48 8D 78 01 | lea     rdi, [rax+1]\n0x00408507 | 48 85 C0 | test    rax, rax\n0x0040850A | 48 89 D8 | mov     rax, rbx\n0x0040850D | 48 0F 45 C7 | cmovnz  rax, rdi\n0x00408511 | 5B | pop     rbx\n0x00408512 | C3 | retn",
        "output": "```c\nvoid function(void* rbx) {\n    push rbx;\n    mov rbx, rdi;\n    mov esi, 0x2F; // '/'\n    call _strrchr;\n    lea rdi, [rax+1];\n    test rax, rax;\n    mov rax, rbx;\n    cmovnz rax, rdi;\n    pop rbx;\n    retn;\n}\n```"
    },
    {
        "func_name": "write_pidfile",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004BA73D | 48 85 FF | test    rdi, rdi\n0x004BA740 | 0F 84 97 00 00 00 | jz      locret_4BA7DD\n0x004BA746 | 55 | push    rbp\n0x004BA747 | 53 | push    rbx\n0x004BA748 | 48 81 EC A8 00 00 00 | sub     rsp, 0A8h\n0x004BA74F | BA B6 01 00 00 | mov     edx, 1B6h\n0x004BA754 | BE 41 02 00 00 | mov     esi, 241h; oflag\n0x004BA759 | B8 00 00 00 00 | mov     eax, 0\n0x004BA75E | E8 BD CA F4 FF | call    _open64\n0x004BA763 | 89 C3 | mov     ebx, eax\n0x004BA765 | 85 C0 | test    eax, eax\n0x004BA767 | 78 31 | js      short loc_4BA79A\n0x004BA769 | 48 89 E2 | mov     rdx, rsp; stat_buf\n0x004BA76C | 89 C6 | mov     esi, eax; fildes\n0x004BA76E | BF 01 00 00 00 | mov     edi, 1; ver\n0x004BA773 | E8 78 C4 F4 FF | call    ___fxstat64\n0x004BA778 | 85 C0 | test    eax, eax\n0x004BA77A | 75 10 | jnz     short loc_4BA78C\n0x004BA77C | 8B 44 24 18 | mov     eax, [rsp+0B8h+var_A0]\n0x004BA780 | 25 00 F0 00 00 | and     eax, 0F000h\n0x004BA785 | 3D 00 80 00 00 | cmp     eax, 8000h\n0x004BA78A | 74 18 | jz      short loc_4BA7A4\n0x004BA78C | C6 05 34 2C 25 00 00 | mov     cs:byte_70D3C7, 0\n0x004BA793 | 89 DF | mov     edi, ebx; fd\n0x004BA795 | E8 16 C2 F4 FF | call    _close\n0x004BA79A | 48 81 C4 A8 00 00 00 | add     rsp, 0A8h\n0x004BA7A1 | 5B | pop     rbx\n0x004BA7A2 | 5D | pop     rbp\n0x004BA7A3 | C3 | retn\n0x004BA7A4 | C6 05 1C 2C 25 00 01 | mov     cs:byte_70D3C7, 1\n0x004BA7AB | E8 90 BD F4 FF | call    _getpid\n0x004BA7B0 | 48 8D AC 24 92 00 00 00 | lea     rbp, [rsp+0B8h+buf]\n0x004BA7B8 | BA 0E 00 00 00 | mov     edx, 0Eh\n0x004BA7BD | 48 89 EE | mov     rsi, rbp\n0x004BA7C0 | 89 C7 | mov     edi, eax\n0x004BA7C2 | E8 3F E6 F4 FF | call    sub_408E06\n0x004BA7C7 | C6 00 0A | mov     byte ptr [rax], 0Ah\n0x004BA7CA | 48 29 E8 | sub     rax, rbp\n0x004BA7CD | 48 8D 50 01 | lea     rdx, [rax+1]; n\n0x004BA7D1 | 48 89 EE | mov     rsi, rbp; buf\n0x004BA7D4 | 89 DF | mov     edi, ebx; fd\n0x004BA7D6 | E8 EF F6 F4 FF | call    sub_409ECA\n0x004BA7DB | EB B6 | jmp     short loc_4BA793\n0x004BA7DD | C3 | retn",
        "output": "```c\nvoid function() {\n    if (rdi == 0) {\n        return;\n    }\n    push(rbp);\n    push(rbx);\n    sub(rsp, 0xA8);\n    mov(edx, 0x1B6);\n    mov(esi, 0x241);\n    mov(eax, 0);\n    open64();\n    ebx = eax;\n    if (eax < 0) {\n        return;\n    }\n    mov(rdx, rsp);\n    mov(esi, eax);\n    mov(edi, 0x1);\n    __fxstat64();\n    if (eax != 0) {\n        return;\n    }\n    eax = [rsp+0xB8+var_A0];\n    eax = eax & 0xF000;\n    if (eax == 0x8000) {\n        return;\n    }\n    byte_70D3C7 = 0;\n    edi = ebx;\n    close();\n    add(rsp, 0xA8);\n    pop(rbx);\n    pop(rbp);\n    return;\n}\n```"
    },
    {
        "func_name": "load_dep_bb",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0041D280 | 41 56 | push    r14\n0x0041D282 | 41 55 | push    r13\n0x0041D284 | 41 54 | push    r12\n0x0041D286 | 55 | push    rbp\n0x0041D287 | 53 | push    rbx\n0x0041D288 | BF AC FB 4D 00 | mov     edi, offset new; \"modules.dep.bb\"\n0x0041D28D | E8 E8 B9 FE FF | call    sub_408C7A\n0x0041D292 | 48 85 C0 | test    rax, rax\n0x0041D295 | 0F 84 35 01 00 00 | jz      loc_41D3D0\n0x0041D29B | 49 89 C6 | mov     r14, rax\n0x0041D29E | 48 8B 1D C3 00 2F 00 | mov     rbx, cs:qword_70D368\n0x0041D2A5 | C6 43 10 01 | mov     byte ptr [rbx+10h], 1\n0x0041D2A9 | C7 43 14 00 00 00 00 | mov     dword ptr [rbx+14h], 0\n0x0041D2B0 | 48 8B 03 | mov     rax, [rbx]\n0x0041D2B3 | 48 C7 00 00 00 00 00 | mov     qword ptr [rax], 0\n0x0041D2BA | 48 C7 40 08 00 00 00 00 | mov     qword ptr [rax+8], 0\n0x0041D2C2 | 48 C7 40 10 00 00 00 00 | mov     qword ptr [rax+10h], 0\n0x0041D2CA | EB 3C | jmp     short loc_41D308\n0x0041D2CC | 48 89 EF | mov     rdi, rbp; ptr\n0x0041D2CF | E8 7C 8F FE FF | call    _free\n0x0041D2D4 | EB 32 | jmp     short loc_41D308\n0x0041D2D6 | 48 8B 03 | mov     rax, [rbx]\n0x0041D2D9 | 4E 89 6C 20 08 | mov     [rax+r12+8], r13\n0x0041D2DE | 4C 89 F7 | mov     rdi, r14\n0x0041D2E1 | E8 E7 75 09 00 | call    sub_4B48CD\n0x0041D2E6 | 48 85 C0 | test    rax, rax\n0x0041D2E9 | 0F 84 8E 00 00 00 | jz      loc_41D37D\n0x0041D2EF | 48 8B 13 | mov     rdx, [rbx]\n0x0041D2F2 | 4A 89 44 22 10 | mov     [rdx+r12+10h], rax\n0x0041D2F7 | 48 8B 03 | mov     rax, [rbx]\n0x0041D2FA | 4A 8B 44 20 10 | mov     rax, [rax+r12+10h]\n0x0041D2FF | 80 38 00 | cmp     byte ptr [rax], 0\n0x0041D302 | 0F 85 84 00 00 00 | jnz     loc_41D38C\n0x0041D308 | 4C 89 F7 | mov     rdi, r14\n0x0041D30B | E8 BD 75 09 00 | call    sub_4B48CD\n0x0041D310 | 48 89 C5 | mov     rbp, rax\n0x0041D313 | 48 85 C0 | test    rax, rax\n0x0041D316 | 0F 84 A6 00 00 00 | jz      loc_41D3C2\n0x0041D31C | 80 7D 00 00 | cmp     byte ptr [rbp+0], 0\n0x0041D320 | 74 AA | jz      short loc_41D2CC\n0x0041D322 | BE 20 00 00 00 | mov     esi, 20h ; ' '; c\n0x0041D327 | 48 89 EF | mov     rdi, rbp; s\n0x0041D32A | E8 91 91 FE FF | call    _strchrnul\n0x0041D32F | 49 89 C5 | mov     r13, rax\n0x0041D332 | 44 8B 63 14 | mov     r12d, [rbx+14h]\n0x0041D336 | 41 8D 44 24 01 | lea     eax, [r12+1]\n0x0041D33B | 89 43 14 | mov     [rbx+14h], eax\n0x0041D33E | 44 89 E2 | mov     edx, r12d\n0x0041D341 | BE 0C 18 00 00 | mov     esi, 180Ch\n0x0041D346 | 48 8B 3B | mov     rdi, [rbx]\n0x0041D349 | E8 8C 3A 0A 00 | call    sub_4C0DDA\n0x0041D34E | 48 89 03 | mov     [rbx], rax\n0x0041D351 | 4D 63 E4 | movsxd  r12, r12d\n0x0041D354 | 4B 8D 14 64 | lea     rdx, [r12+r12*2]\n0x0041D358 | 4C 8D 24 D5 00 00 00 00 | lea     r12, ds:0[rdx*8]\n0x0041D360 | 48 89 2C D0 | mov     [rax+rdx*8], rbp\n0x0041D364 | 41 80 7D 00 00 | cmp     byte ptr [r13+0], 0\n0x0041D369 | 0F 84 67 FF FF FF | jz      loc_41D2D6\n0x0041D36F | 41 C6 45 00 00 | mov     byte ptr [r13+0], 0\n0x0041D374 | 4D 8D 6D 01 | lea     r13, [r13+1]\n0x0041D378 | E9 59 FF FF FF | jmp     loc_41D2D6\n0x0041D37D | BF 01 00 00 00 | mov     edi, 1; n\n0x0041D382 | E8 AC BE FE FF | call    sub_409233\n0x0041D387 | E9 63 FF FF FF | jmp     loc_41D2EF\n0x0041D38C | 4C 89 F7 | mov     rdi, r14\n0x0041D38F | E8 39 75 09 00 | call    sub_4B48CD\n0x0041D394 | 48 85 C0 | test    rax, rax\n0x0041D397 | 74 05 | jz      short loc_41D39E\n0x0041D399 | 80 38 00 | cmp     byte ptr [rax], 0\n0x0041D39C | 75 0D | jnz     short loc_41D3AB\n0x0041D39E | 48 89 C7 | mov     rdi, rax; ptr\n0x0041D3A1 | E8 AA 8E FE FF | call    _free\n0x0041D3A6 | E9 5D FF FF FF | jmp     loc_41D308\n0x0041D3AB | 48 89 C2 | mov     rdx, rax\n0x0041D3AE | BE AC FB 4D 00 | mov     esi, offset new; \"modules.dep.bb\"\n0x0041D3B3 | BF BB FB 4D 00 | mov     edi, offset aErrorInSAtS; \"error in %s at '%s'\"\n0x0041D3B8 | B8 00 00 00 00 | mov     eax, 0\n0x0041D3BD | E8 2D B7 FE FF | call    sub_408AEF\n0x0041D3C2 | B8 01 00 00 00 | mov     eax, 1\n0x0041D3C7 | 5B | pop     rbx\n0x0041D3C8 | 5D | pop     rbp\n0x0041D3C9 | 41 5C | pop     r12\n0x0041D3CB | 41 5D | pop     r13\n0x0041D3CD | 41 5E | pop     r14\n0x0041D3CF | C3 | retn\n0x0041D3D0 | B8 00 00 00 00 | mov     eax, 0\n0x0041D3D5 | EB F0 | jmp     short loc_41D3C7",
        "output": "```c\nvoid function() {\n    push    r14\n    push    r13\n    push    r12\n    push    rbp\n    push    rbx\n    mov     edi, offset new; \"modules.dep.bb\"\n    call    sub_408C7A\n    test    rax, rax\n    jz      loc_41D3D0\n    mov     r14, rax\n    mov     rbx, cs:qword_70D368\n    mov     byte ptr [rbx+10h], 1\n    mov     dword ptr [rbx+14h], 0\n    mov     rax, [rbx]\n    mov     qword ptr [rax], 0\n    mov     qword ptr [rax+8], 0\n    mov     qword ptr [rax+10h], 0\n    jmp     short loc_41D308\n    mov     rdi, rbp\n    call    _free\n    jmp     short loc_41D308\n    mov     rax, [rbx]\n    mov     [rax+r12+8], r13\n    mov     rdi, r14\n    call    sub_4B48CD\n    test    rax, rax\n    jz      loc_41D37D\n    mov     rdx, [rbx]\n    mov     [rdx+r12+10h], rax\n    mov     rax, [rbx]\n    mov     rax, [rax+r12+10h]\n    cmp     byte ptr [rax], 0\n    jnz     loc_41D38C\n    mov     rdi, r14\n    call    sub_4B48CD\n    mov     rbp, rax\n    test    rax, rax\n    jz      loc_41D3C2\n    cmp     byte ptr [rbp+0], 0\n    jz      short loc_41D2CC\n    mov     esi, 20h\n    mov     rdi, rbp\n    call    _strchrnul\n    mov     r13, rax\n    mov     r12d, [rbx+14h]\n    lea     eax, [r12+1]\n    mov     [rbx+14h], eax\n    mov     edx, r12d\n    mov     esi, 180Ch\n    mov     rdi, [rbx]\n    call    sub_4C0DDA\n    mov     [rbx], rax\n    movsxd  r12, r12d\n    lea     rdx, [r12+r12*2]\n    lea     r12, ds:0[rdx*8]\n    mov     [rax+rdx*8], rbp\n    cmp     byte ptr [r13+0], 0\n    jz      loc_41D2D6\n    mov     byte ptr [r13+0], 0\n    lea     r13, [r13+1]\n    jmp     loc_41D2D6\nloc_41D37D:\n    mov     edi, 1\n    call    sub_409233\n    jmp     loc_41D2EF\nloc_41D38C:\n    mov     rdi, r14\n    call    sub_4B48CD\n    test    rax, rax\n    jz      short loc_41D39E\n    cmp     byte ptr [rax], 0\n    jnz     short loc_41D3AB\nloc_41D39E:\n    mov     rdi, rax\n    call    _free\n    jmp     loc_41D308\nloc_41D3AB:\n    mov     rdx, rax\n    mov     esi, offset new; \"modules.dep.bb\"\n    mov     edi, offset aErrorInSAtS; \"error in %s at '%s'\"\n    mov     eax, 0\n    call    sub_408AEF\nloc_41D3C2:\n    mov     eax, 1\n    pop     rbx\n    pop     rbp\n    pop     r12\n    pop     r13\n    pop     r14\n    retn\nloc_41D3D0:\n    mov     eax, 0\n    jmp     short loc_41D3C7\n}\n```"
    },
    {
        "func_name": "showvars",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00458046 | 41 56 | push    r14\n0x00458048 | 41 55 | push    r13\n0x0045804A | 41 54 | push    r12\n0x0045804C | 55 | push    rbp\n0x0045804D | 53 | push    rbx\n0x0045804E | 48 83 EC 10 | sub     rsp, 10h\n0x00458052 | 49 89 FC | mov     r12, rdi\n0x00458055 | 89 F7 | mov     edi, esi\n0x00458057 | 89 D6 | mov     esi, edx\n0x00458059 | 48 8D 54 24 08 | lea     rdx, [rsp+38h+var_30]\n0x0045805E | E8 2F FF FF FF | call    sub_457F92\n0x00458063 | 48 89 C5 | mov     rbp, rax\n0x00458066 | 48 8B 74 24 08 | mov     rsi, [rsp+38h+var_30]\n0x0045806B | 48 29 C6 | sub     rsi, rax\n0x0045806E | 48 C1 FE 03 | sar     rsi, 3; nmemb\n0x00458072 | B9 90 2A 45 00 | mov     ecx, offset sub_452A90; compar\n0x00458077 | BA 08 00 00 00 | mov     edx, 8; size\n0x0045807C | 48 89 C7 | mov     rdi, rax; base\n0x0045807F | E8 AC E3 FA FF | call    _qsort\n0x00458084 | 41 80 3C 24 00 | cmp     byte ptr [r12], 0\n0x00458089 | 41 BD D1 7D 4E 00 | mov     r13d, (offset asc_4E7DD0+1); \" \"\n0x0045808F | 4D 0F 44 EC | cmovz   r13, r12\n0x00458093 | 48 3B 6C 24 08 | cmp     rbp, [rsp+38h+var_30]\n0x00458098 | 73 5E | jnb     short loc_4580F8\n0x0045809A | 4C 8B 35 D7 52 2B 00 | mov     r14, cs:qword_70D378\n0x004580A1 | EB 39 | jmp     short loc_4580DC\n0x004580A3 | 48 83 C3 01 | add     rbx, 1\n0x004580A7 | 48 89 DF | mov     rdi, rbx; src\n0x004580AA | E8 2D F5 FF FF | call    sub_4575DC\n0x004580AF | 49 89 C1 | mov     r9, rax\n0x004580B2 | 4C 8B 45 00 | mov     r8, [rbp+0]\n0x004580B6 | 48 89 D9 | mov     rcx, rbx\n0x004580B9 | 4C 29 C1 | sub     rcx, r8\n0x004580BC | 4C 89 EA | mov     rdx, r13\n0x004580BF | 4C 89 E6 | mov     rsi, r12\n0x004580C2 | BF BC 47 4E 00 | mov     edi, offset aSSSS; \"%s%s%.*s%s\\n\"\n0x004580C7 | B8 00 00 00 00 | mov     eax, 0\n0x004580CC | E8 E4 C5 FF FF | call    sub_4546B5\n0x004580D1 | 48 83 C5 08 | add     rbp, 8\n0x004580D5 | 48 39 6C 24 08 | cmp     [rsp+38h+var_30], rbp\n0x004580DA | 76 1C | jbe     short loc_4580F8\n0x004580DC | BE 3D 00 00 00 | mov     esi, 3Dh ; '='; c\n0x004580E1 | 48 8B 7D 00 | mov     rdi, [rbp+0]; s\n0x004580E5 | E8 D6 E3 FA FF | call    _strchrnul\n0x004580EA | 48 89 C3 | mov     rbx, rax\n0x004580ED | 4D 8D 4E 38 | lea     r9, [r14+38h]\n0x004580F1 | 80 38 00 | cmp     byte ptr [rax], 0\n0x004580F4 | 74 BC | jz      short loc_4580B2\n0x004580F6 | EB AB | jmp     short loc_4580A3\n0x004580F8 | B8 00 00 00 00 | mov     eax, 0\n0x004580FD | 48 83 C4 10 | add     rsp, 10h\n0x00458101 | 5B | pop     rbx\n0x00458102 | 5D | pop     rbp\n0x00458103 | 41 5C | pop     r12\n0x00458105 | 41 5D | pop     r13\n0x00458107 | 41 5E | pop     r14\n0x00458109 | C3 | retn",
        "output": "```c\nvoid function(void* rdi, int esi, int edx) {\n    // Save registers\n    push r14;\n    push r13;\n    push r12;\n    push rbp;\n    push rbx;\n    sub rsp, 0x10;\n    \n    // Function body\n    void* r12 = rdi;\n    int edi = esi;\n    int esi = edx;\n    void* rdx = rsp + 0x38;\n    sub_457F92(rdx);\n    void* rbp = rax;\n    void* rsi = rsp + 0x38;\n    rsi -= rax;\n    rsi >>= 3;\n    int ecx = sub_452A90;\n    int edx = 8;\n    void* rdi = rax;\n    _qsort(rdi, rsi, edx, ecx);\n    \n    // Check if r12 is null terminated\n    if (*r12 == 0) {\n        r13d = (offset asc_4E7DD0+1);\n    }\n    else {\n        r13 = r12;\n    }\n    \n    // Check if rbp is less than rsi\n    if (rbp >= rsp + 0x38) {\n        loc_4580F8:\n        // Function cleanup\n        mov r14, cs:qword_70D378;\n        jmp short loc_4580DC;\n    }\n    \n    // Loop through rbx\n    add rbx, 1;\n    rdi = rbx;\n    sub_4575DC(rdi);\n    r9 = rax;\n    r8 = [rbp+0];\n    rcx = rbx - r8;\n    rdx = r13;\n    rsi = r12;\n    edi = offset aSSSS; // \"%s%s%.*s%s\\n\"\n    eax = 0;\n    sub_4546B5();\n    rbp += 8;\n    \n    // Check if rbp is less than or equal to rsp + 0x38\n    if ([rsp+0x38] <= rbp) {\n        loc_4580F8:\n        esi = 0x3D; // '='\n        rdi = [rbp+0];\n        _strchrnul();\n        rbx = rax;\n        r9 = r14 + 0x38;\n        \n        // Loop until null terminator\n        if (*rax != 0) {\n            loc_4580B2:\n            jmp short loc_4580A3;\n        }\n    }\n    \n    // Function cleanup\n    eax = 0;\n    add rsp, 0x10;\n    pop rbx;\n    pop rbp;\n    pop r12;\n    pop r13;\n    pop r14;\n    retn;\n}\n```"
    },
    {
        "func_name": "find_mount_point",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004B4213 | 41 57 | push    r15\n0x004B4215 | 41 56 | push    r14\n0x004B4217 | 41 55 | push    r13\n0x004B4219 | 41 54 | push    r12\n0x004B421B | 55 | push    rbp\n0x004B421C | 53 | push    rbx\n0x004B421D | 48 81 EC A8 00 00 00 | sub     rsp, 0A8h\n0x004B4224 | 49 89 FC | mov     r12, rdi\n0x004B4227 | 41 89 F6 | mov     r14d, esi\n0x004B422A | 48 8D 54 24 10 | lea     rdx, [rsp+0D8h+stat_buf]; stat_buf\n0x004B422F | 48 89 FE | mov     rsi, rdi; filename\n0x004B4232 | BF 01 00 00 00 | mov     edi, 1; ver\n0x004B4237 | E8 94 23 F5 FF | call    ___xstat64\n0x004B423C | 85 C0 | test    eax, eax\n0x004B423E | 0F 85 0D 01 00 00 | jnz     loc_4B4351\n0x004B4244 | 48 8B 44 24 10 | mov     rax, [rsp+0D8h+stat_buf.st_dev]\n0x004B4249 | 48 89 44 24 08 | mov     [rsp+0D8h+var_D0], rax\n0x004B424E | 8B 44 24 28 | mov     eax, [rsp+0D8h+stat_buf.st_mode]\n0x004B4252 | 25 00 B0 00 00 | and     eax, 0B000h\n0x004B4257 | 41 BF 00 00 00 00 | mov     r15d, 0\n0x004B425D | 3D 00 20 00 00 | cmp     eax, 2000h\n0x004B4262 | 75 10 | jnz     short loc_4B4274\n0x004B4264 | 48 8B 44 24 38 | mov     rax, [rsp+0D8h+stat_buf.st_rdev]\n0x004B4269 | 48 89 44 24 08 | mov     [rsp+0D8h+var_D0], rax\n0x004B426E | 41 BF 01 00 00 00 | mov     r15d, 1\n0x004B4274 | BE 07 90 4E 00 | mov     esi, (offset aNTR+5); mode\n0x004B4279 | BF 2D 6D 4E 00 | mov     edi, offset aProcMounts; \"/proc/mounts\"\n0x004B427E | E8 DD 2C F5 FF | call    _setmntent\n0x004B4283 | 49 89 C5 | mov     r13, rax\n0x004B4286 | 48 85 C0 | test    rax, rax\n0x004B4289 | 0F 84 C9 00 00 00 | jz      loc_4B4358\n0x004B428F | 4C 89 EF | mov     rdi, r13; stream\n0x004B4292 | E8 A9 2C F5 FF | call    _getmntent\n0x004B4297 | 48 89 C3 | mov     rbx, rax\n0x004B429A | 48 85 C0 | test    rax, rax\n0x004B429D | 0F 84 91 00 00 00 | jz      loc_4B4334\n0x004B42A3 | 48 8B 2B | mov     rbp, [rbx]\n0x004B42A6 | BF 4D 7D 4E 00 | mov     edi, offset aRootfs; \"rootfs\"\n0x004B42AB | B9 07 00 00 00 | mov     ecx, 7\n0x004B42B0 | 48 89 EE | mov     rsi, rbp\n0x004B42B3 | F3 A6 | repe cmpsb\n0x004B42B5 | 0F 97 C0 | setnbe  al\n0x004B42B8 | 1C 00 | sbb     al, 0\n0x004B42BA | 84 C0 | test    al, al\n0x004B42BC | 74 D1 | jz      short loc_4B428F\n0x004B42BE | 48 8B 73 08 | mov     rsi, [rbx+8]; s2\n0x004B42C2 | 4C 89 E7 | mov     rdi, r12; s1\n0x004B42C5 | E8 36 29 F5 FF | call    _strcmp\n0x004B42CA | 85 C0 | test    eax, eax\n0x004B42CC | 74 66 | jz      short loc_4B4334\n0x004B42CE | 48 89 EE | mov     rsi, rbp; s2\n0x004B42D1 | 4C 89 E7 | mov     rdi, r12; s1\n0x004B42D4 | E8 27 29 F5 FF | call    _strcmp\n0x004B42D9 | 85 C0 | test    eax, eax\n0x004B42DB | 74 57 | jz      short loc_4B4334\n0x004B42DD | 45 85 F6 | test    r14d, r14d\n0x004B42E0 | 75 05 | jnz     short loc_4B42E7\n0x004B42E2 | 45 84 FF | test    r15b, r15b\n0x004B42E5 | 74 A8 | jz      short loc_4B428F\n0x004B42E7 | 48 8D 54 24 10 | lea     rdx, [rsp+0D8h+stat_buf]; stat_buf\n0x004B42EC | 48 89 EE | mov     rsi, rbp; filename\n0x004B42EF | BF 01 00 00 00 | mov     edi, 1; ver\n0x004B42F4 | E8 D7 22 F5 FF | call    ___xstat64\n0x004B42F9 | 85 C0 | test    eax, eax\n0x004B42FB | 75 0C | jnz     short loc_4B4309\n0x004B42FD | 48 8B 44 24 08 | mov     rax, [rsp+0D8h+var_D0]\n0x004B4302 | 48 39 44 24 38 | cmp     [rsp+0D8h+stat_buf.st_rdev], rax\n0x004B4307 | 74 2B | jz      short loc_4B4334\n0x004B4309 | 48 8B 73 08 | mov     rsi, [rbx+8]; filename\n0x004B430D | 48 8D 54 24 10 | lea     rdx, [rsp+0D8h+stat_buf]; stat_buf\n0x004B4312 | BF 01 00 00 00 | mov     edi, 1; ver\n0x004B4317 | E8 B4 22 F5 FF | call    ___xstat64\n0x004B431C | 85 C0 | test    eax, eax\n0x004B431E | 0F 85 6B FF FF FF | jnz     loc_4B428F\n0x004B4324 | 48 8B 44 24 08 | mov     rax, [rsp+0D8h+var_D0]\n0x004B4329 | 48 39 44 24 10 | cmp     [rsp+0D8h+stat_buf.st_dev], rax\n0x004B432E | 0F 85 5B FF FF FF | jnz     loc_4B428F\n0x004B4334 | 4C 89 EF | mov     rdi, r13; stream\n0x004B4337 | E8 64 1F F5 FF | call    _endmntent\n0x004B433C | 48 89 D8 | mov     rax, rbx\n0x004B433F | 48 81 C4 A8 00 00 00 | add     rsp, 0A8h\n0x004B4346 | 5B | pop     rbx\n0x004B4347 | 5D | pop     rbp\n0x004B4348 | 41 5C | pop     r12\n0x004B434A | 41 5D | pop     r13\n0x004B434C | 41 5E | pop     r14\n0x004B434E | 41 5F | pop     r15\n0x004B4350 | C3 | retn\n0x004B4351 | BB 00 00 00 00 | mov     ebx, 0\n0x004B4356 | EB E4 | jmp     short loc_4B433C\n0x004B4358 | BB 00 00 00 00 | mov     ebx, 0\n0x004B435D | EB DD | jmp     short loc_4B433C",
        "output": "```c\n#include <stdio.h>\n#include <sys/stat.h>\n#include <mntent.h>\n#include <string.h>\n\nint check_mount(char* s1, char* s2) {\n    struct stat stat_buf;\n    int ver = 1;\n    \n    if (stat(s1, &stat_buf) != 0) {\n        return 0;\n    }\n    \n    if ((stat_buf.st_mode & 0xB000) != 0x2000) {\n        return 0;\n    }\n    \n    FILE* stream = setmntent(\"/proc/mounts\", \"r\");\n    if (stream == NULL) {\n        return 0;\n    }\n    \n    struct mntent* mnt;\n    while ((mnt = getmntent(stream)) != NULL) {\n        if (strcmp(mnt->mnt_fsname, \"rootfs\") == 0) {\n            if (strcmp(mnt->mnt_dir, s2) == 0) {\n                endmntent(stream);\n                return 1;\n            }\n        }\n    }\n    \n    endmntent(stream);\n    return 0;\n}\n```"
    },
    {
        "func_name": "checkjobs_and_fg_shell",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004609A8 | 55 | push    rbp\n0x004609A9 | 53 | push    rbx\n0x004609AA | 48 83 EC 08 | sub     rsp, 8\n0x004609AE | E8 66 FD FF FF | call    sub_460719\n0x004609B3 | 89 C5 | mov     ebp, eax\n0x004609B5 | 48 8B 1D AC C9 2A 00 | mov     rbx, cs:qword_70D368\n0x004609BC | 83 7B 3C 00 | cmp     dword ptr [rbx+3Ch], 0\n0x004609C0 | 75 09 | jnz     short loc_4609CB\n0x004609C2 | 89 E8 | mov     eax, ebp\n0x004609C4 | 48 83 C4 08 | add     rsp, 8\n0x004609C8 | 5B | pop     rbx\n0x004609C9 | 5D | pop     rbp\n0x004609CA | C3 | retn\n0x004609CB | E8 30 69 FA FF | call    _getpgrp\n0x004609D0 | 89 C6 | mov     esi, eax; pgrp_id\n0x004609D2 | 8B 3B | mov     edi, [rbx]; fd\n0x004609D4 | E8 37 69 FA FF | call    _tcsetpgrp\n0x004609D9 | EB E7 | jmp     short loc_4609C2",
        "output": "```c\nvoid function() {\n    // Prologue\n    push    rbp\n    push    rbx\n    sub     rsp, 8\n\n    // Call sub_460719 and store the return value in ebp\n    call    sub_460719\n    mov     ebp, eax\n\n    // Move the value at cs:qword_70D368 into rbx\n    mov     rbx, cs:qword_70D368\n\n    // Compare the value at [rbx+3Ch] with 0\n    cmp     dword ptr [rbx+3Ch], 0\n\n    // If not equal to 0, jump to loc_4609CB\n    jnz     short loc_4609CB\n\n    // Move the value in ebp into eax\n    mov     eax, ebp\n\n    // Epilogue\n    add     rsp, 8\n    pop     rbx\n    pop     rbp\n    retn\n\nloc_4609CB:\n    // Call _getpgrp and store the return value in eax\n    call    _getpgrp\n\n    // Move the value in eax into esi (pgrp_id)\n    mov     esi, eax\n\n    // Move the value at [rbx] into edi (fd)\n    mov     edi, [rbx]\n\n    // Call _tcsetpgrp\n    call    _tcsetpgrp\n\n    // Jump to loc_4609C2\n    jmp     short loc_4609C2\n}\n```"
    },
    {
        "func_name": "vconfig_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043606A | 55 | push    rbp\n0x0043606B | 53 | push    rbx\n0x0043606C | 48 83 EC 48 | sub     rsp, 48h\n0x00436070 | 48 89 F3 | mov     rbx, rsi\n0x00436073 | 48 C7 04 24 00 00 00 00 | mov     [rsp+58h+var_58], 0\n0x0043607B | 48 C7 44 24 08 00 00 00 00 | mov     [rsp+58h+var_50], 0\n0x00436084 | 48 C7 44 24 10 00 00 00 00 | mov     [rsp+58h+var_48], 0\n0x0043608D | 48 C7 44 24 18 00 00 00 00 | mov     [rsp+58h+var_40], 0\n0x00436096 | 48 C7 44 24 20 00 00 00 00 | mov     [rsp+58h+var_38], 0\n0x0043609F | 48 C7 44 24 28 00 00 00 00 | mov     [rsp+58h+var_30], 0\n0x004360A8 | 48 C7 44 24 30 00 00 00 00 | mov     [rsp+58h+var_28], 0\n0x004360B1 | 48 8B 76 08 | mov     rsi, [rsi+8]\n0x004360B5 | 48 85 F6 | test    rsi, rsi\n0x004360B8 | 74 6D | jz      short loc_436127\n0x004360BA | 89 FD | mov     ebp, edi\n0x004360BC | BF 6C 21 4E 00 | mov     edi, offset aAdd; \"\\aadd\"\n0x004360C1 | E8 68 FF FF FF | call    sub_43602E\n0x004360C6 | 0F BE 10 | movsx   edx, byte ptr [rax]\n0x004360C9 | 89 14 24 | mov     dword ptr [rsp+58h+var_58], edx\n0x004360CC | 0F BE 40 FF | movsx   eax, byte ptr [rax-1]\n0x004360D0 | 39 E8 | cmp     eax, ebp\n0x004360D2 | 75 58 | jnz     short loc_43612C\n0x004360D4 | 83 FA 06 | cmp     edx, 6\n0x004360D7 | 74 58 | jz      short loc_436131\n0x004360D9 | 48 8B 73 10 | mov     rsi, [rbx+10h]\n0x004360DD | 48 8D 7C 24 04 | lea     rdi, [rsp+58h+var_58+4]\n0x004360E2 | E8 0C 2D FD FF | call    sub_408DF3\n0x004360E7 | 48 8B 7B 18 | mov     rdi, [rbx+18h]\n0x004360EB | 8B 04 24 | mov     eax, dword ptr [rsp+58h+var_58]\n0x004360EE | 83 F8 07 | cmp     eax, 7\n0x004360F1 | 0F 84 8C 00 00 00 | jz      loc_436183\n0x004360F7 | 85 C0 | test    eax, eax\n0x004360F9 | 0F 84 B1 00 00 00 | jz      loc_4361B0\n0x004360FF | 83 F8 01 | cmp     eax, 1\n0x00436102 | 74 42 | jz      short loc_436146\n0x00436104 | E8 E2 A1 08 00 | call    sub_4C02EB\n0x00436109 | 89 44 24 1C | mov     dword ptr [rsp+58h+var_40+4], eax\n0x0043610D | 48 8B 7B 20 | mov     rdi, [rbx+20h]\n0x00436111 | BA 07 00 00 00 | mov     edx, 7\n0x00436116 | BE 00 00 00 00 | mov     esi, 0\n0x0043611B | E8 8E A1 08 00 | call    sub_4C02AE\n0x00436120 | 66 89 44 24 34 | mov     word ptr [rsp+58h+var_28+4], ax\n0x00436125 | EB 1F | jmp     short loc_436146\n0x00436127 | E8 18 19 FD FF | call    sub_407A44\n0x0043612C | E8 13 19 FD FF | call    sub_407A44\n0x00436131 | 48 8B 73 10 | mov     rsi, [rbx+10h]\n0x00436135 | BF 1F 21 4E 00 | mov     edi, offset unk_4E211F\n0x0043613A | E8 EF FE FF FF | call    sub_43602E\n0x0043613F | 0F BE 00 | movsx   eax, byte ptr [rax]\n0x00436142 | 89 44 24 1C | mov     dword ptr [rsp+58h+var_40+4], eax\n0x00436146 | BA 00 00 00 00 | mov     edx, 0\n0x0043614B | BE 01 00 00 00 | mov     esi, 1\n0x00436150 | BF 02 00 00 00 | mov     edi, 2\n0x00436155 | E8 B0 36 FD FF | call    sub_40980A\n0x0043615A | 4C 8B 43 08 | mov     r8, [rbx+8]\n0x0043615E | B9 0B 21 4E 00 | mov     ecx, offset aIoctlErrorForS; \"ioctl error for %s\"\n0x00436163 | 48 89 E2 | mov     rdx, rsp\n0x00436166 | BE 83 89 00 00 | mov     esi, 8983h\n0x0043616B | 89 C7 | mov     edi, eax\n0x0043616D | B8 00 00 00 00 | mov     eax, 0\n0x00436172 | E8 83 37 FD FF | call    sub_4098FA\n0x00436177 | B8 00 00 00 00 | mov     eax, 0\n0x0043617C | 48 83 C4 48 | add     rsp, 48h\n0x00436180 | 5B | pop     rbx\n0x00436181 | 5D | pop     rbp\n0x00436182 | C3 | retn\n0x00436183 | BA 01 00 00 00 | mov     edx, 1\n0x00436188 | BE 00 00 00 00 | mov     esi, 0\n0x0043618D | E8 1C A1 08 00 | call    sub_4C02AE\n0x00436192 | 89 44 24 1C | mov     dword ptr [rsp+58h+var_40+4], eax\n0x00436196 | 48 8B 7B 20 | mov     rdi, [rbx+20h]\n0x0043619A | BA 07 00 00 00 | mov     edx, 7\n0x0043619F | BE 00 00 00 00 | mov     esi, 0\n0x004361A4 | E8 05 A1 08 00 | call    sub_4C02AE\n0x004361A9 | 66 89 44 24 34 | mov     word ptr [rsp+58h+var_28+4], ax\n0x004361AE | EB 96 | jmp     short loc_436146\n0x004361B0 | BA FF 0F 00 00 | mov     edx, 0FFFh\n0x004361B5 | BE 00 00 00 00 | mov     esi, 0\n0x004361BA | E8 EF A0 08 00 | call    sub_4C02AE\n0x004361BF | 89 44 24 1C | mov     dword ptr [rsp+58h+var_40+4], eax\n0x004361C3 | EB 81 | jmp     short loc_436146",
        "output": "```c\nvoid function(int edi, int esi, int ebx) {\n    int var_58 = 0;\n    int var_50 = 0;\n    int var_48 = 0;\n    int var_40 = 0;\n    int var_38 = 0;\n    int var_30 = 0;\n    int var_28 = 0;\n    \n    rbx = rsi;\n    \n    if (rsi != 0) {\n        ebp = edi;\n        aAdd();\n        \n        if (rax != 0) {\n            var_58 = (int8_t)(*rax);\n            var_50 = (int8_t)(*(rax-1));\n            \n            if (var_50 == ebp) {\n                if (var_58 == 6) {\n                    rsi = rbx + 0x10;\n                    sub_408DF3(&var_58+4);\n                    \n                    rdi = rbx + 0x18;\n                    if (var_58 == 7) {\n                        sub_436183();\n                    } else if (var_58 != 0) {\n                        sub_4361B0();\n                    } else if (var_58 == 1) {\n                        sub_4C02EB();\n                        var_40+4 = eax;\n                        \n                        rdi = rbx + 0x20;\n                        sub_4C02AE(7, 0);\n                        var_28+4 = ax;\n                    }\n                } else {\n                    sub_4C02EB();\n                    var_40+4 = eax;\n                    \n                    rdi = rbx + 0x20;\n                    sub_4C02AE(7, 0);\n                    var_28+4 = ax;\n                }\n            }\n        }\n    }\n    \n    r8 = rbx + 0x08;\n    sub_4098FA(\"ioctl error for %s\", rsp, 0x8983, eax);\n    \n    return;\n    \n    sub_436183() {\n        sub_4C02AE(1, 0);\n        var_40+4 = eax;\n        \n        rdi = rbx + 0x20;\n        sub_4C02AE(7, 0);\n        var_28+4 = ax;\n    }\n    \n    sub_4361B0() {\n        sub_4C02AE(0xFFF, 0);\n        var_40+4 = eax;\n    }\n}\n```"
    },
    {
        "func_name": "monotonic_ns",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040A4C8 | 48 83 EC 18 | sub     rsp, 18h\n0x0040A4CC | BE 00 00 00 00 | mov     esi, 0; tz\n0x0040A4D1 | 48 89 E7 | mov     rdi, rsp; tv\n0x0040A4D4 | E8 97 C3 FF FF | call    _gettimeofday\n0x0040A4D9 | 48 69 04 24 00 CA 9A 3B | imul    rax, [rsp+18h+var_18], 3B9ACA00h\n0x0040A4E1 | 48 69 54 24 08 E8 03 00 00 | imul    rdx, [rsp+18h+var_10], 3E8h\n0x0040A4EA | 48 01 D0 | add     rax, rdx\n0x0040A4ED | 48 83 C4 18 | add     rsp, 18h\n0x0040A4F1 | C3 | retn",
        "output": "```c\nvoid function() {\n    // sub     rsp, 18h\n    // allocate space on the stack for local variables\n    \n    int esi = 0; // mov     esi, 0; tz\n    \n    // mov     rdi, rsp; tv\n    // store the address of the stack pointer in rdi\n    \n    gettimeofday(&tv, NULL); // call    _gettimeofday\n    \n    // imul    rax, [rsp+18h+var_18], 3B9ACA00h\n    // multiply the value at [rsp+18h+var_18] by 3B9ACA00h and store the result in rax\n    \n    // imul    rdx, [rsp+18h+var_10], 3E8h\n    // multiply the value at [rsp+18h+var_10] by 3E8h and store the result in rdx\n    \n    // add     rax, rdx\n    // add the values in rax and rdx and store the result in rax\n    \n    // add     rsp, 18h\n    // deallocate the space on the stack\n    \n    return; // retn\n}\n```"
    },
    {
        "func_name": "read_nonempty",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0046B9FF | 53 | push    rbx\n0x0046BA00 | 48 89 FB | mov     rbx, rdi\n0x0046BA03 | 48 89 DF | mov     rdi, rbx\n0x0046BA06 | E8 68 FF FF FF | call    sub_46B973\n0x0046BA0B | 85 C0 | test    eax, eax\n0x0046BA0D | 74 F4 | jz      short loc_46BA03\n0x0046BA0F | 48 8B 05 52 19 2A 00 | mov     rax, cs:qword_70D368\n0x0046BA16 | 48 8B 00 | mov     rax, [rax]\n0x0046BA19 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0046BA1C | 5B | pop     rbx\n0x0046BA1D | C3 | retn",
        "output": "```c\nvoid function(void* rbx) {\n    void* rdi = rbx;\n    sub_46B973();\n    if (eax == 0) {\n        void* rax = qword_70D368;\n        rax = *rax;\n        eax = (unsigned char)(*rax);\n    }\n    return;\n}\n```"
    },
    {
        "func_name": "f_read16",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00481501 | 48 83 EC 18 | sub     rsp, 18h\n0x00481505 | BE 02 00 00 00 | mov     esi, 2\n0x0048150A | 48 8D 7C 24 0E | lea     rdi, [rsp+18h+var_A]\n0x0048150F | E8 9F FF FF FF | call    sub_4814B3\n0x00481514 | 0F B7 44 24 0E | movzx   eax, [rsp+18h+var_A]\n0x00481519 | 66 C1 C8 08 | ror     ax, 8\n0x0048151D | 0F B7 C0 | movzx   eax, ax\n0x00481520 | 48 83 C4 18 | add     rsp, 18h\n0x00481524 | C3 | retn",
        "output": "```c\nvoid function() {\n    int var_A;\n    \n    // sub     rsp, 18h\n    // allocate space on the stack for local variables\n    \n    // mov     esi, 2\n    // move the value 2 into the esi register\n    \n    // lea     rdi, [rsp+18h+var_A]\n    // calculate the address of var_A and store it in the rdi register\n    \n    sub_4814B3(); // call the function sub_4814B3\n    \n    // movzx   eax, [rsp+18h+var_A]\n    // load the value of var_A into the eax register, zero-extending it\n    \n    // ror     ax, 8\n    // rotate the lower 16 bits of eax right by 8 bits\n    \n    // movzx   eax, ax\n    // move the lower 16 bits of eax into eax, zero-extending it\n    \n    // add     rsp, 18h\n    // deallocate the space on the stack\n    \n    // retn\n    // return from the function\n}\n```"
    },
    {
        "func_name": "switch_root_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004799A5 | 55 | push    rbp\n0x004799A6 | 53 | push    rbx\n0x004799A7 | 48 81 EC 28 01 00 00 | sub     rsp, 128h\n0x004799AE | 48 89 F3 | mov     rbx, rsi\n0x004799B1 | 48 C7 84 24 18 01 00 00 00 00 00 00 | mov     [rsp+138h+var_20], 0\n0x004799BD | 48 C7 05 D8 39 29 00 16 70 4E 00 | mov     cs:qword_70D3A0, offset a2; \"-2\"\n0x004799C8 | 48 8D 94 24 18 01 00 00 | lea     rdx, [rsp+138h+var_20]\n0x004799D0 | BE 19 70 4E 00 | mov     esi, offset aC_0; \"+c:\"\n0x004799D5 | 48 89 DF | mov     rdi, rbx; argv\n0x004799D8 | B8 00 00 00 00 | mov     eax, 0\n0x004799DD | E8 36 B0 03 00 | call    sub_4B4A18\n0x004799E2 | 48 63 05 0F 14 29 00 | movsxd  rax, cs:optind\n0x004799E9 | 48 8D 1C C3 | lea     rbx, [rbx+rax*8]\n0x004799ED | 48 8B 3B | mov     rdi, [rbx]\n0x004799F0 | E8 78 FD F8 FF | call    sub_40976D\n0x004799F5 | 48 8D B4 24 80 00 00 00 | lea     rsi, [rsp+138h+stat_buf]; stat_buf\n0x004799FD | BF 21 77 4E 00 | mov     edi, (offset asc_4E771E+3); filename\n0x00479A02 | E8 93 FE F8 FF | call    sub_40989A\n0x00479A07 | 48 8B AC 24 80 00 00 00 | mov     rbp, [rsp+138h+stat_buf.st_dev]\n0x00479A0F | 48 8D B4 24 80 00 00 00 | lea     rsi, [rsp+138h+stat_buf]; stat_buf\n0x00479A17 | BF C4 6A 4E 00 | mov     edi, (offset aD_8+5); filename\n0x00479A1C | E8 79 FE F8 FF | call    sub_40989A\n0x00479A21 | 48 39 AC 24 80 00 00 00 | cmp     [rsp+138h+stat_buf.st_dev], rbp\n0x00479A29 | 74 0A | jz      short loc_479A35\n0x00479A2B | E8 10 CB F8 FF | call    _getpid\n0x00479A30 | 83 F8 01 | cmp     eax, 1\n0x00479A33 | 74 05 | jz      short loc_479A3A\n0x00479A35 | E8 0A E0 F8 FF | call    sub_407A44\n0x00479A3A | 48 8D 94 24 80 00 00 00 | lea     rdx, [rsp+138h+stat_buf]; stat_buf\n0x00479A42 | BE 37 95 4E 00 | mov     esi, offset asc_4E9537; \"/\"\n0x00479A47 | BF 01 00 00 00 | mov     edi, 1; ver\n0x00479A4C | E8 7F CB F8 FF | call    ___xstat64\n0x00479A51 | 85 C0 | test    eax, eax\n0x00479A53 | 75 13 | jnz     short loc_479A68\n0x00479A55 | 8B 84 24 98 00 00 00 | mov     eax, [rsp+138h+stat_buf.st_mode]\n0x00479A5C | 25 00 F0 00 00 | and     eax, 0F000h\n0x00479A61 | 3D 00 80 00 00 | cmp     eax, 8000h\n0x00479A66 | 74 0F | jz      short loc_479A77\n0x00479A68 | BF 1D 70 4E 00 | mov     edi, offset aInitIsNotARegu; \"/init is not a regular file\"\n0x00479A6D | B8 00 00 00 00 | mov     eax, 0\n0x00479A72 | E8 78 F0 F8 FF | call    sub_408AEF\n0x00479A77 | 48 89 E6 | mov     rsi, rsp; buf\n0x00479A7A | BF 21 77 4E 00 | mov     edi, (offset asc_4E771E+3); file\n0x00479A7F | E8 1C CE F8 FF | call    _statfs64\n0x00479A84 | 48 8B 04 24 | mov     rax, [rsp+138h+var_138]\n0x00479A88 | 3D F6 58 84 85 | cmp     eax, 858458F6h\n0x00479A8D | 74 16 | jz      short loc_479AA5\n0x00479A8F | 3D 94 19 02 01 | cmp     eax, 1021994h\n0x00479A94 | 74 0F | jz      short loc_479AA5\n0x00479A96 | BF 68 A3 4D 00 | mov     edi, offset aRootFilesystem; \"root filesystem is not ramfs/tmpfs\"\n0x00479A9B | B8 00 00 00 00 | mov     eax, 0\n0x00479AA0 | E8 4A F0 F8 FF | call    sub_408AEF\n0x00479AA5 | 48 89 EE | mov     rsi, rbp\n0x00479AA8 | BF 21 77 4E 00 | mov     edi, (offset asc_4E771E+3); \"/\"\n0x00479AAD | E8 32 FE FF FF | call    sub_4798E4\n0x00479AB2 | 41 B8 00 00 00 00 | mov     r8d, 0; data\n0x00479AB8 | B9 00 20 00 00 | mov     ecx, 2000h; rwflag\n0x00479ABD | BA 00 00 00 00 | mov     edx, 0; fstype\n0x00479AC2 | BE 21 77 4E 00 | mov     esi, (offset asc_4E771E+3); dir\n0x00479AC7 | BF C4 6A 4E 00 | mov     edi, (offset aD_8+5); special_file\n0x00479ACC | E8 BF CB F8 FF | call    _mount\n0x00479AD1 | 85 C0 | test    eax, eax\n0x00479AD3 | 74 0F | jz      short loc_479AE4\n0x00479AD5 | BF 39 70 4E 00 | mov     edi, offset unk_4E7039\n0x00479ADA | B8 00 00 00 00 | mov     eax, 0\n0x00479ADF | E8 D0 EC F8 FF | call    sub_4087B4\n0x00479AE4 | BF C4 6A 4E 00 | mov     edi, 4E6AC4h\n0x00479AE9 | E8 A0 FC F8 FF | call    sub_40978E\n0x00479AEE | 48 83 BC 24 18 01 00 00 00 | cmp     [rsp+138h+var_20], 0\n0x00479AF7 | 74 3A | jz      short loc_479B33\n0x00479AF9 | BF 00 00 00 00 | mov     edi, 0; fd\n0x00479AFE | E8 AD CE F8 FF | call    _close\n0x00479B03 | BE 02 00 00 00 | mov     esi, 2\n0x00479B08 | 48 8B BC 24 18 01 00 00 | mov     rdi, [rsp+138h+var_20]\n0x00479B10 | E8 17 F8 F8 FF | call    sub_40932C\n0x00479B15 | BE 01 00 00 00 | mov     esi, 1\n0x00479B1A | BF 00 00 00 00 | mov     edi, 0\n0x00479B1F | E8 1D F9 F8 FF | call    sub_409441\n0x00479B24 | BE 02 00 00 00 | mov     esi, 2\n0x00479B29 | BF 00 00 00 00 | mov     edi, 0\n0x00479B2E | E8 0E F9 F8 FF | call    sub_409441\n0x00479B33 | 48 8D 73 08 | lea     rsi, [rbx+8]; argv\n0x00479B37 | 48 8B 7B 08 | mov     rdi, [rbx+8]; path\n0x00479B3B | E8 40 DC F8 FF | call    _execv\n0x00479B40 | 48 8B 73 08 | mov     rsi, [rbx+8]\n0x00479B44 | BF CE DD 4D 00 | mov     edi, offset aCanTExecuteS; \"can't execute '%s'\"\n0x00479B49 | B8 00 00 00 00 | mov     eax, 0\n0x00479B4E | E8 61 EC F8 FF | call    sub_4087B4",
        "output": "```c\nvoid function(char* argv) {\n    push    rbp\n    push    rbx\n    sub     rsp, 128h\n    mov     rbx, rsi\n    mov     [rsp+138h+var_20], 0\n    mov     cs:qword_70D3A0, offset a2; \"-2\"\n    lea     rdx, [rsp+138h+var_20]\n    mov     esi, offset aC_0; \"+c:\"\n    mov     rdi, rbx; argv\n    mov     eax, 0\n    call    sub_4B4A18\n    movsxd  rax, cs:optind\n    lea     rbx, [rbx+rax*8]\n    mov     rdi, [rbx]\n    call    sub_40976D\n    lea     rsi, [rsp+138h+stat_buf]; stat_buf\n    mov     edi, (offset asc_4E771E+3); filename\n    call    sub_40989A\n    mov     rbp, [rsp+138h+stat_buf.st_dev]\n    lea     rsi, [rsp+138h+stat_buf]; stat_buf\n    mov     edi, (offset aD_8+5); filename\n    call    sub_40989A\n    cmp     [rsp+138h+stat_buf.st_dev], rbp\n    jz      short loc_479A35\n    call    _getpid\n    cmp     eax, 1\n    jz      short loc_479A3A\n    call    sub_407A44\n    lea     rdx, [rsp+138h+stat_buf]; stat_buf\n    mov     esi, offset asc_4E9537; \"/\"\n    mov     edi, 1; ver\n    call    ___xstat64\n    test    eax, eax\n    jnz     short loc_479A68\n    mov     eax, [rsp+138h+stat_buf.st_mode]\n    and     eax, 0F000h\n    cmp     eax, 8000h\n    jz      short loc_479A77\n    mov     edi, offset aInitIsNotARegu; \"/init is not a regular file\"\n    mov     eax, 0\n    call    sub_408AEF\n    mov     rsi, rsp; buf\n    mov     edi, (offset asc_4E771E+3); file\n    call    _statfs64\n    mov     rax, [rsp+138h+var_138]\n    cmp     eax, 858458F6h\n    jz      short loc_479AA5\n    cmp     eax, 1021994h\n    jz      short loc_479AA5\n    mov     edi, offset aRootFilesystem; \"root filesystem is not ramfs/tmpfs\"\n    mov     eax, 0\n    call    sub_408AEF\n    mov     rsi, rbp\n    mov     edi, (offset asc_4E771E+3); \"/\"\n    call    sub_4798E4\n    mov     r8d, 0; data\n    mov     ecx, 2000h; rwflag\n    mov     edx, 0; fstype\n    mov     esi, (offset asc_4E771E+3); dir\n    mov     edi, (offset aD_8+5); special_file\n    call    _mount\n    test    eax, eax\n    jz      short loc_479AE4\n    mov     edi, offset unk_4E7039\n    mov     eax, 0\n    call    sub_4087B4\n    mov     edi, 4E6AC4h\n    call    sub_40978E\n    cmp     [rsp+138h+var_20], 0\n    jz      short loc_479B33\n    mov     edi, 0; fd\n    call    _close\n    mov     esi, 2\n    mov     rdi, [rsp+138h+var_20]\n    call    sub_40932C\n    mov     esi, 1\n    mov     edi, 0\n    call    sub_409441\n    mov     esi, 2\n    mov     edi, 0\n    call    sub_409441\n    lea     rsi, [rbx+8]; argv\n    mov     rdi, [rbx+8]; path\n    call    _execv\n    mov     rsi, [rbx+8]\n    mov     edi, offset aCanTExecuteS; \"can't execute '%s'\"\n    mov     eax, 0\n    call    sub_4087B4\n}\n```"
    },
    {
        "func_name": "do_statfs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0049895D | 55 | push    rbp\n0x0049895E | 53 | push    rbx\n0x0049895F | 48 81 EC 88 00 00 00 | sub     rsp, 88h\n0x00498966 | 48 89 FD | mov     rbp, rdi\n0x00498969 | 48 89 F3 | mov     rbx, rsi\n0x0049896C | 48 89 E6 | mov     rsi, rsp; buf\n0x0049896F | E8 2C DF F6 FF | call    _statfs64\n0x00498974 | 85 C0 | test    eax, eax\n0x00498976 | 75 27 | jnz     short loc_49899F\n0x00498978 | 48 85 DB | test    rbx, rbx\n0x0049897B | 74 3B | jz      short loc_4989B8\n0x0049897D | 48 89 E1 | mov     rcx, rsp\n0x00498980 | BA AA 85 49 00 | mov     edx, offset sub_4985AA\n0x00498985 | 48 89 EE | mov     rsi, rbp\n0x00498988 | 48 89 DF | mov     rdi, rbx\n0x0049898B | E8 CB FE FF FF | call    sub_49885B\n0x00498990 | B8 01 00 00 00 | mov     eax, 1\n0x00498995 | 48 81 C4 88 00 00 00 | add     rsp, 88h\n0x0049899C | 5B | pop     rbx\n0x0049899D | 5D | pop     rbp\n0x0049899E | C3 | retn\n0x0049899F | 48 89 EE | mov     rsi, rbp\n0x004989A2 | BF 08 B8 4D 00 | mov     edi, offset aCanTReadFileSy; \"can't read file system information for \"...\n0x004989A7 | B8 00 00 00 00 | mov     eax, 0\n0x004989AC | E8 4B FD F6 FF | call    sub_4086FC\n0x004989B1 | B8 00 00 00 00 | mov     eax, 0\n0x004989B6 | EB DD | jmp     short loc_498995\n0x004989B8 | 8B 05 F2 49 27 00 | mov     eax, cs:dword_70D3B0\n0x004989BE | 83 E0 02 | and     eax, 2\n0x004989C1 | BB 58 B7 4D 00 | mov     ebx, offset aNILTSBFACD; \"%n %i %l %t %s %b %f %a %c %d\\n\"\n0x004989C6 | B8 78 B7 4D 00 | mov     eax, offset aFileNId8iNamel; \"  File: \\\"%n\\\"\\n    ID: %-8i Namelen: %\"...\n0x004989CB | 48 0F 44 D8 | cmovz   rbx, rax\n0x004989CF | EB AC | jmp     short loc_49897D",
        "output": "```c\nvoid function(void* rdi, void* rsi) {\n    // Prologue\n    push rbp;\n    push rbx;\n    sub rsp, 0x88;\n\n    // Save function arguments\n    mov rbp, rdi;\n    mov rbx, rsi;\n\n    // Allocate buffer\n    mov rsi, rsp;\n\n    // Call _statfs64\n    call _statfs64;\n\n    // Check return value\n    test eax, eax;\n    jnz loc_49899F;\n\n    // Check if rbx is null\n    test rbx, rbx;\n    jz loc_4989B8;\n\n    // Prepare arguments for sub_49885B\n    mov rcx, rsp;\n    mov edx, offset sub_4985AA;\n    mov rsi, rbp;\n    mov rdi, rbx;\n\n    // Call sub_49885B\n    call sub_49885B;\n\n    // Set return value to 1\n    mov eax, 1;\n\n    // Epilogue\n    add rsp, 0x88;\n    pop rbx;\n    pop rbp;\n    retn;\n\nloc_49899F:\n    // Prepare arguments for sub_4086FC\n    mov rsi, rbp;\n    mov edi, offset aCanTReadFileSy; // \"can't read file system information for \"\n    mov eax, 0;\n\n    // Call sub_4086FC\n    call sub_4086FC;\n\n    // Set return value to 0\n    mov eax, 0;\n\n    // Jump to the end\n    jmp short loc_498995;\n\nloc_4989B8:\n    // Load value from cs:dword_70D3B0 into eax\n    mov eax, cs:dword_70D3B0;\n\n    // Perform bitwise AND with 2\n    and eax, 2;\n\n    // Prepare arguments for printf\n    mov ebx, offset aNILTSBFACD; // \"%n %i %l %t %s %b %f %a %c %d\\n\"\n    mov eax, offset aFileNId8iNamel; // \"  File: \\\"%n\\\"\\n    ID: %-8i Namelen: %\"\n\n    // Conditionally move rbx to rax\n    cmovz rbx, rax;\n\n    // Jump to loc_49897D\n    jmp short loc_49897D;\n}\n```"
    },
    {
        "func_name": "get_if_settings",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004258F9 | 41 54 | push    r12\n0x004258FB | 55 | push    rbp\n0x004258FC | 53 | push    rbx\n0x004258FD | 49 89 FC | mov     r12, rdi\n0x00425900 | 48 89 F5 | mov     rbp, rsi\n0x00425903 | 48 89 FA | mov     rdx, rdi\n0x00425906 | BF 21 89 00 00 | mov     edi, 8921h; request\n0x0042590B | E8 82 FE FF FF | call    sub_425792\n0x00425910 | 89 C3 | mov     ebx, eax\n0x00425912 | 48 8D 75 28 | lea     rsi, [rbp+28h]\n0x00425916 | 4C 89 E2 | mov     rdx, r12\n0x00425919 | BF 13 89 00 00 | mov     edi, 8913h; request\n0x0042591E | E8 6F FE FF FF | call    sub_425792\n0x00425923 | 09 C3 | or      ebx, eax\n0x00425925 | 48 8D 75 50 | lea     rsi, [rbp+50h]\n0x00425929 | 4C 89 E2 | mov     rdx, r12\n0x0042592C | BF 27 89 00 00 | mov     edi, 8927h; request\n0x00425931 | E8 5C FE FF FF | call    sub_425792\n0x00425936 | 09 D8 | or      eax, ebx\n0x00425938 | 5B | pop     rbx\n0x00425939 | 5D | pop     rbp\n0x0042593A | 41 5C | pop     r12\n0x0042593C | C3 | retn",
        "output": "```c\nvoid function(int rdi, int rsi) {\n    int r12 = rdi;\n    int rbp = rsi;\n    int ebx;\n\n    ebx = sub_425792(0x8921);\n    ebx |= sub_425792(0x8913);\n    ebx |= sub_425792(0x8927);\n\n    return ebx;\n}\n```"
    },
    {
        "func_name": "checkPermIP",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004226AD | 48 8B 35 B4 AC 2E 00 | mov     rsi, cs:qword_70D368\n0x004226B4 | 48 8B 46 58 | mov     rax, [rsi+58h]\n0x004226B8 | 48 85 C0 | test    rax, rax\n0x004226BB | 74 2A | jz      short loc_4226E7\n0x004226BD | 8B 4E 08 | mov     ecx, [rsi+8]\n0x004226C0 | 89 CA | mov     edx, ecx\n0x004226C2 | 23 50 0C | and     edx, [rax+0Ch]\n0x004226C5 | 3B 50 08 | cmp     edx, [rax+8]\n0x004226C8 | 74 12 | jz      short loc_4226DC\n0x004226CA | 48 8B 00 | mov     rax, [rax]\n0x004226CD | 48 85 C0 | test    rax, rax\n0x004226D0 | 74 15 | jz      short loc_4226E7\n0x004226D2 | 89 CA | mov     edx, ecx\n0x004226D4 | 23 50 0C | and     edx, [rax+0Ch]\n0x004226D7 | 3B 50 08 | cmp     edx, [rax+8]\n0x004226DA | 75 EE | jnz     short loc_4226CA\n0x004226DC | 83 78 10 41 | cmp     dword ptr [rax+10h], 41h ; 'A'\n0x004226E0 | 0F 94 C0 | setz    al\n0x004226E3 | 0F B6 C0 | movzx   eax, al\n0x004226E6 | C3 | retn\n0x004226E7 | 80 7E 04 00 | cmp     byte ptr [rsi+4], 0\n0x004226EB | 0F 94 C0 | setz    al\n0x004226EE | 0F B6 C0 | movzx   eax, al\n0x004226F1 | C3 | retn",
        "output": "```c\n#include <stdio.h>\n\nint main() {\n    long long rsi = *(long long*)0x70D368;\n    long long rax = *(long long*)(rsi + 0x58);\n    \n    if (rax == 0) {\n        goto loc_4226E7;\n    }\n    \n    int ecx = *(int*)(rsi + 0x8);\n    int edx = ecx & *(int*)(rax + 0x0C);\n    \n    if (edx != *(int*)(rax + 0x08)) {\n        goto loc_4226DC;\n    }\n    \n    rax = *(long long*)rax;\n    \n    if (rax == 0) {\n        goto loc_4226E7;\n    }\n    \n    edx = ecx & *(int*)(rax + 0x0C);\n    \n    if (edx != *(int*)(rax + 0x08)) {\n        goto loc_4226CA;\n    }\n    \n    if (*(int*)(rax + 0x10) == 0x41) {\n        return 1;\n    }\n    \n    return 0;\n    \nloc_4226E7:\n    if (*(char*)(rsi + 0x4) == 0) {\n        return 1;\n    }\n    \n    return 0;\n}\n```"
    },
    {
        "func_name": "writeheader",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0044BFC3 | 41 54 | push    r12\n0x0044BFC5 | 55 | push    rbp\n0x0044BFC6 | 53 | push    rbx\n0x0044BFC7 | 48 81 EC 00 02 00 00 | sub     rsp, 200h\n0x0044BFCE | 49 89 F8 | mov     r8, rdi\n0x0044BFD1 | 48 89 F5 | mov     rbp, rsi\n0x0044BFD4 | 41 89 D4 | mov     r12d, edx\n0x0044BFD7 | 48 89 E3 | mov     rbx, rsp\n0x0044BFDA | B9 40 00 00 00 | mov     ecx, 40h ; '@'\n0x0044BFDF | B8 00 00 00 00 | mov     eax, 0\n0x0044BFE4 | 48 89 DF | mov     rdi, rbx\n0x0044BFE7 | F3 48 AB | rep stosq\n0x0044BFEA | 4C 89 C6 | mov     rsi, r8; src\n0x0044BFED | 48 89 DF | mov     rdi, rbx; dest\n0x0044BFF0 | E8 CB A3 FB FF | call    _strcpy\n0x0044BFF5 | 8B 55 18 | mov     edx, [rbp+18h]\n0x0044BFF8 | 81 E2 FF 01 00 00 | and     edx, 1FFh\n0x0044BFFE | 48 8D 7B 64 | lea     rdi, [rbx+64h]; s\n0x0044C002 | BE 44 3B 4E 00 | mov     esi, offset aO_1; \"%o\"\n0x0044C007 | B8 00 00 00 00 | mov     eax, 0\n0x0044C00C | E8 8F B5 FB FF | call    _sprintf\n0x0044C011 | 8B 55 1C | mov     edx, [rbp+1Ch]\n0x0044C014 | 81 E2 FF FF 1F 00 | and     edx, 1FFFFFh\n0x0044C01A | 48 8D 7B 6C | lea     rdi, [rbx+6Ch]; s\n0x0044C01E | BE 44 3B 4E 00 | mov     esi, offset aO_1; \"%o\"\n0x0044C023 | B8 00 00 00 00 | mov     eax, 0\n0x0044C028 | E8 73 B5 FB FF | call    _sprintf\n0x0044C02D | 8B 55 20 | mov     edx, [rbp+20h]\n0x0044C030 | 81 E2 FF FF 1F 00 | and     edx, 1FFFFFh\n0x0044C036 | 48 8D 7B 74 | lea     rdi, [rbx+74h]; s\n0x0044C03A | BE 44 3B 4E 00 | mov     esi, offset aO_1; \"%o\"\n0x0044C03F | B8 00 00 00 00 | mov     eax, 0\n0x0044C044 | E8 57 B5 FB FF | call    _sprintf\n0x0044C049 | 48 8D 7B 7C | lea     rdi, [rbx+7Ch]; s\n0x0044C04D | 8B 55 30 | mov     edx, [rbp+30h]\n0x0044C050 | BE 44 3B 4E 00 | mov     esi, offset aO_1; \"%o\"\n0x0044C055 | B8 00 00 00 00 | mov     eax, 0\n0x0044C05A | E8 41 B5 FB FF | call    _sprintf\n0x0044C05F | 48 BA FF FF FF FF 01 00 00 00 | mov     rdx, 1FFFFFFFFh\n0x0044C069 | 48 23 55 58 | and     rdx, [rbp+58h]\n0x0044C06D | 48 8D BB 88 00 00 00 | lea     rdi, [rbx+88h]; s\n0x0044C074 | BE 47 3B 4E 00 | mov     esi, offset aLlo_0; \"%llo\"\n0x0044C079 | B8 00 00 00 00 | mov     eax, 0\n0x0044C07E | E8 1D B5 FB FF | call    _sprintf\n0x0044C083 | 44 88 A4 24 9C 00 00 00 | mov     [rsp+218h+var_17C], r12b\n0x0044C08B | 48 B8 75 73 74 61 72 20 20 00 | mov     rax, 20207261747375h\n0x0044C095 | 48 89 84 24 01 01 00 00 | mov     [rsp+218h+var_117], rax\n0x0044C09D | C6 84 24 9B 00 00 00 20 | mov     [rsp+218h+var_17D], 20h ; ' '\n0x0044C0A5 | 48 89 DF | mov     rdi, rbx\n0x0044C0A8 | 48 8D 8C 24 00 02 00 00 | lea     rcx, [rsp+218h+var_18]\n0x0044C0B0 | BA E0 00 00 00 | mov     edx, 0E0h\n0x0044C0B5 | 0F B6 07 | movzx   eax, byte ptr [rdi]\n0x0044C0B8 | 01 C2 | add     edx, eax\n0x0044C0BA | 48 83 C7 01 | add     rdi, 1\n0x0044C0BE | 48 39 CF | cmp     rdi, rcx\n0x0044C0C1 | 75 F2 | jnz     short loc_44C0B5\n0x0044C0C3 | 48 8D BC 24 94 00 00 00 | lea     rdi, [rsp+218h+s]; s\n0x0044C0CB | BE 4C 3B 4E 00 | mov     esi, offset a06o; \"%06o\"\n0x0044C0D0 | B8 00 00 00 00 | mov     eax, 0\n0x0044C0D5 | E8 C6 B4 FB FF | call    _sprintf\n0x0044C0DA | BA 00 02 00 00 | mov     edx, 200h\n0x0044C0DF | 48 89 E6 | mov     rsi, rsp\n0x0044C0E2 | BF 01 00 00 00 | mov     edi, 1\n0x0044C0E7 | E8 88 D3 FB FF | call    sub_409474\n0x0044C0EC | 48 81 C4 00 02 00 00 | add     rsp, 200h\n0x0044C0F3 | 5B | pop     rbx\n0x0044C0F4 | 5D | pop     rbp\n0x0044C0F5 | 41 5C | pop     r12\n0x0044C0F7 | C3 | retn",
        "output": "```c\nvoid function(void* rdi, void* rsi, int edx, int ecx) {\n    // Save registers\n    push r12;\n    push rbp;\n    push rbx;\n    sub rsp, 0x200;\n\n    // Save function arguments\n    mov r8, rdi;\n    mov rbp, rsi;\n    mov r12d, edx;\n\n    // Allocate space on the stack\n    mov rbx, rsp;\n\n    // Initialize ecx and eax\n    mov ecx, 0x40;\n    mov eax, 0;\n\n    // Fill memory with 0 using rep stosq\n    mov rdi, rbx;\n    rep stosq;\n\n    // Copy source to destination\n    mov rsi, r8;\n    mov rdi, rbx;\n    call _strcpy;\n\n    // Process and format values\n    mov edx, [rbp+0x18];\n    and edx, 0x1FF;\n    lea rdi, [rbx+0x64];\n    mov esi, offset aO_1; // \"%o\"\n    mov eax, 0;\n    call _sprintf;\n\n    mov edx, [rbp+0x1C];\n    and edx, 0x1FFFFF;\n    lea rdi, [rbx+0x6C];\n    mov esi, offset aO_1; // \"%o\"\n    mov eax, 0;\n    call _sprintf;\n\n    mov edx, [rbp+0x20];\n    and edx, 0x1FFFFF;\n    lea rdi, [rbx+0x74];\n    mov esi, offset aO_1; // \"%o\"\n    mov eax, 0;\n    call _sprintf;\n\n    lea rdi, [rbx+0x7C];\n    mov edx, [rbp+0x30];\n    mov esi, offset aO_1; // \"%o\"\n    mov eax, 0;\n    call _sprintf;\n\n    // Format and print value\n    mov rdx, 0x1FFFFFFFF;\n    and rdx, [rbp+0x58];\n    lea rdi, [rbx+0x88];\n    mov esi, offset aLlo_0; // \"%llo\"\n    mov eax, 0;\n    call _sprintf;\n\n    // Save some values on the stack\n    mov [rsp+0x218-0x17C], r12b;\n    mov rax, 0x20207261747375;\n    mov [rsp+0x218-0x117], rax;\n    mov [rsp+0x218-0x17D], 0x20;\n\n    // Process and format string\n    mov rdi, rbx;\n    lea rcx, [rsp+0x218-0x18];\n    mov edx, 0xE0;\n    movzx eax, byte ptr [rdi];\n    add edx, eax;\n    add rdi, 1;\n    cmp rdi, rcx;\n    jnz short loc_44C0B5;\n    lea rdi, [rsp+0x218+s]; // s\n    mov esi, offset a06o; // \"%06o\"\n    mov eax, 0;\n    call _sprintf;\n\n    // Call sub_409474\n    mov edx, 0x200;\n    mov rsi, rsp;\n    mov edi, 1;\n    call sub_409474;\n\n    // Restore registers and return\n    add rsp, 0x200;\n    pop rbx;\n    pop rbp;\n    pop r12;\n    retn;\n}\n```"
    },
    {
        "func_name": "rtnl_rtscope_initialize",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043EB69 | 48 83 3D CF C5 2C 00 00 | cmp     cs:qword_70B140, 0\n0x0043EB71 | 74 01 | jz      short loc_43EB74\n0x0043EB73 | C3 | retn\n0x0043EB74 | 48 83 EC 08 | sub     rsp, 8\n0x0043EB78 | BF 10 08 00 00 | mov     edi, 810h; n\n0x0043EB7D | E8 B1 A6 FC FF | call    sub_409233\n0x0043EB82 | 48 89 05 B7 C5 2C 00 | mov     cs:qword_70B140, rax\n0x0043EB89 | 48 C7 40 10 41 2D 4E 00 | mov     qword ptr [rax+10h], offset aGlobal_0; \"global\"\n0x0043EB91 | 48 C7 80 08 08 00 00 48 2D 4E 00 | mov     qword ptr [rax+808h], offset aNowhere; \"nowhere\"\n0x0043EB9C | 48 C7 80 00 08 00 00 E8 9E 4E 00 | mov     qword ptr [rax+800h], offset aHost_2; \"host\"\n0x0043EBA7 | 48 C7 80 F8 07 00 00 09 84 4E 00 | mov     qword ptr [rax+7F8h], offset aLink_1; \"link\"\n0x0043EBB2 | 48 C7 80 50 06 00 00 50 2D 4E 00 | mov     qword ptr [rax+650h], offset aSite_0; \"site\"\n0x0043EBBD | 48 8D 70 10 | lea     rsi, [rax+10h]\n0x0043EBC1 | BF 55 2D 4E 00 | mov     edi, offset aEtcIproute2RtS; \"/etc/iproute2/rt_scopes\"\n0x0043EBC6 | E8 89 FE FF FF | call    sub_43EA54\n0x0043EBCB | 48 83 C4 08 | add     rsp, 8\n0x0043EBCF | C3 | retn",
        "output": "```c\nif (qword_70B140 == 0) {\n    return;\n}\nelse {\n    sub_409233(0x810);\n    qword_70B140 = rax;\n    *(qword_70B140 + 0x10) = &aGlobal_0;\n    *(qword_70B140 + 0x808) = &aNowhere;\n    *(qword_70B140 + 0x800) = &aHost_2;\n    *(qword_70B140 + 0x7F8) = &aLink_1;\n    *(qword_70B140 + 0x650) = &aSite_0;\n    rsi = qword_70B140 + 0x10;\n    sub_43EA54(&aEtcIproute2RtS);\n    return;\n}\n```"
    },
    {
        "func_name": "builtin_exit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00466DA2 | 48 83 EC 08 | sub     rsp, 8\n0x00466DA6 | E8 26 91 FF FF | call    sub_45FED1\n0x00466DAB | 48 83 38 00 | cmp     qword ptr [rax], 0\n0x00466DAF | 74 17 | jz      short loc_466DC8\n0x00466DB1 | C6 05 10 40 2A 00 FF | mov     cs:byte_70ADC8, 0FFh\n0x00466DB8 | 48 8B 38 | mov     rdi, [rax]\n0x00466DBB | E8 32 96 05 00 | call    sub_4C03F2\n0x00466DC0 | 0F B6 F8 | movzx   edi, al\n0x00466DC3 | E8 7D FF FF FF | call    sub_466D45\n0x00466DC8 | 48 8B 05 99 65 2A 00 | mov     rax, cs:qword_70D368\n0x00466DCF | 0F B6 78 4F | movzx   edi, byte ptr [rax+4Fh]\n0x00466DD3 | E8 6D FF FF FF | call    sub_466D45",
        "output": "```c\nvoid function() {\n    // sub     rsp, 8\n    // call    sub_45FED1\n    sub_45FED1();\n\n    // cmp     qword ptr [rax], 0\n    if (*rax == 0) {\n        // jz      short loc_466DC8\n        goto loc_466DC8;\n    }\n\n    // mov     cs:byte_70ADC8, 0FFh\n    byte_70ADC8 = 0xFF;\n\n    // mov     rdi, [rax]\n    rdi = *rax;\n\n    // call    sub_4C03F2\n    sub_4C03F2();\n\n    // movzx   edi, al\n    edi = (unsigned int)al;\n\n    // call    sub_466D45\n    sub_466D45();\n\nloc_466DC8:\n    // mov     rax, cs:qword_70D368\n    rax = qword_70D368;\n\n    // movzx   edi, byte ptr [rax+4Fh]\n    edi = (unsigned int)byte_70D368[0x4F];\n\n    // call    sub_466D45\n    sub_466D45();\n}\n```"
    },
    {
        "func_name": "nonblock_immune_read",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004BD544 | 41 55 | push    r13\n0x004BD546 | 41 54 | push    r12\n0x004BD548 | 55 | push    rbp\n0x004BD549 | 53 | push    rbx\n0x004BD54A | 48 83 EC 18 | sub     rsp, 18h\n0x004BD54E | 89 FD | mov     ebp, edi\n0x004BD550 | 49 89 F5 | mov     r13, rsi\n0x004BD553 | 49 89 D4 | mov     r12, rdx\n0x004BD556 | 89 CB | mov     ebx, ecx\n0x004BD558 | EB 23 | jmp     short loc_4BD57D\n0x004BD55A | 4C 89 E2 | mov     rdx, r12; nbytes\n0x004BD55D | 4C 89 EE | mov     rsi, r13; buf\n0x004BD560 | 89 EF | mov     edi, ebp; fd\n0x004BD562 | E8 79 95 F4 FF | call    _read\n0x004BD567 | EB 25 | jmp     short loc_4BD58E\n0x004BD569 | BA FF FF FF FF | mov     edx, 0FFFFFFFFh; timeout\n0x004BD56E | BE 01 00 00 00 | mov     esi, 1; nfds\n0x004BD573 | 48 8D 7C 24 08 | lea     rdi, [rsp+38h+fds]; fds\n0x004BD578 | E8 63 9C F4 FF | call    _poll\n0x004BD57D | 85 DB | test    ebx, ebx\n0x004BD57F | 74 D9 | jz      short loc_4BD55A\n0x004BD581 | 4C 89 E2 | mov     rdx, r12; nbytes\n0x004BD584 | 4C 89 EE | mov     rsi, r13; buf\n0x004BD587 | 89 EF | mov     edi, ebp; fd\n0x004BD589 | E8 97 C9 F4 FF | call    sub_409F25\n0x004BD58E | 48 85 C0 | test    rax, rax\n0x004BD591 | 79 31 | jns     short loc_4BD5C4\n0x004BD593 | 48 8B 15 C6 FD 24 00 | mov     rdx, cs:qword_70D360\n0x004BD59A | 83 3A 0B | cmp     dword ptr [rdx], 0Bh\n0x004BD59D | 75 25 | jnz     short loc_4BD5C4\n0x004BD59F | 89 6C 24 08 | mov     [rsp+38h+fds.fd], ebp\n0x004BD5A3 | 66 C7 44 24 0C 01 00 | mov     [rsp+38h+fds.events], 1\n0x004BD5AA | 85 DB | test    ebx, ebx\n0x004BD5AC | 74 BB | jz      short loc_4BD569\n0x004BD5AE | BA FF FF FF FF | mov     edx, 0FFFFFFFFh; timeout\n0x004BD5B3 | BE 01 00 00 00 | mov     esi, 1; nfds\n0x004BD5B8 | 48 8D 7C 24 08 | lea     rdi, [rsp+38h+fds]; fds\n0x004BD5BD | E8 1B 0A 00 00 | call    sub_4BDFDD\n0x004BD5C2 | EB B9 | jmp     short loc_4BD57D\n0x004BD5C4 | 48 83 C4 18 | add     rsp, 18h\n0x004BD5C8 | 5B | pop     rbx\n0x004BD5C9 | 5D | pop     rbp\n0x004BD5CA | 41 5C | pop     r12\n0x004BD5CC | 41 5D | pop     r13\n0x004BD5CE | C3 | retn",
        "output": "```c\nvoid function(int edi, int esi, int edx, int ecx) {\n    // Prologue\n    push r13;\n    push r12;\n    push rbp;\n    push rbx;\n    sub rsp, 0x18;\n\n    // Save function arguments\n    mov ebp, edi;\n    mov r13, rsi;\n    mov r12, rdx;\n    mov ebx, ecx;\n\n    // Jump to loc_4BD57D\n    jmp short loc_4BD57D;\n\nloc_4BD55A:\n    // Read from file descriptor\n    mov rdx, r12; // nbytes\n    mov rsi, r13; // buf\n    mov edi, ebp; // fd\n    call _read;\n\nloc_4BD58E:\n    // Check return value of _read\n    test rax, rax;\n    jns short loc_4BD5C4;\n\nloc_4BD569:\n    // Call _poll\n    mov edx, 0xFFFFFFFF; // timeout\n    mov esi, 1; // nfds\n    lea rdi, [rsp+0x38]; fds\n    call _poll;\n\nloc_4BD57D:\n    // Check ebx\n    test ebx, ebx;\n    jz short loc_4BD55A;\n\n    // Call sub_409F25\n    mov rdx, r12; // nbytes\n    mov rsi, r13; // buf\n    mov edi, ebp; // fd\n    call sub_409F25;\n\nloc_4BD5C4:\n    // Epilogue\n    add rsp, 0x18;\n    pop rbx;\n    pop rbp;\n    pop r12;\n    pop r13;\n    retn;\n}\n```"
    },
    {
        "func_name": "oexpr",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0049B878 | 55 | push    rbp\n0x0049B879 | 53 | push    rbx\n0x0049B87A | 48 83 EC 08 | sub     rsp, 8\n0x0049B87E | E8 8A FF FF FF | call    sub_49B80D\n0x0049B883 | 48 89 C5 | mov     rbp, rax\n0x0049B886 | 48 8B 1D 03 1B 27 00 | mov     rbx, cs:qword_70D390\n0x0049B88D | 48 8B 03 | mov     rax, [rbx]\n0x0049B890 | 48 8D 50 08 | lea     rdx, [rax+8]\n0x0049B894 | 48 89 13 | mov     [rbx], rdx\n0x0049B897 | 48 8B 78 08 | mov     rdi, [rax+8]; s2\n0x0049B89B | E8 37 F8 FF FF | call    sub_49B0D7\n0x0049B8A0 | 83 F8 24 | cmp     eax, 24h ; '$'\n0x0049B8A3 | 74 0E | jz      short loc_49B8B3\n0x0049B8A5 | 48 83 2B 08 | sub     qword ptr [rbx], 8\n0x0049B8A9 | 48 89 E8 | mov     rax, rbp\n0x0049B8AC | 48 83 C4 08 | add     rsp, 8\n0x0049B8B0 | 5B | pop     rbx\n0x0049B8B1 | 5D | pop     rbp\n0x0049B8B2 | C3 | retn\n0x0049B8B3 | 48 8B 03 | mov     rax, [rbx]\n0x0049B8B6 | 48 8D 50 08 | lea     rdx, [rax+8]\n0x0049B8BA | 48 89 13 | mov     [rbx], rdx\n0x0049B8BD | 48 8B 78 08 | mov     rdi, [rax+8]; s2\n0x0049B8C1 | E8 11 F8 FF FF | call    sub_49B0D7\n0x0049B8C6 | 89 C7 | mov     edi, eax\n0x0049B8C8 | E8 AB FF FF FF | call    sub_49B878\n0x0049B8CD | 48 09 E8 | or      rax, rbp\n0x0049B8D0 | 40 0F 95 C5 | setnz   bpl\n0x0049B8D4 | 40 0F B6 ED | movzx   ebp, bpl\n0x0049B8D8 | EB CF | jmp     short loc_49B8A9",
        "output": "```c\nvoid function() {\n    // Prologue\n    push    rbp\n    push    rbx\n    sub     rsp, 8\n\n    // Call sub_49B80D and store the return value in rbp\n    call    sub_49B80D\n    mov     rbp, rax\n\n    // Move the value at cs:qword_70D390 into rbx\n    mov     rbx, cs:qword_70D390\n\n    // Move the value at [rbx] into rax\n    mov     rax, [rbx]\n\n    // Calculate the address of [rax+8] and store it in rdx\n    lea     rdx, [rax+8]\n\n    // Store the value in rdx at [rbx]\n    mov     [rbx], rdx\n\n    // Move the value at [rax+8] into rdi\n    mov     rdi, [rax+8]\n\n    // Call sub_49B0D7 with rdi as the argument\n    call    sub_49B0D7\n\n    // Compare the value in eax with 0x24\n    cmp     eax, 0x24\n\n    // If eax is equal to 0x24, jump to loc_49B8B3\n    jz      short loc_49B8B3\n\n    // Subtract 8 from the value at [rbx]\n    sub     qword ptr [rbx], 8\n\n    // Move the value in rbp into rax\n    mov     rax, rbp\n\n    // Epilogue\n    add     rsp, 8\n    pop     rbx\n    pop     rbp\n    retn\n\nloc_49B8B3:\n    // Move the value at [rbx] into rax\n    mov     rax, [rbx]\n\n    // Calculate the address of [rax+8] and store it in rdx\n    lea     rdx, [rax+8]\n\n    // Store the value in rdx at [rbx]\n    mov     [rbx], rdx\n\n    // Move the value at [rax+8] into rdi\n    mov     rdi, [rax+8]\n\n    // Call sub_49B0D7 with rdi as the argument\n    call    sub_49B0D7\n\n    // Move the value in eax into edi\n    mov     edi, eax\n\n    // Call sub_49B878\n    call    sub_49B878\n\n    // Perform bitwise OR between rax and rbp\n    or      rax, rbp\n\n    // Set bpl to 1 if rax is not zero, otherwise set it to 0\n    setnz   bpl\n\n    // Move the value in bpl into ebp\n    movzx   ebp, bpl\n\n    // Jump to loc_49B8A9\n    jmp     short loc_49B8A9\n}\n```"
    },
    {
        "func_name": "correct_password",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004B28B1 | 41 55 | push    r13\n0x004B28B3 | 41 54 | push    r12\n0x004B28B5 | 55 | push    rbp\n0x004B28B6 | 53 | push    rbx\n0x004B28B7 | 48 81 EC 68 01 00 00 | sub     rsp, 168h\n0x004B28BE | 48 85 FF | test    rdi, rdi\n0x004B28C1 | 0F 84 F3 00 00 00 | jz      loc_4B29BA\n0x004B28C7 | 48 8B 5F 08 | mov     rbx, [rdi+8]\n0x004B28CB | 0F B6 03 | movzx   eax, byte ptr [rbx]\n0x004B28CE | 3C 78 | cmp     al, 78h ; 'x'\n0x004B28D0 | 0F 84 91 00 00 00 | jz      loc_4B2967\n0x004B28D6 | 3C 2A | cmp     al, 2Ah ; '*'\n0x004B28D8 | 0F 84 89 00 00 00 | jz      loc_4B2967\n0x004B28DE | BD 01 00 00 00 | mov     ebp, 1\n0x004B28E3 | 80 3B 00 | cmp     byte ptr [rbx], 0\n0x004B28E6 | 74 6F | jz      short loc_4B2957\n0x004B28E8 | BF 00 DD 4D 00 | mov     edi, offset aPassword; \"Password: \"\n0x004B28ED | E8 97 F3 FF FF | call    sub_4B1C89\n0x004B28F2 | 49 89 C4 | mov     r12, rax\n0x004B28F5 | BD 00 00 00 00 | mov     ebp, 0\n0x004B28FA | 48 85 C0 | test    rax, rax\n0x004B28FD | 74 58 | jz      short loc_4B2957\n0x004B28FF | BA 01 00 00 00 | mov     edx, 1\n0x004B2904 | 48 89 DE | mov     rsi, rbx\n0x004B2907 | 48 89 C7 | mov     rdi, rax\n0x004B290A | E8 4D A4 00 00 | call    sub_4BCD5C\n0x004B290F | 49 89 C5 | mov     r13, rax\n0x004B2912 | 48 89 DE | mov     rsi, rbx; s2\n0x004B2915 | 48 89 C7 | mov     rdi, rax; s1\n0x004B2918 | E8 E3 42 F5 FF | call    _strcmp\n0x004B291D | 85 C0 | test    eax, eax\n0x004B291F | 40 0F 94 C5 | setz    bpl\n0x004B2923 | 40 0F B6 ED | movzx   ebp, bpl\n0x004B2927 | 4C 89 EF | mov     rdi, r13; ptr\n0x004B292A | E8 21 39 F5 FF | call    _free\n0x004B292F | 48 C7 C1 FF FF FF FF | mov     rcx, 0FFFFFFFFFFFFFFFFh\n0x004B2936 | B8 00 00 00 00 | mov     eax, 0\n0x004B293B | 4C 89 E7 | mov     rdi, r12\n0x004B293E | F2 AE | repne scasb\n0x004B2940 | 48 89 CE | mov     rsi, rcx\n0x004B2943 | 48 F7 D6 | not     rsi\n0x004B2946 | 48 8D 56 FF | lea     rdx, [rsi-1]; n\n0x004B294A | BE 00 00 00 00 | mov     esi, 0; c\n0x004B294F | 4C 89 E7 | mov     rdi, r12; s\n0x004B2952 | E8 99 3F F5 FF | call    _memset\n0x004B2957 | 89 E8 | mov     eax, ebp\n0x004B2959 | 48 81 C4 68 01 00 00 | add     rsp, 168h\n0x004B2960 | 5B | pop     rbx\n0x004B2961 | 5D | pop     rbp\n0x004B2962 | 41 5C | pop     r12\n0x004B2964 | 41 5D | pop     r13\n0x004B2966 | C3 | retn\n0x004B2967 | 80 7B 01 00 | cmp     byte ptr [rbx+1], 0\n0x004B296B | 0F 85 6D FF FF FF | jnz     loc_4B28DE\n0x004B2971 | 48 C7 44 24 08 00 00 00 00 | mov     [rsp+188h+var_180], 0\n0x004B297A | 4C 8D 44 24 08 | lea     r8, [rsp+188h+var_180]\n0x004B297F | B9 00 01 00 00 | mov     ecx, 100h\n0x004B2984 | 48 8D 54 24 60 | lea     rdx, [rsp+188h+var_128]\n0x004B2989 | 48 8D 74 24 10 | lea     rsi, [rsp+188h+var_178]\n0x004B298E | 48 8B 3F | mov     rdi, [rdi]; s2\n0x004B2991 | E8 A5 84 F5 FF | call    sub_40AE3B\n0x004B2996 | BB 78 98 4E 00 | mov     ebx, offset aAa; \"aa\"\n0x004B299B | 85 C0 | test    eax, eax\n0x004B299D | 0F 85 3B FF FF FF | jnz     loc_4B28DE\n0x004B29A3 | 48 8B 44 24 08 | mov     rax, [rsp+188h+var_180]\n0x004B29A8 | 48 85 C0 | test    rax, rax\n0x004B29AB | 0F 84 2D FF FF FF | jz      loc_4B28DE\n0x004B29B1 | 48 8B 58 08 | mov     rbx, [rax+8]\n0x004B29B5 | E9 24 FF FF FF | jmp     loc_4B28DE\n0x004B29BA | BB 78 98 4E 00 | mov     ebx, offset aAa; \"aa\"\n0x004B29BF | E9 24 FF FF FF | jmp     loc_4B28E8",
        "output": "```c\nvoid function(char* s1, char* s2) {\n    char* ptr;\n    int c;\n    int n;\n    int bpl;\n    \n    ptr = malloc(strlen(s2) + 1);\n    strcpy(ptr, s2);\n    \n    if (strcmp(ptr, \"x\") == 0 || strcmp(ptr, \"*\") == 0) {\n        bpl = 1;\n    } else {\n        bpl = 0;\n    }\n    \n    memset(s1, c, n);\n    \n    free(ptr);\n    \n    return bpl;\n}\n```"
    },
    {
        "func_name": "newline",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00499358 | 83 3D 05 20 27 00 00 | cmp     cs:dest.c_lflag, 0\n0x0049935F | 75 01 | jnz     short loc_499362\n0x00499361 | C3 | retn\n0x00499362 | 48 83 EC 08 | sub     rsp, 8\n0x00499366 | BF 6F E1 4D 00 | mov     edi, (offset delim+5); format\n0x0049936B | B8 00 00 00 00 | mov     eax, 0\n0x00499370 | E8 A9 FE FF FF | call    sub_49921E\n0x00499375 | 48 83 C4 08 | add     rsp, 8\n0x00499379 | C3 | retn",
        "output": "```c\nif (dest.c_lflag != 0) {\n    return;\n}\n\nsub rsp, 8;\nedi = &delim + 5;\neax = 0;\ncall sub_49921E;\nadd rsp, 8;\nreturn;\n```"
    },
    {
        "func_name": "bb_displayroutes",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004312B5 | 41 56 | push    r14\n0x004312B7 | 41 55 | push    r13\n0x004312B9 | 41 54 | push    r12\n0x004312BB | 55 | push    rbp\n0x004312BC | 53 | push    rbx\n0x004312BD | 48 81 EC A0 00 00 00 | sub     rsp, 0A0h\n0x004312C4 | 89 FD | mov     ebp, edi\n0x004312C6 | 41 89 F4 | mov     r12d, esi\n0x004312C9 | BF B2 1A 4E 00 | mov     edi, offset aProcNetRoute; \"/proc/net/route\"\n0x004312CE | E8 BA 79 FD FF | call    sub_408C8D\n0x004312D3 | 48 89 C3 | mov     rbx, rax\n0x004312D6 | 45 85 E4 | test    r12d, r12d\n0x004312D9 | BE 8D 1A 4E 00 | mov     esi, offset aMssWindowIrtt; \"  MSS Window  irtt\"\n0x004312DE | B8 A0 1A 4E 00 | mov     eax, offset aMetricRefUse; \"Metric Ref    Use\"\n0x004312E3 | 48 0F 44 F0 | cmovz   rsi, rax\n0x004312E7 | BF 78 5E 4D 00 | mov     edi, offset aKernelIpRoutin; \"Kernel IP routing table\\nDestination   \"...\n0x004312EC | B8 00 00 00 00 | mov     eax, 0\n0x004312F1 | E8 7A 54 FD FF | call    _printf\n0x004312F6 | BE C2 1A 4E 00 | mov     esi, offset asc_4E1AC2; \"%*[^\\n]\\n\"\n0x004312FB | 48 89 DF | mov     rdi, rbx; stream\n0x004312FE | B8 00 00 00 00 | mov     eax, 0\n0x00431303 | E8 08 56 FD FF | call    _fscanf\n0x00431308 | 85 C0 | test    eax, eax\n0x0043130A | 79 57 | jns     short loc_431363\n0x0043130C | BF 3C 1A 4E 00 | mov     edi, offset aFscanf_0; \"fscanf\"\n0x00431311 | B8 00 00 00 00 | mov     eax, 0\n0x00431316 | E8 D4 77 FD FF | call    sub_408AEF\n0x0043131B | 85 C0 | test    eax, eax\n0x0043131D | 79 ED | jns     short loc_43130C\n0x0043131F | 48 89 DF | mov     rdi, rbx; stream\n0x00431322 | E8 99 59 FD FF | call    _feof\n0x00431327 | 85 C0 | test    eax, eax\n0x00431329 | 74 E1 | jz      short loc_43130C\n0x0043132B | 48 89 DF | mov     rdi, rbx; stream\n0x0043132E | E8 8D 52 FD FF | call    _fclose\n0x00431333 | 48 81 C4 A0 00 00 00 | add     rsp, 0A0h\n0x0043133A | 5B | pop     rbx\n0x0043133B | 5D | pop     rbp\n0x0043133C | 41 5C | pop     r12\n0x0043133E | 41 5D | pop     r13\n0x00431340 | 41 5E | pop     r14\n0x00431342 | C3 | retn\n0x00431343 | 4C 8D 44 24 60 | lea     r8, [rsp+0C8h+var_68]\n0x00431348 | 8B 4C 24 2C | mov     ecx, [rsp+0C8h+var_9C]\n0x0043134C | 8B 54 24 30 | mov     edx, [rsp+0C8h+var_98]\n0x00431350 | 8B 74 24 28 | mov     esi, [rsp+0C8h+var_A0]\n0x00431354 | BF 14 1B 4E 00 | mov     edi, offset a6d2d7dS; \"%-6d %-2d %7d %s\\n\"\n0x00431359 | B8 00 00 00 00 | mov     eax, 0\n0x0043135E | E8 0D 54 FD FF | call    _printf\n0x00431363 | 48 83 EC 08 | sub     rsp, 8\n0x00431367 | 48 8D 44 24 24 | lea     rax, [rsp+0D0h+var_AC]\n0x0043136C | 50 | push    rax\n0x0043136D | 48 8D 44 24 30 | lea     rax, [rsp+0D8h+var_A8]\n0x00431372 | 50 | push    rax\n0x00431373 | 48 8D 44 24 3C | lea     rax, [rsp+0E0h+var_A4]\n0x00431378 | 50 | push    rax\n0x00431379 | 48 8D 44 24 58 | lea     rax, [rsp+0E8h+in]\n0x0043137E | 50 | push    rax\n0x0043137F | 48 8D 44 24 50 | lea     rax, [rsp+0F0h+var_A0]\n0x00431384 | 50 | push    rax\n0x00431385 | 48 8D 44 24 5C | lea     rax, [rsp+0F8h+var_9C]\n0x0043138A | 50 | push    rax\n0x0043138B | 48 8D 44 24 68 | lea     rax, [rsp+100h+var_98]\n0x00431390 | 50 | push    rax\n0x00431391 | 4C 8D 4C 24 74 | lea     r9, [rsp+108h+var_94]\n0x00431396 | 4C 8D 84 24 80 00 00 00 | lea     r8, [rsp+108h+var_88]\n0x0043139E | 48 8D 8C 24 88 00 00 00 | lea     rcx, [rsp+108h+var_80]\n0x004313A6 | 48 8D 94 24 A0 00 00 00 | lea     rdx, [rsp+108h+var_68]\n0x004313AE | BE CA 1A 4E 00 | mov     esi, offset a63sLxLxXDDDLxD; \"%63s%lx%lx%X%d%d%d%lx%d%d%d\\n\"\n0x004313B3 | 48 89 DF | mov     rdi, rbx; stream\n0x004313B6 | B8 00 00 00 00 | mov     eax, 0\n0x004313BB | E8 50 55 FD FF | call    _fscanf\n0x004313C0 | 48 83 C4 40 | add     rsp, 40h\n0x004313C4 | 83 F8 0B | cmp     eax, 0Bh\n0x004313C7 | 0F 85 4E FF FF FF | jnz     loc_43131B\n0x004313CD | 8B 74 24 34 | mov     esi, [rsp+0C8h+var_94]\n0x004313D1 | 40 F6 C6 01 | test    sil, 1\n0x004313D5 | 74 8C | jz      short loc_431363\n0x004313D7 | 83 E6 3E | and     esi, 3Eh\n0x004313DA | 48 8D 7C 24 50 | lea     rdi, [rsp+0C8h+var_78]\n0x004313DF | E8 4C F4 FF FF | call    sub_430830\n0x004313E4 | F6 44 24 35 02 | test    byte ptr [rsp+0C8h+var_94+1], 2\n0x004313E9 | 74 05 | jz      short loc_4313F0\n0x004313EB | C6 44 24 50 21 | mov     [rsp+0C8h+var_78], 21h ; '!'\n0x004313F0 | 48 C7 44 24 02 00 00 00 00 | mov     [rsp+0C8h+var_C6], 0\n0x004313F9 | C7 44 24 0A 00 00 00 00 | mov     [rsp+0C8h+var_BE], 0\n0x00431401 | 66 C7 44 24 0E 00 00 | mov     [rsp+0C8h+var_BA], 0\n0x00431408 | 66 C7 04 24 02 00 | mov     [rsp+0C8h+var_C8], 2\n0x0043140E | 48 8B 44 24 48 | mov     rax, [rsp+0C8h+var_80]\n0x00431413 | 89 44 24 04 | mov     dword ptr [rsp+0C8h+var_C6+2], eax\n0x00431417 | 89 EE | mov     esi, ebp\n0x00431419 | 81 CE 00 80 00 00 | or      esi, 8000h\n0x0043141F | 8B 54 24 38 | mov     edx, [rsp+0C8h+in.s_addr]\n0x00431423 | 48 89 E7 | mov     rdi, rsp\n0x00431426 | E8 B4 54 08 00 | call    sub_4B68DF\n0x0043142B | 49 89 C6 | mov     r14, rax\n0x0043142E | 48 8B 44 24 40 | mov     rax, [rsp+0C8h+var_88]\n0x00431433 | 89 44 24 04 | mov     dword ptr [rsp+0C8h+var_C6+2], eax\n0x00431437 | 89 EE | mov     esi, ebp\n0x00431439 | 81 CE 00 40 00 00 | or      esi, 4000h\n0x0043143F | 8B 54 24 38 | mov     edx, [rsp+0C8h+in.s_addr]\n0x00431443 | 48 89 E7 | mov     rdi, rsp\n0x00431446 | E8 94 54 08 00 | call    sub_4B68DF\n0x0043144B | 49 89 C5 | mov     r13, rax\n0x0043144E | 8B 7C 24 38 | mov     edi, [rsp+0C8h+in.s_addr]; in\n0x00431452 | E8 29 51 FD FF | call    _inet_ntoa\n0x00431457 | 4C 8D 44 24 50 | lea     r8, [rsp+0C8h+var_78]\n0x0043145C | 48 89 C1 | mov     rcx, rax\n0x0043145F | 4C 89 EA | mov     rdx, r13\n0x00431462 | 4C 89 F6 | mov     rsi, r14\n0x00431465 | BF E7 1A 4E 00 | mov     edi, offset a1515s1515s16s6; \"%-15.15s %-15.15s %-16s%-6s\"\n0x0043146A | B8 00 00 00 00 | mov     eax, 0\n0x0043146F | E8 FC 52 FD FF | call    _printf\n0x00431474 | 4C 89 F7 | mov     rdi, r14; ptr\n0x00431477 | E8 D4 4D FD FF | call    _free\n0x0043147C | 4C 89 EF | mov     rdi, r13; ptr\n0x0043147F | E8 CC 4D FD FF | call    _free\n0x00431484 | 45 85 E4 | test    r12d, r12d\n0x00431487 | 0F 84 B6 FE FF FF | jz      loc_431343\n0x0043148D | 4C 8D 44 24 60 | lea     r8, [rsp+0C8h+var_68]\n0x00431492 | 8B 4C 24 1C | mov     ecx, [rsp+0C8h+var_AC]\n0x00431496 | 8B 54 24 20 | mov     edx, [rsp+0C8h+var_A8]\n0x0043149A | 8B 74 24 24 | mov     esi, [rsp+0C8h+var_A4]\n0x0043149E | BF 03 1B 4E 00 | mov     edi, offset a5d5d6dS; \"%5d %-5d %6d %s\\n\"\n0x004314A3 | B8 00 00 00 00 | mov     eax, 0\n0x004314A8 | E8 C3 52 FD FF | call    _printf\n0x004314AD | E9 B1 FE FF FF | jmp     loc_431363",
        "output": "```c\nvoid function() {\n    push    r14\n    push    r13\n    push    r12\n    push    rbp\n    push    rbx\n    sub     rsp, 0A0h\n    mov     ebp, edi\n    mov     r12d, esi\n    mov     edi, offset aProcNetRoute; \"/proc/net/route\"\n    call    sub_408C8D\n    mov     rbx, rax\n    test    r12d, r12d\n    mov     esi, offset aMssWindowIrtt; \"  MSS Window  irtt\"\n    mov     eax, offset aMetricRefUse; \"Metric Ref    Use\"\n    cmovz   rsi, rax\n    mov     edi, offset aKernelIpRoutin; \"Kernel IP routing table\\nDestination   \"\n    mov     eax, 0\n    call    _printf\n    mov     esi, offset asc_4E1AC2; \"%*[^\\n]\\n\"\n    mov     rdi, rbx; stream\n    mov     eax, 0\n    call    _fscanf\n    test    eax, eax\n    jns     short loc_431363\n    mov     edi, offset aFscanf_0; \"fscanf\"\n    mov     eax, 0\n    call    sub_408AEF\n    test    eax, eax\n    jns     short loc_43130C\n    mov     rdi, rbx; stream\n    call    _feof\n    test    eax, eax\n    jz      short loc_43130C\n    mov     rdi, rbx; stream\n    call    _fclose\n    add     rsp, 0A0h\n    pop     rbx\n    pop     rbp\n    pop     r12\n    pop     r13\n    pop     r14\n    retn\n    lea     r8, [rsp+0C8h+var_68]\n    mov     ecx, [rsp+0C8h+var_9C]\n    mov     edx, [rsp+0C8h+var_98]\n    mov     esi, [rsp+0C8h+var_A0]\n    mov     edi, offset a6d2d7dS; \"%-6d %-2d %7d %s\\n\"\n    mov     eax, 0\n    call    _printf\n    sub     rsp, 8\n    lea     rax, [rsp+0D0h+var_AC]\n    push    rax\n    lea     rax, [rsp+0D8h+var_A8]\n    push    rax\n    lea     rax, [rsp+0E0h+var_A4]\n    push    rax\n    lea     rax, [rsp+0E8h+in]\n    push    rax\n    lea     rax, [rsp+0F0h+var_A0]\n    push    rax\n    lea     rax, [rsp+0F8h+var_9C]\n    push    rax\n    lea     rax, [rsp+100h+var_98]\n    push    rax\n    lea     r9, [rsp+108h+var_94]\n    lea     r8, [rsp+108h+var_88]\n    lea     rcx, [rsp+108h+var_80]\n    lea     rdx, [rsp+108h+var_68]\n    mov     esi, offset a63sLxLxXDDDLxD; \"%63s%lx%lx%X%d%d%d%lx%d%d%d\\n\"\n    mov     rdi, rbx; stream\n    mov     eax, 0\n    call    _fscanf\n    add     rsp, 40h\n    cmp     eax, 0Bh\n    jnz     loc_43131B\n    mov     esi, [rsp+0C8h+var_94]\n    test    sil, 1\n    jz      short loc_431363\n    and     esi, 3Eh\n    lea     rdi, [rsp+0C8h+var_78]\n    call    sub_430830\n    test    byte ptr [rsp+0C8h+var_94+1], 2\n    jz      short loc_4313F0\n    mov     [rsp+0C8h+var_78], 21h ; '!'\n    mov     [rsp+0C8h+var_C6], 0\n    mov     [rsp+0C8h+var_BE], 0\n    mov     [rsp+0C8h+var_BA], 0\n    mov     [rsp+0C8h+var_C8], 2\n    mov     rax, [rsp+0C8h+var_80]\n    mov     dword ptr [rsp+0C8h+var_C6+2], eax\n    mov     esi, ebp\n    or      esi, 8000h\n    mov     edx, [rsp+0C8h+in.s_addr]\n    mov     rdi, rsp\n    call    sub_4B68DF\n    mov     r14, rax\n    mov     rax, [rsp+0C8h+var_88]\n    mov     dword ptr [rsp+0C8h+var_C6+2], eax\n    mov     esi, ebp\n    or      esi, 4000h\n    mov     edx, [rsp+0C8h+in.s_addr]\n    mov     rdi, rsp\n    call    sub_4B68DF\n    mov     r13, rax\n    mov     edi, [rsp+0C8h+in.s_addr]; in\n    call    _inet_ntoa\n    lea     r8, [rsp+0C8h+var_78]\n    mov     rcx, rax\n    mov     rdx, r13\n    mov     rsi, r14\n    mov     edi, offset a1515s1515s16s6; \"%-15.15s %-15.15s %-16s%-6s\"\n    mov     eax, 0\n    call    _printf\n    mov     rdi, r14; ptr\n    call    _free\n    mov     rdi, r13; ptr\n    call    _free\n    test    r12d, r12d\n    jz      loc_431343\n    lea     r8, [rsp+0C8h+var_68]\n    mov     ecx, [rsp+0C8h+var_9C]\n    mov     edx, [rsp+0C8h+var_98]\n    mov     esi, [rsp+0C8h+var_A0]\n    mov     edi, offset a6d2d7dS; \"%-6d %-2d %7d %s\\n\"\n    mov     eax, 0\n    call    _printf\n    jmp     loc_431363\n}\n```"
    },
    {
        "func_name": "read_key_ungets",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004BD510 | 55 | push    rbp\n0x004BD511 | 53 | push    rbx\n0x004BD512 | 48 83 EC 08 | sub     rsp, 8\n0x004BD516 | 48 89 FD | mov     rbp, rdi\n0x004BD519 | 0F B6 07 | movzx   eax, byte ptr [rdi]\n0x004BD51C | 0F B6 C8 | movzx   ecx, al\n0x004BD51F | BB 0F 00 00 00 | mov     ebx, 0Fh\n0x004BD524 | 29 CB | sub     ebx, ecx\n0x004BD526 | 39 D3 | cmp     ebx, edx\n0x004BD528 | 0F 47 DA | cmova   ebx, edx\n0x004BD52B | 0F B6 C0 | movzx   eax, al\n0x004BD52E | 48 8D 7C 07 01 | lea     rdi, [rdi+rax+1]; dest\n0x004BD533 | 89 DA | mov     edx, ebx; n\n0x004BD535 | E8 16 98 F4 FF | call    _memcpy\n0x004BD53A | 00 5D 00 | add     [rbp+0], bl\n0x004BD53D | 48 83 C4 08 | add     rsp, 8\n0x004BD541 | 5B | pop     rbx\n0x004BD542 | 5D | pop     rbp\n0x004BD543 | C3 | retn",
        "output": "```c\nvoid function(char* dest, int n) {\n    push    rbp\n    push    rbx\n    sub     rsp, 8\n    mov     rbp, rdi\n    movzx   eax, byte ptr [rdi]\n    movzx   ecx, al\n    mov     ebx, 0Fh\n    sub     ebx, ecx\n    cmp     ebx, edx\n    cmova   ebx, edx\n    movzx   eax, al\n    lea     rdi, [rdi+rax+1]\n    mov     edx, ebx\n    call    _memcpy\n    add     [rbp+0], bl\n    add     rsp, 8\n    pop     rbx\n    pop     rbp\n    retn\n}\n```"
    },
    {
        "func_name": "stop_handler",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004B0CA0 | 41 54 | push    r12\n0x004B0CA2 | 55 | push    rbp\n0x004B0CA3 | 53 | push    rbx\n0x004B0CA4 | 0F B6 2D 1D C7 25 00 | movzx   ebp, cs:byte_70D3C8\n0x004B0CAB | 48 8B 1D AE C6 25 00 | mov     rbx, cs:qword_70D360\n0x004B0CB2 | 44 8B 23 | mov     r12d, [rbx]\n0x004B0CB5 | BE 7D E1 4B 00 | mov     esi, offset sub_4BE17D; handler\n0x004B0CBA | BF 12 00 00 00 | mov     edi, 12h; sig\n0x004B0CBF | E8 5C 5F F5 FF | call    _signal\n0x004B0CC4 | 80 3D FD C6 25 00 12 | cmp     cs:byte_70D3C8, 12h\n0x004B0CCB | 74 24 | jz      short loc_4B0CF1\n0x004B0CCD | BF 00 00 00 00 | mov     edi, 0; stat_loc\n0x004B0CD2 | E8 77 84 F5 FF | call    sub_40914E\n0x004B0CD7 | 89 C7 | mov     edi, eax\n0x004B0CD9 | E8 74 FF FF FF | call    sub_4B0C52\n0x004B0CDE | BF 01 00 00 00 | mov     edi, 1; seconds\n0x004B0CE3 | E8 48 6A F5 FF | call    _sleep\n0x004B0CE8 | 80 3D D9 C6 25 00 12 | cmp     cs:byte_70D3C8, 12h\n0x004B0CEF | 75 DC | jnz     short loc_4B0CCD\n0x004B0CF1 | BE 00 00 00 00 | mov     esi, 0; handler\n0x004B0CF6 | BF 12 00 00 00 | mov     edi, 12h; sig\n0x004B0CFB | E8 20 5F F5 FF | call    _signal\n0x004B0D00 | 44 89 23 | mov     [rbx], r12d\n0x004B0D03 | 40 88 2D BE C6 25 00 | mov     cs:byte_70D3C8, bpl\n0x004B0D0A | 5B | pop     rbx\n0x004B0D0B | 5D | pop     rbp\n0x004B0D0C | 41 5C | pop     r12\n0x004B0D0E | C3 | retn",
        "output": "```c\nvoid function() {\n    push r12;\n    push rbp;\n    push rbx;\n    ebp = (unsigned char)cs:byte_70D3C8;\n    rbx = cs:qword_70D360;\n    r12d = [rbx];\n    esi = &sub_4BE17D; // handler\n    edi = 0x12; // sig\n    _signal();\n    if (cs:byte_70D3C8 == 0x12) {\n        edi = 0; // stat_loc\n        sub_40914E();\n        edi = eax;\n        sub_4B0C52();\n        edi = 1; // seconds\n        _sleep();\n    }\n    if (cs:byte_70D3C8 != 0x12) {\n        esi = 0; // handler\n        edi = 0x12; // sig\n        _signal();\n    }\n    [rbx] = r12d;\n    cs:byte_70D3C8 = bpl;\n    pop rbx;\n    pop rbp;\n    pop r12;\n    retn;\n}\n```"
    },
    {
        "func_name": "route_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004314B2 | 53 | push    rbx\n0x004314B3 | 48 83 EC 20 | sub     rsp, 20h\n0x004314B7 | 49 89 F0 | mov     r8, rsi\n0x004314BA | 48 89 74 24 08 | mov     [rsp+28h+argv], rsi\n0x004314BF | EB 03 | jmp     short loc_4314C4\n0x004314C1 | C6 00 23 | mov     byte ptr [rax], 23h ; '#'\n0x004314C4 | 49 83 C0 08 | add     r8, 8\n0x004314C8 | 49 8B 00 | mov     rax, [r8]\n0x004314CB | 48 85 C0 | test    rax, rax\n0x004314CE | 74 34 | jz      short loc_431504\n0x004314D0 | BF 26 1B 4E 00 | mov     edi, offset aNet; \"-net\"\n0x004314D5 | B9 05 00 00 00 | mov     ecx, 5\n0x004314DA | 48 89 C6 | mov     rsi, rax\n0x004314DD | F3 A6 | repe cmpsb\n0x004314DF | 0F 97 C2 | setnbe  dl\n0x004314E2 | 80 DA 00 | sbb     dl, 0\n0x004314E5 | 84 D2 | test    dl, dl\n0x004314E7 | 74 D8 | jz      short loc_4314C1\n0x004314E9 | BF 2B 1B 4E 00 | mov     edi, offset aHost_1; \"-host\"\n0x004314EE | B9 06 00 00 00 | mov     ecx, 6\n0x004314F3 | 48 89 C6 | mov     rsi, rax\n0x004314F6 | F3 A6 | repe cmpsb\n0x004314F8 | 0F 97 C2 | setnbe  dl\n0x004314FB | 80 DA 00 | sbb     dl, 0\n0x004314FE | 84 D2 | test    dl, dl\n0x00431500 | 75 C2 | jnz     short loc_4314C4\n0x00431502 | EB BD | jmp     short loc_4314C1\n0x00431504 | 48 8D 54 24 18 | lea     rdx, [rsp+28h+var_10]\n0x00431509 | BE 31 1B 4E 00 | mov     esi, offset aANe; \"A:ne\"\n0x0043150E | 48 8B 7C 24 08 | mov     rdi, [rsp+28h+argv]; argv\n0x00431513 | E8 00 35 08 00 | call    sub_4B4A18\n0x00431518 | 89 C3 | mov     ebx, eax\n0x0043151A | A8 01 | test    al, 1\n0x0043151C | 74 38 | jz      short loc_431556\n0x0043151E | 48 8B 54 24 18 | mov     rdx, [rsp+28h+var_10]\n0x00431523 | BF 56 FD 4D 00 | mov     edi, offset aInet; \"inet\"\n0x00431528 | B9 05 00 00 00 | mov     ecx, 5\n0x0043152D | 48 89 D6 | mov     rsi, rdx\n0x00431530 | F3 A6 | repe cmpsb\n0x00431532 | 0F 97 C0 | setnbe  al\n0x00431535 | 1C 00 | sbb     al, 0\n0x00431537 | 84 C0 | test    al, al\n0x00431539 | 74 1B | jz      short loc_431556\n0x0043153B | BF 7E 10 4E 00 | mov     edi, 4E107Eh\n0x00431540 | B9 06 00 00 00 | mov     ecx, 6\n0x00431545 | 48 89 D6 | mov     rsi, rdx\n0x00431548 | F3 A6 | repe cmpsb\n0x0043154A | 0F 97 C0 | setnbe  al\n0x0043154D | 1C 00 | sbb     al, 0\n0x0043154F | 84 C0 | test    al, al\n0x00431551 | 75 53 | jnz     short loc_4315A6\n0x00431553 | 83 CB 08 | or      ebx, 8\n0x00431556 | 48 63 15 9B 98 2D 00 | movsxd  rdx, cs:optind\n0x0043155D | 48 8B 44 24 08 | mov     rax, [rsp+28h+argv]\n0x00431562 | 48 8D 04 D0 | lea     rax, [rax+rdx*8]\n0x00431566 | 48 89 44 24 08 | mov     [rsp+28h+argv], rax\n0x0043156B | 48 83 38 00 | cmp     qword ptr [rax], 0\n0x0043156F | 74 3A | jz      short loc_4315AB\n0x00431571 | 48 8D 74 24 08 | lea     rsi, [rsp+28h+argv]\n0x00431576 | BF 60 B8 4C 00 | mov     edi, offset unk_4CB860\n0x0043157B | E8 E2 F2 FF FF | call    sub_430862\n0x00431580 | 85 C0 | test    eax, eax\n0x00431582 | 74 59 | jz      short loc_4315DD\n0x00431584 | 48 8B 74 24 08 | mov     rsi, [rsp+28h+argv]\n0x00431589 | 48 83 3E 00 | cmp     qword ptr [rsi], 0\n0x0043158D | 74 4E | jz      short loc_4315DD\n0x0043158F | F6 C3 08 | test    bl, 8\n0x00431592 | 74 4E | jz      short loc_4315E2\n0x00431594 | 89 C7 | mov     edi, eax\n0x00431596 | E8 47 F5 FF FF | call    sub_430AE2\n0x0043159B | B8 00 00 00 00 | mov     eax, 0\n0x004315A0 | 48 83 C4 20 | add     rsp, 20h\n0x004315A4 | 5B | pop     rbx\n0x004315A5 | C3 | retn\n0x004315A6 | E8 99 64 FD FF | call    sub_407A44\n0x004315AB | 89 D8 | mov     eax, ebx\n0x004315AD | 83 E0 02 | and     eax, 2\n0x004315B0 | 83 F8 01 | cmp     eax, 1\n0x004315B3 | 19 FF | sbb     edi, edi\n0x004315B5 | F7 D7 | not     edi\n0x004315B7 | 81 E7 FF 0F 00 00 | and     edi, 0FFFh\n0x004315BD | F6 C3 08 | test    bl, 8\n0x004315C0 | 74 0F | jz      short loc_4315D1\n0x004315C2 | E8 14 F3 FF FF | call    sub_4308DB\n0x004315C7 | BF 00 00 00 00 | mov     edi, 0; status\n0x004315CC | E8 4F 2A 08 00 | call    sub_4B4020\n0x004315D1 | 83 E3 04 | and     ebx, 4\n0x004315D4 | 89 DE | mov     esi, ebx\n0x004315D6 | E8 DA FC FF FF | call    sub_4312B5\n0x004315DB | EB EA | jmp     short loc_4315C7\n0x004315DD | E8 62 64 FD FF | call    sub_407A44\n0x004315E2 | 89 C7 | mov     edi, eax\n0x004315E4 | E8 CF F8 FF FF | call    sub_430EB8\n0x004315E9 | EB B0 | jmp     short loc_43159B",
        "output": "```c\nvoid function(char* argv) {\n    char* r8 = argv;\n    *(r8 + 0x28) = argv;\n    \n    while (*r8 != 0) {\n        if (strncmp(r8, \"-net\", 5) == 0) {\n            // do something\n        } else if (strncmp(r8, \"-host\", 6) == 0) {\n            // do something\n        } else if (strncmp(r8, \"A:ne\", 4) == 0) {\n            // do something\n        } else if (strncmp(r8, \"inet\", 5) == 0) {\n            // do something\n        }\n        \n        r8 += 8;\n    }\n    \n    int ebx = sub_4B4A18(argv);\n    \n    if (ebx & 1) {\n        if (strncmp(r8, \"inet\", 5) == 0) {\n            // do something\n        } else if (strncmp(r8, \"4E107E\", 6) == 0) {\n            // do something\n        }\n    }\n    \n    int optind = *(int*)0x2D989B;\n    char* rax = argv + optind * 8;\n    *(r8 + 0x28) = rax;\n    \n    if (*rax != 0) {\n        sub_430862(argv, \"unk_4CB860\");\n        \n        if (eax != 0 && *rax != 0) {\n            if (ebx & 8) {\n                sub_430AE2(eax);\n            }\n        }\n    }\n    \n    return ebx;\n}\n```"
    },
    {
        "func_name": "xrtnl_wilddump_request",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043DD5D | 48 83 EC 28 | sub     rsp, 28h\n0x0043DD61 | C7 04 24 14 00 00 00 | mov     [rsp+28h+var_28], 14h\n0x0043DD68 | 66 89 54 24 04 | mov     [rsp+28h+var_24], dx\n0x0043DD6D | 66 C7 44 24 06 01 03 | mov     [rsp+28h+var_22], 301h\n0x0043DD74 | C7 44 24 0C 00 00 00 00 | mov     [rsp+28h+var_1C], 0\n0x0043DD7C | 8B 47 1C | mov     eax, [rdi+1Ch]\n0x0043DD7F | 83 C0 01 | add     eax, 1\n0x0043DD82 | 89 47 1C | mov     [rdi+1Ch], eax\n0x0043DD85 | 89 47 20 | mov     [rdi+20h], eax\n0x0043DD88 | 89 44 24 08 | mov     [rsp+28h+var_20], eax\n0x0043DD8C | 40 88 74 24 10 | mov     [rsp+28h+var_18], sil\n0x0043DD91 | BA 14 00 00 00 | mov     edx, 14h\n0x0043DD96 | 48 89 E6 | mov     rsi, rsp\n0x0043DD99 | E8 8A FF FF FF | call    sub_43DD28\n0x0043DD9E | 48 83 C4 28 | add     rsp, 28h\n0x0043DDA2 | C3 | retn",
        "output": "```c\nvoid function(void* rdi) {\n    // sub     rsp, 28h\n    char var_28[0x28];\n\n    // mov     [rsp+28h+var_28], 14h\n    *(int*)(var_28 + 0x28) = 0x14;\n\n    // mov     [rsp+28h+var_24], dx\n    *(short*)(var_28 + 0x24) = dx;\n\n    // mov     [rsp+28h+var_22], 301h\n    *(short*)(var_28 + 0x22) = 0x301;\n\n    // mov     [rsp+28h+var_1C], 0\n    *(int*)(var_28 + 0x1C) = 0;\n\n    // mov     eax, [rdi+1Ch]\n    int eax = *(int*)(rdi + 0x1C);\n\n    // add     eax, 1\n    eax += 1;\n\n    // mov     [rdi+1Ch], eax\n    *(int*)(rdi + 0x1C) = eax;\n\n    // mov     [rdi+20h], eax\n    *(int*)(rdi + 0x20) = eax;\n\n    // mov     [rsp+28h+var_20], eax\n    *(int*)(var_28 + 0x20) = eax;\n\n    // mov     [rsp+28h+var_18], sil\n    *(char*)(var_28 + 0x18) = sil;\n\n    // mov     edx, 14h\n    edx = 0x14;\n\n    // mov     rsi, rsp\n    rsi = &var_28;\n\n    // call    sub_43DD28\n    sub_43DD28();\n\n    // add     rsp, 28h\n    // retn\n}\n```"
    },
    {
        "func_name": "setvar_p",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004A0868 | 55 | push    rbp\n0x004A0869 | 53 | push    rbx\n0x004A086A | 48 83 EC 08 | sub     rsp, 8\n0x004A086E | 48 89 FB | mov     rbx, rdi\n0x004A0871 | 48 89 F5 | mov     rbp, rsi\n0x004A0874 | E8 2F F1 FF FF | call    sub_49F9A8\n0x004A0879 | 48 89 6B 10 | mov     [rbx+10h], rbp\n0x004A087D | 48 89 DF | mov     rdi, rbx\n0x004A0880 | E8 81 FD FF FF | call    sub_4A0606\n0x004A0885 | 48 89 D8 | mov     rax, rbx\n0x004A0888 | 48 83 C4 08 | add     rsp, 8\n0x004A088C | 5B | pop     rbx\n0x004A088D | 5D | pop     rbp\n0x004A088E | C3 | retn",
        "output": "```c\nvoid function(void* rbx, void* rbp) {\n    sub_49F9A8();\n    *(rbx + 0x10) = rbp;\n    sub_4A0606(rbx);\n    return rbx;\n}\n```"
    },
    {
        "func_name": "pseudo_exec_argv",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004660A2 | 41 55 | push    r13\n0x004660A4 | 41 54 | push    r12\n0x004660A6 | 55 | push    rbp\n0x004660A7 | 53 | push    rbx\n0x004660A8 | 48 83 EC 08 | sub     rsp, 8\n0x004660AC | 49 89 FD | mov     r13, rdi\n0x004660AF | 89 F3 | mov     ebx, esi\n0x004660B1 | 48 89 D5 | mov     rbp, rdx\n0x004660B4 | E8 AA F7 FF FF | call    sub_465863\n0x004660B9 | 49 89 C4 | mov     r12, rax\n0x004660BC | 48 89 C7 | mov     rdi, rax\n0x004660BF | E8 48 BF FF FF | call    sub_46200C\n0x004660C4 | 48 63 DB | movsxd  rbx, ebx\n0x004660C7 | 49 8D 5C DD 00 | lea     rbx, [r13+rbx*8+0]\n0x004660CC | 48 83 3B 00 | cmp     qword ptr [rbx], 0\n0x004660D0 | 74 3B | jz      short loc_46610D\n0x004660D2 | 4C 89 E7 | mov     rdi, r12\n0x004660D5 | E8 0F C8 FF FF | call    sub_4628E9\n0x004660DA | 4C 89 E7 | mov     rdi, r12; ptr\n0x004660DD | E8 6E 01 FA FF | call    _free\n0x004660E2 | 48 85 ED | test    rbp, rbp\n0x004660E5 | 74 38 | jz      short loc_46611F\n0x004660E7 | 48 89 EF | mov     rdi, rbp\n0x004660EA | E8 1D BF FF FF | call    sub_46200C\n0x004660EF | 48 8B 5D 00 | mov     rbx, [rbp+0]\n0x004660F3 | BE 2F 00 00 00 | mov     esi, 2Fh ; '/'; c\n0x004660F8 | 48 89 DF | mov     rdi, rbx; s\n0x004660FB | E8 60 06 FA FF | call    _strchr\n0x00466100 | 48 85 C0 | test    rax, rax\n0x00466103 | 74 2C | jz      short loc_466131\n0x00466105 | 48 89 EF | mov     rdi, rbp; argv\n0x00466108 | E8 63 B6 FF FF | call    sub_461770\n0x0046610D | 4C 89 E7 | mov     rdi, r12; ptr\n0x00466110 | E8 37 9E FF FF | call    sub_45FF4C\n0x00466115 | BF 00 00 00 00 | mov     edi, 0; status\n0x0046611A | E8 91 02 FA FF | call    __exit\n0x0046611F | BE 03 00 00 00 | mov     esi, 3\n0x00466124 | 48 89 DF | mov     rdi, rbx\n0x00466127 | E8 32 EA FF FF | call    sub_464B5E\n0x0046612C | 48 89 C5 | mov     rbp, rax\n0x0046612F | EB B6 | jmp     short loc_4660E7\n0x00466131 | 48 89 DF | mov     rdi, rbx; s1\n0x00466134 | E8 E7 CC FF FF | call    sub_462E20\n0x00466139 | 49 89 C4 | mov     r12, rax\n0x0046613C | 48 85 C0 | test    rax, rax\n0x0046613F | 74 1B | jz      short loc_46615C\n0x00466141 | E8 41 34 FA FF | call    sub_409587\n0x00466146 | 48 89 EF | mov     rdi, rbp\n0x00466149 | 41 FF 54 24 08 | call    qword ptr [r12+8]\n0x0046614E | 89 C3 | mov     ebx, eax\n0x00466150 | E8 32 34 FA FF | call    sub_409587\n0x00466155 | 89 DF | mov     edi, ebx; status\n0x00466157 | E8 54 02 FA FF | call    __exit\n0x0046615C | 48 89 DF | mov     rdi, rbx; s1\n0x0046615F | E8 BB A1 FF FF | call    sub_46031F\n0x00466164 | 48 8B 08 | mov     rcx, [rax]\n0x00466167 | 48 85 C9 | test    rcx, rcx\n0x0046616A | 74 99 | jz      short loc_466105\n0x0046616C | 48 8B 35 F5 71 2A 00 | mov     rsi, cs:qword_70D368\n0x00466173 | 48 8B 46 58 | mov     rax, [rsi+58h]\n0x00466177 | 48 8B 00 | mov     rax, [rax]\n0x0046617A | 48 89 45 00 | mov     [rbp+0], rax\n0x0046617E | 48 89 6E 58 | mov     [rsi+58h], rbp\n0x00466182 | B8 00 00 00 00 | mov     eax, 0\n0x00466187 | 8D 50 01 | lea     edx, [rax+1]\n0x0046618A | 48 83 C0 01 | add     rax, 1\n0x0046618E | 48 83 7C C5 00 00 | cmp     qword ptr [rbp+rax*8+0], 0\n0x00466194 | 75 F1 | jnz     short loc_466187\n0x00466196 | 89 56 54 | mov     [rsi+54h], edx\n0x00466199 | 48 8B 79 18 | mov     rdi, [rcx+18h]\n0x0046619D | E8 BF F9 FF FF | call    sub_465B61\n0x004661A2 | 89 C3 | mov     ebx, eax\n0x004661A4 | E8 DE 33 FA FF | call    sub_409587\n0x004661A9 | 89 DF | mov     edi, ebx; status\n0x004661AB | E8 00 02 FA FF | call    __exit",
        "output": "```c\nvoid function(void* rdi, int esi, void* rdx) {\n    void* r13 = rdi;\n    int ebx = esi;\n    void* rbp = rdx;\n    r13 = sub_465863(rdi, esi, rdx);\n    void* r12 = sub_46200C(r13);\n    if (*(long long*)(r13 + ebx * 8) != 0) {\n        sub_4628E9(r12);\n        _free(r12);\n    }\n    if (rbp != 0) {\n        sub_46200C(rbp);\n        void* rbx = *(void**)(rbp);\n        char* s = _strchr(rbx, '/');\n        if (s != 0) {\n            sub_461770(rbp);\n            sub_45FF4C(r12);\n            __exit(0);\n        }\n        sub_464B5E(rbx);\n        rbp = rax;\n    }\n    else {\n        char* s1 = sub_462E20(rbx);\n        r12 = sub_409587(s1);\n        if (r12 != 0) {\n            sub_409587(r12);\n            __exit(0);\n        }\n        sub_46031F(rbx);\n        void* rcx = *(void**)(rax);\n        if (rcx != 0) {\n            void* rsi = *(void**)(qword_70D368 + 0x58);\n            void* rax = *(void**)(rsi + 0x58);\n            *(void**)(rbp + 0) = rax;\n            *(void**)(rsi + 0x58) = rbp;\n            int eax = 0;\n            int edx = eax + 1;\n            eax += 1;\n            while (*(long long*)(rbp + eax * 8) != 0) {\n                edx = eax + 1;\n                eax += 1;\n            }\n            *(int*)(rsi + 0x54) = edx;\n            void* rdi = *(void**)(rcx + 0x18);\n            sub_465B61(rdi);\n            sub_409587(rbx);\n            __exit(0);\n        }\n    }\n}\n```"
    },
    {
        "func_name": "searchLines",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004A66F8 | 41 57 | push    r15\n0x004A66FA | 41 56 | push    r14\n0x004A66FC | 41 55 | push    r13\n0x004A66FE | 41 54 | push    r12\n0x004A6700 | 55 | push    rbp\n0x004A6701 | 53 | push    rbx\n0x004A6702 | 48 83 EC 08 | sub     rsp, 8\n0x004A6706 | 49 89 FC | mov     r12, rdi\n0x004A6709 | 89 F3 | mov     ebx, esi\n0x004A670B | 41 89 D5 | mov     r13d, edx\n0x004A670E | BA 3D 8E 4E 00 | mov     edx, offset aSearch; \"search\"\n0x004A6713 | 44 89 EE | mov     esi, r13d\n0x004A6716 | 89 DF | mov     edi, ebx\n0x004A6718 | E8 CA FA FF FF | call    sub_4A61E7\n0x004A671D | 41 BF 00 00 00 00 | mov     r15d, 0\n0x004A6723 | 85 C0 | test    eax, eax\n0x004A6725 | 0F 85 A4 00 00 00 | jnz     loc_4A67CF\n0x004A672B | 41 89 C7 | mov     r15d, eax\n0x004A672E | 41 80 3C 24 00 | cmp     byte ptr [r12], 0\n0x004A6733 | 75 20 | jnz     short loc_4A6755\n0x004A6735 | 41 BC 58 B3 70 00 | mov     r12d, offset dest\n0x004A673B | 80 3D 16 4C 26 00 00 | cmp     byte ptr cs:dest.c_iflag, 0\n0x004A6742 | 75 27 | jnz     short loc_4A676B\n0x004A6744 | BF 44 8E 4E 00 | mov     edi, offset aNoPreviousSear; \"no previous search string\"\n0x004A6749 | B8 00 00 00 00 | mov     eax, 0\n0x004A674E | E8 32 24 F6 FF | call    sub_408B85\n0x004A6753 | EB 7A | jmp     short loc_4A67CF\n0x004A6755 | 49 81 FC 58 B3 70 00 | cmp     r12, offset dest\n0x004A675C | 74 0D | jz      short loc_4A676B\n0x004A675E | 4C 89 E6 | mov     rsi, r12; src\n0x004A6761 | BF 58 B3 70 00 | mov     edi, offset dest; dest\n0x004A6766 | E8 55 FC F5 FF | call    _strcpy\n0x004A676B | 48 C7 C1 FF FF FF FF | mov     rcx, 0FFFFFFFFFFFFFFFFh\n0x004A6772 | B8 00 00 00 00 | mov     eax, 0\n0x004A6777 | 4C 89 E7 | mov     rdi, r12\n0x004A677A | F2 AE | repne scasb\n0x004A677C | 48 89 CA | mov     rdx, rcx\n0x004A677F | 48 F7 D2 | not     rdx\n0x004A6782 | 44 8D 72 FF | lea     r14d, [rdx-1]\n0x004A6786 | 89 DF | mov     edi, ebx\n0x004A6788 | E8 8A F9 FF FF | call    sub_4A6117\n0x004A678D | 48 89 C5 | mov     rbp, rax\n0x004A6790 | 48 85 C0 | test    rax, rax\n0x004A6793 | 74 3A | jz      short loc_4A67CF\n0x004A6795 | 44 39 EB | cmp     ebx, r13d\n0x004A6798 | 7F 23 | jg      short loc_4A67BD\n0x004A679A | B9 00 00 00 00 | mov     ecx, 0\n0x004A679F | 44 89 F2 | mov     edx, r14d\n0x004A67A2 | 4C 89 E6 | mov     rsi, r12\n0x004A67A5 | 48 89 EF | mov     rdi, rbp\n0x004A67A8 | E8 96 FE FF FF | call    sub_4A6643\n0x004A67AD | 85 C0 | test    eax, eax\n0x004A67AF | 79 30 | jns     short loc_4A67E1\n0x004A67B1 | 83 C3 01 | add     ebx, 1\n0x004A67B4 | 48 8B 6D 00 | mov     rbp, [rbp+0]\n0x004A67B8 | 41 39 DD | cmp     r13d, ebx\n0x004A67BB | 7D DD | jge     short loc_4A679A\n0x004A67BD | 4C 89 E6 | mov     rsi, r12\n0x004A67C0 | BF 5E 8E 4E 00 | mov     edi, offset aCanTFindString; \"can't find string \\\"%s\\\"\"\n0x004A67C5 | B8 00 00 00 00 | mov     eax, 0\n0x004A67CA | E8 B6 23 F6 FF | call    sub_408B85\n0x004A67CF | 44 89 F8 | mov     eax, r15d\n0x004A67D2 | 48 83 C4 08 | add     rsp, 8\n0x004A67D6 | 5B | pop     rbx\n0x004A67D7 | 5D | pop     rbp\n0x004A67D8 | 41 5C | pop     r12\n0x004A67DA | 41 5D | pop     r13\n0x004A67DC | 41 5E | pop     r14\n0x004A67DE | 41 5F | pop     r15\n0x004A67E0 | C3 | retn\n0x004A67E1 | 41 89 DF | mov     r15d, ebx\n0x004A67E4 | EB E9 | jmp     short loc_4A67CF",
        "output": "```c\nvoid function(int rdi, int esi, int edx) {\n    push r15;\n    push r14;\n    push r13;\n    push r12;\n    push rbp;\n    push rbx;\n    sub rsp, 8;\n    r12 = rdi;\n    ebx = esi;\n    r13d = edx;\n    edx = &aSearch;\n    esi = r13d;\n    edi = ebx;\n    sub_4A61E7();\n    r15d = 0;\n    if (eax != 0) {\n        r15d = eax;\n    }\n    if (*r12 == 0) {\n        r12d = &dest;\n        if (dest.c_iflag == 0) {\n            edi = &aNoPreviousSear;\n            eax = 0;\n            sub_408B85();\n            jmp loc_4A67CF;\n        }\n    }\n    if (r12 == &dest) {\n        strcpy(rsi, r12);\n        edi = &dest;\n        _strcpy();\n    }\n    rcx = 0xFFFFFFFFFFFFFFFF;\n    eax = 0;\n    rdi = r12;\n    repne scasb;\n    rdx = rcx;\n    rdx = ~rdx;\n    r14d = rdx - 1;\n    edi = ebx;\n    sub_4A6117();\n    rbp = rax;\n    if (rax != 0) {\n        if (ebx <= r13d) {\n            ecx = 0;\n            edx = r14d;\n            rsi = r12;\n            rdi = rbp;\n            sub_4A6643();\n            if (eax < 0) {\n                ebx += 1;\n                rbp = [rbp+0];\n                if (r13d >= ebx) {\n                    jmp loc_4A679A;\n                }\n            }\n        }\n        rsi = r12;\n        edi = &aCanTFindString;\n        eax = 0;\n        sub_408B85();\n    }\n    eax = r15d;\n    add rsp, 8;\n    pop rbx;\n    pop rbp;\n    pop r12;\n    pop r13;\n    pop r14;\n    pop r15;\n    retn;\n    r15d = ebx;\n    jmp loc_4A67CF;\n}\n```"
    },
    {
        "func_name": "BZ2_compressBlock",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0047EA74 | 55 | push    rbp\n0x0047EA75 | 53 | push    rbx\n0x0047EA76 | 48 83 EC 08 | sub     rsp, 8\n0x0047EA7A | 48 89 FB | mov     rbx, rdi\n0x0047EA7D | 89 F5 | mov     ebp, esi\n0x0047EA7F | 83 7F 60 00 | cmp     dword ptr [rdi+60h], 0\n0x0047EA83 | 7E 2A | jle     short loc_47EAAF\n0x0047EA85 | 8B 57 78 | mov     edx, [rdi+78h]\n0x0047EA88 | F7 D2 | not     edx\n0x0047EA8A | 89 57 78 | mov     [rdi+78h], edx\n0x0047EA8D | 8B 47 7C | mov     eax, [rdi+7Ch]\n0x0047EA90 | D1 C0 | rol     eax, 1\n0x0047EA92 | 31 D0 | xor     eax, edx\n0x0047EA94 | 89 47 7C | mov     [rdi+7Ch], eax\n0x0047EA97 | 83 BF 80 00 00 00 01 | cmp     dword ptr [rdi+80h], 1\n0x0047EA9E | 7E 07 | jle     short loc_47EAA7\n0x0047EAA0 | C7 47 68 00 00 00 00 | mov     dword ptr [rdi+68h], 0\n0x0047EAA7 | 48 89 DF | mov     rdi, rbx\n0x0047EAAA | E8 F3 FE FF FF | call    sub_47E9A2\n0x0047EAAF | 48 63 43 60 | movsxd  rax, dword ptr [rbx+60h]\n0x0047EAB3 | 48 03 43 20 | add     rax, [rbx+20h]\n0x0047EAB7 | 48 89 43 48 | mov     [rbx+48h], rax\n0x0047EABB | 83 BB 80 00 00 00 01 | cmp     dword ptr [rbx+80h], 1\n0x0047EAC2 | 74 15 | jz      short loc_47EAD9\n0x0047EAC4 | 83 7B 60 00 | cmp     dword ptr [rbx+60h], 0\n0x0047EAC8 | 7F 33 | jg      short loc_47EAFD\n0x0047EACA | 85 ED | test    ebp, ebp\n0x0047EACC | 0F 85 9E 00 00 00 | jnz     loc_47EB70\n0x0047EAD2 | 48 83 C4 08 | add     rsp, 8\n0x0047EAD6 | 5B | pop     rbx\n0x0047EAD7 | 5D | pop     rbp\n0x0047EAD8 | C3 | retn\n0x0047EAD9 | C7 43 74 00 00 00 00 | mov     dword ptr [rbx+74h], 0\n0x0047EAE0 | C7 43 70 00 00 00 00 | mov     dword ptr [rbx+70h], 0\n0x0047EAE7 | 8B 83 84 00 00 00 | mov     eax, [rbx+84h]\n0x0047EAED | 8D B0 30 68 5A 42 | lea     esi, [rax+425A6830h]\n0x0047EAF3 | 48 89 DF | mov     rdi, rbx\n0x0047EAF6 | E8 2B EA FF FF | call    sub_47D526\n0x0047EAFB | EB C7 | jmp     short loc_47EAC4\n0x0047EAFD | BE 26 59 41 31 | mov     esi, 31415926h\n0x0047EB02 | 48 89 DF | mov     rdi, rbx\n0x0047EB05 | E8 1C EA FF FF | call    sub_47D526\n0x0047EB0A | BA 53 00 00 00 | mov     edx, 53h ; 'S'\n0x0047EB0F | BE 08 00 00 00 | mov     esi, 8\n0x0047EB14 | 48 89 DF | mov     rdi, rbx\n0x0047EB17 | E8 C7 E9 FF FF | call    sub_47D4E3\n0x0047EB1C | BA 59 00 00 00 | mov     edx, 59h ; 'Y'\n0x0047EB21 | BE 08 00 00 00 | mov     esi, 8\n0x0047EB26 | 48 89 DF | mov     rdi, rbx\n0x0047EB29 | E8 B5 E9 FF FF | call    sub_47D4E3\n0x0047EB2E | 8B 73 78 | mov     esi, [rbx+78h]\n0x0047EB31 | 48 89 DF | mov     rdi, rbx\n0x0047EB34 | E8 ED E9 FF FF | call    sub_47D526\n0x0047EB39 | BA 00 00 00 00 | mov     edx, 0\n0x0047EB3E | BE 01 00 00 00 | mov     esi, 1\n0x0047EB43 | 48 89 DF | mov     rdi, rbx\n0x0047EB46 | E8 98 E9 FF FF | call    sub_47D4E3\n0x0047EB4B | 8B 53 10 | mov     edx, [rbx+10h]\n0x0047EB4E | BE 18 00 00 00 | mov     esi, 18h\n0x0047EB53 | 48 89 DF | mov     rdi, rbx\n0x0047EB56 | E8 88 E9 FF FF | call    sub_47D4E3\n0x0047EB5B | 48 89 DF | mov     rdi, rbx\n0x0047EB5E | E8 11 EA FF FF | call    sub_47D574\n0x0047EB63 | 48 89 DF | mov     rdi, rbx\n0x0047EB66 | E8 46 EC FF FF | call    sub_47D7B1\n0x0047EB6B | E9 5A FF FF FF | jmp     loc_47EACA\n0x0047EB70 | BE 38 45 72 17 | mov     esi, 17724538h\n0x0047EB75 | 48 89 DF | mov     rdi, rbx\n0x0047EB78 | E8 A9 E9 FF FF | call    sub_47D526\n0x0047EB7D | BA 50 00 00 00 | mov     edx, 50h ; 'P'\n0x0047EB82 | BE 08 00 00 00 | mov     esi, 8\n0x0047EB87 | 48 89 DF | mov     rdi, rbx\n0x0047EB8A | E8 54 E9 FF FF | call    sub_47D4E3\n0x0047EB8F | BA 90 00 00 00 | mov     edx, 90h\n0x0047EB94 | BE 08 00 00 00 | mov     esi, 8\n0x0047EB99 | 48 89 DF | mov     rdi, rbx\n0x0047EB9C | E8 42 E9 FF FF | call    sub_47D4E3\n0x0047EBA1 | 8B 73 7C | mov     esi, [rbx+7Ch]\n0x0047EBA4 | 48 89 DF | mov     rdi, rbx\n0x0047EBA7 | E8 7A E9 FF FF | call    sub_47D526\n0x0047EBAC | 48 89 DF | mov     rdi, rbx\n0x0047EBAF | E8 04 E9 FF FF | call    sub_47D4B8\n0x0047EBB4 | E9 19 FF FF FF | jmp     loc_47EAD2",
        "output": "```c\nvoid function(void* rdi, int esi) {\n    push rbp;\n    push rbx;\n    sub rsp, 8;\n    rbx = rdi;\n    ebp = esi;\n    \n    if (*(int*)(rdi + 0x60) > 0) {\n        edx = *(int*)(rdi + 0x78);\n        edx = ~edx;\n        *(int*)(rdi + 0x78) = edx;\n        eax = *(int*)(rdi + 0x7C);\n        eax = (eax << 1) ^ edx;\n        *(int*)(rdi + 0x7C) = eax;\n    }\n    \n    if (*(int*)(rdi + 0x80) > 1) {\n        *(int*)(rdi + 0x68) = 0;\n        sub_47E9A2(rbx);\n    }\n    \n    rax = (int64_t)*(int*)(rbx + 0x60);\n    rax += *(int*)(rbx + 0x20);\n    *(int*)(rbx + 0x48) = rax;\n    \n    if (*(int*)(rbx + 0x80) == 1) {\n        *(int*)(rbx + 0x74) = 0;\n        *(int*)(rbx + 0x70) = 0;\n        eax = *(int*)(rbx + 0x84);\n        esi = eax + 0x425A6830;\n        sub_47D526(rbx);\n        goto loc_47EAC4;\n    }\n    \n    if (*(int*)(rbx + 0x60) <= 0) {\n        if (ebp != 0) {\n            goto loc_47EB70;\n        }\n        add rsp, 8;\n        pop rbx;\n        pop rbp;\n        retn;\n    }\n    \n    *(int*)(rbx + 0x74) = 0;\n    *(int*)(rbx + 0x70) = 0;\n    edx = *(int*)(rbx + 0x78);\n    sub_47D526(rbx);\n    \n    edx = 0;\n    esi = 1;\n    sub_47D4E3(rbx);\n    \n    edx = 0x53;\n    esi = 8;\n    sub_47D4E3(rbx);\n    \n    edx = 0x59;\n    esi = 8;\n    sub_47D4E3(rbx);\n    \n    edx = *(int*)(rbx + 0x10);\n    esi = 0x18;\n    sub_47D4E3(rbx);\n    \n    sub_47D574(rbx);\n    sub_47D7B1(rbx);\n    goto loc_47EACA;\n    \nloc_47EB70:\n    esi = 0x17724538;\n    sub_47D526(rbx);\n    \n    edx = 0x50;\n    esi = 8;\n    sub_47D4E3(rbx);\n    \n    edx = 0x90;\n    esi = 8;\n    sub_47D4E3(rbx);\n    \n    edx = *(int*)(rbx + 0x7C);\n    sub_47D526(rbx);\n    sub_47D4B8(rbx);\n    \nloc_47EAD2:\n    add rsp, 8;\n    pop rbx;\n    pop rbp;\n    retn;\n}\n```"
    },
    {
        "func_name": "ll_addr_n2a",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043E4D3 | 41 57 | push    r15\n0x0043E4D5 | 41 56 | push    r14\n0x0043E4D7 | 41 55 | push    r13\n0x0043E4D9 | 41 54 | push    r12\n0x0043E4DB | 55 | push    rbp\n0x0043E4DC | 53 | push    rbx\n0x0043E4DD | 48 83 EC 08 | sub     rsp, 8\n0x0043E4E1 | 49 89 FF | mov     r15, rdi\n0x0043E4E4 | 41 89 F5 | mov     r13d, esi\n0x0043E4E7 | 49 89 CE | mov     r14, rcx\n0x0043E4EA | 44 89 C5 | mov     ebp, r8d\n0x0043E4ED | 83 FE 04 | cmp     esi, 4\n0x0043E4F0 | 74 11 | jz      short loc_43E503\n0x0043E4F2 | BB 00 00 00 00 | mov     ebx, 0\n0x0043E4F7 | 41 BC 00 00 00 00 | mov     r12d, 0\n0x0043E4FD | 85 F6 | test    esi, esi\n0x0043E4FF | 7F 74 | jg      short loc_43E575\n0x0043E501 | EB 34 | jmp     short loc_43E537\n0x0043E503 | 89 D0 | mov     eax, edx\n0x0043E505 | 83 E0 F7 | and     eax, 0FFFFFFF7h\n0x0043E508 | 3D 00 03 00 00 | cmp     eax, 300h\n0x0043E50D | 74 13 | jz      short loc_43E522\n0x0043E50F | BB 00 00 00 00 | mov     ebx, 0\n0x0043E514 | 41 BC 00 00 00 00 | mov     r12d, 0\n0x0043E51A | 81 FA 0A 03 00 00 | cmp     edx, 30Ah\n0x0043E520 | 75 53 | jnz     short loc_43E575\n0x0043E522 | 89 E9 | mov     ecx, ebp; len\n0x0043E524 | 4C 89 F2 | mov     rdx, r14; buf\n0x0043E527 | 4C 89 FE | mov     rsi, r15; cp\n0x0043E52A | BF 02 00 00 00 | mov     edi, 2; af\n0x0043E52F | E8 BC 7C FC FF | call    _inet_ntop\n0x0043E534 | 49 89 C6 | mov     r14, rax\n0x0043E537 | 4C 89 F0 | mov     rax, r14\n0x0043E53A | 48 83 C4 08 | add     rsp, 8\n0x0043E53E | 5B | pop     rbx\n0x0043E53F | 5D | pop     rbp\n0x0043E540 | 41 5C | pop     r12\n0x0043E542 | 41 5D | pop     r13\n0x0043E544 | 41 5E | pop     r14\n0x0043E546 | 41 5F | pop     r15\n0x0043E548 | C3 | retn\n0x0043E549 | 41 0F B6 0F | movzx   ecx, byte ptr [r15]\n0x0043E54D | 48 63 F5 | movsxd  rsi, ebp; maxlen\n0x0043E550 | 49 63 FC | movsxd  rdi, r12d\n0x0043E553 | 4C 01 F7 | add     rdi, r14; s\n0x0043E556 | BA EC 2C 4E 00 | mov     edx, offset a02x_0; \"%02x\"\n0x0043E55B | B8 00 00 00 00 | mov     eax, 0\n0x0043E560 | E8 4B 82 FC FF | call    _snprintf\n0x0043E565 | 83 ED 02 | sub     ebp, 2\n0x0043E568 | 41 83 C4 02 | add     r12d, 2\n0x0043E56C | 48 83 C3 01 | add     rbx, 1\n0x0043E570 | 41 39 DD | cmp     r13d, ebx\n0x0043E573 | 7E C2 | jle     short loc_43E537\n0x0043E575 | 85 DB | test    ebx, ebx\n0x0043E577 | 74 D0 | jz      short loc_43E549\n0x0043E579 | 41 0F B6 0C 1F | movzx   ecx, byte ptr [r15+rbx]\n0x0043E57E | 48 63 F5 | movsxd  rsi, ebp; maxlen\n0x0043E581 | 49 63 FC | movsxd  rdi, r12d\n0x0043E584 | 4C 01 F7 | add     rdi, r14; s\n0x0043E587 | BA EB 2C 4E 00 | mov     edx, offset asc_4E2CEB; \":\"\n0x0043E58C | B8 00 00 00 00 | mov     eax, 0\n0x0043E591 | E8 1A 82 FC FF | call    _snprintf\n0x0043E596 | 83 ED 03 | sub     ebp, 3\n0x0043E599 | 41 83 C4 03 | add     r12d, 3\n0x0043E59D | EB CD | jmp     short loc_43E56C",
        "output": "```c\nvoid function(char* s, int len) {\n    int i;\n    char buf[16];\n    \n    for (i = 0; i < len; i++) {\n        if (i % 2 == 0) {\n            snprintf(buf, sizeof(buf), \"%02x\", s[i]);\n        } else {\n            snprintf(buf, sizeof(buf), \":%02x\", s[i]);\n        }\n        printf(\"%s\", buf);\n    }\n}\n```"
    },
    {
        "func_name": "sendping4",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0042FAC1 | 53 | push    rbx\n0x0042FAC2 | 48 8B 1D FF B8 2D 00 | mov     rbx, qword ptr cs:stru_70B398.c_cc+1Fh\n0x0042FAC9 | C6 03 08 | mov     byte ptr [rbx], 8\n0x0042FACC | 66 C7 43 02 00 00 | mov     word ptr [rbx+2], 0\n0x0042FAD2 | 0F B7 05 A7 B8 2D 00 | movzx   eax, word ptr cs:dest.c_cc+17h\n0x0042FAD9 | 66 C1 C8 08 | ror     ax, 8\n0x0042FADD | 66 89 43 06 | mov     [rbx+6], ax\n0x0042FAE1 | 0F B7 05 B0 B8 2D 00 | movzx   eax, word ptr cs:stru_70B398.c_iflag\n0x0042FAE8 | 66 89 43 04 | mov     [rbx+4], ax\n0x0042FAEC | E8 01 AA FD FF | call    sub_40A4F2\n0x0042FAF1 | 89 43 08 | mov     [rbx+8], eax\n0x0042FAF4 | 8B 05 76 B8 2D 00 | mov     eax, dword ptr cs:dest.c_cc+7\n0x0042FAFA | 8D 70 08 | lea     esi, [rax+8]\n0x0042FAFD | 48 89 DF | mov     rdi, rbx\n0x0042FB00 | E8 C8 6C 08 00 | call    sub_4B67CD\n0x0042FB05 | 66 89 43 02 | mov     [rbx+2], ax\n0x0042FB09 | BE 08 00 00 00 | mov     esi, 8\n0x0042FB0E | BF C1 FA 42 00 | mov     edi, offset sub_42FAC1; handler\n0x0042FB13 | E8 2D FD FF FF | call    sub_42F845\n0x0042FB18 | 5B | pop     rbx\n0x0042FB19 | C3 | retn",
        "output": "```c\nvoid function() {\n    // push rbx\n    // mov rbx, qword ptr cs:stru_70B398.c_cc+1Fh\n    rbx = *(stru_70B398.c_cc + 0x1F);\n    \n    // mov byte ptr [rbx], 8\n    *(rbx) = 8;\n    \n    // mov word ptr [rbx+2], 0\n    *(rbx + 2) = 0;\n    \n    // movzx eax, word ptr cs:dest.c_cc+17h\n    eax = (unsigned short)*(dest.c_cc + 0x17);\n    \n    // ror ax, 8\n    ax = (ax >> 8) | (ax << (16 - 8));\n    \n    // mov [rbx+6], ax\n    *(rbx + 6) = ax;\n    \n    // movzx eax, word ptr cs:stru_70B398.c_iflag\n    eax = (unsigned short)*(stru_70B398.c_iflag);\n    \n    // mov [rbx+4], ax\n    *(rbx + 4) = ax;\n    \n    // call sub_40A4F2\n    eax = sub_40A4F2();\n    \n    // mov [rbx+8], eax\n    *(rbx + 8) = eax;\n    \n    // mov eax, dword ptr cs:dest.c_cc+7\n    eax = *(dest.c_cc + 0x7);\n    \n    // lea esi, [rax+8]\n    esi = eax + 8;\n    \n    // mov rdi, rbx\n    rdi = rbx;\n    \n    // call sub_4B67CD\n    sub_4B67CD();\n    \n    // mov [rbx+2], ax\n    *(rbx + 2) = ax;\n    \n    // mov esi, 8\n    esi = 8;\n    \n    // mov edi, offset sub_42FAC1; handler\n    edi = &sub_42FAC1;\n    \n    // call sub_42F845\n    sub_42F845();\n    \n    // pop rbx\n    // retn\n}\n```"
    },
    {
        "func_name": "bb_strtoll",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040A61A | 53 | push    rbx\n0x0040A61B | 48 83 EC 10 | sub     rsp, 10h\n0x0040A61F | 48 89 F3 | mov     rbx, rsi\n0x0040A622 | 48 8D 44 24 08 | lea     rax, [rsp+18h+endptr]\n0x0040A627 | 48 85 F6 | test    rsi, rsi\n0x0040A62A | 48 0F 44 D8 | cmovz   rbx, rax\n0x0040A62E | 48 89 3B | mov     [rbx], rdi\n0x0040A631 | 0F B6 07 | movzx   eax, byte ptr [rdi]\n0x0040A634 | 3C 2D | cmp     al, 2Dh ; '-'\n0x0040A636 | 74 38 | jz      short loc_40A670\n0x0040A638 | 8D 48 D0 | lea     ecx, [rax-30h]\n0x0040A63B | 80 F9 09 | cmp     cl, 9\n0x0040A63E | 76 0A | jbe     short loc_40A64A\n0x0040A640 | 83 C8 20 | or      eax, 20h\n0x0040A643 | 83 E8 61 | sub     eax, 61h ; 'a'\n0x0040A646 | 3C 19 | cmp     al, 19h\n0x0040A648 | 77 2C | ja      short loc_40A676\n0x0040A64A | 48 8B 05 0F 2D 30 00 | mov     rax, cs:qword_70D360\n0x0040A651 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0\n0x0040A657 | 48 89 DE | mov     rsi, rbx; endptr\n0x0040A65A | E8 F1 C5 FF FF | call    _strtoll\n0x0040A65F | 48 89 DE | mov     rsi, rbx\n0x0040A662 | 48 89 C7 | mov     rdi, rax\n0x0040A665 | E8 00 FF FF FF | call    sub_40A56A\n0x0040A66A | 48 83 C4 10 | add     rsp, 10h\n0x0040A66E | 5B | pop     rbx\n0x0040A66F | C3 | retn\n0x0040A670 | 0F B6 47 01 | movzx   eax, byte ptr [rdi+1]\n0x0040A674 | EB C2 | jmp     short loc_40A638\n0x0040A676 | 48 8B 05 E3 2C 30 00 | mov     rax, cs:qword_70D360\n0x0040A67D | C7 00 22 00 00 00 | mov     dword ptr [rax], 22h ; '\"'\n0x0040A683 | 48 C7 C0 FF FF FF FF | mov     rax, 0FFFFFFFFFFFFFFFFh\n0x0040A68A | EB DE | jmp     short loc_40A66A",
        "output": "```c\nvoid function(char* endptr, char* str, int len) {\n    char* rbx;\n    rbx = str;\n    if (str == NULL) {\n        rbx = endptr;\n    }\n    *rbx = len;\n    if (*str == '-') {\n        int ecx = *str - '0';\n        if (ecx <= 9) {\n            len |= 0x20;\n            len -= 'a';\n            if (len <= 0x19) {\n                *(long long*)0x70D360 = 0;\n                endptr = rbx;\n                long long result = strtoll(endptr, &endptr);\n                rbx = endptr;\n                sub_40A56A(result, rbx);\n            }\n        }\n    }\n    else {\n        *(long long*)0x70D360 = 0x22;\n        rbx = -1;\n    }\n    return;\n}\n```"
    },
    {
        "func_name": "add_server_options",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0044173F | 55 | push    rbp\n0x00441740 | 53 | push    rbx\n0x00441741 | 48 83 EC 08 | sub     rsp, 8\n0x00441745 | 48 89 FD | mov     rbp, rdi\n0x00441748 | 48 8B 1D 21 9C 2C 00 | mov     rbx, qword ptr cs:dest.c_cc+7\n0x0044174F | 48 85 DB | test    rbx, rbx\n0x00441752 | 75 55 | jnz     short loc_4417A9\n0x00441754 | 8B 05 42 9C 2C 00 | mov     eax, cs:stru_70B398.c_oflag\n0x0044175A | 89 45 14 | mov     [rbp+14h], eax\n0x0044175D | 48 8B 35 54 9C 2C 00 | mov     rsi, qword ptr cs:stru_70B398.c_cc+0Fh; src\n0x00441764 | 48 85 F6 | test    rsi, rsi\n0x00441767 | 74 0E | jz      short loc_441777\n0x00441769 | 48 8D 7D 2C | lea     rdi, [rbp+2Ch]; dest\n0x0044176D | BA 3F 00 00 00 | mov     edx, 3Fh ; '?'; n\n0x00441772 | E8 D9 4B FC FF | call    _strncpy\n0x00441777 | 48 8B 35 42 9C 2C 00 | mov     rsi, qword ptr cs:stru_70B398.c_cc+17h; src\n0x0044177E | 48 85 F6 | test    rsi, rsi\n0x00441781 | 74 0E | jz      short loc_441791\n0x00441783 | 48 8D 7D 6C | lea     rdi, [rbp+6Ch]; dest\n0x00441787 | BA 7F 00 00 00 | mov     edx, 7Fh; n\n0x0044178C | E8 BF 4B FC FF | call    _strncpy\n0x00441791 | 48 83 C4 08 | add     rsp, 8\n0x00441795 | 5B | pop     rbx\n0x00441796 | 5D | pop     rbp\n0x00441797 | C3 | retn\n0x00441798 | 48 89 EF | mov     rdi, rbp\n0x0044179B | E8 C5 2B 00 00 | call    sub_444365\n0x004417A0 | 48 8B 5B 08 | mov     rbx, [rbx+8]\n0x004417A4 | 48 85 DB | test    rbx, rbx\n0x004417A7 | 74 AB | jz      short loc_441754\n0x004417A9 | 48 8B 33 | mov     rsi, [rbx]\n0x004417AC | 80 3E 33 | cmp     byte ptr [rsi], 33h ; '3'\n0x004417AF | 74 EF | jz      short loc_4417A0\n0x004417B1 | EB E5 | jmp     short loc_441798",
        "output": "```c\nvoid function(void* dest, void* src) {\n    push rbp;\n    push rbx;\n    sub rsp, 8;\n    mov rbp, rdi;\n    mov rbx, qword ptr cs:dest.c_cc+7;\n    test rbx, rbx;\n    jnz short loc_4417A9;\n    mov eax, cs:stru_70B398.c_oflag;\n    mov [rbp+14h], eax;\n    mov rsi, qword ptr cs:stru_70B398.c_cc+0Fh; src\n    test rsi, rsi;\n    jz short loc_441777;\n    lea rdi, [rbp+2Ch]; dest\n    mov edx, 3Fh ; '?'; n\n    call _strncpy;\n    mov rsi, qword ptr cs:stru_70B398.c_cc+17h; src\n    test rsi, rsi;\n    jz short loc_441791;\n    lea rdi, [rbp+6Ch]; dest\n    mov edx, 7Fh; n\n    call _strncpy;\n    add rsp, 8;\n    pop rbx;\n    pop rbp;\n    retn;\n    mov rdi, rbp;\n    call sub_444365;\n    mov rbx, [rbx+8];\n    test rbx, rbx;\n    jz short loc_441754;\n    mov rsi, [rbx];\n    cmp byte ptr [rsi], 33h ; '3'\n    jz short loc_4417A0;\n    jmp short loc_441798;\n}\n```"
    },
    {
        "func_name": "start_bunzip",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0048601D | 41 55 | push    r13\n0x0048601F | 41 54 | push    r12\n0x00486021 | 55 | push    rbp\n0x00486022 | 53 | push    rbx\n0x00486023 | 48 83 EC 18 | sub     rsp, 18h\n0x00486027 | 49 89 FC | mov     r12, rdi\n0x0048602A | 89 F3 | mov     ebx, esi\n0x0048602C | 49 89 D5 | mov     r13, rdx\n0x0048602F | 89 CD | mov     ebp, ecx\n0x00486031 | 83 FE FF | cmp     esi, 0FFFFFFFFh\n0x00486034 | BF 50 A1 00 00 | mov     edi, 0A150h\n0x00486039 | B8 50 B1 00 00 | mov     eax, 0B150h\n0x0048603E | 0F 45 F8 | cmovnz  edi, eax\n0x00486041 | 89 FF | mov     edi, edi; n\n0x00486043 | E8 EB 31 F8 FF | call    sub_409233\n0x00486048 | 48 89 44 24 08 | mov     [rsp+38h+ptr], rax\n0x0048604D | 49 89 04 24 | mov     [r12], rax\n0x00486051 | 89 58 08 | mov     [rax+8], ebx\n0x00486054 | 83 FB FF | cmp     ebx, 0FFFFFFFFh\n0x00486057 | 75 41 | jnz     short loc_48609A\n0x00486059 | 4C 89 68 18 | mov     [rax+18h], r13\n0x0048605D | 48 8B 44 24 08 | mov     rax, [rsp+38h+ptr]\n0x00486062 | 89 68 10 | mov     [rax+10h], ebp\n0x00486065 | 48 89 C5 | mov     rbp, rax\n0x00486068 | 48 8D B8 18 01 00 00 | lea     rdi, [rax+118h]\n0x0048606F | BE 01 00 00 00 | mov     esi, 1\n0x00486074 | E8 4B C9 02 00 | call    sub_4B29C4\n0x00486079 | 48 89 6C 24 08 | mov     [rsp+38h+ptr], rbp\n0x0048607E | 48 8D 7D 50 | lea     rdi, [rbp+50h]; env\n0x00486082 | E8 B9 0A F8 FF | call    __setjmp\n0x00486087 | 89 C3 | mov     ebx, eax\n0x00486089 | 85 C0 | test    eax, eax\n0x0048608B | 74 2A | jz      short loc_4860B7\n0x0048608D | 89 D8 | mov     eax, ebx\n0x0048608F | 48 83 C4 18 | add     rsp, 18h\n0x00486093 | 5B | pop     rbx\n0x00486094 | 5D | pop     rbp\n0x00486095 | 41 5C | pop     r12\n0x00486097 | 41 5D | pop     r13\n0x00486099 | C3 | retn\n0x0048609A | 48 8B 44 24 08 | mov     rax, [rsp+38h+ptr]\n0x0048609F | 48 8D B8 50 A1 00 00 | lea     rdi, [rax+0A150h]; dest\n0x004860A6 | 48 89 78 18 | mov     [rax+18h], rdi\n0x004860AA | 48 63 D5 | movsxd  rdx, ebp; n\n0x004860AD | 4C 89 EE | mov     rsi, r13; src\n0x004860B0 | E8 9B 0C F8 FF | call    _memcpy\n0x004860B5 | EB A6 | jmp     short loc_48605D\n0x004860B7 | BE 10 00 00 00 | mov     esi, 10h\n0x004860BC | 48 8B 6C 24 08 | mov     rbp, [rsp+38h+ptr]\n0x004860C1 | 48 89 EF | mov     rdi, rbp\n0x004860C4 | E8 18 F5 FF FF | call    sub_4855E1\n0x004860C9 | 8D 90 CF 97 FF FF | lea     edx, [rax-6831h]\n0x004860CF | 83 FA 08 | cmp     edx, 8\n0x004860D2 | 77 35 | ja      short loc_486109\n0x004860D4 | 69 C0 A0 86 01 00 | imul    eax, 186A0h\n0x004860DA | 05 00 C2 05 61 | add     eax, 6105C200h\n0x004860DF | 89 45 48 | mov     [rbp+48h], eax\n0x004860E2 | 89 C0 | mov     eax, eax\n0x004860E4 | 48 8D 3C 85 00 00 00 00 | lea     rdi, ds:0[rax*4]\n0x004860EC | E8 CE 30 F8 FF | call    sub_4091BF\n0x004860F1 | 48 89 45 40 | mov     [rbp+40h], rax\n0x004860F5 | 48 85 C0 | test    rax, rax\n0x004860F8 | 75 93 | jnz     short loc_48608D\n0x004860FA | 48 8B 7C 24 08 | mov     rdi, [rsp+38h+ptr]; ptr\n0x004860FF | E8 4C 01 F8 FF | call    _free\n0x00486104 | E8 DF 2B F8 FF | call    sub_408CE8\n0x00486109 | BB FE FF FF FF | mov     ebx, 0FFFFFFFEh\n0x0048610E | E9 7A FF FF FF | jmp     loc_48608D",
        "output": "```c\nvoid function(int esi, int edi, int ecx) {\n    int ebx, ebp;\n    int r12, r13;\n    \n    push r13;\n    push r12;\n    push rbp;\n    push rbx;\n    sub rsp, 0x18;\n    \n    r12 = edi;\n    ebx = esi;\n    r13 = edx;\n    ebp = ecx;\n    \n    if (esi != 0xFFFFFFFF) {\n        edi = 0xA150;\n    } else {\n        edi = 0xB150;\n    }\n    \n    edi = edi;\n    sub_409233();\n    \n    rax = [rsp+0x38];\n    [r12] = rax;\n    [rax+8] = ebx;\n    \n    if (ebx != 0xFFFFFFFF) {\n        [rax+0x18] = r13;\n    }\n    \n    rax = [rsp+0x38];\n    [rax+0x10] = ebp;\n    rbp = rax;\n    \n    rdi = rax + 0x118;\n    esi = 1;\n    sub_4B29C4();\n    \n    rax = [rsp+0x38];\n    rbp = rax;\n    \n    rdi = rbp + 0x50;\n    __setjmp();\n    \n    ebx = eax;\n    \n    if (eax == 0) {\n        eax = ebx;\n        add rsp, 0x18;\n        pop rbx;\n        pop rbp;\n        pop r12;\n        pop r13;\n        return;\n    }\n    \n    esi = 0x10;\n    rbp = [rsp+0x38];\n    rdi = rbp;\n    sub_4855E1();\n    \n    edx = rax - 0x6831;\n    \n    if (edx > 8) {\n        goto loc_486109;\n    }\n    \n    eax = eax * 0x186A0;\n    eax = eax + 0x6105C200;\n    [rbp+0x48] = eax;\n    \n    rdi = rax * 4;\n    sub_4091BF();\n    \n    [rbp+0x40] = rax;\n    \n    if (rax == 0) {\n        rdi = [rsp+0x38];\n        _free();\n        sub_408CE8();\n        ebx = 0xFFFFFFFE;\n        goto loc_48608D;\n    }\n    \nloc_486109:\n    ebx = 0xFFFFFFFE;\n    \nloc_48608D:\n    rdi = [rsp+0x38];\n    _free();\n    sub_408CE8();\n    ebx = 0xFFFFFFFE;\n    \nloc_48608D:\n    eax = ebx;\n    add rsp, 0x18;\n    pop rbx;\n    pop rbp;\n    pop r12;\n    pop r13;\n    return;\n}\n```"
    },
    {
        "func_name": "setlogcons_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0048DCC7 | 48 83 EC 18 | sub     rsp, 18h\n0x0048DCCB | C6 44 24 0E 0B | mov     [rsp+18h+var_A], 0Bh\n0x0048DCD0 | C6 44 24 0F 00 | mov     [rsp+18h+var_9], 0\n0x0048DCD5 | 48 8B 7E 08 | mov     rdi, [rsi+8]\n0x0048DCD9 | 48 85 FF | test    rdi, rdi\n0x0048DCDC | 74 13 | jz      short loc_48DCF1\n0x0048DCDE | BA 3F 00 00 00 | mov     edx, 3Fh ; '?'\n0x0048DCE3 | BE 00 00 00 00 | mov     esi, 0\n0x0048DCE8 | E8 C1 25 03 00 | call    sub_4C02AE\n0x0048DCED | 88 44 24 0F | mov     [rsp+18h+var_9], al\n0x0048DCF1 | BE 00 00 00 00 | mov     esi, 0\n0x0048DCF6 | BF E8 79 4E 00 | mov     edi, offset aDevTty1; \"/dev/tty1\"\n0x0048DCFB | E8 2C B6 F7 FF | call    sub_40932C\n0x0048DD00 | B9 F2 79 4E 00 | mov     ecx, offset aTioclinux; \"TIOCLINUX\"\n0x0048DD05 | 48 8D 54 24 0E | lea     rdx, [rsp+18h+var_A]\n0x0048DD0A | BE 1C 54 00 00 | mov     esi, 541Ch\n0x0048DD0F | 89 C7 | mov     edi, eax\n0x0048DD11 | E8 7B BD F7 FF | call    sub_409A91\n0x0048DD16 | B8 00 00 00 00 | mov     eax, 0\n0x0048DD1B | 48 83 C4 18 | add     rsp, 18h\n0x0048DD1F | C3 | retn",
        "output": "```c\nvoid function() {\n    // sub     rsp, 18h\n    char var_A;\n    char var_9;\n    // mov     [rsp+18h+var_A], 0Bh\n    var_A = 0x0B;\n    // mov     [rsp+18h+var_9], 0\n    var_9 = 0;\n    \n    // mov     rdi, [rsi+8]\n    // test    rdi, rdi\n    if (rsi != NULL) {\n        // jz      short loc_48DCF1\n        // mov     edx, 3Fh ; '?'\n        int edx = 0x3F;\n        // mov     esi, 0\n        int esi = 0;\n        // call    sub_4C02AE\n        sub_4C02AE(edx, esi);\n        // mov     [rsp+18h+var_9], al\n        var_9 = al;\n    }\n    \n    // mov     esi, 0\n    int esi = 0;\n    // mov     edi, offset aDevTty1; \"/dev/tty1\"\n    char* edi = \"/dev/tty1\";\n    // call    sub_40932C\n    sub_40932C(esi, edi);\n    \n    // mov     ecx, offset aTioclinux; \"TIOCLINUX\"\n    char* ecx = \"TIOCLINUX\";\n    // lea     rdx, [rsp+18h+var_A]\n    char* rdx = &var_A;\n    // mov     esi, 541Ch\n    int esi = 0x541C;\n    // mov     edi, eax\n    int edi = eax;\n    // call    sub_409A91\n    sub_409A91(ecx, rdx, esi, edi);\n    \n    // mov     eax, 0\n    eax = 0;\n    // add     rsp, 18h\n    // retn\n}\n```"
    },
    {
        "func_name": "rc_do_normalize",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0048810C | 55 | push    rbp\n0x0048810D | 53 | push    rbx\n0x0048810E | 48 83 EC 08 | sub     rsp, 8\n0x00488112 | 48 89 FB | mov     rbx, rdi\n0x00488115 | 48 8B 47 10 | mov     rax, [rdi+10h]\n0x00488119 | 48 39 47 08 | cmp     [rdi+8], rax\n0x0048811D | 73 25 | jnb     short loc_488144\n0x0048811F | C1 63 1C 08 | shl     dword ptr [rbx+1Ch], 8\n0x00488123 | 8B 53 18 | mov     edx, [rbx+18h]\n0x00488126 | C1 E2 08 | shl     edx, 8\n0x00488129 | 48 8B 43 08 | mov     rax, [rbx+8]\n0x0048812D | 48 8D 48 01 | lea     rcx, [rax+1]\n0x00488131 | 48 89 4B 08 | mov     [rbx+8], rcx\n0x00488135 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00488138 | 09 D0 | or      eax, edx\n0x0048813A | 89 43 18 | mov     [rbx+18h], eax\n0x0048813D | 48 83 C4 08 | add     rsp, 8\n0x00488141 | 5B | pop     rbx\n0x00488142 | 5D | pop     rbp\n0x00488143 | C3 | retn\n0x00488144 | 48 8D 6F 28 | lea     rbp, [rdi+28h]\n0x00488148 | BA 00 00 01 00 | mov     edx, 10000h; nbytes\n0x0048814D | 48 89 EE | mov     rsi, rbp; buf\n0x00488150 | 8B 3F | mov     edi, [rdi]; fd\n0x00488152 | E8 CE 1D F8 FF | call    sub_409F25\n0x00488157 | 85 C0 | test    eax, eax\n0x00488159 | 7E 11 | jle     short loc_48816C\n0x0048815B | 48 89 6B 08 | mov     [rbx+8], rbp\n0x0048815F | 48 98 | cdqe\n0x00488161 | 48 8D 44 03 28 | lea     rax, [rbx+rax+28h]\n0x00488166 | 48 89 43 10 | mov     [rbx+10h], rax\n0x0048816A | EB B3 | jmp     short loc_48811F\n0x0048816C | BF D9 76 4E 00 | mov     edi, offset aUnexpectedEof; \"unexpected EOF\"\n0x00488171 | B8 00 00 00 00 | mov     eax, 0\n0x00488176 | E8 74 09 F8 FF | call    sub_408AEF",
        "output": "```c\nvoid function(void* rdi) {\n    // Prologue\n    push rbp;\n    push rbx;\n    sub rsp, 8;\n\n    // Save rdi to rbx\n    mov rbx, rdi;\n\n    // Load rax with [rdi+10h]\n    mov rax, [rdi+10h];\n\n    // Compare [rdi+8] with rax\n    cmp [rdi+8], rax;\n\n    // Jump if not below\n    jnb short loc_488144;\n\n    // Shift left dword ptr [rbx+1Ch] by 8\n    shl dword ptr [rbx+1Ch], 8;\n\n    // Load edx with [rbx+18h]\n    mov edx, [rbx+18h];\n\n    // Shift left edx by 8\n    shl edx, 8;\n\n    // Load rax with [rbx+8]\n    mov rax, [rbx+8];\n\n    // Load rcx with rax+1\n    lea rcx, [rax+1];\n\n    // Store rcx to [rbx+8]\n    mov [rbx+8], rcx;\n\n    // Load eax with byte ptr [rax]\n    movzx eax, byte ptr [rax];\n\n    // OR eax with edx\n    or eax, edx;\n\n    // Store eax to [rbx+18h]\n    mov [rbx+18h], eax;\n\n    // Epilogue\n    add rsp, 8;\n    pop rbx;\n    pop rbp;\n    retn;\n\nloc_488144:\n    // Load rbp with [rdi+28h]\n    lea rbp, [rdi+28h];\n\n    // Load edx with 10000h\n    mov edx, 10000h;\n\n    // Load rsi with rbp\n    mov rsi, rbp;\n\n    // Load edi with [rdi]\n    mov edi, [rdi];\n\n    // Call sub_409F25\n    call sub_409F25;\n\n    // Test eax with eax\n    test eax, eax;\n\n    // Jump if less or equal\n    jle short loc_48816C;\n\n    // Store rbp to [rbx+8]\n    mov [rbx+8], rbp;\n\n    // Sign extend rax\n    cdqe;\n\n    // Load rax with rbx+rax+28h\n    lea rax, [rbx+rax+28h];\n\n    // Store rax to [rbx+10h]\n    mov [rbx+10h], rax;\n\n    // Jump to loc_48811F\n    jmp short loc_48811F;\n\nloc_48816C:\n    // Load edi with offset aUnexpectedEof\n    mov edi, offset aUnexpectedEof; \"unexpected EOF\"\n\n    // Load eax with 0\n    mov eax, 0;\n\n    // Call sub_408AEF\n    call sub_408AEF;\n}\n```"
    },
    {
        "func_name": "rdval_loadavg",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00448781 | 48 81 EC D8 00 00 00 | sub     rsp, 0D8h\n0x00448788 | 48 89 54 24 30 | mov     [rsp+0D8h+var_A8], rdx\n0x0044878D | 48 89 4C 24 38 | mov     [rsp+0D8h+var_A0], rcx\n0x00448792 | 4C 89 44 24 40 | mov     [rsp+0D8h+var_98], r8\n0x00448797 | 4C 89 4C 24 48 | mov     [rsp+0D8h+var_90], r9\n0x0044879C | 84 C0 | test    al, al\n0x0044879E | 74 37 | jz      short loc_4487D7\n0x004487A0 | 0F 29 44 24 50 | movaps  [rsp+0D8h+var_88], xmm0\n0x004487A5 | 0F 29 4C 24 60 | movaps  [rsp+0D8h+var_78], xmm1\n0x004487AA | 0F 29 54 24 70 | movaps  [rsp+0D8h+var_68], xmm2\n0x004487AF | 0F 29 9C 24 80 00 00 00 | movaps  [rsp+0D8h+var_58], xmm3\n0x004487B7 | 0F 29 A4 24 90 00 00 00 | movaps  [rsp+0D8h+var_48], xmm4\n0x004487BF | 0F 29 AC 24 A0 00 00 00 | movaps  [rsp+0D8h+var_38], xmm5\n0x004487C7 | 0F 29 B4 24 B0 00 00 00 | movaps  [rsp+0D8h+var_28], xmm6\n0x004487CF | 0F 29 BC 24 C0 00 00 00 | movaps  [rsp+0D8h+var_18], xmm7\n0x004487D7 | C7 44 24 08 10 00 00 00 | mov     [rsp+0D8h+var_D0], 10h\n0x004487DF | C7 44 24 0C 30 00 00 00 | mov     [rsp+0D8h+var_CC], 30h ; '0'\n0x004487E7 | 48 8D 84 24 E0 00 00 00 | lea     rax, [rsp+0D8h+arg_0]\n0x004487EF | 48 89 44 24 10 | mov     [rsp+0D8h+var_C8], rax\n0x004487F4 | 48 8D 44 24 20 | lea     rax, [rsp+0D8h+var_B8]\n0x004487F9 | 48 89 44 24 18 | mov     [rsp+0D8h+var_C0], rax\n0x004487FE | 4C 8D 44 24 08 | lea     r8, [rsp+0D8h+var_D0]\n0x00448803 | 48 89 F1 | mov     rcx, rsi\n0x00448806 | BA 01 00 00 00 | mov     edx, 1\n0x0044880B | BE 81 98 4E 00 | mov     esi, offset buf\n0x00448810 | E8 B4 FC FF FF | call    sub_4484C9\n0x00448815 | 48 81 C4 D8 00 00 00 | add     rsp, 0D8h\n0x0044881C | C3 | retn",
        "output": "```c\nvoid function() {\n    // allocate space on the stack\n    char var_A8[0xD8];\n    char var_A0[0xD8];\n    char var_98[0xD8];\n    char var_90[0xD8];\n    char var_88[0xD8];\n    char var_78[0xD8];\n    char var_68[0xD8];\n    char var_58[0xD8];\n    char var_48[0xD8];\n    char var_38[0xD8];\n    char var_28[0xD8];\n    char var_18[0xD8];\n    char var_D0[0xD8];\n    char var_CC[0xD8];\n    char arg_0[0xD8];\n    char var_C8[0xD8];\n    char var_B8[0xD8];\n    char var_C0[0xD8];\n\n    // check if al is zero\n    if (al == 0) {\n        // jump to loc_4487D7\n        goto loc_4487D7;\n    }\n\n    // move xmm0 to [rsp+0D8h+var_88]\n    movaps [rsp+0xD8+var_88], xmm0;\n    // move xmm1 to [rsp+0D8h+var_78]\n    movaps [rsp+0xD8+var_78], xmm1;\n    // move xmm2 to [rsp+0xD8h+var_68]\n    movaps [rsp+0xD8+var_68], xmm2;\n    // move xmm3 to [rsp+0xD8h+var_58]\n    movaps [rsp+0xD8+var_58], xmm3;\n    // move xmm4 to [rsp+0xD8h+var_48]\n    movaps [rsp+0xD8+var_48], xmm4;\n    // move xmm5 to [rsp+0xD8h+var_38]\n    movaps [rsp+0xD8+var_38], xmm5;\n    // move xmm6 to [rsp+0xD8h+var_28]\n    movaps [rsp+0xD8+var_28], xmm6;\n    // move xmm7 to [rsp+0xD8h+var_18]\n    movaps [rsp+0xD8+var_18], xmm7;\n\n    // move 0x10 to [rsp+0xD8h+var_D0]\n    mov [rsp+0xD8+var_D0], 0x10;\n    // move 0x30 to [rsp+0xD8h+var_CC]\n    mov [rsp+0xD8+var_CC], 0x30;\n\n    // calculate the address of arg_0\n    rax = rsp+0xD8h+arg_0;\n    // move rax to [rsp+0xD8h+var_C8]\n    mov [rsp+0xD8+var_C8], rax;\n\n    // calculate the address of var_B8\n    rax = rsp+0xD8h+var_B8;\n    // move rax to [rsp+0xD8h+var_C0]\n    mov [rsp+0xD8+var_C0], rax;\n\n    // calculate the address of var_D0\n    r8 = rsp+0xD8h+var_D0;\n\n    // move rsi to rcx\n    rcx = rsi;\n    // move 1 to edx\n    edx = 1;\n    // move the address of buf to esi\n    esi = &buf;\n\n    // call sub_4484C9\n    sub_4484C9();\n\n    // deallocate space on the stack\n    add rsp, 0xD8;\n\n    // return\n    return;\n}\n```"
    },
    {
        "func_name": "lspci_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004733A2 | 48 83 EC 08 | sub     rsp, 8\n0x004733A6 | 48 89 F7 | mov     rdi, rsi; argv\n0x004733A9 | BE 48 68 4E 00 | mov     esi, offset aMknv; \"mknv\"\n0x004733AE | B8 00 00 00 00 | mov     eax, 0\n0x004733B3 | E8 60 16 04 00 | call    sub_4B4A18\n0x004733B8 | 41 B9 00 00 00 00 | mov     r9d, 0\n0x004733BE | 41 B8 00 00 00 00 | mov     r8d, 0\n0x004733C4 | B9 00 00 00 00 | mov     ecx, 0\n0x004733C9 | BA 50 31 47 00 | mov     edx, offset sub_473150\n0x004733CE | BE 01 00 00 00 | mov     esi, 1\n0x004733D3 | BF 4D 68 4E 00 | mov     edi, offset aSysBusPciDevic; \"/sys/bus/pci/devices\"\n0x004733D8 | E8 51 A4 04 00 | call    sub_4BD82E\n0x004733DD | B8 00 00 00 00 | mov     eax, 0\n0x004733E2 | 48 83 C4 08 | add     rsp, 8\n0x004733E6 | C3 | retn",
        "output": "```c\nvoid function() {\n    // sub     rsp, 8\n    // mov     rdi, rsi; argv\n    // mov     esi, offset aMknv; \"mknv\"\n    // mov     eax, 0\n    // call    sub_4B4A18\n    // mov     r9d, 0\n    // mov     r8d, 0\n    // mov     ecx, 0\n    // mov     edx, offset sub_473150\n    // mov     esi, 1\n    // mov     edi, offset aSysBusPciDevic; \"/sys/bus/pci/devices\"\n    // call    sub_4BD82E\n    // mov     eax, 0\n    // add     rsp, 8\n    // retn\n}\n```"
    },
    {
        "func_name": "read_block",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0046F20A | 85 FF | test    edi, edi\n0x0046F20C | 74 3E | jz      short loc_46F24C\n0x0046F20E | 41 54 | push    r12\n0x0046F210 | 55 | push    rbp\n0x0046F211 | 53 | push    rbx\n0x0046F212 | 48 89 F3 | mov     rbx, rsi\n0x0046F215 | 89 FD | mov     ebp, edi\n0x0046F217 | 89 FE | mov     esi, edi\n0x0046F219 | C1 E6 0A | shl     esi, 0Ah\n0x0046F21C | 89 F6 | mov     esi, esi\n0x0046F21E | BA 00 00 00 00 | mov     edx, 0\n0x0046F223 | BF 03 00 00 00 | mov     edi, 3\n0x0046F228 | E8 BC A2 F9 FF | call    sub_4094E9\n0x0046F22D | BA 00 04 00 00 | mov     edx, 400h; nbytes\n0x0046F232 | 48 89 DE | mov     rsi, rbx; buf\n0x0046F235 | BF 03 00 00 00 | mov     edi, 3; fd\n0x0046F23A | E8 25 AD F9 FF | call    sub_409F64\n0x0046F23F | 48 3D 00 04 00 00 | cmp     rax, 400h\n0x0046F245 | 75 36 | jnz     short loc_46F27D\n0x0046F247 | 5B | pop     rbx\n0x0046F248 | 5D | pop     rbp\n0x0046F249 | 41 5C | pop     r12\n0x0046F24B | C3 | retn\n0x0046F24C | 48 C7 06 00 00 00 00 | mov     qword ptr [rsi], 0\n0x0046F253 | 48 C7 86 F8 03 00 00 00 00 00 00 | mov     qword ptr [rsi+3F8h], 0\n0x0046F25E | 48 8D 7E 08 | lea     rdi, [rsi+8]\n0x0046F262 | 48 83 E7 F8 | and     rdi, 0FFFFFFFFFFFFFFF8h\n0x0046F266 | 48 29 FE | sub     rsi, rdi\n0x0046F269 | 8D 8E 00 04 00 00 | lea     ecx, [rsi+400h]\n0x0046F26F | C1 E9 03 | shr     ecx, 3\n0x0046F272 | 89 C9 | mov     ecx, ecx\n0x0046F274 | B8 00 00 00 00 | mov     eax, 0\n0x0046F279 | F3 48 AB | rep stosq\n0x0046F27C | C3 | retn\n0x0046F27D | 4C 8B 25 E4 E0 29 00 | mov     r12, cs:qword_70D368\n0x0046F284 | 49 8D 8C 24 A4 15 00 00 | lea     rcx, [r12+15A4h]\n0x0046F28C | 89 EA | mov     edx, ebp\n0x0046F28E | BE B0 81 4E 00 | mov     esi, offset aReadError; \"read error\"\n0x0046F293 | BF 88 91 4D 00 | mov     edi, offset aSBadBlockUInFi; \"%s: bad block %u in file '%s'\\n\"\n0x0046F298 | B8 00 00 00 00 | mov     eax, 0\n0x0046F29D | E8 CE 74 F9 FF | call    _printf\n0x0046F2A2 | 41 C6 44 24 02 01 | mov     byte ptr [r12+2], 1\n0x0046F2A8 | 48 C7 03 00 00 00 00 | mov     qword ptr [rbx], 0\n0x0046F2AF | 48 C7 83 F8 03 00 00 00 00 00 00 | mov     qword ptr [rbx+3F8h], 0\n0x0046F2BA | 48 8D 7B 08 | lea     rdi, [rbx+8]\n0x0046F2BE | 48 83 E7 F8 | and     rdi, 0FFFFFFFFFFFFFFF8h\n0x0046F2C2 | 48 29 FB | sub     rbx, rdi\n0x0046F2C5 | 8D 8B 00 04 00 00 | lea     ecx, [rbx+400h]\n0x0046F2CB | C1 E9 03 | shr     ecx, 3\n0x0046F2CE | 89 C9 | mov     ecx, ecx\n0x0046F2D0 | B8 00 00 00 00 | mov     eax, 0\n0x0046F2D5 | F3 48 AB | rep stosq\n0x0046F2D8 | E9 6A FF FF FF | jmp     loc_46F247",
        "output": "```c\nvoid function(int edi, int esi) {\n    if (edi == 0) {\n        return;\n    }\n    push(r12);\n    push(rbp);\n    push(rbx);\n    rbx = esi;\n    ebp = edi;\n    esi = edi << 10;\n    esi = esi;\n    edx = 0;\n    edi = 3;\n    sub_4094E9();\n    edx = 0x400;\n    rsi = rbx;\n    edi = 3;\n    sub_409F64();\n    if (rax != 0x400) {\n        return;\n    }\n    pop(rbx);\n    pop(rbp);\n    pop(r12);\n    return;\n    loc_46F24C:\n    *(qword ptr [rsi]) = 0;\n    *(qword ptr [rsi+0x3F8]) = 0;\n    rdi = rsi + 8;\n    rdi = rdi & 0xFFFFFFFFFFFFFFF8;\n    rsi = rsi - rdi;\n    ecx = rsi + 0x400;\n    ecx = ecx >> 3;\n    ecx = ecx;\n    eax = 0;\n    rep stosq;\n    return;\n    loc_46F27D:\n    r12 = qword_70D368;\n    rcx = r12 + 0x15A4;\n    edx = ebp;\n    esi = \"read error\";\n    edi = \"%s: bad block %u in file '%s'\\n\";\n    eax = 0;\n    _printf();\n    *(byte ptr [r12+2]) = 1;\n    *(qword ptr [rbx]) = 0;\n    *(qword ptr [rbx+0x3F8]) = 0;\n    rdi = rbx + 8;\n    rdi = rdi & 0xFFFFFFFFFFFFFFF8;\n    rbx = rbx - rdi;\n    ecx = rbx + 0x400;\n    ecx = ecx >> 3;\n    ecx = ecx;\n    eax = 0;\n    rep stosq;\n    jmp loc_46F247;\n}\n```"
    },
    {
        "func_name": "list_devs_in_proc_partititons",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0046D2B8 | 41 54 | push    r12\n0x0046D2BA | 55 | push    rbp\n0x0046D2BB | 53 | push    rbx\n0x0046D2BC | 48 81 EC 80 01 00 00 | sub     rsp, 180h\n0x0046D2C3 | BE 07 90 4E 00 | mov     esi, (offset aNTR+5); \"r\"\n0x0046D2C8 | BF 85 5A 4E 00 | mov     edi, offset aProcPartitions; \"/proc/partitions\"\n0x0046D2CD | E8 7E B9 F9 FF | call    sub_408C50\n0x0046D2D2 | 48 89 C3 | mov     rbx, rax\n0x0046D2D5 | EB 3B | jmp     short loc_46D312\n0x0046D2D7 | 48 89 E2 | mov     rdx, rsp\n0x0046D2DA | BE 01 03 00 00 | mov     esi, 301h; request\n0x0046D2DF | 89 C7 | mov     edi, eax; fd\n0x0046D2E1 | B8 00 00 00 00 | mov     eax, 0\n0x0046D2E6 | E8 55 96 F9 FF | call    _ioctl\n0x0046D2EB | 41 89 C4 | mov     r12d, eax\n0x0046D2EE | 89 EF | mov     edi, ebp; fd\n0x0046D2F0 | E8 BB 96 F9 FF | call    _close\n0x0046D2F5 | 45 85 E4 | test    r12d, r12d\n0x0046D2F8 | 0F 85 A0 00 00 00 | jnz     loc_46D39E\n0x0046D2FE | 48 83 7C 24 08 00 | cmp     [rsp+198h+var_190], 0\n0x0046D304 | 0F 94 C0 | setz    al\n0x0046D307 | 0F B6 C0 | movzx   eax, al\n0x0046D30A | 85 C0 | test    eax, eax\n0x0046D30C | 0F 85 C8 00 00 00 | jnz     loc_46D3DA\n0x0046D312 | 48 89 DA | mov     rdx, rbx; stream\n0x0046D315 | BE 64 00 00 00 | mov     esi, 64h ; 'd'; n\n0x0046D31A | 48 8D BC 24 10 01 00 00 | lea     rdi, [rsp+198h+s]; s\n0x0046D322 | E8 79 9B F9 FF | call    _fgets_unlocked\n0x0046D327 | 48 85 C0 | test    rax, rax\n0x0046D32A | 0F 84 BE 00 00 00 | jz      loc_46D3EE\n0x0046D330 | 4C 8D 8C 24 A0 00 00 00 | lea     r9, [rsp+198h+var_F8]\n0x0046D338 | 4C 8D 44 24 14 | lea     r8, [rsp+198h+var_184]\n0x0046D33D | 48 8D 4C 24 18 | lea     rcx, [rsp+198h+var_180]\n0x0046D342 | 48 8D 54 24 1C | lea     rdx, [rsp+198h+var_17C]\n0x0046D347 | BE 96 5A 4E 00 | mov     esi, offset aUUU_0; \" %u %u %u %[^\\n ]\"\n0x0046D34C | 48 8D BC 24 10 01 00 00 | lea     rdi, [rsp+198h+s]; s\n0x0046D354 | B8 00 00 00 00 | mov     eax, 0\n0x0046D359 | E8 A2 9C F9 FF | call    _sscanf\n0x0046D35E | 83 F8 04 | cmp     eax, 4\n0x0046D361 | 75 AF | jnz     short loc_46D312\n0x0046D363 | 48 8D 94 24 A0 00 00 00 | lea     rdx, [rsp+198h+var_F8]\n0x0046D36B | BE 9A DD 4D 00 | mov     esi, offset aDevS; \"/dev/%s\"\n0x0046D370 | 48 8D 7C 24 20 | lea     rdi, [rsp+198h+file]; s\n0x0046D375 | B8 00 00 00 00 | mov     eax, 0\n0x0046D37A | E8 21 A2 F9 FF | call    _sprintf\n0x0046D37F | BE 00 00 00 00 | mov     esi, 0; oflag\n0x0046D384 | 48 8D 7C 24 20 | lea     rdi, [rsp+198h+file]; file\n0x0046D389 | B8 00 00 00 00 | mov     eax, 0\n0x0046D38E | E8 8D 9E F9 FF | call    _open64\n0x0046D393 | 89 C5 | mov     ebp, eax\n0x0046D395 | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x0046D398 | 0F 85 39 FF FF FF | jnz     loc_46D2D7\n0x0046D39E | 48 8D 7C 24 20 | lea     rdi, [rsp+198h+file]\n0x0046D3A3 | 48 C7 C1 FF FF FF FF | mov     rcx, 0FFFFFFFFFFFFFFFFh\n0x0046D3AA | B8 00 00 00 00 | mov     eax, 0\n0x0046D3AF | F2 AE | repne scasb\n0x0046D3B1 | 48 89 CE | mov     rsi, rcx\n0x0046D3B4 | 48 F7 D6 | not     rsi\n0x0046D3B7 | 48 89 F1 | mov     rcx, rsi\n0x0046D3BA | 48 83 E9 01 | sub     rcx, 1\n0x0046D3BE | 85 C9 | test    ecx, ecx\n0x0046D3C0 | 74 18 | jz      short loc_46D3DA\n0x0046D3C2 | 8D 41 FF | lea     eax, [rcx-1]\n0x0046D3C5 | 0F B6 44 04 20 | movzx   eax, [rsp+rax+198h+file]\n0x0046D3CA | 83 E8 30 | sub     eax, 30h ; '0'\n0x0046D3CD | 3C 09 | cmp     al, 9\n0x0046D3CF | 0F 97 C0 | setnbe  al\n0x0046D3D2 | 0F B6 C0 | movzx   eax, al\n0x0046D3D5 | E9 30 FF FF FF | jmp     loc_46D30A\n0x0046D3DA | BE 00 00 00 00 | mov     esi, 0\n0x0046D3DF | 48 8D 7C 24 20 | lea     rdi, [rsp+198h+file]\n0x0046D3E4 | E8 D9 FC FF FF | call    sub_46D0C2\n0x0046D3E9 | E9 24 FF FF FF | jmp     loc_46D312\n0x0046D3EE | 48 81 C4 80 01 00 00 | add     rsp, 180h\n0x0046D3F5 | 5B | pop     rbx\n0x0046D3F6 | 5D | pop     rbp\n0x0046D3F7 | 41 5C | pop     r12\n0x0046D3F9 | C3 | retn",
        "output": "```c\nvoid function() {\n    // Prologue\n    push    r12\n    push    rbp\n    push    rbx\n    sub     rsp, 180h\n\n    // Set up arguments for sub_408C50\n    mov     esi, (offset aNTR+5); \"r\"\n    mov     edi, offset aProcPartitions; \"/proc/partitions\"\n    call    sub_408C50\n    mov     rbx, rax\n\n    jmp     short loc_46D312\n\nloc_46D2D7:\n    // Set up arguments for _ioctl\n    mov     rdx, rsp\n    mov     esi, 301h; request\n    mov     edi, eax; fd\n    mov     eax, 0\n    call    _ioctl\n    mov     r12d, eax\n\n    // Set up arguments for _close\n    mov     edi, ebp; fd\n    call    _close\n\n    // Check the result of _ioctl\n    test    r12d, r12d\n    jnz     loc_46D39E\n\n    // Check the value at [rsp+198h+var_190]\n    cmp     [rsp+198h+var_190], 0\n    setz    al\n    movzx   eax, al\n    test    eax, eax\n    jnz     loc_46D3DA\n\nloc_46D312:\n    // Set up arguments for _fgets_unlocked\n    mov     rdx, rbx; stream\n    mov     esi, 64h ; 'd'; n\n    lea     rdi, [rsp+198h+s]; s\n    call    _fgets_unlocked\n\n    // Check the result of _fgets_unlocked\n    test    rax, rax\n    jz      loc_46D3EE\n\n    // Set up arguments for _sscanf\n    lea     r9, [rsp+198h+var_F8]\n    lea     r8, [rsp+198h+var_184]\n    lea     rcx, [rsp+198h+var_180]\n    lea     rdx, [rsp+198h+var_17C]\n    mov     esi, offset aUUU_0; \" %u %u %u %[^\\n ]\"\n    lea     rdi, [rsp+198h+s]; s\n    mov     eax, 0\n    call    _sscanf\n\n    // Check the result of _sscanf\n    cmp     eax, 4\n    jnz     short loc_46D312\n\n    // Set up arguments for _sprintf\n    lea     rdx, [rsp+198h+var_F8]\n    mov     esi, offset aDevS; \"/dev/%s\"\n    lea     rdi, [rsp+198h+file]; s\n    mov     eax, 0\n    call    _sprintf\n\n    // Set up arguments for _open64\n    mov     esi, 0; oflag\n    lea     rdi, [rsp+198h+file]; file\n    mov     eax, 0\n    call    _open64\n    mov     ebp, eax\n\n    // Check the result of _open64\n    cmp     eax, 0FFFFFFFFh\n    jnz     loc_46D2D7\n\nloc_46D39E:\n    // Set up arguments for sub_46D0C2\n    lea     rdi, [rsp+198h+file]\n    mov     rcx, 0FFFFFFFFFFFFFFFFh\n    mov     eax, 0\n    repne scasb\n    mov     rsi, rcx\n    not     rsi\n    mov     rcx, rsi\n    sub     rcx, 1\n    test    ecx, ecx\n    jz      short loc_46D3DA\n\n    // Convert character to integer\n    lea     eax, [rcx-1]\n    movzx   eax, [rsp+rax+198h+file]\n    sub     eax, 30h ; '0'\n    cmp     al, 9\n    setnbe  al\n    movzx   eax, al\n    jmp     loc_46D30A\n\nloc_46D3DA:\n    mov     esi, 0\n    lea     rdi, [rsp+198h+file]\n    call    sub_46D0C2\n    jmp     loc_46D312\n\nloc_46D3EE:\n    // Epilogue\n    add     rsp, 180h\n    pop     rbx\n    pop     rbp\n    pop     r12\n    retn\n}\n```"
    },
    {
        "func_name": "insert_bg_job",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00460534 | 41 57 | push    r15\n0x00460536 | 41 56 | push    r14\n0x00460538 | 41 55 | push    r13\n0x0046053A | 41 54 | push    r12\n0x0046053C | 55 | push    rbp\n0x0046053D | 53 | push    rbx\n0x0046053E | 48 83 EC 08 | sub     rsp, 8\n0x00460542 | 48 89 FB | mov     rbx, rdi\n0x00460545 | C7 47 14 01 00 00 00 | mov     dword ptr [rdi+14h], 1\n0x0046054C | 4C 8B 35 15 CE 2A 00 | mov     r14, cs:qword_70D368\n0x00460553 | 49 8B 46 40 | mov     rax, [r14+40h]\n0x00460557 | 48 85 C0 | test    rax, rax\n0x0046055A | 75 17 | jnz     short loc_460573\n0x0046055C | 49 8B 56 40 | mov     rdx, [r14+40h]\n0x00460560 | 48 85 D2 | test    rdx, rdx\n0x00460563 | 75 21 | jnz     short loc_460586\n0x00460565 | 4D 8D 66 40 | lea     r12, [r14+40h]\n0x00460569 | EB 26 | jmp     short loc_460591\n0x0046056B | 48 8B 00 | mov     rax, [rax]\n0x0046056E | 48 85 C0 | test    rax, rax\n0x00460571 | 74 E9 | jz      short loc_46055C\n0x00460573 | 8B 50 14 | mov     edx, [rax+14h]\n0x00460576 | 3B 53 14 | cmp     edx, [rbx+14h]\n0x00460579 | 7C F0 | jl      short loc_46056B\n0x0046057B | 83 C2 01 | add     edx, 1\n0x0046057E | 89 53 14 | mov     [rbx+14h], edx\n0x00460581 | EB E8 | jmp     short loc_46056B\n0x00460583 | 48 89 C2 | mov     rdx, rax\n0x00460586 | 48 8B 02 | mov     rax, [rdx]\n0x00460589 | 48 85 C0 | test    rax, rax\n0x0046058C | 75 F5 | jnz     short loc_460583\n0x0046058E | 49 89 D4 | mov     r12, rdx\n0x00460591 | BF 38 00 00 00 | mov     edi, 38h ; '8'\n0x00460596 | E8 5A 8C FA FF | call    sub_4091F5\n0x0046059B | 48 89 C5 | mov     rbp, rax\n0x0046059E | 49 89 04 24 | mov     [r12], rax\n0x004605A2 | F3 0F 6F 03 | movdqu  xmm0, xmmword ptr [rbx]\n0x004605A6 | 0F 11 00 | movups  xmmword ptr [rax], xmm0\n0x004605A9 | F3 0F 6F 4B 10 | movdqu  xmm1, xmmword ptr [rbx+10h]\n0x004605AE | 0F 11 48 10 | movups  xmmword ptr [rax+10h], xmm1\n0x004605B2 | F3 0F 6F 53 20 | movdqu  xmm2, xmmword ptr [rbx+20h]\n0x004605B7 | 0F 11 50 20 | movups  xmmword ptr [rax+20h], xmm2\n0x004605BB | 48 8B 43 30 | mov     rax, [rbx+30h]\n0x004605BF | 48 89 45 30 | mov     [rbp+30h], rax\n0x004605C3 | 48 C7 45 00 00 00 00 00 | mov     qword ptr [rbp+0], 0\n0x004605CB | 48 63 43 08 | movsxd  rax, dword ptr [rbx+8]\n0x004605CF | 48 8D 3C 40 | lea     rdi, [rax+rax*2]\n0x004605D3 | 48 C1 E7 04 | shl     rdi, 4; n\n0x004605D7 | E8 57 8C FA FF | call    sub_409233\n0x004605DC | 48 89 45 28 | mov     [rbp+28h], rax\n0x004605E0 | 83 7B 08 00 | cmp     dword ptr [rbx+8], 0\n0x004605E4 | 7E 24 | jle     short loc_46060A\n0x004605E6 | B8 00 00 00 00 | mov     eax, 0\n0x004605EB | BA 00 00 00 00 | mov     edx, 0\n0x004605F0 | 48 8B 4B 28 | mov     rcx, [rbx+28h]\n0x004605F4 | 8B 34 01 | mov     esi, [rcx+rax]\n0x004605F7 | 48 8B 4D 28 | mov     rcx, [rbp+28h]\n0x004605FB | 89 34 01 | mov     [rcx+rax], esi\n0x004605FE | 83 C2 01 | add     edx, 1\n0x00460601 | 48 83 C0 30 | add     rax, 30h ; '0'\n0x00460605 | 39 53 08 | cmp     [rbx+8], edx\n0x00460608 | 7F E6 | jg      short loc_4605F0\n0x0046060A | 4C 8B 7B 20 | mov     r15, [rbx+20h]\n0x0046060E | 4D 85 FF | test    r15, r15\n0x00460611 | 74 2C | jz      short loc_46063F\n0x00460613 | 4C 89 FF | mov     rdi, r15\n0x00460616 | E8 3D 8C FA FF | call    sub_409258\n0x0046061B | 48 89 45 20 | mov     [rbp+20h], rax\n0x0046061F | 41 83 3E 00 | cmp     dword ptr [r14], 0\n0x00460623 | 0F 85 D0 00 00 00 | jnz     loc_4606F9\n0x00460629 | 8B 45 14 | mov     eax, [rbp+14h]\n0x0046062C | 41 89 46 38 | mov     [r14+38h], eax\n0x00460630 | 48 83 C4 08 | add     rsp, 8\n0x00460634 | 5B | pop     rbx\n0x00460635 | 5D | pop     rbp\n0x00460636 | 41 5C | pop     r12\n0x00460638 | 41 5D | pop     r13\n0x0046063A | 41 5E | pop     r14\n0x0046063C | 41 5F | pop     r15\n0x0046063E | C3 | retn\n0x0046063F | 48 8B 43 28 | mov     rax, [rbx+28h]\n0x00460643 | 48 8B 50 20 | mov     rdx, [rax+20h]\n0x00460647 | 48 85 D2 | test    rdx, rdx\n0x0046064A | 0F 84 93 00 00 00 | jz      loc_4606E3\n0x00460650 | BE 00 00 00 00 | mov     esi, 0\n0x00460655 | 49 C7 C0 FF FF FF FF | mov     r8, 0FFFFFFFFFFFFFFFFh\n0x0046065C | B8 00 00 00 00 | mov     eax, 0\n0x00460661 | 48 83 3A 00 | cmp     qword ptr [rdx], 0\n0x00460665 | 74 7C | jz      short loc_4606E3\n0x00460667 | 48 8B 3A | mov     rdi, [rdx]\n0x0046066A | 4C 89 C1 | mov     rcx, r8\n0x0046066D | F2 AE | repne scasb\n0x0046066F | 48 F7 D1 | not     rcx\n0x00460672 | 8D 34 0E | lea     esi, [rsi+rcx]\n0x00460675 | 48 83 C2 08 | add     rdx, 8\n0x00460679 | 48 83 3A 00 | cmp     qword ptr [rdx], 0\n0x0046067D | 75 E8 | jnz     short loc_460667\n0x0046067F | 48 63 FE | movsxd  rdi, esi\n0x00460682 | E8 6E 8B FA FF | call    sub_4091F5\n0x00460687 | 49 89 C7 | mov     r15, rax\n0x0046068A | 48 89 43 20 | mov     [rbx+20h], rax\n0x0046068E | 48 8B 43 28 | mov     rax, [rbx+28h]\n0x00460692 | 4C 8B 60 20 | mov     r12, [rax+20h]\n0x00460696 | 4D 89 FD | mov     r13, r15\n0x00460699 | 49 8B 34 24 | mov     rsi, [r12]; src\n0x0046069D | B8 00 00 00 00 | mov     eax, 0\n0x004606A2 | 48 C7 C1 FF FF FF FF | mov     rcx, 0FFFFFFFFFFFFFFFFh\n0x004606A9 | 48 89 F7 | mov     rdi, rsi\n0x004606AC | F2 AE | repne scasb\n0x004606AE | 48 89 C8 | mov     rax, rcx\n0x004606B1 | 48 F7 D0 | not     rax\n0x004606B4 | 48 8D 58 FF | lea     rbx, [rax-1]\n0x004606B8 | 48 63 DB | movsxd  rbx, ebx\n0x004606BB | 48 89 DA | mov     rdx, rbx; n\n0x004606BE | 4C 89 EF | mov     rdi, r13; dest\n0x004606C1 | E8 8A 66 FA FF | call    _memcpy\n0x004606C6 | 4C 01 EB | add     rbx, r13\n0x004606C9 | 4C 8D 6B 01 | lea     r13, [rbx+1]\n0x004606CD | C6 03 20 | mov     byte ptr [rbx], 20h ; ' '\n0x004606D0 | 49 83 C4 08 | add     r12, 8\n0x004606D4 | 49 83 3C 24 00 | cmp     qword ptr [r12], 0\n0x004606D9 | 75 BE | jnz     short loc_460699\n0x004606DB | C6 03 00 | mov     byte ptr [rbx], 0\n0x004606DE | E9 30 FF FF FF | jmp     loc_460613\n0x004606E3 | BF 01 00 00 00 | mov     edi, 1; n\n0x004606E8 | E8 46 8B FA FF | call    sub_409233\n0x004606ED | 49 89 C7 | mov     r15, rax\n0x004606F0 | 48 89 43 20 | mov     [rbx+20h], rax\n0x004606F4 | E9 1A FF FF FF | jmp     loc_460613\n0x004606F9 | 48 8B 55 28 | mov     rdx, [rbp+28h]\n0x004606FD | 8B 75 14 | mov     esi, [rbp+14h]\n0x00460700 | 48 89 C1 | mov     rcx, rax\n0x00460703 | 8B 12 | mov     edx, [rdx]\n0x00460705 | BF 9B 4D 4E 00 | mov     edi, offset aD_12; \"[%d] \"\n0x0046070A | B8 00 00 00 00 | mov     eax, 0\n0x0046070F | E8 5C 60 FA FF | call    _printf\n0x00460714 | E9 10 FF FF FF | jmp     loc_460629",
        "output": "```c\nvoid function(void* rbx) {\n    int* rdi = (int*)rbx + 0x14;\n    *rdi = 1;\n    long long r14 = *(long long*)0x70D368;\n    long long rax = *(long long*)(r14 + 0x40);\n    if (rax == 0) {\n        rdx = *(long long*)(r14 + 0x40);\n        if (rdx == 0) {\n            r12 = r14 + 0x40;\n            goto loc_460591;\n        }\n    }\n    else {\n        while (rax != 0) {\n            int edx = *(int*)(rax + 0x14);\n            if (edx < *(int*)(rbx + 0x14)) {\n                edx++;\n                *(int*)(rbx + 0x14) = edx;\n            }\n            else {\n                rdx = rax;\n                rax = *(long long*)rax;\n                if (rax == 0) {\n                    r12 = rdx;\n                    break;\n                }\n            }\n        }\n    }\n    int edi = 0x38;\n    sub_4091F5(0x38);\n    long long rbp = rax;\n    *(long long*)r12 = rax;\n    __m128 xmm0 = *(const __m128*)rbx;\n    *(__m128*)rax = xmm0;\n    __m128 xmm1 = *(const __m128*)(rbx + 0x10);\n    *(__m128*)(rax + 0x10) = xmm1;\n    __m128 xmm2 = *(const __m128*)(rbx + 0x20);\n    *(__m128*)(rax + 0x20) = xmm2;\n    long long rax = *(long long*)(rbx + 0x30);\n    *(long long*)(rbp + 0x30) = rax;\n    *(long long*)(rbp + 0) = 0;\n    long long rax = *(int*)(rbx + 8);\n    long long rdi = rax + rax * 2;\n    rdi = rdi << 4;\n    long long rax = sub_409233(rdi);\n    *(long long*)(rbp + 0x28) = rax;\n    if (*(int*)r14 == 0) {\n        *(int*)(r14 + 0x38) = *(int*)(rbp + 0x14);\n    }\n    else {\n        r15 = *(long long*)(rbx + 0x20);\n        if (r15 != 0) {\n            rdi = r15;\n            rax = sub_409258();\n            *(long long*)(rbp + 0x20) = rax;\n            if (*(int*)r14 == 0) {\n                *(int*)(r14 + 0x38) = *(int*)(rbp + 0x14);\n            }\n        }\n    }\n    if (*(int*)r14 == 0) {\n        int eax = *(int*)(rbp + 0x14);\n        *(int*)(r14 + 0x38) = eax;\n    }\n    else {\n        long long rdx = *(long long*)(rbx + 0x28);\n        if (rdx != 0) {\n            int esi = 0;\n            long long r8 = -1;\n            long long rax = 0;\n            if (*(long long*)rdx != 0) {\n                rdi = *(long long*)rdx;\n                while (1) {\n                    rax = r8;\n                    r8 = rdi;\n                    rdi = sub_4091F5(esi);\n                    r15 = rax;\n                    *(long long*)(rbx + 0x20) = rax;\n                    rax = *(long long*)(rbx + 0x28);\n                    r12 = *(long long*)(rax + 0x20);\n                    r13 = r15;\n                    rsi = *(long long*)r12;\n                    rax = 0;\n                    r8 = -1;\n                    rdi = rsi;\n                    while (*(long long*)rdi != 0) {\n                        rdi++;\n                        rax++;\n                    }\n                    rbx = rax - 1;\n                    rdx = rbx;\n                    rdi = r13;\n                    sub_409233(rdx, rdi);\n                    r15 = rax;\n                    *(long long*)(rbx + r13) = rax;\n                    r12 += 8;\n                    if (*(long long*)r12 != 0) {\n                        esi++;\n                        rax = *(long long*)r12;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            *(char*)rbx = 0;\n        }\n    }\n    if (*(long long*)(rbx + 0x28) != 0) {\n        int eax = *(int*)(rbp + 0x14);\n        printf(\"[%d] \", eax);\n    }\n    return;\n}\n```"
    },
    {
        "func_name": "f_write32",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00481921 | 48 83 EC 18 | sub     rsp, 18h\n0x00481925 | 0F CF | bswap   edi\n0x00481927 | 89 7C 24 0C | mov     [rsp+18h+var_C], edi\n0x0048192B | BE 04 00 00 00 | mov     esi, 4\n0x00481930 | 48 8D 7C 24 0C | lea     rdi, [rsp+18h+var_C]\n0x00481935 | E8 78 FF FF FF | call    sub_4818B2\n0x0048193A | 48 83 C4 18 | add     rsp, 18h\n0x0048193E | C3 | retn",
        "output": "```c\nvoid function() {\n    int var_C;\n    \n    // sub     rsp, 18h\n    // allocate space on the stack for local variables\n    \n    // bswap   edi\n    // reverse the bytes of the value in edi\n    \n    // mov     [rsp+18h+var_C], edi\n    // store the reversed value in edi to var_C\n    \n    // mov     esi, 4\n    // move the value 4 into esi\n    \n    // lea     rdi, [rsp+18h+var_C]\n    // calculate the address of var_C and store it in rdi\n    \n    // call    sub_4818B2\n    // call the function sub_4818B2 with the address of var_C as the argument\n    \n    // add     rsp, 18h\n    // deallocate the space on the stack\n    \n    // retn\n    // return from the function\n}\n```"
    },
    {
        "func_name": "popredir",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004568B8 | 48 8B 15 C1 6A 2B 00 | mov     rdx, cs:qword_70D380\n0x004568BF | 8B 42 20 | mov     eax, [rdx+20h]\n0x004568C2 | 83 E8 01 | sub     eax, 1\n0x004568C5 | 89 42 20 | mov     [rdx+20h], eax\n0x004568C8 | 0F 89 E6 00 00 00 | jns     locret_4569B4\n0x004568CE | 41 57 | push    r15\n0x004568D0 | 41 56 | push    r14\n0x004568D2 | 41 55 | push    r13\n0x004568D4 | 41 54 | push    r12\n0x004568D6 | 55 | push    rbp\n0x004568D7 | 53 | push    rbx\n0x004568D8 | 48 83 EC 08 | sub     rsp, 8\n0x004568DC | 41 89 F6 | mov     r14d, esi\n0x004568DF | 41 89 FD | mov     r13d, edi\n0x004568E2 | 48 8B 15 8F 6A 2B 00 | mov     rdx, cs:qword_70D378\n0x004568E9 | 8B 42 30 | mov     eax, [rdx+30h]\n0x004568EC | 83 C0 01 | add     eax, 1\n0x004568EF | 89 42 30 | mov     [rdx+30h], eax\n0x004568F2 | 4C 8B 3D 87 6A 2B 00 | mov     r15, cs:qword_70D380\n0x004568F9 | 4D 8B 67 18 | mov     r12, [r15+18h]\n0x004568FD | 41 83 7C 24 0C 00 | cmp     dword ptr [r12+0Ch], 0\n0x00456903 | 7E 68 | jle     short loc_45696D\n0x00456905 | BD 00 00 00 00 | mov     ebp, 0\n0x0045690A | EB 39 | jmp     short loc_456945\n0x0045690C | 45 85 ED | test    r13d, r13d\n0x0045690F | 75 29 | jnz     short loc_45693A\n0x00456911 | 89 F7 | mov     edi, esi; fd\n0x00456913 | E8 98 00 FB FF | call    _close\n0x00456918 | EB 20 | jmp     short loc_45693A\n0x0045691A | 81 E3 FF FF FF BF | and     ebx, 0BFFFFFFFh\n0x00456920 | 81 CE 00 00 00 80 | or      esi, 80000000h\n0x00456926 | 89 DF | mov     edi, ebx\n0x00456928 | E8 BE D6 FF FF | call    sub_453FEB\n0x0045692D | 89 DF | mov     edi, ebx\n0x0045692F | 81 E7 FF FF FF BF | and     edi, 0BFFFFFFFh; fd\n0x00456935 | E8 76 00 FB FF | call    _close\n0x0045693A | 48 83 C5 01 | add     rbp, 1\n0x0045693E | 41 39 6C 24 0C | cmp     [r12+0Ch], ebp\n0x00456943 | 7E 28 | jle     short loc_45696D\n0x00456945 | 41 8B 74 EC 10 | mov     esi, [r12+rbp*8+10h]\n0x0045694A | 41 8B 5C EC 14 | mov     ebx, [r12+rbp*8+14h]\n0x0045694F | 83 FB FD | cmp     ebx, 0FFFFFFFDh\n0x00456952 | 74 B8 | jz      short loc_45690C\n0x00456954 | 83 FB FE | cmp     ebx, 0FFFFFFFEh\n0x00456957 | 74 E1 | jz      short loc_45693A\n0x00456959 | 45 85 ED | test    r13d, r13d\n0x0045695C | 74 BC | jz      short loc_45691A\n0x0045695E | 45 85 F6 | test    r14d, r14d\n0x00456961 | 74 CA | jz      short loc_45692D\n0x00456963 | F7 C3 00 00 00 40 | test    ebx, 40000000h\n0x00456969 | 74 C2 | jz      short loc_45692D\n0x0045696B | EB AD | jmp     short loc_45691A\n0x0045696D | 49 8B 04 24 | mov     rax, [r12]\n0x00456971 | 49 89 47 18 | mov     [r15+18h], rax\n0x00456975 | 41 8B 44 24 08 | mov     eax, [r12+8]\n0x0045697A | 41 89 47 20 | mov     [r15+20h], eax\n0x0045697E | 4C 89 E7 | mov     rdi, r12; ptr\n0x00456981 | E8 CA F8 FA FF | call    _free\n0x00456986 | 48 8B 15 EB 69 2B 00 | mov     rdx, cs:qword_70D378\n0x0045698D | 8B 42 30 | mov     eax, [rdx+30h]\n0x00456990 | 83 E8 01 | sub     eax, 1\n0x00456993 | 89 42 30 | mov     [rdx+30h], eax\n0x00456996 | 75 08 | jnz     short loc_4569A0\n0x00456998 | 0F B6 42 34 | movzx   eax, byte ptr [rdx+34h]\n0x0045699C | 84 C0 | test    al, al\n0x0045699E | 75 0F | jnz     short loc_4569AF\n0x004569A0 | 48 83 C4 08 | add     rsp, 8\n0x004569A4 | 5B | pop     rbx\n0x004569A5 | 5D | pop     rbp\n0x004569A6 | 41 5C | pop     r12\n0x004569A8 | 41 5D | pop     r13\n0x004569AA | 41 5E | pop     r14\n0x004569AC | 41 5F | pop     r15\n0x004569AE | C3 | retn\n0x004569AF | E8 0E C6 FF FF | call    sub_452FC2\n0x004569B4 | C3 | retn",
        "output": "```c\n#include <stdio.h>\n\nvoid function() {\n    long long qword_70D380 = 0;\n    long long qword_70D378 = 0;\n    int esi = 0;\n    int edi = 0;\n    int ebp = 0;\n    int ebx = 0;\n    int r12 = 0;\n    int r13 = 0;\n    int r14 = 0;\n    int r15 = 0;\n\n    long long rdx = qword_70D380;\n    int eax = *(int *)(rdx + 0x20);\n    eax -= 1;\n    *(int *)(rdx + 0x20) = eax;\n\n    if (eax < 0) {\n        goto locret_4569B4;\n    }\n\n    r15 = qword_70D380;\n    r12 = *(long long *)(r15 + 0x18);\n\n    if (*(int *)(r12 + 0x0C) <= 0) {\n        goto loc_45696D;\n    }\n\n    ebp = 0;\n\nloc_456945:\n    if (r13 != 0) {\n        edi = esi;\n        _close(edi);\n        goto loc_45693A;\n    }\n\n    edi = ebx;\n    sub_453FEB(edi);\n\n    edi = ebx;\n    edi &= 0xBFFFFFFF;\n    _close(edi);\n\nloc_45693A:\n    rbp += 1;\n\n    if (*(int *)(r12 + 0x0C) <= rbp) {\n        goto loc_45696D;\n    }\n\n    esi = *(int *)(r12 + rbp * 8 + 0x10);\n    ebx = *(int *)(r12 + rbp * 8 + 0x14);\n\n    if (ebx == 0xFFFFFFFD) {\n        goto loc_45690C;\n    }\n\n    if (ebx == 0xFFFFFFFE) {\n        goto loc_45693A;\n    }\n\n    if (r13 == 0) {\n        goto loc_45691A;\n    }\n\n    if (r14 == 0) {\n        goto loc_45692D;\n    }\n\n    if (ebx & 0x40000000) {\n        goto loc_45692D;\n    }\n\n    goto loc_45691A;\n\nlocret_4569B4:\n    rax = *(long long *)(r12);\n    *(long long *)(r15 + 0x18) = rax;\n\n    eax = *(int *)(r12 + 0x8);\n    *(int *)(r15 + 0x20) = eax;\n\n    _free(r12);\n\n    rdx = qword_70D378;\n    eax = *(int *)(rdx + 0x30);\n    eax -= 1;\n    *(int *)(rdx + 0x30) = eax;\n\n    if (eax == 0) {\n        if (*(char *)(rdx + 0x34) == 0) {\n            return;\n        }\n    }\n\n    return;\n\nloc_45696D:\n    sub_452FC2();\n    return;\n}\n```"
    },
    {
        "func_name": "restart_handler",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004B141C | 53 | push    rbx\n0x004B141D | 48 8B 1D FC 9D 25 00 | mov     rbx, cs:qword_70B220\n0x004B1424 | 48 85 DB | test    rbx, rbx\n0x004B1427 | 74 4A | jz      short loc_4B1473\n0x004B1429 | 80 7B 0C 00 | cmp     byte ptr [rbx+0Ch], 0\n0x004B142D | 78 0E | js      short loc_4B143D\n0x004B142F | 48 8B 1B | mov     rbx, [rbx]\n0x004B1432 | 48 85 DB | test    rbx, rbx\n0x004B1435 | 74 3C | jz      short loc_4B1473\n0x004B1437 | 80 7B 0C 00 | cmp     byte ptr [rbx+0Ch], 0\n0x004B143B | 79 F2 | jns     short loc_4B142F\n0x004B143D | E8 87 F6 FF FF | call    sub_4B0AC9\n0x004B1442 | E8 4A FF FF FF | call    sub_4B1391\n0x004B1447 | BF EF CD AB 89 | mov     edi, 89ABCDEFh; howto\n0x004B144C | E8 2F 62 F5 FF | call    _reboot\n0x004B1451 | 48 8D 7B 0D | lea     rdi, [rbx+0Dh]; file\n0x004B1455 | E8 F8 F9 FF FF | call    sub_4B0E52\n0x004B145A | 85 C0 | test    eax, eax\n0x004B145C | 75 0A | jnz     short loc_4B1468\n0x004B145E | BF 23 01 EF CD | mov     edi, 0CDEF0123h\n0x004B1463 | E8 83 F6 FF FF | call    sub_4B0AEB\n0x004B1468 | 48 8D 7B 2D | lea     rdi, [rbx+2Dh]; src\n0x004B146C | E8 5E FA FF FF | call    sub_4B0ECF\n0x004B1471 | EB EB | jmp     short loc_4B145E\n0x004B1473 | 5B | pop     rbx\n0x004B1474 | C3 | retn",
        "output": "```c\nvoid function() {\n    // push rbx\n    // mov rbx, cs:qword_70B220\n    rbx = *(qword_70B220);\n\n    // test rbx, rbx\n    if (rbx == 0) {\n        // jz short loc_4B1473\n        // pop rbx\n        return;\n    }\n\n    // cmp byte ptr [rbx+0Ch], 0\n    if (*(rbx + 0x0C) != 0) {\n        // js short loc_4B143D\n        // call sub_4B0AC9\n        // call sub_4B1391\n        // mov edi, 89ABCDEFh\n        // call _reboot\n        // lea rdi, [rbx+0Dh]\n        // call sub_4B0E52\n        // test eax, eax\n        // jnz short loc_4B1468\n        // mov edi, 0CDEF0123h\n        // call sub_4B0AEB\n        // lea rdi, [rbx+2Dh]\n        // call sub_4B0ECF\n        // jmp short loc_4B145E\n        // pop rbx\n        return;\n    }\n\n    // mov rbx, [rbx]\n    rbx = *(rbx);\n\n    // test rbx, rbx\n    if (rbx == 0) {\n        // jz short loc_4B1473\n        // pop rbx\n        return;\n    }\n\n    // cmp byte ptr [rbx+0Ch], 0\n    if (*(rbx + 0x0C) >= 0) {\n        // jns short loc_4B142F\n        // call sub_4B0AC9\n        // call sub_4B1391\n        // mov edi, 89ABCDEFh\n        // call _reboot\n        // lea rdi, [rbx+0Dh]\n        // call sub_4B0E52\n        // test eax, eax\n        // jnz short loc_4B1468\n        // mov edi, 0CDEF0123h\n        // call sub_4B0AEB\n        // lea rdi, [rbx+2Dh]\n        // call sub_4B0ECF\n        // jmp short loc_4B145E\n        // pop rbx\n        return;\n    }\n\n    // call sub_4B0AC9\n    // call sub_4B1391\n    // mov edi, 89ABCDEFh\n    // call _reboot\n    // lea rdi, [rbx+0Dh]\n    // call sub_4B0E52\n    // test eax, eax\n    // jnz short loc_4B1468\n    // mov edi, 0CDEF0123h\n    // call sub_4B0AEB\n    // lea rdi, [rbx+2Dh]\n    // call sub_4B0ECF\n    // jmp short loc_4B145E\n    // pop rbx\n}\n```"
    }
]
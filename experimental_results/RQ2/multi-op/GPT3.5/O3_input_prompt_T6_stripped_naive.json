[
    {
        "func_name": "isrv_close_fd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00443580 | 55 | push    rbp\n0x00443581 | 48 89 FD | mov     rbp, rdi\n0x00443584 | 89 F7 | mov     edi, esi; fd\n0x00443586 | 53 | push    rbx\n0x00443587 | 89 F3 | mov     ebx, esi\n0x00443589 | 48 83 EC 08 | sub     rsp, 8\n0x0044358D | E8 EE 34 FC FF | call    _close\n0x00443592 | 85 DB | test    ebx, ebx\n0x00443594 | 8D 43 3F | lea     eax, [rbx+3Fh]\n0x00443597 | 0F 49 C3 | cmovns  eax, ebx\n0x0044359A | C1 F8 06 | sar     eax, 6\n0x0044359D | 48 98 | cdqe\n0x0044359F | 48 8D 54 C5 00 | lea     rdx, [rbp+rax*8+0]\n0x004435A4 | 89 D8 | mov     eax, ebx\n0x004435A6 | C1 F8 1F | sar     eax, 1Fh\n0x004435A9 | C1 E8 1A | shr     eax, 1Ah\n0x004435AC | 8D 0C 03 | lea     ecx, [rbx+rax]\n0x004435AF | 83 E1 3F | and     ecx, 3Fh\n0x004435B2 | 29 C1 | sub     ecx, eax\n0x004435B4 | B8 01 00 00 00 | mov     eax, 1\n0x004435B9 | 48 D3 E0 | shl     rax, cl\n0x004435BC | 48 89 C1 | mov     rcx, rax\n0x004435BF | 48 F7 D1 | not     rcx\n0x004435C2 | 48 21 4A 38 | and     [rdx+38h], rcx\n0x004435C6 | 8B 75 34 | mov     esi, [rbp+34h]\n0x004435C9 | 85 F6 | test    esi, esi\n0x004435CB | 74 0C | jz      short loc_4435D9\n0x004435CD | 48 8B BA B8 00 00 00 | mov     rdi, [rdx+0B8h]\n0x004435D4 | 48 85 F8 | test    rax, rdi\n0x004435D7 | 75 57 | jnz     short loc_443630\n0x004435D9 | 48 8B 7D 00 | mov     rdi, [rbp+0]\n0x004435DD | 48 63 C3 | movsxd  rax, ebx\n0x004435E0 | 8B 75 2C | mov     esi, [rbp+2Ch]\n0x004435E3 | BA FF FF FF FF | mov     edx, 0FFFFFFFFh\n0x004435E8 | 48 8D 04 47 | lea     rax, [rdi+rax*2]\n0x004435EC | 66 89 10 | mov     [rax], dx\n0x004435EF | 8D 56 FF | lea     edx, [rsi-1]\n0x004435F2 | 39 DA | cmp     edx, ebx\n0x004435F4 | 74 16 | jz      short loc_44360C\n0x004435F6 | 48 83 C4 08 | add     rsp, 8\n0x004435FA | 5B | pop     rbx\n0x004435FB | 5D | pop     rbp\n0x004435FC | C3 | retn\n0x004435FD | 0F 1F 00 | align 20h\n0x00443600 | 48 83 E8 02 | sub     rax, 2\n0x00443604 | 66 83 38 FF | cmp     word ptr [rax], 0FFFFh\n0x00443608 | 75 09 | jnz     short loc_443613\n0x0044360A | 89 D3 | mov     ebx, edx\n0x0044360C | 89 DA | mov     edx, ebx\n0x0044360E | 83 EA 01 | sub     edx, 1\n0x00443611 | 79 ED | jns     short loc_443600\n0x00443613 | 89 5D 2C | mov     [rbp+2Ch], ebx\n0x00443616 | 48 63 F3 | movsxd  rsi, ebx\n0x00443619 | 48 01 F6 | add     rsi, rsi\n0x0044361C | E8 EF 69 FC FF | call    sub_40A010\n0x00443621 | 48 89 45 00 | mov     [rbp+0], rax\n0x00443625 | 48 83 C4 08 | add     rsp, 8\n0x00443629 | 5B | pop     rbx\n0x0044362A | 5D | pop     rbp\n0x0044362B | C3 | retn\n0x0044362C | 0F 1F 40 00 | align 10h\n0x00443630 | 83 EE 01 | sub     esi, 1\n0x00443633 | 48 21 F9 | and     rcx, rdi\n0x00443636 | 89 75 34 | mov     [rbp+34h], esi\n0x00443639 | 48 89 8A B8 00 00 00 | mov     [rdx+0B8h], rcx\n0x00443640 | EB 97 | jmp     short loc_4435D9",
        "output": "```c\nvoid function(int rdi, int esi) {\n    int rbp = rdi;\n    int ebx = esi;\n    int eax;\n    int ecx;\n    int edx;\n    int rax;\n    int rcx;\n    int rdi;\n    int esi;\n\n    push(rbp);\n    mov(rbp, rdi);\n    mov(edi, esi);\n    push(rbx);\n    mov(ebx, esi);\n    sub(rsp, 8);\n    call(_close);\n\n    test(ebx, ebx);\n    eax = ebx + 0x3F;\n    if (ebx >= 0) {\n        eax = ebx;\n    }\n    eax = eax >> 6;\n    rdx = rbp + (rax * 8);\n    eax = ebx;\n    eax = eax >> 0x1F;\n    eax = eax >> 0x1A;\n    ecx = ebx + eax;\n    ecx = ecx & 0x3F;\n    ecx = ecx - eax;\n    eax = 1;\n    rax = rax << cl;\n    rcx = rax;\n    rcx = ~rcx;\n    [rdx + 0x38] = rcx;\n\n    esi = [rbp + 0x34];\n    if (esi != 0) {\n        rdi = [rdx + 0xB8];\n        if (rax & rdi != 0) {\n            goto loc_443630;\n        }\n    } else {\n        rdi = [rbp + 0];\n        rax = ebx;\n        esi = [rbp + 0x2C];\n        edx = 0xFFFFFFFF;\n        rax = rdi + (rax * 2);\n        [rax] = dx;\n        edx = esi - 1;\n        if (edx == ebx) {\n            goto loc_44360C;\n        }\n    }\n\n    add(rsp, 8);\n    pop(rbx);\n    pop(rbp);\n    return;\n\nloc_4435D9:\n    rdi = [rbp + 0];\n    rax = ebx;\n    esi = [rbp + 0x2C];\n    edx = 0xFFFFFFFF;\n    rax = rdi + (rax * 2);\n    [rax] = dx;\n    edx = esi - 1;\n    if (edx != ebx) {\n        goto loc_443600;\n    }\n\nloc_44360C:\n    [rbp + 0x2C] = ebx;\n    rsi = ebx;\n    rsi = rsi + rsi;\n    call(sub_40A010);\n    [rbp + 0] = rax;\n    add(rsp, 8);\n    pop(rbx);\n    pop(rbp);\n    return;\n\nloc_443600:\n    esi = esi - 1;\n    rcx = rcx & rdi;\n    [rbp + 0x34] = esi;\n    [rdx + 0xB8] = rcx;\n    goto loc_4435D9;\n\nloc_443630:\n    goto loc_4435D9;\n}\n```"
    },
    {
        "func_name": "uniq_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004CED80 | 41 57 | push    r15\n0x004CED82 | 31 C0 | xor     eax, eax\n0x004CED84 | 41 56 | push    r14\n0x004CED86 | 41 55 | push    r13\n0x004CED88 | 41 54 | push    r12\n0x004CED8A | 55 | push    rbp\n0x004CED8B | 53 | push    rbx\n0x004CED8C | 48 89 F3 | mov     rbx, rsi\n0x004CED8F | BE 3E D8 52 00 | mov     esi, offset aCdufSW; \"cduf:s:w:\"\n0x004CED94 | 48 89 DF | mov     rdi, rbx; argv\n0x004CED97 | 48 83 EC 28 | sub     rsp, 28h\n0x004CED9B | 48 C7 05 1A 16 28 00 35 D8 52 00 | mov     cs:qword_7503C0, offset aFSW; \"f+:s+:w+\"\n0x004CEDA6 | 4C 8D 44 24 1C | lea     r8, [rsp+58h+n]\n0x004CEDAB | 48 8D 4C 24 18 | lea     rcx, [rsp+58h+var_40]\n0x004CEDB0 | C7 44 24 18 00 00 00 00 | mov     [rsp+58h+var_40], 0\n0x004CEDB8 | 48 8D 54 24 14 | lea     rdx, [rsp+58h+var_44]\n0x004CEDBD | C7 44 24 14 00 00 00 00 | mov     [rsp+58h+var_44], 0\n0x004CEDC5 | C7 44 24 1C FF FF FF 7F | mov     dword ptr [rsp+58h+n], 7FFFFFFFh\n0x004CEDCD | E8 AE 50 02 00 | call    sub_4F3E80\n0x004CEDD2 | 41 89 C7 | mov     r15d, eax\n0x004CEDD5 | 48 63 05 3C F0 27 00 | movsxd  rax, cs:optind\n0x004CEDDC | 48 8D 1C C3 | lea     rbx, [rbx+rax*8]\n0x004CEDE0 | 48 8B 03 | mov     rax, [rbx]\n0x004CEDE3 | 48 89 44 24 08 | mov     [rsp+58h+var_50], rax\n0x004CEDE8 | 48 85 C0 | test    rax, rax\n0x004CEDEB | 74 54 | jz      short loc_4CEE41\n0x004CEDED | 80 38 2D | cmp     byte ptr [rax], 2Dh ; '-'\n0x004CEDF0 | 75 06 | jnz     short loc_4CEDF8\n0x004CEDF2 | 80 78 01 00 | cmp     byte ptr [rax+1], 0\n0x004CEDF6 | 74 13 | jz      short loc_4CEE0B\n0x004CEDF8 | 31 FF | xor     edi, edi; fd\n0x004CEDFA | E8 81 7C F3 FF | call    _close\n0x004CEDFF | 48 8B 7C 24 08 | mov     rdi, [rsp+58h+var_50]\n0x004CEE04 | 31 F6 | xor     esi, esi\n0x004CEE06 | E8 55 B3 F3 FF | call    sub_40A160\n0x004CEE0B | 48 8B 7B 08 | mov     rdi, [rbx+8]\n0x004CEE0F | 48 85 FF | test    rdi, rdi\n0x004CEE12 | 74 2D | jz      short loc_4CEE41\n0x004CEE14 | 48 83 7B 10 00 | cmp     qword ptr [rbx+10h], 0\n0x004CEE19 | 74 05 | jz      short loc_4CEE20\n0x004CEE1B | E8 B0 8C F3 FF | call    sub_407AD0\n0x004CEE20 | 80 3F 2D | cmp     byte ptr [rdi], 2Dh ; '-'\n0x004CEE23 | 75 06 | jnz     short loc_4CEE2B\n0x004CEE25 | 80 7F 01 00 | cmp     byte ptr [rdi+1], 0\n0x004CEE29 | 74 16 | jz      short loc_4CEE41\n0x004CEE2B | BE 41 02 00 00 | mov     esi, 241h\n0x004CEE30 | E8 2B B3 F3 FF | call    sub_40A160\n0x004CEE35 | BE 01 00 00 00 | mov     esi, 1\n0x004CEE3A | 89 C7 | mov     edi, eax; fd\n0x004CEE3C | E8 CF B4 F3 FF | call    sub_40A310\n0x004CEE41 | 44 89 F8 | mov     eax, r15d\n0x004CEE44 | 45 31 F6 | xor     r14d, r14d\n0x004CEE47 | 45 31 ED | xor     r13d, r13d\n0x004CEE4A | 83 E0 01 | and     eax, 1\n0x004CEE4D | 89 44 24 04 | mov     [rsp+58h+var_54], eax\n0x004CEE51 | 0F 1F 80 00 00 00 00 | nop     dword ptr [rax+00000000h]\n0x004CEE58 | 4C 89 F3 | mov     rbx, r14\n0x004CEE5B | 45 31 E4 | xor     r12d, r12d\n0x004CEE5E | 66 90 | xchg    ax, ax\n0x004CEE60 | 48 8B 3D A9 EF 27 00 | mov     rdi, cs:stdin; _IO_FILE *\n0x004CEE67 | E8 14 4E 02 00 | call    sub_4F3C80\n0x004CEE6C | 48 89 C5 | mov     rbp, rax\n0x004CEE6F | 48 85 C0 | test    rax, rax\n0x004CEE72 | 74 76 | jz      short loc_4CEEEA\n0x004CEE74 | 8B 5C 24 14 | mov     ebx, [rsp+58h+var_44]\n0x004CEE78 | 48 89 E8 | mov     rax, rbp\n0x004CEE7B | 85 DB | test    ebx, ebx\n0x004CEE7D | 74 16 | jz      short loc_4CEE95\n0x004CEE7F | 90 | nop\n0x004CEE80 | 48 89 C7 | mov     rdi, rax\n0x004CEE83 | E8 A8 9B F3 FF | call    sub_408A30\n0x004CEE88 | 48 89 C7 | mov     rdi, rax\n0x004CEE8B | E8 D0 9B F3 FF | call    sub_408A60\n0x004CEE90 | 83 EB 01 | sub     ebx, 1\n0x004CEE93 | 75 EB | jnz     short loc_4CEE80\n0x004CEE95 | 80 38 00 | cmp     byte ptr [rax], 0\n0x004CEE98 | 8B 4C 24 18 | mov     ecx, [rsp+58h+var_40]\n0x004CEE9C | 48 89 C3 | mov     rbx, rax\n0x004CEE9F | 74 20 | jz      short loc_4CEEC1\n0x004CEEA1 | 85 C9 | test    ecx, ecx\n0x004CEEA3 | 75 10 | jnz     short loc_4CEEB5\n0x004CEEA5 | EB 1A | jmp     short loc_4CEEC1\n0x004CEEA7 | 66 0F 1F 84 00 00 00 00 00 | align 10h\n0x004CEEB0 | 80 3B 00 | cmp     byte ptr [rbx], 0\n0x004CEEB3 | 74 0C | jz      short loc_4CEEC1\n0x004CEEB5 | 48 83 C3 01 | add     rbx, 1\n0x004CEEB9 | 89 CA | mov     edx, ecx\n0x004CEEBB | 29 DA | sub     edx, ebx\n0x004CEEBD | 01 C2 | add     edx, eax\n0x004CEEBF | 75 EF | jnz     short loc_4CEEB0\n0x004CEEC1 | 4D 85 ED | test    r13, r13\n0x004CEEC4 | 74 62 | jz      short loc_4CEF28\n0x004CEEC6 | 8B 54 24 1C | mov     edx, dword ptr [rsp+58h+n]; n\n0x004CEECA | 48 89 DE | mov     rsi, rbx; s2\n0x004CEECD | 4C 89 F7 | mov     rdi, r14; s1\n0x004CEED0 | E8 7B 75 F3 FF | call    _strncmp\n0x004CEED5 | 85 C0 | test    eax, eax\n0x004CEED7 | 75 16 | jnz     short loc_4CEEEF\n0x004CEED9 | 48 89 EF | mov     rdi, rbp; ptr\n0x004CEEDC | 49 83 C4 01 | add     r12, 1\n0x004CEEE0 | E8 2B 74 F3 FF | call    _free\n0x004CEEE5 | E9 76 FF FF FF | jmp     loc_4CEE60\n0x004CEEEA | 4D 85 ED | test    r13, r13\n0x004CEEED | 74 51 | jz      short loc_4CEF40\n0x004CEEEF | 49 83 FC 01 | cmp     r12, 1\n0x004CEEF3 | 49 89 DE | mov     r14, rbx\n0x004CEEF6 | 19 C0 | sbb     eax, eax\n0x004CEEF8 | 83 E0 FE | and     eax, 0FFFFFFFEh\n0x004CEEFB | 83 C0 04 | add     eax, 4\n0x004CEEFE | 44 85 F8 | test    eax, r15d\n0x004CEF01 | 75 10 | jnz     short loc_4CEF13\n0x004CEF03 | 8B 44 24 04 | mov     eax, [rsp+58h+var_54]\n0x004CEF07 | 85 C0 | test    eax, eax\n0x004CEF09 | 75 22 | jnz     short loc_4CEF2D\n0x004CEF0B | 4C 89 EF | mov     rdi, r13; s\n0x004CEF0E | E8 AD 75 F3 FF | call    _puts\n0x004CEF13 | 4C 89 EF | mov     rdi, r13; ptr\n0x004CEF16 | E8 F5 73 F3 FF | call    _free\n0x004CEF1B | 48 85 ED | test    rbp, rbp\n0x004CEF1E | 74 20 | jz      short loc_4CEF40\n0x004CEF20 | 49 89 ED | mov     r13, rbp\n0x004CEF23 | E9 30 FF FF FF | jmp     loc_4CEE58\n0x004CEF28 | 49 89 DE | mov     r14, rbx\n0x004CEF2B | EB F3 | jmp     short loc_4CEF20\n0x004CEF2D | 49 8D 74 24 01 | lea     rsi, [r12+1]\n0x004CEF32 | BF E7 8B 52 00 | mov     edi, (offset a7lu7lu7lu7lu+0Fh); format\n0x004CEF37 | 31 C0 | xor     eax, eax\n0x004CEF39 | E8 02 79 F3 FF | call    _printf\n0x004CEF3E | EB CB | jmp     short loc_4CEF0B\n0x004CEF40 | 48 8B 3D C9 EE 27 00 | mov     rdi, cs:stdin\n0x004CEF47 | 48 8B 74 24 08 | mov     rsi, [rsp+58h+var_50]\n0x004CEF4C | E8 0F B5 F3 FF | call    sub_40A460\n0x004CEF51 | 31 FF | xor     edi, edi; status\n0x004CEF53 | E8 78 41 02 00 | call    sub_4F30D0",
        "output": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    char *s1 = \"cduf:s:w:\";\n    char *s2 = \"f+:s+:w+\";\n    int n = 0x7FFFFFFF;\n    int fd = 0;\n    int optind = 0;\n    int var_40 = 0;\n    int var_44 = 0;\n    int var_50 = 0;\n    int var_54 = 0;\n    int var_58 = 0;\n    int var_5C = 0;\n    int var_60 = 0;\n    int var_64 = 0;\n    int var_68 = 0;\n    int var_6C = 0;\n    int var_70 = 0;\n    int var_74 = 0;\n    int var_78 = 0;\n    int var_7C = 0;\n    int var_80 = 0;\n    int var_84 = 0;\n    int var_88 = 0;\n    int var_8C = 0;\n    int var_90 = 0;\n    int var_94 = 0;\n    int var_98 = 0;\n    int var_9C = 0;\n    int var_A0 = 0;\n    int var_A4 = 0;\n    int var_A8 = 0;\n    int var_AC = 0;\n    int var_B0 = 0;\n    int var_B4 = 0;\n    int var_B8 = 0;\n    int var_BC = 0;\n    int var_C0 = 0;\n    int var_C4 = 0;\n    int var_C8 = 0;\n    int var_CC = 0;\n    int var_D0 = 0;\n    int var_D4 = 0;\n    int var_D8 = 0;\n    int var_DC = 0;\n    int var_E0 = 0;\n    int var_E4 = 0;\n    int var_E8 = 0;\n    int var_EC = 0;\n    int var_F0 = 0;\n    int var_F4 = 0;\n    int var_F8 = 0;\n    int var_FC = 0;\n    int var_100 = 0;\n    int var_104 = 0;\n    int var_108 = 0;\n    int var_10C = 0;\n    int var_110 = 0;\n    int var_114 = 0;\n    int var_118 = 0;\n    int var_11C = 0;\n    int var_120 = 0;\n    int var_124 = 0;\n    int var_128 = 0;\n    int var_12C = 0;\n    int var_130 = 0;\n    int var_134 = 0;\n    int var_138 = 0;\n    int var_13C = 0;\n    int var_140 = 0;\n    int var_144 = 0;\n    int var_148 = 0;\n    int var_14C = 0;\n    int var_150 = 0;\n    int var_154 = 0;\n    int var_158 = 0;\n    int var_15C = 0;\n    int var_160 = 0;\n    int var_164 = 0;\n    int var_168 = 0;\n    int var_16C = 0;\n    int var_170 = 0;\n    int var_174 = 0;\n    int var_178 = 0;\n    int var_17C = 0;\n    int var_180 = 0;\n    int var_184 = 0;\n    int var_188 = 0;\n    int var_18C = 0;\n    int var_190 = 0;\n    int var_194 = 0;\n    int var_198 = 0;\n    int var_19C = 0;\n    int var_1A0 = 0;\n    int var_1A4 = 0;\n    int var_1A8 = 0;\n    int var_1AC = 0;\n    int var_1B0 = 0;\n    int var_1B4 = 0;\n    int var_1B8 = 0;\n    int var_1BC = 0;\n    int var_1C0 = 0;\n    int var_1C4 = 0;\n    int var_1C8 = 0;\n    int var_1CC = 0;\n    int var_1D0 = 0;\n    int var_1D4 = 0;\n    int var_1D8 = 0;\n    int var_1DC = 0;\n    int var_1E0 = 0;\n    int var_1E4 = 0;\n    int var_1E8 = 0;\n    int var_1EC = 0;\n    int var_1F0 = 0;\n    int var_1F4 = 0;\n    int var_1F8 = 0;\n    int var_1FC = 0;\n    int var_200 = 0;\n    int var_204 = 0;\n    int var_208 = 0;\n    int var_20C = 0;\n    int var_210 = 0;\n    int var_214 = 0;\n    int var_218 = 0;\n    int var_21C = 0;\n    int var_220 = 0;\n    int var_224 = 0;\n    int var_228 = 0;\n    int var_22C = 0;\n    int var_230 = 0;\n    int var_234 = 0;\n    int var_238 = 0;\n    int var_23C = 0;\n    int var_240 = 0;\n    int var_244 = 0;\n    int var_248 = 0;\n    int var_24C = 0;\n    int var_250 = 0;\n    int var_254 = 0;\n    int var_258 = 0;\n    int var_25C = 0;\n    int var_260 = 0;\n    int var_264 = 0;\n    int var_268 = 0;\n    int var_26C = 0;\n    int var_270 = 0;\n    int var_274 = 0;\n    int var_278 = 0;\n    int var_27C = 0;\n    int var_280 = 0;\n    int var_284 = 0;\n    int var_288 = 0;\n    int var_28C = 0;\n    int var_290 = 0;\n    int var_294 = 0;\n    int var_298 = 0;\n    int var_29C = 0;\n    int var_2A0 = 0;\n    int var_2A4 = 0;\n    int var_2A8 = 0;\n    int var_2AC = 0;\n    int var_2B0 = 0;\n    int var_2B4 = 0;\n    int var_2B8 = 0;\n    int var_2BC = 0;\n    int var_2C0 = 0;\n    int var_2C4 = 0;\n    int var_2C8 = 0;\n    int var_2CC = 0;\n    int var_2D0 = 0;\n    int var_2D4 = 0;\n    int var_2D8 = 0;\n    int var_2DC = 0;\n    int var_2E0 = 0;\n    int var_2E4 = 0;\n    int var_2E8 = 0;\n    int var_2EC = 0;\n    int var_2F0 = 0;\n    int var_2F4 = 0;\n    int var_2F8 = 0;\n    int var_2FC = 0;\n    int var_300 = 0;\n    int var_304 = 0;\n    int var_308 = 0;\n    int var_30C = 0;\n    int var_310 = 0;\n    int var_314 = 0;\n    int var_318 = 0;\n    int var_31C = 0;\n    int var_320 = 0;\n    int var_324 = 0;\n    int var_328 = 0;\n    int var_32C = 0;\n    int var_330 = 0;\n    int var_334 = 0;\n    int var_338 = 0;\n    int var_33C = 0;\n    int var_340 = 0;\n    int var_344 = 0;\n    int var_348 = 0;\n    int var_34C = 0;\n    int var_350 = 0;\n    int var_354 = 0;\n    int var_358 = 0;\n    int var_35C = 0;\n    int var_360 = 0;\n    int var_364 = 0;\n    int var_368 = 0;\n    int var_36C = 0;\n    int var_370 = 0;\n    int var_374 = 0;\n    int var_378 = 0;\n    int var_37C = 0;\n    int var_380 = 0;\n    int var_384 = 0;\n    int var_388 = 0;\n    int var_38C = 0;\n    int var_390 = 0;\n    int var_394 = 0;\n    int var_398 = 0;\n    int var_39C = 0;\n    int var_3A0 = 0;\n    int var_3A4 = 0;\n    int var_3A8 = 0;\n    int var_3AC = 0;\n    int var_3B0 = 0;\n    int var_3B4 = 0;\n    int var_3B8 = 0;\n    int var_3BC = 0;\n    int var_3C0 = 0;\n    int var_3C4 = 0;\n    int var_3C8 = 0;\n    int var_3CC = 0;\n    int var_3D0 = 0;\n    int var_3D4 = 0;\n    int var_3D8 = 0;\n    int var_3DC = 0;\n    int var_3E0 = 0;\n    int var_3E4 = 0;\n    int var_3E8 = 0;\n    int var_3EC = 0;\n    int var_3F0 = 0;\n    int var_3F4 = 0;\n    int var_3F8 = 0;\n    int var_3FC = 0;\n    int var_400 = 0;\n    int var_404 = 0;\n    int var_408 = 0;\n    int var_40C = 0;\n    int var_410 = 0;\n    int var_414 = 0;\n    int var_418 = 0;\n    int var_41C = 0;\n    int var_420 = 0;\n    int var_424 = 0;\n    int var_428 = 0;\n    int var_42C = 0;\n    int var_430 = 0;\n    int var_434 = 0;\n    int var_438 = 0;\n    int var_43C = 0;\n    int var_440 = 0;\n    int var_444 = 0;\n    int var_448 = 0;\n    int var_44C = 0;\n    int var_450 = 0;\n    int var_454 = 0;\n    int var_458 = 0;\n    int var_45C = 0;\n    int var_460 = 0;\n    int var_464 = 0;\n    int var_468 = 0;\n    int var_46C = 0;\n    int var_470 = 0;\n    int var_474 = 0;\n    int var_478 = 0;\n    int var_47C = 0;\n    int var_480 = 0;\n    int var_484 = 0;\n    int var_488 = 0;\n    int var_48C = 0;\n    int var_490 = 0;\n    int var_494 = 0;\n    int var_498 = 0;\n    int var_49C = 0;\n    int var_4A0 = 0;\n    int var_4A4 = 0;\n    int var_4A8 = 0;\n    int var_4AC = 0;\n    int var_4B0 = 0;\n    int var_4B4 = 0;\n    int var_4B8 = 0;\n    int var_4BC = 0;\n    int var_4C0 = 0;\n    int var_4C4 = 0;\n    int var_4C8 = 0;\n    int var_4CC = 0;\n    int var_4D0 = 0;\n    int var_4D4 = 0;\n    int var_4D8 = 0;\n    int var_4DC = 0;\n    int var_4E0 = 0;\n    int var_4E4 = 0;\n    int var_4E8 = 0;\n    int var_4EC = 0;\n    int var_4F0 = 0;\n    int var_4F4 = 0;\n    int var_4F8 = 0;\n    int var_4FC = 0;\n    int var_500 = 0;\n    int var_504 = 0;\n    int var_508 = 0;\n    int var_50C = 0;\n    int var_510 = 0;\n    int var_514 = 0;\n    int var_518 = 0;\n    int var_51C = 0;\n    int var_520 = 0;\n    int var_524 = 0;\n    int var_528 = 0;\n    int var_52C = 0;\n    int var_530 = 0;\n    int var_534 = 0;\n    int var_538 = 0;\n    int var_53C = 0;\n    int var_540 = 0;\n    int var_544 = 0;\n    int var_548 = 0;\n    int var_54C = 0;\n    int var_550 = 0;\n    int var_554 = 0;\n    int var_558 = 0;\n    int var_55C = 0;\n    int var_560 = 0;\n    int var_564 = 0;\n    int var_568 = 0;\n    int var_56C = 0;\n    int var_570 = 0;\n    int var_574 = 0;\n    int var_578 = 0;\n    int var_57C = 0;\n    int var_580 = 0;\n    int var_584 = 0;\n    int var_588 = 0;\n    int var_58C = 0;\n    int var_590 = 0;\n    int var_594 = 0;\n    int var_598 = 0;\n    int var_59C = 0;\n    int var_5A0 = 0;\n    int var_5A4 = 0;\n    int var_5A8 = 0;\n    int var_5AC = 0;\n    int var_5B0 = 0;\n    int var_5B4 = 0;\n    int var_5B8 = 0;\n    int var_5BC = 0;\n    int var_5C0 = 0;\n    int var_5C4 = 0;\n    int var_5C8 = 0;\n    int var_5CC = 0;\n    int var_5D0 = 0;\n    int var_5D4 = 0;\n    int var_5D8 = 0;\n    int var_5DC = 0;\n    int var_5E0 = 0;\n    int var_5E4 = 0;\n    int var_5E8 = 0;\n    int var_5EC = 0;\n    int var_5F0 = 0;\n    int var_5F4 = 0;\n    int var_5F8 = 0;\n    int var_5FC = 0;\n    int var_600 = 0;\n    int var_604 = 0;\n    int var_608 = 0;\n    int var_60C = 0;\n    int var_610 = 0;\n    int var_614 = 0;\n    int var_618 = 0;\n    int var_61C = 0;\n    int var_620 = 0;\n    int var_624 = 0;\n    int var_628 = 0;\n    int var_62C = 0;\n    int var_630 = 0;\n    int var_634 = 0;\n    int var_638 = 0;\n    int var_63C = 0;\n    int var_640 = 0;\n    int var_644 = 0;\n    int var_648 = 0;\n    int var_64C = 0;\n    int var_650 = 0;\n    int var_654 = 0;\n    int var_658 = 0;\n    int var_65C = 0;\n    int var_660 = 0;\n    int var_664 = 0;\n    int var_668 = 0;\n    int var_66C = 0;\n    int var_670 = 0;\n    int var_674 = 0;\n    int var_678 = 0;\n    int var_67C = 0;\n    int var_680 = 0;\n    int var_684 = 0;\n    int var_688 = 0;\n    int var_68C = 0;\n    int var_690 = 0;\n    int var_694 = 0;\n    int var_698 = 0;\n    int var_69C = 0;\n    int var_6A0 = 0;\n    int var_6A4 = 0;\n    int var_6A8 = 0;\n    int var_6AC = 0;\n    int var_6B0 = 0;\n    int var_6B4 = 0;\n    int var_6B8 = 0;\n    int var_6BC = 0;\n    int var_6C0 = 0;\n    int var_6C4 = 0;\n    int var_6C8 = 0;\n    int var_6CC = 0;\n    int var_6D0 = 0;\n    int var_6D4 = 0;\n    int var_6D8 = 0;\n    int var_6DC = 0;\n    int var_6E0 = 0;\n    int var_6E4 = 0;\n    int var_6E8 = 0;\n    int var_6EC = 0;\n    int var_6F0 = 0;\n    int var_6F4 = 0;\n    int var_6F8 = 0;\n    int var_6FC = 0;\n    int var_700 = 0;\n    int var_704 = 0;\n    int var_708 = 0;\n    int var_70C = 0;\n    int var_710 = 0;\n    int var_714 = 0;\n    int var_718 = 0;\n    int var_71C = 0;\n    int var_720 = 0;\n    int var_724 = 0;\n    int var_728 = 0;\n    int var_72C = 0;\n    int var_730 = 0;\n    int var_734 = 0;\n    int var_738 = 0;\n    int var_73C = 0;\n    int var_740 = 0;\n    int var_744 = 0;\n    int var_748 = 0;\n    int var_74C = 0;\n    int var_750 = 0;\n    int var_754 = 0;\n    int var_758 = 0;\n    int var_75C = 0;\n    int var_760 = 0;\n    int var_764 = 0;\n    int var_768 = 0;\n    int var_76C = 0;\n    int var_770 = 0;\n    int var_774 = 0;\n    int var_778 = 0;\n    int var_77C = 0;\n    int var_780 = 0;\n    int var_784 = 0;\n    int var_788 = 0;\n    int var_78C = 0;\n    int var_790 = 0;\n    int var_794 = 0;\n    int var_798 = 0;\n    int var_79C = 0;\n    int var_7A0 = 0;\n    int var_7A4 = 0;\n    int var_7A8 = 0;\n    int var_7AC = 0;\n    int var_7B0 = 0;\n    int var_7B4 = 0;\n    int var_7B8 = 0;\n    int var_7BC = 0;\n    int var_7C0 = 0;\n    int var_7C4 = 0;\n    int var_7C8 = 0;\n    int var_7CC = 0;\n    int var_7D0 = 0;\n    int var_7D4 = 0;\n    int var_7D8 = 0;\n    int var_7DC = 0;\n    int var_7E0 = 0;\n    int var_7E4 = 0;\n    int var_7E8 = 0;\n    int var_7EC = 0;\n    int var_7F0 = 0;\n    int var_7F4 = 0;\n    int var_7F8 = 0;\n    int var_7FC = 0;\n    int var_800 = 0;\n    int var_804 = 0;\n    int var_808 = 0;\n    int var_80C = 0;\n    int var_810 = 0;\n    int var_814 = 0;\n    int var_818 = 0;\n    int var_81C = 0;\n    int var_820 = 0;\n    int var_824 = 0;\n    int var_828 = 0;\n    int var_82C = 0;\n    int var_830 = 0;\n    int var_834 = 0;\n    int var_838 = 0;\n    int var_83C = 0;\n    int var_840 = 0;\n    int var_844 = 0;\n    int var_848 = 0;\n    int var_84C = 0;\n    int var_850 = 0;\n    int var_854 = 0;\n    int var_858 = 0;\n    int var_85C = 0;\n    int var_860 = 0;\n    int var_864 = 0;\n    int var_868 = 0;\n    int var_86C = 0;\n    int var_870 = 0;\n    int var_874 = 0;\n    int var_878 = 0;\n    int var_87C = 0;\n    int var_880 = 0;\n    int var_884 = 0;\n    int var_888 = 0;\n    int var_88C = 0;\n    int var_890 = 0;\n    int var_894 = 0;\n    int var_898 = 0;\n    int var_89C = 0;\n    int var_8A0 = 0;\n    int var_8A4 = 0;\n    int var_8A8 = 0;\n    int var_8AC = 0;\n    int var_8B0 = 0;\n    int var_8B4 = 0;\n    int var_8B8 = 0;\n    int var_8BC = 0;\n    int var_8C0 = 0;\n    int var_8C4 = 0;\n    int var_8C8 = 0;\n    int var_8CC = 0;\n    int var_8D0 = 0;\n    int var_8D4 = 0;\n    int var_8D8 = 0;\n    int var_8DC = 0;\n    int var_8E0 = 0;\n    int var_8E4 = 0;\n    int var_8E8 = 0;\n    int var_8EC = 0;\n    int var_8F0 = 0;\n    int var_8F4 = 0;\n    int var_8F8 = 0;\n    int var_8FC = 0;\n    int var_900 = 0;\n    int var_904 = 0;\n    int var_908 = 0;\n    int var_90C = 0;\n    int var_910 = 0;\n    int var_914 = 0;\n    int var_918 = 0;\n    int var_91C = 0;\n    int var_920 = 0;\n    int var_924 = 0;\n    int var_928 = 0;\n    int var_92C = 0;\n    int var_930 = 0;\n    int var_934 = 0;\n    int var_938 = 0;\n    int var_93C = 0;\n    int var_940 = 0;\n    int var_944 = 0;\n    int var_948 = 0;\n    int var_94C = 0;\n    int var_950 = 0;\n    int var_954 = 0;\n    int var_958 = 0;\n    int var_95C = 0;\n    int var_960 = 0;\n    int var_964 = 0;\n    int var_968 = 0;\n    int var_96C = 0;\n    int var_970 = 0;\n    int var_974 = 0;\n    int var_978 = 0;\n    int var_97C = 0;\n    int var_980 = 0;\n    int var_984 = 0;\n    int var_988 = 0;\n    int var_98C = 0;\n    int var_990 = 0;\n    int var_994 = 0;\n    int var_998 = 0;\n    int var_99C = 0;\n    int var_9A0 = 0;\n    int var_9A4 = 0;\n    int var_9A8 = 0;\n    int var_9AC = 0;\n    int var_9B0 = 0;\n    int var_9B4 = 0;\n    int var_9B8 = 0;\n    int var_9BC = 0;\n    int var_9C0 = 0;\n    int var_9C4 = 0;\n    int var_9C8 = 0;\n    int var_9CC = 0;\n    int var_9D0 = 0;\n    int var_9D4 = 0;\n    int var_9D8 = 0;\n    int var_9DC = 0;\n    int var_9E0 = 0;\n    int var_9E4 = 0;\n    int var_9E8 = 0;\n    int var_9EC = 0;\n    int var_9F0 = 0;\n    int var_9F4 = 0;\n    int var_9F8 = 0;\n    int var_9FC = 0;\n    int var_A00 = 0;\n    int var_A04 = 0;\n    int var_A08 = 0;\n    int var_A0C = 0;\n    int var_A10 = 0;\n    int var_A14 = 0;\n    int var_A18 = 0;\n    int var_A1C = 0;\n    int var_A20 = 0;\n    int var_A24 = 0;\n    int var_A28 = 0;\n    int var_A2C = 0;\n    int var_A30 = 0;\n    int var_A34 = 0;\n    int var_A38 = 0;\n    int var_A3C = 0;\n    int var_A40 = 0;\n    int var_A44 = 0;\n    int var_A48 = 0;\n    int var_A4C = 0;\n    int var_A50 = 0;\n    int var_A54 = 0;\n    int var_A58 = 0;\n    int var_A5C = 0;\n    int var_A60 = 0;\n    int var_A64 = 0;\n    int var_A68 = 0;\n    int var_A6C = 0;\n    int var_A70 = 0;\n    int var_A74 = 0;\n    int var_A78 = 0;\n    int var_A7C = 0;\n    int var_A80 = 0;\n    int var_A84 = 0;\n    int var_A88 = 0;\n    int var_A8C = 0;\n    int var_A90 = 0;\n    int var_A94 = 0;\n    int var_A98 = 0;\n    int var_A9C = 0;\n    int var_AA0 = 0;\n    int var_AA4 = 0;\n    int var_AA8 = 0;\n    int var_AAC = 0;\n    int var_AB0 = 0;\n    int var_AB4 = 0;\n    int var_AB8 = 0;\n    int var_ABC = 0;\n    int var_AC0 = 0;\n    int var_AC4 = 0;\n    int var_AC8 = 0;\n    int var_ACC = 0;\n    int var_AD0 = 0;\n    int var_AD4 = 0;\n    int var_AD8 = 0;\n    int var_ADC = 0;\n    int var_AE0 = 0;\n    int var_AE4 = 0;\n    int var_AE8 = 0;\n    int var_AEC = 0;\n    int var_AF0 = 0;\n    int var_AF4 = 0;\n    int var_AF8 = 0;\n    int var_AFC = 0;\n    int var_B00 = 0;\n    int var_B04 = 0;\n    int var_B08 = 0;\n    int var_B0C = 0;\n    int var_B10 = 0;\n    int var_B14 = 0;\n    int var_B18 = 0;\n    int var_B1C = 0;\n    int var_B20 = 0;\n    int var_B24 = 0;\n    int var_B28 = 0;\n    int var_B2C = 0;\n    int var_B30 = 0;\n    int var_B34 = 0;\n    int var_B38 = 0;\n    int var_B3C = 0;\n    int var_B40 = 0;\n    int var_B44 = 0;\n    int var_B48 = 0;\n    int var_B4C = 0;\n    int var_B50 = 0;\n    int var_B54 = 0;\n    int var_B58 = 0;\n    int var_B5C = 0;\n    int var_B60 = 0;\n    int var_B64 = 0;\n    int var_B68 = 0;\n    int var_B6C = 0;\n    int var_B70 = 0;\n    int var_B74 = 0;\n    int var_B78 = 0;\n    int var_B7C = 0;\n    int var_B80 = 0;\n    int var_B84 = 0;\n    int var_B88 = 0;\n    int var_B8C = 0;\n    int var_B90 = 0;\n    int var_B94 = 0;\n    int var_B98 = 0;\n    int var_B9C = 0;\n    int var_BA0 = 0;\n    int var_BA4 = 0;\n    int var_BA8 = 0;\n    int var_BAC = 0;\n    int var_BB0 = 0;\n    int var_BB4 = 0;\n    int var_BB8 = 0;\n    int var_BBC = 0;\n    int var_BC0 = 0;\n    int var_BC4 = 0;\n    int var_BC8 = 0;\n    int var_BCC = 0;\n    int var_BD0 = 0;\n    int var_BD4 = 0;\n    int var_BD8 = 0;\n    int var_BDC = 0;\n    int var_BE0 = 0;\n    int var_BE4 = 0;\n    int var_BE8 = 0;\n    int var_BEC = 0;\n    int var_BF0 = 0;\n    int var_BF4 = 0;\n    int var_BF8 = 0;\n    int var_BFC = 0;\n    int var_C00 = 0;\n    int var_C04 = 0;\n    int var_C08 = 0;\n    int var_C0C = 0;\n    int var_C10 = 0;\n    int var_C14 = 0;\n    int var_C18 = 0;\n    int var_C1C = 0;\n    int var_C20 = 0;\n    int var_C24 = 0;\n    int var_C28 = 0;\n    int var_C2C = 0;\n    int var_C30 = 0;\n    int var_C34 = 0;\n    int var_C38 = 0;\n    int var_C3C = 0;\n    int var_C40 = 0;\n    int var_C44 = 0;\n    int var_C48 = 0;\n    int var_C4C = 0;\n    int var_C50 = 0;\n    int var_C54 = 0;\n    int var_C58 = 0;\n    int var_C5C = 0;\n    int var_C60 = 0;\n    int var_C64 = 0;\n    int var_C68 = 0;\n    int var_C6C = 0;\n    int var_C70 = 0;\n    int var_C74 = 0;\n    int var_C78 = 0;\n    int var_C7C = 0;\n    int var_C80 = 0;\n    int var_C84 = 0;\n    int var_C88 = 0;\n    int var_C8C = 0;\n    int var_C90 = 0;\n    int var_C94 = 0;\n    int var_C98 = 0;\n    int var_C9C = 0;\n    int var_CA0 = 0;\n    int var_CA4 = 0;\n    int var_CA8 = 0;\n    int var_CAC = 0;\n    int var_CB0 = 0;\n    int var_CB4 = 0;\n    int var_CB8 = 0;\n    int var_CBC = 0;\n    int var_CC0 = 0;\n    int var_CC4 = 0;\n    int var_CC8 = 0;\n    int var_CCC = 0;\n    int var_CD0 = 0;\n    int var_CD4 = 0;\n    int var_CD8 = 0;\n    int var_CDC = 0;\n    int var_CE0 = 0;\n    int var_CE4 = 0;\n    int var_CE8 = 0;\n    int var_CEC = 0;\n    int var_CF0 = 0;\n    int var_CF4 = 0;\n    int var_CF8 = 0;\n    int var_CFC = 0;\n    int var_D00 = 0;\n    int var_D04 = 0;\n    int var_D08 = 0;\n    int var_D0C = 0;\n    int var_D10 = 0;\n    int var_D14 = 0;\n    int var_D18 = 0;\n    int var_D1C = 0;\n    int var_D20 = 0;\n    int var_D24 = 0;\n    int var_D28 = 0;\n    int var_D2C = 0;\n    int var_D30 = 0;\n    int var_D34 = 0;\n    int var_D38 = 0;\n    int var_D3C = 0;\n    int var_D40 = 0;\n    int var_D44 = 0;\n    int var_D48 = 0;\n    int var_D4C = 0;\n    int var_D50 = 0;\n    int var_D54 = 0;\n    int var_D58 = 0;\n    int var_D5C = 0;\n    int var_D60 = 0;\n    int var_D64 = 0;\n    int var_D68 = 0;\n    int var_D6C = 0;\n    int var_D70 = 0;\n    int var_D74 = 0;\n    int var_D78 = 0;\n    int var_D7C = 0;\n    int var_D80 = 0;\n    int var_D84 = 0;\n    int var_D88 = 0;\n    int var_D8C = 0;\n    int var_D90 = 0;\n    int var_D94 = 0;\n    int var_D98 = 0;\n    int var_D9C = 0;\n    int var_DA0 = 0;\n    int var_DA4 = 0;\n    int var_DA8 = 0;\n    int var_DAC = 0;\n    int var_DB0 = 0;\n    int var_DB4 = 0;\n    int var_DB8 = 0;\n    int var_DBC = 0;\n    int var_DC0 = 0;\n    int var_DC4 = 0;\n    int var_DC8 = 0;\n    int var_DCC = 0;\n    int var_DD0 = 0;\n    int var_DD4 = 0;\n    int var_DD8 = 0;\n    int var_DDC = 0;\n    int var_DE0 = 0;\n    int var_DE4 = 0;\n    int var_DE8 = 0;\n    int var_DEC = 0;\n    int var_DF0 = 0;\n    int var_DF4 = 0;\n    int var_DF8 = 0;\n    int var_DFC = 0;\n    int var_E00 = 0;\n    int var_E04 = 0;\n    int var_E08 = 0;\n    int var_E0C = 0;\n    int var_E10 = 0;\n    int var_E14 = 0;\n    int var_E18 = 0;\n    int var_E1C = 0;\n    int var_E20 = 0;\n    int var_E24 = 0;\n    int var_E28 = 0;\n    int var_E2C = 0;\n    int var_E30 = 0;\n    int var_E34 = 0;\n    int var_E38 = 0;\n    int var_E3C = 0;\n    int var_E40 = 0;\n    int var_E44 = 0;\n    int var_E48 = 0;\n    int var_E4C = 0;\n    int var_E50 = 0;\n    int var_E54 = 0;\n    int var_E58 = 0;\n    int var_E5C = 0;\n    int var_E60 = 0;\n    int var_E64 = 0;\n    int var_E68 = 0;\n    int var_E6C = 0;\n    int var_E70 = 0;\n    int var_E74 = 0;\n    int var_E78 = 0;\n    int var_E7C = 0;\n    int var_E80 = 0;\n    int var_E84 = 0;\n    int var_E88 = 0;\n    int var_E8C = 0;\n    int var_E90 = 0;\n    int var_E94 = 0;\n    int var_E98 = 0;\n    int var_E9C = 0;\n    int var_EA0 = 0;\n    int var_EA4 = 0;\n    int var_EA8 = 0;\n    int var_EAC = 0;\n    int var_EB0 = 0;\n    int var_EB4 = 0;\n    int var_EB8 = 0;\n    int var_EBC = 0;\n    int var_EC0 = 0;\n    int var_EC4 = 0;\n    int var_EC8 = 0;\n    int var_ECC = 0;\n    int var_ED0 = 0;\n    int var_ED4 = 0;\n    int var_ED8 = 0;\n    int var_EDC = 0;\n    int var_EE0 = 0;\n    int var_EE4 = 0;\n    int var_EE8 = 0;\n    int var_EEC = 0;\n    int var_EF0 = 0;\n    int var_EF4 = 0;\n    int var_EF8 = 0;\n    int var_EFC = 0;\n    int var_F00 = 0;\n    int var_F04 = 0;\n    int var_F08 = 0;\n    int var_F0C = 0;\n    int var_F10 = 0;\n    int var_F14 = 0;\n    int var_F18 = 0;\n    int var_F1C = 0;\n    int var_F20 = 0;\n    int var_F24 = 0;\n    int var_F28 = 0;\n    int var_F2C = 0;\n    int var_F30 = 0;\n    int var_F34 = 0;\n    int var_F38 = 0;\n    int var_F3C = 0;\n    int var_F40 = 0;\n    int var_F44 = 0;\n    int var_F48 = 0;\n    int var_F4C = 0;\n    int var_F50 = 0;\n    int var_F54 = 0;\n    int var_F58 = 0;\n    int var_F5C = 0;\n    int var_F60 = 0;\n    int var_F64 = 0;\n    int var_F68 = 0;\n    int var_F6C = 0;\n    int var_F70 = 0;\n    int var_F74 = 0;\n    int var_F78 = 0;\n    int var_F7C = 0;\n    int var_F80 = 0;\n    int var_F84 = 0;\n    int var_F88 = 0;\n    int var_F8C = 0;\n    int var_F90 = 0;\n    int var_F94 = 0;\n    int var_F98 = 0;\n    int var_F9C = 0;\n    int var_FA0 = 0;\n    int var_FA4 = 0;\n    int var_FA8 = 0;\n    int var_FAC = 0;\n    int var_FB0 = 0;\n    int var_FB4 = 0;\n    int var_FB8 = 0;\n    int var_FBC = 0;\n    int var_FC0 = 0;\n    int var_FC4 = 0;\n    int var_FC8 = 0;\n    int var_FCC = 0;\n    int var_FD0 = 0;\n    int var_FD4 = 0;\n    int var_FD8 = 0;\n    int var_FDC = 0;\n    int var_FE0 = 0;\n    int var_FE4 = 0;\n    int var_FE8 = 0;\n    int var_FEC = 0;\n    int var_FF0 = 0;\n    int var_FF4 = 0;\n    int var_FF8 = 0;\n    int var_FFC = 0;\n    int var_1000 = 0;\n    int var_1004 = 0;\n    int var_1008 = 0;\n    int var_100C = 0;\n    int var_1010 = 0;\n    int var_1014 = 0;\n    int var_1018 = 0;\n    int var_101C = 0;\n    int var_1020 = 0;\n    int var_1024 = 0;\n    int var_1028 = 0;\n    int var_102C = 0;\n    int var_1030 = 0;\n    int var_1034 = 0;\n    int var_1038 = 0;\n    int var_103C = 0;\n    int var_1040 = 0;\n    int var_1044 = 0;\n    int var_1048 = 0;\n    int var_104C = 0;\n    int var_1050 = 0;\n    int var_1054 = 0;\n    int var_1058 = 0;\n    int var_105C = 0;\n    int var_1060 = 0;\n    int var_1064 = 0;\n    int var_1068 = 0;\n    int var_106C = 0;\n    int var_1070 = 0;\n    int var_1074 = 0;\n    int var_1078 = 0;\n    int var_107C = 0;\n    int var_1080 = 0;\n    int var_1084 = 0;\n    int var_1088 = 0;\n    int var_108C = 0;\n    int var_1090 = 0;\n    int var_1094 = 0;\n    int var_1098 = 0;\n    int var_109C = 0;\n    int var_10A0 = 0;\n    int var_10A4 = 0;\n    int var_10A8 = 0;\n    int var_10AC = 0;\n    int var_10B0 = 0;\n    int var_10B4 = 0;\n    int var_10B8 = 0;\n    int var_10BC = 0;\n    int var_10C0 = 0;\n    int var_10C4 = 0;\n    int var_10C8 = 0;\n    int var_10CC = 0;\n    int var_10D0 = 0;\n    int var_10D4 = 0;\n    int var_10D8 = 0;\n    int var_10DC = 0;\n    int var_10E0 = 0;\n    int var_10E4 = 0;\n    int var_10E8 = 0;\n    int var_10EC = 0;\n    int var_10F0 = 0;\n    int var_10F4 = 0;\n    int var_10F8 = 0;\n    int var_10FC = 0;\n    int var_1100 = 0;\n    int var_1104 = 0;\n    int var_1108 = 0;\n    int var_110C = 0;\n    int var_1110 = 0;\n    int var_1114 = 0;\n    int var_1118 = 0;\n    int var_111C = 0;\n    int var_1120 = 0;\n    int var_1124 = 0;\n    int var_1128 = 0;\n    int var_112C = 0;\n    int var_1130 = 0;\n    int var_1134 = 0;\n    int var_1138 = 0;\n    int var_113C = 0;\n    int var_1140 = 0;\n    int var_1144 = 0;\n    int var_1148 = 0;\n    int var_114C = 0;\n    int var_1150 = 0;\n    int var_1154 = 0;\n    int var_1158 = 0;\n    int var_115C = 0;\n    int var_1160 = 0;\n    int var_1164 = 0;\n    int var_1168 = 0;\n    int var_116C = 0;\n    int var_1170 = 0;\n    int var_1174 = 0;\n    int var_1178 = 0;\n    int var_117C = 0;\n    int var_1180 = 0;\n    int var_1184 = 0;\n    int var_1188 = 0;\n    int var_118C = 0;\n    int var_1190 = 0;\n    int var_1194 = 0;\n    int var_1198 = 0;\n    int var_119C = 0;\n    int var_11A0 = 0;\n    int var_11A4 = 0;\n    int var_11A8 = 0;\n    int var_11AC = 0;\n    int var_11B0 = 0;\n    int var_11B4 = 0;\n    int var_11B8 = 0;\n    int var_11BC = 0;\n    int var_11C0 = 0;\n    int var_11C4 = 0;\n    int var_11C8 = 0;\n    int var_11CC = 0;\n    int var_11D0 = 0;\n    int var_11D4 = 0;\n    int var_11D8 = 0;\n    int var_11DC = 0;\n    int var_11E0 = 0;\n    int var_11E4 = 0;\n    int var_11E8 = 0;\n    int var_11EC = 0;\n    int var_11F0 = 0;\n    int var_11F4 = 0;\n    int var_11F8 = 0;\n    int var_11FC = 0;\n    int var_1200 = 0;\n    int var_1204 = 0;\n    int var_1208 = 0;\n    int var_120C = 0;\n    int var_1210 = 0;\n    int var_1214 = 0;\n    int var_1218 = 0;\n    int var_121C = 0;\n    int var_1220 = 0;\n    int var_1224 = 0;\n    int var_1228 = 0;\n    int var_122C = 0;\n    int var_1230 = 0;\n    int var_1234 = 0;\n    int var_1238 = 0;\n    int var_123C = 0;\n    int var_1240 = 0;\n    int var_1244 = 0;\n    int var_1248 = 0;\n    int var_124C = 0;\n    int var_1250 = 0;\n    int var_1254 = 0;\n    int var_1258 = 0;\n    int var_125C = 0;\n    int var_1260 = 0;\n    int var_1264 = 0;\n    int var_1268 = 0;\n    int var_126C = 0;\n    int var_1270 = 0;\n    int var_1274 = 0;\n    int var_1278 = 0;\n    int var_127C = 0;\n    int var_1280 = 0;\n    int var_1284 = 0;\n    int var_1288 = 0;\n    int var_128C = 0;\n    int var_1290 = 0;\n    int var_1294 = 0;\n    int var_1298 = 0;\n    int var_129C = 0;\n    int var_12A0 = 0;\n    int var_12A4 = 0;\n    int var_12A8 = 0;\n    int var_12AC = 0;\n    int var_12B0 = 0;\n    int var_12B4 = 0;\n    int var_12B8 = 0;\n    int var_12BC = 0;\n    int var_12C0 = 0;\n    int var_12C4 = 0;\n    int var_12C8 = 0;\n    int var_12CC = 0;\n    int var_12D0 = 0;\n    int var_12D4 = 0;\n    int var_12D8 = 0;\n    int var_12DC = 0;\n    int var_12E0 = 0;\n    int var_12E4 = 0;\n    int var_12E8 = 0;\n    int var_12EC = 0;\n    int var_12F0 = 0;\n    int var_12F4 = 0;\n    int var_12F8 = 0;\n    int var_12FC = 0;\n    int var_1300 = 0;\n    int var_1304 = 0;\n    int var_1308 = 0;\n    int var_130C = 0;\n    int var_1310 = 0;\n    int var_1314 = 0;\n    int var_1318 = 0;\n    int var_131C = 0;\n    int var_1320 = 0;\n    int var_1324 = 0;\n    int var_1328 = 0;\n    int var_132C = 0;\n    int var_1330 = 0;\n    int var_1334 = 0;\n    int var_1338 = 0;\n    int var_133C = 0;\n    int var_1340 = 0;\n    int var_1344 = 0;\n    int var_1348 = 0;\n    int var_134C = 0;\n    int var_1350 = 0;\n    int var_1354 = 0;\n    int var_1358 = 0;\n    int var_135C = 0;\n    int var_1360 = 0;\n    int var_1364 = 0;\n    int var_1368 = 0;\n    int var_136C = 0;\n    int var_1370 = 0;\n    int var_1374 = 0;\n    int var_1378 = 0;\n    int var_137C = 0;\n    int var_1380 = 0;\n    int var_1384 = 0;\n    int var_1388 = 0;\n    int var_138C = 0;\n    int var_1390 = 0;\n    int var_1394 = 0;\n    int var_1398 = 0;\n    int var_139C = 0;\n    int var_13A0 = 0;\n    int var_13A4 = 0;\n    int var_13A8 = 0;\n    int var_13AC = 0;\n    int var_13B0 = 0;\n    int var_13B4 = 0;\n    int var_13B8 = 0;\n    int var_13BC = 0;\n    int var_13C0 = 0;\n    int var_13C4 = 0;\n    int var_13C8 = 0;\n    int var_13CC = 0;\n    int var_13D0 = 0;\n    int var_13D4 = 0;\n    int var_13D8 = 0;\n    int var_13DC = 0;\n    int var_13E0 = 0;\n    int var_13E4 = 0;\n    int var_13E8 = 0;\n    int var_13EC = 0;\n    int var_13F0 = 0;\n    int var_13F4 = 0;\n    int var_13F8 = 0;\n    int var_13FC = 0;\n    int var_1400 = 0;\n    int var_1404 = 0;\n    int var_1408 = 0;\n    int var_140C = 0;\n    int var_1410 = 0;\n    int var_1414 = 0;\n    int var_1418 = 0;\n    int var_141C = 0;\n    int var_1420 = 0;\n    int var_1424 = 0;\n    int var_1428 = 0;\n    int var_142C = 0;\n    int var_1430 = 0;\n    int var_1434 = 0;\n    int var_1438 = 0;\n    int var_143C = 0;\n    int var_1440 = 0;\n    int var_1444 = 0;\n    int var_1448 = 0;\n    int var_144C = 0;\n    int var_1450 = 0;\n    int var_1454 = 0;\n    int var_1458 = 0;\n    int var_145C = 0;\n    int var_1460 = 0;\n    int var_1464 = 0;\n    int var_1468 = 0;\n    int var_146C = 0;\n    int var_1470 = 0;\n    int var_1474 = 0;\n    int var_1478 = 0;\n    int var_147C = 0;\n    int var_1480 = 0;\n    int var_1484 = 0;\n    int var_1488 = 0;\n    int var_148C = 0;\n    int var_1490 = 0;\n    int var_1494 = 0;\n    int var_1498 = 0;\n    int var_149C = 0;\n    int var_14A0 = 0;\n    int var_14A4 = 0;\n    int var_14A8 = 0;\n    int var_14AC = 0;\n    int var_14B0 = 0;\n    int var_14B4 = 0;\n    int var_14B8 = 0;\n    int var_14BC = 0;\n    int var_14C0 = 0;\n    int var_14C4 = 0;\n    int var_14C8 = 0;\n    int var_14CC = 0;\n    int var_14D0 = 0;\n    int var_14D4 = 0;\n    int var_14D8 = 0;\n    int var_14DC = 0;\n    int var_14E0 = 0;\n    int var_14E4 = 0;\n    int var_14E8 = 0;\n    int var_14EC = 0;\n    int var_14F0 = 0;\n    int var_14F4 = 0;\n    int var_14F8 = 0;\n    int var_14FC = 0;\n    int var"
    },
    {
        "func_name": "lsof_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004553E0 | 41 55 | push    r13\n0x004553E2 | 41 54 | push    r12\n0x004553E4 | 55 | push    rbp\n0x004553E5 | 31 ED | xor     ebp, ebp\n0x004553E7 | 53 | push    rbx\n0x004553E8 | 48 83 EC 38 | sub     rsp, 38h\n0x004553EC | 0F 1F 40 00 | nop     dword ptr [rax+00h]\n0x004553F0 | 48 89 EF | mov     rdi, rbp; ptr\n0x004553F3 | BE 01 01 00 00 | mov     esi, 101h\n0x004553F8 | E8 C3 79 0A 00 | call    sub_4FCDC0\n0x004553FD | 48 89 C5 | mov     rbp, rax\n0x00455400 | 48 85 C0 | test    rax, rax\n0x00455403 | 0F 84 97 00 00 00 | jz      loc_4554A0\n0x00455409 | E8 F2 11 FB FF | call    _getpid\n0x0045540E | 8B 55 58 | mov     edx, [rbp+58h]\n0x00455411 | 39 D0 | cmp     eax, edx\n0x00455413 | 74 DB | jz      short loc_4553F0\n0x00455415 | BE 27 8A 52 00 | mov     esi, offset aProcUFd; \"/proc/%u/fd/\"\n0x0045541A | 48 89 E7 | mov     rdi, rsp; s\n0x0045541D | 31 C0 | xor     eax, eax\n0x0045541F | E8 6C 22 FB FF | call    _sprintf\n0x00455424 | 48 89 E7 | mov     rdi, rsp; name\n0x00455427 | 4C 63 E0 | movsxd  r12, eax\n0x0045542A | E8 81 12 FB FF | call    _opendir\n0x0045542F | 48 89 C3 | mov     rbx, rax\n0x00455432 | 48 85 C0 | test    rax, rax\n0x00455435 | 74 B9 | jz      short loc_4553F0\n0x00455437 | EB 0D | jmp     short loc_455446\n0x00455439 | 0F 1F 80 00 00 00 00 | align 20h\n0x00455440 | 80 78 12 0A | cmp     byte ptr [rax+12h], 0Ah\n0x00455444 | 74 1A | jz      short loc_455460\n0x00455446 | 48 89 DF | mov     rdi, rbx; dirp\n0x00455449 | E8 12 1F FB FF | call    _readdir64\n0x0045544E | 48 85 C0 | test    rax, rax\n0x00455451 | 75 ED | jnz     short loc_455440\n0x00455453 | 48 89 DF | mov     rdi, rbx; dirp\n0x00455456 | E8 A5 16 FB FF | call    _closedir\n0x0045545B | EB 93 | jmp     short loc_4553F0\n0x0045545D | 0F 1F 00 | align 20h\n0x00455460 | 48 8D 70 13 | lea     rsi, [rax+13h]\n0x00455464 | 4A 8D 3C 24 | lea     rdi, [rsp+r12+58h+var_58]\n0x00455468 | BA 0A 00 00 00 | mov     edx, 0Ah\n0x0045546D | E8 FE BA 0A 00 | call    sub_500F70\n0x00455472 | 48 89 E7 | mov     rdi, rsp; path\n0x00455475 | E8 A6 58 FB FF | call    sub_40AD20\n0x0045547A | 48 8B 55 20 | mov     rdx, [rbp+20h]\n0x0045547E | 8B 75 58 | mov     esi, [rbp+58h]\n0x00455481 | BF 34 8A 52 00 | mov     edi, offset aD_10; \"%d\"\n0x00455486 | 49 89 C5 | mov     r13, rax\n0x00455489 | 48 89 C1 | mov     rcx, rax\n0x0045548C | 31 C0 | xor     eax, eax\n0x0045548E | E8 AD 13 FB FF | call    _printf\n0x00455493 | 4C 89 EF | mov     rdi, r13; ptr\n0x00455496 | E8 75 0E FB FF | call    _free\n0x0045549B | EB A9 | jmp     short loc_455446\n0x0045549D | 0F 1F 00 | align 20h\n0x004554A0 | 48 83 C4 38 | add     rsp, 38h\n0x004554A4 | 31 C0 | xor     eax, eax\n0x004554A6 | 5B | pop     rbx\n0x004554A7 | 5D | pop     rbp\n0x004554A8 | 41 5C | pop     r12\n0x004554AA | 41 5D | pop     r13\n0x004554AC | C3 | retn",
        "output": "```c\nvoid function() {\n    // Prologue\n    push r13\n    push r12\n    push rbp\n    xor ebp, ebp\n    push rbx\n    sub rsp, 0x38\n\n    // Function body\n    mov rdi, rbp\n    mov esi, 0x101\n    call sub_4FCDC0\n    mov rbp, rax\n    test rax, rax\n    jz loc_4554A0\n    call _getpid\n    mov edx, [rbp+0x58]\n    cmp eax, edx\n    jz loc_4553F0\n    mov esi, offset aProcUFd\n    mov rdi, rsp\n    xor eax, eax\n    call _sprintf\n    mov rdi, rsp\n    movsxd r12, eax\n    call _opendir\n    mov rbx, rax\n    test rax, rax\n    jz loc_4553F0\n    jmp loc_455446\n\nloc_455440:\n    cmp byte ptr [rax+0x12], 0x0A\n    jz loc_455460\n    mov rdi, rbx\n    call _readdir64\n    test rax, rax\n    jnz loc_455440\n    mov rdi, rbx\n    call _closedir\n    jmp loc_4553F0\n\nloc_455460:\n    lea rsi, [rax+0x13]\n    lea rdi, [rsp+r12+0x58]\n    mov edx, 0x0A\n    call sub_500F70\n    mov rdi, rsp\n    call sub_40AD20\n    mov rdx, [rbp+0x20]\n    mov esi, [rbp+0x58]\n    mov edi, offset aD_10\n    mov r13, rax\n    mov rcx, rax\n    xor eax, eax\n    call _printf\n    mov rdi, r13\n    call _free\n    jmp loc_455446\n\nloc_455446:\n    // Epilogue\n    add rsp, 0x38\n    xor eax, eax\n    pop rbx\n    pop rbp\n    pop r12\n    pop r13\n    retn\n}\n```"
    },
    {
        "func_name": "setvar",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00468A20 | 41 57 | push    r15\n0x00468A22 | 41 56 | push    r14\n0x00468A24 | 41 55 | push    r13\n0x00468A26 | 41 54 | push    r12\n0x00468A28 | 49 89 F4 | mov     r12, rsi\n0x00468A2B | 55 | push    rbp\n0x00468A2C | 48 89 FD | mov     rbp, rdi\n0x00468A2F | 53 | push    rbx\n0x00468A30 | 48 83 EC 18 | sub     rsp, 18h\n0x00468A34 | 89 54 24 0C | mov     [rsp+48h+var_3C], edx\n0x00468A38 | E8 B3 AC 01 00 | call    sub_4836F0\n0x00468A3D | BE 3D 00 00 00 | mov     esi, 3Dh ; '='; c\n0x00468A42 | 48 89 C7 | mov     rdi, rax; s\n0x00468A45 | 48 89 C3 | mov     rbx, rax\n0x00468A48 | E8 33 DB F9 FF | call    _strchrnul\n0x00468A4D | 49 89 C5 | mov     r13, rax\n0x00468A50 | 49 29 ED | sub     r13, rbp\n0x00468A53 | 0F 84 B1 00 00 00 | jz      loc_468B0A\n0x00468A59 | 48 39 C3 | cmp     rbx, rax\n0x00468A5C | 0F 85 A8 00 00 00 | jnz     loc_468B0A\n0x00468A62 | 4D 85 E4 | test    r12, r12\n0x00468A65 | 0F 84 8D 00 00 00 | jz      loc_468AF8\n0x00468A6B | 4C 89 E7 | mov     rdi, r12; s\n0x00468A6E | E8 DD DC F9 FF | call    _strlen\n0x00468A73 | 49 89 C6 | mov     r14, rax\n0x00468A76 | 48 8B 1D 1B 79 2E 00 | mov     rbx, cs:qword_750398\n0x00468A7D | 8B 43 30 | mov     eax, [rbx+30h]\n0x00468A80 | 83 C0 01 | add     eax, 1\n0x00468A83 | 89 43 30 | mov     [rbx+30h], eax\n0x00468A86 | 4B 8D 7C 2E 02 | lea     rdi, [r14+r13+2]\n0x00468A8B | E8 60 15 FA FF | call    sub_409FF0\n0x00468A90 | 4C 89 EA | mov     rdx, r13; n\n0x00468A93 | 48 89 EE | mov     rsi, rbp; src\n0x00468A96 | 49 89 C7 | mov     r15, rax\n0x00468A99 | 48 89 C7 | mov     rdi, rax; dest\n0x00468A9C | E8 9F E3 F9 FF | call    _memcpy\n0x00468AA1 | 4D 01 FD | add     r13, r15\n0x00468AA4 | 4D 85 E4 | test    r12, r12\n0x00468AA7 | 74 18 | jz      short loc_468AC1\n0x00468AA9 | 41 C6 45 00 3D | mov     byte ptr [r13+0], 3Dh ; '='\n0x00468AAE | 49 8D 7D 01 | lea     rdi, [r13+1]; dest\n0x00468AB2 | 4C 89 F2 | mov     rdx, r14; n\n0x00468AB5 | 4C 89 E6 | mov     rsi, r12; src\n0x00468AB8 | E8 83 E3 F9 FF | call    _memcpy\n0x00468ABD | 4E 8D 2C 30 | lea     r13, [rax+r14]\n0x00468AC1 | 8B 74 24 0C | mov     esi, [rsp+48h+var_3C]\n0x00468AC5 | 41 C6 45 00 00 | mov     byte ptr [r13+0], 0\n0x00468ACA | 4C 89 FF | mov     rdi, r15; ptr\n0x00468ACD | 81 CE 00 01 00 00 | or      esi, 100h\n0x00468AD3 | E8 88 F2 FF FF | call    sub_467D60\n0x00468AD8 | 83 6B 30 01 | sub     dword ptr [rbx+30h], 1\n0x00468ADC | 75 08 | jnz     short loc_468AE6\n0x00468ADE | 0F B6 43 34 | movzx   eax, byte ptr [rbx+34h]\n0x00468AE2 | 84 C0 | test    al, al\n0x00468AE4 | 75 1F | jnz     short loc_468B05\n0x00468AE6 | 48 83 C4 18 | add     rsp, 18h\n0x00468AEA | 5B | pop     rbx\n0x00468AEB | 5D | pop     rbp\n0x00468AEC | 41 5C | pop     r12\n0x00468AEE | 41 5D | pop     r13\n0x00468AF0 | 41 5E | pop     r14\n0x00468AF2 | 41 5F | pop     r15\n0x00468AF4 | C3 | retn\n0x00468AF5 | 0F 1F 00 | align 8\n0x00468AF8 | 83 4C 24 0C 20 | or      [rsp+48h+var_3C], 20h\n0x00468AFD | 45 31 F6 | xor     r14d, r14d\n0x00468B00 | E9 71 FF FF FF | jmp     loc_468A76\n0x00468B05 | E8 56 CA FF FF | call    sub_465560\n0x00468B0A | 48 89 EA | mov     rdx, rbp\n0x00468B0D | 4C 89 EE | mov     rsi, r13\n0x00468B10 | BF AB 9A 52 00 | mov     edi, offset unk_529AAB\n0x00468B15 | 31 C0 | xor     eax, eax\n0x00468B17 | E8 04 E5 FF FF | call    sub_467020",
        "output": "```c\nvoid function(char* s, int n) {\n    char* dest = s;\n    char* src = s;\n    int var_3C = n;\n    \n    dest[n] = '=';\n    dest += 1;\n    memcpy(dest, src, n);\n    dest += n;\n    dest[0] = '\\0';\n    \n    sub_467D60(dest, var_3C | 0x100);\n    \n    if (*(rbx+0x34) == 0) {\n        sub_465560();\n    }\n    \n    sub_467020(rbp, r13, offset unk_529AAB);\n}\n```"
    },
    {
        "func_name": "get_devname_from_label",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0049A180 | 55 | push    rbp\n0x0049A181 | 48 89 FD | mov     rbp, rdi\n0x0049A184 | 53 | push    rbx\n0x0049A185 | 48 83 EC 08 | sub     rsp, 8\n0x0049A189 | 48 8B 1D E8 3F 2B 00 | mov     rbx, cs:qword_74E178\n0x0049A190 | 48 85 DB | test    rbx, rbx\n0x0049A193 | 74 2B | jz      short loc_49A1C0\n0x0049A195 | 0F 1F 00 | nop     dword ptr [rax]\n0x0049A198 | 48 8B 73 10 | mov     rsi, [rbx+10h]; s2\n0x0049A19C | 80 3E 00 | cmp     byte ptr [rsi], 0\n0x0049A19F | 74 0C | jz      short loc_49A1AD\n0x0049A1A1 | 48 89 EF | mov     rdi, rbp; s1\n0x0049A1A4 | E8 37 CB F6 FF | call    _strcmp\n0x0049A1A9 | 85 C0 | test    eax, eax\n0x0049A1AB | 74 43 | jz      short loc_49A1F0\n0x0049A1AD | 48 8B 1B | mov     rbx, [rbx]\n0x0049A1B0 | 48 85 DB | test    rbx, rbx\n0x0049A1B3 | 75 E3 | jnz     short loc_49A198\n0x0049A1B5 | 48 83 C4 08 | add     rsp, 8\n0x0049A1B9 | 31 C0 | xor     eax, eax\n0x0049A1BB | 5B | pop     rbx\n0x0049A1BC | 5D | pop     rbp\n0x0049A1BD | C3 | retn\n0x0049A1BE | 66 90 | align 20h\n0x0049A1C0 | 45 31 C9 | xor     r9d, r9d\n0x0049A1C3 | 45 31 C0 | xor     r8d, r8d\n0x0049A1C6 | 31 C9 | xor     ecx, ecx\n0x0049A1C8 | BA 30 A1 49 00 | mov     edx, offset sub_49A130\n0x0049A1CD | BE 01 00 00 00 | mov     esi, 1\n0x0049A1D2 | BF 48 7E 52 00 | mov     edi, offset aDev_0; \"/dev\"\n0x0049A1D7 | E8 84 65 06 00 | call    sub_500760\n0x0049A1DC | 48 8B 1D 95 3F 2B 00 | mov     rbx, cs:qword_74E178\n0x0049A1E3 | 48 85 DB | test    rbx, rbx\n0x0049A1E6 | 75 B0 | jnz     short loc_49A198\n0x0049A1E8 | EB CB | jmp     short loc_49A1B5\n0x0049A1EA | 66 0F 1F 44 00 00 | align 10h\n0x0049A1F0 | 48 8B 7B 08 | mov     rdi, [rbx+8]\n0x0049A1F4 | 48 83 C4 08 | add     rsp, 8\n0x0049A1F8 | 5B | pop     rbx\n0x0049A1F9 | 5D | pop     rbp\n0x0049A1FA | E9 61 FE F6 FF | jmp     sub_40A060",
        "output": "```c\nvoid function(void* rdi) {\n    push rbp;\n    mov rbp, rdi;\n    push rbx;\n    sub rsp, 8;\n    mov rbx, cs:qword_74E178;\n    test rbx, rbx;\n    jz short loc_49A1C0;\n    nop dword ptr [rax];\n    mov rsi, [rbx+10h]; // s2\n    cmp byte ptr [rsi], 0;\n    jz short loc_49A1AD;\n    mov rdi, rbp; // s1\n    call _strcmp;\n    test eax, eax;\n    jz short loc_49A1F0;\nloc_49A1AD:\n    mov rbx, [rbx];\n    test rbx, rbx;\n    jnz short loc_49A198;\n    add rsp, 8;\n    xor eax, eax;\n    pop rbx;\n    pop rbp;\n    retn;\nloc_49A1C0:\n    xor r9d, r9d;\n    xor r8d, r8d;\n    xor ecx, ecx;\n    mov edx, offset sub_49A130;\n    mov esi, 1;\n    mov edi, offset aDev_0; // \"/dev\"\n    call sub_500760;\n    mov rbx, cs:qword_74E178;\n    test rbx, rbx;\n    jnz short loc_49A198;\n    jmp short loc_49A1B5;\nloc_49A1F0:\n    mov rdi, [rbx+8];\n    add rsp, 8;\n    pop rbx;\n    pop rbp;\n    jmp sub_40A060;\n}\n```"
    },
    {
        "func_name": "xget_uidgid",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040D0C0 | 53 | push    rbx\n0x0040D0C1 | BA 01 00 00 00 | mov     edx, 1\n0x0040D0C6 | 48 89 F3 | mov     rbx, rsi\n0x0040D0C9 | E8 B2 FE FF FF | call    sub_40CF80\n0x0040D0CE | 85 C0 | test    eax, eax\n0x0040D0D0 | 74 02 | jz      short loc_40D0D4\n0x0040D0D2 | 5B | pop     rbx\n0x0040D0D3 | C3 | retn\n0x0040D0D4 | 48 89 DE | mov     rsi, rbx\n0x0040D0D7 | BF 80 2E 52 00 | mov     edi, offset aUnknownUserGro_0; \"unknown user/group %s\"\n0x0040D0DC | E8 DF BB FF FF | call    sub_408CC0",
        "output": "```c\nvoid function() {\n    push rbx;\n    mov edx, 1;\n    mov rbx, rsi;\n    call sub_40CF80;\n    if (eax == 0) {\n        pop rbx;\n        return;\n    }\n    mov rsi, rbx;\n    mov edi, offset aUnknownUserGro_0; // \"unknown user/group %s\"\n    call sub_408CC0;\n}\n```"
    },
    {
        "func_name": "free_session",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043DCC0 | 53 | push    rbx\n0x0043DCC1 | F6 05 08 27 31 00 08 | test    byte ptr cs:dword_7503D0, 8\n0x0043DCC8 | 0F 85 A2 00 00 00 | jnz     loc_43DD70\n0x0043DCCE | 48 8B 15 A3 06 31 00 | mov     rdx, qword ptr cs:dest.c_iflag\n0x0043DCD5 | 48 89 FB | mov     rbx, rdi\n0x0043DCD8 | 48 8B 0F | mov     rcx, [rdi]\n0x0043DCDB | 48 39 FA | cmp     rdx, rdi\n0x0043DCDE | 75 13 | jnz     short loc_43DCF3\n0x0043DCE0 | 48 89 0D 91 06 31 00 | mov     qword ptr cs:dest.c_iflag, rcx\n0x0043DCE7 | EB 15 | jmp     short loc_43DCFE\n0x0043DCE9 | 0F 1F 80 00 00 00 00 | align 10h\n0x0043DCF0 | 48 89 C2 | mov     rdx, rax\n0x0043DCF3 | 48 8B 02 | mov     rax, [rdx]\n0x0043DCF6 | 48 39 D8 | cmp     rax, rbx\n0x0043DCF9 | 75 F5 | jnz     short loc_43DCF0\n0x0043DCFB | 48 89 0A | mov     [rdx], rcx\n0x0043DCFE | 8B 7B 14 | mov     edi, [rbx+14h]; fd\n0x0043DD01 | E8 7A 8D FC FF | call    _close\n0x0043DD06 | 8B 7B 0C | mov     edi, [rbx+0Ch]; fd\n0x0043DD09 | E8 72 8D FC FF | call    _close\n0x0043DD0E | 48 89 DF | mov     rdi, rbx; ptr\n0x0043DD11 | E8 FA 85 FC FF | call    _free\n0x0043DD16 | 48 8B 05 5B 06 31 00 | mov     rax, qword ptr cs:dest.c_iflag\n0x0043DD1D | 31 D2 | xor     edx, edx\n0x0043DD1F | C7 05 67 06 31 00 00 00 00 00 | mov     dword ptr cs:dest.c_cc+7, 0\n0x0043DD29 | 48 85 C0 | test    rax, rax\n0x0043DD2C | 74 3E | jz      short loc_43DD6C\n0x0043DD2E | 66 90 | xchg    ax, ax\n0x0043DD30 | 8B 48 14 | mov     ecx, [rax+14h]\n0x0043DD33 | 39 CA | cmp     edx, ecx\n0x0043DD35 | 7D 08 | jge     short loc_43DD3F\n0x0043DD37 | 89 0D 53 06 31 00 | mov     dword ptr cs:dest.c_cc+7, ecx\n0x0043DD3D | 89 CA | mov     edx, ecx\n0x0043DD3F | 8B 48 0C | mov     ecx, [rax+0Ch]\n0x0043DD42 | 39 D1 | cmp     ecx, edx\n0x0043DD44 | 7E 1E | jle     short loc_43DD64\n0x0043DD46 | 89 0D 44 06 31 00 | mov     dword ptr cs:dest.c_cc+7, ecx\n0x0043DD4C | 48 8B 00 | mov     rax, [rax]\n0x0043DD4F | 48 85 C0 | test    rax, rax\n0x0043DD52 | 74 18 | jz      short loc_43DD6C\n0x0043DD54 | 89 CA | mov     edx, ecx\n0x0043DD56 | 8B 48 14 | mov     ecx, [rax+14h]\n0x0043DD59 | 39 CA | cmp     edx, ecx\n0x0043DD5B | 7C DA | jl      short loc_43DD37\n0x0043DD5D | 8B 48 0C | mov     ecx, [rax+0Ch]\n0x0043DD60 | 39 D1 | cmp     ecx, edx\n0x0043DD62 | 7F E2 | jg      short loc_43DD46\n0x0043DD64 | 48 8B 00 | mov     rax, [rax]\n0x0043DD67 | 48 85 C0 | test    rax, rax\n0x0043DD6A | 75 C4 | jnz     short loc_43DD30\n0x0043DD6C | 5B | pop     rbx\n0x0043DD6D | C3 | retn\n0x0043DD6E | 66 90 | align 10h\n0x0043DD70 | 31 FF | xor     edi, edi; status\n0x0043DD72 | E8 59 99 FC FF | call    _exit",
        "output": "```c\nvoid function() {\n    push rbx;\n    test byte ptr cs:dword_7503D0, 8;\n    jnz loc_43DD70;\n    mov rdx, qword ptr cs:dest.c_iflag;\n    mov rbx, rdi;\n    mov rcx, [rdi];\n    cmp rdx, rdi;\n    jnz short loc_43DCF3;\n    mov qword ptr cs:dest.c_iflag, rcx;\n    jmp short loc_43DCFE;\n    align 10h;\nloc_43DCF0:\n    mov rdx, rax;\n    mov rax, [rdx];\n    cmp rax, rbx;\n    jnz short loc_43DCF0;\n    mov [rdx], rcx;\nloc_43DCFE:\n    mov edi, [rbx+14h]; fd\n    call _close;\n    mov edi, [rbx+0Ch]; fd\n    call _close;\n    mov rdi, rbx; ptr\n    call _free;\n    mov rax, qword ptr cs:dest.c_iflag;\n    xor edx, edx;\n    mov dword ptr cs:dest.c_cc+7, 0;\n    test rax, rax;\n    jz short loc_43DD6C;\n    xchg ax, ax;\n    mov ecx, [rax+14h];\n    cmp edx, ecx;\n    jge short loc_43DD3F;\n    mov dword ptr cs:dest.c_cc+7, ecx;\n    mov edx, ecx;\nloc_43DD3F:\n    mov ecx, [rax+0Ch];\n    cmp ecx, edx;\n    jle short loc_43DD64;\n    mov dword ptr cs:dest.c_cc+7, ecx;\n    mov rax, [rax];\n    test rax, rax;\n    jz short loc_43DD6C;\n    mov edx, ecx;\n    mov ecx, [rax+14h];\n    cmp edx, ecx;\n    jl short loc_43DD37;\n    mov ecx, [rax+0Ch];\n    cmp ecx, edx;\n    jg short loc_43DD46;\nloc_43DD64:\n    mov rax, [rax];\n    test rax, rax;\n    jnz short loc_43DD30;\nloc_43DD6C:\n    pop rbx;\n    retn;\n    align 10h;\nloc_43DD70:\n    xor edi, edi; status\n    call _exit;\n}\n```"
    },
    {
        "func_name": "INET6_rresolve",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F7640 | 66 83 3F 0A | cmp     word ptr [rdi], 0Ah\n0x004F7644 | 0F 85 96 00 00 00 | jnz     loc_4F76E0\n0x004F764A | 48 81 EC 88 00 00 00 | sub     rsp, 88h\n0x004F7651 | F7 C6 FF 7F 00 00 | test    esi, 7FFFh\n0x004F7657 | 0F 85 A3 00 00 00 | jnz     loc_4F7700\n0x004F765D | 44 8B 5F 08 | mov     r11d, [rdi+8]\n0x004F7661 | 45 85 DB | test    r11d, r11d\n0x004F7664 | 75 3A | jnz     short loc_4F76A0\n0x004F7666 | 44 8B 57 0C | mov     r10d, [rdi+0Ch]\n0x004F766A | 45 85 D2 | test    r10d, r10d\n0x004F766D | 75 31 | jnz     short loc_4F76A0\n0x004F766F | 44 8B 4F 10 | mov     r9d, [rdi+10h]\n0x004F7673 | 45 85 C9 | test    r9d, r9d\n0x004F7676 | 75 28 | jnz     short loc_4F76A0\n0x004F7678 | 44 8B 47 14 | mov     r8d, [rdi+14h]\n0x004F767C | 45 85 C0 | test    r8d, r8d\n0x004F767F | 75 1F | jnz     short loc_4F76A0\n0x004F7681 | 81 E6 00 80 00 00 | and     esi, 8000h\n0x004F7687 | 0F 84 A3 00 00 00 | jz      loc_4F7730\n0x004F768D | BF CC 5A 52 00 | mov     edi, offset sa; sa\n0x004F7692 | E8 C9 29 F1 FF | call    sub_40A060\n0x004F7697 | EB 35 | jmp     short loc_4F76CE\n0x004F7699 | 0F 1F 80 00 00 00 00 | align 20h\n0x004F76A0 | 48 83 EC 08 | sub     rsp, 8\n0x004F76A4 | B9 80 00 00 00 | mov     ecx, 80h; hostlen\n0x004F76A9 | 45 31 C9 | xor     r9d, r9d; servlen\n0x004F76AC | 45 31 C0 | xor     r8d, r8d; serv\n0x004F76AF | 6A 00 | push    0; flags\n0x004F76B1 | BE 1C 00 00 00 | mov     esi, 1Ch; salen\n0x004F76B6 | 48 8D 54 24 10 | lea     rdx, [rsp+98h+host]; host\n0x004F76BB | E8 10 F4 F0 FF | call    _getnameinfo\n0x004F76C0 | 5A | pop     rdx\n0x004F76C1 | 59 | pop     rcx\n0x004F76C2 | 85 C0 | test    eax, eax\n0x004F76C4 | 75 2A | jnz     short loc_4F76F0\n0x004F76C6 | 48 89 E7 | mov     rdi, rsp\n0x004F76C9 | E8 92 29 F1 FF | call    sub_40A060\n0x004F76CE | 48 81 C4 88 00 00 00 | add     rsp, 88h\n0x004F76D5 | C3 | retn\n0x004F76D6 | 66 2E 0F 1F 84 00 00 00 00 00 | align 20h\n0x004F76E0 | 48 8B 05 99 8C 25 00 | mov     rax, cs:qword_750380\n0x004F76E7 | C7 00 61 00 00 00 | mov     dword ptr [rax], 61h ; 'a'\n0x004F76ED | 31 C0 | xor     eax, eax\n0x004F76EF | C3 | retn\n0x004F76F0 | 31 C0 | xor     eax, eax\n0x004F76F2 | BF 9C EB 52 00 | mov     edi, offset aGetnameinfoFai; \"getnameinfo failed\"\n0x004F76F7 | E8 64 16 F1 FF | call    sub_408D60\n0x004F76FC | 31 C0 | xor     eax, eax\n0x004F76FE | EB CE | jmp     short loc_4F76CE\n0x004F7700 | 48 8D 77 08 | lea     rsi, [rdi+8]; cp\n0x004F7704 | 48 89 E2 | mov     rdx, rsp; buf\n0x004F7707 | B9 80 00 00 00 | mov     ecx, 80h; len\n0x004F770C | BF 0A 00 00 00 | mov     edi, 0Ah; af\n0x004F7711 | E8 9A EB F0 FF | call    _inet_ntop\n0x004F7716 | 48 89 E7 | mov     rdi, rsp\n0x004F7719 | E8 42 29 F1 FF | call    sub_40A060\n0x004F771E | 48 81 C4 88 00 00 00 | add     rsp, 88h\n0x004F7725 | C3 | retn\n0x004F7726 | 66 2E 0F 1F 84 00 00 00 00 00 | align 10h\n0x004F7730 | BF 06 3C 52 00 | mov     edi, 523C06h\n0x004F7735 | E8 26 29 F1 FF | call    sub_40A060\n0x004F773A | EB 92 | jmp     short loc_4F76CE",
        "output": "```c\n#include <stdio.h>\n\nvoid function(unsigned char* rdi, int esi) {\n    if (*rdi != 0x0a) {\n        goto loc_4F76E0;\n    }\n    if (esi & 0x7fff) {\n        goto loc_4F7700;\n    }\n    int r11d = *(int*)(rdi + 8);\n    if (r11d != 0) {\n        goto loc_4F76A0;\n    }\n    int r10d = *(int*)(rdi + 0xc);\n    if (r10d != 0) {\n        goto loc_4F76A0;\n    }\n    int r9d = *(int*)(rdi + 0x10);\n    if (r9d != 0) {\n        goto loc_4F76A0;\n    }\n    int r8d = *(int*)(rdi + 0x14);\n    if (r8d != 0) {\n        goto loc_4F76A0;\n    }\n    esi &= 0x8000;\n    if (esi == 0) {\n        goto loc_4F7730;\n    }\n    int edi = 0x525acc;\n    sub_40A060(&edi);\n    goto loc_4F76CE;\nloc_4F76A0:\n    int ecx = 0x80;\n    int r9d = 0;\n    int r8d = 0;\n    int flags = 0;\n    int esi = 0x1c;\n    unsigned char* rdx = rdi + 0x98;\n    _getnameinfo(&rdx, &esi, &flags, &r8d, &r9d, &ecx);\n    if (eax != 0) {\n        int rdi = rsp;\n        sub_40A060(&rdi);\n    }\nloc_4F76CE:\n    return;\nloc_4F7730:\n    int edi = 0x523c06;\n    sub_40A060(&edi);\n    goto loc_4F76CE;\n}\n```"
    },
    {
        "func_name": "iface_up",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0042F920 | 41 54 | push    r12\n0x0042F922 | BE 40 EA 42 00 | mov     esi, offset sub_42EA40\n0x0042F927 | 55 | push    rbp\n0x0042F928 | 53 | push    rbx\n0x0042F929 | 48 8B 47 08 | mov     rax, [rdi+8]\n0x0042F92D | 48 89 FB | mov     rbx, rdi\n0x0042F930 | FF 50 08 | call    qword ptr [rax+8]\n0x0042F933 | BA FF FF FF FF | mov     edx, 0FFFFFFFFh\n0x0042F938 | 85 C0 | test    eax, eax\n0x0042F93A | 75 0C | jnz     short loc_42F948\n0x0042F93C | 5B | pop     rbx\n0x0042F93D | 89 D0 | mov     eax, edx\n0x0042F93F | 5D | pop     rbp\n0x0042F940 | 41 5C | pop     r12\n0x0042F942 | C3 | retn\n0x0042F943 | 0F 1F 44 00 00 | align 8\n0x0042F948 | BA FF 5F 52 00 | mov     edx, offset aPreUp; \"pre-up\"\n0x0042F94D | BE 54 5B 52 00 | mov     esi, offset aStart; \"start\"\n0x0042F952 | 48 89 DF | mov     rdi, rbx\n0x0042F955 | 31 ED | xor     ebp, ebp\n0x0042F957 | E8 C4 FA FF FF | call    sub_42F420\n0x0042F95C | 44 8B 43 18 | mov     r8d, [rbx+18h]\n0x0042F960 | 41 BC FF 5F 52 00 | mov     r12d, offset aPreUp; \"pre-up\"\n0x0042F966 | 45 85 C0 | test    r8d, r8d\n0x0042F969 | 7F 0E | jg      short loc_42F979\n0x0042F96B | EB 48 | jmp     short loc_42F9B5\n0x0042F96D | 0F 1F 00 | align 10h\n0x0042F970 | 48 83 C5 01 | add     rbp, 1\n0x0042F974 | 41 39 E8 | cmp     r8d, ebp\n0x0042F977 | 7E 3C | jle     short loc_42F9B5\n0x0042F979 | 48 89 E8 | mov     rax, rbp\n0x0042F97C | B9 07 00 00 00 | mov     ecx, 7\n0x0042F981 | 4C 89 E7 | mov     rdi, r12\n0x0042F984 | 48 C1 E0 04 | shl     rax, 4\n0x0042F988 | 48 03 43 20 | add     rax, [rbx+20h]\n0x0042F98C | 48 8B 30 | mov     rsi, [rax]\n0x0042F98F | F3 A6 | repe cmpsb\n0x0042F991 | 0F 97 C2 | setnbe  dl\n0x0042F994 | 80 DA 00 | sbb     dl, 0\n0x0042F997 | 84 D2 | test    dl, dl\n0x0042F999 | 75 D5 | jnz     short loc_42F970\n0x0042F99B | 48 8B 78 08 | mov     rdi, [rax+8]\n0x0042F99F | E8 AC F0 FF FF | call    sub_42EA50\n0x0042F9A4 | 85 C0 | test    eax, eax\n0x0042F9A6 | 74 3D | jz      short loc_42F9E5\n0x0042F9A8 | 44 8B 43 18 | mov     r8d, [rbx+18h]\n0x0042F9AC | 48 83 C5 01 | add     rbp, 1\n0x0042F9B0 | 41 39 E8 | cmp     r8d, ebp\n0x0042F9B3 | 7F C4 | jg      short loc_42F979\n0x0042F9B5 | BF 80 A6 51 00 | mov     edi, offset aRunPartsEtcNet; \"run-parts /etc/network/if-%s.d\"\n0x0042F9BA | 31 C0 | xor     eax, eax\n0x0042F9BC | BE FF 5F 52 00 | mov     esi, offset aPreUp; \"pre-up\"\n0x0042F9C1 | E8 7A AB FD FF | call    sub_40A540\n0x0042F9C6 | 48 89 C7 | mov     rdi, rax\n0x0042F9C9 | E8 82 F0 FF FF | call    sub_42EA50\n0x0042F9CE | 85 C0 | test    eax, eax\n0x0042F9D0 | 74 13 | jz      short loc_42F9E5\n0x0042F9D2 | 48 8B 43 08 | mov     rax, [rbx+8]\n0x0042F9D6 | BE 50 EA 42 00 | mov     esi, offset sub_42EA50\n0x0042F9DB | 48 89 DF | mov     rdi, rbx\n0x0042F9DE | FF 50 08 | call    qword ptr [rax+8]\n0x0042F9E1 | 85 C0 | test    eax, eax\n0x0042F9E3 | 75 0B | jnz     short loc_42F9F0\n0x0042F9E5 | 31 D2 | xor     edx, edx\n0x0042F9E7 | 5B | pop     rbx\n0x0042F9E8 | 5D | pop     rbp\n0x0042F9E9 | 89 D0 | mov     eax, edx\n0x0042F9EB | 41 5C | pop     r12\n0x0042F9ED | C3 | retn\n0x0042F9EE | 66 90 | align 10h\n0x0042F9F0 | BA 06 60 52 00 | mov     edx, offset aPostUp; \"post-up\"\n0x0042F9F5 | BE 54 5B 52 00 | mov     esi, offset aStart; \"start\"\n0x0042F9FA | 48 89 DF | mov     rdi, rbx\n0x0042F9FD | 31 ED | xor     ebp, ebp\n0x0042F9FF | E8 1C FA FF FF | call    sub_42F420\n0x0042FA04 | 44 8B 43 18 | mov     r8d, [rbx+18h]\n0x0042FA08 | 41 BC 88 5F 52 00 | mov     r12d, 525F88h\n0x0042FA0E | 45 85 C0 | test    r8d, r8d\n0x0042FA11 | 7F 0E | jg      short loc_42FA21\n0x0042FA13 | EB 48 | jmp     short loc_42FA5D\n0x0042FA15 | 0F 1F 00 | align 8\n0x0042FA18 | 48 83 C5 01 | add     rbp, 1\n0x0042FA1C | 41 39 E8 | cmp     r8d, ebp\n0x0042FA1F | 7E 3C | jle     short loc_42FA5D\n0x0042FA21 | 48 89 E8 | mov     rax, rbp\n0x0042FA24 | B9 03 00 00 00 | mov     ecx, 3\n0x0042FA29 | 4C 89 E7 | mov     rdi, r12\n0x0042FA2C | 48 C1 E0 04 | shl     rax, 4\n0x0042FA30 | 48 03 43 20 | add     rax, [rbx+20h]\n0x0042FA34 | 48 8B 30 | mov     rsi, [rax]\n0x0042FA37 | F3 A6 | repe cmpsb\n0x0042FA39 | 0F 97 C2 | setnbe  dl\n0x0042FA3C | 80 DA 00 | sbb     dl, 0\n0x0042FA3F | 84 D2 | test    dl, dl\n0x0042FA41 | 75 D5 | jnz     short loc_42FA18\n0x0042FA43 | 48 8B 78 08 | mov     rdi, [rax+8]\n0x0042FA47 | E8 04 F0 FF FF | call    sub_42EA50\n0x0042FA4C | 85 C0 | test    eax, eax\n0x0042FA4E | 74 95 | jz      short loc_42F9E5\n0x0042FA50 | 44 8B 43 18 | mov     r8d, [rbx+18h]\n0x0042FA54 | 48 83 C5 01 | add     rbp, 1\n0x0042FA58 | 41 39 E8 | cmp     r8d, ebp\n0x0042FA5B | 7F C4 | jg      short loc_42FA21\n0x0042FA5D | BE 88 5F 52 00 | mov     esi, 525F88h\n0x0042FA62 | BF 80 A6 51 00 | mov     edi, offset aRunPartsEtcNet; \"run-parts /etc/network/if-%s.d\"\n0x0042FA67 | 31 C0 | xor     eax, eax\n0x0042FA69 | E8 D2 AA FD FF | call    sub_40A540\n0x0042FA6E | 48 89 C7 | mov     rdi, rax\n0x0042FA71 | E8 DA EF FF FF | call    sub_42EA50\n0x0042FA76 | 31 D2 | xor     edx, edx\n0x0042FA78 | 5B | pop     rbx\n0x0042FA79 | 5D | pop     rbp\n0x0042FA7A | 85 C0 | test    eax, eax\n0x0042FA7C | 41 5C | pop     r12\n0x0042FA7E | 0F 95 C2 | setnz   dl\n0x0042FA81 | 89 D0 | mov     eax, edx\n0x0042FA83 | C3 | retn",
        "output": "```c\nvoid function(void* rdi) {\n    push r12;\n    mov esi, offset sub_42EA40;\n    push rbp;\n    push rbx;\n    mov rax, [rdi+8];\n    mov rbx, rdi;\n    call qword ptr [rax+8];\n    mov edx, 0xFFFFFFFF;\n    test eax, eax;\n    jnz loc_42F948;\n    pop rbx;\n    mov eax, edx;\n    pop rbp;\n    pop r12;\n    retn;\n    \nloc_42F948:\n    mov edx, offset aPreUp; // \"pre-up\"\n    mov esi, offset aStart; // \"start\"\n    mov rdi, rbx;\n    xor ebp, ebp;\n    call sub_42F420;\n    mov r8d, [rbx+18h];\n    mov r12d, offset aPreUp; // \"pre-up\"\n    test r8d, r8d;\n    jg loc_42F979;\n    jmp loc_42F9B5;\n    \nloc_42F970:\n    add rbp, 1;\n    cmp r8d, ebp;\n    jle loc_42F9B5;\n    \nloc_42F979:\n    mov rax, rbp;\n    mov ecx, 7;\n    mov rdi, r12;\n    shl rax, 4;\n    add rax, [rbx+20h];\n    mov rsi, [rax];\n    repe cmpsb;\n    setnbe dl;\n    sbb dl, 0;\n    test dl, dl;\n    jnz loc_42F970;\n    mov rdi, [rax+8];\n    call sub_42EA50;\n    test eax, eax;\n    jz loc_42F9E5;\n    mov r8d, [rbx+18h];\n    add rbp, 1;\n    cmp r8d, ebp;\n    jg loc_42F979;\n    mov edi, offset aRunPartsEtcNet; // \"run-parts /etc/network/if-%s.d\"\n    xor eax, eax;\n    mov esi, offset aPreUp; // \"pre-up\"\n    call sub_40A540;\n    mov rdi, rax;\n    call sub_42EA50;\n    test eax, eax;\n    jz loc_42F9E5;\n    mov rax, [rbx+8];\n    mov esi, offset sub_42EA50;\n    mov rdi, rbx;\n    call qword ptr [rax+8];\n    test eax, eax;\n    jnz loc_42F9F0;\n    xor edx, edx;\n    pop rbx;\n    pop rbp;\n    mov eax, edx;\n    pop r12;\n    retn;\n    \nloc_42F9F0:\n    mov edx, offset aPostUp; // \"post-up\"\n    mov esi, offset aStart; // \"start\"\n    mov rdi, rbx;\n    xor ebp, ebp;\n    call sub_42F420;\n    mov r8d, [rbx+18h];\n    mov r12d, 0x525F88;\n    test r8d, r8d;\n    jg loc_42FA21;\n    jmp loc_42FA5D;\n    \nloc_42FA18:\n    add rbp, 1;\n    cmp r8d, ebp;\n    jle loc_42FA5D;\n    \nloc_42FA21:\n    mov rax, rbp;\n    mov ecx, 3;\n    mov rdi, r12;\n    shl rax, 4;\n    add rax, [rbx+20h];\n    mov rsi, [rax];\n    repe cmpsb;\n    setnbe dl;\n    sbb dl, 0;\n    test dl, dl;\n    jnz loc_42FA18;\n    mov rdi, [rax+8];\n    call sub_42EA50;\n    test eax, eax;\n    jz loc_42F9E5;\n    mov r8d, [rbx+18h];\n    add rbp, 1;\n    cmp r8d, ebp;\n    jg loc_42FA21;\n    mov esi, 0x525F88;\n    mov edi, offset aRunPartsEtcNet; // \"run-parts /etc/network/if-%s.d\"\n    xor eax, eax;\n    call sub_40A540;\n    mov rdi, rax;\n    call sub_42EA50;\n    xor edx, edx;\n    pop rbx;\n    pop rbp;\n    test eax, eax;\n    pop r12;\n    setnz dl;\n    mov eax, edx;\n    retn;\n}\n```"
    },
    {
        "func_name": "volname_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00422B60 | 53 | push    rbx\n0x00422B61 | 48 83 EC 20 | sub     rsp, 20h\n0x00422B65 | 48 8B 7E 08 | mov     rdi, [rsi+8]\n0x00422B69 | 48 85 FF | test    rdi, rdi\n0x00422B6C | 74 4A | jz      short loc_422BB8\n0x00422B6E | 48 83 7E 10 00 | cmp     qword ptr [rsi+10h], 0\n0x00422B73 | 75 4A | jnz     short loc_422BBF\n0x00422B75 | 31 F6 | xor     esi, esi\n0x00422B77 | E8 E4 75 FE FF | call    sub_40A160\n0x00422B7C | 31 D2 | xor     edx, edx\n0x00422B7E | BE 28 80 00 00 | mov     esi, 8028h\n0x00422B83 | 89 C3 | mov     ebx, eax\n0x00422B85 | 89 C7 | mov     edi, eax\n0x00422B87 | E8 64 78 FE FF | call    sub_40A3F0\n0x00422B8C | 48 89 E6 | mov     rsi, rsp\n0x00422B8F | 89 DF | mov     edi, ebx\n0x00422B91 | BA 20 00 00 00 | mov     edx, 20h ; ' '\n0x00422B96 | E8 05 DB 0D 00 | call    sub_5006A0\n0x00422B9B | 48 89 E6 | mov     rsi, rsp\n0x00422B9E | BF 29 4E 52 00 | mov     edi, offset a3232s; \"%32.32s\\n\"\n0x00422BA3 | 31 C0 | xor     eax, eax\n0x00422BA5 | E8 96 3C FE FF | call    _printf\n0x00422BAA | 48 83 C4 20 | add     rsp, 20h\n0x00422BAE | 31 C0 | xor     eax, eax\n0x00422BB0 | 5B | pop     rbx\n0x00422BB1 | C3 | retn\n0x00422BB2 | 66 0F 1F 44 00 00 | align 8\n0x00422BB8 | BF 43 3A 52 00 | mov     edi, offset aDevCdrom; \"/dev/cdrom\"\n0x00422BBD | EB B6 | jmp     short loc_422B75\n0x00422BBF | E8 0C 4F FE FF | call    sub_407AD0",
        "output": "```c\nvoid function(void* rsi) {\n    push rbx;\n    sub rsp, 0x20;\n    void* rdi = *(rsi + 0x8);\n    if (rdi == NULL) {\n        goto loc_422BB8;\n    }\n    if (*(rsi + 0x10) != 0) {\n        goto loc_422BBF;\n    }\n    int esi = 0;\n    sub_40A160();\n    int edx = 0;\n    int esi = 0x8028;\n    int ebx = eax;\n    int edi = eax;\n    sub_40A3F0();\n    void* rsi = rsp;\n    int edi = ebx;\n    int edx = 0x20;\n    sub_5006A0();\n    void* rsi = rsp;\n    char* edi = \"%32.32s\\n\";\n    int eax = 0;\n    _printf();\n    add rsp, 0x20;\n    return;\nloc_422BB8:\n    char* edi = \"/dev/cdrom\";\n    goto loc_422B75;\nloc_422BBF:\n    sub_407AD0();\n}\n```"
    },
    {
        "func_name": "base_device",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004D1220 | 53 | push    rbx\n0x004D1221 | E8 3A 8E F3 FF | call    sub_40A060\n0x004D1226 | 48 89 C7 | mov     rdi, rax\n0x004D1229 | 48 89 C3 | mov     rbx, rax\n0x004D122C | E8 5F 78 F3 FF | call    sub_408A90\n0x004D1231 | 48 39 C3 | cmp     rbx, rax\n0x004D1234 | 74 7A | jz      short loc_4D12B0\n0x004D1236 | 44 0F B6 00 | movzx   r8d, byte ptr [rax]\n0x004D123A | 41 80 F8 6D | cmp     r8b, 6Dh ; 'm'\n0x004D123E | 74 50 | jz      short loc_4D1290\n0x004D1240 | BF 4C DB 52 00 | mov     edi, offset aRd; \"rd/\"\n0x004D1245 | B9 03 00 00 00 | mov     ecx, 3\n0x004D124A | 48 89 C6 | mov     rsi, rax\n0x004D124D | F3 A6 | repe cmpsb\n0x004D124F | 0F 97 C2 | setnbe  dl\n0x004D1252 | 80 DA 00 | sbb     dl, 0\n0x004D1255 | 84 D2 | test    dl, dl\n0x004D1257 | 75 67 | jnz     short loc_4D12C0\n0x004D1259 | 80 78 03 63 | cmp     byte ptr [rax+3], 63h ; 'c'\n0x004D125D | 75 51 | jnz     short loc_4D12B0\n0x004D125F | 0F B6 70 04 | movzx   esi, byte ptr [rax+4]\n0x004D1263 | 8D 56 D0 | lea     edx, [rsi-30h]\n0x004D1266 | 80 FA 09 | cmp     dl, 9\n0x004D1269 | 77 45 | ja      short loc_4D12B0\n0x004D126B | 80 78 05 64 | cmp     byte ptr [rax+5], 64h ; 'd'\n0x004D126F | 75 3F | jnz     short loc_4D12B0\n0x004D1271 | 0F B6 70 06 | movzx   esi, byte ptr [rax+6]\n0x004D1275 | 8D 56 D0 | lea     edx, [rsi-30h]\n0x004D1278 | 80 FA 09 | cmp     dl, 9\n0x004D127B | 77 33 | ja      short loc_4D12B0\n0x004D127D | C6 40 07 00 | mov     byte ptr [rax+7], 0\n0x004D1281 | 48 89 D8 | mov     rax, rbx\n0x004D1284 | 5B | pop     rbx\n0x004D1285 | C3 | retn\n0x004D1286 | 66 2E 0F 1F 84 00 00 00 00 00 | align 10h\n0x004D1290 | 80 78 01 64 | cmp     byte ptr [rax+1], 64h ; 'd'\n0x004D1294 | 74 7A | jz      short loc_4D1310\n0x004D1296 | BF 4C DB 52 00 | mov     edi, offset aRd; \"rd/\"\n0x004D129B | B9 03 00 00 00 | mov     ecx, 3\n0x004D12A0 | 48 89 C6 | mov     rsi, rax\n0x004D12A3 | F3 A6 | repe cmpsb\n0x004D12A5 | 0F 97 C2 | setnbe  dl\n0x004D12A8 | 80 DA 00 | sbb     dl, 0\n0x004D12AB | 84 D2 | test    dl, dl\n0x004D12AD | 74 AA | jz      short loc_4D1259\n0x004D12AF | 90 | nop\n0x004D12B0 | 48 89 DF | mov     rdi, rbx; ptr\n0x004D12B3 | 31 DB | xor     ebx, ebx\n0x004D12B5 | E8 56 50 F3 FF | call    _free\n0x004D12BA | 48 89 D8 | mov     rax, rbx\n0x004D12BD | 5B | pop     rbx\n0x004D12BE | C3 | retn\n0x004D12BF | 90 | align 20h\n0x004D12C0 | 41 80 F8 68 | cmp     r8b, 68h ; 'h'\n0x004D12C4 | 74 06 | jz      short loc_4D12CC\n0x004D12C6 | 41 80 F8 73 | cmp     r8b, 73h ; 's'\n0x004D12CA | 75 E4 | jnz     short loc_4D12B0\n0x004D12CC | 80 78 01 64 | cmp     byte ptr [rax+1], 64h ; 'd'\n0x004D12D0 | 75 DE | jnz     short loc_4D12B0\n0x004D12D2 | 0F B6 50 02 | movzx   edx, byte ptr [rax+2]\n0x004D12D6 | 8D 4A D0 | lea     ecx, [rdx-30h]\n0x004D12D9 | 80 F9 09 | cmp     cl, 9\n0x004D12DC | 76 22 | jbe     short loc_4D1300\n0x004D12DE | 48 8D 48 02 | lea     rcx, [rax+2]\n0x004D12E2 | 83 CA 20 | or      edx, 20h\n0x004D12E5 | 83 EA 61 | sub     edx, 61h ; 'a'\n0x004D12E8 | 80 FA 19 | cmp     dl, 19h\n0x004D12EB | 77 C3 | ja      short loc_4D12B0\n0x004D12ED | 48 89 D8 | mov     rax, rbx\n0x004D12F0 | C6 41 01 00 | mov     byte ptr [rcx+1], 0\n0x004D12F4 | 5B | pop     rbx\n0x004D12F5 | C3 | retn\n0x004D12F6 | 66 2E 0F 1F 84 00 00 00 00 00 | align 20h\n0x004D1300 | 48 8D 48 03 | lea     rcx, [rax+3]\n0x004D1304 | 0F B6 50 03 | movzx   edx, byte ptr [rax+3]\n0x004D1308 | EB D8 | jmp     short loc_4D12E2\n0x004D130A | 66 0F 1F 44 00 00 | align 10h\n0x004D1310 | C6 40 02 00 | mov     byte ptr [rax+2], 0\n0x004D1314 | EB A4 | jmp     short loc_4D12BA",
        "output": "```c\nvoid function(void* rax) {\n    push rbx;\n    call sub_40A060;\n    mov rdi, rax;\n    mov rbx, rax;\n    call sub_408A90;\n    cmp rbx, rax;\n    jz loc_4D12B0;\n    movzx r8d, byte ptr [rax];\n    cmp r8b, 0x6D;\n    jz loc_4D1290;\n    mov edi, offset aRd; // \"rd/\"\n    mov ecx, 3;\n    mov rsi, rax;\n    repe cmpsb;\n    setnbe dl;\n    sbb dl, 0;\n    test dl, dl;\n    jnz loc_4D12C0;\n    cmp byte ptr [rax+3], 0x63;\n    jnz loc_4D12B0;\n    movzx esi, byte ptr [rax+4];\n    lea edx, [rsi-0x30];\n    cmp dl, 9;\n    ja loc_4D12B0;\n    cmp byte ptr [rax+5], 0x64;\n    jnz loc_4D12B0;\n    movzx esi, byte ptr [rax+6];\n    lea edx, [rsi-0x30];\n    cmp dl, 9;\n    ja loc_4D12B0;\n    mov byte ptr [rax+7], 0;\n    mov rax, rbx;\n    pop rbx;\n    retn;\nloc_4D1290:\n    cmp byte ptr [rax+1], 0x64;\n    jz loc_4D1310;\n    mov edi, offset aRd; // \"rd/\"\n    mov ecx, 3;\n    mov rsi, rax;\n    repe cmpsb;\n    setnbe dl;\n    sbb dl, 0;\n    test dl, dl;\n    jz loc_4D1259;\n    nop;\nloc_4D12B0:\n    mov rdi, rbx;\n    xor ebx, ebx;\n    call _free;\n    mov rax, rbx;\n    pop rbx;\n    retn;\nloc_4D12C0:\n    cmp r8b, 0x68;\n    jz loc_4D12CC;\n    cmp r8b, 0x73;\n    jnz loc_4D12B0;\nloc_4D12CC:\n    cmp byte ptr [rax+1], 0x64;\n    jnz loc_4D12B0;\n    movzx edx, byte ptr [rax+2];\n    lea ecx, [rdx-0x30];\n    cmp cl, 9;\n    jbe loc_4D1300;\n    lea rcx, [rax+2];\n    or edx, 0x20;\n    sub edx, 0x61;\n    cmp dl, 0x19;\n    ja loc_4D12B0;\n    mov rax, rbx;\n    mov byte ptr [rcx+1], 0;\n    pop rbx;\n    retn;\nloc_4D1300:\n    lea rcx, [rax+3];\n    movzx edx, byte ptr [rax+3];\n    jmp loc_4D12E2;\nloc_4D1310:\n    mov byte ptr [rax+2], 0;\n    jmp loc_4D12BA;\n}\n```"
    },
    {
        "func_name": "killcmd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004673C0 | 55 | push    rbp\n0x004673C1 | 48 89 E5 | mov     rbp, rsp\n0x004673C4 | 41 57 | push    r15\n0x004673C6 | 41 56 | push    r14\n0x004673C8 | 41 55 | push    r13\n0x004673CA | 41 54 | push    r12\n0x004673CC | 49 89 F4 | mov     r12, rsi\n0x004673CF | 53 | push    rbx\n0x004673D0 | 48 83 EC 18 | sub     rsp, 18h\n0x004673D4 | 48 8B 76 08 | mov     rsi, [rsi+8]\n0x004673D8 | 89 7D C8 | mov     [rbp+var_38], edi\n0x004673DB | 48 85 F6 | test    rsi, rsi\n0x004673DE | 74 32 | jz      short loc_467412\n0x004673E0 | BF 39 DD 52 00 | mov     edi, (offset a14LSSL+0Dh); \"-l\"\n0x004673E5 | B9 03 00 00 00 | mov     ecx, 3\n0x004673EA | F3 A6 | repe cmpsb\n0x004673EC | 0F 97 C0 | setnbe  al\n0x004673EF | 1C 00 | sbb     al, 0\n0x004673F1 | 84 C0 | test    al, al\n0x004673F3 | 74 1D | jz      short loc_467412\n0x004673F5 | 49 8D 5C 24 08 | lea     rbx, [r12+8]\n0x004673FA | 66 0F 1F 44 00 00 | nop     word ptr [rax+rax+00h]\n0x00467400 | 48 8B 3B | mov     rdi, [rbx]\n0x00467403 | 80 3F 25 | cmp     byte ptr [rdi], 25h ; '%'\n0x00467406 | 74 28 | jz      short loc_467430\n0x00467408 | 48 83 C3 08 | add     rbx, 8\n0x0046740C | 48 83 3B 00 | cmp     qword ptr [rbx], 0\n0x00467410 | 75 EE | jnz     short loc_467400\n0x00467412 | 8B 7D C8 | mov     edi, [rbp+var_38]\n0x00467415 | 4C 89 E6 | mov     rsi, r12\n0x00467418 | E8 B3 D9 FE FF | call    sub_454DD0\n0x0046741D | 48 8D 65 D8 | lea     rsp, [rbp-28h]\n0x00467421 | 5B | pop     rbx\n0x00467422 | 41 5C | pop     r12\n0x00467424 | 41 5D | pop     r13\n0x00467426 | 41 5E | pop     r14\n0x00467428 | 41 5F | pop     r15\n0x0046742A | 5D | pop     rbp\n0x0046742B | C3 | retn\n0x0046742C | 0F 1F 40 00 | align 10h\n0x00467430 | 31 F6 | xor     esi, esi\n0x00467432 | E8 D9 FD FF FF | call    sub_467210\n0x00467437 | 49 89 C5 | mov     r13, rax\n0x0046743A | F6 40 1F 02 | test    byte ptr [rax+1Fh], 2\n0x0046743E | 0F 85 8C 00 00 00 | jnz     loc_4674D0\n0x00467444 | 0F B7 48 1C | movzx   ecx, word ptr [rax+1Ch]\n0x00467448 | 48 89 C8 | mov     rax, rcx\n0x0046744B | 89 4D CC | mov     [rbp+var_34], ecx\n0x0046744E | 48 C1 E0 04 | shl     rax, 4\n0x00467452 | 48 83 C0 17 | add     rax, 17h\n0x00467456 | 25 F0 FF 1F 00 | and     eax, 1FFFF0h\n0x0046745B | 48 29 C4 | sub     rsp, rax\n0x0046745E | 4C 8D 44 24 0F | lea     r8, [rsp+40h+var_34+3]\n0x00467463 | 49 83 E0 F0 | and     r8, 0FFFFFFFFFFFFFFF0h\n0x00467467 | 4D 89 C7 | mov     r15, r8\n0x0046746A | 4C 89 03 | mov     [rbx], r8\n0x0046746D | 85 C9 | test    ecx, ecx\n0x0046746F | 74 4D | jz      short loc_4674BE\n0x00467471 | 45 31 F6 | xor     r14d, r14d\n0x00467474 | 0F 1F 40 00 | nop     dword ptr [rax+00h]\n0x00467478 | 4C 89 F0 | mov     rax, r14\n0x0046747B | 48 C1 E0 04 | shl     rax, 4\n0x0046747F | 49 03 45 10 | add     rax, [r13+10h]\n0x00467483 | 8B 50 04 | mov     edx, [rax+4]\n0x00467486 | 83 FA FF | cmp     edx, 0FFFFFFFFh\n0x00467489 | 74 05 | jz      short loc_467490\n0x0046748B | 80 FA 7F | cmp     dl, 7Fh\n0x0046748E | 75 24 | jnz     short loc_4674B4\n0x00467490 | 41 F6 45 1F 02 | test    byte ptr [r13+1Fh], 2\n0x00467495 | 8B 10 | mov     edx, [rax]\n0x00467497 | BE 92 BD 52 00 | mov     esi, (offset aU_3+1); \" %u\"\n0x0046749C | 4C 89 FF | mov     rdi, r15; s\n0x0046749F | B8 98 99 52 00 | mov     eax, offset aU_2; \" -%u\"\n0x004674A4 | 48 0F 45 F0 | cmovnz  rsi, rax; format\n0x004674A8 | 31 C0 | xor     eax, eax\n0x004674AA | E8 E1 01 FA FF | call    _sprintf\n0x004674AF | 48 98 | cdqe\n0x004674B1 | 49 01 C7 | add     r15, rax\n0x004674B4 | 49 83 C6 01 | add     r14, 1\n0x004674B8 | 44 39 75 CC | cmp     [rbp+var_34], r14d\n0x004674BC | 7F BA | jg      short loc_467478\n0x004674BE | 41 C6 07 00 | mov     byte ptr [r15], 0\n0x004674C2 | E9 41 FF FF FF | jmp     loc_467408\n0x004674C7 | 66 0F 1F 84 00 00 00 00 00 | align 10h\n0x004674D0 | 48 83 EC 20 | sub     rsp, 20h\n0x004674D4 | C7 45 CC 01 00 00 00 | mov     [rbp+var_34], 1\n0x004674DB | 4C 8D 44 24 0F | lea     r8, [rsp+60h+var_51]\n0x004674E0 | 49 83 E0 F0 | and     r8, 0FFFFFFFFFFFFFFF0h\n0x004674E4 | 4D 89 C7 | mov     r15, r8\n0x004674E7 | 4C 89 03 | mov     [rbx], r8\n0x004674EA | EB 85 | jmp     short loc_467471",
        "output": "```c\nvoid function(int edi, int esi) {\n    int var_38 = edi;\n    int var_34;\n    int var_51;\n    int var_54;\n    int var_58;\n    int var_5C;\n    int var_60;\n    \n    esi = *(int *)(esi + 8);\n    \n    if (esi == 0) {\n        return;\n    }\n    \n    if (strcmp(esi, \"-l\") != 0) {\n        return;\n    }\n    \n    int *rbx = &var_54;\n    \n    while (*rbx != 0) {\n        if (*rbx[0] == '%') {\n            rbx += 2;\n            continue;\n        }\n        \n        int ecx = *(unsigned short *)(rbx[0] + 0x1C);\n        ecx = ecx << 4;\n        ecx += 0x17;\n        ecx = ecx & 0x1FFFF0;\n        rsp -= ecx;\n        \n        char *r8 = rsp + 0x40 + var_34 + 3;\n        r8 = r8 & 0xFFFFFFFFFFFFFFF0;\n        r15 = r8;\n        *rbx = r8;\n        \n        if (ecx == 0) {\n            continue;\n        }\n        \n        int r14d = 0;\n        int rax = r14d;\n        rax = rax << 4;\n        rax += *(int *)(r13 + 0x10);\n        int edx = *(int *)(rax + 4);\n        \n        if (edx == -1) {\n            continue;\n        }\n        \n        if (edx == 0x7F) {\n            continue;\n        }\n        \n        if (*(unsigned char *)(r13 + 0x1F) & 0x2) {\n            edx = *(int *)(rax);\n            char *esi = \"%u\";\n            char *format = \" -%u\";\n            \n            if (*(unsigned char *)(r13 + 0x1F) & 0x2) {\n                esi = format;\n            }\n            \n            sprintf(r15, esi, edx);\n            r15 += strlen(r15);\n        }\n        \n        r14d++;\n        \n        if (var_34 <= r14d) {\n            *r15 = 0;\n            break;\n        }\n    }\n    \n    return;\n}\n```"
    },
    {
        "func_name": "volume_id_probe_reiserfs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0049B800 | 55 | push    rbp\n0x0049B801 | BA 00 02 00 00 | mov     edx, 200h\n0x0049B806 | BE 00 00 01 00 | mov     esi, 10000h\n0x0049B80B | 48 89 FD | mov     rbp, rdi\n0x0049B80E | 53 | push    rbx\n0x0049B80F | 48 83 EC 18 | sub     rsp, 18h\n0x0049B813 | E8 D8 0A 00 00 | call    sub_49C2F0\n0x0049B818 | 48 85 C0 | test    rax, rax\n0x0049B81B | 0F 84 0E 01 00 00 | jz      loc_49B92F\n0x0049B821 | 48 89 C3 | mov     rbx, rax\n0x0049B824 | 48 8D 48 34 | lea     rcx, [rax+34h]\n0x0049B828 | 31 C0 | xor     eax, eax\n0x0049B82A | 48 BA 52 65 49 73 45 72 46 73 | mov     rdx, 7346724573496552h\n0x0049B834 | 48 39 53 34 | cmp     [rbx+34h], rdx\n0x0049B838 | 74 5D | jz      short loc_49B897\n0x0049B83A | 48 B8 52 65 49 73 45 72 32 46 | mov     rax, 4632724573496552h\n0x0049B844 | 48 39 43 34 | cmp     [rbx+34h], rax\n0x0049B848 | 74 56 | jz      short loc_49B8A0\n0x0049B84A | 48 B8 52 65 49 73 45 72 33 46 | mov     rax, 4633724573496552h\n0x0049B854 | 48 39 43 34 | cmp     [rbx+34h], rax\n0x0049B858 | 74 7E | jz      short loc_49B8D8\n0x0049B85A | 81 3B 52 65 49 73 | cmp     dword ptr [rbx], 73496552h\n0x0049B860 | 0F 84 82 00 00 00 | jz      loc_49B8E8\n0x0049B866 | BA 00 02 00 00 | mov     edx, 200h\n0x0049B86B | BE 00 20 00 00 | mov     esi, 2000h\n0x0049B870 | 48 89 EF | mov     rdi, rbp\n0x0049B873 | E8 78 0A 00 00 | call    sub_49C2F0\n0x0049B878 | 48 85 C0 | test    rax, rax\n0x0049B87B | 0F 84 AE 00 00 00 | jz      loc_49B92F\n0x0049B881 | 48 BA 52 65 49 73 45 72 46 73 | mov     rdx, 7346724573496552h\n0x0049B88B | 48 39 50 34 | cmp     [rax+34h], rdx\n0x0049B88F | 0F 95 C0 | setnz   al\n0x0049B892 | 0F B6 C0 | movzx   eax, al\n0x0049B895 | F7 D8 | neg     eax\n0x0049B897 | 48 83 C4 18 | add     rsp, 18h\n0x0049B89B | 5B | pop     rbx\n0x0049B89C | 5D | pop     rbp\n0x0049B89D | C3 | retn\n0x0049B89E | 66 90 | align 20h\n0x0049B8A0 | 80 79 08 73 | cmp     byte ptr [rcx+8], 73h ; 's'\n0x0049B8A4 | 75 A4 | jnz     short loc_49B84A\n0x0049B8A6 | 48 8D 73 64 | lea     rsi, [rbx+64h]\n0x0049B8AA | 48 89 EF | mov     rdi, rbp\n0x0049B8AD | BA 10 00 00 00 | mov     edx, 10h\n0x0049B8B2 | E8 49 06 00 00 | call    sub_49BF00\n0x0049B8B7 | 48 8D 73 54 | lea     rsi, [rbx+54h]\n0x0049B8BB | 48 89 EF | mov     rdi, rbp\n0x0049B8BE | BA 02 00 00 00 | mov     edx, 2\n0x0049B8C3 | E8 88 08 00 00 | call    sub_49C150\n0x0049B8C8 | 48 83 C4 18 | add     rsp, 18h\n0x0049B8CC | 31 C0 | xor     eax, eax\n0x0049B8CE | 5B | pop     rbx\n0x0049B8CF | 5D | pop     rbp\n0x0049B8D0 | C3 | retn\n0x0049B8D1 | 0F 1F 80 00 00 00 00 | align 8\n0x0049B8D8 | 80 79 08 73 | cmp     byte ptr [rcx+8], 73h ; 's'\n0x0049B8DC | 0F 85 78 FF FF FF | jnz     loc_49B85A\n0x0049B8E2 | EB C2 | jmp     short loc_49B8A6\n0x0049B8E4 | 0F 1F 40 00 | align 8\n0x0049B8E8 | 66 81 7B 04 45 72 | cmp     word ptr [rbx+4], 7245h\n0x0049B8EE | 0F 85 72 FF FF FF | jnz     loc_49B866\n0x0049B8F4 | 80 7B 06 34 | cmp     byte ptr [rbx+6], 34h ; '4'\n0x0049B8F8 | 0F 85 68 FF FF FF | jnz     loc_49B866\n0x0049B8FE | 31 C0 | xor     eax, eax\n0x0049B900 | 48 8D 73 24 | lea     rsi, [rbx+24h]\n0x0049B904 | BA 10 00 00 00 | mov     edx, 10h\n0x0049B909 | 48 89 EF | mov     rdi, rbp\n0x0049B90C | 89 44 24 0C | mov     [rsp+28h+var_1C], eax\n0x0049B910 | E8 EB 05 00 00 | call    sub_49BF00\n0x0049B915 | 48 8D 73 14 | lea     rsi, [rbx+14h]\n0x0049B919 | BA 02 00 00 00 | mov     edx, 2\n0x0049B91E | 48 89 EF | mov     rdi, rbp\n0x0049B921 | E8 2A 08 00 00 | call    sub_49C150\n0x0049B926 | 8B 44 24 0C | mov     eax, [rsp+28h+var_1C]\n0x0049B92A | E9 68 FF FF FF | jmp     loc_49B897\n0x0049B92F | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x0049B934 | E9 5E FF FF FF | jmp     loc_49B897",
        "output": "```c\nvoid function(void* rdi) {\n    push    rbp\n    mov     edx, 0x200\n    mov     esi, 0x10000\n    mov     rbp, rdi\n    push    rbx\n    sub     rsp, 0x18\n    call    sub_49C2F0\n    test    rax, rax\n    jz      loc_49B92F\n    mov     rbx, rax\n    lea     rcx, [rax+0x34]\n    xor     eax, eax\n    mov     rdx, 0x7346724573496552\n    cmp     [rbx+0x34], rdx\n    jz      short loc_49B897\n    mov     rax, 0x4632724573496552\n    cmp     [rbx+0x34], rax\n    jz      short loc_49B8A0\n    mov     rax, 0x4633724573496552\n    cmp     [rbx+0x34], rax\n    jz      short loc_49B8D8\n    cmp     dword ptr [rbx], 0x73496552\n    jz      loc_49B8E8\n    mov     edx, 0x200\n    mov     esi, 0x2000\n    mov     rdi, rbp\n    call    sub_49C2F0\n    test    rax, rax\n    jz      loc_49B92F\n    mov     rdx, 0x7346724573496552\n    cmp     [rax+0x34], rdx\n    setnz   al\n    movzx   eax, al\n    neg     eax\n    add     rsp, 0x18\n    pop     rbx\n    pop     rbp\n    retn\nloc_49B897:\n    cmp     byte ptr [rcx+0x8], 0x73\n    jnz     short loc_49B84A\n    lea     rsi, [rbx+0x64]\n    mov     rdi, rbp\n    mov     edx, 0x10\n    call    sub_49BF00\n    lea     rsi, [rbx+0x54]\n    mov     rdi, rbp\n    mov     edx, 0x2\n    call    sub_49C150\n    add     rsp, 0x18\n    xor     eax, eax\n    pop     rbx\n    pop     rbp\n    retn\nloc_49B8D8:\n    cmp     byte ptr [rcx+0x8], 0x73\n    jnz     loc_49B85A\n    jmp     short loc_49B8A6\nloc_49B8E8:\n    cmp     word ptr [rbx+0x4], 0x7245\n    jnz     loc_49B866\n    cmp     byte ptr [rbx+0x6], 0x34\n    jnz     loc_49B866\n    xor     eax, eax\n    lea     rsi, [rbx+0x24]\n    mov     edx, 0x10\n    mov     rdi, rbp\n    mov     [rsp+0x28+var_1C], eax\n    call    sub_49BF00\n    lea     rsi, [rbx+0x14]\n    mov     edx, 0x2\n    mov     rdi, rbp\n    call    sub_49C150\n    mov     eax, [rsp+0x28+var_1C]\n    jmp     loc_49B897\nloc_49B92F:\n    mov     eax, 0xFFFFFFFF\n    jmp     loc_49B897\n}\n```"
    },
    {
        "func_name": "get_groups",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C2EE0 | 53 | push    rbx\n0x004C2EE1 | 48 89 CB | mov     rbx, rcx\n0x004C2EE4 | 48 83 EC 10 | sub     rsp, 10h\n0x004C2EE8 | 48 85 FF | test    rdi, rdi\n0x004C2EEB | 74 17 | jz      short loc_4C2F04\n0x004C2EED | E8 2E A0 F4 FF | call    sub_40CF20\n0x004C2EF2 | 8B 13 | mov     edx, [rbx]\n0x004C2EF4 | 85 D2 | test    edx, edx\n0x004C2EF6 | BA 00 00 00 00 | mov     edx, 0\n0x004C2EFB | 0F 48 C2 | cmovs   eax, edx\n0x004C2EFE | 48 83 C4 10 | add     rsp, 10h\n0x004C2F02 | 5B | pop     rbx\n0x004C2F03 | C3 | retn\n0x004C2F04 | 8B 39 | mov     edi, [rcx]; size\n0x004C2F06 | 48 89 D6 | mov     rsi, rdx; list\n0x004C2F09 | 48 89 54 24 08 | mov     [rsp+18h+list], rdx\n0x004C2F0E | E8 6D 40 F4 FF | call    _getgroups\n0x004C2F13 | 89 03 | mov     [rbx], eax\n0x004C2F15 | 85 C0 | test    eax, eax\n0x004C2F17 | 79 E5 | jns     short loc_4C2EFE\n0x004C2F19 | 48 8B 05 60 D4 28 00 | mov     rax, cs:qword_750380\n0x004C2F20 | 48 8B 54 24 08 | mov     rdx, [rsp+18h+list]\n0x004C2F25 | 83 38 16 | cmp     dword ptr [rax], 16h\n0x004C2F28 | 74 09 | jz      short loc_4C2F33\n0x004C2F2A | 8B 03 | mov     eax, [rbx]\n0x004C2F2C | F7 D0 | not     eax\n0x004C2F2E | C1 F8 1F | sar     eax, 1Fh\n0x004C2F31 | EB CB | jmp     short loc_4C2EFE\n0x004C2F33 | 48 89 D6 | mov     rsi, rdx; list\n0x004C2F36 | 31 FF | xor     edi, edi; size\n0x004C2F38 | E8 43 40 F4 FF | call    _getgroups\n0x004C2F3D | 89 03 | mov     [rbx], eax\n0x004C2F3F | EB E9 | jmp     short loc_4C2F2A",
        "output": "```c\nvoid function(void* list, int size) {\n    push rbx;\n    mov rbx, rcx;\n    sub rsp, 0x10;\n    test rdi, rdi;\n    jz loc_4C2F04;\n    call sub_40CF20;\n    mov edx, [rbx];\n    test edx, edx;\n    mov edx, 0;\n    cmovs eax, edx;\n    add rsp, 0x10;\n    pop rbx;\n    retn;\nloc_4C2F04:\n    mov edi, [rcx]; // size\n    mov rsi, rdx; // list\n    mov [rsp+0x18+list], rdx;\n    call _getgroups;\n    mov [rbx], eax;\n    test eax, eax;\n    jns loc_4C2EFE;\n    mov rax, cs:qword_750380;\n    mov rdx, [rsp+0x18+list];\n    cmp dword ptr [rax], 0x16;\n    jz loc_4C2F33;\n    mov eax, [rbx];\n    not eax;\n    sar eax, 0x1F;\n    jmp loc_4C2EFE;\nloc_4C2F33:\n    mov rsi, rdx; // list\n    xor edi, edi; // size\n    call _getgroups;\n    mov [rbx], eax;\n    jmp loc_4C2F2A;\n}\n```"
    },
    {
        "func_name": "str2env",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004AD350 | 53 | push    rbx; char\n0x004AD351 | 48 63 F6 | movsxd  rsi, esi\n0x004AD354 | 31 C0 | xor     eax, eax\n0x004AD356 | 48 8D 1C F7 | lea     rbx, [rdi+rsi*8]\n0x004AD35A | 48 8B 34 F5 20 41 51 00 | mov     rsi, ds:off_514120[rsi*8]; \"MODE\"\n0x004AD362 | BF AF C7 52 00 | mov     edi, offset aTarSS; \"TAR_%s=%s\"\n0x004AD367 | E8 D4 D1 F5 FF | call    sub_40A540\n0x004AD36C | 48 89 03 | mov     [rbx], rax\n0x004AD36F | 48 89 C7 | mov     rdi, rax; string\n0x004AD372 | E8 19 99 F5 FF | call    _putenv\n0x004AD377 | 85 C0 | test    eax, eax\n0x004AD379 | 75 02 | jnz     short loc_4AD37D\n0x004AD37B | 5B | pop     rbx\n0x004AD37C | C3 | retn\n0x004AD37D | BF 88 2A 52 00 | mov     edi, offset aOutOfMemory; \"out of memory\"\n0x004AD382 | 31 C0 | xor     eax, eax\n0x004AD384 | E8 37 B9 F5 FF | call    sub_408CC0",
        "output": "```c\nvoid function(char* input) {\n    int size = strlen(input);\n    char* buffer = malloc(size * 8);\n    strcpy(buffer, input);\n    char* mode = \"MODE\";\n    char* env_var = malloc(strlen(\"TAR_\") + size + strlen(\"=\") + size + 1);\n    sprintf(env_var, \"TAR_%s=%s\", buffer, buffer);\n    putenv(env_var);\n    if (env_var == NULL) {\n        printf(\"out of memory\");\n        return;\n    }\n    free(buffer);\n}\n```"
    },
    {
        "func_name": "my_stat",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C3AD0 | 41 54 | push    r12\n0x004C3AD2 | 41 89 D4 | mov     r12d, edx\n0x004C3AD5 | 55 | push    rbp\n0x004C3AD6 | 48 89 FD | mov     rbp, rdi\n0x004C3AD9 | 53 | push    rbx\n0x004C3ADA | 48 81 EC A0 00 00 00 | sub     rsp, 0A0h\n0x004C3AE1 | 48 89 34 24 | mov     qword ptr [rsp+0B8h+var_B8], rsi\n0x004C3AE5 | F3 0F 7E 04 24 | movq    xmm0, qword ptr [rsp+0B8h+var_B8]\n0x004C3AEA | 48 89 3C 24 | mov     qword ptr [rsp+0B8h+var_B8], rdi\n0x004C3AEE | BF 70 00 00 00 | mov     edi, 70h ; 'p'\n0x004C3AF3 | 0F 16 04 24 | movhps  xmm0, qword ptr [rsp+0B8h+var_B8]\n0x004C3AF7 | 0F 29 04 24 | movaps  [rsp+0B8h+var_B8], xmm0\n0x004C3AFB | E8 30 65 F4 FF | call    sub_40A030\n0x004C3B00 | 66 0F 6F 04 24 | movdqa  xmm0, [rsp+0B8h+var_B8]\n0x004C3B05 | 48 8D 54 24 10 | lea     rdx, [rsp+0B8h+stat_buf]; stat_buf\n0x004C3B0A | 48 89 EE | mov     rsi, rbp; filename\n0x004C3B0D | 48 89 C3 | mov     rbx, rax\n0x004C3B10 | BF 01 00 00 00 | mov     edi, 1; ver\n0x004C3B15 | 0F 11 00 | movups  xmmword ptr [rax], xmm0\n0x004C3B18 | 8B 05 B2 C8 28 00 | mov     eax, cs:dword_7503D0\n0x004C3B1E | 25 00 00 00 01 | and     eax, 1000000h\n0x004C3B23 | 44 09 E0 | or      eax, r12d\n0x004C3B26 | 0F 84 A4 00 00 00 | jz      loc_4C3BD0\n0x004C3B2C | E8 5F 2B F4 FF | call    ___xstat64\n0x004C3B31 | 85 C0 | test    eax, eax\n0x004C3B33 | 0F 85 AF 00 00 00 | jnz     loc_4C3BE8\n0x004C3B39 | 8B 44 24 28 | mov     eax, [rsp+0B8h+stat_buf.st_mode]\n0x004C3B3D | 89 43 20 | mov     [rbx+20h], eax\n0x004C3B40 | 66 0F 6F 44 24 60 | movdqa  xmm0, xmmword ptr [rsp+0B8h+stat_buf.st_atim.tv_nsec]\n0x004C3B46 | 66 0F 6D 44 24 70 | punpckhqdq xmm0, xmmword ptr [rsp+0B8h+stat_buf.st_mtim.tv_nsec]\n0x004C3B4C | 89 43 24 | mov     [rbx+24h], eax\n0x004C3B4F | 48 8B 44 24 18 | mov     rax, [rsp+0B8h+stat_buf.st_ino]\n0x004C3B54 | 66 0F 6F 4C 24 40 | movdqa  xmm1, xmmword ptr [rsp+0B8h+stat_buf.st_size]\n0x004C3B5A | 66 0F C6 4C 24 50 02 | shufpd  xmm1, xmmword ptr [rsp+0B8h+stat_buf.st_blocks], 2\n0x004C3B61 | 0F 11 4B 28 | movups  xmmword ptr [rbx+28h], xmm1\n0x004C3B65 | 0F 11 43 38 | movups  xmmword ptr [rbx+38h], xmm0\n0x004C3B69 | 48 89 43 48 | mov     [rbx+48h], rax\n0x004C3B6D | 48 8B 44 24 50 | mov     rax, [rsp+0B8h+stat_buf.st_blocks]\n0x004C3B72 | 48 89 43 50 | mov     [rbx+50h], rax\n0x004C3B76 | 48 8B 44 24 20 | mov     rax, [rsp+0B8h+stat_buf.st_nlink]\n0x004C3B7B | 48 89 43 58 | mov     [rbx+58h], rax\n0x004C3B7F | 48 8B 44 24 2C | mov     rax, qword ptr [rsp+0B8h+stat_buf.st_uid]\n0x004C3B84 | 48 89 43 60 | mov     [rbx+60h], rax\n0x004C3B88 | 48 8B 44 24 38 | mov     rax, [rsp+0B8h+stat_buf.st_rdev]\n0x004C3B8D | 48 89 C2 | mov     rdx, rax\n0x004C3B90 | 48 C1 EA 08 | shr     rdx, 8\n0x004C3B94 | 89 D1 | mov     ecx, edx\n0x004C3B96 | 48 89 C2 | mov     rdx, rax\n0x004C3B99 | 48 C1 EA 20 | shr     rdx, 20h\n0x004C3B9D | 81 E1 FF 0F 00 00 | and     ecx, 0FFFh\n0x004C3BA3 | 81 E2 00 F0 FF FF | and     edx, 0FFFFF000h\n0x004C3BA9 | 09 CA | or      edx, ecx\n0x004C3BAB | 89 53 68 | mov     [rbx+68h], edx\n0x004C3BAE | 0F B6 D0 | movzx   edx, al\n0x004C3BB1 | 48 C1 E8 0C | shr     rax, 0Ch\n0x004C3BB5 | 30 C0 | xor     al, al\n0x004C3BB7 | 09 D0 | or      eax, edx\n0x004C3BB9 | 89 43 6C | mov     [rbx+6Ch], eax\n0x004C3BBC | 48 81 C4 A0 00 00 00 | add     rsp, 0A0h\n0x004C3BC3 | 48 89 D8 | mov     rax, rbx\n0x004C3BC6 | 5B | pop     rbx\n0x004C3BC7 | 5D | pop     rbp\n0x004C3BC8 | 41 5C | pop     r12\n0x004C3BCA | C3 | retn\n0x004C3BCB | 0F 1F 44 00 00 | align 10h\n0x004C3BD0 | E8 2B 3A F4 FF | call    ___lxstat64\n0x004C3BD5 | 85 C0 | test    eax, eax\n0x004C3BD7 | 75 0F | jnz     short loc_4C3BE8\n0x004C3BD9 | 8B 44 24 28 | mov     eax, [rsp+0B8h+stat_buf.st_mode]\n0x004C3BDD | 89 43 1C | mov     [rbx+1Ch], eax\n0x004C3BE0 | E9 5B FF FF FF | jmp     loc_4C3B40\n0x004C3BE5 | 0F 1F 00 | align 8\n0x004C3BE8 | 48 89 EF | mov     rdi, rbp\n0x004C3BEB | E8 10 4E F4 FF | call    sub_408A00\n0x004C3BF0 | 48 89 DF | mov     rdi, rbx; ptr\n0x004C3BF3 | C6 05 7F A7 28 00 01 | mov     byte ptr cs:dest.c_iflag+1, 1\n0x004C3BFA | 31 DB | xor     ebx, ebx\n0x004C3BFC | E8 0F 27 F4 FF | call    _free\n0x004C3C01 | EB B9 | jmp     short loc_4C3BBC",
        "output": "```c\nvoid function(void* rdi, int edx, int esi) {\n    push r12\n    mov r12d, edx\n    push rbp\n    mov rbp, rdi\n    push rbx\n    sub rsp, 0xA0\n    mov qword ptr [rsp+0xB8], rsi\n    movq xmm0, qword ptr [rsp+0xB8]\n    mov qword ptr [rsp+0xB8], rdi\n    mov edi, 0x70\n    movhps xmm0, qword ptr [rsp+0xB8]\n    movaps [rsp+0xB8], xmm0\n    call sub_40A030\n    movdqa xmm0, [rsp+0xB8]\n    lea rdx, [rsp+0xB8+stat_buf]\n    mov rsi, rbp\n    mov rbx, rax\n    mov edi, 1\n    movups xmmword ptr [rax], xmm0\n    mov eax, cs:dword_7503D0\n    and eax, 0x1000000\n    or eax, r12d\n    jz loc_4C3BD0\n    call ___xstat64\n    test eax, eax\n    jnz loc_4C3BE8\n    mov eax, [rsp+0xB8+stat_buf.st_mode]\n    mov [rbx+0x20], eax\n    movdqa xmm0, xmmword ptr [rsp+0xB8+stat_buf.st_atim.tv_nsec]\n    punpckhqdq xmm0, xmmword ptr [rsp+0xB8+stat_buf.st_mtim.tv_nsec]\n    mov [rbx+0x24], eax\n    mov rax, [rsp+0xB8+stat_buf.st_ino]\n    movdqa xmm1, xmmword ptr [rsp+0xB8+stat_buf.st_size]\n    shufpd xmm1, xmmword ptr [rsp+0xB8+stat_buf.st_blocks], 2\n    movups xmmword ptr [rbx+0x28], xmm1\n    movups xmmword ptr [rbx+0x38], xmm0\n    mov [rbx+0x48], rax\n    mov rax, [rsp+0xB8+stat_buf.st_blocks]\n    mov [rbx+0x50], rax\n    mov rax, [rsp+0xB8+stat_buf.st_nlink]\n    mov [rbx+0x58], rax\n    mov rax, qword ptr [rsp+0xB8+stat_buf.st_uid]\n    mov [rbx+0x60], rax\n    mov rax, [rsp+0xB8+stat_buf.st_rdev]\n    shr rdx, 8\n    mov ecx, edx\n    shr rdx, 0x20\n    and ecx, 0xFFF\n    and edx, 0xFFFFF000\n    or edx, ecx\n    mov [rbx+0x68], edx\n    movzx edx, al\n    shr rax, 0xC\n    xor al, al\n    or eax, edx\n    mov [rbx+0x6C], eax\n    add rsp, 0xA0\n    mov rax, rbx\n    pop rbx\n    pop rbp\n    pop r12\n    retn\nloc_4C3BD0:\n    call ___lxstat64\n    test eax, eax\n    jnz loc_4C3BE8\n    mov eax, [rsp+0xB8+stat_buf.st_mode]\n    mov [rbx+0x1C], eax\n    jmp loc_4C3B40\nloc_4C3BE8:\n    mov rdi, rbp\n    call sub_408A00\n    mov rdi, rbx\n    mov byte ptr cs:dest.c_iflag+1, 1\n    xor ebx, ebx\n    call _free\n    jmp loc_4C3BBC\n}\n```"
    },
    {
        "func_name": "get_aftype",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00434760 | 41 54 | push    r12\n0x00434762 | 49 89 FC | mov     r12, rdi\n0x00434765 | BF A1 50 52 00 | mov     edi, offset aInet; \"inet\"\n0x0043476A | 55 | push    rbp\n0x0043476B | BD 00 01 51 00 | mov     ebp, offset off_510100\n0x00434770 | 53 | push    rbx\n0x00434771 | BB E0 01 51 00 | mov     ebx, offset off_5101E0; \"inet\"\n0x00434776 | EB 18 | jmp     short loc_434790\n0x00434778 | 0F 1F 84 00 00 00 00 00 | align 20h\n0x00434780 | 48 83 C5 08 | add     rbp, 8\n0x00434784 | 48 8B 5D 00 | mov     rbx, [rbp+0]\n0x00434788 | 48 85 DB | test    rbx, rbx\n0x0043478B | 74 0F | jz      short loc_43479C\n0x0043478D | 48 8B 3B | mov     rdi, [rbx]; s1\n0x00434790 | 4C 89 E6 | mov     rsi, r12; s2\n0x00434793 | E8 48 25 FD FF | call    _strcmp\n0x00434798 | 85 C0 | test    eax, eax\n0x0043479A | 75 E4 | jnz     short loc_434780\n0x0043479C | 48 89 D8 | mov     rax, rbx\n0x0043479F | 5B | pop     rbx\n0x004347A0 | 5D | pop     rbp\n0x004347A1 | 41 5C | pop     r12\n0x004347A3 | C3 | retn",
        "output": "```c\nvoid function(char* s1, char* s2) {\n    char* inet = \"inet\";\n    char* off_510100 = // some address\n    char* off_5101E0 = \"inet\";\n\n    while (1) {\n        off_510100 += 8;\n        char* rbx = *off_510100;\n        if (rbx == NULL) {\n            break;\n        }\n        if (strcmp(rbx, s1) == 0) {\n            return rbx;\n        }\n    }\n    return NULL;\n}\n```"
    },
    {
        "func_name": "bb_unsetenv_and_free",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040A710 | 41 54 | push    r12\n0x0040A712 | BE 3D 00 00 00 | mov     esi, 3Dh ; '='; c\n0x0040A717 | 55 | push    rbp\n0x0040A718 | 53 | push    rbx\n0x0040A719 | 48 89 FB | mov     rbx, rdi\n0x0040A71C | E8 0F C1 FF FF | call    _strchr\n0x0040A721 | 48 85 C0 | test    rax, rax\n0x0040A724 | 0F 84 9E 00 00 00 | jz      loc_40A7C8\n0x0040A72A | 48 29 D8 | sub     rax, rbx\n0x0040A72D | 89 C5 | mov     ebp, eax\n0x0040A72F | 85 C0 | test    eax, eax\n0x0040A731 | 0F 84 A9 00 00 00 | jz      loc_40A7E0\n0x0040A737 | 80 3B 00 | cmp     byte ptr [rbx], 0\n0x0040A73A | 0F 84 B0 00 00 00 | jz      loc_40A7F0\n0x0040A740 | 89 C2 | mov     edx, eax\n0x0040A742 | 48 89 D9 | mov     rcx, rbx\n0x0040A745 | EB 0E | jmp     short loc_40A755\n0x0040A747 | 66 0F 1F 84 00 00 00 00 00 | align 10h\n0x0040A750 | 80 39 00 | cmp     byte ptr [rcx], 0\n0x0040A753 | 74 5B | jz      short loc_40A7B0\n0x0040A755 | 48 83 C1 01 | add     rcx, 1\n0x0040A759 | 83 EA 01 | sub     edx, 1\n0x0040A75C | 75 F2 | jnz     short loc_40A750\n0x0040A75E | 83 C0 01 | add     eax, 1\n0x0040A761 | 48 63 F8 | movsxd  rdi, eax; size\n0x0040A764 | 48 85 FF | test    rdi, rdi\n0x0040A767 | 41 0F 95 C4 | setnz   r12b\n0x0040A76B | E8 70 C8 FF FF | call    _malloc\n0x0040A770 | 48 85 C0 | test    rax, rax\n0x0040A773 | 75 09 | jnz     short loc_40A77E\n0x0040A775 | 45 84 E4 | test    r12b, r12b\n0x0040A778 | 0F 85 84 00 00 00 | jnz     loc_40A802\n0x0040A77E | 48 63 D5 | movsxd  rdx, ebp; n\n0x0040A781 | 48 89 DE | mov     rsi, rbx; src\n0x0040A784 | 48 89 C7 | mov     rdi, rax; dest\n0x0040A787 | C6 04 10 00 | mov     byte ptr [rax+rdx], 0\n0x0040A78B | E8 B0 C6 FF FF | call    _memcpy\n0x0040A790 | 48 89 C5 | mov     rbp, rax\n0x0040A793 | 48 89 C7 | mov     rdi, rax; name\n0x0040A796 | E8 85 CD FF FF | call    _unsetenv\n0x0040A79B | 48 89 EF | mov     rdi, rbp; ptr\n0x0040A79E | E8 6D BB FF FF | call    _free\n0x0040A7A3 | 48 89 DF | mov     rdi, rbx; ptr\n0x0040A7A6 | 5B | pop     rbx\n0x0040A7A7 | 5D | pop     rbp\n0x0040A7A8 | 41 5C | pop     r12\n0x0040A7AA | E9 61 BB FF FF | jmp     _free\n0x0040A7AF | 90 | align 10h\n0x0040A7B0 | 89 C5 | mov     ebp, eax\n0x0040A7B2 | 29 D5 | sub     ebp, edx\n0x0040A7B4 | 8D 7D 01 | lea     edi, [rbp+1]\n0x0040A7B7 | 48 63 FF | movsxd  rdi, edi\n0x0040A7BA | 48 85 FF | test    rdi, rdi\n0x0040A7BD | 41 0F 95 C4 | setnz   r12b\n0x0040A7C1 | EB A8 | jmp     short loc_40A76B\n0x0040A7C3 | 0F 1F 44 00 00 | align 8\n0x0040A7C8 | 48 89 DF | mov     rdi, rbx; name\n0x0040A7CB | E8 50 CD FF FF | call    _unsetenv\n0x0040A7D0 | 48 89 DF | mov     rdi, rbx; ptr\n0x0040A7D3 | 5B | pop     rbx\n0x0040A7D4 | 5D | pop     rbp\n0x0040A7D5 | 41 5C | pop     r12\n0x0040A7D7 | E9 34 BB FF FF | jmp     _free\n0x0040A7DC | 0F 1F 40 00 | align 20h\n0x0040A7E0 | 41 BC 01 00 00 00 | mov     r12d, 1\n0x0040A7E6 | BF 01 00 00 00 | mov     edi, 1\n0x0040A7EB | E9 7B FF FF FF | jmp     loc_40A76B\n0x0040A7F0 | 41 BC 01 00 00 00 | mov     r12d, 1\n0x0040A7F6 | BF 01 00 00 00 | mov     edi, 1\n0x0040A7FB | 31 ED | xor     ebp, ebp\n0x0040A7FD | E9 69 FF FF FF | jmp     loc_40A76B\n0x0040A802 | BF 88 2A 52 00 | mov     edi, offset aOutOfMemory; \"out of memory\"\n0x0040A807 | E8 B4 E4 FF FF | call    sub_408CC0",
        "output": "```c\nvoid function(char* name) {\n    char* ptr;\n    int n = 0x3D;\n    int size;\n    int i;\n\n    // Find the first occurrence of '=' in the name string\n    ptr = strchr(name, '=');\n\n    // If '=' is not found, jump to loc_40A7C8\n    if (ptr == NULL) {\n        goto loc_40A7C8;\n    }\n\n    // Calculate the size of the substring after '='\n    size = ptr - name;\n\n    // If size is 0, jump to loc_40A7E0\n    if (size == 0) {\n        goto loc_40A7E0;\n    }\n\n    // Loop through each character in the substring\n    for (i = 0; i < size; i++) {\n        // If the character is null, jump to loc_40A7F0\n        if (name[i] == '\\0') {\n            goto loc_40A7F0;\n        }\n    }\n\n    // Allocate memory for the substring\n    ptr = malloc(size + 1);\n\n    // If memory allocation fails, jump to loc_40A802\n    if (ptr == NULL) {\n        goto loc_40A802;\n    }\n\n    // Copy the substring to the allocated memory\n    memcpy(ptr, name, size);\n    ptr[size] = '\\0';\n\n    // Unset the environment variable with the same name as the substring\n    unsetenv(ptr);\n\n    // Free the allocated memory\n    free(ptr);\n\n    // Jump to _free\n    goto _free;\n\nloc_40A7C8:\n    // Unset the environment variable with the name\n    unsetenv(name);\n\n    // Jump to _free\n    goto _free;\n\nloc_40A7E0:\n    // Set r12d to 1\n    r12d = 1;\n\n    // Set edi to 1\n    edi = 1;\n\n    // Jump to loc_40A76B\n\nloc_40A7F0:\n    // Set r12d to 1\n    r12d = 1;\n\n    // Set edi to 1\n    edi = 1;\n\n    // Set ebp to 0\n    ebp = 0;\n\n    // Jump to loc_40A76B\n\nloc_40A802:\n    // Print \"out of memory\"\n    printf(\"out of memory\");\n\n_free:\n    // Free the allocated memory\n    free(name);\n}\n```"
    },
    {
        "func_name": "addgroup_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040D320 | 41 55 | push    r13\n0x0040D322 | 41 54 | push    r12\n0x0040D324 | 55 | push    rbp\n0x0040D325 | 53 | push    rbx\n0x0040D326 | 48 89 F3 | mov     rbx, rsi\n0x0040D329 | 48 83 EC 18 | sub     rsp, 18h\n0x0040D32D | C7 44 24 0C 00 00 00 00 | mov     [rsp+38h+var_2C], 0\n0x0040D335 | E8 96 96 FF FF | call    _geteuid\n0x0040D33A | 85 C0 | test    eax, eax\n0x0040D33C | 0F 85 D3 01 00 00 | jnz     loc_40D515\n0x0040D342 | 48 8D 54 24 0C | lea     rdx, [rsp+38h+var_2C]\n0x0040D347 | 31 C0 | xor     eax, eax\n0x0040D349 | BE C4 2E 52 00 | mov     esi, offset off_522EC4\n0x0040D34E | 48 89 DF | mov     rdi, rbx; argv\n0x0040D351 | 48 C7 05 6C 30 34 00 FC 2E 52 00 | mov     cs:qword_7503C8, offset aGid_2; \"gid\"\n0x0040D35C | 48 C7 05 59 30 34 00 BB 2E 52 00 | mov     cs:qword_7503C0, offset a12G; \"-1:?2:g+\"\n0x0040D367 | E8 14 6B 0E 00 | call    sub_4F3E80\n0x0040D36C | 48 63 15 A5 0A 34 00 | movsxd  rdx, cs:optind\n0x0040D373 | 4C 8D 24 D3 | lea     r12, [rbx+rdx*8]\n0x0040D377 | 49 83 7C 24 08 00 | cmp     qword ptr [r12+8], 0\n0x0040D37D | 0F 84 B5 00 00 00 | jz      loc_40D438\n0x0040D383 | A8 01 | test    al, 1\n0x0040D385 | 0F 85 96 01 00 00 | jnz     loc_40D521\n0x0040D38B | 49 8B 3C 24 | mov     rdi, [r12]\n0x0040D38F | E8 1C 33 0E 00 | call    sub_4F06B0\n0x0040D394 | 49 8B 7C 24 08 | mov     rdi, [r12+8]\n0x0040D399 | E8 B2 31 0E 00 | call    sub_4F0550\n0x0040D39E | 4D 8B 2C 24 | mov     r13, [r12]\n0x0040D3A2 | 48 8B 58 18 | mov     rbx, [rax+18h]\n0x0040D3A6 | 48 89 C5 | mov     rbp, rax\n0x0040D3A9 | 48 8B 33 | mov     rsi, [rbx]\n0x0040D3AC | 48 85 F6 | test    rsi, rsi\n0x0040D3AF | 74 3F | jz      short loc_40D3F0\n0x0040D3B1 | 48 83 C3 08 | add     rbx, 8\n0x0040D3B5 | EB 1A | jmp     short loc_40D3D1\n0x0040D3B7 | 66 0F 1F 84 00 00 00 00 00 | align 20h\n0x0040D3C0 | 48 89 5D 18 | mov     [rbp+18h], rbx\n0x0040D3C4 | 48 83 C3 08 | add     rbx, 8\n0x0040D3C8 | 48 8B 73 F8 | mov     rsi, [rbx-8]; s2\n0x0040D3CC | 48 85 F6 | test    rsi, rsi\n0x0040D3CF | 74 1F | jz      short loc_40D3F0\n0x0040D3D1 | 4C 89 EF | mov     rdi, r13; s1\n0x0040D3D4 | E8 07 99 FF FF | call    _strcmp\n0x0040D3D9 | 85 C0 | test    eax, eax\n0x0040D3DB | 75 E3 | jnz     short loc_40D3C0\n0x0040D3DD | 48 83 C4 18 | add     rsp, 18h\n0x0040D3E1 | 5B | pop     rbx\n0x0040D3E2 | 5D | pop     rbp\n0x0040D3E3 | 41 5C | pop     r12\n0x0040D3E5 | 41 5D | pop     r13\n0x0040D3E7 | C3 | retn\n0x0040D3E8 | 0F 1F 84 00 00 00 00 00 | align 10h\n0x0040D3F0 | 49 8B 74 24 08 | mov     rsi, [r12+8]\n0x0040D3F5 | 31 D2 | xor     edx, edx\n0x0040D3F7 | 4C 89 E9 | mov     rcx, r13\n0x0040D3FA | BF 56 2E 52 00 | mov     edi, offset aEtcGroup; \"/etc/group\"\n0x0040D3FF | E8 1C 53 0F 00 | call    sub_502720\n0x0040D404 | 89 C2 | mov     edx, eax\n0x0040D406 | B8 01 00 00 00 | mov     eax, 1\n0x0040D40B | 85 D2 | test    edx, edx\n0x0040D40D | 78 CE | js      short loc_40D3DD\n0x0040D40F | 49 8B 74 24 08 | mov     rsi, [r12+8]\n0x0040D414 | 49 8B 0C 24 | mov     rcx, [r12]\n0x0040D418 | 31 D2 | xor     edx, edx\n0x0040D41A | BF C8 2E 52 00 | mov     edi, offset aEtcGshadow; \"/etc/gshadow\"\n0x0040D41F | E8 FC 52 0F 00 | call    sub_502720\n0x0040D424 | 48 83 C4 18 | add     rsp, 18h\n0x0040D428 | 31 C0 | xor     eax, eax\n0x0040D42A | 5B | pop     rbx\n0x0040D42B | 5D | pop     rbp\n0x0040D42C | 41 5C | pop     r12\n0x0040D42E | 41 5D | pop     r13\n0x0040D430 | C3 | retn\n0x0040D431 | 0F 1F 80 00 00 00 00 | align 8\n0x0040D438 | 4D 8B 24 24 | mov     r12, [r12]\n0x0040D43C | 8B 5C 24 0C | mov     ebx, [rsp+38h+var_2C]\n0x0040D440 | 4C 89 E7 | mov     rdi, r12; s2\n0x0040D443 | E8 A8 F7 FF FF | call    sub_40CBF0\n0x0040D448 | 48 85 C0 | test    rax, rax\n0x0040D44B | 0F 85 D5 00 00 00 | jnz     loc_40D526\n0x0040D451 | 8B 05 79 2F 34 00 | mov     eax, cs:dword_7503D0\n0x0040D457 | BD FF FF FF 7F | mov     ebp, 7FFFFFFFh\n0x0040D45C | A8 01 | test    al, 1\n0x0040D45E | 75 38 | jnz     short loc_40D498\n0x0040D460 | 83 E0 02 | and     eax, 2\n0x0040D463 | 83 F8 01 | cmp     eax, 1\n0x0040D466 | 19 DB | sbb     ebx, ebx\n0x0040D468 | 81 E3 84 03 00 00 | and     ebx, 384h\n0x0040D46E | 83 C3 64 | add     ebx, 64h ; 'd'\n0x0040D471 | 83 F8 01 | cmp     eax, 1\n0x0040D474 | 19 ED | sbb     ebp, ebp\n0x0040D476 | 81 E5 00 FA 00 00 | and     ebp, 0FA00h\n0x0040D47C | 81 C5 E7 03 00 00 | add     ebp, 3E7h\n0x0040D482 | EB 14 | jmp     short loc_40D498\n0x0040D484 | 0F 1F 40 00 | align 8\n0x0040D488 | F6 05 41 2F 34 00 01 | test    byte ptr cs:dword_7503D0, 1\n0x0040D48F | 75 58 | jnz     short loc_40D4E9\n0x0040D491 | 39 EB | cmp     ebx, ebp\n0x0040D493 | 74 6F | jz      short loc_40D504\n0x0040D495 | 83 C3 01 | add     ebx, 1\n0x0040D498 | 89 DF | mov     edi, ebx\n0x0040D49A | E8 F1 F5 FF FF | call    sub_40CA90\n0x0040D49F | 48 85 C0 | test    rax, rax\n0x0040D4A2 | 75 E4 | jnz     short loc_40D488\n0x0040D4A4 | 89 DE | mov     esi, ebx\n0x0040D4A6 | BF F2 2E 52 00 | mov     edi, offset aXU; \"x:%u:\"\n0x0040D4AB | 31 C0 | xor     eax, eax\n0x0040D4AD | E8 8E D0 FF FF | call    sub_40A540\n0x0040D4B2 | 31 C9 | xor     ecx, ecx\n0x0040D4B4 | 4C 89 E6 | mov     rsi, r12\n0x0040D4B7 | BF 56 2E 52 00 | mov     edi, offset aEtcGroup; \"/etc/group\"\n0x0040D4BC | 48 89 C2 | mov     rdx, rax\n0x0040D4BF | E8 5C 52 0F 00 | call    sub_502720\n0x0040D4C4 | 85 C0 | test    eax, eax\n0x0040D4C6 | 78 72 | js      short loc_40D53A\n0x0040D4C8 | 4C 89 E6 | mov     rsi, r12\n0x0040D4CB | 31 C9 | xor     ecx, ecx\n0x0040D4CD | BA F8 2E 52 00 | mov     edx, offset asc_522EF8; \"!::\"\n0x0040D4D2 | BF C8 2E 52 00 | mov     edi, offset aEtcGshadow; \"/etc/gshadow\"\n0x0040D4D7 | E8 44 52 0F 00 | call    sub_502720\n0x0040D4DC | 48 83 C4 18 | add     rsp, 18h\n0x0040D4E0 | 31 C0 | xor     eax, eax\n0x0040D4E2 | 5B | pop     rbx\n0x0040D4E3 | 5D | pop     rbp\n0x0040D4E4 | 41 5C | pop     r12\n0x0040D4E6 | 41 5D | pop     r13\n0x0040D4E8 | C3 | retn\n0x0040D4E9 | 89 DF | mov     edi, ebx\n0x0040D4EB | E8 D0 C3 FF FF | call    sub_4098C0\n0x0040D4F0 | BE 80 2F 52 00 | mov     esi, (offset aGid+2); \"gid\"\n0x0040D4F5 | BF D5 2E 52 00 | mov     edi, offset aSSInUse; \"%s '%s' in use\"\n0x0040D4FA | 48 89 C2 | mov     rdx, rax\n0x0040D4FD | 31 C0 | xor     eax, eax\n0x0040D4FF | E8 BC B7 FF FF | call    sub_408CC0\n0x0040D504 | BE 67 00 00 00 | mov     esi, 67h ; 'g'\n0x0040D509 | BF E4 2E 52 00 | mov     edi, offset aNoCidsLeft; \"no %cids left\"\n0x0040D50E | 31 C0 | xor     eax, eax\n0x0040D510 | E8 AB B7 FF FF | call    sub_408CC0\n0x0040D515 | BF 32 2A 52 00 | mov     edi, offset aPermissionDeni; \"permission denied (are you root?)\"\n0x0040D51A | 31 C0 | xor     eax, eax\n0x0040D51C | E8 9F B7 FF FF | call    sub_408CC0\n0x0040D521 | E8 AA A5 FF FF | call    sub_407AD0\n0x0040D526 | 4C 89 E2 | mov     rdx, r12\n0x0040D529 | BE 5B 2E 52 00 | mov     esi, 522E5Bh\n0x0040D52E | BF D5 2E 52 00 | mov     edi, offset aSSInUse; \"%s '%s' in use\"\n0x0040D533 | 31 C0 | xor     eax, eax\n0x0040D535 | E8 86 B7 FF FF | call    sub_408CC0\n0x0040D53A | BF 01 00 00 00 | mov     edi, 1; status\n0x0040D53F | E8 8C A1 FF FF | call    _exit",
        "output": "```c\nvoid function(char* rbx) {\n    push r13;\n    push r12;\n    push rbp;\n    push rbx;\n    rbx = rbx;\n    rsp -= 0x18;\n    [rsp+0x2C] = 0;\n    _geteuid();\n    if (eax != 0) {\n        goto loc_40D515;\n    }\n    rdx = rsp+0x2C;\n    eax = 0;\n    esi = \"gid\";\n    rdi = rbx;\n    cs:qword_7503C8 = \"gid_2\";\n    cs:qword_7503C0 = \"12G\";\n    sub_4F3E80();\n    rdx = cs:optind;\n    r12 = rbx+rdx*8;\n    if (qword ptr [r12+8] == 0) {\n        goto loc_40D438;\n    }\n    if (al & 1) {\n        goto loc_40D521;\n    }\n    rdi = [r12];\n    sub_4F06B0();\n    rdi = [r12+8];\n    sub_4F0550();\n    r13 = [r12];\n    rbx = [rax+0x18];\n    rbp = rax;\n    rsi = [rbx];\n    if (rsi == 0) {\n        goto loc_40D3F0;\n    }\n    rbx += 8;\nloc_40D3D1:\n    [rbp+0x18] = rbx;\n    rbx += 8;\n    rsi = [rbx-8];\n    if (rsi == 0) {\n        goto loc_40D3F0;\n    }\n    rdi = r13;\n    _strcmp();\n    if (eax != 0) {\n        goto loc_40D3C0;\n    }\n    rsp += 0x18;\n    pop rbx;\n    pop rbp;\n    pop r12;\n    pop r13;\n    return;\nloc_40D3F0:\n    rsi = [r12+8];\n    edx = 0;\n    rcx = r13;\n    edi = \"/etc/group\";\n    sub_502720();\n    edx = eax;\n    eax = 1;\n    if (edx < 0) {\n        goto loc_40D3DD;\n    }\n    rsi = [r12+8];\n    rcx = [r12];\n    edx = 0;\n    edi = \"/etc/gshadow\";\n    sub_502720();\n    rsp += 0x18;\n    eax = 0;\n    pop rbx;\n    pop rbp;\n    pop r12;\n    pop r13;\n    return;\nloc_40D438:\n    r12 = [r12];\n    ebx = [rsp+0x2C];\n    rdi = r12;\n    sub_40CBF0();\n    if (rax != 0) {\n        goto loc_40D526;\n    }\n    eax = 1;\n    if (edx < 0) {\n        goto loc_40D3DD;\n    }\n    rsi = [r12+8];\n    rcx = [r12];\n    edx = 0;\n    edi = \"/etc/gshadow\";\n    sub_502720();\n    rsp += 0x18;\n    eax = 0;\n    pop rbx;\n    pop rbp;\n    pop r12;\n    pop r13;\n    return;\nloc_40D515:\n    edi = \"permission denied (are you root?)\";\n    eax = 0;\n    sub_408CC0();\nloc_40D521:\n    sub_407AD0();\nloc_40D526:\n    rdx = r12;\n    esi = 0x522E5B;\n    edi = \"SSInUse\";\n    eax = 0;\n    sub_408CC0();\n    edi = 1;\n    _exit();\n}\n```"
    },
    {
        "func_name": "xmove_fd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040A310 | 39 F7 | cmp     edi, esi\n0x0040A312 | 74 24 | jz      short locret_40A338\n0x0040A314 | 55 | push    rbp\n0x0040A315 | 89 F5 | mov     ebp, esi\n0x0040A317 | 53 | push    rbx\n0x0040A318 | 89 FB | mov     ebx, edi\n0x0040A31A | 48 83 EC 08 | sub     rsp, 8\n0x0040A31E | E8 CD C4 FF FF | call    _dup2\n0x0040A323 | 39 C5 | cmp     ebp, eax\n0x0040A325 | 75 12 | jnz     short loc_40A339\n0x0040A327 | 48 83 C4 08 | add     rsp, 8\n0x0040A32B | 89 DF | mov     edi, ebx; fd\n0x0040A32D | 5B | pop     rbx\n0x0040A32E | 5D | pop     rbp\n0x0040A32F | E9 4C C7 FF FF | jmp     _close\n0x0040A334 | 0F 1F 40 00 | align 8\n0x0040A338 | C3 | retn\n0x0040A339 | BF C8 7A 51 00 | mov     edi, offset aCanTDuplicateF; \"can't duplicate file descriptor\"\n0x0040A33E | 31 C0 | xor     eax, eax\n0x0040A340 | E8 FB E5 FF FF | call    sub_408940",
        "output": "```c\nvoid function(int edi, int esi) {\n    if (edi == esi) {\n        return;\n    }\n    push rbp;\n    int ebp = esi;\n    push rbx;\n    int ebx = edi;\n    sub rsp, 8;\n    _dup2();\n    if (ebp != eax) {\n        add rsp, 8;\n        edi = ebx; // fd\n        pop rbx;\n        pop rbp;\n        _close();\n    }\n    else {\n        mov edi, offset aCanTDuplicateF; // \"can't duplicate file descriptor\"\n        xor eax, eax;\n        sub_408940();\n    }\n    retn;\n}\n```"
    },
    {
        "func_name": "do_iproute",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00448910 | 48 8B 37 | mov     rsi, [rdi]; s2\n0x00448913 | 48 85 F6 | test    rsi, rsi\n0x00448916 | 74 2F | jz      short sub_448947\n0x00448918 | 53 | push    rbx\n0x00448919 | 48 89 FB | mov     rbx, rdi\n0x0044891C | BF 40 B6 51 00 | mov     edi, offset aAdd_1; \"add\"\n0x00448921 | E8 6A 7F 0A 00 | call    sub_4F0890\n0x00448926 | 83 F8 0B | cmp     eax, 0Bh; switch 12 cases\n0x00448929 | 0F 87 C0 00 00 00 | ja      def_448931; jumptable 0000000000448931 default case\n0x0044892F | 89 C0 | mov     eax, eax\n0x00448931 | FF 24 C5 20 B5 51 00 | jmp     ds:jpt_448931[rax*8]; switch jump",
        "output": "```c\nvoid function(void* rdi) {\n    void* rsi = *(void**)rdi; // s2\n    if (rsi == NULL) {\n        goto sub_448947;\n    }\n    push rbx;\n    void* rbx = rdi;\n    char* edi = \"add\";\n    sub_4F0890(edi);\n    switch (eax) {\n        case 0:\n            // case 0 code\n            break;\n        case 1:\n            // case 1 code\n            break;\n        case 2:\n            // case 2 code\n            break;\n        // ...\n        case 11:\n            // case 11 code\n            break;\n        default:\n            def_448931();\n            break;\n    }\n    jmp ds:jpt_448931[rax*8];\n}\n```"
    },
    {
        "func_name": "cmdlookup",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00465A10 | 41 55 | push    r13\n0x00465A12 | 41 54 | push    r12\n0x00465A14 | 41 89 F4 | mov     r12d, esi\n0x00465A17 | 55 | push    rbp\n0x00465A18 | 48 89 FD | mov     rbp, rdi\n0x00465A1B | 53 | push    rbx\n0x00465A1C | 48 83 EC 08 | sub     rsp, 8\n0x00465A20 | 0F B6 37 | movzx   esi, byte ptr [rdi]\n0x00465A23 | 89 F1 | mov     ecx, esi\n0x00465A25 | C1 E1 04 | shl     ecx, 4\n0x00465A28 | 40 84 F6 | test    sil, sil\n0x00465A2B | 74 21 | jz      short loc_465A4E\n0x00465A2D | 48 89 FA | mov     rdx, rdi\n0x00465A30 | EB 09 | jmp     short loc_465A3B\n0x00465A32 | 66 0F 1F 44 00 00 | align 8\n0x00465A38 | 0F B6 F0 | movzx   esi, al\n0x00465A3B | 48 83 C2 01 | add     rdx, 1\n0x00465A3F | 0F B6 02 | movzx   eax, byte ptr [rdx]\n0x00465A42 | 01 F1 | add     ecx, esi\n0x00465A44 | 84 C0 | test    al, al\n0x00465A46 | 75 F0 | jnz     short loc_465A38\n0x00465A48 | 81 E1 FF 7F 00 00 | and     ecx, 7FFFh\n0x00465A4E | 89 C8 | mov     eax, ecx\n0x00465A50 | BA 85 10 42 08 | mov     edx, 8421085h\n0x00465A55 | F7 E2 | mul     edx\n0x00465A57 | 89 C8 | mov     eax, ecx\n0x00465A59 | 29 D0 | sub     eax, edx\n0x00465A5B | D1 E8 | shr     eax, 1\n0x00465A5D | 01 C2 | add     edx, eax\n0x00465A5F | C1 EA 04 | shr     edx, 4\n0x00465A62 | 89 D0 | mov     eax, edx\n0x00465A64 | C1 E0 05 | shl     eax, 5\n0x00465A67 | 29 D0 | sub     eax, edx\n0x00465A69 | 29 C1 | sub     ecx, eax\n0x00465A6B | 48 8B 05 7E 84 2E 00 | mov     rax, cs:qword_74DEF0\n0x00465A72 | 4C 8D 2C C8 | lea     r13, [rax+rcx*8]\n0x00465A76 | 49 8B 5D 00 | mov     rbx, [r13+0]\n0x00465A7A | 48 85 DB | test    rbx, rbx\n0x00465A7D | 75 14 | jnz     short loc_465A93\n0x00465A7F | EB 3F | jmp     short loc_465AC0\n0x00465A81 | 0F 1F 80 00 00 00 00 | align 8\n0x00465A88 | 49 89 DD | mov     r13, rbx\n0x00465A8B | 48 8B 1B | mov     rbx, [rbx]\n0x00465A8E | 48 85 DB | test    rbx, rbx\n0x00465A91 | 74 2D | jz      short loc_465AC0\n0x00465A93 | 48 8D 7B 12 | lea     rdi, [rbx+12h]; s1\n0x00465A97 | 48 89 EE | mov     rsi, rbp; s2\n0x00465A9A | E8 41 12 FA FF | call    _strcmp\n0x00465A9F | 85 C0 | test    eax, eax\n0x00465AA1 | 75 E5 | jnz     short loc_465A88\n0x00465AA3 | 4C 89 2D 3E 84 2E 00 | mov     cs:qword_74DEE8, r13\n0x00465AAA | 48 83 C4 08 | add     rsp, 8\n0x00465AAE | 48 89 D8 | mov     rax, rbx\n0x00465AB1 | 5B | pop     rbx\n0x00465AB2 | 5D | pop     rbp\n0x00465AB3 | 41 5C | pop     r12\n0x00465AB5 | 41 5D | pop     r13\n0x00465AB7 | C3 | retn\n0x00465AB8 | 0F 1F 84 00 00 00 00 00 | align 20h\n0x00465AC0 | 31 DB | xor     ebx, ebx\n0x00465AC2 | 45 85 E4 | test    r12d, r12d\n0x00465AC5 | 74 DC | jz      short loc_465AA3\n0x00465AC7 | 48 89 EF | mov     rdi, rbp; s\n0x00465ACA | E8 81 0C FA FF | call    _strlen\n0x00465ACF | 48 8D 78 18 | lea     rdi, [rax+18h]\n0x00465AD3 | E8 58 45 FA FF | call    sub_40A030\n0x00465AD8 | 48 89 EE | mov     rsi, rbp; src\n0x00465ADB | 49 89 45 00 | mov     [r13+0], rax\n0x00465ADF | 48 8D 78 12 | lea     rdi, [rax+12h]; dest\n0x00465AE3 | 48 89 C3 | mov     rbx, rax\n0x00465AE6 | C6 40 10 FF | mov     byte ptr [rax+10h], 0FFh\n0x00465AEA | E8 91 09 FA FF | call    _strcpy\n0x00465AEF | EB B2 | jmp     short loc_465AA3",
        "output": "```c\nvoid function(char* s1, char* s2) {\n    int r12d = strlen(s2);\n    int rbp = s1;\n    int rbx;\n    int ecx;\n    int edx;\n    int eax;\n    \n    if (*s1 == 0) {\n        return;\n    }\n    \n    ecx = *s1;\n    ecx = ecx << 4;\n    \n    if (*s1 == 0) {\n        goto loc_465A4E;\n    }\n    \n    edx = s1;\n    \nloc_465A3B:\n    edx = edx + 1;\n    eax = *edx;\n    ecx = ecx + *s1;\n    \n    if (*edx != 0) {\n        goto loc_465A38;\n    }\n    \n    ecx = ecx & 0x7FFF;\n    \nloc_465A4E:\n    eax = ecx;\n    edx = 0x8421085;\n    eax = eax * edx;\n    eax = ecx;\n    eax = eax - edx;\n    eax = eax >> 1;\n    edx = edx + eax;\n    edx = edx >> 4;\n    eax = edx;\n    eax = eax << 5;\n    eax = eax - edx;\n    ecx = ecx - eax;\n    rbx = qword_74DEF0 + ecx * 8;\n    rbx = *rbx;\n    \n    if (rbx == 0) {\n        goto loc_465AC0;\n    }\n    \nloc_465A88:\n    r13 = rbx;\n    rbx = *rbx;\n    \n    if (rbx == 0) {\n        goto loc_465AC0;\n    }\n    \n    rdi = rbx + 0x12;\n    rsi = rbp;\n    strcmp(rdi, rsi);\n    \n    if (eax != 0) {\n        goto loc_465A88;\n    }\n    \n    qword_74DEE8 = r13;\n    return;\n    \nloc_465AC0:\n    ebx = 0;\n    \n    if (r12d == 0) {\n        goto loc_465AA3;\n    }\n    \n    rdi = rbp;\n    strlen(rdi);\n    rdi = rax + 0x18;\n    sub_40A030(rdi);\n    rsi = rbp;\n    qword_74DEE8 = rax;\n    rdi = rax + 0x12;\n    rbx = rax;\n    byte ptr [rax + 0x10] = 0xFF;\n    strcpy(rdi, rsi);\n    \n    goto loc_465AA3;\n}\n```"
    },
    {
        "func_name": "xrtnl_wilddump_request",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0044A450 | 48 83 EC 38 | sub     rsp, 38h\n0x0044A454 | B8 01 03 00 00 | mov     eax, 301h\n0x0044A459 | B9 10 00 00 00 | mov     ecx, 10h\n0x0044A45E | 41 B8 0C 00 00 00 | mov     r8d, 0Ch\n0x0044A464 | 66 89 44 24 16 | mov     [rsp+38h+var_22], ax\n0x0044A469 | 8B 47 1C | mov     eax, [rdi+1Ch]\n0x0044A46C | 66 89 54 24 14 | mov     [rsp+38h+var_24], dx\n0x0044A471 | 31 D2 | xor     edx, edx\n0x0044A473 | 83 C0 01 | add     eax, 1\n0x0044A476 | 40 88 74 24 20 | mov     [rsp+38h+var_18], sil\n0x0044A47B | 48 8D 74 24 10 | lea     rsi, [rsp+38h+var_28]\n0x0044A480 | 89 47 1C | mov     [rdi+1Ch], eax\n0x0044A483 | 89 47 20 | mov     [rdi+20h], eax\n0x0044A486 | 8B 3F | mov     edi, [rdi]\n0x0044A488 | 66 89 54 24 0E | mov     [rsp+38h+var_2A], dx\n0x0044A48D | BA 14 00 00 00 | mov     edx, 14h\n0x0044A492 | 66 89 4C 24 04 | mov     [rsp+38h+var_34], cx\n0x0044A497 | 48 8D 4C 24 04 | lea     rcx, [rsp+38h+var_34]\n0x0044A49C | C7 44 24 10 14 00 00 00 | mov     [rsp+38h+var_28], 14h\n0x0044A4A4 | C7 44 24 1C 00 00 00 00 | mov     [rsp+38h+var_1C], 0\n0x0044A4AC | 89 44 24 18 | mov     [rsp+38h+var_20], eax\n0x0044A4B0 | 48 C7 44 24 06 00 00 00 00 | mov     [rsp+38h+var_32], 0\n0x0044A4B9 | E8 B2 04 FC FF | call    sub_40A970\n0x0044A4BE | 48 83 C4 38 | add     rsp, 38h\n0x0044A4C2 | C3 | retn",
        "output": "```c\nvoid function(void* rdi) {\n    // sub     rsp, 38h\n    char var_22;\n    short var_24;\n    char var_18;\n    short var_2A;\n    short var_34;\n    int var_28;\n    int var_1C;\n    int var_20;\n    int var_32;\n\n    // mov     eax, 301h\n    int eax = 0x301;\n\n    // mov     ecx, 10h\n    int ecx = 0x10;\n\n    // mov     r8d, 0Ch\n    int r8d = 0x0C;\n\n    // mov     [rsp+38h+var_22], ax\n    *(short*)(rsp + 0x38 + &var_22) = (short)eax;\n\n    // mov     eax, [rdi+1Ch]\n    eax = *(int*)(rdi + 0x1C);\n\n    // mov     [rsp+38h+var_24], dx\n    *(short*)(rsp + 0x38 + &var_24) = (short)edx;\n\n    // xor     edx, edx\n    edx = 0;\n\n    // add     eax, 1\n    eax += 1;\n\n    // mov     [rsp+38h+var_18], sil\n    *(char*)(rsp + 0x38 + &var_18) = (char)sil;\n\n    // lea     rsi, [rsp+38h+var_28]\n    rsi = rsp + 0x38 + &var_28;\n\n    // mov     [rdi+1Ch], eax\n    *(int*)(rdi + 0x1C) = eax;\n\n    // mov     [rdi+20h], eax\n    *(int*)(rdi + 0x20) = eax;\n\n    // mov     edi, [rdi]\n    edi = *(int*)rdi;\n\n    // mov     [rsp+38h+var_2A], dx\n    *(short*)(rsp + 0x38 + &var_2A) = (short)edx;\n\n    // mov     edx, 14h\n    edx = 0x14;\n\n    // mov     [rsp+38h+var_34], cx\n    *(short*)(rsp + 0x38 + &var_34) = (short)ecx;\n\n    // lea     rcx, [rsp+38h+var_34]\n    rcx = rsp + 0x38 + &var_34;\n\n    // mov     [rsp+38h+var_28], 14h\n    *(int*)(rsp + 0x38 + &var_28) = 0x14;\n\n    // mov     [rsp+38h+var_1C], 0\n    *(int*)(rsp + 0x38 + &var_1C) = 0;\n\n    // mov     [rsp+38h+var_20], eax\n    *(int*)(rsp + 0x38 + &var_20) = eax;\n\n    // mov     [rsp+38h+var_32], 0\n    *(int*)(rsp + 0x38 + &var_32) = 0;\n\n    // call    sub_40A970\n    sub_40A970();\n\n    // add     rsp, 38h\n    // retn\n}\n```"
    },
    {
        "func_name": "create_icmp_socket",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F1850 | 53 | push    rbx\n0x004F1851 | BA 01 00 00 00 | mov     edx, 1; protocol\n0x004F1856 | BE 03 00 00 00 | mov     esi, 3; type\n0x004F185B | BF 02 00 00 00 | mov     edi, 2; domain\n0x004F1860 | E8 7B 60 F1 FF | call    _socket\n0x004F1865 | 85 C0 | test    eax, eax\n0x004F1867 | 79 1F | jns     short loc_4F1888\n0x004F1869 | 48 8B 05 10 EB 25 00 | mov     rax, cs:qword_750380\n0x004F1870 | 83 38 01 | cmp     dword ptr [rax], 1\n0x004F1873 | 74 2B | jz      short loc_4F18A0\n0x004F1875 | BF 54 2A 52 00 | mov     edi, offset aCanTCreateRawS; \"can't create raw socket\"\n0x004F187A | 31 C0 | xor     eax, eax\n0x004F187C | E8 BF 70 F1 FF | call    sub_408940\n0x004F1881 | 0F 1F 80 00 00 00 00 | align 8\n0x004F1888 | 89 C3 | mov     ebx, eax\n0x004F188A | E8 F1 4E F1 FF | call    _getuid\n0x004F188F | 89 C7 | mov     edi, eax\n0x004F1891 | E8 9A 8F F1 FF | call    sub_40A830\n0x004F1896 | 89 D8 | mov     eax, ebx\n0x004F1898 | 5B | pop     rbx\n0x004F1899 | C3 | retn\n0x004F189A | 66 0F 1F 44 00 00 | align 20h\n0x004F18A0 | BF 32 2A 52 00 | mov     edi, offset aPermissionDeni; \"permission denied (are you root?)\"\n0x004F18A5 | 31 C0 | xor     eax, eax\n0x004F18A7 | E8 14 74 F1 FF | call    sub_408CC0",
        "output": "```c\nvoid function() {\n    push rbx;\n    mov edx, 1; // protocol\n    mov esi, 3; // type\n    mov edi, 2; // domain\n    call _socket;\n    test eax, eax;\n    jns short loc_4F1888;\n    mov rax, cs:qword_750380;\n    cmp dword ptr [rax], 1;\n    jz short loc_4F18A0;\n    mov edi, offset aCanTCreateRawS; // \"can't create raw socket\"\n    xor eax, eax;\n    call sub_408940;\n    align 8;\nloc_4F1888:\n    mov ebx, eax;\n    call _getuid;\n    mov edi, eax;\n    call sub_40A830;\n    mov eax, ebx;\n    pop rbx;\n    retn;\nalign 20h;\nloc_4F18A0:\n    mov edi, offset aPermissionDeni; // \"permission denied (are you root?)\"\n    xor eax, eax;\n    call sub_408CC0;\n}\n```"
    },
    {
        "func_name": "set_local_var_from_halves",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0047AB30 | 48 89 F2 | mov     rdx, rsi\n0x0047AB33 | 48 83 EC 08 | sub     rsp, 8\n0x0047AB37 | 48 89 FE | mov     rsi, rdi\n0x0047AB3A | 31 C0 | xor     eax, eax\n0x0047AB3C | BF E5 5F 52 00 | mov     edi, offset aSS_12; \"%s=%s\"\n0x0047AB41 | E8 FA F9 F8 FF | call    sub_40A540\n0x0047AB46 | 31 D2 | xor     edx, edx\n0x0047AB48 | 31 F6 | xor     esi, esi\n0x0047AB4A | 48 83 C4 08 | add     rsp, 8\n0x0047AB4E | 48 89 C7 | mov     rdi, rax; ptr\n0x0047AB51 | E9 6A FD FF FF | jmp     sub_47A8C0",
        "output": "```c\nvoid function(void* rdi, void* rsi) {\n    void* rdx = rsi;\n    rsp -= 8;\n    rsi = rdi;\n    eax = 0;\n    edi = \"s=%s\";\n    sub_40A540(edi);\n    edx = 0;\n    esi = 0;\n    rsp += 8;\n    rdi = rax;\n    jmp sub_47A8C0;\n}\n```"
    },
    {
        "func_name": "remove_peer",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00443650 | 41 55 | push    r13\n0x00443652 | 4C 63 EE | movsxd  r13, esi\n0x00443655 | 41 54 | push    r12\n0x00443657 | 55 | push    rbp\n0x00443658 | 48 89 FD | mov     rbp, rdi\n0x0044365B | 53 | push    rbx\n0x0044365C | 48 83 EC 08 | sub     rsp, 8\n0x00443660 | 8B 47 2C | mov     eax, [rdi+2Ch]\n0x00443663 | 8D 70 FF | lea     esi, [rax-1]\n0x00443666 | 48 63 DE | movsxd  rbx, esi\n0x00443669 | 48 01 DB | add     rbx, rbx\n0x0044366C | 85 F6 | test    esi, esi\n0x0044366E | 79 1D | jns     short loc_44368D\n0x00443670 | EB 4E | jmp     short loc_4436C0\n0x00443672 | 66 0F 1F 44 00 00 | align 8\n0x00443678 | 7E 06 | jle     short loc_443680\n0x0044367A | 83 E8 01 | sub     eax, 1\n0x0044367D | 66 89 02 | mov     [rdx], ax\n0x00443680 | 48 83 EB 02 | sub     rbx, 2\n0x00443684 | 44 89 E6 | mov     esi, r12d\n0x00443687 | 41 83 FC FF | cmp     r12d, 0FFFFFFFFh\n0x0044368B | 74 33 | jz      short loc_4436C0\n0x0044368D | 48 8B 55 00 | mov     rdx, [rbp+0]\n0x00443691 | 44 8D 66 FF | lea     r12d, [rsi-1]\n0x00443695 | 48 01 DA | add     rdx, rbx\n0x00443698 | 0F BF 0A | movsx   ecx, word ptr [rdx]\n0x0044369B | 89 C8 | mov     eax, ecx\n0x0044369D | 44 39 E9 | cmp     ecx, r13d\n0x004436A0 | 75 D6 | jnz     short loc_443678\n0x004436A2 | 48 89 EF | mov     rdi, rbp\n0x004436A5 | 48 83 EB 02 | sub     rbx, 2\n0x004436A9 | E8 D2 FE FF FF | call    sub_443580\n0x004436AE | 44 89 E6 | mov     esi, r12d\n0x004436B1 | 41 83 FC FF | cmp     r12d, 0FFFFFFFFh\n0x004436B5 | 75 D6 | jnz     short loc_44368D\n0x004436B7 | 66 0F 1F 84 00 00 00 00 00 | nop     word ptr [rax+rax+00000000h]\n0x004436C0 | 8B 45 30 | mov     eax, [rbp+30h]\n0x004436C3 | 48 8B 7D 08 | mov     rdi, [rbp+8]\n0x004436C7 | 83 E8 01 | sub     eax, 1\n0x004436CA | 89 C2 | mov     edx, eax\n0x004436CC | 89 45 30 | mov     [rbp+30h], eax\n0x004436CF | 44 29 EA | sub     edx, r13d\n0x004436D2 | C1 E2 03 | shl     edx, 3\n0x004436D5 | 85 D2 | test    edx, edx\n0x004436D7 | 7F 27 | jg      short loc_443700\n0x004436D9 | 48 98 | cdqe\n0x004436DB | 48 8D 34 C5 00 00 00 00 | lea     rsi, ds:0[rax*8]\n0x004436E3 | E8 28 69 FC FF | call    sub_40A010\n0x004436E8 | 48 89 45 08 | mov     [rbp+8], rax\n0x004436EC | 8B 45 28 | mov     eax, [rbp+28h]\n0x004436EF | 85 C0 | test    eax, eax\n0x004436F1 | 75 45 | jnz     short loc_443738\n0x004436F3 | 48 83 C4 08 | add     rsp, 8\n0x004436F7 | 5B | pop     rbx\n0x004436F8 | 5D | pop     rbp\n0x004436F9 | 41 5C | pop     r12\n0x004436FB | 41 5D | pop     r13\n0x004436FD | C3 | retn\n0x004436FE | 66 90 | align 20h\n0x00443700 | 4E 8D 24 ED 08 00 00 00 | lea     r12, ds:8[r13*8]\n0x00443708 | 48 63 DA | movsxd  rbx, edx\n0x0044370B | 4D 8D 6C 24 F8 | lea     r13, [r12-8]\n0x00443710 | 4A 8D 34 27 | lea     rsi, [rdi+r12]; src\n0x00443714 | 48 89 DA | mov     rdx, rbx; n\n0x00443717 | 4A 8D 04 2F | lea     rax, [rdi+r13]\n0x0044371B | 48 89 C7 | mov     rdi, rax; dest\n0x0044371E | E8 1D 37 FC FF | call    _memcpy\n0x00443723 | 8B 55 28 | mov     edx, [rbp+28h]\n0x00443726 | 85 D2 | test    edx, edx\n0x00443728 | 75 36 | jnz     short loc_443760\n0x0044372A | 8B 45 30 | mov     eax, [rbp+30h]\n0x0044372D | 48 8B 7D 08 | mov     rdi, [rbp+8]\n0x00443731 | EB A6 | jmp     short loc_4436D9\n0x00443733 | 0F 1F 44 00 00 | align 8\n0x00443738 | 48 63 75 30 | movsxd  rsi, dword ptr [rbp+30h]\n0x0044373C | 48 8B 7D 10 | mov     rdi, [rbp+10h]\n0x00443740 | 48 C1 E6 03 | shl     rsi, 3\n0x00443744 | E8 C7 68 FC FF | call    sub_40A010\n0x00443749 | 48 89 45 10 | mov     [rbp+10h], rax\n0x0044374D | 48 83 C4 08 | add     rsp, 8\n0x00443751 | 5B | pop     rbx\n0x00443752 | 5D | pop     rbp\n0x00443753 | 41 5C | pop     r12\n0x00443755 | 41 5D | pop     r13\n0x00443757 | C3 | retn\n0x00443758 | 0F 1F 84 00 00 00 00 00 | align 20h\n0x00443760 | 48 8B 45 10 | mov     rax, [rbp+10h]\n0x00443764 | 48 89 DA | mov     rdx, rbx; n\n0x00443767 | 4A 8D 3C 28 | lea     rdi, [rax+r13]; dest\n0x0044376B | 4A 8D 34 20 | lea     rsi, [rax+r12]; src\n0x0044376F | E8 CC 36 FC FF | call    _memcpy\n0x00443774 | EB B4 | jmp     short loc_44372A",
        "output": "```c\nvoid function(int* rdi, int esi) {\n    int r13 = (int)esi;\n    int r12 = rdi[0x2C];\n    int rbp = rdi;\n    int rbx = r13;\n    rbx += rbx;\n    if (esi >= 0) {\n        if (esi <= 0) {\n            rdi[rbp] = r12;\n            rbx -= 2;\n            if (r12 != -1) {\n                int rdx = rdi[0];\n                int r12d = r13 - 1;\n                rdx += rbx;\n                int ecx = (int)(short)rdx;\n                int eax = ecx;\n                if (ecx == r13) {\n                    function(rbp, rbx - 2);\n                }\n                esi = r12d;\n            }\n        }\n    }\n    int eax = rdi[0x30];\n    int rdi = rdi[0x8];\n    eax -= 1;\n    int edx = eax;\n    rdi[0x30] = eax;\n    edx -= r13;\n    edx <<= 3;\n    if (edx <= 0) {\n        int r12 = r13 * 8 + 8;\n        int rbx = edx;\n        int r13 = r12 - 8;\n        int rsi = rdi + r12;\n        int rdx = rbx;\n        int rax = rdi + r13;\n        rdi = rax;\n        memcpy(rdi, rsi, rdx);\n        if (rdi[0x28] == 0) {\n            eax = rdi[0x30];\n            rdi = rdi[0x8];\n            goto loc_4436D9;\n        }\n    }\n    int rsi = (int)rdi[0x30];\n    rdi = rdi[0x10];\n    rsi <<= 3;\n    memcpy(rdi, rsi, rdi);\n    return;\n}\n```"
    },
    {
        "func_name": "open_as_user",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00414DA0 | 48 83 EC 28 | sub     rsp, 28h\n0x00414DA4 | 48 89 7C 24 08 | mov     [rsp+28h+var_20], rdi\n0x00414DA9 | 48 89 34 24 | mov     [rsp+28h+file], rsi\n0x00414DAD | E8 3E 27 FF FF | call    _vfork\n0x00414DB2 | 85 C0 | test    eax, eax\n0x00414DB4 | 78 61 | js      short loc_414E17\n0x00414DB6 | 74 20 | jz      short loc_414DD8\n0x00414DB8 | 89 C7 | mov     edi, eax; pid\n0x00414DBA | E8 71 51 FF FF | call    sub_409F30\n0x00414DBF | 85 C0 | test    eax, eax\n0x00414DC1 | 75 4D | jnz     short loc_414E10\n0x00414DC3 | 48 8B 3C 24 | mov     rdi, [rsp+28h+file]; file\n0x00414DC7 | 31 F6 | xor     esi, esi; oflag\n0x00414DC9 | E8 42 25 FF FF | call    _open64\n0x00414DCE | 48 83 C4 28 | add     rsp, 28h\n0x00414DD2 | C3 | retn\n0x00414DD3 | 0F 1F 44 00 00 | align 8\n0x00414DD8 | 48 8B 7C 24 08 | mov     rdi, [rsp+28h+var_20]\n0x00414DDD | E8 7E B9 0D 00 | call    sub_4F0760\n0x00414DE2 | 48 8B 3C 24 | mov     rdi, [rsp+28h+file]\n0x00414DE6 | 31 F6 | xor     esi, esi\n0x00414DE8 | E8 73 53 FF FF | call    sub_40A160\n0x00414DED | BA 01 00 00 00 | mov     edx, 1; nbytes\n0x00414DF2 | 48 8D 74 24 1F | lea     rsi, [rsp+28h+buf]; buf\n0x00414DF7 | 89 C7 | mov     edi, eax; fd\n0x00414DF9 | E8 D2 63 FF FF | call    sub_40B1D0\n0x00414DFE | 48 C1 E8 3F | shr     rax, 3Fh\n0x00414E02 | 48 89 C7 | mov     rdi, rax; status\n0x00414E05 | E8 66 16 FF FF | call    __exit\n0x00414E0A | 66 0F 1F 44 00 00 | align 10h\n0x00414E10 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x00414E15 | EB B7 | jmp     short loc_414DCE\n0x00414E17 | BF EB 37 52 00 | mov     edi, offset unk_5237EB\n0x00414E1C | 31 C0 | xor     eax, eax\n0x00414E1E | E8 1D 3B FF FF | call    sub_408940",
        "output": "```c\nvoid function(void* var_20, void* file) {\n    sub rsp, 0x28;\n    mov [rsp+0x28+var_20], rdi;\n    mov [rsp+0x28+file], rsi;\n    call _vfork;\n    test eax, eax;\n    js short loc_414E17;\n    jz short loc_414DD8;\n    mov edi, eax;\n    call sub_409F30;\n    test eax, eax;\n    jnz short loc_414E10;\n    mov rdi, [rsp+0x28+file];\n    xor esi, esi;\n    call _open64;\n    add rsp, 0x28;\n    retn;\n    align 8;\nloc_414DD8:\n    mov rdi, [rsp+0x28+var_20];\n    call sub_4F0760;\n    mov rdi, [rsp+0x28+file];\n    xor esi, esi;\n    call sub_40A160;\n    mov edx, 1;\n    lea rsi, [rsp+0x28+buf];\n    mov edi, eax;\n    call sub_40B1D0;\n    shr rax, 0x3F;\n    mov rdi, rax;\n    call __exit;\n    align 0x10;\nloc_414E10:\n    mov eax, 0xFFFFFFFF;\n    jmp short loc_414DCE;\nloc_414E17:\n    mov edi, offset unk_5237EB;\n    xor eax, eax;\n    call sub_408940;\n}\n```"
    },
    {
        "func_name": "collect_time",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00457850 | 41 55 | push    r13\n0x00457852 | 49 89 FD | mov     r13, rdi\n0x00457855 | 41 54 | push    r12\n0x00457857 | 55 | push    rbp\n0x00457858 | 53 | push    rbx\n0x00457859 | 48 83 EC 28 | sub     rsp, 28h\n0x0045785D | 8B 57 1C | mov     edx, [rdi+1Ch]\n0x00457860 | 48 8B 2D 21 8B 2F 00 | mov     rbp, cs:qword_750388\n0x00457867 | 89 D3 | mov     ebx, edx\n0x00457869 | 48 8B 45 20 | mov     rax, [rbp+20h]\n0x0045786D | C1 EB 1F | shr     ebx, 1Fh\n0x00457870 | 01 D3 | add     ebx, edx\n0x00457872 | D1 FB | sar     ebx, 1\n0x00457874 | 03 5D 28 | add     ebx, [rbp+28h]\n0x00457877 | 81 FB 3F 42 0F 00 | cmp     ebx, 0F423Fh\n0x0045787D | 0F 8F AD 00 00 00 | jg      loc_457930\n0x00457883 | 48 89 44 24 08 | mov     [rsp+48h+timer], rax\n0x00457888 | 48 8D 7C 24 08 | lea     rdi, [rsp+48h+timer]; timer\n0x0045788D | 4C 8D 64 24 10 | lea     r12, [rsp+48h+s]\n0x00457892 | E8 F9 EA FA FF | call    _localtime\n0x00457897 | BE 1F 8B 52 00 | mov     esi, offset a02d02d02d; \"%02d:%02d:%02d\"\n0x0045789C | 4C 89 E7 | mov     rdi, r12; s\n0x0045789F | 8B 48 04 | mov     ecx, [rax+4]\n0x004578A2 | 8B 50 08 | mov     edx, [rax+8]\n0x004578A5 | 44 8B 00 | mov     r8d, [rax]\n0x004578A8 | 31 C0 | xor     eax, eax\n0x004578AA | E8 E1 FD FA FF | call    _sprintf\n0x004578AF | 41 8B 75 18 | mov     esi, [r13+18h]\n0x004578B3 | 85 F6 | test    esi, esi\n0x004578B5 | 0F 85 8D 00 00 00 | jnz     loc_457948\n0x004578BB | 4C 89 E0 | mov     rax, r12\n0x004578BE | 8B 08 | mov     ecx, [rax]\n0x004578C0 | 48 83 C0 04 | add     rax, 4\n0x004578C4 | 8D 91 FF FE FE FE | lea     edx, [rcx-1010101h]\n0x004578CA | F7 D1 | not     ecx\n0x004578CC | 21 CA | and     edx, ecx\n0x004578CE | 81 E2 80 80 80 80 | and     edx, 80808080h\n0x004578D4 | 74 E8 | jz      short loc_4578BE\n0x004578D6 | 89 D1 | mov     ecx, edx\n0x004578D8 | 48 8B 7D 08 | mov     rdi, [rbp+8]; dest\n0x004578DC | BB 79 03 75 00 | mov     ebx, offset unk_750379\n0x004578E1 | C1 E9 10 | shr     ecx, 10h\n0x004578E4 | F7 C2 80 80 00 00 | test    edx, 8080h\n0x004578EA | 0F 44 D1 | cmovz   edx, ecx\n0x004578ED | 48 8D 48 02 | lea     rcx, [rax+2]\n0x004578F1 | 48 0F 44 C1 | cmovz   rax, rcx\n0x004578F5 | 89 D6 | mov     esi, edx\n0x004578F7 | 40 00 D6 | add     sil, dl\n0x004578FA | 4C 89 E6 | mov     rsi, r12; src\n0x004578FD | 48 83 D8 03 | sbb     rax, 3\n0x00457901 | 48 29 FB | sub     rbx, rdi\n0x00457904 | 4C 29 E0 | sub     rax, r12\n0x00457907 | 48 39 D8 | cmp     rax, rbx\n0x0045790A | 0F 4E D8 | cmovle  ebx, eax\n0x0045790D | 48 63 DB | movsxd  rbx, ebx\n0x00457910 | 48 89 DA | mov     rdx, rbx; n\n0x00457913 | E8 28 F5 FA FF | call    _memcpy\n0x00457918 | 48 01 5D 08 | add     [rbp+8], rbx\n0x0045791C | 48 83 C4 28 | add     rsp, 28h\n0x00457920 | 5B | pop     rbx\n0x00457921 | 5D | pop     rbp\n0x00457922 | 41 5C | pop     r12\n0x00457924 | 41 5D | pop     r13\n0x00457926 | C3 | retn\n0x00457927 | 66 0F 1F 84 00 00 00 00 00 | align 10h\n0x00457930 | 48 83 C0 01 | add     rax, 1\n0x00457934 | 81 EB 40 42 0F 00 | sub     ebx, 0F4240h\n0x0045793A | 48 89 44 24 08 | mov     [rsp+48h+timer], rax\n0x0045793F | E9 44 FF FF FF | jmp     loc_457888\n0x00457944 | 0F 1F 40 00 | align 8\n0x00457948 | 89 D8 | mov     eax, ebx\n0x0045794A | 49 8D 7C 24 08 | lea     rdi, [r12+8]; s\n0x0045794F | 99 | cdq\n0x00457950 | 41 F7 7D 1C | idiv    dword ptr [r13+1Ch]\n0x00457954 | 89 F2 | mov     edx, esi\n0x00457956 | BE 2E 8B 52 00 | mov     esi, offset a0D; \".%0*d\"\n0x0045795B | 89 C1 | mov     ecx, eax\n0x0045795D | 31 C0 | xor     eax, eax\n0x0045795F | E8 2C FD FA FF | call    _sprintf\n0x00457964 | E9 52 FF FF FF | jmp     loc_4578BB",
        "output": "```c\nvoid function(void* dest, void* src, int n) {\n    int timer;\n    char s[16];\n    int edx = *((int*)dest + 7);\n    int ebx = edx;\n    long long rbp = *((long long*)0x750388);\n    long long rax = *((long long*)rbp + 4);\n    ebx = (ebx >> 31) + edx;\n    ebx = ebx >> 1;\n    ebx = ebx + *((int*)rbp + 10);\n    if (ebx > 0xF423F) {\n        timer = rax;\n        char* s = (char*)&timer;\n        _localtime(&timer);\n        sprintf(s, \"%02d:%02d:%02d\", *((int*)rax + 1), *((int*)rax + 2), *((int*)rax + 3));\n    }\n    int esi = *((int*)src + 6);\n    if (esi == 0) {\n        char* s = (char*)src;\n        int ecx = *((int*)s);\n        s += 4;\n        int edx = ecx - 0x1010101;\n        ecx = ~ecx;\n        edx = edx & ecx;\n        edx = edx & 0x80808080;\n        if (edx != 0) {\n            ecx = edx;\n            char* dest = (char*)dest;\n            ebx = 0x750379;\n            ecx = ecx >> 16;\n            if ((edx & 0x8080) == 0) {\n                edx = ecx;\n            }\n            char* rcx = rax + 2;\n            if ((edx & 0x80) == 0) {\n                rax = rcx;\n            }\n            esi = edx;\n            esi = esi + (esi & 0xFF);\n            memcpy(s, src, rax - src);\n            *((int*)dest + 2) = *((int*)dest + 2) + (rax - src);\n        }\n    }\n    else {\n        int eax = ebx;\n        char* s = (char*)(src + 8);\n        int edx = 0;\n        edx = edx / *((int*)dest + 7);\n        edx = esi;\n        int ecx = eax;\n        eax = 0;\n        sprintf(s, \"%.0*d\", ecx, edx);\n    }\n}\n```"
    },
    {
        "func_name": "read_key_ungets",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00500360 | 55 | push    rbp\n0x00500361 | 48 89 FD | mov     rbp, rdi\n0x00500364 | 53 | push    rbx\n0x00500365 | BB 0F 00 00 00 | mov     ebx, 0Fh\n0x0050036A | 48 83 EC 08 | sub     rsp, 8\n0x0050036E | 0F B6 0F | movzx   ecx, byte ptr [rdi]\n0x00500371 | 29 CB | sub     ebx, ecx\n0x00500373 | 48 8D 7C 0F 01 | lea     rdi, [rdi+rcx+1]; dest\n0x00500378 | 39 D3 | cmp     ebx, edx\n0x0050037A | 0F 47 DA | cmova   ebx, edx\n0x0050037D | 89 DA | mov     edx, ebx; n\n0x0050037F | E8 BC 6A F0 FF | call    _memcpy\n0x00500384 | 00 5D 00 | add     [rbp+0], bl\n0x00500387 | 48 83 C4 08 | add     rsp, 8\n0x0050038B | 5B | pop     rbx\n0x0050038C | 5D | pop     rbp\n0x0050038D | C3 | retn",
        "output": "```c\nvoid function(char* dest, int n) {\n    char* rbp = dest;\n    int ebx = 0x0F;\n    dest--;\n    ebx -= *dest;\n    dest += ebx + 1;\n    if (ebx > n) {\n        ebx = n;\n    }\n    memcpy(dest, rbp, ebx);\n}\n```"
    },
    {
        "func_name": "route_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043B5D0 | 41 56 | push    r14\n0x0043B5D2 | 41 55 | push    r13\n0x0043B5D4 | 41 54 | push    r12\n0x0043B5D6 | 55 | push    rbp\n0x0043B5D7 | 53 | push    rbx\n0x0043B5D8 | 48 89 F3 | mov     rbx, rsi\n0x0043B5DB | 48 83 EC 10 | sub     rsp, 10h\n0x0043B5DF | 48 8B 46 08 | mov     rax, [rsi+8]\n0x0043B5E3 | 48 85 C0 | test    rax, rax\n0x0043B5E6 | 74 4F | jz      short loc_43B637\n0x0043B5E8 | 4C 8D 46 08 | lea     r8, [rsi+8]\n0x0043B5EC | 41 B9 68 6E 52 00 | mov     r9d, offset aNet; \"-net\"\n0x0043B5F2 | 66 0F 1F 44 00 00 | nop     word ptr [rax+rax+00h]\n0x0043B5F8 | B9 05 00 00 00 | mov     ecx, 5\n0x0043B5FD | 48 89 C6 | mov     rsi, rax\n0x0043B600 | 4C 89 CF | mov     rdi, r9\n0x0043B603 | F3 A6 | repe cmpsb\n0x0043B605 | 0F 97 C2 | setnbe  dl\n0x0043B608 | 80 DA 00 | sbb     dl, 0\n0x0043B60B | 84 D2 | test    dl, dl\n0x0043B60D | 74 19 | jz      short loc_43B628\n0x0043B60F | BF 6D 6E 52 00 | mov     edi, offset aHost_1; \"-host\"\n0x0043B614 | B9 06 00 00 00 | mov     ecx, 6\n0x0043B619 | 48 89 C6 | mov     rsi, rax\n0x0043B61C | F3 A6 | repe cmpsb\n0x0043B61E | 0F 97 C2 | setnbe  dl\n0x0043B621 | 80 DA 00 | sbb     dl, 0\n0x0043B624 | 84 D2 | test    dl, dl\n0x0043B626 | 75 03 | jnz     short loc_43B62B\n0x0043B628 | C6 00 23 | mov     byte ptr [rax], 23h ; '#'\n0x0043B62B | 49 83 C0 08 | add     r8, 8\n0x0043B62F | 49 8B 00 | mov     rax, [r8]\n0x0043B632 | 48 85 C0 | test    rax, rax\n0x0043B635 | 75 C1 | jnz     short loc_43B5F8\n0x0043B637 | 48 8D 54 24 08 | lea     rdx, [rsp+38h+var_30]\n0x0043B63C | BE 73 6E 52 00 | mov     esi, offset aANe; \"A:ne\"\n0x0043B641 | 48 89 DF | mov     rdi, rbx; argv\n0x0043B644 | 31 C0 | xor     eax, eax\n0x0043B646 | E8 35 88 0B 00 | call    sub_4F3E80\n0x0043B64B | 41 89 C6 | mov     r14d, eax\n0x0043B64E | A8 01 | test    al, 1\n0x0043B650 | 74 21 | jz      short loc_43B673\n0x0043B652 | 48 8B 54 24 08 | mov     rdx, [rsp+38h+var_30]\n0x0043B657 | BF A1 50 52 00 | mov     edi, offset aInet; \"inet\"\n0x0043B65C | B9 05 00 00 00 | mov     ecx, 5\n0x0043B661 | 48 89 D6 | mov     rsi, rdx\n0x0043B664 | F3 A6 | repe cmpsb\n0x0043B666 | 0F 97 C0 | setnbe  al\n0x0043B669 | 1C 00 | sbb     al, 0\n0x0043B66B | 84 C0 | test    al, al\n0x0043B66D | 0F 85 8D 00 00 00 | jnz     loc_43B700\n0x0043B673 | 48 63 05 9E 27 31 00 | movsxd  rax, cs:optind\n0x0043B67A | 4C 8D 2C C3 | lea     r13, [rbx+rax*8]\n0x0043B67E | 4D 8B 65 00 | mov     r12, [r13+0]\n0x0043B682 | 4D 85 E4 | test    r12, r12\n0x0043B685 | 0F 84 B6 00 00 00 | jz      loc_43B741\n0x0043B68B | BB 06 00 00 00 | mov     ebx, 6\n0x0043B690 | BD 00 62 51 00 | mov     ebp, offset unk_516200\n0x0043B695 | EB 19 | jmp     short loc_43B6B0\n0x0043B697 | 66 0F 1F 84 00 00 00 00 00 | align 20h\n0x0043B6A0 | 48 01 DD | add     rbp, rbx\n0x0043B6A3 | 48 0F BE 5D 00 | movsx   rbx, byte ptr [rbp+0]\n0x0043B6A8 | 84 DB | test    bl, bl\n0x0043B6AA | 0F 84 8C 00 00 00 | jz      loc_43B73C\n0x0043B6B0 | 48 8D 7D 02 | lea     rdi, [rbp+2]; s1\n0x0043B6B4 | 4C 89 E6 | mov     rsi, r12; s2\n0x0043B6B7 | E8 24 B6 FC FF | call    _strcmp\n0x0043B6BC | 85 C0 | test    eax, eax\n0x0043B6BE | 75 E0 | jnz     short loc_43B6A0\n0x0043B6C0 | 0F BE 7D 01 | movsx   edi, byte ptr [rbp+1]\n0x0043B6C4 | 49 8D 75 08 | lea     rsi, [r13+8]\n0x0043B6C8 | 40 F6 C7 10 | test    dil, 10h\n0x0043B6CC | 74 0B | jz      short loc_43B6D9\n0x0043B6CE | 49 83 7D 08 00 | cmp     qword ptr [r13+8], 0\n0x0043B6D3 | 74 67 | jz      short loc_43B73C\n0x0043B6D5 | 49 8D 75 10 | lea     rsi, [r13+10h]\n0x0043B6D9 | 85 FF | test    edi, edi\n0x0043B6DB | 74 5F | jz      short loc_43B73C\n0x0043B6DD | 48 83 3E 00 | cmp     qword ptr [rsi], 0\n0x0043B6E1 | 74 59 | jz      short loc_43B73C\n0x0043B6E3 | 41 83 E6 08 | and     r14d, 8\n0x0043B6E7 | 74 3F | jz      short loc_43B728\n0x0043B6E9 | E8 52 F3 FF FF | call    sub_43AA40\n0x0043B6EE | 48 83 C4 10 | add     rsp, 10h\n0x0043B6F2 | 31 C0 | xor     eax, eax\n0x0043B6F4 | 5B | pop     rbx\n0x0043B6F5 | 5D | pop     rbp\n0x0043B6F6 | 41 5C | pop     r12\n0x0043B6F8 | 41 5D | pop     r13\n0x0043B6FA | 41 5E | pop     r14\n0x0043B6FC | C3 | retn\n0x0043B6FD | 0F 1F 00 | align 20h\n0x0043B700 | BF 7B 63 52 00 | mov     edi, 52637Bh\n0x0043B705 | B9 06 00 00 00 | mov     ecx, 6\n0x0043B70A | 48 89 D6 | mov     rsi, rdx\n0x0043B70D | F3 A6 | repe cmpsb\n0x0043B70F | 0F 97 C0 | setnbe  al\n0x0043B712 | 1C 00 | sbb     al, 0\n0x0043B714 | 84 C0 | test    al, al\n0x0043B716 | 75 24 | jnz     short loc_43B73C\n0x0043B718 | 41 83 CE 08 | or      r14d, 8\n0x0043B71C | E9 52 FF FF FF | jmp     loc_43B673\n0x0043B721 | 0F 1F 80 00 00 00 00 | align 8\n0x0043B728 | E8 E3 F6 FF FF | call    sub_43AE10\n0x0043B72D | 48 83 C4 10 | add     rsp, 10h\n0x0043B731 | 31 C0 | xor     eax, eax\n0x0043B733 | 5B | pop     rbx\n0x0043B734 | 5D | pop     rbp\n0x0043B735 | 41 5C | pop     r12\n0x0043B737 | 41 5D | pop     r13\n0x0043B739 | 41 5E | pop     r14\n0x0043B73B | C3 | retn\n0x0043B73C | E8 8F C3 FC FF | call    sub_407AD0\n0x0043B741 | 44 89 F7 | mov     edi, r14d\n0x0043B744 | C1 E7 1E | shl     edi, 1Eh\n0x0043B747 | C1 FF 1F | sar     edi, 1Fh\n0x0043B74A | 81 E7 FF 0F 00 00 | and     edi, 0FFFh\n0x0043B750 | 41 F6 C6 08 | test    r14b, 8\n0x0043B754 | 74 0C | jz      short loc_43B762\n0x0043B756 | E8 15 F0 FF FF | call    sub_43A770\n0x0043B75B | 31 FF | xor     edi, edi; status\n0x0043B75D | E8 6E 79 0B 00 | call    sub_4F30D0\n0x0043B762 | 44 89 F6 | mov     esi, r14d\n0x0043B765 | 83 E6 04 | and     esi, 4\n0x0043B768 | E8 E3 FB FF FF | call    sub_43B350\n0x0043B76D | EB EC | jmp     short loc_43B75B",
        "output": "```c\nvoid function(char* rbx, int optind) {\n    char* rax = rbx + 8;\n    if (*rax == '\\0') {\n        if (strcmp(rbx + 8, \"-net\") == 0) {\n            if (*(rbx + 1) != '\\0' && *(rbx + 8) != '\\0') {\n                *rax = '#';\n                rax += 8;\n                while (*rax != '\\0') {\n                    if (strcmp(rax, \"-host\") == 0) {\n                        *(rax - 8) = '\\0';\n                        break;\n                    }\n                    rax += 8;\n                }\n            }\n        }\n    } else {\n        if (strcmp(rbx + 8, \"A:ne\") == 0) {\n            if (*(rbx + 1) != '\\0' && *(rbx + 8) != '\\0') {\n                *rax = '#';\n                rax += 8;\n                while (*rax != '\\0') {\n                    if (strcmp(rax, \"inet\") == 0) {\n                        *(rax - 8) = '\\0';\n                        break;\n                    }\n                    rax += 8;\n                }\n            }\n        }\n    }\n    int optind_extended = (int)optind;\n    char* r13 = rbx + optind_extended * 8;\n    char* r12 = *(r13 + 0);\n    if (r12 != NULL) {\n        if (strcmp(r12 + 2, r13 + 8) == 0) {\n            if ((*(r13 + 1) & 0x10) == 0) {\n                if (*(r13 + 8) != NULL) {\n                    if ((r14 & 0x08) != 0) {\n                        sub_43AA40(rdx, \"52637B\", 6);\n                        r14 |= 0x08;\n                    }\n                }\n            }\n        }\n    }\n    sub_43AE10();\n    sub_407AD0(r14);\n    int status = r14;\n    status <<= 0x1E;\n    status >>= 0x1F;\n    status &= 0xFFF;\n    if ((r14 & 0x08) != 0) {\n        sub_43A770();\n        status = 0;\n        sub_4F30D0();\n    }\n    int esi = r14;\n    esi &= 0x04;\n    sub_43B350();\n}\n```"
    },
    {
        "func_name": "udhcp_add_simple_option",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004526B0 | 48 83 EC 18 | sub     rsp, 18h\n0x004526B4 | 40 80 FE 01 | cmp     sil, 1\n0x004526B8 | 74 61 | jz      short loc_45271B\n0x004526BA | 41 89 F1 | mov     r9d, esi\n0x004526BD | 41 B8 A0 0D 51 00 | mov     r8d, offset byte_510DA0\n0x004526C3 | EB 0B | jmp     short loc_4526D0\n0x004526C5 | 0F 1F 00 | align 8\n0x004526C8 | 44 38 C8 | cmp     al, r9b\n0x004526CB | 74 23 | jz      short loc_4526F0\n0x004526CD | 49 89 C8 | mov     r8, rcx\n0x004526D0 | 49 8D 48 02 | lea     rcx, [r8+2]\n0x004526D4 | 0F B6 41 01 | movzx   eax, byte ptr [rcx+1]\n0x004526D8 | 84 C0 | test    al, al\n0x004526DA | 75 EC | jnz     short loc_4526C8\n0x004526DC | 40 0F B6 F6 | movzx   esi, sil\n0x004526E0 | BF 35 87 52 00 | mov     edi, offset aCanTAddOption0; \"can't add option 0x%02x\"\n0x004526E5 | E8 76 66 FB FF | call    sub_408D60\n0x004526EA | 48 83 C4 18 | add     rsp, 18h\n0x004526EE | C3 | retn\n0x004526EF | 90 | align 10h\n0x004526F0 | 41 0F B6 40 02 | movzx   eax, byte ptr [r8+2]\n0x004526F5 | 83 E0 0F | and     eax, 0Fh\n0x004526F8 | 0F B6 80 88 0C 51 00 | movzx   eax, ds:byte_510C88[rax]\n0x004526FF | 40 88 74 24 0A | mov     [rsp+18h+var_E], sil\n0x00452704 | 48 8D 74 24 0A | lea     rsi, [rsp+18h+var_E]\n0x00452709 | 88 44 24 0B | mov     [rsp+18h+var_D], al\n0x0045270D | 89 54 24 0C | mov     [rsp+18h+var_C], edx\n0x00452711 | E8 5A FE FF FF | call    sub_452570\n0x00452716 | 48 83 C4 18 | add     rsp, 18h\n0x0045271A | C3 | retn\n0x0045271B | B8 04 00 00 00 | mov     eax, 4\n0x00452720 | EB DD | jmp     short loc_4526FF",
        "output": "```c\nvoid function() {\n    // sub     rsp, 18h\n    __asm__(\"sub rsp, 0x18\");\n\n    // cmp     sil, 1\n    if (sil == 1) {\n        // jz      short loc_45271B\n        goto loc_45271B;\n    }\n\n    // mov     r9d, esi\n    r9d = esi;\n\n    // mov     r8d, offset byte_510DA0\n    r8d = &byte_510DA0;\n\n    // jmp     short loc_4526D0\n    goto loc_4526D0;\n\nloc_4526C8:\n    // cmp     al, r9b\n    if (al == r9b) {\n        // jz      short loc_4526F0\n        goto loc_4526F0;\n    }\n\n    // mov     r8, rcx\n    r8 = rcx;\n\nloc_4526D0:\n    // lea     rcx, [r8+2]\n    rcx = r8 + 2;\n\n    // movzx   eax, byte ptr [rcx+1]\n    eax = (unsigned char)*(rcx + 1);\n\n    // test    al, al\n    if (al != 0) {\n        // jnz     short loc_4526C8\n        goto loc_4526C8;\n    }\n\n    // movzx   esi, sil\n    esi = (unsigned char)sil;\n\n    // mov     edi, offset aCanTAddOption0; \"can't add option 0x%02x\"\n    edi = &aCanTAddOption0;\n\n    // call    sub_408D60\n    sub_408D60();\n\n    // add     rsp, 18h\n    __asm__(\"add rsp, 0x18\");\n\n    // retn\n    return;\n\nloc_4526F0:\n    // movzx   eax, byte ptr [r8+2]\n    eax = (unsigned char)*(r8 + 2);\n\n    // and     eax, 0Fh\n    eax = eax & 0x0F;\n\n    // movzx   eax, ds:byte_510C88[rax]\n    eax = (unsigned char)byte_510C88[eax];\n\n    // mov     [rsp+18h+var_E], sil\n    *(rsp + 0x18 + var_E) = sil;\n\n    // lea     rsi, [rsp+18h+var_E]\n    rsi = rsp + 0x18 + var_E;\n\n    // mov     [rsp+18h+var_D], al\n    *(rsp + 0x18 + var_D) = al;\n\n    // mov     [rsp+18h+var_C], edx\n    *(rsp + 0x18 + var_C) = edx;\n\n    // call    sub_452570\n    sub_452570();\n\n    // add     rsp, 18h\n    __asm__(\"add rsp, 0x18\");\n\n    // retn\n    return;\n\nloc_45271B:\n    // mov     eax, 4\n    eax = 4;\n\nloc_4526FF:\n    // jmp     short loc_4526FF\n    goto loc_4526FF;\n}\n```"
    },
    {
        "func_name": "out1fmt",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00466470 | 53 | push    rbx\n0x00466471 | 48 81 EC D0 00 00 00 | sub     rsp, 0D0h\n0x00466478 | 48 89 74 24 28 | mov     [rsp+0D8h+var_B0], rsi\n0x0046647D | 48 89 54 24 30 | mov     [rsp+0D8h+var_A8], rdx\n0x00466482 | 48 89 4C 24 38 | mov     [rsp+0D8h+var_A0], rcx\n0x00466487 | 4C 89 44 24 40 | mov     [rsp+0D8h+var_98], r8\n0x0046648C | 4C 89 4C 24 48 | mov     [rsp+0D8h+var_90], r9\n0x00466491 | 84 C0 | test    al, al\n0x00466493 | 74 37 | jz      short loc_4664CC\n0x00466495 | 0F 29 44 24 50 | movaps  [rsp+0D8h+var_88], xmm0\n0x0046649A | 0F 29 4C 24 60 | movaps  [rsp+0D8h+var_78], xmm1\n0x0046649F | 0F 29 54 24 70 | movaps  [rsp+0D8h+var_68], xmm2\n0x004664A4 | 0F 29 9C 24 80 00 00 00 | movaps  [rsp+0D8h+var_58], xmm3\n0x004664AC | 0F 29 A4 24 90 00 00 00 | movaps  [rsp+0D8h+var_48], xmm4\n0x004664B4 | 0F 29 AC 24 A0 00 00 00 | movaps  [rsp+0D8h+var_38], xmm5\n0x004664BC | 0F 29 B4 24 B0 00 00 00 | movaps  [rsp+0D8h+var_28], xmm6\n0x004664C4 | 0F 29 BC 24 C0 00 00 00 | movaps  [rsp+0D8h+var_18], xmm7\n0x004664CC | 48 8B 1D C5 9E 2E 00 | mov     rbx, cs:qword_750398\n0x004664D3 | 8B 43 30 | mov     eax, [rbx+30h]\n0x004664D6 | 83 C0 01 | add     eax, 1\n0x004664D9 | 89 43 30 | mov     [rbx+30h], eax\n0x004664DC | 48 8D 84 24 E0 00 00 00 | lea     rax, [rsp+0D8h+arg_0]\n0x004664E4 | 48 89 FE | mov     rsi, rdi; format\n0x004664E7 | 48 8B 3D 1A 79 2E 00 | mov     rdi, cs:stdout; s\n0x004664EE | 48 8D 54 24 08 | lea     rdx, [rsp+0D8h+arg]; arg\n0x004664F3 | 48 89 44 24 10 | mov     [rsp+0D8h+var_C8], rax\n0x004664F8 | 48 8D 44 24 20 | lea     rax, [rsp+0D8h+var_B8]\n0x004664FD | C7 44 24 08 08 00 00 00 | mov     [rsp+0D8h+arg], 8\n0x00466505 | C7 44 24 0C 30 00 00 00 | mov     [rsp+0D8h+var_CC], 30h ; '0'\n0x0046650D | 48 89 44 24 18 | mov     [rsp+0D8h+var_C0], rax\n0x00466512 | E8 F9 0F FA FF | call    _vfprintf\n0x00466517 | 83 6B 30 01 | sub     dword ptr [rbx+30h], 1\n0x0046651B | 75 08 | jnz     short loc_466525\n0x0046651D | 0F B6 53 34 | movzx   edx, byte ptr [rbx+34h]\n0x00466521 | 84 D2 | test    dl, dl\n0x00466523 | 75 09 | jnz     short loc_46652E\n0x00466525 | 48 81 C4 D0 00 00 00 | add     rsp, 0D0h\n0x0046652C | 5B | pop     rbx\n0x0046652D | C3 | retn\n0x0046652E | E8 2D F0 FF FF | call    sub_465560",
        "output": "```c\nvoid function(void* arg_0) {\n    rbx = arg_0;\n    rsi = arg_0;\n    rdi = stdout;\n    arg = &arg;\n    var_C8 = &var_B8;\n    arg = 8;\n    var_CC = 0x30;\n    var_C0 = &var_B8;\n    _vfprintf(rdi, rsi, &arg, &var_C8);\n    rbx->field_30 -= 1;\n    if (rbx->field_30 != 0) {\n        edx = rbx->field_34;\n        if (edx != 0) {\n            add rsp, 0xD0;\n            return;\n        }\n    }\n    sub_465560();\n}\n```"
    },
    {
        "func_name": "xgetpwnam",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F0530 | 53 | push    rbx\n0x004F0531 | 48 89 FB | mov     rbx, rdi\n0x004F0534 | E8 07 C6 F1 FF | call    sub_40CB40\n0x004F0539 | 48 85 C0 | test    rax, rax\n0x004F053C | 74 02 | jz      short loc_4F0540\n0x004F053E | 5B | pop     rbx\n0x004F053F | C3 | retn\n0x004F0540 | 48 89 DE | mov     rsi, rbx\n0x004F0543 | BF 5D 8E 52 00 | mov     edi, offset aUnknownUserS; \"unknown user %s\"\n0x004F0548 | E8 73 87 F1 FF | call    sub_408CC0",
        "output": "```c\nvoid function(void* rdi) {\n    push rbx;\n    mov rbx, rdi;\n    call sub_40CB40;\n    test rax, rax;\n    jz short loc_4F0540;\n    pop rbx;\n    retn;\n    \nloc_4F0540:\n    mov rsi, rbx;\n    mov edi, offset aUnknownUserS; // \"unknown user %s\"\n    call sub_408CC0;\n}\n```"
    },
    {
        "func_name": "print_signames",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x005018E0 | 55 | push    rbp\n0x005018E1 | BD C7 5F 51 00 | mov     ebp, offset off_515FC7\n0x005018E6 | 53 | push    rbx\n0x005018E7 | BB 01 00 00 00 | mov     ebx, 1\n0x005018EC | 48 83 EC 08 | sub     rsp, 8\n0x005018F0 | EB 12 | jmp     short loc_501904\n0x005018F2 | 66 0F 1F 44 00 00 | align 8\n0x005018F8 | 83 C3 01 | add     ebx, 1\n0x005018FB | 48 83 C5 07 | add     rbp, 7\n0x005018FF | 83 FB 21 | cmp     ebx, 21h ; '!'\n0x00501902 | 74 23 | jz      short loc_501927\n0x00501904 | 80 7D 00 00 | cmp     byte ptr [rbp+0], 0\n0x00501908 | 74 EE | jz      short loc_5018F8\n0x0050190A | 48 89 EA | mov     rdx, rbp\n0x0050190D | 89 DE | mov     esi, ebx\n0x0050190F | BF 07 EF 52 00 | mov     edi, offset a2uS; \"%2u) %s\\n\"\n0x00501914 | 31 C0 | xor     eax, eax\n0x00501916 | E8 25 4F F0 FF | call    _printf\n0x0050191B | 83 C3 01 | add     ebx, 1\n0x0050191E | 48 83 C5 07 | add     rbp, 7\n0x00501922 | 83 FB 21 | cmp     ebx, 21h ; '!'\n0x00501925 | 75 DD | jnz     short loc_501904\n0x00501927 | 48 83 C4 08 | add     rsp, 8\n0x0050192B | BA 01 EF 52 00 | mov     edx, offset aRtmax; \"RTMAX\"\n0x00501930 | BE 40 00 00 00 | mov     esi, 40h ; '@'\n0x00501935 | 31 C0 | xor     eax, eax\n0x00501937 | 5B | pop     rbx\n0x00501938 | BF 07 EF 52 00 | mov     edi, offset a2uS; \"%2u) %s\\n\"\n0x0050193D | 5D | pop     rbp\n0x0050193E | E9 FD 4E F0 FF | jmp     _printf",
        "output": "```c\n#include <stdio.h>\n\nint main() {\n    int ebp = 0x515FC7;\n    int ebx = 1;\n    \n    while (1) {\n        ebx += 1;\n        ebp += 7;\n        \n        if (ebx == 0x21) {\n            break;\n        }\n        \n        if (*(char*)ebp == 0) {\n            continue;\n        }\n        \n        printf(\"%2u) %s\\n\", ebx, (char*)ebp);\n    }\n    \n    printf(\"RTMAX %c\\n\", '@');\n    \n    return 0;\n}\n```"
    },
    {
        "func_name": "dot_skip_over_ws",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004E47F0 | 48 8B 3D 91 BB 26 00 | mov     rdi, cs:qword_750388\n0x004E47F7 | 48 8B 47 10 | mov     rax, [rdi+10h]\n0x004E47FB | 0F B6 08 | movzx   ecx, byte ptr [rax]\n0x004E47FE | 8D 51 F7 | lea     edx, [rcx-9]\n0x004E4801 | 80 FA 17 | cmp     dl, 17h\n0x004E4804 | 40 0F 94 C6 | setz    sil\n0x004E4808 | 80 FA 04 | cmp     dl, 4\n0x004E480B | 0F 96 C2 | setbe   dl\n0x004E480E | 40 08 D6 | or      sil, dl\n0x004E4811 | 74 47 | jz      short locret_4E485A\n0x004E4813 | 80 F9 0A | cmp     cl, 0Ah\n0x004E4816 | 74 42 | jz      short locret_4E485A\n0x004E4818 | 4C 8B 47 08 | mov     r8, [rdi+8]\n0x004E481C | 49 8D 50 FF | lea     rdx, [r8-1]\n0x004E4820 | 48 39 D0 | cmp     rax, rdx\n0x004E4823 | 73 35 | jnb     short locret_4E485A\n0x004E4825 | 48 83 C0 01 | add     rax, 1\n0x004E4829 | EB 13 | jmp     short loc_4E483E\n0x004E482B | 0F 1F 44 00 00 | align 10h\n0x004E4830 | 80 F9 0A | cmp     cl, 0Ah\n0x004E4833 | 74 25 | jz      short locret_4E485A\n0x004E4835 | 48 83 C0 01 | add     rax, 1\n0x004E4839 | 4C 39 C0 | cmp     rax, r8\n0x004E483C | 74 1C | jz      short locret_4E485A\n0x004E483E | 48 89 47 10 | mov     [rdi+10h], rax\n0x004E4842 | 0F B6 08 | movzx   ecx, byte ptr [rax]\n0x004E4845 | 8D 51 F7 | lea     edx, [rcx-9]\n0x004E4848 | 80 FA 17 | cmp     dl, 17h\n0x004E484B | 40 0F 94 C6 | setz    sil\n0x004E484F | 80 FA 04 | cmp     dl, 4\n0x004E4852 | 0F 96 C2 | setbe   dl\n0x004E4855 | 40 08 D6 | or      sil, dl\n0x004E4858 | 75 D6 | jnz     short loc_4E4830\n0x004E485A | C3 | retn",
        "output": "```c\nvoid function() {\n    // Get the value at address qword_750388 and store it in rdi\n    mov rdi, cs:qword_750388;\n    \n    // Get the value at address [rdi+10h] and store it in rax\n    mov rax, [rdi+10h];\n    \n    // Zero extend the byte at address rax and store it in ecx\n    movzx ecx, byte ptr [rax];\n    \n    // Calculate the address of rcx-9 and store it in edx\n    lea edx, [rcx-9];\n    \n    // Compare the value in dl with 17h\n    cmp dl, 17h;\n    \n    // Set sil to 1 if dl is equal to 0x17, otherwise set it to 0\n    setz sil;\n    \n    // Compare the value in dl with 4\n    cmp dl, 4;\n    \n    // Set dl to 1 if dl is less than or equal to 4, otherwise set it to 0\n    setbe dl;\n    \n    // Perform a bitwise OR operation between sil and dl and store the result in sil\n    or sil, dl;\n    \n    // Jump to locret_4E485A if sil is equal to 0\n    jz short locret_4E485A;\n    \n    // Compare the value in cl with 0x0A\n    cmp cl, 0x0A;\n    \n    // Jump to locret_4E485A if cl is equal to 0x0A\n    jz short locret_4E485A;\n    \n    // Get the value at address [rdi+8] and store it in r8\n    mov r8, [rdi+8];\n    \n    // Calculate the address of r8-1 and store it in rdx\n    lea rdx, [r8-1];\n    \n    // Compare the value in rax with rdx\n    cmp rax, rdx;\n    \n    // Jump to locret_4E485A if rax is not below or equal to rdx\n    jnb short locret_4E485A;\n    \n    // Increment rax by 1\n    add rax, 1;\n    \n    // Jump to loc_4E483E\n    jmp short loc_4E483E;\n    \nloc_4E483E:\n    // Compare the value in cl with 0x0A\n    cmp cl, 0x0A;\n    \n    // Jump to locret_4E485A if cl is equal to 0x0A\n    jz short locret_4E485A;\n    \n    // Increment rax by 1\n    add rax, 1;\n    \n    // Compare the value in rax with r8\n    cmp rax, r8;\n    \n    // Jump to locret_4E485A if rax is equal to r8\n    jz short locret_4E485A;\n    \n    // Store the value in rax at address [rdi+10h]\n    mov [rdi+10h], rax;\n    \n    // Zero extend the byte at address rax and store it in ecx\n    movzx ecx, byte ptr [rax];\n    \n    // Calculate the address of rcx-9 and store it in edx\n    lea edx, [rcx-9];\n    \n    // Compare the value in dl with 17h\n    cmp dl, 17h;\n    \n    // Set sil to 1 if dl is equal to 0x17, otherwise set it to 0\n    setz sil;\n    \n    // Compare the value in dl with 4\n    cmp dl, 4;\n    \n    // Set dl to 1 if dl is less than or equal to 4, otherwise set it to 0\n    setbe dl;\n    \n    // Perform a bitwise OR operation between sil and dl and store the result in sil\n    or sil, dl;\n    \n    // Jump to loc_4E4830 if sil is not equal to 0\n    jnz short loc_4E4830;\n    \nlocret_4E485A:\n    // Return from the function\n    retn;\n}\n```"
    },
    {
        "func_name": "iptunnel_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00434AB0 | 48 83 EC 08 | sub     rsp, 8\n0x00434AB4 | 48 8D 7E 08 | lea     rdi, [rsi+8]\n0x00434AB8 | E8 33 F3 00 00 | call    sub_443DF0\n0x00434ABD | 48 83 C4 08 | add     rsp, 8\n0x00434AC1 | 48 89 C7 | mov     rdi, rax\n0x00434AC4 | E9 67 56 01 00 | jmp     sub_44A130",
        "output": "```c\nvoid function(void* rsi) {\n    // sub     rsp, 8\n    // allocate space on the stack for local variables\n    \n    // lea     rdi, [rsi+8]\n    void* rdi = rsi + 8;\n    \n    // call    sub_443DF0\n    sub_443DF0();\n    \n    // add     rsp, 8\n    // deallocate space on the stack\n    \n    // mov     rdi, rax\n    rdi = rax;\n    \n    // jmp     sub_44A130\n    goto sub_44A130;\n}\n```"
    },
    {
        "func_name": "find_list_entry",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004B7650 | 48 85 FF | test    rdi, rdi\n0x004B7653 | 74 44 | jz      short loc_4B7699\n0x004B7655 | 55 | push    rbp\n0x004B7656 | 48 89 F5 | mov     rbp, rsi\n0x004B7659 | 53 | push    rbx\n0x004B765A | 48 89 FB | mov     rbx, rdi\n0x004B765D | 48 83 EC 08 | sub     rsp, 8\n0x004B7661 | EB 0D | jmp     short loc_4B7670\n0x004B7663 | 0F 1F 44 00 00 | align 8\n0x004B7668 | 48 8B 1B | mov     rbx, [rbx]\n0x004B766B | 48 85 DB | test    rbx, rbx\n0x004B766E | 74 20 | jz      short loc_4B7690\n0x004B7670 | 48 8B 7B 08 | mov     rdi, [rbx+8]; pattern\n0x004B7674 | 31 D2 | xor     edx, edx; flags\n0x004B7676 | 48 89 EE | mov     rsi, rbp; name\n0x004B7679 | E8 22 F3 F4 FF | call    _fnmatch\n0x004B767E | 85 C0 | test    eax, eax\n0x004B7680 | 75 E6 | jnz     short loc_4B7668\n0x004B7682 | 48 83 C4 08 | add     rsp, 8\n0x004B7686 | 48 89 D8 | mov     rax, rbx\n0x004B7689 | 5B | pop     rbx\n0x004B768A | 5D | pop     rbp\n0x004B768B | C3 | retn\n0x004B768C | 0F 1F 40 00 | align 10h\n0x004B7690 | 48 83 C4 08 | add     rsp, 8\n0x004B7694 | 31 C0 | xor     eax, eax\n0x004B7696 | 5B | pop     rbx\n0x004B7697 | 5D | pop     rbp\n0x004B7698 | C3 | retn\n0x004B7699 | 31 C0 | xor     eax, eax\n0x004B769B | C3 | retn",
        "output": "```c\nvoid function(int rdi, int rsi) {\n    if (rdi == 0) {\n        return;\n    }\n    int rbp = rsi;\n    int rbx = rdi;\n    rbx = *rbx;\n    if (rbx == 0) {\n        return;\n    }\n    int eax = _fnmatch(rbx+8, rbp, 0);\n    if (eax != 0) {\n        return;\n    }\n    return rbx;\n}\n```"
    },
    {
        "func_name": "logdirs_reopen",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00464780 | 41 57 | push    r15\n0x00464782 | 41 56 | push    r14\n0x00464784 | 41 55 | push    r13\n0x00464786 | 41 54 | push    r12\n0x00464788 | 55 | push    rbp\n0x00464789 | 53 | push    rbx\n0x0046478A | 48 83 EC 08 | sub     rsp, 8\n0x0046478E | 48 8B 2D F3 BB 2E 00 | mov     rbp, cs:qword_750388\n0x00464795 | 8B 55 4C | mov     edx, [rbp+4Ch]\n0x00464798 | C6 45 3C 00 | mov     byte ptr [rbp+3Ch], 0\n0x0046479C | 85 D2 | test    edx, edx\n0x0046479E | 0F 84 A4 00 00 00 | jz      loc_464848\n0x004647A4 | 45 31 ED | xor     r13d, r13d\n0x004647A7 | 45 31 E4 | xor     r12d, r12d\n0x004647AA | 45 31 F6 | xor     r14d, r14d\n0x004647AD | 41 BF 01 00 00 00 | mov     r15d, 1\n0x004647B3 | EB 48 | jmp     short loc_4647FD\n0x004647B5 | 0F 1F 00 | align 8\n0x004647B8 | E8 C3 22 FA FF | call    _close\n0x004647BD | 83 7B 34 FF | cmp     dword ptr [rbx+34h], 0FFFFFFFFh\n0x004647C1 | C7 43 30 FF FF FF FF | mov     dword ptr [rbx+30h], 0FFFFFFFFh\n0x004647C8 | 74 08 | jz      short loc_4647D2\n0x004647CA | 48 89 DF | mov     rdi, rbx\n0x004647CD | E8 5E EC FF FF | call    sub_463430\n0x004647D2 | 48 8B 5D 00 | mov     rbx, [rbp+0]\n0x004647D6 | 4C 01 EB | add     rbx, r13\n0x004647D9 | 48 8B 45 18 | mov     rax, [rbp+18h]\n0x004647DD | 48 89 DF | mov     rdi, rbx\n0x004647E0 | 4A 8B 34 E0 | mov     rsi, [rax+r12*8]\n0x004647E4 | E8 A7 F7 FF FF | call    sub_463F90\n0x004647E9 | 85 C0 | test    eax, eax\n0x004647EB | 45 0F 45 F7 | cmovnz  r14d, r15d\n0x004647EF | 49 83 C4 01 | add     r12, 1\n0x004647F3 | 49 83 C5 68 | add     r13, 68h ; 'h'\n0x004647F7 | 44 39 65 4C | cmp     [rbp+4Ch], r12d\n0x004647FB | 76 33 | jbe     short loc_464830\n0x004647FD | 48 8B 5D 00 | mov     rbx, [rbp+0]\n0x00464801 | 4C 01 EB | add     rbx, r13\n0x00464804 | 8B 7B 30 | mov     edi, [rbx+30h]; fd\n0x00464807 | 83 FF FF | cmp     edi, 0FFFFFFFFh\n0x0046480A | 74 CD | jz      short loc_4647D9\n0x0046480C | 8B 45 08 | mov     eax, [rbp+8]\n0x0046480F | 85 C0 | test    eax, eax\n0x00464811 | 74 A5 | jz      short loc_4647B8\n0x00464813 | 48 8B 73 10 | mov     rsi, [rbx+10h]\n0x00464817 | BF DA 97 52 00 | mov     edi, offset aInfoCloseS; \"info: close: %s\"\n0x0046481C | 31 C0 | xor     eax, eax\n0x0046481E | E8 3D 45 FA FF | call    sub_408D60\n0x00464823 | 8B 7B 30 | mov     edi, [rbx+30h]\n0x00464826 | EB 90 | jmp     short loc_4647B8\n0x00464828 | 0F 1F 84 00 00 00 00 00 | align 10h\n0x00464830 | 45 85 F6 | test    r14d, r14d\n0x00464833 | 74 13 | jz      short loc_464848\n0x00464835 | 48 83 C4 08 | add     rsp, 8\n0x00464839 | 5B | pop     rbx\n0x0046483A | 5D | pop     rbp\n0x0046483B | 41 5C | pop     r12\n0x0046483D | 41 5D | pop     r13\n0x0046483F | 41 5E | pop     r14\n0x00464841 | 41 5F | pop     r15\n0x00464843 | C3 | retn\n0x00464844 | 0F 1F 40 00 | align 8\n0x00464848 | BE A5 98 52 00 | mov     esi, offset aNoFunctionalLo; \"no functional log directories\"\n0x0046484D | BF C3 98 52 00 | mov     edi, offset aFatalS; \"fatal: %s\"\n0x00464852 | 31 C0 | xor     eax, eax\n0x00464854 | E8 67 44 FA FF | call    sub_408CC0",
        "output": "```c\nvoid function() {\n    push    r15\n    push    r14\n    push    r13\n    push    r12\n    push    rbp\n    push    rbx\n    sub     rsp, 8\n    mov     rbp, cs:qword_750388\n    mov     edx, [rbp+4Ch]\n    mov     byte ptr [rbp+3Ch], 0\n    test    edx, edx\n    jz      loc_464848\n    xor     r13d, r13d\n    xor     r12d, r12d\n    xor     r14d, r14d\n    mov     r15d, 1\n    jmp     short loc_4647FD\nloc_4647B8:\n    call    _close\n    cmp     dword ptr [rbx+34h], 0FFFFFFFFh\n    mov     dword ptr [rbx+30h], 0FFFFFFFFh\n    jz      short loc_4647D2\n    mov     rdi, rbx\n    call    sub_463430\nloc_4647D2:\n    mov     rbx, [rbp+0]\n    add     rbx, r13\n    mov     rax, [rbp+18h]\n    mov     rdi, rbx\n    mov     rsi, [rax+r12*8]\n    call    sub_463F90\n    test    eax, eax\n    cmovnz  r14d, r15d\n    add     r12, 1\n    add     r13, 68h\n    cmp     [rbp+4Ch], r12d\n    jbe     short loc_464830\nloc_4647D9:\n    mov     rbx, [rbp+0]\n    add     rbx, r13\n    mov     edi, [rbx+30h]\n    cmp     edi, 0FFFFFFFFh\n    jz      short loc_4647D9\n    mov     eax, [rbp+8]\n    test    eax, eax\n    jz      short loc_4647B8\n    mov     rsi, [rbx+10h]\n    mov     edi, offset aInfoCloseS\n    xor     eax, eax\n    call    sub_408D60\n    mov     edi, [rbx+30h]\n    jmp     short loc_4647B8\nloc_464830:\n    test    r14d, r14d\n    jz      short loc_464848\n    add     rsp, 8\n    pop     rbx\n    pop     rbp\n    pop     r12\n    pop     r13\n    pop     r14\n    pop     r15\n    retn\nloc_464848:\n    mov     esi, offset aNoFunctionalLo\n    mov     edi, offset aFatalS\n    xor     eax, eax\n    call    sub_408CC0\n}\n```"
    },
    {
        "func_name": "bb_info_msg",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F7740 | 53 | push    rbx\n0x004F7741 | 48 81 EC D0 00 00 00 | sub     rsp, 0D0h\n0x004F7748 | 48 89 74 24 28 | mov     [rsp+0D8h+var_B0], rsi\n0x004F774D | 48 89 54 24 30 | mov     [rsp+0D8h+var_A8], rdx\n0x004F7752 | 48 89 4C 24 38 | mov     [rsp+0D8h+var_A0], rcx\n0x004F7757 | 4C 89 44 24 40 | mov     [rsp+0D8h+var_98], r8\n0x004F775C | 4C 89 4C 24 48 | mov     [rsp+0D8h+var_90], r9\n0x004F7761 | 84 C0 | test    al, al\n0x004F7763 | 74 37 | jz      short loc_4F779C\n0x004F7765 | 0F 29 44 24 50 | movaps  [rsp+0D8h+var_88], xmm0\n0x004F776A | 0F 29 4C 24 60 | movaps  [rsp+0D8h+var_78], xmm1\n0x004F776F | 0F 29 54 24 70 | movaps  [rsp+0D8h+var_68], xmm2\n0x004F7774 | 0F 29 9C 24 80 00 00 00 | movaps  [rsp+0D8h+var_58], xmm3\n0x004F777C | 0F 29 A4 24 90 00 00 00 | movaps  [rsp+0D8h+var_48], xmm4\n0x004F7784 | 0F 29 AC 24 A0 00 00 00 | movaps  [rsp+0D8h+var_38], xmm5\n0x004F778C | 0F 29 B4 24 B0 00 00 00 | movaps  [rsp+0D8h+var_28], xmm6\n0x004F7794 | 0F 29 BC 24 C0 00 00 00 | movaps  [rsp+0D8h+var_18], xmm7\n0x004F779C | 80 3D 1D 66 25 00 00 | cmp     cs:byte_74DDC0, 0\n0x004F77A3 | 75 0B | jnz     short loc_4F77B0\n0x004F77A5 | 48 81 C4 D0 00 00 00 | add     rsp, 0D0h\n0x004F77AC | 5B | pop     rbx\n0x004F77AD | C3 | retn\n0x004F77AE | 66 90 | align 10h\n0x004F77B0 | 48 8D 84 24 E0 00 00 00 | lea     rax, [rsp+0D8h+arg_0]\n0x004F77B8 | 48 89 FE | mov     rsi, rdi; f\n0x004F77BB | 48 8D 54 24 08 | lea     rdx, [rsp+0D8h+arg]; arg\n0x004F77C0 | 48 89 E7 | mov     rdi, rsp; ptr\n0x004F77C3 | 48 89 44 24 10 | mov     [rsp+0D8h+var_C8], rax\n0x004F77C8 | 48 8D 44 24 20 | lea     rax, [rsp+0D8h+var_B8]\n0x004F77CD | C7 44 24 08 08 00 00 00 | mov     [rsp+0D8h+arg], 8\n0x004F77D5 | C7 44 24 0C 30 00 00 00 | mov     [rsp+0D8h+var_CC], 30h ; '0'\n0x004F77DD | 48 89 44 24 18 | mov     [rsp+0D8h+var_C0], rax\n0x004F77E2 | E8 39 EE F0 FF | call    _vasprintf\n0x004F77E7 | 89 C3 | mov     ebx, eax\n0x004F77E9 | 85 C0 | test    eax, eax\n0x004F77EB | 78 B8 | js      short loc_4F77A5\n0x004F77ED | 0F B6 05 CC 65 25 00 | movzx   eax, cs:byte_74DDC0\n0x004F77F4 | A8 02 | test    al, 2\n0x004F77F6 | 75 18 | jnz     short loc_4F7810\n0x004F77F8 | A8 01 | test    al, 1\n0x004F77FA | 75 34 | jnz     short loc_4F7830\n0x004F77FC | 48 8B 3C 24 | mov     rdi, [rsp+0D8h+ptr]; ptr\n0x004F7800 | E8 0B EB F0 FF | call    _free\n0x004F7805 | 48 81 C4 D0 00 00 00 | add     rsp, 0D0h\n0x004F780C | 5B | pop     rbx\n0x004F780D | C3 | retn\n0x004F780E | 66 90 | align 10h\n0x004F7810 | 48 8B 14 24 | mov     rdx, [rsp+0D8h+ptr]\n0x004F7814 | 31 C0 | xor     eax, eax\n0x004F7816 | BE 77 E1 52 00 | mov     esi, (offset aSS_28+3); fmt\n0x004F781B | BF 06 00 00 00 | mov     edi, 6; pri\n0x004F7820 | E8 8B F8 F0 FF | call    _syslog\n0x004F7825 | 0F B6 05 94 65 25 00 | movzx   eax, cs:byte_74DDC0\n0x004F782C | A8 01 | test    al, 1\n0x004F782E | 74 CC | jz      short loc_4F77FC\n0x004F7830 | E8 7B 2C F1 FF | call    sub_40A4B0\n0x004F7835 | 48 8B 14 24 | mov     rdx, [rsp+0D8h+ptr]\n0x004F7839 | 48 63 C3 | movsxd  rax, ebx\n0x004F783C | BF 01 00 00 00 | mov     edi, 1; fd\n0x004F7841 | C6 04 02 0A | mov     byte ptr [rdx+rax], 0Ah\n0x004F7845 | 8D 53 01 | lea     edx, [rbx+1]\n0x004F7848 | 48 8B 34 24 | mov     rsi, [rsp+0D8h+ptr]; buf\n0x004F784C | 48 63 D2 | movsxd  rdx, edx; n\n0x004F784F | E8 1C 39 F1 FF | call    sub_40B170\n0x004F7854 | EB A6 | jmp     short loc_4F77FC",
        "output": "```c\nvoid function(void* arg_0, int arg) {\n    void* ptr = &arg_0;\n    void* var_B8 = &ptr;\n    int var_C0 = 0;\n    int var_C8 = 8;\n    int var_CC = 0x30;\n    int var_B0 = arg_0;\n    int var_A8 = arg;\n    int var_A0 = 0;\n    int var_98 = 0;\n    int var_90 = 0;\n    int var_88 = 0;\n    int var_78 = 0;\n    int var_68 = 0;\n    int var_58 = 0;\n    int var_48 = 0;\n    int var_38 = 0;\n    int var_28 = 0;\n    int var_18 = 0;\n    \n    if (var_B0 != 0) {\n        var_88 = xmm0;\n        var_78 = xmm1;\n        var_68 = xmm2;\n        var_58 = xmm3;\n        var_48 = xmm4;\n        var_38 = xmm5;\n        var_28 = xmm6;\n        var_18 = xmm7;\n    }\n    \n    if (byte_74DDC0 == 0) {\n        if (var_B0 != 0) {\n            free(ptr);\n        }\n        return;\n    }\n    \n    int ebx = _vasprintf(&var_B8, arg_0, &arg, &ptr, var_C8, var_CC, &var_C0);\n    \n    if (ebx < 0) {\n        if (var_B0 != 0) {\n            free(ptr);\n        }\n        return;\n    }\n    \n    if (byte_74DDC0 & 2) {\n        syslog(6, \"SS\", var_B8);\n    }\n    \n    if (byte_74DDC0 & 1) {\n        sub_40A4B0(var_B8);\n    }\n    \n    int edx = ebx + 1;\n    *(ptr + edx) = '\\n';\n    sub_40B170(1, ptr, edx);\n    \n    if (var_B0 != 0) {\n        free(ptr);\n    }\n}\n```"
    },
    {
        "func_name": "setsockopt_bindtodevice",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00504EA0 | 55 | push    rbp\n0x00504EA1 | 48 89 F5 | mov     rbp, rsi\n0x00504EA4 | 53 | push    rbx\n0x00504EA5 | 89 FB | mov     ebx, edi\n0x00504EA7 | 48 83 EC 38 | sub     rsp, 38h\n0x00504EAB | 48 89 E7 | mov     rdi, rsp\n0x00504EAE | E8 0D 41 F0 FF | call    sub_408FC0\n0x00504EB3 | 89 DF | mov     edi, ebx; fd\n0x00504EB5 | 41 B8 28 00 00 00 | mov     r8d, 28h ; '('; optlen\n0x00504EBB | 48 89 E1 | mov     rcx, rsp; optval\n0x00504EBE | BA 19 00 00 00 | mov     edx, 19h; optname\n0x00504EC3 | BE 01 00 00 00 | mov     esi, 1; level\n0x00504EC8 | E8 83 16 F0 FF | call    _setsockopt\n0x00504ECD | 89 C3 | mov     ebx, eax\n0x00504ECF | 85 C0 | test    eax, eax\n0x00504ED1 | 75 0D | jnz     short loc_504EE0\n0x00504ED3 | 48 83 C4 38 | add     rsp, 38h\n0x00504ED7 | 89 D8 | mov     eax, ebx\n0x00504ED9 | 5B | pop     rbx\n0x00504EDA | 5D | pop     rbp\n0x00504EDB | C3 | retn\n0x00504EDC | 0F 1F 40 00 | align 20h\n0x00504EE0 | 48 89 EE | mov     rsi, rbp\n0x00504EE3 | 31 C0 | xor     eax, eax\n0x00504EE5 | BF 24 F0 52 00 | mov     edi, offset aCanTBindToInte; \"can't bind to interface %s\"\n0x00504EEA | E8 91 39 F0 FF | call    sub_408880\n0x00504EEF | 48 83 C4 38 | add     rsp, 38h\n0x00504EF3 | 89 D8 | mov     eax, ebx\n0x00504EF5 | 5B | pop     rbx\n0x00504EF6 | 5D | pop     rbp\n0x00504EF7 | C3 | retn",
        "output": "```c\nvoid function(int edi, int esi) {\n    push    rbp\n    mov     rbp, rsi\n    push    rbx\n    mov     ebx, edi\n    sub     rsp, 38h\n    mov     rdi, rsp\n    call    sub_408FC0\n    mov     edi, ebx; fd\n    mov     r8d, 28h ; '('; optlen\n    mov     rcx, rsp; optval\n    mov     edx, 19h; optname\n    mov     esi, 1; level\n    call    _setsockopt\n    mov     ebx, eax\n    test    eax, eax\n    jnz     short loc_504EE0\n    add     rsp, 38h\n    mov     eax, ebx\n    pop     rbx\n    pop     rbp\n    retn\nloc_504EE0:\n    mov     rsi, rbp\n    xor     eax, eax\n    mov     edi, offset aCanTBindToInte; \"can't bind to interface %s\"\n    call    sub_408880\n    add     rsp, 38h\n    mov     eax, ebx\n    pop     rbx\n    pop     rbp\n    retn\n}\n```"
    },
    {
        "func_name": "rtnl_send",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0044A4D0 | 48 83 EC 18 | sub     rsp, 18h\n0x0044A4D4 | B9 10 00 00 00 | mov     ecx, 10h\n0x0044A4D9 | 8B 3F | mov     edi, [rdi]\n0x0044A4DB | 31 C0 | xor     eax, eax\n0x0044A4DD | 66 89 4C 24 04 | mov     [rsp+18h+var_14], cx\n0x0044A4E2 | 48 63 D2 | movsxd  rdx, edx\n0x0044A4E5 | 48 8D 4C 24 04 | lea     rcx, [rsp+18h+var_14]\n0x0044A4EA | 41 B8 0C 00 00 00 | mov     r8d, 0Ch\n0x0044A4F0 | 48 C7 44 24 06 00 00 00 00 | mov     [rsp+18h+var_12], 0\n0x0044A4F9 | 66 89 44 24 0E | mov     [rsp+18h+var_A], ax\n0x0044A4FE | E8 6D 04 FC FF | call    sub_40A970\n0x0044A503 | 48 83 C4 18 | add     rsp, 18h\n0x0044A507 | C3 | retn",
        "output": "```c\nvoid function() {\n    // sub     rsp, 18h\n    __asm__(\"sub rsp, 0x18\");\n\n    // mov     ecx, 10h\n    int ecx = 0x10;\n\n    // mov     edi, [rdi]\n    int edi = *(int*)rdi;\n\n    // xor     eax, eax\n    int eax = 0;\n\n    // mov     [rsp+18h+var_14], cx\n    *(short*)(rsp + 0x18 + var_14) = (short)ecx;\n\n    // movsxd  rdx, edx\n    long rdx = (long)edx;\n\n    // lea     rcx, [rsp+18h+var_14]\n    long rcx = rsp + 0x18 + var_14;\n\n    // mov     r8d, 0Ch\n    int r8d = 0x0C;\n\n    // mov     [rsp+18h+var_12], 0\n    *(int*)(rsp + 0x18 + var_12) = 0;\n\n    // mov     [rsp+18h+var_A], ax\n    *(short*)(rsp + 0x18 + var_A) = (short)ax;\n\n    // call    sub_40A970\n    sub_40A970();\n\n    // add     rsp, 18h\n    __asm__(\"add rsp, 0x18\");\n\n    // retn\n    return;\n}\n```"
    },
    {
        "func_name": "sub",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00415720 | 48 83 EC 08 | sub     rsp, 8\n0x00415724 | 8B 05 4E 8C 33 00 | mov     eax, cs:dest.c_iflag\n0x0041572A | 85 C0 | test    eax, eax\n0x0041572C | 74 4B | jz      short loc_415779\n0x0041572E | 8D 48 FF | lea     ecx, [rax-1]\n0x00415731 | 89 0D 41 8C 33 00 | mov     cs:dest.c_iflag, ecx\n0x00415737 | 48 89 CA | mov     rdx, rcx\n0x0041573A | F2 0F 10 0C CD 80 E3 74 00 | movsd   xmm1, qword ptr ds:dest.c_cflag[rcx*8]\n0x00415743 | 85 C9 | test    ecx, ecx\n0x00415745 | 74 32 | jz      short loc_415779\n0x00415747 | 8D 48 FE | lea     ecx, [rax-2]\n0x0041574A | 89 0D 28 8C 33 00 | mov     cs:dest.c_iflag, ecx\n0x00415750 | F2 0F 10 04 CD 80 E3 74 00 | movsd   xmm0, qword ptr ds:dest.c_cflag[rcx*8]\n0x00415759 | F2 0F 5C C1 | subsd   xmm0, xmm1\n0x0041575D | 81 F9 FE 03 00 00 | cmp     ecx, 3FEh\n0x00415763 | 77 20 | ja      short loc_415785\n0x00415765 | 89 15 0D 8C 33 00 | mov     cs:dest.c_iflag, edx\n0x0041576B | F2 0F 11 04 CD 80 E3 74 00 | movsd   qword ptr ds:dest.c_cflag[rcx*8], xmm0\n0x00415774 | 48 83 C4 08 | add     rsp, 8\n0x00415778 | C3 | retn\n0x00415779 | BF CD 39 52 00 | mov     edi, offset aStackUnderflow; \"stack underflow\"\n0x0041577E | 31 C0 | xor     eax, eax\n0x00415780 | E8 3B 35 FF FF | call    sub_408CC0\n0x00415785 | BF DD 39 52 00 | mov     edi, offset aStackOverflow; \"stack overflow\"\n0x0041578A | 31 C0 | xor     eax, eax\n0x0041578C | E8 2F 35 FF FF | call    sub_408CC0",
        "output": "```c\nvoid function() {\n    // sub     rsp, 8\n    // mov     eax, cs:dest.c_iflag\n    // test    eax, eax\n    // jz      short loc_415779\n    // lea     ecx, [rax-1]\n    // mov     cs:dest.c_iflag, ecx\n    // mov     rdx, rcx\n    // movsd   xmm1, qword ptr ds:dest.c_cflag[rcx*8]\n    // test    ecx, ecx\n    // jz      short loc_415779\n    // lea     ecx, [rax-2]\n    // mov     cs:dest.c_iflag, ecx\n    // movsd   xmm0, qword ptr ds:dest.c_cflag[rcx*8]\n    // subsd   xmm0, xmm1\n    // cmp     ecx, 3FEh\n    // ja      short loc_415785\n    // mov     cs:dest.c_iflag, edx\n    // movsd   qword ptr ds:dest.c_cflag[rcx*8], xmm0\n    // add     rsp, 8\n    // retn\n\n    // mov     edi, offset aStackUnderflow; \"stack underflow\"\n    // xor     eax, eax\n    // call    sub_408CC0\n\n    // mov     edi, offset aStackOverflow; \"stack overflow\"\n    // xor     eax, eax\n    // call    sub_408CC0\n}\n```"
    },
    {
        "func_name": "filter_accept_reject_list",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004B75F0 | 55 | push    rbp\n0x004B75F1 | 53 | push    rbx\n0x004B75F2 | 48 89 FB | mov     rbx, rdi\n0x004B75F5 | 48 83 EC 08 | sub     rsp, 8\n0x004B75F9 | 48 8B 47 28 | mov     rax, [rdi+28h]\n0x004B75FD | 48 8B 7F 18 | mov     rdi, [rdi+18h]\n0x004B7601 | 48 8B 28 | mov     rbp, [rax]\n0x004B7604 | 48 89 EE | mov     rsi, rbp\n0x004B7607 | E8 94 00 00 00 | call    sub_4B76A0\n0x004B760C | BA 01 00 00 00 | mov     edx, 1\n0x004B7611 | 48 85 C0 | test    rax, rax\n0x004B7614 | 74 0A | jz      short loc_4B7620\n0x004B7616 | 48 83 C4 08 | add     rsp, 8\n0x004B761A | 89 D0 | mov     eax, edx\n0x004B761C | 5B | pop     rbx\n0x004B761D | 5D | pop     rbp\n0x004B761E | C3 | retn\n0x004B761F | 90 | align 20h\n0x004B7620 | 48 8B 7B 10 | mov     rdi, [rbx+10h]\n0x004B7624 | 31 D2 | xor     edx, edx\n0x004B7626 | 48 85 FF | test    rdi, rdi\n0x004B7629 | 74 EB | jz      short loc_4B7616\n0x004B762B | 48 89 EE | mov     rsi, rbp\n0x004B762E | E8 6D 00 00 00 | call    sub_4B76A0\n0x004B7633 | 48 85 C0 | test    rax, rax\n0x004B7636 | 0F 94 C2 | setz    dl\n0x004B7639 | 48 83 C4 08 | add     rsp, 8\n0x004B763D | 89 D0 | mov     eax, edx\n0x004B763F | 5B | pop     rbx\n0x004B7640 | 5D | pop     rbp\n0x004B7641 | C3 | retn",
        "output": "```c\nvoid function(void* rbx) {\n    // Save rbp and rbx\n    push rbp\n    push rbx\n    \n    // Subtract 8 from rsp\n    sub rsp, 8\n    \n    // Move [rdi+28h] into rax\n    mov rax, [rdi+28h]\n    \n    // Move [rdi+18h] into rdi\n    mov rdi, [rdi+18h]\n    \n    // Move [rax] into rbp\n    mov rbp, [rax]\n    \n    // Move rbp into rsi\n    mov rsi, rbp\n    \n    // Call sub_4B76A0\n    call sub_4B76A0\n    \n    // Move 1 into edx\n    mov edx, 1\n    \n    // Test rax with rax\n    test rax, rax\n    \n    // Jump to loc_4B7620 if rax is zero\n    jz short loc_4B7620\n    \n    // Add 8 to rsp\n    add rsp, 8\n    \n    // Move edx into eax\n    mov eax, edx\n    \n    // Restore rbx and rbp\n    pop rbx\n    pop rbp\n    \n    // Return\n    retn\n    \nloc_4B7620:\n    // Move [rbx+10h] into rdi\n    mov rdi, [rbx+10h]\n    \n    // XOR edx with edx\n    xor edx, edx\n    \n    // Test rdi with rdi\n    test rdi, rdi\n    \n    // Jump to loc_4B7616 if rdi is zero\n    jz short loc_4B7616\n    \n    // Move rbp into rsi\n    mov rsi, rbp\n    \n    // Call sub_4B76A0\n    call sub_4B76A0\n    \n    // Test rax with rax\n    test rax, rax\n    \n    // Set dl to 1 if rax is zero\n    setz dl\n    \n    // Add 8 to rsp\n    add rsp, 8\n    \n    // Move edx into eax\n    mov eax, edx\n    \n    // Restore rbx and rbp\n    pop rbx\n    pop rbp\n    \n    // Return\n    retn\n}\n```"
    },
    {
        "func_name": "bzip2_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004A3900 | 55 | push    rbp\n0x004A3901 | 31 C0 | xor     eax, eax\n0x004A3903 | 89 FD | mov     ebp, edi\n0x004A3905 | 53 | push    rbx\n0x004A3906 | 48 89 F3 | mov     rbx, rsi\n0x004A3909 | BE 64 C4 52 00 | mov     esi, offset aCfvdt123456789; \"cfvdt123456789qzs\"\n0x004A390E | 48 89 DF | mov     rdi, rbx; argv\n0x004A3911 | 48 83 EC 08 | sub     rsp, 8\n0x004A3915 | 48 C7 05 A0 CA 2A 00 61 C4 52 00 | mov     cs:qword_7503C0, offset aS2; \"s2\"\n0x004A3920 | E8 5B 05 05 00 | call    sub_4F3E80\n0x004A3925 | A8 18 | test    al, 18h\n0x004A3927 | 75 67 | jnz     short loc_4A3990\n0x004A3929 | C1 E8 05 | shr     eax, 5\n0x004A392C | C6 05 5D A9 2A 00 01 | mov     cs:byte_74E290, 1\n0x004A3933 | 0F B6 D0 | movzx   edx, al\n0x004A3936 | 80 CE 01 | or      dh, 1\n0x004A3939 | A8 01 | test    al, 1\n0x004A393B | 75 1D | jnz     short loc_4A395A\n0x004A393D | B8 02 00 00 00 | mov     eax, 2\n0x004A3942 | EB 06 | jmp     short loc_4A394A\n0x004A3944 | 0F 1F 40 00 | align 8\n0x004A3948 | 89 C8 | mov     eax, ecx\n0x004A394A | D1 EA | shr     edx, 1\n0x004A394C | 8D 48 01 | lea     ecx, [rax+1]\n0x004A394F | F6 C2 01 | test    dl, 1\n0x004A3952 | 74 F4 | jz      short loc_4A3948\n0x004A3954 | 88 05 36 A9 2A 00 | mov     cs:byte_74E290, al\n0x004A395A | B9 5A C4 52 00 | mov     ecx, offset aBz2; \"bz2\"\n0x004A395F | BA 90 C4 49 00 | mov     edx, offset sub_49C490\n0x004A3964 | BE C0 35 4A 00 | mov     esi, offset sub_4A35C0\n0x004A3969 | 83 25 60 CA 2A 00 07 | and     cs:dword_7503D0, 7\n0x004A3970 | 48 63 05 A1 A4 2A 00 | movsxd  rax, cs:optind\n0x004A3977 | 48 83 C4 08 | add     rsp, 8\n0x004A397B | 48 8D 3C C3 | lea     rdi, [rbx+rax*8]\n0x004A397F | 5B | pop     rbx\n0x004A3980 | 5D | pop     rbp\n0x004A3981 | E9 2A 8B FF FF | jmp     sub_49C4B0\n0x004A3986 | 66 2E 0F 1F 84 00 00 00 00 00 | align 10h\n0x004A3990 | 48 83 C4 08 | add     rsp, 8\n0x004A3994 | 48 89 DE | mov     rsi, rbx\n0x004A3997 | 89 EF | mov     edi, ebp\n0x004A3999 | 5B | pop     rbx\n0x004A399A | 5D | pop     rbp\n0x004A399B | E9 E0 91 FF FF | jmp     sub_49CB80",
        "output": "```c\nvoid function(int edi, int esi) {\n    int eax = 0;\n    int ebp = edi;\n    int ebx = esi;\n    char* str = \"cfvdt123456789qzs\";\n    char* argv = ebx;\n    char* s2 = \"s2\";\n    sub_4F3E80();\n    if ((eax & 0x18) != 0) {\n        eax >>= 5;\n        byte_74E290 = 1;\n    }\n    int edx = (unsigned char)eax;\n    edx |= 1;\n    if ((eax & 1) != 0) {\n        eax = 2;\n    } else {\n        eax = ecx;\n        edx >>= 1;\n        ecx = eax + 1;\n        if ((edx & 1) == 0) {\n            byte_74E290 = al;\n        }\n    }\n    ecx = \"bz2\";\n    edx = sub_49C490;\n    esi = sub_4A35C0;\n    dword_7503D0 &= 7;\n    rax = optind;\n    rdi = rbx + rax * 8;\n    rbx = esi;\n    ebp = edi;\n    sub_49C4B0();\n}\n```"
    },
    {
        "func_name": "read_staticlease",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00450980 | 53 | push    rbx\n0x00450981 | 48 89 F3 | mov     rbx, rsi\n0x00450984 | BE 9E 31 52 00 | mov     esi, (offset asc_52319D+1); delim\n0x00450989 | 48 83 EC 20 | sub     rsp, 20h\n0x0045098D | 48 8D 54 24 18 | lea     rdx, [rsp+28h+save_ptr]; save_ptr\n0x00450992 | 48 89 7C 24 18 | mov     [rsp+28h+save_ptr], rdi\n0x00450997 | E8 D4 61 FB FF | call    _strtok_r\n0x0045099C | 48 85 C0 | test    rax, rax\n0x0045099F | 74 39 | jz      short loc_4509DA\n0x004509A1 | 48 8D 74 24 12 | lea     rsi, [rsp+28h+addr]; addr\n0x004509A6 | 48 89 C7 | mov     rdi, rax; asc\n0x004509A9 | E8 F2 66 FB FF | call    _ether_aton_r\n0x004509AE | 48 85 C0 | test    rax, rax\n0x004509B1 | 74 27 | jz      short loc_4509DA\n0x004509B3 | 31 FF | xor     edi, edi; s\n0x004509B5 | 48 8D 54 24 18 | lea     rdx, [rsp+28h+save_ptr]; save_ptr\n0x004509BA | BE 9E 31 52 00 | mov     esi, (offset asc_52319D+1); delim\n0x004509BF | E8 AC 61 FB FF | call    _strtok_r\n0x004509C4 | 48 85 C0 | test    rax, rax\n0x004509C7 | 74 11 | jz      short loc_4509DA\n0x004509C9 | 48 8D 74 24 0C | lea     rsi, [rsp+28h+var_1C]\n0x004509CE | 48 89 C7 | mov     rdi, rax\n0x004509D1 | E8 9A 1D 00 00 | call    sub_452770\n0x004509D6 | 85 C0 | test    eax, eax\n0x004509D8 | 75 0E | jnz     short loc_4509E8\n0x004509DA | 48 83 C4 20 | add     rsp, 20h\n0x004509DE | 31 C0 | xor     eax, eax\n0x004509E0 | 5B | pop     rbx\n0x004509E1 | C3 | retn\n0x004509E2 | 66 0F 1F 44 00 00 | align 8\n0x004509E8 | 8B 54 24 0C | mov     edx, [rsp+28h+var_1C]\n0x004509EC | 48 8D 74 24 12 | lea     rsi, [rsp+28h+addr]\n0x004509F1 | 48 89 DF | mov     rdi, rbx\n0x004509F4 | E8 D7 12 00 00 | call    sub_451CD0\n0x004509F9 | 48 89 DF | mov     rdi, rbx\n0x004509FC | E8 8F 13 00 00 | call    sub_451D90\n0x00450A01 | 48 83 C4 20 | add     rsp, 20h\n0x00450A05 | B8 01 00 00 00 | mov     eax, 1\n0x00450A0A | 5B | pop     rbx\n0x00450A0B | C3 | retn",
        "output": "```c\nvoid function(char* str) {\n    char* save_ptr;\n    char* token = strtok_r(str, \",\", &save_ptr);\n    if (token != NULL) {\n        struct ether_addr* addr = ether_aton_r(token);\n        if (addr != NULL) {\n            int s = 0;\n            while (token != NULL) {\n                token = strtok_r(NULL, \",\", &save_ptr);\n                if (token != NULL) {\n                    int var_1C;\n                    int result = sub_452770(token, &var_1C);\n                    if (result == 0) {\n                        int var_20 = sub_451CD0(addr, &var_1C);\n                        sub_451D90(addr);\n                    }\n                }\n            }\n        }\n    }\n}\n```"
    },
    {
        "func_name": "getch_nowait",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0041CEB0 | 41 57 | push    r15\n0x0041CEB2 | B9 01 00 00 00 | mov     ecx, 1\n0x0041CEB7 | BE 01 00 00 00 | mov     esi, 1\n0x0041CEBC | 41 BF 02 00 00 00 | mov     r15d, 2\n0x0041CEC2 | 41 56 | push    r14\n0x0041CEC4 | 41 55 | push    r13\n0x0041CEC6 | 41 BD FF FF FF FF | mov     r13d, 0FFFFFFFFh\n0x0041CECC | 41 54 | push    r12\n0x0041CECE | 55 | push    rbp\n0x0041CECF | 53 | push    rbx\n0x0041CED0 | 48 83 EC 18 | sub     rsp, 18h\n0x0041CED4 | 48 8B 1D AD 34 33 00 | mov     rbx, cs:qword_750388\n0x0041CEDB | C7 04 24 00 00 00 00 | mov     [rsp+48h+fds.fd], 0\n0x0041CEE2 | 8B 7B 04 | mov     edi, [rbx+4]; fd\n0x0041CEE5 | 66 89 4C 24 04 | mov     [rsp+48h+fds.events], cx\n0x0041CEEA | 4C 8D B3 90 01 00 00 | lea     r14, [rbx+190h]\n0x0041CEF1 | 66 89 74 24 0C | mov     [rsp+48h+var_3C], si\n0x0041CEF6 | 89 7C 24 08 | mov     [rsp+48h+var_40], edi\n0x0041CEFA | 31 F6 | xor     esi, esi; optional_actions\n0x0041CEFC | 4C 89 F2 | mov     rdx, r14; termios_p\n0x0041CEFF | E8 0C A5 FE FF | call    _tcsetattr\n0x0041CF04 | F6 05 C5 34 33 00 40 | test    byte ptr cs:dword_7503D0, 40h\n0x0041CF0B | 0F 85 97 00 00 00 | jnz     loc_41CFA8\n0x0041CF11 | 8B 43 20 | mov     eax, [rbx+20h]\n0x0041CF14 | 03 03 | add     eax, [rbx]\n0x0041CF16 | 39 43 18 | cmp     [rbx+18h], eax\n0x0041CF19 | 0F 96 C0 | setbe   al\n0x0041CF1C | BD 01 00 00 00 | mov     ebp, 1\n0x0041CF21 | 84 C0 | test    al, al\n0x0041CF23 | 75 73 | jnz     short loc_41CF98\n0x0041CF25 | 8B 53 08 | mov     edx, [rbx+8]\n0x0041CF28 | 85 D2 | test    edx, edx\n0x0041CF2A | 78 15 | js      short loc_41CF41\n0x0041CF2C | 8B 43 20 | mov     eax, [rbx+20h]\n0x0041CF2F | 83 C2 01 | add     edx, 1\n0x0041CF32 | BF 6D 37 52 00 | mov     edi, offset aUUh; \"\\x1B[%u;%uH\"\n0x0041CF37 | 8D 70 02 | lea     esi, [rax+2]\n0x0041CF3A | 31 C0 | xor     eax, eax\n0x0041CF3C | E8 FF 98 FE FF | call    _printf\n0x0041CF41 | E8 6A D5 FE FF | call    sub_40A4B0\n0x0041CF46 | 80 BB CC 01 00 00 00 | cmp     byte ptr [rbx+1CCh], 0\n0x0041CF4D | 0F 84 7D 00 00 00 | jz      loc_41CFD0\n0x0041CF53 | 8B 7B 04 | mov     edi, [rbx+4]; fd\n0x0041CF56 | 48 8D B3 CC 01 00 00 | lea     rsi, [rbx+1CCh]\n0x0041CF5D | BA FE FF FF FF | mov     edx, 0FFFFFFFEh\n0x0041CF62 | E8 09 31 0E 00 | call    sub_500070\n0x0041CF67 | 48 89 C5 | mov     rbp, rax\n0x0041CF6A | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x0041CF6D | 0F 85 A9 00 00 00 | jnz     loc_41D01C\n0x0041CF73 | 48 8B 05 06 34 33 00 | mov     rax, cs:qword_750380\n0x0041CF7A | 83 38 0B | cmp     dword ptr [rax], 0Bh\n0x0041CF7D | 0F 85 B1 00 00 00 | jnz     loc_41D034\n0x0041CF83 | E8 E8 F9 FF FF | call    sub_41C970\n0x0041CF88 | E8 F3 F8 FF FF | call    sub_41C880\n0x0041CF8D | 8B 7B 04 | mov     edi, [rbx+4]\n0x0041CF90 | E9 65 FF FF FF | jmp     loc_41CEFA\n0x0041CF95 | 0F 1F 00 | align 8\n0x0041CF98 | 31 ED | xor     ebp, ebp\n0x0041CF9A | 48 83 7B 30 00 | cmp     qword ptr [rbx+30h], 0\n0x0041CF9F | 40 0F 9E C5 | setle   bpl\n0x0041CFA3 | EB 80 | jmp     short loc_41CF25\n0x0041CFA5 | 0F 1F 00 | align 8\n0x0041CFA8 | 48 63 03 | movsxd  rax, dword ptr [rbx]\n0x0041CFAB | 39 43 18 | cmp     [rbx+18h], eax\n0x0041CFAE | 72 E8 | jb      short loc_41CF98\n0x0041CFB0 | 48 8B 53 50 | mov     rdx, [rbx+50h]\n0x0041CFB4 | 48 8B 14 C2 | mov     rdx, [rdx+rax*8]\n0x0041CFB8 | 8B 43 20 | mov     eax, [rbx+20h]\n0x0041CFBB | 03 42 FC | add     eax, [rdx-4]\n0x0041CFBE | 39 43 1C | cmp     [rbx+1Ch], eax\n0x0041CFC1 | 0F 96 C0 | setbe   al\n0x0041CFC4 | E9 53 FF FF FF | jmp     loc_41CF1C\n0x0041CFC9 | 0F 1F 80 00 00 00 00 | align 10h\n0x0041CFD0 | 48 63 C5 | movsxd  rax, ebp\n0x0041CFD3 | 4C 8D 24 C4 | lea     r12, [rsp+rax*8+48h+fds]\n0x0041CFD7 | 44 89 F8 | mov     eax, r15d\n0x0041CFDA | 29 E8 | sub     eax, ebp\n0x0041CFDC | 48 63 E8 | movsxd  rbp, eax\n0x0041CFDF | EB 0F | jmp     short loc_41CFF0\n0x0041CFE1 | 0F 1F 80 00 00 00 00 | align 8\n0x0041CFE8 | 85 C0 | test    eax, eax\n0x0041CFEA | 0F 85 63 FF FF FF | jnz     loc_41CF53\n0x0041CFF0 | 44 89 EA | mov     edx, r13d; timeout\n0x0041CFF3 | 48 89 EE | mov     rsi, rbp; nfds\n0x0041CFF6 | 4C 89 E7 | mov     rdi, r12; fds\n0x0041CFF9 | E8 D2 A2 FE FF | call    _poll\n0x0041CFFE | 8B 53 28 | mov     edx, [rbx+28h]\n0x0041D001 | 85 D2 | test    edx, edx\n0x0041D003 | 74 E3 | jz      short loc_41CFE8\n0x0041D005 | BD 5C 00 00 00 | mov     ebp, 5Ch ; '\\'\n0x0041D00A | 48 83 C4 18 | add     rsp, 18h\n0x0041D00E | 48 89 E8 | mov     rax, rbp\n0x0041D011 | 5B | pop     rbx\n0x0041D012 | 5D | pop     rbp\n0x0041D013 | 41 5C | pop     r12\n0x0041D015 | 41 5D | pop     r13\n0x0041D017 | 41 5E | pop     r14\n0x0041D019 | 41 5F | pop     r15\n0x0041D01B | C3 | retn\n0x0041D01C | E8 8F D4 FE FF | call    sub_40A4B0\n0x0041D021 | 8B 7B 04 | mov     edi, [rbx+4]; fd\n0x0041D024 | 48 8D 93 54 01 00 00 | lea     rdx, [rbx+154h]; termios_p\n0x0041D02B | 31 F6 | xor     esi, esi; optional_actions\n0x0041D02D | E8 DE A3 FE FF | call    _tcsetattr\n0x0041D032 | EB D6 | jmp     short loc_41D00A\n0x0041D034 | 31 FF | xor     edi, edi; status\n0x0041D036 | E8 F5 EF FF FF | call    sub_41C030",
        "output": "```c\nvoid function() {\n    push r15;\n    int ecx = 1;\n    int esi = 1;\n    int r15d = 2;\n    push r14;\n    push r13;\n    int r13d = 0xFFFFFFFF;\n    push r12;\n    push rbp;\n    push rbx;\n    sub rsp, 0x18;\n    mov rbx, cs:qword_750388;\n    mov [rsp+0x48+fds.fd], 0;\n    mov edi, [rbx+4]; fd\n    mov [rsp+0x48+fds.events], cx;\n    lea r14, [rbx+0x190];\n    mov [rsp+0x48+var_3C], si;\n    mov [rsp+0x48+var_40], edi;\n    xor esi, esi; optional_actions\n    mov rdx, r14; termios_p\n    call _tcsetattr;\n    test byte ptr cs:dword_7503D0, 0x40;\n    jnz loc_41CFA8;\n    mov eax, [rbx+0x20];\n    add eax, [rbx];\n    cmp [rbx+0x18], eax;\n    setbe al;\n    mov ebp, 1;\n    test al, al;\n    jnz short loc_41CF98;\n    mov edx, [rbx+0x8];\n    test edx, edx;\n    js short loc_41CF41;\n    mov eax, [rbx+0x20];\n    add edx, 1;\n    mov edi, offset aUUh; \"\\x1B[%u;%uH\"\n    lea esi, [rax+2];\n    xor eax, eax;\n    call _printf;\n    call sub_40A4B0;\n    cmp byte ptr [rbx+0x1CCh], 0;\n    jz loc_41CFD0;\n    mov edi, [rbx+4]; fd\n    lea rsi, [rbx+0x1CCh];\n    mov edx, 0xFFFFFFFE;\n    call sub_500070;\n    mov rbp, rax;\n    cmp eax, 0xFFFFFFFF;\n    jnz loc_41D01C;\n    mov rax, cs:qword_750380;\n    cmp dword ptr [rax], 0xB;\n    jnz loc_41D034;\n    call sub_41C970;\n    call sub_41C880;\n    mov edi, [rbx+4];\n    jmp loc_41CEFA;\n    xor ebp, ebp;\n    cmp qword ptr [rbx+0x30], 0;\n    setle bpl;\n    jmp short loc_41CF25;\n    movsxd rax, dword ptr [rbx];\n    cmp [rbx+0x18], eax;\n    jb short loc_41CF98;\n    mov rdx, [rbx+0x50];\n    mov rdx, [rdx+rax*8];\n    mov eax, [rbx+0x20];\n    add eax, [rdx-4];\n    cmp [rbx+0x1Ch], eax;\n    setbe al;\n    jmp loc_41CF1C;\n    movsxd rax, ebp;\n    lea r12, [rsp+rax*8+0x48+fds];\n    mov eax, r15d;\n    sub eax, ebp;\n    movsxd rbp, eax;\n    jmp short loc_41CFF0;\n    test eax, eax;\n    jnz loc_41CF53;\n    mov edx, r13d; timeout\n    mov rsi, rbp; nfds\n    mov rdi, r12; fds\n    call _poll;\n    mov edx, [rbx+0x28];\n    test edx, edx;\n    jz short loc_41CFE8;\n    mov ebp, 0x5C; '\\'\n    add rsp, 0x18;\n    mov rax, rbp;\n    pop rbx;\n    pop rbp;\n    pop r12;\n    pop r13;\n    pop r14;\n    pop r15;\n    retn;\n    call sub_40A4B0;\n    mov edi, [rbx+4]; fd\n    lea rdx, [rbx+0x154]; termios_p\n    xor esi, esi; optional_actions\n    call _tcsetattr;\n    jmp short loc_41D00A;\n    xor edi, edi; status\n    call sub_41C030;\n}\n```"
    },
    {
        "func_name": "add_to_ino_dev_hashtable",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F78D0 | 48 BA 2B 94 14 D1 0E 82 AE 34 | mov     rdx, 34AE820ED114942Bh\n0x004F78DA | 41 55 | push    r13\n0x004F78DC | 49 89 FD | mov     r13, rdi\n0x004F78DF | 41 54 | push    r12\n0x004F78E1 | 55 | push    rbp\n0x004F78E2 | 53 | push    rbx\n0x004F78E3 | 48 83 EC 08 | sub     rsp, 8\n0x004F78E7 | 48 8B 4F 08 | mov     rcx, [rdi+8]\n0x004F78EB | 48 89 C8 | mov     rax, rcx\n0x004F78EE | 48 F7 E2 | mul     rdx\n0x004F78F1 | 48 C1 EA 06 | shr     rdx, 6\n0x004F78F5 | 48 69 DA 37 01 00 00 | imul    rbx, rdx, 137h\n0x004F78FC | 48 29 D9 | sub     rcx, rbx\n0x004F78FF | 48 89 CB | mov     rbx, rcx\n0x004F7902 | 48 85 F6 | test    rsi, rsi\n0x004F7905 | 74 59 | jz      short loc_4F7960\n0x004F7907 | 48 89 F7 | mov     rdi, rsi; s\n0x004F790A | 49 89 F4 | mov     r12, rsi\n0x004F790D | E8 3E EE F0 FF | call    _strlen\n0x004F7912 | 48 8D 78 20 | lea     rdi, [rax+20h]\n0x004F7916 | E8 D5 26 F1 FF | call    sub_409FF0\n0x004F791B | F3 41 0F 6F 45 00 | movdqu  xmm0, xmmword ptr [r13+0]\n0x004F7921 | 4C 89 E6 | mov     rsi, r12; src\n0x004F7924 | 48 8D 78 18 | lea     rdi, [rax+18h]; dest\n0x004F7928 | 48 89 C5 | mov     rbp, rax\n0x004F792B | 66 0F C6 C0 01 | shufpd  xmm0, xmm0, 1\n0x004F7930 | 0F 11 40 08 | movups  xmmword ptr [rax+8], xmm0\n0x004F7934 | E8 47 EB F0 FF | call    _strcpy\n0x004F7939 | 48 8B 05 20 69 25 00 | mov     rax, cs:qword_74E260\n0x004F7940 | 48 85 C0 | test    rax, rax\n0x004F7943 | 74 2B | jz      short loc_4F7970\n0x004F7945 | 48 8D 04 D8 | lea     rax, [rax+rbx*8]\n0x004F7949 | 48 8B 10 | mov     rdx, [rax]\n0x004F794C | 48 89 55 00 | mov     [rbp+0], rdx\n0x004F7950 | 48 89 28 | mov     [rax], rbp\n0x004F7953 | 48 83 C4 08 | add     rsp, 8\n0x004F7957 | 5B | pop     rbx\n0x004F7958 | 5D | pop     rbp\n0x004F7959 | 41 5C | pop     r12\n0x004F795B | 41 5D | pop     r13\n0x004F795D | C3 | retn\n0x004F795E | 66 90 | align 20h\n0x004F7960 | BF 20 00 00 00 | mov     edi, 20h ; ' '\n0x004F7965 | 41 BC D4 E9 52 00 | mov     r12d, offset pattern\n0x004F796B | EB A9 | jmp     short loc_4F7916\n0x004F796D | 0F 1F 00 | align 10h\n0x004F7970 | BF B8 09 00 00 | mov     edi, 9B8h\n0x004F7975 | E8 B6 26 F1 FF | call    sub_40A030\n0x004F797A | 48 89 05 DF 68 25 00 | mov     cs:qword_74E260, rax\n0x004F7981 | EB C2 | jmp     short loc_4F7945",
        "output": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid sub_409FF0(char* dest, char* src) {\n    strcpy(dest, src);\n}\n\nvoid sub_40A030() {\n    printf(\"Hello, World!\\n\");\n}\n\nvoid _strcpy(char* dest, char* src) {\n    sub_409FF0(dest + 8, src);\n}\n\nvoid _strlen(char* s) {\n    int len = strlen(s);\n    printf(\"Length: %d\\n\", len);\n}\n\nvoid main() {\n    long long rdx = 0x34AE820ED114942B;\n    long long r13 = 0;\n    long long r12 = 0;\n    long long rbp = 0;\n    long long rbx = 0;\n    long long rcx = 0;\n    long long rsi = 0;\n    long long rdi = 0;\n    long long rax = 0;\n    \n    r13 = rdi;\n    rax = rcx;\n    rdx = rdx * rax;\n    rdx = rdx >> 6;\n    rbx = rdx * 0x137;\n    rcx = rcx - rbx;\n    rbx = rcx;\n    \n    if (rsi != 0) {\n        rdi = rsi;\n        r12 = rsi;\n        _strlen(rsi);\n        rdi = rax + 0x20;\n        sub_409FF0(rdi, rax + 0x20);\n        _strcpy(rax + 0x18, r12);\n    }\n    \n    rax = 0x74E260;\n    if (rax != 0) {\n        rax = rax + rbx * 8;\n        rdx = *rax;\n        *(rbp + 0) = rdx;\n        *rax = rbp;\n    }\n}\n```"
    },
    {
        "func_name": "display_topmem_header",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0045E580 | 41 57 | push    r15\n0x0045E582 | BA FF 0F 00 00 | mov     edx, 0FFFh\n0x0045E587 | 41 56 | push    r14\n0x0045E589 | 41 55 | push    r13\n0x0045E58B | 49 89 F5 | mov     r13, rsi\n0x0045E58E | 41 54 | push    r12\n0x0045E590 | 41 89 FC | mov     r12d, edi\n0x0045E593 | BF 9A 8B 52 00 | mov     edi, offset aMeminfo; \"meminfo\"\n0x0045E598 | 55 | push    rbp\n0x0045E599 | 53 | push    rbx\n0x0045E59A | 48 81 EC 78 10 00 00 | sub     rsp, 1078h\n0x0045E5A1 | 48 C7 44 24 08 6A A2 52 00 | mov     [rsp+10A8h+var_10A0], (offset asc_52A263+7); \"?\"\n0x0045E5AA | F3 0F 7E 44 24 08 | movq    xmm0, [rsp+10A8h+var_10A0]\n0x0045E5B0 | 48 8D 74 24 70 | lea     rsi, [rsp+10A8h+haystack]\n0x0045E5B5 | 48 C7 44 24 60 6A A2 52 00 | mov     [rsp+10A8h+var_1048], (offset asc_52A263+7); \"?\"\n0x0045E5BE | 66 0F 6C C0 | punpcklqdq xmm0, xmm0\n0x0045E5C2 | 0F 29 44 24 10 | movaps  [rsp+10A8h+var_1098], xmm0\n0x0045E5C7 | 0F 29 44 24 20 | movaps  [rsp+10A8h+var_1088], xmm0\n0x0045E5CC | 0F 29 44 24 30 | movaps  [rsp+10A8h+var_1078], xmm0\n0x0045E5D1 | 0F 29 44 24 40 | movaps  [rsp+10A8h+var_1068], xmm0\n0x0045E5D6 | 0F 29 44 24 50 | movaps  [rsp+10A8h+var_1058], xmm0\n0x0045E5DB | E8 40 CD FA FF | call    sub_40B320\n0x0045E5E0 | 85 C0 | test    eax, eax\n0x0045E5E2 | 78 60 | js      short loc_45E644\n0x0045E5E4 | 48 98 | cdqe\n0x0045E5E6 | BB C1 10 51 00 | mov     ebx, offset aMemtotal_0; \"MemTotal:\"\n0x0045E5EB | 48 8D 6C 24 10 | lea     rbp, [rsp+10A8h+var_1098]\n0x0045E5F0 | C6 44 04 70 00 | mov     [rsp+rax+10A8h+haystack], 0\n0x0045E5F5 | 4C 8D 74 24 70 | lea     r14, [rsp+10A8h+haystack]\n0x0045E5FA | 66 0F 1F 44 00 00 | nop     word ptr [rax+rax+00h]\n0x0045E600 | 48 89 DE | mov     rsi, rbx; needle\n0x0045E603 | 4C 89 F7 | mov     rdi, r14; haystack\n0x0045E606 | E8 85 92 FA FF | call    _strstr\n0x0045E60B | 48 85 C0 | test    rax, rax\n0x0045E60E | 74 23 | jz      short loc_45E633\n0x0045E610 | 48 0F BE 7B FF | movsx   rdi, byte ptr [rbx-1]\n0x0045E615 | 48 01 C7 | add     rdi, rax\n0x0045E618 | E8 13 A4 FA FF | call    sub_408A30\n0x0045E61D | 48 89 C7 | mov     rdi, rax\n0x0045E620 | 49 89 C7 | mov     r15, rax\n0x0045E623 | E8 38 A4 FA FF | call    sub_408A60\n0x0045E628 | 4C 89 7D 00 | mov     [rbp+0], r15\n0x0045E62C | C6 00 00 | mov     byte ptr [rax], 0\n0x0045E62F | 4C 8D 70 01 | lea     r14, [rax+1]\n0x0045E633 | 48 83 C3 0C | add     rbx, 0Ch\n0x0045E637 | 48 83 C5 08 | add     rbp, 8\n0x0045E63B | 48 81 FB 45 11 51 00 | cmp     rbx, offset unk_511145\n0x0045E642 | 75 BC | jnz     short loc_45E600\n0x0045E644 | 48 83 EC 08 | sub     rsp, 8\n0x0045E648 | BA D8 C5 51 00 | mov     edx, offset aMemTotalSAnonS; \"Mem total:%s anon:%s map:%s free:%s\"\n0x0045E64D | BE B5 1E 00 00 | mov     esi, 1EB5h; maxlen\n0x0045E652 | 31 C0 | xor     eax, eax\n0x0045E654 | FF 74 24 20 | push    qword ptr [rsp+10B0h+var_1098+8]\n0x0045E658 | 4C 8B 4C 24 68 | mov     r9, qword ptr [rsp+10B8h+var_1058+8]\n0x0045E65D | BF C4 E4 74 00 | mov     edi, (offset termios_p.c_cc+13h); s\n0x0045E662 | 4C 8B 44 24 60 | mov     r8, qword ptr [rsp+10B8h+var_1058]\n0x0045E667 | 48 8B 4C 24 20 | mov     rcx, qword ptr [rsp+10B8h+var_1098]\n0x0045E66C | E8 0F 82 FA FF | call    _snprintf\n0x0045E671 | 58 | pop     rax\n0x0045E672 | F6 05 57 1D 2F 00 04 | test    byte ptr cs:dword_7503D0, 4\n0x0045E679 | 44 89 E6 | mov     esi, r12d\n0x0045E67C | B8 40 8F 52 00 | mov     eax, offset aHJ_0; \"\\x1B[H\\x1B[J\"\n0x0045E681 | BF 46 8F 52 00 | mov     edi, offset aS_16; \"%.*s\\n\"\n0x0045E686 | 5A | pop     rdx\n0x0045E687 | BA C4 E4 74 00 | mov     edx, (offset termios_p.c_cc+13h)\n0x0045E68C | 48 0F 44 F8 | cmovz   rdi, rax; format\n0x0045E690 | 31 C0 | xor     eax, eax\n0x0045E692 | E8 A9 81 FA FF | call    _printf\n0x0045E697 | FF 74 24 48 | push    qword ptr [rsp+10A8h+var_1068+8]\n0x0045E69B | BA 00 C6 51 00 | mov     edx, offset aSlabSBufSCache; \" slab:%s buf:%s cache:%s dirty:%s write\"...\n0x0045E6A0 | 31 C0 | xor     eax, eax\n0x0045E6A2 | FF 74 24 48 | push    qword ptr [rsp+10B0h+var_1068]\n0x0045E6A6 | BE B5 1E 00 00 | mov     esi, 1EB5h; maxlen\n0x0045E6AB | BF C4 E4 74 00 | mov     edi, (offset termios_p.c_cc+13h); s\n0x0045E6B0 | 4C 8B 4C 24 38 | mov     r9, qword ptr [rsp+10B8h+var_1088+8]\n0x0045E6B5 | 4C 8B 44 24 30 | mov     r8, qword ptr [rsp+10B8h+var_1088]\n0x0045E6BA | 48 8B 4C 24 70 | mov     rcx, [rsp+10B8h+var_1048]\n0x0045E6BF | E8 BC 81 FA FF | call    _snprintf\n0x0045E6C4 | 44 89 E6 | mov     esi, r12d\n0x0045E6C7 | BA C4 E4 74 00 | mov     edx, (offset termios_p.c_cc+13h)\n0x0045E6CC | 31 C0 | xor     eax, eax\n0x0045E6CE | BF 46 8F 52 00 | mov     edi, offset aS_16; \"%.*s\\n\"\n0x0045E6D3 | E8 68 81 FA FF | call    _printf\n0x0045E6D8 | 4C 8B 44 24 48 | mov     r8, qword ptr [rsp+10B8h+var_1078+8]\n0x0045E6DD | 48 8B 4C 24 40 | mov     rcx, qword ptr [rsp+10B8h+var_1078]\n0x0045E6E2 | BA 4C 8F 52 00 | mov     edx, offset aSwapTotalSFree; \"Swap total:%s free:%s\"\n0x0045E6E7 | BE B5 1E 00 00 | mov     esi, 1EB5h; maxlen\n0x0045E6EC | BF C4 E4 74 00 | mov     edi, (offset termios_p.c_cc+13h); s\n0x0045E6F1 | 31 C0 | xor     eax, eax\n0x0045E6F3 | E8 88 81 FA FF | call    _snprintf\n0x0045E6F8 | 44 89 E6 | mov     esi, r12d\n0x0045E6FB | BA C4 E4 74 00 | mov     edx, (offset termios_p.c_cc+13h)\n0x0045E700 | 31 C0 | xor     eax, eax\n0x0045E702 | BF 46 8F 52 00 | mov     edi, offset aS_16; \"%.*s\\n\"\n0x0045E707 | E8 34 81 FA FF | call    _printf\n0x0045E70C | 41 83 6D 00 03 | sub     dword ptr [r13+0], 3\n0x0045E711 | 48 81 C4 88 10 00 00 | add     rsp, 1088h\n0x0045E718 | 5B | pop     rbx\n0x0045E719 | 5D | pop     rbp\n0x0045E71A | 41 5C | pop     r12\n0x0045E71C | 41 5D | pop     r13\n0x0045E71E | 41 5E | pop     r14\n0x0045E720 | 41 5F | pop     r15\n0x0045E722 | C3 | retn",
        "output": "```c\nvoid function() {\n    // Push registers onto the stack\n    push r15;\n    push r14;\n    push r13;\n    push r12;\n    push rbp;\n    push rbx;\n\n    // Set up variables\n    mov edx, 0xFFF;\n    mov r13, rsi;\n    mov r12d, edi;\n    mov edi, offset aMeminfo; // \"meminfo\"\n\n    // Allocate space on the stack\n    sub rsp, 0x1078;\n\n    // Call sub_40B320\n    call sub_40B320;\n\n    // Check the return value\n    test eax, eax;\n    js short loc_45E644;\n\n    // Loop through haystack\n    lea rsi, [rsp+0x10A8+haystack];\n    lea rbp, [rsp+0x10A8+var_1098];\n    lea r14, [rsp+0x10A8+haystack];\n    mov rsi, rbx; // needle\n    mov rdi, r14; // haystack\n    call _strstr;\n\n    // Check if needle is found in haystack\n    test rax, rax;\n    jz short loc_45E633;\n\n    // Process the found needle\n    movsx rdi, byte ptr [rbx-1];\n    add rdi, rax;\n    call sub_408A30;\n    mov rdi, rax;\n    mov r15, rax;\n    call sub_408A60;\n    mov [rbp+0], r15;\n    mov byte ptr [rax], 0;\n    lea r14, [rax+1];\n\n    // Continue looping through haystack\n    add rbx, 0x0C;\n    add rbp, 0x08;\n    cmp rbx, offset unk_511145;\n    jnz short loc_45E600;\n\n    // Clean up and return\n    sub rsp, 0x08;\n    mov edx, offset aMemTotalSAnonS; // \"Mem total:%s anon:%s map:%s free:%s\"\n    mov esi, 0x1EB5; // maxlen\n    xor eax, eax;\n    push qword ptr [rsp+0x10B0+var_1098+8];\n    mov r9, qword ptr [rsp+0x10B8+var_1058+8];\n    mov edi, offset termios_p.c_cc+0x13; // s\n    mov r8, qword ptr [rsp+0x10B8+var_1058];\n    mov rcx, qword ptr [rsp+0x10B8+var_1098];\n    call _snprintf;\n    pop rax;\n    test byte ptr cs:dword_7503D0, 0x04;\n    mov esi, r12d;\n    mov eax, offset aHJ_0; // \"\\x1B[H\\x1B[J\"\n    mov edi, offset aS_16; // \"%.*s\\n\"\n    pop rdx;\n    mov edx, offset termios_p.c_cc+0x13;\n    cmovz rdi, rax;\n    xor eax, eax;\n    call _printf;\n    push qword ptr [rsp+0x10A8+var_1068+8];\n    mov edx, offset aSlabSBufSCache; // \" slab:%s buf:%s cache:%s dirty:%s write\"\n    xor eax, eax;\n    push qword ptr [rsp+0x10B0+var_1068];\n    mov esi, 0x1EB5; // maxlen\n    mov edi, offset termios_p.c_cc+0x13; // s\n    mov r9, qword ptr [rsp+0x10B8+var_1088+8];\n    mov r8, qword ptr [rsp+0x10B8+var_1088];\n    mov rcx, [rsp+0x10B8+var_1048];\n    call _snprintf;\n    mov esi, r12d;\n    mov edx, offset termios_p.c_cc+0x13;\n    xor eax, eax;\n    mov edi, offset aS_16; // \"%.*s\\n\"\n    call _printf;\n\n    // Update r13\n    sub dword ptr [r13+0], 0x03;\n\n    // Clean up and return\n    add rsp, 0x1088;\n    pop rbx;\n    pop rbp;\n    pop r12;\n    pop r13;\n    pop r14;\n    pop r15;\n    retn;\n}\n```"
    },
    {
        "func_name": "sum_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004CC630 | 41 54 | push    r12\n0x004CC632 | 31 C0 | xor     eax, eax\n0x004CC634 | 55 | push    rbp\n0x004CC635 | 53 | push    rbx; char\n0x004CC636 | 48 89 F3 | mov     rbx, rsi\n0x004CC639 | BE F3 D6 52 00 | mov     esi, offset aSr; \"sr\"\n0x004CC63E | 48 89 DF | mov     rdi, rbx; argv\n0x004CC641 | E8 3A 78 02 00 | call    sub_4F3E80\n0x004CC646 | 48 63 15 CB 17 28 00 | movsxd  rdx, cs:optind\n0x004CC64D | 89 C6 | mov     esi, eax\n0x004CC64F | 48 8D 1C D3 | lea     rbx, [rbx+rdx*8]\n0x004CC653 | 83 E6 01 | and     esi, 1\n0x004CC656 | 74 70 | jz      short loc_4CC6C8\n0x004CC658 | B9 03 00 00 00 | mov     ecx, 3\n0x004CC65D | 41 BC 03 00 00 00 | mov     r12d, 3\n0x004CC663 | BE 02 00 00 00 | mov     esi, 2\n0x004CC668 | 48 8B 13 | mov     rdx, [rbx]\n0x004CC66B | A8 02 | test    al, 2\n0x004CC66D | 75 41 | jnz     short loc_4CC6B0\n0x004CC66F | 48 85 D2 | test    rdx, rdx\n0x004CC672 | 74 6E | jz      short loc_4CC6E2\n0x004CC674 | 48 83 7B 08 00 | cmp     qword ptr [rbx+8], 0\n0x004CC679 | 44 0F 44 E1 | cmovz   r12d, ecx\n0x004CC67D | BD 01 00 00 00 | mov     ebp, 1\n0x004CC682 | 66 0F 1F 44 00 00 | nop     word ptr [rax+rax+00h]\n0x004CC688 | 48 8B 3B | mov     rdi, [rbx]\n0x004CC68B | 44 89 E6 | mov     esi, r12d\n0x004CC68E | 48 83 C3 08 | add     rbx, 8\n0x004CC692 | E8 39 FE FF FF | call    sub_4CC4D0\n0x004CC697 | 21 C5 | and     ebp, eax\n0x004CC699 | 48 83 3B 00 | cmp     qword ptr [rbx], 0\n0x004CC69D | 75 E9 | jnz     short loc_4CC688\n0x004CC69F | 31 C0 | xor     eax, eax\n0x004CC6A1 | 85 ED | test    ebp, ebp\n0x004CC6A3 | 5B | pop     rbx\n0x004CC6A4 | 5D | pop     rbp\n0x004CC6A5 | 0F 94 C0 | setz    al\n0x004CC6A8 | 41 5C | pop     r12\n0x004CC6AA | C3 | retn\n0x004CC6AB | 0F 1F 44 00 00 | align 10h\n0x004CC6B0 | 48 85 D2 | test    rdx, rdx\n0x004CC6B3 | 74 2B | jz      short loc_4CC6E0\n0x004CC6B5 | 45 31 E4 | xor     r12d, r12d\n0x004CC6B8 | 48 83 7B 08 00 | cmp     qword ptr [rbx+8], 0\n0x004CC6BD | 41 0F 95 C4 | setnz   r12b\n0x004CC6C1 | EB BA | jmp     short loc_4CC67D\n0x004CC6C3 | 0F 1F 44 00 00 | align 8\n0x004CC6C8 | 31 C9 | xor     ecx, ecx\n0x004CC6CA | 41 BC 01 00 00 00 | mov     r12d, 1\n0x004CC6D0 | 48 8B 13 | mov     rdx, [rbx]\n0x004CC6D3 | A8 02 | test    al, 2\n0x004CC6D5 | 74 98 | jz      short loc_4CC66F\n0x004CC6D7 | EB D7 | jmp     short loc_4CC6B0\n0x004CC6D9 | 0F 1F 80 00 00 00 00 | align 20h\n0x004CC6E0 | 31 F6 | xor     esi, esi\n0x004CC6E2 | BF 16 E1 52 00 | mov     edi, (offset asc_52E113+3); \"-\"\n0x004CC6E7 | E8 E4 FD FF FF | call    sub_4CC4D0\n0x004CC6EC | 5B | pop     rbx\n0x004CC6ED | 89 C5 | mov     ebp, eax\n0x004CC6EF | 31 C0 | xor     eax, eax\n0x004CC6F1 | 85 ED | test    ebp, ebp\n0x004CC6F3 | 5D | pop     rbp\n0x004CC6F4 | 41 5C | pop     r12\n0x004CC6F6 | 0F 94 C0 | setz    al\n0x004CC6F9 | C3 | retn",
        "output": "```c\nvoid function(char* argv) {\n    push r12;\n    xor eax, eax;\n    push rbp;\n    push rbx;\n    mov rbx, rsi;\n    mov esi, offset aSr; // \"sr\"\n    mov rdi, rbx; // argv\n    call sub_4F3E80;\n    movsxd rdx, cs:optind;\n    mov esi, eax;\n    lea rbx, [rbx+rdx*8];\n    and esi, 1;\n    jz short loc_4CC6C8;\n    mov ecx, 3;\n    mov r12d, 3;\n    mov esi, 2;\n    mov rdx, [rbx];\n    test al, 2;\n    jnz short loc_4CC6B0;\n    test rdx, rdx;\n    jz short loc_4CC6E2;\n    cmp qword ptr [rbx+8], 0;\n    cmovz r12d, ecx;\n    mov ebp, 1;\n    nop word ptr [rax+rax+00h];\n    mov rdi, [rbx];\n    mov esi, r12d;\n    add rbx, 8;\n    call sub_4CC4D0;\n    and ebp, eax;\n    cmp qword ptr [rbx], 0;\n    jnz short loc_4CC688;\n    xor eax, eax;\n    test ebp, ebp;\n    pop rbx;\n    pop rbp;\n    setz al;\n    pop r12;\n    retn;\n    align 10h;\nloc_4CC6B0:\n    test rdx, rdx;\n    jz short loc_4CC6E0;\n    xor r12d, r12d;\n    cmp qword ptr [rbx+8], 0;\n    setnz r12b;\n    jmp short loc_4CC67D;\n    align 8;\nloc_4CC6C8:\n    xor ecx, ecx;\n    mov r12d, 1;\n    mov rdx, [rbx];\n    test al, 2;\n    jz short loc_4CC66F;\n    jmp short loc_4CC6B0;\n    align 20h;\nloc_4CC6E0:\n    xor esi, esi;\n    mov edi, (offset asc_52E113+3); // \"-\"\n    call sub_4CC4D0;\n    pop rbx;\n    mov ebp, eax;\n    xor eax, eax;\n    test ebp, ebp;\n    pop rbp;\n    pop r12;\n    setz al;\n    retn;\n}\n```"
    },
    {
        "func_name": "tunctl_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00440B30 | 41 55 | push    r13\n0x00440B32 | 48 89 F7 | mov     rdi, rsi; argv\n0x00440B35 | BE 08 74 52 00 | mov     esi, offset aFTDUGB; \"f:t:d:u:g:b\"\n0x00440B3A | 41 54 | push    r12\n0x00440B3C | 55 | push    rbp\n0x00440B3D | 53 | push    rbx\n0x00440B3E | 48 83 EC 60 | sub     rsp, 60h\n0x00440B42 | 48 C7 05 73 F8 30 00 FB 73 52 00 | mov     cs:qword_7503C0, offset a0TDDT; \"=0:t--d:d--t\"\n0x00440B4D | 48 C7 44 24 08 E8 73 52 00 | mov     qword ptr [rsp+80h+var_78], offset aTapD; \"tap%d\"\n0x00440B56 | 48 8D 44 24 20 | lea     rax, [rsp+80h+var_60]\n0x00440B5B | 48 C7 44 24 10 EE 73 52 00 | mov     [rsp+80h+var_70], offset aDevNetTun; \"/dev/net/tun\"\n0x00440B64 | 50 | push    rax; char\n0x00440B65 | 31 C0 | xor     eax, eax\n0x00440B67 | 4C 8D 44 24 10 | lea     r8, [rsp+88h+var_78]\n0x00440B6C | 4C 8D 4C 24 20 | lea     r9, [rsp+88h+var_68]\n0x00440B71 | 48 8D 54 24 18 | lea     rdx, [rsp+88h+var_70]\n0x00440B76 | 4C 89 C1 | mov     rcx, r8\n0x00440B79 | E8 02 33 0B 00 | call    sub_4F3E80\n0x00440B7E | 48 8B 74 24 10 | mov     rsi, qword ptr [rsp+88h+var_78]\n0x00440B83 | 66 0F EF C0 | pxor    xmm0, xmm0\n0x00440B87 | 48 8D 7C 24 30 | lea     rdi, [rsp+88h+s]\n0x00440B8C | 89 C3 | mov     ebx, eax\n0x00440B8E | B8 02 10 00 00 | mov     eax, 1002h\n0x00440B93 | 0F 29 44 24 40 | movaps  [rsp+88h+var_48], xmm0\n0x00440B98 | 0F 29 44 24 30 | movaps  xmmword ptr [rsp+88h+s], xmm0\n0x00440B9D | 48 C7 44 24 50 00 00 00 00 | mov     [rsp+88h+var_38], 0\n0x00440BA6 | 66 89 44 24 40 | mov     word ptr [rsp+88h+var_48], ax\n0x00440BAB | E8 10 84 FC FF | call    sub_408FC0\n0x00440BB0 | 48 8B 7C 24 18 | mov     rdi, [rsp+88h+var_70]\n0x00440BB5 | BE 02 00 00 00 | mov     esi, 2\n0x00440BBA | E8 A1 95 FC FF | call    sub_40A160\n0x00440BBF | 48 8D 54 24 30 | lea     rdx, [rsp+88h+s]\n0x00440BC4 | 31 C9 | xor     ecx, ecx\n0x00440BC6 | BE CA 54 04 40 | mov     esi, 400454CAh\n0x00440BCB | 89 C7 | mov     edi, eax\n0x00440BCD | 89 C5 | mov     ebp, eax\n0x00440BCF | 31 C0 | xor     eax, eax\n0x00440BD1 | E8 3A 9E FC FF | call    sub_40AA10\n0x00440BD6 | 5A | pop     rdx\n0x00440BD7 | 59 | pop     rcx\n0x00440BD8 | F6 C3 04 | test    bl, 4\n0x00440BDB | 0F 85 F7 00 00 00 | jnz     loc_440CD8\n0x00440BE1 | F6 C3 10 | test    bl, 10h\n0x00440BE4 | 75 5A | jnz     short loc_440C40\n0x00440BE6 | E8 E5 5D FC FF | call    _geteuid\n0x00440BEB | 49 C7 C5 FF FF FF FF | mov     r13, 0FFFFFFFFFFFFFFFFh\n0x00440BF2 | 41 89 C4 | mov     r12d, eax\n0x00440BF5 | F6 C3 08 | test    bl, 8\n0x00440BF8 | 75 72 | jnz     short loc_440C6C\n0x00440BFA | 31 C9 | xor     ecx, ecx\n0x00440BFC | 4C 89 E2 | mov     rdx, r12\n0x00440BFF | BE CC 54 04 40 | mov     esi, 400454CCh\n0x00440C04 | 89 EF | mov     edi, ebp\n0x00440C06 | 31 C0 | xor     eax, eax\n0x00440C08 | E8 03 9E FC FF | call    sub_40AA10\n0x00440C0D | 31 C9 | xor     ecx, ecx\n0x00440C0F | 31 C0 | xor     eax, eax\n0x00440C11 | BA 01 00 00 00 | mov     edx, 1\n0x00440C16 | BE CB 54 04 40 | mov     esi, 400454CBh\n0x00440C1B | 89 EF | mov     edi, ebp\n0x00440C1D | E8 EE 9D FC FF | call    sub_40AA10\n0x00440C22 | 83 E3 20 | and     ebx, 20h\n0x00440C25 | 74 59 | jz      short loc_440C80\n0x00440C27 | 48 8D 7C 24 20 | lea     rdi, [rsp+78h+s]; s\n0x00440C2C | E8 8F 58 FC FF | call    _puts\n0x00440C31 | 48 83 C4 58 | add     rsp, 58h\n0x00440C35 | 31 C0 | xor     eax, eax\n0x00440C37 | 5B | pop     rbx\n0x00440C38 | 5D | pop     rbp\n0x00440C39 | 41 5C | pop     r12\n0x00440C3B | 41 5D | pop     r13\n0x00440C3D | C3 | retn\n0x00440C3E | 66 90 | align 20h\n0x00440C40 | 48 8B 7C 24 18 | mov     rdi, qword ptr [rsp+78h+var_60]\n0x00440C45 | 49 C7 C4 FF FF FF FF | mov     r12, 0FFFFFFFFFFFFFFFFh\n0x00440C4C | E8 7F FA 0A 00 | call    sub_4F06D0\n0x00440C51 | 31 C9 | xor     ecx, ecx\n0x00440C53 | BE CE 54 04 40 | mov     esi, 400454CEh\n0x00440C58 | 89 EF | mov     edi, ebp\n0x00440C5A | 48 89 C2 | mov     rdx, rax\n0x00440C5D | 49 89 C5 | mov     r13, rax\n0x00440C60 | 31 C0 | xor     eax, eax\n0x00440C62 | E8 A9 9D FC FF | call    sub_40AA10\n0x00440C67 | F6 C3 08 | test    bl, 8\n0x00440C6A | 74 8E | jz      short loc_440BFA\n0x00440C6C | 48 8B 7C 24 10 | mov     rdi, [rsp+78h+var_68]\n0x00440C71 | E8 3A FA 0A 00 | call    sub_4F06B0\n0x00440C76 | 49 89 C4 | mov     r12, rax\n0x00440C79 | E9 7C FF FF FF | jmp     loc_440BFA\n0x00440C7E | 66 90 | align 20h\n0x00440C80 | 48 8D 74 24 20 | lea     rsi, [rsp+78h+s]\n0x00440C85 | BF 18 74 52 00 | mov     edi, offset aSetSSpersisten; \"Set '%s' %spersistent\"\n0x00440C8A | 31 C0 | xor     eax, eax\n0x00440C8C | BA D4 E9 52 00 | mov     edx, offset pattern\n0x00440C91 | E8 AA 5B FC FF | call    _printf\n0x00440C96 | 31 C0 | xor     eax, eax\n0x00440C98 | 4C 89 E6 | mov     rsi, r12\n0x00440C9B | BF 2E 74 52 00 | mov     edi, offset aAndOwnedByUidL; \" and owned by uid %ld\"\n0x00440CA0 | E8 9B 5B FC FF | call    _printf\n0x00440CA5 | 49 83 FD FF | cmp     r13, 0FFFFFFFFFFFFFFFFh\n0x00440CA9 | 74 0F | jz      short loc_440CBA\n0x00440CAB | 4C 89 EE | mov     rsi, r13\n0x00440CAE | BF 44 74 52 00 | mov     edi, offset aGidLd; \" gid %ld\"\n0x00440CB3 | 31 C0 | xor     eax, eax\n0x00440CB5 | E8 86 5B FC FF | call    _printf\n0x00440CBA | BF 0A 00 00 00 | mov     edi, 0Ah\n0x00440CBF | E8 FC 97 FC FF | call    sub_40A4C0\n0x00440CC4 | 48 83 C4 58 | add     rsp, 58h\n0x00440CC8 | 31 C0 | xor     eax, eax\n0x00440CCA | 5B | pop     rbx\n0x00440CCB | 5D | pop     rbp\n0x00440CCC | 41 5C | pop     r12\n0x00440CCE | 41 5D | pop     r13\n0x00440CD0 | C3 | retn\n0x00440CD1 | 0F 1F 80 00 00 00 00 | align 8\n0x00440CD8 | 89 EF | mov     edi, ebp\n0x00440CDA | 31 C9 | xor     ecx, ecx\n0x00440CDC | 31 D2 | xor     edx, edx\n0x00440CDE | BE CB 54 04 40 | mov     esi, 400454CBh\n0x00440CE3 | 31 C0 | xor     eax, eax\n0x00440CE5 | E8 26 9D FC FF | call    sub_40AA10\n0x00440CEA | 48 8D 74 24 20 | lea     rsi, [rsp+78h+s]\n0x00440CEF | 31 C0 | xor     eax, eax\n0x00440CF1 | BA 14 74 52 00 | mov     edx, offset aNon_0; \"non\"\n0x00440CF6 | BF 18 74 52 00 | mov     edi, offset aSetSSpersisten; \"Set '%s' %spersistent\"\n0x00440CFB | E8 40 6A 0B 00 | call    sub_4F7740\n0x00440D00 | 48 83 C4 58 | add     rsp, 58h\n0x00440D04 | 31 C0 | xor     eax, eax\n0x00440D06 | 5B | pop     rbx\n0x00440D07 | 5D | pop     rbp\n0x00440D08 | 41 5C | pop     r12\n0x00440D0A | 41 5D | pop     r13\n0x00440D0C | C3 | retn",
        "output": "```c\n#include <stdio.h>\n\nvoid sub_4F3E80(char* argv, char* s) {\n    // Function implementation\n}\n\nvoid sub_408FC0() {\n    // Function implementation\n}\n\nvoid sub_40A160() {\n    // Function implementation\n}\n\nvoid sub_40AA10() {\n    // Function implementation\n}\n\nvoid sub_4F06D0() {\n    // Function implementation\n}\n\nvoid sub_4F06B0() {\n    // Function implementation\n}\n\nvoid _geteuid() {\n    // Function implementation\n}\n\nvoid _puts(char* s) {\n    // Function implementation\n}\n\nvoid _printf(char* format, ...) {\n    // Function implementation\n}\n\nvoid sub_40A4C0() {\n    // Function implementation\n}\n\nint main(int argc, char* argv[]) {\n    char* aFTDUGB = \"f:t:d:u:g:b\";\n    char* a0TDDT = \"=0:t--d:d--t\";\n    char* aTapD = \"tap%d\";\n    char* aDevNetTun = \"/dev/net/tun\";\n    char* pattern = \"Set '%s' %spersistent\";\n    long int var_78;\n    long int var_60;\n    long int var_70;\n    long int var_48;\n    long int var_38;\n    \n    // Function calls\n    sub_4F3E80(argv[1], s);\n    sub_408FC0();\n    sub_40A160();\n    sub_40AA10();\n    sub_4F06D0();\n    sub_4F06B0();\n    _geteuid();\n    _puts(s);\n    _printf(pattern, s);\n    _printf(\" and owned by uid %ld\", var_78);\n    _printf(\" gid %ld\", var_70);\n    sub_40A4C0();\n    \n    return 0;\n}\n```"
    }
]
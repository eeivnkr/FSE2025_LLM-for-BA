[
    {
        "func_name": "rmaliases",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00470817 | 55 | push    rbp\n0x00470818 | 48 89 E5 | mov     rbp, rsp\n0x0047081B | 48 83 EC 20 | sub     rsp, 20h\n0x0047081F | 48 8B 05 F2 CB 2E 00 | mov     rax, cs:qword_75D418\n0x00470826 | 8B 50 30 | mov     edx, [rax+30h]\n0x00470829 | 83 C2 01 | add     edx, 1\n0x0047082C | 89 50 30 | mov     [rax+30h], edx\n0x0047082F | C7 45 EC 00 00 00 00 | mov     [rbp+var_14], 0\n0x00470836 | EB 69 | jmp     short loc_4708A1\n0x00470838 | 48 8B 05 51 A7 2E 00 | mov     rax, cs:qword_75AF90\n0x0047083F | 8B 55 EC | mov     edx, [rbp+var_14]\n0x00470842 | 48 63 D2 | movsxd  rdx, edx\n0x00470845 | 48 C1 E2 03 | shl     rdx, 3\n0x00470849 | 48 01 D0 | add     rax, rdx\n0x0047084C | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x00470850 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00470854 | 48 8B 00 | mov     rax, [rax]\n0x00470857 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0047085B | EB 39 | jmp     short loc_470896\n0x0047085D | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00470861 | 48 8B 00 | mov     rax, [rax]\n0x00470864 | 48 89 C7 | mov     rdi, rax\n0x00470867 | E8 FC FD FF FF | call    sub_470668\n0x0047086C | 48 89 C2 | mov     rdx, rax\n0x0047086F | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00470873 | 48 89 10 | mov     [rax], rdx\n0x00470876 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0047087A | 48 8B 00 | mov     rax, [rax]\n0x0047087D | 48 39 45 F8 | cmp     [rbp+var_8], rax\n0x00470881 | 75 08 | jnz     short loc_47088B\n0x00470883 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00470887 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x0047088B | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0047088F | 48 8B 00 | mov     rax, [rax]\n0x00470892 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00470896 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0047089B | 75 C0 | jnz     short loc_47085D\n0x0047089D | 83 45 EC 01 | add     [rbp+var_14], 1\n0x004708A1 | 83 7D EC 26 | cmp     [rbp+var_14], 26h ; '&'\n0x004708A5 | 7E 91 | jle     short loc_470838\n0x004708A7 | E8 93 D7 FF FF | call    sub_46E03F\n0x004708AC | 90 | nop\n0x004708AD | C9 | leave\n0x004708AE | C3 | retn",
        "output": "",
        "source_code": "static void\nrmaliases(void)\n{\n\tstruct alias *ap, **app;\n\tint i;\n\n\tINT_OFF;\n\tfor (i = 0; i < ATABSIZE; i++) {\n\t\tapp = &atab[i];\n\t\tfor (ap = *app; ap; ap = *app) {\n\t\t\t*app = freealias(*app);\n\t\t\tif (ap == *app) {\n\t\t\t\tapp = &ap->next;\n\t\t\t}\n\t\t}\n\t}\n\tINT_ON;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_470817(void **a1, __int64 a2)\n{\n  int i; // [rsp+Ch] [rbp-14h]\n  void ***v4; // [rsp+10h] [rbp-10h]\n  void **j; // [rsp+18h] [rbp-8h]\n\n  ++*(_DWORD *)(qword_75D418 + 48);\n  for ( i = 0; i <= 38; ++i )\n  {\n    v4 = (void ***)(8LL * i + qword_75AF90);\n    for ( j = *v4; j; j = *v4 )\n    {\n      a1 = *v4;\n      *v4 = sub_470668(*v4);\n      if ( j == *v4 )\n        v4 = (void ***)j;\n    }\n  }\n  return sub_46E03F(a1, a2);\n}\n",
        "baseline_code_debug": "void __cdecl rmaliases()\n{\n  int i; // [rsp+Ch] [rbp-14h]\n  alias **app; // [rsp+10h] [rbp-10h]\n  alias *ap; // [rsp+18h] [rbp-8h]\n\n  ++ash_ptr_to_globals_misc->suppress_int;\n  for ( i = 0; i <= 38; ++i )\n  {\n    app = &atab[i];\n    for ( ap = *app; ap; ap = *app )\n    {\n      *app = freealias(*app);\n      if ( ap == *app )\n        app = &ap->next;\n    }\n  }\n  int_on();\n}\n",
        "similarity_score_unixcoder": 0.09390775859355927,
        "similarity_score_baseline_stripped": 0.43275851011276245,
        "similarity_score_baseline_debug": 0.7947043776512146
    },
    {
        "func_name": "dot_right",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004EDA45 | 55 | push    rbp\n0x004EDA46 | 48 89 E5 | mov     rbp, rsp\n0x004EDA49 | 48 8B 05 B8 F9 26 00 | mov     rax, cs:qword_75D408\n0x004EDA50 | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x004EDA54 | 48 8B 05 AD F9 26 00 | mov     rax, cs:qword_75D408\n0x004EDA5B | 48 8B 40 08 | mov     rax, [rax+8]\n0x004EDA5F | 48 83 E8 01 | sub     rax, 1\n0x004EDA63 | 48 39 C2 | cmp     rdx, rax\n0x004EDA66 | 73 25 | jnb     short loc_4EDA8D\n0x004EDA68 | 48 8B 05 99 F9 26 00 | mov     rax, cs:qword_75D408\n0x004EDA6F | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004EDA73 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004EDA76 | 3C 0A | cmp     al, 0Ah\n0x004EDA78 | 74 13 | jz      short loc_4EDA8D\n0x004EDA7A | 48 8B 05 87 F9 26 00 | mov     rax, cs:qword_75D408\n0x004EDA81 | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x004EDA85 | 48 83 C2 01 | add     rdx, 1\n0x004EDA89 | 48 89 50 10 | mov     [rax+10h], rdx\n0x004EDA8D | 90 | nop\n0x004EDA8E | 5D | pop     rbp\n0x004EDA8F | C3 | retn",
        "output": "",
        "source_code": "static void dot_right(void)\n{\n\tif (dot < end - 1 && *dot != '\\n')\n\t\tdot++;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "unsigned __int64 sub_4EDA45()\n{\n  unsigned __int64 result; // rax\n\n  result = *((_QWORD *)qword_75D408 + 1) - 1LL;\n  if ( *((_QWORD *)qword_75D408 + 2) < result )\n  {\n    result = **((unsigned __int8 **)qword_75D408 + 2);\n    if ( (_BYTE)result != 10 )\n    {\n      result = (unsigned __int64)qword_75D408;\n      ++*((_QWORD *)qword_75D408 + 2);\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl dot_right()\n{\n  if ( ptr_to_globals->fakehost < ptr_to_globals->login - 1 && *ptr_to_globals->fakehost != 10 )\n    ++ptr_to_globals->fakehost;\n}\n",
        "similarity_score_unixcoder": 0.05771702900528908,
        "similarity_score_baseline_stripped": 0.4882625937461853,
        "similarity_score_baseline_debug": 0.6868862509727478
    },
    {
        "func_name": "catcher",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0042727C | 55 | push    rbp\n0x0042727D | 48 89 E5 | mov     rbp, rsp\n0x00427280 | 48 83 EC 10 | sub     rsp, 10h\n0x00427284 | E8 DE 49 FE FF | call    sub_40BC67\n0x00427289 | 89 45 FC | mov     [rbp+var_4], eax\n0x0042728C | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00427291 | 8B 40 40 | mov     eax, [rax+40h]\n0x00427294 | 85 C0 | test    eax, eax\n0x00427296 | 75 0B | jnz     short loc_4272A3\n0x00427298 | BA F8 B3 75 00 | mov     edx, offset dest\n0x0042729D | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004272A0 | 89 42 40 | mov     [rdx+40h], eax\n0x004272A3 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004272A8 | 8B 40 34 | mov     eax, [rax+34h]\n0x004272AB | 85 C0 | test    eax, eax\n0x004272AD | 74 25 | jz      short loc_4272D4\n0x004272AF | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004272B4 | 8B 40 3C | mov     eax, [rax+3Ch]\n0x004272B7 | 85 C0 | test    eax, eax\n0x004272B9 | 74 1E | jz      short loc_4272D9\n0x004272BB | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004272C0 | 8B 40 40 | mov     eax, [rax+40h]\n0x004272C3 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x004272C6 | 29 C2 | sub     edx, eax\n0x004272C8 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004272CD | 8B 40 3C | mov     eax, [rax+3Ch]\n0x004272D0 | 39 C2 | cmp     edx, eax\n0x004272D2 | 76 05 | jbe     short loc_4272D9\n0x004272D4 | E8 E0 FE FF FF | call    sub_4271B9\n0x004272D9 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004272DE | 8B 40 34 | mov     eax, [rax+34h]\n0x004272E1 | 85 C0 | test    eax, eax\n0x004272E3 | 7E 0E | jle     short loc_4272F3\n0x004272E5 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004272EA | 8B 50 34 | mov     edx, [rax+34h]\n0x004272ED | 83 EA 01 | sub     edx, 1\n0x004272F0 | 89 50 34 | mov     [rax+34h], edx\n0x004272F3 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004272F8 | 8B 40 38 | mov     eax, [rax+38h]\n0x004272FB | 85 C0 | test    eax, eax\n0x004272FD | 74 16 | jz      short loc_427315\n0x004272FF | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00427304 | 8B 40 38 | mov     eax, [rax+38h]\n0x00427307 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x0042730A | 29 C2 | sub     edx, eax\n0x0042730C | 89 D0 | mov     eax, edx\n0x0042730E | 3D 20 A1 07 00 | cmp     eax, 7A120h\n0x00427313 | 76 3A | jbe     short loc_42734F\n0x00427315 | B9 14 B4 75 00 | mov     ecx, 75B414h\n0x0042731A | BA 00 B4 75 00 | mov     edx, offset dest.c_cflag\n0x0042731F | B8 FC B3 75 00 | mov     eax, 75B3FCh\n0x00427324 | 48 89 C6 | mov     rsi, rax\n0x00427327 | BF F8 B3 75 00 | mov     edi, offset dest\n0x0042732C | E8 7C FC FF FF | call    sub_426FAD\n0x00427331 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00427336 | 8B 40 34 | mov     eax, [rax+34h]\n0x00427339 | 85 C0 | test    eax, eax\n0x0042733B | 75 12 | jnz     short loc_42734F\n0x0042733D | 8B 05 0D 61 33 00 | mov     eax, cs:dword_75D450\n0x00427343 | 83 E0 02 | and     eax, 2\n0x00427346 | 85 C0 | test    eax, eax\n0x00427348 | 74 05 | jz      short loc_42734F\n0x0042734A | E8 6A FE FF FF | call    sub_4271B9\n0x0042734F | BF 01 00 00 00 | mov     edi, 1; seconds\n0x00427354 | E8 97 FA FD FF | call    _alarm\n0x00427359 | 90 | nop\n0x0042735A | C9 | leave\n0x0042735B | C3 | retn",
        "output": "",
        "source_code": "static void catcher(void)\n{\n\tunsigned now;\n\n\tnow = MONOTONIC_US();\n\tif (start == 0)\n\t\tstart = now;\n\n\tif (count == 0 || (timeout_us && (now - start) > timeout_us))\n\t\tfinish();\n\n\t/* count < 0 means \"infinite count\" */\n\tif (count > 0)\n\t\tcount--;\n\n\tif (last == 0 || (now - last) > 500000) {\n\t\tsend_pack(&src, &dst, &me, &he);\n\t\tif (count == 0 && (option_mask32 & UNSOLICITED))\n\t\t\tfinish();\n\t}\n\talarm(1);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "unsigned int sub_42727C()\n{\n  int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_40BC67();\n  if ( !*((_DWORD *)&dest + 16) )\n    *((_DWORD *)&dest + 16) = v1;\n  if ( !dest.c_ispeed\n    || *((_DWORD *)&dest + 15) && (unsigned int)(v1 - *((_DWORD *)&dest + 16)) > *((_DWORD *)&dest + 15) )\n  {\n    sub_4271B9();\n  }\n  if ( (int)dest.c_ispeed > 0 )\n    --dest.c_ispeed;\n  if ( !dest.c_ospeed || v1 - dest.c_ospeed > 0x7A120 )\n  {\n    sub_426FAD(&dest, &dest.c_oflag, (__int64)&dest.c_cflag, (const struct sockaddr *)&dest.c_cc[11]);\n    if ( !dest.c_ispeed && (dword_75D450 & 2) != 0 )\n      sub_4271B9();\n  }\n  return alarm(1u);\n}\n",
        "baseline_code_debug": "void __cdecl catcher()\n{\n  unsigned int now; // [rsp+Ch] [rbp-4h]\n\n  now = monotonic_us();\n  if ( !*((_DWORD *)&bb_common_bufsiz1 + 16) )\n    *((_DWORD *)&bb_common_bufsiz1 + 16) = now;\n  if ( !bb_common_bufsiz1.c_ispeed\n    || *((_DWORD *)&bb_common_bufsiz1 + 15)\n    && now - *((_DWORD *)&bb_common_bufsiz1 + 16) > *((_DWORD *)&bb_common_bufsiz1 + 15) )\n  {\n    finish();\n  }\n  if ( (int)bb_common_bufsiz1.c_ispeed > 0 )\n    --bb_common_bufsiz1.c_ispeed;\n  if ( !bb_common_bufsiz1.c_ospeed || now - bb_common_bufsiz1.c_ospeed > 0x7A120 )\n  {\n    send_pack(\n      (in_addr *)&bb_common_bufsiz1,\n      (in_addr *)&bb_common_bufsiz1.c_oflag,\n      (sockaddr_ll *)&bb_common_bufsiz1.c_cflag,\n      (sockaddr_ll *)&bb_common_bufsiz1.c_cc[11]);\n    if ( !bb_common_bufsiz1.c_ispeed && (option_mask32 & 2) != 0 )\n      finish();\n  }\n  alarm(1u);\n}\n",
        "similarity_score_unixcoder": 0.06477796286344528,
        "similarity_score_baseline_stripped": 0.5103849172592163,
        "similarity_score_baseline_debug": 0.683330237865448
    },
    {
        "func_name": "block_CHLD_HUP_ALRM",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00433B6A | 55 | push    rbp\n0x00433B6B | 48 89 E5 | mov     rbp, rsp\n0x00433B6E | 48 83 EC 10 | sub     rsp, 10h\n0x00433B72 | 48 89 7D F8 | mov     [rbp+set], rdi\n0x00433B76 | 48 8B 45 F8 | mov     rax, [rbp+set]\n0x00433B7A | 48 89 C7 | mov     rdi, rax; set\n0x00433B7D | E8 7E 35 FD FF | call    _sigemptyset\n0x00433B82 | 48 8B 45 F8 | mov     rax, [rbp+set]\n0x00433B86 | BE 11 00 00 00 | mov     esi, 11h; signo\n0x00433B8B | 48 89 C7 | mov     rdi, rax; set\n0x00433B8E | E8 FD 40 FD FF | call    _sigaddset\n0x00433B93 | 48 8B 45 F8 | mov     rax, [rbp+set]\n0x00433B97 | BE 01 00 00 00 | mov     esi, 1; signo\n0x00433B9C | 48 89 C7 | mov     rdi, rax; set\n0x00433B9F | E8 EC 40 FD FF | call    _sigaddset\n0x00433BA4 | 48 8B 45 F8 | mov     rax, [rbp+set]\n0x00433BA8 | BE 0E 00 00 00 | mov     esi, 0Eh; signo\n0x00433BAD | 48 89 C7 | mov     rdi, rax; set\n0x00433BB0 | E8 DB 40 FD FF | call    _sigaddset\n0x00433BB5 | 48 8B 55 F8 | mov     rdx, [rbp+set]; oset\n0x00433BB9 | 48 8B 45 F8 | mov     rax, [rbp+set]\n0x00433BBD | 48 89 C6 | mov     rsi, rax; set\n0x00433BC0 | BF 00 00 00 00 | mov     edi, 0; how\n0x00433BC5 | E8 76 2A FD FF | call    _sigprocmask\n0x00433BCA | 90 | nop\n0x00433BCB | C9 | leave\n0x00433BCC | C3 | retn",
        "output": "",
        "source_code": "static void block_CHLD_HUP_ALRM(sigset_t *m)\n{\n\tsigemptyset(m);\n\tsigaddset(m, SIGCHLD);\n\tsigaddset(m, SIGHUP);\n\tsigaddset(m, SIGALRM);\n\tsigprocmask(SIG_BLOCK, m, m); /* old sigmask is stored in m */\n}",
        "parsed_output": "",
        "baseline_code_stripped": "int __fastcall sub_433B6A(sigset_t *a1)\n{\n  sigemptyset(a1);\n  sigaddset(a1, 17);\n  sigaddset(a1, 1);\n  sigaddset(a1, 14);\n  return sigprocmask(0, a1, a1);\n}\n",
        "baseline_code_debug": "void __cdecl block_CHLD_HUP_ALRM(sigset_t *m)\n{\n  sigemptyset(m);\n  sigaddset(m, 17);\n  sigaddset(m, 1);\n  sigaddset(m, 14);\n  sigprocmask(0, m, m);\n}\n",
        "similarity_score_unixcoder": 0.07367219030857086,
        "similarity_score_baseline_stripped": 0.6758031845092773,
        "similarity_score_baseline_debug": 0.8925818800926208
    },
    {
        "func_name": "add_peers",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043B939 | 55 | push    rbp\n0x0043B93A | 48 89 E5 | mov     rbp, rsp\n0x0043B93D | 48 83 EC 20 | sub     rsp, 20h\n0x0043B941 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0043B945 | BF 70 01 00 00 | mov     edi, 170h\n0x0043B94A | E8 99 E7 FC FF | call    sub_40A0E8\n0x0043B94F | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0043B953 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043B957 | BE 7B 00 00 00 | mov     esi, 7Bh ; '{'\n0x0043B95C | 48 89 C7 | mov     rdi, rax\n0x0043B95F | E8 C6 01 0D 00 | call    sub_50BB2A\n0x0043B964 | 48 89 C2 | mov     rdx, rax\n0x0043B967 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043B96B | 48 89 10 | mov     [rax], rdx\n0x0043B96E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043B972 | 48 8B 00 | mov     rax, [rax]\n0x0043B975 | 48 83 C0 04 | add     rax, 4\n0x0043B979 | 48 89 C7 | mov     rdi, rax\n0x0043B97C | E8 5D 06 0D 00 | call    sub_50BFDE\n0x0043B981 | 48 89 C2 | mov     rdx, rax\n0x0043B984 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043B988 | 48 89 50 08 | mov     [rax+8], rdx\n0x0043B98C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043B990 | C7 40 10 FF FF FF FF | mov     dword ptr [rax+10h], 0FFFFFFFFh\n0x0043B997 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043B99B | C6 80 28 01 00 00 23 | mov     byte ptr [rax+128h], 23h ; '#'\n0x0043B9A2 | 48 8B 05 5F 1A 32 00 | mov     rax, cs:qword_75D408\n0x0043B9A9 | F2 0F 10 00 | movsd   xmm0, qword ptr [rax]\n0x0043B9AD | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043B9B1 | F2 0F 11 40 20 | movsd   qword ptr [rax+20h], xmm0\n0x0043B9B6 | F2 0F 10 05 92 A3 0E 00 | movsd   xmm0, cs:qword_525D50\n0x0043B9BE | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043B9C2 | 48 89 C7 | mov     rdi, rax\n0x0043B9C5 | E8 82 FD FF FF | call    sub_43B74C\n0x0043B9CA | 48 8B 05 37 1A 32 00 | mov     rax, cs:qword_75D408\n0x0043B9D1 | 48 8D 50 30 | lea     rdx, [rax+30h]\n0x0043B9D5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043B9D9 | 48 89 C6 | mov     rsi, rax\n0x0043B9DC | 48 89 D7 | mov     rdi, rdx\n0x0043B9DF | E8 EE D5 FC FF | call    sub_408FD2\n0x0043B9E4 | 48 8B 05 1D 1A 32 00 | mov     rax, cs:qword_75D408\n0x0043B9EB | 8B 50 40 | mov     edx, [rax+40h]\n0x0043B9EE | 83 C2 01 | add     edx, 1\n0x0043B9F1 | 89 50 40 | mov     [rax+40h], edx\n0x0043B9F4 | 90 | nop\n0x0043B9F5 | C9 | leave\n0x0043B9F6 | C3 | retn",
        "output": "",
        "source_code": "static void\nadd_peers(char *s)\n{\n\tpeer_t *p;\n\n\tp = xzalloc(sizeof(*p));\n\tp->p_lsa = xhost2sockaddr(s, 123);\n\tp->p_dotted = xmalloc_sockaddr2dotted_noport(&p->p_lsa->u.sa);\n\tp->p_fd = -1;\n\tp->p_xmt_msg.m_status = MODE_CLIENT | (NTP_VERSION << 3);\n\tp->next_action_time = G.cur_time; /* = set_next(p, 0); */\n\treset_peer_stats(p, 16 * STEP_THRESHOLD);\n\n\tllist_add_to(&G.ntp_peers, p);\n\tG.peer_cnt++;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "void *__fastcall sub_43B939(__int64 a1, __int64 a2)\n{\n  void *result; // rax\n  _QWORD *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40A0E8(0x170uLL, a2);\n  *v3 = sub_50BB2A(a1, 123LL);\n  v3[1] = sub_50BFDE(*v3 + 4LL);\n  *((_DWORD *)v3 + 4) = -1;\n  *((_BYTE *)v3 + 296) = 35;\n  v3[4] = *(_QWORD *)qword_75D408;\n  sub_43B74C((__int64)v3, 2.0);\n  sub_408FD2((_QWORD *)qword_75D408 + 6, (__int64)v3);\n  result = qword_75D408;\n  ++*((_DWORD *)qword_75D408 + 16);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl add_peers(char *s)\n{\n  peer_t *p; // [rsp+18h] [rbp-8h]\n\n  p = (peer_t *)xzalloc(0x170uLL);\n  p->p_lsa = xhost2sockaddr(s, 123);\n  p->p_dotted = xmalloc_sockaddr2dotted_noport(&p->p_lsa->u.sa);\n  p->p_fd = -1;\n  p->p_xmt_msg.m_status = 35;\n  p->next_action_time = *(double *)&ptr_to_globals->timeout;\n  reset_peer_stats(p, 2.0);\n  llist_add_to((llist_t_0 **)&ptr_to_globals->numspeed, p);\n  ++ptr_to_globals->speeds[3];\n}\n",
        "similarity_score_unixcoder": 0.11036654561758041,
        "similarity_score_baseline_stripped": 0.4417601227760315,
        "similarity_score_baseline_debug": 0.8972221612930298
    },
    {
        "func_name": "copy_parsing_escapes",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004E8B82 | 55 | push    rbp\n0x004E8B83 | 48 89 E5 | mov     rbp, rsp\n0x004E8B86 | 48 83 EC 20 | sub     rsp, 20h\n0x004E8B8A | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004E8B8E | 89 75 E4 | mov     [rbp+var_1C], esi\n0x004E8B91 | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x004E8B94 | 83 C0 01 | add     eax, 1\n0x004E8B97 | 48 98 | cdqe\n0x004E8B99 | 48 89 C7 | mov     rdi, rax\n0x004E8B9C | E8 BE 14 F2 FF | call    sub_40A05F\n0x004E8BA1 | 48 89 45 F0 | mov     [rbp+s], rax\n0x004E8BA5 | 48 C7 45 F8 37 6E 52 00 | mov     [rbp+var_8], offset aNTR; \"\\nn\\tt\\rr\"\n0x004E8BAD | EB 4A | jmp     short loc_4E8BF9\n0x004E8BAF | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004E8BB3 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004E8BB6 | 0F BE F8 | movsx   edi, al\n0x004E8BB9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004E8BBD | 48 83 C0 01 | add     rax, 1\n0x004E8BC1 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004E8BC4 | 0F BE C8 | movsx   ecx, al\n0x004E8BC7 | 8B 55 E4 | mov     edx, [rbp+var_1C]\n0x004E8BCA | 48 8B 75 E8 | mov     rsi, [rbp+var_18]\n0x004E8BCE | 48 8B 45 F0 | mov     rax, [rbp+s]\n0x004E8BD2 | 41 89 F8 | mov     r8d, edi\n0x004E8BD5 | 48 89 C7 | mov     rdi, rax\n0x004E8BD8 | E8 B8 FE FF FF | call    sub_4E8A95\n0x004E8BDD | 48 8B 45 F0 | mov     rax, [rbp+s]\n0x004E8BE1 | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x004E8BE5 | 48 8B 45 F0 | mov     rax, [rbp+s]\n0x004E8BE9 | 48 89 C7 | mov     rdi, rax; s\n0x004E8BEC | E8 DF DE F1 FF | call    _strlen\n0x004E8BF1 | 89 45 E4 | mov     [rbp+var_1C], eax\n0x004E8BF4 | 48 83 45 F8 02 | add     [rbp+var_8], 2\n0x004E8BF9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004E8BFD | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004E8C00 | 84 C0 | test    al, al\n0x004E8C02 | 75 AB | jnz     short loc_4E8BAF\n0x004E8C04 | 48 8B 45 F0 | mov     rax, [rbp+s]\n0x004E8C08 | C9 | leave\n0x004E8C09 | C3 | retn",
        "output": "",
        "source_code": "static char *copy_parsing_escapes(const char *string, int len)\n{\n\tconst char *s;\n\tchar *dest = xmalloc(len + 1);\n\n\t/* sed recognizes \\n */\n\t/* GNU sed also recognizes \\t and \\r */\n\tfor (s = \"\\nn\\tt\\rr\"; *s; s += 2) {\n\t\tparse_escapes(dest, string, len, s[1], s[0]);\n\t\tstring = dest;\n\t\tlen = strlen(dest);\n\t}\n\treturn dest;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "char *__fastcall sub_4E8B82(__int64 a1, __int64 a2)\n{\n  int v3; // [rsp+4h] [rbp-1Ch]\n  char *s; // [rsp+10h] [rbp-10h]\n  const char *i; // [rsp+18h] [rbp-8h]\n\n  v3 = a2;\n  s = (char *)sub_40A05F((int)a2 + 1, a2);\n  for ( i = \"\\nn\\tt\\rr\"; *i; i += 2 )\n  {\n    sub_4E8A95(s, a1, v3, i[1], *i);\n    a1 = (__int64)s;\n    v3 = strlen(s);\n  }\n  return s;\n}\n",
        "baseline_code_debug": "char *__cdecl copy_parsing_escapes(const char *string, int len)\n{\n  int lena; // [rsp+4h] [rbp-1Ch]\n  char *dest; // [rsp+10h] [rbp-10h]\n  const char *s; // [rsp+18h] [rbp-8h]\n\n  lena = len;\n  dest = (char *)xmalloc(len + 1);\n  for ( s = \"\\nn\\tt\\rr\"; *s; s += 2 )\n  {\n    parse_escapes(dest, string, lena, s[1], *s);\n    string = dest;\n    lena = strlen(dest);\n  }\n  return dest;\n}\n",
        "similarity_score_unixcoder": 0.01247267797589302,
        "similarity_score_baseline_stripped": 0.5210120677947998,
        "similarity_score_baseline_debug": 0.8597697615623474
    },
    {
        "func_name": "nvalloc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004DCDF7 | 55 | push    rbp\n0x004DCDF8 | 48 89 E5 | mov     rbp, rsp\n0x004DCDFB | 53 | push    rbx\n0x004DCDFC | 48 83 EC 38 | sub     rsp, 38h\n0x004DCE00 | 89 7D CC | mov     [rbp+var_34], edi\n0x004DCE03 | 48 C7 45 E8 00 00 00 00 | mov     [rbp+var_18], 0\n0x004DCE0B | E9 A5 00 00 00 | jmp     loc_4DCEB5\n0x004DCE10 | 48 8B 05 F1 05 28 00 | mov     rax, cs:qword_75D408\n0x004DCE17 | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DCE1D | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]\n0x004DCE24 | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x004DCE28 | 48 8B 05 D9 05 28 00 | mov     rax, cs:qword_75D408\n0x004DCE2F | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DCE35 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]\n0x004DCE3C | 48 8B 40 08 | mov     rax, [rax+8]\n0x004DCE40 | 48 8B 15 C1 05 28 00 | mov     rdx, cs:qword_75D408\n0x004DCE47 | 48 81 EA D0 00 00 00 | sub     rdx, 0D0h\n0x004DCE4E | 48 8B 92 B0 00 00 00 | mov     rdx, [rdx+0B0h]\n0x004DCE55 | 48 83 C2 20 | add     rdx, 20h ; ' '\n0x004DCE59 | 48 29 D0 | sub     rax, rdx\n0x004DCE5C | 48 C1 F8 05 | sar     rax, 5\n0x004DCE60 | 48 89 C2 | mov     rdx, rax\n0x004DCE63 | 8B 45 CC | mov     eax, [rbp+var_34]\n0x004DCE66 | 48 98 | cdqe\n0x004DCE68 | 48 01 C2 | add     rdx, rax\n0x004DCE6B | 48 8B 05 96 05 28 00 | mov     rax, cs:qword_75D408\n0x004DCE72 | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DCE78 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]\n0x004DCE7F | 8B 00 | mov     eax, [rax]\n0x004DCE81 | 48 98 | cdqe\n0x004DCE83 | 48 39 C2 | cmp     rdx, rax\n0x004DCE86 | 7E 4C | jle     short loc_4DCED4\n0x004DCE88 | 48 8B 05 79 05 28 00 | mov     rax, cs:qword_75D408\n0x004DCE8F | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DCE95 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]\n0x004DCE9C | 48 8B 15 65 05 28 00 | mov     rdx, cs:qword_75D408\n0x004DCEA3 | 48 81 EA D0 00 00 00 | sub     rdx, 0D0h\n0x004DCEAA | 48 8B 40 18 | mov     rax, [rax+18h]\n0x004DCEAE | 48 89 82 B0 00 00 00 | mov     [rdx+0B0h], rax\n0x004DCEB5 | 48 8B 05 4C 05 28 00 | mov     rax, cs:qword_75D408\n0x004DCEBC | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DCEC2 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]\n0x004DCEC9 | 48 85 C0 | test    rax, rax\n0x004DCECC | 0F 85 3E FF FF FF | jnz     loc_4DCE10\n0x004DCED2 | EB 01 | jmp     short loc_4DCED5\n0x004DCED4 | 90 | nop\n0x004DCED5 | 48 8B 05 2C 05 28 00 | mov     rax, cs:qword_75D408\n0x004DCEDC | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DCEE2 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]\n0x004DCEE9 | 48 85 C0 | test    rax, rax\n0x004DCEEC | 0F 85 C2 00 00 00 | jnz     loc_4DCFB4\n0x004DCEF2 | B8 40 00 00 00 | mov     eax, 40h ; '@'\n0x004DCEF7 | 83 7D CC 40 | cmp     [rbp+var_34], 40h ; '@'\n0x004DCEFB | 0F 4D 45 CC | cmovge  eax, [rbp+var_34]\n0x004DCEFF | 89 45 DC | mov     [rbp+var_24], eax\n0x004DCF02 | 8B 45 DC | mov     eax, [rbp+var_24]\n0x004DCF05 | 48 98 | cdqe\n0x004DCF07 | 48 83 C0 01 | add     rax, 1\n0x004DCF0B | 48 C1 E0 05 | shl     rax, 5\n0x004DCF0F | 48 8B 15 F2 04 28 00 | mov     rdx, cs:qword_75D408\n0x004DCF16 | 48 8D 9A 30 FF FF FF | lea     rbx, [rdx-0D0h]\n0x004DCF1D | 48 89 C7 | mov     rdi, rax\n0x004DCF20 | E8 C3 D1 F2 FF | call    sub_40A0E8\n0x004DCF25 | 48 89 83 B0 00 00 00 | mov     [rbx+0B0h], rax\n0x004DCF2C | 48 8B 05 D5 04 28 00 | mov     rax, cs:qword_75D408\n0x004DCF33 | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DCF39 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]\n0x004DCF40 | 8B 55 DC | mov     edx, [rbp+var_24]\n0x004DCF43 | 89 10 | mov     [rax], edx\n0x004DCF45 | 48 8B 05 BC 04 28 00 | mov     rax, cs:qword_75D408\n0x004DCF4C | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DCF52 | 48 8B 90 B0 00 00 00 | mov     rdx, [rax+0B0h]\n0x004DCF59 | 48 8B 05 A8 04 28 00 | mov     rax, cs:qword_75D408\n0x004DCF60 | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DCF66 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]\n0x004DCF6D | 48 83 C2 20 | add     rdx, 20h ; ' '\n0x004DCF71 | 48 89 50 08 | mov     [rax+8], rdx\n0x004DCF75 | 48 8B 05 8C 04 28 00 | mov     rax, cs:qword_75D408\n0x004DCF7C | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DCF82 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]\n0x004DCF89 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x004DCF8D | 48 89 50 10 | mov     [rax+10h], rdx\n0x004DCF91 | 48 83 7D E8 00 | cmp     [rbp+var_18], 0\n0x004DCF96 | 74 1C | jz      short loc_4DCFB4\n0x004DCF98 | 48 8B 05 69 04 28 00 | mov     rax, cs:qword_75D408\n0x004DCF9F | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DCFA5 | 48 8B 90 B0 00 00 00 | mov     rdx, [rax+0B0h]\n0x004DCFAC | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DCFB0 | 48 89 50 18 | mov     [rax+18h], rdx\n0x004DCFB4 | 48 8B 05 4D 04 28 00 | mov     rax, cs:qword_75D408\n0x004DCFBB | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DCFC1 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]\n0x004DCFC8 | 48 8B 40 08 | mov     rax, [rax+8]\n0x004DCFCC | 48 89 45 D0 | mov     [rbp+var_30], rax\n0x004DCFD0 | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x004DCFD4 | 48 89 45 E0 | mov     [rbp+var_20], rax\n0x004DCFD8 | 48 8B 05 29 04 28 00 | mov     rax, cs:qword_75D408\n0x004DCFDF | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DCFE5 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]\n0x004DCFEC | 48 8B 50 08 | mov     rdx, [rax+8]\n0x004DCFF0 | 8B 45 CC | mov     eax, [rbp+var_34]\n0x004DCFF3 | 48 98 | cdqe\n0x004DCFF5 | 48 C1 E0 05 | shl     rax, 5\n0x004DCFF9 | 48 89 C1 | mov     rcx, rax\n0x004DCFFC | 48 8B 05 05 04 28 00 | mov     rax, cs:qword_75D408\n0x004DD003 | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DD009 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]\n0x004DD010 | 48 01 CA | add     rdx, rcx\n0x004DD013 | 48 89 50 08 | mov     [rax+8], rdx\n0x004DD017 | EB 1B | jmp     short loc_4DD034\n0x004DD019 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004DD01D | C7 00 00 00 00 00 | mov     dword ptr [rax], 0\n0x004DD023 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004DD027 | 48 C7 40 10 00 00 00 00 | mov     qword ptr [rax+10h], 0\n0x004DD02F | 48 83 45 E0 20 | add     [rbp+var_20], 20h ; ' '\n0x004DD034 | 48 8B 05 CD 03 28 00 | mov     rax, cs:qword_75D408\n0x004DD03B | 48 2D D0 00 00 00 | sub     rax, 0D0h\n0x004DD041 | 48 8B 80 B0 00 00 00 | mov     rax, [rax+0B0h]\n0x004DD048 | 48 8B 40 08 | mov     rax, [rax+8]\n0x004DD04C | 48 39 45 E0 | cmp     [rbp+var_20], rax\n0x004DD050 | 72 C7 | jb      short loc_4DD019\n0x004DD052 | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x004DD056 | 48 83 C4 38 | add     rsp, 38h\n0x004DD05A | 5B | pop     rbx\n0x004DD05B | 5D | pop     rbp\n0x004DD05C | C3 | retn",
        "output": "",
        "source_code": "static var *nvalloc(int n)\n{\n\tnvblock *pb = NULL;\n\tvar *v, *r;\n\tint size;\n\n\twhile (g_cb) {\n\t\tpb = g_cb;\n\t\tif ((g_cb->pos - g_cb->nv) + n <= g_cb->size)\n\t\t\tbreak;\n\t\tg_cb = g_cb->next;\n\t}\n\n\tif (!g_cb) {\n\t\tsize = (n <= MINNVBLOCK) ? MINNVBLOCK : n;\n\t\tg_cb = xzalloc(sizeof(nvblock) + size * sizeof(var));\n\t\tg_cb->size = size;\n\t\tg_cb->pos = g_cb->nv;\n\t\tg_cb->prev = pb;\n\t\t/*g_cb->next = NULL; - xzalloc did it */\n\t\tif (pb)\n\t\t\tpb->next = g_cb;\n\t}\n\n\tv = r = g_cb->pos;\n\tg_cb->pos += n;\n\n\twhile (v < g_cb->pos) {\n\t\tv->type = 0;\n\t\tv->string = NULL;\n\t\tv++;\n\t}\n\n\treturn r;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "unsigned __int64 __fastcall sub_4DCDF7(int a1, __int64 a2)\n{\n  int v2; // eax\n  char *v3; // rbx\n  unsigned __int64 v5; // [rsp+10h] [rbp-30h]\n  int v6; // [rsp+1Ch] [rbp-24h]\n  unsigned __int64 v7; // [rsp+20h] [rbp-20h]\n  int *v8; // [rsp+28h] [rbp-18h]\n\n  v8 = 0LL;\n  while ( *((_QWORD *)qword_75D408 - 4) )\n  {\n    v8 = (int *)*((_QWORD *)qword_75D408 - 4);\n    if ( a1 + ((__int64)(*((_QWORD *)v8 + 1) - (_QWORD)(v8 + 8)) >> 5) <= *v8 )\n      break;\n    *((_QWORD *)qword_75D408 - 4) = *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 24LL);\n  }\n  if ( !*((_QWORD *)qword_75D408 - 4) )\n  {\n    v2 = 64;\n    if ( a1 >= 64 )\n      v2 = a1;\n    v6 = v2;\n    v3 = (char *)qword_75D408 - 208;\n    *((_QWORD *)v3 + 22) = sub_40A0E8(32 * (v2 + 1LL), a2);\n    **((_DWORD **)qword_75D408 - 4) = v6;\n    *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) = *((_QWORD *)qword_75D408 - 4) + 32LL;\n    *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 16LL) = v8;\n    if ( v8 )\n      *((_QWORD *)v8 + 3) = *((_QWORD *)qword_75D408 - 4);\n  }\n  v5 = *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL);\n  v7 = v5;\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) = 32LL * a1 + v5;\n  while ( v7 < *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) )\n  {\n    *(_DWORD *)v7 = 0;\n    *(_QWORD *)(v7 + 16) = 0LL;\n    v7 += 32LL;\n  }\n  return v5;\n}\n",
        "baseline_code_debug": "var_0 *__cdecl nvalloc(int n)\n{\n  int v1; // eax\n  int *v2; // rbx\n  var_0 *r; // [rsp+10h] [rbp-30h]\n  int size; // [rsp+1Ch] [rbp-24h]\n  var_0 *v; // [rsp+20h] [rbp-20h]\n  nvblock *pb; // [rsp+28h] [rbp-18h]\n\n  pb = 0LL;\n  while ( *(_QWORD *)&ptr_to_globals[-1].line_buf[100] )\n  {\n    pb = *(nvblock **)&ptr_to_globals[-1].line_buf[100];\n    if ( n + pb->pos - pb->nv <= pb->size )\n      break;\n    *(_QWORD *)&ptr_to_globals[-1].line_buf[100] = *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 24LL);\n  }\n  if ( !*(_QWORD *)&ptr_to_globals[-1].line_buf[100] )\n  {\n    v1 = 64;\n    if ( n >= 64 )\n      v1 = n;\n    size = v1;\n    v2 = &ptr_to_globals[-1].speeds[7];\n    *((_QWORD *)v2 + 22) = xzalloc(32 * (v1 + 1LL));\n    **(_DWORD **)&ptr_to_globals[-1].line_buf[100] = size;\n    *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 8LL) = *(_QWORD *)&ptr_to_globals[-1].line_buf[100]\n                                                                    + 32LL;\n    *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 16LL) = pb;\n    if ( pb )\n      pb->next = *(nvblock_s **)&ptr_to_globals[-1].line_buf[100];\n  }\n  r = *(var_0 **)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 8LL);\n  v = r;\n  *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 8LL) = &r[n];\n  while ( (unsigned __int64)v < *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 8LL) )\n  {\n    v->type = 0;\n    v->string = 0LL;\n    ++v;\n  }\n  return r;\n}\n",
        "similarity_score_unixcoder": 0.057849280536174774,
        "similarity_score_baseline_stripped": 0.4669768214225769,
        "similarity_score_baseline_debug": 0.7178249359130859
    },
    {
        "func_name": "rmoldest",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0046BA5F | 55 | push    rbp\n0x0046BA60 | 48 89 E5 | mov     rbp, rsp\n0x0046BA63 | 48 83 EC 50 | sub     rsp, 50h\n0x0046BA67 | 48 89 7D B8 | mov     [rbp+var_48], rdi\n0x0046BA6B | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x0046BA72 | C6 45 C0 41 | mov     [rbp+s2], 41h ; 'A'\n0x0046BA76 | C6 45 DB 00 | mov     [rbp+var_25], 0\n0x0046BA7A | 0F B6 45 DB | movzx   eax, [rbp+var_25]\n0x0046BA7E | 88 45 C1 | mov     [rbp+var_3F], al\n0x0046BA81 | EB 15 | jmp     short loc_46BA98\n0x0046BA83 | 48 8B 45 B8 | mov     rax, [rbp+var_48]\n0x0046BA87 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x0046BA8B | 48 89 C6 | mov     rsi, rax\n0x0046BA8E | BF FC 62 52 00 | mov     edi, offset aOpenDirectoryW; \"open directory, want rotate\"\n0x0046BA93 | E8 1E F8 FF FF | call    sub_46B2B6\n0x0046BA98 | BF 18 63 52 00 | mov     edi, offset asc_526318; \".\"\n0x0046BA9D | E8 8E AF F9 FF | call    _opendir\n0x0046BAA2 | 48 89 45 F0 | mov     [rbp+dirp], rax\n0x0046BAA6 | 48 83 7D F0 00 | cmp     [rbp+dirp], 0\n0x0046BAAB | 74 D6 | jz      short loc_46BA83\n0x0046BAAD | 48 8B 05 4C 19 2F 00 | mov     rax, cs:qword_75D400\n0x0046BAB4 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0\n0x0046BABA | E9 AA 00 00 00 | jmp     loc_46BB69\n0x0046BABF | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0046BAC3 | 0F B6 40 13 | movzx   eax, byte ptr [rax+13h]\n0x0046BAC7 | 3C 40 | cmp     al, 40h ; '@'\n0x0046BAC9 | 0F 85 9A 00 00 00 | jnz     loc_46BB69\n0x0046BACF | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0046BAD3 | 48 83 C0 13 | add     rax, 13h\n0x0046BAD7 | 48 89 C7 | mov     rdi, rax; s\n0x0046BADA | E8 F1 AF F9 FF | call    _strlen\n0x0046BADF | 48 83 F8 1B | cmp     rax, 1Bh\n0x0046BAE3 | 0F 85 80 00 00 00 | jnz     loc_46BB69\n0x0046BAE9 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0046BAED | 0F B6 40 2D | movzx   eax, byte ptr [rax+2Dh]\n0x0046BAF1 | 3C 74 | cmp     al, 74h ; 't'\n0x0046BAF3 | 75 2C | jnz     short loc_46BB21\n0x0046BAF5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0046BAF9 | 48 83 C0 13 | add     rax, 13h\n0x0046BAFD | 48 89 C7 | mov     rdi, rax; name\n0x0046BB00 | E8 4B AC F9 FF | call    _unlink\n0x0046BB05 | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x0046BB08 | 75 52 | jnz     short loc_46BB5C\n0x0046BB0A | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0046BB0E | 48 83 C0 13 | add     rax, 13h\n0x0046BB12 | 48 89 C6 | mov     rsi, rax\n0x0046BB15 | BF 20 63 52 00 | mov     edi, offset aCanTUnlinkProc; \"can't unlink processor leftover\"\n0x0046BB1A | E8 EE F6 FF FF | call    sub_46B20D\n0x0046BB1F | EB 3B | jmp     short loc_46BB5C\n0x0046BB21 | 83 45 FC 01 | add     [rbp+var_4], 1\n0x0046BB25 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0046BB29 | 48 8D 50 13 | lea     rdx, [rax+13h]\n0x0046BB2D | 48 8D 45 C0 | lea     rax, [rbp+s2]\n0x0046BB31 | 48 89 C6 | mov     rsi, rax; s2\n0x0046BB34 | 48 89 D7 | mov     rdi, rdx; s1\n0x0046BB37 | E8 14 B5 F9 FF | call    _strcmp\n0x0046BB3C | 85 C0 | test    eax, eax\n0x0046BB3E | 79 1C | jns     short loc_46BB5C\n0x0046BB40 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0046BB44 | 48 8D 48 13 | lea     rcx, [rax+13h]\n0x0046BB48 | 48 8D 45 C0 | lea     rax, [rbp+s2]\n0x0046BB4C | BA 1B 00 00 00 | mov     edx, 1Bh; n\n0x0046BB51 | 48 89 CE | mov     rsi, rcx; src\n0x0046BB54 | 48 89 C7 | mov     rdi, rax; dest\n0x0046BB57 | E8 44 B6 F9 FF | call    _memcpy\n0x0046BB5C | 48 8B 05 9D 18 2F 00 | mov     rax, cs:qword_75D400\n0x0046BB63 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0\n0x0046BB69 | 48 8B 45 F0 | mov     rax, [rbp+dirp]\n0x0046BB6D | 48 89 C7 | mov     rdi, rax; dirp\n0x0046BB70 | E8 AB BB F9 FF | call    _readdir64\n0x0046BB75 | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x0046BB79 | 48 83 7D E8 00 | cmp     [rbp+var_18], 0\n0x0046BB7E | 0F 85 3B FF FF FF | jnz     loc_46BABF\n0x0046BB84 | 48 8B 05 75 18 2F 00 | mov     rax, cs:qword_75D400\n0x0046BB8B | 8B 00 | mov     eax, [rax]\n0x0046BB8D | 85 C0 | test    eax, eax\n0x0046BB8F | 74 15 | jz      short loc_46BBA6\n0x0046BB91 | 48 8B 45 B8 | mov     rax, [rbp+var_48]\n0x0046BB95 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x0046BB99 | 48 89 C6 | mov     rsi, rax\n0x0046BB9C | BF 40 63 52 00 | mov     edi, offset aCanTReadDirect; \"can't read directory\"\n0x0046BBA1 | E8 67 F6 FF FF | call    sub_46B20D\n0x0046BBA6 | 48 8B 45 F0 | mov     rax, [rbp+dirp]\n0x0046BBAA | 48 89 C7 | mov     rdi, rax; dirp\n0x0046BBAD | E8 DE B2 F9 FF | call    _closedir\n0x0046BBB2 | 48 8B 45 B8 | mov     rax, [rbp+var_48]\n0x0046BBB6 | 8B 40 20 | mov     eax, [rax+20h]\n0x0046BBB9 | 85 C0 | test    eax, eax\n0x0046BBBB | 74 68 | jz      short loc_46BC25\n0x0046BBBD | 48 8B 45 B8 | mov     rax, [rbp+var_48]\n0x0046BBC1 | 8B 50 20 | mov     edx, [rax+20h]\n0x0046BBC4 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0046BBC7 | 39 C2 | cmp     edx, eax\n0x0046BBC9 | 73 5A | jnb     short loc_46BC25\n0x0046BBCB | 48 8B 05 36 18 2F 00 | mov     rax, cs:qword_75D408\n0x0046BBD2 | 8B 40 08 | mov     eax, [rax+8]\n0x0046BBD5 | 85 C0 | test    eax, eax\n0x0046BBD7 | 74 1E | jz      short loc_46BBF7\n0x0046BBD9 | 48 8B 45 B8 | mov     rax, [rbp+var_48]\n0x0046BBDD | 48 8B 40 10 | mov     rax, [rax+10h]\n0x0046BBE1 | 48 8D 55 C0 | lea     rdx, [rbp+s2]\n0x0046BBE5 | 48 89 C6 | mov     rsi, rax\n0x0046BBE8 | BF 55 63 52 00 | mov     edi, offset aInfoDeleteSS; \"info: delete: %s/%s\"\n0x0046BBED | B8 00 00 00 00 | mov     eax, 0\n0x0046BBF2 | E8 50 DB F9 FF | call    sub_409747\n0x0046BBF7 | 0F B6 45 C0 | movzx   eax, [rbp+s2]\n0x0046BBFB | 3C 40 | cmp     al, 40h ; '@'\n0x0046BBFD | 75 26 | jnz     short loc_46BC25\n0x0046BBFF | 48 8D 45 C0 | lea     rax, [rbp+s2]\n0x0046BC03 | 48 89 C7 | mov     rdi, rax; name\n0x0046BC06 | E8 45 AB F9 FF | call    _unlink\n0x0046BC0B | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x0046BC0E | 75 15 | jnz     short loc_46BC25\n0x0046BC10 | 48 8B 45 B8 | mov     rax, [rbp+var_48]\n0x0046BC14 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x0046BC18 | 48 89 C6 | mov     rsi, rax\n0x0046BC1B | BF 69 63 52 00 | mov     edi, offset aCanTUnlinkOlde; \"can't unlink oldest logfile\"\n0x0046BC20 | E8 E8 F5 FF FF | call    sub_46B20D\n0x0046BC25 | 90 | nop\n0x0046BC26 | C9 | leave\n0x0046BC27 | C3 | retn",
        "output": "",
        "source_code": "static void rmoldest(struct logdir *ld)\n{\n\tDIR *d;\n\tstruct dirent *f;\n\tchar oldest[FMT_PTIME];\n\tint n = 0;\n\n\toldest[0] = 'A'; oldest[1] = oldest[27] = 0;\n\twhile (!(d = opendir(\".\")))\n\t\tpause2cannot(\"open directory, want rotate\", ld->name);\n\terrno = 0;\n\twhile ((f = readdir(d))) {\n\t\tif ((f->d_name[0] == '@') && (strlen(f->d_name) == 27)) {\n\t\t\tif (f->d_name[26] == 't') {\n\t\t\t\tif (unlink(f->d_name) == -1)\n\t\t\t\t\twarn2(\"can't unlink processor leftover\", f->d_name);\n\t\t\t} else {\n\t\t\t\t++n;\n\t\t\t\tif (strcmp(f->d_name, oldest) < 0)\n\t\t\t\t\tmemcpy(oldest, f->d_name, 27);\n\t\t\t}\n\t\t\terrno = 0;\n\t\t}\n\t}\n\tif (errno)\n\t\twarn2(\"can't read directory\", ld->name);\n\tclosedir(d);\n\n\tif (ld->nmax && (n > ld->nmax)) {\n\t\tif (verbose)\n\t\t\tbb_error_msg(INFO\"delete: %s/%s\", ld->name, oldest);\n\t\tif ((*oldest == '@') && (unlink(oldest) == -1))\n\t\t\twarn2(\"can't unlink oldest logfile\", ld->name);\n\t}\n}",
        "parsed_output": "",
        "baseline_code_stripped": "int __fastcall sub_46BA5F(__int64 a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  __int64 v5; // rdx\n  __int64 v6; // rcx\n  __int64 v7; // r8\n  __int64 v8; // r9\n  __int64 v9; // rdx\n  __int64 v10; // rcx\n  __int64 v11; // r8\n  __int64 v12; // r9\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  int result; // eax\n  __int64 v17; // rdx\n  __int64 v18; // rcx\n  __int64 v19; // r8\n  __int64 v20; // r9\n  char s2[40]; // [rsp+10h] [rbp-40h] BYREF\n  struct dirent64 *v22; // [rsp+38h] [rbp-18h]\n  DIR *dirp; // [rsp+40h] [rbp-10h]\n  unsigned int v24; // [rsp+4Ch] [rbp-4h]\n\n  v24 = 0;\n  strcpy(s2, \"A\");\n  s2[27] = 0;\n  while ( 1 )\n  {\n    dirp = opendir(\".\");\n    if ( dirp )\n      break;\n    sub_46B2B6((__int64)\"open directory, want rotate\", *(_QWORD *)(a1 + 16), v1, v2, v3, v4);\n  }\n  *(_DWORD *)qword_75D400 = 0;\n  while ( 1 )\n  {\n    v22 = readdir64(dirp);\n    if ( !v22 )\n      break;\n    if ( v22->d_name[0] == 64 && strlen(v22->d_name) == 27 )\n    {\n      if ( v22->d_name[26] == 116 )\n      {\n        if ( unlink(v22->d_name) == -1 )\n          sub_46B20D((__int64)\"can't unlink processor leftover\", (__int64)v22->d_name, v5, v6, v7, v8);\n      }\n      else\n      {\n        ++v24;\n        if ( strcmp(v22->d_name, s2) < 0 )\n          memcpy(s2, v22->d_name, 0x1BuLL);\n      }\n      *(_DWORD *)qword_75D400 = 0;\n    }\n  }\n  if ( *(_DWORD *)qword_75D400 )\n    sub_46B20D((__int64)\"can't read directory\", *(_QWORD *)(a1 + 16), v9, v10, v11, v12);\n  closedir(dirp);\n  result = *(_DWORD *)(a1 + 32);\n  if ( result )\n  {\n    result = v24;\n    if ( *(_DWORD *)(a1 + 32) < v24 )\n    {\n      if ( *((_DWORD *)qword_75D408 + 2) )\n        sub_409747(\"info: delete: %s/%s\", *(_QWORD *)(a1 + 16), (__int64)s2, v13, v14, v15);\n      result = (unsigned __int8)s2[0];\n      if ( s2[0] == 64 )\n      {\n        result = unlink(s2);\n        if ( result == -1 )\n          return sub_46B20D((__int64)\"can't unlink oldest logfile\", *(_QWORD *)(a1 + 16), v17, v18, v19, v20);\n      }\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl rmoldest(logdir *ld)\n{\n  char oldest[30]; // [rsp+10h] [rbp-40h] BYREF\n  dirent *f; // [rsp+38h] [rbp-18h]\n  DIR *d; // [rsp+40h] [rbp-10h]\n  int n; // [rsp+4Ch] [rbp-4h]\n\n  n = 0;\n  strcpy(oldest, \"A\");\n  oldest[27] = 0;\n  while ( 1 )\n  {\n    d = opendir(\".\");\n    if ( d )\n      break;\n    pause2cannot(\"open directory, want rotate\", ld->name);\n  }\n  *bb_errno = 0;\n  while ( 1 )\n  {\n    f = (dirent *)readdir64(d);\n    if ( !f )\n      break;\n    if ( f->d_name[0] == 64 && strlen(f->d_name) == 27 )\n    {\n      if ( f->d_name[26] == 116 )\n      {\n        if ( unlink(f->d_name) == -1 )\n          warn2(\"can't unlink processor leftover\", f->d_name);\n      }\n      else\n      {\n        ++n;\n        if ( strcmp(f->d_name, oldest) < 0 )\n          memcpy(oldest, f->d_name, 0x1BuLL);\n      }\n      *bb_errno = 0;\n    }\n  }\n  if ( *bb_errno )\n    warn2(\"can't read directory\", ld->name);\n  closedir(d);\n  if ( ld->nmax && ld->nmax < n )\n  {\n    if ( LODWORD(ptr_to_globals->login) )\n      bb_error_msg(\"info: delete: %s/%s\", ld->name, oldest);\n    if ( oldest[0] == 64 && unlink(oldest) == -1 )\n      warn2(\"can't unlink oldest logfile\", ld->name);\n  }\n}\n",
        "similarity_score_unixcoder": 0.010221562348306179,
        "similarity_score_baseline_stripped": 0.5733007788658142,
        "similarity_score_baseline_debug": 0.9122466444969177
    },
    {
        "func_name": "restore_state_and_exit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0044076F | 55 | push    rbp\n0x00440770 | 48 89 E5 | mov     rbp, rsp\n0x00440773 | 48 83 EC 50 | sub     rsp, 50h\n0x00440777 | 89 7D BC | mov     [rbp+status], edi\n0x0044077A | BA FC B3 75 00 | mov     edx, 75B3FCh\n0x0044077F | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00440784 | 8B 00 | mov     eax, [rax]\n0x00440786 | B9 E4 5A 53 00 | mov     ecx, offset aTiocsetd; \"TIOCSETD\"\n0x0044078B | BE 23 54 00 00 | mov     esi, 5423h\n0x00440790 | 89 C7 | mov     edi, eax\n0x00440792 | E8 71 A5 FC FF | call    sub_40AD08\n0x00440797 | 85 C0 | test    eax, eax\n0x00440799 | 79 07 | jns     short loc_4407A2\n0x0044079B | C7 45 BC 01 00 00 00 | mov     [rbp+status], 1\n0x004407A2 | B8 00 B4 75 00 | mov     eax, offset dest.c_cflag\n0x004407A7 | 48 8B 10 | mov     rdx, [rax]\n0x004407AA | 48 8B 48 08 | mov     rcx, [rax+8]\n0x004407AE | 48 89 55 C0 | mov     qword ptr [rbp+termios_p.c_iflag], rdx\n0x004407B2 | 48 89 4D C8 | mov     qword ptr [rbp+termios_p.c_cflag], rcx\n0x004407B6 | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x004407BA | 48 8B 48 18 | mov     rcx, [rax+18h]\n0x004407BE | 48 89 55 D0 | mov     qword ptr [rbp+termios_p.c_line], rdx\n0x004407C2 | 48 89 4D D8 | mov     qword ptr [rbp+termios_p.c_cc+7], rcx\n0x004407C6 | 48 8B 50 20 | mov     rdx, [rax+20h]\n0x004407CA | 48 8B 48 28 | mov     rcx, [rax+28h]\n0x004407CE | 48 89 55 E0 | mov     qword ptr [rbp+termios_p.c_cc+0Fh], rdx\n0x004407D2 | 48 89 4D E8 | mov     qword ptr [rbp+termios_p.c_cc+17h], rcx\n0x004407D6 | 48 8B 50 30 | mov     rdx, [rax+30h]\n0x004407DA | 48 89 55 F0 | mov     qword ptr [rbp+termios_p.c_cc+1Fh], rdx\n0x004407DE | 8B 40 38 | mov     eax, [rax+38h]\n0x004407E1 | 89 45 F8 | mov     [rbp+termios_p.c_ospeed], eax\n0x004407E4 | 48 8D 45 C0 | lea     rax, [rbp+termios_p]\n0x004407E8 | BE 00 00 00 00 | mov     esi, 0; speed\n0x004407ED | 48 89 C7 | mov     rdi, rax; termios_p\n0x004407F0 | E8 5B 70 FC FF | call    _cfsetispeed\n0x004407F5 | 48 8D 45 C0 | lea     rax, [rbp+termios_p]\n0x004407F9 | BE 00 00 00 00 | mov     esi, 0; speed\n0x004407FE | 48 89 C7 | mov     rdi, rax; termios_p\n0x00440801 | E8 8A 62 FC FF | call    _cfsetospeed\n0x00440806 | 48 8D 45 C0 | lea     rax, [rbp+termios_p]\n0x0044080A | 48 89 C7 | mov     rdi, rax\n0x0044080D | E8 14 FF FF FF | call    sub_440726\n0x00440812 | 85 C0 | test    eax, eax\n0x00440814 | 74 07 | jz      short loc_44081D\n0x00440816 | C7 45 BC 01 00 00 00 | mov     [rbp+status], 1\n0x0044081D | BF 01 00 00 00 | mov     edi, 1; seconds\n0x00440822 | E8 19 74 FC FF | call    _sleep\n0x00440827 | B8 00 B4 75 00 | mov     eax, offset dest.c_cflag\n0x0044082C | 48 89 C7 | mov     rdi, rax\n0x0044082F | E8 F2 FE FF FF | call    sub_440726\n0x00440834 | 85 C0 | test    eax, eax\n0x00440836 | 74 0A | jz      short loc_440842\n0x00440838 | BF 01 00 00 00 | mov     edi, 1; status\n0x0044083D | E8 7E 72 FC FF | call    _exit\n0x00440842 | 8B 45 BC | mov     eax, [rbp+status]\n0x00440845 | 89 C7 | mov     edi, eax; status\n0x00440847 | E8 74 72 FC FF | call    _exit",
        "output": "\n",
        "source_code": "static void restore_state_and_exit(int exitcode)\n{\n\tstruct termios state;\n\n\t/* Restore line discipline */\n\tif (ioctl_or_warn(handle, TIOCSETD, &saved_disc) < 0) {\n\t\texitcode = 1;\n\t}\n\n\t/* Hangup */\n\tmemcpy(&state, &saved_state, sizeof(state));\n\tcfsetispeed(&state, B0);\n\tcfsetospeed(&state, B0);\n\tif (set_termios_state_or_warn(&state))\n\t\texitcode = 1;\n\tsleep(1);\n\n\t/* Restore line status */\n\tif (set_termios_state_or_warn(&saved_state))\n\t\texit(EXIT_FAILURE);\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tclose(handle);\n\n\texit(exitcode);\n}",
        "parsed_output": "\n",
        "baseline_code_stripped": "void __fastcall __noreturn sub_44076F(int a1)\n{\n  __int64 v1; // rcx\n  __int64 v2; // rcx\n  __int64 v3; // rcx\n  struct termios termios_p; // [rsp+10h] [rbp-40h] BYREF\n\n  if ( (int)sub_40AD08(dest.c_iflag, 0x5423u, 7713788LL, (__int64)\"TIOCSETD\") < 0 )\n    a1 = 1;\n  v1 = *(_QWORD *)&dest.c_line;\n  *(_QWORD *)&termios_p.c_iflag = *(_QWORD *)&dest.c_cflag;\n  *(_QWORD *)&termios_p.c_cflag = v1;\n  v2 = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&termios_p.c_line = *(_QWORD *)&dest.c_cc[7];\n  *(_QWORD *)&termios_p.c_cc[7] = v2;\n  v3 = *(_QWORD *)&dest.c_cc[31];\n  *(_QWORD *)&termios_p.c_cc[15] = *(_QWORD *)&dest.c_cc[23];\n  *(_QWORD *)&termios_p.c_cc[23] = v3;\n  *(_QWORD *)&termios_p.c_cc[31] = *(_QWORD *)&dest.c_ospeed;\n  termios_p.c_ospeed = *((_DWORD *)&dest + 16);\n  cfsetispeed(&termios_p, 0);\n  cfsetospeed(&termios_p, 0);\n  if ( (unsigned int)sub_440726(&termios_p) )\n    a1 = 1;\n  sleep(1u);\n  if ( (unsigned int)sub_440726((const struct termios *)&dest.c_cflag) )\n    exit(1);\n  exit(a1);\n}\n",
        "baseline_code_debug": "void __cdecl __noreturn restore_state_and_exit(int exitcode)\n{\n  termios state; // [rsp+10h] [rbp-40h] BYREF\n\n  if ( bb_ioctl_or_warn(bb_common_bufsiz1.c_iflag, 0x5423u, &bb_common_bufsiz1.c_oflag, \"TIOCSETD\") < 0 )\n    exitcode = 1;\n  *(_QWORD *)&state.c_iflag = *(_QWORD *)&bb_common_bufsiz1.c_cflag;\n  *(_QWORD *)&state.c_cflag = *(_QWORD *)&bb_common_bufsiz1.c_line;\n  *(_QWORD *)&state.c_line = *(_QWORD *)&bb_common_bufsiz1.c_cc[7];\n  *(_QWORD *)&state.c_cc[7] = *(_QWORD *)&bb_common_bufsiz1.c_cc[15];\n  *(_QWORD *)&state.c_cc[15] = *(_QWORD *)&bb_common_bufsiz1.c_cc[23];\n  *(_QWORD *)&state.c_cc[23] = *(_QWORD *)&bb_common_bufsiz1.c_cc[31];\n  *(_QWORD *)&state.c_cc[31] = *(_QWORD *)&bb_common_bufsiz1.c_ospeed;\n  state.c_ospeed = dst.data[0];\n  cfsetispeed(&state, 0);\n  cfsetospeed(&state, 0);\n  if ( set_termios_state_or_warn(&state) )\n    exitcode = 1;\n  sleep(1u);\n  if ( set_termios_state_or_warn((termios *)&bb_common_bufsiz1.c_cflag) )\n    exit(1);\n  exit(exitcode);\n}\n",
        "similarity_score_unixcoder": 0.02485564723610878,
        "similarity_score_baseline_stripped": 0.5837101936340332,
        "similarity_score_baseline_debug": 0.7493524551391602
    },
    {
        "func_name": "fopen_or_warn",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004097EE | 55 | push    rbp\n0x004097EF | 48 89 E5 | mov     rbp, rsp\n0x004097F2 | 48 83 EC 20 | sub     rsp, 20h\n0x004097F6 | 48 89 7D E8 | mov     [rbp+filename], rdi\n0x004097FA | 48 89 75 E0 | mov     [rbp+modes], rsi\n0x004097FE | 48 8B 55 E0 | mov     rdx, [rbp+modes]\n0x00409802 | 48 8B 45 E8 | mov     rax, [rbp+filename]\n0x00409806 | 48 89 D6 | mov     rsi, rdx; modes\n0x00409809 | 48 89 C7 | mov     rdi, rax; filename\n0x0040980C | E8 3F D9 FF FF | call    _fopen64\n0x00409811 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00409815 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0040981A | 75 0C | jnz     short loc_409828\n0x0040981C | 48 8B 45 E8 | mov     rax, [rbp+filename]\n0x00409820 | 48 89 C7 | mov     rdi, rax\n0x00409823 | E8 45 FB FF FF | call    sub_40936D\n0x00409828 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0040982C | C9 | leave\n0x0040982D | C3 | retn",
        "output": "",
        "source_code": "FAST_FUNC fopen_or_warn(const char *path, const char *mode)\n{\n\tFILE *fp = fopen(path, mode);\n\tif (!fp) {\n\t\tbb_simple_perror_msg(path);\n\t\t//errno = 0; /* why? */\n\t}\n\treturn fp;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "FILE *__fastcall sub_4097EE(const char *a1, const char *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  FILE *v7; // [rsp+18h] [rbp-8h]\n\n  v7 = fopen64(a1, a2);\n  if ( !v7 )\n    sub_40936D((__int64)a1, (__int64)a2, v2, v3, v4, v5);\n  return v7;\n}\n",
        "baseline_code_debug": "FILE *__cdecl fopen_or_warn(const char *path, const char *mode)\n{\n  FILE *fp; // [rsp+18h] [rbp-8h]\n\n  fp = fopen64(path, mode);\n  if ( !fp )\n    bb_simple_perror_msg(path);\n  return fp;\n}\n",
        "similarity_score_unixcoder": 0.0771172046661377,
        "similarity_score_baseline_stripped": 0.5193501114845276,
        "similarity_score_baseline_debug": 0.8607019186019897
    },
    {
        "func_name": "rx_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00421D8D | 55 | push    rbp\n0x00421D8E | 48 89 E5 | mov     rbp, rsp\n0x00421D91 | 48 81 EC A0 00 00 00 | sub     rsp, 0A0h\n0x00421D98 | 89 BD 6C FF FF FF | mov     [rbp+var_94], edi\n0x00421D9E | 48 89 B5 60 FF FF FF | mov     [rbp+var_A0], rsi\n0x00421DA5 | 48 8B 85 60 FF FF FF | mov     rax, [rbp+var_A0]\n0x00421DAC | 48 89 C7 | mov     rdi, rax\n0x00421DAF | E8 45 68 0E 00 | call    sub_5085F9\n0x00421DB4 | BE 42 02 00 00 | mov     esi, 242h\n0x00421DB9 | 48 89 C7 | mov     rdi, rax\n0x00421DBC | E8 D4 84 FE FF | call    sub_40A295\n0x00421DC1 | 89 45 FC | mov     [rbp+var_4], eax\n0x00421DC4 | 48 8D 45 B0 | lea     rax, [rbp+termios_p]\n0x00421DC8 | 48 89 C6 | mov     rsi, rax; termios_p\n0x00421DCB | BF 00 00 00 00 | mov     edi, 0; fd\n0x00421DD0 | E8 CB 59 FE FF | call    _tcgetattr\n0x00421DD5 | 89 45 F8 | mov     [rbp+var_8], eax\n0x00421DD8 | 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00421DDC | 75 66 | jnz     short loc_421E44\n0x00421DDE | 48 8B 45 B0 | mov     rax, qword ptr [rbp+termios_p.c_iflag]\n0x00421DE2 | 48 8B 55 B8 | mov     rdx, qword ptr [rbp+termios_p.c_cflag]\n0x00421DE6 | 48 89 85 70 FF FF FF | mov     qword ptr [rbp+var_90.c_iflag], rax\n0x00421DED | 48 89 95 78 FF FF FF | mov     qword ptr [rbp+var_90.c_cflag], rdx\n0x00421DF4 | 48 8B 45 C0 | mov     rax, qword ptr [rbp+termios_p.c_line]\n0x00421DF8 | 48 8B 55 C8 | mov     rdx, qword ptr [rbp+termios_p.c_cc+7]\n0x00421DFC | 48 89 45 80 | mov     qword ptr [rbp+var_90.c_line], rax\n0x00421E00 | 48 89 55 88 | mov     qword ptr [rbp+var_90.c_cc+7], rdx\n0x00421E04 | 48 8B 45 D0 | mov     rax, qword ptr [rbp+termios_p.c_cc+0Fh]\n0x00421E08 | 48 8B 55 D8 | mov     rdx, qword ptr [rbp+termios_p.c_cc+17h]\n0x00421E0C | 48 89 45 90 | mov     qword ptr [rbp+var_90.c_cc+0Fh], rax\n0x00421E10 | 48 89 55 98 | mov     qword ptr [rbp+var_90.c_cc+17h], rdx\n0x00421E14 | 48 8B 45 E0 | mov     rax, qword ptr [rbp+termios_p.c_cc+1Fh]\n0x00421E18 | 48 89 45 A0 | mov     qword ptr [rbp+var_90.c_cc+1Fh], rax\n0x00421E1C | 8B 45 E8 | mov     eax, [rbp+termios_p.c_ospeed]\n0x00421E1F | 89 45 A8 | mov     [rbp+var_90.c_ospeed], eax\n0x00421E22 | 48 8D 45 B0 | lea     rax, [rbp+termios_p]\n0x00421E26 | 48 89 C7 | mov     rdi, rax; termios_p\n0x00421E29 | E8 A2 57 FE FF | call    _cfmakeraw\n0x00421E2E | 48 8D 45 B0 | lea     rax, [rbp+termios_p]\n0x00421E32 | 48 89 C2 | mov     rdx, rax; termios_p\n0x00421E35 | BE 02 00 00 00 | mov     esi, 2; optional_actions\n0x00421E3A | BF 00 00 00 00 | mov     edi, 0; fd\n0x00421E3F | E8 8C 59 FE FF | call    _tcsetattr\n0x00421E44 | BE 83 1D 42 00 | mov     esi, offset sub_421D83\n0x00421E49 | BF 0E 00 00 00 | mov     edi, 0Eh\n0x00421E4E | E8 DB 65 0E 00 | call    sub_50842E\n0x00421E53 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00421E56 | 89 C7 | mov     edi, eax\n0x00421E58 | E8 D2 FA FF FF | call    sub_42192F\n0x00421E5D | 89 45 F4 | mov     [rbp+var_C], eax\n0x00421E60 | 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00421E64 | 75 19 | jnz     short loc_421E7F\n0x00421E66 | 48 8D 85 70 FF FF FF | lea     rax, [rbp+var_90]\n0x00421E6D | 48 89 C2 | mov     rdx, rax; termios_p\n0x00421E70 | BE 02 00 00 00 | mov     esi, 2; optional_actions\n0x00421E75 | BF 00 00 00 00 | mov     edi, 0; fd\n0x00421E7A | E8 51 59 FE FF | call    _tcsetattr\n0x00421E7F | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00421E82 | F7 D0 | not     eax\n0x00421E84 | C1 E8 1F | shr     eax, 1Fh\n0x00421E87 | 0F B6 C0 | movzx   eax, al\n0x00421E8A | 89 C7 | mov     edi, eax\n0x00421E8C | E8 38 75 0D 00 | call    sub_4F93C9",
        "output": "\n0x00421E91 | 89 45 F8 | mov     [rbp+var_8], eax\n0x00421E94 | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x00421E97 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00421E9A | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00421E9D | 5D | pop     rbp\n0x00421E9E | C3 | ret",
        "source_code": "int rx_main(int argc UNUSED_PARAM, char **argv)\n{\n\tstruct termios tty, orig_tty;\n\tint termios_err;\n\tint file_fd;\n\tint n;\n\n\t/* Disabled by vda:\n\t * why we can't receive from stdin? Why we *require*\n\t * controlling tty?? */\n\t/*read_fd = xopen(CURRENT_TTY, O_RDWR);*/\n\tfile_fd = xopen(single_argv(argv), O_RDWR|O_CREAT|O_TRUNC);\n\n\ttermios_err = tcgetattr(read_fd, &tty);\n\tif (termios_err == 0) {\n\t\torig_tty = tty;\n\t\tcfmakeraw(&tty);\n\t\ttcsetattr(read_fd, TCSAFLUSH, &tty);\n\t}\n\n\t/* No SA_RESTART: we want ALRM to interrupt read() */\n\tsignal_no_SA_RESTART_empty_mask(SIGALRM, sigalrm_handler);\n\n\tn = receive(file_fd);\n\n\tif (termios_err == 0)\n\t\ttcsetattr(read_fd, TCSAFLUSH, &orig_tty);\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tclose(file_fd);\n\tfflush_stdout_and_exit(n >= 0);\n}",
        "parsed_output": "\n0x00421E91 | 89 45 F8 | mov     [rbp+var_8], eax\n0x00421E94 | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x00421E97 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00421E9A | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00421E9D | 5D | pop     rbp\n0x00421E9E | C3 | ret",
        "baseline_code_stripped": "void __fastcall __noreturn sub_421D8D(__int64 a1, __int64 a2)\n{\n  const char *v2; // rax\n  struct termios v3; // [rsp+10h] [rbp-90h] BYREF\n  struct termios termios_p; // [rsp+50h] [rbp-50h] BYREF\n  int v5; // [rsp+94h] [rbp-Ch]\n  int v6; // [rsp+98h] [rbp-8h]\n  unsigned int v7; // [rsp+9Ch] [rbp-4h]\n\n  v2 = (const char *)sub_5085F9(a2);\n  v7 = sub_40A295(v2, 578);\n  v6 = tcgetattr(0, &termios_p);\n  if ( !v6 )\n  {\n    v3 = termios_p;\n    cfmakeraw(&termios_p);\n    tcsetattr(0, 2, &termios_p);\n  }\n  sub_50842E(14LL, sub_421D83);\n  v5 = sub_42192F(v7);\n  if ( !v6 )\n    tcsetattr(0, 2, &v3);\n  sub_4F93C9(v5 >= 0);\n}\n",
        "baseline_code_debug": "int __cdecl __noreturn rx_main(int argc, char **argv)\n{\n  char *v2; // rax\n  termios orig_tty; // [rsp+10h] [rbp-90h] BYREF\n  termios tty; // [rsp+50h] [rbp-50h] BYREF\n  int n; // [rsp+94h] [rbp-Ch]\n  int termios_err; // [rsp+98h] [rbp-8h]\n  int file_fd; // [rsp+9Ch] [rbp-4h]\n\n  v2 = single_argv(argv);\n  file_fd = xopen(v2, 578);\n  termios_err = tcgetattr(0, &tty);\n  if ( !termios_err )\n  {\n    orig_tty = tty;\n    cfmakeraw(&tty);\n    tcsetattr(0, 2, &tty);\n  }\n  signal_no_SA_RESTART_empty_mask(14, (void (*)(int))sigalrm_handler);\n  n = receive(file_fd);\n  if ( !termios_err )\n    tcsetattr(0, 2, &orig_tty);\n  fflush_stdout_and_exit(n >= 0);\n}\n",
        "similarity_score_unixcoder": 0.3069727420806885,
        "similarity_score_baseline_stripped": 0.6274762153625488,
        "similarity_score_baseline_debug": 0.8371586203575134
    },
    {
        "func_name": "monotonic_ns",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040BC33 | 55 | push    rbp\n0x0040BC34 | 48 89 E5 | mov     rbp, rsp\n0x0040BC37 | 48 83 EC 10 | sub     rsp, 10h\n0x0040BC3B | 48 8D 45 F0 | lea     rax, [rbp+tv]\n0x0040BC3F | BE 00 00 00 00 | mov     esi, 0; tz\n0x0040BC44 | 48 89 C7 | mov     rdi, rax; tv\n0x0040BC47 | E8 74 B0 FF FF | call    _gettimeofday\n0x0040BC4C | 48 8B 45 F0 | mov     rax, [rbp+tv.tv_sec]\n0x0040BC50 | 48 69 C0 00 CA 9A 3B | imul    rax, 3B9ACA00h\n0x0040BC57 | 48 8B 55 F8 | mov     rdx, [rbp+tv.tv_usec]\n0x0040BC5B | 48 69 D2 E8 03 00 00 | imul    rdx, 3E8h\n0x0040BC62 | 48 01 D0 | add     rax, rdx\n0x0040BC65 | C9 | leave\n0x0040BC66 | C3 | retn",
        "output": "",
        "source_code": "unsigned long long FAST_FUNC monotonic_ns(void)\n{\n\tstruct timespec ts;\n\tget_mono(&ts);\n\treturn ts.tv_sec * 1000000000ULL + ts.tv_nsec;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__suseconds_t sub_40BC33()\n{\n  struct timeval tv; // [rsp+0h] [rbp-10h] BYREF\n\n  gettimeofday(&tv, 0LL);\n  return 1000 * tv.tv_usec + 1000000000 * tv.tv_sec;\n}\n",
        "baseline_code_debug": "unsigned __int64 __cdecl monotonic_ns()\n{\n  timeval tv; // [rsp+0h] [rbp-10h] BYREF\n\n  gettimeofday(&tv, 0LL);\n  return 1000 * tv.tv_usec + 1000000000 * tv.tv_sec;\n}\n",
        "similarity_score_unixcoder": 0.15845391154289246,
        "similarity_score_baseline_stripped": 0.5797103643417358,
        "similarity_score_baseline_debug": 0.7561351656913757
    },
    {
        "func_name": "rtc_tm2time",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00507D06 | 55 | push    rbp\n0x00507D07 | 48 89 E5 | mov     rbp, rsp\n0x00507D0A | 48 83 EC 20 | sub     rsp, 20h\n0x00507D0E | 48 89 7D E8 | mov     [rbp+tp], rdi\n0x00507D12 | 89 75 E4 | mov     [rbp+var_1C], esi\n0x00507D15 | 83 7D E4 00 | cmp     [rbp+var_1C], 0\n0x00507D19 | 74 1D | jz      short loc_507D38\n0x00507D1B | BF E2 75 53 00 | mov     edi, offset aTz; \"TZ\"\n0x00507D20 | E8 EB E8 EF FF | call    _getenv\n0x00507D25 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00507D29 | BF E5 75 53 00 | mov     edi, offset aTzUtc0_0; \"TZ=UTC0\"\n0x00507D2E | E8 DD F2 EF FF | call    _putenv\n0x00507D33 | E8 D8 F4 EF FF | call    _tzset\n0x00507D38 | 48 8B 45 E8 | mov     rax, [rbp+tp]\n0x00507D3C | 48 89 C7 | mov     rdi, rax; tp\n0x00507D3F | E8 8C F7 EF FF | call    _mktime\n0x00507D44 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x00507D48 | 83 7D E4 00 | cmp     [rbp+var_1C], 0\n0x00507D4C | 74 26 | jz      short loc_507D74\n0x00507D4E | BF E2 75 53 00 | mov     edi, offset aTz; \"TZ\"\n0x00507D53 | E8 88 FB EF FF | call    _unsetenv\n0x00507D58 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00507D5D | 74 10 | jz      short loc_507D6F\n0x00507D5F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00507D63 | 48 83 E8 03 | sub     rax, 3\n0x00507D67 | 48 89 C7 | mov     rdi, rax; string\n0x00507D6A | E8 A1 F2 EF FF | call    _putenv\n0x00507D6F | E8 9C F4 EF FF | call    _tzset\n0x00507D74 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00507D78 | C9 | leave\n0x00507D79 | C3 | retn",
        "output": "",
        "source_code": "time_t FAST_FUNC rtc_tm2time(struct tm *ptm, int utc)\n{\n\tchar *oldtz = oldtz; /* for compiler */\n\ttime_t t;\n\n\tif (utc) {\n\t\toldtz = getenv(\"TZ\");\n\t\tputenv((char*)\"TZ=UTC0\");\n\t\ttzset();\n\t}\n\n\tt = mktime(ptm);\n\n\tif (utc) {\n\t\tunsetenv(\"TZ\");\n\t\tif (oldtz)\n\t\t\tputenv(oldtz - 3);\n\t\ttzset();\n\t}\n\n\treturn t;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "time_t __fastcall sub_507D06(struct tm *a1, int a2)\n{\n  time_t v3; // [rsp+10h] [rbp-10h]\n  char *v4; // [rsp+18h] [rbp-8h]\n\n  if ( a2 )\n  {\n    v4 = getenv(\"TZ\");\n    putenv(\"TZ=UTC0\");\n    tzset();\n  }\n  v3 = mktime(a1);\n  if ( a2 )\n  {\n    unsetenv(\"TZ\");\n    if ( v4 )\n      putenv(v4 - 3);\n    tzset();\n  }\n  return v3;\n}\n",
        "baseline_code_debug": "time_t __cdecl rtc_tm2time(tm *ptm, int utc)\n{\n  time_t t; // [rsp+10h] [rbp-10h]\n  char *oldtz; // [rsp+18h] [rbp-8h]\n\n  if ( utc )\n  {\n    oldtz = getenv(\"TZ\");\n    putenv(\"TZ=UTC0\");\n    tzset();\n  }\n  t = mktime(ptm);\n  if ( utc )\n  {\n    unsetenv(\"TZ\");\n    if ( oldtz )\n      putenv(oldtz - 3);\n    tzset();\n  }\n  return t;\n}\n",
        "similarity_score_unixcoder": 0.07976439595222473,
        "similarity_score_baseline_stripped": 0.7975502610206604,
        "similarity_score_baseline_debug": 0.9317933917045593
    },
    {
        "func_name": "hash_bin_to_hex",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004CCD81 | 55 | push    rbp\n0x004CCD82 | 48 89 E5 | mov     rbp, rsp\n0x004CCD85 | 48 83 EC 20 | sub     rsp, 20h\n0x004CCD89 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004CCD8D | 89 75 E4 | mov     [rbp+var_1C], esi\n0x004CCD90 | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x004CCD93 | 01 C0 | add     eax, eax\n0x004CCD95 | 83 C0 01 | add     eax, 1\n0x004CCD98 | 89 C0 | mov     eax, eax\n0x004CCD9A | 48 89 C7 | mov     rdi, rax\n0x004CCD9D | E8 46 D3 F3 FF | call    sub_40A0E8\n0x004CCDA2 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004CCDA6 | 8B 55 E4 | mov     edx, [rbp+var_1C]\n0x004CCDA9 | 48 8B 4D E8 | mov     rcx, [rbp+var_18]\n0x004CCDAD | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004CCDB1 | 48 89 CE | mov     rsi, rcx\n0x004CCDB4 | 48 89 C7 | mov     rdi, rax\n0x004CCDB7 | E8 F9 CD F3 FF | call    sub_409BB5\n0x004CCDBC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004CCDC0 | C9 | leave\n0x004CCDC1 | C3 | retn",
        "output": "",
        "source_code": "static unsigned char *hash_bin_to_hex(unsigned char *hash_value,\n\t\t\t\tunsigned hash_length)\n{\n\t/* xzalloc zero-terminates */\n\tchar *hex_value = xzalloc((hash_length * 2) + 1);\n\tbin2hex(hex_value, (char*)hash_value, hash_length);\n\treturn (unsigned char *)hex_value;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "_BYTE *__fastcall sub_4CCD81(char *a1, __int64 a2)\n{\n  _BYTE *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40A0E8((unsigned int)(2 * a2 + 1), a2);\n  sub_409BB5(v3, a1, a2);\n  return v3;\n}\n",
        "baseline_code_debug": "unsigned __int8 *__cdecl hash_bin_to_hex(unsigned __int8 *hash_value, unsigned int hash_length)\n{\n  char *hex_value; // [rsp+18h] [rbp-8h]\n\n  hex_value = (char *)xzalloc(2 * hash_length + 1);\n  bin2hex(hex_value, (const char *)hash_value, hash_length);\n  return (unsigned __int8 *)hex_value;\n}\n",
        "similarity_score_unixcoder": 0.013529169373214245,
        "similarity_score_baseline_stripped": 0.47773265838623047,
        "similarity_score_baseline_debug": 0.8737540245056152
    },
    {
        "func_name": "do_lzo_decompress",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004B363F | 55 | push    rbp\n0x004B3640 | 48 89 E5 | mov     rbp, rsp\n0x004B3643 | 48 81 EC 30 01 00 00 | sub     rsp, 130h\n0x004B364A | E8 AF FA FF FF | call    sub_4B30FE\n0x004B364F | 48 8D 85 D0 FE FF FF | lea     rax, [rbp+var_130]\n0x004B3656 | 48 89 C7 | mov     rdi, rax\n0x004B3659 | E8 81 FE FF FF | call    sub_4B34DF\n0x004B365E | 48 8D 85 D0 FE FF FF | lea     rax, [rbp+var_130]\n0x004B3665 | 48 89 C7 | mov     rdi, rax\n0x004B3668 | E8 86 F7 FF FF | call    sub_4B2DF3\n0x004B366D | C9 | leave\n0x004B366E | C3 | retn",
        "output": "",
        "source_code": "static smallint do_lzo_decompress(void)\n{\n\theader_t header;\n\n\tcheck_magic();\n\tp_header(&header);\n\treturn lzo_decompress(&header);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4B363F(__int64 a1, __int64 a2)\n{\n  unsigned __int8 v3[304]; // [rsp+0h] [rbp-130h] BYREF\n\n  sub_4B30FE();\n  sub_4B34DF(v3);\n  return sub_4B2DF3((__int64)v3, a2);\n}\n",
        "baseline_code_debug": "smallint __cdecl do_lzo_decompress()\n{\n  header_t_0 header; // [rsp+0h] [rbp-130h] BYREF\n\n  check_magic();\n  p_header(&header);\n  return lzo_decompress(&header);\n}\n",
        "similarity_score_unixcoder": 0.061720505356788635,
        "similarity_score_baseline_stripped": 0.3258238434791565,
        "similarity_score_baseline_debug": 0.8164466619491577
    },
    {
        "func_name": "logdirs_reopen",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0046CD10 | 55 | push    rbp\n0x0046CD11 | 48 89 E5 | mov     rbp, rsp\n0x0046CD14 | 48 83 EC 10 | sub     rsp, 10h\n0x0046CD18 | C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0\n0x0046CD1F | 48 8B 05 E2 06 2F 00 | mov     rax, cs:qword_75D408\n0x0046CD26 | C6 40 3C 00 | mov     byte ptr [rax+3Ch], 0\n0x0046CD2A | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x0046CD31 | E9 8B 00 00 00 | jmp     loc_46CDC1\n0x0046CD36 | 48 8B 05 CB 06 2F 00 | mov     rax, cs:qword_75D408\n0x0046CD3D | 48 8B 08 | mov     rcx, [rax]\n0x0046CD40 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0046CD43 | 48 63 D0 | movsxd  rdx, eax\n0x0046CD46 | 48 89 D0 | mov     rax, rdx\n0x0046CD49 | 48 01 C0 | add     rax, rax\n0x0046CD4C | 48 01 D0 | add     rax, rdx\n0x0046CD4F | 48 C1 E0 02 | shl     rax, 2\n0x0046CD53 | 48 01 D0 | add     rax, rdx\n0x0046CD56 | 48 C1 E0 03 | shl     rax, 3\n0x0046CD5A | 48 01 C8 | add     rax, rcx\n0x0046CD5D | 48 89 C7 | mov     rdi, rax\n0x0046CD60 | E8 0B F6 FF FF | call    sub_46C370\n0x0046CD65 | 48 8B 05 9C 06 2F 00 | mov     rax, cs:qword_75D408\n0x0046CD6C | 48 8B 40 18 | mov     rax, [rax+18h]\n0x0046CD70 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x0046CD73 | 48 63 D2 | movsxd  rdx, edx\n0x0046CD76 | 48 C1 E2 03 | shl     rdx, 3\n0x0046CD7A | 48 01 D0 | add     rax, rdx\n0x0046CD7D | 48 8B 08 | mov     rcx, [rax]\n0x0046CD80 | 48 8B 05 81 06 2F 00 | mov     rax, cs:qword_75D408\n0x0046CD87 | 48 8B 30 | mov     rsi, [rax]\n0x0046CD8A | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0046CD8D | 48 63 D0 | movsxd  rdx, eax\n0x0046CD90 | 48 89 D0 | mov     rax, rdx\n0x0046CD93 | 48 01 C0 | add     rax, rax\n0x0046CD96 | 48 01 D0 | add     rax, rdx\n0x0046CD99 | 48 C1 E0 02 | shl     rax, 2\n0x0046CD9D | 48 01 D0 | add     rax, rdx\n0x0046CDA0 | 48 C1 E0 03 | shl     rax, 3\n0x0046CDA4 | 48 01 F0 | add     rax, rsi\n0x0046CDA7 | 48 89 CE | mov     rsi, rcx\n0x0046CDAA | 48 89 C7 | mov     rdi, rax\n0x0046CDAD | E8 FF F6 FF FF | call    sub_46C4B1\n0x0046CDB2 | 85 C0 | test    eax, eax\n0x0046CDB4 | 74 07 | jz      short loc_46CDBD\n0x0046CDB6 | C7 45 F8 01 00 00 00 | mov     [rbp+var_8], 1\n0x0046CDBD | 83 45 FC 01 | add     [rbp+var_4], 1\n0x0046CDC1 | 48 8B 05 40 06 2F 00 | mov     rax, cs:qword_75D408\n0x0046CDC8 | 8B 50 4C | mov     edx, [rax+4Ch]\n0x0046CDCB | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0046CDCE | 39 C2 | cmp     edx, eax\n0x0046CDD0 | 0F 87 60 FF FF FF | ja      loc_46CD36\n0x0046CDD6 | 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0046CDDA | 75 0A | jnz     short loc_46CDE6\n0x0046CDDC | BF 68 68 52 00 | mov     edi, offset aNoFunctionalLo; \"no functional log directories\"\n0x0046CDE1 | E8 E0 E3 FF FF | call    sub_46B1C6\n0x0046CDE6 | 90 | nop\n0x0046CDE7 | C9 | leave\n0x0046CDE8 | C3 | retn",
        "output": "",
        "source_code": "static void logdirs_reopen(void)\n{\n\tint l;\n\tint ok = 0;\n\n\ttmaxflag = 0;\n\tfor (l = 0; l < dirn; ++l) {\n\t\tlogdir_close(&dir[l]);\n\t\tif (logdir_open(&dir[l], fndir[l]))\n\t\t\tok = 1;\n\t}\n\tif (!ok)\n\t\tfatalx(\"no functional log directories\");\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_46CD10(__int64 a1, const char *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 result; // rax\n  int v8; // [rsp+8h] [rbp-8h]\n  signed int i; // [rsp+Ch] [rbp-4h]\n\n  v8 = 0;\n  *((_BYTE *)qword_75D408 + 60) = 0;\n  for ( i = 0; ; ++i )\n  {\n    v6 = *((unsigned int *)qword_75D408 + 19);\n    result = (unsigned int)i;\n    if ( (unsigned int)v6 <= i )\n      break;\n    sub_46C370(*(_QWORD *)qword_75D408 + 104LL * i, (__int64)a2, i, *(_QWORD *)qword_75D408, a5, a6);\n    a2 = *(const char **)(8LL * i + *((_QWORD *)qword_75D408 + 3));\n    if ( (unsigned int)sub_46C4B1(*(_QWORD *)qword_75D408 + 104LL * i, a2) )\n      v8 = 1;\n  }\n  if ( !v8 )\n    sub_46B1C6((__int64)\"no functional log directories\", (__int64)a2, v6, a4, a5, a6);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl logdirs_reopen()\n{\n  int ok; // [rsp+8h] [rbp-8h]\n  int l; // [rsp+Ch] [rbp-4h]\n\n  ok = 0;\n  LOBYTE(ptr_to_globals->speeds[2]) = 0;\n  for ( l = 0; ptr_to_globals->speeds[6] > (unsigned int)l; ++l )\n  {\n    logdir_close((logdir *)(*(_QWORD *)&ptr_to_globals->timeout + 104LL * l));\n    if ( logdir_open(\n           (logdir *)(*(_QWORD *)&ptr_to_globals->timeout + 104LL * l),\n           *(const char **)&ptr_to_globals->tty_name[8 * l]) )\n    {\n      ok = 1;\n    }\n  }\n  if ( !ok )\n    fatalx(\"no functional log directories\");\n}\n",
        "similarity_score_unixcoder": 0.03552154451608658,
        "similarity_score_baseline_stripped": 0.4791395664215088,
        "similarity_score_baseline_debug": 0.6450849175453186
    },
    {
        "func_name": "detect_link_iff",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043082B | 55 | push    rbp\n0x0043082C | 48 89 E5 | mov     rbp, rsp\n0x0043082F | 48 83 EC 30 | sub     rsp, 30h\n0x00430833 | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00430837 | 48 89 C7 | mov     rdi, rax\n0x0043083A | E8 F8 FD FF FF | call    sub_430637\n0x0043083F | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00430843 | BA 50 85 51 00 | mov     edx, offset aSiocgifflags_1; \"SIOCGIFFLAGS\"\n0x00430848 | 48 89 C6 | mov     rsi, rax\n0x0043084B | BF 13 89 00 00 | mov     edi, 8913h\n0x00430850 | E8 21 FE FF FF | call    sub_430676\n0x00430855 | 85 C0 | test    eax, eax\n0x00430857 | 79 07 | jns     short loc_430860\n0x00430859 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x0043085E | EB 31 | jmp     short locret_430891\n0x00430860 | 0F B7 45 E0 | movzx   eax, [rbp+var_20]\n0x00430864 | 98 | cwde\n0x00430865 | 83 E0 01 | and     eax, 1\n0x00430868 | 85 C0 | test    eax, eax\n0x0043086A | 75 1A | jnz     short loc_430886\n0x0043086C | 48 8B 05 95 CB 32 00 | mov     rax, cs:qword_75D408\n0x00430873 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00430876 | 3C FF | cmp     al, 0FFh\n0x00430878 | 74 0C | jz      short loc_430886\n0x0043087A | 48 8B 05 87 CB 32 00 | mov     rax, cs:qword_75D408\n0x00430881 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00430884 | EB 0B | jmp     short locret_430891\n0x00430886 | 0F B7 45 E0 | movzx   eax, [rbp+var_20]\n0x0043088A | 98 | cwde\n0x0043088B | C1 F8 06 | sar     eax, 6\n0x0043088E | 83 E0 01 | and     eax, 1\n0x00430891 | C9 | leave\n0x00430892 | C3 | retn",
        "output": "",
        "source_code": "static smallint detect_link_iff(void)\n{\n\tstruct ifreq ifreq;\n\n\tset_ifreq_to_ifname(&ifreq);\n\n\tif (network_ioctl(SIOCGIFFLAGS, &ifreq, \"SIOCGIFFLAGS\") < 0) {\n\t\treturn IFSTATUS_ERR;\n\t}\n\n\t/* If IFF_UP is not set (interface is down), IFF_RUNNING is never set\n\t * regardless of link status. Simply continue to report last status -\n\t * no point in reporting spurious link downs if interface is disabled\n\t * by admin. When/if it will be brought up,\n\t * we'll report real link status.\n\t */\n\tif (!(ifreq.ifr_flags & IFF_UP) && G.iface_last_status != IFSTATUS_ERR)\n\t\treturn G.iface_last_status;\n\n\treturn (ifreq.ifr_flags & IFF_RUNNING) ? IFSTATUS_UP : IFSTATUS_DOWN;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 sub_43082B()\n{\n  char v1[16]; // [rsp+0h] [rbp-30h] BYREF\n  __int16 v2; // [rsp+10h] [rbp-20h]\n\n  sub_430637(v1);\n  if ( (int)sub_430676(35091, (__int64)v1, (__int64)\"SIOCGIFFLAGS\") < 0 )\n    return 0xFFFFFFFFLL;\n  if ( (v2 & 1) != 0 || *(_BYTE *)qword_75D408 == 0xFF )\n    return (v2 >> 6) & 1;\n  return *(unsigned __int8 *)qword_75D408;\n}\n",
        "baseline_code_debug": "smallint __cdecl detect_link_iff()\n{\n  int v0; // eax\n  ifreq_0 ifreq; // [rsp+0h] [rbp-30h] BYREF\n\n  set_ifreq_to_ifname(&ifreq);\n  if ( network_ioctl(35091, &ifreq, \"SIOCGIFFLAGS\") >= 0 )\n  {\n    if ( (ifreq.ifr_ifru.ifru_slave[0] & 1) != 0 || LOBYTE(ptr_to_globals->timeout) == 0xFF )\n      return (ifreq.ifr_ifru.ifru_flags >> 6) & 1;\n    else\n      LOBYTE(v0) = ptr_to_globals->timeout;\n  }\n  else\n  {\n    LOBYTE(v0) = -1;\n  }\n  return v0;\n}\n",
        "similarity_score_unixcoder": 0.14652031660079956,
        "similarity_score_baseline_stripped": 0.3739491403102875,
        "similarity_score_baseline_debug": 0.7152293920516968
    },
    {
        "func_name": "add_inode",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0045B484 | 55 | push    rbp\n0x0045B485 | 48 89 E5 | mov     rbp, rsp\n0x0045B488 | 48 83 EC 20 | sub     rsp, 20h\n0x0045B48C | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0045B490 | 48 C7 45 F8 00 B4 75 00 | mov     [rbp+var_8], offset dest.c_cflag\n0x0045B498 | EB 3A | jmp     short loc_45B4D4\n0x0045B49A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045B49E | 48 8B 00 | mov     rax, [rax]\n0x0045B4A1 | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x0045B4A5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0045B4A9 | 48 8B 00 | mov     rax, [rax]\n0x0045B4AC | 48 39 C2 | cmp     rdx, rax\n0x0045B4AF | 75 18 | jnz     short loc_45B4C9\n0x0045B4B1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045B4B5 | 48 8B 00 | mov     rax, [rax]\n0x0045B4B8 | 48 8B 50 08 | mov     rdx, [rax+8]\n0x0045B4BC | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0045B4C0 | 48 8B 40 08 | mov     rax, [rax+8]\n0x0045B4C4 | 48 39 C2 | cmp     rdx, rax\n0x0045B4C7 | 74 52 | jz      short loc_45B51B\n0x0045B4C9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045B4CD | 48 8B 00 | mov     rax, [rax]\n0x0045B4D0 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0045B4D4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045B4D8 | 48 8B 00 | mov     rax, [rax]\n0x0045B4DB | 48 85 C0 | test    rax, rax\n0x0045B4DE | 75 BA | jnz     short loc_45B49A\n0x0045B4E0 | BF 18 00 00 00 | mov     edi, 18h\n0x0045B4E5 | E8 FE EB FA FF | call    sub_40A0E8\n0x0045B4EA | 48 89 C2 | mov     rdx, rax\n0x0045B4ED | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045B4F1 | 48 89 10 | mov     [rax], rdx\n0x0045B4F4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045B4F8 | 48 8B 00 | mov     rax, [rax]\n0x0045B4FB | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x0045B4FF | 48 8B 12 | mov     rdx, [rdx]\n0x0045B502 | 48 89 50 10 | mov     [rax+10h], rdx\n0x0045B506 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045B50A | 48 8B 00 | mov     rax, [rax]\n0x0045B50D | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x0045B511 | 48 8B 52 08 | mov     rdx, [rdx+8]\n0x0045B515 | 48 89 50 08 | mov     [rax+8], rdx\n0x0045B519 | EB 01 | jmp     short locret_45B51C\n0x0045B51B | 90 | nop\n0x0045B51C | C9 | leave\n0x0045B51D | C3 | retn",
        "output": "",
        "source_code": "static void add_inode(const struct stat *st)\n{\n\tinode_list **curr = &G.inode_list_head;\n\n\twhile (*curr) {\n\t\tif ((*curr)->dev == st->st_dev\n\t\t && (*curr)->inode == st->st_ino\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\tcurr = &(*curr)->next;\n\t}\n\n\t*curr = xzalloc(sizeof(inode_list));\n\t(*curr)->dev = st->st_dev;\n\t(*curr)->inode = st->st_ino;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "tcflag_t *__fastcall sub_45B484(_QWORD *a1, __int64 a2)\n{\n  tcflag_t *result; // rax\n  tcflag_t *i; // [rsp+18h] [rbp-8h]\n\n  for ( i = &dest.c_cflag; *(_QWORD *)i; i = *(tcflag_t **)i )\n  {\n    if ( *(_QWORD *)(*(_QWORD *)i + 16LL) == *a1 )\n    {\n      result = (tcflag_t *)a1[1];\n      if ( *(tcflag_t **)(*(_QWORD *)i + 8LL) == result )\n        return result;\n    }\n  }\n  *(_QWORD *)i = sub_40A0E8(0x18uLL, a2);\n  *(_QWORD *)(*(_QWORD *)i + 16LL) = *a1;\n  result = *(tcflag_t **)i;\n  *(_QWORD *)(*(_QWORD *)i + 8LL) = a1[1];\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl add_inode(const stat *st)\n{\n  inode_list_0 **curr; // [rsp+18h] [rbp-8h]\n\n  for ( curr = (inode_list_0 **)(&bb_common_bufsiz1 + 8); *curr; curr = (inode_list_0 **)*curr )\n  {\n    if ( (*curr)->dev == st->st_dev && (*curr)->inode == st->st_ino )\n      return;\n  }\n  *curr = (inode_list_0 *)xzalloc(0x18uLL);\n  (*curr)->dev = st->st_dev;\n  (*curr)->inode = st->st_ino;\n}\n",
        "similarity_score_unixcoder": 0.06522747874259949,
        "similarity_score_baseline_stripped": 0.45952922105789185,
        "similarity_score_baseline_debug": 0.83051997423172
    },
    {
        "func_name": "udhcp_recv_kernel_packet",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0045897C | 55 | push    rbp\n0x0045897D | 48 89 E5 | mov     rbp, rsp\n0x00458980 | 53 | push    rbx\n0x00458981 | 48 83 EC 28 | sub     rsp, 28h\n0x00458985 | 48 89 7D D8 | mov     [rbp+s], rdi\n0x00458989 | 89 75 D4 | mov     [rbp+var_2C], esi\n0x0045898C | 48 8B 45 D8 | mov     rax, [rbp+s]\n0x00458990 | BA 74 02 00 00 | mov     edx, 274h; n\n0x00458995 | BE 00 00 00 00 | mov     esi, 0; c\n0x0045899A | 48 89 C7 | mov     rdi, rax; s\n0x0045899D | E8 AE E3 FA FF | call    _memset\n0x004589A2 | 48 8B 4D D8 | mov     rcx, [rbp+s]\n0x004589A6 | 8B 45 D4 | mov     eax, [rbp+var_2C]\n0x004589A9 | BA 74 02 00 00 | mov     edx, 274h\n0x004589AE | 48 89 CE | mov     rsi, rcx\n0x004589B1 | 89 C7 | mov     edi, eax\n0x004589B3 | E8 47 2A FB FF | call    sub_40B3FF\n0x004589B8 | 89 45 EC | mov     [rbp+var_14], eax\n0x004589BB | 83 7D EC 00 | cmp     [rbp+var_14], 0\n0x004589BF | 79 1E | jns     short loc_4589DF\n0x004589C1 | 8B 05 99 4A 30 00 | mov     eax, cs:dword_75D460\n0x004589C7 | 85 C0 | test    eax, eax\n0x004589C9 | 74 0F | jz      short loc_4589DA\n0x004589CB | BF 7B D2 52 00 | mov     edi, offset aPacketReadErro_0; \"Packet read error, ignoring\"\n0x004589D0 | B8 00 00 00 00 | mov     eax, 0\n0x004589D5 | E8 E2 50 0A 00 | call    sub_4FDABC\n0x004589DA | 8B 45 EC | mov     eax, [rbp+var_14]\n0x004589DD | EB 60 | jmp     short loc_458A3F\n0x004589DF | 8B 45 EC | mov     eax, [rbp+var_14]\n0x004589E2 | 3D EF 00 00 00 | cmp     eax, 0EFh\n0x004589E7 | 76 18 | jbe     short loc_458A01\n0x004589E9 | 48 8B 45 D8 | mov     rax, [rbp+s]\n0x004589ED | 8B 98 EC 00 00 00 | mov     ebx, [rax+0ECh]\n0x004589F3 | BF 63 53 82 63 | mov     edi, 63825363h; hostlong\n0x004589F8 | E8 33 E3 FA FF | call    _htonl\n0x004589FD | 39 C3 | cmp     ebx, eax\n0x004589FF | 74 16 | jz      short loc_458A17\n0x00458A01 | BF 98 D2 52 00 | mov     edi, offset aPacketWithBadM_0; \"Packet with bad magic, ignoring\"\n0x00458A06 | B8 00 00 00 00 | mov     eax, 0\n0x00458A0B | E8 AC 50 0A 00 | call    sub_4FDABC\n0x00458A10 | B8 FE FF FF FF | mov     eax, 0FFFFFFFEh\n0x00458A15 | EB 28 | jmp     short loc_458A3F\n0x00458A17 | 8B 05 43 4A 30 00 | mov     eax, cs:dword_75D460\n0x00458A1D | 85 C0 | test    eax, eax\n0x00458A1F | 74 0F | jz      short loc_458A30\n0x00458A21 | BF B8 D2 52 00 | mov     edi, offset aReceivedAPacke_0; \"Received a packet\"\n0x00458A26 | B8 00 00 00 00 | mov     eax, 0\n0x00458A2B | E8 8C 50 0A 00 | call    sub_4FDABC\n0x00458A30 | 48 8B 45 D8 | mov     rax, [rbp+s]\n0x00458A34 | 48 89 C7 | mov     rdi, rax\n0x00458A37 | E8 9C FE FF FF | call    sub_4588D8\n0x00458A3C | 8B 45 EC | mov     eax, [rbp+var_14]\n0x00458A3F | 48 83 C4 28 | add     rsp, 28h\n0x00458A43 | 5B | pop     rbx\n0x00458A44 | 5D | pop     rbp\n0x00458A45 | C3 | retn",
        "output": "",
        "source_code": "int FAST_FUNC udhcp_recv_kernel_packet(struct dhcp_packet *packet, int fd)\n{\n\tint bytes;\n\n\tmemset(packet, 0, sizeof(*packet));\n\tbytes = safe_read(fd, packet, sizeof(*packet));\n\tif (bytes < 0) {\n\t\tlog1(\"Packet read error, ignoring\");\n\t\treturn bytes; /* returns -1 */\n\t}\n\n\tif (bytes < offsetof(struct dhcp_packet, options)\n\t || packet->cookie != htonl(DHCP_MAGIC)\n\t) {\n\t\tbb_info_msg(\"Packet with bad magic, ignoring\");\n\t\treturn -2;\n\t}\n\tlog1(\"Received a packet\");\n\tudhcp_dump_packet(packet);\n\n\treturn bytes;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_45897C(_DWORD *a1, int a2)\n{\n  int v2; // edx\n  int v3; // ecx\n  int v4; // r8d\n  int v5; // r9d\n  int v7; // ebx\n  unsigned int v8; // [rsp+1Ch] [rbp-14h]\n\n  memset(a1, 0, 0x274uLL);\n  v8 = sub_40B3FF(a2, a1, 0x274uLL);\n  if ( (v8 & 0x80000000) == 0 )\n  {\n    if ( v8 > 0xEF && (v7 = a1[59], v7 == htonl(0x63825363u)) )\n    {\n      if ( dword_75D460 )\n        sub_4FDABC((unsigned int)\"Received a packet\", (_DWORD)a1, v2, v3, v4, v5);\n      sub_4588D8((__int64)a1);\n      return v8;\n    }\n    else\n    {\n      sub_4FDABC((unsigned int)\"Packet with bad magic, ignoring\", (_DWORD)a1, v2, v3, v4, v5);\n      return 4294967294LL;\n    }\n  }\n  else\n  {\n    if ( dword_75D460 )\n      sub_4FDABC((unsigned int)\"Packet read error, ignoring\", (_DWORD)a1, v2, v3, v4, v5);\n    return v8;\n  }\n}\n",
        "baseline_code_debug": "int __cdecl udhcp_recv_kernel_packet(dhcp_packet *packet, int fd)\n{\n  uint32_t cookie; // ebx\n  int bytes; // [rsp+1Ch] [rbp-14h]\n\n  memset(packet, 0, sizeof(dhcp_packet));\n  bytes = safe_read(fd, packet, 0x274uLL);\n  if ( bytes >= 0 )\n  {\n    if ( (unsigned int)bytes > 0xEF && (cookie = packet->cookie, cookie == htonl(0x63825363u)) )\n    {\n      if ( dhcp_verbose )\n        bb_info_msg(\"Received a packet\");\n      udhcp_dump_packet(packet);\n      return bytes;\n    }\n    else\n    {\n      bb_info_msg(\"Packet with bad magic, ignoring\");\n      return -2;\n    }\n  }\n  else\n  {\n    if ( dhcp_verbose )\n      bb_info_msg(\"Packet read error, ignoring\");\n    return bytes;\n  }\n}\n",
        "similarity_score_unixcoder": 0.04669138044118881,
        "similarity_score_baseline_stripped": 0.5748022198677063,
        "similarity_score_baseline_debug": 0.9289586544036865
    },
    {
        "func_name": "chpasswd_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040DC16 | 55 | push    rbp\n0x0040DC17 | 48 89 E5 | mov     rbp, rsp\n0x0040DC1A | 48 83 EC 40 | sub     rsp, 40h\n0x0040DC1E | 89 7D CC | mov     [rbp+var_34], edi\n0x0040DC21 | 48 89 75 C0 | mov     [rbp+var_40], rsi\n0x0040DC25 | E8 D6 8E FF FF | call    _getuid\n0x0040DC2A | 85 C0 | test    eax, eax\n0x0040DC2C | 74 0F | jz      short loc_40DC3D\n0x0040DC2E | BF 6C 4D 53 00 | mov     edi, offset aPermissionDeni; \"permission denied (are you root?)\"\n0x0040DC33 | B8 00 00 00 00 | mov     eax, 0\n0x0040DC38 | E8 61 BA FF FF | call    sub_40969E\n0x0040DC3D | 48 C7 05 F8 F7 34 00 1B 83 52 00 | mov     cs:qword_75D440, offset aMEEM; \"m--e:e--m\"\n0x0040DC48 | 48 C7 05 F5 F7 34 00 08 83 52 00 | mov     cs:qword_75D448, offset aEncrypted; \"encrypted\"\n0x0040DC53 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x0040DC57 | BE 25 83 52 00 | mov     esi, offset aEm; \"em\"\n0x0040DC5C | 48 89 C7 | mov     rdi, rax\n0x0040DC5F | B8 00 00 00 00 | mov     eax, 0\n0x0040DC64 | E8 86 C5 0E 00 | call    sub_4FA1EF\n0x0040DC69 | 89 45 E8 | mov     [rbp+var_18], eax\n0x0040DC6C | E9 64 01 00 00 | jmp     loc_40DDD5\n0x0040DC71 | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x0040DC75 | BE 3A 00 00 00 | mov     esi, 3Ah ; ':'; c\n0x0040DC7A | 48 89 C7 | mov     rdi, rax; s\n0x0040DC7D | E8 3E 8F FF FF | call    _strchr\n0x0040DC82 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x0040DC86 | 48 83 7D F0 00 | cmp     [rbp+var_10], 0\n0x0040DC8B | 75 0F | jnz     short loc_40DC9C\n0x0040DC8D | BF 28 83 52 00 | mov     edi, offset aMissingNewPass; \"missing new password\"\n0x0040DC92 | B8 00 00 00 00 | mov     eax, 0\n0x0040DC97 | E8 02 BA FF FF | call    sub_40969E\n0x0040DC9C | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0040DCA0 | 48 8D 50 01 | lea     rdx, [rax+1]\n0x0040DCA4 | 48 89 55 F0 | mov     [rbp+var_10], rdx\n0x0040DCA8 | C6 00 00 | mov     byte ptr [rax], 0\n0x0040DCAB | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x0040DCAF | 48 89 C7 | mov     rdi, rax\n0x0040DCB2 | E8 C2 87 0E 00 | call    sub_4F6479\n0x0040DCB7 | 48 C7 45 F8 00 00 00 00 | mov     [rbp+ptr], 0\n0x0040DCBF | 8B 45 E8 | mov     eax, [rbp+var_18]\n0x0040DCC2 | 83 E0 01 | and     eax, 1\n0x0040DCC5 | 85 C0 | test    eax, eax\n0x0040DCC7 | 75 60 | jnz     short loc_40DD29\n0x0040DCC9 | 48 8D 45 D4 | lea     rax, [rbp+var_2C]\n0x0040DCCD | BE 01 00 00 00 | mov     esi, 1\n0x0040DCD2 | 48 89 C7 | mov     rdi, rax\n0x0040DCD5 | E8 C8 6D 0F 00 | call    sub_504AA2\n0x0040DCDA | 8B 45 E8 | mov     eax, [rbp+var_18]\n0x0040DCDD | 83 E0 02 | and     eax, 2\n0x0040DCE0 | 85 C0 | test    eax, eax\n0x0040DCE2 | 74 21 | jz      short loc_40DD05\n0x0040DCE4 | C6 45 D4 24 | mov     [rbp+var_2C], 24h ; '$'\n0x0040DCE8 | C6 45 D5 31 | mov     [rbp+var_2B], 31h ; '1'\n0x0040DCEC | C6 45 D6 24 | mov     [rbp+var_2A], 24h ; '$'\n0x0040DCF0 | 48 8D 45 D4 | lea     rax, [rbp+var_2C]\n0x0040DCF4 | 48 83 C0 03 | add     rax, 3\n0x0040DCF8 | BE 04 00 00 00 | mov     esi, 4\n0x0040DCFD | 48 89 C7 | mov     rdi, rax\n0x0040DD00 | E8 9D 6D 0F 00 | call    sub_504AA2\n0x0040DD05 | 48 8D 4D D4 | lea     rcx, [rbp+var_2C]\n0x0040DD09 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0040DD0D | BA 00 00 00 00 | mov     edx, 0\n0x0040DD12 | 48 89 CE | mov     rsi, rcx\n0x0040DD15 | 48 89 C7 | mov     rdi, rax\n0x0040DD18 | E8 BF 8E 0F 00 | call    sub_506BDC\n0x0040DD1D | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x0040DD21 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0040DD25 | 48 89 45 F8 | mov     [rbp+ptr], rax\n0x0040DD29 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x0040DD2D | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x0040DD31 | B9 00 00 00 00 | mov     ecx, 0\n0x0040DD36 | 48 89 C6 | mov     rsi, rax\n0x0040DD39 | BF 3D 83 52 00 | mov     edi, offset aEtcShadow_1; \"/etc/shadow\"\n0x0040DD3E | E8 38 B9 0F 00 | call    sub_50967B\n0x0040DD43 | 89 45 EC | mov     [rbp+var_14], eax\n0x0040DD46 | 83 7D EC 00 | cmp     [rbp+var_14], 0\n0x0040DD4A | 7E 08 | jle     short loc_40DD54\n0x0040DD4C | 48 C7 45 F0 49 83 52 00 | mov     [rbp+var_10], offset asc_528349; \"x\"\n0x0040DD54 | 83 7D EC 00 | cmp     [rbp+var_14], 0\n0x0040DD58 | 78 1D | js      short loc_40DD77\n0x0040DD5A | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x0040DD5E | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x0040DD62 | B9 00 00 00 00 | mov     ecx, 0\n0x0040DD67 | 48 89 C6 | mov     rsi, rax\n0x0040DD6A | BF 4B 83 52 00 | mov     edi, offset aEtcPasswd_1; \"/etc/passwd\"\n0x0040DD6F | E8 07 B9 0F 00 | call    sub_50967B\n0x0040DD74 | 89 45 EC | mov     [rbp+var_14], eax\n0x0040DD77 | C6 05 9A D0 34 00 03 | mov     cs:byte_75AE18, 3\n0x0040DD7E | 83 7D EC 00 | cmp     [rbp+var_14], 0\n0x0040DD82 | 79 16 | jns     short loc_40DD9A\n0x0040DD84 | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x0040DD88 | 48 89 C6 | mov     rsi, rax\n0x0040DD8B | BF 58 83 52 00 | mov     edi, offset aAnErrorOccurre; \"an error occurred updating password for\"...\n0x0040DD90 | B8 00 00 00 00 | mov     eax, 0\n0x0040DD95 | E8 04 B9 FF FF | call    sub_40969E\n0x0040DD9A | 83 7D EC 00 | cmp     [rbp+var_14], 0\n0x0040DD9E | 74 16 | jz      short loc_40DDB6\n0x0040DDA0 | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x0040DDA4 | 48 89 C6 | mov     rsi, rax\n0x0040DDA7 | BF 83 83 52 00 | mov     edi, offset aPasswordForSCh; \"Password for '%s' changed\"\n0x0040DDAC | B8 00 00 00 00 | mov     eax, 0\n0x0040DDB1 | E8 06 FD 0E 00 | call    sub_4FDABC\n0x0040DDB6 | C6 05 5B D0 34 00 01 | mov     cs:byte_75AE18, 1\n0x0040DDBD | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x0040DDC1 | 48 89 C7 | mov     rdi, rax; ptr\n0x0040DDC4 | E8 97 88 FF FF | call    _free\n0x0040DDC9 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x0040DDCD | 48 89 C7 | mov     rdi, rax; ptr\n0x0040DDD0 | E8 8B 88 FF FF | call    _free\n0x0040DDD5 | 48 8B 05 94 D0 34 00 | mov     rax, cs:stdin\n0x0040DDDC | 48 89 C7 | mov     rdi, rax\n0x0040DDDF | E8 0D C2 0E 00 | call    sub_4F9FF1\n0x0040DDE4 | 48 89 45 E0 | mov     [rbp+s], rax\n0x0040DDE8 | 48 83 7D E0 00 | cmp     [rbp+s], 0\n0x0040DDED | 0F 85 7E FE FF FF | jnz     loc_40DC71\n0x0040DDF3 | B8 00 00 00 00 | mov     eax, 0\n0x0040DDF8 | C9 | leave\n0x0040DDF9 | C3 | retn",
        "output": "",
        "source_code": "int chpasswd_main(int argc UNUSED_PARAM, char **argv)\n{\n\tchar *name;\n\tint opt;\n\n\tif (getuid() != 0)\n\t\tbb_error_msg_and_die(bb_msg_perm_denied_are_you_root);\n\n\topt_complementary = \"m--e:e--m\";\n\tIF_LONG_OPTS(applet_long_options = chpasswd_longopts;)\n\topt = getopt32(argv, \"em\");\n\n\twhile ((name = xmalloc_fgetline(stdin)) != NULL) {\n\t\tchar *free_me;\n\t\tchar *pass;\n\t\tint rc;\n\n\t\tpass = strchr(name, ':');\n\t\tif (!pass)\n\t\t\tbb_error_msg_and_die(\"missing new password\");\n\t\t*pass++ = '\\0';\n\n\t\txuname2uid(name); /* dies if there is no such user */\n\n\t\tfree_me = NULL;\n\t\tif (!(opt & OPT_ENC)) {\n\t\t\tchar salt[sizeof(\"$N$XXXXXXXX\")];\n\n\t\t\tcrypt_make_salt(salt, 1);\n\t\t\tif (opt & OPT_MD5) {\n\t\t\t\tsalt[0] = '$';\n\t\t\t\tsalt[1] = '1';\n\t\t\t\tsalt[2] = '$';\n\t\t\t\tcrypt_make_salt(salt + 3, 4);\n\t\t\t}\n\t\t\tfree_me = pass = pw_encrypt(pass, salt, 0);\n\t\t}\n\n\t\t/* This is rather complex: if user is not found in /etc/shadow,\n\t\t * we try to find & change his passwd in /etc/passwd */\n#if ENABLE_FEATURE_SHADOWPASSWDS\n\t\trc = update_passwd(bb_path_shadow_file, name, pass, NULL);\n\t\tif (rc > 0) /* password in /etc/shadow was updated */\n\t\t\tpass = (char*)\"x\";\n\t\tif (rc >= 0)\n\t\t\t/* 0 = /etc/shadow missing (not an error), >0 = passwd changed in /etc/shadow */\n#endif\n\t\t\trc = update_passwd(bb_path_passwd_file, name, pass, NULL);\n\t\t/* LOGMODE_BOTH logs to syslog also */\n\t\tlogmode = LOGMODE_BOTH;\n\t\tif (rc < 0)\n\t\t\tbb_error_msg_and_die(\"an error occurred updating password for %s\", name);\n\t\tif (rc)\n\t\t\tbb_info_msg(\"Password for '%s' changed\", name);\n\t\tlogmode = LOGMODE_STDIO;\n\t\tfree(name);\n\t\tfree(free_me);\n\t}\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_40DC16(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  char *v10; // rax\n  __int64 v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  __int64 v14; // r9\n  char v16[3]; // [rsp+14h] [rbp-2Ch] BYREF\n  char v17; // [rsp+17h] [rbp-29h] BYREF\n  char *s; // [rsp+20h] [rbp-20h]\n  int v19; // [rsp+28h] [rbp-18h]\n  int v20; // [rsp+2Ch] [rbp-14h]\n  char *v21; // [rsp+30h] [rbp-10h]\n  void *ptr; // [rsp+38h] [rbp-8h]\n\n  if ( getuid() )\n    sub_40969E(\"permission denied (are you root?)\", a2, v2, v3, v4, v5);\n  qword_75D440 = (__int64)\"m--e:e--m\";\n  qword_75D448 = (__int64)\"encrypted\";\n  v19 = sub_4FA1EF(a2, (unsigned int)\"em\", v2, v3, v4, v5, a2);\n  while ( 1 )\n  {\n    s = (char *)sub_4F9FF1(stdin);\n    if ( !s )\n      break;\n    v21 = strchr(s, 58);\n    if ( !v21 )\n      sub_40969E(\"missing new password\", 58LL, v6, v7, v8, v9);\n    v10 = v21++;\n    *v10 = 0;\n    sub_4F6479(s);\n    ptr = 0LL;\n    if ( (v19 & 1) == 0 )\n    {\n      sub_504AA2(v16, 1LL);\n      if ( (v19 & 2) != 0 )\n      {\n        qmemcpy(v16, \"$1$\", sizeof(v16));\n        sub_504AA2(&v17, 4LL);\n      }\n      v21 = (char *)sub_506BDC(v21, v16, 0LL);\n      ptr = v21;\n    }\n    v20 = sub_50967B(\"/etc/shadow\", s, v21, 0LL);\n    if ( v20 > 0 )\n      v21 = \"x\";\n    if ( v20 >= 0 )\n      v20 = sub_50967B(\"/etc/passwd\", s, v21, 0LL);\n    byte_75AE18 = 3;\n    if ( v20 < 0 )\n      sub_40969E(\"an error occurred updating password for %s\", (__int64)s, v11, v12, v13, v14);\n    if ( v20 )\n      sub_4FDABC((unsigned int)\"Password for '%s' changed\", (_DWORD)s, v11, v12, v13, v14);\n    byte_75AE18 = 1;\n    free(s);\n    free(ptr);\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl chpasswd_main(int argc, char **argv)\n{\n  char *v2; // rax\n  char salt[12]; // [rsp+14h] [rbp-2Ch] BYREF\n  char *name; // [rsp+20h] [rbp-20h]\n  int opt; // [rsp+28h] [rbp-18h]\n  int rc; // [rsp+2Ch] [rbp-14h]\n  char *pass; // [rsp+30h] [rbp-10h]\n  char *free_me; // [rsp+38h] [rbp-8h]\n\n  if ( getuid() )\n    bb_error_msg_and_die(\"permission denied (are you root?)\");\n  opt_complementary = \"m--e:e--m\";\n  applet_long_options = chpasswd_longopts;\n  opt = getopt32(argv, \"em\");\n  while ( 1 )\n  {\n    name = xmalloc_fgetline(stdin);\n    if ( !name )\n      break;\n    pass = strchr(name, 58);\n    if ( !pass )\n      bb_error_msg_and_die(\"missing new password\");\n    v2 = pass++;\n    *v2 = 0;\n    xuname2uid(name);\n    free_me = 0LL;\n    if ( (opt & 1) == 0 )\n    {\n      crypt_make_salt(salt, 1);\n      if ( (opt & 2) != 0 )\n      {\n        qmemcpy(salt, \"$1$\", 3);\n        crypt_make_salt(&salt[3], 4);\n      }\n      pass = pw_encrypt(pass, salt, 0);\n      free_me = pass;\n    }\n    rc = update_passwd(\"/etc/shadow\", name, pass, 0LL);\n    if ( rc > 0 )\n      pass = \"x\";\n    if ( rc >= 0 )\n      rc = update_passwd(\"/etc/passwd\", name, pass, 0LL);\n    logmode = 3;\n    if ( rc < 0 )\n      bb_error_msg_and_die(\"an error occurred updating password for %s\", name);\n    if ( rc )\n      bb_info_msg(\"Password for '%s' changed\", name);\n    logmode = 1;\n    free(name);\n    free(free_me);\n  }\n  return 0;\n}\n",
        "similarity_score_unixcoder": -0.02483786642551422,
        "similarity_score_baseline_stripped": 0.6942784786224365,
        "similarity_score_baseline_debug": 0.9099503755569458
    },
    {
        "func_name": "read_big_block",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0041A1AA | 55 | push    rbp\n0x0041A1AB | 48 89 E5 | mov     rbp, rsp\n0x0041A1AE | 48 83 EC 20 | sub     rsp, 20h\n0x0041A1B2 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0041A1B6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0041A1BA | BA 00 00 10 00 | mov     edx, 100000h\n0x0041A1BF | 48 89 C6 | mov     rsi, rax\n0x0041A1C2 | BF 03 00 00 00 | mov     edi, 3\n0x0041A1C7 | E8 86 D2 0E 00 | call    sub_507452\n0x0041A1CC | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x0041A1D3 | EB 29 | jmp     short loc_41A1FE\n0x0041A1D5 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0041A1D8 | 48 63 D0 | movsxd  rdx, eax\n0x0041A1DB | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0041A1DF | 48 01 D0 | add     rax, rdx\n0x0041A1E2 | 0F B6 10 | movzx   edx, byte ptr [rax]\n0x0041A1E5 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0041A1E8 | 48 63 C8 | movsxd  rcx, eax\n0x0041A1EB | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0041A1EF | 48 01 C8 | add     rax, rcx\n0x0041A1F2 | 83 E2 01 | and     edx, 1\n0x0041A1F5 | 88 10 | mov     [rax], dl\n0x0041A1F7 | 81 45 FC 00 02 00 00 | add     [rbp+var_4], 200h\n0x0041A1FE | 81 7D FC FF FF 0F 00 | cmp     [rbp+var_4], 0FFFFFh\n0x0041A205 | 7E CE | jle     short loc_41A1D5\n0x0041A207 | 90 | nop\n0x0041A208 | C9 | leave\n0x0041A209 | C3 | retn",
        "output": "",
        "source_code": "static void read_big_block(/*int fd,*/ char *buf)\n{\n\tint i;\n\n\txread(fd, buf, TIMING_BUF_BYTES);\n\t/* access all sectors of buf to ensure the read fully completed */\n\tfor (i = 0; i < TIMING_BUF_BYTES; i += 512)\n\t\tbuf[i] &= 1;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "_BYTE *__fastcall sub_41A1AA(__int64 a1)\n{\n  _BYTE *result; // rax\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  result = (_BYTE *)sub_507452(3LL, a1, 0x100000LL);\n  for ( i = 0; i <= 0xFFFFF; i += 512 )\n  {\n    result = (_BYTE *)(i + a1);\n    *result &= 1u;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl read_big_block(char *buf)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  xread(3, buf, 0x100000uLL);\n  for ( i = 0; i <= 0xFFFFF; i += 512 )\n    buf[i] &= 1u;\n}\n",
        "similarity_score_unixcoder": 0.07343591749668121,
        "similarity_score_baseline_stripped": 0.49999451637268066,
        "similarity_score_baseline_debug": 0.6921022534370422
    },
    {
        "func_name": "rc_get_bit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004BB517 | 55 | push    rbp\n0x004BB518 | 48 89 E5 | mov     rbp, rsp\n0x004BB51B | 48 83 EC 30 | sub     rsp, 30h\n0x004BB51F | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004BB523 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004BB527 | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x004BB52B | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x004BB52F | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004BB533 | 48 89 D6 | mov     rsi, rdx\n0x004BB536 | 48 89 C7 | mov     rdi, rax\n0x004BB539 | E8 02 FF FF FF | call    sub_4BB440\n0x004BB53E | 89 45 FC | mov     [rbp+var_4], eax\n0x004BB541 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004BB545 | 8B 00 | mov     eax, [rax]\n0x004BB547 | 8D 14 00 | lea     edx, [rax+rax]\n0x004BB54A | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004BB54D | 01 C2 | add     edx, eax\n0x004BB54F | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004BB553 | 89 10 | mov     [rax], edx\n0x004BB555 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004BB558 | C9 | leave\n0x004BB559 | C3 | retn",
        "output": "",
        "source_code": "static speed_inline int rc_get_bit(rc_t *rc, uint16_t *p, int *symbol)\n{\n\tint ret = rc_is_bit_1(rc, p);\n\t*symbol = *symbol * 2 + ret;\n\treturn ret;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4BB517(_DWORD *a1, _WORD *a2, _DWORD *a3)\n{\n  __int64 result; // rax\n\n  LODWORD(result) = sub_4BB440(a1, a2);\n  *a3 = result + 2 * *a3;\n  return (unsigned int)result;\n}\n",
        "baseline_code_debug": "int __cdecl rc_get_bit(rc_t *rc, uint16_t *p, int *symbol)\n{\n  int result; // eax\n\n  result = rc_is_bit_1(rc, p);\n  *symbol = result + 2 * *symbol;\n  return result;\n}\n",
        "similarity_score_unixcoder": 0.11512994766235352,
        "similarity_score_baseline_stripped": 0.5090862512588501,
        "similarity_score_baseline_debug": 0.8854587078094482
    },
    {
        "func_name": "print_char",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004CDB91 | 55 | push    rbp\n0x004CDB92 | 48 89 E5 | mov     rbp, rsp\n0x004CDB95 | 48 83 EC 30 | sub     rsp, 30h\n0x004CDB99 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004CDB9D | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004CDBA1 | 48 89 55 D8 | mov     [rbp+format], rdx\n0x004CDBA5 | EB 28 | jmp     short loc_4CDBCF\n0x004CDBA7 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004CDBAB | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004CDBAE | 0F B6 C0 | movzx   eax, al\n0x004CDBB1 | 89 45 FC | mov     [rbp+var_4], eax\n0x004CDBB4 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x004CDBB7 | 48 8B 45 D8 | mov     rax, [rbp+format]\n0x004CDBBB | 89 D6 | mov     esi, edx\n0x004CDBBD | 48 89 C7 | mov     rdi, rax; format\n0x004CDBC0 | B8 00 00 00 00 | mov     eax, 0\n0x004CDBC5 | E8 06 90 F3 FF | call    _printf\n0x004CDBCA | 48 83 45 E0 01 | add     [rbp+var_20], 1\n0x004CDBCF | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CDBD3 | 48 8D 50 FF | lea     rdx, [rax-1]\n0x004CDBD7 | 48 89 55 E8 | mov     [rbp+var_18], rdx\n0x004CDBDB | 48 85 C0 | test    rax, rax\n0x004CDBDE | 75 C7 | jnz     short loc_4CDBA7\n0x004CDBE0 | 90 | nop\n0x004CDBE1 | C9 | leave\n0x004CDBE2 | C3 | retn",
        "output": "",
        "source_code": "static void\nprint_char(size_t n_bytes, const char *block, const char *fmt_string)\n{\n\twhile (n_bytes--) {\n\t\tunsigned tmp = *(unsigned char *) block;\n\t\tprintf(fmt_string, tmp);\n\t\tblock += sizeof(unsigned char);\n\t}\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4CDB91(__int64 a1, unsigned __int8 *a2, const char *a3)\n{\n  __int64 result; // rax\n\n  while ( 1 )\n  {\n    result = a1--;\n    if ( !result )\n      break;\n    printf(a3, *a2++);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl print_char(size_t n_bytes, const char *block, const char *fmt_string)\n{\n  while ( n_bytes-- )\n    printf(fmt_string, *(unsigned __int8 *)block++);\n}\n",
        "similarity_score_unixcoder": 0.04587359353899956,
        "similarity_score_baseline_stripped": 0.633916974067688,
        "similarity_score_baseline_debug": 0.9284946918487549
    },
    {
        "func_name": "pivot_root_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004A32AA | 55 | push    rbp\n0x004A32AB | 48 89 E5 | mov     rbp, rsp\n0x004A32AE | 48 83 EC 10 | sub     rsp, 10h\n0x004A32B2 | 89 7D FC | mov     [rbp+var_4], edi\n0x004A32B5 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004A32B9 | 83 7D FC 03 | cmp     [rbp+var_4], 3\n0x004A32BD | 74 05 | jz      short loc_4A32C4\n0x004A32BF | E8 A0 4C F6 FF | call    sub_407F64\n0x004A32C4 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004A32C8 | 48 83 C0 10 | add     rax, 10h\n0x004A32CC | 48 8B 10 | mov     rdx, [rax]\n0x004A32CF | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004A32D3 | 48 83 C0 08 | add     rax, 8\n0x004A32D7 | 48 8B 00 | mov     rax, [rax]\n0x004A32DA | 48 89 D6 | mov     rsi, rdx\n0x004A32DD | 48 89 C7 | mov     rdi, rax\n0x004A32E0 | E8 EB 46 F6 FF | call    _pivot_root\n0x004A32E5 | 85 C0 | test    eax, eax\n0x004A32E7 | 79 05 | jns     short loc_4A32EE\n0x004A32E9 | E8 66 FA 05 00 | call    sub_502D54\n0x004A32EE | B8 00 00 00 00 | mov     eax, 0\n0x004A32F3 | C9 | leave\n0x004A32F4 | C3 | retn",
        "output": "",
        "source_code": "int pivot_root_main(int argc, char **argv)\n{\n\tif (argc != 3)\n\t\tbb_show_usage();\n\n\tif (pivot_root(argv[1], argv[2]) < 0) {\n\t\t/* prints \"pivot_root: <strerror text>\" */\n\t\tbb_perror_nomsg_and_die();\n\t}\n\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4A32AA(__int64 a1, __int64 a2)\n{\n  if ( (_DWORD)a1 != 3 )\n    sub_407F64(a1);\n  if ( (int)pivot_root(*(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16)) < 0 )\n    sub_502D54();\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl pivot_root_main(int argc, char **argv)\n{\n  if ( argc != 3 )\n    bb_show_usage();\n  if ( (int)pivot_root(argv[1], argv[2]) < 0 )\n    bb_perror_nomsg_and_die();\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.06535463035106659,
        "similarity_score_baseline_stripped": 0.5956843495368958,
        "similarity_score_baseline_debug": 0.885185718536377
    },
    {
        "func_name": "out_args",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00464183 | 55 | push    rbp\n0x00464184 | 48 89 E5 | mov     rbp, rsp\n0x00464187 | 48 83 EC 30 | sub     rsp, 30h\n0x0046418B | 48 89 7D D8 | mov     [rbp+var_28], rdi\n0x0046418F | C7 45 F4 00 00 00 00 | mov     [rbp+var_C], 0\n0x00464196 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x0046419A | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0046419E | EB 7D | jmp     short loc_46421D\n0x004641A0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004641A4 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004641A7 | 3C 5C | cmp     al, 5Ch ; '\\'\n0x004641A9 | 75 10 | jnz     short loc_4641BB\n0x004641AB | BF C9 61 53 00 | mov     edi, offset asc_5361C9; \"\\\\\\\\\"\n0x004641B0 | E8 7D FC FF FF | call    sub_463E32\n0x004641B5 | 83 45 F4 02 | add     [rbp+var_C], 2\n0x004641B9 | EB 5D | jmp     short loc_464218\n0x004641BB | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004641BF | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004641C2 | 3C 1F | cmp     al, 1Fh\n0x004641C4 | 7E 22 | jle     short loc_4641E8\n0x004641C6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004641CA | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004641CD | 3C 7F | cmp     al, 7Fh\n0x004641CF | 74 17 | jz      short loc_4641E8\n0x004641D1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004641D5 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004641D8 | 0F BE C0 | movsx   eax, al\n0x004641DB | 89 C7 | mov     edi, eax\n0x004641DD | E8 F3 FB FF FF | call    sub_463DD5\n0x004641E2 | 83 45 F4 01 | add     [rbp+var_C], 1\n0x004641E6 | EB 30 | jmp     short loc_464218\n0x004641E8 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004641EC | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004641EF | 0F B6 D0 | movzx   edx, al\n0x004641F2 | 48 8D 45 EF | lea     rax, [rbp+s]\n0x004641F6 | BE CC 61 53 00 | mov     esi, offset a03o; \"\\\\%03o\"\n0x004641FB | 48 89 C7 | mov     rdi, rax; s\n0x004641FE | B8 00 00 00 00 | mov     eax, 0\n0x00464203 | E8 78 38 FA FF | call    _sprintf\n0x00464208 | 48 8D 45 EF | lea     rax, [rbp+s]\n0x0046420C | 48 89 C7 | mov     rdi, rax\n0x0046420F | E8 1E FC FF FF | call    sub_463E32\n0x00464214 | 83 45 F4 04 | add     [rbp+var_C], 4\n0x00464218 | 48 83 45 F8 01 | add     [rbp+var_8], 1\n0x0046421D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00464221 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00464224 | 84 C0 | test    al, al\n0x00464226 | 0F 85 74 FF FF FF | jnz     loc_4641A0\n0x0046422C | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x0046422F | C9 | leave\n0x00464230 | C3 | retn",
        "output": "",
        "source_code": "static int out_args(const char *mystr)\n{\n\tconst char *here;\n\tint strcount = 0;\n\tchar tmpstr[5];\n\n\tfor (here = mystr; *here; here++) {\n\t\tif (*here == '\\\\') {\n\t\t\tout_string(\"\\\\\\\\\");\n\t\t\tstrcount += 2;\n\t\t} else if (*here >= ' ' && *here < 0x7f) {\n\t\t\tout_char(*here);\n\t\t\tstrcount++;\n\t\t} else {\n\t\t\tsprintf(tmpstr, \"\\\\%03o\", (unsigned char) *here);\n\t\t\tout_string(tmpstr);\n\t\t\tstrcount += 4;\n\t\t}\n\t}\n\n\treturn strcount;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_464183(char *a1)\n{\n  char s[5]; // [rsp+1Fh] [rbp-11h] BYREF\n  unsigned int v3; // [rsp+24h] [rbp-Ch]\n  char *i; // [rsp+28h] [rbp-8h]\n\n  v3 = 0;\n  for ( i = a1; *i; ++i )\n  {\n    if ( *i == 92 )\n    {\n      sub_463E32(\"\\\\\\\\\");\n      v3 += 2;\n    }\n    else if ( *i <= 31 || *i == 127 )\n    {\n      sprintf(s, \"\\\\%03o\", (unsigned __int8)*i);\n      sub_463E32(s);\n      v3 += 4;\n    }\n    else\n    {\n      sub_463DD5(*i);\n      ++v3;\n    }\n  }\n  return v3;\n}\n",
        "baseline_code_debug": "int __cdecl out_args(const char *mystr)\n{\n  char tmpstr[5]; // [rsp+1Fh] [rbp-11h] BYREF\n  int strcount; // [rsp+24h] [rbp-Ch]\n  const char *here; // [rsp+28h] [rbp-8h]\n\n  strcount = 0;\n  for ( here = mystr; *here; ++here )\n  {\n    if ( *here == 92 )\n    {\n      out_string(\"\\\\\\\\\");\n      strcount += 2;\n    }\n    else if ( *here <= 31 || *here == 127 )\n    {\n      sprintf(tmpstr, \"\\\\%03o\", *(unsigned __int8 *)here);\n      out_string(tmpstr);\n      strcount += 4;\n    }\n    else\n    {\n      out_char(*here);\n      ++strcount;\n    }\n  }\n  return strcount;\n}\n",
        "similarity_score_unixcoder": 0.06179209053516388,
        "similarity_score_baseline_stripped": 0.647746205329895,
        "similarity_score_baseline_debug": 0.8625788688659668
    },
    {
        "func_name": "rtnl_rtcache_request",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0044DBD3 | 55 | push    rbp\n0x0044DBD4 | 48 89 E5 | mov     rbp, rsp\n0x0044DBD7 | 48 83 EC 40 | sub     rsp, 40h\n0x0044DBDB | 48 89 7D C8 | mov     [rbp+var_38], rdi\n0x0044DBDF | 89 75 C4 | mov     [rbp+var_3C], esi\n0x0044DBE2 | 48 8D 45 D4 | lea     rax, [rbp+s]\n0x0044DBE6 | BA 0C 00 00 00 | mov     edx, 0Ch; n\n0x0044DBEB | BE 00 00 00 00 | mov     esi, 0; c\n0x0044DBF0 | 48 89 C7 | mov     rdi, rax; s\n0x0044DBF3 | E8 58 91 FB FF | call    _memset\n0x0044DBF8 | 48 8D 45 E0 | lea     rax, [rbp+var_20]\n0x0044DBFC | BA 1C 00 00 00 | mov     edx, 1Ch; n\n0x0044DC01 | BE 00 00 00 00 | mov     esi, 0; c\n0x0044DC06 | 48 89 C7 | mov     rdi, rax; s\n0x0044DC09 | E8 42 91 FB FF | call    _memset\n0x0044DC0E | 66 C7 45 D4 10 00 | mov     [rbp+s], 10h\n0x0044DC14 | C7 45 E0 1C 00 00 00 | mov     [rbp+var_20], 1Ch\n0x0044DC1B | 66 C7 45 E4 1A 00 | mov     [rbp+var_1C], 1Ah\n0x0044DC21 | 66 C7 45 E6 01 01 | mov     [rbp+var_1A], 101h\n0x0044DC27 | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x0044DC2B | 8B 40 1C | mov     eax, [rax+1Ch]\n0x0044DC2E | 8D 50 01 | lea     edx, [rax+1]\n0x0044DC31 | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x0044DC35 | 89 50 1C | mov     [rax+1Ch], edx\n0x0044DC38 | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x0044DC3C | 8B 50 1C | mov     edx, [rax+1Ch]\n0x0044DC3F | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x0044DC43 | 89 50 20 | mov     [rax+20h], edx\n0x0044DC46 | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x0044DC4A | 8B 40 20 | mov     eax, [rax+20h]\n0x0044DC4D | 89 45 E8 | mov     [rbp+var_18], eax\n0x0044DC50 | 8B 45 C4 | mov     eax, [rbp+var_3C]\n0x0044DC53 | 88 45 F0 | mov     [rbp+var_10], al\n0x0044DC56 | C7 45 F8 00 02 00 00 | mov     [rbp+var_8], 200h\n0x0044DC5D | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x0044DC61 | 8B 00 | mov     eax, [rax]\n0x0044DC63 | 48 8D 55 D4 | lea     rdx, [rbp+s]\n0x0044DC67 | 48 8D 75 E0 | lea     rsi, [rbp+var_20]\n0x0044DC6B | 41 B8 0C 00 00 00 | mov     r8d, 0Ch\n0x0044DC71 | 48 89 D1 | mov     rcx, rdx\n0x0044DC74 | BA 1C 00 00 00 | mov     edx, 1Ch\n0x0044DC79 | 89 C7 | mov     edi, eax\n0x0044DC7B | E8 C8 CD FB FF | call    sub_40AA48\n0x0044DC80 | C9 | leave\n0x0044DC81 | C3 | retn",
        "output": "",
        "source_code": "static int rtnl_rtcache_request(struct rtnl_handle *rth, int family)\n{\n\tstruct {\n\t\tstruct nlmsghdr nlh;\n\t\tstruct rtmsg rtm;\n\t} req;\n\tstruct sockaddr_nl nladdr;\n\n\tmemset(&nladdr, 0, sizeof(nladdr));\n\tmemset(&req, 0, sizeof(req));\n\tnladdr.nl_family = AF_NETLINK;\n\n\treq.nlh.nlmsg_len = sizeof(req);\n\tif (RTM_GETROUTE)\n\t\treq.nlh.nlmsg_type = RTM_GETROUTE;\n\tif (NLM_F_ROOT | NLM_F_REQUEST)\n\t\treq.nlh.nlmsg_flags = NLM_F_ROOT | NLM_F_REQUEST;\n\t/*req.nlh.nlmsg_pid = 0; - memset did it already */\n\treq.nlh.nlmsg_seq = rth->dump = ++rth->seq;\n\treq.rtm.rtm_family = family;\n\tif (RTM_F_CLONED)\n\t\treq.rtm.rtm_flags = RTM_F_CLONED;\n\n\treturn xsendto(rth->fd, (void*)&req, sizeof(req), (struct sockaddr*)&nladdr, sizeof(nladdr));\n}",
        "parsed_output": "",
        "baseline_code_stripped": "ssize_t __fastcall sub_44DBD3(int *a1, char a2)\n{\n  struct sockaddr s; // [rsp+14h] [rbp-2Ch] BYREF\n  __int16 v4; // [rsp+24h] [rbp-1Ch]\n  __int16 v5; // [rsp+26h] [rbp-1Ah]\n  int v6; // [rsp+28h] [rbp-18h]\n  char v7; // [rsp+30h] [rbp-10h]\n  int v8; // [rsp+38h] [rbp-8h]\n\n  memset(&s, 0, 0xCuLL);\n  memset(&s.sa_data[10], 0, 0x1CuLL);\n  s.sa_family = 16;\n  *(_DWORD *)&s.sa_data[10] = 28;\n  v4 = 26;\n  v5 = 257;\n  a1[8] = ++a1[7];\n  v6 = a1[8];\n  v7 = a2;\n  v8 = 512;\n  return sub_40AA48(*a1, &s.sa_data[10], 0x1CuLL, &s, 0xCu);\n}\n",
        "baseline_code_debug": "int __cdecl rtnl_rtcache_request(rtnl_handle *rth, int family)\n{\n  sockaddr_nl nladdr; // [rsp+14h] [rbp-2Ch] BYREF\n  rtnl_rtcache_request::$1492BE4ADC39CA43DF839E93F37835AF req; // [rsp+20h] [rbp-20h] BYREF\n\n  memset(&nladdr, 0, sizeof(nladdr));\n  memset(&req, 0, sizeof(req));\n  nladdr.nl_family = 16;\n  req.nlh.nlmsg_len = 28;\n  req.nlh.nlmsg_type = 26;\n  req.nlh.nlmsg_flags = 257;\n  rth->dump = ++rth->seq;\n  req.nlh.nlmsg_seq = rth->dump;\n  req.rtm.rtm_family = family;\n  req.rtm.rtm_flags = 512;\n  return xsendto(rth->fd, &req, 0x1CuLL, (const sockaddr *)&nladdr, 0xCu);\n}\n",
        "similarity_score_unixcoder": 0.06864668428897858,
        "similarity_score_baseline_stripped": 0.4541364312171936,
        "similarity_score_baseline_debug": 0.8757914900779724
    },
    {
        "func_name": "unalias",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004707B3 | 55 | push    rbp\n0x004707B4 | 48 89 E5 | mov     rbp, rsp\n0x004707B7 | 48 83 EC 20 | sub     rsp, 20h\n0x004707BB | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004707BF | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004707C3 | 48 89 C7 | mov     rdi, rax\n0x004707C6 | E8 97 FD FF FF | call    sub_470562\n0x004707CB | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004707CF | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004707D3 | 48 8B 00 | mov     rax, [rax]\n0x004707D6 | 48 85 C0 | test    rax, rax\n0x004707D9 | 74 35 | jz      short loc_470810\n0x004707DB | 48 8B 05 36 CC 2E 00 | mov     rax, cs:qword_75D418\n0x004707E2 | 8B 50 30 | mov     edx, [rax+30h]\n0x004707E5 | 83 C2 01 | add     edx, 1\n0x004707E8 | 89 50 30 | mov     [rax+30h], edx\n0x004707EB | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004707EF | 48 8B 00 | mov     rax, [rax]\n0x004707F2 | 48 89 C7 | mov     rdi, rax\n0x004707F5 | E8 6E FE FF FF | call    sub_470668\n0x004707FA | 48 89 C2 | mov     rdx, rax\n0x004707FD | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00470801 | 48 89 10 | mov     [rax], rdx\n0x00470804 | E8 36 D8 FF FF | call    sub_46E03F\n0x00470809 | B8 00 00 00 00 | mov     eax, 0\n0x0047080E | EB 05 | jmp     short locret_470815\n0x00470810 | B8 01 00 00 00 | mov     eax, 1\n0x00470815 | C9 | leave\n0x00470816 | C3 | retn",
        "output": "",
        "source_code": "static int\nunalias(const char *name)\n{\n\tstruct alias **app;\n\n\tapp = __lookupalias(name);\n\n\tif (*app) {\n\t\tINT_OFF;\n\t\t*app = freealias(*app);\n\t\tINT_ON;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4707B3(const char *a1, __int64 a2)\n{\n  void **v2; // rdi\n  void ***v4; // [rsp+18h] [rbp-8h]\n\n  v4 = (void ***)sub_470562(a1);\n  if ( !*v4 )\n    return 1LL;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  v2 = *v4;\n  *v4 = sub_470668(*v4);\n  sub_46E03F(v2, a2);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl unalias(const char *name)\n{\n  alias **app; // [rsp+18h] [rbp-8h]\n\n  app = _lookupalias(name);\n  if ( !*app )\n    return 1;\n  ++ash_ptr_to_globals_misc->suppress_int;\n  *app = freealias(*app);\n  int_on();\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.15461860597133636,
        "similarity_score_baseline_stripped": 0.4393694996833801,
        "similarity_score_baseline_debug": 0.7727838754653931
    },
    {
        "func_name": "step_time",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043BDFE | 55 | push    rbp\n0x0043BDFF | 48 89 E5 | mov     rbp, rsp\n0x0043BE02 | 48 83 C4 80 | add     rsp, 0FFFFFFFFFFFFFF80h\n0x0043BE06 | F2 0F 11 45 88 | movsd   [rbp+var_78], xmm0\n0x0043BE0B | 48 8D 45 D0 | lea     rax, [rbp+tv]\n0x0043BE0F | BE 00 00 00 00 | mov     esi, 0; tz\n0x0043BE14 | 48 89 C7 | mov     rdi, rax; tv\n0x0043BE17 | E8 A4 AE FC FF | call    _gettimeofday\n0x0043BE1C | 48 8B 45 D0 | mov     rax, [rbp+tv.tv_sec]\n0x0043BE20 | F2 48 0F 2A C8 | cvtsi2sd xmm1, rax\n0x0043BE25 | 48 8B 45 D8 | mov     rax, [rbp+tv.tv_usec]\n0x0043BE29 | F2 48 0F 2A D0 | cvtsi2sd xmm2, rax\n0x0043BE2E | F2 0F 10 05 E2 9E 0E 00 | movsd   xmm0, cs:qword_525D18\n0x0043BE36 | F2 0F 59 C2 | mulsd   xmm0, xmm2\n0x0043BE3A | F2 0F 58 C1 | addsd   xmm0, xmm1\n0x0043BE3E | F2 0F 10 4D 88 | movsd   xmm1, [rbp+var_78]\n0x0043BE43 | F2 0F 58 C1 | addsd   xmm0, xmm1\n0x0043BE47 | F2 0F 11 45 F0 | movsd   [rbp+var_10], xmm0\n0x0043BE4C | 48 8D 45 C0 | lea     rax, [rbp+var_40]\n0x0043BE50 | F2 0F 10 45 F0 | movsd   xmm0, [rbp+var_10]\n0x0043BE55 | 48 89 C7 | mov     rdi, rax\n0x0043BE58 | E8 D6 F3 FF FF | call    sub_43B233\n0x0043BE5D | 48 8D 45 C0 | lea     rax, [rbp+var_40]\n0x0043BE61 | BE 00 00 00 00 | mov     esi, 0; tz\n0x0043BE66 | 48 89 C7 | mov     rdi, rax; tv\n0x0043BE69 | E8 12 B4 FC FF | call    _settimeofday\n0x0043BE6E | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x0043BE71 | 75 0F | jnz     short loc_43BE82\n0x0043BE73 | BF A5 5A 52 00 | mov     edi, offset aSettimeofday_0; \"settimeofday\"\n0x0043BE78 | B8 00 00 00 00 | mov     eax, 0\n0x0043BE7D | E8 20 D4 FC FF | call    sub_4092A2\n0x0043BE82 | 48 8B 05 7F 15 32 00 | mov     rax, cs:qword_75D408\n0x0043BE89 | 8B 40 3C | mov     eax, [rax+3Ch]\n0x0043BE8C | 83 F8 01 | cmp     eax, 1\n0x0043BE8F | 76 4C | jbe     short loc_43BEDD\n0x0043BE91 | 48 8B 45 D0 | mov     rax, [rbp+tv.tv_sec]\n0x0043BE95 | 48 89 45 98 | mov     [rbp+timer], rax\n0x0043BE99 | 48 8D 45 98 | lea     rax, [rbp+timer]\n0x0043BE9D | 48 89 C7 | mov     rdi, rax; timer\n0x0043BEA0 | E8 3B A8 FC FF | call    _localtime\n0x0043BEA5 | 48 89 C2 | mov     rdx, rax\n0x0043BEA8 | 48 8D 45 A0 | lea     rax, [rbp+s]\n0x0043BEAC | 48 89 D1 | mov     rcx, rdx; tp\n0x0043BEAF | BA B2 5A 52 00 | mov     edx, offset aYMDHMS; \"%Y-%m-%d %H:%M:%S\"\n0x0043BEB4 | BE 18 00 00 00 | mov     esi, 18h; maxsize\n0x0043BEB9 | 48 89 C7 | mov     rdi, rax; s\n0x0043BEBC | E8 1F B8 FC FF | call    _strftime\n0x0043BEC1 | 48 8B 45 D8 | mov     rax, [rbp+tv.tv_usec]\n0x0043BEC5 | 89 C2 | mov     edx, eax\n0x0043BEC7 | 48 8D 45 A0 | lea     rax, [rbp+s]\n0x0043BECB | 48 89 C6 | mov     rsi, rax\n0x0043BECE | BF C4 5A 52 00 | mov     edi, offset aCurrentTimeIsS; \"current time is %s.%06u\"\n0x0043BED3 | B8 00 00 00 00 | mov     eax, 0\n0x0043BED8 | E8 6A D8 FC FF | call    sub_409747\n0x0043BEDD | 48 8B 45 C0 | mov     rax, [rbp+var_40.tv_sec]\n0x0043BEE1 | 48 89 45 98 | mov     [rbp+timer], rax\n0x0043BEE5 | 48 8D 45 98 | lea     rax, [rbp+timer]\n0x0043BEE9 | 48 89 C7 | mov     rdi, rax; timer\n0x0043BEEC | E8 EF A7 FC FF | call    _localtime\n0x0043BEF1 | 48 89 C2 | mov     rdx, rax\n0x0043BEF4 | 48 8D 45 A0 | lea     rax, [rbp+s]\n0x0043BEF8 | 48 89 D1 | mov     rcx, rdx; tp\n0x0043BEFB | BA B2 5A 52 00 | mov     edx, offset aYMDHMS; \"%Y-%m-%d %H:%M:%S\"\n0x0043BF00 | BE 18 00 00 00 | mov     esi, 18h; maxsize\n0x0043BF05 | 48 89 C7 | mov     rdi, rax; s\n0x0043BF08 | E8 D3 B7 FC FF | call    _strftime\n0x0043BF0D | 48 8B 45 C8 | mov     rax, [rbp+var_40.tv_usec]\n0x0043BF11 | 89 C2 | mov     edx, eax\n0x0043BF13 | F2 0F 10 45 88 | movsd   xmm0, [rbp+var_78]\n0x0043BF18 | 48 8D 45 A0 | lea     rax, [rbp+s]\n0x0043BF1C | 48 89 C6 | mov     rsi, rax\n0x0043BF1F | BF E0 5A 52 00 | mov     edi, offset aSettingTimeToS; \"setting time to %s.%06u (offset %+fs)\"\n0x0043BF24 | B8 01 00 00 00 | mov     eax, 1\n0x0043BF29 | E8 19 D8 FC FF | call    sub_409747\n0x0043BF2E | 48 8B 05 D3 14 32 00 | mov     rax, cs:qword_75D408\n0x0043BF35 | F2 0F 10 00 | movsd   xmm0, qword ptr [rax]\n0x0043BF39 | 48 8B 05 C8 14 32 00 | mov     rax, cs:qword_75D408\n0x0043BF40 | F2 0F 58 45 88 | addsd   xmm0, [rbp+var_78]\n0x0043BF45 | F2 0F 11 00 | movsd   qword ptr [rax], xmm0\n0x0043BF49 | 48 8B 05 B8 14 32 00 | mov     rax, cs:qword_75D408\n0x0043BF50 | F2 0F 10 40 70 | movsd   xmm0, qword ptr [rax+70h]\n0x0043BF55 | 48 8B 05 AC 14 32 00 | mov     rax, cs:qword_75D408\n0x0043BF5C | F2 0F 58 45 88 | addsd   xmm0, [rbp+var_78]\n0x0043BF61 | F2 0F 11 40 70 | movsd   qword ptr [rax+70h], xmm0\n0x0043BF66 | 48 8B 05 9B 14 32 00 | mov     rax, cs:qword_75D408\n0x0043BF6D | F2 0F 10 40 20 | movsd   xmm0, qword ptr [rax+20h]\n0x0043BF72 | 48 8B 05 8F 14 32 00 | mov     rax, cs:qword_75D408\n0x0043BF79 | F2 0F 58 45 88 | addsd   xmm0, [rbp+var_78]\n0x0043BF7E | F2 0F 11 40 20 | movsd   qword ptr [rax+20h], xmm0\n0x0043BF83 | 48 8B 05 7E 14 32 00 | mov     rax, cs:qword_75D408\n0x0043BF8A | 48 8B 40 30 | mov     rax, [rax+30h]\n0x0043BF8E | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0043BF92 | EB 74 | jmp     short loc_43C008\n0x0043BF94 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043BF98 | 48 8B 40 08 | mov     rax, [rax+8]\n0x0043BF9C | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x0043BFA0 | F2 0F 10 45 88 | movsd   xmm0, [rbp+var_78]\n0x0043BFA5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043BFA9 | 48 89 C7 | mov     rdi, rax\n0x0043BFAC | E8 9B F7 FF FF | call    sub_43B74C\n0x0043BFB1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043BFB5 | F2 0F 10 40 20 | movsd   xmm0, qword ptr [rax+20h]\n0x0043BFBA | F2 0F 58 45 88 | addsd   xmm0, [rbp+var_78]\n0x0043BFBF | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043BFC3 | F2 0F 11 40 20 | movsd   qword ptr [rax+20h], xmm0\n0x0043BFC8 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043BFCC | 8B 40 10 | mov     eax, [rax+10h]\n0x0043BFCF | 85 C0 | test    eax, eax\n0x0043BFD1 | 78 2A | js      short loc_43BFFD\n0x0043BFD3 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043BFD7 | 8B 40 10 | mov     eax, [rax+10h]\n0x0043BFDA | 89 C7 | mov     edi, eax; fd\n0x0043BFDC | E8 2F AE FC FF | call    _close\n0x0043BFE1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043BFE5 | C7 40 10 FF FF FF FF | mov     dword ptr [rax+10h], 0FFFFFFFFh\n0x0043BFEC | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043BFF0 | BE 05 00 00 00 | mov     esi, 5\n0x0043BFF5 | 48 89 C7 | mov     rdi, rax\n0x0043BFF8 | E8 37 F5 FF FF | call    sub_43B534\n0x0043BFFD | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043C001 | 48 8B 00 | mov     rax, [rax]\n0x0043C004 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0043C008 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0043C00D | 75 85 | jnz     short loc_43BF94\n0x0043C00F | 90 | nop\n0x0043C010 | C9 | leave\n0x0043C011 | C3 | retn",
        "output": "",
        "source_code": "static NOINLINE void\nstep_time(double offset)\n{\n\tllist_t *item;\n\tdouble dtime;\n\tstruct timeval tvc, tvn;\n\tchar buf[sizeof(\"yyyy-mm-dd hh:mm:ss\") + /*paranoia:*/ 4];\n\ttime_t tval;\n\n\tgettimeofday(&tvc, NULL); /* never fails */\n\tdtime = tvc.tv_sec + (1.0e-6 * tvc.tv_usec) + offset;\n\td_to_tv(dtime, &tvn);\n\tif (settimeofday(&tvn, NULL) == -1)\n\t\tbb_perror_msg_and_die(\"settimeofday\");\n\n\tVERB2 {\n\t\ttval = tvc.tv_sec;\n\t\tstrftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", localtime(&tval));\n\t\tbb_error_msg(\"current time is %s.%06u\", buf, (unsigned)tvc.tv_usec);\n\t}\n\ttval = tvn.tv_sec;\n\tstrftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", localtime(&tval));\n\tbb_error_msg(\"setting time to %s.%06u (offset %+fs)\", buf, (unsigned)tvn.tv_usec, offset);\n\n\t/* Correct various fields which contain time-relative values: */\n\n\t/* Globals: */\n\tG.cur_time += offset;\n\tG.last_update_recv_time += offset;\n\tG.last_script_run += offset;\n\n\t/* p->lastpkt_recv_time, p->next_action_time and such: */\n\tfor (item = G.ntp_peers; item != NULL; item = item->link) {\n\t\tpeer_t *pp = (peer_t *) item->data;\n\t\treset_peer_stats(pp, offset);\n\t\t//bb_error_msg(\"offset:%+f pp->next_action_time:%f -> %f\",\n\t\t//\toffset, pp->next_action_time, pp->next_action_time + offset);\n\t\tpp->next_action_time += offset;\n\t\tif (pp->p_fd >= 0) {\n\t\t\t/* We wait for reply from this peer too.\n\t\t\t * But due to step we are doing, reply's data is no longer\n\t\t\t * useful (in fact, it'll be bogus). Stop waiting for it.\n\t\t\t */\n\t\t\tclose(pp->p_fd);\n\t\t\tpp->p_fd = -1;\n\t\t\tset_next(pp, RETRY_INTERVAL);\n\t\t}\n\t}\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 *__fastcall sub_43BDFE(double a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  struct tm *v5; // rax\n  __int64 v6; // rcx\n  __int64 v7; // r8\n  __int64 v8; // r9\n  struct tm *v9; // rax\n  __int64 v10; // rcx\n  __int64 v11; // r8\n  __int64 v12; // r9\n  __int64 *result; // rax\n  time_t timer; // [rsp+18h] [rbp-68h] BYREF\n  char s[32]; // [rsp+20h] [rbp-60h] BYREF\n  struct timeval v16; // [rsp+40h] [rbp-40h] BYREF\n  struct timeval tv; // [rsp+50h] [rbp-30h] BYREF\n  __int64 v18; // [rsp+68h] [rbp-18h]\n  double v19; // [rsp+70h] [rbp-10h]\n  __int64 *i; // [rsp+78h] [rbp-8h]\n\n  gettimeofday(&tv, 0LL);\n  v19 = 0.000001 * (double)SLODWORD(tv.tv_usec) + (double)SLODWORD(tv.tv_sec) + a1;\n  sub_43B233(&v16, v19);\n  if ( settimeofday(&v16, 0LL) == -1 )\n    sub_4092A2((__int64)\"settimeofday\", 0LL, v1, v2, v3, v4);\n  if ( *((_DWORD *)qword_75D408 + 15) > 1u )\n  {\n    timer = tv.tv_sec;\n    v5 = localtime(&timer);\n    strftime(s, 0x18uLL, \"%Y-%m-%d %H:%M:%S\", v5);\n    sub_409747(\"current time is %s.%06u\", (__int64)s, LODWORD(tv.tv_usec), v6, v7, v8);\n  }\n  timer = v16.tv_sec;\n  v9 = localtime(&timer);\n  strftime(s, 0x18uLL, \"%Y-%m-%d %H:%M:%S\", v9);\n  sub_409747(\"setting time to %s.%06u (offset %+fs)\", (__int64)s, LODWORD(v16.tv_usec), v10, v11, v12, a1);\n  *(double *)qword_75D408 = *(double *)qword_75D408 + a1;\n  *((double *)qword_75D408 + 14) = *((double *)qword_75D408 + 14) + a1;\n  *((double *)qword_75D408 + 4) = *((double *)qword_75D408 + 4) + a1;\n  result = (__int64 *)*((_QWORD *)qword_75D408 + 6);\n  for ( i = result; i; i = (__int64 *)*i )\n  {\n    v18 = i[1];\n    sub_43B74C(v18, a1);\n    *(double *)(v18 + 32) = *(double *)(v18 + 32) + a1;\n    if ( *(int *)(v18 + 16) >= 0 )\n    {\n      close(*(_DWORD *)(v18 + 16));\n      *(_DWORD *)(v18 + 16) = -1;\n      sub_43B534(v18, 5);\n    }\n    result = (__int64 *)*i;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl step_time(double offset)\n{\n  struct tm *v1; // rax\n  struct tm *v2; // rax\n  time_t tval; // [rsp+18h] [rbp-68h] BYREF\n  char buf[24]; // [rsp+20h] [rbp-60h] BYREF\n  timeval tvn; // [rsp+40h] [rbp-40h] BYREF\n  timeval tvc; // [rsp+50h] [rbp-30h] BYREF\n  peer_t *pp; // [rsp+68h] [rbp-18h]\n  double dtime; // [rsp+70h] [rbp-10h]\n  llist_t_0 *item; // [rsp+78h] [rbp-8h]\n\n  gettimeofday(&tvc, 0LL);\n  dtime = 0.000001 * (double)SLODWORD(tvc.tv_usec) + (double)SLODWORD(tvc.tv_sec) + offset;\n  d_to_tv(dtime, &tvn);\n  if ( settimeofday(&tvn, 0LL) == -1 )\n    bb_perror_msg_and_die(\"settimeofday\");\n  if ( ptr_to_globals->speeds[2] > 1u )\n  {\n    tval = tvc.tv_sec;\n    v1 = localtime(&tval);\n    strftime(buf, 0x18uLL, \"%Y-%m-%d %H:%M:%S\", v1);\n    bb_error_msg(\"current time is %s.%06u\", buf, LODWORD(tvc.tv_usec));\n  }\n  tval = tvn.tv_sec;\n  v2 = localtime(&tval);\n  strftime(buf, 0x18uLL, \"%Y-%m-%d %H:%M:%S\", v2);\n  bb_error_msg(\"setting time to %s.%06u (offset %+fs)\", buf, LODWORD(tvn.tv_usec), offset);\n  *(double *)&ptr_to_globals->timeout = *(double *)&ptr_to_globals->timeout + offset;\n  *(double *)&ptr_to_globals->tty_attrs.c_line = *(double *)&ptr_to_globals->tty_attrs.c_line + offset;\n  *(double *)&ptr_to_globals->initstring = *(double *)&ptr_to_globals->initstring + offset;\n  for ( item = *(llist_t_0 **)&ptr_to_globals->numspeed; item; item = item->link )\n  {\n    pp = (peer_t *)item->data;\n    reset_peer_stats(pp, offset);\n    pp->next_action_time = pp->next_action_time + offset;\n    if ( pp->p_fd >= 0 )\n    {\n      close(pp->p_fd);\n      pp->p_fd = -1;\n      set_next(pp, 5u);\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.039686039090156555,
        "similarity_score_baseline_stripped": 0.6234804391860962,
        "similarity_score_baseline_debug": 0.9118036031723022
    },
    {
        "func_name": "bb_alphasort",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004D8F24 | 55 | push    rbp\n0x004D8F25 | 48 89 E5 | mov     rbp, rsp\n0x004D8F28 | 48 83 EC 20 | sub     rsp, 20h\n0x004D8F2C | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004D8F30 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004D8F34 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004D8F38 | 48 8B 10 | mov     rdx, [rax]\n0x004D8F3B | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004D8F3F | 48 8B 00 | mov     rax, [rax]\n0x004D8F42 | 48 89 D6 | mov     rsi, rdx; s2\n0x004D8F45 | 48 89 C7 | mov     rdi, rax; s1\n0x004D8F48 | E8 03 E1 F2 FF | call    _strcmp\n0x004D8F4D | 89 45 FC | mov     [rbp+var_4], eax\n0x004D8F50 | 8B 05 FA 44 28 00 | mov     eax, cs:dword_75D450\n0x004D8F56 | 83 E0 01 | and     eax, 1\n0x004D8F59 | 85 C0 | test    eax, eax\n0x004D8F5B | 74 07 | jz      short loc_4D8F64\n0x004D8F5D | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004D8F60 | F7 D8 | neg     eax\n0x004D8F62 | EB 03 | jmp     short locret_4D8F67\n0x004D8F64 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004D8F67 | C9 | leave\n0x004D8F68 | C3 | retn",
        "output": "",
        "source_code": "static int bb_alphasort(const void *p1, const void *p2)\n{\n\tint r = strcmp(*(char **) p1, *(char **) p2);\n\treturn (option_mask32 & OPT_r) ? -r : r;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4D8F24(const char **a1, const char **a2)\n{\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = strcmp(*a1, *a2);\n  if ( (dword_75D450 & 1) != 0 )\n    return -v3;\n  else\n    return v3;\n}\n",
        "baseline_code_debug": "int __cdecl bb_alphasort(const void *p1, const void *p2)\n{\n  int r; // [rsp+1Ch] [rbp-4h]\n\n  r = strcmp(*(const char **)p1, *(const char **)p2);\n  if ( (option_mask32 & 1) != 0 )\n    return -r;\n  else\n    return r;\n}\n",
        "similarity_score_unixcoder": 0.10548552125692368,
        "similarity_score_baseline_stripped": 0.5747663974761963,
        "similarity_score_baseline_debug": 0.8037915229797363
    },
    {
        "func_name": "time_sort",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004656EB | 55 | push    rbp\n0x004656EC | 48 89 E5 | mov     rbp, rsp\n0x004656EF | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004656F3 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004656F7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004656FB | 48 8B 50 08 | mov     rdx, [rax+8]\n0x004656FF | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00465703 | 48 8B 40 08 | mov     rax, [rax+8]\n0x00465707 | 48 39 C2 | cmp     rdx, rax\n0x0046570A | 73 07 | jnb     short loc_465713\n0x0046570C | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x00465711 | EB 19 | jmp     short loc_46572C\n0x00465713 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00465717 | 48 8B 50 08 | mov     rdx, [rax+8]\n0x0046571B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0046571F | 48 8B 40 08 | mov     rax, [rax+8]\n0x00465723 | 48 39 C2 | cmp     rdx, rax\n0x00465726 | 0F 95 C0 | setnz   al\n0x00465729 | 0F B6 C0 | movzx   eax, al\n0x0046572C | 5D | pop     rbp\n0x0046572D | C3 | retn",
        "output": "",
        "source_code": "static int time_sort(top_status_t *P, top_status_t *Q)\n{\n\t/* We want to avoid unsigned->signed and truncation errors */\n\tif (Q->ticks < P->ticks) return -1;\n\treturn Q->ticks != P->ticks; /* 0 if ==, 1 if > */\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4656EB(__int64 a1, __int64 a2)\n{\n  if ( *(_QWORD *)(a2 + 8) >= *(_QWORD *)(a1 + 8) )\n    return *(_QWORD *)(a2 + 8) != *(_QWORD *)(a1 + 8);\n  else\n    return 0xFFFFFFFFLL;\n}\n",
        "baseline_code_debug": "int __cdecl time_sort(top_status_t_0 *P, top_status_t_0 *Q)\n{\n  if ( Q->ticks >= P->ticks )\n    return Q->ticks != P->ticks;\n  else\n    return -1;\n}\n",
        "similarity_score_unixcoder": 0.09213041514158249,
        "similarity_score_baseline_stripped": 0.46980077028274536,
        "similarity_score_baseline_debug": 0.919461727142334
    },
    {
        "func_name": "rawmode",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00442521 | 55 | push    rbp\n0x00442522 | 48 89 E5 | mov     rbp, rsp\n0x00442525 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0044252A | 0F B6 40 08 | movzx   eax, byte ptr [rax+8]\n0x0044252E | 84 C0 | test    al, al\n0x00442530 | 74 17 | jz      short loc_442549\n0x00442532 | B8 5C B5 75 00 | mov     eax, offset termios_p\n0x00442537 | 48 89 C2 | mov     rdx, rax; termios_p\n0x0044253A | BE 01 00 00 00 | mov     esi, 1; optional_actions\n0x0044253F | BF 00 00 00 00 | mov     edi, 0; fd\n0x00442544 | E8 87 52 FC FF | call    _tcsetattr\n0x00442549 | 90 | nop\n0x0044254A | 5D | pop     rbp\n0x0044254B | C3 | retn",
        "output": "",
        "source_code": "static void rawmode(void)\n{\n\ttcgetattr(0, &term_orig);\n\tterm_vi = term_orig;\n\tterm_vi.c_lflag &= (~ICANON & ~ECHO);\t// leave ISIG on - allow intr's\n\tterm_vi.c_iflag &= (~IXON & ~ICRNL);\n\tterm_vi.c_oflag &= (~ONLCR);\n\tterm_vi.c_cc[VMIN] = 1;\n\tterm_vi.c_cc[VTIME] = 0;\n\terase_char = term_vi.c_cc[VERASE];\n\ttcsetattr_stdin_TCSANOW(&term_vi);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "int sub_442521()\n{\n  int result; // eax\n\n  result = LOBYTE(dest.c_cflag);\n  if ( (_BYTE)result )\n    return tcsetattr(0, 1, &termios_p);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl rawmode()\n{\n  if ( LOBYTE(bb_common_bufsiz1.c_cflag) )\n    tcsetattr(0, 1, &unk_75B55C);\n}\n",
        "similarity_score_unixcoder": 0.033940963447093964,
        "similarity_score_baseline_stripped": 0.567959725856781,
        "similarity_score_baseline_debug": 0.5760945081710815
    },
    {
        "func_name": "bb_init_module",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00426133 | 55 | push    rbp\n0x00426134 | 48 89 E5 | mov     rbp, rsp\n0x00426137 | 48 83 EC 30 | sub     rsp, 30h\n0x0042613B | 48 89 7D D8 | mov     [rbp+var_28], rdi\n0x0042613F | 48 89 75 D0 | mov     [rbp+var_30], rsi\n0x00426143 | 48 83 7D D0 00 | cmp     [rbp+var_30], 0\n0x00426148 | 75 08 | jnz     short loc_426152\n0x0042614A | 48 C7 45 D0 22 AA 52 00 | mov     [rbp+var_30], offset unk_52AA22\n0x00426152 | 48 C7 45 E8 00 F0 FF 7F | mov     [rbp+len], 7FFFF000h\n0x0042615A | C6 45 F7 00 | mov     [rbp+var_9], 0\n0x0042615E | 48 C7 45 F8 00 00 00 00 | mov     [rbp+addr], 0\n0x00426166 | 48 83 7D F8 00 | cmp     [rbp+addr], 0\n0x0042616B | 74 06 | jz      short loc_426173\n0x0042616D | C6 45 F7 01 | mov     [rbp+var_9], 1\n0x00426171 | EB 38 | jmp     short loc_4261AB\n0x00426173 | 48 8B 05 86 72 33 00 | mov     rax, cs:qword_75D400\n0x0042617A | C7 00 0C 00 00 00 | mov     dword ptr [rax], 0Ch\n0x00426180 | 48 8D 55 E8 | lea     rdx, [rbp+len]\n0x00426184 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00426188 | 48 89 D6 | mov     rsi, rdx\n0x0042618B | 48 89 C7 | mov     rdi, rax\n0x0042618E | E8 19 D2 09 00 | call    sub_4C33AC\n0x00426193 | 48 89 45 F8 | mov     [rbp+addr], rax\n0x00426197 | 48 83 7D F8 00 | cmp     [rbp+addr], 0\n0x0042619C | 75 0D | jnz     short loc_4261AB\n0x0042619E | 48 8B 05 5B 72 33 00 | mov     rax, cs:qword_75D400\n0x004261A5 | 8B 00 | mov     eax, [rax]\n0x004261A7 | F7 D8 | neg     eax\n0x004261A9 | EB 61 | jmp     short locret_42620C\n0x004261AB | 48 8B 05 4E 72 33 00 | mov     rax, cs:qword_75D400\n0x004261B2 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0\n0x004261B8 | 48 8B 55 E8 | mov     rdx, [rbp+len]\n0x004261BC | 48 8B 4D D0 | mov     rcx, [rbp+var_30]\n0x004261C0 | 48 8B 45 F8 | mov     rax, [rbp+addr]\n0x004261C4 | 48 89 C6 | mov     rsi, rax\n0x004261C7 | BF AF 00 00 00 | mov     edi, 0AFh; sysno\n0x004261CC | B8 00 00 00 00 | mov     eax, 0\n0x004261D1 | E8 1A 0F FE FF | call    _syscall\n0x004261D6 | 48 8B 05 23 72 33 00 | mov     rax, cs:qword_75D400\n0x004261DD | 8B 00 | mov     eax, [rax]\n0x004261DF | 89 45 F0 | mov     [rbp+var_10], eax\n0x004261E2 | 80 7D F7 00 | cmp     [rbp+var_9], 0\n0x004261E6 | 74 15 | jz      short loc_4261FD\n0x004261E8 | 48 8B 55 E8 | mov     rdx, [rbp+len]\n0x004261EC | 48 8B 45 F8 | mov     rax, [rbp+addr]\n0x004261F0 | 48 89 D6 | mov     rsi, rdx; len\n0x004261F3 | 48 89 C7 | mov     rdi, rax; addr\n0x004261F6 | E8 05 14 FE FF | call    _munmap\n0x004261FB | EB 0C | jmp     short loc_426209\n0x004261FD | 48 8B 45 F8 | mov     rax, [rbp+addr]\n0x00426201 | 48 89 C7 | mov     rdi, rax; ptr\n0x00426204 | E8 57 04 FE FF | call    _free\n0x00426209 | 8B 45 F0 | mov     eax, [rbp+var_10]\n0x0042620C | C9 | leave\n0x0042620D | C3 | retn",
        "output": "",
        "source_code": "int FAST_FUNC bb_init_module(const char *filename, const char *options)\n{\n\tsize_t image_size;\n\tchar *image;\n\tint rc;\n\tbool mmaped;\n\n\tif (!options)\n\t\toptions = \"\";\n\n//TODO: audit bb_init_module_24 to match error code convention\n#if ENABLE_FEATURE_2_4_MODULES\n\tif (get_linux_version_code() < KERNEL_VERSION(2,6,0))\n\t\treturn bb_init_module_24(filename, options);\n#endif\n\n\timage_size = INT_MAX - 4095;\n\tmmaped = 0;\n\timage = try_to_mmap_module(filename, &image_size);\n\tif (image) {\n\t\tmmaped = 1;\n\t} else {\n\t\terrno = ENOMEM; /* may be changed by e.g. open errors below */\n\t\timage = xmalloc_open_zipped_read_close(filename, &image_size);\n\t\tif (!image)\n\t\t\treturn -errno;\n\t}\n\n\terrno = 0;\n\tinit_module(image, image_size, options);\n\trc = errno;\n\tif (mmaped)\n\t\tmunmap(image, image_size);\n\telse\n\t\tfree(image);\n\treturn rc;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_426133(__int64 a1, void *a2)\n{\n  void *v3; // [rsp+0h] [rbp-30h]\n  size_t len; // [rsp+18h] [rbp-18h] BYREF\n  unsigned int v5; // [rsp+20h] [rbp-10h]\n  char v6; // [rsp+27h] [rbp-9h]\n  void *addr; // [rsp+28h] [rbp-8h]\n\n  v3 = a2;\n  if ( !a2 )\n    v3 = &unk_52AA22;\n  len = 2147479552LL;\n  v6 = 0;\n  addr = 0LL;\n  *(_DWORD *)qword_75D400 = 12;\n  addr = (void *)sub_4C33AC(a1, &len);\n  if ( !addr )\n    return (unsigned int)-*(_DWORD *)qword_75D400;\n  *(_DWORD *)qword_75D400 = 0;\n  syscall(175LL, addr, len, v3);\n  v5 = *(_DWORD *)qword_75D400;\n  if ( v6 )\n    munmap(addr, len);\n  else\n    free(addr);\n  return v5;\n}\n",
        "baseline_code_debug": "int __cdecl bb_init_module(const char *filename, const char *options)\n{\n  const char *optionsa; // [rsp+0h] [rbp-30h]\n  size_t image_size; // [rsp+18h] [rbp-18h] BYREF\n  int rc; // [rsp+20h] [rbp-10h]\n  bool mmaped; // [rsp+27h] [rbp-9h]\n  char *image; // [rsp+28h] [rbp-8h]\n\n  optionsa = options;\n  if ( !options )\n    optionsa = (const char *)&unk_52AA22;\n  image_size = 2147479552LL;\n  mmaped = 0;\n  image = 0LL;\n  *bb_errno = 12;\n  image = (char *)xmalloc_open_zipped_read_close(filename, &image_size);\n  if ( !image )\n    return -*bb_errno;\n  *bb_errno = 0;\n  syscall(175LL, image, image_size, optionsa);\n  rc = *bb_errno;\n  if ( mmaped )\n    munmap(image, image_size);\n  else\n    free(image);\n  return rc;\n}\n",
        "similarity_score_unixcoder": 0.0277395062148571,
        "similarity_score_baseline_stripped": 0.6034728288650513,
        "similarity_score_baseline_debug": 0.8624898195266724
    },
    {
        "func_name": "run_parts_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004D9040 | 55 | push    rbp\n0x004D9041 | 48 89 E5 | mov     rbp, rsp\n0x004D9044 | 41 54 | push    r12\n0x004D9046 | 53 | push    rbx\n0x004D9047 | 48 83 EC 40 | sub     rsp, 40h\n0x004D904B | 89 7D BC | mov     [rbp+var_44], edi\n0x004D904E | 48 89 75 B0 | mov     [rbp+var_50], rsi\n0x004D9052 | 48 C7 45 D0 F1 70 53 00 | mov     [rbp+var_30], offset unk_5370F1\n0x004D905A | 48 C7 45 C8 00 00 00 00 | mov     [rbp+var_38], 0\n0x004D9062 | 48 C7 05 DB 43 28 00 CA 70 53 00 | mov     cs:qword_75D448, offset aArg; \"arg\"\n0x004D906D | 48 C7 05 C8 43 28 00 F4 70 53 00 | mov     cs:qword_75D440, offset a1A; \"=1:a::\"\n0x004D9078 | 48 8D 4D D0 | lea     rcx, [rbp+var_30]\n0x004D907C | 48 8D 55 C8 | lea     rdx, [rbp+var_38]\n0x004D9080 | 48 8B 45 B0 | mov     rax, [rbp+var_50]\n0x004D9084 | BE FB 70 53 00 | mov     esi, offset aRaUTl; \"ra:u:tl\"\n0x004D9089 | 48 89 C7 | mov     rdi, rax\n0x004D908C | B8 00 00 00 00 | mov     eax, 0\n0x004D9091 | E8 59 11 02 00 | call    sub_4FA1EF\n0x004D9096 | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x004D909A | B9 FF 0F 00 00 | mov     ecx, 0FFFh\n0x004D909F | BA 00 00 00 00 | mov     edx, 0\n0x004D90A4 | BE 08 00 00 00 | mov     esi, 8\n0x004D90A9 | 48 89 C7 | mov     rdi, rax\n0x004D90AC | E8 1E 1F 03 00 | call    sub_50AFCF\n0x004D90B1 | 89 C7 | mov     edi, eax; mask\n0x004D90B3 | E8 78 E0 F2 FF | call    _umask\n0x004D90B8 | C7 45 EC 01 00 00 00 | mov     [rbp+var_14], 1\n0x004D90BF | EB 28 | jmp     short loc_4D90E9\n0x004D90C1 | 41 BC F8 B3 75 00 | mov     r12d, offset dest\n0x004D90C7 | 8B 5D EC | mov     ebx, [rbp+var_14]\n0x004D90CA | 8D 43 01 | lea     eax, [rbx+1]\n0x004D90CD | 89 45 EC | mov     [rbp+var_14], eax\n0x004D90D0 | 48 8D 45 C8 | lea     rax, [rbp+var_38]\n0x004D90D4 | 48 89 C7 | mov     rdi, rax\n0x004D90D7 | E8 8B FF F2 FF | call    sub_409067\n0x004D90DC | 48 89 C2 | mov     rdx, rax\n0x004D90DF | 89 D8 | mov     eax, ebx\n0x004D90E1 | 48 83 C0 02 | add     rax, 2\n0x004D90E5 | 49 89 14 C4 | mov     [r12+rax*8], rdx\n0x004D90E9 | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x004D90ED | 48 85 C0 | test    rax, rax\n0x004D90F0 | 74 09 | jz      short loc_4D90FB\n0x004D90F2 | 81 7D EC FB 03 00 00 | cmp     [rbp+var_14], 3FBh\n0x004D90F9 | 76 C6 | jbe     short loc_4D90C1\n0x004D90FB | 8B 05 77 1D 28 00 | mov     eax, cs:optind\n0x004D9101 | 48 98 | cdqe\n0x004D9103 | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]\n0x004D910B | 48 8B 45 B0 | mov     rax, [rbp+var_50]\n0x004D910F | 48 01 D0 | add     rax, rdx\n0x004D9112 | 48 8B 00 | mov     rax, [rax]\n0x004D9115 | 41 B9 01 00 00 00 | mov     r9d, 1\n0x004D911B | 41 B8 00 00 00 00 | mov     r8d, 0\n0x004D9121 | B9 69 8F 4D 00 | mov     ecx, offset sub_4D8F69\n0x004D9126 | BA 69 8F 4D 00 | mov     edx, offset sub_4D8F69\n0x004D912B | BE 03 00 00 00 | mov     esi, 3\n0x004D9130 | 48 89 C7 | mov     rdi, rax\n0x004D9133 | E8 F4 E3 02 00 | call    sub_50752C\n0x004D9138 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004D913D | 48 8B 00 | mov     rax, [rax]\n0x004D9140 | 48 85 C0 | test    rax, rax\n0x004D9143 | 75 0A | jnz     short loc_4D914F\n0x004D9145 | B8 00 00 00 00 | mov     eax, 0\n0x004D914A | E9 DE 00 00 00 | jmp     loc_4D922D\n0x004D914F | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004D9154 | 8B 40 08 | mov     eax, [rax+8]\n0x004D9157 | 48 63 F0 | movsxd  rsi, eax; nmemb\n0x004D915A | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004D915F | 48 8B 00 | mov     rax, [rax]\n0x004D9162 | B9 24 8F 4D 00 | mov     ecx, offset sub_4D8F24; compar\n0x004D9167 | BA 08 00 00 00 | mov     edx, 8; size\n0x004D916C | 48 89 C7 | mov     rdi, rax; base\n0x004D916F | E8 DC D6 F2 FF | call    _qsort\n0x004D9174 | C7 45 EC 00 00 00 00 | mov     [rbp+var_14], 0\n0x004D917B | BA F8 B3 75 00 | mov     edx, offset dest\n0x004D9180 | 48 8B 02 | mov     rax, [rdx]\n0x004D9183 | 48 8D 48 08 | lea     rcx, [rax+8]\n0x004D9187 | 48 89 0A | mov     [rdx], rcx\n0x004D918A | 48 8B 00 | mov     rax, [rax]\n0x004D918D | 48 89 45 E0 | mov     [rbp+s], rax\n0x004D9191 | 48 83 7D E0 00 | cmp     [rbp+s], 0\n0x004D9196 | 0F 84 8D 00 00 00 | jz      loc_4D9229\n0x004D919C | 8B 05 AE 42 28 00 | mov     eax, cs:dword_75D450\n0x004D91A2 | 83 E0 18 | and     eax, 18h\n0x004D91A5 | 85 C0 | test    eax, eax\n0x004D91A7 | 74 0E | jz      short loc_4D91B7\n0x004D91A9 | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x004D91AD | 48 89 C7 | mov     rdi, rax; s\n0x004D91B0 | E8 5B D6 F2 FF | call    _puts\n0x004D91B5 | EB 6D | jmp     short loc_4D9224\n0x004D91B7 | BA F8 B3 75 00 | mov     edx, offset dest\n0x004D91BC | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x004D91C0 | 48 89 42 10 | mov     [rdx+10h], rax\n0x004D91C4 | B8 08 B4 75 00 | mov     eax, offset dest.c_line\n0x004D91C9 | 48 89 C7 | mov     rdi, rax\n0x004D91CC | E8 53 14 03 00 | call    sub_50A624\n0x004D91D1 | 89 45 DC | mov     [rbp+var_24], eax\n0x004D91D4 | 83 7D DC 00 | cmp     [rbp+var_24], 0\n0x004D91D8 | 74 49 | jz      short loc_4D9223\n0x004D91DA | C7 45 EC 01 00 00 00 | mov     [rbp+var_14], 1\n0x004D91E1 | 83 7D DC 00 | cmp     [rbp+var_24], 0\n0x004D91E5 | 79 1B | jns     short loc_4D9202\n0x004D91E7 | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x004D91EB | 48 89 C6 | mov     rsi, rax\n0x004D91EE | BF 03 71 53 00 | mov     edi, offset aCanTExecuteS_7; \"can't execute '%s'\"\n0x004D91F3 | B8 00 00 00 00 | mov     eax, 0\n0x004D91F8 | E8 DC FF F2 FF | call    sub_4091D9\n0x004D91FD | E9 79 FF FF FF | jmp     loc_4D917B\n0x004D9202 | 8B 45 DC | mov     eax, [rbp+var_24]\n0x004D9205 | 0F B6 D0 | movzx   edx, al\n0x004D9208 | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x004D920C | 48 89 C6 | mov     rsi, rax\n0x004D920F | BF 16 71 53 00 | mov     edi, offset aSExitedWithCod; \"%s exited with code %d\"\n0x004D9214 | B8 00 00 00 00 | mov     eax, 0\n0x004D9219 | E8 29 05 F3 FF | call    sub_409747\n0x004D921E | E9 58 FF FF FF | jmp     loc_4D917B\n0x004D9223 | 90 | nop\n0x004D9224 | E9 52 FF FF FF | jmp     loc_4D917B\n0x004D9229 | 90 | nop\n0x004D922A | 8B 45 EC | mov     eax, [rbp+var_14]\n0x004D922D | 48 83 C4 40 | add     rsp, 40h\n0x004D9231 | 5B | pop     rbx\n0x004D9232 | 41 5C | pop     r12\n0x004D9234 | 5D | pop     rbp\n0x004D9235 | C3 | retn",
        "output": "",
        "source_code": "int run_parts_main(int argc UNUSED_PARAM, char **argv)\n{\n\tconst char *umask_p = \"22\";\n\tllist_t *arg_list = NULL;\n\tunsigned n;\n\tint ret;\n\n\tINIT_G();\n\n#if ENABLE_FEATURE_RUN_PARTS_LONG_OPTIONS\n\tapplet_long_options = runparts_longopts;\n#endif\n\t/* We require exactly one argument: the directory name */\n\topt_complementary = \"=1:a::\";\n\tgetopt32(argv, \"ra:u:t\"IF_FEATURE_RUN_PARTS_FANCY(\"l\"), &arg_list, &umask_p);\n\n\tumask(xstrtou_range(umask_p, 8, 0, 07777));\n\n\tn = 1;\n\twhile (arg_list && n < NUM_CMD) {\n\t\tcmd[n++] = llist_pop(&arg_list);\n\t}\n\t/* cmd[n] = NULL; - is already zeroed out */\n\n\t/* run-parts has to sort executables by name before running them */\n\n\trecursive_action(argv[optind],\n\t\t\tACTION_RECURSE|ACTION_FOLLOWLINKS,\n\t\t\tact,            /* file action */\n\t\t\tact,            /* dir action */\n\t\t\tNULL,           /* user data */\n\t\t\t1               /* depth */\n\t\t);\n\n\tif (!names)\n\t\treturn 0;\n\n\tqsort(names, cur, sizeof(char *), bb_alphasort);\n\n\tn = 0;\n\twhile (1) {\n\t\tchar *name = *names++;\n\t\tif (!name)\n\t\t\tbreak;\n\t\tif (option_mask32 & (OPT_t | OPT_l)) {\n\t\t\tputs(name);\n\t\t\tcontinue;\n\t\t}\n\t\tcmd[0] = name;\n\t\tret = spawn_and_wait(cmd);\n\t\tif (ret == 0)\n\t\t\tcontinue;\n\t\tn = 1;\n\t\tif (ret < 0)\n\t\t\tbb_perror_msg(\"can't execute '%s'\", name);\n\t\telse /* ret > 0 */\n\t\t\tbb_error_msg(\"%s exited with code %d\", name, ret & 0xff);\n\t}\n\n\treturn n;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4D9040(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5, int a6)\n{\n  __mode_t v6; // eax\n  unsigned int v7; // ebx\n  char **v9; // rax\n  __int64 v10; // rdx\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  __int64 v13; // r9\n  _QWORD *v14; // [rsp+18h] [rbp-38h] BYREF\n  void *v15; // [rsp+20h] [rbp-30h] BYREF\n  int v16; // [rsp+2Ch] [rbp-24h]\n  char *s; // [rsp+30h] [rbp-20h]\n  unsigned int v18; // [rsp+3Ch] [rbp-14h]\n\n  v15 = &unk_5370F1;\n  v14 = 0LL;\n  qword_75D448 = (__int64)\"arg\";\n  qword_75D440 = (__int64)\"=1:a::\";\n  sub_4FA1EF(a2, (unsigned int)\"ra:u:tl\", (unsigned int)&v14, (unsigned int)&v15, a5, a6);\n  v6 = sub_50AFCF(v15, 8LL, 0LL, 4095LL);\n  umask(v6);\n  v18 = 1;\n  while ( v14 && v18 <= 0x3FB )\n  {\n    v7 = v18++;\n    *((_QWORD *)&dest.c_line + v7) = sub_409067(&v14);\n  }\n  sub_50752C(*(_QWORD *)(8LL * optind + a2), 3LL, sub_4D8F69, sub_4D8F69, 0LL, 1LL);\n  if ( !*(_QWORD *)&dest.c_iflag )\n    return 0LL;\n  qsort(*(void **)&dest.c_iflag, (int)dest.c_cflag, 8uLL, (__compar_fn_t)sub_4D8F24);\n  v18 = 0;\n  while ( 1 )\n  {\n    v9 = *(char ***)&dest.c_iflag;\n    *(_QWORD *)&dest.c_iflag += 8LL;\n    s = *v9;\n    if ( !s )\n      break;\n    if ( (dword_75D450 & 0x18) != 0 )\n    {\n      puts(s);\n    }\n    else\n    {\n      *(_QWORD *)&dest.c_line = s;\n      v16 = sub_50A624(&dest.c_line);\n      if ( v16 )\n      {\n        v18 = 1;\n        if ( v16 >= 0 )\n          sub_409747(\"%s exited with code %d\", (__int64)s, (unsigned __int8)v16, v11, v12, v13);\n        else\n          sub_4091D9((__int64)\"can't execute '%s'\", (__int64)s, v10, v11, v12, v13);\n      }\n    }\n  }\n  return v18;\n}\n",
        "baseline_code_debug": "int __cdecl run_parts_main(int argc, char **argv)\n{\n  unsigned int v2; // eax\n  unsigned int v3; // ebx\n  char **v5; // rax\n  llist_t_0 *head; // [rsp+18h] [rbp-38h] BYREF\n  const char *umask_p; // [rsp+20h] [rbp-30h] BYREF\n  int ret; // [rsp+2Ch] [rbp-24h]\n  char *name; // [rsp+30h] [rbp-20h]\n  unsigned int n; // [rsp+3Ch] [rbp-14h]\n\n  umask_p = (const char *)&unk_5370F1;\n  head = 0LL;\n  applet_long_options = runparts_longopts;\n  opt_complementary = \"=1:a::\";\n  getopt32(argv, \"ra:u:tl\", &head, &umask_p);\n  v2 = xstrtou_range(umask_p, 8, 0, 0xFFFu);\n  umask(v2);\n  n = 1;\n  while ( head && n <= 0x3FB )\n  {\n    v3 = n++;\n    *((_QWORD *)&bb_common_bufsiz1.c_line + v3) = llist_pop(&head);\n  }\n  recursive_action(\n    argv[optind],\n    3u,\n    (int (*)(const char *, stat *, void *, int))act_0,\n    (int (*)(const char *, stat *, void *, int))act_0,\n    0LL,\n    1u);\n  if ( !*(_QWORD *)&bb_common_bufsiz1.c_iflag )\n    return 0;\n  qsort(*(void **)&bb_common_bufsiz1.c_iflag, (int)bb_common_bufsiz1.c_cflag, 8uLL, (__compar_fn_t)bb_alphasort);\n  n = 0;\n  while ( 1 )\n  {\n    v5 = *(char ***)&bb_common_bufsiz1.c_iflag;\n    *(_QWORD *)&bb_common_bufsiz1.c_iflag += 8LL;\n    name = *v5;\n    if ( !name )\n      break;\n    if ( (option_mask32 & 0x18) != 0 )\n    {\n      puts(name);\n    }\n    else\n    {\n      *(_QWORD *)&bb_common_bufsiz1.c_line = name;\n      ret = spawn_and_wait((char **)&bb_common_bufsiz1.c_line);\n      if ( ret )\n      {\n        n = 1;\n        if ( ret >= 0 )\n          bb_error_msg(\"%s exited with code %d\", name, (unsigned __int8)ret);\n        else\n          bb_perror_msg(\"can't execute '%s'\", name);\n      }\n    }\n  }\n  return n;\n}\n",
        "similarity_score_unixcoder": 0.029020249843597412,
        "similarity_score_baseline_stripped": 0.6001295447349548,
        "similarity_score_baseline_debug": 0.8547645807266235
    },
    {
        "func_name": "str_value",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C92D7 | 55 | push    rbp\n0x004C92D8 | 48 89 E5 | mov     rbp, rsp\n0x004C92DB | 48 83 EC 20 | sub     rsp, 20h\n0x004C92DF | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004C92E3 | BF 10 00 00 00 | mov     edi, 10h\n0x004C92E8 | E8 FB 0D F4 FF | call    sub_40A0E8\n0x004C92ED | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004C92F1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C92F5 | C6 00 01 | mov     byte ptr [rax], 1\n0x004C92F8 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004C92FC | 48 89 C7 | mov     rdi, rax\n0x004C92FF | E8 1B 0E F4 FF | call    sub_40A11F\n0x004C9304 | 48 89 C2 | mov     rdx, rax\n0x004C9307 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C930B | 48 89 50 08 | mov     [rax+8], rdx\n0x004C930F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C9313 | C9 | leave\n0x004C9314 | C3 | retn",
        "output": "",
        "source_code": "static VALUE *str_value(const char *s)\n{\n\tVALUE *v;\n\n\tv = xzalloc(sizeof(VALUE));\n\tif (STRING) /* otherwise xzaaloc did it already */\n\t\tv->type = STRING;\n\tv->u.s = xstrdup(s);\n\treturn v;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "_QWORD *__fastcall sub_4C92D7(const char *a1, __int64 a2)\n{\n  _QWORD *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40A0E8(0x10uLL, a2);\n  *(_BYTE *)v3 = 1;\n  v3[1] = sub_40A11F(a1, a2);\n  return v3;\n}\n",
        "baseline_code_debug": "VALUE *__cdecl str_value(const char *s)\n{\n  VALUE *v; // [rsp+18h] [rbp-8h]\n\n  v = (VALUE *)xzalloc(0x10uLL);\n  v->type = 1;\n  v->u.i = (arith_t_0)xstrdup(s);\n  return v;\n}\n",
        "similarity_score_unixcoder": 0.04294678196310997,
        "similarity_score_baseline_stripped": 0.4493058919906616,
        "similarity_score_baseline_debug": 0.7117202281951904
    },
    {
        "func_name": "install_sighandler",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00480305 | 55 | push    rbp\n0x00480306 | 48 89 E5 | mov     rbp, rsp\n0x00480309 | 48 81 EC B0 00 00 00 | sub     rsp, 0B0h\n0x00480310 | 89 BD 5C FF FF FF | mov     [rbp+sig], edi\n0x00480316 | 48 89 B5 50 FF FF FF | mov     [rbp+var_B0], rsi\n0x0048031D | 48 8B 05 E4 D0 2D 00 | mov     rax, cs:qword_75D408\n0x00480324 | 48 8B 95 50 FF FF FF | mov     rdx, [rbp+var_B0]\n0x0048032B | 48 89 90 40 01 00 00 | mov     [rax+140h], rdx\n0x00480332 | 48 8B 05 CF D0 2D 00 | mov     rax, cs:qword_75D408\n0x00480339 | 48 8D 88 40 01 00 00 | lea     rcx, [rax+140h]\n0x00480340 | 48 8D 95 60 FF FF FF | lea     rdx, [rbp+var_A0]; oact\n0x00480347 | 8B 85 5C FF FF FF | mov     eax, [rbp+sig]\n0x0048034D | 48 89 CE | mov     rsi, rcx; act\n0x00480350 | 89 C7 | mov     edi, eax; sig\n0x00480352 | E8 19 65 F8 FF | call    _sigaction\n0x00480357 | 48 8B 85 60 FF FF FF | mov     rax, [rbp+var_A0]\n0x0048035E | C9 | leave\n0x0048035F | C3 | retn",
        "output": "",
        "source_code": "static sighandler_t install_sighandler(int sig, sighandler_t handler)\n{\n\tstruct sigaction old_sa;\n\n\t/* We could use signal() to install handlers... almost:\n\t * except that we need to mask ALL signals while handlers run.\n\t * I saw signal nesting in strace, race window isn't small.\n\t * SA_RESTART is also needed, but in Linux, signal()\n\t * sets SA_RESTART too.\n\t */\n\t/* memset(&G.sa, 0, sizeof(G.sa)); - already done */\n\t/* sigfillset(&G.sa.sa_mask);      - already done */\n\t/* G.sa.sa_flags = SA_RESTART;     - already done */\n\tG.sa.sa_handler = handler;\n\tsigaction(sig, &G.sa, &old_sa);\n\treturn old_sa.sa_handler;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__sighandler_t __fastcall sub_480305(int a1, __int64 a2)\n{\n  struct sigaction v3; // [rsp+10h] [rbp-A0h] BYREF\n\n  *((_QWORD *)qword_75D408 + 40) = a2;\n  sigaction(a1, (const struct sigaction *)((char *)qword_75D408 + 320), &v3);\n  return v3.sa_handler;\n}\n",
        "baseline_code_debug": "sighandler_t __cdecl install_sighandler(int sig, sighandler_t handler)\n{\n  sigaction old_sa; // [rsp+10h] [rbp-A0h] BYREF\n\n  ptr_to_globals[1].initstring = (char *)handler;\n  sigaction(sig, (const struct sigaction *)&ptr_to_globals[1].initstring, &old_sa);\n  return old_sa.sa_handler;\n}\n",
        "similarity_score_unixcoder": 0.05395692214369774,
        "similarity_score_baseline_stripped": 0.6133325099945068,
        "similarity_score_baseline_debug": 0.7921295762062073
    },
    {
        "func_name": "put_prompt",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004FE30A | 55 | push    rbp\n0x004FE30B | 48 89 E5 | mov     rbp, rsp\n0x004FE30E | 48 83 EC 10 | sub     rsp, 10h\n0x004FE312 | 48 8B 15 4F CB 25 00 | mov     rdx, cs:stdout\n0x004FE319 | 48 8B 05 38 F1 25 00 | mov     rax, cs:qword_75D458\n0x004FE320 | 48 8B 40 38 | mov     rax, [rax+38h]\n0x004FE324 | 48 89 D6 | mov     rsi, rdx; stream\n0x004FE327 | 48 89 C7 | mov     rdi, rax; s\n0x004FE32A | E8 91 8C F0 FF | call    _fputs_unlocked\n0x004FE32F | E8 15 C3 F0 FF | call    sub_40A649\n0x004FE334 | 48 8B 05 1D F1 25 00 | mov     rax, cs:qword_75D458\n0x004FE33B | C7 40 24 00 00 00 00 | mov     dword ptr [rax+24h], 0\n0x004FE342 | 48 8B 05 0F F1 25 00 | mov     rax, cs:qword_75D458\n0x004FE349 | 8B 40 08 | mov     eax, [rax+8]\n0x004FE34C | 89 45 FC | mov     [rbp+var_4], eax\n0x004FE34F | 48 8B 05 02 F1 25 00 | mov     rax, cs:qword_75D458\n0x004FE356 | 8B 40 20 | mov     eax, [rax+20h]\n0x004FE359 | 48 8B 0D F8 F0 25 00 | mov     rcx, cs:qword_75D458\n0x004FE360 | BA 00 00 00 00 | mov     edx, 0\n0x004FE365 | F7 75 FC | div     [rbp+var_4]\n0x004FE368 | 89 41 1C | mov     [rcx+1Ch], eax\n0x004FE36B | 48 8B 05 E6 F0 25 00 | mov     rax, cs:qword_75D458\n0x004FE372 | 8B 40 20 | mov     eax, [rax+20h]\n0x004FE375 | 48 8B 0D DC F0 25 00 | mov     rcx, cs:qword_75D458\n0x004FE37C | BA 00 00 00 00 | mov     edx, 0\n0x004FE381 | F7 75 FC | div     [rbp+var_4]\n0x004FE384 | 89 D0 | mov     eax, edx\n0x004FE386 | 89 41 18 | mov     [rcx+18h], eax\n0x004FE389 | 90 | nop\n0x004FE38A | C9 | leave\n0x004FE38B | C3 | retn",
        "output": "",
        "source_code": "static void put_prompt(void)\n{\n\tunsigned w;\n\n\tfputs(cmdedit_prompt, stdout);\n\tfflush_all();\n\tcursor = 0;\n\tw = cmdedit_termw; /* read volatile var once */\n\tcmdedit_y = cmdedit_prmt_len / w; /* new quasireal y */\n\tcmdedit_x = cmdedit_prmt_len % w;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 sub_4FE30A()\n{\n  __int64 result; // rax\n  unsigned int v1; // [rsp+Ch] [rbp-4h]\n\n  fputs_unlocked(*((const char **)qword_75D458 + 7), stdout);\n  sub_40A649();\n  *((_DWORD *)qword_75D458 + 9) = 0;\n  v1 = *((_DWORD *)qword_75D458 + 2);\n  *((_DWORD *)qword_75D458 + 7) = *((_DWORD *)qword_75D458 + 8) / v1;\n  result = *((_DWORD *)qword_75D458 + 8) % v1;\n  *((_DWORD *)qword_75D458 + 6) = result;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl put_prompt()\n{\n  unsigned int w; // [rsp+Ch] [rbp-4h]\n\n  fputs_unlocked(lineedit_ptr_to_statics->cmdedit_prompt, stdout);\n  fflush_all();\n  lineedit_ptr_to_statics->cursor = 0;\n  w = lineedit_ptr_to_statics->cmdedit_termw;\n  lineedit_ptr_to_statics->cmdedit_y = lineedit_ptr_to_statics->cmdedit_prmt_len / w;\n  lineedit_ptr_to_statics->cmdedit_x = lineedit_ptr_to_statics->cmdedit_prmt_len % w;\n}\n",
        "similarity_score_unixcoder": 0.014599448069930077,
        "similarity_score_baseline_stripped": 0.4488571882247925,
        "similarity_score_baseline_debug": 0.7783833146095276
    },
    {
        "func_name": "lzma_props",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004BE323 | 55 | push    rbp\n0x004BE324 | 48 89 E5 | mov     rbp, rsp\n0x004BE327 | 48 83 EC 10 | sub     rsp, 10h\n0x004BE32B | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004BE32F | 89 F0 | mov     eax, esi\n0x004BE331 | 88 45 F4 | mov     [rbp+var_C], al\n0x004BE334 | 80 7D F4 E0 | cmp     [rbp+var_C], 0E0h\n0x004BE338 | 76 0A | jbe     short loc_4BE344\n0x004BE33A | B8 00 00 00 00 | mov     eax, 0\n0x004BE33F | E9 EB 00 00 00 | jmp     locret_4BE42F\n0x004BE344 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BE348 | C7 80 9C 00 00 00 00 00 00 00 | mov     dword ptr [rax+9Ch], 0\n0x004BE352 | EB 1B | jmp     short loc_4BE36F\n0x004BE354 | 80 6D F4 2D | sub     [rbp+var_C], 2Dh ; '-'\n0x004BE358 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BE35C | 8B 80 9C 00 00 00 | mov     eax, [rax+9Ch]\n0x004BE362 | 8D 50 01 | lea     edx, [rax+1]\n0x004BE365 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BE369 | 89 90 9C 00 00 00 | mov     [rax+9Ch], edx\n0x004BE36F | 80 7D F4 2C | cmp     [rbp+var_C], 2Ch ; ','\n0x004BE373 | 77 DF | ja      short loc_4BE354\n0x004BE375 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BE379 | 8B 80 9C 00 00 00 | mov     eax, [rax+9Ch]\n0x004BE37F | BA 01 00 00 00 | mov     edx, 1\n0x004BE384 | 89 C1 | mov     ecx, eax\n0x004BE386 | D3 E2 | shl     edx, cl\n0x004BE388 | 89 D0 | mov     eax, edx\n0x004BE38A | 83 E8 01 | sub     eax, 1\n0x004BE38D | 89 C2 | mov     edx, eax\n0x004BE38F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BE393 | 89 90 9C 00 00 00 | mov     [rax+9Ch], edx\n0x004BE399 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BE39D | C7 80 98 00 00 00 00 00 00 00 | mov     dword ptr [rax+98h], 0\n0x004BE3A7 | EB 1B | jmp     short loc_4BE3C4\n0x004BE3A9 | 80 6D F4 09 | sub     [rbp+var_C], 9\n0x004BE3AD | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BE3B1 | 8B 80 98 00 00 00 | mov     eax, [rax+98h]\n0x004BE3B7 | 8D 50 01 | lea     edx, [rax+1]\n0x004BE3BA | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BE3BE | 89 90 98 00 00 00 | mov     [rax+98h], edx\n0x004BE3C4 | 80 7D F4 08 | cmp     [rbp+var_C], 8\n0x004BE3C8 | 77 DF | ja      short loc_4BE3A9\n0x004BE3CA | 0F B6 55 F4 | movzx   edx, [rbp+var_C]\n0x004BE3CE | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BE3D2 | 89 90 94 00 00 00 | mov     [rax+94h], edx\n0x004BE3D8 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BE3DC | 8B 90 94 00 00 00 | mov     edx, [rax+94h]\n0x004BE3E2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BE3E6 | 8B 80 98 00 00 00 | mov     eax, [rax+98h]\n0x004BE3EC | 01 D0 | add     eax, edx\n0x004BE3EE | 83 F8 04 | cmp     eax, 4\n0x004BE3F1 | 76 07 | jbe     short loc_4BE3FA\n0x004BE3F3 | B8 00 00 00 00 | mov     eax, 0\n0x004BE3F8 | EB 35 | jmp     short locret_4BE42F\n0x004BE3FA | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BE3FE | 8B 80 98 00 00 00 | mov     eax, [rax+98h]\n0x004BE404 | BA 01 00 00 00 | mov     edx, 1\n0x004BE409 | 89 C1 | mov     ecx, eax\n0x004BE40B | D3 E2 | shl     edx, cl\n0x004BE40D | 89 D0 | mov     eax, edx\n0x004BE40F | 83 E8 01 | sub     eax, 1\n0x004BE412 | 89 C2 | mov     edx, eax\n0x004BE414 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BE418 | 89 90 98 00 00 00 | mov     [rax+98h], edx\n0x004BE41E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BE422 | 48 89 C7 | mov     rdi, rax\n0x004BE425 | E8 60 FE FF FF | call    sub_4BE28A\n0x004BE42A | B8 01 00 00 00 | mov     eax, 1\n0x004BE42F | C9 | leave\n0x004BE430 | C3 | retn",
        "output": "",
        "source_code": "static bool XZ_FUNC lzma_props(struct xz_dec_lzma2 *s, uint8_t props)\n{\n\tif (props > (4 * 5 + 4) * 9 + 8)\n\t\treturn false;\n\n\ts->lzma.pos_mask = 0;\n\twhile (props >= 9 * 5) {\n\t\tprops -= 9 * 5;\n\t\t++s->lzma.pos_mask;\n\t}\n\n\ts->lzma.pos_mask = (1 << s->lzma.pos_mask) - 1;\n\n\ts->lzma.literal_pos_mask = 0;\n\twhile (props >= 9) {\n\t\tprops -= 9;\n\t\t++s->lzma.literal_pos_mask;\n\t}\n\n\ts->lzma.lc = props;\n\n\tif (s->lzma.lc + s->lzma.literal_pos_mask > 4)\n\t\treturn false;\n\n\ts->lzma.literal_pos_mask = (1 << s->lzma.literal_pos_mask) - 1;\n\n\tlzma_reset(s);\n\n\treturn true;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4BE323(_DWORD *a1, unsigned __int8 a2)\n{\n  unsigned __int8 v3; // [rsp+4h] [rbp-Ch]\n\n  v3 = a2;\n  if ( a2 > 0xE0u )\n    return 0LL;\n  a1[39] = 0;\n  while ( v3 > 0x2Cu )\n  {\n    v3 -= 45;\n    ++a1[39];\n  }\n  a1[39] = (1 << a1[39]) - 1;\n  a1[38] = 0;\n  while ( v3 > 8u )\n  {\n    v3 -= 9;\n    ++a1[38];\n  }\n  a1[37] = v3;\n  if ( (unsigned int)(a1[37] + a1[38]) > 4 )\n    return 0LL;\n  a1[38] = (1 << a1[38]) - 1;\n  sub_4BE28A(a1);\n  return 1LL;\n}\n",
        "baseline_code_debug": "bool __cdecl lzma_props(xz_dec_lzma2 *s, uint8_t props)\n{\n  uint8_t propsa; // [rsp+4h] [rbp-Ch]\n\n  propsa = props;\n  if ( props > 0xE0u )\n    return 0;\n  s->lzma.pos_mask = 0;\n  while ( propsa > 0x2Cu )\n  {\n    propsa -= 45;\n    ++s->lzma.pos_mask;\n  }\n  s->lzma.pos_mask = (1 << s->lzma.pos_mask) - 1;\n  s->lzma.literal_pos_mask = 0;\n  while ( propsa > 8u )\n  {\n    propsa -= 9;\n    ++s->lzma.literal_pos_mask;\n  }\n  s->lzma.lc = propsa;\n  if ( s->lzma.lc + s->lzma.literal_pos_mask > 4 )\n    return 0;\n  s->lzma.literal_pos_mask = (1 << s->lzma.literal_pos_mask) - 1;\n  lzma_reset(s);\n  return 1;\n}\n",
        "similarity_score_unixcoder": 0.009369994513690472,
        "similarity_score_baseline_stripped": 0.4296833872795105,
        "similarity_score_baseline_debug": 0.8982182145118713
    },
    {
        "func_name": "writeTarFile",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004B52FD | 55 | push    rbp\n0x004B52FE | 48 89 E5 | mov     rbp, rsp\n0x004B5301 | 48 81 EC F0 00 00 00 | sub     rsp, 0F0h\n0x004B5308 | 89 BD 2C FF FF FF | mov     [rbp+var_D4], edi\n0x004B530E | 89 B5 28 FF FF FF | mov     [rbp+var_D8], esi\n0x004B5314 | 89 95 24 FF FF FF | mov     [rbp+var_DC], edx\n0x004B531A | 48 89 8D 18 FF FF FF | mov     [rbp+var_E8], rcx\n0x004B5321 | 4C 89 85 10 FF FF FF | mov     [rbp+var_F0], r8\n0x004B5328 | 44 89 8D 20 FF FF FF | mov     [rbp+var_E0], r9d\n0x004B532F | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x004B5336 | 48 C7 85 50 FF FF FF 00 00 00 00 | mov     [rbp+var_B0], 0\n0x004B5341 | 8B 85 2C FF FF FF | mov     eax, [rbp+var_D4]\n0x004B5347 | 89 85 40 FF FF FF | mov     [rbp+fd], eax\n0x004B534D | 8B 85 28 FF FF FF | mov     eax, [rbp+var_D8]\n0x004B5353 | 89 85 44 FF FF FF | mov     [rbp+var_BC], eax\n0x004B5359 | 8B 85 40 FF FF FF | mov     eax, [rbp+fd]\n0x004B535F | 48 8D 95 40 FF FF FF | lea     rdx, [rbp+fd]\n0x004B5366 | 48 8D 4A 20 | lea     rcx, [rdx+20h]\n0x004B536A | BA 21 27 52 00 | mov     edx, offset aCanTStatTarFil; \"can't stat tar file\"\n0x004B536F | 48 89 CE | mov     rsi, rcx\n0x004B5372 | 89 C7 | mov     edi, eax\n0x004B5374 | E8 6E 57 F5 FF | call    sub_40AAE7\n0x004B5379 | 83 BD 20 FF FF FF 00 | cmp     [rbp+var_E0], 0\n0x004B5380 | 74 15 | jz      short loc_4B5397\n0x004B5382 | 8B 85 40 FF FF FF | mov     eax, [rbp+fd]\n0x004B5388 | 8B 95 20 FF FF FF | mov     edx, [rbp+var_E0]\n0x004B538E | 89 D6 | mov     esi, edx\n0x004B5390 | 89 C7 | mov     edi, eax\n0x004B5392 | E8 55 FE FF FF | call    sub_4B51EC\n0x004B5397 | 48 8B 85 10 FF FF FF | mov     rax, [rbp+var_F0]\n0x004B539E | 48 89 85 48 FF FF FF | mov     [rbp+var_B8], rax\n0x004B53A5 | EB 4F | jmp     short loc_4B53F6\n0x004B53A7 | 8B B5 24 FF FF FF | mov     esi, [rbp+var_DC]\n0x004B53AD | 48 8B 85 18 FF FF FF | mov     rax, [rbp+var_E8]\n0x004B53B4 | 48 8B 40 08 | mov     rax, [rax+8]\n0x004B53B8 | 48 8D 95 40 FF FF FF | lea     rdx, [rbp+fd]\n0x004B53BF | 41 B9 00 00 00 00 | mov     r9d, 0\n0x004B53C5 | 49 89 D0 | mov     r8, rdx\n0x004B53C8 | B9 B0 4F 4B 00 | mov     ecx, offset sub_4B4FB0\n0x004B53CD | BA B0 4F 4B 00 | mov     edx, offset sub_4B4FB0\n0x004B53D2 | 48 89 C7 | mov     rdi, rax\n0x004B53D5 | E8 52 21 05 00 | call    sub_50752C\n0x004B53DA | 85 C0 | test    eax, eax\n0x004B53DC | 75 07 | jnz     short loc_4B53E5\n0x004B53DE | C7 45 FC 01 00 00 00 | mov     [rbp+var_4], 1\n0x004B53E5 | 48 8B 85 18 FF FF FF | mov     rax, [rbp+var_E8]\n0x004B53EC | 48 8B 00 | mov     rax, [rax]\n0x004B53EF | 48 89 85 18 FF FF FF | mov     [rbp+var_E8], rax\n0x004B53F6 | 48 83 BD 18 FF FF FF 00 | cmp     [rbp+var_E8], 0\n0x004B53FE | 75 A7 | jnz     short loc_4B53A7\n0x004B5400 | BA 00 04 00 00 | mov     edx, 400h; n\n0x004B5405 | BE 00 00 00 00 | mov     esi, 0; c\n0x004B540A | BF F8 B3 75 00 | mov     edi, offset dest; s\n0x004B540F | E8 3C 19 F5 FF | call    _memset\n0x004B5414 | 8B 85 40 FF FF FF | mov     eax, [rbp+fd]\n0x004B541A | BA 00 04 00 00 | mov     edx, 400h\n0x004B541F | BE F8 B3 75 00 | mov     esi, offset dest\n0x004B5424 | 89 C7 | mov     edi, eax\n0x004B5426 | E8 80 50 F5 FF | call    sub_40A4AB\n0x004B542B | 8B 85 40 FF FF FF | mov     eax, [rbp+fd]\n0x004B5431 | 89 C7 | mov     edi, eax; fd\n0x004B5433 | E8 D8 19 F5 FF | call    _close\n0x004B5438 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004B543C | 74 0F | jz      short loc_4B544D\n0x004B543E | BF 38 27 52 00 | mov     edi, offset aErrorExitDelay; \"error exit delayed from previous errors\"\n0x004B5443 | B8 00 00 00 00 | mov     eax, 0\n0x004B5448 | E8 FA 42 F5 FF | call    sub_409747\n0x004B544D | 83 BD 20 FF FF FF 00 | cmp     [rbp+var_E0], 0\n0x004B5454 | 74 53 | jz      short loc_4B54A9\n0x004B5456 | 48 8D 85 3C FF FF FF | lea     rax, [rbp+var_C4]\n0x004B545D | BA 00 00 00 00 | mov     edx, 0\n0x004B5462 | 48 89 C6 | mov     rsi, rax\n0x004B5465 | BF FF FF FF FF | mov     edi, 0FFFFFFFFh\n0x004B546A | E8 D9 4A F5 FF | call    sub_409F48\n0x004B546F | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x004B5472 | 75 11 | jnz     short loc_4B5485\n0x004B5474 | BF 60 27 52 00 | mov     edi, offset aWaitpid_1; \"waitpid\"\n0x004B5479 | B8 00 00 00 00 | mov     eax, 0\n0x004B547E | E8 56 3D F5 FF | call    sub_4091D9\n0x004B5483 | EB 24 | jmp     short loc_4B54A9\n0x004B5485 | 8B 85 3C FF FF FF | mov     eax, [rbp+var_C4]\n0x004B548B | 83 E0 7F | and     eax, 7Fh\n0x004B548E | 85 C0 | test    eax, eax\n0x004B5490 | 75 10 | jnz     short loc_4B54A2\n0x004B5492 | 8B 85 3C FF FF FF | mov     eax, [rbp+var_C4]\n0x004B5498 | C1 F8 08 | sar     eax, 8\n0x004B549B | 0F B6 C0 | movzx   eax, al\n0x004B549E | 85 C0 | test    eax, eax\n0x004B54A0 | 74 07 | jz      short loc_4B54A9\n0x004B54A2 | C7 45 FC 01 00 00 00 | mov     [rbp+var_4], 1\n0x004B54A9 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004B54AC | C9 | leave\n0x004B54AD | C3 | retn",
        "output": "",
        "source_code": "static NOINLINE int writeTarFile(int tar_fd, int verboseFlag,\n\tint recurseFlags, const llist_t *include,\n\tconst llist_t *exclude, int gzip)\n{\n\tint errorFlag = FALSE;\n\tstruct TarBallInfo tbInfo;\n\n\ttbInfo.hlInfoHead = NULL;\n\ttbInfo.tarFd = tar_fd;\n\ttbInfo.verboseFlag = verboseFlag;\n\n\t/* Store the stat info for the tarball's file, so\n\t * can avoid including the tarball into itself....  */\n\txfstat(tbInfo.tarFd, &tbInfo.tarFileStatBuf, \"can't stat tar file\");\n\n#if ENABLE_FEATURE_SEAMLESS_GZ || ENABLE_FEATURE_SEAMLESS_BZ2\n\tif (gzip)\n\t\tvfork_compressor(tbInfo.tarFd, gzip);\n#endif\n\n\ttbInfo.excludeList = exclude;\n\n\t/* Read the directory/files and iterate over them one at a time */\n\twhile (include) {\n\t\tif (!recursive_action(include->data, recurseFlags,\n\t\t\t\twriteFileToTarball, writeFileToTarball, &tbInfo, 0)\n\t\t) {\n\t\t\terrorFlag = TRUE;\n\t\t}\n\t\tinclude = include->link;\n\t}\n\t/* Write two empty blocks to the end of the archive */\n\tmemset(block_buf, 0, 2*TAR_BLOCK_SIZE);\n\txwrite(tbInfo.tarFd, block_buf, 2*TAR_BLOCK_SIZE);\n\n\t/* To be pedantically correct, we would check if the tarball\n\t * is smaller than 20 tar blocks, and pad it if it was smaller,\n\t * but that isn't necessary for GNU tar interoperability, and\n\t * so is considered a waste of space */\n\n\t/* Close so the child process (if any) will exit */\n\tclose(tbInfo.tarFd);\n\n\t/* Hang up the tools, close up shop, head home */\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tfreeHardLinkInfo(&tbInfo.hlInfoHead);\n\n\tif (errorFlag)\n\t\tbb_error_msg(\"error exit delayed from previous errors\");\n\n#if ENABLE_FEATURE_SEAMLESS_GZ || ENABLE_FEATURE_SEAMLESS_BZ2\n\tif (gzip) {\n\t\tint status;\n\t\tif (safe_waitpid(-1, &status, 0) == -1)\n\t\t\tbb_perror_msg(\"waitpid\");\n\t\telse if (!WIFEXITED(status) || WEXITSTATUS(status))\n\t\t\t/* gzip was killed or has exited with nonzero! */\n\t\t\terrorFlag = TRUE;\n\t}\n#endif\n\treturn errorFlag;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4B52FD(int a1, int a2, unsigned int a3, _QWORD *a4, __int64 a5, unsigned int a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  __int64 v10; // rdx\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  __int64 v13; // r9\n  int v19; // [rsp+2Ch] [rbp-C4h] BYREF\n  int fd[2]; // [rsp+30h] [rbp-C0h] BYREF\n  __int64 v21; // [rsp+38h] [rbp-B8h]\n  __int64 v22; // [rsp+40h] [rbp-B0h]\n  struct stat64 v23; // [rsp+50h] [rbp-A0h] BYREF\n  unsigned int v24; // [rsp+ECh] [rbp-4h]\n\n  v24 = 0;\n  v22 = 0LL;\n  fd[0] = a1;\n  fd[1] = a2;\n  sub_40AAE7(a1, &v23, (__int64)\"can't stat tar file\");\n  if ( a6 )\n    sub_4B51EC(fd[0], a6);\n  v21 = a5;\n  while ( a4 )\n  {\n    if ( !(unsigned int)sub_50752C(a4[1], a3, sub_4B4FB0, sub_4B4FB0, fd, 0LL) )\n      v24 = 1;\n    a4 = (_QWORD *)*a4;\n  }\n  memset(&dest, 0, 0x400uLL);\n  sub_40A4AB(fd[0], (__int64)&dest, 1024LL);\n  close(fd[0]);\n  if ( v24 )\n    sub_409747(\"error exit delayed from previous errors\", (__int64)&dest, v6, v7, v8, v9);\n  if ( a6 )\n  {\n    if ( (unsigned int)sub_409F48(-1, &v19, 0) == -1 )\n    {\n      sub_4091D9((__int64)\"waitpid\", (__int64)&v19, v10, v11, v12, v13);\n    }\n    else if ( (v19 & 0x7F) != 0 || BYTE1(v19) )\n    {\n      return 1;\n    }\n  }\n  return v24;\n}\n",
        "baseline_code_debug": "int __cdecl writeTarFile(\n        int tar_fd,\n        int verboseFlag,\n        int recurseFlags,\n        const llist_t_0 *include,\n        const llist_t_0 *exclude,\n        int gzip)\n{\n  int status; // [rsp+2Ch] [rbp-C4h] BYREF\n  TarBallInfo tbInfo; // [rsp+30h] [rbp-C0h] BYREF\n  int errorFlag; // [rsp+ECh] [rbp-4h]\n\n  errorFlag = 0;\n  tbInfo.hlInfoHead = 0LL;\n  tbInfo.tarFd = tar_fd;\n  tbInfo.verboseFlag = verboseFlag;\n  xfstat(tar_fd, &tbInfo.tarFileStatBuf, \"can't stat tar file\");\n  if ( gzip )\n    vfork_compressor(tbInfo.tarFd, gzip);\n  tbInfo.excludeList = exclude;\n  while ( include )\n  {\n    if ( !recursive_action(\n            include->data,\n            recurseFlags,\n            (int (*)(const char *, stat *, void *, int))writeFileToTarball,\n            (int (*)(const char *, stat *, void *, int))writeFileToTarball,\n            &tbInfo,\n            0) )\n      errorFlag = 1;\n    include = include->link;\n  }\n  memset(&bb_common_bufsiz1, 0, 0x400uLL);\n  xwrite(tbInfo.tarFd, &bb_common_bufsiz1, 0x400uLL);\n  close(tbInfo.tarFd);\n  if ( errorFlag )\n    bb_error_msg(\"error exit delayed from previous errors\");\n  if ( gzip )\n  {\n    if ( safe_waitpid(-1, &status, 0) == -1 )\n    {\n      bb_perror_msg(\"waitpid\");\n    }\n    else if ( (status & 0x7F) != 0 || BYTE1(status) )\n    {\n      return 1;\n    }\n  }\n  return errorFlag;\n}\n",
        "similarity_score_unixcoder": 0.07467157393693924,
        "similarity_score_baseline_stripped": 0.5742865800857544,
        "similarity_score_baseline_debug": 0.9014596939086914
    },
    {
        "func_name": "xrealloc_vector_helper",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0050C0E1 | 55 | push    rbp\n0x0050C0E2 | 48 89 E5 | mov     rbp, rsp\n0x0050C0E5 | 48 83 EC 20 | sub     rsp, 20h\n0x0050C0E9 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0050C0ED | 89 75 E4 | mov     [rbp+var_1C], esi\n0x0050C0F0 | 89 55 E0 | mov     [rbp+var_20], edx\n0x0050C0F3 | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x0050C0F6 | 0F B6 C0 | movzx   eax, al\n0x0050C0F9 | BA 01 00 00 00 | mov     edx, 1\n0x0050C0FE | 89 C1 | mov     ecx, eax\n0x0050C100 | D3 E2 | shl     edx, cl\n0x0050C102 | 89 D0 | mov     eax, edx\n0x0050C104 | 89 45 FC | mov     [rbp+var_4], eax\n0x0050C107 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0050C10A | 83 E8 01 | sub     eax, 1\n0x0050C10D | 23 45 E0 | and     eax, [rbp+var_20]\n0x0050C110 | 85 C0 | test    eax, eax\n0x0050C112 | 75 51 | jnz     short loc_50C165\n0x0050C114 | C1 6D E4 08 | shr     [rbp+var_1C], 8\n0x0050C118 | 8B 55 E0 | mov     edx, [rbp+var_20]\n0x0050C11B | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0050C11E | 01 D0 | add     eax, edx\n0x0050C120 | 83 C0 01 | add     eax, 1\n0x0050C123 | 0F AF 45 E4 | imul    eax, [rbp+var_1C]\n0x0050C127 | 89 C2 | mov     edx, eax\n0x0050C129 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0050C12D | 48 89 D6 | mov     rsi, rdx\n0x0050C130 | 48 89 C7 | mov     rdi, rax\n0x0050C133 | E8 66 DF EF FF | call    sub_40A09E\n0x0050C138 | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x0050C13C | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0050C13F | 83 C0 01 | add     eax, 1\n0x0050C142 | 0F AF 45 E4 | imul    eax, [rbp+var_1C]\n0x0050C146 | 89 C2 | mov     edx, eax; n\n0x0050C148 | 8B 45 E0 | mov     eax, [rbp+var_20]\n0x0050C14B | 0F AF 45 E4 | imul    eax, [rbp+var_1C]\n0x0050C14F | 89 C1 | mov     ecx, eax\n0x0050C151 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0050C155 | 48 01 C8 | add     rax, rcx\n0x0050C158 | BE 00 00 00 00 | mov     esi, 0; c\n0x0050C15D | 48 89 C7 | mov     rdi, rax; s\n0x0050C160 | E8 EB AB EF FF | call    _memset\n0x0050C165 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0050C169 | C9 | leave\n0x0050C16A | C3 | retn",
        "output": "",
        "source_code": "FAST_FUNC xrealloc_vector_helper(void *vector, unsigned sizeof_and_shift, int idx)\n{\n\tint mask = 1 << (uint8_t)sizeof_and_shift;\n\n\tif (!(idx & (mask - 1))) {\n\t\tsizeof_and_shift >>= 8; /* sizeof(vector[0]) */\n\t\tvector = xrealloc(vector, sizeof_and_shift * (idx + mask + 1));\n\t\tmemset((char*)vector + (sizeof_and_shift * idx), 0, sizeof_and_shift * (mask + 1));\n\t}\n\treturn vector;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "char *__fastcall sub_50C0E1(char *a1, unsigned int a2, int a3)\n{\n  char *v5; // [rsp+8h] [rbp-18h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  v5 = a1;\n  v6 = 1 << a2;\n  if ( (a3 & ((1 << a2) - 1)) == 0 )\n  {\n    v5 = (char *)sub_40A09E(a1, (a2 >> 8) * (a3 + v6 + 1));\n    memset(&v5[(a2 >> 8) * a3], 0, (a2 >> 8) * (v6 + 1));\n  }\n  return v5;\n}\n",
        "baseline_code_debug": "void *__cdecl xrealloc_vector_helper(void *vector, unsigned int sizeof_and_shift, int idx)\n{\n  char *vectora; // [rsp+8h] [rbp-18h]\n  int mask; // [rsp+1Ch] [rbp-4h]\n\n  vectora = (char *)vector;\n  mask = 1 << sizeof_and_shift;\n  if ( (idx & ((1 << sizeof_and_shift) - 1)) == 0 )\n  {\n    vectora = (char *)xrealloc(vector, (sizeof_and_shift >> 8) * (idx + mask + 1));\n    memset(&vectora[(sizeof_and_shift >> 8) * idx], 0, (sizeof_and_shift >> 8) * (mask + 1));\n  }\n  return vectora;\n}\n",
        "similarity_score_unixcoder": 0.04401322826743126,
        "similarity_score_baseline_stripped": 0.6163210868835449,
        "similarity_score_baseline_debug": 0.9031795263290405
    },
    {
        "func_name": "print_stats_and_exit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043DEF7 | 55 | push    rbp\n0x0043DEF8 | 48 89 E5 | mov     rbp, rsp\n0x0043DEFB | 48 83 EC 20 | sub     rsp, 20h\n0x0043DEFF | 89 7D EC | mov     [rbp+var_14], edi\n0x0043DF02 | BE 01 00 00 00 | mov     esi, 1; handler\n0x0043DF07 | BF 02 00 00 00 | mov     edi, 2; sig\n0x0043DF0C | E8 5F 91 FC FF | call    _signal\n0x0043DF11 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043DF16 | 48 8B 40 78 | mov     rax, [rax+78h]\n0x0043DF1A | 48 89 C6 | mov     rsi, rax\n0x0043DF1D | BF 00 B6 52 00 | mov     edi, offset aSPingStatistic; \"\\n--- %s ping statistics ---\\n\"\n0x0043DF22 | B8 00 00 00 00 | mov     eax, 0\n0x0043DF27 | E8 A4 8C FC FF | call    _printf\n0x0043DF2C | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043DF31 | 48 8B 40 28 | mov     rax, [rax+28h]\n0x0043DF35 | 48 89 C6 | mov     rsi, rax\n0x0043DF38 | BF 1D B6 52 00 | mov     edi, offset aLuPacketsTrans; \"%lu packets transmitted, \"\n0x0043DF3D | B8 00 00 00 00 | mov     eax, 0\n0x0043DF42 | E8 89 8C FC FF | call    _printf\n0x0043DF47 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043DF4C | 48 8B 40 30 | mov     rax, [rax+30h]\n0x0043DF50 | 48 89 C6 | mov     rsi, rax\n0x0043DF53 | BF 37 B6 52 00 | mov     edi, offset aLuPacketsRecei; \"%lu packets received, \"\n0x0043DF58 | B8 00 00 00 00 | mov     eax, 0\n0x0043DF5D | E8 6E 8C FC FF | call    _printf\n0x0043DF62 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043DF67 | 48 8B 40 38 | mov     rax, [rax+38h]\n0x0043DF6B | 48 85 C0 | test    rax, rax\n0x0043DF6E | 74 1B | jz      short loc_43DF8B\n0x0043DF70 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043DF75 | 48 8B 40 38 | mov     rax, [rax+38h]\n0x0043DF79 | 48 89 C6 | mov     rsi, rax\n0x0043DF7C | BF 4E B6 52 00 | mov     edi, offset aLuDuplicates; \"%lu duplicates, \"\n0x0043DF81 | B8 00 00 00 00 | mov     eax, 0\n0x0043DF86 | E8 45 8C FC FF | call    _printf\n0x0043DF8B | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043DF90 | 48 8B 40 28 | mov     rax, [rax+28h]\n0x0043DF94 | 48 85 C0 | test    rax, rax\n0x0043DF97 | 74 48 | jz      short loc_43DFE1\n0x0043DF99 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043DF9E | 48 8B 50 28 | mov     rdx, [rax+28h]\n0x0043DFA2 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043DFA7 | 48 8B 40 30 | mov     rax, [rax+30h]\n0x0043DFAB | 48 29 C2 | sub     rdx, rax\n0x0043DFAE | 48 89 D0 | mov     rax, rdx\n0x0043DFB1 | 48 C1 E0 02 | shl     rax, 2\n0x0043DFB5 | 48 01 D0 | add     rax, rdx\n0x0043DFB8 | 48 8D 14 85 00 00 00 00 | lea     rdx, ds:0[rax*4]\n0x0043DFC0 | 48 01 D0 | add     rax, rdx\n0x0043DFC3 | 48 C1 E0 02 | shl     rax, 2\n0x0043DFC7 | BA F8 B3 75 00 | mov     edx, offset dest\n0x0043DFCC | 48 8B 7A 28 | mov     rdi, [rdx+28h]\n0x0043DFD0 | B9 F8 B3 75 00 | mov     ecx, offset dest\n0x0043DFD5 | BA 00 00 00 00 | mov     edx, 0\n0x0043DFDA | 48 F7 F7 | div     rdi\n0x0043DFDD | 48 89 41 28 | mov     [rcx+28h], rax\n0x0043DFE1 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043DFE6 | 48 8B 40 28 | mov     rax, [rax+28h]\n0x0043DFEA | 48 89 C6 | mov     rsi, rax\n0x0043DFED | BF 5F B6 52 00 | mov     edi, offset aLuPacketLoss; \"%lu%% packet loss\\n\"\n0x0043DFF2 | B8 00 00 00 00 | mov     eax, 0\n0x0043DFF7 | E8 D4 8B FC FF | call    _printf\n0x0043DFFC | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E001 | 8B 40 44 | mov     eax, [rax+44h]\n0x0043E004 | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x0043E007 | 0F 84 E2 00 00 00 | jz      loc_43E0EF\n0x0043E00D | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E012 | 48 8B 40 50 | mov     rax, [rax+50h]\n0x0043E016 | BA F8 B3 75 00 | mov     edx, offset dest\n0x0043E01B | 48 8B 4A 30 | mov     rcx, [rdx+30h]\n0x0043E01F | BA F8 B3 75 00 | mov     edx, offset dest\n0x0043E024 | 48 8B 52 38 | mov     rdx, [rdx+38h]\n0x0043E028 | 48 01 D1 | add     rcx, rdx\n0x0043E02B | BA 00 00 00 00 | mov     edx, 0\n0x0043E030 | 48 F7 F1 | div     rcx\n0x0043E033 | 89 45 FC | mov     [rbp+var_4], eax\n0x0043E036 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E03B | 8B 70 48 | mov     esi, [rax+48h]\n0x0043E03E | BA D3 4D 62 10 | mov     edx, 10624DD3h\n0x0043E043 | 89 F0 | mov     eax, esi\n0x0043E045 | F7 E2 | mul     edx\n0x0043E047 | 89 D1 | mov     ecx, edx\n0x0043E049 | C1 E9 06 | shr     ecx, 6\n0x0043E04C | 69 C1 E8 03 00 00 | imul    eax, ecx, 3E8h\n0x0043E052 | 89 F1 | mov     ecx, esi\n0x0043E054 | 29 C1 | sub     ecx, eax\n0x0043E056 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E05B | 8B 40 48 | mov     eax, [rax+48h]\n0x0043E05E | BA D3 4D 62 10 | mov     edx, 10624DD3h\n0x0043E063 | F7 E2 | mul     edx\n0x0043E065 | C1 EA 06 | shr     edx, 6\n0x0043E068 | 41 89 D1 | mov     r9d, edx\n0x0043E06B | 8B 75 FC | mov     esi, [rbp+var_4]\n0x0043E06E | BA D3 4D 62 10 | mov     edx, 10624DD3h\n0x0043E073 | 89 F0 | mov     eax, esi\n0x0043E075 | F7 E2 | mul     edx\n0x0043E077 | 89 D7 | mov     edi, edx\n0x0043E079 | C1 EF 06 | shr     edi, 6\n0x0043E07C | 69 C7 E8 03 00 00 | imul    eax, edi, 3E8h\n0x0043E082 | 89 F7 | mov     edi, esi\n0x0043E084 | 29 C7 | sub     edi, eax\n0x0043E086 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0043E089 | BA D3 4D 62 10 | mov     edx, 10624DD3h\n0x0043E08E | F7 E2 | mul     edx\n0x0043E090 | C1 EA 06 | shr     edx, 6\n0x0043E093 | 41 89 D2 | mov     r10d, edx\n0x0043E096 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E09B | 44 8B 40 44 | mov     r8d, [rax+44h]\n0x0043E09F | BA D3 4D 62 10 | mov     edx, 10624DD3h\n0x0043E0A4 | 44 89 C0 | mov     eax, r8d\n0x0043E0A7 | F7 E2 | mul     edx\n0x0043E0A9 | 89 D6 | mov     esi, edx\n0x0043E0AB | C1 EE 06 | shr     esi, 6\n0x0043E0AE | 69 C6 E8 03 00 00 | imul    eax, esi, 3E8h\n0x0043E0B4 | 44 89 C6 | mov     esi, r8d\n0x0043E0B7 | 29 C6 | sub     esi, eax\n0x0043E0B9 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E0BE | 8B 40 44 | mov     eax, [rax+44h]\n0x0043E0C1 | BA D3 4D 62 10 | mov     edx, 10624DD3h\n0x0043E0C6 | F7 E2 | mul     edx\n0x0043E0C8 | 89 D0 | mov     eax, edx\n0x0043E0CA | C1 E8 06 | shr     eax, 6\n0x0043E0CD | 48 83 EC 08 | sub     rsp, 8\n0x0043E0D1 | 51 | push    rcx\n0x0043E0D2 | 41 89 F8 | mov     r8d, edi\n0x0043E0D5 | 44 89 D1 | mov     ecx, r10d\n0x0043E0D8 | 89 F2 | mov     edx, esi\n0x0043E0DA | 89 C6 | mov     esi, eax\n0x0043E0DC | BF 78 B6 52 00 | mov     edi, offset aRoundTripMinAv; \"round-trip min/avg/max = %u.%03u/%u.%03\"...\n0x0043E0E1 | B8 00 00 00 00 | mov     eax, 0\n0x0043E0E6 | E8 E5 8A FC FF | call    _printf\n0x0043E0EB | 48 83 C4 10 | add     rsp, 10h\n0x0043E0EF | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E0F4 | 48 8B 40 30 | mov     rax, [rax+30h]\n0x0043E0F8 | 48 85 C0 | test    rax, rax\n0x0043E0FB | 74 24 | jz      short loc_43E121\n0x0043E0FD | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E102 | 8B 40 58 | mov     eax, [rax+58h]\n0x0043E105 | 85 C0 | test    eax, eax\n0x0043E107 | 74 1F | jz      short loc_43E128\n0x0043E109 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E10E | 48 8B 40 30 | mov     rax, [rax+30h]\n0x0043E112 | BA F8 B3 75 00 | mov     edx, offset dest\n0x0043E117 | 8B 52 1C | mov     edx, [rdx+1Ch]\n0x0043E11A | 89 D2 | mov     edx, edx\n0x0043E11C | 48 39 D0 | cmp     rax, rdx\n0x0043E11F | 73 07 | jnb     short loc_43E128\n0x0043E121 | B8 01 00 00 00 | mov     eax, 1\n0x0043E126 | EB 05 | jmp     short loc_43E12D\n0x0043E128 | B8 00 00 00 00 | mov     eax, 0\n0x0043E12D | 89 C7 | mov     edi, eax; status\n0x0043E12F | E8 8C 99 FC FF | call    _exit",
        "output": "\n0x0043E134 | 5D | pop    rbp\n0x0043E135 | 48 83 EC 08 | sub     rsp, 8\n00x0043E139 | C3 | ret",
        "source_code": "static void print_stats_and_exit(int junk UNUSED_PARAM)\n{\n\tsignal(SIGINT, SIG_IGN);\n\n\tprintf(\"\\n--- %s ping statistics ---\\n\", hostname);\n\tprintf(\"%lu packets transmitted, \", ntransmitted);\n\tprintf(\"%lu packets received, \", nreceived);\n\tif (nrepeats)\n\t\tprintf(\"%lu duplicates, \", nrepeats);\n\tif (ntransmitted)\n\t\tntransmitted = (ntransmitted - nreceived) * 100 / ntransmitted;\n\tprintf(\"%lu%% packet loss\\n\", ntransmitted);\n\tif (tmin != UINT_MAX) {\n\t\tunsigned tavg = tsum / (nreceived + nrepeats);\n\t\tprintf(\"round-trip min/avg/max = %u.%03u/%u.%03u/%u.%03u ms\\n\",\n\t\t\ttmin / 1000, tmin % 1000,\n\t\t\ttavg / 1000, tavg % 1000,\n\t\t\ttmax / 1000, tmax % 1000);\n\t}\n\t/* if condition is true, exit with 1 -- 'failure' */\n\texit(nreceived == 0 || (deadline && nreceived < pingcount));\n}",
        "parsed_output": "\n0x0043E134 | 5D | pop    rbp\n0x0043E135 | 48 83 EC 08 | sub     rsp, 8\n00x0043E139 | C3 | ret",
        "baseline_code_stripped": "void __noreturn sub_43DEF7()\n{\n  int v0; // eax\n  unsigned int v1; // [rsp+1Ch] [rbp-4h]\n\n  signal(2, (__sighandler_t)1);\n  printf(\"\\n--- %s ping statistics ---\\n\", *((const char **)&dest + 15));\n  printf(\"%lu packets transmitted, \", *(_QWORD *)&dest.c_cc[23]);\n  printf(\"%lu packets received, \", *(_QWORD *)&dest.c_cc[31]);\n  if ( *(_QWORD *)&dest.c_ospeed )\n    printf(\"%lu duplicates, \", *(_QWORD *)&dest.c_ospeed);\n  if ( *(_QWORD *)&dest.c_cc[23] )\n    *(_QWORD *)&dest.c_cc[23] = (unsigned __int64)(100LL * (*(_QWORD *)&dest.c_cc[23] - *(_QWORD *)&dest.c_cc[31]))\n                              / *(_QWORD *)&dest.c_cc[23];\n  printf(\"%lu%% packet loss\\n\", *(_QWORD *)&dest.c_cc[23]);\n  if ( *((_DWORD *)&dest + 17) != -1 )\n  {\n    v1 = *((_QWORD *)&dest + 10) / (*(_QWORD *)&dest.c_ospeed + *(_QWORD *)&dest.c_cc[31]);\n    printf(\n      \"round-trip min/avg/max = %u.%03u/%u.%03u/%u.%03u ms\\n\",\n      *((_DWORD *)&dest + 17) / 0x3E8u,\n      *((_DWORD *)&dest + 17) % 0x3E8u,\n      v1 / 0x3E8,\n      v1 % 0x3E8,\n      *((_DWORD *)&dest + 18) / 0x3E8u,\n      *((_DWORD *)&dest + 18) % 0x3E8u);\n  }\n  v0 = !*(_QWORD *)&dest.c_cc[31]\n    || *((_DWORD *)&dest + 22) && *(_QWORD *)&dest.c_cc[31] < (unsigned __int64)*(unsigned int *)&dest.c_cc[11];\n  exit(v0);\n}\n",
        "baseline_code_debug": "void __cdecl __noreturn print_stats_and_exit(int junk)\n{\n  int v1; // eax\n  unsigned int tavg; // [rsp+1Ch] [rbp-4h]\n\n  signal(2, (__sighandler_t)1);\n  printf(\"\\n--- %s ping statistics ---\\n\", *((const char **)&bb_common_bufsiz1 + 15));\n  printf(\"%lu packets transmitted, \", *(_QWORD *)&bb_common_bufsiz1.c_cc[23]);\n  printf(\"%lu packets received, \", *(_QWORD *)&bb_common_bufsiz1.c_cc[31]);\n  if ( *(_QWORD *)&bb_common_bufsiz1.c_ospeed )\n    printf(\"%lu duplicates, \", *(_QWORD *)&bb_common_bufsiz1.c_ospeed);\n  if ( *(_QWORD *)&bb_common_bufsiz1.c_cc[23] )\n    *(_QWORD *)&bb_common_bufsiz1.c_cc[23] = (unsigned __int64)(100LL\n                                                              * (*(_QWORD *)&bb_common_bufsiz1.c_cc[23]\n                                                               - *(_QWORD *)&bb_common_bufsiz1.c_cc[31]))\n                                           / *(_QWORD *)&bb_common_bufsiz1.c_cc[23];\n  printf(\"%lu%% packet loss\\n\", *(_QWORD *)&bb_common_bufsiz1.c_cc[23]);\n  if ( *((_DWORD *)&bb_common_bufsiz1 + 17) != -1 )\n  {\n    tavg = *((_QWORD *)&bb_common_bufsiz1 + 10)\n         / (*(_QWORD *)&bb_common_bufsiz1.c_ospeed + *(_QWORD *)&bb_common_bufsiz1.c_cc[31]);\n    printf(\n      \"round-trip min/avg/max = %u.%03u/%u.%03u/%u.%03u ms\\n\",\n      *((_DWORD *)&bb_common_bufsiz1 + 17) / 0x3E8u,\n      *((_DWORD *)&bb_common_bufsiz1 + 17) % 0x3E8u,\n      tavg / 0x3E8,\n      tavg % 0x3E8,\n      *((_DWORD *)&bb_common_bufsiz1 + 18) / 0x3E8u,\n      *((_DWORD *)&bb_common_bufsiz1 + 18) % 0x3E8u);\n  }\n  v1 = !*(_QWORD *)&bb_common_bufsiz1.c_cc[31]\n    || *((_DWORD *)&bb_common_bufsiz1 + 22)\n    && *(_QWORD *)&bb_common_bufsiz1.c_cc[31] < (unsigned __int64)*(unsigned int *)&bb_common_bufsiz1.c_cc[11];\n  exit(v1);\n}\n",
        "similarity_score_unixcoder": 0.307934045791626,
        "similarity_score_baseline_stripped": 0.5795648097991943,
        "similarity_score_baseline_debug": 0.5727331638336182
    },
    {
        "func_name": "udhcp_str2nip",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00459D25 | 55 | push    rbp\n0x00459D26 | 48 89 E5 | mov     rbp, rsp\n0x00459D29 | 48 83 EC 20 | sub     rsp, 20h\n0x00459D2D | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00459D31 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00459D35 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00459D39 | BA 02 00 00 00 | mov     edx, 2\n0x00459D3E | BE 00 00 00 00 | mov     esi, 0\n0x00459D43 | 48 89 C7 | mov     rdi, rax\n0x00459D46 | E8 57 1D 0B 00 | call    sub_50BAA2\n0x00459D4B | 48 89 45 F8 | mov     [rbp+ptr], rax\n0x00459D4F | 48 83 7D F8 00 | cmp     [rbp+ptr], 0\n0x00459D54 | 75 07 | jnz     short loc_459D5D\n0x00459D56 | B8 00 00 00 00 | mov     eax, 0\n0x00459D5B | EB 1E | jmp     short locret_459D7B\n0x00459D5D | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00459D61 | 8B 50 08 | mov     edx, [rax+8]\n0x00459D64 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00459D68 | 89 10 | mov     [rax], edx\n0x00459D6A | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00459D6E | 48 89 C7 | mov     rdi, rax; ptr\n0x00459D71 | E8 EA C8 FA FF | call    _free\n0x00459D76 | B8 01 00 00 00 | mov     eax, 1\n0x00459D7B | C9 | leave\n0x00459D7C | C3 | retn",
        "output": "",
        "source_code": "int FAST_FUNC udhcp_str2nip(const char *str, void *arg)\n{\n\tlen_and_sockaddr *lsa;\n\n\tlsa = host_and_af2sockaddr(str, 0, AF_INET);\n\tif (!lsa)\n\t\treturn 0;\n\t/* arg maybe unaligned */\n\tmove_to_unaligned32((uint32_t*)arg, lsa->u.sin.sin_addr.s_addr);\n\tfree(lsa);\n\treturn 1;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_459D25(__int64 a1, _DWORD *a2)\n{\n  _DWORD *ptr; // [rsp+18h] [rbp-8h]\n\n  ptr = (_DWORD *)sub_50BAA2(a1, 0LL, 2LL);\n  if ( !ptr )\n    return 0LL;\n  *a2 = ptr[2];\n  free(ptr);\n  return 1LL;\n}\n",
        "baseline_code_debug": "int __cdecl udhcp_str2nip(const char *str, void *arg)\n{\n  len_and_sockaddr_0 *lsa; // [rsp+18h] [rbp-8h]\n\n  lsa = host_and_af2sockaddr(str, 0, 2u);\n  if ( !lsa )\n    return 0;\n  *(_DWORD *)arg = lsa->u.sin.sin_addr.s_addr;\n  free(lsa);\n  return 1;\n}\n",
        "similarity_score_unixcoder": 0.09517598152160645,
        "similarity_score_baseline_stripped": 0.47081640362739563,
        "similarity_score_baseline_debug": 0.9108211994171143
    },
    {
        "func_name": "llist_find_str",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00409191 | 55 | push    rbp\n0x00409192 | 48 89 E5 | mov     rbp, rsp\n0x00409195 | 48 83 EC 10 | sub     rsp, 10h\n0x00409199 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0040919D | 48 89 75 F0 | mov     [rbp+s2], rsi\n0x004091A1 | EB 26 | jmp     short loc_4091C9\n0x004091A3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004091A7 | 48 8B 40 08 | mov     rax, [rax+8]\n0x004091AB | 48 8B 55 F0 | mov     rdx, [rbp+s2]\n0x004091AF | 48 89 D6 | mov     rsi, rdx; s2\n0x004091B2 | 48 89 C7 | mov     rdi, rax; s1\n0x004091B5 | E8 96 DE FF FF | call    _strcmp\n0x004091BA | 85 C0 | test    eax, eax\n0x004091BC | 74 14 | jz      short loc_4091D2\n0x004091BE | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004091C2 | 48 8B 00 | mov     rax, [rax]\n0x004091C5 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004091C9 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004091CE | 75 D3 | jnz     short loc_4091A3\n0x004091D0 | EB 01 | jmp     short loc_4091D3\n0x004091D2 | 90 | nop\n0x004091D3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004091D7 | C9 | leave\n0x004091D8 | C3 | retn",
        "output": "",
        "source_code": "FAST_FUNC llist_find_str(llist_t *list, const char *str)\n{\n\twhile (list) {\n\t\tif (strcmp(list->data, str) == 0)\n\t\t\tbreak;\n\t\tlist = list->link;\n\t}\n\treturn list;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 **__fastcall sub_409191(__int64 **a1, const char *a2)\n{\n  while ( a1 && strcmp((const char *)a1[1], a2) )\n    a1 = (__int64 **)*a1;\n  return a1;\n}\n",
        "baseline_code_debug": "llist_t_0 *__cdecl llist_find_str(llist_t_0 *list, const char *str)\n{\n  while ( list && strcmp(list->data, str) )\n    list = list->link;\n  return list;\n}\n",
        "similarity_score_unixcoder": 0.08800790458917618,
        "similarity_score_baseline_stripped": 0.563047468662262,
        "similarity_score_baseline_debug": 0.926653265953064
    },
    {
        "func_name": "wget_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00447FE0 | 55 | push    rbp\n0x00447FE1 | 48 89 E5 | mov     rbp, rsp\n0x00447FE4 | 53 | push    rbx\n0x00447FE5 | 48 83 EC 38 | sub     rsp, 38h\n0x00447FE9 | 89 7D CC | mov     [rbp+var_34], edi\n0x00447FEC | 48 89 75 C0 | mov     [rbp+var_40], rsi\n0x00447FF0 | 48 C7 45 D0 00 00 00 00 | mov     [rbp+var_30], 0\n0x00447FF8 | BB 08 D4 75 00 | mov     ebx, offset qword_75D408\n0x00447FFD | BF 80 10 00 00 | mov     edi, 1080h\n0x00448002 | E8 E1 20 FC FF | call    sub_40A0E8\n0x00448007 | 48 89 03 | mov     [rbx], rax\n0x0044800A | 48 8B 05 F7 53 31 00 | mov     rax, cs:qword_75D408\n0x00448011 | C7 40 68 84 03 00 00 | mov     dword ptr [rax+68h], 384h\n0x00448018 | 48 8B 05 E9 53 31 00 | mov     rax, cs:qword_75D408\n0x0044801F | C7 40 68 84 03 00 00 | mov     dword ptr [rax+68h], 384h\n0x00448026 | 48 8B 05 DB 53 31 00 | mov     rax, cs:qword_75D408\n0x0044802D | 48 C7 40 58 4C C1 52 00 | mov     qword ptr [rax+58h], offset aOn_0; \"on\"\n0x00448035 | 48 8B 05 CC 53 31 00 | mov     rax, cs:qword_75D408\n0x0044803C | 48 C7 40 60 4F C1 52 00 | mov     qword ptr [rax+60h], offset aWget; \"Wget\"\n0x00448044 | 48 C7 05 F9 53 31 00 9E C1 52 00 | mov     cs:qword_75D448, offset aContinue_0; \"continue\"\n0x0044804F | 48 C7 05 E6 53 31 00 54 C1 52 00 | mov     cs:qword_75D440, offset unk_52C154\n0x0044805A | 48 8B 05 A7 53 31 00 | mov     rax, cs:qword_75D408\n0x00448061 | 48 8D 50 40 | lea     rdx, [rax+40h]\n0x00448065 | 48 8B 05 9C 53 31 00 | mov     rax, cs:qword_75D408\n0x0044806C | 48 8D 78 68 | lea     rdi, [rax+68h]\n0x00448070 | 48 8B 05 91 53 31 00 | mov     rax, cs:qword_75D408\n0x00448077 | 4C 8D 48 60 | lea     r9, [rax+60h]\n0x0044807B | 48 8B 05 86 53 31 00 | mov     rax, cs:qword_75D408\n0x00448082 | 4C 8D 40 58 | lea     r8, [rax+58h]\n0x00448086 | 48 8B 05 7B 53 31 00 | mov     rax, cs:qword_75D408\n0x0044808D | 48 8D 48 38 | lea     rcx, [rax+38h]\n0x00448091 | 48 8B 05 70 53 31 00 | mov     rax, cs:qword_75D408\n0x00448098 | 48 8D 70 50 | lea     rsi, [rax+50h]\n0x0044809C | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004480A0 | 52 | push    rdx\n0x004480A1 | 48 8D 55 D0 | lea     rdx, [rbp+var_30]\n0x004480A5 | 52 | push    rdx\n0x004480A6 | 6A 00 | push    0\n0x004480A8 | 57 | push    rdi\n0x004480A9 | 48 89 F2 | mov     rdx, rsi\n0x004480AC | BE 5E C1 52 00 | mov     esi, offset aCsqoPYUTT; \"csqO:P:Y:U:T:t:\"\n0x004480B1 | 48 89 C7 | mov     rdi, rax\n0x004480B4 | B8 00 00 00 00 | mov     eax, 0\n0x004480B9 | E8 31 21 0B 00 | call    sub_4FA1EF\n0x004480BE | 48 83 C4 20 | add     rsp, 20h\n0x004480C2 | 8B 05 B0 2D 31 00 | mov     eax, cs:optind\n0x004480C8 | 48 98 | cdqe\n0x004480CA | 48 C1 E0 03 | shl     rax, 3\n0x004480CE | 48 01 45 C0 | add     [rbp+var_40], rax\n0x004480D2 | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x004480D6 | 48 85 C0 | test    rax, rax\n0x004480D9 | 0F 84 96 00 00 00 | jz      loc_448175\n0x004480DF | C7 45 EC 01 00 00 00 | mov     [rbp+var_14], 1\n0x004480E6 | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x004480EA | 48 89 45 D8 | mov     [rbp+var_28], rax\n0x004480EE | EB 28 | jmp     short loc_448118\n0x004480F0 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004480F4 | 48 8B 40 08 | mov     rax, [rax+8]\n0x004480F8 | 48 89 C7 | mov     rdi, rax; s\n0x004480FB | E8 D0 E9 FB FF | call    _strlen\n0x00448100 | 89 C2 | mov     edx, eax\n0x00448102 | 8B 45 EC | mov     eax, [rbp+var_14]\n0x00448105 | 01 D0 | add     eax, edx\n0x00448107 | 83 C0 02 | add     eax, 2\n0x0044810A | 89 45 EC | mov     [rbp+var_14], eax\n0x0044810D | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00448111 | 48 8B 00 | mov     rax, [rax]\n0x00448114 | 48 89 45 D8 | mov     [rbp+var_28], rax\n0x00448118 | 48 83 7D D8 00 | cmp     [rbp+var_28], 0\n0x0044811D | 75 D1 | jnz     short loc_4480F0\n0x0044811F | 8B 45 EC | mov     eax, [rbp+var_14]\n0x00448122 | 48 98 | cdqe\n0x00448124 | 48 89 C7 | mov     rdi, rax\n0x00448127 | E8 33 1F FC FF | call    sub_40A05F\n0x0044812C | 48 89 45 E0 | mov     [rbp+s], rax\n0x00448130 | 48 8B 05 D1 52 31 00 | mov     rax, cs:qword_75D408\n0x00448137 | 48 8B 55 E0 | mov     rdx, [rbp+s]\n0x0044813B | 48 89 50 48 | mov     [rax+48h], rdx\n0x0044813F | EB 2B | jmp     short loc_44816C\n0x00448141 | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00448145 | 48 89 C7 | mov     rdi, rax\n0x00448148 | E8 1A 0F FC FF | call    sub_409067\n0x0044814D | 48 89 C2 | mov     rdx, rax\n0x00448150 | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x00448154 | BE 6E C1 52 00 | mov     esi, offset aS_37; \"%s\\r\\n\"\n0x00448159 | 48 89 C7 | mov     rdi, rax; s\n0x0044815C | B8 00 00 00 00 | mov     eax, 0\n0x00448161 | E8 1A F9 FB FF | call    _sprintf\n0x00448166 | 48 98 | cdqe\n0x00448168 | 48 01 45 E0 | add     [rbp+s], rax\n0x0044816C | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x00448170 | 48 85 C0 | test    rax, rax\n0x00448173 | 75 CC | jnz     short loc_448141\n0x00448175 | 48 8B 05 8C 52 31 00 | mov     rax, cs:qword_75D408\n0x0044817C | C7 40 6C FF FF FF FF | mov     dword ptr [rax+6Ch], 0FFFFFFFFh\n0x00448183 | 48 8B 05 7E 52 31 00 | mov     rax, cs:qword_75D408\n0x0044818A | C7 40 70 C1 02 00 00 | mov     dword ptr [rax+70h], 2C1h\n0x00448191 | 48 8B 05 70 52 31 00 | mov     rax, cs:qword_75D408\n0x00448198 | 48 8B 40 50 | mov     rax, [rax+50h]\n0x0044819C | 48 85 C0 | test    rax, rax\n0x0044819F | 74 6C | jz      short loc_44820D\n0x004481A1 | 48 8B 05 60 52 31 00 | mov     rax, cs:qword_75D408\n0x004481A8 | 48 8B 40 50 | mov     rax, [rax+50h]\n0x004481AC | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004481AF | 3C 2D | cmp     al, 2Dh ; '-'\n0x004481B1 | 75 33 | jnz     short loc_4481E6\n0x004481B3 | 48 8B 05 4E 52 31 00 | mov     rax, cs:qword_75D408\n0x004481BA | 48 8B 40 50 | mov     rax, [rax+50h]\n0x004481BE | 48 83 C0 01 | add     rax, 1\n0x004481C2 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004481C5 | 84 C0 | test    al, al\n0x004481C7 | 75 1D | jnz     short loc_4481E6\n0x004481C9 | 48 8B 05 38 52 31 00 | mov     rax, cs:qword_75D408\n0x004481D0 | C7 40 6C 01 00 00 00 | mov     dword ptr [rax+6Ch], 1\n0x004481D7 | 8B 05 73 52 31 00 | mov     eax, cs:dword_75D450\n0x004481DD | 83 E0 FE | and     eax, 0FFFFFFFEh\n0x004481E0 | 89 05 6A 52 31 00 | mov     cs:dword_75D450, eax\n0x004481E6 | 48 8B 05 1B 52 31 00 | mov     rax, cs:qword_75D408\n0x004481ED | C7 40 70 41 02 00 00 | mov     dword ptr [rax+70h], 241h\n0x004481F4 | EB 17 | jmp     short loc_44820D\n0x004481F6 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004481FA | 48 8D 50 08 | lea     rdx, [rax+8]\n0x004481FE | 48 89 55 C0 | mov     [rbp+var_40], rdx\n0x00448202 | 48 8B 00 | mov     rax, [rax]\n0x00448205 | 48 89 C7 | mov     rdi, rax\n0x00448208 | E8 0A F4 FF FF | call    sub_447617\n0x0044820D | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x00448211 | 48 8B 00 | mov     rax, [rax]\n0x00448214 | 48 85 C0 | test    rax, rax\n0x00448217 | 75 DD | jnz     short loc_4481F6\n0x00448219 | 48 8B 05 E8 51 31 00 | mov     rax, cs:qword_75D408\n0x00448220 | 8B 40 6C | mov     eax, [rax+6Ch]\n0x00448223 | 85 C0 | test    eax, eax\n0x00448225 | 78 11 | js      short loc_448238\n0x00448227 | 48 8B 05 DA 51 31 00 | mov     rax, cs:qword_75D408\n0x0044822E | 8B 40 6C | mov     eax, [rax+6Ch]\n0x00448231 | 89 C7 | mov     edi, eax\n0x00448233 | E8 F4 22 FC FF | call    sub_40A52C\n0x00448238 | B8 00 00 00 00 | mov     eax, 0\n0x0044823D | 48 8B 5D F8 | mov     rbx, [rbp+var_8]\n0x00448241 | C9 | leave\n0x00448242 | C3 | retn",
        "output": "",
        "source_code": "int wget_main(int argc UNUSED_PARAM, char **argv)\n{\n#if ENABLE_FEATURE_WGET_LONG_OPTIONS\n\tstatic const char wget_longopts[] ALIGN1 =\n\t\t/* name, has_arg, val */\n\t\t\"continue\\0\"         No_argument       \"c\"\n//FIXME: -s isn't --spider, it's --save-headers!\n\t\t\"spider\\0\"           No_argument       \"s\"\n\t\t\"quiet\\0\"            No_argument       \"q\"\n\t\t\"output-document\\0\"  Required_argument \"O\"\n\t\t\"directory-prefix\\0\" Required_argument \"P\"\n\t\t\"proxy\\0\"            Required_argument \"Y\"\n\t\t\"user-agent\\0\"       Required_argument \"U\"\n#if ENABLE_FEATURE_WGET_TIMEOUT\n\t\t\"timeout\\0\"          Required_argument \"T\"\n#endif\n\t\t/* Ignored: */\n\t\t// \"tries\\0\"            Required_argument \"t\"\n\t\t/* Ignored (we always use PASV): */\n\t\t\"passive-ftp\\0\"      No_argument       \"\\xff\"\n\t\t\"header\\0\"           Required_argument \"\\xfe\"\n\t\t\"post-data\\0\"        Required_argument \"\\xfd\"\n\t\t/* Ignored (we don't do ssl) */\n\t\t\"no-check-certificate\\0\" No_argument   \"\\xfc\"\n\t\t/* Ignored (we don't support caching) */\n\t\t\"no-cache\\0\"         No_argument       \"\\xfb\"\n\t\t;\n#endif\n\n#if ENABLE_FEATURE_WGET_LONG_OPTIONS\n\tllist_t *headers_llist = NULL;\n#endif\n\n\tINIT_G();\n\n\tIF_FEATURE_WGET_TIMEOUT(G.timeout_seconds = 900;)\n\tG.proxy_flag = \"on\";   /* use proxies if env vars are set */\n\tG.user_agent = \"Wget\"; /* \"User-Agent\" header field */\n\n#if ENABLE_FEATURE_WGET_LONG_OPTIONS\n\tapplet_long_options = wget_longopts;\n#endif\n\topt_complementary = \"-1\" IF_FEATURE_WGET_TIMEOUT(\":T+\") IF_FEATURE_WGET_LONG_OPTIONS(\":\\xfe::\");\n\tgetopt32(argv, \"csqO:P:Y:U:T:\" /*ignored:*/ \"t:\",\n\t\t&G.fname_out, &G.dir_prefix,\n\t\t&G.proxy_flag, &G.user_agent,\n\t\tIF_FEATURE_WGET_TIMEOUT(&G.timeout_seconds) IF_NOT_FEATURE_WGET_TIMEOUT(NULL),\n\t\tNULL /* -t RETRIES */\n\t\tIF_FEATURE_WGET_LONG_OPTIONS(, &headers_llist)\n\t\tIF_FEATURE_WGET_LONG_OPTIONS(, &G.post_data)\n\t);\n\targv += optind;\n\n#if ENABLE_FEATURE_WGET_LONG_OPTIONS\n\tif (headers_llist) {\n\t\tint size = 1;\n\t\tchar *cp;\n\t\tllist_t *ll = headers_llist;\n\t\twhile (ll) {\n\t\t\tsize += strlen(ll->data) + 2;\n\t\t\tll = ll->link;\n\t\t}\n\t\tG.extra_headers = cp = xmalloc(size);\n\t\twhile (headers_llist) {\n\t\t\tcp += sprintf(cp, \"%s\\r\\n\", (char*)llist_pop(&headers_llist));\n\t\t}\n\t}\n#endif\n\n\tG.output_fd = -1;\n\tG.o_flags = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL;\n\tif (G.fname_out) { /* -O FILE ? */\n\t\tif (LONE_DASH(G.fname_out)) { /* -O - ? */\n\t\t\tG.output_fd = 1;\n\t\t\toption_mask32 &= ~WGET_OPT_CONTINUE;\n\t\t}\n\t\t/* compat with wget: -O FILE can overwrite */\n\t\tG.o_flags = O_WRONLY | O_CREAT | O_TRUNC;\n\t}\n\n\twhile (*argv)\n\t\tdownload_one_url(*argv++);\n\n\tif (G.output_fd >= 0)\n\t\txclose(G.output_fd);\n\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_447FE0(__int64 a1, __int64 a2)\n{\n  const char *v2; // rsi\n  int v3; // eax\n  const char *v4; // rax\n  int v5; // eax\n  const char **v6; // rax\n  const char **v9; // [rsp+0h] [rbp-40h]\n  _QWORD *v10; // [rsp+10h] [rbp-30h] BYREF\n  _QWORD *i; // [rsp+18h] [rbp-28h]\n  char *s; // [rsp+20h] [rbp-20h]\n  int v13; // [rsp+2Ch] [rbp-14h]\n\n  v10 = 0LL;\n  qword_75D408 = sub_40A0E8(0x1080uLL, a2);\n  *((_DWORD *)qword_75D408 + 26) = 900;\n  *((_DWORD *)qword_75D408 + 26) = 900;\n  *((_QWORD *)qword_75D408 + 11) = \"on\";\n  *((_QWORD *)qword_75D408 + 12) = \"Wget\";\n  qword_75D448 = (__int64)\"continue\";\n  qword_75D440 = (__int64)&unk_52C154;\n  v2 = \"csqO:P:Y:U:T:t:\";\n  sub_4FA1EF(\n    a2,\n    (unsigned int)\"csqO:P:Y:U:T:t:\",\n    (_DWORD)qword_75D408 + 80,\n    (_DWORD)qword_75D408 + 56,\n    (_DWORD)qword_75D408 + 88,\n    (_DWORD)qword_75D408 + 96,\n    (char *)qword_75D408 + 104,\n    0LL,\n    &v10,\n    (char *)qword_75D408 + 64);\n  v9 = (const char **)(8LL * optind + a2);\n  if ( v10 )\n  {\n    v13 = 1;\n    for ( i = v10; i; i = (_QWORD *)*i )\n    {\n      v3 = strlen((const char *)i[1]);\n      v13 += v3 + 2;\n    }\n    s = (char *)sub_40A05F(v13, (__int64)\"csqO:P:Y:U:T:t:\");\n    *((_QWORD *)qword_75D408 + 9) = s;\n    while ( v10 )\n    {\n      v4 = (const char *)sub_409067(&v10);\n      v2 = \"%s\\r\\n\";\n      v5 = sprintf(s, \"%s\\r\\n\", v4);\n      s += v5;\n    }\n  }\n  *((_DWORD *)qword_75D408 + 27) = -1;\n  *((_DWORD *)qword_75D408 + 28) = 705;\n  if ( *((_QWORD *)qword_75D408 + 10) )\n  {\n    if ( **((_BYTE **)qword_75D408 + 10) == 45 && !*(_BYTE *)(*((_QWORD *)qword_75D408 + 10) + 1LL) )\n    {\n      *((_DWORD *)qword_75D408 + 27) = 1;\n      dword_75D450 &= ~1u;\n    }\n    *((_DWORD *)qword_75D408 + 28) = 577;\n  }\n  while ( *v9 )\n  {\n    v6 = v9++;\n    sub_447617(*v6);\n  }\n  if ( *((int *)qword_75D408 + 27) >= 0 )\n    sub_40A52C(*((_DWORD *)qword_75D408 + 27), (__int64)v2);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl wget_main(int argc, char **argv)\n{\n  int v2; // eax\n  const char *v3; // rax\n  int v4; // eax\n  const char **v5; // rax\n  char **argva; // [rsp+0h] [rbp-40h]\n  llist_t_0 *headers_llist; // [rsp+10h] [rbp-30h] BYREF\n  llist_t_0 *ll; // [rsp+18h] [rbp-28h]\n  char *cp; // [rsp+20h] [rbp-20h]\n  int size; // [rsp+2Ch] [rbp-14h]\n\n  headers_llist = 0LL;\n  ptr_to_globals = (globals *)xzalloc(0x1080uLL);\n  ptr_to_globals->tty_attrs.c_cflag = 900;\n  ptr_to_globals->tty_attrs.c_cflag = 900;\n  *(_QWORD *)&ptr_to_globals->speeds[9] = \"on\";\n  *(_QWORD *)&ptr_to_globals->tty_attrs.c_iflag = \"Wget\";\n  applet_long_options = wget_longopts_8281;\n  opt_complementary = (const char *)&unk_52C154;\n  getopt32(\n    argv,\n    \"csqO:P:Y:U:T:t:\",\n    &ptr_to_globals->speeds[7],\n    &ptr_to_globals->speeds[1],\n    &ptr_to_globals->speeds[9],\n    &ptr_to_globals->tty_attrs,\n    &ptr_to_globals->tty_attrs.c_cflag,\n    0LL,\n    &headers_llist,\n    &ptr_to_globals->speeds[3]);\n  argva = &argv[optind];\n  if ( headers_llist )\n  {\n    size = 1;\n    for ( ll = headers_llist; ll; ll = ll->link )\n    {\n      v2 = strlen(ll->data);\n      size += v2 + 2;\n    }\n    cp = (char *)xmalloc(size);\n    *(_QWORD *)&ptr_to_globals->speeds[5] = cp;\n    while ( headers_llist )\n    {\n      v3 = (const char *)llist_pop(&headers_llist);\n      v4 = sprintf(cp, \"%s\\r\\n\", v3);\n      cp += v4;\n    }\n  }\n  ptr_to_globals->tty_attrs.c_lflag = -1;\n  *(_DWORD *)&ptr_to_globals->tty_attrs.c_line = 705;\n  if ( *(_QWORD *)&ptr_to_globals->speeds[7] )\n  {\n    if ( **(_BYTE **)&ptr_to_globals->speeds[7] == 45 && !*(_BYTE *)(*(_QWORD *)&ptr_to_globals->speeds[7] + 1LL) )\n    {\n      ptr_to_globals->tty_attrs.c_lflag = 1;\n      option_mask32 &= ~1u;\n    }\n    *(_DWORD *)&ptr_to_globals->tty_attrs.c_line = 577;\n  }\n  while ( *argva )\n  {\n    v5 = (const char **)argva++;\n    download_one_url(*v5);\n  }\n  if ( (ptr_to_globals->tty_attrs.c_lflag & 0x80000000) == 0 )\n    xclose(ptr_to_globals->tty_attrs.c_lflag);\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.002349264919757843,
        "similarity_score_baseline_stripped": 0.47754380106925964,
        "similarity_score_baseline_debug": 0.7149375081062317
    },
    {
        "func_name": "change_identity",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F6569 | 55 | push    rbp\n0x004F656A | 48 89 E5 | mov     rbp, rsp\n0x004F656D | 48 83 EC 10 | sub     rsp, 10h\n0x004F6571 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004F6575 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F6579 | 8B 50 14 | mov     edx, [rax+14h]\n0x004F657C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F6580 | 48 8B 00 | mov     rax, [rax]\n0x004F6583 | 89 D6 | mov     esi, edx\n0x004F6585 | 48 89 C7 | mov     rdi, rax\n0x004F6588 | E8 5F 63 F1 FF | call    sub_40C8EC\n0x004F658D | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x004F6590 | 75 0F | jnz     short loc_4F65A1\n0x004F6592 | BF 1F 72 53 00 | mov     edi, offset aCanTSetGroups; \"can't set groups\"\n0x004F6597 | B8 00 00 00 00 | mov     eax, 0\n0x004F659C | E8 01 2D F1 FF | call    sub_4092A2\n0x004F65A1 | E8 42 61 F1 FF | call    sub_40C6E8\n0x004F65A6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F65AA | 8B 40 14 | mov     eax, [rax+14h]\n0x004F65AD | 89 C7 | mov     edi, eax\n0x004F65AF | E8 9D 42 F1 FF | call    sub_40A851\n0x004F65B4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F65B8 | 8B 40 10 | mov     eax, [rax+10h]\n0x004F65BB | 89 C7 | mov     edi, eax\n0x004F65BD | E8 BA 42 F1 FF | call    sub_40A87C\n0x004F65C2 | 90 | nop\n0x004F65C3 | C9 | leave\n0x004F65C4 | C3 | retn",
        "output": "",
        "source_code": "void FAST_FUNC change_identity(const struct passwd *pw)\n{\n\tif (initgroups(pw->pw_name, pw->pw_gid) == -1)\n\t\tbb_perror_msg_and_die(\"can't set groups\");\n\tendgrent(); /* helps to close a fd used internally by libc */\n\txsetgid(pw->pw_gid);\n\txsetuid(pw->pw_uid);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "int __fastcall sub_4F6569(__int64 a1)\n{\n  __int64 v1; // rsi\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n\n  v1 = *(unsigned int *)(a1 + 20);\n  if ( (unsigned int)sub_40C8EC(*(const char **)a1, v1) == -1 )\n    sub_4092A2((__int64)\"can't set groups\", v1, v2, v3, v4, v5);\n  sub_40C6E8();\n  sub_40A851(*(_DWORD *)(a1 + 20), v1);\n  return sub_40A87C(*(_DWORD *)(a1 + 16), v1);\n}\n",
        "baseline_code_debug": "void __cdecl change_identity(const passwd *pw)\n{\n  if ( bb_internal_initgroups(pw->pw_name, pw->pw_gid) == -1 )\n    bb_perror_msg_and_die(\"can't set groups\");\n  bb_internal_endgrent();\n  xsetgid(pw->pw_gid);\n  xsetuid(pw->pw_uid);\n}\n",
        "similarity_score_unixcoder": 0.05433861166238785,
        "similarity_score_baseline_stripped": 0.5057234168052673,
        "similarity_score_baseline_debug": 0.9373175501823425
    },
    {
        "func_name": "collect_mem",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00460936 | 55 | push    rbp\n0x00460937 | 48 89 E5 | mov     rbp, rsp\n0x0046093A | 48 83 EC 40 | sub     rsp, 40h\n0x0046093E | 48 89 7D C8 | mov     [rbp+var_38], rdi\n0x00460942 | 48 C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0\n0x0046094A | 48 C7 45 F0 00 00 00 00 | mov     [rbp+var_10], 0\n0x00460952 | 48 C7 45 E8 00 00 00 00 | mov     [rbp+var_18], 0\n0x0046095A | 48 C7 45 E0 00 00 00 00 | mov     [rbp+var_20], 0\n0x00460962 | 48 C7 45 D8 00 00 00 00 | mov     [rbp+var_28], 0\n0x0046096A | 48 8B 05 97 CA 2F 00 | mov     rax, cs:qword_75D408\n0x00460971 | 48 83 C0 60 | add     rax, 60h ; '`'\n0x00460975 | 48 89 C7 | mov     rdi, rax\n0x00460978 | E8 FC EE FF FF | call    sub_45F879\n0x0046097D | 48 89 C7 | mov     rdi, rax\n0x00460980 | 48 8D 45 F8 | lea     rax, [rbp+var_8]\n0x00460984 | B9 01 00 00 00 | mov     ecx, 1\n0x00460989 | 48 89 C2 | mov     rdx, rax\n0x0046098C | BE 1F BE 51 00 | mov     esi, offset aMemtotal; \"MemTotal:\"\n0x00460991 | B8 00 00 00 00 | mov     eax, 0\n0x00460996 | E8 24 F1 FF FF | call    sub_45FABF\n0x0046099B | 85 C0 | test    eax, eax\n0x0046099D | 74 0F | jz      short loc_4609AE\n0x0046099F | BF 04 00 00 00 | mov     edi, 4\n0x004609A4 | E8 C3 ED FF FF | call    sub_45F76C\n0x004609A9 | E9 2F 01 00 00 | jmp     locret_460ADD\n0x004609AE | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x004609B2 | 0F B6 40 18 | movzx   eax, byte ptr [rax+18h]\n0x004609B6 | 3C 74 | cmp     al, 74h ; 't'\n0x004609B8 | 75 15 | jnz     short loc_4609CF\n0x004609BA | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004609BE | 48 C1 E0 0A | shl     rax, 0Ah\n0x004609C2 | 48 89 C7 | mov     rdi, rax\n0x004609C5 | E8 44 F4 FF FF | call    sub_45FE0E\n0x004609CA | E9 0E 01 00 00 | jmp     locret_460ADD\n0x004609CF | 48 8B 05 32 CA 2F 00 | mov     rax, cs:qword_75D408\n0x004609D6 | 48 8B 40 60 | mov     rax, [rax+60h]\n0x004609DA | 48 8D 55 F0 | lea     rdx, [rbp+var_10]\n0x004609DE | B9 01 00 00 00 | mov     ecx, 1\n0x004609E3 | BE 29 BE 51 00 | mov     esi, offset aMemfree; \"MemFree:\"\n0x004609E8 | 48 89 C7 | mov     rdi, rax\n0x004609EB | B8 00 00 00 00 | mov     eax, 0\n0x004609F0 | E8 CA F0 FF FF | call    sub_45FABF\n0x004609F5 | 85 C0 | test    eax, eax\n0x004609F7 | 75 7E | jnz     short loc_460A77\n0x004609F9 | 48 8B 05 08 CA 2F 00 | mov     rax, cs:qword_75D408\n0x00460A00 | 48 8B 40 60 | mov     rax, [rax+60h]\n0x00460A04 | 48 8D 55 E8 | lea     rdx, [rbp+var_18]\n0x00460A08 | B9 01 00 00 00 | mov     ecx, 1\n0x00460A0D | BE 32 BE 51 00 | mov     esi, offset aBuffers_1; \"Buffers:\"\n0x00460A12 | 48 89 C7 | mov     rdi, rax\n0x00460A15 | B8 00 00 00 00 | mov     eax, 0\n0x00460A1A | E8 A0 F0 FF FF | call    sub_45FABF\n0x00460A1F | 85 C0 | test    eax, eax\n0x00460A21 | 75 54 | jnz     short loc_460A77\n0x00460A23 | 48 8B 05 DE C9 2F 00 | mov     rax, cs:qword_75D408\n0x00460A2A | 48 8B 40 60 | mov     rax, [rax+60h]\n0x00460A2E | 48 8D 55 E0 | lea     rdx, [rbp+var_20]\n0x00460A32 | B9 01 00 00 00 | mov     ecx, 1\n0x00460A37 | BE 3B BE 51 00 | mov     esi, offset aCached; \"Cached:\"\n0x00460A3C | 48 89 C7 | mov     rdi, rax\n0x00460A3F | B8 00 00 00 00 | mov     eax, 0\n0x00460A44 | E8 76 F0 FF FF | call    sub_45FABF\n0x00460A49 | 85 C0 | test    eax, eax\n0x00460A4B | 75 2A | jnz     short loc_460A77\n0x00460A4D | 48 8B 05 B4 C9 2F 00 | mov     rax, cs:qword_75D408\n0x00460A54 | 48 8B 40 60 | mov     rax, [rax+60h]\n0x00460A58 | 48 8D 55 D8 | lea     rdx, [rbp+var_28]\n0x00460A5C | B9 01 00 00 00 | mov     ecx, 1\n0x00460A61 | BE 43 BE 51 00 | mov     esi, offset aSlab; \"Slab:\"\n0x00460A66 | 48 89 C7 | mov     rdi, rax\n0x00460A69 | B8 00 00 00 00 | mov     eax, 0\n0x00460A6E | E8 4C F0 FF FF | call    sub_45FABF\n0x00460A73 | 85 C0 | test    eax, eax\n0x00460A75 | 74 0C | jz      short loc_460A83\n0x00460A77 | BF 04 00 00 00 | mov     edi, 4\n0x00460A7C | E8 EB EC FF FF | call    sub_45F76C\n0x00460A81 | EB 5A | jmp     short locret_460ADD\n0x00460A83 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x00460A87 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00460A8B | 48 01 C2 | add     rdx, rax\n0x00460A8E | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00460A92 | 48 01 C2 | add     rdx, rax\n0x00460A95 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00460A99 | 48 01 D0 | add     rax, rdx\n0x00460A9C | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x00460AA0 | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x00460AA4 | 0F B6 40 18 | movzx   eax, byte ptr [rax+18h]\n0x00460AA8 | 0F BE C0 | movsx   eax, al\n0x00460AAB | 83 F8 66 | cmp     eax, 66h ; 'f'\n0x00460AAE | 75 12 | jnz     short loc_460AC2\n0x00460AB0 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00460AB4 | 48 C1 E0 0A | shl     rax, 0Ah\n0x00460AB8 | 48 89 C7 | mov     rdi, rax\n0x00460ABB | E8 4E F3 FF FF | call    sub_45FE0E\n0x00460AC0 | EB 1B | jmp     short locret_460ADD\n0x00460AC2 | 48 8B 55 F8 | mov     rdx, [rbp+var_8]\n0x00460AC6 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00460ACA | 48 29 C2 | sub     rdx, rax\n0x00460ACD | 48 89 D0 | mov     rax, rdx\n0x00460AD0 | 48 C1 E0 0A | shl     rax, 0Ah\n0x00460AD4 | 48 89 C7 | mov     rdi, rax\n0x00460AD7 | E8 32 F3 FF FF | call    sub_45FE0E\n0x00460ADC | 90 | nop\n0x00460ADD | C9 | leave\n0x00460ADE | C3 | retn",
        "output": "",
        "source_code": "4096 kB\nstatic void FAST_FUNC collect_mem(mem_stat *s)\n{\n\tullong m_total = 0;\n\tullong m_free = 0;\n\tullong m_bufs = 0;\n\tullong m_cached = 0;\n\tullong m_slab = 0;\n\n\tif (rdval(get_file(&proc_meminfo), \"MemTotal:\", &m_total, 1)) {\n\t\tput_question_marks(4);\n\t\treturn;\n\t}\n\tif (s->opt == 't') {\n\t\tscale(m_total << 10);\n\t\treturn;\n\t}\n\n\tif (rdval(proc_meminfo.file, \"MemFree:\", &m_free  , 1)\n\t || rdval(proc_meminfo.file, \"Buffers:\", &m_bufs  , 1)\n\t || rdval(proc_meminfo.file, \"Cached:\",  &m_cached, 1)\n\t || rdval(proc_meminfo.file, \"Slab:\",    &m_slab  , 1)\n\t) {\n\t\tput_question_marks(4);\n\t\treturn;\n\t}\n\n\tm_free += m_bufs + m_cached + m_slab;\n\tswitch (s->opt) {\n\tcase 'f':\n\t\tscale(m_free << 10); break;\n\tdefault:\n\t\tscale((m_total - m_free) << 10); break;\n\t}\n}",
        "parsed_output": "",
        "baseline_code_stripped": "void *__fastcall sub_460936(__int64 a1)\n{\n  const char *v1; // rax\n  __int64 v2; // r8\n  __int64 v3; // r9\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v7; // r8\n  __int64 v8; // r9\n  __int64 v9; // r8\n  __int64 v10; // r9\n  __int64 v11; // r8\n  __int64 v12; // r9\n  unsigned __int64 v13; // [rsp+18h] [rbp-28h] BYREF\n  unsigned __int64 v14; // [rsp+20h] [rbp-20h] BYREF\n  unsigned __int64 v15; // [rsp+28h] [rbp-18h] BYREF\n  unsigned __int64 v16; // [rsp+30h] [rbp-10h] BYREF\n  unsigned __int64 v17; // [rsp+38h] [rbp-8h] BYREF\n\n  v17 = 0LL;\n  v16 = 0LL;\n  v15 = 0LL;\n  v14 = 0LL;\n  v13 = 0LL;\n  v1 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 96);\n  if ( (unsigned int)sub_45FABF(v1, \"MemTotal:\", &v17, 1LL, v2, v3) )\n    return (void *)sub_45F76C(4u);\n  if ( *(_BYTE *)(a1 + 24) == 116 )\n    return sub_45FE0E(v17 << 10);\n  if ( (unsigned int)sub_45FABF(*((const char **)qword_75D408 + 12), \"MemFree:\", &v16, 1LL, v4, v5)\n    || (unsigned int)sub_45FABF(*((const char **)qword_75D408 + 12), \"Buffers:\", &v15, 1LL, v7, v8)\n    || (unsigned int)sub_45FABF(*((const char **)qword_75D408 + 12), \"Cached:\", &v14, 1LL, v9, v10)\n    || (unsigned int)sub_45FABF(*((const char **)qword_75D408 + 12), \"Slab:\", &v13, 1LL, v11, v12) )\n  {\n    return (void *)sub_45F76C(4u);\n  }\n  v16 += v13 + v14 + v15;\n  if ( *(_BYTE *)(a1 + 24) == 102 )\n    return sub_45FE0E(v16 << 10);\n  else\n    return sub_45FE0E((v17 - v16) << 10);\n}\n",
        "baseline_code_debug": "void __cdecl collect_mem(mem_stat_0 *s)\n{\n  const char *file; // rax\n  ullong m_slab; // [rsp+18h] [rbp-28h] BYREF\n  ullong m_cached; // [rsp+20h] [rbp-20h] BYREF\n  ullong m_bufs; // [rsp+28h] [rbp-18h] BYREF\n  ullong m_free; // [rsp+30h] [rbp-10h] BYREF\n  ullong m_total; // [rsp+38h] [rbp-8h] BYREF\n\n  m_total = 0LL;\n  m_free = 0LL;\n  m_bufs = 0LL;\n  m_cached = 0LL;\n  m_slab = 0LL;\n  file = get_file((proc_file_0 *)&ptr_to_globals->tty_attrs);\n  if ( rdval(file, \"MemTotal:\", &m_total, 1LL) )\n  {\n    put_question_marks(4);\n  }\n  else if ( s->opt == 116 )\n  {\n    scale_0(m_total << 10);\n  }\n  else if ( rdval(*(const char **)&ptr_to_globals->tty_attrs.c_iflag, \"MemFree:\", &m_free, 1LL)\n         || rdval(*(const char **)&ptr_to_globals->tty_attrs.c_iflag, \"Buffers:\", &m_bufs, 1LL)\n         || rdval(*(const char **)&ptr_to_globals->tty_attrs.c_iflag, \"Cached:\", &m_cached, 1LL)\n         || rdval(*(const char **)&ptr_to_globals->tty_attrs.c_iflag, \"Slab:\", &m_slab, 1LL) )\n  {\n    put_question_marks(4);\n  }\n  else\n  {\n    m_free += m_slab + m_cached + m_bufs;\n    if ( s->opt == 102 )\n      scale_0(m_free << 10);\n    else\n      scale_0((m_total - m_free) << 10);\n  }\n}\n",
        "similarity_score_unixcoder": 0.04510555788874626,
        "similarity_score_baseline_stripped": 0.44682246446609497,
        "similarity_score_baseline_debug": 0.8510918617248535
    },
    {
        "func_name": "archivejoin",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00464F04 | 55 | push    rbp\n0x00464F05 | 48 89 E5 | mov     rbp, rsp\n0x00464F08 | 48 83 EC 40 | sub     rsp, 40h\n0x00464F0C | 48 89 7D C8 | mov     [rbp+var_38], rdi\n0x00464F10 | 48 89 75 C0 | mov     [rbp+var_40], rsi\n0x00464F14 | 48 8B 4D C0 | mov     rcx, [rbp+var_40]\n0x00464F18 | 48 8B 55 C8 | mov     rdx, [rbp+var_38]\n0x00464F1C | 48 8D 45 D0 | lea     rax, [rbp+s]\n0x00464F20 | BE 8D 62 53 00 | mov     esi, offset aSS_26; \"%s/%s\"\n0x00464F25 | 48 89 C7 | mov     rdi, rax; s\n0x00464F28 | B8 00 00 00 00 | mov     eax, 0\n0x00464F2D | E8 4E 2B FA FF | call    _sprintf\n0x00464F32 | 48 8D 45 D0 | lea     rax, [rbp+s]\n0x00464F36 | 48 89 C7 | mov     rdi, rax\n0x00464F39 | E8 A1 FE FF FF | call    sub_464DDF\n0x00464F3E | 90 | nop\n0x00464F3F | C9 | leave\n0x00464F40 | C3 | retn",
        "output": "",
        "source_code": "static void archivejoin(const char *sub, const char *name)\n{\n\tchar path[sizeof(long long)*3 + sizeof(\"/cmdline\")];\n\tsprintf(path, \"%s/%s\", sub, name);\n\tarchivefile(path);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_464F04(const char *a1, const char *a2)\n{\n  char s[48]; // [rsp+10h] [rbp-30h] BYREF\n\n  sprintf(s, \"%s/%s\", a1, a2);\n  return sub_464DDF(s);\n}\n",
        "baseline_code_debug": "void __cdecl archivejoin(const char *sub, const char *name)\n{\n  char path[33]; // [rsp+10h] [rbp-30h] BYREF\n\n  sprintf(path, \"%s/%s\", sub, name);\n  archivefile(path);\n}\n",
        "similarity_score_unixcoder": -0.017793424427509308,
        "similarity_score_baseline_stripped": 0.42278406023979187,
        "similarity_score_baseline_debug": 0.7182942032814026
    },
    {
        "func_name": "start_new_cmd_q",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004EEE0F | 55 | push    rbp\n0x004EEE10 | 48 89 E5 | mov     rbp, rsp\n0x004EEE13 | 53 | push    rbx\n0x004EEE14 | 48 83 EC 18 | sub     rsp, 18h\n0x004EEE18 | 89 F8 | mov     eax, edi\n0x004EEE1A | 88 45 EC | mov     [rbp+var_14], al\n0x004EEE1D | 48 8B 05 E4 E5 26 00 | mov     rax, cs:qword_75D408\n0x004EEE24 | 8B 40 2C | mov     eax, [rax+2Ch]\n0x004EEE27 | 85 C0 | test    eax, eax\n0x004EEE29 | 7E 3B | jle     short loc_4EEE66\n0x004EEE2B | 0F BE 55 EC | movsx   edx, [rbp+var_14]\n0x004EEE2F | 48 8B 05 D2 E5 26 00 | mov     rax, cs:qword_75D408\n0x004EEE36 | 8B 40 2C | mov     eax, [rax+2Ch]\n0x004EEE39 | 48 8B 0D C8 E5 26 00 | mov     rcx, cs:qword_75D408\n0x004EEE40 | 48 8D B9 B8 04 00 00 | lea     rdi, [rcx+4B8h]; s\n0x004EEE47 | 48 8B 1D BA E5 26 00 | mov     rbx, cs:qword_75D408\n0x004EEE4E | 89 D1 | mov     ecx, edx\n0x004EEE50 | 89 C2 | mov     edx, eax\n0x004EEE52 | BE 7C 76 52 00 | mov     esi, offset aDC; \"%d%c\"\n0x004EEE57 | B8 00 00 00 00 | mov     eax, 0\n0x004EEE5C | E8 1F 8C F1 FF | call    _sprintf\n0x004EEE61 | 89 43 78 | mov     [rbx+78h], eax\n0x004EEE64 | EB 1F | jmp     short loc_4EEE85\n0x004EEE66 | 48 8B 05 9B E5 26 00 | mov     rax, cs:qword_75D408\n0x004EEE6D | 0F B6 55 EC | movzx   edx, [rbp+var_14]\n0x004EEE71 | 88 90 B8 04 00 00 | mov     [rax+4B8h], dl\n0x004EEE77 | 48 8B 05 8A E5 26 00 | mov     rax, cs:qword_75D408\n0x004EEE7E | C7 40 78 01 00 00 00 | mov     dword ptr [rax+78h], 1\n0x004EEE85 | 48 8B 05 7C E5 26 00 | mov     rax, cs:qword_75D408\n0x004EEE8C | C6 40 76 01 | mov     byte ptr [rax+76h], 1\n0x004EEE90 | 90 | nop\n0x004EEE91 | 48 83 C4 18 | add     rsp, 18h\n0x004EEE95 | 5B | pop     rbx\n0x004EEE96 | 5D | pop     rbp\n0x004EEE97 | C3 | retn",
        "output": "",
        "source_code": "if ENABLE_FEATURE_VI_DOT_CMD\nstatic void start_new_cmd_q(char c)\n{\n\t// get buffer for new cmd\n\t// if there is a current cmd count put it in the buffer first\n\tif (cmdcnt > 0) {\n\t\tlmc_len = sprintf(last_modifying_cmd, \"%d%c\", cmdcnt, c);\n\t} else { // just save char c onto queue\n\t\tlast_modifying_cmd[0] = c;\n\t\tlmc_len = 1;\n\t}\n\tadding2q = 1;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "void *__fastcall sub_4EEE0F(char a1)\n{\n  _DWORD *v1; // rbx\n  void *result; // rax\n\n  if ( *((int *)qword_75D408 + 11) <= 0 )\n  {\n    *((_BYTE *)qword_75D408 + 1208) = a1;\n    *((_DWORD *)qword_75D408 + 30) = 1;\n  }\n  else\n  {\n    v1 = qword_75D408;\n    v1[30] = sprintf((char *)qword_75D408 + 1208, \"%d%c\", *((unsigned int *)qword_75D408 + 11), (unsigned int)a1);\n  }\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 118) = 1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl start_new_cmd_q(char c)\n{\n  globals *v1; // rbx\n\n  if ( SHIDWORD(ptr_to_globals->issue) <= 0 )\n  {\n    LOBYTE(ptr_to_globals[4].speeds[1]) = c;\n    *(_DWORD *)&ptr_to_globals->tty_attrs.c_cc[7] = 1;\n  }\n  else\n  {\n    v1 = ptr_to_globals;\n    *(_DWORD *)&v1->tty_attrs.c_cc[7] = sprintf(\n                                          (char *)&ptr_to_globals[4].speeds[1],\n                                          \"%d%c\",\n                                          HIDWORD(ptr_to_globals->issue),\n                                          (unsigned int)c);\n  }\n  ptr_to_globals->tty_attrs.c_cc[5] = 1;\n}\n",
        "similarity_score_unixcoder": 0.029295802116394043,
        "similarity_score_baseline_stripped": 0.5308853387832642,
        "similarity_score_baseline_debug": 0.6258626580238342
    },
    {
        "func_name": "reset_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C464E | 55 | push    rbp\n0x004C464F | 48 89 E5 | mov     rbp, rsp\n0x004C4652 | 48 83 EC 10 | sub     rsp, 10h\n0x004C4656 | 89 7D FC | mov     [rbp+var_4], edi\n0x004C4659 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004C465D | BF 01 00 00 00 | mov     edi, 1; fd\n0x004C4662 | E8 F9 21 F4 FF | call    _isatty\n0x004C4667 | 85 C0 | test    eax, eax\n0x004C4669 | 74 20 | jz      short loc_4C468B\n0x004C466B | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C4670 | B8 00 00 00 00 | mov     eax, 0\n0x004C4675 | E8 56 25 F4 FF | call    _printf\n0x004C467A | BE 50 6D 52 00 | mov     esi, offset off_526D50; \"stty\"\n0x004C467F | BF 02 00 00 00 | mov     edi, 2\n0x004C4684 | E8 7D FE 00 00 | call    sub_4D4506\n0x004C4689 | EB 05 | jmp     short locret_4C4690\n0x004C468B | B8 00 00 00 00 | mov     eax, 0\n0x004C4690 | C9 | leave\n0x004C4691 | C3 | retn",
        "output": "",
        "source_code": "int reset_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tstatic const char *const args[] = {\n\t\t\"stty\", \"sane\", NULL\n\t};\n\n\t/* no options, no getopt */\n\n\tif (/*isatty(STDIN_FILENO) &&*/ isatty(STDOUT_FILENO)) {\n\t\t/* See 'man 4 console_codes' for details:\n\t\t * \"ESC c\"        -- Reset\n\t\t * \"ESC ( B\"      -- Select G0 Character Set (B = US)\n\t\t * \"ESC [ 0 m\"    -- Reset all display attributes\n\t\t * \"ESC [ J\"      -- Erase to the end of screen\n\t\t * \"ESC [ ? 25 h\" -- Make cursor visible\n\t\t */\n\t\tprintf(ESC\"c\" ESC\"(B\" ESC\"[0m\" ESC\"[J\" ESC\"[?25h\");\n\t\t/* http://bugs.busybox.net/view.php?id=1414:\n\t\t * people want it to reset echo etc: */\n#if ENABLE_STTY\n\t\treturn stty_main(2, (char**)args);\n#else\n\t\texecvp(\"stty\", (char**)args);\n#endif\n\t}\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 sub_4C464E()\n{\n  if ( !isatty(1) )\n    return 0LL;\n  printf(\"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\");\n  return sub_4D4506(2LL, off_526D50);\n}\n",
        "baseline_code_debug": "int __cdecl reset_main(int argc, char **argv)\n{\n  if ( !isatty(1) )\n    return 0;\n  printf(\"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\");\n  return stty_main(2, (char **)args_8111);\n}\n",
        "similarity_score_unixcoder": -0.058293234556913376,
        "similarity_score_baseline_stripped": 0.5364027619361877,
        "similarity_score_baseline_debug": 0.7071895599365234
    },
    {
        "func_name": "strstr_pattern",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00484A4F | 55 | push    rbp\n0x00484A50 | 48 89 E5 | mov     rbp, rsp\n0x00484A53 | 48 83 EC 30 | sub     rsp, 30h\n0x00484A57 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00484A5B | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00484A5F | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x00484A63 | 48 8B 4D E0 | mov     rcx, [rbp+var_20]\n0x00484A67 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00484A6B | BA 06 00 00 00 | mov     edx, 6\n0x00484A70 | 48 89 CE | mov     rsi, rcx\n0x00484A73 | 48 89 C7 | mov     rdi, rax\n0x00484A76 | E8 AC 5E 00 00 | call    sub_48A927\n0x00484A7B | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00484A7F | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00484A84 | 74 16 | jz      short loc_484A9C\n0x00484A86 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00484A8A | 48 2B 45 E8 | sub     rax, [rbp+var_18]\n0x00484A8E | 89 C2 | mov     edx, eax\n0x00484A90 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00484A94 | 89 10 | mov     [rax], edx\n0x00484A96 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00484A9A | EB 2B | jmp     short locret_484AC7\n0x00484A9C | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00484AA0 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00484AA3 | 84 C0 | test    al, al\n0x00484AA5 | 75 07 | jnz     short loc_484AAE\n0x00484AA7 | B8 00 00 00 00 | mov     eax, 0\n0x00484AAC | EB 19 | jmp     short locret_484AC7\n0x00484AAE | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00484AB2 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00484AB5 | 3C 2A | cmp     al, 2Ah ; '*'\n0x00484AB7 | 75 07 | jnz     short loc_484AC0\n0x00484AB9 | B8 00 00 00 00 | mov     eax, 0\n0x00484ABE | EB 07 | jmp     short locret_484AC7\n0x00484AC0 | 48 83 45 E8 01 | add     [rbp+var_18], 1\n0x00484AC5 | EB 9C | jmp     short loc_484A63\n0x00484AC7 | C9 | leave\n0x00484AC8 | C3 | retn",
        "output": "",
        "source_code": "static char *strstr_pattern(char *val, const char *pattern, int *size)\n{\n\twhile (1) {\n\t\tchar *end = scan_and_match(val, pattern, SCAN_MOVE_FROM_RIGHT + SCAN_MATCH_LEFT_HALF);\n\t\tdebug_printf_varexp(\"val:'%s' pattern:'%s' end:'%s'\\n\", val, pattern, end);\n\t\tif (end) {\n\t\t\t*size = end - val;\n\t\t\treturn val;\n\t\t}\n\t\tif (*val == '\\0')\n\t\t\treturn NULL;\n\t\t/* Optimization: if \"*pat\" did not match the start of \"string\",\n\t\t * we know that \"tring\", \"ring\" etc will not match too:\n\t\t */\n\t\tif (pattern[0] == '*')\n\t\t\treturn NULL;\n\t\tval++;\n\t}\n}",
        "parsed_output": "",
        "baseline_code_stripped": "_BYTE *__fastcall sub_484A4F(_BYTE *a1, _BYTE *a2, _DWORD *a3)\n{\n  __int64 v6; // [rsp+28h] [rbp-8h]\n\n  while ( 1 )\n  {\n    v6 = sub_48A927(a1, a2, 6LL);\n    if ( v6 )\n    {\n      *a3 = v6 - (_DWORD)a1;\n      return a1;\n    }\n    if ( !*a1 )\n      return 0LL;\n    if ( *a2 == 42 )\n      break;\n    ++a1;\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "char *__cdecl strstr_pattern(char *val, const char *pattern, int *size)\n{\n  char *end; // [rsp+28h] [rbp-8h]\n\n  while ( 1 )\n  {\n    end = scan_and_match(val, pattern, 6u);\n    if ( end )\n    {\n      *size = (_DWORD)end - (_DWORD)val;\n      return val;\n    }\n    if ( !*val )\n      return 0LL;\n    if ( *pattern == 42 )\n      break;\n    ++val;\n  }\n  return 0LL;\n}\n",
        "similarity_score_unixcoder": 0.03187268227338791,
        "similarity_score_baseline_stripped": 0.5384126305580139,
        "similarity_score_baseline_debug": 0.8483339548110962
    },
    {
        "func_name": "sendping6",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043E38D | 55 | push    rbp\n0x0043E38E | 48 89 E5 | mov     rbp, rsp\n0x0043E391 | 48 83 EC 20 | sub     rsp, 20h\n0x0043E395 | 89 7D EC | mov     [rbp+var_14], edi\n0x0043E398 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E39D | 48 8B 40 70 | mov     rax, [rax+70h]\n0x0043E3A1 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0043E3A5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E3A9 | C6 00 80 | mov     byte ptr [rax], 80h\n0x0043E3AC | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E3B1 | 48 8B 40 28 | mov     rax, [rax+28h]\n0x0043E3B5 | 0F B7 C0 | movzx   eax, ax\n0x0043E3B8 | 89 C7 | mov     edi, eax; hostshort\n0x0043E3BA | E8 B1 87 FC FF | call    _htons\n0x0043E3BF | 89 C2 | mov     edx, eax\n0x0043E3C1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E3C5 | 66 89 50 06 | mov     [rax+6], dx\n0x0043E3C9 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E3CE | 0F B7 50 40 | movzx   edx, word ptr [rax+40h]\n0x0043E3D2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E3D6 | 66 89 50 04 | mov     [rax+4], dx\n0x0043E3DA | E8 88 D8 FC FF | call    sub_40BC67\n0x0043E3DF | 48 89 C2 | mov     rdx, rax\n0x0043E3E2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E3E6 | 48 83 C0 08 | add     rax, 8\n0x0043E3EA | 89 10 | mov     [rax], edx\n0x0043E3EC | BE 08 00 00 00 | mov     esi, 8\n0x0043E3F1 | BF 8D E3 43 00 | mov     edi, offset sub_43E38D\n0x0043E3F6 | E8 39 FD FF FF | call    sub_43E134\n0x0043E3FB | 90 | nop\n0x0043E3FC | C9 | leave\n0x0043E3FD | C3 | retn",
        "output": "",
        "source_code": "if ENABLE_PING6\nstatic void sendping6(int junk UNUSED_PARAM)\n{\n\tstruct icmp6_hdr *pkt = G.snd_packet;\n\n\t//memset(pkt, 0, datalen + sizeof(struct icmp6_hdr) + 4);\n\tpkt->icmp6_type = ICMP6_ECHO_REQUEST;\n\t/*pkt->icmp6_code = 0;*/\n\t/*pkt->icmp6_cksum = 0;*/\n\tpkt->icmp6_seq = htons(ntransmitted); /* don't ++ here, it can be a macro */\n\tpkt->icmp6_id = myid;\n\n\t/*if (datalen >= 4)*/\n\t\t*(uint32_t*)(&pkt->icmp6_data8[4]) = monotonic_us();\n\n\t//TODO? pkt->icmp_cksum = inet_cksum(...);\n\n\tsendping_tail(sendping6, sizeof(struct icmp6_hdr));\n}",
        "parsed_output": "",
        "baseline_code_stripped": "unsigned int sub_43E38D()\n{\n  __int64 v1; // [rsp+18h] [rbp-8h]\n\n  v1 = *((_QWORD *)&dest + 14);\n  *(_BYTE *)v1 = 0x80;\n  *(_WORD *)(v1 + 6) = htons(*(_QWORD *)&dest.c_cc[23]);\n  *(_WORD *)(v1 + 4) = *((_WORD *)&dest + 32);\n  *(_DWORD *)(v1 + 8) = sub_40BC67();\n  return sub_43E134((void (*)(int))sub_43E38D, 8);\n}\n",
        "baseline_code_debug": "void __cdecl sendping6(int junk)\n{\n  icmp6_hdr *pkt; // [rsp+18h] [rbp-8h]\n\n  pkt = (icmp6_hdr *)*((_QWORD *)&bb_common_bufsiz1 + 14);\n  pkt->icmp6_type = 0x80;\n  pkt->icmp6_dataun.icmp6_un_data16[1] = htons(*(_QWORD *)&bb_common_bufsiz1.c_cc[23]);\n  pkt->icmp6_dataun.icmp6_un_data16[0] = *((_WORD *)&bb_common_bufsiz1 + 32);\n  *(_DWORD *)&pkt[1].icmp6_type = monotonic_us();\n  sendping_tail((void (*)(int))sendping6, 8);\n}\n",
        "similarity_score_unixcoder": 0.11297260224819183,
        "similarity_score_baseline_stripped": 0.5067846179008484,
        "similarity_score_baseline_debug": 0.8522728681564331
    },
    {
        "func_name": "casematch",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00476B22 | 55 | push    rbp\n0x00476B23 | 48 89 E5 | mov     rbp, rsp\n0x00476B26 | 48 83 EC 40 | sub     rsp, 40h\n0x00476B2A | 48 89 7D C8 | mov     [rbp+var_38], rdi\n0x00476B2E | 48 89 75 C0 | mov     [rbp+var_40], rsi\n0x00476B32 | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00476B36 | 48 89 C7 | mov     rdi, rax\n0x00476B39 | E8 63 7D FF FF | call    sub_46E8A1\n0x00476B3E | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x00476B42 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x00476B46 | 48 89 05 83 44 2E 00 | mov     cs:qword_75AFD0, rax\n0x00476B4D | 48 8B 05 D4 68 2E 00 | mov     rax, cs:qword_75D428\n0x00476B54 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x00476B58 | 48 89 05 69 44 2E 00 | mov     cs:qword_75AFC8, rax\n0x00476B5F | 48 C7 05 8E 44 2E 00 00 00 00 00 | mov     cs:qword_75AFF8, 0\n0x00476B6A | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x00476B6E | 48 8B 40 10 | mov     rax, [rax+10h]\n0x00476B72 | BA 00 00 00 00 | mov     edx, 0\n0x00476B77 | BE 12 00 00 00 | mov     esi, 12h\n0x00476B7C | 48 89 C7 | mov     rdi, rax\n0x00476B7F | E8 F5 DB FF FF | call    sub_474779\n0x00476B84 | 48 8B 05 9D 68 2E 00 | mov     rax, cs:qword_75D428\n0x00476B8B | 48 8B 50 18 | mov     rdx, [rax+18h]\n0x00476B8F | 48 8B 05 32 44 2E 00 | mov     rax, cs:qword_75AFC8\n0x00476B96 | 48 39 C2 | cmp     rdx, rax\n0x00476B99 | 75 0C | jnz     short loc_476BA7\n0x00476B9B | E8 A1 80 FF FF | call    sub_46EC41\n0x00476BA0 | 48 89 05 21 44 2E 00 | mov     cs:qword_75AFC8, rax\n0x00476BA7 | 48 8B 05 1A 44 2E 00 | mov     rax, cs:qword_75AFC8\n0x00476BAE | C6 00 00 | mov     byte ptr [rax], 0\n0x00476BB1 | 48 8B 05 70 68 2E 00 | mov     rax, cs:qword_75D428\n0x00476BB8 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x00476BBC | 48 8B 55 C0 | mov     rdx, [rbp+var_40]\n0x00476BC0 | 48 89 D6 | mov     rsi, rdx\n0x00476BC3 | 48 89 C7 | mov     rdi, rax\n0x00476BC6 | E8 10 FF FF FF | call    sub_476ADB\n0x00476BCB | 89 45 FC | mov     [rbp+var_4], eax\n0x00476BCE | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00476BD2 | 48 89 C7 | mov     rdi, rax\n0x00476BD5 | E8 2B 7D FF FF | call    sub_46E905\n0x00476BDA | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00476BDD | C9 | leave\n0x00476BDE | C3 | retn",
        "output": "",
        "source_code": "static int\ncasematch(union node *pattern, char *val)\n{\n\tstruct stackmark smark;\n\tint result;\n\n\tsetstackmark(&smark);\n\targbackq = pattern->narg.backquote;\n\tSTARTSTACKSTR(expdest);\n\tifslastp = NULL;\n\targstr(pattern->narg.text, EXP_TILDE | EXP_CASE,\n\t\t\t/* var_str_list: */ NULL);\n\tSTACKSTRNUL(expdest);\n\tresult = patmatch(stackblock(), val);\n\tpopstackmark(&smark);\n\treturn result;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "_BOOL8 __fastcall sub_476B22(__int64 a1, const char *a2)\n{\n  _BYTE *v2; // rdi\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v6; // rdx\n  _QWORD v8[5]; // [rsp+10h] [rbp-30h] BYREF\n  _BOOL4 v9; // [rsp+3Ch] [rbp-4h]\n\n  sub_46E8A1(v8);\n  qword_75AFD0 = *(_QWORD *)(a1 + 24);\n  qword_75AFC8 = *(_QWORD *)(qword_75D428 + 16);\n  qword_75AFF8 = 0LL;\n  v2 = *(_BYTE **)(a1 + 16);\n  sub_474779(v2, 0x12u, 0LL);\n  v6 = *(_QWORD *)(qword_75D428 + 24);\n  if ( v6 == qword_75AFC8 )\n    qword_75AFC8 = sub_46EC41((__int64)v2, 18LL, v6, v3, v4, v5);\n  *(_BYTE *)qword_75AFC8 = 0;\n  v9 = sub_476ADB(*(const char **)(qword_75D428 + 16), a2);\n  sub_46E905(v8, (__int64)a2);\n  return v9;\n}\n",
        "baseline_code_debug": "int __cdecl casematch(node *pattern, char *val)\n{\n  stackmark smark; // [rsp+10h] [rbp-30h] BYREF\n  int result; // [rsp+3Ch] [rbp-4h]\n\n  setstackmark(&smark);\n  argbackq = pattern->narg.backquote;\n  expdest = ash_ptr_to_globals_memstack->g_stacknxt;\n  ifslastp = 0LL;\n  argstr(pattern->narg.text, 18, 0LL);\n  if ( ash_ptr_to_globals_memstack->sstrend == expdest )\n    expdest = (char *)growstackstr();\n  *expdest = 0;\n  result = patmatch(ash_ptr_to_globals_memstack->g_stacknxt, val);\n  popstackmark(&smark);\n  return result;\n}\n",
        "similarity_score_unixcoder": 0.06350237876176834,
        "similarity_score_baseline_stripped": 0.42853468656539917,
        "similarity_score_baseline_debug": 0.8595593571662903
    },
    {
        "func_name": "overflow_safe_sub",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0045BF9C | 55 | push    rbp\n0x0045BF9D | 48 89 E5 | mov     rbp, rsp\n0x0045BFA0 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0045BFA4 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x0045BFA8 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0045BFAC | 48 2B 45 E8 | sub     rax, [rbp+var_18]\n0x0045BFB0 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0045BFB4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045BFB8 | 48 85 C0 | test    rax, rax\n0x0045BFBB | 79 19 | jns     short loc_45BFD6\n0x0045BFBD | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x0045BFC2 | 48 39 45 E8 | cmp     [rbp+var_18], rax\n0x0045BFC6 | 77 0E | ja      short loc_45BFD6\n0x0045BFC8 | 48 B8 00 00 00 00 01 00 00 00 | mov     rax, 100000000h\n0x0045BFD2 | 48 01 45 F8 | add     [rbp+var_8], rax\n0x0045BFD6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045BFDA | 5D | pop     rbp\n0x0045BFDB | C3 | retn",
        "output": "",
        "source_code": "static ALWAYS_INLINE cputime_t overflow_safe_sub(cputime_t prev, cputime_t curr)\n{\n\tcputime_t v = curr - prev;\n\n\tif ((icputime_t)v < 0     /* curr < prev - counter overflow? */\n\t && prev <= 0xffffffff /* kernel uses 32bit value for the counter? */\n\t) {\n\t\t/* Add 33th bit set to 1 to curr, compensating for the overflow */\n\t\t/* double shift defeats \"warning: left shift count >= width of type\" */\n\t\tv += ((cputime_t)1 << 16) << 16;\n\t}\n\treturn v;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_45BF9C(unsigned __int64 a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = a2 - a1;\n  if ( (__int64)(a2 - a1) < 0 && a1 <= 0xFFFFFFFF )\n    v3 += 0x100000000LL;\n  return v3;\n}\n",
        "baseline_code_debug": "cputime_t __cdecl overflow_safe_sub(cputime_t prev, cputime_t curr)\n{\n  cputime_t v; // [rsp+18h] [rbp-8h]\n\n  v = curr - prev;\n  if ( (__int64)(curr - prev) < 0 && prev <= 0xFFFFFFFF )\n    v += 0x100000000LL;\n  return v;\n}\n",
        "similarity_score_unixcoder": 0.041425496339797974,
        "similarity_score_baseline_stripped": 0.6165815591812134,
        "similarity_score_baseline_debug": 0.7931541204452515
    },
    {
        "func_name": "next_good_eraseblock",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0042111A | 55 | push    rbp\n0x0042111B | 48 89 E5 | mov     rbp, rsp\n0x0042111E | 48 83 EC 20 | sub     rsp, 20h\n0x00421122 | 89 7D EC | mov     [rbp+var_14], edi\n0x00421125 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00421129 | 89 55 E8 | mov     [rbp+var_18], edx\n0x0042112C | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00421130 | 8B 40 08 | mov     eax, [rax+8]\n0x00421133 | 39 45 E8 | cmp     [rbp+var_18], eax\n0x00421136 | 72 26 | jb      short loc_42115E\n0x00421138 | 48 8B 05 B1 A2 33 00 | mov     rax, cs:ident\n0x0042113F | 48 83 C0 04 | add     rax, 4\n0x00421143 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00421146 | 3C 64 | cmp     al, 64h ; 'd'\n0x00421148 | 74 0F | jz      short loc_421159\n0x0042114A | BF 98 9F 52 00 | mov     edi, offset aNotEnoughSpace; \"not enough space in MTD device\"\n0x0042114F | B8 00 00 00 00 | mov     eax, 0\n0x00421154 | E8 45 85 FE FF | call    sub_40969E\n0x00421159 | 8B 45 E8 | mov     eax, [rbp+var_18]\n0x0042115C | EB 5D | jmp     short locret_4211BB\n0x0042115E | 8B 45 E8 | mov     eax, [rbp+var_18]\n0x00421161 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00421165 | 48 8D 55 F8 | lea     rdx, [rbp+var_8]\n0x00421169 | 8B 45 EC | mov     eax, [rbp+var_14]\n0x0042116C | B9 B7 9F 52 00 | mov     ecx, offset aMemgetbadblock; \"MEMGETBADBLOCK\"\n0x00421171 | BE 0B 4D 08 40 | mov     esi, 40084D0Bh\n0x00421176 | 89 C7 | mov     edi, eax\n0x00421178 | E8 D4 9B FE FF | call    sub_40AD51\n0x0042117D | 85 C0 | test    eax, eax\n0x0042117F | 75 05 | jnz     short loc_421186\n0x00421181 | 8B 45 E8 | mov     eax, [rbp+var_18]\n0x00421184 | EB 35 | jmp     short locret_4211BB\n0x00421186 | 48 8B 05 63 A2 33 00 | mov     rax, cs:ident\n0x0042118D | 48 83 C0 04 | add     rax, 4\n0x00421191 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00421194 | 3C 64 | cmp     al, 64h ; 'd'\n0x00421196 | 74 14 | jz      short loc_4211AC\n0x00421198 | 8B 45 E8 | mov     eax, [rbp+var_18]\n0x0042119B | 89 C6 | mov     esi, eax\n0x0042119D | BF C6 9F 52 00 | mov     edi, offset aSkippingBadBlo; \"Skipping bad block at 0x%08x\\n\"\n0x004211A2 | B8 00 00 00 00 | mov     eax, 0\n0x004211A7 | E8 24 5A FE FF | call    _printf\n0x004211AC | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004211B0 | 8B 40 0C | mov     eax, [rax+0Ch]\n0x004211B3 | 01 45 E8 | add     [rbp+var_18], eax\n0x004211B6 | E9 71 FF FF FF | jmp     loc_42112C\n0x004211BB | C9 | leave\n0x004211BC | C3 | retn",
        "output": "",
        "source_code": "static unsigned next_good_eraseblock(int fd, struct mtd_info_user *meminfo,\n\t\tunsigned block_offset)\n{\n\twhile (1) {\n\t\tloff_t offs;\n\n\t\tif (block_offset >= meminfo->size) {\n\t\t\tif (IS_NANDWRITE)\n\t\t\t\tbb_error_msg_and_die(\"not enough space in MTD device\");\n\t\t\treturn block_offset; /* let the caller exit */\n\t\t}\n\t\toffs = block_offset;\n\t\tif (xioctl(fd, MEMGETBADBLOCK, &offs) == 0)\n\t\t\treturn block_offset;\n\t\t/* ioctl returned 1 => \"bad block\" */\n\t\tif (IS_NANDWRITE)\n\t\t\tprintf(\"Skipping bad block at 0x%08x\\n\", block_offset);\n\t\tblock_offset += meminfo->erasesize;\n\t}\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_42111A(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v7; // [rsp+0h] [rbp-20h]\n  unsigned int i; // [rsp+8h] [rbp-18h]\n  __int64 v9; // [rsp+18h] [rbp-8h] BYREF\n\n  v7 = a2;\n  for ( i = a3; i < *(_DWORD *)(v7 + 8); i += *(_DWORD *)(v7 + 12) )\n  {\n    v9 = i;\n    a2 = 1074285835LL;\n    if ( !(unsigned int)sub_40AD51(a1, 0x40084D0Bu, (__int64)&v9, (__int64)\"MEMGETBADBLOCK\") )\n      return i;\n    if ( ident[4] != 100 )\n    {\n      a2 = i;\n      printf(\"Skipping bad block at 0x%08x\\n\", i);\n    }\n  }\n  if ( ident[4] != 100 )\n    sub_40969E(\"not enough space in MTD device\", a2, a3, a4, a5, a6);\n  return i;\n}\n",
        "baseline_code_debug": "unsigned int __cdecl next_good_eraseblock(int fd, mtd_info_user *meminfo, unsigned int block_offset)\n{\n  loff_t offs; // [rsp+18h] [rbp-8h] BYREF\n\n  while ( block_offset < meminfo->size )\n  {\n    offs = block_offset;\n    if ( !bb_xioctl(fd, 0x40084D0Bu, &offs, \"MEMGETBADBLOCK\") )\n      return block_offset;\n    if ( applet_name[4] != 100 )\n      printf(\"Skipping bad block at 0x%08x\\n\", block_offset);\n    block_offset += meminfo->erasesize;\n  }\n  if ( applet_name[4] != 100 )\n    bb_error_msg_and_die(\"not enough space in MTD device\");\n  return block_offset;\n}\n",
        "similarity_score_unixcoder": 0.0023488514125347137,
        "similarity_score_baseline_stripped": 0.6492072343826294,
        "similarity_score_baseline_debug": 0.9105750322341919
    },
    {
        "func_name": "getvar_i",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004DCB18 | 55 | push    rbp\n0x004DCB19 | 48 89 E5 | mov     rbp, rsp\n0x004DCB1C | 48 83 EC 20 | sub     rsp, 20h\n0x004DCB20 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004DCB24 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DCB28 | 8B 00 | mov     eax, [rax]\n0x004DCB2A | 25 01 01 00 00 | and     eax, 101h\n0x004DCB2F | 85 C0 | test    eax, eax\n0x004DCB31 | 0F 85 A8 00 00 00 | jnz     loc_4DCBDF\n0x004DCB37 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DCB3B | 66 0F EF C0 | pxor    xmm0, xmm0\n0x004DCB3F | F2 0F 11 40 08 | movsd   qword ptr [rax+8], xmm0\n0x004DCB44 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DCB48 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004DCB4C | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004DCB50 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004DCB54 | 48 85 C0 | test    rax, rax\n0x004DCB57 | 74 61 | jz      short loc_4DCBBA\n0x004DCB59 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004DCB5D | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004DCB60 | 84 C0 | test    al, al\n0x004DCB62 | 74 56 | jz      short loc_4DCBBA\n0x004DCB64 | 48 8D 45 F8 | lea     rax, [rbp+var_8]\n0x004DCB68 | 48 89 C7 | mov     rdi, rax\n0x004DCB6B | E8 13 FB FF FF | call    sub_4DC683\n0x004DCB70 | 66 48 0F 7E C2 | movq    rdx, xmm0\n0x004DCB75 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DCB79 | 48 89 50 08 | mov     [rax+8], rdx\n0x004DCB7D | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DCB81 | 8B 00 | mov     eax, [rax]\n0x004DCB83 | 25 00 02 00 00 | and     eax, 200h\n0x004DCB88 | 85 C0 | test    eax, eax\n0x004DCB8A | 74 41 | jz      short loc_4DCBCD\n0x004DCB8C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004DCB90 | 48 89 C7 | mov     rdi, rax\n0x004DCB93 | E8 6A F9 FF FF | call    sub_4DC502\n0x004DCB98 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004DCB9C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004DCBA0 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004DCBA3 | 84 C0 | test    al, al\n0x004DCBA5 | 74 26 | jz      short loc_4DCBCD\n0x004DCBA7 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DCBAB | 8B 00 | mov     eax, [rax]\n0x004DCBAD | 80 E4 FD | and     ah, 0FDh\n0x004DCBB0 | 89 C2 | mov     edx, eax\n0x004DCBB2 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DCBB6 | 89 10 | mov     [rax], edx\n0x004DCBB8 | EB 13 | jmp     short loc_4DCBCD\n0x004DCBBA | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DCBBE | 8B 00 | mov     eax, [rax]\n0x004DCBC0 | 80 E4 FD | and     ah, 0FDh\n0x004DCBC3 | 89 C2 | mov     edx, eax\n0x004DCBC5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DCBC9 | 89 10 | mov     [rax], edx\n0x004DCBCB | EB 01 | jmp     short loc_4DCBCE\n0x004DCBCD | 90 | nop\n0x004DCBCE | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DCBD2 | 8B 00 | mov     eax, [rax]\n0x004DCBD4 | 80 CC 01 | or      ah, 1\n0x004DCBD7 | 89 C2 | mov     edx, eax\n0x004DCBD9 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DCBDD | 89 10 | mov     [rax], edx\n0x004DCBDF | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DCBE3 | F2 0F 10 40 08 | movsd   xmm0, qword ptr [rax+8]\n0x004DCBE8 | C9 | leave\n0x004DCBE9 | C3 | retn",
        "output": "",
        "source_code": "static double getvar_i(var *v)\n{\n\tchar *s;\n\n\tif ((v->type & (VF_NUMBER | VF_CACHED)) == 0) {\n\t\tv->number = 0;\n\t\ts = v->string;\n\t\tif (s && *s) {\n\t\t\tdebug_printf_eval(\"getvar_i: '%s'->\", s);\n\t\t\tv->number = my_strtod(&s);\n\t\t\tdebug_printf_eval(\"%f (s:'%s')\\n\", v->number, s);\n\t\t\tif (v->type & VF_USER) {\n\t\t\t\ts = skip_spaces(s);\n\t\t\t\tif (*s != '\\0')\n\t\t\t\t\tv->type &= ~VF_USER;\n\t\t\t}\n\t\t} else {\n\t\t\tdebug_printf_eval(\"getvar_i: '%s'->zero\\n\", s);\n\t\t\tv->type &= ~VF_USER;\n\t\t}\n\t\tv->type |= VF_CACHED;\n\t}\n\tdebug_printf_eval(\"getvar_i: %f\\n\", v->number);\n\treturn v->number;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "double __fastcall sub_4DCB18(int *a1)\n{\n  int v1; // eax\n  int v2; // eax\n  int v3; // eax\n  char *v5; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( (*a1 & 0x101) == 0 )\n  {\n    *((_QWORD *)a1 + 1) = 0LL;\n    v5 = (char *)*((_QWORD *)a1 + 2);\n    if ( v5 && *v5 )\n    {\n      *((double *)a1 + 1) = sub_4DC683(&v5);\n      if ( (*a1 & 0x200) != 0 )\n      {\n        v5 = sub_4DC502(v5);\n        if ( *v5 )\n        {\n          v1 = *a1;\n          BYTE1(v1) = BYTE1(*a1) & 0xFD;\n          *a1 = v1;\n        }\n      }\n    }\n    else\n    {\n      v2 = *a1;\n      BYTE1(v2) = BYTE1(*a1) & 0xFD;\n      *a1 = v2;\n    }\n    v3 = *a1;\n    BYTE1(v3) = BYTE1(*a1) | 1;\n    *a1 = v3;\n  }\n  return *((double *)a1 + 1);\n}\n",
        "baseline_code_debug": "double __cdecl getvar_i(var_0 *v)\n{\n  unsigned int type; // eax\n  unsigned int v2; // eax\n  unsigned int v3; // eax\n  char *s; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( (v->type & 0x101) == 0 )\n  {\n    v->number = 0.0;\n    s = v->string;\n    if ( s && *s )\n    {\n      v->number = my_strtod(&s);\n      if ( (v->type & 0x200) != 0 )\n      {\n        s = skip_spaces(s);\n        if ( *s )\n        {\n          type = v->type;\n          BYTE1(type) = BYTE1(v->type) & 0xFD;\n          v->type = type;\n        }\n      }\n    }\n    else\n    {\n      v2 = v->type;\n      BYTE1(v2) = BYTE1(v->type) & 0xFD;\n      v->type = v2;\n    }\n    v3 = v->type;\n    BYTE1(v3) = BYTE1(v->type) | 1;\n    v->type = v3;\n  }\n  return v->number;\n}\n",
        "similarity_score_unixcoder": 0.023863481357693672,
        "similarity_score_baseline_stripped": 0.5368391871452332,
        "similarity_score_baseline_debug": 0.7285971641540527
    },
    {
        "func_name": "run_actions",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F5345 | 55 | push    rbp\n0x004F5346 | 48 89 E5 | mov     rbp, rsp\n0x004F5349 | 48 83 EC 20 | sub     rsp, 20h\n0x004F534D | 89 7D EC | mov     [rbp+var_14], edi\n0x004F5350 | 48 8B 05 59 5F 26 00 | mov     rax, cs:qword_75B2B0\n0x004F5357 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004F535B | E9 8F 00 00 00 | jmp     loc_4F53EF\n0x004F5360 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F5364 | 0F B6 40 0C | movzx   eax, byte ptr [rax+0Ch]\n0x004F5368 | 0F B6 C0 | movzx   eax, al\n0x004F536B | 23 45 EC | and     eax, [rbp+var_14]\n0x004F536E | 85 C0 | test    eax, eax\n0x004F5370 | 74 71 | jz      short loc_4F53E3\n0x004F5372 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F5376 | 0F B6 40 0C | movzx   eax, byte ptr [rax+0Ch]\n0x004F537A | 0F B6 C0 | movzx   eax, al\n0x004F537D | 83 E0 67 | and     eax, 67h\n0x004F5380 | 85 C0 | test    eax, eax\n0x004F5382 | 74 2B | jz      short loc_4F53AF\n0x004F5384 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F5388 | 48 89 C7 | mov     rdi, rax\n0x004F538B | E8 93 FD FF FF | call    sub_4F5123\n0x004F5390 | 89 45 F4 | mov     [rbp+var_C], eax\n0x004F5393 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F5397 | 0F B6 40 0C | movzx   eax, byte ptr [rax+0Ch]\n0x004F539B | 0F B6 C0 | movzx   eax, al\n0x004F539E | 83 E0 63 | and     eax, 63h\n0x004F53A1 | 85 C0 | test    eax, eax\n0x004F53A3 | 74 0A | jz      short loc_4F53AF\n0x004F53A5 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x004F53A8 | 89 C7 | mov     edi, eax\n0x004F53AA | E8 53 FF FF FF | call    sub_4F5302\n0x004F53AF | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F53B3 | 0F B6 40 0C | movzx   eax, byte ptr [rax+0Ch]\n0x004F53B7 | 0F B6 C0 | movzx   eax, al\n0x004F53BA | 83 E0 18 | and     eax, 18h\n0x004F53BD | 85 C0 | test    eax, eax\n0x004F53BF | 74 23 | jz      short loc_4F53E4\n0x004F53C1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F53C5 | 8B 40 08 | mov     eax, [rax+8]\n0x004F53C8 | 85 C0 | test    eax, eax\n0x004F53CA | 75 18 | jnz     short loc_4F53E4\n0x004F53CC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F53D0 | 48 89 C7 | mov     rdi, rax\n0x004F53D3 | E8 4B FD FF FF | call    sub_4F5123\n0x004F53D8 | 89 C2 | mov     edx, eax\n0x004F53DA | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F53DE | 89 50 08 | mov     [rax+8], edx\n0x004F53E1 | EB 01 | jmp     short loc_4F53E4\n0x004F53E3 | 90 | nop\n0x004F53E4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F53E8 | 48 8B 00 | mov     rax, [rax]\n0x004F53EB | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004F53EF | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004F53F4 | 0F 85 66 FF FF FF | jnz     loc_4F5360\n0x004F53FA | 90 | nop\n0x004F53FB | C9 | leave\n0x004F53FC | C3 | retn",
        "output": "",
        "source_code": "static void run_actions(int action_type)\n{\n\tstruct init_action *a;\n\n\tfor (a = init_action_list; a; a = a->next) {\n\t\tif (!(a->action_type & action_type))\n\t\t\tcontinue;\n\n\t\tif (a->action_type & (SYSINIT | WAIT | ONCE | CTRLALTDEL | SHUTDOWN)) {\n\t\t\tpid_t pid = run(a);\n\t\t\tif (a->action_type & (SYSINIT | WAIT | CTRLALTDEL | SHUTDOWN))\n\t\t\t\twaitfor(pid);\n\t\t}\n\t\tif (a->action_type & (RESPAWN | ASKFIRST)) {\n\t\t\t/* Only run stuff with pid == 0. If pid != 0,\n\t\t\t * it is already running\n\t\t\t */\n\t\t\tif (a->pid == 0)\n\t\t\t\ta->pid = run(a);\n\t\t}\n\t}\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4F5345(unsigned __int8 a1)\n{\n  __int64 result; // rax\n  __pid_t v2; // [rsp+14h] [rbp-Ch]\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  result = qword_75B2B0;\n  for ( i = qword_75B2B0; i; i = *(_QWORD *)i )\n  {\n    if ( (a1 & *(_BYTE *)(i + 12)) != 0 )\n    {\n      if ( (*(_BYTE *)(i + 12) & 0x67) != 0 )\n      {\n        v2 = sub_4F5123(i);\n        if ( (*(_BYTE *)(i + 12) & 0x63) != 0 )\n          sub_4F5302(v2);\n      }\n      if ( (*(_BYTE *)(i + 12) & 0x18) != 0 && !*(_DWORD *)(i + 8) )\n        *(_DWORD *)(i + 8) = sub_4F5123(i);\n    }\n    result = *(_QWORD *)i;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl run_actions(int action_type)\n{\n  pid_t pid; // [rsp+14h] [rbp-Ch]\n  init_action *a; // [rsp+18h] [rbp-8h]\n\n  for ( a = init_action_list; a; a = a->next )\n  {\n    if ( ((unsigned __int8)action_type & a->action_type) != 0 )\n    {\n      if ( (a->action_type & 0x67) != 0 )\n      {\n        pid = run_0(a);\n        if ( (a->action_type & 0x63) != 0 )\n          waitfor(pid);\n      }\n      if ( (a->action_type & 0x18) != 0 && !a->pid )\n        a->pid = run_0(a);\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.07979556918144226,
        "similarity_score_baseline_stripped": 0.5745024681091309,
        "similarity_score_baseline_debug": 0.8893314003944397
    },
    {
        "func_name": "pid_is_exec",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004D9236 | 55 | push    rbp\n0x004D9237 | 48 89 E5 | mov     rbp, rsp\n0x004D923A | 48 83 EC 50 | sub     rsp, 50h\n0x004D923E | 89 7D BC | mov     [rbp+var_44], edi\n0x004D9241 | 8B 55 BC | mov     edx, [rbp+var_44]\n0x004D9244 | 48 8D 45 C0 | lea     rax, [rbp+s]\n0x004D9248 | BE 80 26 53 00 | mov     esi, offset aProcUExe; \"/proc/%u/exe\"\n0x004D924D | 48 89 C7 | mov     rdi, rax; s\n0x004D9250 | B8 00 00 00 00 | mov     eax, 0\n0x004D9255 | E8 26 E8 F2 FF | call    _sprintf\n0x004D925A | 48 98 | cdqe\n0x004D925C | 48 8D 50 FD | lea     rdx, [rax-3]\n0x004D9260 | 48 8D 45 C0 | lea     rax, [rbp+s]\n0x004D9264 | 48 01 D0 | add     rax, rdx\n0x004D9267 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004D926B | 48 8D 45 C0 | lea     rax, [rbp+s]\n0x004D926F | 48 89 C7 | mov     rdi, rax\n0x004D9272 | E8 9C 1C F3 FF | call    sub_40AF13\n0x004D9277 | 48 89 45 F0 | mov     [rbp+s2], rax\n0x004D927B | 48 83 7D F0 00 | cmp     [rbp+s2], 0\n0x004D9280 | 74 23 | jz      short loc_4D92A5\n0x004D9282 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004D9287 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x004D928B | 48 8B 55 F0 | mov     rdx, [rbp+s2]\n0x004D928F | 48 89 D6 | mov     rsi, rdx; s2\n0x004D9292 | 48 89 C7 | mov     rdi, rax; s1\n0x004D9295 | E8 B6 DD F2 FF | call    _strcmp\n0x004D929A | 85 C0 | test    eax, eax\n0x004D929C | 75 07 | jnz     short loc_4D92A5\n0x004D929E | B8 01 00 00 00 | mov     eax, 1\n0x004D92A3 | EB 05 | jmp     short loc_4D92AA\n0x004D92A5 | B8 00 00 00 00 | mov     eax, 0\n0x004D92AA | 89 45 EC | mov     [rbp+var_14], eax\n0x004D92AD | 48 8B 45 F0 | mov     rax, [rbp+s2]\n0x004D92B1 | 48 89 C7 | mov     rdi, rax; ptr\n0x004D92B4 | E8 A7 D3 F2 FF | call    _free\n0x004D92B9 | 83 7D EC 00 | cmp     [rbp+var_14], 0\n0x004D92BD | 74 05 | jz      short loc_4D92C4\n0x004D92BF | 8B 45 EC | mov     eax, [rbp+var_14]\n0x004D92C2 | EB 7D | jmp     short locret_4D9341\n0x004D92C4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004D92C8 | 48 B9 63 6D 64 6C 69 6E 65 00 | mov     rcx, 656E696C646D63h\n0x004D92D2 | 48 89 08 | mov     [rax], rcx\n0x004D92D5 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004D92DA | 8B 40 30 | mov     eax, [rax+30h]\n0x004D92DD | 89 C2 | mov     edx, eax\n0x004D92DF | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004D92E4 | 48 8B 48 28 | mov     rcx, [rax+28h]\n0x004D92E8 | 48 8D 45 C0 | lea     rax, [rbp+s]\n0x004D92EC | 48 89 CE | mov     rsi, rcx\n0x004D92EF | 48 89 C7 | mov     rdi, rax\n0x004D92F2 | E8 0A 22 F3 FF | call    sub_40B501\n0x004D92F7 | 48 89 45 E0 | mov     [rbp+var_20], rax\n0x004D92FB | 48 83 7D E0 00 | cmp     [rbp+var_20], 0\n0x004D9300 | 7E 3A | jle     short loc_4D933C\n0x004D9302 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004D9307 | 48 8B 50 28 | mov     rdx, [rax+28h]\n0x004D930B | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004D930F | 48 01 D0 | add     rax, rdx\n0x004D9312 | C6 00 00 | mov     byte ptr [rax], 0\n0x004D9315 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004D931A | 48 8B 50 28 | mov     rdx, [rax+28h]\n0x004D931E | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004D9323 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x004D9327 | 48 89 D6 | mov     rsi, rdx; s2\n0x004D932A | 48 89 C7 | mov     rdi, rax; s1\n0x004D932D | E8 1E DD F2 FF | call    _strcmp\n0x004D9332 | 85 C0 | test    eax, eax\n0x004D9334 | 0F 94 C0 | setz    al\n0x004D9337 | 0F B6 C0 | movzx   eax, al\n0x004D933A | EB 05 | jmp     short locret_4D9341\n0x004D933C | B8 00 00 00 00 | mov     eax, 0\n0x004D9341 | C9 | leave\n0x004D9342 | C3 | retn",
        "output": "",
        "source_code": "static int pid_is_exec(pid_t pid)\n{\n\tstruct stat st;\n\tchar buf[sizeof(\"/proc/%u/exe\") + sizeof(int)*3];\n\n\tsprintf(buf, \"/proc/%u/exe\", (unsigned)pid);\n\tif (stat(buf, &st) < 0)\n\t\treturn 0;\n\tif (st.st_dev == execstat.st_dev\n\t && st.st_ino == execstat.st_ino)\n\t\treturn 1;\n\treturn 0;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4D9236(unsigned int a1)\n{\n  _BOOL4 v1; // eax\n  unsigned int v3; // [rsp+Ch] [rbp-44h]\n  char s[32]; // [rsp+10h] [rbp-40h] BYREF\n  ssize_t v5; // [rsp+30h] [rbp-20h]\n  unsigned int v6; // [rsp+3Ch] [rbp-14h]\n  char *s2; // [rsp+40h] [rbp-10h]\n  char *v8; // [rsp+48h] [rbp-8h]\n\n  v3 = a1;\n  v8 = &s[sprintf(s, \"/proc/%u/exe\", a1) - 3];\n  s2 = sub_40AF13(s);\n  v1 = s2 && !strcmp(*(const char **)&dest.c_cc[7], s2);\n  v6 = v1;\n  free(s2);\n  if ( v6 )\n    return v6;\n  *(_QWORD *)v8 = 0x656E696C646D63LL;\n  v5 = sub_40B501(s, *(char **)&dest.c_cc[23], *(unsigned int *)&dest.c_cc[31]);\n  if ( v5 <= 0 )\n    return 0LL;\n  *(_BYTE *)(*(_QWORD *)&dest.c_cc[23] + v5) = 0;\n  return strcmp(*(const char **)&dest.c_cc[7], *(const char **)&dest.c_cc[23]) == 0;\n}\n",
        "baseline_code_debug": "int __cdecl pid_is_exec(pid_t pid)\n{\n  int v1; // eax\n  pid_t pida; // [rsp+Ch] [rbp-44h]\n  char buf[29]; // [rsp+10h] [rbp-40h] BYREF\n  ssize_t bytes; // [rsp+30h] [rbp-20h]\n  int match; // [rsp+3Ch] [rbp-14h]\n  char *exelink; // [rsp+40h] [rbp-10h]\n  char *procname; // [rsp+48h] [rbp-8h]\n\n  pida = pid;\n  procname = &buf[sprintf(buf, \"/proc/%u/exe\", (unsigned int)pid) - 3];\n  exelink = xmalloc_readlink(buf);\n  v1 = exelink && !strcmp(*(const char **)&bb_common_bufsiz1.c_cc[7], exelink);\n  match = v1;\n  free(exelink);\n  if ( match )\n    return match;\n  *(_QWORD *)procname = 0x656E696C646D63LL;\n  bytes = open_read_close(buf, *(void **)&bb_common_bufsiz1.c_cc[23], *(unsigned int *)&bb_common_bufsiz1.c_cc[31]);\n  if ( bytes <= 0 )\n    return 0;\n  *(_BYTE *)(*(_QWORD *)&bb_common_bufsiz1.c_cc[23] + bytes) = 0;\n  return strcmp(*(const char **)&bb_common_bufsiz1.c_cc[7], *(const char **)&bb_common_bufsiz1.c_cc[23]) == 0;\n}\n",
        "similarity_score_unixcoder": 0.09084895253181458,
        "similarity_score_baseline_stripped": 0.5646306872367859,
        "similarity_score_baseline_debug": 0.7550192475318909
    },
    {
        "func_name": "free_volume_id",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004A5BEA | 55 | push    rbp\n0x004A5BEB | 48 89 E5 | mov     rbp, rsp\n0x004A5BEE | 48 83 EC 10 | sub     rsp, 10h\n0x004A5BF2 | 48 89 7D F8 | mov     [rbp+ptr], rdi\n0x004A5BF6 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0\n0x004A5BFB | 74 27 | jz      short loc_4A5C24\n0x004A5BFD | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004A5C01 | 8B 00 | mov     eax, [rax]\n0x004A5C03 | 89 C7 | mov     edi, eax; fd\n0x004A5C05 | E8 06 12 F6 FF | call    _close\n0x004A5C0A | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004A5C0E | 48 89 C7 | mov     rdi, rax\n0x004A5C11 | E8 1B 27 00 00 | call    sub_4A8331\n0x004A5C16 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004A5C1A | 48 89 C7 | mov     rdi, rax; ptr\n0x004A5C1D | E8 3E 0A F6 FF | call    _free\n0x004A5C22 | EB 01 | jmp     short locret_4A5C25\n0x004A5C24 | 90 | nop\n0x004A5C25 | C9 | leave\n0x004A5C26 | C3 | retn",
        "output": "",
        "source_code": "endif\n\nvoid FAST_FUNC free_volume_id(struct volume_id *id)\n{\n\tif (id == NULL)\n\t\treturn;\n\n\t//if (id->fd_close != 0) - always true\n\t\tclose(id->fd);\n\tvolume_id_free_buffer(id);\n#ifdef UNUSED_PARTITION_CODE\n\tfree(id->partitions);\n#endif\n\tfree(id);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "void __fastcall sub_4A5BEA(int *a1)\n{\n  if ( a1 )\n  {\n    close(*a1);\n    sub_4A8331(a1);\n    free(a1);\n  }\n}\n",
        "baseline_code_debug": "void __cdecl free_volume_id(volume_id *id)\n{\n  if ( id )\n  {\n    close(id->fd);\n    volume_id_free_buffer(id);\n    free(id);\n  }\n}\n",
        "similarity_score_unixcoder": 0.030397754162549973,
        "similarity_score_baseline_stripped": 0.5103965997695923,
        "similarity_score_baseline_debug": 0.8812991380691528
    },
    {
        "func_name": "do_linemode",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0044219F | 55 | push    rbp\n0x004421A0 | 48 89 E5 | mov     rbp, rsp\n0x004421A3 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004421A8 | C6 40 06 00 | mov     byte ptr [rax+6], 0\n0x004421AC | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004421B1 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]\n0x004421B5 | BA F8 B3 75 00 | mov     edx, offset dest\n0x004421BA | 83 E0 FC | and     eax, 0FFFFFFFCh\n0x004421BD | 88 42 07 | mov     [rdx+7], al\n0x004421C0 | E8 0A FF FF FF | call    sub_4420CF\n0x004421C5 | BE 01 00 00 00 | mov     esi, 1\n0x004421CA | BF FE 00 00 00 | mov     edi, 0FEh\n0x004421CF | E8 93 FC FF FF | call    sub_441E67\n0x004421D4 | BE 03 00 00 00 | mov     esi, 3\n0x004421D9 | BF FE 00 00 00 | mov     edi, 0FEh\n0x004421DE | E8 84 FC FF FF | call    sub_441E67\n0x004421E3 | E8 43 F8 FF FF | call    sub_441A2B\n0x004421E8 | 90 | nop\n0x004421E9 | 5D | pop     rbp\n0x004421EA | C3 | retn",
        "output": "",
        "source_code": "static void do_linemode(void)\n{\n\tG.charmode = CHM_TRY;\n\tG.telflags &= ~(UF_ECHO | UF_SGA);\n\tsetConMode();\n\n\tput_iac2(DONT, TELOPT_ECHO);\n\tput_iac2(DONT, TELOPT_SGA);\n\tiac_flush();\n}",
        "parsed_output": "",
        "baseline_code_stripped": "struct termios *sub_44219F()\n{\n  BYTE2(dest.c_oflag) = 0;\n  HIBYTE(dest.c_oflag) &= 0xFCu;\n  sub_4420CF();\n  sub_441E67(254, 1);\n  sub_441E67(254, 3);\n  return sub_441A2B();\n}\n",
        "baseline_code_debug": "void __cdecl do_linemode()\n{\n  BYTE2(bb_common_bufsiz1.c_oflag) = 0;\n  HIBYTE(bb_common_bufsiz1.c_oflag) &= 0xFCu;\n  setConMode();\n  put_iac2(0xFEu, 1u);\n  put_iac2(0xFEu, 3u);\n  iac_flush();\n}\n",
        "similarity_score_unixcoder": 0.04143993929028511,
        "similarity_score_baseline_stripped": 0.492007851600647,
        "similarity_score_baseline_debug": 0.6759384870529175
    },
    {
        "func_name": "unbackslash",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0047FF75 | 55 | push    rbp\n0x0047FF76 | 48 89 E5 | mov     rbp, rsp\n0x0047FF79 | 48 83 EC 20 | sub     rsp, 20h\n0x0047FF7D | 48 89 7D E8 | mov     [rbp+s], rdi\n0x0047FF81 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x0047FF85 | BE 5C 00 00 00 | mov     esi, 5Ch ; '\\'; c\n0x0047FF8A | 48 89 C7 | mov     rdi, rax; s\n0x0047FF8D | E8 5E 69 F8 FF | call    _strchrnul\n0x0047FF92 | 48 89 45 E8 | mov     [rbp+s], rax\n0x0047FF96 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x0047FF9A | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0047FF9E | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x0047FFA2 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0047FFA5 | 3C 5C | cmp     al, 5Ch ; '\\'\n0x0047FFA7 | 75 05 | jnz     short loc_47FFAE\n0x0047FFA9 | 48 83 45 E8 01 | add     [rbp+s], 1\n0x0047FFAE | 48 8B 55 E8 | mov     rdx, [rbp+s]\n0x0047FFB2 | 48 8D 42 01 | lea     rax, [rdx+1]\n0x0047FFB6 | 48 89 45 E8 | mov     [rbp+s], rax\n0x0047FFBA | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0047FFBE | 48 8D 48 01 | lea     rcx, [rax+1]\n0x0047FFC2 | 48 89 4D F8 | mov     [rbp+var_8], rcx\n0x0047FFC6 | 0F B6 12 | movzx   edx, byte ptr [rdx]\n0x0047FFC9 | 88 10 | mov     [rax], dl\n0x0047FFCB | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0047FFCE | 84 C0 | test    al, al\n0x0047FFD0 | 74 02 | jz      short loc_47FFD4\n0x0047FFD2 | EB CA | jmp     short loc_47FF9E\n0x0047FFD4 | 90 | nop\n0x0047FFD5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0047FFD9 | C9 | leave\n0x0047FFDA | C3 | retn",
        "output": "",
        "source_code": "static char *unbackslash(char *src)\n{\n\tchar *dst = src = strchrnul(src, '\\\\');\n\twhile (1) {\n\t\tif (*src == '\\\\')\n\t\t\tsrc++;\n\t\tif ((*dst++ = *src++) == '\\0')\n\t\t\tbreak;\n\t}\n\treturn dst;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "char *__fastcall sub_47FF75(const char *a1)\n{\n  char *v1; // rdx\n  char *v2; // rax\n  char *s; // [rsp+8h] [rbp-18h]\n  char *v5; // [rsp+18h] [rbp-8h]\n\n  s = strchrnul(a1, 92);\n  v5 = s;\n  do\n  {\n    if ( *s == 92 )\n      ++s;\n    v1 = s++;\n    v2 = v5++;\n    *v2 = *v1;\n  }\n  while ( *v2 );\n  return v5;\n}\n",
        "baseline_code_debug": "char *__cdecl unbackslash(char *src)\n{\n  char *v1; // rdx\n  char *v2; // rax\n  char *srca; // [rsp+8h] [rbp-18h]\n  char *dst; // [rsp+18h] [rbp-8h]\n\n  srca = strchrnul(src, 92);\n  dst = srca;\n  do\n  {\n    if ( *srca == 92 )\n      ++srca;\n    v1 = srca++;\n    v2 = dst++;\n    *v2 = *v1;\n  }\n  while ( *v2 );\n  return dst;\n}\n",
        "similarity_score_unixcoder": 0.06290796399116516,
        "similarity_score_baseline_stripped": 0.5178252458572388,
        "similarity_score_baseline_debug": 0.8297326564788818
    },
    {
        "func_name": "fs_match",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004DB197 | 55 | push    rbp\n0x004DB198 | 48 89 E5 | mov     rbp, rsp\n0x004DB19B | 48 83 EC 30 | sub     rsp, 30h\n0x004DB19F | 48 89 7D D8 | mov     [rbp+var_28], rdi\n0x004DB1A3 | 48 8B 05 BE 00 28 00 | mov     rax, cs:qword_75B268\n0x004DB1AA | 48 85 C0 | test    rax, rax\n0x004DB1AD | 75 0A | jnz     short loc_4DB1B9\n0x004DB1AF | B8 01 00 00 00 | mov     eax, 1\n0x004DB1B4 | E9 02 01 00 00 | jmp     locret_4DB2BB\n0x004DB1B9 | C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0\n0x004DB1C0 | C7 45 F4 00 00 00 00 | mov     [rbp+var_C], 0\n0x004DB1C7 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x004DB1CE | 48 8B 05 93 00 28 00 | mov     rax, cs:qword_75B268\n0x004DB1D5 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x004DB1D8 | 48 63 D2 | movsxd  rdx, edx\n0x004DB1DB | 48 C1 E2 03 | shl     rdx, 3\n0x004DB1DF | 48 01 D0 | add     rax, rdx\n0x004DB1E2 | 48 8B 00 | mov     rax, [rax]\n0x004DB1E5 | 48 89 45 E8 | mov     [rbp+s1], rax\n0x004DB1E9 | 48 83 7D E8 00 | cmp     [rbp+s1], 0\n0x004DB1EE | 0F 84 9F 00 00 00 | jz      loc_4DB293\n0x004DB1F4 | 48 8B 15 75 00 28 00 | mov     rdx, cs:qword_75B270\n0x004DB1FB | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004DB1FE | 48 98 | cdqe\n0x004DB200 | 48 01 D0 | add     rax, rdx\n0x004DB203 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004DB206 | 0F B6 C0 | movzx   eax, al\n0x004DB209 | 83 F8 01 | cmp     eax, 1\n0x004DB20C | 74 53 | jz      short loc_4DB261\n0x004DB20E | 83 F8 02 | cmp     eax, 2\n0x004DB211 | 74 2C | jz      short loc_4DB23F\n0x004DB213 | 85 C0 | test    eax, eax\n0x004DB215 | 75 73 | jnz     short loc_4DB28A\n0x004DB217 | 83 45 F4 01 | add     [rbp+var_C], 1\n0x004DB21B | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004DB21F | 48 8B 50 18 | mov     rdx, [rax+18h]\n0x004DB223 | 48 8B 45 E8 | mov     rax, [rbp+s1]\n0x004DB227 | 48 89 D6 | mov     rsi, rdx; s2\n0x004DB22A | 48 89 C7 | mov     rdi, rax; s1\n0x004DB22D | E8 1E BE F2 FF | call    _strcmp\n0x004DB232 | 85 C0 | test    eax, eax\n0x004DB234 | 75 4D | jnz     short loc_4DB283\n0x004DB236 | C7 45 F8 01 00 00 00 | mov     [rbp+var_8], 1\n0x004DB23D | EB 44 | jmp     short loc_4DB283\n0x004DB23F | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004DB243 | 48 8B 50 20 | mov     rdx, [rax+20h]\n0x004DB247 | 48 8B 45 E8 | mov     rax, [rbp+s1]\n0x004DB24B | 48 89 D6 | mov     rsi, rdx\n0x004DB24E | 48 89 C7 | mov     rdi, rax\n0x004DB251 | E8 8C FE FF FF | call    sub_4DB0E2\n0x004DB256 | 85 C0 | test    eax, eax\n0x004DB258 | 74 2C | jz      short loc_4DB286\n0x004DB25A | B8 00 00 00 00 | mov     eax, 0\n0x004DB25F | EB 5A | jmp     short locret_4DB2BB\n0x004DB261 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004DB265 | 48 8B 50 20 | mov     rdx, [rax+20h]\n0x004DB269 | 48 8B 45 E8 | mov     rax, [rbp+s1]\n0x004DB26D | 48 89 D6 | mov     rsi, rdx\n0x004DB270 | 48 89 C7 | mov     rdi, rax\n0x004DB273 | E8 6A FE FF FF | call    sub_4DB0E2\n0x004DB278 | 85 C0 | test    eax, eax\n0x004DB27A | 75 0D | jnz     short loc_4DB289\n0x004DB27C | B8 00 00 00 00 | mov     eax, 0\n0x004DB281 | EB 38 | jmp     short locret_4DB2BB\n0x004DB283 | 90 | nop\n0x004DB284 | EB 04 | jmp     short loc_4DB28A\n0x004DB286 | 90 | nop\n0x004DB287 | EB 01 | jmp     short loc_4DB28A\n0x004DB289 | 90 | nop\n0x004DB28A | 83 45 FC 01 | add     [rbp+var_4], 1\n0x004DB28E | E9 3B FF FF FF | jmp     loc_4DB1CE\n0x004DB293 | 90 | nop\n0x004DB294 | 83 7D F4 00 | cmp     [rbp+var_C], 0\n0x004DB298 | 75 07 | jnz     short loc_4DB2A1\n0x004DB29A | B8 01 00 00 00 | mov     eax, 1\n0x004DB29F | EB 1A | jmp     short locret_4DB2BB\n0x004DB2A1 | 0F B6 05 D0 FF 27 00 | movzx   eax, cs:byte_75B278\n0x004DB2A8 | 84 C0 | test    al, al\n0x004DB2AA | 74 0C | jz      short loc_4DB2B8\n0x004DB2AC | 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004DB2B0 | 0F 94 C0 | setz    al\n0x004DB2B3 | 0F B6 C0 | movzx   eax, al\n0x004DB2B6 | EB 03 | jmp     short locret_4DB2BB\n0x004DB2B8 | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x004DB2BB | C9 | leave\n0x004DB2BC | C3 | retn",
        "output": "",
        "source_code": "static int fs_match(struct fs_info *fs)\n{\n\tint n, ret, checked_type;\n\tchar *cp;\n\n\tif (!fs_type_list)\n\t\treturn 1;\n\n\tret = 0;\n\tchecked_type = 0;\n\tn = 0;\n\twhile (1) {\n\t\tcp = fs_type_list[n];\n\t\tif (!cp)\n\t\t\tbreak;\n\t\tswitch (fs_type_flag[n]) {\n\t\tcase FS_TYPE_FLAG_NORMAL:\n\t\t\tchecked_type++;\n\t\t\tif (strcmp(cp, fs->type) == 0)\n\t\t\t\tret = 1;\n\t\t\tbreak;\n\t\tcase FS_TYPE_FLAG_NEGOPT:\n\t\t\tif (opt_in_list(cp, fs->opts))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase FS_TYPE_FLAG_OPT:\n\t\t\tif (!opt_in_list(cp, fs->opts))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\t\tn++;\n\t}\n\tif (checked_type == 0)\n\t\treturn 1;\n\n\treturn (fs_type_negated ? !ret : ret);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4DB197(__int64 a1)\n{\n  int v2; // eax\n  char *s1; // [rsp+18h] [rbp-18h]\n  int v4; // [rsp+24h] [rbp-Ch]\n  unsigned int v5; // [rsp+28h] [rbp-8h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  if ( !qword_75B268 )\n    return 1LL;\n  v5 = 0;\n  v4 = 0;\n  for ( i = 0; ; ++i )\n  {\n    s1 = *(char **)(8LL * i + qword_75B268);\n    if ( !s1 )\n      break;\n    v2 = *(unsigned __int8 *)(qword_75B270 + i);\n    if ( v2 == 1 )\n    {\n      if ( !(unsigned int)sub_4DB0E2(s1, *(char **)(a1 + 32)) )\n        return 0LL;\n    }\n    else if ( v2 == 2 )\n    {\n      if ( (unsigned int)sub_4DB0E2(s1, *(char **)(a1 + 32)) )\n        return 0LL;\n    }\n    else if ( !*(_BYTE *)(qword_75B270 + i) )\n    {\n      ++v4;\n      if ( !strcmp(s1, *(const char **)(a1 + 24)) )\n        v5 = 1;\n    }\n  }\n  if ( !v4 )\n    return 1LL;\n  if ( byte_75B278 )\n    return v5 == 0;\n  return v5;\n}\n",
        "baseline_code_debug": "int __cdecl fs_match(fs_info *fs_0)\n{\n  int v2; // eax\n  char *cp; // [rsp+18h] [rbp-18h]\n  int checked_type; // [rsp+24h] [rbp-Ch]\n  int ret; // [rsp+28h] [rbp-8h]\n  int n; // [rsp+2Ch] [rbp-4h]\n\n  if ( !fs_type_list )\n    return 1;\n  ret = 0;\n  checked_type = 0;\n  for ( n = 0; ; ++n )\n  {\n    cp = fs_type_list[n];\n    if ( !cp )\n      break;\n    v2 = fs_type_flag[n];\n    if ( v2 == 1 )\n    {\n      if ( !opt_in_list(cp, fs_0->opts) )\n        return 0;\n    }\n    else if ( v2 == 2 )\n    {\n      if ( opt_in_list(cp, fs_0->opts) )\n        return 0;\n    }\n    else if ( !fs_type_flag[n] )\n    {\n      ++checked_type;\n      if ( !strcmp(cp, fs_0->type) )\n        ret = 1;\n    }\n  }\n  if ( !checked_type )\n    return 1;\n  if ( fs_type_negated )\n    return ret == 0;\n  return ret;\n}\n",
        "similarity_score_unixcoder": 0.06879869103431702,
        "similarity_score_baseline_stripped": 0.5069974064826965,
        "similarity_score_baseline_debug": 0.8795309662818909
    },
    {
        "func_name": "add_logical",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00494AF9 | 55 | push    rbp\n0x00494AFA | 48 89 E5 | mov     rbp, rsp\n0x00494AFD | 48 83 EC 10 | sub     rsp, 10h\n0x00494B01 | 48 8B 05 00 89 2C 00 | mov     rax, cs:qword_75D408\n0x00494B08 | 8B 40 10 | mov     eax, [rax+10h]\n0x00494B0B | 83 F8 05 | cmp     eax, 5\n0x00494B0E | 7F 1A | jg      short loc_494B2A\n0x00494B10 | 48 8B 05 F1 88 2C 00 | mov     rax, cs:qword_75D408\n0x00494B17 | 48 8B 80 68 0A 00 00 | mov     rax, [rax+0A68h]\n0x00494B1E | 0F B6 40 04 | movzx   eax, byte ptr [rax+4]\n0x00494B22 | 84 C0 | test    al, al\n0x00494B24 | 0F 84 9E 00 00 00 | jz      loc_494BC8\n0x00494B2A | 48 8B 0D D7 88 2C 00 | mov     rcx, cs:qword_75D408\n0x00494B31 | 48 8B 05 D0 88 2C 00 | mov     rax, cs:qword_75D408\n0x00494B38 | 8B 40 10 | mov     eax, [rax+10h]\n0x00494B3B | 48 63 D0 | movsxd  rdx, eax\n0x00494B3E | 48 89 D0 | mov     rax, rdx\n0x00494B41 | 48 C1 E0 02 | shl     rax, 2\n0x00494B45 | 48 01 D0 | add     rax, rdx\n0x00494B48 | 48 C1 E0 03 | shl     rax, 3\n0x00494B4C | 48 05 C0 09 00 00 | add     rax, 9C0h\n0x00494B52 | 48 01 C8 | add     rax, rcx\n0x00494B55 | 48 83 C0 08 | add     rax, 8\n0x00494B59 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00494B5D | 48 8B 05 A4 88 2C 00 | mov     rax, cs:qword_75D408\n0x00494B64 | 8B 40 18 | mov     eax, [rax+18h]\n0x00494B67 | 89 C0 | mov     eax, eax\n0x00494B69 | 48 89 C7 | mov     rdi, rax\n0x00494B6C | E8 77 55 F7 FF | call    sub_40A0E8\n0x00494B71 | 48 89 C2 | mov     rdx, rax\n0x00494B74 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00494B78 | 48 89 50 18 | mov     [rax+18h], rdx\n0x00494B7C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00494B80 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x00494B84 | 48 8D 90 BE 01 00 00 | lea     rdx, [rax+1BEh]\n0x00494B8B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00494B8F | 48 89 10 | mov     [rax], rdx\n0x00494B92 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00494B96 | 48 8B 00 | mov     rax, [rax]\n0x00494B99 | 48 8D 50 10 | lea     rdx, [rax+10h]\n0x00494B9D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00494BA1 | 48 89 50 08 | mov     [rax+8], rdx\n0x00494BA5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00494BA9 | C7 40 10 00 00 00 00 | mov     dword ptr [rax+10h], 0\n0x00494BB0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00494BB4 | C6 40 20 01 | mov     byte ptr [rax+20h], 1\n0x00494BB8 | 48 8B 05 49 88 2C 00 | mov     rax, cs:qword_75D408\n0x00494BBF | 8B 50 10 | mov     edx, [rax+10h]\n0x00494BC2 | 83 C2 01 | add     edx, 1\n0x00494BC5 | 89 50 10 | mov     [rax+10h], edx\n0x00494BC8 | 48 8B 05 39 88 2C 00 | mov     rax, cs:qword_75D408\n0x00494BCF | 8B 40 10 | mov     eax, [rax+10h]\n0x00494BD2 | 83 E8 01 | sub     eax, 1\n0x00494BD5 | BE 83 00 00 00 | mov     esi, 83h\n0x00494BDA | 89 C7 | mov     edi, eax\n0x00494BDC | E8 F2 F4 FF FF | call    sub_4940D3\n0x00494BE1 | 90 | nop\n0x00494BE2 | C9 | leave\n0x00494BE3 | C3 | retn",
        "output": "",
        "source_code": "static void\nadd_logical(void)\n{\n\tif (g_partitions > 5 || ptes[4].part_table->sys_ind) {\n\t\tstruct pte *pe = &ptes[g_partitions];\n\n\t\tpe->sectorbuffer = xzalloc(sector_size);\n\t\tpe->part_table = pt_offset(pe->sectorbuffer, 0);\n\t\tpe->ext_pointer = pe->part_table + 1;\n\t\tpe->offset_from_dev_start = 0;\n\t\tpe->changed = 1;\n\t\tg_partitions++;\n\t}\n\tadd_partition(g_partitions - 1, LINUX_NATIVE);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "unsigned int __fastcall sub_494AF9(__int64 a1, __int64 a2)\n{\n  char *v3; // [rsp+8h] [rbp-8h]\n\n  if ( *((int *)qword_75D408 + 4) > 5 || *(_BYTE *)(*((_QWORD *)qword_75D408 + 333) + 4LL) )\n  {\n    v3 = (char *)qword_75D408 + 40 * *((int *)qword_75D408 + 4) + 2504;\n    *((_QWORD *)v3 + 3) = sub_40A0E8(*((unsigned int *)qword_75D408 + 6), a2);\n    *(_QWORD *)v3 = *((_QWORD *)v3 + 3) + 446LL;\n    *((_QWORD *)v3 + 1) = *(_QWORD *)v3 + 16LL;\n    *((_DWORD *)v3 + 4) = 0;\n    v3[32] = 1;\n    ++*((_DWORD *)qword_75D408 + 4);\n  }\n  return sub_4940D3(*((_DWORD *)qword_75D408 + 4) - 1, 131);\n}\n",
        "baseline_code_debug": "void __cdecl add_logical()\n{\n  pte *pe; // [rsp+8h] [rbp-8h]\n\n  if ( SLODWORD(ptr_to_globals->fakehost) > 5 || *(_BYTE *)(*(_QWORD *)&ptr_to_globals[9].speeds[5] + 4LL) )\n  {\n    pe = (pte *)&ptr_to_globals[8].line_buf[40 * SLODWORD(ptr_to_globals->fakehost) + 44];\n    pe->sectorbuffer = (char *)xzalloc(LODWORD(ptr_to_globals->tty_name));\n    pe->part_table = (partition *)(pe->sectorbuffer + 446);\n    pe->ext_pointer = pe->part_table + 1;\n    pe->offset_from_dev_start = 0;\n    pe->changed = 1;\n    ++LODWORD(ptr_to_globals->fakehost);\n  }\n  add_partition(LODWORD(ptr_to_globals->fakehost) - 1, 131);\n}\n",
        "similarity_score_unixcoder": 0.05396481603384018,
        "similarity_score_baseline_stripped": 0.445894718170166,
        "similarity_score_baseline_debug": 0.7685377597808838
    },
    {
        "func_name": "add_till_closing_bracket",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004832A5 | 55 | push    rbp\n0x004832A6 | 48 89 E5 | mov     rbp, rsp\n0x004832A9 | 48 83 EC 30 | sub     rsp, 30h\n0x004832AD | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004832B1 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004832B5 | 89 55 DC | mov     [rbp+var_24], edx\n0x004832B8 | 8B 45 DC | mov     eax, [rbp+var_24]\n0x004832BB | 83 E0 80 | and     eax, 0FFFFFF80h\n0x004832BE | 88 45 FF | mov     [rbp+var_1], al\n0x004832C1 | 8B 45 DC | mov     eax, [rbp+var_24]\n0x004832C4 | C1 E8 08 | shr     eax, 8\n0x004832C7 | 88 45 FE | mov     [rbp+var_2], al\n0x004832CA | 83 65 DC 7F | and     [rbp+var_24], 7Fh\n0x004832CE | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004832D2 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x004832D6 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x004832DA | 48 89 D7 | mov     rdi, rdx\n0x004832DD | FF D0 | call    rax\n0x004832DF | 89 45 F8 | mov     [rbp+var_8], eax\n0x004832E2 | 83 7D F8 FF | cmp     [rbp+var_8], 0FFFFFFFFh\n0x004832E6 | 75 17 | jnz     short loc_4832FF\n0x004832E8 | 8B 45 DC | mov     eax, [rbp+var_24]\n0x004832EB | 0F BE C0 | movsx   eax, al\n0x004832EE | 89 C7 | mov     edi, eax\n0x004832F0 | E8 1E CC FF FF | call    sub_47FF13\n0x004832F5 | B8 00 00 00 00 | mov     eax, 0\n0x004832FA | E9 B9 01 00 00 | jmp     locret_4834B8\n0x004832FF | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x00483302 | 39 45 DC | cmp     [rbp+var_24], eax\n0x00483305 | 74 09 | jz      short loc_483310\n0x00483307 | 0F BE 45 FE | movsx   eax, [rbp+var_2]\n0x0048330B | 39 45 F8 | cmp     [rbp+var_8], eax\n0x0048330E | 75 36 | jnz     short loc_483346\n0x00483310 | 80 7D FF 00 | cmp     [rbp+var_1], 0\n0x00483314 | 0F 84 9A 01 00 00 | jz      loc_4834B4\n0x0048331A | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0048331E | 48 8B 40 20 | mov     rax, [rax+20h]\n0x00483322 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00483326 | 48 89 D7 | mov     rdi, rdx\n0x00483329 | FF D0 | call    rax\n0x0048332B | 39 45 DC | cmp     [rbp+var_24], eax\n0x0048332E | 75 16 | jnz     short loc_483346\n0x00483330 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00483334 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x00483338 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x0048333C | 48 89 D7 | mov     rdi, rdx\n0x0048333F | FF D0 | call    rax\n0x00483341 | E9 6F 01 00 00 | jmp     loc_4834B5\n0x00483346 | 8B 55 F8 | mov     edx, [rbp+var_8]\n0x00483349 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0048334D | 89 D6 | mov     esi, edx\n0x0048334F | 48 89 C7 | mov     rdi, rax\n0x00483352 | E8 0C E1 FF FF | call    sub_481463\n0x00483357 | 83 7D F8 28 | cmp     [rbp+var_8], 28h ; '('\n0x0048335B | 74 06 | jz      short loc_483363\n0x0048335D | 83 7D F8 7B | cmp     [rbp+var_8], 7Bh ; '{'\n0x00483361 | 75 4F | jnz     short loc_4833B2\n0x00483363 | 83 7D F8 28 | cmp     [rbp+var_8], 28h ; '('\n0x00483367 | 75 07 | jnz     short loc_483370\n0x00483369 | B8 29 00 00 00 | mov     eax, 29h ; ')'\n0x0048336E | EB 05 | jmp     short loc_483375\n0x00483370 | B8 7D 00 00 00 | mov     eax, 7Dh ; '}'\n0x00483375 | 89 45 F8 | mov     [rbp+var_8], eax\n0x00483378 | 8B 55 F8 | mov     edx, [rbp+var_8]\n0x0048337B | 48 8B 4D E0 | mov     rcx, [rbp+var_20]\n0x0048337F | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00483383 | 48 89 CE | mov     rsi, rcx\n0x00483386 | 48 89 C7 | mov     rdi, rax\n0x00483389 | E8 17 FF FF FF | call    sub_4832A5\n0x0048338E | 85 C0 | test    eax, eax\n0x00483390 | 75 0A | jnz     short loc_48339C\n0x00483392 | B8 00 00 00 00 | mov     eax, 0\n0x00483397 | E9 1C 01 00 00 | jmp     locret_4834B8\n0x0048339C | 8B 55 F8 | mov     edx, [rbp+var_8]\n0x0048339F | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004833A3 | 89 D6 | mov     esi, edx\n0x004833A5 | 48 89 C7 | mov     rdi, rax\n0x004833A8 | E8 B6 E0 FF FF | call    sub_481463\n0x004833AD | E9 FD 00 00 00 | jmp     loc_4834AF\n0x004833B2 | 83 7D F8 27 | cmp     [rbp+var_8], 27h ; '''\n0x004833B6 | 75 37 | jnz     short loc_4833EF\n0x004833B8 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x004833BC | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004833C0 | 48 89 D6 | mov     rsi, rdx\n0x004833C3 | 48 89 C7 | mov     rdi, rax\n0x004833C6 | E8 08 FD FF FF | call    sub_4830D3\n0x004833CB | 85 C0 | test    eax, eax\n0x004833CD | 75 0A | jnz     short loc_4833D9\n0x004833CF | B8 00 00 00 00 | mov     eax, 0\n0x004833D4 | E9 DF 00 00 00 | jmp     locret_4834B8\n0x004833D9 | 8B 55 F8 | mov     edx, [rbp+var_8]\n0x004833DC | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004833E0 | 89 D6 | mov     esi, edx\n0x004833E2 | 48 89 C7 | mov     rdi, rax\n0x004833E5 | E8 79 E0 FF FF | call    sub_481463\n0x004833EA | E9 C0 00 00 00 | jmp     loc_4834AF\n0x004833EF | 83 7D F8 22 | cmp     [rbp+var_8], 22h ; '\"'\n0x004833F3 | 75 37 | jnz     short loc_48342C\n0x004833F5 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x004833F9 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004833FD | 48 89 D6 | mov     rsi, rdx\n0x00483400 | 48 89 C7 | mov     rdi, rax\n0x00483403 | E8 28 FD FF FF | call    sub_483130\n0x00483408 | 85 C0 | test    eax, eax\n0x0048340A | 75 0A | jnz     short loc_483416\n0x0048340C | B8 00 00 00 00 | mov     eax, 0\n0x00483411 | E9 A2 00 00 00 | jmp     locret_4834B8\n0x00483416 | 8B 55 F8 | mov     edx, [rbp+var_8]\n0x00483419 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0048341D | 89 D6 | mov     esi, edx\n0x0048341F | 48 89 C7 | mov     rdi, rax\n0x00483422 | E8 3C E0 FF FF | call    sub_481463\n0x00483427 | E9 83 00 00 00 | jmp     loc_4834AF\n0x0048342C | 83 7D F8 60 | cmp     [rbp+var_8], 60h ; '`'\n0x00483430 | 75 36 | jnz     short loc_483468\n0x00483432 | 48 8B 4D E0 | mov     rcx, [rbp+var_20]\n0x00483436 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0048343A | BA 00 00 00 00 | mov     edx, 0\n0x0048343F | 48 89 CE | mov     rsi, rcx\n0x00483442 | 48 89 C7 | mov     rdi, rax\n0x00483445 | E8 AF FD FF FF | call    sub_4831F9\n0x0048344A | 85 C0 | test    eax, eax\n0x0048344C | 75 07 | jnz     short loc_483455\n0x0048344E | B8 00 00 00 00 | mov     eax, 0\n0x00483453 | EB 63 | jmp     short locret_4834B8\n0x00483455 | 8B 55 F8 | mov     edx, [rbp+var_8]\n0x00483458 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0048345C | 89 D6 | mov     esi, edx\n0x0048345E | 48 89 C7 | mov     rdi, rax\n0x00483461 | E8 FD DF FF FF | call    sub_481463\n0x00483466 | EB 47 | jmp     short loc_4834AF\n0x00483468 | 83 7D F8 5C | cmp     [rbp+var_8], 5Ch ; '\\'\n0x0048346C | 0F 85 5C FE FF FF | jnz     loc_4832CE\n0x00483472 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00483476 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x0048347A | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x0048347E | 48 89 D7 | mov     rdi, rdx\n0x00483481 | FF D0 | call    rax\n0x00483483 | 89 45 F8 | mov     [rbp+var_8], eax\n0x00483486 | 83 7D F8 FF | cmp     [rbp+var_8], 0FFFFFFFFh\n0x0048348A | 75 11 | jnz     short loc_48349D\n0x0048348C | BF 29 00 00 00 | mov     edi, 29h ; ')'\n0x00483491 | E8 7D CA FF FF | call    sub_47FF13\n0x00483496 | B8 00 00 00 00 | mov     eax, 0\n0x0048349B | EB 1B | jmp     short locret_4834B8\n0x0048349D | 8B 55 F8 | mov     edx, [rbp+var_8]\n0x004834A0 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004834A4 | 89 D6 | mov     esi, edx\n0x004834A6 | 48 89 C7 | mov     rdi, rax\n0x004834A9 | E8 B5 DF FF FF | call    sub_481463\n0x004834AE | 90 | nop\n0x004834AF | E9 1A FE FF FF | jmp     loc_4832CE\n0x004834B4 | 90 | nop\n0x004834B5 | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x004834B8 | C9 | leave\n0x004834B9 | C3 | retn",
        "output": "",
        "source_code": "define DOUBLE_CLOSE_CHAR_FLAG 0x80\nstatic int add_till_closing_bracket(o_string *dest, struct in_str *input, unsigned end_ch)\n{\n\tint ch;\n\tchar dbl = end_ch & DOUBLE_CLOSE_CHAR_FLAG;\n# if ENABLE_HUSH_BASH_COMPAT\n\tchar end_char2 = end_ch >> 8;\n# endif\n\tend_ch &= (DOUBLE_CLOSE_CHAR_FLAG - 1);\n\n\twhile (1) {\n\t\tch = i_getch(input);\n\t\tif (ch == EOF) {\n\t\t\tsyntax_error_unterm_ch(end_ch);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ch == end_ch  IF_HUSH_BASH_COMPAT( || ch == end_char2)) {\n\t\t\tif (!dbl)\n\t\t\t\tbreak;\n\t\t\t/* we look for closing )) of $((EXPR)) */\n\t\t\tif (i_peek(input) == end_ch) {\n\t\t\t\ti_getch(input); /* eat second ')' */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\to_addchr(dest, ch);\n\t\tif (ch == '(' || ch == '{') {\n\t\t\tch = (ch == '(' ? ')' : '}');\n\t\t\tif (!add_till_closing_bracket(dest, input, ch))\n\t\t\t\treturn 0;\n\t\t\to_addchr(dest, ch);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\\'') {\n\t\t\tif (!add_till_single_quote(dest, input))\n\t\t\t\treturn 0;\n\t\t\to_addchr(dest, ch);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\"') {\n\t\t\tif (!add_till_double_quote(dest, input))\n\t\t\t\treturn 0;\n\t\t\to_addchr(dest, ch);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '`') {\n\t\t\tif (!add_till_backquote(dest, input, /*in_dquote:*/ 0))\n\t\t\t\treturn 0;\n\t\t\to_addchr(dest, ch);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ch == '\\\\') {\n\t\t\t/* \\x. Copy verbatim. Important for  \\(, \\) */\n\t\t\tch = i_getch(input);\n\t\t\tif (ch == EOF) {\n\t\t\t\tsyntax_error_unterm_ch(')');\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\to_addchr(dest, ch);\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn ch;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4832A5(__int64 a1, __int64 a2, __int16 a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  unsigned int v8; // eax\n  __int64 v9; // rdx\n  __int64 v10; // rcx\n  __int64 v11; // r8\n  __int64 v12; // r9\n  int v13; // [rsp+Ch] [rbp-24h]\n  __int64 v14; // [rsp+10h] [rbp-20h]\n  unsigned int v15; // [rsp+28h] [rbp-8h]\n  char v16; // [rsp+2Eh] [rbp-2h]\n  char v17; // [rsp+2Fh] [rbp-1h]\n\n  v14 = a2;\n  v17 = a3 & 0x80;\n  v16 = HIBYTE(a3);\n  v13 = a3 & 0x7F;\n  while ( 1 )\n  {\n    v15 = (*(__int64 (__fastcall **)(__int64))(v14 + 24))(v14);\n    if ( v15 == -1 )\n    {\n      sub_47FF13(v13, a2, v3, v4, v5, v6);\n      return 0LL;\n    }\n    if ( v13 == v15 || v15 == v16 )\n    {\n      if ( !v17 )\n        return v15;\n      if ( v13 == (*(unsigned int (__fastcall **)(__int64))(v14 + 32))(v14) )\n        break;\n    }\n    a2 = v15;\n    sub_481463(a1, v15);\n    switch ( v15 )\n    {\n      case '(':\n      case '{':\n        if ( v15 == 40 )\n          v8 = 41;\n        else\n          v8 = 125;\n        v15 = v8;\n        if ( !(unsigned int)sub_4832A5(a1, v14, v8) )\n          return 0LL;\n        goto LABEL_28;\n      case '\\'':\n        if ( !(unsigned int)sub_4830D3(a1, v14) )\n          return 0LL;\n        goto LABEL_28;\n      case '\"':\n        if ( !(unsigned int)sub_483130(a1, v14) )\n          return 0LL;\n        goto LABEL_28;\n      case '`':\n        if ( !(unsigned int)sub_4831F9(a1, v14, 0) )\n          return 0LL;\n        goto LABEL_28;\n      case '\\\\':\n        v15 = (*(__int64 (__fastcall **)(__int64))(v14 + 24))(v14);\n        if ( v15 == -1 )\n        {\n          sub_47FF13(41, a2, v9, v10, v11, v12);\n          return 0LL;\n        }\nLABEL_28:\n        a2 = v15;\n        sub_481463(a1, v15);\n        break;\n    }\n  }\n  (*(void (__fastcall **)(__int64))(v14 + 24))(v14);\n  return v15;\n}\n",
        "baseline_code_debug": "int __cdecl add_till_closing_bracket(o_string_0 *dest, in_str *input, unsigned int end_ch)\n{\n  unsigned int v4; // eax\n  unsigned int end_cha; // [rsp+Ch] [rbp-24h]\n  int ch_0; // [rsp+28h] [rbp-8h]\n  char end_char2; // [rsp+2Eh] [rbp-2h]\n  char dbl; // [rsp+2Fh] [rbp-1h]\n\n  dbl = end_ch & 0x80;\n  end_char2 = BYTE1(end_ch);\n  end_cha = end_ch & 0x7F;\n  while ( 1 )\n  {\n    ch_0 = input->get(input);\n    if ( ch_0 == -1 )\n    {\n      syntax_error_unterm_ch(end_cha);\n      return 0;\n    }\n    if ( end_cha == ch_0 || ch_0 == end_char2 )\n    {\n      if ( !dbl )\n        return ch_0;\n      if ( end_cha == input->peek(input) )\n        break;\n    }\n    o_addchr(dest, ch_0);\n    switch ( ch_0 )\n    {\n      case '(':\n      case '{':\n        if ( ch_0 == 40 )\n          v4 = 41;\n        else\n          v4 = 125;\n        ch_0 = v4;\n        if ( !add_till_closing_bracket(dest, input, v4) )\n          return 0;\n        goto LABEL_28;\n      case '\\'':\n        if ( !add_till_single_quote(dest, input) )\n          return 0;\n        goto LABEL_28;\n      case '\"':\n        if ( !add_till_double_quote(dest, input) )\n          return 0;\n        goto LABEL_28;\n      case '`':\n        if ( !add_till_backquote(dest, input, 0) )\n          return 0;\n        goto LABEL_28;\n      case '\\\\':\n        ch_0 = input->get(input);\n        if ( ch_0 == -1 )\n        {\n          syntax_error_unterm_ch(41);\n          return 0;\n        }\nLABEL_28:\n        o_addchr(dest, ch_0);\n        break;\n    }\n  }\n  input->get(input);\n  return ch_0;\n}\n",
        "similarity_score_unixcoder": 0.06558618694543839,
        "similarity_score_baseline_stripped": 0.5851776003837585,
        "similarity_score_baseline_debug": 0.9221171140670776
    },
    {
        "func_name": "procnetdev_version",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00436DA9 | 55 | push    rbp\n0x00436DAA | 48 89 E5 | mov     rbp, rsp\n0x00436DAD | 48 83 EC 10 | sub     rsp, 10h\n0x00436DB1 | 48 89 7D F8 | mov     [rbp+haystack], rdi\n0x00436DB5 | 48 8B 45 F8 | mov     rax, [rbp+haystack]\n0x00436DB9 | BE 58 97 51 00 | mov     esi, offset aCompressed; \"compressed\"\n0x00436DBE | 48 89 C7 | mov     rdi, rax; haystack\n0x00436DC1 | E8 FA 0E FD FF | call    _strstr\n0x00436DC6 | 48 85 C0 | test    rax, rax\n0x00436DC9 | 74 07 | jz      short loc_436DD2\n0x00436DCB | B8 02 00 00 00 | mov     eax, 2\n0x00436DD0 | EB 22 | jmp     short locret_436DF4\n0x00436DD2 | 48 8B 45 F8 | mov     rax, [rbp+haystack]\n0x00436DD6 | BE 63 97 51 00 | mov     esi, offset aBytes_0; \"bytes\"\n0x00436DDB | 48 89 C7 | mov     rdi, rax; haystack\n0x00436DDE | E8 DD 0E FD FF | call    _strstr\n0x00436DE3 | 48 85 C0 | test    rax, rax\n0x00436DE6 | 74 07 | jz      short loc_436DEF\n0x00436DE8 | B8 01 00 00 00 | mov     eax, 1\n0x00436DED | EB 05 | jmp     short locret_436DF4\n0x00436DEF | B8 00 00 00 00 | mov     eax, 0\n0x00436DF4 | C9 | leave\n0x00436DF5 | C3 | retn",
        "output": "",
        "source_code": "static int procnetdev_version(char *buf)\n{\n\tif (strstr(buf, \"compressed\"))\n\t\treturn 2;\n\tif (strstr(buf, \"bytes\"))\n\t\treturn 1;\n\treturn 0;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_436DA9(const char *a1)\n{\n  if ( strstr(a1, \"compressed\") )\n    return 2LL;\n  else\n    return strstr(a1, \"bytes\") != 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl procnetdev_version(char *buf)\n{\n  if ( strstr(buf, \"compressed\") )\n    return 2;\n  else\n    return strstr(buf, \"bytes\") != 0LL;\n}\n",
        "similarity_score_unixcoder": 0.0808802992105484,
        "similarity_score_baseline_stripped": 0.6556093096733093,
        "similarity_score_baseline_debug": 0.8193730115890503
    },
    {
        "func_name": "xsetenv_proto",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00440C5D | 55 | push    rbp\n0x00440C5E | 48 89 E5 | mov     rbp, rsp\n0x00440C61 | 48 83 EC 30 | sub     rsp, 30h\n0x00440C65 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00440C69 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00440C6D | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x00440C71 | 48 8B 4D D8 | mov     rcx, [rbp+var_28]\n0x00440C75 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00440C79 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00440C7D | 48 89 C6 | mov     rsi, rax\n0x00440C80 | BF 4E BA 52 00 | mov     edi, offset aSSS_2; \"%s%s=%s\"\n0x00440C85 | B8 00 00 00 00 | mov     eax, 0\n0x00440C8A | E8 24 9A FC FF | call    sub_40A6B3\n0x00440C8F | 48 89 45 F8 | mov     [rbp+string], rax\n0x00440C93 | BA F8 B3 75 00 | mov     edx, offset dest\n0x00440C98 | 48 8B 42 18 | mov     rax, [rdx+18h]\n0x00440C9C | 48 8D 48 08 | lea     rcx, [rax+8]\n0x00440CA0 | 48 89 4A 18 | mov     [rdx+18h], rcx\n0x00440CA4 | 48 8B 55 F8 | mov     rdx, [rbp+string]\n0x00440CA8 | 48 89 10 | mov     [rax], rdx\n0x00440CAB | 48 8B 45 F8 | mov     rax, [rbp+string]\n0x00440CAF | 48 89 C7 | mov     rdi, rax; string\n0x00440CB2 | E8 59 63 FC FF | call    _putenv\n0x00440CB7 | 90 | nop\n0x00440CB8 | C9 | leave\n0x00440CB9 | C3 | retn",
        "output": "",
        "source_code": "static void xsetenv_proto(const char *proto, const char *n, const char *v)\n{\n\tchar *var = xasprintf(\"%s%s=%s\", proto, n, v);\n\t*env_cur++ = var;\n\tputenv(var);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "int __fastcall sub_440C5D(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  char **v6; // rax\n  char *string; // [rsp+28h] [rbp-8h]\n\n  string = sub_40A6B3(\"%s%s=%s\", a1, a2, a3, a5, a6);\n  v6 = *(char ***)&dest.c_cc[7];\n  *(_QWORD *)&dest.c_cc[7] = v6 + 1;\n  *v6 = string;\n  return putenv(string);\n}\n",
        "baseline_code_debug": "void __cdecl xsetenv_proto(const char *proto, const char *n, const char *v)\n{\n  char **v3; // rax\n  char *var; // [rsp+28h] [rbp-8h]\n\n  var = xasprintf(\"%s%s=%s\", proto, n, v);\n  v3 = *(char ***)&bb_common_bufsiz1.c_cc[7];\n  *(_QWORD *)&bb_common_bufsiz1.c_cc[7] = v3 + 1;\n  *v3 = var;\n  putenv(var);\n}\n",
        "similarity_score_unixcoder": 0.08381744474172592,
        "similarity_score_baseline_stripped": 0.5559948086738586,
        "similarity_score_baseline_debug": 0.7900841236114502
    },
    {
        "func_name": "clearredir",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00473AA2 | 55 | push    rbp\n0x00473AA3 | 48 89 E5 | mov     rbp, rsp\n0x00473AA6 | 48 83 EC 10 | sub     rsp, 10h\n0x00473AAA | 89 7D FC | mov     [rbp+var_4], edi\n0x00473AAD | 48 8B 05 6C 99 2E 00 | mov     rax, cs:qword_75D420\n0x00473AB4 | C7 40 20 00 00 00 00 | mov     dword ptr [rax+20h], 0\n0x00473ABB | 48 8B 05 5E 99 2E 00 | mov     rax, cs:qword_75D420\n0x00473AC2 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x00473AC6 | 48 85 C0 | test    rax, rax\n0x00473AC9 | 74 11 | jz      short loc_473ADC\n0x00473ACB | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00473ACE | BE 00 00 00 00 | mov     esi, 0\n0x00473AD3 | 89 C7 | mov     edi, eax\n0x00473AD5 | E8 99 FE FF FF | call    sub_473973\n0x00473ADA | EB D1 | jmp     short loc_473AAD\n0x00473ADC | 90 | nop\n0x00473ADD | 90 | nop\n0x00473ADE | C9 | leave\n0x00473ADF | C3 | retn",
        "output": "",
        "source_code": "static void\nclearredir(int drop)\n{\n\tfor (;;) {\n\t\tg_nullredirs = 0;\n\t\tif (!redirlist)\n\t\t\tbreak;\n\t\tpopredir(drop, /*restore:*/ 0);\n\t}\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_473AA2(int a1)\n{\n  __int64 result; // rax\n\n  while ( 1 )\n  {\n    *(_DWORD *)(qword_75D420 + 32) = 0;\n    result = *(_QWORD *)(qword_75D420 + 24);\n    if ( !result )\n      break;\n    sub_473973(a1, 0LL);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl clearredir(int drop)\n{\n  while ( 1 )\n  {\n    ash_ptr_to_globals_var->g_nullredirs = 0;\n    if ( !ash_ptr_to_globals_var->redirlist )\n      break;\n    popredir(drop, 0);\n  }\n}\n",
        "similarity_score_unixcoder": 0.16196981072425842,
        "similarity_score_baseline_stripped": 0.38169553875923157,
        "similarity_score_baseline_debug": 0.8097824454307556
    },
    {
        "func_name": "minix_clrbit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00495E73 | 55 | push    rbp\n0x00495E74 | 48 89 E5 | mov     rbp, rsp\n0x00495E77 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00495E7B | 89 75 F4 | mov     [rbp+var_C], esi\n0x00495E7E | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00495E81 | C1 E8 03 | shr     eax, 3\n0x00495E84 | 89 C6 | mov     esi, eax\n0x00495E86 | 89 F2 | mov     edx, esi\n0x00495E88 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00495E8C | 48 01 D0 | add     rax, rdx\n0x00495E8F | 0F B6 10 | movzx   edx, byte ptr [rax]\n0x00495E92 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00495E95 | 83 E0 07 | and     eax, 7\n0x00495E98 | BF 01 00 00 00 | mov     edi, 1\n0x00495E9D | 89 C1 | mov     ecx, eax\n0x00495E9F | D3 E7 | shl     edi, cl\n0x00495EA1 | 89 F8 | mov     eax, edi\n0x00495EA3 | F7 D0 | not     eax\n0x00495EA5 | 89 C1 | mov     ecx, eax\n0x00495EA7 | 89 F6 | mov     esi, esi\n0x00495EA9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00495EAD | 48 01 F0 | add     rax, rsi\n0x00495EB0 | 21 CA | and     edx, ecx\n0x00495EB2 | 88 10 | mov     [rax], dl\n0x00495EB4 | 48 8B 05 4D 75 2C 00 | mov     rax, cs:qword_75D408\n0x00495EBB | C6 40 01 01 | mov     byte ptr [rax+1], 1\n0x00495EBF | 90 | nop\n0x00495EC0 | 5D | pop     rbp\n0x00495EC1 | C3 | retn",
        "output": "",
        "source_code": "static void minix_clrbit(char *a, unsigned i)\n{\n\tclrbit(a, i);\n\tchanged = 1;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "void *__fastcall sub_495E73(__int64 a1, unsigned int a2)\n{\n  void *result; // rax\n\n  *(_BYTE *)((a2 >> 3) + a1) &= ~(1 << (a2 & 7));\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 1) = 1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl minix_clrbit(char *a, unsigned int i)\n{\n  a[i >> 3] &= ~(1 << (i & 7));\n  BYTE1(ptr_to_globals->timeout) = 1;\n}\n",
        "similarity_score_unixcoder": 0.11464439332485199,
        "similarity_score_baseline_stripped": 0.49454984068870544,
        "similarity_score_baseline_debug": 0.7167501449584961
    },
    {
        "func_name": "do_load",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C3C8E | 55 | push    rbp\n0x004C3C8F | 48 89 E5 | mov     rbp, rsp\n0x004C3C92 | 48 83 EC 50 | sub     rsp, 50h\n0x004C3C96 | 89 7D CC | mov     [rbp+var_34], edi\n0x004C3C99 | 48 89 75 C0 | mov     [rbp+var_40], rsi\n0x004C3C9D | 48 89 55 B8 | mov     [rbp+var_48], rdx\n0x004C3CA1 | C7 45 F8 08 00 00 00 | mov     [rbp+var_8], 8\n0x004C3CA8 | C7 45 F0 00 01 00 00 | mov     [rbp+var_10], 100h\n0x004C3CAF | C7 45 EC 00 00 00 00 | mov     [rbp+var_14], 0\n0x004C3CB6 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3CBA | 48 89 45 E0 | mov     [rbp+var_20], rax\n0x004C3CBE | 48 83 7D B8 03 | cmp     [rbp+var_48], 3\n0x004C3CC3 | 0F 86 82 00 00 00 | jbe     loc_4C3D4B\n0x004C3CC9 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3CCD | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004C3CD0 | 3C 36 | cmp     al, 36h ; '6'\n0x004C3CD2 | 75 77 | jnz     short loc_4C3D4B\n0x004C3CD4 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3CD8 | 0F B6 40 01 | movzx   eax, byte ptr [rax+1]\n0x004C3CDC | 3C 04 | cmp     al, 4\n0x004C3CDE | 75 6B | jnz     short loc_4C3D4B\n0x004C3CE0 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3CE4 | 0F B6 40 02 | movzx   eax, byte ptr [rax+2]\n0x004C3CE8 | 3C 05 | cmp     al, 5\n0x004C3CEA | 76 0F | jbe     short loc_4C3CFB\n0x004C3CEC | BF D3 1A 53 00 | mov     edi, offset aUnsupportedPsf; \"unsupported psf file mode\"\n0x004C3CF1 | B8 00 00 00 00 | mov     eax, 0\n0x004C3CF6 | E8 A3 59 F4 FF | call    sub_40969E\n0x004C3CFB | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3CFF | 0F B6 40 02 | movzx   eax, byte ptr [rax+2]\n0x004C3D03 | 0F B6 C0 | movzx   eax, al\n0x004C3D06 | 83 E0 01 | and     eax, 1\n0x004C3D09 | 85 C0 | test    eax, eax\n0x004C3D0B | 74 07 | jz      short loc_4C3D14\n0x004C3D0D | C7 45 F0 00 02 00 00 | mov     [rbp+var_10], 200h\n0x004C3D14 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3D18 | 0F B6 40 02 | movzx   eax, byte ptr [rax+2]\n0x004C3D1C | 0F B6 C0 | movzx   eax, al\n0x004C3D1F | 83 E0 02 | and     eax, 2\n0x004C3D22 | 85 C0 | test    eax, eax\n0x004C3D24 | 74 07 | jz      short loc_4C3D2D\n0x004C3D26 | C7 45 EC 01 00 00 00 | mov     [rbp+var_14], 1\n0x004C3D2D | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3D31 | 0F B6 40 03 | movzx   eax, byte ptr [rax+3]\n0x004C3D35 | 0F B6 C0 | movzx   eax, al\n0x004C3D38 | 89 45 F4 | mov     [rbp+var_C], eax\n0x004C3D3B | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x004C3D3E | 89 45 FC | mov     [rbp+var_4], eax\n0x004C3D41 | 48 83 45 E0 04 | add     [rbp+var_20], 4\n0x004C3D46 | E9 F0 00 00 00 | jmp     loc_4C3E3B\n0x004C3D4B | 48 83 7D B8 1F | cmp     [rbp+var_48], 1Fh\n0x004C3D50 | 0F 86 99 00 00 00 | jbe     loc_4C3DEF\n0x004C3D56 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3D5A | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004C3D5D | 3C 72 | cmp     al, 72h ; 'r'\n0x004C3D5F | 0F 85 8A 00 00 00 | jnz     loc_4C3DEF\n0x004C3D65 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3D69 | 0F B6 40 01 | movzx   eax, byte ptr [rax+1]\n0x004C3D6D | 3C B5 | cmp     al, 0B5h\n0x004C3D6F | 75 7E | jnz     short loc_4C3DEF\n0x004C3D71 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3D75 | 0F B6 40 02 | movzx   eax, byte ptr [rax+2]\n0x004C3D79 | 3C 4A | cmp     al, 4Ah ; 'J'\n0x004C3D7B | 75 72 | jnz     short loc_4C3DEF\n0x004C3D7D | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3D81 | 0F B6 40 03 | movzx   eax, byte ptr [rax+3]\n0x004C3D85 | 3C 86 | cmp     al, 86h\n0x004C3D87 | 75 66 | jnz     short loc_4C3DEF\n0x004C3D89 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3D8D | 8B 40 04 | mov     eax, [rax+4]\n0x004C3D90 | 85 C0 | test    eax, eax\n0x004C3D92 | 74 0F | jz      short loc_4C3DA3\n0x004C3D94 | BF ED 1A 53 00 | mov     edi, offset aUnsupportedPsf_0; \"unsupported psf file version\"\n0x004C3D99 | B8 00 00 00 00 | mov     eax, 0\n0x004C3D9E | E8 FB 58 F4 FF | call    sub_40969E\n0x004C3DA3 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3DA7 | 8B 40 10 | mov     eax, [rax+10h]\n0x004C3DAA | 89 45 F0 | mov     [rbp+var_10], eax\n0x004C3DAD | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3DB1 | 8B 40 0C | mov     eax, [rax+0Ch]\n0x004C3DB4 | 83 E0 01 | and     eax, 1\n0x004C3DB7 | 85 C0 | test    eax, eax\n0x004C3DB9 | 74 07 | jz      short loc_4C3DC2\n0x004C3DBB | C7 45 EC 02 00 00 00 | mov     [rbp+var_14], 2\n0x004C3DC2 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3DC6 | 8B 40 14 | mov     eax, [rax+14h]\n0x004C3DC9 | 89 45 F4 | mov     [rbp+var_C], eax\n0x004C3DCC | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3DD0 | 8B 40 18 | mov     eax, [rax+18h]\n0x004C3DD3 | 89 45 FC | mov     [rbp+var_4], eax\n0x004C3DD6 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3DDA | 8B 40 1C | mov     eax, [rax+1Ch]\n0x004C3DDD | 89 45 F8 | mov     [rbp+var_8], eax\n0x004C3DE0 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3DE4 | 8B 40 08 | mov     eax, [rax+8]\n0x004C3DE7 | 89 C0 | mov     eax, eax\n0x004C3DE9 | 48 01 45 E0 | add     [rbp+var_20], rax\n0x004C3DED | EB 4C | jmp     short loc_4C3E3B\n0x004C3DEF | 48 81 7D B8 34 26 00 00 | cmp     [rbp+var_48], 2634h\n0x004C3DF7 | 75 14 | jnz     short loc_4C3E0D\n0x004C3DF9 | C7 45 FC 10 00 00 00 | mov     [rbp+var_4], 10h\n0x004C3E00 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004C3E03 | 89 45 F4 | mov     [rbp+var_C], eax\n0x004C3E06 | 48 83 45 E0 28 | add     [rbp+var_20], 28h ; '('\n0x004C3E0B | EB 2E | jmp     short loc_4C3E3B\n0x004C3E0D | 48 8B 45 B8 | mov     rax, [rbp+var_48]\n0x004C3E11 | 0F B6 C0 | movzx   eax, al\n0x004C3E14 | 48 85 C0 | test    rax, rax\n0x004C3E17 | 75 13 | jnz     short loc_4C3E2C\n0x004C3E19 | 48 8B 45 B8 | mov     rax, [rbp+var_48]\n0x004C3E1D | 48 C1 E8 08 | shr     rax, 8\n0x004C3E21 | 89 45 FC | mov     [rbp+var_4], eax\n0x004C3E24 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004C3E27 | 89 45 F4 | mov     [rbp+var_C], eax\n0x004C3E2A | EB 0F | jmp     short loc_4C3E3B\n0x004C3E2C | BF 10 1B 53 00 | mov     edi, offset aInputFileBadLe; \"input file: bad length or unsupported f\"...\n0x004C3E31 | B8 00 00 00 00 | mov     eax, 0\n0x004C3E36 | E8 63 58 F4 FF | call    sub_40969E\n0x004C3E3B | 8B 45 F0 | mov     eax, [rbp+var_10]\n0x004C3E3E | 0F AF 45 F4 | imul    eax, [rbp+var_C]\n0x004C3E42 | 48 63 D0 | movsxd  rdx, eax\n0x004C3E45 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004C3E49 | 48 01 D0 | add     rax, rdx\n0x004C3E4C | 48 89 45 D8 | mov     [rbp+var_28], rax\n0x004C3E50 | 48 8B 45 B8 | mov     rax, [rbp+var_48]\n0x004C3E54 | 48 01 45 C0 | add     [rbp+var_40], rax\n0x004C3E58 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004C3E5C | 48 3B 45 C0 | cmp     rax, [rbp+var_40]\n0x004C3E60 | 77 10 | ja      short loc_4C3E72\n0x004C3E62 | 83 7D EC 00 | cmp     [rbp+var_14], 0\n0x004C3E66 | 75 19 | jnz     short loc_4C3E81\n0x004C3E68 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004C3E6C | 48 3B 45 C0 | cmp     rax, [rbp+var_40]\n0x004C3E70 | 74 0F | jz      short loc_4C3E81\n0x004C3E72 | BF 40 1B 53 00 | mov     edi, offset aInputFileBadLe_0; \"input file: bad length\"\n0x004C3E77 | B8 00 00 00 00 | mov     eax, 0\n0x004C3E7C | E8 1D 58 F4 FF | call    sub_40969E\n0x004C3E81 | 44 8B 45 F0 | mov     r8d, [rbp+var_10]\n0x004C3E85 | 8B 7D F4 | mov     edi, [rbp+var_C]\n0x004C3E88 | 8B 4D F8 | mov     ecx, [rbp+var_8]\n0x004C3E8B | 8B 55 FC | mov     edx, [rbp+var_4]\n0x004C3E8E | 48 8B 75 E0 | mov     rsi, [rbp+var_20]\n0x004C3E92 | 8B 45 CC | mov     eax, [rbp+var_34]\n0x004C3E95 | 45 89 C1 | mov     r9d, r8d\n0x004C3E98 | 41 89 F8 | mov     r8d, edi\n0x004C3E9B | 89 C7 | mov     edi, eax\n0x004C3E9D | E8 7E FA FF FF | call    sub_4C3920\n0x004C3EA2 | 83 7D EC 00 | cmp     [rbp+var_14], 0\n0x004C3EA6 | 74 28 | jz      short loc_4C3ED0\n0x004C3EA8 | 8B 45 EC | mov     eax, [rbp+var_14]\n0x004C3EAB | 8D 48 FF | lea     ecx, [rax-1]\n0x004C3EAE | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004C3EB2 | 48 2B 45 D8 | sub     rax, [rbp+var_28]\n0x004C3EB6 | 89 C7 | mov     edi, eax\n0x004C3EB8 | 8B 55 F0 | mov     edx, [rbp+var_10]\n0x004C3EBB | 48 8B 75 D8 | mov     rsi, [rbp+var_28]\n0x004C3EBF | 8B 45 CC | mov     eax, [rbp+var_34]\n0x004C3EC2 | 41 89 C8 | mov     r8d, ecx\n0x004C3EC5 | 89 D1 | mov     ecx, edx\n0x004C3EC7 | 89 FA | mov     edx, edi\n0x004C3EC9 | 89 C7 | mov     edi, eax\n0x004C3ECB | E8 6C FB FF FF | call    sub_4C3A3C\n0x004C3ED0 | 90 | nop\n0x004C3ED1 | C9 | leave\n0x004C3ED2 | C3 | retn",
        "output": "",
        "source_code": "static void do_load(int fd, unsigned char *buffer, size_t len)\n{\n\tint height;\n\tint width = 8;\n\tint charsize;\n\tint fontsize = 256;\n\tint has_table = 0;\n\tunsigned char *font = buffer;\n\tunsigned char *table;\n\n\tif (len >= sizeof(struct psf1_header) && PSF1_MAGIC_OK(psf1h(buffer))) {\n\t\tif (psf1h(buffer)->mode > PSF1_MAXMODE)\n\t\t\tbb_error_msg_and_die(\"unsupported psf file mode\");\n\t\tif (psf1h(buffer)->mode & PSF1_MODE512)\n\t\t\tfontsize = 512;\n\t\tif (psf1h(buffer)->mode & PSF1_MODEHASTAB)\n\t\t\thas_table = 1;\n\t\theight = charsize = psf1h(buffer)->charsize;\n\t\tfont += sizeof(struct psf1_header);\n\t} else\n#if ENABLE_FEATURE_LOADFONT_PSF2\n\tif (len >= sizeof(struct psf2_header) && PSF2_MAGIC_OK(psf2h(buffer))) {\n\t\tif (psf2h(buffer)->version > PSF2_MAXVERSION)\n\t\t\tbb_error_msg_and_die(\"unsupported psf file version\");\n\t\tfontsize = psf2h(buffer)->length;\n\t\tif (psf2h(buffer)->flags & PSF2_HAS_UNICODE_TABLE)\n\t\t\thas_table = 2;\n\t\tcharsize = psf2h(buffer)->charsize;\n\t\theight = psf2h(buffer)->height;\n\t\twidth = psf2h(buffer)->width;\n\t\tfont += psf2h(buffer)->headersize;\n\t} else\n#endif\n#if ENABLE_FEATURE_LOADFONT_RAW\n\tif (len == 9780) {  /* file with three code pages? */\n\t\tcharsize = height = 16;\n\t\tfont += 40;\n\t} else if ((len & 0377) == 0) {  /* bare font */\n\t\tcharsize = height = len / 256;\n\t} else\n#endif\n\t{\n\t\tbb_error_msg_and_die(\"input file: bad length or unsupported font type\");\n\t}\n\n#if !defined(PIO_FONTX) || defined(__sparc__)\n\tif (fontsize != 256)\n\t\tbb_error_msg_and_die(\"only fontsize 256 supported\");\n#endif\n\n\ttable = font + fontsize * charsize;\n\tbuffer += len;\n\n\tif (table > buffer || (!has_table && table != buffer))\n\t\tbb_error_msg_and_die(\"input file: bad length\");\n\n\tdo_loadfont(fd, font, height, width, charsize, fontsize);\n\n\tif (has_table)\n\t\tdo_loadtable(fd, table, buffer - table, fontsize, has_table - 1);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "void __fastcall sub_4C3C8E(int a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  unsigned __int64 v8; // [rsp+10h] [rbp-40h]\n  __int64 v9; // [rsp+28h] [rbp-28h]\n  __int64 v10; // [rsp+30h] [rbp-20h]\n  int v11; // [rsp+3Ch] [rbp-14h]\n  unsigned int v12; // [rsp+40h] [rbp-10h]\n  unsigned int v13; // [rsp+44h] [rbp-Ch]\n  unsigned int v14; // [rsp+48h] [rbp-8h]\n  int v15; // [rsp+4Ch] [rbp-4h]\n\n  v14 = 8;\n  v12 = 256;\n  v11 = 0;\n  v10 = a2;\n  if ( a3 > 3 && *(_BYTE *)a2 == 54 && *(_BYTE *)(a2 + 1) == 4 )\n  {\n    if ( *(_BYTE *)(a2 + 2) > 5u )\n      sub_40969E(\"unsupported psf file mode\", a2, a3, a4, a5, a6);\n    if ( (*(_BYTE *)(a2 + 2) & 1) != 0 )\n      v12 = 512;\n    if ( (*(_BYTE *)(a2 + 2) & 2) != 0 )\n      v11 = 1;\n    v13 = *(unsigned __int8 *)(a2 + 3);\n    v15 = v13;\n    v10 = a2 + 4;\n  }\n  else if ( a3 > 0x1F\n         && *(_BYTE *)a2 == 114\n         && *(_BYTE *)(a2 + 1) == 0xB5\n         && *(_BYTE *)(a2 + 2) == 74\n         && *(_BYTE *)(a2 + 3) == 0x86 )\n  {\n    if ( *(_DWORD *)(a2 + 4) )\n      sub_40969E(\"unsupported psf file version\", a2, a3, a4, a5, a6);\n    v12 = *(_DWORD *)(a2 + 16);\n    if ( (*(_DWORD *)(a2 + 12) & 1) != 0 )\n      v11 = 2;\n    v13 = *(_DWORD *)(a2 + 20);\n    v15 = *(_DWORD *)(a2 + 24);\n    v14 = *(_DWORD *)(a2 + 28);\n    v10 = *(unsigned int *)(a2 + 8) + a2;\n  }\n  else if ( a3 == 9780 )\n  {\n    v15 = 16;\n    v13 = 16;\n    v10 = a2 + 40;\n  }\n  else\n  {\n    if ( (_BYTE)a3 )\n      sub_40969E(\"input file: bad length or unsupported font type\", a2, a3, a4, a5, a6);\n    v15 = a3 >> 8;\n    v13 = v15;\n  }\n  v6 = (int)(v13 * v12);\n  v9 = v6 + v10;\n  v8 = a3 + a2;\n  if ( v6 + v10 > a3 + a2 || !v11 && v9 != v8 )\n    sub_40969E(\"input file: bad length\", a2, v6, a4, a5, a6);\n  sub_4C3920(a1, v10, v15, v14, v13, v12);\n  if ( v11 )\n    sub_4C3A3C(a1, v9, v8 - v9, v12, v11 - 1);\n}\n",
        "baseline_code_debug": "void __cdecl do_load(int fd, unsigned __int8 *buffer, size_t len)\n{\n  unsigned __int8 *buffera; // [rsp+10h] [rbp-40h]\n  unsigned __int8 *table; // [rsp+28h] [rbp-28h]\n  unsigned __int8 *font; // [rsp+30h] [rbp-20h]\n  int has_table; // [rsp+3Ch] [rbp-14h]\n  int fontsize; // [rsp+40h] [rbp-10h]\n  int charsize; // [rsp+44h] [rbp-Ch]\n  int width; // [rsp+48h] [rbp-8h]\n  int height; // [rsp+4Ch] [rbp-4h]\n\n  width = 8;\n  fontsize = 256;\n  has_table = 0;\n  font = buffer;\n  if ( len > 3 && *buffer == 54 && buffer[1] == 4 )\n  {\n    if ( buffer[2] > 5u )\n      bb_error_msg_and_die(\"unsupported psf file mode\");\n    if ( (buffer[2] & 1) != 0 )\n      fontsize = 512;\n    if ( (buffer[2] & 2) != 0 )\n      has_table = 1;\n    charsize = buffer[3];\n    height = charsize;\n    font = buffer + 4;\n  }\n  else if ( len > 0x1F && *buffer == 114 && buffer[1] == 0xB5 && buffer[2] == 74 && buffer[3] == 0x86 )\n  {\n    if ( *((_DWORD *)buffer + 1) )\n      bb_error_msg_and_die(\"unsupported psf file version\");\n    fontsize = *((_DWORD *)buffer + 4);\n    if ( (*((_DWORD *)buffer + 3) & 1) != 0 )\n      has_table = 2;\n    charsize = *((_DWORD *)buffer + 5);\n    height = *((_DWORD *)buffer + 6);\n    width = *((_DWORD *)buffer + 7);\n    font = &buffer[*((unsigned int *)buffer + 2)];\n  }\n  else if ( len == 9780 )\n  {\n    height = 16;\n    charsize = 16;\n    font = buffer + 40;\n  }\n  else\n  {\n    if ( (_BYTE)len )\n      bb_error_msg_and_die(\"input file: bad length or unsupported font type\");\n    height = len >> 8;\n    charsize = height;\n  }\n  table = &font[charsize * fontsize];\n  buffera = &buffer[len];\n  if ( table > &buffer[len] || !has_table && table != buffera )\n    bb_error_msg_and_die(\"input file: bad length\");\n  do_loadfont(fd, font, height, width, charsize, fontsize);\n  if ( has_table )\n    do_loadtable(fd, table, (_DWORD)buffera - (_DWORD)table, fontsize, has_table - 1);\n}\n",
        "similarity_score_unixcoder": 0.0011793230660259724,
        "similarity_score_baseline_stripped": 0.6297453045845032,
        "similarity_score_baseline_debug": 0.90090012550354
    },
    {
        "func_name": "quote_special_chars",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004FF303 | 55 | push    rbp\n0x004FF304 | 48 89 E5 | mov     rbp, rsp\n0x004FF307 | 48 83 EC 20 | sub     rsp, 20h\n0x004FF30B | 48 89 7D E8 | mov     [rbp+s], rdi\n0x004FF30F | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x004FF316 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x004FF31A | 48 89 C7 | mov     rdi, rax; s\n0x004FF31D | E8 AE 77 F0 FF | call    _strlen\n0x004FF322 | 48 83 C0 01 | add     rax, 1\n0x004FF326 | 48 01 C0 | add     rax, rax\n0x004FF329 | 48 89 C7 | mov     rdi, rax\n0x004FF32C | E8 B7 AD F0 FF | call    sub_40A0E8\n0x004FF331 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x004FF335 | EB 50 | jmp     short loc_4FF387\n0x004FF337 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x004FF33B | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004FF33E | 0F BE C0 | movsx   eax, al\n0x004FF341 | 89 C7 | mov     edi, eax\n0x004FF343 | E8 9C FF FF FF | call    sub_4FF2E4\n0x004FF348 | 48 85 C0 | test    rax, rax\n0x004FF34B | 74 16 | jz      short loc_4FF363\n0x004FF34D | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004FF350 | 8D 50 01 | lea     edx, [rax+1]\n0x004FF353 | 89 55 FC | mov     [rbp+var_4], edx\n0x004FF356 | 48 63 D0 | movsxd  rdx, eax\n0x004FF359 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004FF35D | 48 01 D0 | add     rax, rdx\n0x004FF360 | C6 00 5C | mov     byte ptr [rax], 5Ch ; '\\'\n0x004FF363 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x004FF367 | 48 8D 50 01 | lea     rdx, [rax+1]\n0x004FF36B | 48 89 55 E8 | mov     [rbp+s], rdx\n0x004FF36F | 8B 55 FC | mov     edx, [rbp+var_4]\n0x004FF372 | 8D 4A 01 | lea     ecx, [rdx+1]\n0x004FF375 | 89 4D FC | mov     [rbp+var_4], ecx\n0x004FF378 | 48 63 CA | movsxd  rcx, edx\n0x004FF37B | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x004FF37F | 48 01 CA | add     rdx, rcx\n0x004FF382 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004FF385 | 88 02 | mov     [rdx], al\n0x004FF387 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x004FF38B | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004FF38E | 84 C0 | test    al, al\n0x004FF390 | 75 A5 | jnz     short loc_4FF337\n0x004FF392 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004FF396 | C9 | leave\n0x004FF397 | C3 | retn",
        "output": "",
        "source_code": "static char *quote_special_chars(char *found)\n{\n\tint l = 0;\n\tchar *s = xzalloc((strlen(found) + 1) * 2);\n\n\twhile (*found) {\n\t\tif (is_special_char(*found))\n\t\t\ts[l++] = '\\\\';\n\t\ts[l++] = *found++;\n\t}\n\t/* s[l] = '\\0'; - already is */\n\treturn s;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "_BYTE *__fastcall sub_4FF303(const char *a1, __int64 a2)\n{\n  size_t v2; // rax\n  int v3; // eax\n  char *v4; // rax\n  int v5; // edx\n  char *s; // [rsp+8h] [rbp-18h]\n  _BYTE *v8; // [rsp+10h] [rbp-10h]\n  int v9; // [rsp+1Ch] [rbp-4h]\n\n  s = (char *)a1;\n  v9 = 0;\n  v2 = strlen(a1);\n  v8 = sub_40A0E8(2 * (v2 + 1), a2);\n  while ( *s )\n  {\n    if ( sub_4FF2E4(*s) )\n    {\n      v3 = v9++;\n      v8[v3] = 92;\n    }\n    v4 = s++;\n    v5 = v9++;\n    v8[v5] = *v4;\n  }\n  return v8;\n}\n",
        "baseline_code_debug": "char *__cdecl quote_special_chars(char *found)\n{\n  size_t v1; // rax\n  int v2; // eax\n  char *v3; // rax\n  int v4; // edx\n  char *founda; // [rsp+8h] [rbp-18h]\n  char *s; // [rsp+10h] [rbp-10h]\n  int l; // [rsp+1Ch] [rbp-4h]\n\n  founda = found;\n  l = 0;\n  v1 = strlen(found);\n  s = (char *)xzalloc(2 * (v1 + 1));\n  while ( *founda )\n  {\n    if ( is_special_char(*founda) )\n    {\n      v2 = l++;\n      s[v2] = 92;\n    }\n    v3 = founda++;\n    v4 = l++;\n    s[v4] = *v3;\n  }\n  return s;\n}\n",
        "similarity_score_unixcoder": 0.03091125190258026,
        "similarity_score_baseline_stripped": 0.47940418124198914,
        "similarity_score_baseline_debug": 0.7070457935333252
    },
    {
        "func_name": "str2env",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004B70B6 | 55 | push    rbp\n0x004B70B7 | 48 89 E5 | mov     rbp, rsp\n0x004B70BA | 53 | push    rbx\n0x004B70BB | 48 83 EC 28 | sub     rsp, 28h\n0x004B70BF | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004B70C3 | 89 75 E4 | mov     [rbp+var_1C], esi\n0x004B70C6 | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x004B70CA | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x004B70CD | 48 98 | cdqe\n0x004B70CF | 48 8B 04 C5 A0 29 52 00 | mov     rax, ds:off_5229A0[rax*8]; \"MODE\"\n0x004B70D7 | 8B 55 E4 | mov     edx, [rbp+var_1C]\n0x004B70DA | 48 63 D2 | movsxd  rdx, edx\n0x004B70DD | 48 8D 0C D5 00 00 00 00 | lea     rcx, ds:0[rdx*8]\n0x004B70E5 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x004B70E9 | 48 8D 1C 11 | lea     rbx, [rcx+rdx]\n0x004B70ED | 48 8B 55 D8 | mov     rdx, [rbp+var_28]\n0x004B70F1 | 48 89 C6 | mov     rsi, rax\n0x004B70F4 | BF E0 29 52 00 | mov     edi, offset aTarSS; \"TAR_%s=%s\"\n0x004B70F9 | B8 00 00 00 00 | mov     eax, 0\n0x004B70FE | E8 B0 35 F5 FF | call    sub_40A6B3\n0x004B7103 | 48 89 03 | mov     [rbx], rax\n0x004B7106 | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x004B7109 | 48 98 | cdqe\n0x004B710B | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]\n0x004B7113 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004B7117 | 48 01 D0 | add     rax, rdx\n0x004B711A | 48 8B 00 | mov     rax, [rax]\n0x004B711D | 48 89 C7 | mov     rdi, rax\n0x004B7120 | E8 63 FF FF FF | call    sub_4B7088\n0x004B7125 | 90 | nop\n0x004B7126 | 48 83 C4 28 | add     rsp, 28h\n0x004B712A | 5B | pop     rbx\n0x004B712B | 5D | pop     rbp\n0x004B712C | C3 | retn",
        "output": "",
        "source_code": "static void str2env(char *env[], int idx, const char *str)\n{\n\tenv[idx] = xasprintf(\"TAR_%s=%s\", tar_var[idx], str);\n\txputenv(env[idx]);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "int __fastcall sub_4B70B6(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  unsigned __int64 v6; // rcx\n  char *v7; // rsi\n\n  v6 = 8LL * a2;\n  v7 = off_5229A0[v6 / 8];\n  *(_QWORD *)(v6 + a1) = sub_40A6B3(\"TAR_%s=%s\", (__int64)v7, a3, v6, a5, a6);\n  return sub_4B7088(*(char **)(8LL * a2 + a1), (__int64)v7);\n}\n",
        "baseline_code_debug": "void __cdecl str2env(char **env, int idx, const char *str)\n{\n  env[idx] = xasprintf(\"TAR_%s=%s\", tar_var[idx], str);\n  xputenv(env[idx]);\n}\n",
        "similarity_score_unixcoder": 0.056981392204761505,
        "similarity_score_baseline_stripped": 0.39911532402038574,
        "similarity_score_baseline_debug": 0.9627740383148193
    },
    {
        "func_name": "close_dev_fd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00490398 | 55 | push    rbp\n0x00490399 | 48 89 E5 | mov     rbp, rsp\n0x0049039C | BE 00 00 00 00 | mov     esi, 0\n0x004903A1 | BF C1 06 52 00 | mov     edi, offset aDevNull_2; \"/dev/null\"\n0x004903A6 | E8 EA 9E F7 FF | call    sub_40A295\n0x004903AB | BE 03 00 00 00 | mov     esi, 3\n0x004903B0 | 89 C7 | mov     edi, eax\n0x004903B2 | E8 C0 A0 F7 FF | call    sub_40A477\n0x004903B7 | 90 | nop\n0x004903B8 | 5D | pop     rbp\n0x004903B9 | C3 | retn",
        "output": "",
        "source_code": "static void\nclose_dev_fd(void)\n{\n\t/* Not really closing, but making sure it is open, and to harmless place */\n\txmove_fd(xopen(bb_dev_null, O_RDONLY), dev_fd);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "int sub_490398()\n{\n  int v0; // eax\n\n  v0 = sub_40A295(\"/dev/null\", 0);\n  return sub_40A477(v0, 3u);\n}\n",
        "baseline_code_debug": "void __cdecl close_dev_fd()\n{\n  int v0; // eax\n\n  v0 = xopen(\"/dev/null\", 0);\n  xmove_fd(v0, 3);\n}\n",
        "similarity_score_unixcoder": 0.10211627185344696,
        "similarity_score_baseline_stripped": 0.4572550654411316,
        "similarity_score_baseline_debug": 0.7473095059394836
    },
    {
        "func_name": "launch_helper",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00411CED | 55 | push    rbp\n0x00411CEE | 48 89 E5 | mov     rbp, rsp\n0x00411CF1 | 48 83 EC 30 | sub     rsp, 30h\n0x00411CF5 | 48 89 7D D8 | mov     [rbp+var_28], rdi\n0x00411CF9 | 48 8D 45 E0 | lea     rax, [rbp+fd]\n0x00411CFD | 48 89 C7 | mov     rdi, rax\n0x00411D00 | E8 10 87 FF FF | call    sub_40A415\n0x00411D05 | 48 8D 45 E0 | lea     rax, [rbp+fd]\n0x00411D09 | 48 83 C0 08 | add     rax, 8\n0x00411D0D | 48 89 C7 | mov     rdi, rax\n0x00411D10 | E8 00 87 FF FF | call    sub_40A415\n0x00411D15 | BE 3F 1C 41 00 | mov     esi, offset sub_411C3F\n0x00411D1A | BF 00 40 02 00 | mov     edi, 24000h\n0x00411D1F | E8 DD 64 0F 00 | call    sub_508201\n0x00411D24 | E8 87 5B FF FF | call    _vfork\n0x00411D29 | 89 45 FC | mov     [rbp+var_4], eax\n0x00411D2C | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x00411D30 | 79 0F | jns     short loc_411D41\n0x00411D32 | BF D0 53 53 00 | mov     edi, offset aVfork_0; \"vfork\"\n0x00411D37 | B8 00 00 00 00 | mov     eax, 0\n0x00411D3C | E8 61 75 FF FF | call    sub_4092A2\n0x00411D41 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x00411D44 | 48 8B 05 BD B6 34 00 | mov     rax, cs:qword_75D408\n0x00411D4B | 89 10 | mov     [rax], edx\n0x00411D4D | 48 8B 05 B4 B6 34 00 | mov     rax, cs:qword_75D408\n0x00411D54 | 8B 00 | mov     eax, [rax]\n0x00411D56 | 85 C0 | test    eax, eax\n0x00411D58 | 75 07 | jnz     short loc_411D61\n0x00411D5A | B8 02 00 00 00 | mov     eax, 2\n0x00411D5F | EB 05 | jmp     short loc_411D66\n0x00411D61 | B8 00 00 00 00 | mov     eax, 0\n0x00411D66 | 89 45 F8 | mov     [rbp+var_8], eax\n0x00411D69 | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x00411D6C | 83 C0 01 | add     eax, 1\n0x00411D6F | 48 98 | cdqe\n0x00411D71 | 8B 44 85 E0 | mov     eax, [rbp+rax*4+fd]\n0x00411D75 | 89 C7 | mov     edi, eax; fd\n0x00411D77 | E8 94 50 FF FF | call    _close\n0x00411D7C | B8 02 00 00 00 | mov     eax, 2\n0x00411D81 | 2B 45 F8 | sub     eax, [rbp+var_8]\n0x00411D84 | 48 98 | cdqe\n0x00411D86 | 8B 44 85 E0 | mov     eax, [rbp+rax*4+fd]\n0x00411D8A | 89 C7 | mov     edi, eax; fd\n0x00411D8C | E8 7F 50 FF FF | call    _close\n0x00411D91 | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x00411D94 | 48 98 | cdqe\n0x00411D96 | 8B 44 85 E0 | mov     eax, [rbp+rax*4+fd]\n0x00411D9A | BE 00 00 00 00 | mov     esi, 0\n0x00411D9F | 89 C7 | mov     edi, eax\n0x00411DA1 | E8 D1 86 FF FF | call    sub_40A477\n0x00411DA6 | B8 03 00 00 00 | mov     eax, 3\n0x00411DAB | 2B 45 F8 | sub     eax, [rbp+var_8]\n0x00411DAE | 48 98 | cdqe\n0x00411DB0 | 8B 44 85 E0 | mov     eax, [rbp+rax*4+fd]\n0x00411DB4 | BE 01 00 00 00 | mov     esi, 1\n0x00411DB9 | 89 C7 | mov     edi, eax\n0x00411DBB | E8 B7 86 FF FF | call    sub_40A477\n0x00411DC0 | 48 8B 05 41 B6 34 00 | mov     rax, cs:qword_75D408\n0x00411DC7 | 8B 00 | mov     eax, [rax]\n0x00411DC9 | 85 C0 | test    eax, eax\n0x00411DCB | 75 0C | jnz     short loc_411DD9\n0x00411DCD | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00411DD1 | 48 89 C7 | mov     rdi, rax\n0x00411DD4 | E8 44 75 0E 00 | call    sub_4F931D\n0x00411DD9 | BF 09 1C 41 00 | mov     edi, offset sub_411C09\n0x00411DDE | E8 ED 5F FF FF | call    sub_407DD0\n0x00411DE3 | 90 | nop\n0x00411DE4 | C9 | leave\n0x00411DE5 | C3 | retn",
        "output": "",
        "source_code": "void FAST_FUNC launch_helper(const char **argv)\n{\n\t// setup vanilla unidirectional pipes interchange\n\tint i;\n\tint pipes[4];\n\n\txpipe(pipes);\n\txpipe(pipes + 2);\n\n\t// NB: handler must be installed before vfork\n\tbb_signals(0\n\t\t+ (1 << SIGCHLD)\n\t\t+ (1 << SIGALRM)\n\t\t, signal_handler);\n\n\tG.helper_pid = xvfork();\n\n\ti = (!G.helper_pid) * 2; // for parent:0, for child:2\n\tclose(pipes[i + 1]);     // 1 or 3 - closing one write end\n\tclose(pipes[2 - i]);     // 2 or 0 - closing one read end\n\txmove_fd(pipes[i], STDIN_FILENO);      // 0 or 2 - using other read end\n\txmove_fd(pipes[3 - i], STDOUT_FILENO); // 3 or 1 - using other write end\n\t// End result:\n\t// parent stdout [3] -> child stdin [2]\n\t// child stdout [1] -> parent stdin [0]\n\n\tif (!G.helper_pid) {\n\t\t// child: try to execute connection helper\n\t\t// NB: SIGCHLD & SIGALRM revert to SIG_DFL on exec\n\t\tBB_EXECVP_or_die((char**)argv);\n\t}\n\n\t// parent\n\t// check whether child is alive\n\t//redundant:signal_handler(SIGCHLD);\n\t// child seems OK -> parent goes on\n\tatexit(kill_helper);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "int __fastcall sub_411CED(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  int v6; // eax\n  int fd[2]; // [rsp+10h] [rbp-20h] BYREF\n  int v9[4]; // [rsp+18h] [rbp-18h] BYREF\n  int v10; // [rsp+28h] [rbp-8h]\n  __pid_t v11; // [rsp+2Ch] [rbp-4h]\n\n  sub_40A415(fd, a2);\n  sub_40A415(v9, a2);\n  sub_508201(147456LL, sub_411C3F);\n  v11 = vfork();\n  if ( v11 < 0 )\n    sub_4092A2((__int64)\"vfork\", (__int64)sub_411C3F, v2, v3, v4, v5);\n  *(_DWORD *)qword_75D408 = v11;\n  if ( *(_DWORD *)qword_75D408 )\n    v6 = 0;\n  else\n    v6 = 2;\n  v10 = v6;\n  close(fd[v6 + 1]);\n  close(fd[2 - v10]);\n  sub_40A477(fd[v10], 0);\n  sub_40A477(fd[3 - v10], 1u);\n  if ( !*(_DWORD *)qword_75D408 )\n    sub_4F931D(a1);\n  return sub_407DD0((void (__fastcall *)(void *))sub_411C09);\n}\n",
        "baseline_code_debug": "void __cdecl launch_helper(const char **argv)\n{\n  int v1; // eax\n  int pipes[4]; // [rsp+10h] [rbp-20h] BYREF\n  int i; // [rsp+28h] [rbp-8h]\n  pid_t bb__xvfork_pid; // [rsp+2Ch] [rbp-4h]\n\n  xpipe(pipes);\n  xpipe(&pipes[2]);\n  bb_signals(147456, (void (*)(int))signal_handler);\n  bb__xvfork_pid = vfork();\n  if ( bb__xvfork_pid < 0 )\n    bb_perror_msg_and_die(\"vfork\");\n  ptr_to_globals->timeout = bb__xvfork_pid;\n  if ( ptr_to_globals->timeout )\n    v1 = 0;\n  else\n    v1 = 2;\n  i = v1;\n  close(pipes[v1 + 1]);\n  close(pipes[2 - i]);\n  xmove_fd(pipes[i], 0);\n  xmove_fd(pipes[3 - i], 1);\n  if ( !ptr_to_globals->timeout )\n    BB_EXECVP_or_die((char **)argv);\n  atexit(kill_helper);\n}\n",
        "similarity_score_unixcoder": 0.00883006863296032,
        "similarity_score_baseline_stripped": 0.6085917353630066,
        "similarity_score_baseline_debug": 0.7690134644508362
    },
    {
        "func_name": "fix_partition_table_order",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004932AD | 55 | push    rbp\n0x004932AE | 48 89 E5 | mov     rbp, rsp\n0x004932B1 | 48 83 EC 50 | sub     rsp, 50h\n0x004932B5 | BF 00 00 00 00 | mov     edi, 0\n0x004932BA | E8 44 FB FF FF | call    sub_492E03\n0x004932BF | 85 C0 | test    eax, eax\n0x004932C1 | 0F 85 F8 00 00 00 | jnz     loc_4933BF\n0x004932C7 | BF BC 13 52 00 | mov     edi, offset aOrderingIsAlre; \"Ordering is already correct\\n\"\n0x004932CC | E8 3F 35 F7 FF | call    _puts\n0x004932D1 | E9 1D 01 00 00 | jmp     locret_4933F3\n0x004932D6 | 48 8B 0D 2B A1 2C 00 | mov     rcx, cs:qword_75D408\n0x004932DD | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004932E0 | 48 63 D0 | movsxd  rdx, eax\n0x004932E3 | 48 89 D0 | mov     rax, rdx\n0x004932E6 | 48 C1 E0 02 | shl     rax, 2\n0x004932EA | 48 01 D0 | add     rax, rdx\n0x004932ED | 48 C1 E0 03 | shl     rax, 3\n0x004932F1 | 48 05 C0 09 00 00 | add     rax, 9C0h\n0x004932F7 | 48 01 C8 | add     rax, rcx\n0x004932FA | 48 83 C0 08 | add     rax, 8\n0x004932FE | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x00493302 | 48 8B 0D FF A0 2C 00 | mov     rcx, cs:qword_75D408\n0x00493309 | 8B 45 CC | mov     eax, [rbp+var_34]\n0x0049330C | 48 63 D0 | movsxd  rdx, eax\n0x0049330F | 48 89 D0 | mov     rax, rdx\n0x00493312 | 48 C1 E0 02 | shl     rax, 2\n0x00493316 | 48 01 D0 | add     rax, rdx\n0x00493319 | 48 C1 E0 03 | shl     rax, 3\n0x0049331D | 48 05 C0 09 00 00 | add     rax, 9C0h\n0x00493323 | 48 01 C8 | add     rax, rcx\n0x00493326 | 48 83 C0 08 | add     rax, 8\n0x0049332A | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x0049332E | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00493332 | 48 8B 40 08 | mov     rax, [rax+8]\n0x00493336 | 48 89 45 E0 | mov     [rbp+var_20], rax\n0x0049333A | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0049333E | 48 8B 50 08 | mov     rdx, [rax+8]\n0x00493342 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00493346 | 48 89 50 08 | mov     [rax+8], rdx\n0x0049334A | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0049334E | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00493352 | 48 89 50 08 | mov     [rax+8], rdx\n0x00493356 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0049335A | 48 8B 00 | mov     rax, [rax]\n0x0049335D | 48 89 45 D8 | mov     [rbp+var_28], rax\n0x00493361 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00493365 | 48 8B 00 | mov     rax, [rax]\n0x00493368 | 48 89 45 D0 | mov     [rbp+var_30], rax\n0x0049336C | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00493370 | 48 8B 50 08 | mov     rdx, [rax+8]\n0x00493374 | 48 8B 00 | mov     rax, [rax]\n0x00493377 | 48 89 45 B0 | mov     [rbp+var_50], rax\n0x0049337B | 48 89 55 B8 | mov     [rbp+var_48], rdx\n0x0049337F | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x00493383 | 48 8B 50 08 | mov     rdx, [rax+8]\n0x00493387 | 48 8B 00 | mov     rax, [rax]\n0x0049338A | 48 8B 4D D8 | mov     rcx, [rbp+var_28]\n0x0049338E | 48 89 01 | mov     [rcx], rax\n0x00493391 | 48 89 51 08 | mov     [rcx+8], rdx\n0x00493395 | 48 8B 45 B0 | mov     rax, [rbp+var_50]\n0x00493399 | 48 8B 55 B8 | mov     rdx, [rbp+var_48]\n0x0049339D | 48 8B 4D D0 | mov     rcx, [rbp+var_30]\n0x004933A1 | 48 89 01 | mov     [rcx], rax\n0x004933A4 | 48 89 51 08 | mov     [rcx+8], rdx\n0x004933A8 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004933AC | C6 40 20 01 | mov     byte ptr [rax+20h], 1\n0x004933B0 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004933B4 | 0F B6 50 20 | movzx   edx, byte ptr [rax+20h]\n0x004933B8 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004933BC | 88 50 20 | mov     [rax+20h], dl\n0x004933BF | 48 8D 45 CC | lea     rax, [rbp+var_34]\n0x004933C3 | 48 89 C7 | mov     rdi, rax\n0x004933C6 | E8 38 FA FF FF | call    sub_492E03\n0x004933CB | 89 45 FC | mov     [rbp+var_4], eax\n0x004933CE | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004933D2 | 74 0A | jz      short loc_4933DE\n0x004933D4 | 83 7D FC 03 | cmp     [rbp+var_4], 3\n0x004933D8 | 0F 8E F8 FE FF FF | jle     loc_4932D6\n0x004933DE | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004933E2 | 74 05 | jz      short loc_4933E9\n0x004933E4 | E8 EA FA FF FF | call    sub_492ED3\n0x004933E9 | BF D9 13 52 00 | mov     edi, offset aDone_4; \"Done.\"\n0x004933EE | E8 1D 34 F7 FF | call    _puts\n0x004933F3 | C9 | leave\n0x004933F4 | C3 | retn",
        "output": "",
        "source_code": "static void\nfix_partition_table_order(void)\n{\n\tstruct pte *pei, *pek;\n\tint i,k;\n\n\tif (!wrong_p_order(NULL)) {\n\t\tprintf(\"Ordering is already correct\\n\\n\");\n\t\treturn;\n\t}\n\n\twhile ((i = wrong_p_order(&k)) != 0 && i < 4) {\n\t\t/* partition i should have come earlier, move it */\n\t\t/* We have to move data in the MBR */\n\t\tstruct partition *pi, *pk, *pe, pbuf;\n\t\tpei = &ptes[i];\n\t\tpek = &ptes[k];\n\n\t\tpe = pei->ext_pointer;\n\t\tpei->ext_pointer = pek->ext_pointer;\n\t\tpek->ext_pointer = pe;\n\n\t\tpi = pei->part_table;\n\t\tpk = pek->part_table;\n\n\t\tmemmove(&pbuf, pi, sizeof(struct partition));\n\t\tmemmove(pi, pk, sizeof(struct partition));\n\t\tmemmove(pk, &pbuf, sizeof(struct partition));\n\n\t\tpei->changed = pek->changed = 1;\n\t}\n\n\tif (i)\n\t\tfix_chain_of_logicals();\n\n\tprintf(\"Done.\\n\");\n}",
        "parsed_output": "",
        "baseline_code_stripped": "int sub_4932AD()\n{\n  char *v1; // rax\n  __int64 v2; // rdx\n  _QWORD *v3; // rcx\n  _QWORD *v4; // rcx\n  __int64 v5; // [rsp+0h] [rbp-50h]\n  __int64 v6; // [rsp+8h] [rbp-48h]\n  int v7; // [rsp+1Ch] [rbp-34h] BYREF\n  _QWORD *v8; // [rsp+20h] [rbp-30h]\n  _QWORD *v9; // [rsp+28h] [rbp-28h]\n  __int64 v10; // [rsp+30h] [rbp-20h]\n  char *v11; // [rsp+38h] [rbp-18h]\n  __int64 v12; // [rsp+40h] [rbp-10h]\n  int v13; // [rsp+4Ch] [rbp-4h]\n\n  if ( !(unsigned int)sub_492E03(0LL) )\n    return puts(\"Ordering is already correct\\n\");\n  while ( 1 )\n  {\n    v13 = sub_492E03(&v7);\n    if ( !v13 || v13 > 3 )\n      break;\n    v12 = (__int64)qword_75D408 + 40 * v13 + 2504;\n    v1 = (char *)qword_75D408 + 40 * v7 + 2496;\n    v11 = v1 + 8;\n    v10 = *((_QWORD *)qword_75D408 + 5 * v13 + 314);\n    *((_QWORD *)qword_75D408 + 5 * v13 + 314) = *((_QWORD *)v1 + 2);\n    *((_QWORD *)v11 + 1) = v10;\n    v9 = *(_QWORD **)v12;\n    v8 = *(_QWORD **)v11;\n    v5 = *v9;\n    v6 = v9[1];\n    v2 = v8[1];\n    v3 = v9;\n    *v9 = *v8;\n    v3[1] = v2;\n    v4 = v8;\n    *v8 = v5;\n    v4[1] = v6;\n    v11[32] = 1;\n    *(_BYTE *)(v12 + 32) = v11[32];\n  }\n  if ( v13 )\n    sub_492ED3();\n  return puts(\"Done.\");\n}\n",
        "baseline_code_debug": "void __cdecl fix_partition_table_order()\n{\n  char *v0; // rax\n  __int64 v1; // rdx\n  partition *v2; // rcx\n  partition pbuf; // [rsp+0h] [rbp-50h]\n  int k; // [rsp+1Ch] [rbp-34h] BYREF\n  partition *pk; // [rsp+20h] [rbp-30h]\n  partition *pi; // [rsp+28h] [rbp-28h]\n  partition *pe; // [rsp+30h] [rbp-20h]\n  pte *pek; // [rsp+38h] [rbp-18h]\n  pte *pei; // [rsp+40h] [rbp-10h]\n  int i; // [rsp+4Ch] [rbp-4h]\n\n  if ( wrong_p_order(0LL) )\n  {\n    while ( 1 )\n    {\n      i = wrong_p_order(&k);\n      if ( !i || i > 3 )\n        break;\n      pei = (pte *)&ptr_to_globals[8].line_buf[40 * i + 44];\n      v0 = &ptr_to_globals[8].line_buf[40 * k + 36];\n      pek = (pte *)(v0 + 8);\n      pe = *(partition **)&ptr_to_globals[8].line_buf[40 * i + 52];\n      *(_QWORD *)&ptr_to_globals[8].line_buf[40 * i + 52] = *((_QWORD *)v0 + 2);\n      pek->ext_pointer = pe;\n      pi = pei->part_table;\n      pk = pek->part_table;\n      pbuf = *pi;\n      v1 = *(_QWORD *)pk->start4;\n      v2 = pi;\n      *(_QWORD *)&pi->boot_ind = *(_QWORD *)&pk->boot_ind;\n      *(_QWORD *)v2->start4 = v1;\n      *pk = pbuf;\n      pek->changed = 1;\n      pei->changed = pek->changed;\n    }\n    if ( i )\n      fix_chain_of_logicals();\n    puts(\"Done.\");\n  }\n  else\n  {\n    puts(\"Ordering is already correct\\n\");\n  }\n}\n",
        "similarity_score_unixcoder": 0.054796189069747925,
        "similarity_score_baseline_stripped": 0.46154457330703735,
        "similarity_score_baseline_debug": 0.7745316028594971
    },
    {
        "func_name": "get_input_line",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004EF6AB | 55 | push    rbp\n0x004EF6AC | 48 89 E5 | mov     rbp, rsp\n0x004EF6AF | 48 83 EC 20 | sub     rsp, 20h\n0x004EF6B3 | 48 89 7D E8 | mov     [rbp+src], rdi\n0x004EF6B7 | 48 8B 05 4A DD 26 00 | mov     rax, cs:qword_75D408\n0x004EF6BE | 48 8D 90 38 05 00 00 | lea     rdx, [rax+538h]\n0x004EF6C5 | 48 8B 45 E8 | mov     rax, [rbp+src]\n0x004EF6C9 | 48 89 C6 | mov     rsi, rax; src\n0x004EF6CC | 48 89 D7 | mov     rdi, rdx; dest\n0x004EF6CF | E8 FC 70 F1 FF | call    _strcpy\n0x004EF6D4 | 48 8B 05 2D DD 26 00 | mov     rax, cs:qword_75D408\n0x004EF6DB | C7 40 4C 00 00 00 00 | mov     dword ptr [rax+4Ch], 0\n0x004EF6E2 | E8 50 05 00 00 | call    sub_4EFC37\n0x004EF6E7 | 48 8B 45 E8 | mov     rax, [rbp+src]\n0x004EF6EB | 48 89 C7 | mov     rdi, rax\n0x004EF6EE | E8 E3 BB FF FF | call    sub_4EB2D6\n0x004EF6F3 | 48 8B 05 0E DD 26 00 | mov     rax, cs:qword_75D408\n0x004EF6FA | 48 05 38 05 00 00 | add     rax, 538h\n0x004EF700 | 48 89 C7 | mov     rdi, rax; s\n0x004EF703 | E8 C8 73 F1 FF | call    _strlen\n0x004EF708 | 89 45 FC | mov     [rbp+var_4], eax\n0x004EF70B | E9 B8 00 00 00 | jmp     loc_4EF7C8\n0x004EF710 | E8 94 FE FF FF | call    sub_4EF5A9\n0x004EF715 | 89 45 F8 | mov     [rbp+var_8], eax\n0x004EF718 | 83 7D F8 0A | cmp     [rbp+var_8], 0Ah\n0x004EF71C | 0F 84 B3 00 00 00 | jz      loc_4EF7D5\n0x004EF722 | 83 7D F8 0D | cmp     [rbp+var_8], 0Dh\n0x004EF726 | 0F 84 A9 00 00 00 | jz      loc_4EF7D5\n0x004EF72C | 83 7D F8 1B | cmp     [rbp+var_8], 1Bh\n0x004EF730 | 0F 84 9F 00 00 00 | jz      loc_4EF7D5\n0x004EF736 | 48 8B 05 CB DC 26 00 | mov     rax, cs:qword_75D408\n0x004EF73D | 0F B6 40 74 | movzx   eax, byte ptr [rax+74h]\n0x004EF741 | 0F BE C0 | movsx   eax, al\n0x004EF744 | 39 45 F8 | cmp     [rbp+var_8], eax\n0x004EF747 | 74 0C | jz      short loc_4EF755\n0x004EF749 | 83 7D F8 08 | cmp     [rbp+var_8], 8\n0x004EF74D | 74 06 | jz      short loc_4EF755\n0x004EF74F | 83 7D F8 7F | cmp     [rbp+var_8], 7Fh\n0x004EF753 | 75 2A | jnz     short loc_4EF77F\n0x004EF755 | 48 8B 15 AC DC 26 00 | mov     rdx, cs:qword_75D408\n0x004EF75C | 83 6D FC 01 | sub     [rbp+var_4], 1\n0x004EF760 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004EF763 | 48 98 | cdqe\n0x004EF765 | C6 84 02 38 05 00 00 00 | mov     byte ptr [rdx+rax+538h], 0\n0x004EF76D | BF DB 76 52 00 | mov     edi, offset asc_5276DB; \"\\b \\b\"\n0x004EF772 | E8 5F BB FF FF | call    sub_4EB2D6\n0x004EF777 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004EF77B | 7E 57 | jle     short loc_4EF7D4\n0x004EF77D | EB 49 | jmp     short loc_4EF7C8\n0x004EF77F | 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004EF783 | 7E 43 | jle     short loc_4EF7C8\n0x004EF785 | 81 7D F8 FF 00 00 00 | cmp     [rbp+var_8], 0FFh\n0x004EF78C | 7F 3A | jg      short loc_4EF7C8\n0x004EF78E | 48 8B 15 73 DC 26 00 | mov     rdx, cs:qword_75D408\n0x004EF795 | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x004EF798 | 89 C1 | mov     ecx, eax\n0x004EF79A | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004EF79D | 48 98 | cdqe\n0x004EF79F | 88 8C 02 38 05 00 00 | mov     [rdx+rax+538h], cl\n0x004EF7A6 | 48 8B 15 5B DC 26 00 | mov     rdx, cs:qword_75D408\n0x004EF7AD | 83 45 FC 01 | add     [rbp+var_4], 1\n0x004EF7B1 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004EF7B4 | 48 98 | cdqe\n0x004EF7B6 | C6 84 02 38 05 00 00 00 | mov     byte ptr [rdx+rax+538h], 0\n0x004EF7BE | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x004EF7C1 | 89 C7 | mov     edi, eax\n0x004EF7C3 | E8 91 AE F1 FF | call    sub_40A659\n0x004EF7C8 | 83 7D FC 7F | cmp     [rbp+var_4], 7Fh\n0x004EF7CC | 0F 8E 3E FF FF FF | jle     loc_4EF710\n0x004EF7D2 | EB 01 | jmp     short loc_4EF7D5\n0x004EF7D4 | 90 | nop\n0x004EF7D5 | BF 00 00 00 00 | mov     edi, 0\n0x004EF7DA | E8 1C 0E 00 00 | call    sub_4F05FB\n0x004EF7DF | 48 8B 05 22 DC 26 00 | mov     rax, cs:qword_75D408\n0x004EF7E6 | 48 05 38 05 00 00 | add     rax, 538h\n0x004EF7EC | C9 | leave\n0x004EF7ED | C3 | retn",
        "output": "",
        "source_code": "static char *get_input_line(const char *prompt)\n{\n\t// char [MAX_INPUT_LEN]\n#define buf get_input_line__buf\n\n\tint c;\n\tint i;\n\n\tstrcpy(buf, prompt);\n\tlast_status_cksum = 0;\t// force status update\n\tgo_bottom_and_clear_to_eol();\n\twrite1(prompt);      // write out the :, /, or ? prompt\n\n\ti = strlen(buf);\n\twhile (i < MAX_INPUT_LEN) {\n\t\tc = get_one_char();\n\t\tif (c == '\\n' || c == '\\r' || c == 27)\n\t\t\tbreak;\t\t// this is end of input\n\t\tif (c == erase_char || c == 8 || c == 127) {\n\t\t\t// user wants to erase prev char\n\t\t\tbuf[--i] = '\\0';\n\t\t\twrite1(\"\\b \\b\"); // erase char on screen\n\t\t\tif (i <= 0) // user backs up before b-o-l, exit\n\t\t\t\tbreak;\n\t\t} else if (c > 0 && c < 256) { // exclude Unicode\n\t\t\t// (TODO: need to handle Unicode)\n\t\t\tbuf[i] = c;\n\t\t\tbuf[++i] = '\\0';\n\t\t\tbb_putchar(c);\n\t\t}\n\t}\n\trefresh(FALSE);\n\treturn buf;\n#undef buf\n}",
        "parsed_output": "",
        "baseline_code_stripped": "char *__fastcall sub_4EF6AB(const char *a1)\n{\n  int v1; // esi\n  __int64 v2; // rdi\n  int v4; // [rsp+18h] [rbp-8h]\n  int v5; // [rsp+1Ch] [rbp-4h]\n\n  v1 = (int)a1;\n  strcpy((char *)qword_75D408 + 1336, a1);\n  *((_DWORD *)qword_75D408 + 19) = 0;\n  sub_4EFC37();\n  sub_4EB2D6(a1);\n  v2 = (__int64)qword_75D408 + 1336;\n  v5 = strlen((const char *)qword_75D408 + 1336);\n  while ( v5 <= 127 )\n  {\n    v4 = sub_4EF5A9(v2, v1);\n    if ( v4 == 10 || v4 == 13 || v4 == 27 )\n      break;\n    if ( v4 == *((char *)qword_75D408 + 116) || v4 == 8 || v4 == 127 )\n    {\n      *((_BYTE *)qword_75D408 + --v5 + 1336) = 0;\n      v2 = (__int64)\"\\b \\b\";\n      sub_4EB2D6(\"\\b \\b\");\n      if ( v5 <= 0 )\n        break;\n    }\n    else if ( v4 > 0 && v4 <= 255 )\n    {\n      *((_BYTE *)qword_75D408 + v5++ + 1336) = v4;\n      *((_BYTE *)qword_75D408 + v5 + 1336) = 0;\n      v2 = (unsigned int)v4;\n      sub_40A659(v4);\n    }\n  }\n  sub_4F05FB(0LL);\n  return (char *)qword_75D408 + 1336;\n}\n",
        "baseline_code_debug": "char *__cdecl get_input_line(const char *prompt)\n{\n  int c; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  strcpy(&ptr_to_globals[4].line_buf[28], prompt);\n  ptr_to_globals->speeds[6] = 0;\n  go_bottom_and_clear_to_eol();\n  write1(prompt);\n  i = strlen(&ptr_to_globals[4].line_buf[28]);\n  while ( i <= 127 )\n  {\n    c = get_one_char();\n    if ( c == 10 || c == 13 || c == 27 )\n      break;\n    if ( c == (char)ptr_to_globals->tty_attrs.c_cc[3] || c == 8 || c == 127 )\n    {\n      ptr_to_globals[4].line_buf[--i + 28] = 0;\n      write1(\"\\b \\b\");\n      if ( i <= 0 )\n        break;\n    }\n    else if ( c > 0 && c <= 255 )\n    {\n      ptr_to_globals[4].line_buf[i++ + 28] = c;\n      ptr_to_globals[4].line_buf[i + 28] = 0;\n      bb_putchar(c);\n    }\n  }\n  refresh(0);\n  return &ptr_to_globals[4].line_buf[28];\n}\n",
        "similarity_score_unixcoder": -0.03560343012213707,
        "similarity_score_baseline_stripped": 0.5242857336997986,
        "similarity_score_baseline_debug": 0.8551048040390015
    },
    {
        "func_name": "get_terminal_width_height",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00409E70 | 55 | push    rbp\n0x00409E71 | 48 89 E5 | mov     rbp, rsp\n0x00409E74 | 48 83 EC 30 | sub     rsp, 30h\n0x00409E78 | 89 7D EC | mov     [rbp+fd], edi\n0x00409E7B | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00409E7F | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x00409E83 | 66 C7 45 F8 00 00 | mov     [rbp+var_8], 0\n0x00409E89 | 66 C7 45 FA 00 00 | mov     [rbp+var_6], 0\n0x00409E8F | 48 8D 55 F8 | lea     rdx, [rbp+var_8]\n0x00409E93 | 8B 45 EC | mov     eax, [rbp+fd]\n0x00409E96 | BE 13 54 00 00 | mov     esi, 5413h; request\n0x00409E9B | 89 C7 | mov     edi, eax; fd\n0x00409E9D | B8 00 00 00 00 | mov     eax, 0\n0x00409EA2 | E8 F9 CE FF FF | call    _ioctl\n0x00409EA7 | 85 C0 | test    eax, eax\n0x00409EA9 | 75 09 | jnz     short loc_409EB4\n0x00409EAB | 0F B7 45 F8 | movzx   eax, [rbp+var_8]\n0x00409EAF | 66 85 C0 | test    ax, ax\n0x00409EB2 | 75 07 | jnz     short loc_409EBB\n0x00409EB4 | B8 01 00 00 00 | mov     eax, 1\n0x00409EB9 | EB 05 | jmp     short loc_409EC0\n0x00409EBB | B8 00 00 00 00 | mov     eax, 0\n0x00409EC0 | 89 45 F4 | mov     [rbp+var_C], eax\n0x00409EC3 | 48 83 7D D8 00 | cmp     [rbp+var_28], 0\n0x00409EC8 | 74 27 | jz      short loc_409EF1\n0x00409ECA | 0F B7 45 F8 | movzx   eax, [rbp+var_8]\n0x00409ECE | 0F B7 C0 | movzx   eax, ax\n0x00409ED1 | 48 8D 55 F4 | lea     rdx, [rbp+var_C]\n0x00409ED5 | 48 89 D1 | mov     rcx, rdx\n0x00409ED8 | BA C0 4F 53 00 | mov     edx, offset aLines; \"LINES\"\n0x00409EDD | BE 18 00 00 00 | mov     esi, 18h\n0x00409EE2 | 89 C7 | mov     edi, eax\n0x00409EE4 | E8 21 FF FF FF | call    sub_409E0A\n0x00409EE9 | 89 C2 | mov     edx, eax\n0x00409EEB | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00409EEF | 89 10 | mov     [rax], edx\n0x00409EF1 | 48 83 7D E0 00 | cmp     [rbp+var_20], 0\n0x00409EF6 | 74 27 | jz      short loc_409F1F\n0x00409EF8 | 0F B7 45 FA | movzx   eax, [rbp+var_6]\n0x00409EFC | 0F B7 C0 | movzx   eax, ax\n0x00409EFF | 48 8D 55 F4 | lea     rdx, [rbp+var_C]\n0x00409F03 | 48 89 D1 | mov     rcx, rdx\n0x00409F06 | BA C6 4F 53 00 | mov     edx, offset aColumns; \"COLUMNS\"\n0x00409F0B | BE 50 00 00 00 | mov     esi, 50h ; 'P'\n0x00409F10 | 89 C7 | mov     edi, eax\n0x00409F12 | E8 F3 FE FF FF | call    sub_409E0A\n0x00409F17 | 89 C2 | mov     edx, eax\n0x00409F19 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00409F1D | 89 10 | mov     [rax], edx\n0x00409F1F | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00409F22 | C9 | leave\n0x00409F23 | C3 | retn",
        "output": "",
        "source_code": "int FAST_FUNC get_terminal_width_height(int fd, unsigned *width, unsigned *height)\n{\n\tstruct winsize win;\n\tint err;\n\n\twin.ws_row = 0;\n\twin.ws_col = 0;\n\t/* I've seen ioctl returning 0, but row/col is (still?) 0.\n\t * We treat that as an error too.  */\n\terr = ioctl(fd, TIOCGWINSZ, &win) != 0 || win.ws_row == 0;\n\tif (height)\n\t\t*height = wh_helper(win.ws_row, 24, \"LINES\", &err);\n\tif (width)\n\t\t*width = wh_helper(win.ws_col, 80, \"COLUMNS\", &err);\n\treturn err;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_409E70(int a1, _DWORD *a2, _DWORD *a3)\n{\n  _BOOL4 v3; // eax\n  unsigned int v6; // [rsp+24h] [rbp-Ch] BYREF\n  unsigned __int16 v7; // [rsp+28h] [rbp-8h] BYREF\n  unsigned __int16 v8; // [rsp+2Ah] [rbp-6h]\n\n  v7 = 0;\n  v8 = 0;\n  v3 = ioctl(a1, 0x5413uLL, &v7) || !v7;\n  v6 = v3;\n  if ( a3 )\n    *a3 = sub_409E0A(v7, 0x18u, \"LINES\", &v6);\n  if ( a2 )\n    *a2 = sub_409E0A(v8, 0x50u, \"COLUMNS\", &v6);\n  return v6;\n}\n",
        "baseline_code_debug": "int __cdecl get_terminal_width_height(int fd, unsigned int *width, unsigned int *height)\n{\n  int v3; // eax\n  int err; // [rsp+24h] [rbp-Ch] BYREF\n  winsize win; // [rsp+28h] [rbp-8h] BYREF\n\n  win.ws_row = 0;\n  win.ws_col = 0;\n  v3 = ioctl(fd, 0x5413uLL, &win) || !win.ws_row;\n  err = v3;\n  if ( height )\n    *height = wh_helper(win.ws_row, 24, \"LINES\", &err);\n  if ( width )\n    *width = wh_helper(win.ws_col, 80, \"COLUMNS\", &err);\n  return err;\n}\n",
        "similarity_score_unixcoder": 0.06001531332731247,
        "similarity_score_baseline_stripped": 0.5627363920211792,
        "similarity_score_baseline_debug": 0.8944959044456482
    },
    {
        "func_name": "set_changed",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00490725 | 55 | push    rbp\n0x00490726 | 48 89 E5 | mov     rbp, rsp\n0x00490729 | 89 7D FC | mov     [rbp+var_4], edi\n0x0049072C | 48 8B 0D D5 CC 2C 00 | mov     rcx, cs:qword_75D408\n0x00490733 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00490736 | 48 63 D0 | movsxd  rdx, eax\n0x00490739 | 48 89 D0 | mov     rax, rdx\n0x0049073C | 48 C1 E0 02 | shl     rax, 2\n0x00490740 | 48 01 D0 | add     rax, rdx\n0x00490743 | 48 C1 E0 03 | shl     rax, 3\n0x00490747 | 48 01 C8 | add     rax, rcx\n0x0049074A | 48 05 E8 09 00 00 | add     rax, 9E8h\n0x00490750 | C6 00 01 | mov     byte ptr [rax], 1\n0x00490753 | 90 | nop\n0x00490754 | 5D | pop     rbp\n0x00490755 | C3 | retn",
        "output": "",
        "source_code": "static ALWAYS_INLINE void\nset_changed(int i)\n{\n\tptes[i].changed = 1;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "_BYTE *__fastcall sub_490725(int a1)\n{\n  _BYTE *result; // rax\n\n  result = (char *)qword_75D408 + 40 * a1 + 2536;\n  *result = 1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl set_changed(int i)\n{\n  ptr_to_globals[8].line_buf[40 * i + 76] = 1;\n}\n",
        "similarity_score_unixcoder": 0.18142622709274292,
        "similarity_score_baseline_stripped": 0.3783988952636719,
        "similarity_score_baseline_debug": 0.6713061928749084
    },
    {
        "func_name": "xprint_and_close_file",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040A670 | 55 | push    rbp\n0x0040A671 | 48 89 E5 | mov     rbp, rsp\n0x0040A674 | 48 83 EC 10 | sub     rsp, 10h\n0x0040A678 | 48 89 7D F8 | mov     [rbp+stream], rdi\n0x0040A67C | E8 C8 FF FF FF | call    sub_40A649\n0x0040A681 | 48 8B 45 F8 | mov     rax, [rbp+stream]\n0x0040A685 | 48 89 C7 | mov     rdi, rax; stream\n0x0040A688 | E8 D3 CB FF FF | call    _fileno\n0x0040A68D | BE 01 00 00 00 | mov     esi, 1\n0x0040A692 | 89 C7 | mov     edi, eax\n0x0040A694 | E8 CD 0C 00 00 | call    sub_40B366\n0x0040A699 | 48 83 F8 FF | cmp     rax, 0FFFFFFFFFFFFFFFFh\n0x0040A69D | 75 05 | jnz     short loc_40A6A4\n0x0040A69F | E8 8B F2 FF FF | call    sub_40992F\n0x0040A6A4 | 48 8B 45 F8 | mov     rax, [rbp+stream]\n0x0040A6A8 | 48 89 C7 | mov     rdi, rax; stream\n0x0040A6AB | E8 50 C3 FF FF | call    _fclose\n0x0040A6B0 | 90 | nop\n0x0040A6B1 | C9 | leave\n0x0040A6B2 | C3 | retn",
        "output": "",
        "source_code": "void FAST_FUNC xprint_and_close_file(FILE *file)\n{\n\tfflush_all();\n\t// copyfd outputs error messages for us.\n\tif (bb_copyfd_eof(fileno(file), STDOUT_FILENO) == -1)\n\t\txfunc_die();\n\n\tfclose(file);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "int __fastcall sub_40A670(FILE *a1)\n{\n  unsigned int v1; // eax\n\n  sub_40A649();\n  v1 = fileno(a1);\n  if ( sub_40B366(v1, 1LL) == -1 )\n    sub_40992F();\n  return fclose(a1);\n}\n",
        "baseline_code_debug": "void __cdecl xprint_and_close_file(FILE *file)\n{\n  int v1; // eax\n\n  fflush_all();\n  v1 = fileno(file);\n  if ( bb_copyfd_eof(v1, 1) == -1 )\n    xfunc_die();\n  fclose(file);\n}\n",
        "similarity_score_unixcoder": 0.03468155860900879,
        "similarity_score_baseline_stripped": 0.604171872138977,
        "similarity_score_baseline_debug": 0.8830003142356873
    },
    {
        "func_name": "func_tty",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004633DC | 55 | push    rbp\n0x004633DD | 48 89 E5 | mov     rbp, rsp\n0x004633E0 | 48 83 EC 20 | sub     rsp, 20h\n0x004633E4 | 48 89 7D F8 | mov     [rbp+s], rdi\n0x004633E8 | 89 75 F4 | mov     [rbp+var_C], esi\n0x004633EB | 48 89 55 E8 | mov     [rbp+var_18], rdx\n0x004633EF | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x004633F3 | C6 00 3F | mov     byte ptr [rax], 3Fh ; '?'\n0x004633F6 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x004633FA | 48 83 C0 01 | add     rax, 1\n0x004633FE | C6 00 00 | mov     byte ptr [rax], 0\n0x00463401 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00463405 | 8B 40 7C | mov     eax, [rax+7Ch]\n0x00463408 | 85 C0 | test    eax, eax\n0x0046340A | 74 35 | jz      short loc_463441\n0x0046340C | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00463410 | 8B 88 80 00 00 00 | mov     ecx, [rax+80h]\n0x00463416 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0046341A | 8B 50 7C | mov     edx, [rax+7Ch]\n0x0046341D | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00463420 | 83 C0 01 | add     eax, 1\n0x00463423 | 48 63 F0 | movsxd  rsi, eax; maxlen\n0x00463426 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x0046342A | 41 89 C8 | mov     r8d, ecx\n0x0046342D | 89 D1 | mov     ecx, edx\n0x0046342F | BA 12 BF 51 00 | mov     edx, offset aUU_2; \"%u,%u\"\n0x00463434 | 48 89 C7 | mov     rdi, rax; s\n0x00463437 | B8 00 00 00 00 | mov     eax, 0\n0x0046343C | E8 CF 37 FA FF | call    _snprintf\n0x00463441 | 90 | nop\n0x00463442 | C9 | leave\n0x00463443 | C3 | retn",
        "output": "",
        "source_code": "static void func_tty(char *buf, int size, const procps_status_t *ps)\n{\n\tbuf[0] = '?';\n\tbuf[1] = '\\0';\n\tif (ps->tty_major) /* tty field of \"0\" means \"no tty\" */\n\t\tsnprintf(buf, size+1, \"%u,%u\", ps->tty_major, ps->tty_minor);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "int __fastcall sub_4633DC(char *a1, int a2, __int64 a3)\n{\n  int result; // eax\n\n  *a1 = 63;\n  a1[1] = 0;\n  result = *(_DWORD *)(a3 + 124);\n  if ( result )\n    return snprintf(a1, a2 + 1, \"%u,%u\", *(unsigned int *)(a3 + 124), *(unsigned int *)(a3 + 128));\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl func_tty(char *buf, int size, const procps_status_t_0 *ps)\n{\n  *buf = 63;\n  buf[1] = 0;\n  if ( ps->tty_major )\n    snprintf(buf, size + 1, \"%u,%u\", ps->tty_major, ps->tty_minor);\n}\n",
        "similarity_score_unixcoder": 0.03719093278050423,
        "similarity_score_baseline_stripped": 0.4665062427520752,
        "similarity_score_baseline_debug": 0.9123704433441162
    },
    {
        "func_name": "handle_size_or_mdtm",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0042A051 | 55 | push    rbp\n0x0042A052 | 48 89 E5 | mov     rbp, rsp\n0x0042A055 | 48 81 EC 20 01 00 00 | sub     rsp, 120h\n0x0042A05C | 89 BD EC FE FF FF | mov     [rbp+var_114], edi\n0x0042A062 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0042A067 | 48 8B 40 40 | mov     rax, [rax+40h]\n0x0042A06B | 48 85 C0 | test    rax, rax\n0x0042A06E | 74 2E | jz      short loc_42A09E\n0x0042A070 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0042A075 | 48 8B 40 40 | mov     rax, [rax+40h]\n0x0042A079 | 48 8D 95 70 FF FF FF | lea     rdx, [rbp+stat_buf]\n0x0042A080 | 48 89 D6 | mov     rsi, rdx; stat_buf\n0x0042A083 | 48 89 C7 | mov     rdi, rax; filename\n0x0042A086 | E8 65 DD FD FF | call    sub_407DF0\n0x0042A08B | 85 C0 | test    eax, eax\n0x0042A08D | 75 0F | jnz     short loc_42A09E\n0x0042A08F | 8B 45 88 | mov     eax, [rbp+stat_buf.st_mode]\n0x0042A092 | 25 00 F0 00 00 | and     eax, 0F000h\n0x0042A097 | 3D 00 80 00 00 | cmp     eax, 8000h\n0x0042A09C | 74 0F | jz      short loc_42A0AD\n0x0042A09E | BF 35 35 30 20 | mov     edi, 20303535h\n0x0042A0A3 | E8 C8 F4 FF FF | call    sub_429570\n0x0042A0A8 | E9 A6 00 00 00 | jmp     locret_42A153\n0x0042A0AD | 83 BD EC FE FF FF 00 | cmp     [rbp+var_114], 0\n0x0042A0B4 | 74 1F | jz      short loc_42A0D5\n0x0042A0B6 | 48 8B 55 A0 | mov     rdx, [rbp+stat_buf.st_size]\n0x0042A0BA | 48 8D 85 F0 FE FF FF | lea     rax, [rbp+s]\n0x0042A0C1 | BE 72 B3 52 00 | mov     esi, offset a213Lu; \"213 %lu\\r\\n\"\n0x0042A0C6 | 48 89 C7 | mov     rdi, rax; s\n0x0042A0C9 | B8 00 00 00 00 | mov     eax, 0\n0x0042A0CE | E8 AD D9 FD FF | call    _sprintf\n0x0042A0D3 | EB 6F | jmp     short loc_42A144\n0x0042A0D5 | 48 8D 85 30 FF FF FF | lea     rax, [rbp+tp]\n0x0042A0DC | 48 8D 95 70 FF FF FF | lea     rdx, [rbp+stat_buf]\n0x0042A0E3 | 48 83 C2 58 | add     rdx, 58h ; 'X'\n0x0042A0E7 | 48 89 C6 | mov     rsi, rax; tp\n0x0042A0EA | 48 89 D7 | mov     rdi, rdx; timer\n0x0042A0ED | E8 7E CB FD FF | call    _gmtime_r\n0x0042A0F2 | 8B 8D 30 FF FF FF | mov     ecx, [rbp+tp.tm_sec]\n0x0042A0F8 | 8B 95 34 FF FF FF | mov     edx, [rbp+tp.tm_min]\n0x0042A0FE | 44 8B 8D 38 FF FF FF | mov     r9d, [rbp+tp.tm_hour]\n0x0042A105 | 44 8B 85 3C FF FF FF | mov     r8d, [rbp+tp.tm_mday]\n0x0042A10C | 8B 85 40 FF FF FF | mov     eax, [rbp+tp.tm_mon]\n0x0042A112 | 8D 78 01 | lea     edi, [rax+1]\n0x0042A115 | 8B 85 44 FF FF FF | mov     eax, [rbp+tp.tm_year]\n0x0042A11B | 8D B0 6C 07 00 00 | lea     esi, [rax+76Ch]\n0x0042A121 | 48 8D 85 F0 FE FF FF | lea     rax, [rbp+s]\n0x0042A128 | 51 | push    rcx\n0x0042A129 | 52 | push    rdx\n0x0042A12A | 89 F9 | mov     ecx, edi\n0x0042A12C | 89 F2 | mov     edx, esi\n0x0042A12E | BE 80 B3 52 00 | mov     esi, offset a21304u02u02u02; \"213 %04u%02u%02u%02u%02u%02u\\r\\n\"\n0x0042A133 | 48 89 C7 | mov     rdi, rax; s\n0x0042A136 | B8 00 00 00 00 | mov     eax, 0\n0x0042A13B | E8 40 D9 FD FF | call    _sprintf\n0x0042A140 | 48 83 C4 10 | add     rsp, 10h\n0x0042A144 | 48 8D 85 F0 FE FF FF | lea     rax, [rbp+s]\n0x0042A14B | 48 89 C7 | mov     rdi, rax\n0x0042A14E | E8 65 F4 FF FF | call    sub_4295B8\n0x0042A153 | C9 | leave\n0x0042A154 | C3 | retn",
        "output": "",
        "source_code": "static void\nhandle_size_or_mdtm(int need_size)\n{\n\tstruct stat statbuf;\n\tstruct tm broken_out;\n\tchar buf[(sizeof(\"NNN %\"OFF_FMT\"u\\r\\n\") + sizeof(off_t) * 3)\n\t\t| sizeof(\"NNN YYYYMMDDhhmmss\\r\\n\")\n\t];\n\n\tif (!G.ftp_arg\n\t || stat(G.ftp_arg, &statbuf) != 0\n\t || !S_ISREG(statbuf.st_mode)\n\t) {\n\t\tWRITE_ERR(FTP_FILEFAIL);\n\t\treturn;\n\t}\n\tif (need_size) {\n\t\tsprintf(buf, STR(FTP_STATFILE_OK)\" %\"OFF_FMT\"u\\r\\n\", statbuf.st_size);\n\t} else {\n\t\tgmtime_r(&statbuf.st_mtime, &broken_out);\n\t\tsprintf(buf, STR(FTP_STATFILE_OK)\" %04u%02u%02u%02u%02u%02u\\r\\n\",\n\t\t\tbroken_out.tm_year + 1900,\n\t\t\tbroken_out.tm_mon + 1,\n\t\t\tbroken_out.tm_mday,\n\t\t\tbroken_out.tm_hour,\n\t\t\tbroken_out.tm_min,\n\t\t\tbroken_out.tm_sec);\n\t}\n\tcmdio_write_raw(buf);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "void __fastcall sub_42A051(int a1)\n{\n  char s[64]; // [rsp+10h] [rbp-110h] BYREF\n  struct tm tp; // [rsp+50h] [rbp-D0h] BYREF\n  struct stat64 stat_buf; // [rsp+90h] [rbp-90h] BYREF\n\n  if ( *((_QWORD *)&dest + 8) && !sub_407DF0(*((char **)&dest + 8), &stat_buf) && (stat_buf.st_mode & 0xF000) == 0x8000 )\n  {\n    if ( a1 )\n    {\n      sprintf(s, \"213 %lu\\r\\n\", stat_buf.st_size);\n    }\n    else\n    {\n      gmtime_r(&stat_buf.st_mtim.tv_sec, &tp);\n      sprintf(\n        s,\n        \"213 %04u%02u%02u%02u%02u%02u\\r\\n\",\n        (unsigned int)(tp.tm_year + 1900),\n        (unsigned int)(tp.tm_mon + 1),\n        (unsigned int)tp.tm_mday,\n        (unsigned int)tp.tm_hour,\n        (unsigned int)tp.tm_min,\n        (unsigned int)tp.tm_sec);\n    }\n    sub_4295B8(s);\n  }\n  else\n  {\n    sub_429570(540030261);\n  }\n}\n",
        "baseline_code_debug": "void __cdecl handle_size_or_mdtm(int need_size)\n{\n  char buf[55]; // [rsp+10h] [rbp-110h] BYREF\n  tm broken_out; // [rsp+50h] [rbp-D0h] BYREF\n  stat statbuf; // [rsp+90h] [rbp-90h] BYREF\n\n  if ( *((_QWORD *)&bb_common_bufsiz1 + 8)\n    && !stat64_0(*((const char **)&bb_common_bufsiz1 + 8), (stat64 *)&statbuf)\n    && (statbuf.st_mode & 0xF000) == 0x8000 )\n  {\n    if ( need_size )\n    {\n      sprintf(buf, \"213 %lu\\r\\n\", statbuf.st_size);\n    }\n    else\n    {\n      gmtime_r(&statbuf.st_mtim.tv_sec, &broken_out);\n      sprintf(\n        buf,\n        \"213 %04u%02u%02u%02u%02u%02u\\r\\n\",\n        (unsigned int)(broken_out.tm_year + 1900),\n        (unsigned int)(broken_out.tm_mon + 1),\n        (unsigned int)broken_out.tm_mday,\n        (unsigned int)broken_out.tm_hour,\n        (unsigned int)broken_out.tm_min,\n        (unsigned int)broken_out.tm_sec);\n    }\n    cmdio_write_raw(buf);\n  }\n  else\n  {\n    cmdio_write_error(0x20303535u);\n  }\n}\n",
        "similarity_score_unixcoder": 0.09206631034612656,
        "similarity_score_baseline_stripped": 0.6889386177062988,
        "similarity_score_baseline_debug": 0.8070555329322815
    },
    {
        "func_name": "svstatus_get",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0046A465 | 55 | push    rbp\n0x0046A466 | 48 89 E5 | mov     rbp, rsp\n0x0046A469 | 48 83 EC 10 | sub     rsp, 10h\n0x0046A46D | BE 01 08 00 00 | mov     esi, 801h; oflag\n0x0046A472 | BF CC E5 52 00 | mov     edi, offset aSuperviseOk_0; \"supervise/ok\"\n0x0046A477 | B8 00 00 00 00 | mov     eax, 0\n0x0046A47C | E8 4F D2 F9 FF | call    _open64\n0x0046A481 | 89 45 FC | mov     [rbp+fd], eax\n0x0046A484 | 83 7D FC FF | cmp     [rbp+fd], 0FFFFFFFFh\n0x0046A488 | 75 51 | jnz     short loc_46A4DB\n0x0046A48A | 48 8B 05 6F 2F 2F 00 | mov     rax, cs:qword_75D400\n0x0046A491 | 8B 00 | mov     eax, [rax]\n0x0046A493 | 83 F8 13 | cmp     eax, 13h\n0x0046A496 | 75 2F | jnz     short loc_46A4C7\n0x0046A498 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0046A49D | 48 8B 00 | mov     rax, [rax]\n0x0046A4A0 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0046A4A3 | 3C 78 | cmp     al, 78h ; 'x'\n0x0046A4A5 | 75 0C | jnz     short loc_46A4B3\n0x0046A4A7 | BF D9 E5 52 00 | mov     edi, offset aRunsvNotRunnin; \"runsv not running\"\n0x0046A4AC | E8 87 FF FF FF | call    sub_46A438\n0x0046A4B1 | EB 0A | jmp     short loc_46A4BD\n0x0046A4B3 | BF D9 E5 52 00 | mov     edi, offset aRunsvNotRunnin; \"runsv not running\"\n0x0046A4B8 | E8 25 FF FF FF | call    sub_46A3E2\n0x0046A4BD | B8 00 00 00 00 | mov     eax, 0\n0x0046A4C2 | E9 B2 00 00 00 | jmp     locret_46A579\n0x0046A4C7 | BF EB E5 52 00 | mov     edi, offset aCanTOpenSuperv; \"can't open supervise/ok\"\n0x0046A4CC | E8 39 FF FF FF | call    sub_46A40A\n0x0046A4D1 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x0046A4D6 | E9 9E 00 00 00 | jmp     locret_46A579\n0x0046A4DB | 8B 45 FC | mov     eax, [rbp+fd]\n0x0046A4DE | 89 C7 | mov     edi, eax; fd\n0x0046A4E0 | E8 2B C9 F9 FF | call    _close\n0x0046A4E5 | BE 00 08 00 00 | mov     esi, 800h; oflag\n0x0046A4EA | BF 03 E6 52 00 | mov     edi, offset aSuperviseStatu_0; \"supervise/status\"\n0x0046A4EF | B8 00 00 00 00 | mov     eax, 0\n0x0046A4F4 | E8 D7 D1 F9 FF | call    _open64\n0x0046A4F9 | 89 45 FC | mov     [rbp+fd], eax\n0x0046A4FC | 83 7D FC FF | cmp     [rbp+fd], 0FFFFFFFFh\n0x0046A500 | 75 11 | jnz     short loc_46A513\n0x0046A502 | BF 14 E6 52 00 | mov     edi, offset aCanTOpenSuperv_0; \"can't open supervise/status\"\n0x0046A507 | E8 FE FE FF FF | call    sub_46A40A\n0x0046A50C | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x0046A511 | EB 66 | jmp     short locret_46A579\n0x0046A513 | B9 20 B4 75 00 | mov     ecx, (offset dest.c_cc+17h)\n0x0046A518 | 8B 45 FC | mov     eax, [rbp+fd]\n0x0046A51B | BA 14 00 00 00 | mov     edx, 14h; nbytes\n0x0046A520 | 48 89 CE | mov     rsi, rcx; buf\n0x0046A523 | 89 C7 | mov     edi, eax; fd\n0x0046A525 | E8 16 CA F9 FF | call    _read\n0x0046A52A | 89 45 F8 | mov     [rbp+var_8], eax\n0x0046A52D | 8B 45 FC | mov     eax, [rbp+fd]\n0x0046A530 | 89 C7 | mov     edi, eax; fd\n0x0046A532 | E8 D9 C8 F9 FF | call    _close\n0x0046A537 | 83 7D F8 FF | cmp     [rbp+var_8], 0FFFFFFFFh\n0x0046A53B | 74 08 | jz      short loc_46A545\n0x0046A53D | 83 7D F8 14 | cmp     [rbp+var_8], 14h\n0x0046A541 | 75 13 | jnz     short loc_46A556\n0x0046A543 | EB 2F | jmp     short loc_46A574\n0x0046A545 | BF 30 E6 52 00 | mov     edi, offset aCanTReadSuperv; \"can't read supervise/status\"\n0x0046A54A | E8 BB FE FF FF | call    sub_46A40A\n0x0046A54F | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x0046A554 | EB 23 | jmp     short locret_46A579\n0x0046A556 | 48 8B 05 A3 2E 2F 00 | mov     rax, cs:qword_75D400\n0x0046A55D | C7 00 00 00 00 00 | mov     dword ptr [rax], 0\n0x0046A563 | BF 50 E6 52 00 | mov     edi, offset aCanTReadSuperv_0; \"can't read supervise/status: bad format\"\n0x0046A568 | E8 9D FE FF FF | call    sub_46A40A\n0x0046A56D | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x0046A572 | EB 05 | jmp     short locret_46A579\n0x0046A574 | B8 01 00 00 00 | mov     eax, 1\n0x0046A579 | C9 | leave\n0x0046A57A | C3 | retn",
        "output": "",
        "source_code": "static int svstatus_get(void)\n{\n\tint fd, r;\n\n\tfd = open(\"supervise/ok\", O_WRONLY|O_NDELAY);\n\tif (fd == -1) {\n\t\tif (errno == ENODEV) {\n\t\t\t*acts == 'x' ? ok(\"runsv not running\")\n\t\t\t             : failx(\"runsv not running\");\n\t\t\treturn 0;\n\t\t}\n\t\twarn(\"can't open supervise/ok\");\n\t\treturn -1;\n\t}\n\tclose(fd);\n\tfd = open(\"supervise/status\", O_RDONLY|O_NDELAY);\n\tif (fd == -1) {\n\t\twarn(\"can't open supervise/status\");\n\t\treturn -1;\n\t}\n\tr = read(fd, &svstatus, 20);\n\tclose(fd);\n\tswitch (r) {\n\tcase 20:\n\t\tbreak;\n\tcase -1:\n\t\twarn(\"can't read supervise/status\");\n\t\treturn -1;\n\tdefault:\n\t\terrno = 0;\n\t\twarn(\"can't read supervise/status: bad format\");\n\t\treturn -1;\n\t}\n\treturn 1;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 sub_46A465()\n{\n  int v1; // [rsp+8h] [rbp-8h]\n  int fd; // [rsp+Ch] [rbp-4h]\n  int fda; // [rsp+Ch] [rbp-4h]\n\n  fd = open64(\"supervise/ok\", 2049);\n  if ( fd == -1 )\n  {\n    if ( *(_DWORD *)qword_75D400 == 19 )\n    {\n      if ( **(_BYTE **)&dest.c_iflag == 120 )\n        sub_46A438(\"runsv not running\");\n      else\n        sub_46A3E2(\"runsv not running\");\n      return 0LL;\n    }\n    else\n    {\n      sub_46A40A(\"can't open supervise/ok\");\n      return 0xFFFFFFFFLL;\n    }\n  }\n  else\n  {\n    close(fd);\n    fda = open64(\"supervise/status\", 2048);\n    if ( fda == -1 )\n    {\n      sub_46A40A(\"can't open supervise/status\");\n      return 0xFFFFFFFFLL;\n    }\n    else\n    {\n      v1 = read(fda, &dest.c_cc[23], 0x14uLL);\n      close(fda);\n      if ( v1 == -1 )\n      {\n        sub_46A40A(\"can't read supervise/status\");\n        return 0xFFFFFFFFLL;\n      }\n      else if ( v1 == 20 )\n      {\n        return 1LL;\n      }\n      else\n      {\n        *(_DWORD *)qword_75D400 = 0;\n        sub_46A40A(\"can't read supervise/status: bad format\");\n        return 0xFFFFFFFFLL;\n      }\n    }\n  }\n}\n",
        "baseline_code_debug": "int __cdecl svstatus_get()\n{\n  int r; // [rsp+8h] [rbp-8h]\n  int fd; // [rsp+Ch] [rbp-4h]\n  int fda; // [rsp+Ch] [rbp-4h]\n\n  fd = open64(\"supervise/ok\", 2049);\n  if ( fd == -1 )\n  {\n    if ( *bb_errno == 19 )\n    {\n      if ( **(_BYTE **)&bb_common_bufsiz1.c_iflag == 120 )\n        ok(\"runsv not running\");\n      else\n        failx(\"runsv not running\");\n      return 0;\n    }\n    else\n    {\n      warn(\"can't open supervise/ok\");\n      return -1;\n    }\n  }\n  else\n  {\n    close(fd);\n    fda = open64(\"supervise/status\", 2048);\n    if ( fda == -1 )\n    {\n      warn(\"can't open supervise/status\");\n      return -1;\n    }\n    else\n    {\n      r = read(fda, &bb_common_bufsiz1.c_cc[23], 0x14uLL);\n      close(fda);\n      if ( r == -1 )\n      {\n        warn(\"can't read supervise/status\");\n        return -1;\n      }\n      else if ( r == 20 )\n      {\n        return 1;\n      }\n      else\n      {\n        *bb_errno = 0;\n        warn(\"can't read supervise/status: bad format\");\n        return -1;\n      }\n    }\n  }\n}\n",
        "similarity_score_unixcoder": -0.009626642800867558,
        "similarity_score_baseline_stripped": 0.7565339207649231,
        "similarity_score_baseline_debug": 0.8569511771202087
    },
    {
        "func_name": "handle_retr",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00429C7C | 55 | push    rbp\n0x00429C7D | 48 89 E5 | mov     rbp, rsp\n0x00429C80 | 48 81 EC C0 00 00 00 | sub     rsp, 0C0h\n0x00429C87 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00429C8C | 48 8B 40 20 | mov     rax, [rax+20h]\n0x00429C90 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00429C94 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00429C99 | 48 C7 40 20 00 00 00 00 | mov     qword ptr [rax+20h], 0\n0x00429CA1 | E8 38 FC FF FF | call    sub_4298DE\n0x00429CA6 | 85 C0 | test    eax, eax\n0x00429CA8 | 0F 84 4F 01 00 00 | jz      loc_429DFD\n0x00429CAE | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00429CB3 | 48 8B 40 40 | mov     rax, [rax+40h]\n0x00429CB7 | 48 85 C0 | test    rax, rax\n0x00429CBA | 74 1D | jz      short loc_429CD9\n0x00429CBC | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00429CC1 | 48 8B 40 40 | mov     rax, [rax+40h]\n0x00429CC5 | BE 00 08 00 00 | mov     esi, 800h; oflag\n0x00429CCA | 48 89 C7 | mov     rdi, rax; file\n0x00429CCD | B8 00 00 00 00 | mov     eax, 0\n0x00429CD2 | E8 F9 D9 FD FF | call    _open64\n0x00429CD7 | EB 05 | jmp     short loc_429CDE\n0x00429CD9 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x00429CDE | 89 45 F4 | mov     [rbp+fildes], eax\n0x00429CE1 | 83 7D F4 00 | cmp     [rbp+fildes], 0\n0x00429CE5 | 79 0F | jns     short loc_429CF6\n0x00429CE7 | BF 35 35 30 20 | mov     edi, 20303535h\n0x00429CEC | E8 7F F8 FF FF | call    sub_429570\n0x00429CF1 | E9 08 01 00 00 | jmp     locret_429DFE\n0x00429CF6 | 48 8D 95 40 FF FF FF | lea     rdx, [rbp+stat_buf]\n0x00429CFD | 8B 45 F4 | mov     eax, [rbp+fildes]\n0x00429D00 | 48 89 D6 | mov     rsi, rdx; stat_buf\n0x00429D03 | 89 C7 | mov     edi, eax; fildes\n0x00429D05 | E8 F6 E0 FD FF | call    sub_407E00\n0x00429D0A | 85 C0 | test    eax, eax\n0x00429D0C | 75 12 | jnz     short loc_429D20\n0x00429D0E | 8B 85 58 FF FF FF | mov     eax, [rbp+stat_buf.st_mode]\n0x00429D14 | 25 00 F0 00 00 | and     eax, 0F000h\n0x00429D19 | 3D 00 80 00 00 | cmp     eax, 8000h\n0x00429D1E | 74 0F | jz      short loc_429D2F\n0x00429D20 | BF 35 35 30 20 | mov     edi, 20303535h\n0x00429D25 | E8 46 F8 FF FF | call    sub_429570\n0x00429D2A | E9 B6 00 00 00 | jmp     loc_429DE5\n0x00429D2F | BA F8 B3 75 00 | mov     edx, offset dest\n0x00429D34 | 8B 45 F4 | mov     eax, [rbp+fildes]\n0x00429D37 | 89 42 04 | mov     [rdx+4], eax\n0x00429D3A | 8B 45 F4 | mov     eax, [rbp+fildes]\n0x00429D3D | 89 C7 | mov     edi, eax\n0x00429D3F | E8 98 FC FD FF | call    sub_4099DC\n0x00429D44 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00429D49 | 74 16 | jz      short loc_429D61\n0x00429D4B | 48 8B 4D F8 | mov     rcx, [rbp+var_8]\n0x00429D4F | 8B 45 F4 | mov     eax, [rbp+fildes]\n0x00429D52 | BA 00 00 00 00 | mov     edx, 0\n0x00429D57 | 48 89 CE | mov     rsi, rcx\n0x00429D5A | 89 C7 | mov     edi, eax\n0x00429D5C | E8 F6 07 FE FF | call    sub_40A557\n0x00429D61 | 48 8B 95 70 FF FF FF | mov     rdx, [rbp+stat_buf.st_size]\n0x00429D68 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00429D6D | 48 8B 40 40 | mov     rax, [rax+40h]\n0x00429D71 | 48 89 C6 | mov     rsi, rax\n0x00429D74 | BF 10 B3 52 00 | mov     edi, offset aOpeningBinaryC; \" Opening BINARY connection for %s (%lu \"...\n0x00429D79 | B8 00 00 00 00 | mov     eax, 0\n0x00429D7E | E8 30 09 FE FF | call    sub_40A6B3\n0x00429D83 | 48 89 45 E8 | mov     [rbp+ptr], rax\n0x00429D87 | 48 8B 45 E8 | mov     rax, [rbp+ptr]\n0x00429D8B | 48 89 C7 | mov     rdi, rax\n0x00429D8E | E8 F2 FA FF FF | call    sub_429885\n0x00429D93 | 89 45 E4 | mov     [rbp+fd], eax\n0x00429D96 | 48 8B 45 E8 | mov     rax, [rbp+ptr]\n0x00429D9A | 48 89 C7 | mov     rdi, rax; ptr\n0x00429D9D | E8 BE C8 FD FF | call    _free\n0x00429DA2 | 83 7D E4 00 | cmp     [rbp+fd], 0\n0x00429DA6 | 78 3C | js      short loc_429DE4\n0x00429DA8 | 8B 55 E4 | mov     edx, [rbp+fd]\n0x00429DAB | 8B 45 F4 | mov     eax, [rbp+fildes]\n0x00429DAE | 89 D6 | mov     esi, edx\n0x00429DB0 | 89 C7 | mov     edi, eax\n0x00429DB2 | E8 AF 15 FE FF | call    sub_40B366\n0x00429DB7 | 48 89 45 D8 | mov     [rbp+var_28], rax\n0x00429DBB | 8B 45 E4 | mov     eax, [rbp+fd]\n0x00429DBE | 89 C7 | mov     edi, eax; fd\n0x00429DC0 | E8 4B D0 FD FF | call    _close\n0x00429DC5 | 48 83 7D D8 00 | cmp     [rbp+var_28], 0\n0x00429DCA | 79 0C | jns     short loc_429DD8\n0x00429DCC | BF 34 35 31 20 | mov     edi, 20313534h\n0x00429DD1 | E8 9A F7 FF FF | call    sub_429570\n0x00429DD6 | EB 0D | jmp     short loc_429DE5\n0x00429DD8 | BF 32 32 36 20 | mov     edi, 20363232h\n0x00429DDD | E8 45 F7 FF FF | call    sub_429527\n0x00429DE2 | EB 01 | jmp     short loc_429DE5\n0x00429DE4 | 90 | nop\n0x00429DE5 | 8B 45 F4 | mov     eax, [rbp+fildes]\n0x00429DE8 | 89 C7 | mov     edi, eax; fd\n0x00429DEA | E8 21 D0 FD FF | call    _close\n0x00429DEF | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00429DF4 | C7 40 04 00 00 00 00 | mov     dword ptr [rax+4], 0\n0x00429DFB | EB 01 | jmp     short locret_429DFE\n0x00429DFD | 90 | nop\n0x00429DFE | C9 | leave\n0x00429DFF | C3 | retn",
        "output": "",
        "source_code": "static void\nhandle_retr(void)\n{\n\tstruct stat statbuf;\n\toff_t bytes_transferred;\n\tint remote_fd;\n\tint local_file_fd;\n\toff_t offset = G.restart_pos;\n\tchar *response;\n\n\tG.restart_pos = 0;\n\n\tif (!port_or_pasv_was_seen())\n\t\treturn; /* port_or_pasv_was_seen emitted error response */\n\n\t/* O_NONBLOCK is useful if file happens to be a device node */\n\tlocal_file_fd = G.ftp_arg ? open(G.ftp_arg, O_RDONLY | O_NONBLOCK) : -1;\n\tif (local_file_fd < 0) {\n\t\tWRITE_ERR(FTP_FILEFAIL);\n\t\treturn;\n\t}\n\n\tif (fstat(local_file_fd, &statbuf) != 0 || !S_ISREG(statbuf.st_mode)) {\n\t\t/* Note - pretend open failed */\n\t\tWRITE_ERR(FTP_FILEFAIL);\n\t\tgoto file_close_out;\n\t}\n\tG.local_file_fd = local_file_fd;\n\n\t/* Now deactive O_NONBLOCK, otherwise we have a problem\n\t * on DMAPI filesystems such as XFS DMAPI.\n\t */\n\tndelay_off(local_file_fd);\n\n\t/* Set the download offset (from REST) if any */\n\tif (offset != 0)\n\t\txlseek(local_file_fd, offset, SEEK_SET);\n\n\tresponse = xasprintf(\n\t\t\" Opening BINARY connection for %s (%\"OFF_FMT\"u bytes)\",\n\t\tG.ftp_arg, statbuf.st_size);\n\tremote_fd = get_remote_transfer_fd(response);\n\tfree(response);\n\tif (remote_fd < 0)\n\t\tgoto file_close_out;\n\n\tbytes_transferred = bb_copyfd_eof(local_file_fd, remote_fd);\n\tclose(remote_fd);\n\tif (bytes_transferred < 0)\n\t\tWRITE_ERR(FTP_BADSENDFILE);\n\telse\n\t\tWRITE_OK(FTP_TRANSFEROK);\n\n file_close_out:\n\tclose(local_file_fd);\n\tG.local_file_fd = 0;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "void sub_429C7C()\n{\n  int v0; // eax\n  __int64 v1; // rcx\n  __int64 v2; // r8\n  __int64 v3; // r9\n  struct stat64 stat_buf; // [rsp+0h] [rbp-C0h] BYREF\n  __int64 v5; // [rsp+98h] [rbp-28h]\n  int fd; // [rsp+A4h] [rbp-1Ch]\n  void *ptr; // [rsp+A8h] [rbp-18h]\n  int fildes; // [rsp+B4h] [rbp-Ch]\n  __off64_t v9; // [rsp+B8h] [rbp-8h]\n\n  v9 = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&dest.c_cc[15] = 0LL;\n  if ( (unsigned int)sub_4298DE() )\n  {\n    if ( *((_QWORD *)&dest + 8) )\n      v0 = open64(*((const char **)&dest + 8), 2048);\n    else\n      v0 = -1;\n    fildes = v0;\n    if ( v0 >= 0 )\n    {\n      if ( !sub_407E00(fildes, &stat_buf) && (stat_buf.st_mode & 0xF000) == 0x8000 )\n      {\n        dest.c_oflag = fildes;\n        sub_4099DC(fildes);\n        if ( v9 )\n          sub_40A557(fildes, v9, 0);\n        ptr = sub_40A6B3(\n                \" Opening BINARY connection for %s (%lu bytes)\",\n                *((_QWORD *)&dest + 8),\n                stat_buf.st_size,\n                v1,\n                v2,\n                v3);\n        fd = sub_429885((const char *)ptr);\n        free(ptr);\n        if ( fd >= 0 )\n        {\n          v5 = sub_40B366(fildes, fd);\n          close(fd);\n          if ( v5 >= 0 )\n            sub_429527(540422706);\n          else\n            sub_429570(540095796);\n        }\n      }\n      else\n      {\n        sub_429570(540030261);\n      }\n      close(fildes);\n      dest.c_oflag = 0;\n    }\n    else\n    {\n      sub_429570(540030261);\n    }\n  }\n}\n",
        "baseline_code_debug": "void __cdecl handle_retr()\n{\n  int v0; // eax\n  stat statbuf; // [rsp+0h] [rbp-C0h] BYREF\n  off_t bytes_transferred; // [rsp+98h] [rbp-28h]\n  int remote_fd; // [rsp+A4h] [rbp-1Ch]\n  char *response; // [rsp+A8h] [rbp-18h]\n  int local_file_fd; // [rsp+B4h] [rbp-Ch]\n  off_t offset; // [rsp+B8h] [rbp-8h]\n\n  offset = *(_QWORD *)&bb_common_bufsiz1.c_cc[15];\n  *(_QWORD *)&bb_common_bufsiz1.c_cc[15] = 0LL;\n  if ( port_or_pasv_was_seen() )\n  {\n    if ( *((_QWORD *)&bb_common_bufsiz1 + 8) )\n      v0 = open64(*((const char **)&bb_common_bufsiz1 + 8), 2048);\n    else\n      v0 = -1;\n    local_file_fd = v0;\n    if ( v0 >= 0 )\n    {\n      if ( !fstat64(local_file_fd, (stat64 *)&statbuf) && (statbuf.st_mode & 0xF000) == 0x8000 )\n      {\n        bb_common_bufsiz1.c_oflag = local_file_fd;\n        ndelay_off(local_file_fd);\n        if ( offset )\n          xlseek(local_file_fd, offset, 0);\n        response = xasprintf(\n                     \" Opening BINARY connection for %s (%lu bytes)\",\n                     *((const char **)&bb_common_bufsiz1 + 8),\n                     statbuf.st_size);\n        remote_fd = get_remote_transfer_fd(response);\n        free(response);\n        if ( remote_fd >= 0 )\n        {\n          bytes_transferred = bb_copyfd_eof(local_file_fd, remote_fd);\n          close(remote_fd);\n          if ( bytes_transferred >= 0 )\n            cmdio_write_ok(0x20363232u);\n          else\n            cmdio_write_error(0x20313534u);\n        }\n      }\n      else\n      {\n        cmdio_write_error(0x20303535u);\n      }\n      close(local_file_fd);\n      bb_common_bufsiz1.c_oflag = 0;\n    }\n    else\n    {\n      cmdio_write_error(0x20303535u);\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.03075852245092392,
        "similarity_score_baseline_stripped": 0.575982928276062,
        "similarity_score_baseline_debug": 0.8112479448318481
    },
    {
        "func_name": "may_wakeup",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004A4040 | 55 | push    rbp\n0x004A4041 | 48 89 E5 | mov     rbp, rsp\n0x004A4044 | 48 81 EC A0 00 00 00 | sub     rsp, 0A0h\n0x004A404B | 48 89 BD 68 FF FF FF | mov     [rbp+var_98], rdi\n0x004A4052 | 48 8B 85 68 FF FF FF | mov     rax, [rbp+var_98]\n0x004A4059 | 48 89 C7 | mov     rdi, rax\n0x004A405C | E8 BA 53 F6 FF | call    sub_40941B\n0x004A4061 | 48 89 85 68 FF FF FF | mov     [rbp+var_98], rax\n0x004A4068 | 48 8B 95 68 FF FF FF | mov     rdx, [rbp+var_98]\n0x004A406F | 48 8D 85 70 FF FF FF | lea     rax, [rbp+s]\n0x004A4076 | 48 89 D1 | mov     rcx, rdx\n0x004A4079 | BA 58 09 53 00 | mov     edx, offset aSysClassRtcSDe; \"/sys/class/rtc/%s/device/power/wakeup\"\n0x004A407E | BE 80 00 00 00 | mov     esi, 80h; maxlen\n0x004A4083 | 48 89 C7 | mov     rdi, rax; s\n0x004A4086 | B8 00 00 00 00 | mov     eax, 0\n0x004A408B | E8 80 2B F6 FF | call    _snprintf\n0x004A4090 | 48 8D 8D 70 FF FF FF | lea     rcx, [rbp+s]\n0x004A4097 | 48 8D 85 70 FF FF FF | lea     rax, [rbp+s]\n0x004A409E | BA 80 00 00 00 | mov     edx, 80h\n0x004A40A3 | 48 89 CE | mov     rsi, rcx\n0x004A40A6 | 48 89 C7 | mov     rdi, rax\n0x004A40A9 | E8 53 74 F6 FF | call    sub_40B501\n0x004A40AE | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004A40B2 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004A40B7 | 79 07 | jns     short loc_4A40C0\n0x004A40B9 | B8 00 00 00 00 | mov     eax, 0\n0x004A40BE | EB 1E | jmp     short locret_4A40DE\n0x004A40C0 | 48 8D 85 70 FF FF FF | lea     rax, [rbp+s]\n0x004A40C7 | BA 08 00 00 00 | mov     edx, 8; n\n0x004A40CC | BE 7E 09 53 00 | mov     esi, offset aEnabled_0; \"enabled\\n\"\n0x004A40D1 | 48 89 C7 | mov     rdi, rax; s1\n0x004A40D4 | E8 C7 26 F6 FF | call    _strncmp\n0x004A40D9 | 85 C0 | test    eax, eax\n0x004A40DB | 0F 94 C0 | setz    al\n0x004A40DE | C9 | leave\n0x004A40DF | C3 | retn",
        "output": "",
        "source_code": "static NOINLINE bool may_wakeup(const char *rtcname)\n{\n\tssize_t ret;\n\tchar buf[128];\n\n\t/* strip \"/dev/\" from the rtcname here */\n\trtcname = skip_dev_pfx(rtcname);\n\n\tsnprintf(buf, sizeof(buf), SYS_RTC_PATH, rtcname);\n\tret = open_read_close(buf, buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn false;\n\n\t/* wakeup events could be disabled or not supported */\n\treturn strncmp(buf, \"enabled\\n\", 8) == 0;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "bool __fastcall sub_4A4040(const char *a1)\n{\n  char *v2; // [rsp+8h] [rbp-98h]\n  char s[136]; // [rsp+10h] [rbp-90h] BYREF\n  ssize_t v4; // [rsp+98h] [rbp-8h]\n\n  v2 = sub_40941B(a1);\n  snprintf(s, 0x80uLL, \"/sys/class/rtc/%s/device/power/wakeup\", v2);\n  v4 = sub_40B501(s, s, 0x80uLL);\n  return v4 >= 0 && strncmp(s, \"enabled\\n\", 8uLL) == 0;\n}\n",
        "baseline_code_debug": "bool __cdecl may_wakeup(const char *rtcname)\n{\n  char *rtcnamea; // [rsp+8h] [rbp-98h]\n  char buf[128]; // [rsp+10h] [rbp-90h] BYREF\n  ssize_t ret; // [rsp+98h] [rbp-8h]\n\n  rtcnamea = skip_dev_pfx(rtcname);\n  snprintf(buf, 0x80uLL, \"/sys/class/rtc/%s/device/power/wakeup\", rtcnamea);\n  ret = open_read_close(buf, buf, 0x80uLL);\n  return ret >= 0 && strncmp(buf, \"enabled\\n\", 8uLL) == 0;\n}\n",
        "similarity_score_unixcoder": 0.05970997363328934,
        "similarity_score_baseline_stripped": 0.6505969762802124,
        "similarity_score_baseline_debug": 0.8455996513366699
    },
    {
        "func_name": "readlink_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004D055D | 55 | push    rbp\n0x004D055E | 48 89 E5 | mov     rbp, rsp\n0x004D0561 | 48 83 EC 30 | sub     rsp, 30h\n0x004D0565 | 89 7D DC | mov     [rbp+var_24], edi\n0x004D0568 | 48 89 75 D0 | mov     [rbp+var_30], rsi\n0x004D056C | 48 C7 05 C9 CE 28 00 7D 6E 53 00 | mov     cs:qword_75D440, offset a1_25; \"=1\"\n0x004D0577 | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x004D057B | BE 80 6E 53 00 | mov     esi, offset aFnvsq; \"fnvsq\"\n0x004D0580 | 48 89 C7 | mov     rdi, rax\n0x004D0583 | B8 00 00 00 00 | mov     eax, 0\n0x004D0588 | E8 62 9C 02 00 | call    sub_4FA1EF\n0x004D058D | 89 45 F4 | mov     [rbp+var_C], eax\n0x004D0590 | 8B 05 E2 A8 28 00 | mov     eax, cs:optind\n0x004D0596 | 48 98 | cdqe\n0x004D0598 | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]\n0x004D05A0 | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x004D05A4 | 48 01 D0 | add     rax, rdx\n0x004D05A7 | 48 8B 00 | mov     rax, [rax]\n0x004D05AA | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x004D05AE | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x004D05B1 | 83 E0 04 | and     eax, 4\n0x004D05B4 | 85 C0 | test    eax, eax\n0x004D05B6 | 75 07 | jnz     short loc_4D05BF\n0x004D05B8 | C6 05 59 A8 28 00 00 | mov     cs:byte_75AE18, 0\n0x004D05BF | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x004D05C2 | 83 E0 01 | and     eax, 1\n0x004D05C5 | 85 C0 | test    eax, eax\n0x004D05C7 | 74 12 | jz      short loc_4D05DB\n0x004D05C9 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004D05CD | 48 89 C7 | mov     rdi, rax\n0x004D05D0 | E8 6B AB F3 FF | call    sub_40B140\n0x004D05D5 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004D05D9 | EB 10 | jmp     short loc_4D05EB\n0x004D05DB | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004D05DF | 48 89 C7 | mov     rdi, rax\n0x004D05E2 | E8 EE AA F3 FF | call    sub_40B0D5\n0x004D05E7 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004D05EB | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004D05F0 | 75 07 | jnz     short loc_4D05F9\n0x004D05F2 | B8 01 00 00 00 | mov     eax, 1\n0x004D05F7 | EB 34 | jmp     short locret_4D062D\n0x004D05F9 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x004D05FC | 83 E0 02 | and     eax, 2\n0x004D05FF | 85 C0 | test    eax, eax\n0x004D0601 | 74 07 | jz      short loc_4D060A\n0x004D0603 | BA 86 6E 53 00 | mov     edx, offset aS_96; \"%s\"\n0x004D0608 | EB 05 | jmp     short loc_4D060F\n0x004D060A | BA 89 6E 53 00 | mov     edx, offset aS_97; \"%s\\n\"\n0x004D060F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004D0613 | 48 89 C6 | mov     rsi, rax\n0x004D0616 | 48 89 D7 | mov     rdi, rdx; format\n0x004D0619 | B8 00 00 00 00 | mov     eax, 0\n0x004D061E | E8 AD 65 F3 FF | call    _printf\n0x004D0623 | BF 00 00 00 00 | mov     edi, 0\n0x004D0628 | E8 9C 8D 02 00 | call    sub_4F93C9\n0x004D062D | C9 | leave\n0x004D062E | C3 | retn",
        "output": "",
        "source_code": "int readlink_main(int argc UNUSED_PARAM, char **argv)\n{\n\tchar *buf;\n\tchar *fname;\n\n\tIF_FEATURE_READLINK_FOLLOW(\n\t\tunsigned opt;\n\t\t/* We need exactly one non-option argument.  */\n\t\topt_complementary = \"=1\";\n\t\topt = getopt32(argv, \"fnvsq\");\n\t\tfname = argv[optind];\n\t)\n\tIF_NOT_FEATURE_READLINK_FOLLOW(\n\t\tconst unsigned opt = 0;\n\t\tif (argc != 2) bb_show_usage();\n\t\tfname = argv[1];\n\t)\n\n\t/* compat: coreutils readlink reports errors silently via exit code */\n\tif (!(opt & 4)) /* not -v */\n\t\tlogmode = LOGMODE_NONE;\n\n\tif (opt & 1) { /* -f */\n\t\tbuf = xmalloc_realpath(fname);\n\t} else {\n\t\tbuf = xmalloc_readlink_or_warn(fname);\n\t}\n\n\tif (!buf)\n\t\treturn EXIT_FAILURE;\n\tprintf((opt & 2) ? \"%s\" : \"%s\\n\", buf);\n\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tfree(buf);\n\n\tfflush_stdout_and_exit(EXIT_SUCCESS);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4D055D(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  const char *v7; // [rsp+18h] [rbp-18h]\n  char v8; // [rsp+24h] [rbp-Ch]\n  __int64 v9; // [rsp+28h] [rbp-8h]\n\n  qword_75D440 = (__int64)\"=1\";\n  v8 = sub_4FA1EF(a2, (unsigned int)\"fnvsq\", a3, a4, a5, a6);\n  v7 = *(const char **)(8LL * optind + a2);\n  if ( (v8 & 4) == 0 )\n    byte_75AE18 = 0;\n  if ( (v8 & 1) != 0 )\n    v9 = (__int64)sub_40B140(v7);\n  else\n    v9 = sub_40B0D5(v7);\n  if ( v9 )\n  {\n    if ( (v8 & 2) != 0 )\n      printf(\"%s\", v9);\n    else\n      printf(\"%s\\n\", v9);\n    sub_4F93C9(0LL);\n  }\n  return 1LL;\n}\n",
        "baseline_code_debug": "int __cdecl readlink_main(int argc, char **argv)\n{\n  char *fname; // [rsp+18h] [rbp-18h]\n  char opt; // [rsp+24h] [rbp-Ch]\n  char *buf; // [rsp+28h] [rbp-8h]\n\n  opt_complementary = \"=1\";\n  opt = getopt32(argv, \"fnvsq\");\n  fname = argv[optind];\n  if ( (opt & 4) == 0 )\n    logmode = 0;\n  if ( (opt & 1) != 0 )\n    buf = xmalloc_realpath(fname);\n  else\n    buf = xmalloc_readlink_or_warn(fname);\n  if ( buf )\n  {\n    if ( (opt & 2) != 0 )\n      printf(\"%s\", buf);\n    else\n      printf(\"%s\\n\", buf);\n    fflush_stdout_and_exit(0);\n  }\n  return 1;\n}\n",
        "similarity_score_unixcoder": 0.02310938388109207,
        "similarity_score_baseline_stripped": 0.5667601823806763,
        "similarity_score_baseline_debug": 0.8732278347015381
    },
    {
        "func_name": "svstatus_print",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0046A57B | 55 | push    rbp\n0x0046A57C | 48 89 E5 | mov     rbp, rsp\n0x0046A57F | 48 81 EC C0 00 00 00 | sub     rsp, 0C0h\n0x0046A586 | 48 89 BD 48 FF FF FF | mov     [rbp+var_B8], rdi\n0x0046A58D | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x0046A594 | 48 8D 85 50 FF FF FF | lea     rax, [rbp+stat_buf]\n0x0046A59B | 48 89 C6 | mov     rsi, rax; stat_buf\n0x0046A59E | BF 78 E6 52 00 | mov     edi, offset aDown_3; \"down\"\n0x0046A5A3 | E8 48 D8 F9 FF | call    sub_407DF0\n0x0046A5A8 | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x0046A5AB | 75 3D | jnz     short loc_46A5EA\n0x0046A5AD | 48 8B 05 4C 2E 2F 00 | mov     rax, cs:qword_75D400\n0x0046A5B4 | 8B 00 | mov     eax, [rax]\n0x0046A5B6 | 83 F8 02 | cmp     eax, 2\n0x0046A5B9 | 74 28 | jz      short loc_46A5E3\n0x0046A5BB | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0046A5C0 | 48 8B 40 08 | mov     rax, [rax+8]\n0x0046A5C4 | 48 8B 00 | mov     rax, [rax]\n0x0046A5C7 | 48 89 C6 | mov     rsi, rax\n0x0046A5CA | BF 7D E6 52 00 | mov     edi, offset aWarningCanTSta; \"warning: can't stat %s/down\"\n0x0046A5CF | B8 00 00 00 00 | mov     eax, 0\n0x0046A5D4 | E8 00 EC F9 FF | call    sub_4091D9\n0x0046A5D9 | B8 00 00 00 00 | mov     eax, 0\n0x0046A5DE | E9 85 01 00 00 | jmp     locret_46A768\n0x0046A5E3 | C7 45 FC 01 00 00 00 | mov     [rbp+var_4], 1\n0x0046A5EA | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0046A5EF | 8B 40 34 | mov     eax, [rax+34h]\n0x0046A5F2 | 89 45 F8 | mov     [rbp+var_8], eax\n0x0046A5F5 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0046A5FA | 48 8B 40 28 | mov     rax, [rax+28h]\n0x0046A5FE | 48 89 C7 | mov     rdi, rax\n0x0046A601 | E8 FF FC FF FF | call    sub_46A305\n0x0046A606 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x0046A60A | 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0046A60E | 74 57 | jz      short loc_46A667\n0x0046A610 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0046A615 | 0F B6 40 3B | movzx   eax, byte ptr [rax+3Bh]\n0x0046A619 | 0F B6 C0 | movzx   eax, al\n0x0046A61C | 83 F8 01 | cmp     eax, 1\n0x0046A61F | 74 07 | jz      short loc_46A628\n0x0046A621 | 83 F8 02 | cmp     eax, 2\n0x0046A624 | 74 13 | jz      short loc_46A639\n0x0046A626 | EB 21 | jmp     short loc_46A649\n0x0046A628 | BF 99 E6 52 00 | mov     edi, offset aRun_0; \"run: \"\n0x0046A62D | B8 00 00 00 00 | mov     eax, 0\n0x0046A632 | E8 99 C5 F9 FF | call    _printf\n0x0046A637 | EB 10 | jmp     short loc_46A649\n0x0046A639 | BF 9F E6 52 00 | mov     edi, offset aFinish_1; \"finish: \"\n0x0046A63E | B8 00 00 00 00 | mov     eax, 0\n0x0046A643 | E8 88 C5 F9 FF | call    _printf\n0x0046A648 | 90 | nop\n0x0046A649 | 8B 55 F8 | mov     edx, [rbp+var_8]\n0x0046A64C | 48 8B 85 48 FF FF FF | mov     rax, [rbp+var_B8]\n0x0046A653 | 48 89 C6 | mov     rsi, rax\n0x0046A656 | BF A8 E6 52 00 | mov     edi, offset aSPidD; \"%s: (pid %d) \"\n0x0046A65B | B8 00 00 00 00 | mov     eax, 0\n0x0046A660 | E8 6B C5 F9 FF | call    _printf\n0x0046A665 | EB 19 | jmp     short loc_46A680\n0x0046A667 | 48 8B 85 48 FF FF FF | mov     rax, [rbp+var_B8]\n0x0046A66E | 48 89 C6 | mov     rsi, rax\n0x0046A671 | BF B6 E6 52 00 | mov     edi, offset aDownS; \"down: %s: \"\n0x0046A676 | B8 00 00 00 00 | mov     eax, 0\n0x0046A67B | E8 50 C5 F9 FF | call    _printf\n0x0046A680 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0046A685 | 48 8B 40 20 | mov     rax, [rax+20h]\n0x0046A689 | 89 C2 | mov     edx, eax\n0x0046A68B | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0046A68F | 29 C2 | sub     edx, eax\n0x0046A691 | 89 D0 | mov     eax, edx\n0x0046A693 | 89 45 EC | mov     [rbp+var_14], eax\n0x0046A696 | B8 00 00 00 00 | mov     eax, 0\n0x0046A69B | 83 7D EC 00 | cmp     [rbp+var_14], 0\n0x0046A69F | 0F 49 45 EC | cmovns  eax, [rbp+var_14]\n0x0046A6A3 | 89 C6 | mov     esi, eax\n0x0046A6A5 | BF C1 E6 52 00 | mov     edi, offset aUs; \"%us\"\n0x0046A6AA | B8 00 00 00 00 | mov     eax, 0\n0x0046A6AF | E8 1C C5 F9 FF | call    _printf\n0x0046A6B4 | 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0046A6B8 | 74 6B | jz      short loc_46A725\n0x0046A6BA | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x0046A6BE | 75 0F | jnz     short loc_46A6CF\n0x0046A6C0 | BF C5 E6 52 00 | mov     edi, offset aNormallyDown; \", normally down\"\n0x0046A6C5 | B8 00 00 00 00 | mov     eax, 0\n0x0046A6CA | E8 01 C5 F9 FF | call    _printf\n0x0046A6CF | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0046A6D4 | 0F B6 40 38 | movzx   eax, byte ptr [rax+38h]\n0x0046A6D8 | 84 C0 | test    al, al\n0x0046A6DA | 74 0F | jz      short loc_46A6EB\n0x0046A6DC | BF D5 E6 52 00 | mov     edi, offset aPaused; \", paused\"\n0x0046A6E1 | B8 00 00 00 00 | mov     eax, 0\n0x0046A6E6 | E8 E5 C4 F9 FF | call    _printf\n0x0046A6EB | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0046A6F0 | 0F B6 40 39 | movzx   eax, byte ptr [rax+39h]\n0x0046A6F4 | 3C 64 | cmp     al, 64h ; 'd'\n0x0046A6F6 | 75 0F | jnz     short loc_46A707\n0x0046A6F8 | BF DE E6 52 00 | mov     edi, offset aWantDown; \", want down\"\n0x0046A6FD | B8 00 00 00 00 | mov     eax, 0\n0x0046A702 | E8 C9 C4 F9 FF | call    _printf\n0x0046A707 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0046A70C | 0F B6 40 3A | movzx   eax, byte ptr [rax+3Ah]\n0x0046A710 | 84 C0 | test    al, al\n0x0046A712 | 74 42 | jz      short loc_46A756\n0x0046A714 | BF EA E6 52 00 | mov     edi, offset aGotTerm; \", got TERM\"\n0x0046A719 | B8 00 00 00 00 | mov     eax, 0\n0x0046A71E | E8 AD C4 F9 FF | call    _printf\n0x0046A723 | EB 31 | jmp     short loc_46A756\n0x0046A725 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x0046A729 | 74 0F | jz      short loc_46A73A\n0x0046A72B | BF F5 E6 52 00 | mov     edi, offset aNormallyUp; \", normally up\"\n0x0046A730 | B8 00 00 00 00 | mov     eax, 0\n0x0046A735 | E8 96 C4 F9 FF | call    _printf\n0x0046A73A | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0046A73F | 0F B6 40 39 | movzx   eax, byte ptr [rax+39h]\n0x0046A743 | 3C 75 | cmp     al, 75h ; 'u'\n0x0046A745 | 75 0F | jnz     short loc_46A756\n0x0046A747 | BF 03 E7 52 00 | mov     edi, offset aWantUp; \", want up\"\n0x0046A74C | B8 00 00 00 00 | mov     eax, 0\n0x0046A751 | E8 7A C4 F9 FF | call    _printf\n0x0046A756 | 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0046A75A | 74 07 | jz      short loc_46A763\n0x0046A75C | B8 01 00 00 00 | mov     eax, 1\n0x0046A761 | EB 05 | jmp     short locret_46A768\n0x0046A763 | B8 02 00 00 00 | mov     eax, 2\n0x0046A768 | C9 | leave\n0x0046A769 | C3 | retn",
        "output": "",
        "source_code": "static unsigned svstatus_print(const char *m)\n{\n\tint diff;\n\tint pid;\n\tint normallyup = 0;\n\tstruct stat s;\n\tuint64_t timestamp;\n\n\tif (stat(\"down\", &s) == -1) {\n\t\tif (errno != ENOENT) {\n\t\t\tbb_perror_msg(WARN\"can't stat %s/down\", *service);\n\t\t\treturn 0;\n\t\t}\n\t\tnormallyup = 1;\n\t}\n\tpid = SWAP_LE32(svstatus.pid_le32);\n\ttimestamp = SWAP_BE64(svstatus.time_be64);\n\tif (pid) {\n\t\tswitch (svstatus.run_or_finish) {\n\t\tcase 1: printf(\"run: \"); break;\n\t\tcase 2: printf(\"finish: \"); break;\n\t\t}\n\t\tprintf(\"%s: (pid %d) \", m, pid);\n\t} else {\n\t\tprintf(\"down: %s: \", m);\n\t}\n\tdiff = tnow - timestamp;\n\tprintf(\"%us\", (diff < 0 ? 0 : diff));\n\tif (pid) {\n\t\tif (!normallyup) printf(\", normally down\");\n\t\tif (svstatus.paused) printf(\", paused\");\n\t\tif (svstatus.want == 'd') printf(\", want down\");\n\t\tif (svstatus.got_term) printf(\", got TERM\");\n\t} else {\n\t\tif (normallyup) printf(\", normally up\");\n\t\tif (svstatus.want == 'u') printf(\", want up\");\n\t}\n\treturn pid ? 1 : 2;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_46A57B(const char *a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  int c_ospeed_high; // eax\n  unsigned int v7; // eax\n  struct stat64 stat_buf; // [rsp+10h] [rbp-B0h] BYREF\n  int v9; // [rsp+ACh] [rbp-14h]\n  unsigned __int64 v10; // [rsp+B0h] [rbp-10h]\n  speed_t c_ispeed; // [rsp+B8h] [rbp-8h]\n  int v12; // [rsp+BCh] [rbp-4h]\n\n  v12 = 0;\n  if ( sub_407DF0(\"down\", &stat_buf) == -1 )\n  {\n    if ( *(_DWORD *)qword_75D400 != 2 )\n    {\n      sub_4091D9((__int64)\"warning: can't stat %s/down\", **(_QWORD **)&dest.c_cflag, v1, v2, v3, v4);\n      return 0LL;\n    }\n    v12 = 1;\n  }\n  c_ispeed = dest.c_ispeed;\n  v10 = sub_46A305(*(_QWORD *)&dest.c_cc[23]);\n  if ( c_ispeed )\n  {\n    c_ospeed_high = HIBYTE(dest.c_ospeed);\n    if ( c_ospeed_high == 1 )\n    {\n      printf(\"run: \");\n    }\n    else if ( c_ospeed_high == 2 )\n    {\n      printf(\"finish: \");\n    }\n    printf(\"%s: (pid %d) \", a1, c_ispeed);\n  }\n  else\n  {\n    printf(\"down: %s: \", a1);\n  }\n  v9 = *(_QWORD *)&dest.c_cc[15] - v10;\n  v7 = 0;\n  if ( v9 >= 0 )\n    v7 = v9;\n  printf(\"%us\", v7);\n  if ( c_ispeed )\n  {\n    if ( !v12 )\n      printf(\", normally down\");\n    if ( LOBYTE(dest.c_ospeed) )\n      printf(\", paused\");\n    if ( BYTE1(dest.c_ospeed) == 100 )\n      printf(\", want down\");\n    if ( BYTE2(dest.c_ospeed) )\n      printf(\", got TERM\");\n  }\n  else\n  {\n    if ( v12 )\n      printf(\", normally up\");\n    if ( BYTE1(dest.c_ospeed) == 117 )\n      printf(\", want up\");\n  }\n  if ( c_ispeed )\n    return 1LL;\n  else\n    return 2LL;\n}\n",
        "baseline_code_debug": "unsigned int __cdecl svstatus_print(const char *m)\n{\n  int c_ospeed_high; // eax\n  unsigned int v3; // eax\n  stat s; // [rsp+10h] [rbp-B0h] BYREF\n  int diff; // [rsp+ACh] [rbp-14h]\n  uint64_t timestamp; // [rsp+B0h] [rbp-10h]\n  int pid; // [rsp+B8h] [rbp-8h]\n  int normallyup; // [rsp+BCh] [rbp-4h]\n\n  normallyup = 0;\n  if ( stat64_0(\"down\", (stat64 *)&s) == -1 )\n  {\n    if ( *bb_errno != 2 )\n    {\n      bb_perror_msg(\"warning: can't stat %s/down\", **(const char ***)&bb_common_bufsiz1.c_cflag);\n      return 0;\n    }\n    normallyup = 1;\n  }\n  pid = bb_common_bufsiz1.c_ispeed;\n  timestamp = _bswap_64_3(*(_QWORD *)&bb_common_bufsiz1.c_cc[23]);\n  if ( pid )\n  {\n    c_ospeed_high = HIBYTE(bb_common_bufsiz1.c_ospeed);\n    if ( c_ospeed_high == 1 )\n    {\n      printf(\"run: \");\n    }\n    else if ( c_ospeed_high == 2 )\n    {\n      printf(\"finish: \");\n    }\n    printf(\"%s: (pid %d) \", m, (unsigned int)pid);\n  }\n  else\n  {\n    printf(\"down: %s: \", m);\n  }\n  diff = *(_QWORD *)&bb_common_bufsiz1.c_cc[15] - timestamp;\n  v3 = 0;\n  if ( diff >= 0 )\n    v3 = diff;\n  printf(\"%us\", v3);\n  if ( pid )\n  {\n    if ( !normallyup )\n      printf(\", normally down\");\n    if ( LOBYTE(bb_common_bufsiz1.c_ospeed) )\n      printf(\", paused\");\n    if ( BYTE1(bb_common_bufsiz1.c_ospeed) == 100 )\n      printf(\", want down\");\n    if ( BYTE2(bb_common_bufsiz1.c_ospeed) )\n      printf(\", got TERM\");\n  }\n  else\n  {\n    if ( normallyup )\n      printf(\", normally up\");\n    if ( BYTE1(bb_common_bufsiz1.c_ospeed) == 117 )\n      printf(\", want up\");\n  }\n  if ( pid )\n    return 1;\n  else\n    return 2;\n}\n",
        "similarity_score_unixcoder": 0.03417482599616051,
        "similarity_score_baseline_stripped": 0.584214448928833,
        "similarity_score_baseline_debug": 0.7094349265098572
    },
    {
        "func_name": "log_to_shmem",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0048CF88 | 55 | push    rbp\n0x0048CF89 | 48 89 E5 | mov     rbp, rsp\n0x0048CF8C | 48 83 EC 20 | sub     rsp, 20h\n0x0048CF90 | 48 89 7D E8 | mov     [rbp+s], rdi\n0x0048CF94 | 48 8B 05 6D 04 2D 00 | mov     rax, cs:qword_75D408\n0x0048CF9B | 48 8D 48 36 | lea     rcx, [rax+36h]\n0x0048CF9F | 48 8B 05 62 04 2D 00 | mov     rax, cs:qword_75D408\n0x0048CFA6 | 8B 40 28 | mov     eax, [rax+28h]\n0x0048CFA9 | BA 03 00 00 00 | mov     edx, 3; nsops\n0x0048CFAE | 48 89 CE | mov     rsi, rcx; sops\n0x0048CFB1 | 89 C7 | mov     edi, eax; semid\n0x0048CFB3 | E8 88 AA F7 FF | call    _semop\n0x0048CFB8 | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x0048CFBB | 75 0F | jnz     short loc_48CFCC\n0x0048CFBD | BF 9A F6 51 00 | mov     edi, offset aSmwdn; \"SMwdn\"\n0x0048CFC2 | B8 00 00 00 00 | mov     eax, 0\n0x0048CFC7 | E8 D6 C2 F7 FF | call    sub_4092A2\n0x0048CFCC | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x0048CFD0 | 48 89 C7 | mov     rdi, rax; s\n0x0048CFD3 | E8 F8 9A F7 FF | call    _strlen\n0x0048CFD8 | 83 C0 01 | add     eax, 1\n0x0048CFDB | 89 45 FC | mov     [rbp+var_4], eax\n0x0048CFDE | 48 8B 05 23 04 2D 00 | mov     rax, cs:qword_75D408\n0x0048CFE5 | 48 8B 40 60 | mov     rax, [rax+60h]\n0x0048CFE9 | 8B 40 04 | mov     eax, [rax+4]\n0x0048CFEC | 89 45 F8 | mov     [rbp+var_8], eax\n0x0048CFEF | 8B 55 F8 | mov     edx, [rbp+var_8]\n0x0048CFF2 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0048CFF5 | 01 D0 | add     eax, edx\n0x0048CFF7 | 89 45 F4 | mov     [rbp+var_C], eax\n0x0048CFFA | 48 8B 05 07 04 2D 00 | mov     rax, cs:qword_75D408\n0x0048D001 | 48 8B 40 60 | mov     rax, [rax+60h]\n0x0048D005 | 8B 00 | mov     eax, [rax]\n0x0048D007 | 39 45 F4 | cmp     [rbp+var_C], eax\n0x0048D00A | 7D 68 | jge     short loc_48D074\n0x0048D00C | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0048D00F | 48 63 D0 | movsxd  rdx, eax; n\n0x0048D012 | 48 8B 05 EF 03 2D 00 | mov     rax, cs:qword_75D408\n0x0048D019 | 48 8B 40 60 | mov     rax, [rax+60h]\n0x0048D01D | 48 8D 48 08 | lea     rcx, [rax+8]\n0x0048D021 | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x0048D024 | 48 98 | cdqe\n0x0048D026 | 48 01 C1 | add     rcx, rax\n0x0048D029 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x0048D02D | 48 89 C6 | mov     rsi, rax; src\n0x0048D030 | 48 89 CF | mov     rdi, rcx; dest\n0x0048D033 | E8 68 A1 F7 FF | call    _memcpy\n0x0048D038 | 48 8B 05 C9 03 2D 00 | mov     rax, cs:qword_75D408\n0x0048D03F | 48 8B 40 60 | mov     rax, [rax+60h]\n0x0048D043 | 8B 55 F4 | mov     edx, [rbp+var_C]\n0x0048D046 | 89 50 04 | mov     [rax+4], edx\n0x0048D049 | 48 8B 05 B8 03 2D 00 | mov     rax, cs:qword_75D408\n0x0048D050 | 48 8D 48 30 | lea     rcx, [rax+30h]\n0x0048D054 | 48 8B 05 AD 03 2D 00 | mov     rax, cs:qword_75D408\n0x0048D05B | 8B 40 28 | mov     eax, [rax+28h]\n0x0048D05E | BA 01 00 00 00 | mov     edx, 1; nsops\n0x0048D063 | 48 89 CE | mov     rsi, rcx; sops\n0x0048D066 | 89 C7 | mov     edi, eax; semid\n0x0048D068 | E8 D3 A9 F7 FF | call    _semop\n0x0048D06D | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x0048D070 | 75 76 | jnz     short loc_48D0E8\n0x0048D072 | EB 65 | jmp     short loc_48D0D9\n0x0048D074 | 48 8B 05 8D 03 2D 00 | mov     rax, cs:qword_75D408\n0x0048D07B | 48 8B 40 60 | mov     rax, [rax+60h]\n0x0048D07F | 8B 00 | mov     eax, [rax]\n0x0048D081 | 2B 45 F8 | sub     eax, [rbp+var_8]\n0x0048D084 | 89 45 F0 | mov     [rbp+var_10], eax\n0x0048D087 | 8B 45 F0 | mov     eax, [rbp+var_10]\n0x0048D08A | 48 63 D0 | movsxd  rdx, eax; n\n0x0048D08D | 48 8B 05 74 03 2D 00 | mov     rax, cs:qword_75D408\n0x0048D094 | 48 8B 40 60 | mov     rax, [rax+60h]\n0x0048D098 | 48 8D 48 08 | lea     rcx, [rax+8]\n0x0048D09C | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x0048D09F | 48 98 | cdqe\n0x0048D0A1 | 48 01 C1 | add     rcx, rax\n0x0048D0A4 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x0048D0A8 | 48 89 C6 | mov     rsi, rax; src\n0x0048D0AB | 48 89 CF | mov     rdi, rcx; dest\n0x0048D0AE | E8 ED A0 F7 FF | call    _memcpy\n0x0048D0B3 | 8B 45 F0 | mov     eax, [rbp+var_10]\n0x0048D0B6 | 48 98 | cdqe\n0x0048D0B8 | 48 01 45 E8 | add     [rbp+s], rax\n0x0048D0BC | 8B 45 F0 | mov     eax, [rbp+var_10]\n0x0048D0BF | 29 45 FC | sub     [rbp+var_4], eax\n0x0048D0C2 | 48 8B 05 3F 03 2D 00 | mov     rax, cs:qword_75D408\n0x0048D0C9 | 48 8B 40 60 | mov     rax, [rax+60h]\n0x0048D0CD | C7 40 04 00 00 00 00 | mov     dword ptr [rax+4], 0\n0x0048D0D4 | E9 05 FF FF FF | jmp     loc_48CFDE\n0x0048D0D9 | BF A0 F6 51 00 | mov     edi, offset aSmwup; \"SMwup\"\n0x0048D0DE | B8 00 00 00 00 | mov     eax, 0\n0x0048D0E3 | E8 BA C1 F7 FF | call    sub_4092A2\n0x0048D0E8 | 90 | nop\n0x0048D0E9 | C9 | leave\n0x0048D0EA | C3 | retn",
        "output": "",
        "source_code": "static void log_to_shmem(const char *msg)\n{\n\tint old_tail, new_tail;\n\tint len;\n\n\tif (semop(G.s_semid, G.SMwdn, 3) == -1) {\n\t\tbb_perror_msg_and_die(\"SMwdn\");\n\t}\n\n\t/* Circular Buffer Algorithm:\n\t * --------------------------\n\t * tail == position where to store next syslog message.\n\t * tail's max value is (shbuf->size - 1)\n\t * Last byte of buffer is never used and remains NUL.\n\t */\n\tlen = strlen(msg) + 1; /* length with NUL included */\n again:\n\told_tail = G.shbuf->tail;\n\tnew_tail = old_tail + len;\n\tif (new_tail < G.shbuf->size) {\n\t\t/* store message, set new tail */\n\t\tmemcpy(G.shbuf->data + old_tail, msg, len);\n\t\tG.shbuf->tail = new_tail;\n\t} else {\n\t\t/* k == available buffer space ahead of old tail */\n\t\tint k = G.shbuf->size - old_tail;\n\t\t/* copy what fits to the end of buffer, and repeat */\n\t\tmemcpy(G.shbuf->data + old_tail, msg, k);\n\t\tmsg += k;\n\t\tlen -= k;\n\t\tG.shbuf->tail = 0;\n\t\tgoto again;\n\t}\n\tif (semop(G.s_semid, G.SMwup, 1) == -1) {\n\t\tbb_perror_msg_and_die(\"SMwup\");\n\t}\n\tif (DEBUG)\n\t\tprintf(\"tail:%d\\n\", G.shbuf->tail);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "int __fastcall sub_48CF88(const char *a1)\n{\n  char *v1; // rsi\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  char *v6; // rsi\n  int result; // eax\n  __int64 v8; // rdx\n  __int64 v9; // rcx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  char *s; // [rsp+8h] [rbp-18h]\n  int v13; // [rsp+10h] [rbp-10h]\n  int v14; // [rsp+18h] [rbp-8h]\n  int v15; // [rsp+1Ch] [rbp-4h]\n\n  s = (char *)a1;\n  v1 = (char *)qword_75D408 + 54;\n  if ( semop(*((_DWORD *)qword_75D408 + 10), (struct sembuf *)qword_75D408 + 9, 3uLL) == -1 )\n    sub_4092A2((__int64)\"SMwdn\", (__int64)v1, v2, v3, v4, v5);\n  v15 = strlen(a1) + 1;\n  while ( 1 )\n  {\n    v14 = *(_DWORD *)(*((_QWORD *)qword_75D408 + 12) + 4LL);\n    if ( v14 + v15 < **((_DWORD **)qword_75D408 + 12) )\n      break;\n    v13 = **((_DWORD **)qword_75D408 + 12) - v14;\n    memcpy((void *)(v14 + *((_QWORD *)qword_75D408 + 12) + 8LL), s, v13);\n    s += v13;\n    v15 -= v13;\n    *(_DWORD *)(*((_QWORD *)qword_75D408 + 12) + 4LL) = 0;\n  }\n  memcpy((void *)(v14 + *((_QWORD *)qword_75D408 + 12) + 8LL), s, v15);\n  *(_DWORD *)(*((_QWORD *)qword_75D408 + 12) + 4LL) = v14 + v15;\n  v6 = (char *)qword_75D408 + 48;\n  result = semop(*((_DWORD *)qword_75D408 + 10), (struct sembuf *)qword_75D408 + 8, 1uLL);\n  if ( result == -1 )\n    sub_4092A2((__int64)\"SMwup\", (__int64)v6, v8, v9, v10, v11);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl log_to_shmem(const char *msg)\n{\n  const char *msga; // [rsp+8h] [rbp-18h]\n  int k; // [rsp+10h] [rbp-10h]\n  int old_tail; // [rsp+18h] [rbp-8h]\n  int len; // [rsp+1Ch] [rbp-4h]\n\n  msga = msg;\n  if ( semop((int)ptr_to_globals->issue, (struct sembuf *)((char *)ptr_to_globals->speeds + 2), 3uLL) == -1 )\n    bb_perror_msg_and_die(\"SMwdn\");\n  len = strlen(msg) + 1;\n  while ( 1 )\n  {\n    old_tail = *(_DWORD *)(*(_QWORD *)&ptr_to_globals->tty_attrs.c_iflag + 4LL);\n    if ( old_tail + len < **(_DWORD **)&ptr_to_globals->tty_attrs.c_iflag )\n      break;\n    k = **(_DWORD **)&ptr_to_globals->tty_attrs.c_iflag - old_tail;\n    memcpy((void *)(old_tail + *(_QWORD *)&ptr_to_globals->tty_attrs.c_iflag + 8LL), msga, k);\n    msga += k;\n    len -= k;\n    *(_DWORD *)(*(_QWORD *)&ptr_to_globals->tty_attrs.c_iflag + 4LL) = 0;\n  }\n  memcpy((void *)(old_tail + *(_QWORD *)&ptr_to_globals->tty_attrs.c_iflag + 8LL), msga, len);\n  *(_DWORD *)(*(_QWORD *)&ptr_to_globals->tty_attrs.c_iflag + 4LL) = old_tail + len;\n  if ( semop((int)ptr_to_globals->issue, (struct sembuf *)&ptr_to_globals->numspeed, 1uLL) == -1 )\n    bb_perror_msg_and_die(\"SMwup\");\n}\n",
        "similarity_score_unixcoder": -0.0666855126619339,
        "similarity_score_baseline_stripped": 0.44038528203964233,
        "similarity_score_baseline_debug": 0.7354618906974792
    },
    {
        "func_name": "llist_add_to_end",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00409018 | 55 | push    rbp\n0x00409019 | 48 89 E5 | mov     rbp, rsp\n0x0040901C | 48 83 EC 10 | sub     rsp, 10h\n0x00409020 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00409024 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x00409028 | EB 0B | jmp     short loc_409035\n0x0040902A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0040902E | 48 8B 00 | mov     rax, [rax]\n0x00409031 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00409035 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00409039 | 48 8B 00 | mov     rax, [rax]\n0x0040903C | 48 85 C0 | test    rax, rax\n0x0040903F | 75 E9 | jnz     short loc_40902A\n0x00409041 | BF 10 00 00 00 | mov     edi, 10h\n0x00409046 | E8 9D 10 00 00 | call    sub_40A0E8\n0x0040904B | 48 89 C2 | mov     rdx, rax\n0x0040904E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00409052 | 48 89 10 | mov     [rax], rdx\n0x00409055 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00409059 | 48 8B 00 | mov     rax, [rax]\n0x0040905C | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x00409060 | 48 89 50 08 | mov     [rax+8], rdx\n0x00409064 | 90 | nop\n0x00409065 | C9 | leave\n0x00409066 | C3 | retn",
        "output": "",
        "source_code": "void FAST_FUNC llist_add_to_end(llist_t **list_head, void *data)\n{\n\twhile (*list_head)\n\t\tlist_head = &(*list_head)->link;\n\t*list_head = xzalloc(sizeof(llist_t));\n\t(*list_head)->data = data;\n\t/*(*list_head)->link = NULL;*/\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 *__fastcall sub_409018(__int64 *a1, __int64 a2)\n{\n  __int64 *result; // rax\n\n  while ( *a1 )\n    a1 = (__int64 *)*a1;\n  *a1 = sub_40A0E8(16LL);\n  result = (__int64 *)*a1;\n  *(_QWORD *)(*a1 + 8) = a2;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl llist_add_to_end(llist_t_0 **list_head, void *data)\n{\n  while ( *list_head )\n    list_head = (llist_t_0 **)*list_head;\n  *list_head = (llist_t_0 *)xzalloc(0x10uLL);\n  (*list_head)->data = (char *)data;\n}\n",
        "similarity_score_unixcoder": 0.031776417046785355,
        "similarity_score_baseline_stripped": 0.5214083194732666,
        "similarity_score_baseline_debug": 0.9074715375900269
    },
    {
        "func_name": "write_and_stats",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C760C | 55 | push    rbp\n0x004C760D | 48 89 E5 | mov     rbp, rsp\n0x004C7610 | 48 83 EC 30 | sub     rsp, 30h\n0x004C7614 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004C7618 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004C761C | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x004C7620 | 48 89 4D D0 | mov     [rbp+var_30], rcx\n0x004C7624 | 48 8B 55 D0 | mov     rdx, [rbp+var_30]\n0x004C7628 | 48 8B 4D E0 | mov     rcx, [rbp+var_20]\n0x004C762C | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004C7630 | 48 89 CE | mov     rsi, rcx\n0x004C7633 | 48 89 C7 | mov     rdi, rax\n0x004C7636 | E8 81 FF FF FF | call    sub_4C75BC\n0x004C763B | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004C763F | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004C7644 | 79 07 | jns     short loc_4C764D\n0x004C7646 | B8 01 00 00 00 | mov     eax, 1\n0x004C764B | EB 51 | jmp     short locret_4C769E\n0x004C764D | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004C7651 | 48 39 45 F8 | cmp     [rbp+var_8], rax\n0x004C7655 | 75 11 | jnz     short loc_4C7668\n0x004C7657 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004C765C | 48 8B 10 | mov     rdx, [rax]\n0x004C765F | 48 83 C2 01 | add     rdx, 1\n0x004C7663 | 48 89 10 | mov     [rax], rdx\n0x004C7666 | EB 18 | jmp     short loc_4C7680\n0x004C7668 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004C766D | 74 11 | jz      short loc_4C7680\n0x004C766F | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004C7674 | 48 8B 50 08 | mov     rdx, [rax+8]\n0x004C7678 | 48 83 C2 01 | add     rdx, 1\n0x004C767C | 48 89 50 08 | mov     [rax+8], rdx\n0x004C7680 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004C7685 | 48 8B 50 20 | mov     rdx, [rax+20h]\n0x004C7689 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C768D | B9 F8 B3 75 00 | mov     ecx, offset dest\n0x004C7692 | 48 01 D0 | add     rax, rdx\n0x004C7695 | 48 89 41 20 | mov     [rcx+20h], rax\n0x004C7699 | B8 00 00 00 00 | mov     eax, 0\n0x004C769E | C9 | leave\n0x004C769F | C3 | retn",
        "output": "",
        "source_code": "static bool write_and_stats(const void *buf, size_t len, size_t obs,\n\tconst char *filename)\n{\n\tssize_t n = full_write_or_warn(buf, len, filename);\n\tif (n < 0)\n\t\treturn 1;\n\tif ((size_t)n == obs)\n\t\tG.out_full++;\n\telse if (n) /* > 0 */\n\t\tG.out_part++;\n#if ENABLE_FEATURE_DD_THIRD_STATUS_LINE\n\tG.total_bytes += n;\n#endif\n\treturn 0;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4C760C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v6 = sub_4C75BC(a1, a2, a4);\n  if ( v6 < 0 )\n    return 1LL;\n  if ( v6 == a3 )\n  {\n    ++*(_QWORD *)&dest.c_iflag;\n  }\n  else if ( v6 )\n  {\n    ++*(_QWORD *)&dest.c_cflag;\n  }\n  *(_QWORD *)&dest.c_cc[15] += v6;\n  return 0LL;\n}\n",
        "baseline_code_debug": "bool __cdecl write_and_stats(const void *buf, size_t len, size_t obs, const char *filename)\n{\n  __int64 n; // [rsp+28h] [rbp-8h]\n\n  n = full_write_or_warn(buf, len, filename);\n  if ( n < 0 )\n    return 1;\n  if ( n == obs )\n  {\n    ++*(_QWORD *)&bb_common_bufsiz1.c_iflag;\n  }\n  else if ( n )\n  {\n    ++*(_QWORD *)&bb_common_bufsiz1.c_cflag;\n  }\n  *(_QWORD *)&bb_common_bufsiz1.c_cc[15] += n;\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.09404563158750534,
        "similarity_score_baseline_stripped": 0.48002612590789795,
        "similarity_score_baseline_debug": 0.823329508304596
    },
    {
        "func_name": "size_from_HISTFILESIZE",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004FF94D | 55 | push    rbp\n0x004FF94E | 48 89 E5 | mov     rbp, rsp\n0x004FF951 | 48 83 EC 20 | sub     rsp, 20h\n0x004FF955 | 48 89 7D E8 | mov     [rbp+nptr], rdi\n0x004FF959 | C7 45 FC FF 00 00 00 | mov     [rbp+var_4], 0FFh\n0x004FF960 | 48 83 7D E8 00 | cmp     [rbp+nptr], 0\n0x004FF965 | 74 2C | jz      short loc_4FF993\n0x004FF967 | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x004FF96B | 48 89 C7 | mov     rdi, rax; nptr\n0x004FF96E | E8 4D 80 F0 FF | call    _atoi\n0x004FF973 | 89 45 FC | mov     [rbp+var_4], eax\n0x004FF976 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004FF97A | 7F 07 | jg      short loc_4FF983\n0x004FF97C | B8 01 00 00 00 | mov     eax, 1\n0x004FF981 | EB 13 | jmp     short locret_4FF996\n0x004FF983 | 81 7D FC FF 00 00 00 | cmp     [rbp+var_4], 0FFh\n0x004FF98A | 7E 07 | jle     short loc_4FF993\n0x004FF98C | B8 FF 00 00 00 | mov     eax, 0FFh\n0x004FF991 | EB 03 | jmp     short locret_4FF996\n0x004FF993 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004FF996 | C9 | leave\n0x004FF997 | C3 | retn",
        "output": "",
        "source_code": "0\n\nunsigned size_from_HISTFILESIZE(const char *hp)\n{\n\tint size = MAX_HISTORY;\n\tif (hp) {\n\t\tsize = atoi(hp);\n\t\tif (size <= 0)\n\t\t\treturn 1;\n\t\tif (size > MAX_HISTORY)\n\t\t\treturn MAX_HISTORY;\n\t}\n\treturn size;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4FF94D(const char *a1)\n{\n  int v2; // [rsp+1Ch] [rbp-4h]\n\n  v2 = 255;\n  if ( !a1 )\n    return (unsigned int)v2;\n  v2 = atoi(a1);\n  if ( v2 <= 0 )\n    return 1LL;\n  if ( v2 > 255 )\n    return 255LL;\n  else\n    return (unsigned int)v2;\n}\n",
        "baseline_code_debug": "unsigned int __cdecl size_from_HISTFILESIZE(const char *hp)\n{\n  signed int size; // [rsp+1Ch] [rbp-4h]\n\n  size = 255;\n  if ( !hp )\n    return size;\n  size = atoi(hp);\n  if ( size <= 0 )\n    return 1;\n  if ( size > 255 )\n    return 255;\n  else\n    return size;\n}\n",
        "similarity_score_unixcoder": 0.05439923703670502,
        "similarity_score_baseline_stripped": 0.49767521023750305,
        "similarity_score_baseline_debug": 0.8438743948936462
    },
    {
        "func_name": "fork_job",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00414F9A | 55 | push    rbp\n0x00414F9B | 48 89 E5 | mov     rbp, rsp\n0x00414F9E | 48 83 EC 30 | sub     rsp, 30h\n0x00414FA2 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00414FA6 | 89 75 E4 | mov     [rbp+fd], esi\n0x00414FA9 | 48 89 55 D8 | mov     [rbp+file], rdx\n0x00414FAD | 48 89 4D D0 | mov     [rbp+var_30], rcx\n0x00414FB1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00414FB5 | 48 89 C7 | mov     rdi, rax\n0x00414FB8 | E8 67 75 FF FF | call    sub_40C524\n0x00414FBD | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00414FC1 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00414FC6 | 75 1B | jnz     short loc_414FE3\n0x00414FC8 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00414FCC | 48 89 C6 | mov     rsi, rax\n0x00414FCF | BF 52 8D 52 00 | mov     edi, offset aIcanTGetUidFor; \"Ican't get uid for %s\"\n0x00414FD4 | B8 00 00 00 00 | mov     eax, 0\n0x00414FD9 | E8 99 F3 FF FF | call    sub_414377\n0x00414FDE | E9 18 01 00 00 | jmp     loc_4150FB\n0x00414FE3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00414FE7 | 48 89 C7 | mov     rdi, rax\n0x00414FEA | E8 08 FF FF FF | call    sub_414EF7\n0x00414FEF | E8 BC 28 FF FF | call    _vfork\n0x00414FF4 | 89 45 F4 | mov     [rbp+var_C], eax\n0x00414FF7 | 83 7D F4 00 | cmp     [rbp+var_C], 0\n0x00414FFB | 0F 85 E5 00 00 00 | jnz     loc_4150E6\n0x00415001 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00415005 | 48 89 C7 | mov     rdi, rax\n0x00415008 | E8 22 FF FF FF | call    sub_414F2F\n0x0041500D | 8B 05 3D 84 34 00 | mov     eax, cs:dword_75D450\n0x00415013 | 83 E0 40 | and     eax, 40h\n0x00415016 | 85 C0 | test    eax, eax\n0x00415018 | 74 16 | jz      short loc_415030\n0x0041501A | 48 8B 45 D8 | mov     rax, [rbp+file]\n0x0041501E | 48 89 C6 | mov     rsi, rax\n0x00415021 | BF 68 8D 52 00 | mov     edi, offset unk_528D68\n0x00415026 | B8 00 00 00 00 | mov     eax, 0\n0x0041502B | E8 47 F3 FF FF | call    sub_414377\n0x00415030 | 83 7D E4 00 | cmp     [rbp+fd], 0\n0x00415034 | 78 26 | js      short loc_41505C\n0x00415036 | 48 83 7D D0 00 | cmp     [rbp+var_30], 0\n0x0041503B | 0F 95 C0 | setnz   al\n0x0041503E | 0F B6 D0 | movzx   edx, al\n0x00415041 | 8B 45 E4 | mov     eax, [rbp+fd]\n0x00415044 | 89 D6 | mov     esi, edx\n0x00415046 | 89 C7 | mov     edi, eax\n0x00415048 | E8 2A 54 FF FF | call    sub_40A477\n0x0041504D | BE 02 00 00 00 | mov     esi, 2; fd2\n0x00415052 | BF 01 00 00 00 | mov     edi, 1; fd\n0x00415057 | E8 24 1B FF FF | call    _dup2\n0x0041505C | E8 1F 2C FF FF | call    _setpgrp\n0x00415061 | 48 83 7D D0 00 | cmp     [rbp+var_30], 0\n0x00415066 | 74 07 | jz      short loc_41506F\n0x00415068 | BF 7A 8D 52 00 | mov     edi, offset unk_528D7A\n0x0041506D | EB 05 | jmp     short loc_415074\n0x0041506F | BF 7D 8D 52 00 | mov     edi, offset unk_528D7D\n0x00415074 | 48 8B 55 D0 | mov     rdx, [rbp+var_30]\n0x00415078 | 48 8B 75 D8 | mov     rsi, [rbp+file]; arg\n0x0041507C | 48 8B 45 D8 | mov     rax, [rbp+file]\n0x00415080 | 41 B8 00 00 00 00 | mov     r8d, 0\n0x00415086 | 48 89 D1 | mov     rcx, rdx\n0x00415089 | 48 89 FA | mov     rdx, rdi\n0x0041508C | 48 89 C7 | mov     rdi, rax; file\n0x0041508F | B8 00 00 00 00 | mov     eax, 0\n0x00415094 | E8 57 2B FF FF | call    _execlp\n0x00415099 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x0041509D | 48 8B 45 D8 | mov     rax, [rbp+file]\n0x004150A1 | 48 89 C6 | mov     rsi, rax\n0x004150A4 | BF 88 8D 52 00 | mov     edi, offset unk_528D88\n0x004150A9 | B8 00 00 00 00 | mov     eax, 0\n0x004150AE | E8 C4 F2 FF FF | call    sub_414377\n0x004150B3 | 48 83 7D D0 00 | cmp     [rbp+var_30], 0\n0x004150B8 | 74 22 | jz      short loc_4150DC\n0x004150BA | 48 8B 55 D0 | mov     rdx, [rbp+var_30]\n0x004150BE | 48 8B 45 D8 | mov     rax, [rbp+file]\n0x004150C2 | 48 89 D1 | mov     rcx, rdx\n0x004150C5 | 48 89 C2 | mov     rdx, rax\n0x004150C8 | BE A8 8D 52 00 | mov     esi, offset aExecFailedSCS; \"Exec failed: %s -c %s\\n\"\n0x004150CD | BF 01 00 00 00 | mov     edi, 1; fd\n0x004150D2 | B8 00 00 00 00 | mov     eax, 0\n0x004150D7 | E8 44 1D FF FF | call    _dprintf\n0x004150DC | BF 00 00 00 00 | mov     edi, 0; status\n0x004150E1 | E8 DA 16 FF FF | call    __exit\n0x004150E6 | 83 7D F4 00 | cmp     [rbp+var_C], 0\n0x004150EA | 79 16 | jns     short loc_415102\n0x004150EC | BF BF 8D 52 00 | mov     edi, offset unk_528DBF\n0x004150F1 | B8 00 00 00 00 | mov     eax, 0\n0x004150F6 | E8 7C F2 FF FF | call    sub_414377\n0x004150FB | C7 45 F4 00 00 00 00 | mov     [rbp+var_C], 0\n0x00415102 | 83 7D E4 00 | cmp     [rbp+fd], 0\n0x00415106 | 78 0A | js      short loc_415112\n0x00415108 | 8B 45 E4 | mov     eax, [rbp+fd]\n0x0041510B | 89 C7 | mov     edi, eax; fd\n0x0041510D | E8 FE 1C FF FF | call    _close\n0x00415112 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00415115 | C9 | leave\n0x00415116 | C3 | retn",
        "output": "",
        "source_code": "if ENABLE_FEATURE_CROND_CALL_SENDMAIL\n\nstatic pid_t\nfork_job(const char *user, int mailFd,\n\t\tconst char *prog,\n\t\tconst char *shell_cmd /* if NULL, we run sendmail */\n) {\n\tstruct passwd *pas;\n\tpid_t pid;\n\n\t/* prepare things before vfork */\n\tpas = getpwnam(user);\n\tif (!pas) {\n\t\tcrondlog(WARN9 \"can't get uid for %s\", user);\n\t\tgoto err;\n\t}\n\tset_env_vars(pas);\n\n\tpid = vfork();\n\tif (pid == 0) {\n\t\t/* CHILD */\n\t\t/* initgroups, setgid, setuid, and chdir to home or TMPDIR */\n\t\tchange_user(pas);\n\t\tif (DebugOpt) {\n\t\t\tcrondlog(LVL5 \"child running %s\", prog);\n\t\t}\n\t\tif (mailFd >= 0) {\n\t\t\txmove_fd(mailFd, shell_cmd ? 1 : 0);\n\t\t\tdup2(1, 2);\n\t\t}\n\t\t/* crond 3.0pl1-100 puts tasks in separate process groups */\n\t\tbb_setpgrp();\n\t\texeclp(prog, prog, (shell_cmd ? \"-c\" : SENDMAIL_ARGS), shell_cmd, (char *) NULL);\n\t\tcrondlog(ERR20 \"can't execute '%s' for user %s\", prog, user);\n\t\tif (shell_cmd) {\n\t\t\tfdprintf(1, \"Exec failed: %s -c %s\\n\", prog, shell_cmd);\n\t\t}\n\t\t_exit(EXIT_SUCCESS);\n\t}\n\n\tif (pid < 0) {\n\t\t/* FORK FAILED */\n\t\tcrondlog(ERR20 \"can't vfork\");\n err:\n\t\tpid = 0;\n\t} /* else: PARENT, FORK SUCCESS */\n\n\t/*\n\t * Close the mail file descriptor.. we can't just leave it open in\n\t * a structure, closing it later, because we might run out of descriptors\n\t */\n\tif (mailFd >= 0) {\n\t\tclose(mailFd);\n\t}\n\treturn pid;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_414F9A(const char *a1, __int64 a2, const char *a3, const char *a4)\n{\n  __int64 v4; // rdx\n  __int64 v5; // rcx\n  __int64 v6; // r8\n  __int64 v7; // r9\n  __int64 v8; // rdx\n  __int64 v9; // rcx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  void *v16; // rdi\n  __int64 v17; // rcx\n  __int64 v18; // r8\n  __int64 v19; // r9\n  __pid_t v24; // [rsp+24h] [rbp-Ch]\n  const char **v25; // [rsp+28h] [rbp-8h]\n\n  v25 = sub_40C524(a1, a2);\n  if ( !v25 )\n  {\n    sub_414377(\"Ican't get uid for %s\", (__int64)a1, v4, v5, v6, v7);\nLABEL_16:\n    v24 = 0;\n    goto LABEL_17;\n  }\n  sub_414EF7(v25);\n  v24 = vfork();\n  if ( !v24 )\n  {\n    sub_414F2F((__int64)v25);\n    if ( (dword_75D450 & 0x40) != 0 )\n      sub_414377(byte_528D68, (__int64)a3, v12, v13, v14, v15);\n    if ( (int)a2 >= 0 )\n    {\n      sub_40A477(a2, a4 != 0LL);\n      dup2(1, 2);\n    }\n    setpgrp();\n    if ( a4 )\n      v16 = &unk_528D7A;\n    else\n      v16 = &unk_528D7D;\n    execlp(a3, a3, v16, a4, 0LL);\n    sub_414377(byte_528D88, (__int64)a3, (__int64)a1, v17, v18, v19);\n    if ( a4 )\n      dprintf(1, \"Exec failed: %s -c %s\\n\", a3, a4);\n    _exit(0);\n  }\n  if ( v24 < 0 )\n  {\n    sub_414377(byte_528DBF, a2, v8, v9, v10, v11);\n    goto LABEL_16;\n  }\nLABEL_17:\n  if ( (int)a2 >= 0 )\n    close(a2);\n  return (unsigned int)v24;\n}\n",
        "baseline_code_debug": "pid_t __cdecl fork_job(const char *user, int mailFd, const char *prog, const char *shell_cmd)\n{\n  const char *v4; // rdi\n  __pid_t pid; // [rsp+24h] [rbp-Ch]\n  passwd *pas; // [rsp+28h] [rbp-8h]\n\n  pas = bb_internal_getpwnam(user);\n  if ( !pas )\n  {\n    crondlog(\"Ican't get uid for %s\", user);\nerr:\n    pid = 0;\n    goto LABEL_17;\n  }\n  set_env_vars(pas);\n  pid = vfork();\n  if ( !pid )\n  {\n    change_user(pas);\n    if ( (option_mask32 & 0x40) != 0 )\n      crondlog(&byte_528D68, prog);\n    if ( mailFd >= 0 )\n    {\n      xmove_fd(mailFd, shell_cmd != 0LL);\n      dup2(1, 2);\n    }\n    setpgrp();\n    if ( shell_cmd )\n      v4 = \"-c\";\n    else\n      v4 = \"-ti\";\n    execlp(prog, prog, v4, shell_cmd, 0LL);\n    crondlog(&byte_528D88, prog, user);\n    if ( shell_cmd )\n      dprintf(1, \"Exec failed: %s -c %s\\n\", prog, shell_cmd);\n    _exit(0);\n  }\n  if ( pid < 0 )\n  {\n    crondlog(&byte_528DBF);\n    goto err;\n  }\nLABEL_17:\n  if ( mailFd >= 0 )\n    close(mailFd);\n  return pid;\n}\n",
        "similarity_score_unixcoder": 0.013452917337417603,
        "similarity_score_baseline_stripped": 0.6366757750511169,
        "similarity_score_baseline_debug": 0.9272937774658203
    },
    {
        "func_name": "strncmpz",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004317A8 | 55 | push    rbp\n0x004317A9 | 48 89 E5 | mov     rbp, rsp\n0x004317AC | 48 83 EC 30 | sub     rsp, 30h\n0x004317B0 | 48 89 7D E8 | mov     [rbp+s1], rdi\n0x004317B4 | 48 89 75 E0 | mov     [rbp+s2], rsi\n0x004317B8 | 48 89 55 D8 | mov     [rbp+n], rdx\n0x004317BC | 48 8B 55 D8 | mov     rdx, [rbp+n]; n\n0x004317C0 | 48 8B 4D E0 | mov     rcx, [rbp+s2]\n0x004317C4 | 48 8B 45 E8 | mov     rax, [rbp+s1]\n0x004317C8 | 48 89 CE | mov     rsi, rcx; s2\n0x004317CB | 48 89 C7 | mov     rdi, rax; s1\n0x004317CE | E8 CD 4F FD FF | call    _strncmp\n0x004317D3 | 89 45 FC | mov     [rbp+var_4], eax\n0x004317D6 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004317DA | 75 15 | jnz     short loc_4317F1\n0x004317DC | 48 8B 55 E0 | mov     rdx, [rbp+s2]\n0x004317E0 | 48 8B 45 D8 | mov     rax, [rbp+n]\n0x004317E4 | 48 01 D0 | add     rax, rdx\n0x004317E7 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004317EA | 0F B6 C0 | movzx   eax, al\n0x004317ED | F7 D8 | neg     eax\n0x004317EF | EB 03 | jmp     short locret_4317F4\n0x004317F1 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004317F4 | C9 | leave\n0x004317F5 | C3 | retn",
        "output": "",
        "source_code": "static int strncmpz(const char *l, const char *r, size_t llen)\n{\n\tint i = strncmp(l, r, llen);\n\n\tif (i == 0)\n\t\treturn - (unsigned char)r[llen];\n\treturn i;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4317A8(const char *a1, const char *a2, size_t a3)\n{\n  unsigned int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = strncmp(a1, a2, a3);\n  if ( v5 )\n    return v5;\n  else\n    return (unsigned int)-(unsigned __int8)a2[a3];\n}\n",
        "baseline_code_debug": "int __cdecl strncmpz(const char *l, const char *r, size_t llen)\n{\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  i = strncmp(l, r, llen);\n  if ( i )\n    return i;\n  else\n    return -(unsigned __int8)r[llen];\n}\n",
        "similarity_score_unixcoder": 0.12423910200595856,
        "similarity_score_baseline_stripped": 0.5575990676879883,
        "similarity_score_baseline_debug": 0.7797098755836487
    },
    {
        "func_name": "iac_flush",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00441A2B | 55 | push    rbp\n0x00441A2C | 48 89 E5 | mov     rbp, rsp\n0x00441A2F | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00441A34 | 8B 00 | mov     eax, [rax]\n0x00441A36 | 48 98 | cdqe\n0x00441A38 | B9 A0 B4 75 00 | mov     ecx, offset qword_75B4A0\n0x00441A3D | 48 89 C2 | mov     rdx, rax; n\n0x00441A40 | 48 89 CE | mov     rsi, rcx; buf\n0x00441A43 | BF 03 00 00 00 | mov     edi, 3; fd\n0x00441A48 | E8 13 4F FC FF | call    _write\n0x00441A4D | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00441A52 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0\n0x00441A58 | 90 | nop\n0x00441A59 | 5D | pop     rbp\n0x00441A5A | C3 | retn",
        "output": "",
        "source_code": "static void iac_flush(void)\n{\n\twrite(netfd, G.iacbuf, G.iaclen);\n\tG.iaclen = 0;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "struct termios *sub_441A2B()\n{\n  struct termios *result; // rax\n\n  write(3, &qword_75B4A0, (int)dest.c_iflag);\n  result = &dest;\n  dest.c_iflag = 0;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl iac_flush()\n{\n  write(3, &qword_75B4A0, (int)bb_common_bufsiz1.c_iflag);\n  bb_common_bufsiz1.c_iflag = 0;\n}\n",
        "similarity_score_unixcoder": 0.08783179521560669,
        "similarity_score_baseline_stripped": 0.47276219725608826,
        "similarity_score_baseline_debug": 0.6510634422302246
    },
    {
        "func_name": "get_trimmed_slice",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00408145 | 55 | push    rbp\n0x00408146 | 48 89 E5 | mov     rbp, rsp\n0x00408149 | 48 83 EC 20 | sub     rsp, 20h\n0x0040814D | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00408151 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00408155 | EB 29 | jmp     short loc_408180\n0x00408157 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0040815B | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0040815E | 83 E8 09 | sub     eax, 9\n0x00408161 | 88 45 FF | mov     [rbp+var_1], al\n0x00408164 | 80 7D FF 17 | cmp     [rbp+var_1], 17h\n0x00408168 | 74 06 | jz      short loc_408170\n0x0040816A | 80 7D FF 04 | cmp     [rbp+var_1], 4\n0x0040816E | 77 07 | ja      short loc_408177\n0x00408170 | B8 01 00 00 00 | mov     eax, 1\n0x00408175 | EB 05 | jmp     short loc_40817C\n0x00408177 | B8 00 00 00 00 | mov     eax, 0\n0x0040817C | 85 C0 | test    eax, eax\n0x0040817E | 74 14 | jz      short loc_408194\n0x00408180 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00408184 | 48 8D 50 FF | lea     rdx, [rax-1]\n0x00408188 | 48 89 55 E0 | mov     [rbp+var_20], rdx\n0x0040818C | 48 39 45 E8 | cmp     [rbp+var_18], rax\n0x00408190 | 72 C5 | jb      short loc_408157\n0x00408192 | EB 01 | jmp     short loc_408195\n0x00408194 | 90 | nop\n0x00408195 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00408199 | 48 83 C0 01 | add     rax, 1\n0x0040819D | C6 00 00 | mov     byte ptr [rax], 0\n0x004081A0 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004081A4 | 48 89 C7 | mov     rdi, rax\n0x004081A7 | E8 08 12 00 00 | call    sub_4093B4\n0x004081AC | C9 | leave\n0x004081AD | C3 | retn",
        "output": "",
        "source_code": "static char *get_trimmed_slice(char *s, char *e)\n{\n\t/* First, consider the value at e to be nul and back up until we\n\t * reach a non-space char.  Set the char after that (possibly at\n\t * the original e) to nul. */\n\twhile (e-- > s) {\n\t\tif (!isspace(*e)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\te[1] = '\\0';\n\n\t/* Next, advance past all leading space and return a ptr to the\n\t * first non-space char; possibly the terminating nul. */\n\treturn skip_whitespace(s);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_408145(unsigned __int64 a1, _BYTE *a2)\n{\n  _BYTE *v3; // rax\n\n  do\n  {\n    v3 = a2--;\n    if ( a1 >= (unsigned __int64)v3 )\n      break;\n  }\n  while ( *a2 == 32 || (unsigned __int8)(*a2 - 9) <= 4u );\n  a2[1] = 0;\n  return sub_4093B4(a1);\n}\n",
        "baseline_code_debug": "char *__cdecl get_trimmed_slice(char *s, char *e)\n{\n  char *v3; // rax\n\n  do\n  {\n    v3 = e--;\n    if ( s >= v3 )\n      break;\n  }\n  while ( *e == 32 || (unsigned __int8)(*e - 9) <= 4u );\n  e[1] = 0;\n  return skip_whitespace(s);\n}\n",
        "similarity_score_unixcoder": 0.058660928159952164,
        "similarity_score_baseline_stripped": 0.5633623003959656,
        "similarity_score_baseline_debug": 0.8151691555976868
    },
    {
        "func_name": "print_closing_wait",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00422354 | 55 | push    rbp\n0x00422355 | 48 89 E5 | mov     rbp, rsp\n0x00422358 | 48 83 EC 10 | sub     rsp, 10h\n0x0042235C | 89 7D FC | mov     [rbp+var_4], edi\n0x0042235F | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x00422363 | 74 15 | jz      short loc_42237A\n0x00422365 | 81 7D FC FF FF 00 00 | cmp     [rbp+var_4], 0FFFFh\n0x0042236C | 75 18 | jnz     short loc_422386\n0x0042236E | BF 69 75 51 00 | mov     edi, offset aNone_1; \"none\"\n0x00422373 | E8 98 44 FE FF | call    _puts\n0x00422378 | EB 20 | jmp     short loc_42239A\n0x0042237A | BF 60 75 51 00 | mov     edi, offset aInfinite; \"infinite\"\n0x0042237F | E8 8C 44 FE FF | call    _puts\n0x00422384 | EB 14 | jmp     short loc_42239A\n0x00422386 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00422389 | 89 C6 | mov     esi, eax\n0x0042238B | BF DB 75 51 00 | mov     edi, offset aU_5; \"%u\\n\"\n0x00422390 | B8 00 00 00 00 | mov     eax, 0\n0x00422395 | E8 36 48 FE FF | call    _printf\n0x0042239A | 90 | nop\n0x0042239B | C9 | leave\n0x0042239C | C3 | retn",
        "output": "",
        "source_code": "static void print_closing_wait(unsigned int closing_wait)\n{\n\tswitch (closing_wait) {\n\tcase ASYNC_CLOSING_WAIT_NONE:\n\t\tputs(STR_NONE);\n\t\tbreak;\n\tcase ASYNC_CLOSING_WAIT_INF:\n\t\tputs(STR_INFINITE);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%u\\n\", closing_wait);\n\t}\n}",
        "parsed_output": "",
        "baseline_code_stripped": "int __fastcall sub_422354(unsigned int a1)\n{\n  if ( !a1 )\n    return puts(\"infinite\");\n  if ( a1 == 0xFFFF )\n    return puts(\"none\");\n  return printf(\"%u\\n\", a1);\n}\n",
        "baseline_code_debug": "void __cdecl print_closing_wait(unsigned int closing_wait)\n{\n  if ( closing_wait )\n  {\n    if ( closing_wait == 0xFFFF )\n      puts(\"none\");\n    else\n      printf(\"%u\\n\", closing_wait);\n  }\n  else\n  {\n    puts(\"infinite\");\n  }\n}\n",
        "similarity_score_unixcoder": 0.040102578699588776,
        "similarity_score_baseline_stripped": 0.6266295909881592,
        "similarity_score_baseline_debug": 0.8534532785415649
    },
    {
        "func_name": "evalcmd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0047DEBD | 55 | push    rbp\n0x0047DEBE | 48 89 E5 | mov     rbp, rsp\n0x0047DEC1 | 48 83 EC 20 | sub     rsp, 20h\n0x0047DEC5 | 89 7D EC | mov     [rbp+var_14], edi\n0x0047DEC8 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x0047DECC | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0047DED0 | 48 83 C0 08 | add     rax, 8\n0x0047DED4 | 48 8B 00 | mov     rax, [rax]\n0x0047DED7 | 48 85 C0 | test    rax, rax\n0x0047DEDA | 0F 84 C0 00 00 00 | jz      loc_47DFA0\n0x0047DEE0 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0047DEE4 | 48 8B 40 08 | mov     rax, [rax+8]\n0x0047DEE8 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0047DEEC | 48 83 45 E0 10 | add     [rbp+var_20], 10h\n0x0047DEF1 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0047DEF5 | 48 8B 00 | mov     rax, [rax]\n0x0047DEF8 | 48 85 C0 | test    rax, rax\n0x0047DEFB | 0F 84 8E 00 00 00 | jz      loc_47DF8F\n0x0047DF01 | 48 8B 05 20 F5 2D 00 | mov     rax, cs:qword_75D428\n0x0047DF08 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x0047DF0C | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x0047DF10 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x0047DF14 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0047DF18 | 48 89 D6 | mov     rsi, rdx\n0x0047DF1B | 48 89 C7 | mov     rdi, rax\n0x0047DF1E | E8 65 0E FF FF | call    sub_46ED88\n0x0047DF23 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x0047DF27 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0047DF2B | 48 8D 50 08 | lea     rdx, [rax+8]\n0x0047DF2F | 48 89 55 E0 | mov     [rbp+var_20], rdx\n0x0047DF33 | 48 8B 00 | mov     rax, [rax]\n0x0047DF36 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0047DF3A | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0047DF3F | 74 17 | jz      short loc_47DF58\n0x0047DF41 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0047DF45 | 48 89 C6 | mov     rsi, rax\n0x0047DF48 | BF 20 00 00 00 | mov     edi, 20h ; ' '\n0x0047DF4D | E8 6A 0E FF FF | call    sub_46EDBC\n0x0047DF52 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x0047DF56 | EB B8 | jmp     short loc_47DF10\n0x0047DF58 | 90 | nop\n0x0047DF59 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0047DF5D | 48 89 C6 | mov     rsi, rax\n0x0047DF60 | BF 00 00 00 00 | mov     edi, 0\n0x0047DF65 | E8 52 0E FF FF | call    sub_46EDBC\n0x0047DF6A | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x0047DF6E | 48 8B 05 B3 F4 2D 00 | mov     rax, cs:qword_75D428\n0x0047DF75 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x0047DF79 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x0047DF7D | 48 29 C2 | sub     rdx, rax\n0x0047DF80 | 48 89 D0 | mov     rax, rdx\n0x0047DF83 | 48 89 C7 | mov     rdi, rax\n0x0047DF86 | E8 1D 07 FF FF | call    sub_46E6A8\n0x0047DF8B | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0047DF8F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0047DF93 | BE EF FF FF FF | mov     esi, 0FFFFFFEFh\n0x0047DF98 | 48 89 C7 | mov     rdi, rax\n0x0047DF9B | E8 8C FE FF FF | call    sub_47DE2C\n0x0047DFA0 | 0F B6 05 A9 CF 2D 00 | movzx   eax, cs:byte_75AF50\n0x0047DFA7 | 0F B6 C0 | movzx   eax, al\n0x0047DFAA | C9 | leave\n0x0047DFAB | C3 | retn",
        "output": "",
        "source_code": "static int FAST_FUNC\nevalcmd(int argc UNUSED_PARAM, char **argv)\n{\n\tchar *p;\n\tchar *concat;\n\n\tif (argv[1]) {\n\t\tp = argv[1];\n\t\targv += 2;\n\t\tif (argv[0]) {\n\t\t\tSTARTSTACKSTR(concat);\n\t\t\tfor (;;) {\n\t\t\t\tconcat = stack_putstr(p, concat);\n\t\t\t\tp = *argv++;\n\t\t\t\tif (p == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tSTPUTC(' ', concat);\n\t\t\t}\n\t\t\tSTPUTC('\\0', concat);\n\t\t\tp = grabstackstr(concat);\n\t\t}\n\t\tevalstring(p, ~SKIPEVAL);\n\t}\n\treturn exitstatus;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_47DEBD(__int64 a1, __int64 a2)\n{\n  char *i; // rax\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  const char **v6; // rax\n  __int64 v7; // rdx\n  __int64 v8; // rsi\n  __int64 v9; // rcx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  const char **v13; // [rsp+0h] [rbp-20h]\n  __int64 v14; // [rsp+10h] [rbp-10h]\n  _BYTE *v15; // [rsp+10h] [rbp-10h]\n  _BYTE *v16; // [rsp+10h] [rbp-10h]\n  const char *v17; // [rsp+18h] [rbp-8h]\n  const char *v18; // [rsp+18h] [rbp-8h]\n\n  if ( *(_QWORD *)(a2 + 8) )\n  {\n    v17 = *(const char **)(a2 + 8);\n    v13 = (const char **)(a2 + 16);\n    if ( *(_QWORD *)(a2 + 16) )\n    {\n      for ( i = sub_46ED88(v17, *(_QWORD *)(qword_75D428 + 16)); ; i = sub_46ED88(v18, (__int64)v15) )\n      {\n        v14 = (__int64)i;\n        v6 = v13;\n        v7 = (__int64)++v13;\n        v18 = *v6;\n        if ( !*v6 )\n          break;\n        v15 = sub_46EDBC(32LL, v14, v7, v3, v4, v5);\n      }\n      v8 = v14;\n      v16 = sub_46EDBC(0LL, v14, v7, v3, v4, v5);\n      v17 = (const char *)sub_46E6A8(\n                            (__int64)&v16[-*(_QWORD *)(qword_75D428 + 16)],\n                            v8,\n                            (__int64)&v16[-*(_QWORD *)(qword_75D428 + 16)],\n                            v9,\n                            v10,\n                            v11);\n    }\n    sub_47DE2C(v17, 4294967279LL);\n  }\n  return (unsigned __int8)byte_75AF50;\n}\n",
        "baseline_code_debug": "int __cdecl evalcmd(int argc, char **argv)\n{\n  char **v2; // rax\n  char **argva; // [rsp+0h] [rbp-20h]\n  char *concat; // [rsp+10h] [rbp-10h]\n  char *concata; // [rsp+10h] [rbp-10h]\n  char *concatb; // [rsp+10h] [rbp-10h]\n  char *p; // [rsp+18h] [rbp-8h]\n\n  if ( argv[1] )\n  {\n    p = argv[1];\n    argva = argv + 2;\n    if ( argv[2] )\n    {\n      for ( concat = ash_ptr_to_globals_memstack->g_stacknxt; ; concat = STPUTC(32, concata) )\n      {\n        concata = stack_putstr(p, concat);\n        v2 = argva++;\n        p = *v2;\n        if ( !*v2 )\n          break;\n      }\n      concatb = STPUTC(0, concata);\n      p = (char *)stalloc(concatb - ash_ptr_to_globals_memstack->g_stacknxt);\n    }\n    evalstring(p, -17);\n  }\n  return exitstatus;\n}\n",
        "similarity_score_unixcoder": -0.04019477963447571,
        "similarity_score_baseline_stripped": 0.3927846848964691,
        "similarity_score_baseline_debug": 0.7912641763687134
    },
    {
        "func_name": "xdup2",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040A443 | 55 | push    rbp\n0x0040A444 | 48 89 E5 | mov     rbp, rsp\n0x0040A447 | 48 83 EC 10 | sub     rsp, 10h\n0x0040A44B | 89 7D FC | mov     [rbp+fd], edi\n0x0040A44E | 89 75 F8 | mov     [rbp+fd2], esi\n0x0040A451 | 8B 55 F8 | mov     edx, [rbp+fd2]\n0x0040A454 | 8B 45 FC | mov     eax, [rbp+fd]\n0x0040A457 | 89 D6 | mov     esi, edx; fd2\n0x0040A459 | 89 C7 | mov     edi, eax; fd\n0x0040A45B | E8 20 C7 FF FF | call    _dup2\n0x0040A460 | 39 45 F8 | cmp     [rbp+fd2], eax\n0x0040A463 | 74 0F | jz      short loc_40A474\n0x0040A465 | BF 60 80 52 00 | mov     edi, offset aCanTDuplicateF; \"can't duplicate file descriptor\"\n0x0040A46A | B8 00 00 00 00 | mov     eax, 0\n0x0040A46F | E8 2E EE FF FF | call    sub_4092A2\n0x0040A474 | 90 | nop\n0x0040A475 | C9 | leave\n0x0040A476 | C3 | retn",
        "output": "",
        "source_code": "void FAST_FUNC xdup2(int from, int to)\n{\n\tif (dup2(from, to) != to)\n\t\tbb_perror_msg_and_die(\"can't duplicate file descriptor\");\n}",
        "parsed_output": "",
        "baseline_code_stripped": "int __fastcall sub_40A443(int a1, unsigned int a2)\n{\n  int result; // eax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n\n  result = dup2(a1, a2);\n  if ( a2 != result )\n    sub_4092A2((__int64)\"can't duplicate file descriptor\", a2, v3, v4, v5, v6);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl xdup2(int from, int to)\n{\n  if ( to != dup2(from, to) )\n    bb_perror_msg_and_die(\"can't duplicate file descriptor\");\n}\n",
        "similarity_score_unixcoder": 0.09552198648452759,
        "similarity_score_baseline_stripped": 0.661356508731842,
        "similarity_score_baseline_debug": 0.926609992980957
    },
    {
        "func_name": "topmem_sort",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00466863 | 55 | push    rbp\n0x00466864 | 48 89 E5 | mov     rbp, rsp\n0x00466867 | 48 89 7D D8 | mov     [rbp+var_28], rdi\n0x0046686B | 48 89 75 D0 | mov     [rbp+var_30], rsi\n0x0046686F | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00466874 | 0F B6 40 0D | movzx   eax, byte ptr [rax+0Dh]\n0x00466878 | 48 0F BE C0 | movsx   rax, al\n0x0046687C | 48 83 C0 03 | add     rax, 3\n0x00466880 | C1 E0 03 | shl     eax, 3\n0x00466883 | 89 45 EC | mov     [rbp+var_14], eax\n0x00466886 | 8B 45 EC | mov     eax, [rbp+var_14]\n0x00466889 | 48 63 D0 | movsxd  rdx, eax\n0x0046688C | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00466890 | 48 01 D0 | add     rax, rdx\n0x00466893 | 48 8B 00 | mov     rax, [rax]\n0x00466896 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0046689A | 8B 45 EC | mov     eax, [rbp+var_14]\n0x0046689D | 48 63 D0 | movsxd  rdx, eax\n0x004668A0 | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x004668A4 | 48 01 D0 | add     rax, rdx\n0x004668A7 | 48 8B 00 | mov     rax, [rax]\n0x004668AA | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x004668AE | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004668B2 | 48 3B 45 F0 | cmp     rax, [rbp+var_10]\n0x004668B6 | 75 18 | jnz     short loc_4668D0\n0x004668B8 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004668BC | 48 8B 40 38 | mov     rax, [rax+38h]\n0x004668C0 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004668C4 | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x004668C8 | 48 8B 40 38 | mov     rax, [rax+38h]\n0x004668CC | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x004668D0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004668D4 | 48 3B 45 F0 | cmp     rax, [rbp+var_10]\n0x004668D8 | 77 10 | ja      short loc_4668EA\n0x004668DA | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004668DE | 48 3B 45 F0 | cmp     rax, [rbp+var_10]\n0x004668E2 | 0F 95 C0 | setnz   al\n0x004668E5 | 0F B6 C0 | movzx   eax, al\n0x004668E8 | EB 05 | jmp     short loc_4668EF\n0x004668EA | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x004668EF | 89 45 EC | mov     [rbp+var_14], eax\n0x004668F2 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004668F7 | 0F B6 40 0C | movzx   eax, byte ptr [rax+0Ch]\n0x004668FB | 84 C0 | test    al, al\n0x004668FD | 74 07 | jz      short loc_466906\n0x004668FF | 8B 45 EC | mov     eax, [rbp+var_14]\n0x00466902 | F7 D8 | neg     eax\n0x00466904 | EB 03 | jmp     short loc_466909\n0x00466906 | 8B 45 EC | mov     eax, [rbp+var_14]\n0x00466909 | 5D | pop     rbp\n0x0046690A | C3 | retn",
        "output": "",
        "source_code": "if ENABLE_FEATURE_TOPMEM\n\nstatic int topmem_sort(char *a, char *b)\n{\n\tint n;\n\tmem_t l, r;\n\n\tn = offsetof(topmem_status_t, vsz) + (sort_field * sizeof(mem_t));\n\tl = *(mem_t*)(a + n);\n\tr = *(mem_t*)(b + n);\n\tif (l == r) {\n\t\tl = ((topmem_status_t*)a)->dirty;\n\t\tr = ((topmem_status_t*)b)->dirty;\n\t}\n\t/* We want to avoid unsigned->signed and truncation errors */\n\t/* l>r: -1, l=r: 0, l<r: 1 */\n\tn = (l > r) ? -1 : (l != r);\n\treturn inverted ? -n : n;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_466863(_QWORD *a1, _QWORD *a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+1Ch] [rbp-14h]\n  unsigned __int64 v4; // [rsp+20h] [rbp-10h]\n  unsigned __int64 v5; // [rsp+28h] [rbp-8h]\n\n  v3 = SBYTE1(dest.c_lflag) + 3;\n  v5 = a1[v3];\n  v4 = a2[v3];\n  if ( v5 == v4 )\n  {\n    v5 = a1[7];\n    v4 = a2[7];\n  }\n  if ( v5 > v4 )\n    LODWORD(result) = -1;\n  else\n    LODWORD(result) = v5 != v4;\n  if ( LOBYTE(dest.c_lflag) )\n    return (unsigned int)-(int)result;\n  else\n    return (unsigned int)result;\n}\n",
        "baseline_code_debug": "int __cdecl topmem_sort(char *a, char *b)\n{\n  int result; // eax\n  int n; // [rsp+1Ch] [rbp-14h]\n  mem_t r; // [rsp+20h] [rbp-10h]\n  mem_t l; // [rsp+28h] [rbp-8h]\n\n  n = 8 * (SBYTE1(bb_common_bufsiz1.c_lflag) + 3);\n  l = *(_QWORD *)&a[n];\n  r = *(_QWORD *)&b[n];\n  if ( l == r )\n  {\n    l = *((_QWORD *)a + 7);\n    r = *((_QWORD *)b + 7);\n  }\n  if ( l > r )\n    result = -1;\n  else\n    result = l != r;\n  if ( LOBYTE(bb_common_bufsiz1.c_lflag) )\n    return -result;\n  return result;\n}\n",
        "similarity_score_unixcoder": 0.06114301458001137,
        "similarity_score_baseline_stripped": 0.4610469937324524,
        "similarity_score_baseline_debug": 0.7383714914321899
    },
    {
        "func_name": "recalculate_maxsock",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00433F24 | 55 | push    rbp\n0x00433F25 | 48 89 E5 | mov     rbp, rsp\n0x00433F28 | 48 83 EC 10 | sub     rsp, 10h\n0x00433F2C | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x00433F33 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00433F38 | C7 40 24 00 00 00 00 | mov     dword ptr [rax+24h], 0\n0x00433F3F | EB 4B | jmp     short loc_433F8C\n0x00433F41 | B9 D8 B4 75 00 | mov     ecx, offset qword_75B4D8\n0x00433F46 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00433F49 | 8D 50 3F | lea     edx, [rax+3Fh]\n0x00433F4C | 85 C0 | test    eax, eax\n0x00433F4E | 0F 48 C2 | cmovs   eax, edx\n0x00433F51 | C1 F8 06 | sar     eax, 6\n0x00433F54 | 48 98 | cdqe\n0x00433F56 | 48 8B 34 C1 | mov     rsi, [rcx+rax*8]\n0x00433F5A | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00433F5D | 99 | cdq\n0x00433F5E | C1 EA 1A | shr     edx, 1Ah\n0x00433F61 | 01 D0 | add     eax, edx\n0x00433F63 | 83 E0 3F | and     eax, 3Fh\n0x00433F66 | 29 D0 | sub     eax, edx\n0x00433F68 | BA 01 00 00 00 | mov     edx, 1\n0x00433F6D | 89 C1 | mov     ecx, eax\n0x00433F6F | 48 D3 E2 | shl     rdx, cl\n0x00433F72 | 48 89 D0 | mov     rax, rdx\n0x00433F75 | 48 21 F0 | and     rax, rsi\n0x00433F78 | 48 85 C0 | test    rax, rax\n0x00433F7B | 74 0B | jz      short loc_433F88\n0x00433F7D | BA F8 B3 75 00 | mov     edx, offset dest\n0x00433F82 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00433F85 | 89 42 24 | mov     [rdx+24h], eax\n0x00433F88 | 83 45 FC 01 | add     [rbp+var_4], 1\n0x00433F8C | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00433F91 | 8B 40 28 | mov     eax, [rax+28h]\n0x00433F94 | 39 45 FC | cmp     [rbp+var_4], eax\n0x00433F97 | 7E A8 | jle     short loc_433F41\n0x00433F99 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00433F9E | BA F8 B3 75 00 | mov     edx, offset dest\n0x00433FA3 | 8B 40 24 | mov     eax, [rax+24h]\n0x00433FA6 | 89 42 28 | mov     [rdx+28h], eax\n0x00433FA9 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00433FAE | 8B 40 24 | mov     eax, [rax+24h]\n0x00433FB1 | 48 98 | cdqe\n0x00433FB3 | BA F8 B3 75 00 | mov     edx, offset dest\n0x00433FB8 | 48 8B 12 | mov     rdx, [rdx]\n0x00433FBB | 48 83 EA 08 | sub     rdx, 8\n0x00433FBF | 48 39 D0 | cmp     rax, rdx\n0x00433FC2 | 76 05 | jbe     short loc_433FC9\n0x00433FC4 | E8 A1 FD FF FF | call    sub_433D6A\n0x00433FC9 | 90 | nop\n0x00433FCA | C9 | leave\n0x00433FCB | C3 | retn",
        "output": "",
        "source_code": "static void recalculate_maxsock(void)\n{\n\tint fd = 0;\n\n\t/* We may have no services, in this case maxsock should still be >= 0\n\t * (code elsewhere is not happy with maxsock == -1) */\n\tmaxsock = 0;\n\twhile (fd <= prev_maxsock) {\n\t\tif (FD_ISSET(fd, &allsock))\n\t\t\tmaxsock = fd;\n\t\tfd++;\n\t}\n\tdbg(\"recalculated maxsock:%d\\n\", maxsock);\n\tprev_maxsock = maxsock;\n\tif ((rlim_t)maxsock > rlim_ofile_cur - FD_MARGIN)\n\t\tbump_nofile();\n}",
        "parsed_output": "",
        "baseline_code_stripped": "void sub_433F24()\n{\n  int v0; // [rsp+Ch] [rbp-4h]\n\n  v0 = 0;\n  *(_DWORD *)&dest.c_cc[19] = 0;\n  while ( v0 <= *(_DWORD *)&dest.c_cc[23] )\n  {\n    if ( (qword_75B4D8[v0 / 64] & (1LL << (v0 % 64))) != 0 )\n      *(_DWORD *)&dest.c_cc[19] = v0;\n    ++v0;\n  }\n  *(_DWORD *)&dest.c_cc[23] = *(_DWORD *)&dest.c_cc[19];\n  if ( *(int *)&dest.c_cc[19] > (unsigned __int64)(*(_QWORD *)&dest.c_iflag - 8LL) )\n    sub_433D6A();\n}\n",
        "baseline_code_debug": "void __cdecl recalculate_maxsock()\n{\n  int fd; // [rsp+Ch] [rbp-4h]\n\n  fd = 0;\n  *(_DWORD *)&bb_common_bufsiz1.c_cc[19] = 0;\n  while ( fd <= *(_DWORD *)&bb_common_bufsiz1.c_cc[23] )\n  {\n    if ( (qword_75B4D8[fd / 64] & (1LL << (fd % 64))) != 0 )\n      *(_DWORD *)&bb_common_bufsiz1.c_cc[19] = fd;\n    ++fd;\n  }\n  *(_DWORD *)&bb_common_bufsiz1.c_cc[23] = *(_DWORD *)&bb_common_bufsiz1.c_cc[19];\n  if ( *(int *)&bb_common_bufsiz1.c_cc[19] > (unsigned __int64)(*(_QWORD *)&bb_common_bufsiz1.c_iflag - 8LL) )\n    bump_nofile();\n}\n",
        "similarity_score_unixcoder": 0.003242697101086378,
        "similarity_score_baseline_stripped": 0.38263827562332153,
        "similarity_score_baseline_debug": 0.5691468715667725
    },
    {
        "func_name": "setlogcons_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C49F4 | 55 | push    rbp\n0x004C49F5 | 48 89 E5 | mov     rbp, rsp\n0x004C49F8 | 48 83 EC 20 | sub     rsp, 20h\n0x004C49FC | 89 7D EC | mov     [rbp+var_14], edi\n0x004C49FF | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004C4A03 | C6 45 FE 0B | mov     [rbp+var_2], 0Bh\n0x004C4A07 | C6 45 FF 00 | mov     [rbp+var_1], 0\n0x004C4A0B | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004C4A0F | 48 83 C0 08 | add     rax, 8\n0x004C4A13 | 48 8B 00 | mov     rax, [rax]\n0x004C4A16 | 48 85 C0 | test    rax, rax\n0x004C4A19 | 74 20 | jz      short loc_4C4A3B\n0x004C4A1B | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004C4A1F | 48 83 C0 08 | add     rax, 8\n0x004C4A23 | 48 8B 00 | mov     rax, [rax]\n0x004C4A26 | BA 3F 00 00 00 | mov     edx, 3Fh ; '?'\n0x004C4A2B | BE 00 00 00 00 | mov     esi, 0\n0x004C4A30 | 48 89 C7 | mov     rdi, rax\n0x004C4A33 | E8 64 66 04 00 | call    sub_50B09C\n0x004C4A38 | 88 45 FF | mov     [rbp+var_1], al\n0x004C4A3B | BE 00 00 00 00 | mov     esi, 0\n0x004C4A40 | BF 4C 6A 53 00 | mov     edi, offset aDevTty1; \"/dev/tty1\"\n0x004C4A45 | E8 4B 58 F4 FF | call    sub_40A295\n0x004C4A4A | 89 C7 | mov     edi, eax\n0x004C4A4C | 48 8D 45 FE | lea     rax, [rbp+var_2]\n0x004C4A50 | B9 56 6A 53 00 | mov     ecx, offset aTioclinux; \"TIOCLINUX\"\n0x004C4A55 | 48 89 C2 | mov     rdx, rax\n0x004C4A58 | BE 1C 54 00 00 | mov     esi, 541Ch\n0x004C4A5D | E8 EF 62 F4 FF | call    sub_40AD51\n0x004C4A62 | B8 00 00 00 00 | mov     eax, 0\n0x004C4A67 | C9 | leave\n0x004C4A68 | C3 | retn",
        "output": "",
        "source_code": "int setlogcons_main(int argc UNUSED_PARAM, char **argv)\n{\n\tstruct {\n\t\tchar fn;\n\t\tchar subarg;\n\t} arg = {\n\t\t11, /* redirect kernel messages */\n\t\t0   /* to specified console (current as default) */\n\t};\n\n\tif (argv[1])\n\t\targ.subarg = xatou_range(argv[1], 0, 63);\n\n\txioctl(xopen(VC_1, O_RDONLY), TIOCLINUX, &arg);\n\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4C49F4(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  char v4; // [rsp+1Eh] [rbp-2h] BYREF\n  char v5; // [rsp+1Fh] [rbp-1h]\n\n  v4 = 11;\n  v5 = 0;\n  if ( *(_QWORD *)(a2 + 8) )\n    v5 = sub_50B09C(*(_QWORD *)(a2 + 8), 0LL, 63LL);\n  v2 = sub_40A295(\"/dev/tty1\", 0);\n  sub_40AD51(v2, 0x541Cu, (__int64)&v4, (__int64)\"TIOCLINUX\");\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl setlogcons_main(int argc, char **argv)\n{\n  int v2; // eax\n  setlogcons_main::$23BE6824809191D382C73B1FF0181EB2 arg; // [rsp+1Eh] [rbp-2h] BYREF\n\n  arg.fn = 11;\n  arg.subarg = 0;\n  if ( argv[1] )\n    arg.subarg = xatou_range(argv[1], 0, 0x3Fu);\n  v2 = xopen(\"/dev/tty1\", 0);\n  bb_xioctl(v2, 0x541Cu, &arg, \"TIOCLINUX\");\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.024819228798151016,
        "similarity_score_baseline_stripped": 0.612819492816925,
        "similarity_score_baseline_debug": 0.8217524886131287
    },
    {
        "func_name": "bb_strtoull",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040BDA6 | 55 | push    rbp\n0x0040BDA7 | 48 89 E5 | mov     rbp, rsp\n0x0040BDAA | 48 83 EC 30 | sub     rsp, 30h\n0x0040BDAE | 48 89 7D E8 | mov     [rbp+nptr], rdi\n0x0040BDB2 | 48 89 75 E0 | mov     [rbp+endptr], rsi\n0x0040BDB6 | 89 55 DC | mov     [rbp+base], edx\n0x0040BDB9 | 48 83 7D E0 00 | cmp     [rbp+endptr], 0\n0x0040BDBE | 75 08 | jnz     short loc_40BDC8\n0x0040BDC0 | 48 8D 45 F0 | lea     rax, [rbp+var_10]\n0x0040BDC4 | 48 89 45 E0 | mov     [rbp+endptr], rax\n0x0040BDC8 | 48 8B 45 E0 | mov     rax, [rbp+endptr]\n0x0040BDCC | 48 8B 55 E8 | mov     rdx, [rbp+nptr]\n0x0040BDD0 | 48 89 10 | mov     [rax], rdx\n0x0040BDD3 | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x0040BDD7 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0040BDDA | 0F B6 C0 | movzx   eax, al\n0x0040BDDD | 89 C7 | mov     edi, eax\n0x0040BDDF | E8 0E FF FF FF | call    sub_40BCF2\n0x0040BDE4 | 85 C0 | test    eax, eax\n0x0040BDE6 | 75 07 | jnz     short loc_40BDEF\n0x0040BDE8 | E8 43 FF FF FF | call    sub_40BD30\n0x0040BDED | EB 3A | jmp     short locret_40BE29\n0x0040BDEF | 48 8B 05 0A 16 35 00 | mov     rax, cs:qword_75D400\n0x0040BDF6 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0\n0x0040BDFC | 8B 55 DC | mov     edx, [rbp+base]; base\n0x0040BDFF | 48 8B 4D E0 | mov     rcx, [rbp+endptr]\n0x0040BE03 | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x0040BE07 | 48 89 CE | mov     rsi, rcx; endptr\n0x0040BE0A | 48 89 C7 | mov     rdi, rax; nptr\n0x0040BE0D | E8 CE B1 FF FF | call    _strtoull\n0x0040BE12 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0040BE16 | 48 8B 55 E0 | mov     rdx, [rbp+endptr]\n0x0040BE1A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0040BE1E | 48 89 D6 | mov     rsi, rdx\n0x0040BE21 | 48 89 C7 | mov     rdi, rax\n0x0040BE24 | E8 21 FF FF FF | call    sub_40BD4A\n0x0040BE29 | C9 | leave\n0x0040BE2A | C3 | retn",
        "output": "",
        "source_code": "unsigned long long FAST_FUNC bb_strtoull(const char *arg, char **endp, int base)\n{\n\tunsigned long long v;\n\tchar *endptr;\n\n\tif (!endp) endp = &endptr;\n\t*endp = (char*) arg;\n\n\t/* strtoul(\"  -4200000000\") returns 94967296, errno 0 (!) */\n\t/* I don't think that this is right. Preventing this... */\n\tif (!isalnum(arg[0])) return ret_ERANGE();\n\n\t/* not 100% correct for lib func, but convenient for the caller */\n\terrno = 0;\n\tv = strtoull(arg, endp, base);\n\treturn handle_errors(v, endp);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_40BDA6(const char *a1, char **a2, int a3)\n{\n  __int64 v3; // rdi\n  char **endptr; // [rsp+10h] [rbp-20h]\n  char v8; // [rsp+20h] [rbp-10h] BYREF\n  __int64 v9; // [rsp+28h] [rbp-8h]\n\n  endptr = a2;\n  if ( !a2 )\n    endptr = (char **)&v8;\n  *endptr = (char *)a1;\n  v3 = *(unsigned __int8 *)a1;\n  if ( !sub_40BCF2(v3) )\n    return sub_40BD30(v3);\n  *(_DWORD *)qword_75D400 = 0;\n  v9 = strtoull(a1, endptr, a3);\n  return sub_40BD4A(v9, (unsigned __int8 **)endptr);\n}\n",
        "baseline_code_debug": "unsigned __int64 __cdecl bb_strtoull(const char *arg, char **endp, int base)\n{\n  char **endpa; // [rsp+10h] [rbp-20h]\n  char *endptr; // [rsp+20h] [rbp-10h] BYREF\n  unsigned __int64 v; // [rsp+28h] [rbp-8h]\n\n  endpa = endp;\n  if ( !endp )\n    endpa = &endptr;\n  *endpa = (char *)arg;\n  if ( !bb_ascii_isalnum(*arg) )\n    return ret_ERANGE();\n  *bb_errno = 0;\n  v = strtoull(arg, endpa, base);\n  return handle_errors(v, endpa);\n}\n",
        "similarity_score_unixcoder": 0.04032487794756889,
        "similarity_score_baseline_stripped": 0.5122089385986328,
        "similarity_score_baseline_debug": 0.8585160374641418
    }
]
[
    {
        "func_name": "dot_right",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004ED9FB | 55 | push    rbp\n0x004ED9FC | 48 89 E5 | mov     rbp, rsp\n0x004ED9FF | 48 8B 05 02 FA 26 00 | mov     rax, cs:qword_75D408\n0x004EDA06 | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x004EDA0A | 48 8B 05 F7 F9 26 00 | mov     rax, cs:qword_75D408\n0x004EDA11 | 48 8B 00 | mov     rax, [rax]\n0x004EDA14 | 48 39 C2 | cmp     rdx, rax\n0x004EDA17 | 76 29 | jbe     short loc_4EDA42\n0x004EDA19 | 48 8B 05 E8 F9 26 00 | mov     rax, cs:qword_75D408\n0x004EDA20 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004EDA24 | 48 83 E8 01 | sub     rax, 1\n0x004EDA28 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004EDA2B | 3C 0A | cmp     al, 0Ah\n0x004EDA2D | 74 13 | jz      short loc_4EDA42\n0x004EDA2F | 48 8B 05 D2 F9 26 00 | mov     rax, cs:qword_75D408\n0x004EDA36 | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x004EDA3A | 48 83 EA 01 | sub     rdx, 1\n0x004EDA3E | 48 89 50 10 | mov     [rax+10h], rdx\n0x004EDA42 | 90 | nop\n0x004EDA43 | 5D | pop     rbp\n0x004EDA44 | C3 | retn\n\n Ourput decompiled code:\nstatic void dot_left(void)\n{\n\tif (dot > text && dot[-1] != '\\n')\n\t\tdot--;\n}\n\n## Example:\n\n Input assembly code:\n0x00495FC0 | 55 | push    rbp\n0x00495FC1 | 48 89 E5 | mov     rbp, rsp\n0x00495FC4 | 48 8B 05 3D 74 2C 00 | mov     rax, cs:qword_75D408\n0x00495FCB | 8B 50 58 | mov     edx, [rax+58h]\n0x00495FCE | 83 EA 01 | sub     edx, 1\n0x00495FD1 | 89 50 58 | mov     [rax+58h], edx\n0x00495FD4 | 48 8B 05 2D 74 2C 00 | mov     rax, cs:qword_75D408\n0x00495FDB | 8B 40 58 | mov     eax, [rax+58h]\n0x00495FDE | 83 F8 1F | cmp     eax, 1Fh\n0x00495FE1 | 7F 49 | jg      short loc_49602C\n0x00495FE3 | 48 8B 05 1E 74 2C 00 | mov     rax, cs:qword_75D408\n0x00495FEA | 48 8B 15 17 74 2C 00 | mov     rdx, cs:qword_75D408\n0x00495FF1 | 8B 52 58 | mov     edx, [rdx+58h]\n0x00495FF4 | 48 63 D2 | movsxd  rdx, edx\n0x00495FF7 | 48 83 C2 0C | add     rdx, 0Ch\n0x00495FFB | 48 8B 04 D0 | mov     rax, [rax+rdx*8]\n0x00495FFF | C6 00 00 | mov     byte ptr [rax], 0\n0x00496002 | 48 8B 05 FF 73 2C 00 | mov     rax, cs:qword_75D408\n0x00496009 | 8B 40 58 | mov     eax, [rax+58h]\n0x0049600C | 85 C0 | test    eax, eax\n0x0049600E | 75 1C | jnz     short loc_49602C\n0x00496010 | 48 8B 05 F1 73 2C 00 | mov     rax, cs:qword_75D408\n0x00496017 | C6 80 A4 15 00 00 2F | mov     byte ptr [rax+15A4h], 2Fh ; '/'\n0x0049601E | 48 8B 05 E3 73 2C 00 | mov     rax, cs:qword_75D408\n0x00496025 | C6 80 A5 15 00 00 00 | mov     byte ptr [rax+15A5h], 0\n0x0049602C | 90 | nop\n0x0049602D | 5D | pop     rbp\n0x0049602E | C3 | retn\n\n Ourput decompiled code:\nstatic void pop_filename(void)\n{\n\tname_depth--;\n\tif (name_depth < MAX_DEPTH) {\n\t\t*name_component[name_depth] = '\\0';\n\t\tif (!name_depth) {\n\t\t\tcurrent_name[0] = '/';\n\t\t\tcurrent_name[1] = '\\0';\n\t\t}\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x004EDCAC | 55 | push    rbp\n0x004EDCAD | 48 89 E5 | mov     rbp, rsp\n0x004EDCB0 | EB 13 | jmp     short loc_4EDCC5\n0x004EDCB2 | 48 8B 05 4F F7 26 00 | mov     rax, cs:qword_75D408\n0x004EDCB9 | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x004EDCBD | 48 83 C2 01 | add     rdx, 1\n0x004EDCC1 | 48 89 50 10 | mov     [rax+10h], rdx\n0x004EDCC5 | 48 8B 05 3C F7 26 00 | mov     rax, cs:qword_75D408\n0x004EDCCC | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004EDCD0 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004EDCD3 | 83 E8 09 | sub     eax, 9\n0x004EDCD6 | 88 45 FF | mov     [rbp+var_1], al\n0x004EDCD9 | 80 7D FF 17 | cmp     [rbp+var_1], 17h\n0x004EDCDD | 74 06 | jz      short loc_4EDCE5\n0x004EDCDF | 80 7D FF 04 | cmp     [rbp+var_1], 4\n0x004EDCE3 | 77 07 | ja      short loc_4EDCEC\n0x004EDCE5 | B8 01 00 00 00 | mov     eax, 1\n0x004EDCEA | EB 05 | jmp     short loc_4EDCF1\n0x004EDCEC | B8 00 00 00 00 | mov     eax, 0\n0x004EDCF1 | 85 C0 | test    eax, eax\n0x004EDCF3 | 74 31 | jz      short loc_4EDD26\n0x004EDCF5 | 48 8B 05 0C F7 26 00 | mov     rax, cs:qword_75D408\n0x004EDCFC | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004EDD00 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004EDD03 | 3C 0A | cmp     al, 0Ah\n0x004EDD05 | 74 1F | jz      short loc_4EDD26\n0x004EDD07 | 48 8B 05 FA F6 26 00 | mov     rax, cs:qword_75D408\n0x004EDD0E | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x004EDD12 | 48 8B 05 EF F6 26 00 | mov     rax, cs:qword_75D408\n0x004EDD19 | 48 8B 40 08 | mov     rax, [rax+8]\n0x004EDD1D | 48 83 E8 01 | sub     rax, 1\n0x004EDD21 | 48 39 C2 | cmp     rdx, rax\n0x004EDD24 | 72 8C | jb      short loc_4EDCB2\n0x004EDD26 | 90 | nop\n0x004EDD27 | 5D | pop     rbp\n0x004EDD28 | C3 | retn\n\n Ourput decompiled code:\nstatic void dot_skip_over_ws(void)\n{\n\t// skip WS\n\twhile (isspace(*dot) && *dot != '\\n' && dot < end - 1)\n\t\tdot++;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004EDA45 | 55 | push    rbp\n0x004EDA46 | 48 89 E5 | mov     rbp, rsp\n0x004EDA49 | 48 8B 05 B8 F9 26 00 | mov     rax, cs:qword_75D408\n0x004EDA50 | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x004EDA54 | 48 8B 05 AD F9 26 00 | mov     rax, cs:qword_75D408\n0x004EDA5B | 48 8B 40 08 | mov     rax, [rax+8]\n0x004EDA5F | 48 83 E8 01 | sub     rax, 1\n0x004EDA63 | 48 39 C2 | cmp     rdx, rax\n0x004EDA66 | 73 25 | jnb     short loc_4EDA8D\n0x004EDA68 | 48 8B 05 99 F9 26 00 | mov     rax, cs:qword_75D408\n0x004EDA6F | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004EDA73 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004EDA76 | 3C 0A | cmp     al, 0Ah\n0x004EDA78 | 74 13 | jz      short loc_4EDA8D\n0x004EDA7A | 48 8B 05 87 F9 26 00 | mov     rax, cs:qword_75D408\n0x004EDA81 | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x004EDA85 | 48 83 C2 01 | add     rdx, 1\n0x004EDA89 | 48 89 50 10 | mov     [rax+10h], rdx\n0x004EDA8D | 90 | nop\n0x004EDA8E | 5D | pop     rbp\n0x004EDA8F | C3 | retn",
        "output": "\n\nstatic void dot_right(void)\n{\n\tif (dot < end - 1 && *dot != '\\n')\n\t\tdot++;\n}",
        "source_code": "static void dot_right(void)\n{\n\tif (dot < end - 1 && *dot != '\\n')\n\t\tdot++;\n}",
        "parsed_output": "\n\nstatic void dot_right(void)\n{\n\tif (dot < end - 1 && *dot != '\\n')\n\t\tdot++;\n}",
        "baseline_code_stripped": "unsigned __int64 sub_4EDA45()\n{\n  unsigned __int64 result; // rax\n\n  result = *((_QWORD *)qword_75D408 + 1) - 1LL;\n  if ( *((_QWORD *)qword_75D408 + 2) < result )\n  {\n    result = **((unsigned __int8 **)qword_75D408 + 2);\n    if ( (_BYTE)result != 10 )\n    {\n      result = (unsigned __int64)qword_75D408;\n      ++*((_QWORD *)qword_75D408 + 2);\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl dot_right()\n{\n  if ( ptr_to_globals->fakehost < ptr_to_globals->login - 1 && *ptr_to_globals->fakehost != 10 )\n    ++ptr_to_globals->fakehost;\n}\n",
        "similarity_score_unixcoder": 0.969274640083313,
        "similarity_score_baseline_stripped": 0.4882625937461853,
        "similarity_score_baseline_debug": 0.6868862509727478
    },
    {
        "func_name": "block_CHLD_HUP_ALRM",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00482419 | 55 | push    rbp\n0x0048241A | 48 89 E5 | mov     rbp, rsp\n0x0048241D | 48 83 EC 10 | sub     rsp, 10h\n0x00482421 | 48 89 7D F8 | mov     [rbp+s], rdi\n0x00482425 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x00482429 | BA 30 00 00 00 | mov     edx, 30h ; '0'; n\n0x0048242E | BE 00 00 00 00 | mov     esi, 0; c\n0x00482433 | 48 89 C7 | mov     rdi, rax; s\n0x00482436 | E8 15 49 F8 FF | call    _memset\n0x0048243B | E8 A0 FD FF FF | call    sub_4821E0\n0x00482440 | 48 89 C2 | mov     rdx, rax\n0x00482443 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x00482447 | 48 89 10 | mov     [rax], rdx\n0x0048244A | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x0048244E | 48 8B 10 | mov     rdx, [rax]\n0x00482451 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x00482455 | 48 89 50 08 | mov     [rax+8], rdx\n0x00482459 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x0048245D | 48 89 C7 | mov     rdi, rax\n0x00482460 | E8 97 FD FF FF | call    sub_4821FC\n0x00482465 | 90 | nop\n0x00482466 | C9 | leave\n0x00482467 | C3 | retn\n\n Ourput decompiled code:\nstatic void initialize_context(struct parse_context *ctx)\n{\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->pipe = ctx->list_head = new_pipe();\n\t/* Create the memory for command, roughly:\n\t * ctx->pipe->cmds = new struct command;\n\t * ctx->command = &ctx->pipe->cmds[0];\n\t */\n\tdone_command(ctx);\n}\n\n## Example:\n\n Input assembly code:\n0x004DA7BB | 55 | push    rbp\n0x004DA7BC | 48 89 E5 | mov     rbp, rsp\n0x004DA7BF | 48 83 EC 10 | sub     rsp, 10h\n0x004DA7C3 | 48 89 7D F8 | mov     [rbp+ptr], rdi\n0x004DA7C7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004DA7CB | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004DA7CF | 48 89 C7 | mov     rdi, rax; ptr\n0x004DA7D2 | E8 89 BE F2 FF | call    _free\n0x004DA7D7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004DA7DB | 48 8B 40 18 | mov     rax, [rax+18h]\n0x004DA7DF | 48 89 C7 | mov     rdi, rax; ptr\n0x004DA7E2 | E8 79 BE F2 FF | call    _free\n0x004DA7E7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004DA7EB | 48 8B 40 20 | mov     rax, [rax+20h]\n0x004DA7EF | 48 89 C7 | mov     rdi, rax; ptr\n0x004DA7F2 | E8 69 BE F2 FF | call    _free\n0x004DA7F7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004DA7FB | 48 89 C7 | mov     rdi, rax; ptr\n0x004DA7FE | E8 5D BE F2 FF | call    _free\n0x004DA803 | 90 | nop\n0x004DA804 | C9 | leave\n0x004DA805 | C3 | retn\n\n Ourput decompiled code:\nstatic void free_instance(struct fsck_instance *p)\n{\n\tfree(p->prog);\n\tfree(p->device);\n\tfree(p->base_device);\n\tfree(p);\n}\n\n## Example:\n\n Input assembly code:\n0x00481399 | 55 | push    rbp\n0x0048139A | 48 89 E5 | mov     rbp, rsp\n0x0048139D | 48 83 EC 10 | sub     rsp, 10h\n0x004813A1 | 48 89 7D F8 | mov     [rbp+s], rdi\n0x004813A5 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x004813A9 | 48 8B 00 | mov     rax, [rax]\n0x004813AC | 48 89 C7 | mov     rdi, rax; ptr\n0x004813AF | E8 AC 52 F8 FF | call    _free\n0x004813B4 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x004813B8 | BA 18 00 00 00 | mov     edx, 18h; n\n0x004813BD | BE 00 00 00 00 | mov     esi, 0; c\n0x004813C2 | 48 89 C7 | mov     rdi, rax; s\n0x004813C5 | E8 86 59 F8 FF | call    _memset\n0x004813CA | 90 | nop\n0x004813CB | C9 | leave\n0x004813CC | C3 | retn\n\n Ourput decompiled code:\nstatic void o_free(o_string *o)\n{\n\tfree(o->data);\n\tmemset(o, 0, sizeof(*o));\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00433B6A | 55 | push    rbp\n0x00433B6B | 48 89 E5 | mov     rbp, rsp\n0x00433B6E | 48 83 EC 10 | sub     rsp, 10h\n0x00433B72 | 48 89 7D F8 | mov     [rbp+set], rdi\n0x00433B76 | 48 8B 45 F8 | mov     rax, [rbp+set]\n0x00433B7A | 48 89 C7 | mov     rdi, rax; set\n0x00433B7D | E8 7E 35 FD FF | call    _sigemptyset\n0x00433B82 | 48 8B 45 F8 | mov     rax, [rbp+set]\n0x00433B86 | BE 11 00 00 00 | mov     esi, 11h; signo\n0x00433B8B | 48 89 C7 | mov     rdi, rax; set\n0x00433B8E | E8 FD 40 FD FF | call    _sigaddset\n0x00433B93 | 48 8B 45 F8 | mov     rax, [rbp+set]\n0x00433B97 | BE 01 00 00 00 | mov     esi, 1; signo\n0x00433B9C | 48 89 C7 | mov     rdi, rax; set\n0x00433B9F | E8 EC 40 FD FF | call    _sigaddset\n0x00433BA4 | 48 8B 45 F8 | mov     rax, [rbp+set]\n0x00433BA8 | BE 0E 00 00 00 | mov     esi, 0Eh; signo\n0x00433BAD | 48 89 C7 | mov     rdi, rax; set\n0x00433BB0 | E8 DB 40 FD FF | call    _sigaddset\n0x00433BB5 | 48 8B 55 F8 | mov     rdx, [rbp+set]; oset\n0x00433BB9 | 48 8B 45 F8 | mov     rax, [rbp+set]\n0x00433BBD | 48 89 C6 | mov     rsi, rax; set\n0x00433BC0 | BF 00 00 00 00 | mov     edi, 0; how\n0x00433BC5 | E8 76 2A FD FF | call    _sigprocmask\n0x00433BCA | 90 | nop\n0x00433BCB | C9 | leave\n0x00433BCC | C3 | retn",
        "output": "\n\nstatic void set_signal_mask(sigset_t *set)\n{\n\tsigemptyset(set);\n\tsigaddset(set, SIGUSR1);\n\tsigaddset(set, 1);\n\tsigaddset(set, 14);\n\tsigprocmask(0, set, set);\n}",
        "source_code": "static void block_CHLD_HUP_ALRM(sigset_t *m)\n{\n\tsigemptyset(m);\n\tsigaddset(m, SIGCHLD);\n\tsigaddset(m, SIGHUP);\n\tsigaddset(m, SIGALRM);\n\tsigprocmask(SIG_BLOCK, m, m); /* old sigmask is stored in m */\n}",
        "parsed_output": "\n\nstatic void set_signal_mask(sigset_t *set)\n{\n\tsigemptyset(set);\n\tsigaddset(set, SIGUSR1);\n\tsigaddset(set, 1);\n\tsigaddset(set, 14);\n\tsigprocmask(0, set, set);\n}",
        "baseline_code_stripped": "int __fastcall sub_433B6A(sigset_t *a1)\n{\n  sigemptyset(a1);\n  sigaddset(a1, 17);\n  sigaddset(a1, 1);\n  sigaddset(a1, 14);\n  return sigprocmask(0, a1, a1);\n}\n",
        "baseline_code_debug": "void __cdecl block_CHLD_HUP_ALRM(sigset_t *m)\n{\n  sigemptyset(m);\n  sigaddset(m, 17);\n  sigaddset(m, 1);\n  sigaddset(m, 14);\n  sigprocmask(0, m, m);\n}\n",
        "similarity_score_unixcoder": 0.7306624054908752,
        "similarity_score_baseline_stripped": 0.6758031845092773,
        "similarity_score_baseline_debug": 0.8925818800926208
    },
    {
        "func_name": "fopen_or_warn",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0040A1FC | 55 | push    rbp\n0x0040A1FD | 48 89 E5 | mov     rbp, rsp\n0x0040A200 | 48 83 EC 20 | sub     rsp, 20h\n0x0040A204 | 48 89 7D E8 | mov     [rbp+filename], rdi\n0x0040A208 | 48 89 75 E0 | mov     [rbp+modes], rsi\n0x0040A20C | 48 8B 55 E0 | mov     rdx, [rbp+modes]\n0x0040A210 | 48 8B 45 E8 | mov     rax, [rbp+filename]\n0x0040A214 | 48 89 D6 | mov     rsi, rdx; modes\n0x0040A217 | 48 89 C7 | mov     rdi, rax; filename\n0x0040A21A | E8 31 CF FF FF | call    _fopen64\n0x0040A21F | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0040A223 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0040A228 | 75 16 | jnz     short loc_40A240\n0x0040A22A | 48 8B 45 E8 | mov     rax, [rbp+filename]\n0x0040A22E | 48 89 C6 | mov     rsi, rax\n0x0040A231 | BF 0D 80 52 00 | mov     edi, offset aCanTOpenS; \"can't open '%s'\"\n0x0040A236 | B8 00 00 00 00 | mov     eax, 0\n0x0040A23B | E8 62 F0 FF FF | call    sub_4092A2\n0x0040A240 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0040A244 | C9 | leave\n0x0040A245 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC xfopen(const char *path, const char *mode)\n{\n\tFILE *fp = fopen(path, mode);\n\tif (fp == NULL)\n\t\tbb_perror_msg_and_die(\"can't open '%s'\", path);\n\treturn fp;\n}\n\n## Example:\n\n Input assembly code:\n0x005074C8 | 55 | push    rbp\n0x005074C9 | 48 89 E5 | mov     rbp, rsp\n0x005074CC | 48 83 EC 20 | sub     rsp, 20h\n0x005074D0 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x005074D4 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x005074D8 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x005074DC | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x005074E0 | 48 89 D6 | mov     rsi, rdx\n0x005074E3 | 48 89 C7 | mov     rdi, rax\n0x005074E6 | E8 0C FF FF FF | call    sub_5073F7\n0x005074EB | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x005074EF | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x005074F4 | 75 16 | jnz     short loc_50750C\n0x005074F6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x005074FA | 48 89 C6 | mov     rsi, rax\n0x005074FD | BF 94 75 53 00 | mov     edi, offset aCanTReadS_3; \"can't read '%s'\"\n0x00507502 | B8 00 00 00 00 | mov     eax, 0\n0x00507507 | E8 96 1D F0 FF | call    sub_4092A2\n0x0050750C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00507510 | C9 | leave\n0x00507511 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC xmalloc_xopen_read_close(const char *filename, size_t *maxsz_p)\n{\n\tvoid *buf = xmalloc_open_read_close(filename, maxsz_p);\n\tif (!buf)\n\t\tbb_perror_msg_and_die(\"can't read '%s'\", filename);\n\treturn buf;\n}\n\n## Example:\n\n Input assembly code:\n0x0040A09E | 55 | push    rbp\n0x0040A09F | 48 89 E5 | mov     rbp, rsp\n0x0040A0A2 | 48 83 EC 10 | sub     rsp, 10h\n0x0040A0A6 | 48 89 7D F8 | mov     [rbp+ptr], rdi\n0x0040A0AA | 48 89 75 F0 | mov     [rbp+size], rsi\n0x0040A0AE | 48 8B 55 F0 | mov     rdx, [rbp+size]\n0x0040A0B2 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x0040A0B6 | 48 89 D6 | mov     rsi, rdx; size\n0x0040A0B9 | 48 89 C7 | mov     rdi, rax; ptr\n0x0040A0BC | E8 EF D4 FF FF | call    _realloc\n0x0040A0C1 | 48 89 45 F8 | mov     [rbp+ptr], rax\n0x0040A0C5 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0\n0x0040A0CA | 75 16 | jnz     short loc_40A0E2\n0x0040A0CC | 48 83 7D F0 00 | cmp     [rbp+size], 0\n0x0040A0D1 | 74 0F | jz      short loc_40A0E2\n0x0040A0D3 | BF 2A 4D 53 00 | mov     edi, offset aOutOfMemory; \"out of memory\"\n0x0040A0D8 | B8 00 00 00 00 | mov     eax, 0\n0x0040A0DD | E8 BC F5 FF FF | call    sub_40969E\n0x0040A0E2 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x0040A0E6 | C9 | leave\n0x0040A0E7 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC xrealloc(void *ptr, size_t size)\n{\n\tptr = realloc(ptr, size);\n\tif (ptr == NULL && size != 0)\n\t\tbb_error_msg_and_die(bb_msg_memory_exhausted);\n\treturn ptr;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004097EE | 55 | push    rbp\n0x004097EF | 48 89 E5 | mov     rbp, rsp\n0x004097F2 | 48 83 EC 20 | sub     rsp, 20h\n0x004097F6 | 48 89 7D E8 | mov     [rbp+filename], rdi\n0x004097FA | 48 89 75 E0 | mov     [rbp+modes], rsi\n0x004097FE | 48 8B 55 E0 | mov     rdx, [rbp+modes]\n0x00409802 | 48 8B 45 E8 | mov     rax, [rbp+filename]\n0x00409806 | 48 89 D6 | mov     rsi, rdx; modes\n0x00409809 | 48 89 C7 | mov     rdi, rax; filename\n0x0040980C | E8 3F D9 FF FF | call    _fopen64\n0x00409811 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00409815 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0040981A | 75 0C | jnz     short loc_409828\n0x0040981C | 48 8B 45 E8 | mov     rax, [rbp+filename]\n0x00409820 | 48 89 C7 | mov     rdi, rax\n0x00409823 | E8 45 FB FF FF | call    sub_40936D\n0x00409828 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0040982C | C9 | leave\n0x0040982D | C3 | retn",
        "output": "\n\nstatic FAST_FUNC xfopen(const char *path, const char *mode)\n{\n\tFILE *fp = fopen(path, mode);\n\tif (fp == NULL)\n\t\tbb_perror_msg_and_die(\"can't open '%s'\", path);\n\treturn fp;\n}",
        "source_code": "FAST_FUNC fopen_or_warn(const char *path, const char *mode)\n{\n\tFILE *fp = fopen(path, mode);\n\tif (!fp) {\n\t\tbb_simple_perror_msg(path);\n\t\t//errno = 0; /* why? */\n\t}\n\treturn fp;\n}",
        "parsed_output": "\n\nstatic FAST_FUNC xfopen(const char *path, const char *mode)\n{\n\tFILE *fp = fopen(path, mode);\n\tif (fp == NULL)\n\t\tbb_perror_msg_and_die(\"can't open '%s'\", path);\n\treturn fp;\n}",
        "baseline_code_stripped": "FILE *__fastcall sub_4097EE(const char *a1, const char *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  FILE *v7; // [rsp+18h] [rbp-8h]\n\n  v7 = fopen64(a1, a2);\n  if ( !v7 )\n    sub_40936D((__int64)a1, (__int64)a2, v2, v3, v4, v5);\n  return v7;\n}\n",
        "baseline_code_debug": "FILE *__cdecl fopen_or_warn(const char *path, const char *mode)\n{\n  FILE *fp; // [rsp+18h] [rbp-8h]\n\n  fp = fopen64(path, mode);\n  if ( !fp )\n    bb_simple_perror_msg(path);\n  return fp;\n}\n",
        "similarity_score_unixcoder": 0.8983213901519775,
        "similarity_score_baseline_stripped": 0.5193501114845276,
        "similarity_score_baseline_debug": 0.8607019186019897
    },
    {
        "func_name": "monotonic_ns",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0040BC67 | 55 | push    rbp\n0x0040BC68 | 48 89 E5 | mov     rbp, rsp\n0x0040BC6B | 48 83 EC 10 | sub     rsp, 10h\n0x0040BC6F | 48 8D 45 F0 | lea     rax, [rbp+tv]\n0x0040BC73 | BE 00 00 00 00 | mov     esi, 0; tz\n0x0040BC78 | 48 89 C7 | mov     rdi, rax; tv\n0x0040BC7B | E8 40 B0 FF FF | call    _gettimeofday\n0x0040BC80 | 48 8B 45 F0 | mov     rax, [rbp+tv.tv_sec]\n0x0040BC84 | 48 69 C0 40 42 0F 00 | imul    rax, 0F4240h\n0x0040BC8B | 48 8B 55 F8 | mov     rdx, [rbp+tv.tv_usec]\n0x0040BC8F | 48 01 D0 | add     rax, rdx\n0x0040BC92 | C9 | leave\n0x0040BC93 | C3 | retn\n\n Ourput decompiled code:\nunsigned long long FAST_FUNC monotonic_us(void)\n{\n\tstruct timespec ts;\n\tget_mono(&ts);\n\treturn ts.tv_sec * 1000000ULL + ts.tv_nsec/1000;\n}\n\n## Example:\n\n Input assembly code:\n0x0040BC94 | 55 | push    rbp\n0x0040BC95 | 48 89 E5 | mov     rbp, rsp\n0x0040BC98 | 48 83 EC 10 | sub     rsp, 10h\n0x0040BC9C | 48 8D 45 F0 | lea     rax, [rbp+tv]\n0x0040BCA0 | BE 00 00 00 00 | mov     esi, 0; tz\n0x0040BCA5 | 48 89 C7 | mov     rdi, rax; tv\n0x0040BCA8 | E8 13 B0 FF FF | call    _gettimeofday\n0x0040BCAD | 48 8B 45 F0 | mov     rax, [rbp+tv.tv_sec]\n0x0040BCB1 | 48 69 F0 E8 03 00 00 | imul    rsi, rax, 3E8h\n0x0040BCB8 | 48 8B 4D F8 | mov     rcx, [rbp+tv.tv_usec]\n0x0040BCBC | 48 BA CF F7 53 E3 A5 9B C4 20 | mov     rdx, 20C49BA5E353F7CFh\n0x0040BCC6 | 48 89 C8 | mov     rax, rcx\n0x0040BCC9 | 48 F7 EA | imul    rdx\n0x0040BCCC | 48 C1 FA 07 | sar     rdx, 7\n0x0040BCD0 | 48 89 C8 | mov     rax, rcx\n0x0040BCD3 | 48 C1 F8 3F | sar     rax, 3Fh\n0x0040BCD7 | 48 29 C2 | sub     rdx, rax\n0x0040BCDA | 48 89 D0 | mov     rax, rdx\n0x0040BCDD | 48 01 F0 | add     rax, rsi\n0x0040BCE0 | C9 | leave\n0x0040BCE1 | C3 | retn\n\n Ourput decompiled code:\nunsigned long long FAST_FUNC monotonic_ms(void)\n{\n\tstruct timespec ts;\n\tget_mono(&ts);\n\treturn ts.tv_sec * 1000ULL + ts.tv_nsec/1000000;\n}\n\n## Example:\n\n Input assembly code:\n0x00436544 | 55 | push    rbp\n0x00436545 | 48 89 E5 | mov     rbp, rsp\n0x00436548 | 48 83 EC 10 | sub     rsp, 10h\n0x0043654C | 48 8D 45 F0 | lea     rax, [rbp+tv]\n0x00436550 | BE 00 00 00 00 | mov     esi, 0; tz\n0x00436555 | 48 89 C7 | mov     rdi, rax; tv\n0x00436558 | E8 63 07 FD FF | call    _gettimeofday\n0x0043655D | 48 8B 45 F0 | mov     rax, [rbp+tv.tv_sec]\n0x00436561 | 2D 80 81 55 7C | sub     eax, 7C558180h\n0x00436566 | 89 C7 | mov     edi, eax; hostlong\n0x00436568 | E8 C3 07 FD FF | call    _htonl\n0x0043656D | C9 | leave\n0x0043656E | C3 | retn\n\n Ourput decompiled code:\nstatic uint32_t machtime(void)\n{\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\treturn htonl((uint32_t)(tv.tv_sec + 2208988800));\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040BC33 | 55 | push    rbp\n0x0040BC34 | 48 89 E5 | mov     rbp, rsp\n0x0040BC37 | 48 83 EC 10 | sub     rsp, 10h\n0x0040BC3B | 48 8D 45 F0 | lea     rax, [rbp+tv]\n0x0040BC3F | BE 00 00 00 00 | mov     esi, 0; tz\n0x0040BC44 | 48 89 C7 | mov     rdi, rax; tv\n0x0040BC47 | E8 74 B0 FF FF | call    _gettimeofday\n0x0040BC4C | 48 8B 45 F0 | mov     rax, [rbp+tv.tv_sec]\n0x0040BC50 | 48 69 C0 00 CA 9A 3B | imul    rax, 3B9ACA00h\n0x0040BC57 | 48 8B 55 F8 | mov     rdx, [rbp+tv.tv_usec]\n0x0040BC5B | 48 69 D2 E8 03 00 00 | imul    rdx, 3E8h\n0x0040BC62 | 48 01 D0 | add     rax, rdx\n0x0040BC65 | C9 | leave\n0x0040BC66 | C3 | retn",
        "output": "\n\nstatic unsigned long long FAST_FUNC monotonic_ns(void)\n{\n\tstruct timespec ts;\n\tget_mono(&ts);\n\treturn ts.tv_sec * 1000000000ULL + ts.tv_nsec;\n}",
        "source_code": "unsigned long long FAST_FUNC monotonic_ns(void)\n{\n\tstruct timespec ts;\n\tget_mono(&ts);\n\treturn ts.tv_sec * 1000000000ULL + ts.tv_nsec;\n}",
        "parsed_output": "\n\nstatic unsigned long long FAST_FUNC monotonic_ns(void)\n{\n\tstruct timespec ts;\n\tget_mono(&ts);\n\treturn ts.tv_sec * 1000000000ULL + ts.tv_nsec;\n}",
        "baseline_code_stripped": "__suseconds_t sub_40BC33()\n{\n  struct timeval tv; // [rsp+0h] [rbp-10h] BYREF\n\n  gettimeofday(&tv, 0LL);\n  return 1000 * tv.tv_usec + 1000000000 * tv.tv_sec;\n}\n",
        "baseline_code_debug": "unsigned __int64 __cdecl monotonic_ns()\n{\n  timeval tv; // [rsp+0h] [rbp-10h] BYREF\n\n  gettimeofday(&tv, 0LL);\n  return 1000 * tv.tv_usec + 1000000000 * tv.tv_sec;\n}\n",
        "similarity_score_unixcoder": 0.987783670425415,
        "similarity_score_baseline_stripped": 0.5797103643417358,
        "similarity_score_baseline_debug": 0.7561351656913757
    },
    {
        "func_name": "rtc_tm2time",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0042B3F8 | 55 | push    rbp\n0x0042B3F9 | 48 89 E5 | mov     rbp, rsp\n0x0042B3FC | 48 83 EC 20 | sub     rsp, 20h\n0x0042B400 | 48 89 7D E8 | mov     [rbp+s], rdi\n0x0042B404 | 89 75 E4 | mov     [rbp+var_1C], esi\n0x0042B407 | 83 7D E4 00 | cmp     [rbp+var_1C], 0\n0x0042B40B | 74 48 | jz      short loc_42B455\n0x0042B40D | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x0042B411 | BE 4D 98 40 00 | mov     esi, offset sub_40984D\n0x0042B416 | 48 89 C7 | mov     rdi, rax\n0x0042B419 | E8 32 70 0D 00 | call    sub_502450\n0x0042B41E | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0042B422 | EB 11 | jmp     short loc_42B435\n0x0042B424 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x0042B428 | BE 00 00 00 00 | mov     esi, 0\n0x0042B42D | 48 89 C7 | mov     rdi, rax\n0x0042B430 | E8 C3 FF FF FF | call    sub_42B3F8\n0x0042B435 | 48 8D 75 E8 | lea     rsi, [rbp+s]\n0x0042B439 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0042B43D | B9 FA 58 53 00 | mov     ecx, offset asc_5358FA; \"# \\t\"\n0x0042B442 | BA 01 01 43 00 | mov     edx, 430101h\n0x0042B447 | 48 89 C7 | mov     rdi, rax\n0x0042B44A | E8 4C 72 0D 00 | call    sub_50269B\n0x0042B44F | 85 C0 | test    eax, eax\n0x0042B451 | 75 D1 | jnz     short loc_42B424\n0x0042B453 | EB 31 | jmp     short loc_42B486\n0x0042B455 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x0042B459 | 48 89 C7 | mov     rdi, rax; s\n0x0042B45C | E8 6F B6 FD FF | call    _strlen\n0x0042B461 | 48 89 C2 | mov     rdx, rax\n0x0042B464 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x0042B468 | 48 89 D6 | mov     rsi, rdx; len\n0x0042B46B | 48 89 C7 | mov     rdi, rax; name\n0x0042B46E | E8 6D BC FD FF | call    _sethostname\n0x0042B473 | 85 C0 | test    eax, eax\n0x0042B475 | 74 0F | jz      short loc_42B486\n0x0042B477 | BF FE 58 53 00 | mov     edi, offset aSethostname_0; \"sethostname\"\n0x0042B47C | B8 00 00 00 00 | mov     eax, 0\n0x0042B481 | E8 1C DE FD FF | call    sub_4092A2\n0x0042B486 | 90 | nop\n0x0042B487 | C9 | leave\n0x0042B488 | C3 | retn\n\n Ourput decompiled code:\nstatic void do_sethostname(char *s, int isfile)\n{\n//\tif (!s)\n//\t\treturn;\n\tif (isfile) {\n\t\tparser_t *parser = config_open2(s, xfopen_for_read);\n\t\twhile (config_read(parser, &s, 1, 1, \"# \\t\", PARSE_NORMAL & ~PARSE_GREEDY)) {\n\t\t\tdo_sethostname(s, 0);\n\t\t}\n\t\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\t\tconfig_close(parser);\n\t} else if (sethostname(s, strlen(s))) {\n//\t\tif (errno == EPERM)\n//\t\t\tbb_error_msg_and_die(bb_msg_perm_denied_are_you_root);\n\t\tbb_perror_msg_and_die(\"sethostname\");\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x0040B309 | 55 | push    rbp\n0x0040B30A | 48 89 E5 | mov     rbp, rsp\n0x0040B30D | 48 83 EC 20 | sub     rsp, 20h\n0x0040B311 | 89 7D EC | mov     [rbp+var_14], edi\n0x0040B314 | 89 75 E8 | mov     [rbp+var_18], esi\n0x0040B317 | 48 89 55 E0 | mov     [rbp+var_20], rdx\n0x0040B31B | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x0040B31F | 8B 4D E8 | mov     ecx, [rbp+var_18]\n0x0040B322 | 8B 45 EC | mov     eax, [rbp+var_14]\n0x0040B325 | 89 CE | mov     esi, ecx\n0x0040B327 | 89 C7 | mov     edi, eax\n0x0040B329 | E8 A6 FF FF FF | call    sub_40B2D4\n0x0040B32E | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0040B332 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0040B336 | 48 99 | cqo\n0x0040B338 | 48 89 D0 | mov     rax, rdx\n0x0040B33B | 48 33 45 E0 | xor     rax, [rbp+var_20]\n0x0040B33F | 48 29 D0 | sub     rax, rdx\n0x0040B342 | 48 39 45 F8 | cmp     [rbp+var_8], rax\n0x0040B346 | 74 1B | jz      short loc_40B363\n0x0040B348 | 48 83 7D F8 FF | cmp     [rbp+var_8], 0FFFFFFFFFFFFFFFFh\n0x0040B34D | 74 0F | jz      short loc_40B35E\n0x0040B34F | BF 0C 50 53 00 | mov     edi, offset aShortRead; \"short read\"\n0x0040B354 | B8 00 00 00 00 | mov     eax, 0\n0x0040B359 | E8 40 E3 FF FF | call    sub_40969E\n0x0040B35E | E8 CC E5 FF FF | call    sub_40992F\n0x0040B363 | 90 | nop\n0x0040B364 | C9 | leave\n0x0040B365 | C3 | retn\n\n Ourput decompiled code:\nvoid FAST_FUNC bb_copyfd_exact_size(int fd1, int fd2, off_t size)\n{\n\toff_t sz = bb_copyfd_size(fd1, fd2, size);\n\tif (sz == (size >= 0 ? size : -size))\n\t\treturn;\n\tif (sz != -1)\n\t\tbb_error_msg_and_die(\"short read\");\n\t/* if sz == -1, bb_copyfd_XX already complained */\n\txfunc_die();\n}\n\n## Example:\n\n Input assembly code:\n0x0043A15B | 55 | push    rbp\n0x0043A15C | 48 89 E5 | mov     rbp, rsp\n0x0043A15F | 48 83 EC 30 | sub     rsp, 30h\n0x0043A163 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0043A167 | 89 75 E4 | mov     [rbp+var_1C], esi\n0x0043A16A | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x0043A16E | 89 4D E0 | mov     [rbp+var_20], ecx\n0x0043A171 | 83 7D E0 00 | cmp     [rbp+var_20], 0\n0x0043A175 | 74 0E | jz      short loc_43A185\n0x0043A177 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043A17B | 48 89 C7 | mov     rdi, rax\n0x0043A17E | E8 5B 1E 0D 00 | call    sub_50BFDE\n0x0043A183 | EB 0C | jmp     short loc_43A191\n0x0043A185 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043A189 | 48 89 C7 | mov     rdi, rax\n0x0043A18C | E8 F0 1D 0D 00 | call    sub_50BF81\n0x0043A191 | 48 89 45 F8 | mov     [rbp+ptr], rax\n0x0043A195 | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x0043A198 | 0F B7 C0 | movzx   eax, ax\n0x0043A19B | 89 C7 | mov     edi, eax; hostshort\n0x0043A19D | E8 CE C9 FC FF | call    _htons\n0x0043A1A2 | 0F B7 C0 | movzx   eax, ax\n0x0043A1A5 | 8B 55 E0 | mov     edx, [rbp+var_20]\n0x0043A1A8 | 48 8B 4D D8 | mov     rcx, [rbp+var_28]\n0x0043A1AC | 48 89 CE | mov     rsi, rcx\n0x0043A1AF | 89 C7 | mov     edi, eax\n0x0043A1B1 | E8 42 FF FF FF | call    sub_43A0F8\n0x0043A1B6 | 48 89 C2 | mov     rdx, rax\n0x0043A1B9 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x0043A1BD | 48 89 C6 | mov     rsi, rax\n0x0043A1C0 | BF 0F A0 51 00 | mov     edi, offset aSS_19; \"%s:%s\"\n0x0043A1C5 | B8 00 00 00 00 | mov     eax, 0\n0x0043A1CA | E8 E4 04 FD FF | call    sub_40A6B3\n0x0043A1CF | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x0043A1D3 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x0043A1D7 | 48 89 C7 | mov     rdi, rax; ptr\n0x0043A1DA | E8 81 C4 FC FF | call    _free\n0x0043A1DF | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0043A1E3 | C9 | leave\n0x0043A1E4 | C3 | retn\n\n Ourput decompiled code:\nstatic char *ip_port_str(struct sockaddr *addr, int port, const char *proto, int numeric)\n{\n\tchar *host, *host_port;\n\n\t/* Code which used \"*\" for INADDR_ANY is removed: it's ambiguous\n\t * in IPv6, while \"0.0.0.0\" is not. */\n\n\thost = numeric ? xmalloc_sockaddr2dotted_noport(addr)\n\t               : xmalloc_sockaddr2host_noport(addr);\n\n\thost_port = xasprintf(\"%s:%s\", host, get_sname(htons(port), proto, numeric));\n\tfree(host);\n\treturn host_port;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00507D06 | 55 | push    rbp\n0x00507D07 | 48 89 E5 | mov     rbp, rsp\n0x00507D0A | 48 83 EC 20 | sub     rsp, 20h\n0x00507D0E | 48 89 7D E8 | mov     [rbp+tp], rdi\n0x00507D12 | 89 75 E4 | mov     [rbp+var_1C], esi\n0x00507D15 | 83 7D E4 00 | cmp     [rbp+var_1C], 0\n0x00507D19 | 74 1D | jz      short loc_507D38\n0x00507D1B | BF E2 75 53 00 | mov     edi, offset aTz; \"TZ\"\n0x00507D20 | E8 EB E8 EF FF | call    _getenv\n0x00507D25 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00507D29 | BF E5 75 53 00 | mov     edi, offset aTzUtc0_0; \"TZ=UTC0\"\n0x00507D2E | E8 DD F2 EF FF | call    _putenv\n0x00507D33 | E8 D8 F4 EF FF | call    _tzset\n0x00507D38 | 48 8B 45 E8 | mov     rax, [rbp+tp]\n0x00507D3C | 48 89 C7 | mov     rdi, rax; tp\n0x00507D3F | E8 8C F7 EF FF | call    _mktime\n0x00507D44 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x00507D48 | 83 7D E4 00 | cmp     [rbp+var_1C], 0\n0x00507D4C | 74 26 | jz      short loc_507D74\n0x00507D4E | BF E2 75 53 00 | mov     edi, offset aTz; \"TZ\"\n0x00507D53 | E8 88 FB EF FF | call    _unsetenv\n0x00507D58 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00507D5D | 74 10 | jz      short loc_507D6F\n0x00507D5F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00507D63 | 48 83 E8 03 | sub     rax, 3\n0x00507D67 | 48 89 C7 | mov     rdi, rax; string\n0x00507D6A | E8 A1 F2 EF FF | call    _putenv\n0x00507D6F | E8 9C F4 EF FF | call    _tzset\n0x00507D74 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00507D78 | C9 | leave\n0x00507D79 | C3 | retn",
        "output": "\n\nstatic time_t FAST_FUNC do_time(time_t *t)\n{\n\ttime_t ret;\n\tchar *tz;\n\n\tif (*t)\n\t\treturn *t;\n\n\ttz = getenv(\"TZ\");\n\tputenv(\"TZ=UTC0\");\n\ttzset();\n\tret = mktime(t);\n\tif (*t) {\n\t\tunsetenv(\"TZ\");\n\t\tif (tz)\n\t\t\tputenv(tz - 3);\n\t}\n\ttzset();\n\treturn ret;\n}",
        "source_code": "time_t FAST_FUNC rtc_tm2time(struct tm *ptm, int utc)\n{\n\tchar *oldtz = oldtz; /* for compiler */\n\ttime_t t;\n\n\tif (utc) {\n\t\toldtz = getenv(\"TZ\");\n\t\tputenv((char*)\"TZ=UTC0\");\n\t\ttzset();\n\t}\n\n\tt = mktime(ptm);\n\n\tif (utc) {\n\t\tunsetenv(\"TZ\");\n\t\tif (oldtz)\n\t\t\tputenv(oldtz - 3);\n\t\ttzset();\n\t}\n\n\treturn t;\n}",
        "parsed_output": "\n\nstatic time_t FAST_FUNC do_time(time_t *t)\n{\n\ttime_t ret;\n\tchar *tz;\n\n\tif (*t)\n\t\treturn *t;\n\n\ttz = getenv(\"TZ\");\n\tputenv(\"TZ=UTC0\");\n\ttzset();\n\tret = mktime(t);\n\tif (*t) {\n\t\tunsetenv(\"TZ\");\n\t\tif (tz)\n\t\t\tputenv(tz - 3);\n\t}\n\ttzset();\n\treturn ret;\n}",
        "baseline_code_stripped": "time_t __fastcall sub_507D06(struct tm *a1, int a2)\n{\n  time_t v3; // [rsp+10h] [rbp-10h]\n  char *v4; // [rsp+18h] [rbp-8h]\n\n  if ( a2 )\n  {\n    v4 = getenv(\"TZ\");\n    putenv(\"TZ=UTC0\");\n    tzset();\n  }\n  v3 = mktime(a1);\n  if ( a2 )\n  {\n    unsetenv(\"TZ\");\n    if ( v4 )\n      putenv(v4 - 3);\n    tzset();\n  }\n  return v3;\n}\n",
        "baseline_code_debug": "time_t __cdecl rtc_tm2time(tm *ptm, int utc)\n{\n  time_t t; // [rsp+10h] [rbp-10h]\n  char *oldtz; // [rsp+18h] [rbp-8h]\n\n  if ( utc )\n  {\n    oldtz = getenv(\"TZ\");\n    putenv(\"TZ=UTC0\");\n    tzset();\n  }\n  t = mktime(ptm);\n  if ( utc )\n  {\n    unsetenv(\"TZ\");\n    if ( oldtz )\n      putenv(oldtz - 3);\n    tzset();\n  }\n  return t;\n}\n",
        "similarity_score_unixcoder": 0.9103730916976929,
        "similarity_score_baseline_stripped": 0.7975502610206604,
        "similarity_score_baseline_debug": 0.9317933917045593
    },
    {
        "func_name": "hash_bin_to_hex",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0050BD71 | 55 | push    rbp\n0x0050BD72 | 48 89 E5 | mov     rbp, rsp\n0x0050BD75 | 48 83 EC 20 | sub     rsp, 20h\n0x0050BD79 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0050BD7D | 89 75 E4 | mov     [rbp+var_1C], esi\n0x0050BD80 | 8B 55 E4 | mov     edx, [rbp+var_1C]\n0x0050BD83 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0050BD87 | 89 D6 | mov     esi, edx\n0x0050BD89 | 48 89 C7 | mov     rdi, rax\n0x0050BD8C | E8 99 FD FF FF | call    sub_50BB2A\n0x0050BD91 | 48 89 45 F8 | mov     [rbp+ptr], rax\n0x0050BD95 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x0050BD99 | 0F B7 40 04 | movzx   eax, word ptr [rax+4]\n0x0050BD9D | 0F B7 C0 | movzx   eax, ax\n0x0050BDA0 | BA 00 00 00 00 | mov     edx, 0\n0x0050BDA5 | BE 01 00 00 00 | mov     esi, 1\n0x0050BDAA | 89 C7 | mov     edi, eax\n0x0050BDAC | E8 E8 EB EF FF | call    sub_40A999\n0x0050BDB1 | 89 45 F4 | mov     [rbp+var_C], eax\n0x0050BDB4 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x0050BDB7 | 89 C7 | mov     edi, eax\n0x0050BDB9 | E8 90 F5 FF FF | call    sub_50B34E\n0x0050BDBE | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x0050BDC2 | 8B 10 | mov     edx, [rax]\n0x0050BDC4 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x0050BDC8 | 48 8D 48 04 | lea     rcx, [rax+4]\n0x0050BDCC | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x0050BDCF | 48 89 CE | mov     rsi, rcx\n0x0050BDD2 | 89 C7 | mov     edi, eax\n0x0050BDD4 | E8 04 F7 FF FF | call    sub_50B4DD\n0x0050BDD9 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x0050BDDD | 48 89 C7 | mov     rdi, rax; ptr\n0x0050BDE0 | E8 7B A8 EF FF | call    _free\n0x0050BDE5 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x0050BDE8 | C9 | leave\n0x0050BDE9 | C3 | retn\n\n Ourput decompiled code:\nint FAST_FUNC create_and_connect_stream_or_die(const char *peer, int port)\n{\n\tint fd;\n\tlen_and_sockaddr *lsa;\n\n\tlsa = xhost2sockaddr(peer, port);\n\tfd = xsocket(lsa->u.sa.sa_family, SOCK_STREAM, 0);\n\tsetsockopt_reuseaddr(fd);\n\txconnect(fd, &lsa->u.sa, lsa->len);\n\tfree(lsa);\n\treturn fd;\n}\n\n## Example:\n\n Input assembly code:\n0x0049A1CE | 55 | push    rbp\n0x0049A1CF | 48 89 E5 | mov     rbp, rsp\n0x0049A1D2 | 48 83 EC 50 | sub     rsp, 50h\n0x0049A1D6 | 48 89 7D B8 | mov     [rbp+var_48], rdi\n0x0049A1DA | 89 75 B4 | mov     [rbp+var_4C], esi\n0x0049A1DD | 48 8B 45 B8 | mov     rax, [rbp+var_48]\n0x0049A1E1 | BE 00 00 00 00 | mov     esi, 0\n0x0049A1E6 | 48 89 C7 | mov     rdi, rax\n0x0049A1E9 | E8 2D DA 06 00 | call    sub_507C1B\n0x0049A1EE | 89 45 FC | mov     [rbp+var_4], eax\n0x0049A1F1 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x0049A1F4 | 48 8D 45 C0 | lea     rax, [rbp+var_40]\n0x0049A1F8 | 89 D6 | mov     esi, edx\n0x0049A1FA | 48 89 C7 | mov     rdi, rax\n0x0049A1FD | E8 B9 DA 06 00 | call    sub_507CBB\n0x0049A202 | 8B 55 B4 | mov     edx, [rbp+var_4C]\n0x0049A205 | 48 8D 45 C0 | lea     rax, [rbp+var_40]\n0x0049A209 | 89 D6 | mov     esi, edx\n0x0049A20B | 48 89 C7 | mov     rdi, rax\n0x0049A20E | E8 F3 DA 06 00 | call    sub_507D06\n0x0049A213 | C9 | leave\n0x0049A214 | C3 | retn\n\n Ourput decompiled code:\nendif\nstatic time_t read_rtc(const char **pp_rtcname, struct timeval *sys_tv, int utc)\n{\n\tstruct tm tm_time;\n\tint fd;\n\n\tfd = rtc_xopen(pp_rtcname, O_RDONLY);\n\n\trtc_read_tm(&tm_time, fd);\n\n#if SHOW_HWCLOCK_DIFF\n\t{\n\t\tint before = tm_time.tm_sec;\n\t\twhile (1) {\n\t\t\trtc_read_tm(&tm_time, fd);\n\t\t\tgettimeofday(sys_tv, NULL);\n\t\t\tif (before != (int)tm_time.tm_sec)\n\t\t\t\tbreak;\n\t\t}\n\t}\n#endif\n\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tclose(fd);\n\n\treturn rtc_tm2time(&tm_time, utc);\n}\n\n## Example:\n\n Input assembly code:\n0x00463151 | 55 | push    rbp\n0x00463152 | 48 89 E5 | mov     rbp, rsp\n0x00463155 | 53 | push    rbx\n0x00463156 | 48 83 EC 28 | sub     rsp, 28h\n0x0046315A | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0046315E | 89 75 E4 | mov     [rbp+var_1C], esi\n0x00463161 | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x00463165 | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x00463168 | 83 C0 01 | add     eax, 1\n0x0046316B | 48 63 D8 | movsxd  rbx, eax\n0x0046316E | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00463172 | 8B 40 68 | mov     eax, [rax+68h]\n0x00463175 | 89 C7 | mov     edi, eax\n0x00463177 | E8 CA 01 0A 00 | call    sub_503346\n0x0046317C | 48 89 C1 | mov     rcx, rax\n0x0046317F | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00463183 | 48 89 DA | mov     rdx, rbx\n0x00463186 | 48 89 CE | mov     rsi, rcx\n0x00463189 | 48 89 C7 | mov     rdi, rax\n0x0046318C | E8 2F 4E 0A 00 | call    sub_507FC0\n0x00463191 | 90 | nop\n0x00463192 | 48 83 C4 28 | add     rsp, 28h\n0x00463196 | 5B | pop     rbx\n0x00463197 | 5D | pop     rbp\n0x00463198 | C3 | retn\n\n Ourput decompiled code:\nstatic void func_user(char *buf, int size, const procps_status_t *ps)\n{\n#if 1\n\tsafe_strncpy(buf, get_cached_username(ps->uid), size+1);\n#else\n\t/* \"compatible\" version, but it's larger */\n\t/* procps 2.18 shows numeric UID if name overflows the field */\n\t/* TODO: get_cached_username() returns numeric string if\n\t * user has no passwd record, we will display it\n\t * left-justified here; too long usernames are shown\n\t * as _right-justified_ IDs. Is it worth fixing? */\n\tconst char *user = get_cached_username(ps->uid);\n\tif (strlen(user) <= size)\n\t\tsafe_strncpy(buf, user, size+1);\n\telse\n\t\tsprintf(buf, \"%*u\", size, (unsigned)ps->uid);\n#endif\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004CCD81 | 55 | push    rbp\n0x004CCD82 | 48 89 E5 | mov     rbp, rsp\n0x004CCD85 | 48 83 EC 20 | sub     rsp, 20h\n0x004CCD89 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004CCD8D | 89 75 E4 | mov     [rbp+var_1C], esi\n0x004CCD90 | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x004CCD93 | 01 C0 | add     eax, eax\n0x004CCD95 | 83 C0 01 | add     eax, 1\n0x004CCD98 | 89 C0 | mov     eax, eax\n0x004CCD9A | 48 89 C7 | mov     rdi, rax\n0x004CCD9D | E8 46 D3 F3 FF | call    sub_40A0E8\n0x004CCDA2 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004CCDA6 | 8B 55 E4 | mov     edx, [rbp+var_1C]\n0x004CCDA9 | 48 8B 4D E8 | mov     rcx, [rbp+var_18]\n0x004CCDAD | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004CCDB1 | 48 89 CE | mov     rsi, rcx\n0x004CCDB4 | 48 89 C7 | mov     rdi, rax\n0x004CCDB7 | E8 F9 CD F3 FF | call    sub_409BB5\n0x004CCDBC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004CCDC0 | C9 | leave\n0x004CCDC1 | C3 | retn",
        "output": "\n\nstatic char *func_uid(char *buf, int size, const procps_status_t *ps)\n{\n\tchar *uid_str = xmalloc(size * 2 + 1);\n\tuid_t uid = ps->uid;\n\n\tsprintf(uid_str, \"%u\", uid * 2 + 1);\n\treturn uid_str;\n}",
        "source_code": "static unsigned char *hash_bin_to_hex(unsigned char *hash_value,\n\t\t\t\tunsigned hash_length)\n{\n\t/* xzalloc zero-terminates */\n\tchar *hex_value = xzalloc((hash_length * 2) + 1);\n\tbin2hex(hex_value, (char*)hash_value, hash_length);\n\treturn (unsigned char *)hex_value;\n}",
        "parsed_output": "\n\nstatic char *func_uid(char *buf, int size, const procps_status_t *ps)\n{\n\tchar *uid_str = xmalloc(size * 2 + 1);\n\tuid_t uid = ps->uid;\n\n\tsprintf(uid_str, \"%u\", uid * 2 + 1);\n\treturn uid_str;\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_4CCD81(char *a1, __int64 a2)\n{\n  _BYTE *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40A0E8((unsigned int)(2 * a2 + 1), a2);\n  sub_409BB5(v3, a1, a2);\n  return v3;\n}\n",
        "baseline_code_debug": "unsigned __int8 *__cdecl hash_bin_to_hex(unsigned __int8 *hash_value, unsigned int hash_length)\n{\n  char *hex_value; // [rsp+18h] [rbp-8h]\n\n  hex_value = (char *)xzalloc(2 * hash_length + 1);\n  bin2hex(hex_value, (const char *)hash_value, hash_length);\n  return (unsigned __int8 *)hex_value;\n}\n",
        "similarity_score_unixcoder": 0.5418984889984131,
        "similarity_score_baseline_stripped": 0.47773265838623047,
        "similarity_score_baseline_debug": 0.8737540245056152
    },
    {
        "func_name": "do_lzo_decompress",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00508371 | 55 | push    rbp\n0x00508372 | 48 89 E5 | mov     rbp, rsp\n0x00508375 | 48 83 C4 80 | add     rsp, 0FFFFFFFFFFFFFF80h\n0x00508379 | 48 8D 45 80 | lea     rax, [rbp+set]\n0x0050837D | 48 89 C7 | mov     rdi, rax; set\n0x00508380 | E8 7B ED EF FF | call    _sigemptyset\n0x00508385 | 48 8D 45 80 | lea     rax, [rbp+set]\n0x00508389 | 48 89 C7 | mov     rdi, rax; set\n0x0050838C | E8 7F F1 EF FF | call    _sigsuspend\n0x00508391 | 90 | nop\n0x00508392 | C9 | leave\n0x00508393 | C3 | retn\n\n Ourput decompiled code:\nvoid FAST_FUNC wait_for_any_sig(void)\n{\n\tsigset_t ss;\n\tsigemptyset(&ss);\n\tsigsuspend(&ss);\n}\n\n## Example:\n\n Input assembly code:\n0x00507F01 | 55 | push    rbp\n0x00507F02 | 48 89 E5 | mov     rbp, rsp\n0x00507F05 | 48 81 EC 90 01 00 00 | sub     rsp, 190h\n0x00507F0C | 48 8D 85 70 FE FF FF | lea     rax, [rbp+name]\n0x00507F13 | 48 89 C7 | mov     rdi, rax; name\n0x00507F16 | E8 25 ED EF FF | call    _uname\n0x00507F1B | 0F B6 85 B1 FE FF FF | movzx   eax, [rbp+name.nodename]\n0x00507F22 | 84 C0 | test    al, al\n0x00507F24 | 74 0D | jz      short loc_507F33\n0x00507F26 | 48 8D 85 70 FE FF FF | lea     rax, [rbp+name]\n0x00507F2D | 48 83 C0 41 | add     rax, 41h ; 'A'\n0x00507F31 | EB 05 | jmp     short loc_507F38\n0x00507F33 | B8 07 76 53 00 | mov     eax, offset asc_537607; \"?\"\n0x00507F38 | BE 41 00 00 00 | mov     esi, 41h ; 'A'\n0x00507F3D | 48 89 C7 | mov     rdi, rax\n0x00507F40 | E8 20 22 F0 FF | call    sub_40A165\n0x00507F45 | C9 | leave\n0x00507F46 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC safe_gethostname(void)\n{\n\tstruct utsname uts;\n\n\t/* The length of the arrays in a struct utsname is unspecified;\n\t * the fields are terminated by a null byte.\n\t * Note that there is no standard that says that the hostname\n\t * set by sethostname(2) is the same string as the nodename field of the\n\t * struct returned by uname (indeed, some systems allow a 256-byte host-\n\t * name and an 8-byte nodename), but this is true on Linux. The same holds\n\t * for setdomainname(2) and the domainname field.\n\t */\n\n\t/* Uname can fail only if you pass a bad pointer to it. */\n\tuname(&uts);\n\treturn xstrndup(!uts.nodename[0] ? \"?\" : uts.nodename, sizeof(uts.nodename));\n}\n\n## Example:\n\n Input assembly code:\n0x00436544 | 55 | push    rbp\n0x00436545 | 48 89 E5 | mov     rbp, rsp\n0x00436548 | 48 83 EC 10 | sub     rsp, 10h\n0x0043654C | 48 8D 45 F0 | lea     rax, [rbp+tv]\n0x00436550 | BE 00 00 00 00 | mov     esi, 0; tz\n0x00436555 | 48 89 C7 | mov     rdi, rax; tv\n0x00436558 | E8 63 07 FD FF | call    _gettimeofday\n0x0043655D | 48 8B 45 F0 | mov     rax, [rbp+tv.tv_sec]\n0x00436561 | 2D 80 81 55 7C | sub     eax, 7C558180h\n0x00436566 | 89 C7 | mov     edi, eax; hostlong\n0x00436568 | E8 C3 07 FD FF | call    _htonl\n0x0043656D | C9 | leave\n0x0043656E | C3 | retn\n\n Ourput decompiled code:\nstatic uint32_t machtime(void)\n{\n\tstruct timeval tv;\n\n\tgettimeofday(&tv, NULL);\n\treturn htonl((uint32_t)(tv.tv_sec + 2208988800));\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004B363F | 55 | push    rbp\n0x004B3640 | 48 89 E5 | mov     rbp, rsp\n0x004B3643 | 48 81 EC 30 01 00 00 | sub     rsp, 130h\n0x004B364A | E8 AF FA FF FF | call    sub_4B30FE\n0x004B364F | 48 8D 85 D0 FE FF FF | lea     rax, [rbp+var_130]\n0x004B3656 | 48 89 C7 | mov     rdi, rax\n0x004B3659 | E8 81 FE FF FF | call    sub_4B34DF\n0x004B365E | 48 8D 85 D0 FE FF FF | lea     rax, [rbp+var_130]\n0x004B3665 | 48 89 C7 | mov     rdi, rax\n0x004B3668 | E8 86 F7 FF FF | call    sub_4B2DF3\n0x004B366D | C9 | leave\n0x004B366E | C3 | retn",
        "output": "\n\nstatic void\nprocess_data(void)\n{\n\tuint8_t var_130[16];\n\n\tmac_address(var_130);\n\tprocess_mac(var_130);\n\tprocess_ip(var_130);\n}",
        "source_code": "static smallint do_lzo_decompress(void)\n{\n\theader_t header;\n\n\tcheck_magic();\n\tp_header(&header);\n\treturn lzo_decompress(&header);\n}",
        "parsed_output": "\n\nstatic void\nprocess_data(void)\n{\n\tuint8_t var_130[16];\n\n\tmac_address(var_130);\n\tprocess_mac(var_130);\n\tprocess_ip(var_130);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4B363F(__int64 a1, __int64 a2)\n{\n  unsigned __int8 v3[304]; // [rsp+0h] [rbp-130h] BYREF\n\n  sub_4B30FE();\n  sub_4B34DF(v3);\n  return sub_4B2DF3((__int64)v3, a2);\n}\n",
        "baseline_code_debug": "smallint __cdecl do_lzo_decompress()\n{\n  header_t_0 header; // [rsp+0h] [rbp-130h] BYREF\n\n  check_magic();\n  p_header(&header);\n  return lzo_decompress(&header);\n}\n",
        "similarity_score_unixcoder": 0.49010610580444336,
        "similarity_score_baseline_stripped": 0.3258238434791565,
        "similarity_score_baseline_debug": 0.8164466619491577
    },
    {
        "func_name": "detect_link_iff",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00430ACD | 55 | push    rbp\n0x00430ACE | 48 89 E5 | mov     rbp, rsp\n0x00430AD1 | 48 83 EC 30 | sub     rsp, 30h\n0x00430AD5 | 48 8B 05 2C C9 32 00 | mov     rax, cs:qword_75D408\n0x00430ADC | 0F B6 40 02 | movzx   eax, byte ptr [rax+2]\n0x00430AE0 | 84 C0 | test    al, al\n0x00430AE2 | 74 78 | jz      short loc_430B5C\n0x00430AE4 | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00430AE8 | 48 89 C7 | mov     rdi, rax\n0x00430AEB | E8 47 FB FF FF | call    sub_430637\n0x00430AF0 | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00430AF4 | BA 48 86 51 00 | mov     edx, offset aGettingInterfa; \"getting interface flags\"\n0x00430AF9 | 48 89 C6 | mov     rsi, rax\n0x00430AFC | BF 13 89 00 00 | mov     edi, 8913h\n0x00430B01 | E8 70 FB FF FF | call    sub_430676\n0x00430B06 | 85 C0 | test    eax, eax\n0x00430B08 | 79 0D | jns     short loc_430B17\n0x00430B0A | 48 8B 05 F7 C8 32 00 | mov     rax, cs:qword_75D408\n0x00430B11 | C6 40 02 00 | mov     byte ptr [rax+2], 0\n0x00430B15 | EB 46 | jmp     short locret_430B5D\n0x00430B17 | 0F B7 45 E0 | movzx   eax, [rbp+var_20]\n0x00430B1B | 98 | cwde\n0x00430B1C | 83 E0 01 | and     eax, 1\n0x00430B1F | 85 C0 | test    eax, eax\n0x00430B21 | 75 3A | jnz     short locret_430B5D\n0x00430B23 | 0F B7 45 E0 | movzx   eax, [rbp+var_20]\n0x00430B27 | 83 C8 01 | or      eax, 1\n0x00430B2A | 66 89 45 E0 | mov     [rbp+var_20], ax\n0x00430B2E | BF 60 86 51 00 | mov     edi, offset aUppingInterfac; \"upping interface\"\n0x00430B33 | B8 00 00 00 00 | mov     eax, 0\n0x00430B38 | E8 0A 8C FD FF | call    sub_409747\n0x00430B3D | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00430B41 | BA 71 86 51 00 | mov     edx, offset aSettingInterfa; \"setting interface flags\"\n0x00430B46 | 48 89 C6 | mov     rsi, rax\n0x00430B49 | BF 14 89 00 00 | mov     edi, 8914h\n0x00430B4E | E8 23 FB FF FF | call    sub_430676\n0x00430B53 | 85 C0 | test    eax, eax\n0x00430B55 | 79 06 | jns     short locret_430B5D\n0x00430B57 | E8 D3 8D FD FF | call    sub_40992F\n0x00430B5C | 90 | nop\n0x00430B5D | C9 | leave\n0x00430B5E | C3 | retn\n\n Ourput decompiled code:\nstatic void up_iface(void)\n{\n\tstruct ifreq ifrequest;\n\n\tif (!G.iface_exists)\n\t\treturn;\n\n\tset_ifreq_to_ifname(&ifrequest);\n\tif (network_ioctl(SIOCGIFFLAGS, &ifrequest, \"getting interface flags\") < 0) {\n\t\tG.iface_exists = 0;\n\t\treturn;\n\t}\n\n\tif (!(ifrequest.ifr_flags & IFF_UP)) {\n\t\tifrequest.ifr_flags |= IFF_UP;\n\t\t/* Let user know we mess up with interface */\n\t\tbb_error_msg(\"upping interface\");\n\t\tif (network_ioctl(SIOCSIFFLAGS, &ifrequest, \"setting interface flags\") < 0)\n\t\t\txfunc_die();\n\t}\n\n#if 0 /* why do we mess with IP addr? It's not our business */\n\tif (network_ioctl(SIOCGIFADDR, &ifrequest, \"can't get interface address\") < 0) {\n\t} else if (ifrequest.ifr_addr.sa_family != AF_INET) {\n\t\tbb_perror_msg(\"the interface is not IP-based\");\n\t} else {\n\t\t((struct sockaddr_in*)(&ifrequest.ifr_addr))->sin_addr.s_addr = INADDR_ANY;\n\t\tnetwork_ioctl(SIOCSIFADDR, &ifrequest, \"can't set interface address\");\n\t}\n\tnetwork_ioctl(SIOCGIFFLAGS, &ifrequest, \"can't get interface flags\");\n#endif\n}\n\n## Example:\n\n Input assembly code:\n0x00430893 | 55 | push    rbp\n0x00430894 | 48 89 E5 | mov     rbp, rsp\n0x00430897 | 48 83 EC 40 | sub     rsp, 40h\n0x0043089B | 48 8D 45 D0 | lea     rax, [rbp+s]\n0x0043089F | BA 20 00 00 00 | mov     edx, 20h ; ' '; n\n0x004308A4 | BE 00 00 00 00 | mov     esi, 0; c\n0x004308A9 | 48 89 C7 | mov     rdi, rax; s\n0x004308AC | E8 9F 64 FD FF | call    _memset\n0x004308B1 | 48 8B 05 50 CB 32 00 | mov     rax, cs:qword_75D408\n0x004308B8 | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x004308BC | 48 8D 45 D0 | lea     rax, [rbp+s]\n0x004308C0 | 48 89 D6 | mov     rsi, rdx\n0x004308C3 | 48 89 C7 | mov     rdi, rax\n0x004308C6 | E8 87 91 FD FF | call    sub_409A52\n0x004308CB | 48 8D 45 D0 | lea     rax, [rbp+s]\n0x004308CF | BA 5D 85 51 00 | mov     edx, offset aSiocgiwap; \"SIOCGIWAP\"\n0x004308D4 | 48 89 C6 | mov     rsi, rax\n0x004308D7 | BF 15 8B 00 00 | mov     edi, 8B15h\n0x004308DC | E8 95 FD FF FF | call    sub_430676\n0x004308E1 | 85 C0 | test    eax, eax\n0x004308E3 | 79 07 | jns     short loc_4308EC\n0x004308E5 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x004308EA | EB 5E | jmp     short locret_43094A\n0x004308EC | 8B 45 E2 | mov     eax, [rbp+var_1E]\n0x004308EF | 89 45 CA | mov     [rbp+var_36], eax\n0x004308F2 | 0F B7 45 E6 | movzx   eax, [rbp+var_1A]\n0x004308F6 | 66 89 45 CE | mov     [rbp+var_32], ax\n0x004308FA | 0F B6 45 CA | movzx   eax, byte ptr [rbp+var_36]\n0x004308FE | 3C FF | cmp     al, 0FFh\n0x00430900 | 74 10 | jz      short loc_430912\n0x00430902 | 0F B6 45 CA | movzx   eax, byte ptr [rbp+var_36]\n0x00430906 | 3C 44 | cmp     al, 44h ; 'D'\n0x00430908 | 74 08 | jz      short loc_430912\n0x0043090A | 0F B6 45 CA | movzx   eax, byte ptr [rbp+var_36]\n0x0043090E | 84 C0 | test    al, al\n0x00430910 | 75 33 | jnz     short loc_430945\n0x00430912 | C7 45 FC 01 00 00 00 | mov     [rbp+var_4], 1\n0x00430919 | EB 1D | jmp     short loc_430938\n0x0043091B | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0043091E | 48 98 | cdqe\n0x00430920 | 0F B6 54 05 CA | movzx   edx, byte ptr [rbp+rax+var_36]\n0x00430925 | 0F B6 45 CA | movzx   eax, byte ptr [rbp+var_36]\n0x00430929 | 38 C2 | cmp     dl, al\n0x0043092B | 74 07 | jz      short loc_430934\n0x0043092D | B8 01 00 00 00 | mov     eax, 1\n0x00430932 | EB 16 | jmp     short locret_43094A\n0x00430934 | 83 45 FC 01 | add     [rbp+var_4], 1\n0x00430938 | 83 7D FC 05 | cmp     [rbp+var_4], 5\n0x0043093C | 7E DD | jle     short loc_43091B\n0x0043093E | B8 00 00 00 00 | mov     eax, 0\n0x00430943 | EB 05 | jmp     short locret_43094A\n0x00430945 | B8 01 00 00 00 | mov     eax, 1\n0x0043094A | C9 | leave\n0x0043094B | C3 | retn\n\n Ourput decompiled code:\nstatic smallint detect_link_wlan(void)\n{\n\tint i;\n\tstruct iwreq iwrequest;\n\tuint8_t mac[ETH_ALEN];\n\n\tmemset(&iwrequest, 0, sizeof(iwrequest));\n\tstrncpy_IFNAMSIZ(iwrequest.ifr_ifrn.ifrn_name, G.iface);\n\n\tif (network_ioctl(SIOCGIWAP, &iwrequest, \"SIOCGIWAP\") < 0) {\n\t\treturn IFSTATUS_ERR;\n\t}\n\n\tmemcpy(mac, &iwrequest.u.ap_addr.sa_data, ETH_ALEN);\n\n\tif (mac[0] == 0xFF || mac[0] == 0x44 || mac[0] == 0x00) {\n\t\tfor (i = 1; i < ETH_ALEN; ++i) {\n\t\t\tif (mac[i] != mac[0])\n\t\t\t\treturn IFSTATUS_UP;\n\t\t}\n\t\treturn IFSTATUS_DOWN;\n\t}\n\n\treturn IFSTATUS_UP;\n}\n\n## Example:\n\n Input assembly code:\n0x004307DD | 55 | push    rbp\n0x004307DE | 48 89 E5 | mov     rbp, rsp\n0x004307E1 | 48 83 EC 40 | sub     rsp, 40h\n0x004307E5 | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x004307E9 | 48 89 C7 | mov     rdi, rax\n0x004307EC | E8 46 FE FF FF | call    sub_430637\n0x004307F1 | C7 45 C8 0A 00 00 00 | mov     [rbp+var_38], 0Ah\n0x004307F8 | 48 8D 45 C8 | lea     rax, [rbp+var_38]\n0x004307FC | 48 89 45 E0 | mov     [rbp+var_20], rax\n0x00430800 | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00430804 | BA 42 85 51 00 | mov     edx, offset aEthtoolGlink; \"ETHTOOL_GLINK\"\n0x00430809 | 48 89 C6 | mov     rsi, rax\n0x0043080C | BF 46 89 00 00 | mov     edi, 8946h\n0x00430811 | E8 60 FE FF FF | call    sub_430676\n0x00430816 | 85 C0 | test    eax, eax\n0x00430818 | 79 07 | jns     short loc_430821\n0x0043081A | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x0043081F | EB 08 | jmp     short locret_430829\n0x00430821 | 8B 45 CC | mov     eax, [rbp+var_34]\n0x00430824 | 85 C0 | test    eax, eax\n0x00430826 | 0F 95 C0 | setnz   al\n0x00430829 | C9 | leave\n0x0043082A | C3 | retn\n\n Ourput decompiled code:\nstatic smallint detect_link_ethtool(void)\n{\n\tstruct ifreq ifreq;\n\tstruct ethtool_value edata;\n\n\tset_ifreq_to_ifname(&ifreq);\n\n\tedata.cmd = ETHTOOL_GLINK;\n\tifreq.ifr_data = (void*) &edata;\n\n\tif (network_ioctl(SIOCETHTOOL, &ifreq, \"ETHTOOL_GLINK\") < 0) {\n\t\treturn IFSTATUS_ERR;\n\t}\n\n\treturn edata.data ? IFSTATUS_UP : IFSTATUS_DOWN;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043082B | 55 | push    rbp\n0x0043082C | 48 89 E5 | mov     rbp, rsp\n0x0043082F | 48 83 EC 30 | sub     rsp, 30h\n0x00430833 | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00430837 | 48 89 C7 | mov     rdi, rax\n0x0043083A | E8 F8 FD FF FF | call    sub_430637\n0x0043083F | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00430843 | BA 50 85 51 00 | mov     edx, offset aSiocgifflags_1; \"SIOCGIFFLAGS\"\n0x00430848 | 48 89 C6 | mov     rsi, rax\n0x0043084B | BF 13 89 00 00 | mov     edi, 8913h\n0x00430850 | E8 21 FE FF FF | call    sub_430676\n0x00430855 | 85 C0 | test    eax, eax\n0x00430857 | 79 07 | jns     short loc_430860\n0x00430859 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x0043085E | EB 31 | jmp     short locret_430891\n0x00430860 | 0F B7 45 E0 | movzx   eax, [rbp+var_20]\n0x00430864 | 98 | cwde\n0x00430865 | 83 E0 01 | and     eax, 1\n0x00430868 | 85 C0 | test    eax, eax\n0x0043086A | 75 1A | jnz     short loc_430886\n0x0043086C | 48 8B 05 95 CB 32 00 | mov     rax, cs:qword_75D408\n0x00430873 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00430876 | 3C FF | cmp     al, 0FFh\n0x00430878 | 74 0C | jz      short loc_430886\n0x0043087A | 48 8B 05 87 CB 32 00 | mov     rax, cs:qword_75D408\n0x00430881 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00430884 | EB 0B | jmp     short locret_430891\n0x00430886 | 0F B7 45 E0 | movzx   eax, [rbp+var_20]\n0x0043088A | 98 | cwde\n0x0043088B | C1 F8 06 | sar     eax, 6\n0x0043088E | 83 E0 01 | and     eax, 1\n0x00430891 | C9 | leave\n0x00430892 | C3 | retn",
        "output": "",
        "source_code": "static smallint detect_link_iff(void)\n{\n\tstruct ifreq ifreq;\n\n\tset_ifreq_to_ifname(&ifreq);\n\n\tif (network_ioctl(SIOCGIFFLAGS, &ifreq, \"SIOCGIFFLAGS\") < 0) {\n\t\treturn IFSTATUS_ERR;\n\t}\n\n\t/* If IFF_UP is not set (interface is down), IFF_RUNNING is never set\n\t * regardless of link status. Simply continue to report last status -\n\t * no point in reporting spurious link downs if interface is disabled\n\t * by admin. When/if it will be brought up,\n\t * we'll report real link status.\n\t */\n\tif (!(ifreq.ifr_flags & IFF_UP) && G.iface_last_status != IFSTATUS_ERR)\n\t\treturn G.iface_last_status;\n\n\treturn (ifreq.ifr_flags & IFF_RUNNING) ? IFSTATUS_UP : IFSTATUS_DOWN;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 sub_43082B()\n{\n  char v1[16]; // [rsp+0h] [rbp-30h] BYREF\n  __int16 v2; // [rsp+10h] [rbp-20h]\n\n  sub_430637(v1);\n  if ( (int)sub_430676(35091, (__int64)v1, (__int64)\"SIOCGIFFLAGS\") < 0 )\n    return 0xFFFFFFFFLL;\n  if ( (v2 & 1) != 0 || *(_BYTE *)qword_75D408 == 0xFF )\n    return (v2 >> 6) & 1;\n  return *(unsigned __int8 *)qword_75D408;\n}\n",
        "baseline_code_debug": "smallint __cdecl detect_link_iff()\n{\n  int v0; // eax\n  ifreq_0 ifreq; // [rsp+0h] [rbp-30h] BYREF\n\n  set_ifreq_to_ifname(&ifreq);\n  if ( network_ioctl(35091, &ifreq, \"SIOCGIFFLAGS\") >= 0 )\n  {\n    if ( (ifreq.ifr_ifru.ifru_slave[0] & 1) != 0 || LOBYTE(ptr_to_globals->timeout) == 0xFF )\n      return (ifreq.ifr_ifru.ifru_flags >> 6) & 1;\n    else\n      LOBYTE(v0) = ptr_to_globals->timeout;\n  }\n  else\n  {\n    LOBYTE(v0) = -1;\n  }\n  return v0;\n}\n",
        "similarity_score_unixcoder": 0.14652031660079956,
        "similarity_score_baseline_stripped": 0.3739491403102875,
        "similarity_score_baseline_debug": 0.7152293920516968
    },
    {
        "func_name": "read_big_block",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004BB2CA | 55 | push    rbp\n0x004BB2CB | 48 89 E5 | mov     rbp, rsp\n0x004BB2CE | 48 83 EC 20 | sub     rsp, 20h\n0x004BB2D2 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004BB2D6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004BB2DA | 48 8D 48 28 | lea     rcx, [rax+28h]\n0x004BB2DE | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004BB2E2 | 8B 00 | mov     eax, [rax]\n0x004BB2E4 | BA 00 00 01 00 | mov     edx, 10000h\n0x004BB2E9 | 48 89 CE | mov     rsi, rcx\n0x004BB2EC | 89 C7 | mov     edi, eax\n0x004BB2EE | E8 0C 01 F5 FF | call    sub_40B3FF\n0x004BB2F3 | 89 45 FC | mov     [rbp+var_4], eax\n0x004BB2F6 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004BB2FA | 7F 0F | jg      short loc_4BB30B\n0x004BB2FC | BF 08 16 53 00 | mov     edi, offset aUnexpectedEof; \"unexpected EOF\"\n0x004BB301 | B8 00 00 00 00 | mov     eax, 0\n0x004BB306 | E8 93 E3 F4 FF | call    sub_40969E\n0x004BB30B | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004BB30F | 48 8D 50 28 | lea     rdx, [rax+28h]\n0x004BB313 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004BB317 | 48 89 50 08 | mov     [rax+8], rdx\n0x004BB31B | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004BB31F | 48 8D 50 28 | lea     rdx, [rax+28h]\n0x004BB323 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004BB326 | 48 98 | cdqe\n0x004BB328 | 48 01 C2 | add     rdx, rax\n0x004BB32B | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004BB32F | 48 89 50 10 | mov     [rax+10h], rdx\n0x004BB333 | 90 | nop\n0x004BB334 | C9 | leave\n0x004BB335 | C3 | retn\n\n Ourput decompiled code:\nstatic size_inline void rc_read(rc_t *rc)\n{\n\tint buffer_size = safe_read(rc->fd, RC_BUFFER, RC_BUFFER_SIZE);\n//TODO: return -1 instead\n//This will make unlzma delete broken unpacked file on unpack errors\n\tif (buffer_size <= 0)\n\t\tbb_error_msg_and_die(\"unexpected EOF\");\n\trc->ptr = RC_BUFFER;\n\trc->buffer_end = RC_BUFFER + buffer_size;\n}\n\n## Example:\n\n Input assembly code:\n0x004CB548 | 55 | push    rbp\n0x004CB549 | 48 89 E5 | mov     rbp, rsp\n0x004CB54C | 48 83 EC 20 | sub     rsp, 20h\n0x004CB550 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004CB554 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x004CB558 | 48 8D 45 F0 | lea     rax, [rbp+var_10]\n0x004CB55C | 48 89 D6 | mov     rsi, rdx\n0x004CB55F | 48 89 C7 | mov     rdi, rax\n0x004CB562 | E8 4A 7A 03 00 | call    sub_502FB1\n0x004CB567 | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x004CB56B | 8B 05 DF 1E 29 00 | mov     eax, cs:dword_75D450\n0x004CB571 | 25 00 04 00 00 | and     eax, 400h\n0x004CB576 | 85 C0 | test    eax, eax\n0x004CB578 | 75 05 | jnz     short loc_4CB57F\n0x004CB57A | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x004CB57D | EB 38 | jmp     short locret_4CB5B7\n0x004CB57F | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x004CB582 | 83 C0 02 | add     eax, 2\n0x004CB585 | 89 45 FC | mov     [rbp+var_4], eax\n0x004CB588 | EB 1F | jmp     short loc_4CB5A9\n0x004CB58A | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CB58E | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004CB591 | 3C 22 | cmp     al, 22h ; '\"'\n0x004CB593 | 74 0B | jz      short loc_4CB5A0\n0x004CB595 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CB599 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004CB59C | 3C 5C | cmp     al, 5Ch ; '\\'\n0x004CB59E | 75 04 | jnz     short loc_4CB5A4\n0x004CB5A0 | 83 45 FC 01 | add     [rbp+var_4], 1\n0x004CB5A4 | 48 83 45 E8 01 | add     [rbp+var_18], 1\n0x004CB5A9 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CB5AD | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004CB5B0 | 84 C0 | test    al, al\n0x004CB5B2 | 75 D6 | jnz     short loc_4CB58A\n0x004CB5B4 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004CB5B7 | C9 | leave\n0x004CB5B8 | C3 | retn\n\n Ourput decompiled code:\nendif\n\nstatic unsigned calc_name_len(const char *name)\n{\n\tunsigned len;\n\tuni_stat_t uni_stat;\n\n\t// TODO: quote tab as \\t, etc, if -Q\n\tname = printable_string(&uni_stat, name);\n\n\tif (!(option_mask32 & OPT_Q)) {\n\t\treturn uni_stat.unicode_width;\n\t}\n\n\tlen = 2 + uni_stat.unicode_width;\n\twhile (*name) {\n\t\tif (*name == '\"' || *name == '\\\\') {\n\t\t\tlen++;\n\t\t}\n\t\tname++;\n\t}\n\treturn len;\n}\n\n## Example:\n\n Input assembly code:\n0x00433D06 | 55 | push    rbp\n0x00433D07 | 48 89 E5 | mov     rbp, rsp\n0x00433D0A | 48 83 EC 20 | sub     rsp, 20h\n0x00433D0E | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00433D12 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00433D16 | 8B 40 24 | mov     eax, [rax+24h]\n0x00433D19 | 89 45 FC | mov     [rbp+var_4], eax\n0x00433D1C | EB 3D | jmp     short loc_433D5B\n0x00433D1E | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00433D21 | 48 63 D0 | movsxd  rdx, eax\n0x00433D24 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00433D28 | 8B 40 20 | mov     eax, [rax+20h]\n0x00433D2B | 48 98 | cdqe\n0x00433D2D | 48 89 D6 | mov     rsi, rdx; vers\n0x00433D30 | 48 89 C7 | mov     rdi, rax; program\n0x00433D33 | E8 48 33 FD FF | call    _pmap_unset\n0x00433D38 | 85 C0 | test    eax, eax\n0x00433D3A | 75 1B | jnz     short loc_433D57\n0x00433D3C | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00433D40 | 8B 40 20 | mov     eax, [rax+20h]\n0x00433D43 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x00433D46 | 89 C6 | mov     esi, eax\n0x00433D48 | BF A1 92 51 00 | mov     edi, offset aPmapUnsetUU; \"pmap_unset(%u,%u)\"\n0x00433D4D | B8 00 00 00 00 | mov     eax, 0\n0x00433D52 | E8 82 54 FD FF | call    sub_4091D9\n0x00433D57 | 83 45 FC 01 | add     [rbp+var_4], 1\n0x00433D5B | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00433D5F | 8B 40 28 | mov     eax, [rax+28h]\n0x00433D62 | 39 45 FC | cmp     [rbp+var_4], eax\n0x00433D65 | 7E B7 | jle     short loc_433D1E\n0x00433D67 | 90 | nop\n0x00433D68 | C9 | leave\n0x00433D69 | C3 | retn\n\n Ourput decompiled code:\nstatic void unregister_rpc(servtab_t *sep)\n{\n\tint n;\n\n\tfor (n = sep->se_rpcver_lo; n <= sep->se_rpcver_hi; n++) {\n\t\tif (!pmap_unset(sep->se_rpcprog, n))\n\t\t\tbb_perror_msg(\"pmap_unset(%u,%u)\", sep->se_rpcprog, n);\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0041A1AA | 55 | push    rbp\n0x0041A1AB | 48 89 E5 | mov     rbp, rsp\n0x0041A1AE | 48 83 EC 20 | sub     rsp, 20h\n0x0041A1B2 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0041A1B6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0041A1BA | BA 00 00 10 00 | mov     edx, 100000h\n0x0041A1BF | 48 89 C6 | mov     rsi, rax\n0x0041A1C2 | BF 03 00 00 00 | mov     edi, 3\n0x0041A1C7 | E8 86 D2 0E 00 | call    sub_507452\n0x0041A1CC | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x0041A1D3 | EB 29 | jmp     short loc_41A1FE\n0x0041A1D5 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0041A1D8 | 48 63 D0 | movsxd  rdx, eax\n0x0041A1DB | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0041A1DF | 48 01 D0 | add     rax, rdx\n0x0041A1E2 | 0F B6 10 | movzx   edx, byte ptr [rax]\n0x0041A1E5 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0041A1E8 | 48 63 C8 | movsxd  rcx, eax\n0x0041A1EB | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0041A1EF | 48 01 C8 | add     rax, rcx\n0x0041A1F2 | 83 E2 01 | and     edx, 1\n0x0041A1F5 | 88 10 | mov     [rax], dl\n0x0041A1F7 | 81 45 FC 00 02 00 00 | add     [rbp+var_4], 200h\n0x0041A1FE | 81 7D FC FF FF 0F 00 | cmp     [rbp+var_4], 0FFFFFh\n0x0041A205 | 7E CE | jle     short loc_41A1D5\n0x0041A207 | 90 | nop\n0x0041A208 | C9 | leave\n0x0041A209 | C3 | retn",
        "output": "\n\nstatic void\nset_all_bits(char *p)\n{\n\tint i;\n\n\tbzero(p, 1024 * 16);\n\tfor (i = 0; i < 1024 * 16; i += 256)\n\t\tp[i] = 0xff;\n}",
        "source_code": "static void read_big_block(/*int fd,*/ char *buf)\n{\n\tint i;\n\n\txread(fd, buf, TIMING_BUF_BYTES);\n\t/* access all sectors of buf to ensure the read fully completed */\n\tfor (i = 0; i < TIMING_BUF_BYTES; i += 512)\n\t\tbuf[i] &= 1;\n}",
        "parsed_output": "\n\nstatic void\nset_all_bits(char *p)\n{\n\tint i;\n\n\tbzero(p, 1024 * 16);\n\tfor (i = 0; i < 1024 * 16; i += 256)\n\t\tp[i] = 0xff;\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_41A1AA(__int64 a1)\n{\n  _BYTE *result; // rax\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  result = (_BYTE *)sub_507452(3LL, a1, 0x100000LL);\n  for ( i = 0; i <= 0xFFFFF; i += 512 )\n  {\n    result = (_BYTE *)(i + a1);\n    *result &= 1u;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl read_big_block(char *buf)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  xread(3, buf, 0x100000uLL);\n  for ( i = 0; i <= 0xFFFFF; i += 512 )\n    buf[i] &= 1u;\n}\n",
        "similarity_score_unixcoder": 0.5204257965087891,
        "similarity_score_baseline_stripped": 0.49999451637268066,
        "similarity_score_baseline_debug": 0.6921022534370422
    },
    {
        "func_name": "rc_get_bit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00497671 | 55 | push    rbp\n0x00497672 | 48 89 E5 | mov     rbp, rsp\n0x00497675 | 48 83 EC 20 | sub     rsp, 20h\n0x00497679 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0049767D | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00497681 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00497685 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00497689 | 48 89 D6 | mov     rsi, rdx\n0x0049768C | 48 89 C7 | mov     rdi, rax\n0x0049768F | E8 29 EC FF FF | call    sub_4962BD\n0x00497694 | 89 45 FC | mov     [rbp+var_4], eax\n0x00497697 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x0049769B | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0049769E | 48 89 D6 | mov     rsi, rdx\n0x004976A1 | 89 C7 | mov     edi, eax\n0x004976A3 | E8 65 FE FF FF | call    sub_49750D\n0x004976A8 | 89 45 FC | mov     [rbp+var_4], eax\n0x004976AB | 83 7D FC FF | cmp     [rbp+var_4], 0FFFFFFFFh\n0x004976AF | 75 10 | jnz     short loc_4976C1\n0x004976B1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004976B5 | 66 C7 00 00 00 | mov     word ptr [rax], 0\n0x004976BA | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x004976C1 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004976C4 | C9 | leave\n0x004976C5 | C3 | retn\n\n Ourput decompiled code:\nstatic int add_zone(uint16_t *znr, smallint *corrected)\n{\n\tint block;\n\n\tblock = check_zone_nr(znr, corrected);\n\tblock = add_zone_common(block, corrected);\n\tif (block == -1) {\n\t\t*znr = 0;\n\t\tblock = 0;\n\t}\n\treturn block;\n}\n\n## Example:\n\n Input assembly code:\n0x004976C6 | 55 | push    rbp\n0x004976C7 | 48 89 E5 | mov     rbp, rsp\n0x004976CA | 48 83 EC 20 | sub     rsp, 20h\n0x004976CE | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004976D2 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004976D6 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x004976DA | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004976DE | 48 89 D6 | mov     rsi, rdx\n0x004976E1 | 48 89 C7 | mov     rdi, rax\n0x004976E4 | E8 E9 EA FF FF | call    sub_4961D2\n0x004976E9 | 89 45 FC | mov     [rbp+var_4], eax\n0x004976EC | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x004976F0 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004976F3 | 48 89 D6 | mov     rsi, rdx\n0x004976F6 | 89 C7 | mov     edi, eax\n0x004976F8 | E8 10 FE FF FF | call    sub_49750D\n0x004976FD | 89 45 FC | mov     [rbp+var_4], eax\n0x00497700 | 83 7D FC FF | cmp     [rbp+var_4], 0FFFFFFFFh\n0x00497704 | 75 11 | jnz     short loc_497717\n0x00497706 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0049770A | C7 00 00 00 00 00 | mov     dword ptr [rax], 0\n0x00497710 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x00497717 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0049771A | C9 | leave\n0x0049771B | C3 | retn\n\n Ourput decompiled code:\nif ENABLE_FEATURE_MINIX2\nstatic int add_zone2(uint32_t *znr, smallint *corrected)\n{\n\tint block;\n\n\tblock = check_zone_nr2(znr, corrected);\n\tblock = add_zone_common(block, corrected);\n\tif (block == -1) {\n\t\t*znr = 0;\n\t\tblock = 0;\n\t}\n\treturn block;\n}\n\n## Example:\n\n Input assembly code:\n0x004317A8 | 55 | push    rbp\n0x004317A9 | 48 89 E5 | mov     rbp, rsp\n0x004317AC | 48 83 EC 30 | sub     rsp, 30h\n0x004317B0 | 48 89 7D E8 | mov     [rbp+s1], rdi\n0x004317B4 | 48 89 75 E0 | mov     [rbp+s2], rsi\n0x004317B8 | 48 89 55 D8 | mov     [rbp+n], rdx\n0x004317BC | 48 8B 55 D8 | mov     rdx, [rbp+n]; n\n0x004317C0 | 48 8B 4D E0 | mov     rcx, [rbp+s2]\n0x004317C4 | 48 8B 45 E8 | mov     rax, [rbp+s1]\n0x004317C8 | 48 89 CE | mov     rsi, rcx; s2\n0x004317CB | 48 89 C7 | mov     rdi, rax; s1\n0x004317CE | E8 CD 4F FD FF | call    _strncmp\n0x004317D3 | 89 45 FC | mov     [rbp+var_4], eax\n0x004317D6 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004317DA | 75 15 | jnz     short loc_4317F1\n0x004317DC | 48 8B 55 E0 | mov     rdx, [rbp+s2]\n0x004317E0 | 48 8B 45 D8 | mov     rax, [rbp+n]\n0x004317E4 | 48 01 D0 | add     rax, rdx\n0x004317E7 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004317EA | 0F B6 C0 | movzx   eax, al\n0x004317ED | F7 D8 | neg     eax\n0x004317EF | EB 03 | jmp     short locret_4317F4\n0x004317F1 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004317F4 | C9 | leave\n0x004317F5 | C3 | retn\n\n Ourput decompiled code:\nstatic int strncmpz(const char *l, const char *r, size_t llen)\n{\n\tint i = strncmp(l, r, llen);\n\n\tif (i == 0)\n\t\treturn - (unsigned char)r[llen];\n\treturn i;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004BB517 | 55 | push    rbp\n0x004BB518 | 48 89 E5 | mov     rbp, rsp\n0x004BB51B | 48 83 EC 30 | sub     rsp, 30h\n0x004BB51F | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004BB523 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004BB527 | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x004BB52B | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x004BB52F | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004BB533 | 48 89 D6 | mov     rsi, rdx\n0x004BB536 | 48 89 C7 | mov     rdi, rax\n0x004BB539 | E8 02 FF FF FF | call    sub_4BB440\n0x004BB53E | 89 45 FC | mov     [rbp+var_4], eax\n0x004BB541 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004BB545 | 8B 00 | mov     eax, [rax]\n0x004BB547 | 8D 14 00 | lea     edx, [rax+rax]\n0x004BB54A | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004BB54D | 01 C2 | add     edx, eax\n0x004BB54F | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004BB553 | 89 10 | mov     [rax], edx\n0x004BB555 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004BB558 | C9 | leave\n0x004BB559 | C3 | retn",
        "output": "\n\nstatic int add_zone_common(int block, smallint *corrected)\n{\n\tblock = add_corrected(block, corrected);\n\t*corrected = *corrected + *corrected * 2 + block;\n\treturn block;\n}",
        "source_code": "static speed_inline int rc_get_bit(rc_t *rc, uint16_t *p, int *symbol)\n{\n\tint ret = rc_is_bit_1(rc, p);\n\t*symbol = *symbol * 2 + ret;\n\treturn ret;\n}",
        "parsed_output": "\n\nstatic int add_zone_common(int block, smallint *corrected)\n{\n\tblock = add_corrected(block, corrected);\n\t*corrected = *corrected + *corrected * 2 + block;\n\treturn block;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4BB517(_DWORD *a1, _WORD *a2, _DWORD *a3)\n{\n  __int64 result; // rax\n\n  LODWORD(result) = sub_4BB440(a1, a2);\n  *a3 = result + 2 * *a3;\n  return (unsigned int)result;\n}\n",
        "baseline_code_debug": "int __cdecl rc_get_bit(rc_t *rc, uint16_t *p, int *symbol)\n{\n  int result; // eax\n\n  result = rc_is_bit_1(rc, p);\n  *symbol = result + 2 * *symbol;\n  return result;\n}\n",
        "similarity_score_unixcoder": 0.508095920085907,
        "similarity_score_baseline_stripped": 0.5090862512588501,
        "similarity_score_baseline_debug": 0.8854587078094482
    },
    {
        "func_name": "print_char",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004CDB3F | 55 | push    rbp\n0x004CDB40 | 48 89 E5 | mov     rbp, rsp\n0x004CDB43 | 48 83 EC 30 | sub     rsp, 30h\n0x004CDB47 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004CDB4B | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004CDB4F | 48 89 55 D8 | mov     [rbp+format], rdx\n0x004CDB53 | EB 28 | jmp     short loc_4CDB7D\n0x004CDB55 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004CDB59 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004CDB5C | 0F BE C0 | movsx   eax, al\n0x004CDB5F | 89 45 FC | mov     [rbp+var_4], eax\n0x004CDB62 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x004CDB65 | 48 8B 45 D8 | mov     rax, [rbp+format]\n0x004CDB69 | 89 D6 | mov     esi, edx\n0x004CDB6B | 48 89 C7 | mov     rdi, rax; format\n0x004CDB6E | B8 00 00 00 00 | mov     eax, 0\n0x004CDB73 | E8 58 90 F3 FF | call    _printf\n0x004CDB78 | 48 83 45 E0 01 | add     [rbp+var_20], 1\n0x004CDB7D | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CDB81 | 48 8D 50 FF | lea     rdx, [rax-1]\n0x004CDB85 | 48 89 55 E8 | mov     [rbp+var_18], rdx\n0x004CDB89 | 48 85 C0 | test    rax, rax\n0x004CDB8C | 75 C7 | jnz     short loc_4CDB55\n0x004CDB8E | 90 | nop\n0x004CDB8F | C9 | leave\n0x004CDB90 | C3 | retn\n\n Ourput decompiled code:\nstatic void\nprint_s_char(size_t n_bytes, const char *block, const char *fmt_string)\n{\n\twhile (n_bytes--) {\n\t\tint tmp = *(signed char *) block;\n\t\tprintf(fmt_string, tmp);\n\t\tblock += sizeof(unsigned char);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x004CDC9B | 55 | push    rbp\n0x004CDC9C | 48 89 E5 | mov     rbp, rsp\n0x004CDC9F | 48 83 EC 30 | sub     rsp, 30h\n0x004CDCA3 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004CDCA7 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004CDCAB | 48 89 55 D8 | mov     [rbp+format], rdx\n0x004CDCAF | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CDCB3 | 48 C1 E8 02 | shr     rax, 2\n0x004CDCB7 | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x004CDCBB | EB 24 | jmp     short loc_4CDCE1\n0x004CDCBD | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004CDCC1 | 8B 00 | mov     eax, [rax]\n0x004CDCC3 | 89 45 FC | mov     [rbp+var_4], eax\n0x004CDCC6 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x004CDCC9 | 48 8B 45 D8 | mov     rax, [rbp+format]\n0x004CDCCD | 89 D6 | mov     esi, edx\n0x004CDCCF | 48 89 C7 | mov     rdi, rax; format\n0x004CDCD2 | B8 00 00 00 00 | mov     eax, 0\n0x004CDCD7 | E8 F4 8E F3 FF | call    _printf\n0x004CDCDC | 48 83 45 E0 04 | add     [rbp+var_20], 4\n0x004CDCE1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CDCE5 | 48 8D 50 FF | lea     rdx, [rax-1]\n0x004CDCE9 | 48 89 55 E8 | mov     [rbp+var_18], rdx\n0x004CDCED | 48 85 C0 | test    rax, rax\n0x004CDCF0 | 75 CB | jnz     short loc_4CDCBD\n0x004CDCF2 | 90 | nop\n0x004CDCF3 | C9 | leave\n0x004CDCF4 | C3 | retn\n\n Ourput decompiled code:\nstatic void\nprint_int(size_t n_bytes, const char *block, const char *fmt_string)\n{\n\tn_bytes /= sizeof(unsigned);\n\twhile (n_bytes--) {\n\t\tunsigned tmp = *(unsigned *) block;\n\t\tprintf(fmt_string, tmp);\n\t\tblock += sizeof(unsigned);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x004CDC3E | 55 | push    rbp\n0x004CDC3F | 48 89 E5 | mov     rbp, rsp\n0x004CDC42 | 48 83 EC 30 | sub     rsp, 30h\n0x004CDC46 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004CDC4A | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004CDC4E | 48 89 55 D8 | mov     [rbp+format], rdx\n0x004CDC52 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CDC56 | 48 D1 E8 | shr     rax, 1\n0x004CDC59 | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x004CDC5D | EB 28 | jmp     short loc_4CDC87\n0x004CDC5F | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004CDC63 | 0F B7 00 | movzx   eax, word ptr [rax]\n0x004CDC66 | 0F B7 C0 | movzx   eax, ax\n0x004CDC69 | 89 45 FC | mov     [rbp+var_4], eax\n0x004CDC6C | 8B 55 FC | mov     edx, [rbp+var_4]\n0x004CDC6F | 48 8B 45 D8 | mov     rax, [rbp+format]\n0x004CDC73 | 89 D6 | mov     esi, edx\n0x004CDC75 | 48 89 C7 | mov     rdi, rax; format\n0x004CDC78 | B8 00 00 00 00 | mov     eax, 0\n0x004CDC7D | E8 4E 8F F3 FF | call    _printf\n0x004CDC82 | 48 83 45 E0 02 | add     [rbp+var_20], 2\n0x004CDC87 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CDC8B | 48 8D 50 FF | lea     rdx, [rax-1]\n0x004CDC8F | 48 89 55 E8 | mov     [rbp+var_18], rdx\n0x004CDC93 | 48 85 C0 | test    rax, rax\n0x004CDC96 | 75 C7 | jnz     short loc_4CDC5F\n0x004CDC98 | 90 | nop\n0x004CDC99 | C9 | leave\n0x004CDC9A | C3 | retn\n\n Ourput decompiled code:\nstatic void\nprint_short(size_t n_bytes, const char *block, const char *fmt_string)\n{\n\tn_bytes /= sizeof(unsigned short);\n\twhile (n_bytes--) {\n\t\tunsigned tmp = *(unsigned short *) block;\n\t\tprintf(fmt_string, tmp);\n\t\tblock += sizeof(unsigned short);\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004CDB91 | 55 | push    rbp\n0x004CDB92 | 48 89 E5 | mov     rbp, rsp\n0x004CDB95 | 48 83 EC 30 | sub     rsp, 30h\n0x004CDB99 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004CDB9D | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004CDBA1 | 48 89 55 D8 | mov     [rbp+format], rdx\n0x004CDBA5 | EB 28 | jmp     short loc_4CDBCF\n0x004CDBA7 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004CDBAB | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004CDBAE | 0F B6 C0 | movzx   eax, al\n0x004CDBB1 | 89 45 FC | mov     [rbp+var_4], eax\n0x004CDBB4 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x004CDBB7 | 48 8B 45 D8 | mov     rax, [rbp+format]\n0x004CDBBB | 89 D6 | mov     esi, edx\n0x004CDBBD | 48 89 C7 | mov     rdi, rax; format\n0x004CDBC0 | B8 00 00 00 00 | mov     eax, 0\n0x004CDBC5 | E8 06 90 F3 FF | call    _printf\n0x004CDBCA | 48 83 45 E0 01 | add     [rbp+var_20], 1\n0x004CDBCF | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CDBD3 | 48 8D 50 FF | lea     rdx, [rax-1]\n0x004CDBD7 | 48 89 55 E8 | mov     [rbp+var_18], rdx\n0x004CDBDB | 48 85 C0 | test    rax, rax\n0x004CDBDE | 75 C7 | jnz     short loc_4CDBA7\n0x004CDBE0 | 90 | nop\n0x004CDBE1 | C9 | leave\n0x004CDBE2 | C3 | retn",
        "output": "\n\nstatic void\nprint_uchar(size_t n_bytes, const char *block, const char *fmt_string)\n{\n\twhile (n_bytes--) {\n\t\tunsigned tmp = *(unsigned char *) block;\n\t\tprintf(fmt_string, tmp);\n\t\tblock += sizeof(unsigned char);\n\t}\n}",
        "source_code": "static void\nprint_char(size_t n_bytes, const char *block, const char *fmt_string)\n{\n\twhile (n_bytes--) {\n\t\tunsigned tmp = *(unsigned char *) block;\n\t\tprintf(fmt_string, tmp);\n\t\tblock += sizeof(unsigned char);\n\t}\n}",
        "parsed_output": "\n\nstatic void\nprint_uchar(size_t n_bytes, const char *block, const char *fmt_string)\n{\n\twhile (n_bytes--) {\n\t\tunsigned tmp = *(unsigned char *) block;\n\t\tprintf(fmt_string, tmp);\n\t\tblock += sizeof(unsigned char);\n\t}\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4CDB91(__int64 a1, unsigned __int8 *a2, const char *a3)\n{\n  __int64 result; // rax\n\n  while ( 1 )\n  {\n    result = a1--;\n    if ( !result )\n      break;\n    printf(a3, *a2++);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl print_char(size_t n_bytes, const char *block, const char *fmt_string)\n{\n  while ( n_bytes-- )\n    printf(fmt_string, *(unsigned __int8 *)block++);\n}\n",
        "similarity_score_unixcoder": 0.9827877879142761,
        "similarity_score_baseline_stripped": 0.633916974067688,
        "similarity_score_baseline_debug": 0.9284946918487549
    },
    {
        "func_name": "pivot_root_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004D7CA3 | 55 | push    rbp\n0x004D7CA4 | 48 89 E5 | mov     rbp, rsp\n0x004D7CA7 | 48 83 EC 10 | sub     rsp, 10h\n0x004D7CAB | 89 7D FC | mov     [rbp+var_4], edi\n0x004D7CAE | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004D7CB2 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004D7CB6 | 48 83 C0 08 | add     rax, 8\n0x004D7CBA | 48 8B 00 | mov     rax, [rax]\n0x004D7CBD | 48 85 C0 | test    rax, rax\n0x004D7CC0 | 75 05 | jnz     short loc_4D7CC7\n0x004D7CC2 | E8 9D 02 F3 FF | call    sub_407F64\n0x004D7CC7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004D7CCB | 48 83 C0 08 | add     rax, 8\n0x004D7CCF | 48 8B 00 | mov     rax, [rax]\n0x004D7CD2 | 48 89 C7 | mov     rdi, rax\n0x004D7CD5 | E8 27 34 03 00 | call    sub_50B101\n0x004D7CDA | 89 C7 | mov     edi, eax; useconds\n0x004D7CDC | E8 FF FF F2 FF | call    _usleep\n0x004D7CE1 | B8 00 00 00 00 | mov     eax, 0\n0x004D7CE6 | C9 | leave\n0x004D7CE7 | C3 | retn\n\n Ourput decompiled code:\nint usleep_main(int argc UNUSED_PARAM, char **argv)\n{\n\tif (!argv[1]) {\n\t\tbb_show_usage();\n\t}\n\n\tusleep(xatou(argv[1]));\n\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input assembly code:\n0x0047E306 | 55 | push    rbp\n0x0047E307 | 48 89 E5 | mov     rbp, rsp\n0x0047E30A | 48 83 EC 10 | sub     rsp, 10h\n0x0047E30E | 89 7D FC | mov     [rbp+var_4], edi\n0x0047E311 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x0047E315 | E8 E2 4C FF FF | call    sub_472FFC\n0x0047E31A | 85 C0 | test    eax, eax\n0x0047E31C | 74 07 | jz      short loc_47E325\n0x0047E31E | B8 00 00 00 00 | mov     eax, 0\n0x0047E323 | EB 33 | jmp     short locret_47E358\n0x0047E325 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0047E329 | 48 83 C0 08 | add     rax, 8\n0x0047E32D | 48 8B 00 | mov     rax, [rax]\n0x0047E330 | 48 85 C0 | test    rax, rax\n0x0047E333 | 74 19 | jz      short loc_47E34E\n0x0047E335 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0047E339 | 48 83 C0 08 | add     rax, 8\n0x0047E33D | 48 8B 00 | mov     rax, [rax]\n0x0047E340 | 48 89 C7 | mov     rdi, rax\n0x0047E343 | E8 30 0B FF FF | call    sub_46EE78\n0x0047E348 | 88 05 02 CC 2D 00 | mov     cs:byte_75AF50, al\n0x0047E34E | BF 04 00 00 00 | mov     edi, 4\n0x0047E353 | E8 17 FC FE FF | call    sub_46DF6F\n0x0047E358 | C9 | leave\n0x0047E359 | C3 | retn\n\n Ourput decompiled code:\nstatic int FAST_FUNC\nexitcmd(int argc UNUSED_PARAM, char **argv)\n{\n\tif (stoppedjobs())\n\t\treturn 0;\n\tif (argv[1])\n\t\texitstatus = number(argv[1]);\n\traise_exception(EXEXIT);\n\t/* NOTREACHED */\n}\n\n## Example:\n\n Input assembly code:\n0x004228D5 | 55 | push    rbp\n0x004228D6 | 48 89 E5 | mov     rbp, rsp\n0x004228D9 | 48 83 EC 20 | sub     rsp, 20h\n0x004228DD | 89 7D EC | mov     [rbp+var_14], edi\n0x004228E0 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004228E4 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004228E8 | 48 83 C0 08 | add     rax, 8\n0x004228EC | 48 8B 00 | mov     rax, [rax]\n0x004228EF | 48 85 C0 | test    rax, rax\n0x004228F2 | 75 05 | jnz     short loc_4228F9\n0x004228F4 | E8 6B 56 FE FF | call    sub_407F64\n0x004228F9 | E8 72 45 FE FF | call    _setsid\n0x004228FE | 85 C0 | test    eax, eax\n0x00422900 | 79 1D | jns     short loc_42291F\n0x00422902 | E8 DF 85 FE FF | call    sub_40AEE6\n0x00422907 | 89 45 FC | mov     [rbp+var_4], eax\n0x0042290A | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x0042290E | 74 0A | jz      short loc_42291A\n0x00422910 | BF 00 00 00 00 | mov     edi, 0; status\n0x00422915 | E8 A6 51 FE FF | call    _exit\n0x0042291A | E8 51 45 FE FF | call    _setsid\n0x0042291F | 48 83 45 E0 08 | add     [rbp+var_20], 8\n0x00422924 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00422928 | 48 89 C7 | mov     rdi, rax\n0x0042292B | E8 ED 69 0D 00 | call    sub_4F931D\n\n Ourput decompiled code:\nint setsid_main(int argc UNUSED_PARAM, char **argv)\n{\n\tif (!argv[1])\n\t\tbb_show_usage();\n\n\t/* setsid() is allowed only when we are not a process group leader.\n\t * Otherwise our PID serves as PGID of some existing process group\n\t * and cannot be used as PGID of a new process group. */\n\tif (setsid() < 0) {\n\t\tpid_t pid = fork_or_rexec(argv);\n\t\tif (pid != 0) {\n\t\t\t/* parent */\n\t\t\t/* TODO:\n\t\t\t * we can waitpid(pid, &status, 0) and then even\n\t\t\t * emulate exitcode, making the behavior consistent\n\t\t\t * in both forked and non forked cases.\n\t\t\t * However, the code is larger and upstream\n\t\t\t * does not do such trick.\n\t\t\t */\n\t\t\texit(EXIT_SUCCESS);\n\t\t}\n\n\t\t/* child */\n\t\t/* now there should be no error: */\n\t\tsetsid();\n\t}\n\n\targv++;\n\tBB_EXECVP_or_die(argv);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004A32AA | 55 | push    rbp\n0x004A32AB | 48 89 E5 | mov     rbp, rsp\n0x004A32AE | 48 83 EC 10 | sub     rsp, 10h\n0x004A32B2 | 89 7D FC | mov     [rbp+var_4], edi\n0x004A32B5 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004A32B9 | 83 7D FC 03 | cmp     [rbp+var_4], 3\n0x004A32BD | 74 05 | jz      short loc_4A32C4\n0x004A32BF | E8 A0 4C F6 FF | call    sub_407F64\n0x004A32C4 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004A32C8 | 48 83 C0 10 | add     rax, 10h\n0x004A32CC | 48 8B 10 | mov     rdx, [rax]\n0x004A32CF | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004A32D3 | 48 83 C0 08 | add     rax, 8\n0x004A32D7 | 48 8B 00 | mov     rax, [rax]\n0x004A32DA | 48 89 D6 | mov     rsi, rdx\n0x004A32DD | 48 89 C7 | mov     rdi, rax\n0x004A32E0 | E8 EB 46 F6 FF | call    _pivot_root\n0x004A32E5 | 85 C0 | test    eax, eax\n0x004A32E7 | 79 05 | jns     short loc_4A32EE\n0x004A32E9 | E8 66 FA 05 00 | call    sub_502D54\n0x004A32EE | B8 00 00 00 00 | mov     eax, 0\n0x004A32F3 | C9 | leave\n0x004A32F4 | C3 | retn",
        "output": "\n\nint pivot_root_main(int argc, char **argv)\n{\n\tif (argc != 3)\n\t\tbb_show_usage();\n\n\tif (pivot_root(argv[1], argv[2]) < 0)\n\t\tbb_perror(\"pivot_root\");\n\n\treturn 0;\n}",
        "source_code": "int pivot_root_main(int argc, char **argv)\n{\n\tif (argc != 3)\n\t\tbb_show_usage();\n\n\tif (pivot_root(argv[1], argv[2]) < 0) {\n\t\t/* prints \"pivot_root: <strerror text>\" */\n\t\tbb_perror_nomsg_and_die();\n\t}\n\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "\n\nint pivot_root_main(int argc, char **argv)\n{\n\tif (argc != 3)\n\t\tbb_show_usage();\n\n\tif (pivot_root(argv[1], argv[2]) < 0)\n\t\tbb_perror(\"pivot_root\");\n\n\treturn 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4A32AA(__int64 a1, __int64 a2)\n{\n  if ( (_DWORD)a1 != 3 )\n    sub_407F64(a1);\n  if ( (int)pivot_root(*(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16)) < 0 )\n    sub_502D54();\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl pivot_root_main(int argc, char **argv)\n{\n  if ( argc != 3 )\n    bb_show_usage();\n  if ( (int)pivot_root(argv[1], argv[2]) < 0 )\n    bb_perror_nomsg_and_die();\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.9303191304206848,
        "similarity_score_baseline_stripped": 0.5956843495368958,
        "similarity_score_baseline_debug": 0.885185718536377
    },
    {
        "func_name": "unalias",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004892A0 | 55 | push    rbp\n0x004892A1 | 48 89 E5 | mov     rbp, rsp\n0x004892A4 | 48 83 EC 10 | sub     rsp, 10h\n0x004892A8 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004892AC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004892B0 | 48 89 C7 | mov     rdi, rax\n0x004892B3 | E8 95 FE FF FF | call    sub_48914D\n0x004892B8 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004892BC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004892C0 | 48 8B 00 | mov     rax, [rax]\n0x004892C3 | 48 85 C0 | test    rax, rax\n0x004892C6 | 75 07 | jnz     short loc_4892CF\n0x004892C8 | B8 00 00 00 00 | mov     eax, 0\n0x004892CD | EB 4B | jmp     short locret_48931A\n0x004892CF | 48 8B 05 32 41 2D 00 | mov     rax, cs:qword_75D408\n0x004892D6 | 8B 40 3C | mov     eax, [rax+3Ch]\n0x004892D9 | 85 C0 | test    eax, eax\n0x004892DB | 74 31 | jz      short loc_48930E\n0x004892DD | E8 9E D6 F7 FF | call    _getpid\n0x004892E2 | 89 C2 | mov     edx, eax\n0x004892E4 | 48 8B 05 1D 41 2D 00 | mov     rax, cs:qword_75D408\n0x004892EB | 8B 40 20 | mov     eax, [rax+20h]\n0x004892EE | 39 C2 | cmp     edx, eax\n0x004892F0 | 75 1C | jnz     short loc_48930E\n0x004892F2 | 48 8B 05 0F 41 2D 00 | mov     rax, cs:qword_75D408\n0x004892F9 | 8B 50 3C | mov     edx, [rax+3Ch]\n0x004892FC | 48 8B 05 05 41 2D 00 | mov     rax, cs:qword_75D408\n0x00489303 | 8B 00 | mov     eax, [rax]\n0x00489305 | 89 D6 | mov     esi, edx; pgrp_id\n0x00489307 | 89 C7 | mov     edi, eax; fd\n0x00489309 | E8 B2 E4 F7 FF | call    _tcsetpgrp\n0x0048930E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00489312 | 48 89 C7 | mov     rdi, rax\n0x00489315 | E8 46 D8 FF FF | call    sub_486B60\n0x0048931A | C9 | leave\n0x0048931B | C3 | retn\n\n Ourput decompiled code:\nstatic int FAST_FUNC builtin_exec(char **argv)\n{\n\targv = skip_dash_dash(argv);\n\tif (argv[0] == NULL)\n\t\treturn EXIT_SUCCESS; /* bash does this */\n\n\t/* Careful: we can end up here after [v]fork. Do not restore\n\t * tty pgrp then, only top-level shell process does that */\n\tif (G_saved_tty_pgrp && getpid() == G.root_pid)\n\t\ttcsetpgrp(G_interactive_fd, G_saved_tty_pgrp);\n\n\t/* TODO: if exec fails, bash does NOT exit! We do.\n\t * We'll need to undo trap cleanup (it's inside execvp_or_die)\n\t * and tcsetpgrp, and this is inherently racy.\n\t */\n\texecvp_or_die(argv);\n}\n\n## Example:\n\n Input assembly code:\n0x004891A3 | 55 | push    rbp\n0x004891A4 | 48 89 E5 | mov     rbp, rsp\n0x004891A7 | 48 83 EC 20 | sub     rsp, 20h\n0x004891AB | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004891AF | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x004891B6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004891BA | 48 89 C7 | mov     rdi, rax\n0x004891BD | E8 8B FF FF FF | call    sub_48914D\n0x004891C2 | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x004891C6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004891CA | 48 8B 00 | mov     rax, [rax]\n0x004891CD | 48 85 C0 | test    rax, rax\n0x004891D0 | 74 39 | jz      short loc_48920B\n0x004891D2 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004891D6 | 48 89 C7 | mov     rdi, rax\n0x004891D9 | E8 25 C9 FF FF | call    sub_485B03\n0x004891DE | 48 89 45 F0 | mov     [rbp+ptr], rax\n0x004891E2 | 48 8B 45 F0 | mov     rax, [rbp+ptr]\n0x004891E6 | 48 89 C7 | mov     rdi, rax\n0x004891E9 | E8 EA CD FF FF | call    sub_485FD8\n0x004891EE | 48 8B 45 F0 | mov     rax, [rbp+ptr]\n0x004891F2 | 48 89 C7 | mov     rdi, rax; ptr\n0x004891F5 | E8 66 D4 F7 FF | call    _free\n0x004891FA | 48 8B 05 07 42 2D 00 | mov     rax, cs:qword_75D408\n0x00489201 | 0F B6 40 4F | movzx   eax, byte ptr [rax+4Fh]\n0x00489205 | 0F B6 C0 | movzx   eax, al\n0x00489208 | 89 45 FC | mov     [rbp+var_4], eax\n0x0048920B | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0048920E | C9 | leave\n0x0048920F | C3 | retn\n\n Ourput decompiled code:\nstatic int FAST_FUNC builtin_eval(char **argv)\n{\n\tint rcode = EXIT_SUCCESS;\n\n\targv = skip_dash_dash(argv);\n\tif (*argv) {\n\t\tchar *str = expand_strvec_to_string(argv);\n\t\t/* bash:\n\t\t * eval \"echo Hi; done\" (\"done\" is syntax error):\n\t\t * \"echo Hi\" will not execute too.\n\t\t */\n\t\tparse_and_run_string(str);\n\t\tfree(str);\n\t\trcode = G.last_exitcode;\n\t}\n\treturn rcode;\n}\n\n## Example:\n\n Input assembly code:\n0x0046F438 | 55 | push    rbp\n0x0046F439 | 48 89 E5 | mov     rbp, rsp\n0x0046F43C | 48 83 EC 20 | sub     rsp, 20h\n0x0046F440 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0046F444 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0046F448 | 48 89 C7 | mov     rdi, rax\n0x0046F44B | E8 71 FE FF FF | call    sub_46F2C1\n0x0046F450 | 48 89 C2 | mov     rdx, rax\n0x0046F453 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0046F457 | 48 89 C6 | mov     rsi, rax\n0x0046F45A | 48 89 D7 | mov     rdi, rdx\n0x0046F45D | E8 86 FF FF FF | call    sub_46F3E8\n0x0046F462 | 48 8B 00 | mov     rax, [rax]\n0x0046F465 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0046F469 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0046F46E | 74 3F | jz      short loc_46F4AF\n0x0046F470 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0046F474 | 8B 40 08 | mov     eax, [rax+8]\n0x0046F477 | 25 00 02 00 00 | and     eax, 200h\n0x0046F47C | 85 C0 | test    eax, eax\n0x0046F47E | 74 0F | jz      short loc_46F48F\n0x0046F480 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0046F484 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x0046F488 | BF 00 00 00 00 | mov     edi, 0\n0x0046F48D | FF D0 | call    rax\n0x0046F48F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0046F493 | 8B 40 08 | mov     eax, [rax+8]\n0x0046F496 | 83 E0 20 | and     eax, 20h\n0x0046F499 | 85 C0 | test    eax, eax\n0x0046F49B | 75 12 | jnz     short loc_46F4AF\n0x0046F49D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0046F4A1 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x0046F4A5 | 48 89 C7 | mov     rdi, rax\n0x0046F4A8 | E8 91 EA FF FF | call    sub_46DF3E\n0x0046F4AD | EB 05 | jmp     short locret_46F4B4\n0x0046F4AF | B8 00 00 00 00 | mov     eax, 0\n0x0046F4B4 | C9 | leave\n0x0046F4B5 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC\nlookupvar(const char *name)\n{\n\tstruct var *v;\n\n\tv = *findvar(hashvar(name), name);\n\tif (v) {\n#if ENABLE_ASH_RANDOM_SUPPORT\n\t/*\n\t * Dynamic variables are implemented roughly the same way they are\n\t * in bash. Namely, they're \"special\" so long as they aren't unset.\n\t * As soon as they're unset, they're no longer dynamic, and dynamic\n\t * lookup will no longer happen at that point. -- PFM.\n\t */\n\t\tif (v->flags & VDYNAMIC)\n\t\t\tv->var_func(NULL);\n#endif\n\t\tif (!(v->flags & VUNSET))\n\t\t\treturn var_end(v->var_text);\n\t}\n\treturn NULL;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004707B3 | 55 | push    rbp\n0x004707B4 | 48 89 E5 | mov     rbp, rsp\n0x004707B7 | 48 83 EC 20 | sub     rsp, 20h\n0x004707BB | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004707BF | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004707C3 | 48 89 C7 | mov     rdi, rax\n0x004707C6 | E8 97 FD FF FF | call    sub_470562\n0x004707CB | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004707CF | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004707D3 | 48 8B 00 | mov     rax, [rax]\n0x004707D6 | 48 85 C0 | test    rax, rax\n0x004707D9 | 74 35 | jz      short loc_470810\n0x004707DB | 48 8B 05 36 CC 2E 00 | mov     rax, cs:qword_75D418\n0x004707E2 | 8B 50 30 | mov     edx, [rax+30h]\n0x004707E5 | 83 C2 01 | add     edx, 1\n0x004707E8 | 89 50 30 | mov     [rax+30h], edx\n0x004707EB | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004707EF | 48 8B 00 | mov     rax, [rax]\n0x004707F2 | 48 89 C7 | mov     rdi, rax\n0x004707F5 | E8 6E FE FF FF | call    sub_470668\n0x004707FA | 48 89 C2 | mov     rdx, rax\n0x004707FD | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00470801 | 48 89 10 | mov     [rax], rdx\n0x00470804 | E8 36 D8 FF FF | call    sub_46E03F\n0x00470809 | B8 00 00 00 00 | mov     eax, 0\n0x0047080E | EB 05 | jmp     short locret_470815\n0x00470810 | B8 01 00 00 00 | mov     eax, 1\n0x00470815 | C9 | leave\n0x00470816 | C3 | retn",
        "output": "\n\nstatic int FAST_FUNC builtin_shift(char **argv)\n{\n\tint rcode = 0;\n\n\targv = skip_dash_dash(argv);\n\tif (argv[0] == NULL) {\n\t\trcode = 1;\n\t} else {\n\t\tG.last_exitcode = (int) parse_and_eval_arith_exp(argv[0]);\n\t\tG.last_exitcode = (int) shift(G.last_exitcode);\n\t}\n\treturn rcode;\n}",
        "source_code": "static int\nunalias(const char *name)\n{\n\tstruct alias **app;\n\n\tapp = __lookupalias(name);\n\n\tif (*app) {\n\t\tINT_OFF;\n\t\t*app = freealias(*app);\n\t\tINT_ON;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
        "parsed_output": "\n\nstatic int FAST_FUNC builtin_shift(char **argv)\n{\n\tint rcode = 0;\n\n\targv = skip_dash_dash(argv);\n\tif (argv[0] == NULL) {\n\t\trcode = 1;\n\t} else {\n\t\tG.last_exitcode = (int) parse_and_eval_arith_exp(argv[0]);\n\t\tG.last_exitcode = (int) shift(G.last_exitcode);\n\t}\n\treturn rcode;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4707B3(const char *a1, __int64 a2)\n{\n  void **v2; // rdi\n  void ***v4; // [rsp+18h] [rbp-8h]\n\n  v4 = (void ***)sub_470562(a1);\n  if ( !*v4 )\n    return 1LL;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  v2 = *v4;\n  *v4 = sub_470668(*v4);\n  sub_46E03F(v2, a2);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl unalias(const char *name)\n{\n  alias **app; // [rsp+18h] [rbp-8h]\n\n  app = _lookupalias(name);\n  if ( !*app )\n    return 1;\n  ++ash_ptr_to_globals_misc->suppress_int;\n  *app = freealias(*app);\n  int_on();\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.4886554181575775,
        "similarity_score_baseline_stripped": 0.4393694996833801,
        "similarity_score_baseline_debug": 0.7727838754653931
    },
    {
        "func_name": "bb_alphasort",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004CFE71 | 55 | push    rbp\n0x004CFE72 | 48 89 E5 | mov     rbp, rsp\n0x004CFE75 | 48 83 EC 20 | sub     rsp, 20h\n0x004CFE79 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004CFE7D | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CFE81 | BA 0A 00 00 00 | mov     edx, 0Ah\n0x004CFE86 | BE 00 00 00 00 | mov     esi, 0\n0x004CFE8B | 48 89 C7 | mov     rdi, rax\n0x004CFE8E | E8 D3 C0 F3 FF | call    sub_40BF66\n0x004CFE93 | 89 45 FC | mov     [rbp+var_4], eax\n0x004CFE96 | 48 8B 05 63 D5 28 00 | mov     rax, cs:qword_75D400\n0x004CFE9D | 8B 00 | mov     eax, [rax]\n0x004CFE9F | 85 C0 | test    eax, eax\n0x004CFEA1 | 74 1D | jz      short loc_4CFEC0\n0x004CFEA3 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CFEA7 | 48 89 C6 | mov     rsi, rax\n0x004CFEAA | BF 60 23 53 00 | mov     edi, offset aInvalidNumberS_2; \"invalid number '%s'\"\n0x004CFEAF | B8 00 00 00 00 | mov     eax, 0\n0x004CFEB4 | E8 8E 98 F3 FF | call    sub_409747\n0x004CFEB9 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x004CFEC0 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004CFEC3 | C9 | leave\n0x004CFEC4 | C3 | retn\n\n Ourput decompiled code:\nstatic int get_width_prec(const char *str)\n{\n\tint v = bb_strtoi(str, NULL, 10);\n\tif (errno) {\n\t\tbb_error_msg(\"invalid number '%s'\", str);\n\t\tv = 0;\n\t}\n\treturn v;\n}\n\n## Example:\n\n Input assembly code:\n0x00432144 | 55 | push    rbp\n0x00432145 | 48 89 E5 | mov     rbp, rsp\n0x00432148 | 48 83 EC 20 | sub     rsp, 20h\n0x0043214C | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00432150 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00432154 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00432158 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043215C | 48 89 C6 | mov     rsi, rax\n0x0043215F | BF 70 8C 51 00 | mov     edi, offset aTestFVarRunUdh; \"test -f /var/run/udhcpc.%iface%.pid && \"...\n0x00432164 | E8 E5 FB FF FF | call    sub_431D4E\n0x00432169 | 89 45 FC | mov     [rbp+var_4], eax\n0x0043216C | BF A0 86 01 00 | mov     edi, 186A0h; useconds\n0x00432171 | E8 6A 5B FD FF | call    _usleep\n0x00432176 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x0043217A | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043217E | 48 89 D6 | mov     rsi, rdx\n0x00432181 | 48 89 C7 | mov     rdi, rax\n0x00432184 | E8 20 FF FF FF | call    sub_4320A9\n0x00432189 | 01 45 FC | add     [rbp+var_4], eax\n0x0043218C | 83 7D FC 03 | cmp     [rbp+var_4], 3\n0x00432190 | 75 07 | jnz     short loc_432199\n0x00432192 | B8 03 00 00 00 | mov     eax, 3\n0x00432197 | EB 05 | jmp     short locret_43219E\n0x00432199 | B8 00 00 00 00 | mov     eax, 0\n0x0043219E | C9 | leave\n0x0043219F | C3 | retn\n\n Ourput decompiled code:\nif ENABLE_FEATURE_IFUPDOWN_EXTERNAL_DHCP\nstatic int FAST_FUNC dhcp_down(struct interface_defn_t *ifd, execfn *exec)\n{\n\tint result = 0;\n\tunsigned i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ext_dhcp_clients); i++) {\n\t\tif (exists_execable(ext_dhcp_clients[i].name)) {\n\t\t\tresult = execute(ext_dhcp_clients[i].stopcmd, ifd, exec);\n\t\t\tif (result)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!result)\n\t\tbb_error_msg(\"warning: no dhcp clients found and stopped\");\n\n\t/* Sleep a bit, otherwise static_down tries to bring down interface too soon,\n\t   and it may come back up because udhcpc is still shutting down */\n\tusleep(100000);\n\tresult += static_down(ifd, exec);\n\treturn ((result == 3) ? 3 : 0);\n}\n\n## Example:\n\n Input assembly code:\n0x00431DC9 | 55 | push    rbp\n0x00431DCA | 48 89 E5 | mov     rbp, rsp\n0x00431DCD | 48 83 EC 20 | sub     rsp, 20h\n0x00431DD1 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00431DD5 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00431DD9 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00431DDD | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00431DE1 | 48 89 C6 | mov     rsi, rax\n0x00431DE4 | BF 3F 88 51 00 | mov     edi, offset aIpAddrAdd1DevI; \"ip addr add ::1 dev %iface%\"\n0x00431DE9 | E8 60 FF FF FF | call    sub_431D4E\n0x00431DEE | 89 45 FC | mov     [rbp+var_4], eax\n0x00431DF1 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00431DF5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00431DF9 | 48 89 C6 | mov     rsi, rax\n0x00431DFC | BF 5B 88 51 00 | mov     edi, offset aIpLinkSetIface; \"ip link set %iface% up\"\n0x00431E01 | E8 48 FF FF FF | call    sub_431D4E\n0x00431E06 | 01 45 FC | add     [rbp+var_4], eax\n0x00431E09 | 83 7D FC 02 | cmp     [rbp+var_4], 2\n0x00431E0D | 75 07 | jnz     short loc_431E16\n0x00431E0F | B8 02 00 00 00 | mov     eax, 2\n0x00431E14 | EB 05 | jmp     short locret_431E1B\n0x00431E16 | B8 00 00 00 00 | mov     eax, 0\n0x00431E1B | C9 | leave\n0x00431E1C | C3 | retn\n\n Ourput decompiled code:\nif ENABLE_FEATURE_IFUPDOWN_IPV6\n\nstatic int FAST_FUNC loopback_up6(struct interface_defn_t *ifd, execfn *exec)\n{\n# if ENABLE_FEATURE_IFUPDOWN_IP\n\tint result;\n\tresult = execute(\"ip addr add ::1 dev %iface%\", ifd, exec);\n\tresult += execute(\"ip link set %iface% up\", ifd, exec);\n\treturn ((result == 2) ? 2 : 0);\n# else\n\treturn execute(\"ifconfig %iface% add ::1\", ifd, exec);\n# endif\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004D8F24 | 55 | push    rbp\n0x004D8F25 | 48 89 E5 | mov     rbp, rsp\n0x004D8F28 | 48 83 EC 20 | sub     rsp, 20h\n0x004D8F2C | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004D8F30 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004D8F34 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004D8F38 | 48 8B 10 | mov     rdx, [rax]\n0x004D8F3B | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004D8F3F | 48 8B 00 | mov     rax, [rax]\n0x004D8F42 | 48 89 D6 | mov     rsi, rdx; s2\n0x004D8F45 | 48 89 C7 | mov     rdi, rax; s1\n0x004D8F48 | E8 03 E1 F2 FF | call    _strcmp\n0x004D8F4D | 89 45 FC | mov     [rbp+var_4], eax\n0x004D8F50 | 8B 05 FA 44 28 00 | mov     eax, cs:dword_75D450\n0x004D8F56 | 83 E0 01 | and     eax, 1\n0x004D8F59 | 85 C0 | test    eax, eax\n0x004D8F5B | 74 07 | jz      short loc_4D8F64\n0x004D8F5D | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004D8F60 | F7 D8 | neg     eax\n0x004D8F62 | EB 03 | jmp     short locret_4D8F67\n0x004D8F64 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004D8F67 | C9 | leave\n0x004D8F68 | C3 | retn",
        "output": "\n\nstatic int FAST_FUNC cmp_iface(const void *s1, const void *s2)\n{\n\tconst struct interface_defn_t *ifd1 = s1;\n\tconst struct interface_defn_t *ifd2 = s2;\n\tint result;\n\n\tresult = strcmp(ifd1->iface, ifd2->iface);\n\tif (local_storage_p & 1)\n\t\treturn -result;\n\telse\n\t\treturn result;\n}",
        "source_code": "static int bb_alphasort(const void *p1, const void *p2)\n{\n\tint r = strcmp(*(char **) p1, *(char **) p2);\n\treturn (option_mask32 & OPT_r) ? -r : r;\n}",
        "parsed_output": "\n\nstatic int FAST_FUNC cmp_iface(const void *s1, const void *s2)\n{\n\tconst struct interface_defn_t *ifd1 = s1;\n\tconst struct interface_defn_t *ifd2 = s2;\n\tint result;\n\n\tresult = strcmp(ifd1->iface, ifd2->iface);\n\tif (local_storage_p & 1)\n\t\treturn -result;\n\telse\n\t\treturn result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4D8F24(const char **a1, const char **a2)\n{\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = strcmp(*a1, *a2);\n  if ( (dword_75D450 & 1) != 0 )\n    return -v3;\n  else\n    return v3;\n}\n",
        "baseline_code_debug": "int __cdecl bb_alphasort(const void *p1, const void *p2)\n{\n  int r; // [rsp+1Ch] [rbp-4h]\n\n  r = strcmp(*(const char **)p1, *(const char **)p2);\n  if ( (option_mask32 & 1) != 0 )\n    return -r;\n  else\n    return r;\n}\n",
        "similarity_score_unixcoder": 0.5700300931930542,
        "similarity_score_baseline_stripped": 0.5747663974761963,
        "similarity_score_baseline_debug": 0.8037915229797363
    },
    {
        "func_name": "time_sort",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0046568A | 55 | push    rbp\n0x0046568B | 48 89 E5 | mov     rbp, rsp\n0x0046568E | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00465692 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x00465696 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0046569A | 48 8B 10 | mov     rdx, [rax]\n0x0046569D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004656A1 | 48 8B 00 | mov     rax, [rax]\n0x004656A4 | 48 39 C2 | cmp     rdx, rax\n0x004656A7 | 73 07 | jnb     short loc_4656B0\n0x004656A9 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x004656AE | EB 17 | jmp     short loc_4656C7\n0x004656B0 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004656B4 | 48 8B 10 | mov     rdx, [rax]\n0x004656B7 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004656BB | 48 8B 00 | mov     rax, [rax]\n0x004656BE | 48 39 C2 | cmp     rdx, rax\n0x004656C1 | 0F 95 C0 | setnz   al\n0x004656C4 | 0F B6 C0 | movzx   eax, al\n0x004656C7 | 5D | pop     rbp\n0x004656C8 | C3 | retn\n\n Ourput decompiled code:\nendif\n\nstatic int mem_sort(top_status_t *P, top_status_t *Q)\n{\n\t/* We want to avoid unsigned->signed and truncation errors */\n\tif (Q->vsz < P->vsz) return -1;\n\treturn Q->vsz != P->vsz; /* 0 if ==, 1 if > */\n}\n\n## Example:\n\n Input assembly code:\n0x004BC120 | 55 | push    rbp\n0x004BC121 | 48 89 E5 | mov     rbp, rsp\n0x004BC124 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004BC128 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004BC12C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BC130 | 48 8B 50 28 | mov     rdx, [rax+28h]\n0x004BC134 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BC138 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004BC13C | 48 29 C2 | sub     rdx, rax\n0x004BC13F | 48 89 D0 | mov     rax, rdx\n0x004BC142 | 48 39 45 F0 | cmp     [rbp+var_10], rax\n0x004BC146 | 72 12 | jb      short loc_4BC15A\n0x004BC148 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BC14C | 48 8B 50 28 | mov     rdx, [rax+28h]\n0x004BC150 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BC154 | 48 89 50 20 | mov     [rax+20h], rdx\n0x004BC158 | EB 17 | jmp     short loc_4BC171\n0x004BC15A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BC15E | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x004BC162 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004BC166 | 48 01 C2 | add     rdx, rax\n0x004BC169 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BC16D | 48 89 50 20 | mov     [rax+20h], rdx\n0x004BC171 | 90 | nop\n0x004BC172 | 5D | pop     rbp\n0x004BC173 | C3 | retn\n\n Ourput decompiled code:\nstatic void XZ_FUNC dict_limit(struct dictionary *dict, size_t out_max)\n{\n\tif (dict->end - dict->pos <= out_max)\n\t\tdict->limit = dict->end;\n\telse\n\t\tdict->limit = dict->pos + out_max;\n}\n\n## Example:\n\n Input assembly code:\n0x004BF520 | 55 | push    rbp\n0x004BF521 | 48 89 E5 | mov     rbp, rsp\n0x004BF524 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004BF528 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004BF52C | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004BF530 | 48 8B 50 08 | mov     rdx, [rax+8]\n0x004BF534 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004BF538 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004BF53C | 48 39 C2 | cmp     rdx, rax\n0x004BF53F | 75 07 | jnz     short loc_4BF548\n0x004BF541 | B8 00 00 00 00 | mov     eax, 0\n0x004BF546 | EB 7E | jmp     short loc_4BF5C6\n0x004BF548 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BF54C | 8B 50 20 | mov     edx, [rax+20h]\n0x004BF54F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BF553 | 8B 40 04 | mov     eax, [rax+4]\n0x004BF556 | 89 C1 | mov     ecx, eax\n0x004BF558 | D3 EA | shr     edx, cl\n0x004BF55A | 89 D0 | mov     eax, edx\n0x004BF55C | 0F B6 F0 | movzx   esi, al\n0x004BF55F | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004BF563 | 48 8B 38 | mov     rdi, [rax]\n0x004BF566 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004BF56A | 48 8B 40 08 | mov     rax, [rax+8]\n0x004BF56E | 48 8D 48 01 | lea     rcx, [rax+1]\n0x004BF572 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x004BF576 | 48 89 4A 08 | mov     [rdx+8], rcx\n0x004BF57A | 48 01 F8 | add     rax, rdi\n0x004BF57D | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004BF580 | 0F B6 C0 | movzx   eax, al\n0x004BF583 | 39 C6 | cmp     esi, eax\n0x004BF585 | 74 07 | jz      short loc_4BF58E\n0x004BF587 | B8 07 00 00 00 | mov     eax, 7\n0x004BF58C | EB 38 | jmp     short loc_4BF5C6\n0x004BF58E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BF592 | 8B 40 04 | mov     eax, [rax+4]\n0x004BF595 | 8D 50 08 | lea     edx, [rax+8]\n0x004BF598 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BF59C | 89 50 04 | mov     [rax+4], edx\n0x004BF59F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BF5A3 | 8B 40 04 | mov     eax, [rax+4]\n0x004BF5A6 | 83 F8 1F | cmp     eax, 1Fh\n0x004BF5A9 | 76 81 | jbe     short loc_4BF52C\n0x004BF5AB | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BF5AF | C7 40 20 00 00 00 00 | mov     dword ptr [rax+20h], 0\n0x004BF5B6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004BF5BA | C7 40 04 00 00 00 00 | mov     dword ptr [rax+4], 0\n0x004BF5C1 | B8 01 00 00 00 | mov     eax, 1\n0x004BF5C6 | 5D | pop     rbp\n0x004BF5C7 | C3 | retn\n\n Ourput decompiled code:\nstatic enum xz_ret XZ_FUNC crc32_validate(struct xz_dec *s, struct xz_buf *b)\n{\n\tdo {\n\t\tif (b->in_pos == b->in_size)\n\t\t\treturn XZ_OK;\n\n\t\tif (((s->crc32 >> s->pos) & 0xFF) != b->in[b->in_pos++])\n\t\t\treturn XZ_DATA_ERROR;\n\n\t\ts->pos += 8;\n\n\t} while (s->pos < 32);\n\n\ts->crc32 = 0;\n\ts->pos = 0;\n\n\treturn XZ_STREAM_END;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004656EB | 55 | push    rbp\n0x004656EC | 48 89 E5 | mov     rbp, rsp\n0x004656EF | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004656F3 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004656F7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004656FB | 48 8B 50 08 | mov     rdx, [rax+8]\n0x004656FF | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00465703 | 48 8B 40 08 | mov     rax, [rax+8]\n0x00465707 | 48 39 C2 | cmp     rdx, rax\n0x0046570A | 73 07 | jnb     short loc_465713\n0x0046570C | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x00465711 | EB 19 | jmp     short loc_46572C\n0x00465713 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00465717 | 48 8B 50 08 | mov     rdx, [rax+8]\n0x0046571B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0046571F | 48 8B 40 08 | mov     rax, [rax+8]\n0x00465723 | 48 39 C2 | cmp     rdx, rax\n0x00465726 | 0F 95 C0 | setnz   al\n0x00465729 | 0F B6 C0 | movzx   eax, al\n0x0046572C | 5D | pop     rbp\n0x0046572D | C3 | retn",
        "output": "\n\nstatic int crc_sort(top_status_t *P, top_status_t *Q)\n{\n\t/* We want to avoid unsigned->signed and truncation errors */\n\tif (Q->crc32 < P->crc32) return -1;\n\treturn Q->crc32 != P->crc32; /* 0 if ==, 1 if > */\n}",
        "source_code": "static int time_sort(top_status_t *P, top_status_t *Q)\n{\n\t/* We want to avoid unsigned->signed and truncation errors */\n\tif (Q->ticks < P->ticks) return -1;\n\treturn Q->ticks != P->ticks; /* 0 if ==, 1 if > */\n}",
        "parsed_output": "\n\nstatic int crc_sort(top_status_t *P, top_status_t *Q)\n{\n\t/* We want to avoid unsigned->signed and truncation errors */\n\tif (Q->crc32 < P->crc32) return -1;\n\treturn Q->crc32 != P->crc32; /* 0 if ==, 1 if > */\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4656EB(__int64 a1, __int64 a2)\n{\n  if ( *(_QWORD *)(a2 + 8) >= *(_QWORD *)(a1 + 8) )\n    return *(_QWORD *)(a2 + 8) != *(_QWORD *)(a1 + 8);\n  else\n    return 0xFFFFFFFFLL;\n}\n",
        "baseline_code_debug": "int __cdecl time_sort(top_status_t_0 *P, top_status_t_0 *Q)\n{\n  if ( Q->ticks >= P->ticks )\n    return Q->ticks != P->ticks;\n  else\n    return -1;\n}\n",
        "similarity_score_unixcoder": 0.8388184309005737,
        "similarity_score_baseline_stripped": 0.46980077028274536,
        "similarity_score_baseline_debug": 0.919461727142334
    },
    {
        "func_name": "rawmode",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0044254C | 55 | push    rbp\n0x0044254D | 48 89 E5 | mov     rbp, rsp\n0x00442550 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00442555 | 0F B6 40 08 | movzx   eax, byte ptr [rax+8]\n0x00442559 | 84 C0 | test    al, al\n0x0044255B | 74 17 | jz      short loc_442574\n0x0044255D | B8 20 B5 75 00 | mov     eax, offset stru_75B520\n0x00442562 | 48 89 C2 | mov     rdx, rax; termios_p\n0x00442565 | BE 01 00 00 00 | mov     esi, 1; optional_actions\n0x0044256A | BF 00 00 00 00 | mov     edi, 0; fd\n0x0044256F | E8 5C 52 FC FF | call    _tcsetattr\n0x00442574 | 90 | nop\n0x00442575 | 5D | pop     rbp\n0x00442576 | C3 | retn\n\n Ourput decompiled code:\nstatic void cookmode(void)\n{\n\tfflush_all();\n\ttcsetattr_stdin_TCSANOW(&term_orig);\n}\n\n## Example:\n\n Input assembly code:\n0x00433B43 | 55 | push    rbp\n0x00433B44 | 48 89 E5 | mov     rbp, rsp\n0x00433B47 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00433B4C | 0F B6 40 30 | movzx   eax, byte ptr [rax+30h]\n0x00433B50 | 84 C0 | test    al, al\n0x00433B52 | 75 13 | jnz     short loc_433B67\n0x00433B54 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00433B59 | C6 40 30 01 | mov     byte ptr [rax+30h], 1\n0x00433B5D | BF 3C 00 00 00 | mov     edi, 3Ch ; '<'; seconds\n0x00433B62 | E8 89 32 FD FF | call    _alarm\n0x00433B67 | 90 | nop\n0x00433B68 | 5D | pop     rbp\n0x00433B69 | C3 | retn\n\n Ourput decompiled code:\nstatic void rearm_alarm(void)\n{\n\tif (!alarm_armed) {\n\t\talarm_armed = 1;\n\t\talarm(RETRYTIME);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x004D36C5 | 55 | push    rbp\n0x004D36C6 | 48 89 E5 | mov     rbp, rsp\n0x004D36C9 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004D36CE | 8B 40 0C | mov     eax, [rax+0Ch]\n0x004D36D1 | 85 C0 | test    eax, eax\n0x004D36D3 | 74 0F | jz      short loc_4D36E4\n0x004D36D5 | BF AA 3F 52 00 | mov     edi, offset asc_523FAA; \"\\n\"\n0x004D36DA | B8 00 00 00 00 | mov     eax, 0\n0x004D36DF | E8 5D FE FF FF | call    sub_4D3541\n0x004D36E4 | 90 | nop\n0x004D36E5 | 5D | pop     rbp\n0x004D36E6 | C3 | retn\n\n Ourput decompiled code:\nstatic void newline(void)\n{\n\tif (G.current_col != 0)\n\t\twrapf(\"\\n\");\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00442521 | 55 | push    rbp\n0x00442522 | 48 89 E5 | mov     rbp, rsp\n0x00442525 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0044252A | 0F B6 40 08 | movzx   eax, byte ptr [rax+8]\n0x0044252E | 84 C0 | test    al, al\n0x00442530 | 74 17 | jz      short loc_442549\n0x00442532 | B8 5C B5 75 00 | mov     eax, offset termios_p\n0x00442537 | 48 89 C2 | mov     rdx, rax; termios_p\n0x0044253A | BE 01 00 00 00 | mov     esi, 1; optional_actions\n0x0044253F | BF 00 00 00 00 | mov     edi, 0; fd\n0x00442544 | E8 87 52 FC FF | call    _tcsetattr\n0x00442549 | 90 | nop\n0x0044254A | 5D | pop     rbp\n0x0044254B | C3 | retn",
        "output": "\n\nstatic void rawmode(void)\n{\n\tif (dest.rawmode)\n\t\ttcsetattr_stdin_TCSANOW(&termios_p);\n}",
        "source_code": "static void rawmode(void)\n{\n\ttcgetattr(0, &term_orig);\n\tterm_vi = term_orig;\n\tterm_vi.c_lflag &= (~ICANON & ~ECHO);\t// leave ISIG on - allow intr's\n\tterm_vi.c_iflag &= (~IXON & ~ICRNL);\n\tterm_vi.c_oflag &= (~ONLCR);\n\tterm_vi.c_cc[VMIN] = 1;\n\tterm_vi.c_cc[VTIME] = 0;\n\terase_char = term_vi.c_cc[VERASE];\n\ttcsetattr_stdin_TCSANOW(&term_vi);\n}",
        "parsed_output": "\n\nstatic void rawmode(void)\n{\n\tif (dest.rawmode)\n\t\ttcsetattr_stdin_TCSANOW(&termios_p);\n}",
        "baseline_code_stripped": "int sub_442521()\n{\n  int result; // eax\n\n  result = LOBYTE(dest.c_cflag);\n  if ( (_BYTE)result )\n    return tcsetattr(0, 1, &termios_p);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl rawmode()\n{\n  if ( LOBYTE(bb_common_bufsiz1.c_cflag) )\n    tcsetattr(0, 1, &unk_75B55C);\n}\n",
        "similarity_score_unixcoder": 0.7156482338905334,
        "similarity_score_baseline_stripped": 0.567959725856781,
        "similarity_score_baseline_debug": 0.5760945081710815
    },
    {
        "func_name": "str_value",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004C92AB | 55 | push    rbp\n0x004C92AC | 48 89 E5 | mov     rbp, rsp\n0x004C92AF | 48 83 EC 20 | sub     rsp, 20h\n0x004C92B3 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004C92B7 | BF 10 00 00 00 | mov     edi, 10h\n0x004C92BC | E8 27 0E F4 FF | call    sub_40A0E8\n0x004C92C1 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004C92C5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C92C9 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x004C92CD | 48 89 50 08 | mov     [rax+8], rdx\n0x004C92D1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C92D5 | C9 | leave\n0x004C92D6 | C3 | retn\n\n Ourput decompiled code:\nstatic VALUE *int_value(arith_t i)\n{\n\tVALUE *v;\n\n\tv = xzalloc(sizeof(VALUE));\n\tif (INTEGER) /* otherwise xzaaloc did it already */\n\t\tv->type = INTEGER;\n\tv->u.i = i;\n\treturn v;\n}\n\n## Example:\n\n Input assembly code:\n0x00476145 | 55 | push    rbp\n0x00476146 | 48 89 E5 | mov     rbp, rsp\n0x00476149 | 48 83 EC 20 | sub     rsp, 20h\n0x0047614D | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00476151 | BF 10 00 00 00 | mov     edi, 10h\n0x00476156 | E8 8C 86 FF FF | call    sub_46E7E7\n0x0047615B | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0047615F | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00476163 | 48 89 C7 | mov     rdi, rax\n0x00476166 | E8 F2 86 FF FF | call    sub_46E85D\n0x0047616B | 48 89 C2 | mov     rdx, rax\n0x0047616E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00476172 | 48 89 50 08 | mov     [rax+8], rdx\n0x00476176 | 48 8B 05 8B 4E 2E 00 | mov     rax, cs:qword_75B008\n0x0047617D | 48 8B 55 F8 | mov     rdx, [rbp+var_8]\n0x00476181 | 48 89 10 | mov     [rax], rdx\n0x00476184 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00476188 | 48 89 05 79 4E 2E 00 | mov     cs:qword_75B008, rax\n0x0047618F | 90 | nop\n0x00476190 | C9 | leave\n0x00476191 | C3 | retn\n\n Ourput decompiled code:\nstatic void\naddfname(const char *name)\n{\n\tstruct strlist *sp;\n\n\tsp = stzalloc(sizeof(*sp));\n\tsp->text = ststrdup(name);\n\t*exparg.lastp = sp;\n\texparg.lastp = &sp->next;\n}\n\n## Example:\n\n Input assembly code:\n0x00408FD2 | 55 | push    rbp\n0x00408FD3 | 48 89 E5 | mov     rbp, rsp\n0x00408FD6 | 48 83 EC 20 | sub     rsp, 20h\n0x00408FDA | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00408FDE | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00408FE2 | BF 10 00 00 00 | mov     edi, 10h\n0x00408FE7 | E8 73 10 00 00 | call    sub_40A05F\n0x00408FEC | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00408FF0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00408FF4 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00408FF8 | 48 89 50 08 | mov     [rax+8], rdx\n0x00408FFC | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00409000 | 48 8B 10 | mov     rdx, [rax]\n0x00409003 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00409007 | 48 89 10 | mov     [rax], rdx\n0x0040900A | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0040900E | 48 8B 55 F8 | mov     rdx, [rbp+var_8]\n0x00409012 | 48 89 10 | mov     [rax], rdx\n0x00409015 | 90 | nop\n0x00409016 | C9 | leave\n0x00409017 | C3 | retn\n\n Ourput decompiled code:\nvoid FAST_FUNC llist_add_to(llist_t **old_head, void *data)\n{\n\tllist_t *new_head = xmalloc(sizeof(llist_t));\n\n\tnew_head->data = data;\n\tnew_head->link = *old_head;\n\t*old_head = new_head;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C92D7 | 55 | push    rbp\n0x004C92D8 | 48 89 E5 | mov     rbp, rsp\n0x004C92DB | 48 83 EC 20 | sub     rsp, 20h\n0x004C92DF | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004C92E3 | BF 10 00 00 00 | mov     edi, 10h\n0x004C92E8 | E8 FB 0D F4 FF | call    sub_40A0E8\n0x004C92ED | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004C92F1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C92F5 | C6 00 01 | mov     byte ptr [rax], 1\n0x004C92F8 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004C92FC | 48 89 C7 | mov     rdi, rax\n0x004C92FF | E8 1B 0E F4 FF | call    sub_40A11F\n0x004C9304 | 48 89 C2 | mov     rdx, rax\n0x004C9307 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C930B | 48 89 50 08 | mov     [rax+8], rdx\n0x004C930F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C9313 | C9 | leave\n0x004C9314 | C3 | retn",
        "output": "\n\nstatic VALUE *float_value(arith_t f)\n{\n\tVALUE *v;\n\n\tv = xzalloc(sizeof(VALUE));\n\tif (FLOAT) /* otherwise xzaaloc did it already */\n\t\tv->type = FLOAT;\n\tv->u.f = f;\n\treturn v;\n}",
        "source_code": "static VALUE *str_value(const char *s)\n{\n\tVALUE *v;\n\n\tv = xzalloc(sizeof(VALUE));\n\tif (STRING) /* otherwise xzaaloc did it already */\n\t\tv->type = STRING;\n\tv->u.s = xstrdup(s);\n\treturn v;\n}",
        "parsed_output": "\n\nstatic VALUE *float_value(arith_t f)\n{\n\tVALUE *v;\n\n\tv = xzalloc(sizeof(VALUE));\n\tif (FLOAT) /* otherwise xzaaloc did it already */\n\t\tv->type = FLOAT;\n\tv->u.f = f;\n\treturn v;\n}",
        "baseline_code_stripped": "_QWORD *__fastcall sub_4C92D7(const char *a1, __int64 a2)\n{\n  _QWORD *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40A0E8(0x10uLL, a2);\n  *(_BYTE *)v3 = 1;\n  v3[1] = sub_40A11F(a1, a2);\n  return v3;\n}\n",
        "baseline_code_debug": "VALUE *__cdecl str_value(const char *s)\n{\n  VALUE *v; // [rsp+18h] [rbp-8h]\n\n  v = (VALUE *)xzalloc(0x10uLL);\n  v->type = 1;\n  v->u.i = (arith_t_0)xstrdup(s);\n  return v;\n}\n",
        "similarity_score_unixcoder": 0.7328392267227173,
        "similarity_score_baseline_stripped": 0.4493058919906616,
        "similarity_score_baseline_debug": 0.7117202281951904
    },
    {
        "func_name": "install_sighandler",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00479364 | 55 | push    rbp\n0x00479365 | 48 89 E5 | mov     rbp, rsp\n0x00479368 | 48 83 EC 10 | sub     rsp, 10h\n0x0047936C | 89 7D FC | mov     [rbp+var_4], edi\n0x0047936F | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x00479373 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00479377 | 48 83 C0 08 | add     rax, 8\n0x0047937B | 48 8B 00 | mov     rax, [rax]\n0x0047937E | 48 85 C0 | test    rax, rax\n0x00479381 | 74 4C | jz      short loc_4793CF\n0x00479383 | 48 8B 05 8E 40 2E 00 | mov     rax, cs:qword_75D418\n0x0047938A | C6 40 3C 00 | mov     byte ptr [rax+3Ch], 0\n0x0047938E | 48 8B 05 83 40 2E 00 | mov     rax, cs:qword_75D418\n0x00479395 | C6 40 3D 00 | mov     byte ptr [rax+3Dh], 0\n0x00479399 | E8 E9 F9 FF FF | call    sub_478D87\n0x0047939E | 48 8B 05 7B 40 2E 00 | mov     rax, cs:qword_75D420\n0x004793A5 | 48 05 60 01 00 00 | add     rax, 160h\n0x004793AB | 48 83 C0 20 | add     rax, 20h ; ' '\n0x004793AF | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004793B3 | 48 8D 48 05 | lea     rcx, [rax+5]\n0x004793B7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004793BB | 48 83 C0 08 | add     rax, 8\n0x004793BF | BA 00 00 00 00 | mov     edx, 0\n0x004793C4 | 48 89 CE | mov     rsi, rcx\n0x004793C7 | 48 89 C7 | mov     rdi, rax\n0x004793CA | E8 06 D9 FF FF | call    sub_476CD5\n0x004793CF | B8 00 00 00 00 | mov     eax, 0\n0x004793D4 | C9 | leave\n0x004793D5 | C3 | retn\n\n Ourput decompiled code:\nstatic int FAST_FUNC\nexeccmd(int argc UNUSED_PARAM, char **argv)\n{\n\tif (argv[1]) {\n\t\tiflag = 0;              /* exit on error */\n\t\tmflag = 0;\n\t\toptschanged();\n\t\tshellexec(argv + 1, pathval(), 0);\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x0046E0F3 | 55 | push    rbp\n0x0046E0F4 | 48 89 E5 | mov     rbp, rsp\n0x0046E0F7 | 48 83 EC 10 | sub     rsp, 10h\n0x0046E0FB | 89 7D FC | mov     [rbp+c], edi\n0x0046E0FE | 48 89 75 F0 | mov     [rbp+stream], rsi\n0x0046E102 | 48 8B 05 0F F3 2E 00 | mov     rax, cs:qword_75D418\n0x0046E109 | 8B 50 30 | mov     edx, [rax+30h]\n0x0046E10C | 83 C2 01 | add     edx, 1\n0x0046E10F | 89 50 30 | mov     [rax+30h], edx\n0x0046E112 | 48 8B 55 F0 | mov     rdx, [rbp+stream]\n0x0046E116 | 8B 45 FC | mov     eax, [rbp+c]\n0x0046E119 | 48 89 D6 | mov     rsi, rdx; stream\n0x0046E11C | 89 C7 | mov     edi, eax; c\n0x0046E11E | E8 0D 92 F9 FF | call    _putc_unlocked\n0x0046E123 | 48 8B 45 F0 | mov     rax, [rbp+stream]\n0x0046E127 | 48 89 C7 | mov     rdi, rax; stream\n0x0046E12A | E8 51 92 F9 FF | call    _fflush\n0x0046E12F | E8 0B FF FF FF | call    sub_46E03F\n0x0046E134 | 90 | nop\n0x0046E135 | C9 | leave\n0x0046E136 | C3 | retn\n\n Ourput decompiled code:\nstatic void\noutcslow(int c, FILE *dest)\n{\n\tINT_OFF;\n\tputc(c, dest);\n\tfflush(dest);\n\tINT_ON;\n}\n\n## Example:\n\n Input assembly code:\n0x0042620E | 55 | push    rbp\n0x0042620F | 48 89 E5 | mov     rbp, rsp\n0x00426212 | 48 83 EC 10 | sub     rsp, 10h\n0x00426216 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0042621A | 89 75 F4 | mov     [rbp+var_C], esi\n0x0042621D | 48 8B 05 DC 71 33 00 | mov     rax, cs:qword_75D400\n0x00426224 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0\n0x0042622A | 8B 55 F4 | mov     edx, [rbp+var_C]\n0x0042622D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00426231 | 48 89 C6 | mov     rsi, rax\n0x00426234 | BF B0 00 00 00 | mov     edi, 0B0h; sysno\n0x00426239 | B8 00 00 00 00 | mov     eax, 0\n0x0042623E | E8 AD 0E FE FF | call    _syscall\n0x00426243 | 48 8B 05 B6 71 33 00 | mov     rax, cs:qword_75D400\n0x0042624A | 8B 00 | mov     eax, [rax]\n0x0042624C | C9 | leave\n0x0042624D | C3 | retn\n\n Ourput decompiled code:\nint FAST_FUNC bb_delete_module(const char *module, unsigned int flags)\n{\n\terrno = 0;\n\tdelete_module(module, flags);\n\treturn errno;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00480305 | 55 | push    rbp\n0x00480306 | 48 89 E5 | mov     rbp, rsp\n0x00480309 | 48 81 EC B0 00 00 00 | sub     rsp, 0B0h\n0x00480310 | 89 BD 5C FF FF FF | mov     [rbp+sig], edi\n0x00480316 | 48 89 B5 50 FF FF FF | mov     [rbp+var_B0], rsi\n0x0048031D | 48 8B 05 E4 D0 2D 00 | mov     rax, cs:qword_75D408\n0x00480324 | 48 8B 95 50 FF FF FF | mov     rdx, [rbp+var_B0]\n0x0048032B | 48 89 90 40 01 00 00 | mov     [rax+140h], rdx\n0x00480332 | 48 8B 05 CF D0 2D 00 | mov     rax, cs:qword_75D408\n0x00480339 | 48 8D 88 40 01 00 00 | lea     rcx, [rax+140h]\n0x00480340 | 48 8D 95 60 FF FF FF | lea     rdx, [rbp+var_A0]; oact\n0x00480347 | 8B 85 5C FF FF FF | mov     eax, [rbp+sig]\n0x0048034D | 48 89 CE | mov     rsi, rcx; act\n0x00480350 | 89 C7 | mov     edi, eax; sig\n0x00480352 | E8 19 65 F8 FF | call    _sigaction\n0x00480357 | 48 8B 85 60 FF FF FF | mov     rax, [rbp+var_A0]\n0x0048035E | C9 | leave\n0x0048035F | C3 | retn",
        "output": "\n\nstatic struct sigaction *\nsigaction(int sig, const struct sigaction *nact)\n{\n\tstruct sigaction oact, *sact;\n\n\toact.sa_handler = nact->sa_handler;\n\toact.sa_mask = nact->sa_mask;\n\toact.sa_flags = nact->sa_flags;\n\tsigaction(sig, &oact, &sact->sa_mask);\n\treturn (sact);\n}",
        "source_code": "static sighandler_t install_sighandler(int sig, sighandler_t handler)\n{\n\tstruct sigaction old_sa;\n\n\t/* We could use signal() to install handlers... almost:\n\t * except that we need to mask ALL signals while handlers run.\n\t * I saw signal nesting in strace, race window isn't small.\n\t * SA_RESTART is also needed, but in Linux, signal()\n\t * sets SA_RESTART too.\n\t */\n\t/* memset(&G.sa, 0, sizeof(G.sa)); - already done */\n\t/* sigfillset(&G.sa.sa_mask);      - already done */\n\t/* G.sa.sa_flags = SA_RESTART;     - already done */\n\tG.sa.sa_handler = handler;\n\tsigaction(sig, &G.sa, &old_sa);\n\treturn old_sa.sa_handler;\n}",
        "parsed_output": "\n\nstatic struct sigaction *\nsigaction(int sig, const struct sigaction *nact)\n{\n\tstruct sigaction oact, *sact;\n\n\toact.sa_handler = nact->sa_handler;\n\toact.sa_mask = nact->sa_mask;\n\toact.sa_flags = nact->sa_flags;\n\tsigaction(sig, &oact, &sact->sa_mask);\n\treturn (sact);\n}",
        "baseline_code_stripped": "__sighandler_t __fastcall sub_480305(int a1, __int64 a2)\n{\n  struct sigaction v3; // [rsp+10h] [rbp-A0h] BYREF\n\n  *((_QWORD *)qword_75D408 + 40) = a2;\n  sigaction(a1, (const struct sigaction *)((char *)qword_75D408 + 320), &v3);\n  return v3.sa_handler;\n}\n",
        "baseline_code_debug": "sighandler_t __cdecl install_sighandler(int sig, sighandler_t handler)\n{\n  sigaction old_sa; // [rsp+10h] [rbp-A0h] BYREF\n\n  ptr_to_globals[1].initstring = (char *)handler;\n  sigaction(sig, (const struct sigaction *)&ptr_to_globals[1].initstring, &old_sa);\n  return old_sa.sa_handler;\n}\n",
        "similarity_score_unixcoder": 0.8088198304176331,
        "similarity_score_baseline_stripped": 0.6133325099945068,
        "similarity_score_baseline_debug": 0.7921295762062073
    },
    {
        "func_name": "put_prompt",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004EB63E | 55 | push    rbp\n0x004EB63F | 48 89 E5 | mov     rbp, rsp\n0x004EB642 | 48 83 EC 10 | sub     rsp, 10h\n0x004EB646 | 48 8B 05 BB 1D 27 00 | mov     rax, cs:qword_75D408\n0x004EB64D | 48 8D 50 30 | lea     rdx, [rax+30h]\n0x004EB651 | 48 8B 05 B0 1D 27 00 | mov     rax, cs:qword_75D408\n0x004EB658 | 48 83 C0 34 | add     rax, 34h ; '4'\n0x004EB65C | 48 89 C6 | mov     rsi, rax\n0x004EB65F | BF 00 00 00 00 | mov     edi, 0\n0x004EB664 | E8 07 E8 F1 FF | call    sub_409E70\n0x004EB669 | 89 45 FC | mov     [rbp+var_4], eax\n0x004EB66C | 48 8B 05 95 1D 27 00 | mov     rax, cs:qword_75D408\n0x004EB673 | 8B 40 30 | mov     eax, [rax+30h]\n0x004EB676 | 3D 00 10 00 00 | cmp     eax, 1000h\n0x004EB67B | 76 0E | jbe     short loc_4EB68B\n0x004EB67D | 48 8B 05 84 1D 27 00 | mov     rax, cs:qword_75D408\n0x004EB684 | C7 40 30 00 10 00 00 | mov     dword ptr [rax+30h], 1000h\n0x004EB68B | 48 8B 05 76 1D 27 00 | mov     rax, cs:qword_75D408\n0x004EB692 | 8B 40 34 | mov     eax, [rax+34h]\n0x004EB695 | 3D 00 10 00 00 | cmp     eax, 1000h\n0x004EB69A | 76 0E | jbe     short loc_4EB6AA\n0x004EB69C | 48 8B 05 65 1D 27 00 | mov     rax, cs:qword_75D408\n0x004EB6A3 | C7 40 34 00 10 00 00 | mov     dword ptr [rax+34h], 1000h\n0x004EB6AA | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004EB6AD | C9 | leave\n0x004EB6AE | C3 | retn\n\n Ourput decompiled code:\nif ENABLE_FEATURE_VI_WIN_RESIZE\nstatic int query_screen_dimensions(void)\n{\n\tint err = get_terminal_width_height(STDIN_FILENO, &columns, &rows);\n\tif (rows > MAX_SCR_ROWS)\n\t\trows = MAX_SCR_ROWS;\n\tif (columns > MAX_SCR_COLS)\n\t\tcolumns = MAX_SCR_COLS;\n\treturn err;\n}\n\n## Example:\n\n Input assembly code:\n0x0042C3F5 | 55 | push    rbp\n0x0042C3F6 | 48 89 E5 | mov     rbp, rsp\n0x0042C3F9 | 48 83 EC 10 | sub     rsp, 10h\n0x0042C3FD | 48 8B 05 04 10 33 00 | mov     rax, cs:qword_75D408\n0x0042C404 | 48 8B 40 20 | mov     rax, [rax+20h]\n0x0042C408 | BA 0A 00 00 00 | mov     edx, 0Ah\n0x0042C40D | BE 00 00 00 00 | mov     esi, 0\n0x0042C412 | 48 89 C7 | mov     rdi, rax\n0x0042C415 | E8 B5 FA FD FF | call    sub_40BECF\n0x0042C41A | 89 45 FC | mov     [rbp+var_4], eax\n0x0042C41D | 48 8B 05 DC 0F 33 00 | mov     rax, cs:qword_75D400\n0x0042C424 | 8B 00 | mov     eax, [rax]\n0x0042C426 | 85 C0 | test    eax, eax\n0x0042C428 | 75 23 | jnz     short loc_42C44D\n0x0042C42A | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x0042C42E | 74 1D | jz      short loc_42C44D\n0x0042C430 | 81 7D FC FF FF 00 00 | cmp     [rbp+var_4], 0FFFFh\n0x0042C437 | 77 14 | ja      short loc_42C44D\n0x0042C439 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0042C43C | 89 C6 | mov     esi, eax\n0x0042C43E | BF 00 00 00 00 | mov     edi, 0\n0x0042C443 | E8 DB F8 0D 00 | call    sub_50BD23\n0x0042C448 | 89 45 FC | mov     [rbp+var_4], eax\n0x0042C44B | EB 1B | jmp     short loc_42C468\n0x0042C44D | 48 8B 05 B4 0F 33 00 | mov     rax, cs:qword_75D408\n0x0042C454 | 48 8B 40 20 | mov     rax, [rax+20h]\n0x0042C458 | BE 50 00 00 00 | mov     esi, 50h ; 'P'\n0x0042C45D | 48 89 C7 | mov     rdi, rax\n0x0042C460 | E8 BE F8 0D 00 | call    sub_50BD23\n0x0042C465 | 89 45 FC | mov     [rbp+var_4], eax\n0x0042C468 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0042C46B | BE 09 00 00 00 | mov     esi, 9\n0x0042C470 | 89 C7 | mov     edi, eax\n0x0042C472 | E8 9E E5 FD FF | call    sub_40AA15\n0x0042C477 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0042C47A | C9 | leave\n0x0042C47B | C3 | retn\n\n Ourput decompiled code:\nstatic int openServer(void)\n{\n\tunsigned n = bb_strtou(bind_addr_or_port, NULL, 10);\n\tif (!errno && n && n <= 0xffff)\n\t\tn = create_and_bind_stream_or_die(NULL, n);\n\telse\n\t\tn = create_and_bind_stream_or_die(bind_addr_or_port, 80);\n\txlisten(n, 9);\n\treturn n;\n}\n\n## Example:\n\n Input assembly code:\n0x004770DD | 55 | push    rbp\n0x004770DE | 48 89 E5 | mov     rbp, rsp\n0x004770E1 | 48 83 EC 10 | sub     rsp, 10h\n0x004770E5 | 48 8B 05 2C 63 2E 00 | mov     rax, cs:qword_75D418\n0x004770EC | 8B 50 30 | mov     edx, [rax+30h]\n0x004770EF | 83 C2 01 | add     edx, 1\n0x004770F2 | 89 50 30 | mov     [rax+30h], edx\n0x004770F5 | 48 8B 05 24 3F 2E 00 | mov     rax, cs:qword_75B020\n0x004770FC | 48 8B 00 | mov     rax, [rax]\n0x004770FF | 48 89 45 F8 | mov     [rbp+ptr], rax\n0x00477103 | 48 8B 05 16 3F 2E 00 | mov     rax, cs:qword_75B020\n0x0047710A | 48 8B 55 F8 | mov     rdx, [rbp+ptr]\n0x0047710E | 48 8B 12 | mov     rdx, [rdx]\n0x00477111 | 48 89 10 | mov     [rax], rdx\n0x00477114 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00477118 | 0F B6 40 10 | movzx   eax, byte ptr [rax+10h]\n0x0047711C | 3C 01 | cmp     al, 1\n0x0047711E | 75 10 | jnz     short loc_477130\n0x00477120 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00477124 | 48 8B 40 08 | mov     rax, [rax+8]\n0x00477128 | 48 89 C7 | mov     rdi, rax\n0x0047712B | E8 E5 71 FF FF | call    sub_46E315\n0x00477130 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00477134 | 48 89 C7 | mov     rdi, rax; ptr\n0x00477137 | E8 24 F5 F8 FF | call    _free\n0x0047713C | E8 FE 6E FF FF | call    sub_46E03F\n0x00477141 | 90 | nop\n0x00477142 | C9 | leave\n0x00477143 | C3 | retn\n\n Ourput decompiled code:\nstatic void\ndelete_cmd_entry(void)\n{\n\tstruct tblentry *cmdp;\n\n\tINT_OFF;\n\tcmdp = *lastcmdentry;\n\t*lastcmdentry = cmdp->next;\n\tif (cmdp->cmdtype == CMDFUNCTION)\n\t\tfreefunc(cmdp->param.func);\n\tfree(cmdp);\n\tINT_ON;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004FE30A | 55 | push    rbp\n0x004FE30B | 48 89 E5 | mov     rbp, rsp\n0x004FE30E | 48 83 EC 10 | sub     rsp, 10h\n0x004FE312 | 48 8B 15 4F CB 25 00 | mov     rdx, cs:stdout\n0x004FE319 | 48 8B 05 38 F1 25 00 | mov     rax, cs:qword_75D458\n0x004FE320 | 48 8B 40 38 | mov     rax, [rax+38h]\n0x004FE324 | 48 89 D6 | mov     rsi, rdx; stream\n0x004FE327 | 48 89 C7 | mov     rdi, rax; s\n0x004FE32A | E8 91 8C F0 FF | call    _fputs_unlocked\n0x004FE32F | E8 15 C3 F0 FF | call    sub_40A649\n0x004FE334 | 48 8B 05 1D F1 25 00 | mov     rax, cs:qword_75D458\n0x004FE33B | C7 40 24 00 00 00 00 | mov     dword ptr [rax+24h], 0\n0x004FE342 | 48 8B 05 0F F1 25 00 | mov     rax, cs:qword_75D458\n0x004FE349 | 8B 40 08 | mov     eax, [rax+8]\n0x004FE34C | 89 45 FC | mov     [rbp+var_4], eax\n0x004FE34F | 48 8B 05 02 F1 25 00 | mov     rax, cs:qword_75D458\n0x004FE356 | 8B 40 20 | mov     eax, [rax+20h]\n0x004FE359 | 48 8B 0D F8 F0 25 00 | mov     rcx, cs:qword_75D458\n0x004FE360 | BA 00 00 00 00 | mov     edx, 0\n0x004FE365 | F7 75 FC | div     [rbp+var_4]\n0x004FE368 | 89 41 1C | mov     [rcx+1Ch], eax\n0x004FE36B | 48 8B 05 E6 F0 25 00 | mov     rax, cs:qword_75D458\n0x004FE372 | 8B 40 20 | mov     eax, [rax+20h]\n0x004FE375 | 48 8B 0D DC F0 25 00 | mov     rcx, cs:qword_75D458\n0x004FE37C | BA 00 00 00 00 | mov     edx, 0\n0x004FE381 | F7 75 FC | div     [rbp+var_4]\n0x004FE384 | 89 D0 | mov     eax, edx\n0x004FE386 | 89 41 18 | mov     [rcx+18h], eax\n0x004FE389 | 90 | nop\n0x004FE38A | C9 | leave\n0x004FE38B | C3 | retn",
        "output": "\n\nstatic void\nset_screen_size(void)\n{\n\tfputs(tty_rows_cols[2], stdout);\n\tfflush(stdout);\n\ttty_rows_cols[4] = 0;\n\trows = tty_rows_cols[0];\n\ttty_rows_cols[6] = tty_rows_cols[0] / tty_rows_cols[2];\n\ttty_rows_cols[7] = tty_rows_cols[0] % tty_rows_cols[2];\n}",
        "source_code": "static void put_prompt(void)\n{\n\tunsigned w;\n\n\tfputs(cmdedit_prompt, stdout);\n\tfflush_all();\n\tcursor = 0;\n\tw = cmdedit_termw; /* read volatile var once */\n\tcmdedit_y = cmdedit_prmt_len / w; /* new quasireal y */\n\tcmdedit_x = cmdedit_prmt_len % w;\n}",
        "parsed_output": "\n\nstatic void\nset_screen_size(void)\n{\n\tfputs(tty_rows_cols[2], stdout);\n\tfflush(stdout);\n\ttty_rows_cols[4] = 0;\n\trows = tty_rows_cols[0];\n\ttty_rows_cols[6] = tty_rows_cols[0] / tty_rows_cols[2];\n\ttty_rows_cols[7] = tty_rows_cols[0] % tty_rows_cols[2];\n}",
        "baseline_code_stripped": "__int64 sub_4FE30A()\n{\n  __int64 result; // rax\n  unsigned int v1; // [rsp+Ch] [rbp-4h]\n\n  fputs_unlocked(*((const char **)qword_75D458 + 7), stdout);\n  sub_40A649();\n  *((_DWORD *)qword_75D458 + 9) = 0;\n  v1 = *((_DWORD *)qword_75D458 + 2);\n  *((_DWORD *)qword_75D458 + 7) = *((_DWORD *)qword_75D458 + 8) / v1;\n  result = *((_DWORD *)qword_75D458 + 8) % v1;\n  *((_DWORD *)qword_75D458 + 6) = result;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl put_prompt()\n{\n  unsigned int w; // [rsp+Ch] [rbp-4h]\n\n  fputs_unlocked(lineedit_ptr_to_statics->cmdedit_prompt, stdout);\n  fflush_all();\n  lineedit_ptr_to_statics->cursor = 0;\n  w = lineedit_ptr_to_statics->cmdedit_termw;\n  lineedit_ptr_to_statics->cmdedit_y = lineedit_ptr_to_statics->cmdedit_prmt_len / w;\n  lineedit_ptr_to_statics->cmdedit_x = lineedit_ptr_to_statics->cmdedit_prmt_len % w;\n}\n",
        "similarity_score_unixcoder": 0.5826683640480042,
        "similarity_score_baseline_stripped": 0.4488571882247925,
        "similarity_score_baseline_debug": 0.7783833146095276
    },
    {
        "func_name": "udhcp_str2nip",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004A872C | 55 | push    rbp\n0x004A872D | 48 89 E5 | mov     rbp, rsp\n0x004A8730 | 48 83 EC 20 | sub     rsp, 20h\n0x004A8734 | 48 89 7D E8 | mov     [rbp+s], rdi\n0x004A8738 | 48 89 75 E0 | mov     [rbp+s2], rsi\n0x004A873C | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x004A8740 | BE 2E 00 00 00 | mov     esi, 2Eh ; '.'; c\n0x004A8745 | 48 89 C7 | mov     rdi, rax; s\n0x004A8748 | E8 E3 E4 F5 FF | call    _strrchr\n0x004A874D | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004A8751 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004A8756 | 74 1B | jz      short loc_4A8773\n0x004A8758 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004A875C | 48 8D 50 01 | lea     rdx, [rax+1]\n0x004A8760 | 48 8B 45 E0 | mov     rax, [rbp+s2]\n0x004A8764 | 48 89 C6 | mov     rsi, rax; s2\n0x004A8767 | 48 89 D7 | mov     rdi, rdx; s1\n0x004A876A | E8 E1 E8 F5 FF | call    _strcmp\n0x004A876F | 85 C0 | test    eax, eax\n0x004A8771 | 74 07 | jz      short loc_4A877A\n0x004A8773 | B8 00 00 00 00 | mov     eax, 0\n0x004A8778 | EB 0B | jmp     short locret_4A8785\n0x004A877A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004A877E | C6 00 00 | mov     byte ptr [rax], 0\n0x004A8781 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x004A8785 | C9 | leave\n0x004A8786 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC make_new_name_generic(char *filename, const char *expected_ext)\n{\n\tchar *extension = strrchr(filename, '.');\n\tif (!extension || strcmp(extension + 1, expected_ext) != 0) {\n\t\t/* Mimic GNU gunzip - \"real\" bunzip2 tries to */\n\t\t/* unpack file anyway, to file.out */\n\t\treturn NULL;\n\t}\n\t*extension = '\\0';\n\treturn filename;\n}\n\n## Example:\n\n Input assembly code:\n0x00461B56 | 55 | push    rbp\n0x00461B57 | 48 89 E5 | mov     rbp, rsp\n0x00461B5A | 48 83 EC 20 | sub     rsp, 20h\n0x00461B5E | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00461B62 | 48 89 75 E0 | mov     [rbp+s], rsi\n0x00461B66 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00461B6A | 48 89 C7 | mov     rdi, rax\n0x00461B6D | E8 FA 7C FA FF | call    sub_40986C\n0x00461B72 | 48 89 45 F8 | mov     [rbp+stream], rax\n0x00461B76 | 48 83 7D F8 00 | cmp     [rbp+stream], 0\n0x00461B7B | 75 07 | jnz     short loc_461B84\n0x00461B7D | B8 01 00 00 00 | mov     eax, 1\n0x00461B82 | EB 24 | jmp     short locret_461BA8\n0x00461B84 | 48 8B 55 F8 | mov     rdx, [rbp+stream]\n0x00461B88 | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x00461B8C | 48 89 D6 | mov     rsi, rdx; stream\n0x00461B8F | 48 89 C7 | mov     rdi, rax; s\n0x00461B92 | E8 29 54 FA FF | call    _fputs_unlocked\n0x00461B97 | 48 8B 45 F8 | mov     rax, [rbp+stream]\n0x00461B9B | 48 89 C7 | mov     rdi, rax; stream\n0x00461B9E | E8 5D 4E FA FF | call    _fclose\n0x00461BA3 | B8 00 00 00 00 | mov     eax, 0\n0x00461BA8 | C9 | leave\n0x00461BA9 | C3 | retn\n\n Ourput decompiled code:\nendif\n\nstatic int write_str_to_file(const char *fname, const char *str)\n{\n\tFILE *fp = fopen_for_write(fname);\n\tif (!fp)\n\t\treturn 1;\n\tfputs(str, fp);\n\tfclose(fp);\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x0040A1FC | 55 | push    rbp\n0x0040A1FD | 48 89 E5 | mov     rbp, rsp\n0x0040A200 | 48 83 EC 20 | sub     rsp, 20h\n0x0040A204 | 48 89 7D E8 | mov     [rbp+filename], rdi\n0x0040A208 | 48 89 75 E0 | mov     [rbp+modes], rsi\n0x0040A20C | 48 8B 55 E0 | mov     rdx, [rbp+modes]\n0x0040A210 | 48 8B 45 E8 | mov     rax, [rbp+filename]\n0x0040A214 | 48 89 D6 | mov     rsi, rdx; modes\n0x0040A217 | 48 89 C7 | mov     rdi, rax; filename\n0x0040A21A | E8 31 CF FF FF | call    _fopen64\n0x0040A21F | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0040A223 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0040A228 | 75 16 | jnz     short loc_40A240\n0x0040A22A | 48 8B 45 E8 | mov     rax, [rbp+filename]\n0x0040A22E | 48 89 C6 | mov     rsi, rax\n0x0040A231 | BF 0D 80 52 00 | mov     edi, offset aCanTOpenS; \"can't open '%s'\"\n0x0040A236 | B8 00 00 00 00 | mov     eax, 0\n0x0040A23B | E8 62 F0 FF FF | call    sub_4092A2\n0x0040A240 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0040A244 | C9 | leave\n0x0040A245 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC xfopen(const char *path, const char *mode)\n{\n\tFILE *fp = fopen(path, mode);\n\tif (fp == NULL)\n\t\tbb_perror_msg_and_die(\"can't open '%s'\", path);\n\treturn fp;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00459D25 | 55 | push    rbp\n0x00459D26 | 48 89 E5 | mov     rbp, rsp\n0x00459D29 | 48 83 EC 20 | sub     rsp, 20h\n0x00459D2D | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00459D31 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00459D35 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00459D39 | BA 02 00 00 00 | mov     edx, 2\n0x00459D3E | BE 00 00 00 00 | mov     esi, 0\n0x00459D43 | 48 89 C7 | mov     rdi, rax\n0x00459D46 | E8 57 1D 0B 00 | call    sub_50BAA2\n0x00459D4B | 48 89 45 F8 | mov     [rbp+ptr], rax\n0x00459D4F | 48 83 7D F8 00 | cmp     [rbp+ptr], 0\n0x00459D54 | 75 07 | jnz     short loc_459D5D\n0x00459D56 | B8 00 00 00 00 | mov     eax, 0\n0x00459D5B | EB 1E | jmp     short locret_459D7B\n0x00459D5D | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00459D61 | 8B 50 08 | mov     edx, [rax+8]\n0x00459D64 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00459D68 | 89 10 | mov     [rax], edx\n0x00459D6A | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00459D6E | 48 89 C7 | mov     rdi, rax; ptr\n0x00459D71 | E8 EA C8 FA FF | call    _free\n0x00459D76 | B8 01 00 00 00 | mov     eax, 1\n0x00459D7B | C9 | leave\n0x00459D7C | C3 | retn",
        "output": "\n\nstatic int get_file_size(const char *fname, off_t *size)\n{\n\tstruct stat st;\n\n\tst = *((struct stat *)memset((void *)&st, 0, sizeof(st)));\n\n\tif ((st = stat(fname, &st)) == 0) {\n\t\t*size = st.st_size;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
        "source_code": "int FAST_FUNC udhcp_str2nip(const char *str, void *arg)\n{\n\tlen_and_sockaddr *lsa;\n\n\tlsa = host_and_af2sockaddr(str, 0, AF_INET);\n\tif (!lsa)\n\t\treturn 0;\n\t/* arg maybe unaligned */\n\tmove_to_unaligned32((uint32_t*)arg, lsa->u.sin.sin_addr.s_addr);\n\tfree(lsa);\n\treturn 1;\n}",
        "parsed_output": "\n\nstatic int get_file_size(const char *fname, off_t *size)\n{\n\tstruct stat st;\n\n\tst = *((struct stat *)memset((void *)&st, 0, sizeof(st)));\n\n\tif ((st = stat(fname, &st)) == 0) {\n\t\t*size = st.st_size;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_459D25(__int64 a1, _DWORD *a2)\n{\n  _DWORD *ptr; // [rsp+18h] [rbp-8h]\n\n  ptr = (_DWORD *)sub_50BAA2(a1, 0LL, 2LL);\n  if ( !ptr )\n    return 0LL;\n  *a2 = ptr[2];\n  free(ptr);\n  return 1LL;\n}\n",
        "baseline_code_debug": "int __cdecl udhcp_str2nip(const char *str, void *arg)\n{\n  len_and_sockaddr_0 *lsa; // [rsp+18h] [rbp-8h]\n\n  lsa = host_and_af2sockaddr(str, 0, 2u);\n  if ( !lsa )\n    return 0;\n  *(_DWORD *)arg = lsa->u.sin.sin_addr.s_addr;\n  free(lsa);\n  return 1;\n}\n",
        "similarity_score_unixcoder": 0.47560393810272217,
        "similarity_score_baseline_stripped": 0.47081640362739563,
        "similarity_score_baseline_debug": 0.9108211994171143
    },
    {
        "func_name": "llist_find_str",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004C03B7 | 55 | push    rbp\n0x004C03B8 | 48 89 E5 | mov     rbp, rsp\n0x004C03BB | 48 83 EC 10 | sub     rsp, 10h\n0x004C03BF | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004C03C3 | 48 89 75 F0 | mov     [rbp+name], rsi\n0x004C03C7 | EB 31 | jmp     short loc_4C03FA\n0x004C03C9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C03CD | 48 8B 40 08 | mov     rax, [rax+8]\n0x004C03D1 | 48 8B 4D F0 | mov     rcx, [rbp+name]\n0x004C03D5 | BA 00 00 00 00 | mov     edx, 0; flags\n0x004C03DA | 48 89 CE | mov     rsi, rcx; name\n0x004C03DD | 48 89 C7 | mov     rdi, rax; pattern\n0x004C03E0 | E8 3B 69 F4 FF | call    _fnmatch\n0x004C03E5 | 85 C0 | test    eax, eax\n0x004C03E7 | 75 06 | jnz     short loc_4C03EF\n0x004C03E9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C03ED | EB 17 | jmp     short locret_4C0406\n0x004C03EF | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C03F3 | 48 8B 00 | mov     rax, [rax]\n0x004C03F6 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004C03FA | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004C03FF | 75 C8 | jnz     short loc_4C03C9\n0x004C0401 | B8 00 00 00 00 | mov     eax, 0\n0x004C0406 | C9 | leave\n0x004C0407 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC find_list_entry(const llist_t *list, const char *filename)\n{\n\twhile (list) {\n\t\tif (fnmatch(list->data, filename, 0) == 0) {\n\t\t\treturn list;\n\t\t}\n\t\tlist = list->link;\n\t}\n\treturn NULL;\n}\n\n## Example:\n\n Input assembly code:\n0x0045942D | 55 | push    rbp\n0x0045942E | 48 89 E5 | mov     rbp, rsp\n0x00459431 | 48 83 EC 10 | sub     rsp, 10h\n0x00459435 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00459439 | 48 89 75 F0 | mov     [rbp+s2], rsi\n0x0045943D | EB 34 | jmp     short loc_459473\n0x0045943F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00459443 | 48 8D 48 0C | lea     rcx, [rax+0Ch]\n0x00459447 | 48 8B 45 F0 | mov     rax, [rbp+s2]\n0x0045944B | BA 06 00 00 00 | mov     edx, 6; n\n0x00459450 | 48 89 C6 | mov     rsi, rax; s2\n0x00459453 | 48 89 CF | mov     rdi, rcx; s1\n0x00459456 | E8 05 DB FA FF | call    _memcmp\n0x0045945B | 85 C0 | test    eax, eax\n0x0045945D | 75 09 | jnz     short loc_459468\n0x0045945F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00459463 | 8B 40 08 | mov     eax, [rax+8]\n0x00459466 | EB 17 | jmp     short locret_45947F\n0x00459468 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045946C | 48 8B 00 | mov     rax, [rax]\n0x0045946F | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00459473 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00459478 | 75 C5 | jnz     short loc_45943F\n0x0045947A | B8 00 00 00 00 | mov     eax, 0\n0x0045947F | C9 | leave\n0x00459480 | C3 | retn\n\n Ourput decompiled code:\nuint32_t FAST_FUNC get_static_nip_by_mac(struct static_lease *st_lease, void *mac)\n{\n\twhile (st_lease) {\n\t\tif (memcmp(st_lease->mac, mac, 6) == 0)\n\t\t\treturn st_lease->nip;\n\t\tst_lease = st_lease->next;\n\t}\n\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x00409018 | 55 | push    rbp\n0x00409019 | 48 89 E5 | mov     rbp, rsp\n0x0040901C | 48 83 EC 10 | sub     rsp, 10h\n0x00409020 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00409024 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x00409028 | EB 0B | jmp     short loc_409035\n0x0040902A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0040902E | 48 8B 00 | mov     rax, [rax]\n0x00409031 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00409035 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00409039 | 48 8B 00 | mov     rax, [rax]\n0x0040903C | 48 85 C0 | test    rax, rax\n0x0040903F | 75 E9 | jnz     short loc_40902A\n0x00409041 | BF 10 00 00 00 | mov     edi, 10h\n0x00409046 | E8 9D 10 00 00 | call    sub_40A0E8\n0x0040904B | 48 89 C2 | mov     rdx, rax\n0x0040904E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00409052 | 48 89 10 | mov     [rax], rdx\n0x00409055 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00409059 | 48 8B 00 | mov     rax, [rax]\n0x0040905C | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x00409060 | 48 89 50 08 | mov     [rax+8], rdx\n0x00409064 | 90 | nop\n0x00409065 | C9 | leave\n0x00409066 | C3 | retn\n\n Ourput decompiled code:\nvoid FAST_FUNC llist_add_to_end(llist_t **list_head, void *data)\n{\n\twhile (*list_head)\n\t\tlist_head = &(*list_head)->link;\n\t*list_head = xzalloc(sizeof(llist_t));\n\t(*list_head)->data = data;\n\t/*(*list_head)->link = NULL;*/\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00409191 | 55 | push    rbp\n0x00409192 | 48 89 E5 | mov     rbp, rsp\n0x00409195 | 48 83 EC 10 | sub     rsp, 10h\n0x00409199 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0040919D | 48 89 75 F0 | mov     [rbp+s2], rsi\n0x004091A1 | EB 26 | jmp     short loc_4091C9\n0x004091A3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004091A7 | 48 8B 40 08 | mov     rax, [rax+8]\n0x004091AB | 48 8B 55 F0 | mov     rdx, [rbp+s2]\n0x004091AF | 48 89 D6 | mov     rsi, rdx; s2\n0x004091B2 | 48 89 C7 | mov     rdi, rax; s1\n0x004091B5 | E8 96 DE FF FF | call    _strcmp\n0x004091BA | 85 C0 | test    eax, eax\n0x004091BC | 74 14 | jz      short loc_4091D2\n0x004091BE | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004091C2 | 48 8B 00 | mov     rax, [rax]\n0x004091C5 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004091C9 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004091CE | 75 D3 | jnz     short loc_4091A3\n0x004091D0 | EB 01 | jmp     short loc_4091D3\n0x004091D2 | 90 | nop\n0x004091D3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004091D7 | C9 | leave\n0x004091D8 | C3 | retn",
        "output": "\n\nstatic llist_t * FAST_FUNC find_list_entry(const llist_t *list, const char *filename)\n{\n\twhile (list) {\n\t\tif (strcmp(list->data, filename) == 0) {\n\t\t\treturn list;\n\t\t}\n\t\tlist = list->link;\n\t}\n\treturn NULL;\n}",
        "source_code": "FAST_FUNC llist_find_str(llist_t *list, const char *str)\n{\n\twhile (list) {\n\t\tif (strcmp(list->data, str) == 0)\n\t\t\tbreak;\n\t\tlist = list->link;\n\t}\n\treturn list;\n}",
        "parsed_output": "\n\nstatic llist_t * FAST_FUNC find_list_entry(const llist_t *list, const char *filename)\n{\n\twhile (list) {\n\t\tif (strcmp(list->data, filename) == 0) {\n\t\t\treturn list;\n\t\t}\n\t\tlist = list->link;\n\t}\n\treturn NULL;\n}",
        "baseline_code_stripped": "__int64 **__fastcall sub_409191(__int64 **a1, const char *a2)\n{\n  while ( a1 && strcmp((const char *)a1[1], a2) )\n    a1 = (__int64 **)*a1;\n  return a1;\n}\n",
        "baseline_code_debug": "llist_t_0 *__cdecl llist_find_str(llist_t_0 *list, const char *str)\n{\n  while ( list && strcmp(list->data, str) )\n    list = list->link;\n  return list;\n}\n",
        "similarity_score_unixcoder": 0.8650422096252441,
        "similarity_score_baseline_stripped": 0.563047468662262,
        "similarity_score_baseline_debug": 0.926653265953064
    },
    {
        "func_name": "change_identity",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00414F2F | 55 | push    rbp\n0x00414F30 | 48 89 E5 | mov     rbp, rsp\n0x00414F33 | 48 83 EC 10 | sub     rsp, 10h\n0x00414F37 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00414F3B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00414F3F | 48 89 C7 | mov     rdi, rax\n0x00414F42 | E8 22 16 0E 00 | call    sub_4F6569\n0x00414F47 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00414F4B | 48 8B 40 20 | mov     rax, [rax+20h]\n0x00414F4F | 48 89 C7 | mov     rdi, rax; path\n0x00414F52 | E8 99 1B FF FF | call    _chdir\n0x00414F57 | 85 C0 | test    eax, eax\n0x00414F59 | 79 3C | jns     short loc_414F97\n0x00414F5B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00414F5F | 48 8B 40 20 | mov     rax, [rax+20h]\n0x00414F63 | 48 89 C6 | mov     rsi, rax\n0x00414F66 | BF 37 8D 52 00 | mov     edi, offset aIchdirS; \"Ichdir(%s)\"\n0x00414F6B | B8 00 00 00 00 | mov     eax, 0\n0x00414F70 | E8 02 F4 FF FF | call    sub_414377\n0x00414F75 | BF 42 8D 52 00 | mov     edi, offset path; \"/var/spool/cron\"\n0x00414F7A | E8 71 1B FF FF | call    _chdir\n0x00414F7F | 85 C0 | test    eax, eax\n0x00414F81 | 79 14 | jns     short loc_414F97\n0x00414F83 | BE 42 8D 52 00 | mov     esi, offset path; \"/var/spool/cron\"\n0x00414F88 | BF 20 8D 52 00 | mov     edi, offset byte_528D20\n0x00414F8D | B8 00 00 00 00 | mov     eax, 0\n0x00414F92 | E8 E0 F3 FF FF | call    sub_414377\n0x00414F97 | 90 | nop\n0x00414F98 | C9 | leave\n0x00414F99 | C3 | retn\n\n Ourput decompiled code:\nstatic void change_user(struct passwd *pas)\n{\n\t/* careful: we're after vfork! */\n\tchange_identity(pas); /* - initgroups, setgid, setuid */\n\tif (chdir(pas->pw_dir) < 0) {\n\t\tcrondlog(WARN9 \"chdir(%s)\", pas->pw_dir);\n\t\tif (chdir(TMPDIR) < 0) {\n\t\t\tcrondlog(DIE9 \"chdir(%s)\", TMPDIR); /* exits */\n\t\t}\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x004B748C | 55 | push    rbp\n0x004B748D | 48 89 E5 | mov     rbp, rsp\n0x004B7490 | 48 83 EC 10 | sub     rsp, 10h\n0x004B7494 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004B7498 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004B749C | 48 8B 40 28 | mov     rax, [rax+28h]\n0x004B74A0 | 48 8B 50 20 | mov     rdx, [rax+20h]\n0x004B74A4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004B74A8 | 8B 40 04 | mov     eax, [rax+4]\n0x004B74AB | BE 01 00 00 00 | mov     esi, 1\n0x004B74B0 | 89 C7 | mov     edi, eax\n0x004B74B2 | E8 52 3E F5 FF | call    sub_40B309\n0x004B74B7 | 90 | nop\n0x004B74B8 | C9 | leave\n0x004B74B9 | C3 | retn\n\n Ourput decompiled code:\nvoid FAST_FUNC data_extract_to_stdout(archive_handle_t *archive_handle)\n{\n\tbb_copyfd_exact_size(archive_handle->src_fd,\n\t\t\tSTDOUT_FILENO,\n\t\t\tarchive_handle->file_header->size);\n}\n\n## Example:\n\n Input assembly code:\n0x00455CC5 | 55 | push    rbp\n0x00455CC6 | 48 89 E5 | mov     rbp, rsp\n0x00455CC9 | 48 83 EC 10 | sub     rsp, 10h\n0x00455CCD | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00455CD1 | 8B 05 89 77 30 00 | mov     eax, cs:dword_75D460\n0x00455CD7 | 85 C0 | test    eax, eax\n0x00455CD9 | 74 0F | jz      short loc_455CEA\n0x00455CDB | BF 83 CE 52 00 | mov     edi, offset aForwardingPack; \"Forwarding packet to relay\"\n0x00455CE0 | B8 00 00 00 00 | mov     eax, 0\n0x00455CE5 | E8 D2 7D 0A 00 | call    sub_4FDABC\n0x00455CEA | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00455CEE | 8B 50 18 | mov     edx, [rax+18h]\n0x00455CF1 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00455CF6 | 8B 70 0C | mov     esi, [rax+0Ch]\n0x00455CF9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00455CFD | 41 B8 43 00 00 00 | mov     r8d, 43h ; 'C'\n0x00455D03 | 89 D1 | mov     ecx, edx\n0x00455D05 | BA 43 00 00 00 | mov     edx, 43h ; 'C'\n0x00455D0A | 48 89 C7 | mov     rdi, rax\n0x00455D0D | E8 F5 2F 00 00 | call    sub_458D07\n0x00455D12 | 90 | nop\n0x00455D13 | C9 | leave\n0x00455D14 | C3 | retn\n\n Ourput decompiled code:\nstatic void send_packet_to_relay(struct dhcp_packet *dhcp_pkt)\n{\n\tlog1(\"Forwarding packet to relay\");\n\n\tudhcp_send_kernel_packet(dhcp_pkt,\n\t\t\tserver_config.server_nip, SERVER_PORT,\n\t\t\tdhcp_pkt->gateway_nip, SERVER_PORT);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F6569 | 55 | push    rbp\n0x004F656A | 48 89 E5 | mov     rbp, rsp\n0x004F656D | 48 83 EC 10 | sub     rsp, 10h\n0x004F6571 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004F6575 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F6579 | 8B 50 14 | mov     edx, [rax+14h]\n0x004F657C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F6580 | 48 8B 00 | mov     rax, [rax]\n0x004F6583 | 89 D6 | mov     esi, edx\n0x004F6585 | 48 89 C7 | mov     rdi, rax\n0x004F6588 | E8 5F 63 F1 FF | call    sub_40C8EC\n0x004F658D | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x004F6590 | 75 0F | jnz     short loc_4F65A1\n0x004F6592 | BF 1F 72 53 00 | mov     edi, offset aCanTSetGroups; \"can't set groups\"\n0x004F6597 | B8 00 00 00 00 | mov     eax, 0\n0x004F659C | E8 01 2D F1 FF | call    sub_4092A2\n0x004F65A1 | E8 42 61 F1 FF | call    sub_40C6E8\n0x004F65A6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F65AA | 8B 40 14 | mov     eax, [rax+14h]\n0x004F65AD | 89 C7 | mov     edi, eax\n0x004F65AF | E8 9D 42 F1 FF | call    sub_40A851\n0x004F65B4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004F65B8 | 8B 40 10 | mov     eax, [rax+10h]\n0x004F65BB | 89 C7 | mov     edi, eax\n0x004F65BD | E8 BA 42 F1 FF | call    sub_40A87C\n0x004F65C2 | 90 | nop\n0x004F65C3 | C9 | leave\n0x004F65C4 | C3 | retn",
        "output": "\n\nstatic void change_identity(struct passwd *pas)\n{\n\tif (setgroups(pas->pw_gid, pas->pw_gidlist) == -1)\n\t\tlog0(\"can't set groups\");\n\n\tsetgid(pas->pw_gid);\n\tsetuid(pas->pw_uid);\n}",
        "source_code": "void FAST_FUNC change_identity(const struct passwd *pw)\n{\n\tif (initgroups(pw->pw_name, pw->pw_gid) == -1)\n\t\tbb_perror_msg_and_die(\"can't set groups\");\n\tendgrent(); /* helps to close a fd used internally by libc */\n\txsetgid(pw->pw_gid);\n\txsetuid(pw->pw_uid);\n}",
        "parsed_output": "\n\nstatic void change_identity(struct passwd *pas)\n{\n\tif (setgroups(pas->pw_gid, pas->pw_gidlist) == -1)\n\t\tlog0(\"can't set groups\");\n\n\tsetgid(pas->pw_gid);\n\tsetuid(pas->pw_uid);\n}",
        "baseline_code_stripped": "int __fastcall sub_4F6569(__int64 a1)\n{\n  __int64 v1; // rsi\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n\n  v1 = *(unsigned int *)(a1 + 20);\n  if ( (unsigned int)sub_40C8EC(*(const char **)a1, v1) == -1 )\n    sub_4092A2((__int64)\"can't set groups\", v1, v2, v3, v4, v5);\n  sub_40C6E8();\n  sub_40A851(*(_DWORD *)(a1 + 20), v1);\n  return sub_40A87C(*(_DWORD *)(a1 + 16), v1);\n}\n",
        "baseline_code_debug": "void __cdecl change_identity(const passwd *pw)\n{\n  if ( bb_internal_initgroups(pw->pw_name, pw->pw_gid) == -1 )\n    bb_perror_msg_and_die(\"can't set groups\");\n  bb_internal_endgrent();\n  xsetgid(pw->pw_gid);\n  xsetuid(pw->pw_uid);\n}\n",
        "similarity_score_unixcoder": 0.8762774467468262,
        "similarity_score_baseline_stripped": 0.5057234168052673,
        "similarity_score_baseline_debug": 0.9373175501823425
    },
    {
        "func_name": "archivejoin",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004562E0 | 55 | push    rbp\n0x004562E1 | 48 89 E5 | mov     rbp, rsp\n0x004562E4 | 48 81 EC 90 02 00 00 | sub     rsp, 290h\n0x004562EB | 48 89 BD 78 FD FF FF | mov     [rbp+var_288], rdi\n0x004562F2 | 48 8B 8D 78 FD FF FF | mov     rcx, [rbp+var_288]\n0x004562F9 | 48 8D 85 80 FD FF FF | lea     rax, [rbp+var_280]\n0x00456300 | BA 05 00 00 00 | mov     edx, 5\n0x00456305 | 48 89 CE | mov     rsi, rcx\n0x00456308 | 48 89 C7 | mov     rdi, rax\n0x0045630B | E8 41 FA FF FF | call    sub_455D51\n0x00456310 | 48 8D 85 80 FD FF FF | lea     rax, [rbp+var_280]\n0x00456317 | 48 89 C7 | mov     rdi, rax\n0x0045631A | E8 CD FA FF FF | call    sub_455DEC\n0x0045631F | 48 8D 85 80 FD FF FF | lea     rax, [rbp+var_280]\n0x00456326 | BE 00 00 00 00 | mov     esi, 0\n0x0045632B | 48 89 C7 | mov     rdi, rax\n0x0045632E | E8 E2 F9 FF FF | call    sub_455D15\n0x00456333 | 90 | nop\n0x00456334 | C9 | leave\n0x00456335 | C3 | retn\n\n Ourput decompiled code:\nstatic NOINLINE void send_inform(struct dhcp_packet *oldpacket)\n{\n\tstruct dhcp_packet packet;\n\n\t/* \"If a client has obtained a network address through some other means\n\t * (e.g., manual configuration), it may use a DHCPINFORM request message\n\t * to obtain other local configuration parameters.  Servers receiving a\n\t * DHCPINFORM message construct a DHCPACK message with any local\n\t * configuration parameters appropriate for the client without:\n\t * allocating a new address, checking for an existing binding, filling\n\t * in 'yiaddr' or including lease time parameters.  The servers SHOULD\n\t * unicast the DHCPACK reply to the address given in the 'ciaddr' field\n\t * of the DHCPINFORM message.\n\t * ...\n\t * The server responds to a DHCPINFORM message by sending a DHCPACK\n\t * message directly to the address given in the 'ciaddr' field\n\t * of the DHCPINFORM message.  The server MUST NOT send a lease\n\t * expiration time to the client and SHOULD NOT fill in 'yiaddr'.\"\n\t */\n//TODO: do a few sanity checks: is ciaddr set?\n//Better yet: is ciaddr == IP source addr?\n\tinit_packet(&packet, oldpacket, DHCPACK);\n\tadd_server_options(&packet);\n\n\tsend_packet(&packet, /*force_bcast:*/ 0);\n}\n\n## Example:\n\n Input assembly code:\n0x004F018A | 55 | push    rbp\n0x004F018B | 48 89 E5 | mov     rbp, rsp\n0x004F018E | 48 81 EC 90 00 00 00 | sub     rsp, 90h\n0x004F0195 | 48 89 BD 78 FF FF FF | mov     [rbp+var_88], rdi\n0x004F019C | 48 8B 95 78 FF FF FF | mov     rdx, [rbp+var_88]\n0x004F01A3 | 48 8D 45 80 | lea     rax, [rbp+var_80]\n0x004F01A7 | 48 89 D6 | mov     rsi, rdx\n0x004F01AA | 48 89 C7 | mov     rdi, rax\n0x004F01AD | E8 B7 FE FF FF | call    sub_4F0069\n0x004F01B2 | 48 8D 45 80 | lea     rax, [rbp+var_80]\n0x004F01B6 | 48 89 C6 | mov     rsi, rax\n0x004F01B9 | BF 60 77 52 00 | mov     edi, offset aSIsNotImplemen; \"'%s' is not implemented\"\n0x004F01BE | B8 00 00 00 00 | mov     eax, 0\n0x004F01C3 | E8 CF FC FF FF | call    sub_4EFE97\n0x004F01C8 | 90 | nop\n0x004F01C9 | C9 | leave\n0x004F01CA | C3 | retn\n\n Ourput decompiled code:\nstatic void not_implemented(const char *s)\n{\n\tchar buf[MAX_INPUT_LEN];\n\n\tprint_literal(buf, s);\n\tstatus_line_bold(\"\\'%s\\' is not implemented\", buf);\n}\n\n## Example:\n\n Input assembly code:\n0x00485FD8 | 55 | push    rbp\n0x00485FD9 | 48 89 E5 | mov     rbp, rsp\n0x00485FDC | 48 83 EC 40 | sub     rsp, 40h\n0x00485FE0 | 48 89 7D C8 | mov     [rbp+var_38], rdi\n0x00485FE4 | 48 8B 55 C8 | mov     rdx, [rbp+var_38]\n0x00485FE8 | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00485FEC | 48 89 D6 | mov     rsi, rdx\n0x00485FEF | 48 89 C7 | mov     rdi, rax\n0x00485FF2 | E8 22 B3 FF FF | call    sub_481319\n0x00485FF7 | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00485FFB | BE 00 00 00 00 | mov     esi, 0\n0x00486000 | 48 89 C7 | mov     rdi, rax\n0x00486003 | E8 FD FE FF FF | call    sub_485F05\n0x00486008 | 90 | nop\n0x00486009 | C9 | leave\n0x0048600A | C3 | retn\n\n Ourput decompiled code:\nstatic void parse_and_run_string(const char *s)\n{\n\tstruct in_str input;\n\tsetup_string_in_str(&input, s);\n\tparse_and_run_stream(&input, '\\0');\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00464F04 | 55 | push    rbp\n0x00464F05 | 48 89 E5 | mov     rbp, rsp\n0x00464F08 | 48 83 EC 40 | sub     rsp, 40h\n0x00464F0C | 48 89 7D C8 | mov     [rbp+var_38], rdi\n0x00464F10 | 48 89 75 C0 | mov     [rbp+var_40], rsi\n0x00464F14 | 48 8B 4D C0 | mov     rcx, [rbp+var_40]\n0x00464F18 | 48 8B 55 C8 | mov     rdx, [rbp+var_38]\n0x00464F1C | 48 8D 45 D0 | lea     rax, [rbp+s]\n0x00464F20 | BE 8D 62 53 00 | mov     esi, offset aSS_26; \"%s/%s\"\n0x00464F25 | 48 89 C7 | mov     rdi, rax; s\n0x00464F28 | B8 00 00 00 00 | mov     eax, 0\n0x00464F2D | E8 4E 2B FA FF | call    _sprintf\n0x00464F32 | 48 8D 45 D0 | lea     rax, [rbp+s]\n0x00464F36 | 48 89 C7 | mov     rdi, rax\n0x00464F39 | E8 A1 FE FF FF | call    sub_464DDF\n0x00464F3E | 90 | nop\n0x00464F3F | C9 | leave\n0x00464F40 | C3 | retn",
        "output": "\n\nstatic void process_file(const char *filename, const char *dirname)\n{\n\tchar s[MAX_INPUT_LEN];\n\tsprintf(s, \"%s/%s\", dirname, filename);\n\tparse_and_run_string(s);\n}",
        "source_code": "static void archivejoin(const char *sub, const char *name)\n{\n\tchar path[sizeof(long long)*3 + sizeof(\"/cmdline\")];\n\tsprintf(path, \"%s/%s\", sub, name);\n\tarchivefile(path);\n}",
        "parsed_output": "\n\nstatic void process_file(const char *filename, const char *dirname)\n{\n\tchar s[MAX_INPUT_LEN];\n\tsprintf(s, \"%s/%s\", dirname, filename);\n\tparse_and_run_string(s);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_464F04(const char *a1, const char *a2)\n{\n  char s[48]; // [rsp+10h] [rbp-30h] BYREF\n\n  sprintf(s, \"%s/%s\", a1, a2);\n  return sub_464DDF(s);\n}\n",
        "baseline_code_debug": "void __cdecl archivejoin(const char *sub, const char *name)\n{\n  char path[33]; // [rsp+10h] [rbp-30h] BYREF\n\n  sprintf(path, \"%s/%s\", sub, name);\n  archivefile(path);\n}\n",
        "similarity_score_unixcoder": 0.58221036195755,
        "similarity_score_baseline_stripped": 0.42278406023979187,
        "similarity_score_baseline_debug": 0.7182942032814026
    },
    {
        "func_name": "start_new_cmd_q",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00463D34 | 55 | push    rbp\n0x00463D35 | 48 89 E5 | mov     rbp, rsp\n0x00463D38 | 53 | push    rbx\n0x00463D39 | 48 83 EC 18 | sub     rsp, 18h\n0x00463D3D | 89 7D EC | mov     [rbp+var_14], edi\n0x00463D40 | 48 8B 05 C1 96 2F 00 | mov     rax, cs:qword_75D408\n0x00463D47 | 8B 50 08 | mov     edx, [rax+8]\n0x00463D4A | 8B 45 EC | mov     eax, [rbp+var_14]\n0x00463D4D | 39 C2 | cmp     edx, eax\n0x00463D4F | 77 7C | ja      short loc_463DCD\n0x00463D51 | 48 8B 05 B0 96 2F 00 | mov     rax, cs:qword_75D408\n0x00463D58 | 8B 50 08 | mov     edx, [rax+8]\n0x00463D5B | 48 8B 05 A6 96 2F 00 | mov     rax, cs:qword_75D408\n0x00463D62 | 81 C2 00 01 00 00 | add     edx, 100h\n0x00463D68 | 89 50 08 | mov     [rax+8], edx\n0x00463D6B | 48 8B 05 96 96 2F 00 | mov     rax, cs:qword_75D408\n0x00463D72 | 8B 40 08 | mov     eax, [rax+8]\n0x00463D75 | 89 C0 | mov     eax, eax\n0x00463D77 | 48 8D 14 85 00 00 00 00 | lea     rdx, ds:0[rax*4]\n0x00463D7F | 48 8B 05 82 96 2F 00 | mov     rax, cs:qword_75D408\n0x00463D86 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x00463D8A | 48 8B 1D 77 96 2F 00 | mov     rbx, cs:qword_75D408\n0x00463D91 | 48 89 D6 | mov     rsi, rdx\n0x00463D94 | 48 89 C7 | mov     rdi, rax\n0x00463D97 | E8 02 63 FA FF | call    sub_40A09E\n0x00463D9C | 48 89 43 10 | mov     [rbx+10h], rax\n0x00463DA0 | 48 8B 05 61 96 2F 00 | mov     rax, cs:qword_75D408\n0x00463DA7 | 8B 40 08 | mov     eax, [rax+8]\n0x00463DAA | 89 C2 | mov     edx, eax\n0x00463DAC | 48 8B 05 55 96 2F 00 | mov     rax, cs:qword_75D408\n0x00463DB3 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x00463DB7 | 48 8B 1D 4A 96 2F 00 | mov     rbx, cs:qword_75D408\n0x00463DBE | 48 89 D6 | mov     rsi, rdx\n0x00463DC1 | 48 89 C7 | mov     rdi, rax\n0x00463DC4 | E8 D5 62 FA FF | call    sub_40A09E\n0x00463DC9 | 48 89 43 18 | mov     [rbx+18h], rax\n0x00463DCD | 90 | nop\n0x00463DCE | 48 83 C4 18 | add     rsp, 18h\n0x00463DD2 | 5B | pop     rbx\n0x00463DD3 | 5D | pop     rbp\n0x00463DD4 | C3 | retn\n\n Ourput decompiled code:\nstatic void ensure_buffer_capacity(int bufindex)\n{\n\tif (bufindex >= G.capacity) {\n\t\tG.capacity += 0x100;\n\t\tG.width = xrealloc(G.width, G.capacity * sizeof(G.width[0]));\n\t\tG.more = xrealloc(G.more, G.capacity * sizeof(G.more[0]));\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x0041E546 | 55 | push    rbp\n0x0041E547 | 48 89 E5 | mov     rbp, rsp\n0x0041E54A | 53 | push    rbx\n0x0041E54B | 48 83 EC 18 | sub     rsp, 18h\n0x0041E54F | 89 7D EC | mov     [rbp+var_14], edi\n0x0041E552 | 48 8B 05 AF EE 33 00 | mov     rax, cs:qword_75D408\n0x0041E559 | 8B 50 64 | mov     edx, [rax+64h]\n0x0041E55C | 83 7D EC 00 | cmp     [rbp+var_14], 0\n0x0041E560 | 7E 0C | jle     short loc_41E56E\n0x0041E562 | 48 8B 05 9F EE 33 00 | mov     rax, cs:qword_75D408\n0x0041E569 | 8B 40 60 | mov     eax, [rax+60h]\n0x0041E56C | EB 05 | jmp     short loc_41E573\n0x0041E56E | B8 01 00 00 00 | mov     eax, 1\n0x0041E573 | 39 D0 | cmp     eax, edx\n0x0041E575 | 74 77 | jz      short loc_41E5EE\n0x0041E577 | 83 7D EC 00 | cmp     [rbp+var_14], 0\n0x0041E57B | 74 11 | jz      short loc_41E58E\n0x0041E57D | 48 8B 05 84 EE 33 00 | mov     rax, cs:qword_75D408\n0x0041E584 | 8B 50 64 | mov     edx, [rax+64h]\n0x0041E587 | 8B 45 EC | mov     eax, [rbp+var_14]\n0x0041E58A | 01 C2 | add     edx, eax\n0x0041E58C | EB 05 | jmp     short loc_41E593\n0x0041E58E | BA 01 00 00 00 | mov     edx, 1\n0x0041E593 | 48 8B 05 6E EE 33 00 | mov     rax, cs:qword_75D408\n0x0041E59A | 89 50 64 | mov     [rax+64h], edx\n0x0041E59D | 48 8B 05 64 EE 33 00 | mov     rax, cs:qword_75D408\n0x0041E5A4 | 48 8B 40 68 | mov     rax, [rax+68h]\n0x0041E5A8 | 48 89 C7 | mov     rdi, rax; ptr\n0x0041E5AB | E8 B0 80 FE FF | call    _free\n0x0041E5B0 | 48 8B 05 51 EE 33 00 | mov     rax, cs:qword_75D408\n0x0041E5B7 | 48 8B 50 70 | mov     rdx, [rax+70h]\n0x0041E5BB | 48 8B 05 46 EE 33 00 | mov     rax, cs:qword_75D408\n0x0041E5C2 | 8B 40 64 | mov     eax, [rax+64h]\n0x0041E5C5 | 83 E8 01 | sub     eax, 1\n0x0041E5C8 | 89 C0 | mov     eax, eax\n0x0041E5CA | 48 C1 E0 03 | shl     rax, 3\n0x0041E5CE | 48 01 D0 | add     rax, rdx\n0x0041E5D1 | 48 8B 00 | mov     rax, [rax]\n0x0041E5D4 | 48 8B 1D 2D EE 33 00 | mov     rbx, cs:qword_75D408\n0x0041E5DB | 48 89 C7 | mov     rdi, rax\n0x0041E5DE | E8 3C BB FE FF | call    sub_40A11F\n0x0041E5E3 | 48 89 43 68 | mov     [rbx+68h], rax\n0x0041E5E7 | E8 6B FA FF FF | call    sub_41E057\n0x0041E5EC | EB 1A | jmp     short loc_41E608\n0x0041E5EE | 83 7D EC 00 | cmp     [rbp+var_14], 0\n0x0041E5F2 | 7E 07 | jle     short loc_41E5FB\n0x0041E5F4 | B8 B3 91 52 00 | mov     eax, offset aNoNextFile; \"No next file\"\n0x0041E5F9 | EB 05 | jmp     short loc_41E600\n0x0041E5FB | B8 C0 91 52 00 | mov     eax, offset aNoPreviousFile; \"No previous file\"\n0x0041E600 | 48 89 C7 | mov     rdi, rax\n0x0041E603 | E8 07 E5 FF FF | call    sub_41CB0F\n0x0041E608 | 90 | nop\n0x0041E609 | 48 83 C4 18 | add     rsp, 18h\n0x0041E60D | 5B | pop     rbx\n0x0041E60E | 5D | pop     rbp\n0x0041E60F | C3 | retn\n\n Ourput decompiled code:\nstatic void change_file(int direction)\n{\n\tif (current_file != ((direction > 0) ? num_files : 1)) {\n\t\tcurrent_file = direction ? current_file + direction : 1;\n\t\tfree(filename);\n\t\tfilename = xstrdup(files[current_file - 1]);\n\t\treinitialize();\n\t} else {\n\t\tprint_statusline(direction > 0 ? \"No next file\" : \"No previous file\");\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x00463DD5 | 55 | push    rbp\n0x00463DD6 | 48 89 E5 | mov     rbp, rsp\n0x00463DD9 | 48 83 EC 10 | sub     rsp, 10h\n0x00463DDD | 89 F8 | mov     eax, edi\n0x00463DDF | 88 45 FC | mov     [rbp+var_4], al\n0x00463DE2 | 48 8B 05 1F 96 2F 00 | mov     rax, cs:qword_75D408\n0x00463DE9 | 8B 10 | mov     edx, [rax]\n0x00463DEB | 83 C2 01 | add     edx, 1\n0x00463DEE | 89 10 | mov     [rax], edx\n0x00463DF0 | 48 8B 05 11 96 2F 00 | mov     rax, cs:qword_75D408\n0x00463DF7 | 8B 10 | mov     edx, [rax]\n0x00463DF9 | 48 8B 05 08 96 2F 00 | mov     rax, cs:qword_75D408\n0x00463E00 | 8B 40 04 | mov     eax, [rax+4]\n0x00463E03 | 39 C2 | cmp     edx, eax\n0x00463E05 | 77 28 | ja      short loc_463E2F\n0x00463E07 | 48 8B 05 FA 95 2F 00 | mov     rax, cs:qword_75D408\n0x00463E0E | 8B 10 | mov     edx, [rax]\n0x00463E10 | 48 8B 05 F1 95 2F 00 | mov     rax, cs:qword_75D408\n0x00463E17 | 8B 40 04 | mov     eax, [rax+4]\n0x00463E1A | 39 C2 | cmp     edx, eax\n0x00463E1C | 75 04 | jnz     short loc_463E22\n0x00463E1E | C6 45 FC 2B | mov     [rbp+var_4], 2Bh ; '+'\n0x00463E22 | 0F BE 45 FC | movsx   eax, [rbp+var_4]\n0x00463E26 | 89 C7 | mov     edi, eax; c\n0x00463E28 | E8 C3 33 FA FF | call    _putchar_unlocked\n0x00463E2D | EB 01 | jmp     short locret_463E30\n0x00463E2F | 90 | nop\n0x00463E30 | C9 | leave\n0x00463E31 | C3 | retn\n\n Ourput decompiled code:\nstatic void out_char(char c)\n{\n\tG.cur_x++;\n\tif (G.cur_x > G.output_width)\n\t\treturn;\n\tif (G.cur_x == G.output_width)\n\t\tc = '+';\n\tputchar(c);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004EEE0F | 55 | push    rbp\n0x004EEE10 | 48 89 E5 | mov     rbp, rsp\n0x004EEE13 | 53 | push    rbx\n0x004EEE14 | 48 83 EC 18 | sub     rsp, 18h\n0x004EEE18 | 89 F8 | mov     eax, edi\n0x004EEE1A | 88 45 EC | mov     [rbp+var_14], al\n0x004EEE1D | 48 8B 05 E4 E5 26 00 | mov     rax, cs:qword_75D408\n0x004EEE24 | 8B 40 2C | mov     eax, [rax+2Ch]\n0x004EEE27 | 85 C0 | test    eax, eax\n0x004EEE29 | 7E 3B | jle     short loc_4EEE66\n0x004EEE2B | 0F BE 55 EC | movsx   edx, [rbp+var_14]\n0x004EEE2F | 48 8B 05 D2 E5 26 00 | mov     rax, cs:qword_75D408\n0x004EEE36 | 8B 40 2C | mov     eax, [rax+2Ch]\n0x004EEE39 | 48 8B 0D C8 E5 26 00 | mov     rcx, cs:qword_75D408\n0x004EEE40 | 48 8D B9 B8 04 00 00 | lea     rdi, [rcx+4B8h]; s\n0x004EEE47 | 48 8B 1D BA E5 26 00 | mov     rbx, cs:qword_75D408\n0x004EEE4E | 89 D1 | mov     ecx, edx\n0x004EEE50 | 89 C2 | mov     edx, eax\n0x004EEE52 | BE 7C 76 52 00 | mov     esi, offset aDC; \"%d%c\"\n0x004EEE57 | B8 00 00 00 00 | mov     eax, 0\n0x004EEE5C | E8 1F 8C F1 FF | call    _sprintf\n0x004EEE61 | 89 43 78 | mov     [rbx+78h], eax\n0x004EEE64 | EB 1F | jmp     short loc_4EEE85\n0x004EEE66 | 48 8B 05 9B E5 26 00 | mov     rax, cs:qword_75D408\n0x004EEE6D | 0F B6 55 EC | movzx   edx, [rbp+var_14]\n0x004EEE71 | 88 90 B8 04 00 00 | mov     [rax+4B8h], dl\n0x004EEE77 | 48 8B 05 8A E5 26 00 | mov     rax, cs:qword_75D408\n0x004EEE7E | C7 40 78 01 00 00 00 | mov     dword ptr [rax+78h], 1\n0x004EEE85 | 48 8B 05 7C E5 26 00 | mov     rax, cs:qword_75D408\n0x004EEE8C | C6 40 76 01 | mov     byte ptr [rax+76h], 1\n0x004EEE90 | 90 | nop\n0x004EEE91 | 48 83 C4 18 | add     rsp, 18h\n0x004EEE95 | 5B | pop     rbx\n0x004EEE96 | 5D | pop     rbp\n0x004EEE97 | C3 | retn",
        "output": "",
        "source_code": "if ENABLE_FEATURE_VI_DOT_CMD\nstatic void start_new_cmd_q(char c)\n{\n\t// get buffer for new cmd\n\t// if there is a current cmd count put it in the buffer first\n\tif (cmdcnt > 0) {\n\t\tlmc_len = sprintf(last_modifying_cmd, \"%d%c\", cmdcnt, c);\n\t} else { // just save char c onto queue\n\t\tlast_modifying_cmd[0] = c;\n\t\tlmc_len = 1;\n\t}\n\tadding2q = 1;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "void *__fastcall sub_4EEE0F(char a1)\n{\n  _DWORD *v1; // rbx\n  void *result; // rax\n\n  if ( *((int *)qword_75D408 + 11) <= 0 )\n  {\n    *((_BYTE *)qword_75D408 + 1208) = a1;\n    *((_DWORD *)qword_75D408 + 30) = 1;\n  }\n  else\n  {\n    v1 = qword_75D408;\n    v1[30] = sprintf((char *)qword_75D408 + 1208, \"%d%c\", *((unsigned int *)qword_75D408 + 11), (unsigned int)a1);\n  }\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 118) = 1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl start_new_cmd_q(char c)\n{\n  globals *v1; // rbx\n\n  if ( SHIDWORD(ptr_to_globals->issue) <= 0 )\n  {\n    LOBYTE(ptr_to_globals[4].speeds[1]) = c;\n    *(_DWORD *)&ptr_to_globals->tty_attrs.c_cc[7] = 1;\n  }\n  else\n  {\n    v1 = ptr_to_globals;\n    *(_DWORD *)&v1->tty_attrs.c_cc[7] = sprintf(\n                                          (char *)&ptr_to_globals[4].speeds[1],\n                                          \"%d%c\",\n                                          HIDWORD(ptr_to_globals->issue),\n                                          (unsigned int)c);\n  }\n  ptr_to_globals->tty_attrs.c_cc[5] = 1;\n}\n",
        "similarity_score_unixcoder": 0.029295802116394043,
        "similarity_score_baseline_stripped": 0.5308853387832642,
        "similarity_score_baseline_debug": 0.6258626580238342
    },
    {
        "func_name": "reset_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00421726 | 55 | push    rbp\n0x00421727 | 48 89 E5 | mov     rbp, rsp\n0x0042172A | 48 83 EC 10 | sub     rsp, 10h\n0x0042172E | 89 7D FC | mov     [rbp+var_4], edi\n0x00421731 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x00421735 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00421739 | 48 89 C7 | mov     rdi, rax\n0x0042173C | E8 B8 6E 0E 00 | call    sub_5085F9\n0x00421741 | BE 00 00 00 00 | mov     esi, 0\n0x00421746 | 48 89 C7 | mov     rdi, rax\n0x00421749 | E8 47 8B FE FF | call    sub_40A295\n0x0042174E | B9 9A 56 53 00 | mov     ecx, offset aRaidAutorun; \"RAID_AUTORUN\"\n0x00421753 | BA 00 00 00 00 | mov     edx, 0\n0x00421758 | BE 14 09 00 00 | mov     esi, 914h\n0x0042175D | 89 C7 | mov     edi, eax\n0x0042175F | E8 ED 95 FE FF | call    sub_40AD51\n0x00421764 | B8 00 00 00 00 | mov     eax, 0\n0x00421769 | C9 | leave\n0x0042176A | C3 | retn\n\n Ourput decompiled code:\nint raidautorun_main(int argc UNUSED_PARAM, char **argv)\n{\n\txioctl(xopen(single_argv(argv), O_RDONLY), RAID_AUTORUN, NULL);\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input assembly code:\n0x0040A52C | 55 | push    rbp\n0x0040A52D | 48 89 E5 | mov     rbp, rsp\n0x0040A530 | 48 83 EC 10 | sub     rsp, 10h\n0x0040A534 | 89 7D FC | mov     [rbp+fd], edi\n0x0040A537 | 8B 45 FC | mov     eax, [rbp+fd]\n0x0040A53A | 89 C7 | mov     edi, eax; fd\n0x0040A53C | E8 CF C8 FF FF | call    _close\n0x0040A541 | 85 C0 | test    eax, eax\n0x0040A543 | 74 0F | jz      short loc_40A554\n0x0040A545 | BF 8C 80 52 00 | mov     edi, offset aCloseFailed; \"close failed\"\n0x0040A54A | B8 00 00 00 00 | mov     eax, 0\n0x0040A54F | E8 4E ED FF FF | call    sub_4092A2\n0x0040A554 | 90 | nop\n0x0040A555 | C9 | leave\n0x0040A556 | C3 | retn\n\n Ourput decompiled code:\nvoid FAST_FUNC xclose(int fd)\n{\n\tif (close(fd))\n\t\tbb_perror_msg_and_die(\"close failed\");\n}\n\n## Example:\n\n Input assembly code:\n0x0040A851 | 55 | push    rbp\n0x0040A852 | 48 89 E5 | mov     rbp, rsp\n0x0040A855 | 48 83 EC 10 | sub     rsp, 10h\n0x0040A859 | 89 7D FC | mov     [rbp+gid], edi\n0x0040A85C | 8B 45 FC | mov     eax, [rbp+gid]\n0x0040A85F | 89 C7 | mov     edi, eax; gid\n0x0040A861 | E8 0A CF FF FF | call    _setgid\n0x0040A866 | 85 C0 | test    eax, eax\n0x0040A868 | 74 0F | jz      short loc_40A879\n0x0040A86A | BF D4 80 52 00 | mov     edi, offset aSetgid_0; \"setgid\"\n0x0040A86F | B8 00 00 00 00 | mov     eax, 0\n0x0040A874 | E8 29 EA FF FF | call    sub_4092A2\n0x0040A879 | 90 | nop\n0x0040A87A | C9 | leave\n0x0040A87B | C3 | retn\n\n Ourput decompiled code:\nvoid FAST_FUNC xsetgid(gid_t gid)\n{\n\tif (setgid(gid)) bb_perror_msg_and_die(\"setgid\");\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C464E | 55 | push    rbp\n0x004C464F | 48 89 E5 | mov     rbp, rsp\n0x004C4652 | 48 83 EC 10 | sub     rsp, 10h\n0x004C4656 | 89 7D FC | mov     [rbp+var_4], edi\n0x004C4659 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004C465D | BF 01 00 00 00 | mov     edi, 1; fd\n0x004C4662 | E8 F9 21 F4 FF | call    _isatty\n0x004C4667 | 85 C0 | test    eax, eax\n0x004C4669 | 74 20 | jz      short loc_4C468B\n0x004C466B | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C4670 | B8 00 00 00 00 | mov     eax, 0\n0x004C4675 | E8 56 25 F4 FF | call    _printf\n0x004C467A | BE 50 6D 52 00 | mov     esi, offset off_526D50; \"stty\"\n0x004C467F | BF 02 00 00 00 | mov     edi, 2\n0x004C4684 | E8 7D FE 00 00 | call    sub_4D4506\n0x004C4689 | EB 05 | jmp     short locret_4C4690\n0x004C468B | B8 00 00 00 00 | mov     eax, 0\n0x004C4690 | C9 | leave\n0x004C4691 | C3 | retn",
        "output": "\n0x004C4692 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C4697 | E8 56 25 F4 FF | call    _printf\n0x004C469C | EB 05 | jmp     short loc_4C46A3\n0x004C469E | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46A3 | E8 56 25 F4 FF | call    _printf\n0x004C46A8 | EB 05 | jmp     short loc_4C46AF\n0x004C46AA | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46AF | E8 56 25 F4 FF | call    _printf\n0x004C46B4 | EB 05 | jmp     short loc_4C46BA\n0x004C46B6 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46BB | E8 56 25 F4 FF | call    _printf\n0x004C46C0 | EB 05 | jmp     short loc_4C46C7\n0x004C46C2 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46C7 | E8 56 25 F4 FF | call    _printf\n0x004C46CC | EB 05 | jmp     short loc_4C46D3\n0x004C46CD | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46D2 | E8 56 25 F4 FF | call    _printf\n0x004C46D7 | EB 05 | jmp     short loc_4C46DE\n0x004C46D9 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46DE | E8 56 25 F4 FF | call    _printf\n0x004C46E3 | EB 05 | jmp     short loc_4C46EA\n0x004C46E5 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46EA | E8 56 25 F4 FF | call    _printf\n0x004C46EF | EB 05 | jmp     short loc_4C46F6\n0x004C46F1 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46F6 | E8 56 25 F4 FF | call    _printf\n0x004C46FB | EB 05 | jmp     short loc_4C4702\n0x004C46FD | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C4702 | E8 56 25 F4 FF | call    _printf\n0x004C4707 | EB 05 | jmp     short loc_4C470E\n0x004C4709 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C470E | E8 56 25 F4 FF | call    _printf\n0x004C4713 | EB 05 | jmp     short loc_4C471A\n0x004C4715 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C471A | E8 56 25 F4 FF | call    _printf\n0x004C471F | EB 05 | jmp     short loc_4C4726\n0x004C4721 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C4726 | E8 56 25 F4 FF | call    _printf\n0x004C472B | EB 05 | jmp     short loc_4C4732\n0x004C472D | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C4732 | E8 56 25 F4 FF | call    _printf\n0x004C4737 | EB 05 | jmp     short loc_4C473E\n0x004C4739 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C473E | E8 56 25 F4 FF | call    _printf\n0x004C4743 | EB 05 | jmp     short loc_4C474A\n0x004C4745 | BF 30 6D 52 00 | mov     edi, offset a",
        "source_code": "int reset_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tstatic const char *const args[] = {\n\t\t\"stty\", \"sane\", NULL\n\t};\n\n\t/* no options, no getopt */\n\n\tif (/*isatty(STDIN_FILENO) &&*/ isatty(STDOUT_FILENO)) {\n\t\t/* See 'man 4 console_codes' for details:\n\t\t * \"ESC c\"        -- Reset\n\t\t * \"ESC ( B\"      -- Select G0 Character Set (B = US)\n\t\t * \"ESC [ 0 m\"    -- Reset all display attributes\n\t\t * \"ESC [ J\"      -- Erase to the end of screen\n\t\t * \"ESC [ ? 25 h\" -- Make cursor visible\n\t\t */\n\t\tprintf(ESC\"c\" ESC\"(B\" ESC\"[0m\" ESC\"[J\" ESC\"[?25h\");\n\t\t/* http://bugs.busybox.net/view.php?id=1414:\n\t\t * people want it to reset echo etc: */\n#if ENABLE_STTY\n\t\treturn stty_main(2, (char**)args);\n#else\n\t\texecvp(\"stty\", (char**)args);\n#endif\n\t}\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "\n0x004C4692 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C4697 | E8 56 25 F4 FF | call    _printf\n0x004C469C | EB 05 | jmp     short loc_4C46A3\n0x004C469E | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46A3 | E8 56 25 F4 FF | call    _printf\n0x004C46A8 | EB 05 | jmp     short loc_4C46AF\n0x004C46AA | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46AF | E8 56 25 F4 FF | call    _printf\n0x004C46B4 | EB 05 | jmp     short loc_4C46BA\n0x004C46B6 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46BB | E8 56 25 F4 FF | call    _printf\n0x004C46C0 | EB 05 | jmp     short loc_4C46C7\n0x004C46C2 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46C7 | E8 56 25 F4 FF | call    _printf\n0x004C46CC | EB 05 | jmp     short loc_4C46D3\n0x004C46CD | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46D2 | E8 56 25 F4 FF | call    _printf\n0x004C46D7 | EB 05 | jmp     short loc_4C46DE\n0x004C46D9 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46DE | E8 56 25 F4 FF | call    _printf\n0x004C46E3 | EB 05 | jmp     short loc_4C46EA\n0x004C46E5 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46EA | E8 56 25 F4 FF | call    _printf\n0x004C46EF | EB 05 | jmp     short loc_4C46F6\n0x004C46F1 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C46F6 | E8 56 25 F4 FF | call    _printf\n0x004C46FB | EB 05 | jmp     short loc_4C4702\n0x004C46FD | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C4702 | E8 56 25 F4 FF | call    _printf\n0x004C4707 | EB 05 | jmp     short loc_4C470E\n0x004C4709 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C470E | E8 56 25 F4 FF | call    _printf\n0x004C4713 | EB 05 | jmp     short loc_4C471A\n0x004C4715 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C471A | E8 56 25 F4 FF | call    _printf\n0x004C471F | EB 05 | jmp     short loc_4C4726\n0x004C4721 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C4726 | E8 56 25 F4 FF | call    _printf\n0x004C472B | EB 05 | jmp     short loc_4C4732\n0x004C472D | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C4732 | E8 56 25 F4 FF | call    _printf\n0x004C4737 | EB 05 | jmp     short loc_4C473E\n0x004C4739 | BF 30 6D 52 00 | mov     edi, offset aCB0mJ25h; \"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\"\n0x004C473E | E8 56 25 F4 FF | call    _printf\n0x004C4743 | EB 05 | jmp     short loc_4C474A\n0x004C4745 | BF 30 6D 52 00 | mov     edi, offset a",
        "baseline_code_stripped": "__int64 sub_4C464E()\n{\n  if ( !isatty(1) )\n    return 0LL;\n  printf(\"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\");\n  return sub_4D4506(2LL, off_526D50);\n}\n",
        "baseline_code_debug": "int __cdecl reset_main(int argc, char **argv)\n{\n  if ( !isatty(1) )\n    return 0;\n  printf(\"\\x1Bc\\x1B(B\\x1B[0m\\x1B[J\\x1B[?25h\");\n  return stty_main(2, (char **)args_8111);\n}\n",
        "similarity_score_unixcoder": 0.37882909178733826,
        "similarity_score_baseline_stripped": 0.5364027619361877,
        "similarity_score_baseline_debug": 0.7071895003318787
    },
    {
        "func_name": "sendping6",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0043E2ED | 55 | push    rbp\n0x0043E2EE | 48 89 E5 | mov     rbp, rsp\n0x0043E2F1 | 48 83 EC 20 | sub     rsp, 20h\n0x0043E2F5 | 89 7D EC | mov     [rbp+var_14], edi\n0x0043E2F8 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E2FD | 48 8B 40 70 | mov     rax, [rax+70h]\n0x0043E301 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0043E305 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E309 | C6 00 08 | mov     byte ptr [rax], 8\n0x0043E30C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E310 | 66 C7 40 02 00 00 | mov     word ptr [rax+2], 0\n0x0043E316 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E31B | 48 8B 40 28 | mov     rax, [rax+28h]\n0x0043E31F | 0F B7 C0 | movzx   eax, ax\n0x0043E322 | 89 C7 | mov     edi, eax; hostshort\n0x0043E324 | E8 47 88 FC FF | call    _htons\n0x0043E329 | 89 C2 | mov     edx, eax\n0x0043E32B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E32F | 66 89 50 06 | mov     [rax+6], dx\n0x0043E333 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E338 | 0F B7 50 40 | movzx   edx, word ptr [rax+40h]\n0x0043E33C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E340 | 66 89 50 04 | mov     [rax+4], dx\n0x0043E344 | E8 1E D9 FC FF | call    sub_40BC67\n0x0043E349 | 48 89 C2 | mov     rdx, rax\n0x0043E34C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E350 | 48 83 C0 08 | add     rax, 8\n0x0043E354 | 89 10 | mov     [rax], edx\n0x0043E356 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E35B | 8B 40 18 | mov     eax, [rax+18h]\n0x0043E35E | 83 C0 08 | add     eax, 8\n0x0043E361 | 89 C2 | mov     edx, eax\n0x0043E363 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E367 | 89 D6 | mov     esi, edx\n0x0043E369 | 48 89 C7 | mov     rdi, rax\n0x0043E36C | E8 DE F1 0B 00 | call    sub_4FD54F\n0x0043E371 | 89 C2 | mov     edx, eax\n0x0043E373 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E377 | 66 89 50 02 | mov     [rax+2], dx\n0x0043E37B | BE 08 00 00 00 | mov     esi, 8\n0x0043E380 | BF ED E2 43 00 | mov     edi, offset sub_43E2ED\n0x0043E385 | E8 AA FD FF FF | call    sub_43E134\n0x0043E38A | 90 | nop\n0x0043E38B | C9 | leave\n0x0043E38C | C3 | retn\n\n Ourput decompiled code:\nstatic void sendping4(int junk UNUSED_PARAM)\n{\n\tstruct icmp *pkt = G.snd_packet;\n\n\t//memset(pkt, 0, datalen + ICMP_MINLEN + 4); - G.snd_packet was xzalloced\n\tpkt->icmp_type = ICMP_ECHO;\n\t/*pkt->icmp_code = 0;*/\n\tpkt->icmp_cksum = 0; /* cksum is calculated with this field set to 0 */\n\tpkt->icmp_seq = htons(ntransmitted); /* don't ++ here, it can be a macro */\n\tpkt->icmp_id = myid;\n\n\t/* If datalen < 4, we store timestamp _past_ the packet,\n\t * but it's ok - we allocated 4 extra bytes in xzalloc() just in case.\n\t */\n\t/*if (datalen >= 4)*/\n\t\t/* No hton: we'll read it back on the same machine */\n\t\t*(uint32_t*)&pkt->icmp_dun = monotonic_us();\n\n\tpkt->icmp_cksum = inet_cksum((uint16_t *) pkt, datalen + ICMP_MINLEN);\n\n\tsendping_tail(sendping4, ICMP_MINLEN);\n}\n\n## Example:\n\n Input assembly code:\n0x0043542A | 55 | push    rbp\n0x0043542B | 48 89 E5 | mov     rbp, rsp\n0x0043542E | 48 83 EC 20 | sub     rsp, 20h\n0x00435432 | 89 7D EC | mov     [rbp+var_14], edi\n0x00435435 | 48 8B 05 C4 7F 32 00 | mov     rax, cs:qword_75D400\n0x0043543C | 8B 00 | mov     eax, [rax]\n0x0043543E | 89 45 F4 | mov     [rbp+var_C], eax\n0x00435441 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00435446 | C6 40 30 00 | mov     byte ptr [rax+30h], 0\n0x0043544A | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043544F | 48 8B 40 18 | mov     rax, [rax+18h]\n0x00435453 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00435457 | EB 45 | jmp     short loc_43549E\n0x00435459 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043545D | 8B 00 | mov     eax, [rax]\n0x0043545F | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x00435462 | 75 2E | jnz     short loc_435492\n0x00435464 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00435468 | 48 89 C7 | mov     rdi, rax\n0x0043546B | E8 5C EB FF FF | call    sub_433FCC\n0x00435470 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00435474 | 8B 00 | mov     eax, [rax]\n0x00435476 | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x00435479 | 74 17 | jz      short loc_435492\n0x0043547B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043547F | 8B 40 24 | mov     eax, [rax+24h]\n0x00435482 | 85 C0 | test    eax, eax\n0x00435484 | 74 0C | jz      short loc_435492\n0x00435486 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043548A | 48 89 C7 | mov     rdi, rax\n0x0043548D | E8 60 E7 FF FF | call    sub_433BF2\n0x00435492 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00435496 | 48 8B 40 58 | mov     rax, [rax+58h]\n0x0043549A | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0043549E | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004354A3 | 75 B4 | jnz     short loc_435459\n0x004354A5 | 48 8B 05 54 7F 32 00 | mov     rax, cs:qword_75D400\n0x004354AC | 8B 55 F4 | mov     edx, [rbp+var_C]\n0x004354AF | 89 10 | mov     [rax], edx\n0x004354B1 | 90 | nop\n0x004354B2 | C9 | leave\n0x004354B3 | C3 | retn\n\n Ourput decompiled code:\nstatic void retry_network_setup(int sig UNUSED_PARAM)\n{\n\tint save_errno = errno;\n\tservtab_t *sep;\n\n\talarm_armed = 0;\n\tfor (sep = serv_list; sep; sep = sep->se_next) {\n\t\tif (sep->se_fd == -1) {\n\t\t\tprepare_socket_fd(sep);\n#if ENABLE_FEATURE_INETD_RPC\n\t\t\tif (sep->se_fd != -1 && is_rpc_service(sep))\n\t\t\t\tregister_rpc(sep);\n#endif\n\t\t}\n\t}\n\terrno = save_errno;\n}\n\n## Example:\n\n Input assembly code:\n0x00456C5B | 55 | push    rbp\n0x00456C5C | 48 89 E5 | mov     rbp, rsp\n0x00456C5F | 48 83 EC 20 | sub     rsp, 20h\n0x00456C63 | 89 7D EC | mov     [rbp+var_14], edi\n0x00456C66 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00456C6B | 48 8B 40 20 | mov     rax, [rax+20h]\n0x00456C6F | 48 89 45 F8 | mov     [rbp+ptr], rax\n0x00456C73 | 48 C7 45 F0 F8 B3 75 00 | mov     [rbp+var_10], offset dest\n0x00456C7B | EB 4A | jmp     short loc_456CC7\n0x00456C7D | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00456C81 | 8B 40 08 | mov     eax, [rax+8]\n0x00456C84 | 39 45 EC | cmp     [rbp+var_14], eax\n0x00456C87 | 75 2A | jnz     short loc_456CB3\n0x00456C89 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00456C8D | 48 8B 50 20 | mov     rdx, [rax+20h]\n0x00456C91 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00456C95 | 48 89 50 20 | mov     [rax+20h], rdx\n0x00456C99 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00456C9D | 48 89 C7 | mov     rdi, rax; ptr\n0x00456CA0 | E8 BB F9 FA FF | call    _free\n0x00456CA5 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00456CA9 | 48 8B 40 20 | mov     rax, [rax+20h]\n0x00456CAD | 48 89 45 F8 | mov     [rbp+ptr], rax\n0x00456CB1 | EB 14 | jmp     short loc_456CC7\n0x00456CB3 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00456CB7 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x00456CBB | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00456CBF | 48 8B 40 20 | mov     rax, [rax+20h]\n0x00456CC3 | 48 89 45 F8 | mov     [rbp+ptr], rax\n0x00456CC7 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0\n0x00456CCC | 75 AF | jnz     short loc_456C7D\n0x00456CCE | 90 | nop\n0x00456CCF | C9 | leave\n0x00456CD0 | C3 | retn\n\n Ourput decompiled code:\nstatic void xid_del(uint32_t xid)\n{\n\tstruct xid_item *item = dhcprelay_xid_list.next;\n\tstruct xid_item *last = &dhcprelay_xid_list;\n\twhile (item != NULL) {\n\t\tif (item->xid == xid) {\n\t\t\tlast->next = item->next;\n\t\t\tfree(item);\n\t\t\titem = last->next;\n\t\t} else {\n\t\t\tlast = item;\n\t\t\titem = item->next;\n\t\t}\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043E38D | 55 | push    rbp\n0x0043E38E | 48 89 E5 | mov     rbp, rsp\n0x0043E391 | 48 83 EC 20 | sub     rsp, 20h\n0x0043E395 | 89 7D EC | mov     [rbp+var_14], edi\n0x0043E398 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E39D | 48 8B 40 70 | mov     rax, [rax+70h]\n0x0043E3A1 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0043E3A5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E3A9 | C6 00 80 | mov     byte ptr [rax], 80h\n0x0043E3AC | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E3B1 | 48 8B 40 28 | mov     rax, [rax+28h]\n0x0043E3B5 | 0F B7 C0 | movzx   eax, ax\n0x0043E3B8 | 89 C7 | mov     edi, eax; hostshort\n0x0043E3BA | E8 B1 87 FC FF | call    _htons\n0x0043E3BF | 89 C2 | mov     edx, eax\n0x0043E3C1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E3C5 | 66 89 50 06 | mov     [rax+6], dx\n0x0043E3C9 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0043E3CE | 0F B7 50 40 | movzx   edx, word ptr [rax+40h]\n0x0043E3D2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E3D6 | 66 89 50 04 | mov     [rax+4], dx\n0x0043E3DA | E8 88 D8 FC FF | call    sub_40BC67\n0x0043E3DF | 48 89 C2 | mov     rdx, rax\n0x0043E3E2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043E3E6 | 48 83 C0 08 | add     rax, 8\n0x0043E3EA | 89 10 | mov     [rax], edx\n0x0043E3EC | BE 08 00 00 00 | mov     esi, 8\n0x0043E3F1 | BF 8D E3 43 00 | mov     edi, offset sub_43E38D\n0x0043E3F6 | E8 39 FD FF FF | call    sub_43E134\n0x0043E3FB | 90 | nop\n0x0043E3FC | C9 | leave\n0x0043E3FD | C3 | retn",
        "output": "",
        "source_code": "if ENABLE_PING6\nstatic void sendping6(int junk UNUSED_PARAM)\n{\n\tstruct icmp6_hdr *pkt = G.snd_packet;\n\n\t//memset(pkt, 0, datalen + sizeof(struct icmp6_hdr) + 4);\n\tpkt->icmp6_type = ICMP6_ECHO_REQUEST;\n\t/*pkt->icmp6_code = 0;*/\n\t/*pkt->icmp6_cksum = 0;*/\n\tpkt->icmp6_seq = htons(ntransmitted); /* don't ++ here, it can be a macro */\n\tpkt->icmp6_id = myid;\n\n\t/*if (datalen >= 4)*/\n\t\t*(uint32_t*)(&pkt->icmp6_data8[4]) = monotonic_us();\n\n\t//TODO? pkt->icmp_cksum = inet_cksum(...);\n\n\tsendping_tail(sendping6, sizeof(struct icmp6_hdr));\n}",
        "parsed_output": "",
        "baseline_code_stripped": "unsigned int sub_43E38D()\n{\n  __int64 v1; // [rsp+18h] [rbp-8h]\n\n  v1 = *((_QWORD *)&dest + 14);\n  *(_BYTE *)v1 = 0x80;\n  *(_WORD *)(v1 + 6) = htons(*(_QWORD *)&dest.c_cc[23]);\n  *(_WORD *)(v1 + 4) = *((_WORD *)&dest + 32);\n  *(_DWORD *)(v1 + 8) = sub_40BC67();\n  return sub_43E134((void (*)(int))sub_43E38D, 8);\n}\n",
        "baseline_code_debug": "void __cdecl sendping6(int junk)\n{\n  icmp6_hdr *pkt; // [rsp+18h] [rbp-8h]\n\n  pkt = (icmp6_hdr *)*((_QWORD *)&bb_common_bufsiz1 + 14);\n  pkt->icmp6_type = 0x80;\n  pkt->icmp6_dataun.icmp6_un_data16[1] = htons(*(_QWORD *)&bb_common_bufsiz1.c_cc[23]);\n  pkt->icmp6_dataun.icmp6_un_data16[0] = *((_WORD *)&bb_common_bufsiz1 + 32);\n  *(_DWORD *)&pkt[1].icmp6_type = monotonic_us();\n  sendping_tail((void (*)(int))sendping6, 8);\n}\n",
        "similarity_score_unixcoder": 0.11297260224819183,
        "similarity_score_baseline_stripped": 0.5067846179008484,
        "similarity_score_baseline_debug": 0.8522728681564331
    },
    {
        "func_name": "overflow_safe_sub",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0045BF70 | 55 | push    rbp\n0x0045BF71 | 48 89 E5 | mov     rbp, rsp\n0x0045BF74 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0045BF78 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x0045BF7C | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0045BF80 | 48 2B 45 E8 | sub     rax, [rbp+var_18]\n0x0045BF84 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0045BF88 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0045BF8D | 74 06 | jz      short loc_45BF95\n0x0045BF8F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045BF93 | EB 05 | jmp     short loc_45BF9A\n0x0045BF95 | B8 01 00 00 00 | mov     eax, 1\n0x0045BF9A | 5D | pop     rbp\n0x0045BF9B | C3 | retn\n\n Ourput decompiled code:\nstatic ALWAYS_INLINE cputime_t get_interval(cputime_t old, cputime_t new)\n{\n\tcputime_t itv = new - old;\n\n\treturn (itv == 0) ? 1 : itv;\n}\n\n## Example:\n\n Input assembly code:\n0x0045D449 | 55 | push    rbp\n0x0045D44A | 48 89 E5 | mov     rbp, rsp\n0x0045D44D | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0045D451 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x0045D455 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0045D459 | 48 2B 45 E8 | sub     rax, [rbp+var_18]\n0x0045D45D | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0045D461 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0045D466 | 74 06 | jz      short loc_45D46E\n0x0045D468 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045D46C | EB 05 | jmp     short loc_45D473\n0x0045D46E | B8 01 00 00 00 | mov     eax, 1\n0x0045D473 | 5D | pop     rbp\n0x0045D474 | C3 | retn\n\n Ourput decompiled code:\nstatic ALWAYS_INLINE data_t jiffies_diff(data_t old, data_t new)\n{\n\tdata_t diff = new - old;\n\treturn (diff == 0) ? 1 : diff;\n}\n\n## Example:\n\n Input assembly code:\n0x00473C97 | 55 | push    rbp\n0x00473C98 | 48 89 E5 | mov     rbp, rsp\n0x00473C9B | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00473C9F | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00473CA3 | 48 C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0\n0x00473CAB | EB 05 | jmp     short loc_473CB2\n0x00473CAD | 48 83 45 F8 01 | add     [rbp+var_8], 1\n0x00473CB2 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00473CB6 | 48 3B 45 E8 | cmp     rax, [rbp+var_18]\n0x00473CBA | 76 10 | jbe     short loc_473CCC\n0x00473CBC | 48 83 6D E0 01 | sub     [rbp+var_20], 1\n0x00473CC1 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00473CC5 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00473CC8 | 3C 81 | cmp     al, 81h\n0x00473CCA | 74 E1 | jz      short loc_473CAD\n0x00473CCC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00473CD0 | 5D | pop     rbp\n0x00473CD1 | C3 | retn\n\n Ourput decompiled code:\nstatic size_t\nesclen(const char *start, const char *p)\n{\n\tsize_t esc = 0;\n\n\twhile (p > start && (unsigned char)*--p == CTLESC) {\n\t\tesc++;\n\t}\n\treturn esc;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0045BF9C | 55 | push    rbp\n0x0045BF9D | 48 89 E5 | mov     rbp, rsp\n0x0045BFA0 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0045BFA4 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x0045BFA8 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0045BFAC | 48 2B 45 E8 | sub     rax, [rbp+var_18]\n0x0045BFB0 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0045BFB4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045BFB8 | 48 85 C0 | test    rax, rax\n0x0045BFBB | 79 19 | jns     short loc_45BFD6\n0x0045BFBD | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x0045BFC2 | 48 39 45 E8 | cmp     [rbp+var_18], rax\n0x0045BFC6 | 77 0E | ja      short loc_45BFD6\n0x0045BFC8 | 48 B8 00 00 00 00 01 00 00 00 | mov     rax, 100000000h\n0x0045BFD2 | 48 01 45 F8 | add     [rbp+var_8], rax\n0x0045BFD6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045BFDA | 5D | pop     rbp\n0x0045BFDB | C3 | retn",
        "output": "\n\n Ourput decompiled code:\nstatic ALWAYS_INLINE cputime_t get_interval(cputime_t old, cputime_t new)\n{\n\tcputime_t itv = new - old;\n\n\tif (itv < 0) {\n\t\tif (old <= (cputime_t)-1 + (cputime_t)100000000)\n\t\t\titv += (cputime_t)100000000;\n\t\telse\n\t\t\titv = -1;\n\t}\n\n\treturn itv;\n}",
        "source_code": "static ALWAYS_INLINE cputime_t overflow_safe_sub(cputime_t prev, cputime_t curr)\n{\n\tcputime_t v = curr - prev;\n\n\tif ((icputime_t)v < 0     /* curr < prev - counter overflow? */\n\t && prev <= 0xffffffff /* kernel uses 32bit value for the counter? */\n\t) {\n\t\t/* Add 33th bit set to 1 to curr, compensating for the overflow */\n\t\t/* double shift defeats \"warning: left shift count >= width of type\" */\n\t\tv += ((cputime_t)1 << 16) << 16;\n\t}\n\treturn v;\n}",
        "parsed_output": "\n\n Ourput decompiled code:\nstatic ALWAYS_INLINE cputime_t get_interval(cputime_t old, cputime_t new)\n{\n\tcputime_t itv = new - old;\n\n\tif (itv < 0) {\n\t\tif (old <= (cputime_t)-1 + (cputime_t)100000000)\n\t\t\titv += (cputime_t)100000000;\n\t\telse\n\t\t\titv = -1;\n\t}\n\n\treturn itv;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_45BF9C(unsigned __int64 a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = a2 - a1;\n  if ( (__int64)(a2 - a1) < 0 && a1 <= 0xFFFFFFFF )\n    v3 += 0x100000000LL;\n  return v3;\n}\n",
        "baseline_code_debug": "cputime_t __cdecl overflow_safe_sub(cputime_t prev, cputime_t curr)\n{\n  cputime_t v; // [rsp+18h] [rbp-8h]\n\n  v = curr - prev;\n  if ( (__int64)(curr - prev) < 0 && prev <= 0xFFFFFFFF )\n    v += 0x100000000LL;\n  return v;\n}\n",
        "similarity_score_unixcoder": 0.7837573885917664,
        "similarity_score_baseline_stripped": 0.6165815591812134,
        "similarity_score_baseline_debug": 0.7931541204452515
    },
    {
        "func_name": "free_volume_id",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0045C54B | 55 | push    rbp\n0x0045C54C | 48 89 E5 | mov     rbp, rsp\n0x0045C54F | 48 83 EC 10 | sub     rsp, 10h\n0x0045C553 | 48 89 7D F8 | mov     [rbp+ptr], rdi\n0x0045C557 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0\n0x0045C55C | 74 1B | jz      short loc_45C579\n0x0045C55E | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x0045C562 | 48 8B 00 | mov     rax, [rax]\n0x0045C565 | 48 89 C7 | mov     rdi, rax\n0x0045C568 | E8 DE FF FF FF | call    sub_45C54B\n0x0045C56D | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x0045C571 | 48 89 C7 | mov     rdi, rax; ptr\n0x0045C574 | E8 E7 A0 FA FF | call    _free\n0x0045C579 | 90 | nop\n0x0045C57A | C9 | leave\n0x0045C57B | C3 | retn\n\n Ourput decompiled code:\nstatic void stats_dev_free(stats_dev_t *stats_dev)\n{\n\tif (stats_dev) {\n\t\tstats_dev_free(stats_dev->next);\n\t\tfree(stats_dev);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x004C00B6 | 55 | push    rbp\n0x004C00B7 | 48 89 E5 | mov     rbp, rsp\n0x004C00BA | 48 83 EC 10 | sub     rsp, 10h\n0x004C00BE | 48 89 7D F8 | mov     [rbp+ptr], rdi\n0x004C00C2 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0\n0x004C00C7 | 74 1F | jz      short loc_4C00E8\n0x004C00C9 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004C00CD | 48 8B 80 B8 04 00 00 | mov     rax, [rax+4B8h]\n0x004C00D4 | 48 89 C7 | mov     rdi, rax\n0x004C00D7 | E8 0E EE FF FF | call    sub_4BEEEA\n0x004C00DC | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004C00E0 | 48 89 C7 | mov     rdi, rax; ptr\n0x004C00E3 | E8 78 65 F4 FF | call    _free\n0x004C00E8 | 90 | nop\n0x004C00E9 | C9 | leave\n0x004C00EA | C3 | retn\n\n Ourput decompiled code:\nXZ_EXTERN void XZ_FUNC xz_dec_end(struct xz_dec *s)\n{\n\tif (s != NULL) {\n\t\txz_dec_lzma2_end(s->lzma2);\n#ifdef XZ_DEC_BCJ\n\t\txz_dec_bcj_end(s->bcj);\n#endif\n\t\tkfree(s);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x0040F557 | 55 | push    rbp\n0x0040F558 | 48 89 E5 | mov     rbp, rsp\n0x0040F55B | 48 83 EC 10 | sub     rsp, 10h\n0x0040F55F | 48 89 7D F8 | mov     [rbp+s], rdi\n0x0040F563 | 48 83 7D F8 00 | cmp     [rbp+s], 0\n0x0040F568 | 74 20 | jz      short loc_40F58A\n0x0040F56A | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x0040F56E | 48 89 C7 | mov     rdi, rax; s\n0x0040F571 | E8 5A 75 FF FF | call    _strlen\n0x0040F576 | 48 89 C2 | mov     rdx, rax; n\n0x0040F579 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x0040F57D | BE 00 00 00 00 | mov     esi, 0; c\n0x0040F582 | 48 89 C7 | mov     rdi, rax; s\n0x0040F585 | E8 C6 77 FF FF | call    _memset\n0x0040F58A | 90 | nop\n0x0040F58B | C9 | leave\n0x0040F58C | C3 | retn\n\n Ourput decompiled code:\nstatic void nuke_str(char *str)\n{\n\tif (str) memset(str, 0, strlen(str));\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004A5BEA | 55 | push    rbp\n0x004A5BEB | 48 89 E5 | mov     rbp, rsp\n0x004A5BEE | 48 83 EC 10 | sub     rsp, 10h\n0x004A5BF2 | 48 89 7D F8 | mov     [rbp+ptr], rdi\n0x004A5BF6 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0\n0x004A5BFB | 74 27 | jz      short loc_4A5C24\n0x004A5BFD | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004A5C01 | 8B 00 | mov     eax, [rax]\n0x004A5C03 | 89 C7 | mov     edi, eax; fd\n0x004A5C05 | E8 06 12 F6 FF | call    _close\n0x004A5C0A | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004A5C0E | 48 89 C7 | mov     rdi, rax\n0x004A5C11 | E8 1B 27 00 00 | call    sub_4A8331\n0x004A5C16 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004A5C1A | 48 89 C7 | mov     rdi, rax; ptr\n0x004A5C1D | E8 3E 0A F6 FF | call    _free\n0x004A5C22 | EB 01 | jmp     short locret_4A5C25\n0x004A5C24 | 90 | nop\n0x004A5C25 | C9 | leave\n0x004A5C26 | C3 | retn",
        "output": "\n\nstatic void free_data(struct data *data)\n{\n\tif (data) {\n\t\tclose(data->fd);\n\t\tnuke_str(data->path);\n\t\tfree(data);\n\t}\n}",
        "source_code": "endif\n\nvoid FAST_FUNC free_volume_id(struct volume_id *id)\n{\n\tif (id == NULL)\n\t\treturn;\n\n\t//if (id->fd_close != 0) - always true\n\t\tclose(id->fd);\n\tvolume_id_free_buffer(id);\n#ifdef UNUSED_PARTITION_CODE\n\tfree(id->partitions);\n#endif\n\tfree(id);\n}",
        "parsed_output": "\n\nstatic void free_data(struct data *data)\n{\n\tif (data) {\n\t\tclose(data->fd);\n\t\tnuke_str(data->path);\n\t\tfree(data);\n\t}\n}",
        "baseline_code_stripped": "void __fastcall sub_4A5BEA(int *a1)\n{\n  if ( a1 )\n  {\n    close(*a1);\n    sub_4A8331(a1);\n    free(a1);\n  }\n}\n",
        "baseline_code_debug": "void __cdecl free_volume_id(volume_id *id)\n{\n  if ( id )\n  {\n    close(id->fd);\n    volume_id_free_buffer(id);\n    free(id);\n  }\n}\n",
        "similarity_score_unixcoder": 0.6686382293701172,
        "similarity_score_baseline_stripped": 0.5103965997695923,
        "similarity_score_baseline_debug": 0.8812991380691528
    },
    {
        "func_name": "do_linemode",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00442153 | 55 | push    rbp\n0x00442154 | 48 89 E5 | mov     rbp, rsp\n0x00442157 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0044215C | C6 40 06 00 | mov     byte ptr [rax+6], 0\n0x00442160 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00442165 | 0F B6 50 07 | movzx   edx, byte ptr [rax+7]\n0x00442169 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0044216E | 83 CA 03 | or      edx, 3\n0x00442171 | 88 50 07 | mov     [rax+7], dl\n0x00442174 | E8 56 FF FF FF | call    sub_4420CF\n0x00442179 | BE 01 00 00 00 | mov     esi, 1\n0x0044217E | BF FD 00 00 00 | mov     edi, 0FDh\n0x00442183 | E8 DF FC FF FF | call    sub_441E67\n0x00442188 | BE 03 00 00 00 | mov     esi, 3\n0x0044218D | BF FD 00 00 00 | mov     edi, 0FDh\n0x00442192 | E8 D0 FC FF FF | call    sub_441E67\n0x00442197 | E8 8F F8 FF FF | call    sub_441A2B\n0x0044219C | 90 | nop\n0x0044219D | 5D | pop     rbp\n0x0044219E | C3 | retn\n\n Ourput decompiled code:\nstatic void will_charmode(void)\n{\n\tG.charmode = CHM_TRY;\n\tG.telflags |= (UF_ECHO | UF_SGA);\n\tsetConMode();\n\n\tput_iac2(DO, TELOPT_ECHO);\n\tput_iac2(DO, TELOPT_SGA);\n\tiac_flush();\n}\n\n## Example:\n\n Input assembly code:\n0x004420CF | 55 | push    rbp\n0x004420D0 | 48 89 E5 | mov     rbp, rsp\n0x004420D3 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004420D8 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]\n0x004420DC | 0F B6 C0 | movzx   eax, al\n0x004420DF | 83 E0 01 | and     eax, 1\n0x004420E2 | 85 C0 | test    eax, eax\n0x004420E4 | 74 36 | jz      short loc_44211C\n0x004420E6 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004420EB | 0F B6 40 06 | movzx   eax, byte ptr [rax+6]\n0x004420EF | 84 C0 | test    al, al\n0x004420F1 | 75 5D | jnz     short loc_442150\n0x004420F3 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004420F8 | C6 40 06 01 | mov     byte ptr [rax+6], 1\n0x004420FC | BA 5D 00 00 00 | mov     edx, 5Dh ; ']'\n0x00442101 | BE 9D BC 52 00 | mov     esi, offset aCharacter; \"character\"\n0x00442106 | BF A8 BC 52 00 | mov     edi, offset aEnteringSModeE; \"\\r\\nEntering %s mode\\r\\nEscape characte\"...\n0x0044210B | B8 00 00 00 00 | mov     eax, 0\n0x00442110 | E8 BB 4A FC FF | call    _printf\n0x00442115 | E8 07 04 00 00 | call    sub_442521\n0x0044211A | EB 34 | jmp     short loc_442150\n0x0044211C | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00442121 | 0F B6 40 06 | movzx   eax, byte ptr [rax+6]\n0x00442125 | 3C 02 | cmp     al, 2\n0x00442127 | 74 27 | jz      short loc_442150\n0x00442129 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0044212E | C6 40 06 02 | mov     byte ptr [rax+6], 2\n0x00442132 | BA 43 00 00 00 | mov     edx, 43h ; 'C'\n0x00442137 | BE D9 BC 52 00 | mov     esi, offset aLine; \"line\"\n0x0044213C | BF A8 BC 52 00 | mov     edi, offset aEnteringSModeE; \"\\r\\nEntering %s mode\\r\\nEscape characte\"...\n0x00442141 | B8 00 00 00 00 | mov     eax, 0\n0x00442146 | E8 85 4A FC FF | call    _printf\n0x0044214B | E8 FC 03 00 00 | call    sub_44254C\n0x00442150 | 90 | nop\n0x00442151 | 5D | pop     rbp\n0x00442152 | C3 | retn\n\n Ourput decompiled code:\nendif\n\nstatic void setConMode(void)\n{\n\tif (G.telflags & UF_ECHO) {\n\t\tif (G.charmode == CHM_TRY) {\n\t\t\tG.charmode = CHM_ON;\n\t\t\tprintf(\"\\r\\nEntering %s mode\"\n\t\t\t\t\"\\r\\nEscape character is '^%c'.\\r\\n\", \"character\", ']');\n\t\t\trawmode();\n\t\t}\n\t} else {\n\t\tif (G.charmode != CHM_OFF) {\n\t\t\tG.charmode = CHM_OFF;\n\t\t\tprintf(\"\\r\\nEntering %s mode\"\n\t\t\t\t\"\\r\\nEscape character is '^%c'.\\r\\n\", \"line\", 'C');\n\t\t\tcookmode();\n\t\t}\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x00440DC1 | 55 | push    rbp\n0x00440DC2 | 48 89 E5 | mov     rbp, rsp\n0x00440DC5 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00440DCA | 8B 40 10 | mov     eax, [rax+10h]\n0x00440DCD | 83 F8 01 | cmp     eax, 1\n0x00440DD0 | 76 21 | jbe     short loc_440DF3\n0x00440DD2 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00440DD7 | 8B 50 10 | mov     edx, [rax+10h]\n0x00440DDA | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00440DDF | 8B 40 0C | mov     eax, [rax+0Ch]\n0x00440DE2 | 89 C6 | mov     esi, eax\n0x00440DE4 | BF 84 BA 52 00 | mov     edi, offset aStatusUU; \"status %u/%u\"\n0x00440DE9 | B8 00 00 00 00 | mov     eax, 0\n0x00440DEE | E8 54 89 FC FF | call    sub_409747\n0x00440DF3 | 90 | nop\n0x00440DF4 | 5D | pop     rbp\n0x00440DF5 | C3 | retn\n\n Ourput decompiled code:\nstatic void connection_status(void)\n{\n\t/* \"only 1 client max\" desn't need this */\n\tif (cmax > 1)\n\t\tbb_error_msg(\"status %u/%u\", cnum, cmax);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0044219F | 55 | push    rbp\n0x004421A0 | 48 89 E5 | mov     rbp, rsp\n0x004421A3 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004421A8 | C6 40 06 00 | mov     byte ptr [rax+6], 0\n0x004421AC | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004421B1 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]\n0x004421B5 | BA F8 B3 75 00 | mov     edx, offset dest\n0x004421BA | 83 E0 FC | and     eax, 0FFFFFFFCh\n0x004421BD | 88 42 07 | mov     [rdx+7], al\n0x004421C0 | E8 0A FF FF FF | call    sub_4420CF\n0x004421C5 | BE 01 00 00 00 | mov     esi, 1\n0x004421CA | BF FE 00 00 00 | mov     edi, 0FEh\n0x004421CF | E8 93 FC FF FF | call    sub_441E67\n0x004421D4 | BE 03 00 00 00 | mov     esi, 3\n0x004421D9 | BF FE 00 00 00 | mov     edi, 0FEh\n0x004421DE | E8 84 FC FF FF | call    sub_441E67\n0x004421E3 | E8 43 F8 FF FF | call    sub_441A2B\n0x004421E8 | 90 | nop\n0x004421E9 | 5D | pop     rbp\n0x004421EA | C3 | retn",
        "output": "\n\nstatic void wont_charmode(void)\n{\n\tG.charmode = CHM_OFF;\n\tG.telflags &= ~(UF_ECHO | UF_SGA);\n\tsetConMode();\n\n\tput_iac2(WILL, TELOPT_ECHO);\n\tput_iac2(WILL, TELOPT_SGA);\n\tiac_flush();\n}",
        "source_code": "static void do_linemode(void)\n{\n\tG.charmode = CHM_TRY;\n\tG.telflags &= ~(UF_ECHO | UF_SGA);\n\tsetConMode();\n\n\tput_iac2(DONT, TELOPT_ECHO);\n\tput_iac2(DONT, TELOPT_SGA);\n\tiac_flush();\n}",
        "parsed_output": "\n\nstatic void wont_charmode(void)\n{\n\tG.charmode = CHM_OFF;\n\tG.telflags &= ~(UF_ECHO | UF_SGA);\n\tsetConMode();\n\n\tput_iac2(WILL, TELOPT_ECHO);\n\tput_iac2(WILL, TELOPT_SGA);\n\tiac_flush();\n}",
        "baseline_code_stripped": "struct termios *sub_44219F()\n{\n  BYTE2(dest.c_oflag) = 0;\n  HIBYTE(dest.c_oflag) &= 0xFCu;\n  sub_4420CF();\n  sub_441E67(254, 1);\n  sub_441E67(254, 3);\n  return sub_441A2B();\n}\n",
        "baseline_code_debug": "void __cdecl do_linemode()\n{\n  BYTE2(bb_common_bufsiz1.c_oflag) = 0;\n  HIBYTE(bb_common_bufsiz1.c_oflag) &= 0xFCu;\n  setConMode();\n  put_iac2(0xFEu, 1u);\n  put_iac2(0xFEu, 3u);\n  iac_flush();\n}\n",
        "similarity_score_unixcoder": 0.8922610282897949,
        "similarity_score_baseline_stripped": 0.492007851600647,
        "similarity_score_baseline_debug": 0.6759384870529175
    },
    {
        "func_name": "unbackslash",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00408F1D | 55 | push    rbp\n0x00408F1E | 48 89 E5 | mov     rbp, rsp\n0x00408F21 | 48 83 EC 20 | sub     rsp, 20h\n0x00408F25 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00408F29 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00408F2D | BE 2F 00 00 00 | mov     esi, 2Fh ; '/'\n0x00408F32 | 48 89 C7 | mov     rdi, rax\n0x00408F35 | E8 3F 00 00 00 | call    sub_408F79\n0x00408F3A | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00408F3E | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00408F43 | 74 26 | jz      short loc_408F6B\n0x00408F45 | EB 0F | jmp     short loc_408F56\n0x00408F47 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00408F4B | 48 8D 50 FF | lea     rdx, [rax-1]\n0x00408F4F | 48 89 55 F8 | mov     [rbp+var_8], rdx\n0x00408F53 | C6 00 00 | mov     byte ptr [rax], 0\n0x00408F56 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00408F5A | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00408F5D | 3C 2F | cmp     al, 2Fh ; '/'\n0x00408F5F | 75 0A | jnz     short loc_408F6B\n0x00408F61 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00408F65 | 48 3B 45 E8 | cmp     rax, [rbp+var_18]\n0x00408F69 | 75 DC | jnz     short loc_408F47\n0x00408F6B | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00408F6F | 48 89 C7 | mov     rdi, rax\n0x00408F72 | E8 55 FF FF FF | call    sub_408ECC\n0x00408F77 | C9 | leave\n0x00408F78 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC bb_get_last_path_component_strip(char *path)\n{\n\tchar *slash = last_char_is(path, '/');\n\n\tif (slash)\n\t\twhile (*slash == '/' && slash != path)\n\t\t\t*slash-- = '\\0';\n\n\treturn bb_get_last_path_component_nostrip(path);\n}\n\n## Example:\n\n Input assembly code:\n0x00446899 | 55 | push    rbp\n0x0044689A | 48 89 E5 | mov     rbp, rsp\n0x0044689D | 48 83 EC 20 | sub     rsp, 20h\n0x004468A1 | 48 89 7D E8 | mov     [rbp+s], rdi\n0x004468A5 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x004468A9 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004468AC | 3C 5B | cmp     al, 5Bh ; '['\n0x004468AE | 75 6B | jnz     short loc_44691B\n0x004468B0 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x004468B4 | BE 25 00 00 00 | mov     esi, 25h ; '%'; c\n0x004468B9 | 48 89 C7 | mov     rdi, rax; s\n0x004468BC | E8 FF 02 FC FF | call    _strchr\n0x004468C1 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004468C5 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004468CA | 74 52 | jz      short loc_44691E\n0x004468CC | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x004468D0 | BE 5D 00 00 00 | mov     esi, 5Dh ; ']'; c\n0x004468D5 | 48 89 C7 | mov     rdi, rax; s\n0x004468D8 | E8 E3 02 FC FF | call    _strchr\n0x004468DD | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x004468E1 | 48 83 7D F0 00 | cmp     [rbp+var_10], 0\n0x004468E6 | 74 39 | jz      short loc_446921\n0x004468E8 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004468EC | 48 83 C0 01 | add     rax, 1\n0x004468F0 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004468F3 | 3C 3A | cmp     al, 3Ah ; ':'\n0x004468F5 | 74 0F | jz      short loc_446906\n0x004468F7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004468FB | 48 83 C0 01 | add     rax, 1\n0x004468FF | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00446902 | 84 C0 | test    al, al\n0x00446904 | 75 1B | jnz     short loc_446921\n0x00446906 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x0044690A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0044690E | 48 89 D6 | mov     rsi, rdx\n0x00446911 | 48 89 C7 | mov     rdi, rax\n0x00446914 | E8 F4 16 0C 00 | call    sub_50800D\n0x00446919 | EB 07 | jmp     short locret_446922\n0x0044691B | 90 | nop\n0x0044691C | EB 04 | jmp     short locret_446922\n0x0044691E | 90 | nop\n0x0044691F | EB 01 | jmp     short locret_446922\n0x00446921 | 90 | nop\n0x00446922 | C9 | leave\n0x00446923 | C3 | retn\n\n Ourput decompiled code:\nstatic void strip_ipv6_scope_id(char *host)\n{\n\tchar *scope, *cp;\n\n\t/* bbox wget actually handles IPv6 addresses without [], like\n\t * wget \"http://::1/xxx\", but this is not standard.\n\t * To save code, _here_ we do not support it. */\n\n\tif (host[0] != '[')\n\t\treturn; /* not IPv6 */\n\n\tscope = strchr(host, '%');\n\tif (!scope)\n\t\treturn;\n\n\t/* Remove the IPv6 zone identifier from the host address */\n\tcp = strchr(host, ']');\n\tif (!cp || (cp[1] != ':' && cp[1] != '\\0')) {\n\t\t/* malformed address (not \"[xx]:nn\" or \"[xx]\") */\n\t\treturn;\n\t}\n\n\t/* cp points to \"]...\", scope points to \"%eth0]...\" */\n\toverlapping_strcpy(scope, cp);\n}\n\n## Example:\n\n Input assembly code:\n0x00408ECC | 55 | push    rbp\n0x00408ECD | 48 89 E5 | mov     rbp, rsp\n0x00408ED0 | 48 83 EC 20 | sub     rsp, 20h\n0x00408ED4 | 48 89 7D E8 | mov     [rbp+s], rdi\n0x00408ED8 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x00408EDC | BE 2F 00 00 00 | mov     esi, 2Fh ; '/'; c\n0x00408EE1 | 48 89 C7 | mov     rdi, rax; s\n0x00408EE4 | E8 47 DD FF FF | call    _strrchr\n0x00408EE9 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00408EED | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00408EF2 | 74 19 | jz      short loc_408F0D\n0x00408EF4 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00408EF8 | 48 3B 45 E8 | cmp     rax, [rbp+s]\n0x00408EFC | 75 15 | jnz     short loc_408F13\n0x00408EFE | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00408F02 | 48 83 C0 01 | add     rax, 1\n0x00408F06 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00408F09 | 84 C0 | test    al, al\n0x00408F0B | 75 06 | jnz     short loc_408F13\n0x00408F0D | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x00408F11 | EB 08 | jmp     short locret_408F1B\n0x00408F13 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00408F17 | 48 83 C0 01 | add     rax, 1\n0x00408F1B | C9 | leave\n0x00408F1C | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC bb_get_last_path_component_nostrip(const char *path)\n{\n\tchar *slash = strrchr(path, '/');\n\n\tif (!slash || (slash == path && !slash[1]))\n\t\treturn (char*)path;\n\n\treturn slash + 1;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0047FF75 | 55 | push    rbp\n0x0047FF76 | 48 89 E5 | mov     rbp, rsp\n0x0047FF79 | 48 83 EC 20 | sub     rsp, 20h\n0x0047FF7D | 48 89 7D E8 | mov     [rbp+s], rdi\n0x0047FF81 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x0047FF85 | BE 5C 00 00 00 | mov     esi, 5Ch ; '\\'; c\n0x0047FF8A | 48 89 C7 | mov     rdi, rax; s\n0x0047FF8D | E8 5E 69 F8 FF | call    _strchrnul\n0x0047FF92 | 48 89 45 E8 | mov     [rbp+s], rax\n0x0047FF96 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x0047FF9A | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0047FF9E | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x0047FFA2 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0047FFA5 | 3C 5C | cmp     al, 5Ch ; '\\'\n0x0047FFA7 | 75 05 | jnz     short loc_47FFAE\n0x0047FFA9 | 48 83 45 E8 01 | add     [rbp+s], 1\n0x0047FFAE | 48 8B 55 E8 | mov     rdx, [rbp+s]\n0x0047FFB2 | 48 8D 42 01 | lea     rax, [rdx+1]\n0x0047FFB6 | 48 89 45 E8 | mov     [rbp+s], rax\n0x0047FFBA | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0047FFBE | 48 8D 48 01 | lea     rcx, [rax+1]\n0x0047FFC2 | 48 89 4D F8 | mov     [rbp+var_8], rcx\n0x0047FFC6 | 0F B6 12 | movzx   edx, byte ptr [rdx]\n0x0047FFC9 | 88 10 | mov     [rax], dl\n0x0047FFCB | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0047FFCE | 84 C0 | test    al, al\n0x0047FFD0 | 74 02 | jz      short loc_47FFD4\n0x0047FFD2 | EB CA | jmp     short loc_47FF9E\n0x0047FFD4 | 90 | nop\n0x0047FFD5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0047FFD9 | C9 | leave\n0x0047FFDA | C3 | retn",
        "output": "\n\nstatic void bb_get_last_path_component(char *path)\n{\n\tchar *slash = strchrnul(path, '\\\\');\n\n\tpath = slash;\n\tdo {\n\t\tslash = path;\n\t\tpath++;\n\t} while (*path == '\\\\');\n\n\tif (*path) {\n\t\t*slash = *path++;\n\t\t*slash = '\\0';\n\t}\n}",
        "source_code": "static char *unbackslash(char *src)\n{\n\tchar *dst = src = strchrnul(src, '\\\\');\n\twhile (1) {\n\t\tif (*src == '\\\\')\n\t\t\tsrc++;\n\t\tif ((*dst++ = *src++) == '\\0')\n\t\t\tbreak;\n\t}\n\treturn dst;\n}",
        "parsed_output": "\n\nstatic void bb_get_last_path_component(char *path)\n{\n\tchar *slash = strchrnul(path, '\\\\');\n\n\tpath = slash;\n\tdo {\n\t\tslash = path;\n\t\tpath++;\n\t} while (*path == '\\\\');\n\n\tif (*path) {\n\t\t*slash = *path++;\n\t\t*slash = '\\0';\n\t}\n}",
        "baseline_code_stripped": "char *__fastcall sub_47FF75(const char *a1)\n{\n  char *v1; // rdx\n  char *v2; // rax\n  char *s; // [rsp+8h] [rbp-18h]\n  char *v5; // [rsp+18h] [rbp-8h]\n\n  s = strchrnul(a1, 92);\n  v5 = s;\n  do\n  {\n    if ( *s == 92 )\n      ++s;\n    v1 = s++;\n    v2 = v5++;\n    *v2 = *v1;\n  }\n  while ( *v2 );\n  return v5;\n}\n",
        "baseline_code_debug": "char *__cdecl unbackslash(char *src)\n{\n  char *v1; // rdx\n  char *v2; // rax\n  char *srca; // [rsp+8h] [rbp-18h]\n  char *dst; // [rsp+18h] [rbp-8h]\n\n  srca = strchrnul(src, 92);\n  dst = srca;\n  do\n  {\n    if ( *srca == 92 )\n      ++srca;\n    v1 = srca++;\n    v2 = dst++;\n    *v2 = *v1;\n  }\n  while ( *v2 );\n  return dst;\n}\n",
        "similarity_score_unixcoder": 0.6669597625732422,
        "similarity_score_baseline_stripped": 0.5178252458572388,
        "similarity_score_baseline_debug": 0.8297326564788818
    },
    {
        "func_name": "procnetdev_version",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00422081 | 55 | push    rbp\n0x00422082 | 48 89 E5 | mov     rbp, rsp\n0x00422085 | 48 83 EC 10 | sub     rsp, 10h\n0x00422089 | 48 89 7D F8 | mov     [rbp+s1], rdi\n0x0042208D | 48 8B 45 F8 | mov     rax, [rbp+s1]\n0x00422091 | BE 69 75 51 00 | mov     esi, offset aNone_1; \"none\"\n0x00422096 | 48 89 C7 | mov     rdi, rax; s1\n0x00422099 | E8 22 46 FE FF | call    _strcasecmp\n0x0042209E | 85 C0 | test    eax, eax\n0x004220A0 | 75 07 | jnz     short loc_4220A9\n0x004220A2 | B8 FF FF 00 00 | mov     eax, 0FFFFh\n0x004220A7 | EB 28 | jmp     short locret_4220D1\n0x004220A9 | 48 8B 45 F8 | mov     rax, [rbp+s1]\n0x004220AD | BE 60 75 51 00 | mov     esi, offset aInfinite; \"infinite\"\n0x004220B2 | 48 89 C7 | mov     rdi, rax; s1\n0x004220B5 | E8 06 46 FE FF | call    _strcasecmp\n0x004220BA | 85 C0 | test    eax, eax\n0x004220BC | 75 07 | jnz     short loc_4220C5\n0x004220BE | B8 00 00 00 00 | mov     eax, 0\n0x004220C3 | EB 0C | jmp     short locret_4220D1\n0x004220C5 | 48 8B 45 F8 | mov     rax, [rbp+s1]\n0x004220C9 | 48 89 C7 | mov     rdi, rax\n0x004220CC | E8 8C FF FF FF | call    sub_42205D\n0x004220D1 | C9 | leave\n0x004220D2 | C3 | retn\n\n Ourput decompiled code:\nstatic int get_wait(const char *arg)\n{\n\tif (strcasecmp(arg, STR_NONE) == 0)\n\t\treturn ASYNC_CLOSING_WAIT_NONE;\n\n\tif (strcasecmp(arg, STR_INFINITE) == 0)\n\t\treturn ASYNC_CLOSING_WAIT_INF;\n\n\treturn get_numeric(arg);\n}\n\n## Example:\n\n Input assembly code:\n0x0046EE78 | 55 | push    rbp\n0x0046EE79 | 48 89 E5 | mov     rbp, rsp\n0x0046EE7C | 48 83 EC 10 | sub     rsp, 10h\n0x0046EE80 | 48 89 7D F8 | mov     [rbp+nptr], rdi\n0x0046EE84 | 48 8B 45 F8 | mov     rax, [rbp+nptr]\n0x0046EE88 | 48 89 C7 | mov     rdi, rax\n0x0046EE8B | E8 B4 FF FF FF | call    sub_46EE44\n0x0046EE90 | 85 C0 | test    eax, eax\n0x0046EE92 | 75 16 | jnz     short loc_46EEAA\n0x0046EE94 | 48 8B 45 F8 | mov     rax, [rbp+nptr]\n0x0046EE98 | 48 89 C6 | mov     rsi, rax\n0x0046EE9B | BF 7D C6 51 00 | mov     edi, offset aIllegalNumberS; \"Illegal number: %s\"\n0x0046EEA0 | B8 00 00 00 00 | mov     eax, 0\n0x0046EEA5 | E8 C9 F5 FF FF | call    sub_46E473\n0x0046EEAA | 48 8B 45 F8 | mov     rax, [rbp+nptr]\n0x0046EEAE | 48 89 C7 | mov     rdi, rax; nptr\n0x0046EEB1 | E8 0A 8B F9 FF | call    _atoi\n0x0046EEB6 | C9 | leave\n0x0046EEB7 | C3 | retn\n\n Ourput decompiled code:\nstatic int\nnumber(const char *s)\n{\n\tif (!is_number(s))\n\t\tash_msg_and_raise_error(msg_illnum, s);\n\treturn atoi(s);\n}\n\n## Example:\n\n Input assembly code:\n0x0040A8DC | 55 | push    rbp\n0x0040A8DD | 48 89 E5 | mov     rbp, rsp\n0x0040A8E0 | 48 83 EC 10 | sub     rsp, 10h\n0x0040A8E4 | 48 89 7D F8 | mov     [rbp+path], rdi\n0x0040A8E8 | 48 8B 45 F8 | mov     rax, [rbp+path]\n0x0040A8EC | 48 89 C7 | mov     rdi, rax; path\n0x0040A8EF | E8 EC BE FF FF | call    _chroot\n0x0040A8F4 | 85 C0 | test    eax, eax\n0x0040A8F6 | 74 16 | jz      short loc_40A90E\n0x0040A8F8 | 48 8B 45 F8 | mov     rax, [rbp+path]\n0x0040A8FC | 48 89 C6 | mov     rsi, rax\n0x0040A8FF | BF 08 81 52 00 | mov     edi, offset aCanTChangeRoot; \"can't change root directory to '%s'\"\n0x0040A904 | B8 00 00 00 00 | mov     eax, 0\n0x0040A909 | E8 94 E9 FF FF | call    sub_4092A2\n0x0040A90E | BF 2C 81 52 00 | mov     edi, offset asc_52812C; \"/\"\n0x0040A913 | E8 8F FF FF FF | call    sub_40A8A7\n0x0040A918 | 90 | nop\n0x0040A919 | C9 | leave\n0x0040A91A | C3 | retn\n\n Ourput decompiled code:\nvoid FAST_FUNC xchroot(const char *path)\n{\n\tif (chroot(path))\n\t\tbb_perror_msg_and_die(\"can't change root directory to '%s'\", path);\n\txchdir(\"/\");\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00436DA9 | 55 | push    rbp\n0x00436DAA | 48 89 E5 | mov     rbp, rsp\n0x00436DAD | 48 83 EC 10 | sub     rsp, 10h\n0x00436DB1 | 48 89 7D F8 | mov     [rbp+haystack], rdi\n0x00436DB5 | 48 8B 45 F8 | mov     rax, [rbp+haystack]\n0x00436DB9 | BE 58 97 51 00 | mov     esi, offset aCompressed; \"compressed\"\n0x00436DBE | 48 89 C7 | mov     rdi, rax; haystack\n0x00436DC1 | E8 FA 0E FD FF | call    _strstr\n0x00436DC6 | 48 85 C0 | test    rax, rax\n0x00436DC9 | 74 07 | jz      short loc_436DD2\n0x00436DCB | B8 02 00 00 00 | mov     eax, 2\n0x00436DD0 | EB 22 | jmp     short locret_436DF4\n0x00436DD2 | 48 8B 45 F8 | mov     rax, [rbp+haystack]\n0x00436DD6 | BE 63 97 51 00 | mov     esi, offset aBytes_0; \"bytes\"\n0x00436DDB | 48 89 C7 | mov     rdi, rax; haystack\n0x00436DDE | E8 DD 0E FD FF | call    _strstr\n0x00436DE3 | 48 85 C0 | test    rax, rax\n0x00436DE6 | 74 07 | jz      short loc_436DEF\n0x00436DE8 | B8 01 00 00 00 | mov     eax, 1\n0x00436DED | EB 05 | jmp     short locret_436DF4\n0x00436DEF | B8 00 00 00 00 | mov     eax, 0\n0x00436DF4 | C9 | leave\n0x00436DF5 | C3 | retn",
        "output": "\nstatic int FAST_FUNC is_compressed(const char *haystack)\n{\n\tif (strstr(haystack, STR_COMPRESSED))\n\t\treturn 2;\n\tif (strstr(haystack, STR_BYTES))\n\t\treturn 1;\n\treturn 0;\n}",
        "source_code": "static int procnetdev_version(char *buf)\n{\n\tif (strstr(buf, \"compressed\"))\n\t\treturn 2;\n\tif (strstr(buf, \"bytes\"))\n\t\treturn 1;\n\treturn 0;\n}",
        "parsed_output": "\nstatic int FAST_FUNC is_compressed(const char *haystack)\n{\n\tif (strstr(haystack, STR_COMPRESSED))\n\t\treturn 2;\n\tif (strstr(haystack, STR_BYTES))\n\t\treturn 1;\n\treturn 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_436DA9(const char *a1)\n{\n  if ( strstr(a1, \"compressed\") )\n    return 2LL;\n  else\n    return strstr(a1, \"bytes\") != 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl procnetdev_version(char *buf)\n{\n  if ( strstr(buf, \"compressed\") )\n    return 2;\n  else\n    return strstr(buf, \"bytes\") != 0LL;\n}\n",
        "similarity_score_unixcoder": 0.7189751863479614,
        "similarity_score_baseline_stripped": 0.6556093096733093,
        "similarity_score_baseline_debug": 0.8193730115890503
    },
    {
        "func_name": "xsetenv_proto",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00440C08 | 55 | push    rbp\n0x00440C09 | 48 89 E5 | mov     rbp, rsp\n0x00440C0C | 48 83 EC 20 | sub     rsp, 20h\n0x00440C10 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00440C14 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00440C18 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00440C1C | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00440C20 | 48 89 C6 | mov     rsi, rax\n0x00440C23 | BF 48 BA 52 00 | mov     edi, offset aSS_20; \"%s=%s\"\n0x00440C28 | B8 00 00 00 00 | mov     eax, 0\n0x00440C2D | E8 81 9A FC FF | call    sub_40A6B3\n0x00440C32 | 48 89 45 F8 | mov     [rbp+string], rax\n0x00440C36 | BA F8 B3 75 00 | mov     edx, offset dest\n0x00440C3B | 48 8B 42 18 | mov     rax, [rdx+18h]\n0x00440C3F | 48 8D 48 08 | lea     rcx, [rax+8]\n0x00440C43 | 48 89 4A 18 | mov     [rdx+18h], rcx\n0x00440C47 | 48 8B 55 F8 | mov     rdx, [rbp+string]\n0x00440C4B | 48 89 10 | mov     [rax], rdx\n0x00440C4E | 48 8B 45 F8 | mov     rax, [rbp+string]\n0x00440C52 | 48 89 C7 | mov     rdi, rax; string\n0x00440C55 | E8 B6 63 FC FF | call    _putenv\n0x00440C5A | 90 | nop\n0x00440C5B | C9 | leave\n0x00440C5C | C3 | retn\n\n Ourput decompiled code:\nstatic void xsetenv_plain(const char *n, const char *v)\n{\n\tchar *var = xasprintf(\"%s=%s\", n, v);\n\t*env_cur++ = var;\n\tputenv(var);\n}\n\n## Example:\n\n Input assembly code:\n0x00480DED | 55 | push    rbp\n0x00480DEE | 48 89 E5 | mov     rbp, rsp\n0x00480DF1 | 48 83 EC 20 | sub     rsp, 20h\n0x00480DF5 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00480DF9 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00480DFD | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00480E01 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00480E05 | 48 89 C6 | mov     rsi, rax\n0x00480E08 | BF 32 E6 51 00 | mov     edi, offset aSS_33; \"%s=%s\"\n0x00480E0D | B8 00 00 00 00 | mov     eax, 0\n0x00480E12 | E8 9C 98 F8 FF | call    sub_40A6B3\n0x00480E17 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00480E1B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00480E1F | BA 00 00 00 00 | mov     edx, 0\n0x00480E24 | BE 00 00 00 00 | mov     esi, 0\n0x00480E29 | 48 89 C7 | mov     rdi, rax\n0x00480E2C | E8 E8 FA FF FF | call    sub_480919\n0x00480E31 | 90 | nop\n0x00480E32 | C9 | leave\n0x00480E33 | C3 | retn\n\n Ourput decompiled code:\nstatic void FAST_FUNC set_local_var_from_halves(const char *name, const char *val)\n{\n\tchar *var = xasprintf(\"%s=%s\", name, val);\n\tset_local_var(var, /*flags:*/ 0, /*lvl:*/ 0, /*ro:*/ 0);\n}\n\n## Example:\n\n Input assembly code:\n0x004DD898 | 55 | push    rbp\n0x004DD899 | 48 89 E5 | mov     rbp, rsp\n0x004DD89C | 48 83 EC 20 | sub     rsp, 20h\n0x004DD8A0 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004DD8A4 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004DD8A8 | 48 89 55 E8 | mov     [rbp+var_18], rdx\n0x004DD8AC | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004DD8B0 | C7 00 00 21 00 00 | mov     dword ptr [rax], 2100h\n0x004DD8B6 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004DD8BA | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x004DD8BE | 48 89 50 08 | mov     [rax+8], rdx\n0x004DD8C2 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DD8C6 | 48 8D 50 40 | lea     rdx, [rax+40h]\n0x004DD8CA | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004DD8CE | 48 89 50 10 | mov     [rax+10h], rdx\n0x004DD8D2 | 48 8B 4D F8 | mov     rcx, [rbp+var_8]\n0x004DD8D6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DD8DA | BA 01 00 00 00 | mov     edx, 1\n0x004DD8DF | 48 89 CE | mov     rsi, rcx\n0x004DD8E2 | 48 89 C7 | mov     rdi, rax\n0x004DD8E5 | E8 04 E9 02 00 | call    sub_50C1EE\n0x004DD8EA | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DD8EE | 48 8D 48 40 | lea     rcx, [rax+40h]\n0x004DD8F2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004DD8F6 | BA 03 00 00 00 | mov     edx, 3\n0x004DD8FB | 48 89 C6 | mov     rsi, rax\n0x004DD8FE | 48 89 CF | mov     rdi, rcx\n0x004DD901 | E8 E8 E8 02 00 | call    sub_50C1EE\n0x004DD906 | 90 | nop\n0x004DD907 | C9 | leave\n0x004DD908 | C3 | retn\n\n Ourput decompiled code:\nstatic void mk_re_node(const char *s, node *n, regex_t *re)\n{\n\tn->info = OC_REGEXP;\n\tn->l.re = re;\n\tn->r.ire = re + 1;\n\txregcomp(re, s, REG_EXTENDED);\n\txregcomp(re + 1, s, REG_EXTENDED | REG_ICASE);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00440C5D | 55 | push    rbp\n0x00440C5E | 48 89 E5 | mov     rbp, rsp\n0x00440C61 | 48 83 EC 30 | sub     rsp, 30h\n0x00440C65 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00440C69 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00440C6D | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x00440C71 | 48 8B 4D D8 | mov     rcx, [rbp+var_28]\n0x00440C75 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00440C79 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00440C7D | 48 89 C6 | mov     rsi, rax\n0x00440C80 | BF 4E BA 52 00 | mov     edi, offset aSSS_2; \"%s%s=%s\"\n0x00440C85 | B8 00 00 00 00 | mov     eax, 0\n0x00440C8A | E8 24 9A FC FF | call    sub_40A6B3\n0x00440C8F | 48 89 45 F8 | mov     [rbp+string], rax\n0x00440C93 | BA F8 B3 75 00 | mov     edx, offset dest\n0x00440C98 | 48 8B 42 18 | mov     rax, [rdx+18h]\n0x00440C9C | 48 8D 48 08 | lea     rcx, [rax+8]\n0x00440CA0 | 48 89 4A 18 | mov     [rdx+18h], rcx\n0x00440CA4 | 48 8B 55 F8 | mov     rdx, [rbp+string]\n0x00440CA8 | 48 89 10 | mov     [rax], rdx\n0x00440CAB | 48 8B 45 F8 | mov     rax, [rbp+string]\n0x00440CAF | 48 89 C7 | mov     rdi, rax; string\n0x00440CB2 | E8 59 63 FC FF | call    _putenv\n0x00440CB7 | 90 | nop\n0x00440CB8 | C9 | leave\n0x00440CB9 | C3 | retn",
        "output": "\n\nstatic void xsetenv_prefixed(const char *p, const char *n, const char *v)\n{\n\tchar *var = xasprintf(\"%s%s=%s\", p, n, v);\n\t*env_cur++ = var;\n\tputenv(var);\n}",
        "source_code": "static void xsetenv_proto(const char *proto, const char *n, const char *v)\n{\n\tchar *var = xasprintf(\"%s%s=%s\", proto, n, v);\n\t*env_cur++ = var;\n\tputenv(var);\n}",
        "parsed_output": "\n\nstatic void xsetenv_prefixed(const char *p, const char *n, const char *v)\n{\n\tchar *var = xasprintf(\"%s%s=%s\", p, n, v);\n\t*env_cur++ = var;\n\tputenv(var);\n}",
        "baseline_code_stripped": "int __fastcall sub_440C5D(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  char **v6; // rax\n  char *string; // [rsp+28h] [rbp-8h]\n\n  string = sub_40A6B3(\"%s%s=%s\", a1, a2, a3, a5, a6);\n  v6 = *(char ***)&dest.c_cc[7];\n  *(_QWORD *)&dest.c_cc[7] = v6 + 1;\n  *v6 = string;\n  return putenv(string);\n}\n",
        "baseline_code_debug": "void __cdecl xsetenv_proto(const char *proto, const char *n, const char *v)\n{\n  char **v3; // rax\n  char *var; // [rsp+28h] [rbp-8h]\n\n  var = xasprintf(\"%s%s=%s\", proto, n, v);\n  v3 = *(char ***)&bb_common_bufsiz1.c_cc[7];\n  *(_QWORD *)&bb_common_bufsiz1.c_cc[7] = v3 + 1;\n  *v3 = var;\n  putenv(var);\n}\n",
        "similarity_score_unixcoder": 0.8902507424354553,
        "similarity_score_baseline_stripped": 0.5559948086738586,
        "similarity_score_baseline_debug": 0.7900841236114502
    },
    {
        "func_name": "clearredir",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0046D3A8 | 55 | push    rbp\n0x0046D3A9 | 48 89 E5 | mov     rbp, rsp\n0x0046D3AC | 48 83 EC 10 | sub     rsp, 10h\n0x0046D3B0 | 89 7D FC | mov     [rbp+var_4], edi\n0x0046D3B3 | 48 8B 05 4E 00 2F 00 | mov     rax, cs:qword_75D408\n0x0046D3BA | 8B 40 08 | mov     eax, [rax+8]\n0x0046D3BD | 85 C0 | test    eax, eax\n0x0046D3BF | 74 14 | jz      short loc_46D3D5\n0x0046D3C1 | BE C0 68 52 00 | mov     esi, offset aAlarm_0; \"alarm\"\n0x0046D3C6 | BF A5 68 52 00 | mov     edi, offset aInfoSigSReceiv; \"info: sig%s received\"\n0x0046D3CB | B8 00 00 00 00 | mov     eax, 0\n0x0046D3D0 | E8 72 C3 F9 FF | call    sub_409747\n0x0046D3D5 | 48 8B 05 2C 00 2F 00 | mov     rax, cs:qword_75D408\n0x0046D3DC | C6 40 39 01 | mov     byte ptr [rax+39h], 1\n0x0046D3E0 | 90 | nop\n0x0046D3E1 | C9 | leave\n0x0046D3E2 | C3 | retn\n\n Ourput decompiled code:\nstatic void sig_alarm_handler(int sig_no UNUSED_PARAM)\n{\n\tif (verbose)\n\t\tbb_error_msg(INFO\"sig%s received\", \"alarm\");\n\trotateasap = 1;\n}\n\n## Example:\n\n Input assembly code:\n0x0046D3E3 | 55 | push    rbp\n0x0046D3E4 | 48 89 E5 | mov     rbp, rsp\n0x0046D3E7 | 48 83 EC 10 | sub     rsp, 10h\n0x0046D3EB | 89 7D FC | mov     [rbp+var_4], edi\n0x0046D3EE | 48 8B 05 13 00 2F 00 | mov     rax, cs:qword_75D408\n0x0046D3F5 | 8B 40 08 | mov     eax, [rax+8]\n0x0046D3F8 | 85 C0 | test    eax, eax\n0x0046D3FA | 74 14 | jz      short loc_46D410\n0x0046D3FC | BE C6 68 52 00 | mov     esi, offset aHangup_0; \"hangup\"\n0x0046D401 | BF A5 68 52 00 | mov     edi, offset aInfoSigSReceiv; \"info: sig%s received\"\n0x0046D406 | B8 00 00 00 00 | mov     eax, 0\n0x0046D40B | E8 37 C3 F9 FF | call    sub_409747\n0x0046D410 | 48 8B 05 F1 FF 2E 00 | mov     rax, cs:qword_75D408\n0x0046D417 | C6 40 3A 01 | mov     byte ptr [rax+3Ah], 1\n0x0046D41B | 90 | nop\n0x0046D41C | C9 | leave\n0x0046D41D | C3 | retn\n\n Ourput decompiled code:\nstatic void sig_hangup_handler(int sig_no UNUSED_PARAM)\n{\n\tif (verbose)\n\t\tbb_error_msg(INFO\"sig%s received\", \"hangup\");\n\treopenasap = 1;\n}\n\n## Example:\n\n Input assembly code:\n0x004EF418 | 55 | push    rbp\n0x004EF419 | 48 89 E5 | mov     rbp, rsp\n0x004EF41C | 48 83 EC 20 | sub     rsp, 20h\n0x004EF420 | 89 7D EC | mov     [rbp+var_14], edi\n0x004EF423 | 48 8B 05 D6 DF 26 00 | mov     rax, cs:qword_75D400\n0x004EF42A | 8B 00 | mov     eax, [rax]\n0x004EF42C | 89 45 FC | mov     [rbp+var_4], eax\n0x004EF42F | E8 19 FE FF FF | call    sub_4EF24D\n0x004EF434 | 48 8B 05 CD DF 26 00 | mov     rax, cs:qword_75D408\n0x004EF43B | C7 40 4C 00 00 00 00 | mov     dword ptr [rax+4Ch], 0\n0x004EF442 | BF 01 00 00 00 | mov     edi, 1\n0x004EF447 | E8 58 0F 00 00 | call    sub_4F03A4\n0x004EF44C | BE 79 F4 4E 00 | mov     esi, offset sub_4EF479; handler\n0x004EF451 | BF 14 00 00 00 | mov     edi, 14h; sig\n0x004EF456 | E8 15 7C F1 FF | call    _signal\n0x004EF45B | BE 00 00 00 00 | mov     esi, 0; handler\n0x004EF460 | BF 12 00 00 00 | mov     edi, 12h; sig\n0x004EF465 | E8 06 7C F1 FF | call    _signal\n0x004EF46A | 48 8B 05 8F DF 26 00 | mov     rax, cs:qword_75D400\n0x004EF471 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x004EF474 | 89 10 | mov     [rax], edx\n0x004EF476 | 90 | nop\n0x004EF477 | C9 | leave\n0x004EF478 | C3 | retn\n\n Ourput decompiled code:\nstatic void cont_sig(int sig UNUSED_PARAM)\n{\n\tint save_errno = errno;\n\trawmode(); // terminal to \"raw\"\n\tlast_status_cksum = 0; // force status update\n\tredraw(TRUE); // re-draw the screen\n\n\tsignal(SIGTSTP, suspend_sig);\n\tsignal(SIGCONT, SIG_DFL);\n\t//kill(my_pid, SIGCONT); // huh? why? we are already \"continued\"...\n\terrno = save_errno;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00473AA2 | 55 | push    rbp\n0x00473AA3 | 48 89 E5 | mov     rbp, rsp\n0x00473AA6 | 48 83 EC 10 | sub     rsp, 10h\n0x00473AAA | 89 7D FC | mov     [rbp+var_4], edi\n0x00473AAD | 48 8B 05 6C 99 2E 00 | mov     rax, cs:qword_75D420\n0x00473AB4 | C7 40 20 00 00 00 00 | mov     dword ptr [rax+20h], 0\n0x00473ABB | 48 8B 05 5E 99 2E 00 | mov     rax, cs:qword_75D420\n0x00473AC2 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x00473AC6 | 48 85 C0 | test    rax, rax\n0x00473AC9 | 74 11 | jz      short loc_473ADC\n0x00473ACB | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00473ACE | BE 00 00 00 00 | mov     esi, 0\n0x00473AD3 | 89 C7 | mov     edi, eax\n0x00473AD5 | E8 99 FE FF FF | call    sub_473973\n0x00473ADA | EB D1 | jmp     short loc_473AAD\n0x00473ADC | 90 | nop\n0x00473ADD | 90 | nop\n0x00473ADE | C9 | leave\n0x00473ADF | C3 | retn",
        "output": "",
        "source_code": "static void\nclearredir(int drop)\n{\n\tfor (;;) {\n\t\tg_nullredirs = 0;\n\t\tif (!redirlist)\n\t\t\tbreak;\n\t\tpopredir(drop, /*restore:*/ 0);\n\t}\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_473AA2(int a1)\n{\n  __int64 result; // rax\n\n  while ( 1 )\n  {\n    *(_DWORD *)(qword_75D420 + 32) = 0;\n    result = *(_QWORD *)(qword_75D420 + 24);\n    if ( !result )\n      break;\n    sub_473973(a1, 0LL);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl clearredir(int drop)\n{\n  while ( 1 )\n  {\n    ash_ptr_to_globals_var->g_nullredirs = 0;\n    if ( !ash_ptr_to_globals_var->redirlist )\n      break;\n    popredir(drop, 0);\n  }\n}\n",
        "similarity_score_unixcoder": 0.16196981072425842,
        "similarity_score_baseline_stripped": 0.38169553875923157,
        "similarity_score_baseline_debug": 0.8097824454307556
    },
    {
        "func_name": "minix_clrbit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00495E26 | 55 | push    rbp\n0x00495E27 | 48 89 E5 | mov     rbp, rsp\n0x00495E2A | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00495E2E | 89 75 F4 | mov     [rbp+var_C], esi\n0x00495E31 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00495E34 | C1 E8 03 | shr     eax, 3\n0x00495E37 | 89 C6 | mov     esi, eax\n0x00495E39 | 89 F2 | mov     edx, esi\n0x00495E3B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00495E3F | 48 01 D0 | add     rax, rdx\n0x00495E42 | 0F B6 10 | movzx   edx, byte ptr [rax]\n0x00495E45 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00495E48 | 83 E0 07 | and     eax, 7\n0x00495E4B | BF 01 00 00 00 | mov     edi, 1\n0x00495E50 | 89 C1 | mov     ecx, eax\n0x00495E52 | D3 E7 | shl     edi, cl\n0x00495E54 | 89 F8 | mov     eax, edi\n0x00495E56 | 89 C7 | mov     edi, eax\n0x00495E58 | 89 F1 | mov     ecx, esi\n0x00495E5A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00495E5E | 48 01 C8 | add     rax, rcx\n0x00495E61 | 09 FA | or      edx, edi\n0x00495E63 | 88 10 | mov     [rax], dl\n0x00495E65 | 48 8B 05 9C 75 2C 00 | mov     rax, cs:qword_75D408\n0x00495E6C | C6 40 01 01 | mov     byte ptr [rax+1], 1\n0x00495E70 | 90 | nop\n0x00495E71 | 5D | pop     rbp\n0x00495E72 | C3 | retn\n\n Ourput decompiled code:\nstatic void minix_setbit(char *a, unsigned i)\n{\n\tsetbit(a, i);\n\tchanged = 1;\n}\n\n## Example:\n\n Input assembly code:\n0x00495DF1 | 55 | push    rbp\n0x00495DF2 | 48 89 E5 | mov     rbp, rsp\n0x00495DF5 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00495DF9 | 89 75 F4 | mov     [rbp+var_C], esi\n0x00495DFC | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00495DFF | C1 E8 03 | shr     eax, 3\n0x00495E02 | 89 C2 | mov     edx, eax\n0x00495E04 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00495E08 | 48 01 D0 | add     rax, rdx\n0x00495E0B | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00495E0E | 0F BE C0 | movsx   eax, al\n0x00495E11 | 8B 55 F4 | mov     edx, [rbp+var_C]\n0x00495E14 | 83 E2 07 | and     edx, 7\n0x00495E17 | BE 01 00 00 00 | mov     esi, 1\n0x00495E1C | 89 D1 | mov     ecx, edx\n0x00495E1E | D3 E6 | shl     esi, cl\n0x00495E20 | 89 F2 | mov     edx, esi\n0x00495E22 | 21 D0 | and     eax, edx\n0x00495E24 | 5D | pop     rbp\n0x00495E25 | C3 | retn\n\n Ourput decompiled code:\nstatic int minix_bit(const char *a, unsigned i)\n{\n\treturn (a[i >> 3] & (1<<(i & 7)));\n}\n\n## Example:\n\n Input assembly code:\n0x00448EC6 | 55 | push    rbp\n0x00448EC7 | 48 89 E5 | mov     rbp, rsp\n0x00448ECA | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00448ECE | 89 75 F4 | mov     [rbp+var_C], esi\n0x00448ED1 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00448ED4 | 8D 50 3F | lea     edx, [rax+3Fh]\n0x00448ED7 | 85 C0 | test    eax, eax\n0x00448ED9 | 0F 48 C2 | cmovs   eax, edx\n0x00448EDC | C1 F8 06 | sar     eax, 6\n0x00448EDF | 89 C6 | mov     esi, eax\n0x00448EE1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00448EE5 | 48 63 D6 | movsxd  rdx, esi\n0x00448EE8 | 48 83 C2 06 | add     rdx, 6\n0x00448EEC | 48 8B 7C D0 08 | mov     rdi, [rax+rdx*8+8]\n0x00448EF1 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00448EF4 | 99 | cdq\n0x00448EF5 | C1 EA 1A | shr     edx, 1Ah\n0x00448EF8 | 01 D0 | add     eax, edx\n0x00448EFA | 83 E0 3F | and     eax, 3Fh\n0x00448EFD | 29 D0 | sub     eax, edx\n0x00448EFF | BA 01 00 00 00 | mov     edx, 1\n0x00448F04 | 89 C1 | mov     ecx, eax\n0x00448F06 | 48 D3 E2 | shl     rdx, cl\n0x00448F09 | 48 89 D0 | mov     rax, rdx\n0x00448F0C | 48 F7 D0 | not     rax\n0x00448F0F | 48 21 C7 | and     rdi, rax\n0x00448F12 | 48 89 F9 | mov     rcx, rdi\n0x00448F15 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00448F19 | 48 63 D6 | movsxd  rdx, esi\n0x00448F1C | 48 83 C2 06 | add     rdx, 6\n0x00448F20 | 48 89 4C D0 08 | mov     [rax+rdx*8+8], rcx\n0x00448F25 | 90 | nop\n0x00448F26 | 5D | pop     rbp\n0x00448F27 | C3 | retn\n\n Ourput decompiled code:\nvoid isrv_dont_want_rd(isrv_state_t *state, int fd)\n{\n\tFD_CLR(fd, &state->rd);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00495E73 | 55 | push    rbp\n0x00495E74 | 48 89 E5 | mov     rbp, rsp\n0x00495E77 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00495E7B | 89 75 F4 | mov     [rbp+var_C], esi\n0x00495E7E | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00495E81 | C1 E8 03 | shr     eax, 3\n0x00495E84 | 89 C6 | mov     esi, eax\n0x00495E86 | 89 F2 | mov     edx, esi\n0x00495E88 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00495E8C | 48 01 D0 | add     rax, rdx\n0x00495E8F | 0F B6 10 | movzx   edx, byte ptr [rax]\n0x00495E92 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00495E95 | 83 E0 07 | and     eax, 7\n0x00495E98 | BF 01 00 00 00 | mov     edi, 1\n0x00495E9D | 89 C1 | mov     ecx, eax\n0x00495E9F | D3 E7 | shl     edi, cl\n0x00495EA1 | 89 F8 | mov     eax, edi\n0x00495EA3 | F7 D0 | not     eax\n0x00495EA5 | 89 C1 | mov     ecx, eax\n0x00495EA7 | 89 F6 | mov     esi, esi\n0x00495EA9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00495EAD | 48 01 F0 | add     rax, rsi\n0x00495EB0 | 21 CA | and     edx, ecx\n0x00495EB2 | 88 10 | mov     [rax], dl\n0x00495EB4 | 48 8B 05 4D 75 2C 00 | mov     rax, cs:qword_75D408\n0x00495EBB | C6 40 01 01 | mov     byte ptr [rax+1], 1\n0x00495EBF | 90 | nop\n0x00495EC0 | 5D | pop     rbp\n0x00495EC1 | C3 | retn",
        "output": "\n\nstatic void minix_clearbit(char *a, unsigned i)\n{\n\ta[i >> 3] &= ~(1<<(i & 7));\n\tchanged = 1;\n}",
        "source_code": "static void minix_clrbit(char *a, unsigned i)\n{\n\tclrbit(a, i);\n\tchanged = 1;\n}",
        "parsed_output": "\n\nstatic void minix_clearbit(char *a, unsigned i)\n{\n\ta[i >> 3] &= ~(1<<(i & 7));\n\tchanged = 1;\n}",
        "baseline_code_stripped": "void *__fastcall sub_495E73(__int64 a1, unsigned int a2)\n{\n  void *result; // rax\n\n  *(_BYTE *)((a2 >> 3) + a1) &= ~(1 << (a2 & 7));\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 1) = 1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl minix_clrbit(char *a, unsigned int i)\n{\n  a[i >> 3] &= ~(1 << (i & 7));\n  BYTE1(ptr_to_globals->timeout) = 1;\n}\n",
        "similarity_score_unixcoder": 0.9161927700042725,
        "similarity_score_baseline_stripped": 0.49454984068870544,
        "similarity_score_baseline_debug": 0.7167501449584961
    },
    {
        "func_name": "str2env",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004B712D | 55 | push    rbp\n0x004B712E | 48 89 E5 | mov     rbp, rsp\n0x004B7131 | 53 | push    rbx\n0x004B7132 | 48 83 EC 28 | sub     rsp, 28h\n0x004B7136 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004B713A | 89 75 E4 | mov     [rbp+var_1C], esi\n0x004B713D | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x004B7141 | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x004B7144 | 48 98 | cdqe\n0x004B7146 | 48 8B 04 C5 A0 29 52 00 | mov     rax, ds:off_5229A0[rax*8]; \"MODE\"\n0x004B714E | 8B 55 E4 | mov     edx, [rbp+var_1C]\n0x004B7151 | 48 63 D2 | movsxd  rdx, edx\n0x004B7154 | 48 8D 0C D5 00 00 00 00 | lea     rcx, ds:0[rdx*8]\n0x004B715C | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x004B7160 | 48 8D 1C 11 | lea     rbx, [rcx+rdx]\n0x004B7164 | 48 8B 55 D8 | mov     rdx, [rbp+var_28]\n0x004B7168 | 48 89 C6 | mov     rsi, rax\n0x004B716B | BF EA 29 52 00 | mov     edi, offset aTarSLlu; \"TAR_%s=%llu\"\n0x004B7170 | B8 00 00 00 00 | mov     eax, 0\n0x004B7175 | E8 39 35 F5 FF | call    sub_40A6B3\n0x004B717A | 48 89 03 | mov     [rbx], rax\n0x004B717D | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x004B7180 | 48 98 | cdqe\n0x004B7182 | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]\n0x004B718A | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004B718E | 48 01 D0 | add     rax, rdx\n0x004B7191 | 48 8B 00 | mov     rax, [rax]\n0x004B7194 | 48 89 C7 | mov     rdi, rax\n0x004B7197 | E8 EC FE FF FF | call    sub_4B7088\n0x004B719C | 90 | nop\n0x004B719D | 48 83 C4 28 | add     rsp, 28h\n0x004B71A1 | 5B | pop     rbx\n0x004B71A2 | 5D | pop     rbp\n0x004B71A3 | C3 | retn\n\n Ourput decompiled code:\nstatic void dec2env(char *env[], int idx, unsigned long long val)\n{\n\tenv[idx] = xasprintf(\"TAR_%s=%llu\", tar_var[idx], val);\n\txputenv(env[idx]);\n}\n\n## Example:\n\n Input assembly code:\n0x004B71A4 | 55 | push    rbp\n0x004B71A5 | 48 89 E5 | mov     rbp, rsp\n0x004B71A8 | 53 | push    rbx\n0x004B71A9 | 48 83 EC 28 | sub     rsp, 28h\n0x004B71AD | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004B71B1 | 89 75 E4 | mov     [rbp+var_1C], esi\n0x004B71B4 | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x004B71B8 | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x004B71BB | 48 98 | cdqe\n0x004B71BD | 48 8B 04 C5 A0 29 52 00 | mov     rax, ds:off_5229A0[rax*8]; \"MODE\"\n0x004B71C5 | 8B 55 E4 | mov     edx, [rbp+var_1C]\n0x004B71C8 | 48 63 D2 | movsxd  rdx, edx\n0x004B71CB | 48 8D 0C D5 00 00 00 00 | lea     rcx, ds:0[rdx*8]\n0x004B71D3 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x004B71D7 | 48 8D 1C 11 | lea     rbx, [rcx+rdx]\n0x004B71DB | 48 8B 55 D8 | mov     rdx, [rbp+var_28]\n0x004B71DF | 48 89 C6 | mov     rsi, rax\n0x004B71E2 | BF F6 29 52 00 | mov     edi, offset aTarSLo; \"TAR_%s=%lo\"\n0x004B71E7 | B8 00 00 00 00 | mov     eax, 0\n0x004B71EC | E8 C2 34 F5 FF | call    sub_40A6B3\n0x004B71F1 | 48 89 03 | mov     [rbx], rax\n0x004B71F4 | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x004B71F7 | 48 98 | cdqe\n0x004B71F9 | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]\n0x004B7201 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004B7205 | 48 01 D0 | add     rax, rdx\n0x004B7208 | 48 8B 00 | mov     rax, [rax]\n0x004B720B | 48 89 C7 | mov     rdi, rax\n0x004B720E | E8 75 FE FF FF | call    sub_4B7088\n0x004B7213 | 90 | nop\n0x004B7214 | 48 83 C4 28 | add     rsp, 28h\n0x004B7218 | 5B | pop     rbx\n0x004B7219 | 5D | pop     rbp\n0x004B721A | C3 | retn\n\n Ourput decompiled code:\nstatic void oct2env(char *env[], int idx, unsigned long val)\n{\n\tenv[idx] = xasprintf(\"TAR_%s=%lo\", tar_var[idx], val);\n\txputenv(env[idx]);\n}\n\n## Example:\n\n Input assembly code:\n0x00463151 | 55 | push    rbp\n0x00463152 | 48 89 E5 | mov     rbp, rsp\n0x00463155 | 53 | push    rbx\n0x00463156 | 48 83 EC 28 | sub     rsp, 28h\n0x0046315A | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0046315E | 89 75 E4 | mov     [rbp+var_1C], esi\n0x00463161 | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x00463165 | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x00463168 | 83 C0 01 | add     eax, 1\n0x0046316B | 48 63 D8 | movsxd  rbx, eax\n0x0046316E | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00463172 | 8B 40 68 | mov     eax, [rax+68h]\n0x00463175 | 89 C7 | mov     edi, eax\n0x00463177 | E8 CA 01 0A 00 | call    sub_503346\n0x0046317C | 48 89 C1 | mov     rcx, rax\n0x0046317F | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00463183 | 48 89 DA | mov     rdx, rbx\n0x00463186 | 48 89 CE | mov     rsi, rcx\n0x00463189 | 48 89 C7 | mov     rdi, rax\n0x0046318C | E8 2F 4E 0A 00 | call    sub_507FC0\n0x00463191 | 90 | nop\n0x00463192 | 48 83 C4 28 | add     rsp, 28h\n0x00463196 | 5B | pop     rbx\n0x00463197 | 5D | pop     rbp\n0x00463198 | C3 | retn\n\n Ourput decompiled code:\nstatic void func_user(char *buf, int size, const procps_status_t *ps)\n{\n#if 1\n\tsafe_strncpy(buf, get_cached_username(ps->uid), size+1);\n#else\n\t/* \"compatible\" version, but it's larger */\n\t/* procps 2.18 shows numeric UID if name overflows the field */\n\t/* TODO: get_cached_username() returns numeric string if\n\t * user has no passwd record, we will display it\n\t * left-justified here; too long usernames are shown\n\t * as _right-justified_ IDs. Is it worth fixing? */\n\tconst char *user = get_cached_username(ps->uid);\n\tif (strlen(user) <= size)\n\t\tsafe_strncpy(buf, user, size+1);\n\telse\n\t\tsprintf(buf, \"%*u\", size, (unsigned)ps->uid);\n#endif\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004B70B6 | 55 | push    rbp\n0x004B70B7 | 48 89 E5 | mov     rbp, rsp\n0x004B70BA | 53 | push    rbx\n0x004B70BB | 48 83 EC 28 | sub     rsp, 28h\n0x004B70BF | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004B70C3 | 89 75 E4 | mov     [rbp+var_1C], esi\n0x004B70C6 | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x004B70CA | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x004B70CD | 48 98 | cdqe\n0x004B70CF | 48 8B 04 C5 A0 29 52 00 | mov     rax, ds:off_5229A0[rax*8]; \"MODE\"\n0x004B70D7 | 8B 55 E4 | mov     edx, [rbp+var_1C]\n0x004B70DA | 48 63 D2 | movsxd  rdx, edx\n0x004B70DD | 48 8D 0C D5 00 00 00 00 | lea     rcx, ds:0[rdx*8]\n0x004B70E5 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x004B70E9 | 48 8D 1C 11 | lea     rbx, [rcx+rdx]\n0x004B70ED | 48 8B 55 D8 | mov     rdx, [rbp+var_28]\n0x004B70F1 | 48 89 C6 | mov     rsi, rax\n0x004B70F4 | BF E0 29 52 00 | mov     edi, offset aTarSS; \"TAR_%s=%s\"\n0x004B70F9 | B8 00 00 00 00 | mov     eax, 0\n0x004B70FE | E8 B0 35 F5 FF | call    sub_40A6B3\n0x004B7103 | 48 89 03 | mov     [rbx], rax\n0x004B7106 | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x004B7109 | 48 98 | cdqe\n0x004B710B | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]\n0x004B7113 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004B7117 | 48 01 D0 | add     rax, rdx\n0x004B711A | 48 8B 00 | mov     rax, [rax]\n0x004B711D | 48 89 C7 | mov     rdi, rax\n0x004B7120 | E8 63 FF FF FF | call    sub_4B7088\n0x004B7125 | 90 | nop\n0x004B7126 | 48 83 C4 28 | add     rsp, 28h\n0x004B712A | 5B | pop     rbx\n0x004B712B | 5D | pop     rbp\n0x004B712C | C3 | retn",
        "output": "\n\nstatic void str2env(char *env[], int idx, const char *str)\n{\n\tenv[idx] = xasprintf(\"TAR_%s=%s\", tar_var[idx], str);\n\txputenv(env[idx]);\n}",
        "source_code": "static void str2env(char *env[], int idx, const char *str)\n{\n\tenv[idx] = xasprintf(\"TAR_%s=%s\", tar_var[idx], str);\n\txputenv(env[idx]);\n}",
        "parsed_output": "\n\nstatic void str2env(char *env[], int idx, const char *str)\n{\n\tenv[idx] = xasprintf(\"TAR_%s=%s\", tar_var[idx], str);\n\txputenv(env[idx]);\n}",
        "baseline_code_stripped": "int __fastcall sub_4B70B6(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  unsigned __int64 v6; // rcx\n  char *v7; // rsi\n\n  v6 = 8LL * a2;\n  v7 = off_5229A0[v6 / 8];\n  *(_QWORD *)(v6 + a1) = sub_40A6B3(\"TAR_%s=%s\", (__int64)v7, a3, v6, a5, a6);\n  return sub_4B7088(*(char **)(8LL * a2 + a1), (__int64)v7);\n}\n",
        "baseline_code_debug": "void __cdecl str2env(char **env, int idx, const char *str)\n{\n  env[idx] = xasprintf(\"TAR_%s=%s\", tar_var[idx], str);\n  xputenv(env[idx]);\n}\n",
        "similarity_score_unixcoder": 0.9869676828384399,
        "similarity_score_baseline_stripped": 0.39911532402038574,
        "similarity_score_baseline_debug": 0.9627740383148193
    },
    {
        "func_name": "close_dev_fd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004F4F3E | 55 | push    rbp\n0x004F4F3F | 48 89 E5 | mov     rbp, rsp\n0x004F4F42 | BE 00 00 00 00 | mov     esi, 0\n0x004F4F47 | BF 0E 94 18 00 | mov     edi, 18940Eh\n0x004F4F4C | E8 B0 32 01 00 | call    sub_508201\n0x004F4F51 | BF 01 00 00 00 | mov     edi, 1\n0x004F4F56 | E8 6E 32 01 00 | call    sub_5081C9\n0x004F4F5B | 90 | nop\n0x004F4F5C | 5D | pop     rbp\n0x004F4F5D | C3 | retn\n\n Ourput decompiled code:\nstatic void reset_sighandlers_and_unblock_sigs(void)\n{\n\tbb_signals(0\n\t\t+ (1 << SIGUSR1)\n\t\t+ (1 << SIGUSR2)\n\t\t+ (1 << SIGTERM)\n\t\t+ (1 << SIGQUIT)\n\t\t+ (1 << SIGINT)\n\t\t+ (1 << SIGHUP)\n\t\t+ (1 << SIGTSTP)\n\t\t+ (1 << SIGSTOP)\n\t\t, SIG_DFL);\n\tsigprocmask_allsigs(SIG_UNBLOCK);\n}\n\n## Example:\n\n Input assembly code:\n0x0041A18F | 55 | push    rbp\n0x0041A190 | 48 89 E5 | mov     rbp, rsp\n0x0041A193 | BA 00 00 00 00 | mov     edx, 0\n0x0041A198 | BE 00 00 00 00 | mov     esi, 0\n0x0041A19D | BF 03 00 00 00 | mov     edi, 3\n0x0041A1A2 | E8 B0 03 FF FF | call    sub_40A557\n0x0041A1A7 | 90 | nop\n0x0041A1A8 | 5D | pop     rbp\n0x0041A1A9 | C3 | retn\n\n Ourput decompiled code:\nstatic void seek_to_zero(/*int fd*/ void)\n{\n\txlseek(fd, (off_t) 0, SEEK_SET);\n}\n\n## Example:\n\n Input assembly code:\n0x0048C1FD | 55 | push    rbp\n0x0048C1FE | 48 89 E5 | mov     rbp, rsp\n0x0048C201 | BA 00 00 00 00 | mov     edx, 0; len\n0x0048C206 | BE 00 00 00 00 | mov     esi, 0; bufp\n0x0048C20B | BF 01 00 00 00 | mov     edi, 1; type\n0x0048C210 | E8 FB B1 F7 FF | call    _klogctl\n0x0048C215 | 90 | nop\n0x0048C216 | 5D | pop     rbp\n0x0048C217 | C3 | retn\n\n Ourput decompiled code:\nstatic void klogd_open(void)\n{\n\t/* \"Open the log. Currently a NOP\" */\n\tklogctl(1, NULL, 0);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00490398 | 55 | push    rbp\n0x00490399 | 48 89 E5 | mov     rbp, rsp\n0x0049039C | BE 00 00 00 00 | mov     esi, 0\n0x004903A1 | BF C1 06 52 00 | mov     edi, offset aDevNull_2; \"/dev/null\"\n0x004903A6 | E8 EA 9E F7 FF | call    sub_40A295\n0x004903AB | BE 03 00 00 00 | mov     esi, 3\n0x004903B0 | 89 C7 | mov     edi, eax\n0x004903B2 | E8 C0 A0 F7 FF | call    sub_40A477\n0x004903B7 | 90 | nop\n0x004903B8 | 5D | pop     rbp\n0x004903B9 | C3 | retn",
        "output": "\n\nstatic void klogd_close(void)\n{\n\t/* \"Close the log. Currently a NOP\" */\n\tclose(open((char *)&aDevNull_2, 0, 3));\n}",
        "source_code": "static void\nclose_dev_fd(void)\n{\n\t/* Not really closing, but making sure it is open, and to harmless place */\n\txmove_fd(xopen(bb_dev_null, O_RDONLY), dev_fd);\n}",
        "parsed_output": "\n\nstatic void klogd_close(void)\n{\n\t/* \"Close the log. Currently a NOP\" */\n\tclose(open((char *)&aDevNull_2, 0, 3));\n}",
        "baseline_code_stripped": "int sub_490398()\n{\n  int v0; // eax\n\n  v0 = sub_40A295(\"/dev/null\", 0);\n  return sub_40A477(v0, 3u);\n}\n",
        "baseline_code_debug": "void __cdecl close_dev_fd()\n{\n  int v0; // eax\n\n  v0 = xopen(\"/dev/null\", 0);\n  xmove_fd(v0, 3);\n}\n",
        "similarity_score_unixcoder": 0.6765080094337463,
        "similarity_score_baseline_stripped": 0.4572550654411316,
        "similarity_score_baseline_debug": 0.7473095059394836
    },
    {
        "func_name": "set_changed",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00490C6D | 55 | push    rbp\n0x00490C6E | 48 89 E5 | mov     rbp, rsp\n0x00490C71 | 89 7D FC | mov     [rbp+var_4], edi\n0x00490C74 | 48 8B 0D 8D C7 2C 00 | mov     rcx, cs:qword_75D408\n0x00490C7B | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00490C7E | 48 63 D0 | movsxd  rdx, eax\n0x00490C81 | 48 89 D0 | mov     rax, rdx\n0x00490C84 | 48 C1 E0 02 | shl     rax, 2\n0x00490C88 | 48 01 D0 | add     rax, rdx\n0x00490C8B | 48 C1 E0 03 | shl     rax, 3\n0x00490C8F | 48 01 C8 | add     rax, rcx\n0x00490C92 | 48 05 C8 09 00 00 | add     rax, 9C8h\n0x00490C98 | 48 8B 00 | mov     rax, [rax]\n0x00490C9B | 0F B6 40 04 | movzx   eax, byte ptr [rax+4]\n0x00490C9F | 0F B6 C0 | movzx   eax, al\n0x00490CA2 | 5D | pop     rbp\n0x00490CA3 | C3 | retn\n\n Ourput decompiled code:\nif ENABLE_FEATURE_FDISK_WRITABLE\nstatic int\nget_sysid(int i)\n{\n\treturn LABEL_IS_SUN ? sunlabel->infos[i].id :\n\t\t\t(LABEL_IS_SGI ? sgi_get_sysid(i) :\n\t\t\t\tptes[i].part_table->sys_ind);\n}\n\n## Example:\n\n Input assembly code:\n0x004ED405 | 55 | push    rbp\n0x004ED406 | 48 89 E5 | mov     rbp, rsp\n0x004ED409 | 89 7D FC | mov     [rbp+var_4], edi\n0x004ED40C | 48 8B 05 F5 FF 26 00 | mov     rax, cs:qword_75D408\n0x004ED413 | 8B 40 6C | mov     eax, [rax+6Ch]\n0x004ED416 | 8D 70 FF | lea     esi, [rax-1]\n0x004ED419 | 48 8B 05 E8 FF 26 00 | mov     rax, cs:qword_75D408\n0x004ED420 | 8B 48 6C | mov     ecx, [rax+6Ch]\n0x004ED423 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004ED426 | 99 | cdq\n0x004ED427 | F7 F9 | idiv    ecx\n0x004ED429 | 89 D0 | mov     eax, edx\n0x004ED42B | 29 C6 | sub     esi, eax\n0x004ED42D | 89 F2 | mov     edx, esi\n0x004ED42F | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004ED432 | 01 D0 | add     eax, edx\n0x004ED434 | 5D | pop     rbp\n0x004ED435 | C3 | retn\n\n Ourput decompiled code:\nstatic int next_tabstop(int col)\n{\n\treturn col + ((tabstop - 1) - (col % tabstop));\n}\n\n## Example:\n\n Input assembly code:\n0x00458611 | 55 | push    rbp\n0x00458612 | 48 89 E5 | mov     rbp, rsp\n0x00458615 | 89 7D EC | mov     [rbp+var_14], edi\n0x00458618 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x0045861F | EB 44 | jmp     short loc_458665\n0x00458621 | 48 8B 0D E8 4D 30 00 | mov     rcx, cs:qword_75D410\n0x00458628 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x0045862B | 48 89 D0 | mov     rax, rdx\n0x0045862E | 48 C1 E0 03 | shl     rax, 3\n0x00458632 | 48 01 D0 | add     rax, rdx\n0x00458635 | 48 C1 E0 02 | shl     rax, 2\n0x00458639 | 48 01 C8 | add     rax, rcx\n0x0045863C | 8B 40 04 | mov     eax, [rax+4]\n0x0045863F | 39 45 EC | cmp     [rbp+var_14], eax\n0x00458642 | 75 1D | jnz     short loc_458661\n0x00458644 | 48 8B 0D C5 4D 30 00 | mov     rcx, cs:qword_75D410\n0x0045864B | 8B 55 FC | mov     edx, [rbp+var_4]\n0x0045864E | 48 89 D0 | mov     rax, rdx\n0x00458651 | 48 C1 E0 03 | shl     rax, 3\n0x00458655 | 48 01 D0 | add     rax, rdx\n0x00458658 | 48 C1 E0 02 | shl     rax, 2\n0x0045865C | 48 01 C8 | add     rax, rcx\n0x0045865F | EB 16 | jmp     short loc_458677\n0x00458661 | 83 45 FC 01 | add     [rbp+var_4], 1\n0x00458665 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0045866A | 8B 40 30 | mov     eax, [rax+30h]\n0x0045866D | 39 45 FC | cmp     [rbp+var_4], eax\n0x00458670 | 72 AF | jb      short loc_458621\n0x00458672 | B8 00 00 00 00 | mov     eax, 0\n0x00458677 | 5D | pop     rbp\n0x00458678 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC find_lease_by_nip(uint32_t nip)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < server_config.max_leases; i++)\n\t\tif (g_leases[i].lease_nip == nip)\n\t\t\treturn &g_leases[i];\n\n\treturn NULL;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00490725 | 55 | push    rbp\n0x00490726 | 48 89 E5 | mov     rbp, rsp\n0x00490729 | 89 7D FC | mov     [rbp+var_4], edi\n0x0049072C | 48 8B 0D D5 CC 2C 00 | mov     rcx, cs:qword_75D408\n0x00490733 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00490736 | 48 63 D0 | movsxd  rdx, eax\n0x00490739 | 48 89 D0 | mov     rax, rdx\n0x0049073C | 48 C1 E0 02 | shl     rax, 2\n0x00490740 | 48 01 D0 | add     rax, rdx\n0x00490743 | 48 C1 E0 03 | shl     rax, 3\n0x00490747 | 48 01 C8 | add     rax, rcx\n0x0049074A | 48 05 E8 09 00 00 | add     rax, 9E8h\n0x00490750 | C6 00 01 | mov     byte ptr [rax], 1\n0x00490753 | 90 | nop\n0x00490754 | 5D | pop     rbp\n0x00490755 | C3 | retn",
        "output": "",
        "source_code": "static ALWAYS_INLINE void\nset_changed(int i)\n{\n\tptes[i].changed = 1;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "_BYTE *__fastcall sub_490725(int a1)\n{\n  _BYTE *result; // rax\n\n  result = (char *)qword_75D408 + 40 * a1 + 2536;\n  *result = 1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl set_changed(int i)\n{\n  ptr_to_globals[8].line_buf[40 * i + 76] = 1;\n}\n",
        "similarity_score_unixcoder": 0.18142622709274292,
        "similarity_score_baseline_stripped": 0.3783988952636719,
        "similarity_score_baseline_debug": 0.6713061928749084
    },
    {
        "func_name": "xprint_and_close_file",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004C4489 | 55 | push    rbp\n0x004C448A | 48 89 E5 | mov     rbp, rsp\n0x004C448D | 48 83 EC 10 | sub     rsp, 10h\n0x004C4491 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004C4495 | E8 16 34 F4 FF | call    _vfork\n0x004C449A | 85 C0 | test    eax, eax\n0x004C449C | 75 2A | jnz     short loc_4C44C8\n0x004C449E | E8 CD 29 F4 FF | call    _setsid\n0x004C44A3 | BA 00 00 00 00 | mov     edx, 0\n0x004C44A8 | BE 0E 54 00 00 | mov     esi, 540Eh; request\n0x004C44AD | BF 00 00 00 00 | mov     edi, 0; fd\n0x004C44B2 | B8 00 00 00 00 | mov     eax, 0\n0x004C44B7 | E8 E4 28 F4 FF | call    _ioctl\n0x004C44BC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C44C0 | 48 89 C7 | mov     rdi, rax\n0x004C44C3 | E8 55 4E 03 00 | call    sub_4F931D\n0x004C44C8 | 90 | nop\n0x004C44C9 | C9 | leave\n0x004C44CA | C3 | retn\n\n Ourput decompiled code:\nstatic NOINLINE void vfork_child(char **argv)\n{\n\tif (vfork() == 0) {\n\t\t/* CHILD */\n\t\t/* Try to make this VT our controlling tty */\n\t\tsetsid(); /* lose old ctty */\n\t\tioctl(STDIN_FILENO, TIOCSCTTY, 0 /* 0: don't forcibly steal */);\n\t\t//bb_error_msg(\"our sid %d\", getsid(0));\n\t\t//bb_error_msg(\"our pgrp %d\", getpgrp());\n\t\t//bb_error_msg(\"VT's sid %d\", tcgetsid(0));\n\t\t//bb_error_msg(\"VT's pgrp %d\", tcgetpgrp(0));\n\t\tBB_EXECVP_or_die(argv);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x00509D73 | 55 | push    rbp\n0x00509D74 | 48 89 E5 | mov     rbp, rsp\n0x00509D77 | 48 83 EC 10 | sub     rsp, 10h\n0x00509D7B | 48 89 7D F8 | mov     [rbp+name], rdi\n0x00509D7F | 48 8B 45 F8 | mov     rax, [rbp+name]\n0x00509D83 | BE 06 00 00 00 | mov     esi, 6; type\n0x00509D88 | 48 89 C7 | mov     rdi, rax; name\n0x00509D8B | E8 60 DA EF FF | call    _access\n0x00509D90 | 83 F8 FF | cmp     eax, 0FFFFFFFFh\n0x00509D93 | 75 22 | jnz     short loc_509DB7\n0x00509D95 | 48 8B 45 F8 | mov     rax, [rbp+name]\n0x00509D99 | BA B4 01 00 00 | mov     edx, 1B4h\n0x00509D9E | BE 41 00 00 00 | mov     esi, 41h ; 'A'; oflag\n0x00509DA3 | 48 89 C7 | mov     rdi, rax; file\n0x00509DA6 | B8 00 00 00 00 | mov     eax, 0\n0x00509DAB | E8 20 D9 EF FF | call    _open64\n0x00509DB0 | 89 C7 | mov     edi, eax; fd\n0x00509DB2 | E8 59 D0 EF FF | call    _close\n0x00509DB7 | 90 | nop\n0x00509DB8 | C9 | leave\n0x00509DB9 | C3 | retn\n\n Ourput decompiled code:\nstatic void touch(const char *filename)\n{\n\tif (access(filename, R_OK | W_OK) == -1)\n\t\tclose(open(filename, O_WRONLY | O_CREAT, 0664));\n}\n\n## Example:\n\n Input assembly code:\n0x0040A8DC | 55 | push    rbp\n0x0040A8DD | 48 89 E5 | mov     rbp, rsp\n0x0040A8E0 | 48 83 EC 10 | sub     rsp, 10h\n0x0040A8E4 | 48 89 7D F8 | mov     [rbp+path], rdi\n0x0040A8E8 | 48 8B 45 F8 | mov     rax, [rbp+path]\n0x0040A8EC | 48 89 C7 | mov     rdi, rax; path\n0x0040A8EF | E8 EC BE FF FF | call    _chroot\n0x0040A8F4 | 85 C0 | test    eax, eax\n0x0040A8F6 | 74 16 | jz      short loc_40A90E\n0x0040A8F8 | 48 8B 45 F8 | mov     rax, [rbp+path]\n0x0040A8FC | 48 89 C6 | mov     rsi, rax\n0x0040A8FF | BF 08 81 52 00 | mov     edi, offset aCanTChangeRoot; \"can't change root directory to '%s'\"\n0x0040A904 | B8 00 00 00 00 | mov     eax, 0\n0x0040A909 | E8 94 E9 FF FF | call    sub_4092A2\n0x0040A90E | BF 2C 81 52 00 | mov     edi, offset asc_52812C; \"/\"\n0x0040A913 | E8 8F FF FF FF | call    sub_40A8A7\n0x0040A918 | 90 | nop\n0x0040A919 | C9 | leave\n0x0040A91A | C3 | retn\n\n Ourput decompiled code:\nvoid FAST_FUNC xchroot(const char *path)\n{\n\tif (chroot(path))\n\t\tbb_perror_msg_and_die(\"can't change root directory to '%s'\", path);\n\txchdir(\"/\");\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040A670 | 55 | push    rbp\n0x0040A671 | 48 89 E5 | mov     rbp, rsp\n0x0040A674 | 48 83 EC 10 | sub     rsp, 10h\n0x0040A678 | 48 89 7D F8 | mov     [rbp+stream], rdi\n0x0040A67C | E8 C8 FF FF FF | call    sub_40A649\n0x0040A681 | 48 8B 45 F8 | mov     rax, [rbp+stream]\n0x0040A685 | 48 89 C7 | mov     rdi, rax; stream\n0x0040A688 | E8 D3 CB FF FF | call    _fileno\n0x0040A68D | BE 01 00 00 00 | mov     esi, 1\n0x0040A692 | 89 C7 | mov     edi, eax\n0x0040A694 | E8 CD 0C 00 00 | call    sub_40B366\n0x0040A699 | 48 83 F8 FF | cmp     rax, 0FFFFFFFFFFFFFFFFh\n0x0040A69D | 75 05 | jnz     short loc_40A6A4\n0x0040A69F | E8 8B F2 FF FF | call    sub_40992F\n0x0040A6A4 | 48 8B 45 F8 | mov     rax, [rbp+stream]\n0x0040A6A8 | 48 89 C7 | mov     rdi, rax; stream\n0x0040A6AB | E8 50 C3 FF FF | call    _fclose\n0x0040A6B0 | 90 | nop\n0x0040A6B1 | C9 | leave\n0x0040A6B2 | C3 | retn",
        "output": "\n\nvoid FAST_FUNC xfclose(FILE *stream)\n{\n\txfflush(stream);\n\tif (xclose(fileno(stream), 1) == -1)\n\t\tbb_perror_nomsg();\n\tfclose(stream);\n}",
        "source_code": "void FAST_FUNC xprint_and_close_file(FILE *file)\n{\n\tfflush_all();\n\t// copyfd outputs error messages for us.\n\tif (bb_copyfd_eof(fileno(file), STDOUT_FILENO) == -1)\n\t\txfunc_die();\n\n\tfclose(file);\n}",
        "parsed_output": "\n\nvoid FAST_FUNC xfclose(FILE *stream)\n{\n\txfflush(stream);\n\tif (xclose(fileno(stream), 1) == -1)\n\t\tbb_perror_nomsg();\n\tfclose(stream);\n}",
        "baseline_code_stripped": "int __fastcall sub_40A670(FILE *a1)\n{\n  unsigned int v1; // eax\n\n  sub_40A649();\n  v1 = fileno(a1);\n  if ( sub_40B366(v1, 1LL) == -1 )\n    sub_40992F();\n  return fclose(a1);\n}\n",
        "baseline_code_debug": "void __cdecl xprint_and_close_file(FILE *file)\n{\n  int v1; // eax\n\n  fflush_all();\n  v1 = fileno(file);\n  if ( bb_copyfd_eof(v1, 1) == -1 )\n    xfunc_die();\n  fclose(file);\n}\n",
        "similarity_score_unixcoder": 0.8389345407485962,
        "similarity_score_baseline_stripped": 0.604171872138977,
        "similarity_score_baseline_debug": 0.8830003142356873
    },
    {
        "func_name": "func_tty",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00417CF4 | 55 | push    rbp\n0x00417CF5 | 48 89 E5 | mov     rbp, rsp\n0x00417CF8 | 48 83 EC 20 | sub     rsp, 20h\n0x00417CFC | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00417D00 | 89 75 F4 | mov     [rbp+var_C], esi\n0x00417D03 | 48 89 55 E8 | mov     [rbp+var_18], rdx\n0x00417D07 | 89 4D F0 | mov     [rbp+var_10], ecx\n0x00417D0A | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00417D0D | 48 98 | cdqe\n0x00417D0F | 48 8D 14 00 | lea     rdx, [rax+rax]\n0x00417D13 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00417D17 | 48 01 D0 | add     rax, rdx\n0x00417D1A | 0F B7 00 | movzx   eax, word ptr [rax]\n0x00417D1D | 66 85 C0 | test    ax, ax\n0x00417D20 | 74 33 | jz      short loc_417D55\n0x00417D22 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00417D26 | 48 89 C6 | mov     rsi, rax\n0x00417D29 | BF 0B 53 51 00 | mov     edi, offset a20s; \"\\t%-20s\"\n0x00417D2E | B8 00 00 00 00 | mov     eax, 0\n0x00417D33 | E8 98 EE FE FF | call    _printf\n0x00417D38 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00417D3B | 48 98 | cdqe\n0x00417D3D | 48 8D 14 00 | lea     rdx, [rax+rax]\n0x00417D41 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00417D45 | 48 01 C2 | add     rdx, rax\n0x00417D48 | 8B 45 F0 | mov     eax, [rbp+var_10]\n0x00417D4B | 89 C6 | mov     esi, eax\n0x00417D4D | 48 89 D7 | mov     rdi, rdx\n0x00417D50 | E8 0F FF FF FF | call    sub_417C64\n0x00417D55 | 90 | nop\n0x00417D56 | C9 | leave\n0x00417D57 | C3 | retn\n\n Ourput decompiled code:\nstatic void xprint_ascii(uint16_t *val, int i, const char *string, int n)\n{\n\tif (val[i]) {\n\t\tprintf(\"\\t%-20s\", string);\n\t\tprint_ascii((void*)&val[i], n);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x00481463 | 55 | push    rbp\n0x00481464 | 48 89 E5 | mov     rbp, rsp\n0x00481467 | 48 83 EC 10 | sub     rsp, 10h\n0x0048146B | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0048146F | 89 75 F4 | mov     [rbp+var_C], esi\n0x00481472 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00481476 | BE 01 00 00 00 | mov     esi, 1\n0x0048147B | 48 89 C7 | mov     rdi, rax\n0x0048147E | E8 68 FF FF FF | call    sub_4813EB\n0x00481483 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00481487 | 48 8B 10 | mov     rdx, [rax]\n0x0048148A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048148E | 8B 40 08 | mov     eax, [rax+8]\n0x00481491 | 48 98 | cdqe\n0x00481493 | 48 01 D0 | add     rax, rdx\n0x00481496 | 8B 55 F4 | mov     edx, [rbp+var_C]\n0x00481499 | 88 10 | mov     [rax], dl\n0x0048149B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048149F | 8B 40 08 | mov     eax, [rax+8]\n0x004814A2 | 8D 50 01 | lea     edx, [rax+1]\n0x004814A5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004814A9 | 89 50 08 | mov     [rax+8], edx\n0x004814AC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004814B0 | 48 8B 10 | mov     rdx, [rax]\n0x004814B3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004814B7 | 8B 40 08 | mov     eax, [rax+8]\n0x004814BA | 48 98 | cdqe\n0x004814BC | 48 01 D0 | add     rax, rdx\n0x004814BF | C6 00 00 | mov     byte ptr [rax], 0\n0x004814C2 | 90 | nop\n0x004814C3 | C9 | leave\n0x004814C4 | C3 | retn\n\n Ourput decompiled code:\nstatic void o_addchr(o_string *o, int ch)\n{\n\tdebug_printf(\"o_addchr: '%c' o->length=%d o=%p\\n\", ch, o->length, o);\n\to_grow_by(o, 1);\n\to->data[o->length] = ch;\n\to->length++;\n\to->data[o->length] = '\\0';\n}\n\n## Example:\n\n Input assembly code:\n0x004D39DE | 55 | push    rbp\n0x004D39DF | 48 89 E5 | mov     rbp, rsp\n0x004D39E2 | 48 83 EC 20 | sub     rsp, 20h\n0x004D39E6 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004D39EA | 89 75 E4 | mov     [rbp+var_1C], esi\n0x004D39ED | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004D39F1 | 8B 40 0C | mov     eax, [rax+0Ch]\n0x004D39F4 | 89 C6 | mov     esi, eax\n0x004D39F6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004D39FA | 8B 40 08 | mov     eax, [rax+8]\n0x004D39FD | 89 C1 | mov     ecx, eax\n0x004D39FF | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004D3A03 | 8B 40 04 | mov     eax, [rax+4]\n0x004D3A06 | 89 C2 | mov     edx, eax\n0x004D3A08 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004D3A0C | 8B 00 | mov     eax, [rax]\n0x004D3A0E | 89 C0 | mov     eax, eax\n0x004D3A10 | 49 89 F0 | mov     r8, rsi\n0x004D3A13 | 48 89 C6 | mov     rsi, rax\n0x004D3A16 | BF 38 40 52 00 | mov     edi, offset aLxLxLxLx; \"%lx:%lx:%lx:%lx\"\n0x004D3A1B | B8 00 00 00 00 | mov     eax, 0\n0x004D3A20 | E8 AB 31 F3 FF | call    _printf\n0x004D3A25 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x004D3A2C | EB 26 | jmp     short loc_4D3A54\n0x004D3A2E | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x004D3A32 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004D3A35 | 48 98 | cdqe\n0x004D3A37 | 0F B6 44 02 11 | movzx   eax, byte ptr [rdx+rax+11h]\n0x004D3A3C | 0F B6 C0 | movzx   eax, al\n0x004D3A3F | 89 C6 | mov     esi, eax\n0x004D3A41 | BF 48 40 52 00 | mov     edi, offset asc_524048; \":%x\"\n0x004D3A46 | B8 00 00 00 00 | mov     eax, 0\n0x004D3A4B | E8 80 31 F3 FF | call    _printf\n0x004D3A50 | 83 45 FC 01 | add     [rbp+var_4], 1\n0x004D3A54 | 83 7D FC 1F | cmp     [rbp+var_4], 1Fh\n0x004D3A58 | 7E D4 | jle     short loc_4D3A2E\n0x004D3A5A | BF 0A 00 00 00 | mov     edi, 0Ah\n0x004D3A5F | E8 F5 6B F3 FF | call    sub_40A659\n0x004D3A64 | 90 | nop\n0x004D3A65 | C9 | leave\n0x004D3A66 | C3 | retn\n\n Ourput decompiled code:\nstatic void display_recoverable(const struct termios *mode,\n\t\t\t\tint UNUSED_PARAM dummy)\n{\n\tint i;\n\tprintf(\"%lx:%lx:%lx:%lx\",\n\t\t   (unsigned long) mode->c_iflag, (unsigned long) mode->c_oflag,\n\t\t   (unsigned long) mode->c_cflag, (unsigned long) mode->c_lflag);\n\tfor (i = 0; i < NCCS; ++i)\n\t\tprintf(\":%x\", (unsigned int) mode->c_cc[i]);\n\tbb_putchar('\\n');\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004633DC | 55 | push    rbp\n0x004633DD | 48 89 E5 | mov     rbp, rsp\n0x004633E0 | 48 83 EC 20 | sub     rsp, 20h\n0x004633E4 | 48 89 7D F8 | mov     [rbp+s], rdi\n0x004633E8 | 89 75 F4 | mov     [rbp+var_C], esi\n0x004633EB | 48 89 55 E8 | mov     [rbp+var_18], rdx\n0x004633EF | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x004633F3 | C6 00 3F | mov     byte ptr [rax], 3Fh ; '?'\n0x004633F6 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x004633FA | 48 83 C0 01 | add     rax, 1\n0x004633FE | C6 00 00 | mov     byte ptr [rax], 0\n0x00463401 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00463405 | 8B 40 7C | mov     eax, [rax+7Ch]\n0x00463408 | 85 C0 | test    eax, eax\n0x0046340A | 74 35 | jz      short loc_463441\n0x0046340C | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00463410 | 8B 88 80 00 00 00 | mov     ecx, [rax+80h]\n0x00463416 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0046341A | 8B 50 7C | mov     edx, [rax+7Ch]\n0x0046341D | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00463420 | 83 C0 01 | add     eax, 1\n0x00463423 | 48 63 F0 | movsxd  rsi, eax; maxlen\n0x00463426 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x0046342A | 41 89 C8 | mov     r8d, ecx\n0x0046342D | 89 D1 | mov     ecx, edx\n0x0046342F | BA 12 BF 51 00 | mov     edx, offset aUU_2; \"%u,%u\"\n0x00463434 | 48 89 C7 | mov     rdi, rax; s\n0x00463437 | B8 00 00 00 00 | mov     eax, 0\n0x0046343C | E8 CF 37 FA FF | call    _snprintf\n0x00463441 | 90 | nop\n0x00463442 | C9 | leave\n0x00463443 | C3 | retn",
        "output": "\n\n Ourput decompiled code:\nstatic void xprint_unknown(uint16_t *val, int i, char *s, int n)\n{\n\ts[0] = '?';\n\ts[1] = '\\0';\n\tif (val[0x38]) {\n\t\tsnprintf(s, n+1, \"%u,%u\", val[0x38], val[0x37]);\n\t}\n}",
        "source_code": "static void func_tty(char *buf, int size, const procps_status_t *ps)\n{\n\tbuf[0] = '?';\n\tbuf[1] = '\\0';\n\tif (ps->tty_major) /* tty field of \"0\" means \"no tty\" */\n\t\tsnprintf(buf, size+1, \"%u,%u\", ps->tty_major, ps->tty_minor);\n}",
        "parsed_output": "\n\n Ourput decompiled code:\nstatic void xprint_unknown(uint16_t *val, int i, char *s, int n)\n{\n\ts[0] = '?';\n\ts[1] = '\\0';\n\tif (val[0x38]) {\n\t\tsnprintf(s, n+1, \"%u,%u\", val[0x38], val[0x37]);\n\t}\n}",
        "baseline_code_stripped": "int __fastcall sub_4633DC(char *a1, int a2, __int64 a3)\n{\n  int result; // eax\n\n  *a1 = 63;\n  a1[1] = 0;\n  result = *(_DWORD *)(a3 + 124);\n  if ( result )\n    return snprintf(a1, a2 + 1, \"%u,%u\", *(unsigned int *)(a3 + 124), *(unsigned int *)(a3 + 128));\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl func_tty(char *buf, int size, const procps_status_t_0 *ps)\n{\n  *buf = 63;\n  buf[1] = 0;\n  if ( ps->tty_major )\n    snprintf(buf, size + 1, \"%u,%u\", ps->tty_major, ps->tty_minor);\n}\n",
        "similarity_score_unixcoder": 0.6574656367301941,
        "similarity_score_baseline_stripped": 0.4665062427520752,
        "similarity_score_baseline_debug": 0.9123704433441162
    },
    {
        "func_name": "may_wakeup",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004654F9 | 55 | push    rbp\n0x004654FA | 48 89 E5 | mov     rbp, rsp\n0x004654FD | 48 83 EC 30 | sub     rsp, 30h\n0x00465501 | 48 89 7D D8 | mov     [rbp+var_28], rdi\n0x00465505 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00465509 | 48 89 C7 | mov     rdi, rax\n0x0046550C | E8 8D CF 09 00 | call    sub_50249E\n0x00465511 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00465515 | BF 43 DF 52 00 | mov     edi, offset aProcSys; \"/proc/sys\"\n0x0046551A | E8 88 53 FA FF | call    sub_40A8A7\n0x0046551F | EB 42 | jmp     short loc_465563\n0x00465521 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00465525 | 48 89 C7 | mov     rdi, rax\n0x00465528 | E8 13 FB FF FF | call    sub_465040\n0x0046552D | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x00465531 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00465535 | 48 89 C6 | mov     rsi, rax\n0x00465538 | BF 4D DF 52 00 | mov     edi, offset aSS_27; \"%s=%s\"\n0x0046553D | B8 00 00 00 00 | mov     eax, 0\n0x00465542 | E8 6C 51 FA FF | call    sub_40A6B3\n0x00465547 | 48 89 45 F0 | mov     [rbp+ptr], rax\n0x0046554B | 48 8B 45 F0 | mov     rax, [rbp+ptr]\n0x0046554F | 48 89 C7 | mov     rdi, rax\n0x00465552 | E8 67 FE FF FF | call    sub_4653BE\n0x00465557 | 48 8B 45 F0 | mov     rax, [rbp+ptr]\n0x0046555B | 48 89 C7 | mov     rdi, rax; ptr\n0x0046555E | E8 FD 10 FA FF | call    _free\n0x00465563 | 48 8D 75 E0 | lea     rsi, [rbp+var_20]\n0x00465567 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0046556B | B9 53 DF 52 00 | mov     ecx, offset asc_52DF53; \"# \\t=\"\n0x00465570 | BA 02 02 47 00 | mov     edx, offset loc_470202\n0x00465575 | 48 89 C7 | mov     rdi, rax\n0x00465578 | E8 1E D1 09 00 | call    sub_50269B\n0x0046557D | 85 C0 | test    eax, eax\n0x0046557F | 75 A0 | jnz     short loc_465521\n0x00465581 | B8 00 00 00 00 | mov     eax, 0\n0x00465586 | C9 | leave\n0x00465587 | C3 | retn\n\n Ourput decompiled code:\nstatic int sysctl_handle_preload_file(const char *filename)\n{\n\tchar *token[2];\n\tparser_t *parser;\n\n\tparser = config_open(filename);\n\t/* Must do it _after_ config_open(): */\n\txchdir(\"/proc/sys\");\n\t/* xchroot(\"/proc/sys\") - if you are paranoid */\n\n//TODO: ';' is comment char too\n//TODO: comment may be only at line start. \"var=1 #abc\" - \"1 #abc\" is the value\n// (but _whitespace_ from ends should be trimmed first (and we do it right))\n//TODO: \"var==1\" is mishandled (must use \"=1\" as a value, but uses \"1\")\n// can it be fixed by removing PARSE_COLLAPSE bit?\n\twhile (config_read(parser, token, 2, 2, \"# \\t=\", PARSE_NORMAL)) {\n\t\tchar *tp;\n\t\tsysctl_dots_to_slashes(token[0]);\n\t\ttp = xasprintf(\"%s=%s\", token[0], token[1]);\n\t\tsysctl_act_recursive(tp);\n\t\tfree(tp);\n\t}\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tconfig_close(parser);\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x0044F857 | 55 | push    rbp\n0x0044F858 | 48 89 E5 | mov     rbp, rsp\n0x0044F85B | 48 83 EC 40 | sub     rsp, 40h\n0x0044F85F | 48 89 7D C8 | mov     [rbp+var_38], rdi\n0x0044F863 | 48 89 75 C0 | mov     [rbp+var_40], rsi\n0x0044F867 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x0044F86B | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0044F86E | 84 C0 | test    al, al\n0x0044F870 | 74 15 | jz      short loc_44F887\n0x0044F872 | 48 8B 55 C0 | mov     rdx, [rbp+var_40]\n0x0044F876 | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x0044F87A | 48 89 D6 | mov     rsi, rdx\n0x0044F87D | 48 89 C7 | mov     rdi, rax\n0x0044F880 | E8 CD A1 FB FF | call    sub_409A52\n0x0044F885 | EB 13 | jmp     short loc_44F89A\n0x0044F887 | 48 8B 55 C8 | mov     rdx, [rbp+var_38]\n0x0044F88B | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x0044F88F | 48 89 D6 | mov     rsi, rdx\n0x0044F892 | 48 89 C7 | mov     rdi, rax\n0x0044F895 | E8 B8 A1 FB FF | call    sub_409A52\n0x0044F89A | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x0044F89E | 48 89 45 E0 | mov     [rbp+var_20], rax\n0x0044F8A2 | BA 00 00 00 00 | mov     edx, 0\n0x0044F8A7 | BE 02 00 00 00 | mov     esi, 2\n0x0044F8AC | BF 02 00 00 00 | mov     edi, 2\n0x0044F8B1 | E8 E3 B0 FB FF | call    sub_40A999\n0x0044F8B6 | 89 45 FC | mov     [rbp+fd], eax\n0x0044F8B9 | 48 8D 55 D0 | lea     rdx, [rbp+var_30]\n0x0044F8BD | 8B 45 FC | mov     eax, [rbp+fd]\n0x0044F8C0 | B9 29 C8 52 00 | mov     ecx, offset aSiocdeltunnel; \"SIOCDELTUNNEL\"\n0x0044F8C5 | BE F2 89 00 00 | mov     esi, 89F2h\n0x0044F8CA | 89 C7 | mov     edi, eax\n0x0044F8CC | E8 80 B4 FB FF | call    sub_40AD51\n0x0044F8D1 | 8B 45 FC | mov     eax, [rbp+fd]\n0x0044F8D4 | 89 C7 | mov     edi, eax; fd\n0x0044F8D6 | E8 35 75 FB FF | call    _close\n0x0044F8DB | B8 00 00 00 00 | mov     eax, 0\n0x0044F8E0 | C9 | leave\n0x0044F8E1 | C3 | retn\n\n Ourput decompiled code:\nstatic int do_del_ioctl(const char *basedev, struct ip_tunnel_parm *p)\n{\n\tstruct ifreq ifr;\n\tint fd;\n\n\tif (p->name[0]) {\n\t\tstrncpy_IFNAMSIZ(ifr.ifr_name, p->name);\n\t} else {\n\t\tstrncpy_IFNAMSIZ(ifr.ifr_name, basedev);\n\t}\n\tifr.ifr_ifru.ifru_data = (void*)p;\n\tfd = xsocket(AF_INET, SOCK_DGRAM, 0);\n\txioctl(fd, SIOCDELTUNNEL, &ifr);\n\tclose(fd);\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x0043A44B | 55 | push    rbp\n0x0043A44C | 48 89 E5 | mov     rbp, rsp\n0x0043A44F | 48 83 EC 70 | sub     rsp, 70h\n0x0043A453 | 48 89 7D 98 | mov     [rbp+var_68], rdi\n0x0043A457 | 48 8D 45 A0 | lea     rax, [rbp+s]\n0x0043A45B | BA 60 00 00 00 | mov     edx, 60h ; '`'; n\n0x0043A460 | BE 00 00 00 00 | mov     esi, 0; c\n0x0043A465 | 48 89 C7 | mov     rdi, rax; s\n0x0043A468 | E8 E3 C8 FC FF | call    _memset\n0x0043A46D | 48 8B 55 98 | mov     rdx, [rbp+var_68]\n0x0043A471 | 48 8D 45 A0 | lea     rax, [rbp+s]\n0x0043A475 | 48 89 D6 | mov     rsi, rdx\n0x0043A478 | 48 89 C7 | mov     rdi, rax\n0x0043A47B | E8 65 FD FF FF | call    sub_43A1E5\n0x0043A480 | 85 C0 | test    eax, eax\n0x0043A482 | 74 07 | jz      short loc_43A48B\n0x0043A484 | B8 01 00 00 00 | mov     eax, 1\n0x0043A489 | EB 28 | jmp     short locret_43A4B3\n0x0043A48B | 8B 55 A4 | mov     edx, [rbp+var_5C]\n0x0043A48E | 8B 45 A8 | mov     eax, [rbp+var_58]\n0x0043A491 | 48 98 | cdqe\n0x0043A493 | 48 8B 34 C5 20 9F 51 00 | mov     rsi, ds:off_519F20[rax*8]\n0x0043A49B | 48 8D 45 A0 | lea     rax, [rbp+s]\n0x0043A49F | 89 D1 | mov     ecx, edx\n0x0043A4A1 | BA 8D A0 51 00 | mov     edx, offset aTcp_3; \"tcp\"\n0x0043A4A6 | 48 89 C7 | mov     rdi, rax\n0x0043A4A9 | E8 3C FE FF FF | call    sub_43A2EA\n0x0043A4AE | B8 00 00 00 00 | mov     eax, 0\n0x0043A4B3 | C9 | leave\n0x0043A4B4 | C3 | retn\n\n Ourput decompiled code:\nstatic int FAST_FUNC tcp_do_one(char *line)\n{\n\tstruct inet_params param;\n\n\tmemset(&param, 0, sizeof(param));\n\tif (scan_inet_proc_line(&param, line))\n\t\treturn 1;\n\n\tprint_inet_line(&param, tcp_state[param.state], \"tcp\", param.rem_port);\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004A4040 | 55 | push    rbp\n0x004A4041 | 48 89 E5 | mov     rbp, rsp\n0x004A4044 | 48 81 EC A0 00 00 00 | sub     rsp, 0A0h\n0x004A404B | 48 89 BD 68 FF FF FF | mov     [rbp+var_98], rdi\n0x004A4052 | 48 8B 85 68 FF FF FF | mov     rax, [rbp+var_98]\n0x004A4059 | 48 89 C7 | mov     rdi, rax\n0x004A405C | E8 BA 53 F6 FF | call    sub_40941B\n0x004A4061 | 48 89 85 68 FF FF FF | mov     [rbp+var_98], rax\n0x004A4068 | 48 8B 95 68 FF FF FF | mov     rdx, [rbp+var_98]\n0x004A406F | 48 8D 85 70 FF FF FF | lea     rax, [rbp+s]\n0x004A4076 | 48 89 D1 | mov     rcx, rdx\n0x004A4079 | BA 58 09 53 00 | mov     edx, offset aSysClassRtcSDe; \"/sys/class/rtc/%s/device/power/wakeup\"\n0x004A407E | BE 80 00 00 00 | mov     esi, 80h; maxlen\n0x004A4083 | 48 89 C7 | mov     rdi, rax; s\n0x004A4086 | B8 00 00 00 00 | mov     eax, 0\n0x004A408B | E8 80 2B F6 FF | call    _snprintf\n0x004A4090 | 48 8D 8D 70 FF FF FF | lea     rcx, [rbp+s]\n0x004A4097 | 48 8D 85 70 FF FF FF | lea     rax, [rbp+s]\n0x004A409E | BA 80 00 00 00 | mov     edx, 80h\n0x004A40A3 | 48 89 CE | mov     rsi, rcx\n0x004A40A6 | 48 89 C7 | mov     rdi, rax\n0x004A40A9 | E8 53 74 F6 FF | call    sub_40B501\n0x004A40AE | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004A40B2 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004A40B7 | 79 07 | jns     short loc_4A40C0\n0x004A40B9 | B8 00 00 00 00 | mov     eax, 0\n0x004A40BE | EB 1E | jmp     short locret_4A40DE\n0x004A40C0 | 48 8D 85 70 FF FF FF | lea     rax, [rbp+s]\n0x004A40C7 | BA 08 00 00 00 | mov     edx, 8; n\n0x004A40CC | BE 7E 09 53 00 | mov     esi, offset aEnabled_0; \"enabled\\n\"\n0x004A40D1 | 48 89 C7 | mov     rdi, rax; s1\n0x004A40D4 | E8 C7 26 F6 FF | call    _strncmp\n0x004A40D9 | 85 C0 | test    eax, eax\n0x004A40DB | 0F 94 C0 | setz    al\n0x004A40DE | C9 | leave\n0x004A40DF | C3 | retn",
        "output": "\n\nstatic int rtc_wakealarm_handle_preload_file(const char *filename)\n{\n\tchar s[128];\n\tchar *token;\n\n\ttoken = config_open(filename);\n\tsnprintf(s, sizeof(s), \"/sys/class/rtc/%s/device/power/wakeup\", token);\n\trtc_wakealarm_handle_file(s, token, sizeof(s));\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tconfig_close(token);\n\treturn 0;\n}",
        "source_code": "static NOINLINE bool may_wakeup(const char *rtcname)\n{\n\tssize_t ret;\n\tchar buf[128];\n\n\t/* strip \"/dev/\" from the rtcname here */\n\trtcname = skip_dev_pfx(rtcname);\n\n\tsnprintf(buf, sizeof(buf), SYS_RTC_PATH, rtcname);\n\tret = open_read_close(buf, buf, sizeof(buf));\n\tif (ret < 0)\n\t\treturn false;\n\n\t/* wakeup events could be disabled or not supported */\n\treturn strncmp(buf, \"enabled\\n\", 8) == 0;\n}",
        "parsed_output": "\n\nstatic int rtc_wakealarm_handle_preload_file(const char *filename)\n{\n\tchar s[128];\n\tchar *token;\n\n\ttoken = config_open(filename);\n\tsnprintf(s, sizeof(s), \"/sys/class/rtc/%s/device/power/wakeup\", token);\n\trtc_wakealarm_handle_file(s, token, sizeof(s));\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tconfig_close(token);\n\treturn 0;\n}",
        "baseline_code_stripped": "bool __fastcall sub_4A4040(const char *a1)\n{\n  char *v2; // [rsp+8h] [rbp-98h]\n  char s[136]; // [rsp+10h] [rbp-90h] BYREF\n  ssize_t v4; // [rsp+98h] [rbp-8h]\n\n  v2 = sub_40941B(a1);\n  snprintf(s, 0x80uLL, \"/sys/class/rtc/%s/device/power/wakeup\", v2);\n  v4 = sub_40B501(s, s, 0x80uLL);\n  return v4 >= 0 && strncmp(s, \"enabled\\n\", 8uLL) == 0;\n}\n",
        "baseline_code_debug": "bool __cdecl may_wakeup(const char *rtcname)\n{\n  char *rtcnamea; // [rsp+8h] [rbp-98h]\n  char buf[128]; // [rsp+10h] [rbp-90h] BYREF\n  ssize_t ret; // [rsp+98h] [rbp-8h]\n\n  rtcnamea = skip_dev_pfx(rtcname);\n  snprintf(buf, 0x80uLL, \"/sys/class/rtc/%s/device/power/wakeup\", rtcnamea);\n  ret = open_read_close(buf, buf, 0x80uLL);\n  return ret >= 0 && strncmp(buf, \"enabled\\n\", 8uLL) == 0;\n}\n",
        "similarity_score_unixcoder": 0.7471197843551636,
        "similarity_score_baseline_stripped": 0.6505969762802124,
        "similarity_score_baseline_debug": 0.8455996513366699
    },
    {
        "func_name": "llist_add_to_end",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00409191 | 55 | push    rbp\n0x00409192 | 48 89 E5 | mov     rbp, rsp\n0x00409195 | 48 83 EC 10 | sub     rsp, 10h\n0x00409199 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0040919D | 48 89 75 F0 | mov     [rbp+s2], rsi\n0x004091A1 | EB 26 | jmp     short loc_4091C9\n0x004091A3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004091A7 | 48 8B 40 08 | mov     rax, [rax+8]\n0x004091AB | 48 8B 55 F0 | mov     rdx, [rbp+s2]\n0x004091AF | 48 89 D6 | mov     rsi, rdx; s2\n0x004091B2 | 48 89 C7 | mov     rdi, rax; s1\n0x004091B5 | E8 96 DE FF FF | call    _strcmp\n0x004091BA | 85 C0 | test    eax, eax\n0x004091BC | 74 14 | jz      short loc_4091D2\n0x004091BE | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004091C2 | 48 8B 00 | mov     rax, [rax]\n0x004091C5 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004091C9 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004091CE | 75 D3 | jnz     short loc_4091A3\n0x004091D0 | EB 01 | jmp     short loc_4091D3\n0x004091D2 | 90 | nop\n0x004091D3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004091D7 | C9 | leave\n0x004091D8 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC llist_find_str(llist_t *list, const char *str)\n{\n\twhile (list) {\n\t\tif (strcmp(list->data, str) == 0)\n\t\t\tbreak;\n\t\tlist = list->link;\n\t}\n\treturn list;\n}\n\n## Example:\n\n Input assembly code:\n0x004D12FE | 55 | push    rbp\n0x004D12FF | 48 89 E5 | mov     rbp, rsp\n0x004D1302 | 48 83 EC 10 | sub     rsp, 10h\n0x004D1306 | 48 C7 45 F8 50 B2 75 00 | mov     [rbp+var_8], offset qword_75B250\n0x004D130E | EB 0B | jmp     short loc_4D131B\n0x004D1310 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004D1314 | 48 8B 00 | mov     rax, [rax]\n0x004D1317 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004D131B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004D131F | 48 8B 00 | mov     rax, [rax]\n0x004D1322 | 48 85 C0 | test    rax, rax\n0x004D1325 | 75 E9 | jnz     short loc_4D1310\n0x004D1327 | BF 20 00 00 00 | mov     edi, 20h ; ' '\n0x004D132C | E8 B7 8D F3 FF | call    sub_40A0E8\n0x004D1331 | 48 89 C2 | mov     rdx, rax\n0x004D1334 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004D1338 | 48 89 10 | mov     [rax], rdx\n0x004D133B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004D133F | 48 8B 00 | mov     rax, [rax]\n0x004D1342 | C9 | leave\n0x004D1343 | C3 | retn\n\n Ourput decompiled code:\nstatic struct sort_key *add_key(void)\n{\n\tstruct sort_key **pkey = &key_list;\n\twhile (*pkey)\n\t\tpkey = &((*pkey)->next_key);\n\treturn *pkey = xzalloc(sizeof(struct sort_key));\n}\n\n## Example:\n\n Input assembly code:\n0x004C03B7 | 55 | push    rbp\n0x004C03B8 | 48 89 E5 | mov     rbp, rsp\n0x004C03BB | 48 83 EC 10 | sub     rsp, 10h\n0x004C03BF | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004C03C3 | 48 89 75 F0 | mov     [rbp+name], rsi\n0x004C03C7 | EB 31 | jmp     short loc_4C03FA\n0x004C03C9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C03CD | 48 8B 40 08 | mov     rax, [rax+8]\n0x004C03D1 | 48 8B 4D F0 | mov     rcx, [rbp+name]\n0x004C03D5 | BA 00 00 00 00 | mov     edx, 0; flags\n0x004C03DA | 48 89 CE | mov     rsi, rcx; name\n0x004C03DD | 48 89 C7 | mov     rdi, rax; pattern\n0x004C03E0 | E8 3B 69 F4 FF | call    _fnmatch\n0x004C03E5 | 85 C0 | test    eax, eax\n0x004C03E7 | 75 06 | jnz     short loc_4C03EF\n0x004C03E9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C03ED | EB 17 | jmp     short locret_4C0406\n0x004C03EF | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C03F3 | 48 8B 00 | mov     rax, [rax]\n0x004C03F6 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004C03FA | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004C03FF | 75 C8 | jnz     short loc_4C03C9\n0x004C0401 | B8 00 00 00 00 | mov     eax, 0\n0x004C0406 | C9 | leave\n0x004C0407 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC find_list_entry(const llist_t *list, const char *filename)\n{\n\twhile (list) {\n\t\tif (fnmatch(list->data, filename, 0) == 0) {\n\t\t\treturn list;\n\t\t}\n\t\tlist = list->link;\n\t}\n\treturn NULL;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00409018 | 55 | push    rbp\n0x00409019 | 48 89 E5 | mov     rbp, rsp\n0x0040901C | 48 83 EC 10 | sub     rsp, 10h\n0x00409020 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00409024 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x00409028 | EB 0B | jmp     short loc_409035\n0x0040902A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0040902E | 48 8B 00 | mov     rax, [rax]\n0x00409031 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00409035 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00409039 | 48 8B 00 | mov     rax, [rax]\n0x0040903C | 48 85 C0 | test    rax, rax\n0x0040903F | 75 E9 | jnz     short loc_40902A\n0x00409041 | BF 10 00 00 00 | mov     edi, 10h\n0x00409046 | E8 9D 10 00 00 | call    sub_40A0E8\n0x0040904B | 48 89 C2 | mov     rdx, rax\n0x0040904E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00409052 | 48 89 10 | mov     [rax], rdx\n0x00409055 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00409059 | 48 8B 00 | mov     rax, [rax]\n0x0040905C | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x00409060 | 48 89 50 08 | mov     [rax+8], rdx\n0x00409064 | 90 | nop\n0x00409065 | C9 | leave\n0x00409066 | C3 | retn",
        "output": "\n\nstatic void llist_add_str(llist_t *list, const char *str)\n{\n\twhile (list->link)\n\t\tlist = list->link;\n\tlist->link = xzalloc(sizeof(llist_t));\n\tlist->link->data = xstrdup(str);\n\tlist->link->link = NULL;\n}",
        "source_code": "void FAST_FUNC llist_add_to_end(llist_t **list_head, void *data)\n{\n\twhile (*list_head)\n\t\tlist_head = &(*list_head)->link;\n\t*list_head = xzalloc(sizeof(llist_t));\n\t(*list_head)->data = data;\n\t/*(*list_head)->link = NULL;*/\n}",
        "parsed_output": "\n\nstatic void llist_add_str(llist_t *list, const char *str)\n{\n\twhile (list->link)\n\t\tlist = list->link;\n\tlist->link = xzalloc(sizeof(llist_t));\n\tlist->link->data = xstrdup(str);\n\tlist->link->link = NULL;\n}",
        "baseline_code_stripped": "__int64 *__fastcall sub_409018(__int64 *a1, __int64 a2)\n{\n  __int64 *result; // rax\n\n  while ( *a1 )\n    a1 = (__int64 *)*a1;\n  *a1 = sub_40A0E8(16LL);\n  result = (__int64 *)*a1;\n  *(_QWORD *)(*a1 + 8) = a2;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl llist_add_to_end(llist_t_0 **list_head, void *data)\n{\n  while ( *list_head )\n    list_head = (llist_t_0 **)*list_head;\n  *list_head = (llist_t_0 *)xzalloc(0x10uLL);\n  (*list_head)->data = (char *)data;\n}\n",
        "similarity_score_unixcoder": 0.8698559403419495,
        "similarity_score_baseline_stripped": 0.5214083194732666,
        "similarity_score_baseline_debug": 0.9074715375900269
    },
    {
        "func_name": "write_and_stats",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x005023F6 | 55 | push    rbp\n0x005023F7 | 48 89 E5 | mov     rbp, rsp\n0x005023FA | 48 83 EC 30 | sub     rsp, 30h\n0x005023FE | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00502402 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00502406 | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x0050240A | 48 8B 55 D8 | mov     rdx, [rbp+var_28]\n0x0050240E | 48 8B 4D E0 | mov     rcx, [rbp+var_20]\n0x00502412 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00502416 | 48 89 CE | mov     rsi, rcx\n0x00502419 | 48 89 C7 | mov     rdi, rax\n0x0050241C | E8 C3 FD FF FF | call    sub_5021E4\n0x00502421 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00502425 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0050242A | 74 1D | jz      short loc_502449\n0x0050242C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00502430 | 48 89 C6 | mov     rsi, rax\n0x00502433 | BF DE 73 53 00 | mov     edi, offset aBadPasswordS; \"Bad password: %s\\n\"\n0x00502438 | B8 00 00 00 00 | mov     eax, 0\n0x0050243D | E8 8E 47 F0 FF | call    _printf\n0x00502442 | B8 01 00 00 00 | mov     eax, 1\n0x00502447 | EB 05 | jmp     short locret_50244E\n0x00502449 | B8 00 00 00 00 | mov     eax, 0\n0x0050244E | C9 | leave\n0x0050244F | C3 | retn\n\n Ourput decompiled code:\nint FAST_FUNC obscure(const char *old, const char *newval, const struct passwd *pw)\n{\n\tconst char *msg;\n\n\tmsg = obscure_msg(old, newval, pw);\n\tif (msg) {\n\t\tprintf(\"Bad password: %s\\n\", msg);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x0040BECF | 55 | push    rbp\n0x0040BED0 | 48 89 E5 | mov     rbp, rsp\n0x0040BED3 | 48 83 EC 30 | sub     rsp, 30h\n0x0040BED7 | 48 89 7D E8 | mov     [rbp+nptr], rdi\n0x0040BEDB | 48 89 75 E0 | mov     [rbp+endptr], rsi\n0x0040BEDF | 89 55 DC | mov     [rbp+base], edx\n0x0040BEE2 | 48 83 7D E0 00 | cmp     [rbp+endptr], 0\n0x0040BEE7 | 75 08 | jnz     short loc_40BEF1\n0x0040BEE9 | 48 8D 45 F0 | lea     rax, [rbp+var_10]\n0x0040BEED | 48 89 45 E0 | mov     [rbp+endptr], rax\n0x0040BEF1 | 48 8B 45 E0 | mov     rax, [rbp+endptr]\n0x0040BEF5 | 48 8B 55 E8 | mov     rdx, [rbp+nptr]\n0x0040BEF9 | 48 89 10 | mov     [rax], rdx\n0x0040BEFC | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x0040BF00 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0040BF03 | 0F B6 C0 | movzx   eax, al\n0x0040BF06 | 89 C7 | mov     edi, eax\n0x0040BF08 | E8 E5 FD FF FF | call    sub_40BCF2\n0x0040BF0D | 85 C0 | test    eax, eax\n0x0040BF0F | 75 07 | jnz     short loc_40BF18\n0x0040BF11 | E8 1A FE FF FF | call    sub_40BD30\n0x0040BF16 | EB 4C | jmp     short locret_40BF64\n0x0040BF18 | 48 8B 05 E1 14 35 00 | mov     rax, cs:qword_75D400\n0x0040BF1F | C7 00 00 00 00 00 | mov     dword ptr [rax], 0\n0x0040BF25 | 8B 55 DC | mov     edx, [rbp+base]; base\n0x0040BF28 | 48 8B 4D E0 | mov     rcx, [rbp+endptr]\n0x0040BF2C | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x0040BF30 | 48 89 CE | mov     rsi, rcx; endptr\n0x0040BF33 | 48 89 C7 | mov     rdi, rax; nptr\n0x0040BF36 | E8 25 BA FF FF | call    _strtoul\n0x0040BF3B | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0040BF3F | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x0040BF44 | 48 39 45 F8 | cmp     [rbp+var_8], rax\n0x0040BF48 | 76 07 | jbe     short loc_40BF51\n0x0040BF4A | E8 E1 FD FF FF | call    sub_40BD30\n0x0040BF4F | EB 13 | jmp     short locret_40BF64\n0x0040BF51 | 48 8B 55 E0 | mov     rdx, [rbp+endptr]\n0x0040BF55 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0040BF59 | 48 89 D6 | mov     rsi, rdx\n0x0040BF5C | 48 89 C7 | mov     rdi, rax\n0x0040BF5F | E8 E6 FD FF FF | call    sub_40BD4A\n0x0040BF64 | C9 | leave\n0x0040BF65 | C3 | retn\n\n Ourput decompiled code:\nULONG_MAX\nunsigned FAST_FUNC bb_strtou(const char *arg, char **endp, int base)\n{\n\tunsigned long v;\n\tchar *endptr;\n\n\tif (!endp) endp = &endptr;\n\t*endp = (char*) arg;\n\n\tif (!isalnum(arg[0])) return ret_ERANGE();\n\terrno = 0;\n\tv = strtoul(arg, endp, base);\n\tif (v > UINT_MAX) return ret_ERANGE();\n\treturn handle_errors(v, endp);\n}\n\n## Example:\n\n Input assembly code:\n0x00484A4F | 55 | push    rbp\n0x00484A50 | 48 89 E5 | mov     rbp, rsp\n0x00484A53 | 48 83 EC 30 | sub     rsp, 30h\n0x00484A57 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00484A5B | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00484A5F | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x00484A63 | 48 8B 4D E0 | mov     rcx, [rbp+var_20]\n0x00484A67 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00484A6B | BA 06 00 00 00 | mov     edx, 6\n0x00484A70 | 48 89 CE | mov     rsi, rcx\n0x00484A73 | 48 89 C7 | mov     rdi, rax\n0x00484A76 | E8 AC 5E 00 00 | call    sub_48A927\n0x00484A7B | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00484A7F | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00484A84 | 74 16 | jz      short loc_484A9C\n0x00484A86 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00484A8A | 48 2B 45 E8 | sub     rax, [rbp+var_18]\n0x00484A8E | 89 C2 | mov     edx, eax\n0x00484A90 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00484A94 | 89 10 | mov     [rax], edx\n0x00484A96 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00484A9A | EB 2B | jmp     short locret_484AC7\n0x00484A9C | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00484AA0 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00484AA3 | 84 C0 | test    al, al\n0x00484AA5 | 75 07 | jnz     short loc_484AAE\n0x00484AA7 | B8 00 00 00 00 | mov     eax, 0\n0x00484AAC | EB 19 | jmp     short locret_484AC7\n0x00484AAE | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00484AB2 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00484AB5 | 3C 2A | cmp     al, 2Ah ; '*'\n0x00484AB7 | 75 07 | jnz     short loc_484AC0\n0x00484AB9 | B8 00 00 00 00 | mov     eax, 0\n0x00484ABE | EB 07 | jmp     short locret_484AC7\n0x00484AC0 | 48 83 45 E8 01 | add     [rbp+var_18], 1\n0x00484AC5 | EB 9C | jmp     short loc_484A63\n0x00484AC7 | C9 | leave\n0x00484AC8 | C3 | retn\n\n Ourput decompiled code:\nstatic char *strstr_pattern(char *val, const char *pattern, int *size)\n{\n\twhile (1) {\n\t\tchar *end = scan_and_match(val, pattern, SCAN_MOVE_FROM_RIGHT + SCAN_MATCH_LEFT_HALF);\n\t\tdebug_printf_varexp(\"val:'%s' pattern:'%s' end:'%s'\\n\", val, pattern, end);\n\t\tif (end) {\n\t\t\t*size = end - val;\n\t\t\treturn val;\n\t\t}\n\t\tif (*val == '\\0')\n\t\t\treturn NULL;\n\t\t/* Optimization: if \"*pat\" did not match the start of \"string\",\n\t\t * we know that \"tring\", \"ring\" etc will not match too:\n\t\t */\n\t\tif (pattern[0] == '*')\n\t\t\treturn NULL;\n\t\tval++;\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C760C | 55 | push    rbp\n0x004C760D | 48 89 E5 | mov     rbp, rsp\n0x004C7610 | 48 83 EC 30 | sub     rsp, 30h\n0x004C7614 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004C7618 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004C761C | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x004C7620 | 48 89 4D D0 | mov     [rbp+var_30], rcx\n0x004C7624 | 48 8B 55 D0 | mov     rdx, [rbp+var_30]\n0x004C7628 | 48 8B 4D E0 | mov     rcx, [rbp+var_20]\n0x004C762C | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004C7630 | 48 89 CE | mov     rsi, rcx\n0x004C7633 | 48 89 C7 | mov     rdi, rax\n0x004C7636 | E8 81 FF FF FF | call    sub_4C75BC\n0x004C763B | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004C763F | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004C7644 | 79 07 | jns     short loc_4C764D\n0x004C7646 | B8 01 00 00 00 | mov     eax, 1\n0x004C764B | EB 51 | jmp     short locret_4C769E\n0x004C764D | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004C7651 | 48 39 45 F8 | cmp     [rbp+var_8], rax\n0x004C7655 | 75 11 | jnz     short loc_4C7668\n0x004C7657 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004C765C | 48 8B 10 | mov     rdx, [rax]\n0x004C765F | 48 83 C2 01 | add     rdx, 1\n0x004C7663 | 48 89 10 | mov     [rax], rdx\n0x004C7666 | EB 18 | jmp     short loc_4C7680\n0x004C7668 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004C766D | 74 11 | jz      short loc_4C7680\n0x004C766F | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004C7674 | 48 8B 50 08 | mov     rdx, [rax+8]\n0x004C7678 | 48 83 C2 01 | add     rdx, 1\n0x004C767C | 48 89 50 08 | mov     [rax+8], rdx\n0x004C7680 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004C7685 | 48 8B 50 20 | mov     rdx, [rax+20h]\n0x004C7689 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C768D | B9 F8 B3 75 00 | mov     ecx, offset dest\n0x004C7692 | 48 01 D0 | add     rax, rdx\n0x004C7695 | 48 89 41 20 | mov     [rcx+20h], rax\n0x004C7699 | B8 00 00 00 00 | mov     eax, 0\n0x004C769E | C9 | leave\n0x004C769F | C3 | retn",
        "output": "\n\nstatic int\nparse_pattern(char *val, const char *pattern, char **dest, int *size)\n{\n\tchar *end;\n\n\tend = strstr_pattern(val, pattern, size);\n\tif (end < 0)\n\t\treturn 1;\n\tif (end == *dest)\n\t\t(*dest)[0]++;\n\telse if (end)\n\t\t(*dest)[8]++, (*dest)[12]++;\n\t(*dest)[20] = end + *size;\n\treturn 0;\n}",
        "source_code": "static bool write_and_stats(const void *buf, size_t len, size_t obs,\n\tconst char *filename)\n{\n\tssize_t n = full_write_or_warn(buf, len, filename);\n\tif (n < 0)\n\t\treturn 1;\n\tif ((size_t)n == obs)\n\t\tG.out_full++;\n\telse if (n) /* > 0 */\n\t\tG.out_part++;\n#if ENABLE_FEATURE_DD_THIRD_STATUS_LINE\n\tG.total_bytes += n;\n#endif\n\treturn 0;\n}",
        "parsed_output": "\n\nstatic int\nparse_pattern(char *val, const char *pattern, char **dest, int *size)\n{\n\tchar *end;\n\n\tend = strstr_pattern(val, pattern, size);\n\tif (end < 0)\n\t\treturn 1;\n\tif (end == *dest)\n\t\t(*dest)[0]++;\n\telse if (end)\n\t\t(*dest)[8]++, (*dest)[12]++;\n\t(*dest)[20] = end + *size;\n\treturn 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4C760C(__int64 a1, __int64 a2, __int64 a3, __int64 a4)\n{\n  __int64 v6; // [rsp+28h] [rbp-8h]\n\n  v6 = sub_4C75BC(a1, a2, a4);\n  if ( v6 < 0 )\n    return 1LL;\n  if ( v6 == a3 )\n  {\n    ++*(_QWORD *)&dest.c_iflag;\n  }\n  else if ( v6 )\n  {\n    ++*(_QWORD *)&dest.c_cflag;\n  }\n  *(_QWORD *)&dest.c_cc[15] += v6;\n  return 0LL;\n}\n",
        "baseline_code_debug": "bool __cdecl write_and_stats(const void *buf, size_t len, size_t obs, const char *filename)\n{\n  __int64 n; // [rsp+28h] [rbp-8h]\n\n  n = full_write_or_warn(buf, len, filename);\n  if ( n < 0 )\n    return 1;\n  if ( n == obs )\n  {\n    ++*(_QWORD *)&bb_common_bufsiz1.c_iflag;\n  }\n  else if ( n )\n  {\n    ++*(_QWORD *)&bb_common_bufsiz1.c_cflag;\n  }\n  *(_QWORD *)&bb_common_bufsiz1.c_cc[15] += n;\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.5008617043495178,
        "similarity_score_baseline_stripped": 0.48002612590789795,
        "similarity_score_baseline_debug": 0.823329508304596
    },
    {
        "func_name": "size_from_HISTFILESIZE",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0050A825 | 55 | push    rbp\n0x0050A826 | 48 89 E5 | mov     rbp, rsp\n0x0050A829 | 48 83 EC 20 | sub     rsp, 20h\n0x0050A82D | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0050A831 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x0050A838 | 48 81 7D E8 D5 4D 53 00 | cmp     [rbp+var_18], offset aStandardInput; \"standard input\"\n0x0050A840 | 74 2E | jz      short loc_50A870\n0x0050A842 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0050A846 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0050A849 | 3C 2D | cmp     al, 2Dh ; '-'\n0x0050A84B | 75 0F | jnz     short loc_50A85C\n0x0050A84D | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0050A851 | 48 83 C0 01 | add     rax, 1\n0x0050A855 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0050A858 | 84 C0 | test    al, al\n0x0050A85A | 74 14 | jz      short loc_50A870\n0x0050A85C | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0050A860 | BE 00 00 00 00 | mov     esi, 0\n0x0050A865 | 48 89 C7 | mov     rdi, rax\n0x0050A868 | E8 BD FA EF FF | call    sub_40A32A\n0x0050A86D | 89 45 FC | mov     [rbp+var_4], eax\n0x0050A870 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0050A873 | C9 | leave\n0x0050A874 | C3 | retn\n\n Ourput decompiled code:\nint FAST_FUNC open_or_warn_stdin(const char *filename)\n{\n\tint fd = STDIN_FILENO;\n\n\tif (filename != bb_msg_standard_input\n\t && NOT_LONE_DASH(filename)\n\t) {\n\t\tfd = open_or_warn(filename, O_RDONLY);\n\t}\n\n\treturn fd;\n}\n\n## Example:\n\n Input assembly code:\n0x004D3891 | 55 | push    rbp\n0x004D3892 | 48 89 E5 | mov     rbp, rsp\n0x004D3895 | 48 83 EC 20 | sub     rsp, 20h\n0x004D3899 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004D389D | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004D38A1 | 48 89 C6 | mov     rsi, rax\n0x004D38A4 | BF 98 41 52 00 | mov     edi, offset aLine_0; \"line\"\n0x004D38A9 | E8 B8 2D 02 00 | call    sub_4F6666\n0x004D38AE | 83 C0 01 | add     eax, 1\n0x004D38B1 | 89 45 FC | mov     [rbp+var_4], eax\n0x004D38B4 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004D38B8 | 75 07 | jnz     short loc_4D38C1\n0x004D38BA | B8 00 00 00 00 | mov     eax, 0\n0x004D38BF | EB 16 | jmp     short locret_4D38D7\n0x004D38C1 | 83 7D FC 05 | cmp     [rbp+var_4], 5\n0x004D38C5 | 74 0D | jz      short loc_4D38D4\n0x004D38C7 | 83 7D FC 06 | cmp     [rbp+var_4], 6\n0x004D38CB | 74 07 | jz      short loc_4D38D4\n0x004D38CD | 81 4D FC 80 00 00 00 | or      [rbp+var_4], 80h\n0x004D38D4 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004D38D7 | C9 | leave\n0x004D38D8 | C3 | retn\n\n Ourput decompiled code:\nstatic int find_param(const char *name)\n{\n\tstatic const char params[] ALIGN1 =\n\t\t\"line\\0\"    /* 1 */\n\t\t\"rows\\0\"    /* 2 */\n\t\t\"cols\\0\"    /* 3 */\n\t\t\"columns\\0\" /* 4 */\n\t\t\"size\\0\"    /* 5 */\n\t\t\"speed\\0\"   /* 6 */\n\t\t\"ispeed\\0\"\n\t\t\"ospeed\\0\";\n\tint i = index_in_strings(params, name) + 1;\n\tif (i == 0)\n\t\treturn 0;\n\tif (i != 5 && i != 6)\n\t\ti |= 0x80;\n\treturn i;\n}\n\n## Example:\n\n Input assembly code:\n0x004D3816 | 55 | push    rbp\n0x004D3817 | 48 89 E5 | mov     rbp, rsp\n0x004D381A | 48 83 EC 20 | sub     rsp, 20h\n0x004D381E | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004D3822 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004D3826 | 48 89 C6 | mov     rsi, rax\n0x004D3829 | BF 60 3A 52 00 | mov     edi, offset aEvenp; \"evenp\"\n0x004D382E | E8 33 2E 02 00 | call    sub_4F6666\n0x004D3833 | 89 45 FC | mov     [rbp+var_4], eax\n0x004D3836 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004D383A | 78 11 | js      short loc_4D384D\n0x004D383C | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004D383F | 48 98 | cdqe\n0x004D3841 | 48 C1 E0 03 | shl     rax, 3\n0x004D3845 | 48 05 60 3C 52 00 | add     rax, 523C60h\n0x004D384B | EB 05 | jmp     short locret_4D3852\n0x004D384D | B8 00 00 00 00 | mov     eax, 0\n0x004D3852 | C9 | leave\n0x004D3853 | C3 | retn\n\n Ourput decompiled code:\nstatic const struct mode_info *find_mode(const char *name)\n{\n\tint i = index_in_strings(mode_name, name);\n\treturn i >= 0 ? &mode_info[i] : NULL;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004FF94D | 55 | push    rbp\n0x004FF94E | 48 89 E5 | mov     rbp, rsp\n0x004FF951 | 48 83 EC 20 | sub     rsp, 20h\n0x004FF955 | 48 89 7D E8 | mov     [rbp+nptr], rdi\n0x004FF959 | C7 45 FC FF 00 00 00 | mov     [rbp+var_4], 0FFh\n0x004FF960 | 48 83 7D E8 00 | cmp     [rbp+nptr], 0\n0x004FF965 | 74 2C | jz      short loc_4FF993\n0x004FF967 | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x004FF96B | 48 89 C7 | mov     rdi, rax; nptr\n0x004FF96E | E8 4D 80 F0 FF | call    _atoi\n0x004FF973 | 89 45 FC | mov     [rbp+var_4], eax\n0x004FF976 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004FF97A | 7F 07 | jg      short loc_4FF983\n0x004FF97C | B8 01 00 00 00 | mov     eax, 1\n0x004FF981 | EB 13 | jmp     short locret_4FF996\n0x004FF983 | 81 7D FC FF 00 00 00 | cmp     [rbp+var_4], 0FFh\n0x004FF98A | 7E 07 | jle     short loc_4FF993\n0x004FF98C | B8 FF 00 00 00 | mov     eax, 0FFh\n0x004FF991 | EB 03 | jmp     short locret_4FF996\n0x004FF993 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004FF996 | C9 | leave\n0x004FF997 | C3 | retn",
        "output": "\nstatic int parse_int(const char *nptr)\n{\n\tint n = -1;\n\n\tif (*nptr) {\n\t\tn = atoi(nptr);\n\t\tif (n <= 0 || n > 255)\n\t\t\tn = -1;\n\t}\n\n\treturn n;\n}",
        "source_code": "0\n\nunsigned size_from_HISTFILESIZE(const char *hp)\n{\n\tint size = MAX_HISTORY;\n\tif (hp) {\n\t\tsize = atoi(hp);\n\t\tif (size <= 0)\n\t\t\treturn 1;\n\t\tif (size > MAX_HISTORY)\n\t\t\treturn MAX_HISTORY;\n\t}\n\treturn size;\n}",
        "parsed_output": "\nstatic int parse_int(const char *nptr)\n{\n\tint n = -1;\n\n\tif (*nptr) {\n\t\tn = atoi(nptr);\n\t\tif (n <= 0 || n > 255)\n\t\t\tn = -1;\n\t}\n\n\treturn n;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4FF94D(const char *a1)\n{\n  int v2; // [rsp+1Ch] [rbp-4h]\n\n  v2 = 255;\n  if ( !a1 )\n    return (unsigned int)v2;\n  v2 = atoi(a1);\n  if ( v2 <= 0 )\n    return 1LL;\n  if ( v2 > 255 )\n    return 255LL;\n  else\n    return (unsigned int)v2;\n}\n",
        "baseline_code_debug": "unsigned int __cdecl size_from_HISTFILESIZE(const char *hp)\n{\n  signed int size; // [rsp+1Ch] [rbp-4h]\n\n  size = 255;\n  if ( !hp )\n    return size;\n  size = atoi(hp);\n  if ( size <= 0 )\n    return 1;\n  if ( size > 255 )\n    return 255;\n  else\n    return size;\n}\n",
        "similarity_score_unixcoder": 0.566662073135376,
        "similarity_score_baseline_stripped": 0.49767521023750305,
        "similarity_score_baseline_debug": 0.8438743948936462
    },
    {
        "func_name": "strncmpz",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004BB517 | 55 | push    rbp\n0x004BB518 | 48 89 E5 | mov     rbp, rsp\n0x004BB51B | 48 83 EC 30 | sub     rsp, 30h\n0x004BB51F | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004BB523 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004BB527 | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x004BB52B | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x004BB52F | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004BB533 | 48 89 D6 | mov     rsi, rdx\n0x004BB536 | 48 89 C7 | mov     rdi, rax\n0x004BB539 | E8 02 FF FF FF | call    sub_4BB440\n0x004BB53E | 89 45 FC | mov     [rbp+var_4], eax\n0x004BB541 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004BB545 | 8B 00 | mov     eax, [rax]\n0x004BB547 | 8D 14 00 | lea     edx, [rax+rax]\n0x004BB54A | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004BB54D | 01 C2 | add     edx, eax\n0x004BB54F | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004BB553 | 89 10 | mov     [rax], edx\n0x004BB555 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004BB558 | C9 | leave\n0x004BB559 | C3 | retn\n\n Ourput decompiled code:\nstatic speed_inline int rc_get_bit(rc_t *rc, uint16_t *p, int *symbol)\n{\n\tint ret = rc_is_bit_1(rc, p);\n\t*symbol = *symbol * 2 + ret;\n\treturn ret;\n}\n\n## Example:\n\n Input assembly code:\n0x0040A3CA | 55 | push    rbp\n0x0040A3CB | 48 89 E5 | mov     rbp, rsp\n0x0040A3CE | 48 83 EC 20 | sub     rsp, 20h\n0x0040A3D2 | 48 89 7D E8 | mov     [rbp+old], rdi\n0x0040A3D6 | 48 89 75 E0 | mov     [rbp+new], rsi\n0x0040A3DA | 48 8B 55 E0 | mov     rdx, [rbp+new]\n0x0040A3DE | 48 8B 45 E8 | mov     rax, [rbp+old]\n0x0040A3E2 | 48 89 D6 | mov     rsi, rdx; new\n0x0040A3E5 | 48 89 C7 | mov     rdi, rax; old\n0x0040A3E8 | E8 A3 D4 FF FF | call    _rename\n0x0040A3ED | 89 45 FC | mov     [rbp+var_4], eax\n0x0040A3F0 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x0040A3F4 | 74 1A | jz      short loc_40A410\n0x0040A3F6 | 48 8B 55 E0 | mov     rdx, [rbp+new]\n0x0040A3FA | 48 8B 45 E8 | mov     rax, [rbp+old]\n0x0040A3FE | 48 89 C6 | mov     rsi, rax\n0x0040A401 | BF 34 80 52 00 | mov     edi, offset aCanTMoveSToS; \"can't move '%s' to '%s'\"\n0x0040A406 | B8 00 00 00 00 | mov     eax, 0\n0x0040A40B | E8 C9 ED FF FF | call    sub_4091D9\n0x0040A410 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0040A413 | C9 | leave\n0x0040A414 | C3 | retn\n\n Ourput decompiled code:\nint FAST_FUNC rename_or_warn(const char *oldpath, const char *newpath)\n{\n\tint n = rename(oldpath, newpath);\n\tif (n)\n\t\tbb_perror_msg(\"can't move '%s' to '%s'\", oldpath, newpath);\n\treturn n;\n}\n\n## Example:\n\n Input assembly code:\n0x00497671 | 55 | push    rbp\n0x00497672 | 48 89 E5 | mov     rbp, rsp\n0x00497675 | 48 83 EC 20 | sub     rsp, 20h\n0x00497679 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0049767D | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00497681 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00497685 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00497689 | 48 89 D6 | mov     rsi, rdx\n0x0049768C | 48 89 C7 | mov     rdi, rax\n0x0049768F | E8 29 EC FF FF | call    sub_4962BD\n0x00497694 | 89 45 FC | mov     [rbp+var_4], eax\n0x00497697 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x0049769B | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0049769E | 48 89 D6 | mov     rsi, rdx\n0x004976A1 | 89 C7 | mov     edi, eax\n0x004976A3 | E8 65 FE FF FF | call    sub_49750D\n0x004976A8 | 89 45 FC | mov     [rbp+var_4], eax\n0x004976AB | 83 7D FC FF | cmp     [rbp+var_4], 0FFFFFFFFh\n0x004976AF | 75 10 | jnz     short loc_4976C1\n0x004976B1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004976B5 | 66 C7 00 00 00 | mov     word ptr [rax], 0\n0x004976BA | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x004976C1 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004976C4 | C9 | leave\n0x004976C5 | C3 | retn\n\n Ourput decompiled code:\nstatic int add_zone(uint16_t *znr, smallint *corrected)\n{\n\tint block;\n\n\tblock = check_zone_nr(znr, corrected);\n\tblock = add_zone_common(block, corrected);\n\tif (block == -1) {\n\t\t*znr = 0;\n\t\tblock = 0;\n\t}\n\treturn block;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004317A8 | 55 | push    rbp\n0x004317A9 | 48 89 E5 | mov     rbp, rsp\n0x004317AC | 48 83 EC 30 | sub     rsp, 30h\n0x004317B0 | 48 89 7D E8 | mov     [rbp+s1], rdi\n0x004317B4 | 48 89 75 E0 | mov     [rbp+s2], rsi\n0x004317B8 | 48 89 55 D8 | mov     [rbp+n], rdx\n0x004317BC | 48 8B 55 D8 | mov     rdx, [rbp+n]; n\n0x004317C0 | 48 8B 4D E0 | mov     rcx, [rbp+s2]\n0x004317C4 | 48 8B 45 E8 | mov     rax, [rbp+s1]\n0x004317C8 | 48 89 CE | mov     rsi, rcx; s2\n0x004317CB | 48 89 C7 | mov     rdi, rax; s1\n0x004317CE | E8 CD 4F FD FF | call    _strncmp\n0x004317D3 | 89 45 FC | mov     [rbp+var_4], eax\n0x004317D6 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004317DA | 75 15 | jnz     short loc_4317F1\n0x004317DC | 48 8B 55 E0 | mov     rdx, [rbp+s2]\n0x004317E0 | 48 8B 45 D8 | mov     rax, [rbp+n]\n0x004317E4 | 48 01 D0 | add     rax, rdx\n0x004317E7 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004317EA | 0F B6 C0 | movzx   eax, al\n0x004317ED | F7 D8 | neg     eax\n0x004317EF | EB 03 | jmp     short locret_4317F4\n0x004317F1 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004317F4 | C9 | leave\n0x004317F5 | C3 | retn",
        "output": "\n\nstatic int FAST_FUNC cmp_str(const char *s1, const char *s2, size_t n)\n{\n\tint ret = strncmp(s1, s2, n);\n\tif (ret == 0)\n\t\tret = (unsigned char)s2[n] ^ 0xFF;\n\treturn ret;\n}",
        "source_code": "static int strncmpz(const char *l, const char *r, size_t llen)\n{\n\tint i = strncmp(l, r, llen);\n\n\tif (i == 0)\n\t\treturn - (unsigned char)r[llen];\n\treturn i;\n}",
        "parsed_output": "\n\nstatic int FAST_FUNC cmp_str(const char *s1, const char *s2, size_t n)\n{\n\tint ret = strncmp(s1, s2, n);\n\tif (ret == 0)\n\t\tret = (unsigned char)s2[n] ^ 0xFF;\n\treturn ret;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4317A8(const char *a1, const char *a2, size_t a3)\n{\n  unsigned int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = strncmp(a1, a2, a3);\n  if ( v5 )\n    return v5;\n  else\n    return (unsigned int)-(unsigned __int8)a2[a3];\n}\n",
        "baseline_code_debug": "int __cdecl strncmpz(const char *l, const char *r, size_t llen)\n{\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  i = strncmp(l, r, llen);\n  if ( i )\n    return i;\n  else\n    return -(unsigned __int8)r[llen];\n}\n",
        "similarity_score_unixcoder": 0.781193196773529,
        "similarity_score_baseline_stripped": 0.5575990676879883,
        "similarity_score_baseline_debug": 0.7797098755836487
    },
    {
        "func_name": "iac_flush",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0049C7AA | 55 | push    rbp\n0x0049C7AB | 48 89 E5 | mov     rbp, rsp\n0x0049C7AE | B8 38 B4 75 00 | mov     eax, offset stru_75B438\n0x0049C7B3 | BA 80 00 00 00 | mov     edx, 80h; n\n0x0049C7B8 | BE 00 00 00 00 | mov     esi, 0; c\n0x0049C7BD | 48 89 C7 | mov     rdi, rax; s\n0x0049C7C0 | E8 8B A5 F6 FF | call    _memset\n0x0049C7C5 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0049C7CA | C7 40 48 FF FF FF FF | mov     dword ptr [rax+48h], 0FFFFFFFFh\n0x0049C7D1 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0049C7D6 | C7 40 44 B0 01 00 00 | mov     dword ptr [rax+44h], 1B0h\n0x0049C7DD | 90 | nop\n0x0049C7DE | 5D | pop     rbp\n0x0049C7DF | C3 | retn\n\n Ourput decompiled code:\nif ENABLE_FEATURE_MDEV_CONF\n\nstatic void make_default_cur_rule(void)\n{\n\tmemset(&G.cur_rule, 0, sizeof(G.cur_rule));\n\tG.cur_rule.maj = -1; /* \"not a @major,minor rule\" */\n\tG.cur_rule.mode = 0660;\n}\n\n## Example:\n\n Input assembly code:\n0x00443AA3 | 55 | push    rbp\n0x00443AA4 | 48 89 E5 | mov     rbp, rsp\n0x00443AA7 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00443AAC | 48 8B 80 38 02 00 00 | mov     rax, [rax+238h]\n0x00443AB3 | 48 89 C1 | mov     rcx, rax\n0x00443AB6 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00443ABB | 48 8B 80 30 02 00 00 | mov     rax, [rax+230h]\n0x00443AC2 | 48 89 C2 | mov     rdx, rax\n0x00443AC5 | B8 40 B6 75 00 | mov     eax, offset unk_75B640\n0x00443ACA | BE 00 00 00 00 | mov     esi, 0\n0x00443ACF | 48 89 C7 | mov     rdi, rax\n0x00443AD2 | E8 8A 0B 0C 00 | call    sub_504661\n0x00443AD7 | 90 | nop\n0x00443AD8 | 5D | pop     rbp\n0x00443AD9 | C3 | retn\n\n Ourput decompiled code:\nif ENABLE_FEATURE_TFTP_PROGRESS_BAR\nstatic void tftp_progress_update(void)\n{\n\tbb_progress_update(&G.pmt, 0, G.pos, G.size);\n}\n\n## Example:\n\n Input assembly code:\n0x00443ADA | 55 | push    rbp\n0x00443ADB | 48 89 E5 | mov     rbp, rsp\n0x00443ADE | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00443AE3 | 48 8B 80 40 02 00 00 | mov     rax, [rax+240h]\n0x00443AEA | BA 40 B6 75 00 | mov     edx, offset unk_75B640\n0x00443AEF | 48 89 C6 | mov     rsi, rax\n0x00443AF2 | 48 89 D7 | mov     rdi, rdx\n0x00443AF5 | E8 04 0B 0C 00 | call    sub_5045FE\n0x00443AFA | E8 A4 FF FF FF | call    sub_443AA3\n0x00443AFF | 90 | nop\n0x00443B00 | 5D | pop     rbp\n0x00443B01 | C3 | retn\n\n Ourput decompiled code:\nstatic void tftp_progress_init(void)\n{\n\tbb_progress_init(&G.pmt, G.file);\n\ttftp_progress_update();\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00441A2B | 55 | push    rbp\n0x00441A2C | 48 89 E5 | mov     rbp, rsp\n0x00441A2F | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00441A34 | 8B 00 | mov     eax, [rax]\n0x00441A36 | 48 98 | cdqe\n0x00441A38 | B9 A0 B4 75 00 | mov     ecx, offset qword_75B4A0\n0x00441A3D | 48 89 C2 | mov     rdx, rax; n\n0x00441A40 | 48 89 CE | mov     rsi, rcx; buf\n0x00441A43 | BF 03 00 00 00 | mov     edi, 3; fd\n0x00441A48 | E8 13 4F FC FF | call    _write\n0x00441A4D | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00441A52 | C7 00 00 00 00 00 | mov     dword ptr [rax], 0\n0x00441A58 | 90 | nop\n0x00441A59 | 5D | pop     rbp\n0x00441A5A | C3 | retn",
        "output": "\n\nstatic void\ntftp_progress_close(void)\n{\n\twrite(3, G.file, (size_t)G.pos, (off_t) &dest->pos);\n\tdest->pos = 0;\n}",
        "source_code": "static void iac_flush(void)\n{\n\twrite(netfd, G.iacbuf, G.iaclen);\n\tG.iaclen = 0;\n}",
        "parsed_output": "\n\nstatic void\ntftp_progress_close(void)\n{\n\twrite(3, G.file, (size_t)G.pos, (off_t) &dest->pos);\n\tdest->pos = 0;\n}",
        "baseline_code_stripped": "struct termios *sub_441A2B()\n{\n  struct termios *result; // rax\n\n  write(3, &qword_75B4A0, (int)dest.c_iflag);\n  result = &dest;\n  dest.c_iflag = 0;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl iac_flush()\n{\n  write(3, &qword_75B4A0, (int)bb_common_bufsiz1.c_iflag);\n  bb_common_bufsiz1.c_iflag = 0;\n}\n",
        "similarity_score_unixcoder": 0.5687670111656189,
        "similarity_score_baseline_stripped": 0.47276219725608826,
        "similarity_score_baseline_debug": 0.6510634422302246
    },
    {
        "func_name": "get_trimmed_slice",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004C57E8 | 55 | push    rbp\n0x004C57E9 | 48 89 E5 | mov     rbp, rsp\n0x004C57EC | 48 83 EC 20 | sub     rsp, 20h\n0x004C57F0 | 48 89 7D E8 | mov     [rbp+s], rdi\n0x004C57F4 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x004C57F8 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004C57FC | EB 05 | jmp     short loc_4C5803\n0x004C57FE | 48 83 45 F8 01 | add     [rbp+var_8], 1\n0x004C5803 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C5807 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004C580A | 84 C0 | test    al, al\n0x004C580C | 75 F0 | jnz     short loc_4C57FE\n0x004C580E | EB 3B | jmp     short loc_4C584B\n0x004C5810 | 48 83 6D F8 01 | sub     [rbp+var_8], 1\n0x004C5815 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C5819 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004C581C | 83 E8 09 | sub     eax, 9\n0x004C581F | 88 45 F7 | mov     [rbp+var_9], al\n0x004C5822 | 80 7D F7 17 | cmp     [rbp+var_9], 17h\n0x004C5826 | 74 06 | jz      short loc_4C582E\n0x004C5828 | 80 7D F7 04 | cmp     [rbp+var_9], 4\n0x004C582C | 77 07 | ja      short loc_4C5835\n0x004C582E | B8 01 00 00 00 | mov     eax, 1\n0x004C5833 | EB 05 | jmp     short loc_4C583A\n0x004C5835 | B8 00 00 00 00 | mov     eax, 0\n0x004C583A | 85 C0 | test    eax, eax\n0x004C583C | 75 0D | jnz     short loc_4C584B\n0x004C583E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C5842 | 48 83 C0 01 | add     rax, 1\n0x004C5846 | C6 00 00 | mov     byte ptr [rax], 0\n0x004C5849 | EB 0A | jmp     short loc_4C5855\n0x004C584B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C584F | 48 3B 45 E8 | cmp     rax, [rbp+s]\n0x004C5853 | 75 BB | jnz     short loc_4C5810\n0x004C5855 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x004C5859 | 48 89 C7 | mov     rdi, rax; s\n0x004C585C | E8 AF 0F F4 FF | call    _puts\n0x004C5861 | 90 | nop\n0x004C5862 | C9 | leave\n0x004C5863 | C3 | retn\n\n Ourput decompiled code:\nstatic void trim_trailing_spaces_and_print(char *s)\n{\n\tchar *p = s;\n\n\twhile (*p) {\n\t\t++p;\n\t}\n\twhile (p != s) {\n\t\t--p;\n\t\tif (!isspace(*p)) {\n\t\t\tp[1] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tputs(s);\n}\n\n## Example:\n\n Input assembly code:\n0x0048E12B | 55 | push    rbp\n0x0048E12C | 48 89 E5 | mov     rbp, rsp\n0x0048E12F | 48 83 EC 20 | sub     rsp, 20h\n0x0048E133 | 48 89 7D E8 | mov     [rbp+nptr], rdi\n0x0048E137 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x0048E13B | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x0048E13F | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0048E142 | 83 E8 30 | sub     eax, 30h ; '0'\n0x0048E145 | 3C 09 | cmp     al, 9\n0x0048E147 | 77 0E | ja      short loc_48E157\n0x0048E149 | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x0048E14D | 48 89 C7 | mov     rdi, rax; nptr\n0x0048E150 | E8 6B 98 F7 FF | call    _atoi\n0x0048E155 | EB 43 | jmp     short locret_48E19A\n0x0048E157 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0048E15B | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0048E15F | EB 28 | jmp     short loc_48E189\n0x0048E161 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048E165 | 48 8B 10 | mov     rdx, [rax]\n0x0048E168 | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x0048E16C | 48 89 D6 | mov     rsi, rdx; s2\n0x0048E16F | 48 89 C7 | mov     rdi, rax; s1\n0x0048E172 | E8 49 85 F7 FF | call    _strcasecmp\n0x0048E177 | 85 C0 | test    eax, eax\n0x0048E179 | 75 09 | jnz     short loc_48E184\n0x0048E17B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048E17F | 8B 40 08 | mov     eax, [rax+8]\n0x0048E182 | EB 16 | jmp     short locret_48E19A\n0x0048E184 | 48 83 45 F8 10 | add     [rbp+var_8], 10h\n0x0048E189 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048E18D | 48 8B 00 | mov     rax, [rax]\n0x0048E190 | 48 85 C0 | test    rax, rax\n0x0048E193 | 75 CC | jnz     short loc_48E161\n0x0048E195 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x0048E19A | C9 | leave\n0x0048E19B | C3 | retn\n\n Ourput decompiled code:\nstatic int decode(char *name, const CODE *codetab)\n{\n\tconst CODE *c;\n\n\tif (isdigit(*name))\n\t\treturn atoi(name);\n\tfor (c = codetab; c->c_name; c++) {\n\t\tif (!strcasecmp(name, c->c_name)) {\n\t\t\treturn c->c_val;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n## Example:\n\n Input assembly code:\n0x004CFBB7 | 55 | push    rbp\n0x004CFBB8 | 48 89 E5 | mov     rbp, rsp\n0x004CFBBB | 48 83 EC 20 | sub     rsp, 20h\n0x004CFBBF | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004CFBC3 | EB 57 | jmp     short loc_4CFC1C\n0x004CFBC5 | 48 83 45 E8 01 | add     [rbp+var_18], 1\n0x004CFBCA | 80 7D FF 5C | cmp     [rbp+var_1], 5Ch ; '\\'\n0x004CFBCE | 75 41 | jnz     short loc_4CFC11\n0x004CFBD0 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CFBD4 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004CFBD7 | 3C 30 | cmp     al, 30h ; '0'\n0x004CFBD9 | 75 17 | jnz     short loc_4CFBF2\n0x004CFBDB | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CFBDF | 48 83 C0 01 | add     rax, 1\n0x004CFBE3 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004CFBE6 | 83 E8 30 | sub     eax, 30h ; '0'\n0x004CFBE9 | 3C 07 | cmp     al, 7\n0x004CFBEB | 77 05 | ja      short loc_4CFBF2\n0x004CFBED | 48 83 45 E8 01 | add     [rbp+var_18], 1\n0x004CFBF2 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CFBF6 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x004CFBFA | 48 8D 45 F0 | lea     rax, [rbp+var_10]\n0x004CFBFE | 48 89 C7 | mov     rdi, rax\n0x004CFC01 | E8 84 34 03 00 | call    sub_50308A\n0x004CFC06 | 88 45 FF | mov     [rbp+var_1], al\n0x004CFC09 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004CFC0D | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x004CFC11 | 0F BE 45 FF | movsx   eax, [rbp+var_1]\n0x004CFC15 | 89 C7 | mov     edi, eax; c\n0x004CFC17 | E8 D4 75 F3 FF | call    _putchar_unlocked\n0x004CFC1C | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004CFC20 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004CFC23 | 88 45 FF | mov     [rbp+var_1], al\n0x004CFC26 | 80 7D FF 00 | cmp     [rbp+var_1], 0\n0x004CFC2A | 75 99 | jnz     short loc_4CFBC5\n0x004CFC2C | 90 | nop\n0x004CFC2D | C9 | leave\n0x004CFC2E | C3 | retn\n\n Ourput decompiled code:\nstatic void print_esc_string(const char *str)\n{\n\tchar c;\n\twhile ((c = *str) != '\\0') {\n\t\tstr++;\n\t\tif (c == '\\\\') {\n\t\t\t/* %b also accepts 4-digit octals of the form \\0### */\n\t\t\tif (*str == '0') {\n\t\t\t\tif ((unsigned char)(str[1] - '0') < 8) {\n\t\t\t\t\t/* 2nd char is 0..7: skip leading '0' */\n\t\t\t\t\tstr++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\t/* optimization: don't force arg to be on-stack,\n\t\t\t\t * use another variable for that. */\n\t\t\t\tconst char *z = str;\n\t\t\t\tc = bb_process_escape_sequence(&z);\n\t\t\t\tstr = z;\n\t\t\t}\n\t\t}\n\t\tputchar(c);\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00408145 | 55 | push    rbp\n0x00408146 | 48 89 E5 | mov     rbp, rsp\n0x00408149 | 48 83 EC 20 | sub     rsp, 20h\n0x0040814D | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00408151 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00408155 | EB 29 | jmp     short loc_408180\n0x00408157 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0040815B | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0040815E | 83 E8 09 | sub     eax, 9\n0x00408161 | 88 45 FF | mov     [rbp+var_1], al\n0x00408164 | 80 7D FF 17 | cmp     [rbp+var_1], 17h\n0x00408168 | 74 06 | jz      short loc_408170\n0x0040816A | 80 7D FF 04 | cmp     [rbp+var_1], 4\n0x0040816E | 77 07 | ja      short loc_408177\n0x00408170 | B8 01 00 00 00 | mov     eax, 1\n0x00408175 | EB 05 | jmp     short loc_40817C\n0x00408177 | B8 00 00 00 00 | mov     eax, 0\n0x0040817C | 85 C0 | test    eax, eax\n0x0040817E | 74 14 | jz      short loc_408194\n0x00408180 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00408184 | 48 8D 50 FF | lea     rdx, [rax-1]\n0x00408188 | 48 89 55 E0 | mov     [rbp+var_20], rdx\n0x0040818C | 48 39 45 E8 | cmp     [rbp+var_18], rax\n0x00408190 | 72 C5 | jb      short loc_408157\n0x00408192 | EB 01 | jmp     short loc_408195\n0x00408194 | 90 | nop\n0x00408195 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00408199 | 48 83 C0 01 | add     rax, 1\n0x0040819D | C6 00 00 | mov     byte ptr [rax], 0\n0x004081A0 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004081A4 | 48 89 C7 | mov     rdi, rax\n0x004081A7 | E8 08 12 00 00 | call    sub_4093B4\n0x004081AC | C9 | leave\n0x004081AD | C3 | retn",
        "output": "\n\nstatic void\nprint_esc_string(const char *str, const CODE *codetab)\n{\n\tchar c;\n\twhile ((c = *str) != '\\0') {\n\t\tstr++;\n\t\tif (c == '\\\\') {\n\t\t\tc = decode(str, codetab);\n\t\t\tstr++;\n\t\t}\n\t\tputchar(c);\n\t}\n}",
        "source_code": "static char *get_trimmed_slice(char *s, char *e)\n{\n\t/* First, consider the value at e to be nul and back up until we\n\t * reach a non-space char.  Set the char after that (possibly at\n\t * the original e) to nul. */\n\twhile (e-- > s) {\n\t\tif (!isspace(*e)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\te[1] = '\\0';\n\n\t/* Next, advance past all leading space and return a ptr to the\n\t * first non-space char; possibly the terminating nul. */\n\treturn skip_whitespace(s);\n}",
        "parsed_output": "\n\nstatic void\nprint_esc_string(const char *str, const CODE *codetab)\n{\n\tchar c;\n\twhile ((c = *str) != '\\0') {\n\t\tstr++;\n\t\tif (c == '\\\\') {\n\t\t\tc = decode(str, codetab);\n\t\t\tstr++;\n\t\t}\n\t\tputchar(c);\n\t}\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_408145(unsigned __int64 a1, _BYTE *a2)\n{\n  _BYTE *v3; // rax\n\n  do\n  {\n    v3 = a2--;\n    if ( a1 >= (unsigned __int64)v3 )\n      break;\n  }\n  while ( *a2 == 32 || (unsigned __int8)(*a2 - 9) <= 4u );\n  a2[1] = 0;\n  return sub_4093B4(a1);\n}\n",
        "baseline_code_debug": "char *__cdecl get_trimmed_slice(char *s, char *e)\n{\n  char *v3; // rax\n\n  do\n  {\n    v3 = e--;\n    if ( s >= v3 )\n      break;\n  }\n  while ( *e == 32 || (unsigned __int8)(*e - 9) <= 4u );\n  e[1] = 0;\n  return skip_whitespace(s);\n}\n",
        "similarity_score_unixcoder": 0.5772653222084045,
        "similarity_score_baseline_stripped": 0.5633623003959656,
        "similarity_score_baseline_debug": 0.8151691555976868
    },
    {
        "func_name": "print_closing_wait",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0041A462 | 55 | push    rbp\n0x0041A463 | 48 89 E5 | mov     rbp, rsp\n0x0041A466 | 48 83 EC 10 | sub     rsp, 10h\n0x0041A46A | 89 7D FC | mov     [rbp+var_4], edi\n0x0041A46D | 83 7D FC 01 | cmp     [rbp+var_4], 1\n0x0041A471 | 75 0C | jnz     short loc_41A47F\n0x0041A473 | BF 01 00 00 00 | mov     edi, 1\n0x0041A478 | E8 3F D7 FF FF | call    sub_417BBC\n0x0041A47D | EB 38 | jmp     short loc_41A4B7\n0x0041A47F | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x0041A483 | 75 0C | jnz     short loc_41A491\n0x0041A485 | BF 00 00 00 00 | mov     edi, 0\n0x0041A48A | E8 2D D7 FF FF | call    sub_417BBC\n0x0041A48F | EB 26 | jmp     short loc_41A4B7\n0x0041A491 | 83 7D FC 02 | cmp     [rbp+var_4], 2\n0x0041A495 | 75 0C | jnz     short loc_41A4A3\n0x0041A497 | BF DB 69 51 00 | mov     edi, offset aTristate; \" (tristate)\"\n0x0041A49C | E8 6F C3 FE FF | call    _puts\n0x0041A4A1 | EB 14 | jmp     short loc_41A4B7\n0x0041A4A3 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0041A4A6 | 89 C6 | mov     esi, eax\n0x0041A4A8 | BF E7 69 51 00 | mov     edi, offset aUnknownD; \" (unknown: %d)\\n\"\n0x0041A4AD | B8 00 00 00 00 | mov     eax, 0\n0x0041A4B2 | E8 19 C7 FE FF | call    _printf\n0x0041A4B7 | 90 | nop\n0x0041A4B8 | C9 | leave\n0x0041A4B9 | C3 | retn\n\n Ourput decompiled code:\nif ENABLE_FEATURE_HDPARM_HDIO_TRISTATE_HWIF\nstatic void bus_state_value(unsigned value)\n{\n\tif (value == BUSSTATE_ON)\n\t\ton_off(1);\n\telse if (value == BUSSTATE_OFF)\n\t\ton_off(0);\n\telse if (value == BUSSTATE_TRISTATE)\n\t\tprintf(\" (tristate)\\n\");\n\telse\n\t\tprintf(\" (unknown: %d)\\n\", value);\n}\n\n## Example:\n\n Input assembly code:\n0x00421F28 | 55 | push    rbp\n0x00421F29 | 48 89 E5 | mov     rbp, rsp\n0x00421F2C | 48 83 EC 10 | sub     rsp, 10h\n0x00421F30 | 89 7D FC | mov     [rbp+var_4], edi\n0x00421F33 | 83 7D FC 13 | cmp     [rbp+var_4], 13h\n0x00421F37 | 7E 07 | jle     short loc_421F40\n0x00421F39 | B8 6E 75 51 00 | mov     eax, offset aUndefined; \"undefined\"\n0x00421F3E | EB 0F | jmp     short locret_421F4F\n0x00421F40 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00421F43 | 89 C6 | mov     esi, eax\n0x00421F45 | BF A0 73 51 00 | mov     edi, offset aUnknown_4; \"unknown\"\n0x00421F4A | E8 1C 48 0D 00 | call    sub_4F676B\n0x00421F4F | C9 | leave\n0x00421F50 | C3 | retn\n\n Ourput decompiled code:\nstatic const char *uart_type(int type)\n{\n\tif (type > MAX_SERIAL_TYPE)\n\t\treturn \"undefined\";\n\n\treturn nth_string(serial_types, type);\n}\n\n## Example:\n\n Input assembly code:\n0x00417BBC | 55 | push    rbp\n0x00417BBD | 48 89 E5 | mov     rbp, rsp\n0x00417BC0 | 48 83 EC 10 | sub     rsp, 10h\n0x00417BC4 | 89 7D FC | mov     [rbp+var_4], edi\n0x00417BC7 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x00417BCB | 74 07 | jz      short loc_417BD4\n0x00417BCD | B8 E0 52 51 00 | mov     eax, offset aOn; \" (on)\"\n0x00417BD2 | EB 05 | jmp     short loc_417BD9\n0x00417BD4 | B8 E6 52 51 00 | mov     eax, offset aOff; \" (off)\"\n0x00417BD9 | 48 89 C7 | mov     rdi, rax; s\n0x00417BDC | E8 2F EC FE FF | call    _puts\n0x00417BE1 | 90 | nop\n0x00417BE2 | C9 | leave\n0x00417BE3 | C3 | retn\n\n Ourput decompiled code:\nendif\n\nstatic void on_off(int value)\n{\n\tputs(value ? \" (on)\" : \" (off)\");\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00422354 | 55 | push    rbp\n0x00422355 | 48 89 E5 | mov     rbp, rsp\n0x00422358 | 48 83 EC 10 | sub     rsp, 10h\n0x0042235C | 89 7D FC | mov     [rbp+var_4], edi\n0x0042235F | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x00422363 | 74 15 | jz      short loc_42237A\n0x00422365 | 81 7D FC FF FF 00 00 | cmp     [rbp+var_4], 0FFFFh\n0x0042236C | 75 18 | jnz     short loc_422386\n0x0042236E | BF 69 75 51 00 | mov     edi, offset aNone_1; \"none\"\n0x00422373 | E8 98 44 FE FF | call    _puts\n0x00422378 | EB 20 | jmp     short loc_42239A\n0x0042237A | BF 60 75 51 00 | mov     edi, offset aInfinite; \"infinite\"\n0x0042237F | E8 8C 44 FE FF | call    _puts\n0x00422384 | EB 14 | jmp     short loc_42239A\n0x00422386 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00422389 | 89 C6 | mov     esi, eax\n0x0042238B | BF DB 75 51 00 | mov     edi, offset aU_5; \"%u\\n\"\n0x00422390 | B8 00 00 00 00 | mov     eax, 0\n0x00422395 | E8 36 48 FE FF | call    _printf\n0x0042239A | 90 | nop\n0x0042239B | C9 | leave\n0x0042239C | C3 | retn",
        "output": "\n\nstatic void bus_width_value(unsigned value)\n{\n\tif (value == 0)\n\t\tputs(\"none\");\n\telse if (value == 0xFFFF)\n\t\tputs(\"infinite\");\n\telse\n\t\tprintf(\"%u\\n\", value);\n}",
        "source_code": "static void print_closing_wait(unsigned int closing_wait)\n{\n\tswitch (closing_wait) {\n\tcase ASYNC_CLOSING_WAIT_NONE:\n\t\tputs(STR_NONE);\n\t\tbreak;\n\tcase ASYNC_CLOSING_WAIT_INF:\n\t\tputs(STR_INFINITE);\n\t\tbreak;\n\tdefault:\n\t\tprintf(\"%u\\n\", closing_wait);\n\t}\n}",
        "parsed_output": "\n\nstatic void bus_width_value(unsigned value)\n{\n\tif (value == 0)\n\t\tputs(\"none\");\n\telse if (value == 0xFFFF)\n\t\tputs(\"infinite\");\n\telse\n\t\tprintf(\"%u\\n\", value);\n}",
        "baseline_code_stripped": "int __fastcall sub_422354(unsigned int a1)\n{\n  if ( !a1 )\n    return puts(\"infinite\");\n  if ( a1 == 0xFFFF )\n    return puts(\"none\");\n  return printf(\"%u\\n\", a1);\n}\n",
        "baseline_code_debug": "void __cdecl print_closing_wait(unsigned int closing_wait)\n{\n  if ( closing_wait )\n  {\n    if ( closing_wait == 0xFFFF )\n      puts(\"none\");\n    else\n      printf(\"%u\\n\", closing_wait);\n  }\n  else\n  {\n    puts(\"infinite\");\n  }\n}\n",
        "similarity_score_unixcoder": 0.5513184070587158,
        "similarity_score_baseline_stripped": 0.6266295909881592,
        "similarity_score_baseline_debug": 0.8534532785415649
    },
    {
        "func_name": "xdup2",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0040AA15 | 55 | push    rbp\n0x0040AA16 | 48 89 E5 | mov     rbp, rsp\n0x0040AA19 | 48 83 EC 10 | sub     rsp, 10h\n0x0040AA1D | 89 7D FC | mov     [rbp+fd], edi\n0x0040AA20 | 89 75 F8 | mov     [rbp+n], esi\n0x0040AA23 | 8B 55 F8 | mov     edx, [rbp+n]\n0x0040AA26 | 8B 45 FC | mov     eax, [rbp+fd]\n0x0040AA29 | 89 D6 | mov     esi, edx; n\n0x0040AA2B | 89 C7 | mov     edi, eax; fd\n0x0040AA2D | E8 1E CA FF FF | call    _listen\n0x0040AA32 | 85 C0 | test    eax, eax\n0x0040AA34 | 74 0F | jz      short loc_40AA45\n0x0040AA36 | BF 3A 81 52 00 | mov     edi, offset aListen_0; \"listen\"\n0x0040AA3B | B8 00 00 00 00 | mov     eax, 0\n0x0040AA40 | E8 5D E8 FF FF | call    sub_4092A2\n0x0040AA45 | 90 | nop\n0x0040AA46 | C9 | leave\n0x0040AA47 | C3 | retn\n\n Ourput decompiled code:\nvoid FAST_FUNC xlisten(int s, int backlog)\n{\n\tif (listen(s, backlog)) bb_perror_msg_and_die(\"listen\");\n}\n\n## Example:\n\n Input assembly code:\n0x00471133 | 55 | push    rbp\n0x00471134 | 48 89 E5 | mov     rbp, rsp\n0x00471137 | 48 83 EC 10 | sub     rsp, 10h\n0x0047113B | 89 7D FC | mov     [rbp+fd], edi\n0x0047113E | 89 75 F8 | mov     [rbp+pgrp_id], esi\n0x00471141 | 8B 55 F8 | mov     edx, [rbp+pgrp_id]\n0x00471144 | 8B 45 FC | mov     eax, [rbp+fd]\n0x00471147 | 89 D6 | mov     esi, edx; pgrp_id\n0x00471149 | 89 C7 | mov     edi, eax; fd\n0x0047114B | E8 70 66 F9 FF | call    _tcsetpgrp\n0x00471150 | 85 C0 | test    eax, eax\n0x00471152 | 74 0F | jz      short loc_471163\n0x00471154 | BF 98 C9 51 00 | mov     edi, offset aCanTSetTtyProc; \"can't set tty process group (%m)\"\n0x00471159 | B8 00 00 00 00 | mov     eax, 0\n0x0047115E | E8 10 D3 FF FF | call    sub_46E473\n0x00471163 | 90 | nop\n0x00471164 | C9 | leave\n0x00471165 | C3 | retn\n\n Ourput decompiled code:\nif JOBS\nstatic void\nxtcsetpgrp(int fd, pid_t pgrp)\n{\n\tif (tcsetpgrp(fd, pgrp))\n\t\tash_msg_and_raise_error(\"can't set tty process group (%m)\");\n}\n\n## Example:\n\n Input assembly code:\n0x0040A477 | 55 | push    rbp\n0x0040A478 | 48 89 E5 | mov     rbp, rsp\n0x0040A47B | 48 83 EC 10 | sub     rsp, 10h\n0x0040A47F | 89 7D FC | mov     [rbp+fd], edi\n0x0040A482 | 89 75 F8 | mov     [rbp+var_8], esi\n0x0040A485 | 8B 45 FC | mov     eax, [rbp+fd]\n0x0040A488 | 3B 45 F8 | cmp     eax, [rbp+var_8]\n0x0040A48B | 74 1B | jz      short loc_40A4A8\n0x0040A48D | 8B 55 F8 | mov     edx, [rbp+var_8]\n0x0040A490 | 8B 45 FC | mov     eax, [rbp+fd]\n0x0040A493 | 89 D6 | mov     esi, edx\n0x0040A495 | 89 C7 | mov     edi, eax\n0x0040A497 | E8 A7 FF FF FF | call    sub_40A443\n0x0040A49C | 8B 45 FC | mov     eax, [rbp+fd]\n0x0040A49F | 89 C7 | mov     edi, eax; fd\n0x0040A4A1 | E8 6A C9 FF FF | call    _close\n0x0040A4A6 | EB 01 | jmp     short locret_40A4A9\n0x0040A4A8 | 90 | nop\n0x0040A4A9 | C9 | leave\n0x0040A4AA | C3 | retn\n\n Ourput decompiled code:\nopened fd\nvoid FAST_FUNC xmove_fd(int from, int to)\n{\n\tif (from == to)\n\t\treturn;\n\txdup2(from, to);\n\tclose(from);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040A443 | 55 | push    rbp\n0x0040A444 | 48 89 E5 | mov     rbp, rsp\n0x0040A447 | 48 83 EC 10 | sub     rsp, 10h\n0x0040A44B | 89 7D FC | mov     [rbp+fd], edi\n0x0040A44E | 89 75 F8 | mov     [rbp+fd2], esi\n0x0040A451 | 8B 55 F8 | mov     edx, [rbp+fd2]\n0x0040A454 | 8B 45 FC | mov     eax, [rbp+fd]\n0x0040A457 | 89 D6 | mov     esi, edx; fd2\n0x0040A459 | 89 C7 | mov     edi, eax; fd\n0x0040A45B | E8 20 C7 FF FF | call    _dup2\n0x0040A460 | 39 45 F8 | cmp     [rbp+fd2], eax\n0x0040A463 | 74 0F | jz      short loc_40A474\n0x0040A465 | BF 60 80 52 00 | mov     edi, offset aCanTDuplicateF; \"can't duplicate file descriptor\"\n0x0040A46A | B8 00 00 00 00 | mov     eax, 0\n0x0040A46F | E8 2E EE FF FF | call    sub_4092A2\n0x0040A474 | 90 | nop\n0x0040A475 | C9 | leave\n0x0040A476 | C3 | retn",
        "output": "\nstatic void\nxmove_fd(int from, int to)\n{\n\tif (dup2(from, to) != to)\n\t\tbb_perror_msg_and_die(\"can't duplicate file descriptor\");\n}",
        "source_code": "void FAST_FUNC xdup2(int from, int to)\n{\n\tif (dup2(from, to) != to)\n\t\tbb_perror_msg_and_die(\"can't duplicate file descriptor\");\n}",
        "parsed_output": "\nstatic void\nxmove_fd(int from, int to)\n{\n\tif (dup2(from, to) != to)\n\t\tbb_perror_msg_and_die(\"can't duplicate file descriptor\");\n}",
        "baseline_code_stripped": "int __fastcall sub_40A443(int a1, unsigned int a2)\n{\n  int result; // eax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n\n  result = dup2(a1, a2);\n  if ( a2 != result )\n    sub_4092A2((__int64)\"can't duplicate file descriptor\", a2, v3, v4, v5, v6);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl xdup2(int from, int to)\n{\n  if ( to != dup2(from, to) )\n    bb_perror_msg_and_die(\"can't duplicate file descriptor\");\n}\n",
        "similarity_score_unixcoder": 0.9427112340927124,
        "similarity_score_baseline_stripped": 0.661356508731842,
        "similarity_score_baseline_debug": 0.926609992980957
    },
    {
        "func_name": "setlogcons_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0042408D | 55 | push    rbp\n0x0042408E | 48 89 E5 | mov     rbp, rsp\n0x00424091 | 48 83 EC 40 | sub     rsp, 40h\n0x00424095 | 89 7D CC | mov     [rbp+var_34], edi\n0x00424098 | 48 89 75 C0 | mov     [rbp+var_40], rsi\n0x0042409C | 48 C7 45 F8 FE 56 53 00 | mov     [rbp+var_8], offset aDevCdrom_0; \"/dev/cdrom\"\n0x004240A4 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004240A8 | 48 83 C0 08 | add     rax, 8\n0x004240AC | 48 8B 00 | mov     rax, [rax]\n0x004240AF | 48 85 C0 | test    rax, rax\n0x004240B2 | 74 21 | jz      short loc_4240D5\n0x004240B4 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004240B8 | 48 8B 40 08 | mov     rax, [rax+8]\n0x004240BC | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004240C0 | 48 8B 45 C0 | mov     rax, [rbp+var_40]\n0x004240C4 | 48 83 C0 10 | add     rax, 10h\n0x004240C8 | 48 8B 00 | mov     rax, [rax]\n0x004240CB | 48 85 C0 | test    rax, rax\n0x004240CE | 74 05 | jz      short loc_4240D5\n0x004240D0 | E8 8F 3E FE FF | call    sub_407F64\n0x004240D5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004240D9 | BE 00 00 00 00 | mov     esi, 0\n0x004240DE | 48 89 C7 | mov     rdi, rax\n0x004240E1 | E8 AF 61 FE FF | call    sub_40A295\n0x004240E6 | 89 45 F4 | mov     [rbp+var_C], eax\n0x004240E9 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x004240EC | BA 00 00 00 00 | mov     edx, 0\n0x004240F1 | BE 28 80 00 00 | mov     esi, 8028h\n0x004240F6 | 89 C7 | mov     edi, eax\n0x004240F8 | E8 5A 64 FE FF | call    sub_40A557\n0x004240FD | 48 8D 4D D0 | lea     rcx, [rbp+var_30]\n0x00424101 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00424104 | BA 20 00 00 00 | mov     edx, 20h ; ' '\n0x00424109 | 48 89 CE | mov     rsi, rcx\n0x0042410C | 89 C7 | mov     edi, eax\n0x0042410E | E8 3F 33 0E 00 | call    sub_507452\n0x00424113 | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00424117 | 48 89 C6 | mov     rsi, rax\n0x0042411A | BF 09 57 53 00 | mov     edi, offset a3232s; \"%32.32s\\n\"\n0x0042411F | B8 00 00 00 00 | mov     eax, 0\n0x00424124 | E8 A7 2A FE FF | call    _printf\n0x00424129 | B8 00 00 00 00 | mov     eax, 0\n0x0042412E | C9 | leave\n0x0042412F | C3 | retn\n\n Ourput decompiled code:\nint volname_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint fd;\n\tchar buffer[32];\n\tconst char *device;\n\n\tdevice = \"/dev/cdrom\";\n\tif (argv[1]) {\n\t\tdevice = argv[1];\n\t\tif (argv[2])\n\t\t\tbb_show_usage();\n\t}\n\n\tfd = xopen(device, O_RDONLY);\n\txlseek(fd, 32808, SEEK_SET);\n\txread(fd, buffer, 32);\n\tprintf(\"%32.32s\\n\", buffer);\n\tif (ENABLE_FEATURE_CLEAN_UP) {\n\t\tclose(fd);\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x00479364 | 55 | push    rbp\n0x00479365 | 48 89 E5 | mov     rbp, rsp\n0x00479368 | 48 83 EC 10 | sub     rsp, 10h\n0x0047936C | 89 7D FC | mov     [rbp+var_4], edi\n0x0047936F | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x00479373 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00479377 | 48 83 C0 08 | add     rax, 8\n0x0047937B | 48 8B 00 | mov     rax, [rax]\n0x0047937E | 48 85 C0 | test    rax, rax\n0x00479381 | 74 4C | jz      short loc_4793CF\n0x00479383 | 48 8B 05 8E 40 2E 00 | mov     rax, cs:qword_75D418\n0x0047938A | C6 40 3C 00 | mov     byte ptr [rax+3Ch], 0\n0x0047938E | 48 8B 05 83 40 2E 00 | mov     rax, cs:qword_75D418\n0x00479395 | C6 40 3D 00 | mov     byte ptr [rax+3Dh], 0\n0x00479399 | E8 E9 F9 FF FF | call    sub_478D87\n0x0047939E | 48 8B 05 7B 40 2E 00 | mov     rax, cs:qword_75D420\n0x004793A5 | 48 05 60 01 00 00 | add     rax, 160h\n0x004793AB | 48 83 C0 20 | add     rax, 20h ; ' '\n0x004793AF | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004793B3 | 48 8D 48 05 | lea     rcx, [rax+5]\n0x004793B7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004793BB | 48 83 C0 08 | add     rax, 8\n0x004793BF | BA 00 00 00 00 | mov     edx, 0\n0x004793C4 | 48 89 CE | mov     rsi, rcx\n0x004793C7 | 48 89 C7 | mov     rdi, rax\n0x004793CA | E8 06 D9 FF FF | call    sub_476CD5\n0x004793CF | B8 00 00 00 00 | mov     eax, 0\n0x004793D4 | C9 | leave\n0x004793D5 | C3 | retn\n\n Ourput decompiled code:\nstatic int FAST_FUNC\nexeccmd(int argc UNUSED_PARAM, char **argv)\n{\n\tif (argv[1]) {\n\t\tiflag = 0;              /* exit on error */\n\t\tmflag = 0;\n\t\toptschanged();\n\t\tshellexec(argv + 1, pathval(), 0);\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x004C35B6 | 55 | push    rbp\n0x004C35B7 | 48 89 E5 | mov     rbp, rsp\n0x004C35BA | 53 | push    rbx\n0x004C35BB | 48 83 EC 28 | sub     rsp, 28h\n0x004C35BF | 89 7D DC | mov     [rbp+var_24], edi\n0x004C35C2 | 48 89 75 D0 | mov     [rbp+var_30], rsi\n0x004C35C6 | C7 45 EC 00 00 00 00 | mov     [rbp+var_14], 0\n0x004C35CD | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x004C35D1 | 48 83 C0 08 | add     rax, 8\n0x004C35D5 | 48 8B 00 | mov     rax, [rax]\n0x004C35D8 | 48 85 C0 | test    rax, rax\n0x004C35DB | 74 35 | jz      short loc_4C3612\n0x004C35DD | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x004C35E1 | 48 83 C0 10 | add     rax, 10h\n0x004C35E5 | 48 8B 00 | mov     rax, [rax]\n0x004C35E8 | 48 85 C0 | test    rax, rax\n0x004C35EB | 74 05 | jz      short loc_4C35F2\n0x004C35ED | E8 72 49 F4 FF | call    sub_407F64\n0x004C35F2 | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x004C35F6 | 48 83 C0 08 | add     rax, 8\n0x004C35FA | 48 8B 00 | mov     rax, [rax]\n0x004C35FD | BA 3F 00 00 00 | mov     edx, 3Fh ; '?'\n0x004C3602 | BE 01 00 00 00 | mov     esi, 1\n0x004C3607 | 48 89 C7 | mov     rdi, rax\n0x004C360A | E8 8D 7A 04 00 | call    sub_50B09C\n0x004C360F | 89 45 EC | mov     [rbp+var_14], eax\n0x004C3612 | 8B 45 EC | mov     eax, [rbp+var_14]\n0x004C3615 | 48 98 | cdqe\n0x004C3617 | 48 89 C3 | mov     rbx, rax\n0x004C361A | E8 05 67 03 00 | call    sub_4F9D24\n0x004C361F | B9 DF 68 53 00 | mov     ecx, offset aVtDisallocate; \"VT_DISALLOCATE\"\n0x004C3624 | 48 89 DA | mov     rdx, rbx\n0x004C3627 | BE 08 56 00 00 | mov     esi, 5608h\n0x004C362C | 89 C7 | mov     edi, eax\n0x004C362E | E8 1E 77 F4 FF | call    sub_40AD51\n0x004C3633 | B8 00 00 00 00 | mov     eax, 0\n0x004C3638 | 48 83 C4 28 | add     rsp, 28h\n0x004C363C | 5B | pop     rbx\n0x004C363D | 5D | pop     rbp\n0x004C363E | C3 | retn\n\n Ourput decompiled code:\nint deallocvt_main(int argc UNUSED_PARAM, char **argv)\n{\n\t/* num = 0 deallocate all unused consoles */\n\tint num = 0;\n\n\tif (argv[1]) {\n\t\tif (argv[2])\n\t\t\tbb_show_usage();\n\t\tnum = xatou_range(argv[1], 1, 63);\n\t}\n\n\t/* double cast suppresses \"cast to ptr from int of different size\" */\n\txioctl(get_console_fd_or_die(), VT_DISALLOCATE, (void *)(ptrdiff_t)num);\n\treturn EXIT_SUCCESS;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C49F4 | 55 | push    rbp\n0x004C49F5 | 48 89 E5 | mov     rbp, rsp\n0x004C49F8 | 48 83 EC 20 | sub     rsp, 20h\n0x004C49FC | 89 7D EC | mov     [rbp+var_14], edi\n0x004C49FF | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004C4A03 | C6 45 FE 0B | mov     [rbp+var_2], 0Bh\n0x004C4A07 | C6 45 FF 00 | mov     [rbp+var_1], 0\n0x004C4A0B | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004C4A0F | 48 83 C0 08 | add     rax, 8\n0x004C4A13 | 48 8B 00 | mov     rax, [rax]\n0x004C4A16 | 48 85 C0 | test    rax, rax\n0x004C4A19 | 74 20 | jz      short loc_4C4A3B\n0x004C4A1B | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004C4A1F | 48 83 C0 08 | add     rax, 8\n0x004C4A23 | 48 8B 00 | mov     rax, [rax]\n0x004C4A26 | BA 3F 00 00 00 | mov     edx, 3Fh ; '?'\n0x004C4A2B | BE 00 00 00 00 | mov     esi, 0\n0x004C4A30 | 48 89 C7 | mov     rdi, rax\n0x004C4A33 | E8 64 66 04 00 | call    sub_50B09C\n0x004C4A38 | 88 45 FF | mov     [rbp+var_1], al\n0x004C4A3B | BE 00 00 00 00 | mov     esi, 0\n0x004C4A40 | BF 4C 6A 53 00 | mov     edi, offset aDevTty1; \"/dev/tty1\"\n0x004C4A45 | E8 4B 58 F4 FF | call    sub_40A295\n0x004C4A4A | 89 C7 | mov     edi, eax\n0x004C4A4C | 48 8D 45 FE | lea     rax, [rbp+var_2]\n0x004C4A50 | B9 56 6A 53 00 | mov     ecx, offset aTioclinux; \"TIOCLINUX\"\n0x004C4A55 | 48 89 C2 | mov     rdx, rax\n0x004C4A58 | BE 1C 54 00 00 | mov     esi, 541Ch\n0x004C4A5D | E8 EF 62 F4 FF | call    sub_40AD51\n0x004C4A62 | B8 00 00 00 00 | mov     eax, 0\n0x004C4A67 | C9 | leave\n0x004C4A68 | C3 | retn",
        "output": "\n\nint tioclinux_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint fd;\n\tint val = 11;\n\tunsigned char mode = 0;\n\n\tif (argv[1]) {\n\t\tif (argv[2])\n\t\t\tbb_show_usage();\n\t\tmode = xatou_range(argv[1], 0, 63);\n\t}\n\n\tfd = xopen(\"/dev/tty1\", O_RDWR);\n\txioctl(fd, TIOCLINUX, &val);\n\treturn EXIT_SUCCESS;\n}",
        "source_code": "int setlogcons_main(int argc UNUSED_PARAM, char **argv)\n{\n\tstruct {\n\t\tchar fn;\n\t\tchar subarg;\n\t} arg = {\n\t\t11, /* redirect kernel messages */\n\t\t0   /* to specified console (current as default) */\n\t};\n\n\tif (argv[1])\n\t\targ.subarg = xatou_range(argv[1], 0, 63);\n\n\txioctl(xopen(VC_1, O_RDONLY), TIOCLINUX, &arg);\n\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "\n\nint tioclinux_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint fd;\n\tint val = 11;\n\tunsigned char mode = 0;\n\n\tif (argv[1]) {\n\t\tif (argv[2])\n\t\t\tbb_show_usage();\n\t\tmode = xatou_range(argv[1], 0, 63);\n\t}\n\n\tfd = xopen(\"/dev/tty1\", O_RDWR);\n\txioctl(fd, TIOCLINUX, &val);\n\treturn EXIT_SUCCESS;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4C49F4(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  char v4; // [rsp+1Eh] [rbp-2h] BYREF\n  char v5; // [rsp+1Fh] [rbp-1h]\n\n  v4 = 11;\n  v5 = 0;\n  if ( *(_QWORD *)(a2 + 8) )\n    v5 = sub_50B09C(*(_QWORD *)(a2 + 8), 0LL, 63LL);\n  v2 = sub_40A295(\"/dev/tty1\", 0);\n  sub_40AD51(v2, 0x541Cu, (__int64)&v4, (__int64)\"TIOCLINUX\");\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl setlogcons_main(int argc, char **argv)\n{\n  int v2; // eax\n  setlogcons_main::$23BE6824809191D382C73B1FF0181EB2 arg; // [rsp+1Eh] [rbp-2h] BYREF\n\n  arg.fn = 11;\n  arg.subarg = 0;\n  if ( argv[1] )\n    arg.subarg = xatou_range(argv[1], 0, 0x3Fu);\n  v2 = xopen(\"/dev/tty1\", 0);\n  bb_xioctl(v2, 0x541Cu, &arg, \"TIOCLINUX\");\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.7580670118331909,
        "similarity_score_baseline_stripped": 0.612819492816925,
        "similarity_score_baseline_debug": 0.8217524886131287
    },
    {
        "func_name": "free_instance",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004B882D | 55 | push    rbp\n0x004B882E | 48 89 E5 | mov     rbp, rsp\n0x004B8831 | 48 83 EC 10 | sub     rsp, 10h\n0x004B8835 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004B8839 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004B883D | 48 8B 40 60 | mov     rax, [rax+60h]\n0x004B8841 | 48 89 C7 | mov     rdi, rax\n0x004B8844 | E8 A7 FF FF FF | call    sub_4B87F0\n0x004B8849 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004B884D | 48 8B 40 68 | mov     rax, [rax+68h]\n0x004B8851 | 48 89 C7 | mov     rdi, rax\n0x004B8854 | E8 97 FF FF FF | call    sub_4B87F0\n0x004B8859 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004B885D | 48 C7 40 60 00 00 00 00 | mov     qword ptr [rax+60h], 0\n0x004B8865 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004B8869 | 48 C7 40 68 00 00 00 00 | mov     qword ptr [rax+68h], 0\n0x004B8871 | 90 | nop\n0x004B8872 | C9 | leave\n0x004B8873 | C3 | retn\n\n Ourput decompiled code:\nstatic void huft_free_all(STATE_PARAM_ONLY)\n{\n\thuft_free(inflate_codes_tl);\n\thuft_free(inflate_codes_td);\n\tinflate_codes_tl = NULL;\n\tinflate_codes_td = NULL;\n}\n\n## Example:\n\n Input assembly code:\n0x005024BD | 55 | push    rbp\n0x005024BE | 48 89 E5 | mov     rbp, rsp\n0x005024C1 | 48 83 EC 10 | sub     rsp, 10h\n0x005024C5 | 48 89 7D F8 | mov     [rbp+ptr], rdi\n0x005024C9 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0\n0x005024CE | 74 4B | jz      short loc_50251B\n0x005024D0 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x005024D4 | 48 8B 40 08 | mov     rax, [rax+8]\n0x005024D8 | 48 89 C7 | mov     rdi, rax; ptr\n0x005024DB | E8 80 41 F0 FF | call    _free\n0x005024E0 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x005024E4 | 48 8B 00 | mov     rax, [rax]\n0x005024E7 | 48 89 C7 | mov     rdi, rax; stream\n0x005024EA | E8 11 45 F0 FF | call    _fclose\n0x005024EF | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x005024F3 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x005024F7 | 48 89 C7 | mov     rdi, rax; ptr\n0x005024FA | E8 61 41 F0 FF | call    _free\n0x005024FF | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00502503 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x00502507 | 48 89 C7 | mov     rdi, rax; ptr\n0x0050250A | E8 51 41 F0 FF | call    _free\n0x0050250F | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00502513 | 48 89 C7 | mov     rdi, rax; ptr\n0x00502516 | E8 45 41 F0 FF | call    _free\n0x0050251B | 90 | nop\n0x0050251C | C9 | leave\n0x0050251D | C3 | retn\n\n Ourput decompiled code:\nvoid FAST_FUNC config_close(parser_t *parser)\n{\n\tif (parser) {\n\t\tif (PARSE_KEEP_COPY) /* compile-time constant */\n\t\t\tfree(parser->data);\n\t\tfclose(parser->fp);\n\t\tfree(parser->line);\n\t\tfree(parser->nline);\n\t\tfree(parser);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x0050346D | 55 | push    rbp\n0x0050346E | 48 89 E5 | mov     rbp, rsp\n0x00503471 | 48 83 EC 10 | sub     rsp, 10h\n0x00503475 | 48 89 7D F8 | mov     [rbp+ptr], rdi\n0x00503479 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x0050347D | 48 8B 00 | mov     rax, [rax]\n0x00503480 | 48 89 C7 | mov     rdi, rax; dirp\n0x00503483 | E8 08 3A F0 FF | call    _closedir\n0x00503488 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x0050348C | 48 8B 40 08 | mov     rax, [rax+8]\n0x00503490 | 48 85 C0 | test    rax, rax\n0x00503493 | 74 10 | jz      short loc_5034A5\n0x00503495 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x00503499 | 48 8B 40 08 | mov     rax, [rax+8]\n0x0050349D | 48 89 C7 | mov     rdi, rax; dirp\n0x005034A0 | E8 EB 39 F0 FF | call    _closedir\n0x005034A5 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x005034A9 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x005034AD | 48 89 C7 | mov     rdi, rax; ptr\n0x005034B0 | E8 AB 31 F0 FF | call    _free\n0x005034B5 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x005034B9 | 48 8B 40 20 | mov     rax, [rax+20h]\n0x005034BD | 48 89 C7 | mov     rdi, rax; ptr\n0x005034C0 | E8 9B 31 F0 FF | call    _free\n0x005034C5 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x005034C9 | 48 89 C7 | mov     rdi, rax; ptr\n0x005034CC | E8 8F 31 F0 FF | call    _free\n0x005034D1 | 90 | nop\n0x005034D2 | C9 | leave\n0x005034D3 | C3 | retn\n\n Ourput decompiled code:\nvoid FAST_FUNC free_procps_scan(procps_status_t* sp)\n{\n\tclosedir(sp->dir);\n#if ENABLE_FEATURE_SHOW_THREADS\n\tif (sp->task_dir)\n\t\tclosedir(sp->task_dir);\n#endif\n\tfree(sp->argv0);\n\tfree(sp->exe);\n\tIF_SELINUX(free(sp->context);)\n\tfree(sp);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004DA7BB | 55 | push    rbp\n0x004DA7BC | 48 89 E5 | mov     rbp, rsp\n0x004DA7BF | 48 83 EC 10 | sub     rsp, 10h\n0x004DA7C3 | 48 89 7D F8 | mov     [rbp+ptr], rdi\n0x004DA7C7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004DA7CB | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004DA7CF | 48 89 C7 | mov     rdi, rax; ptr\n0x004DA7D2 | E8 89 BE F2 FF | call    _free\n0x004DA7D7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004DA7DB | 48 8B 40 18 | mov     rax, [rax+18h]\n0x004DA7DF | 48 89 C7 | mov     rdi, rax; ptr\n0x004DA7E2 | E8 79 BE F2 FF | call    _free\n0x004DA7E7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004DA7EB | 48 8B 40 20 | mov     rax, [rax+20h]\n0x004DA7EF | 48 89 C7 | mov     rdi, rax; ptr\n0x004DA7F2 | E8 69 BE F2 FF | call    _free\n0x004DA7F7 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004DA7FB | 48 89 C7 | mov     rdi, rax; ptr\n0x004DA7FE | E8 5D BE F2 FF | call    _free\n0x004DA803 | 90 | nop\n0x004DA804 | C9 | leave\n0x004DA805 | C3 | retn",
        "output": "",
        "source_code": "static void free_instance(struct fsck_instance *p)\n{\n\tfree(p->prog);\n\tfree(p->device);\n\tfree(p->base_device);\n\tfree(p);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "void __fastcall sub_4DA7BB(void **a1)\n{\n  free(a1[2]);\n  free(a1[3]);\n  free(a1[4]);\n  free(a1);\n}\n",
        "baseline_code_debug": "void __cdecl free_instance(fsck_instance *p)\n{\n  free(p->prog);\n  free(p->device);\n  free(p->base_device);\n  free(p);\n}\n",
        "similarity_score_unixcoder": 0.04433828592300415,
        "similarity_score_baseline_stripped": 0.5425723791122437,
        "similarity_score_baseline_debug": 0.929505467414856
    },
    {
        "func_name": "builtin_exec",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0048931C | 55 | push    rbp\n0x0048931D | 48 89 E5 | mov     rbp, rsp\n0x00489320 | 48 83 EC 10 | sub     rsp, 10h\n0x00489324 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00489328 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048932C | 48 89 C7 | mov     rdi, rax\n0x0048932F | E8 19 FE FF FF | call    sub_48914D\n0x00489334 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00489338 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048933C | 48 8B 00 | mov     rax, [rax]\n0x0048933F | 48 85 C0 | test    rax, rax\n0x00489342 | 75 15 | jnz     short loc_489359\n0x00489344 | 48 8B 05 BD 40 2D 00 | mov     rax, cs:qword_75D408\n0x0048934B | 0F B6 40 4F | movzx   eax, byte ptr [rax+4Fh]\n0x0048934F | 0F B6 C0 | movzx   eax, al\n0x00489352 | 89 C7 | mov     edi, eax\n0x00489354 | E8 F1 70 FF FF | call    sub_48044A\n0x00489359 | C6 05 E8 1A 2D 00 FF | mov     cs:byte_75AE48, 0FFh\n0x00489360 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00489364 | 48 8B 00 | mov     rax, [rax]\n0x00489367 | 48 89 C7 | mov     rdi, rax\n0x0048936A | E8 68 1F 08 00 | call    sub_50B2D7\n0x0048936F | 0F B6 C0 | movzx   eax, al\n0x00489372 | 89 C7 | mov     edi, eax\n0x00489374 | E8 D1 70 FF FF | call    sub_48044A\n\n Ourput decompiled code:\nstatic int FAST_FUNC builtin_exit(char **argv)\n{\n\tdebug_printf_exec(\"%s()\\n\", __func__);\n\n\t/* interactive bash:\n\t * # trap \"echo EEE\" EXIT\n\t * # exit\n\t * exit\n\t * There are stopped jobs.\n\t * (if there are _stopped_ jobs, running ones don't count)\n\t * # exit\n\t * exit\n\t * EEE (then bash exits)\n\t *\n\t * TODO: we can use G.exiting = -1 as indicator \"last cmd was exit\"\n\t */\n\n\t/* note: EXIT trap is run by hush_exit */\n\targv = skip_dash_dash(argv);\n\tif (argv[0] == NULL)\n\t\thush_exit(G.last_exitcode);\n\t/* mimic bash: exit 123abc == exit 255 + error msg */\n\txfunc_error_retval = 255;\n\t/* bash: exit -2 == exit 254, no error msg */\n\thush_exit(xatoi(argv[0]) & 0xff);\n}\n\n## Example:\n\n Input assembly code:\n0x004367CC | 55 | push    rbp\n0x004367CD | 48 89 E5 | mov     rbp, rsp\n0x004367D0 | 48 83 EC 10 | sub     rsp, 10h\n0x004367D4 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004367D8 | 89 75 F4 | mov     [rbp+var_C], esi\n0x004367DB | 48 8B 05 9E 49 32 00 | mov     rax, cs:ptr\n0x004367E2 | 48 89 C7 | mov     rdi, rax; ptr\n0x004367E5 | E8 76 FE FC FF | call    _free\n0x004367EA | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004367EE | 0F B7 00 | movzx   eax, word ptr [rax]\n0x004367F1 | 66 83 F8 FF | cmp     ax, 0FFFFh\n0x004367F5 | 74 0C | jz      short loc_436803\n0x004367F7 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004367FB | 0F B7 00 | movzx   eax, word ptr [rax]\n0x004367FE | 66 85 C0 | test    ax, ax\n0x00436801 | 75 07 | jnz     short loc_43680A\n0x00436803 | B8 20 95 51 00 | mov     eax, offset aNoneSet; \"[NONE SET]\"\n0x00436808 | EB 24 | jmp     short locret_43682E\n0x0043680A | 8B 4D F4 | mov     ecx, [rbp+var_C]\n0x0043680D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00436811 | BA 00 FF FF FF | mov     edx, 0FFFFFF00h\n0x00436816 | 89 CE | mov     esi, ecx\n0x00436818 | 48 89 C7 | mov     rdi, rax\n0x0043681B | E8 91 6E 0C 00 | call    sub_4FD6B1\n0x00436820 | 48 89 05 59 49 32 00 | mov     cs:ptr, rax\n0x00436827 | 48 8B 05 52 49 32 00 | mov     rax, cs:ptr\n0x0043682E | C9 | leave\n0x0043682F | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC INET_sprint(struct sockaddr *sap, int numeric)\n{\n\tstatic char *buff; /* defaults to NULL */\n\n\tfree(buff);\n\tif (sap->sa_family == 0xFFFF || sap->sa_family == 0)\n\t\treturn \"[NONE SET]\";\n\tbuff = INET_rresolve((struct sockaddr_in *) sap, numeric, 0xffffff00);\n\treturn buff;\n}\n\n## Example:\n\n Input assembly code:\n0x0043685A | 55 | push    rbp\n0x0043685B | 48 89 E5 | mov     rbp, rsp\n0x0043685E | 48 83 EC 10 | sub     rsp, 10h\n0x00436862 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00436866 | 89 75 F4 | mov     [rbp+var_C], esi\n0x00436869 | 48 8B 05 18 49 32 00 | mov     rax, cs:qword_75B188\n0x00436870 | 48 89 C7 | mov     rdi, rax; ptr\n0x00436873 | E8 E8 FD FC FF | call    _free\n0x00436878 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043687C | 0F B7 00 | movzx   eax, word ptr [rax]\n0x0043687F | 66 83 F8 FF | cmp     ax, 0FFFFh\n0x00436883 | 74 0C | jz      short loc_436891\n0x00436885 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00436889 | 0F B7 00 | movzx   eax, word ptr [rax]\n0x0043688C | 66 85 C0 | test    ax, ax\n0x0043688F | 75 07 | jnz     short loc_436898\n0x00436891 | B8 20 95 51 00 | mov     eax, offset aNoneSet; \"[NONE SET]\"\n0x00436896 | EB 1F | jmp     short locret_4368B7\n0x00436898 | 8B 55 F4 | mov     edx, [rbp+var_C]\n0x0043689B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043689F | 89 D6 | mov     esi, edx\n0x004368A1 | 48 89 C7 | mov     rdi, rax\n0x004368A4 | E8 B6 70 0C 00 | call    sub_4FD95F\n0x004368A9 | 48 89 05 D8 48 32 00 | mov     cs:qword_75B188, rax\n0x004368B0 | 48 8B 05 D1 48 32 00 | mov     rax, cs:qword_75B188\n0x004368B7 | C9 | leave\n0x004368B8 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC INET6_sprint(struct sockaddr *sap, int numeric)\n{\n\tstatic char *buff;\n\n\tfree(buff);\n\tif (sap->sa_family == 0xFFFF || sap->sa_family == 0)\n\t\treturn \"[NONE SET]\";\n\tbuff = INET6_rresolve((struct sockaddr_in6 *) sap, numeric);\n\treturn buff;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004892A0 | 55 | push    rbp\n0x004892A1 | 48 89 E5 | mov     rbp, rsp\n0x004892A4 | 48 83 EC 10 | sub     rsp, 10h\n0x004892A8 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004892AC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004892B0 | 48 89 C7 | mov     rdi, rax\n0x004892B3 | E8 95 FE FF FF | call    sub_48914D\n0x004892B8 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004892BC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004892C0 | 48 8B 00 | mov     rax, [rax]\n0x004892C3 | 48 85 C0 | test    rax, rax\n0x004892C6 | 75 07 | jnz     short loc_4892CF\n0x004892C8 | B8 00 00 00 00 | mov     eax, 0\n0x004892CD | EB 4B | jmp     short locret_48931A\n0x004892CF | 48 8B 05 32 41 2D 00 | mov     rax, cs:qword_75D408\n0x004892D6 | 8B 40 3C | mov     eax, [rax+3Ch]\n0x004892D9 | 85 C0 | test    eax, eax\n0x004892DB | 74 31 | jz      short loc_48930E\n0x004892DD | E8 9E D6 F7 FF | call    _getpid\n0x004892E2 | 89 C2 | mov     edx, eax\n0x004892E4 | 48 8B 05 1D 41 2D 00 | mov     rax, cs:qword_75D408\n0x004892EB | 8B 40 20 | mov     eax, [rax+20h]\n0x004892EE | 39 C2 | cmp     edx, eax\n0x004892F0 | 75 1C | jnz     short loc_48930E\n0x004892F2 | 48 8B 05 0F 41 2D 00 | mov     rax, cs:qword_75D408\n0x004892F9 | 8B 50 3C | mov     edx, [rax+3Ch]\n0x004892FC | 48 8B 05 05 41 2D 00 | mov     rax, cs:qword_75D408\n0x00489303 | 8B 00 | mov     eax, [rax]\n0x00489305 | 89 D6 | mov     esi, edx; pgrp_id\n0x00489307 | 89 C7 | mov     edi, eax; fd\n0x00489309 | E8 B2 E4 F7 FF | call    _tcsetpgrp\n0x0048930E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00489312 | 48 89 C7 | mov     rdi, rax\n0x00489315 | E8 46 D8 FF FF | call    sub_486B60\n0x0048931A | C9 | leave\n0x0048931B | C3 | retn",
        "output": "",
        "source_code": "static int FAST_FUNC builtin_exec(char **argv)\n{\n\targv = skip_dash_dash(argv);\n\tif (argv[0] == NULL)\n\t\treturn EXIT_SUCCESS; /* bash does this */\n\n\t/* Careful: we can end up here after [v]fork. Do not restore\n\t * tty pgrp then, only top-level shell process does that */\n\tif (G_saved_tty_pgrp && getpid() == G.root_pid)\n\t\ttcsetpgrp(G_interactive_fd, G_saved_tty_pgrp);\n\n\t/* TODO: if exec fails, bash does NOT exit! We do.\n\t * We'll need to undo trap cleanup (it's inside execvp_or_die)\n\t * and tcsetpgrp, and this is inherently racy.\n\t */\n\texecvp_or_die(argv);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4892A0(__int64 a1)\n{\n  const char **v2; // [rsp+8h] [rbp-8h]\n\n  v2 = (const char **)sub_48914D(a1);\n  if ( *v2 )\n  {\n    if ( *((_DWORD *)qword_75D408 + 15) && getpid() == *((_DWORD *)qword_75D408 + 8) )\n      tcsetpgrp(*(_DWORD *)qword_75D408, *((_DWORD *)qword_75D408 + 15));\n    sub_486B60(v2);\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl builtin_exec(char **argv)\n{\n  char **argva; // [rsp+8h] [rbp-8h]\n\n  argva = skip_dash_dash(argv);\n  if ( *argva )\n  {\n    if ( ptr_to_globals->speeds[2] && getpid() == LODWORD(ptr_to_globals->initstring) )\n      tcsetpgrp(ptr_to_globals->timeout, ptr_to_globals->speeds[2]);\n    execvp_or_die(argva);\n  }\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.0018001040443778038,
        "similarity_score_baseline_stripped": 0.5872774124145508,
        "similarity_score_baseline_debug": 0.7505084276199341
    },
    {
        "func_name": "setcmd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00479364 | 55 | push    rbp\n0x00479365 | 48 89 E5 | mov     rbp, rsp\n0x00479368 | 48 83 EC 10 | sub     rsp, 10h\n0x0047936C | 89 7D FC | mov     [rbp+var_4], edi\n0x0047936F | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x00479373 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00479377 | 48 83 C0 08 | add     rax, 8\n0x0047937B | 48 8B 00 | mov     rax, [rax]\n0x0047937E | 48 85 C0 | test    rax, rax\n0x00479381 | 74 4C | jz      short loc_4793CF\n0x00479383 | 48 8B 05 8E 40 2E 00 | mov     rax, cs:qword_75D418\n0x0047938A | C6 40 3C 00 | mov     byte ptr [rax+3Ch], 0\n0x0047938E | 48 8B 05 83 40 2E 00 | mov     rax, cs:qword_75D418\n0x00479395 | C6 40 3D 00 | mov     byte ptr [rax+3Dh], 0\n0x00479399 | E8 E9 F9 FF FF | call    sub_478D87\n0x0047939E | 48 8B 05 7B 40 2E 00 | mov     rax, cs:qword_75D420\n0x004793A5 | 48 05 60 01 00 00 | add     rax, 160h\n0x004793AB | 48 83 C0 20 | add     rax, 20h ; ' '\n0x004793AF | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004793B3 | 48 8D 48 05 | lea     rcx, [rax+5]\n0x004793B7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004793BB | 48 83 C0 08 | add     rax, 8\n0x004793BF | BA 00 00 00 00 | mov     edx, 0\n0x004793C4 | 48 89 CE | mov     rsi, rcx\n0x004793C7 | 48 89 C7 | mov     rdi, rax\n0x004793CA | E8 06 D9 FF FF | call    sub_476CD5\n0x004793CF | B8 00 00 00 00 | mov     eax, 0\n0x004793D4 | C9 | leave\n0x004793D5 | C3 | retn\n\n Ourput decompiled code:\nstatic int FAST_FUNC\nexeccmd(int argc UNUSED_PARAM, char **argv)\n{\n\tif (argv[1]) {\n\t\tiflag = 0;              /* exit on error */\n\t\tmflag = 0;\n\t\toptschanged();\n\t\tshellexec(argv + 1, pathval(), 0);\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x00470A25 | 55 | push    rbp\n0x00470A26 | 48 89 E5 | mov     rbp, rsp\n0x00470A29 | 48 83 EC 20 | sub     rsp, 20h\n0x00470A2D | 89 7D EC | mov     [rbp+var_14], edi\n0x00470A30 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00470A34 | EB 15 | jmp     short loc_470A4B\n0x00470A36 | 83 7D FC 61 | cmp     [rbp+var_4], 61h ; 'a'\n0x00470A3A | 75 0F | jnz     short loc_470A4B\n0x00470A3C | E8 D6 FD FF FF | call    sub_470817\n0x00470A41 | B8 00 00 00 00 | mov     eax, 0\n0x00470A46 | E9 88 00 00 00 | jmp     locret_470AD3\n0x00470A4B | BF 67 C8 51 00 | mov     edi, offset aA_4; \"a\"\n0x00470A50 | E8 E3 E5 FF FF | call    sub_46F038\n0x00470A55 | 89 45 FC | mov     [rbp+var_4], eax\n0x00470A58 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x00470A5C | 75 D8 | jnz     short loc_470A36\n0x00470A5E | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x00470A65 | EB 5A | jmp     short loc_470AC1\n0x00470A67 | 48 8B 05 EA A4 2E 00 | mov     rax, cs:qword_75AF58\n0x00470A6E | 48 8B 00 | mov     rax, [rax]\n0x00470A71 | 48 89 C7 | mov     rdi, rax\n0x00470A74 | E8 3A FD FF FF | call    sub_4707B3\n0x00470A79 | 85 C0 | test    eax, eax\n0x00470A7B | 74 32 | jz      short loc_470AAF\n0x00470A7D | 48 8B 05 D4 A4 2E 00 | mov     rax, cs:qword_75AF58\n0x00470A84 | 48 8B 10 | mov     rdx, [rax]\n0x00470A87 | 48 8B 05 32 A4 2E 00 | mov     rax, cs:stderr\n0x00470A8E | 48 89 D1 | mov     rcx, rdx\n0x00470A91 | BA 69 C8 51 00 | mov     edx, offset aUnalias; \"unalias\"\n0x00470A96 | BE 55 C8 51 00 | mov     esi, offset aSSNotFound; \"%s: %s not found\\n\"\n0x00470A9B | 48 89 C7 | mov     rdi, rax; stream\n0x00470A9E | B8 00 00 00 00 | mov     eax, 0\n0x00470AA3 | E8 28 66 F9 FF | call    _fprintf\n0x00470AA8 | C7 45 FC 01 00 00 00 | mov     [rbp+var_4], 1\n0x00470AAF | 48 8B 05 A2 A4 2E 00 | mov     rax, cs:qword_75AF58\n0x00470AB6 | 48 83 C0 08 | add     rax, 8\n0x00470ABA | 48 89 05 97 A4 2E 00 | mov     cs:qword_75AF58, rax\n0x00470AC1 | 48 8B 05 90 A4 2E 00 | mov     rax, cs:qword_75AF58\n0x00470AC8 | 48 8B 00 | mov     rax, [rax]\n0x00470ACB | 48 85 C0 | test    rax, rax\n0x00470ACE | 75 97 | jnz     short loc_470A67\n0x00470AD0 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00470AD3 | C9 | leave\n0x00470AD4 | C3 | retn\n\n Ourput decompiled code:\nstatic int FAST_FUNC\nunaliascmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tint i;\n\n\twhile ((i = nextopt(\"a\")) != '\\0') {\n\t\tif (i == 'a') {\n\t\t\trmaliases();\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (i = 0; *argptr; argptr++) {\n\t\tif (unalias(*argptr)) {\n\t\t\tfprintf(stderr, \"%s: %s not found\\n\", \"unalias\", *argptr);\n\t\t\ti = 1;\n\t\t}\n\t}\n\n\treturn i;\n}\n\n## Example:\n\n Input assembly code:\n0x0047E306 | 55 | push    rbp\n0x0047E307 | 48 89 E5 | mov     rbp, rsp\n0x0047E30A | 48 83 EC 10 | sub     rsp, 10h\n0x0047E30E | 89 7D FC | mov     [rbp+var_4], edi\n0x0047E311 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x0047E315 | E8 E2 4C FF FF | call    sub_472FFC\n0x0047E31A | 85 C0 | test    eax, eax\n0x0047E31C | 74 07 | jz      short loc_47E325\n0x0047E31E | B8 00 00 00 00 | mov     eax, 0\n0x0047E323 | EB 33 | jmp     short locret_47E358\n0x0047E325 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0047E329 | 48 83 C0 08 | add     rax, 8\n0x0047E32D | 48 8B 00 | mov     rax, [rax]\n0x0047E330 | 48 85 C0 | test    rax, rax\n0x0047E333 | 74 19 | jz      short loc_47E34E\n0x0047E335 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0047E339 | 48 83 C0 08 | add     rax, 8\n0x0047E33D | 48 8B 00 | mov     rax, [rax]\n0x0047E340 | 48 89 C7 | mov     rdi, rax\n0x0047E343 | E8 30 0B FF FF | call    sub_46EE78\n0x0047E348 | 88 05 02 CC 2D 00 | mov     cs:byte_75AF50, al\n0x0047E34E | BF 04 00 00 00 | mov     edi, 4\n0x0047E353 | E8 17 FC FE FF | call    sub_46DF6F\n0x0047E358 | C9 | leave\n0x0047E359 | C3 | retn\n\n Ourput decompiled code:\nstatic int FAST_FUNC\nexitcmd(int argc UNUSED_PARAM, char **argv)\n{\n\tif (stoppedjobs())\n\t\treturn 0;\n\tif (argv[1])\n\t\texitstatus = number(argv[1]);\n\traise_exception(EXEXIT);\n\t/* NOTREACHED */\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0047AF6D | 55 | push    rbp\n0x0047AF6E | 48 89 E5 | mov     rbp, rsp\n0x0047AF71 | 48 83 EC 20 | sub     rsp, 20h\n0x0047AF75 | 89 7D EC | mov     [rbp+var_14], edi\n0x0047AF78 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x0047AF7C | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0047AF80 | 48 83 C0 08 | add     rax, 8\n0x0047AF84 | 48 8B 00 | mov     rax, [rax]\n0x0047AF87 | 48 85 C0 | test    rax, rax\n0x0047AF8A | 75 1F | jnz     short loc_47AFAB\n0x0047AF8C | 48 8B 05 85 24 2E 00 | mov     rax, cs:qword_75D418\n0x0047AF93 | 48 83 C0 38 | add     rax, 38h ; '8'\n0x0047AF97 | BA 20 00 00 00 | mov     edx, 20h ; ' '\n0x0047AF9C | BE 00 00 00 00 | mov     esi, 0\n0x0047AFA1 | 48 89 C7 | mov     rdi, rax\n0x0047AFA4 | E8 B6 FE FF FF | call    sub_47AE5F\n0x0047AFA9 | EB 4E | jmp     short locret_47AFF9\n0x0047AFAB | 48 8B 05 66 24 2E 00 | mov     rax, cs:qword_75D418\n0x0047AFB2 | 8B 50 30 | mov     edx, [rax+30h]\n0x0047AFB5 | 83 C2 01 | add     edx, 1\n0x0047AFB8 | 89 50 30 | mov     [rax+30h], edx\n0x0047AFBB | BF 00 00 00 00 | mov     edi, 0\n0x0047AFC0 | E8 78 FB FF FF | call    sub_47AB3D\n0x0047AFC5 | 89 45 FC | mov     [rbp+var_4], eax\n0x0047AFC8 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x0047AFCC | 75 23 | jnz     short loc_47AFF1\n0x0047AFCE | E8 B4 DD FF FF | call    sub_478D87\n0x0047AFD3 | 48 8B 05 7E FF 2D 00 | mov     rax, cs:qword_75AF58\n0x0047AFDA | 48 8B 00 | mov     rax, [rax]\n0x0047AFDD | 48 85 C0 | test    rax, rax\n0x0047AFE0 | 74 0F | jz      short loc_47AFF1\n0x0047AFE2 | 48 8B 05 6F FF 2D 00 | mov     rax, cs:qword_75AF58\n0x0047AFE9 | 48 89 C7 | mov     rdi, rax\n0x0047AFEC | E8 8D F8 FF FF | call    sub_47A87E\n0x0047AFF1 | E8 49 30 FF FF | call    sub_46E03F\n0x0047AFF6 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0047AFF9 | C9 | leave\n0x0047AFFA | C3 | retn",
        "output": "\n\n Ourput decompiled code:\nstatic int FAST_FUNC\nbgncmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tif (argv[1] == NULL) {\n\t\tpid_t pid;\n\t\tpid = fork();\n\t\tswitch (pid) {\n\t\tcase 0:\n\t\t\texecv(pathval() + 8, NULL);\n\t\tcase -1:\n\t\t\tperror(\"fork\");\n\t\tdefault:\n\t\t\tbgjobs[bgjobsused++] = pid;\n\t\t}\n\t} else {\n\t\tint i;\n\t\ti = number(argv[1]);\n\t\tif (i == 0)\n\t\t\tbgncmd_all();\n\t\telse if (argv[2])\n\t\t\tbgncmd_pid(argv[2]);\n\t}\n\treturn 0;\n}",
        "source_code": "static int FAST_FUNC\nsetcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tint retval;\n\n\tif (!argv[1])\n\t\treturn showvars(nullstr, 0, VUNSET);\n\n\tINT_OFF;\n\tretval = options(/*cmdline:*/ 0);\n\tif (retval == 0) { /* if no parse error... */\n\t\toptschanged();\n\t\tif (*argptr != NULL) {\n\t\t\tsetparam(argptr);\n\t\t}\n\t}\n\tINT_ON;\n\treturn retval;\n}",
        "parsed_output": "\n\n Ourput decompiled code:\nstatic int FAST_FUNC\nbgncmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tif (argv[1] == NULL) {\n\t\tpid_t pid;\n\t\tpid = fork();\n\t\tswitch (pid) {\n\t\tcase 0:\n\t\t\texecv(pathval() + 8, NULL);\n\t\tcase -1:\n\t\t\tperror(\"fork\");\n\t\tdefault:\n\t\t\tbgjobs[bgjobsused++] = pid;\n\t\t}\n\t} else {\n\t\tint i;\n\t\ti = number(argv[1]);\n\t\tif (i == 0)\n\t\t\tbgncmd_all();\n\t\telse if (argv[2])\n\t\t\tbgncmd_pid(argv[2]);\n\t}\n\treturn 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_47AF6D(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v7; // rdx\n  __int64 v8; // rdi\n  unsigned int v9; // [rsp+1Ch] [rbp-4h]\n\n  if ( !*(_QWORD *)(a2 + 8) )\n    return sub_47AE5F((const char *)(qword_75D418 + 56), 0, 0x20u, a4, a5, a6);\n  v7 = (unsigned int)(*(_DWORD *)(qword_75D418 + 48) + 1);\n  *(_DWORD *)(qword_75D418 + 48) = v7;\n  v8 = 0LL;\n  v9 = sub_47AB3D(0, a2, v7, a4, a5, a6);\n  if ( !v9 )\n  {\n    sub_478D87(0LL);\n    if ( *(_QWORD *)qword_75AF58 )\n    {\n      v8 = qword_75AF58;\n      sub_47A87E((const char **)qword_75AF58, a2);\n    }\n  }\n  sub_46E03F(v8, a2);\n  return v9;\n}\n",
        "baseline_code_debug": "int __cdecl setcmd(int argc, char **argv)\n{\n  int retval; // [rsp+1Ch] [rbp-4h]\n\n  if ( !argv[1] )\n    return showvars(ash_ptr_to_globals_misc->nullstr, 0, 32);\n  ++ash_ptr_to_globals_misc->suppress_int;\n  retval = options(0);\n  if ( !retval )\n  {\n    optschanged();\n    if ( *argptr )\n      setparam(argptr);\n  }\n  int_on();\n  return retval;\n}\n",
        "similarity_score_unixcoder": 0.5694403648376465,
        "similarity_score_baseline_stripped": 0.4230878949165344,
        "similarity_score_baseline_debug": 0.829210638999939
    },
    {
        "func_name": "stack_nputstr",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0046ED32 | 55 | push    rbp\n0x0046ED33 | 48 89 E5 | mov     rbp, rsp\n0x0046ED36 | 48 83 EC 20 | sub     rsp, 20h\n0x0046ED3A | 48 89 7D F8 | mov     [rbp+src], rdi\n0x0046ED3E | 48 89 75 F0 | mov     [rbp+n], rsi\n0x0046ED42 | 48 89 55 E8 | mov     [rbp+dest], rdx\n0x0046ED46 | 48 8B 55 E8 | mov     rdx, [rbp+dest]\n0x0046ED4A | 48 8B 45 F0 | mov     rax, [rbp+n]\n0x0046ED4E | 48 89 D6 | mov     rsi, rdx\n0x0046ED51 | 48 89 C7 | mov     rdi, rax\n0x0046ED54 | E8 60 FF FF FF | call    sub_46ECB9\n0x0046ED59 | 48 89 45 E8 | mov     [rbp+dest], rax\n0x0046ED5D | 48 8B 55 F0 | mov     rdx, [rbp+n]; n\n0x0046ED61 | 48 8B 4D F8 | mov     rcx, [rbp+src]\n0x0046ED65 | 48 8B 45 E8 | mov     rax, [rbp+dest]\n0x0046ED69 | 48 89 CE | mov     rsi, rcx; src\n0x0046ED6C | 48 89 C7 | mov     rdi, rax; dest\n0x0046ED6F | E8 2C 84 F9 FF | call    _memcpy\n0x0046ED74 | 48 89 C2 | mov     rdx, rax\n0x0046ED77 | 48 8B 45 F0 | mov     rax, [rbp+n]\n0x0046ED7B | 48 01 D0 | add     rax, rdx\n0x0046ED7E | 48 89 45 E8 | mov     [rbp+dest], rax\n0x0046ED82 | 48 8B 45 E8 | mov     rax, [rbp+dest]\n0x0046ED86 | C9 | leave\n0x0046ED87 | C3 | retn",
        "output": "",
        "source_code": "static char *\nstack_nputstr(const char *s, size_t n, char *p)\n{\n\tp = makestrspace(n, p);\n\tp = (char *)memcpy(p, s, n) + n;\n\treturn p;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "char *__fastcall sub_46ED32(const void *a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  void *v6; // rax\n\n  v6 = (void *)sub_46ECB9(a2, a3, a3, a4, a5, a6);\n  return (char *)memcpy(v6, a1, a2) + a2;\n}\n",
        "baseline_code_debug": "char *__cdecl stack_nputstr(const char *s, size_t n, char *p)\n{\n  char *v3; // rax\n\n  v3 = makestrspace(n, p);\n  return (char *)memcpy(v3, s, n) + n;\n}\n",
        "similarity_score_unixcoder": 0.04751906543970108,
        "similarity_score_baseline_stripped": 0.4952497184276581,
        "similarity_score_baseline_debug": 0.8806359171867371
    },
    {
        "func_name": "arith",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004DC8ED | 55 | push    rbp\n0x004DC8EE | 48 89 E5 | mov     rbp, rsp\n0x004DC8F1 | 48 83 EC 10 | sub     rsp, 10h\n0x004DC8F5 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004DC8F9 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004DC8FD | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004DC901 | 48 89 C7 | mov     rdi, rax\n0x004DC904 | E8 83 FF FF FF | call    sub_4DC88C\n0x004DC909 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004DC90D | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x004DC911 | 48 89 50 10 | mov     [rax+10h], rdx\n0x004DC915 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004DC919 | 48 89 C7 | mov     rdi, rax\n0x004DC91C | E8 EA 26 00 00 | call    sub_4DF00B\n0x004DC921 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004DC925 | C9 | leave\n0x004DC926 | C3 | retn\n\n Ourput decompiled code:\nstatic var *setvar_p(var *v, char *value)\n{\n\tclrvar(v);\n\tv->string = value;\n\thandle_special(v);\n\treturn v;\n}\n\n## Example:\n\n Input assembly code:\n0x0046F33E | 55 | push    rbp\n0x0046F33F | 48 89 E5 | mov     rbp, rsp\n0x0046F342 | 48 83 EC 10 | sub     rsp, 10h\n0x0046F346 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0046F34A | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x0046F34E | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0046F352 | 48 8B 10 | mov     rdx, [rax]\n0x0046F355 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0046F359 | 48 8B 00 | mov     rax, [rax]\n0x0046F35C | 48 89 D6 | mov     rsi, rdx\n0x0046F35F | 48 89 C7 | mov     rdi, rax\n0x0046F362 | E8 EC FE FF FF | call    sub_46F253\n0x0046F367 | C9 | leave\n0x0046F368 | C3 | retn\n\n Ourput decompiled code:\nstatic int\nvpcmp(const void *a, const void *b)\n{\n\treturn varcmp(*(const char **)a, *(const char **)b);\n}\n\n## Example:\n\n Input assembly code:\n0x004CFA97 | 55 | push    rbp\n0x004CFA98 | 48 89 E5 | mov     rbp, rsp\n0x004CFA9B | 48 83 EC 10 | sub     rsp, 10h\n0x004CFA9F | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004CFAA3 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004CFAA7 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004CFAAB | BA 00 00 00 00 | mov     edx, 0\n0x004CFAB0 | BE 00 00 00 00 | mov     esi, 0\n0x004CFAB5 | 48 89 C7 | mov     rdi, rax\n0x004CFAB8 | E8 6E C3 F3 FF | call    sub_40BE2B\n0x004CFABD | 48 89 C2 | mov     rdx, rax\n0x004CFAC0 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004CFAC4 | 48 89 10 | mov     [rax], rdx\n0x004CFAC7 | 90 | nop\n0x004CFAC8 | C9 | leave\n0x004CFAC9 | C3 | retn\n\n Ourput decompiled code:\nstatic void FAST_FUNC conv_strtoll(const char *arg, void *result)\n{\n\t*(long long*)result = bb_strtoll(arg, NULL, 0);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0048B66A | 55 | push    rbp\n0x0048B66B | 48 89 E5 | mov     rbp, rsp\n0x0048B66E | 48 83 EC 10 | sub     rsp, 10h\n0x0048B672 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0048B676 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x0048B67A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B67E | 48 C7 00 00 00 00 00 | mov     qword ptr [rax], 0\n0x0048B685 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B689 | 48 C7 40 18 00 00 00 00 | mov     qword ptr [rax+18h], 0\n0x0048B691 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x0048B695 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B699 | 48 89 D6 | mov     rsi, rdx\n0x0048B69C | 48 89 C7 | mov     rdi, rax\n0x0048B69F | E8 F3 FA FF FF | call    sub_48B197\n0x0048B6A4 | C9 | leave\n0x0048B6A5 | C3 | retn",
        "output": "\n\nstatic void FAST_FUNC conv_strtoll(const char *arg, void *result)\n{\n\tstruct bb_strtoll_result *res = result;\n\tres->err = 0;\n\tres->val = 0;\n\tconv_strtoll_err(arg, &res->err);\n}",
        "source_code": "arith_t FAST_FUNC\narith(arith_state_t *math_state, const char *expr)\n{\n\tmath_state->errmsg = NULL;\n\tmath_state->list_of_recursed_names = NULL;\n\treturn evaluate_string(math_state, expr);\n}",
        "parsed_output": "\n\nstatic void FAST_FUNC conv_strtoll(const char *arg, void *result)\n{\n\tstruct bb_strtoll_result *res = result;\n\tres->err = 0;\n\tres->val = 0;\n\tconv_strtoll_err(arg, &res->err);\n}",
        "baseline_code_stripped": "char *__fastcall sub_48B66A(__int64 a1, _BYTE *a2)\n{\n  *(_QWORD *)a1 = 0LL;\n  *(_QWORD *)(a1 + 24) = 0LL;\n  return sub_48B197((const char **)a1, a2);\n}\n",
        "baseline_code_debug": "arith_t __cdecl arith(arith_state_t_0 *math_state, const char *expr)\n{\n  math_state->errmsg = 0LL;\n  math_state->list_of_recursed_names = 0LL;\n  return evaluate_string(math_state, expr);\n}\n",
        "similarity_score_unixcoder": 0.5565593838691711,
        "similarity_score_baseline_stripped": 0.3425426185131073,
        "similarity_score_baseline_debug": 0.9159606695175171
    },
    {
        "func_name": "setConMode",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0044230D | 55 | push    rbp\n0x0044230E | 48 89 E5 | mov     rbp, rsp\n0x00442311 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00442316 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]\n0x0044231A | 0F B6 C0 | movzx   eax, al\n0x0044231D | 83 E0 02 | and     eax, 2\n0x00442320 | 85 C0 | test    eax, eax\n0x00442322 | 74 0F | jz      short loc_442333\n0x00442324 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00442329 | 0F B6 40 05 | movzx   eax, byte ptr [rax+5]\n0x0044232D | 3C FB | cmp     al, 0FBh\n0x0044232F | 75 0F | jnz     short loc_442340\n0x00442331 | EB 57 | jmp     short loc_44238A\n0x00442333 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00442338 | 0F B6 40 05 | movzx   eax, byte ptr [rax+5]\n0x0044233C | 3C FC | cmp     al, 0FCh\n0x0044233E | 74 49 | jz      short loc_442389\n0x00442340 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00442345 | 0F B6 50 07 | movzx   edx, byte ptr [rax+7]\n0x00442349 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0044234E | 83 F2 02 | xor     edx, 2\n0x00442351 | 88 50 07 | mov     [rax+7], dl\n0x00442354 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00442359 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]\n0x0044235D | 0F B6 C0 | movzx   eax, al\n0x00442360 | 83 E0 02 | and     eax, 2\n0x00442363 | 85 C0 | test    eax, eax\n0x00442365 | 74 11 | jz      short loc_442378\n0x00442367 | BE 03 00 00 00 | mov     esi, 3\n0x0044236C | BF FD 00 00 00 | mov     edi, 0FDh\n0x00442371 | E8 F1 FA FF FF | call    sub_441E67\n0x00442376 | EB 12 | jmp     short loc_44238A\n0x00442378 | BE 03 00 00 00 | mov     esi, 3\n0x0044237D | BF FE 00 00 00 | mov     edi, 0FEh\n0x00442382 | E8 E0 FA FF FF | call    sub_441E67\n0x00442387 | EB 01 | jmp     short loc_44238A\n0x00442389 | 90 | nop\n0x0044238A | 5D | pop     rbp\n0x0044238B | C3 | retn\n\n Ourput decompiled code:\nstatic void to_sga(void)\n{\n\t/* daemon always sends will/wont, client do/dont */\n\n\tif (G.telflags & UF_SGA) {\n\t\tif (G.telwish == WILL)\n\t\t\treturn;\n\t} else if (G.telwish == WONT)\n\t\treturn;\n\n\tG.telflags ^= UF_SGA; /* toggle */\n\tif (G.telflags & UF_SGA)\n\t\tput_iac2(DO, TELOPT_SGA);\n\telse\n\t\tput_iac2(DONT, TELOPT_SGA);\n}\n\n## Example:\n\n Input assembly code:\n0x0044223D | 55 | push    rbp\n0x0044223E | 48 89 E5 | mov     rbp, rsp\n0x00442241 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00442246 | 0F B6 40 05 | movzx   eax, byte ptr [rax+5]\n0x0044224A | 3C FD | cmp     al, 0FDh\n0x0044224C | 75 14 | jnz     short loc_442262\n0x0044224E | BE 01 00 00 00 | mov     esi, 1\n0x00442253 | BF FC 00 00 00 | mov     edi, 0FCh\n0x00442258 | E8 0A FC FF FF | call    sub_441E67\n0x0044225D | E9 A9 00 00 00 | jmp     loc_44230B\n0x00442262 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00442267 | 0F B6 40 05 | movzx   eax, byte ptr [rax+5]\n0x0044226B | 3C FE | cmp     al, 0FEh\n0x0044226D | 0F 84 94 00 00 00 | jz      loc_442307\n0x00442273 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00442278 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]\n0x0044227C | 0F B6 C0 | movzx   eax, al\n0x0044227F | 83 E0 01 | and     eax, 1\n0x00442282 | 85 C0 | test    eax, eax\n0x00442284 | 74 0F | jz      short loc_442295\n0x00442286 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0044228B | 0F B6 40 05 | movzx   eax, byte ptr [rax+5]\n0x0044228F | 3C FB | cmp     al, 0FBh\n0x00442291 | 75 0F | jnz     short loc_4422A2\n0x00442293 | EB 76 | jmp     short loc_44230B\n0x00442295 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0044229A | 0F B6 40 05 | movzx   eax, byte ptr [rax+5]\n0x0044229E | 3C FC | cmp     al, 0FCh\n0x004422A0 | 74 68 | jz      short loc_44230A\n0x004422A2 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004422A7 | 0F B6 40 06 | movzx   eax, byte ptr [rax+6]\n0x004422AB | 3C 02 | cmp     al, 2\n0x004422AD | 74 14 | jz      short loc_4422C3\n0x004422AF | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004422B4 | 0F B6 50 07 | movzx   edx, byte ptr [rax+7]\n0x004422B8 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004422BD | 83 F2 01 | xor     edx, 1\n0x004422C0 | 88 50 07 | mov     [rax+7], dl\n0x004422C3 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004422C8 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]\n0x004422CC | 0F B6 C0 | movzx   eax, al\n0x004422CF | 83 E0 01 | and     eax, 1\n0x004422D2 | 85 C0 | test    eax, eax\n0x004422D4 | 74 11 | jz      short loc_4422E7\n0x004422D6 | BE 01 00 00 00 | mov     esi, 1\n0x004422DB | BF FD 00 00 00 | mov     edi, 0FDh\n0x004422E0 | E8 82 FB FF FF | call    sub_441E67\n0x004422E5 | EB 0F | jmp     short loc_4422F6\n0x004422E7 | BE 01 00 00 00 | mov     esi, 1\n0x004422EC | BF FE 00 00 00 | mov     edi, 0FEh\n0x004422F1 | E8 71 FB FF FF | call    sub_441E67\n0x004422F6 | E8 D4 FD FF FF | call    sub_4420CF\n0x004422FB | BF DE BC 52 00 | mov     edi, offset asc_52BCDE; \"\\r\\n\"\n0x00442300 | E8 A9 7A FC FF | call    sub_409DAE\n0x00442305 | EB 04 | jmp     short loc_44230B\n0x00442307 | 90 | nop\n0x00442308 | EB 01 | jmp     short loc_44230B\n0x0044230A | 90 | nop\n0x0044230B | 5D | pop     rbp\n0x0044230C | C3 | retn\n\n Ourput decompiled code:\nstatic void to_echo(void)\n{\n\t/* if server requests ECHO, don't agree */\n\tif (G.telwish == DO) {\n\t\tput_iac2(WONT, TELOPT_ECHO);\n\t\treturn;\n\t}\n\tif (G.telwish == DONT)\n\t\treturn;\n\n\tif (G.telflags & UF_ECHO) {\n\t\tif (G.telwish == WILL)\n\t\t\treturn;\n\t} else if (G.telwish == WONT)\n\t\treturn;\n\n\tif (G.charmode != CHM_OFF)\n\t\tG.telflags ^= UF_ECHO;\n\n\tif (G.telflags & UF_ECHO)\n\t\tput_iac2(DO, TELOPT_ECHO);\n\telse\n\t\tput_iac2(DONT, TELOPT_ECHO);\n\n\tsetConMode();\n\tfull_write1_str(\"\\r\\n\");  /* sudden modec */\n}\n\n## Example:\n\n Input assembly code:\n0x0044219F | 55 | push    rbp\n0x004421A0 | 48 89 E5 | mov     rbp, rsp\n0x004421A3 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004421A8 | C6 40 06 00 | mov     byte ptr [rax+6], 0\n0x004421AC | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004421B1 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]\n0x004421B5 | BA F8 B3 75 00 | mov     edx, offset dest\n0x004421BA | 83 E0 FC | and     eax, 0FFFFFFFCh\n0x004421BD | 88 42 07 | mov     [rdx+7], al\n0x004421C0 | E8 0A FF FF FF | call    sub_4420CF\n0x004421C5 | BE 01 00 00 00 | mov     esi, 1\n0x004421CA | BF FE 00 00 00 | mov     edi, 0FEh\n0x004421CF | E8 93 FC FF FF | call    sub_441E67\n0x004421D4 | BE 03 00 00 00 | mov     esi, 3\n0x004421D9 | BF FE 00 00 00 | mov     edi, 0FEh\n0x004421DE | E8 84 FC FF FF | call    sub_441E67\n0x004421E3 | E8 43 F8 FF FF | call    sub_441A2B\n0x004421E8 | 90 | nop\n0x004421E9 | 5D | pop     rbp\n0x004421EA | C3 | retn\n\n Ourput decompiled code:\nstatic void do_linemode(void)\n{\n\tG.charmode = CHM_TRY;\n\tG.telflags &= ~(UF_ECHO | UF_SGA);\n\tsetConMode();\n\n\tput_iac2(DONT, TELOPT_ECHO);\n\tput_iac2(DONT, TELOPT_SGA);\n\tiac_flush();\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004420CF | 55 | push    rbp\n0x004420D0 | 48 89 E5 | mov     rbp, rsp\n0x004420D3 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004420D8 | 0F B6 40 07 | movzx   eax, byte ptr [rax+7]\n0x004420DC | 0F B6 C0 | movzx   eax, al\n0x004420DF | 83 E0 01 | and     eax, 1\n0x004420E2 | 85 C0 | test    eax, eax\n0x004420E4 | 74 36 | jz      short loc_44211C\n0x004420E6 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004420EB | 0F B6 40 06 | movzx   eax, byte ptr [rax+6]\n0x004420EF | 84 C0 | test    al, al\n0x004420F1 | 75 5D | jnz     short loc_442150\n0x004420F3 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004420F8 | C6 40 06 01 | mov     byte ptr [rax+6], 1\n0x004420FC | BA 5D 00 00 00 | mov     edx, 5Dh ; ']'\n0x00442101 | BE 9D BC 52 00 | mov     esi, offset aCharacter; \"character\"\n0x00442106 | BF A8 BC 52 00 | mov     edi, offset aEnteringSModeE; \"\\r\\nEntering %s mode\\r\\nEscape characte\"...\n0x0044210B | B8 00 00 00 00 | mov     eax, 0\n0x00442110 | E8 BB 4A FC FF | call    _printf\n0x00442115 | E8 07 04 00 00 | call    sub_442521\n0x0044211A | EB 34 | jmp     short loc_442150\n0x0044211C | B8 F8 B3 75 00 | mov     eax, offset dest\n0x00442121 | 0F B6 40 06 | movzx   eax, byte ptr [rax+6]\n0x00442125 | 3C 02 | cmp     al, 2\n0x00442127 | 74 27 | jz      short loc_442150\n0x00442129 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0044212E | C6 40 06 02 | mov     byte ptr [rax+6], 2\n0x00442132 | BA 43 00 00 00 | mov     edx, 43h ; 'C'\n0x00442137 | BE D9 BC 52 00 | mov     esi, offset aLine; \"line\"\n0x0044213C | BF A8 BC 52 00 | mov     edi, offset aEnteringSModeE; \"\\r\\nEntering %s mode\\r\\nEscape characte\"...\n0x00442141 | B8 00 00 00 00 | mov     eax, 0\n0x00442146 | E8 85 4A FC FF | call    _printf\n0x0044214B | E8 FC 03 00 00 | call    sub_44254C\n0x00442150 | 90 | nop\n0x00442151 | 5D | pop     rbp\n0x00442152 | C3 | retn",
        "output": "\n\nstatic void setConMode(void)\n{\n\tif (G.telflags & 1) {\n\t\tif (G.telch != 0) {\n\t\t\tG.telch = ']';\n\t\t\t_printf(\"\\r\\nEntering character mode\\r\\nEscape character is '%c'.\\r\\n\", G.telch);\n\t\t\tiac_flush();\n\t\t}\n\t} else if (G.telch != 2) {\n\t\tG.telch = 'C';\n\t\t_printf(\"\\r\\nEntering line mode\\r\\nEscape character is '%c'.\\r\\n\", G.telch);\n\t\tiac_flush();\n\t}\n}",
        "source_code": "endif\n\nstatic void setConMode(void)\n{\n\tif (G.telflags & UF_ECHO) {\n\t\tif (G.charmode == CHM_TRY) {\n\t\t\tG.charmode = CHM_ON;\n\t\t\tprintf(\"\\r\\nEntering %s mode\"\n\t\t\t\t\"\\r\\nEscape character is '^%c'.\\r\\n\", \"character\", ']');\n\t\t\trawmode();\n\t\t}\n\t} else {\n\t\tif (G.charmode != CHM_OFF) {\n\t\t\tG.charmode = CHM_OFF;\n\t\t\tprintf(\"\\r\\nEntering %s mode\"\n\t\t\t\t\"\\r\\nEscape character is '^%c'.\\r\\n\", \"line\", 'C');\n\t\t\tcookmode();\n\t\t}\n\t}\n}",
        "parsed_output": "\n\nstatic void setConMode(void)\n{\n\tif (G.telflags & 1) {\n\t\tif (G.telch != 0) {\n\t\t\tG.telch = ']';\n\t\t\t_printf(\"\\r\\nEntering character mode\\r\\nEscape character is '%c'.\\r\\n\", G.telch);\n\t\t\tiac_flush();\n\t\t}\n\t} else if (G.telch != 2) {\n\t\tG.telch = 'C';\n\t\t_printf(\"\\r\\nEntering line mode\\r\\nEscape character is '%c'.\\r\\n\", G.telch);\n\t\tiac_flush();\n\t}\n}",
        "baseline_code_stripped": "__int64 sub_4420CF()\n{\n  __int64 result; // rax\n\n  if ( (dest.c_oflag & 0x1000000) != 0 )\n  {\n    result = BYTE2(dest.c_oflag);\n    if ( !(_BYTE)result )\n    {\n      BYTE2(dest.c_oflag) = 1;\n      printf(\"\\r\\nEntering %s mode\\r\\nEscape character is '^%c'.\\r\\n\", \"character\", 93LL);\n      return sub_442521();\n    }\n  }\n  else\n  {\n    result = BYTE2(dest.c_oflag);\n    if ( (_BYTE)result != 2 )\n    {\n      BYTE2(dest.c_oflag) = 2;\n      printf(\"\\r\\nEntering %s mode\\r\\nEscape character is '^%c'.\\r\\n\", \"line\", 67LL);\n      return sub_44254C();\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl setConMode()\n{\n  if ( (bb_common_bufsiz1.c_oflag & 0x1000000) != 0 )\n  {\n    if ( !BYTE2(bb_common_bufsiz1.c_oflag) )\n    {\n      BYTE2(bb_common_bufsiz1.c_oflag) = 1;\n      printf(\"\\r\\nEntering %s mode\\r\\nEscape character is '^%c'.\\r\\n\", \"character\", 93LL);\n      rawmode();\n    }\n  }\n  else if ( BYTE2(bb_common_bufsiz1.c_oflag) != 2 )\n  {\n    BYTE2(bb_common_bufsiz1.c_oflag) = 2;\n    printf(\"\\r\\nEntering %s mode\\r\\nEscape character is '^%c'.\\r\\n\", \"line\", 67LL);\n    cookmode();\n  }\n}\n",
        "similarity_score_unixcoder": 0.821963369846344,
        "similarity_score_baseline_stripped": 0.6176630258560181,
        "similarity_score_baseline_debug": 0.7900682687759399
    },
    {
        "func_name": "write32",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004B29AD | 55 | push    rbp\n0x004B29AE | 48 89 E5 | mov     rbp, rsp\n0x004B29B1 | 48 83 EC 10 | sub     rsp, 10h\n0x004B29B5 | 89 7D FC | mov     [rbp+hostlong], edi\n0x004B29B8 | 8B 45 FC | mov     eax, [rbp+hostlong]\n0x004B29BB | 89 C7 | mov     edi, eax; hostlong\n0x004B29BD | E8 6E 43 F5 FF | call    _htonl\n0x004B29C2 | 89 45 FC | mov     [rbp+hostlong], eax\n0x004B29C5 | 48 8D 45 FC | lea     rax, [rbp+hostlong]\n0x004B29C9 | BE 04 00 00 00 | mov     esi, 4\n0x004B29CE | 48 89 C7 | mov     rdi, rax\n0x004B29D1 | E8 92 FE FF FF | call    sub_4B2868\n0x004B29D6 | 90 | nop\n0x004B29D7 | C9 | leave\n0x004B29D8 | C3 | retn\n\n Ourput decompiled code:\nstatic void f_write32(uint32_t v)\n{\n\tv = htonl(v);\n\tf_write(&v, 4);\n}\n\n## Example:\n\n Input assembly code:\n0x00429778 | 55 | push    rbp\n0x00429779 | 48 89 E5 | mov     rbp, rsp\n0x0042977C | 48 83 EC 10 | sub     rsp, 10h\n0x00429780 | 89 7D FC | mov     [rbp+var_4], edi\n0x00429783 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00429786 | BE 7C B2 52 00 | mov     esi, offset aFeatures; \"-Features:\"\n0x0042978B | 89 C7 | mov     edi, eax\n0x0042978D | E8 FC FC FF FF | call    sub_42948E\n0x00429792 | BF 88 B2 52 00 | mov     edi, offset aEpsvPasvRestSt; \" EPSV\\r\\n PASV\\r\\n REST STREAM\\r\\n MDTM\"...\n0x00429797 | E8 1C FE FF FF | call    sub_4295B8\n0x0042979C | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0042979F | BE B3 B2 52 00 | mov     esi, offset aOk; \" Ok\"\n0x004297A4 | 89 C7 | mov     edi, eax\n0x004297A6 | E8 E3 FC FF FF | call    sub_42948E\n0x004297AB | 90 | nop\n0x004297AC | C9 | leave\n0x004297AD | C3 | retn\n\n Ourput decompiled code:\nstatic void\nhandle_feat(unsigned status)\n{\n\tcmdio_write(status, \"-Features:\");\n\tcmdio_write_raw(\" EPSV\\r\\n\"\n\t\t\t\" PASV\\r\\n\"\n\t\t\t\" REST STREAM\\r\\n\"\n\t\t\t\" MDTM\\r\\n\"\n\t\t\t\" SIZE\\r\\n\");\n\tcmdio_write(status, \" Ok\");\n}\n\n## Example:\n\n Input assembly code:\n0x00480BCB | 55 | push    rbp\n0x00480BCC | 48 89 E5 | mov     rbp, rsp\n0x00480BCF | 48 83 EC 10 | sub     rsp, 10h\n0x00480BD3 | 89 7D FC | mov     [rbp+var_4], edi\n0x00480BD6 | BF 01 00 00 00 | mov     edi, 1\n0x00480BDB | E8 FD FA FF FF | call    sub_4806DD\n0x00480BE0 | 48 89 C6 | mov     rsi, rax\n0x00480BE3 | BF 2B E6 51 00 | mov     edi, offset aPwdS; \"PWD=%s\"\n0x00480BE8 | B8 00 00 00 00 | mov     eax, 0\n0x00480BED | E8 C1 9A F8 FF | call    sub_40A6B3\n0x00480BF2 | 48 89 C1 | mov     rcx, rax\n0x00480BF5 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00480BF8 | BA 00 00 00 00 | mov     edx, 0\n0x00480BFD | 89 C6 | mov     esi, eax\n0x00480BFF | 48 89 CF | mov     rdi, rcx\n0x00480C02 | E8 12 FD FF FF | call    sub_480919\n0x00480C07 | 90 | nop\n0x00480C08 | C9 | leave\n0x00480C09 | C3 | retn\n\n Ourput decompiled code:\nstatic void set_pwd_var(int exp)\n{\n\tset_local_var(xasprintf(\"PWD=%s\", get_cwd(/*force:*/ 1)),\n\t\t/*exp:*/ exp, /*lvl:*/ 0, /*ro:*/ 0);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004B2837 | 55 | push    rbp\n0x004B2838 | 48 89 E5 | mov     rbp, rsp\n0x004B283B | 48 83 EC 10 | sub     rsp, 10h\n0x004B283F | 89 7D FC | mov     [rbp+hostlong], edi\n0x004B2842 | 8B 45 FC | mov     eax, [rbp+hostlong]\n0x004B2845 | 89 C7 | mov     edi, eax; hostlong\n0x004B2847 | E8 E4 44 F5 FF | call    _htonl\n0x004B284C | 89 45 FC | mov     [rbp+hostlong], eax\n0x004B284F | 48 8D 45 FC | lea     rax, [rbp+hostlong]\n0x004B2853 | BA 04 00 00 00 | mov     edx, 4\n0x004B2858 | 48 89 C6 | mov     rsi, rax\n0x004B285B | BF 01 00 00 00 | mov     edi, 1\n0x004B2860 | E8 46 7C F5 FF | call    sub_40A4AB\n0x004B2865 | 90 | nop\n0x004B2866 | C9 | leave\n0x004B2867 | C3 | retn",
        "output": "\n\nstatic void f_write32(uint32_t v)\n{\n\tv = htonl(v);\n\tf_write(&v, 4);\n}",
        "source_code": "static void write32(uint32_t v)\n{\n\tv = htonl(v);\n\txwrite(1, &v, 4);\n}",
        "parsed_output": "\n\nstatic void f_write32(uint32_t v)\n{\n\tv = htonl(v);\n\tf_write(&v, 4);\n}",
        "baseline_code_stripped": "void __fastcall sub_4B2837(uint32_t a1)\n{\n  uint32_t hostlong; // [rsp+Ch] [rbp-4h] BYREF\n\n  hostlong = htonl(a1);\n  sub_40A4AB(1u, (__int64)&hostlong, 4LL);\n}\n",
        "baseline_code_debug": "void __cdecl write32(uint32_t v)\n{\n  uint32_t va; // [rsp+Ch] [rbp-4h] BYREF\n\n  va = htonl(v);\n  xwrite(1, &va, 4uLL);\n}\n",
        "similarity_score_unixcoder": 0.8972955346107483,
        "similarity_score_baseline_stripped": 0.5749458074569702,
        "similarity_score_baseline_debug": 0.7601217031478882
    },
    {
        "func_name": "unregister_rpc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004FFAE0 | 55 | push    rbp\n0x004FFAE1 | 48 89 E5 | mov     rbp, rsp\n0x004FFAE4 | 48 83 EC 20 | sub     rsp, 20h\n0x004FFAE8 | 48 89 7D E8 | mov     [rbp+ptr], rdi\n0x004FFAEC | 48 8B 45 E8 | mov     rax, [rbp+ptr]\n0x004FFAF0 | 8B 40 10 | mov     eax, [rax+10h]\n0x004FFAF3 | 89 45 FC | mov     [rbp+var_4], eax\n0x004FFAF6 | EB 1F | jmp     short loc_4FFB17\n0x004FFAF8 | 83 6D FC 01 | sub     [rbp+var_4], 1\n0x004FFAFC | 48 8B 45 E8 | mov     rax, [rbp+ptr]\n0x004FFB00 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x004FFB03 | 48 63 D2 | movsxd  rdx, edx\n0x004FFB06 | 48 83 C2 04 | add     rdx, 4\n0x004FFB0A | 48 8B 44 D0 08 | mov     rax, [rax+rdx*8+8]\n0x004FFB0F | 48 89 C7 | mov     rdi, rax; ptr\n0x004FFB12 | E8 49 6B F0 FF | call    _free\n0x004FFB17 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004FFB1B | 7F DB | jg      short loc_4FFAF8\n0x004FFB1D | 48 8B 45 E8 | mov     rax, [rbp+ptr]\n0x004FFB21 | 48 89 C7 | mov     rdi, rax; ptr\n0x004FFB24 | E8 37 6B F0 FF | call    _free\n0x004FFB29 | 90 | nop\n0x004FFB2A | C9 | leave\n0x004FFB2B | C3 | retn\n\n Ourput decompiled code:\nstatic void free_line_input_t(line_input_t *n)\n{\n\tint i = n->cnt_history;\n\twhile (i > 0)\n\t\tfree(n->history[--i]);\n\tfree(n);\n}\n\n## Example:\n\n Input assembly code:\n0x004AC054 | 55 | push    rbp\n0x004AC055 | 48 89 E5 | mov     rbp, rsp\n0x004AC058 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004AC05C | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004AC060 | C7 80 8C 00 00 00 00 00 00 00 | mov     dword ptr [rax+8Ch], 0\n0x004AC06A | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x004AC071 | EB 4C | jmp     short loc_4AC0BF\n0x004AC073 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x004AC077 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004AC07A | 48 98 | cdqe\n0x004AC07C | 0F B6 84 02 90 00 00 00 | movzx   eax, byte ptr [rdx+rax+90h]\n0x004AC084 | 84 C0 | test    al, al\n0x004AC086 | 74 33 | jz      short loc_4AC0BB\n0x004AC088 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004AC08C | 8B 80 8C 00 00 00 | mov     eax, [rax+8Ch]\n0x004AC092 | 89 C1 | mov     ecx, eax\n0x004AC094 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x004AC098 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004AC09B | 48 98 | cdqe\n0x004AC09D | 88 8C 02 90 01 00 00 | mov     [rdx+rax+190h], cl\n0x004AC0A4 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004AC0A8 | 8B 80 8C 00 00 00 | mov     eax, [rax+8Ch]\n0x004AC0AE | 8D 50 01 | lea     edx, [rax+1]\n0x004AC0B1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004AC0B5 | 89 90 8C 00 00 00 | mov     [rax+8Ch], edx\n0x004AC0BB | 83 45 FC 01 | add     [rbp+var_4], 1\n0x004AC0BF | 81 7D FC FF 00 00 00 | cmp     [rbp+var_4], 0FFh\n0x004AC0C6 | 7E AB | jle     short loc_4AC073\n0x004AC0C8 | 90 | nop\n0x004AC0C9 | 5D | pop     rbp\n0x004AC0CA | C3 | retn\n\n Ourput decompiled code:\nstatic\nvoid makeMaps_e(EState* s)\n{\n\tint i;\n\ts->nInUse = 0;\n\tfor (i = 0; i < 256; i++) {\n\t\tif (s->inUse[i]) {\n\t\t\ts->unseqToSeq[i] = s->nInUse;\n\t\t\ts->nInUse++;\n\t\t}\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x004D39DE | 55 | push    rbp\n0x004D39DF | 48 89 E5 | mov     rbp, rsp\n0x004D39E2 | 48 83 EC 20 | sub     rsp, 20h\n0x004D39E6 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004D39EA | 89 75 E4 | mov     [rbp+var_1C], esi\n0x004D39ED | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004D39F1 | 8B 40 0C | mov     eax, [rax+0Ch]\n0x004D39F4 | 89 C6 | mov     esi, eax\n0x004D39F6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004D39FA | 8B 40 08 | mov     eax, [rax+8]\n0x004D39FD | 89 C1 | mov     ecx, eax\n0x004D39FF | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004D3A03 | 8B 40 04 | mov     eax, [rax+4]\n0x004D3A06 | 89 C2 | mov     edx, eax\n0x004D3A08 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004D3A0C | 8B 00 | mov     eax, [rax]\n0x004D3A0E | 89 C0 | mov     eax, eax\n0x004D3A10 | 49 89 F0 | mov     r8, rsi\n0x004D3A13 | 48 89 C6 | mov     rsi, rax\n0x004D3A16 | BF 38 40 52 00 | mov     edi, offset aLxLxLxLx; \"%lx:%lx:%lx:%lx\"\n0x004D3A1B | B8 00 00 00 00 | mov     eax, 0\n0x004D3A20 | E8 AB 31 F3 FF | call    _printf\n0x004D3A25 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x004D3A2C | EB 26 | jmp     short loc_4D3A54\n0x004D3A2E | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x004D3A32 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004D3A35 | 48 98 | cdqe\n0x004D3A37 | 0F B6 44 02 11 | movzx   eax, byte ptr [rdx+rax+11h]\n0x004D3A3C | 0F B6 C0 | movzx   eax, al\n0x004D3A3F | 89 C6 | mov     esi, eax\n0x004D3A41 | BF 48 40 52 00 | mov     edi, offset asc_524048; \":%x\"\n0x004D3A46 | B8 00 00 00 00 | mov     eax, 0\n0x004D3A4B | E8 80 31 F3 FF | call    _printf\n0x004D3A50 | 83 45 FC 01 | add     [rbp+var_4], 1\n0x004D3A54 | 83 7D FC 1F | cmp     [rbp+var_4], 1Fh\n0x004D3A58 | 7E D4 | jle     short loc_4D3A2E\n0x004D3A5A | BF 0A 00 00 00 | mov     edi, 0Ah\n0x004D3A5F | E8 F5 6B F3 FF | call    sub_40A659\n0x004D3A64 | 90 | nop\n0x004D3A65 | C9 | leave\n0x004D3A66 | C3 | retn\n\n Ourput decompiled code:\nstatic void display_recoverable(const struct termios *mode,\n\t\t\t\tint UNUSED_PARAM dummy)\n{\n\tint i;\n\tprintf(\"%lx:%lx:%lx:%lx\",\n\t\t   (unsigned long) mode->c_iflag, (unsigned long) mode->c_oflag,\n\t\t   (unsigned long) mode->c_cflag, (unsigned long) mode->c_lflag);\n\tfor (i = 0; i < NCCS; ++i)\n\t\tprintf(\":%x\", (unsigned int) mode->c_cc[i]);\n\tbb_putchar('\\n');\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00433D06 | 55 | push    rbp\n0x00433D07 | 48 89 E5 | mov     rbp, rsp\n0x00433D0A | 48 83 EC 20 | sub     rsp, 20h\n0x00433D0E | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00433D12 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00433D16 | 8B 40 24 | mov     eax, [rax+24h]\n0x00433D19 | 89 45 FC | mov     [rbp+var_4], eax\n0x00433D1C | EB 3D | jmp     short loc_433D5B\n0x00433D1E | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00433D21 | 48 63 D0 | movsxd  rdx, eax\n0x00433D24 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00433D28 | 8B 40 20 | mov     eax, [rax+20h]\n0x00433D2B | 48 98 | cdqe\n0x00433D2D | 48 89 D6 | mov     rsi, rdx; vers\n0x00433D30 | 48 89 C7 | mov     rdi, rax; program\n0x00433D33 | E8 48 33 FD FF | call    _pmap_unset\n0x00433D38 | 85 C0 | test    eax, eax\n0x00433D3A | 75 1B | jnz     short loc_433D57\n0x00433D3C | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00433D40 | 8B 40 20 | mov     eax, [rax+20h]\n0x00433D43 | 8B 55 FC | mov     edx, [rbp+var_4]\n0x00433D46 | 89 C6 | mov     esi, eax\n0x00433D48 | BF A1 92 51 00 | mov     edi, offset aPmapUnsetUU; \"pmap_unset(%u,%u)\"\n0x00433D4D | B8 00 00 00 00 | mov     eax, 0\n0x00433D52 | E8 82 54 FD FF | call    sub_4091D9\n0x00433D57 | 83 45 FC 01 | add     [rbp+var_4], 1\n0x00433D5B | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00433D5F | 8B 40 28 | mov     eax, [rax+28h]\n0x00433D62 | 39 45 FC | cmp     [rbp+var_4], eax\n0x00433D65 | 7E B7 | jle     short loc_433D1E\n0x00433D67 | 90 | nop\n0x00433D68 | C9 | leave\n0x00433D69 | C3 | retn",
        "output": "\n\nstatic void\npmap_unset_recoverable(const struct pmap_recoverable *recoverable)\n{\n\tint i;\n\n\tfor (i = recoverable->nrecoverable; i < recoverable->nrecoverable_max;\n\t    ++i) {\n\t\tif (!pmap_unset(recoverable->recoverable, i,\n\t\t    (vm_size_t)recoverable->vers)) {\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"pmap_unset(%u,%u) failed\",\n\t\t\t    recoverable->recoverable, i);\n\t\t}\n\t}\n}",
        "source_code": "static void unregister_rpc(servtab_t *sep)\n{\n\tint n;\n\n\tfor (n = sep->se_rpcver_lo; n <= sep->se_rpcver_hi; n++) {\n\t\tif (!pmap_unset(sep->se_rpcprog, n))\n\t\t\tbb_perror_msg(\"pmap_unset(%u,%u)\", sep->se_rpcprog, n);\n\t}\n}",
        "parsed_output": "\n\nstatic void\npmap_unset_recoverable(const struct pmap_recoverable *recoverable)\n{\n\tint i;\n\n\tfor (i = recoverable->nrecoverable; i < recoverable->nrecoverable_max;\n\t    ++i) {\n\t\tif (!pmap_unset(recoverable->recoverable, i,\n\t\t    (vm_size_t)recoverable->vers)) {\n\t\t\tlog(LOG_ERR,\n\t\t\t    \"pmap_unset(%u,%u) failed\",\n\t\t\t    recoverable->recoverable, i);\n\t\t}\n\t}\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_433D06(unsigned int *a1)\n{\n  __int64 v1; // rcx\n  __int64 v2; // r8\n  __int64 v3; // r9\n  __int64 result; // rax\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = a1[9]; ; ++i )\n  {\n    result = a1[10];\n    if ( i > (int)result )\n      break;\n    if ( !pmap_unset((int)a1[8], i) )\n      sub_4091D9((__int64)\"pmap_unset(%u,%u)\", a1[8], (unsigned int)i, v1, v2, v3);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl unregister_rpc(servtab_t_0 *sep)\n{\n  int n; // [rsp+1Ch] [rbp-4h]\n\n  for ( n = sep->se_rpcver_lo; n <= sep->se_rpcver_hi; ++n )\n  {\n    if ( !pmap_unset(sep->se_rpcprog, n) )\n      bb_perror_msg(\"pmap_unset(%u,%u)\", (unsigned int)sep->se_rpcprog, (unsigned int)n);\n  }\n}\n",
        "similarity_score_unixcoder": 0.6216095089912415,
        "similarity_score_baseline_stripped": 0.5096832513809204,
        "similarity_score_baseline_debug": 0.931544840335846
    },
    {
        "func_name": "run_applet_and_exit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004C33AC | 55 | push    rbp\n0x004C33AD | 48 89 E5 | mov     rbp, rsp\n0x004C33B0 | 48 83 EC 20 | sub     rsp, 20h\n0x004C33B4 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004C33B8 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004C33BC | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004C33C0 | 48 89 C7 | mov     rdi, rax\n0x004C33C3 | E8 12 FF FF FF | call    sub_4C32DA\n0x004C33C8 | 89 45 FC | mov     [rbp+fd], eax\n0x004C33CB | 83 7D FC 00 | cmp     [rbp+fd], 0\n0x004C33CF | 79 07 | jns     short loc_4C33D8\n0x004C33D1 | B8 00 00 00 00 | mov     eax, 0\n0x004C33D6 | EB 40 | jmp     short locret_4C3418\n0x004C33D8 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x004C33DC | 8B 45 FC | mov     eax, [rbp+fd]\n0x004C33DF | 48 89 D6 | mov     rsi, rdx\n0x004C33E2 | 89 C7 | mov     edi, eax\n0x004C33E4 | E8 7B 3E 04 00 | call    sub_507264\n0x004C33E9 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x004C33ED | 48 83 7D F0 00 | cmp     [rbp+var_10], 0\n0x004C33F2 | 75 16 | jnz     short loc_4C340A\n0x004C33F4 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004C33F8 | 48 89 C6 | mov     rsi, rax\n0x004C33FB | BF B6 68 53 00 | mov     edi, offset aReadErrorFromS; \"read error from '%s'\"\n0x004C3400 | B8 00 00 00 00 | mov     eax, 0\n0x004C3405 | E8 CF 5D F4 FF | call    sub_4091D9\n0x004C340A | 8B 45 FC | mov     eax, [rbp+fd]\n0x004C340D | 89 C7 | mov     edi, eax; fd\n0x004C340F | E8 FC 39 F4 FF | call    _close\n0x004C3414 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004C3418 | C9 | leave\n0x004C3419 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC xmalloc_open_zipped_read_close(const char *fname, size_t *maxsz_p)\n{\n\tint fd;\n\tchar *image;\n\n\tfd = open_zipped(fname);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\timage = xmalloc_read(fd, maxsz_p);\n\tif (!image)\n\t\tbb_perror_msg(\"read error from '%s'\", fname);\n\tclose(fd);\n\n\treturn image;\n}\n\n## Example:\n\n Input assembly code:\n0x004F3F0D | 55 | push    rbp\n0x004F3F0E | 48 89 E5 | mov     rbp, rsp\n0x004F3F11 | 48 83 EC 20 | sub     rsp, 20h\n0x004F3F15 | 48 89 7D E8 | mov     [rbp+stream], rdi\n0x004F3F19 | 48 89 75 E0 | mov     [rbp+file], rsi\n0x004F3F1D | 48 8B 45 E0 | mov     rax, [rbp+file]\n0x004F3F21 | BE 00 00 00 00 | mov     esi, 0; oflag\n0x004F3F26 | 48 89 C7 | mov     rdi, rax; file\n0x004F3F29 | B8 00 00 00 00 | mov     eax, 0\n0x004F3F2E | E8 9D 37 F1 FF | call    _open64\n0x004F3F33 | 89 45 FC | mov     [rbp+fd], eax\n0x004F3F36 | 83 7D FC 00 | cmp     [rbp+fd], 0\n0x004F3F3A | 78 52 | js      short loc_4F3F8E\n0x004F3F3C | 48 8B 45 E8 | mov     rax, [rbp+stream]\n0x004F3F40 | 48 89 C6 | mov     rsi, rax; stream\n0x004F3F43 | BF F8 B3 75 00 | mov     edi, offset dest; s\n0x004F3F48 | E8 73 30 F1 FF | call    _fputs_unlocked\n0x004F3F4D | 48 8B 45 E8 | mov     rax, [rbp+stream]\n0x004F3F51 | 48 89 C7 | mov     rdi, rax; stream\n0x004F3F54 | E8 27 34 F1 FF | call    _fflush\n0x004F3F59 | 48 8B 45 E8 | mov     rax, [rbp+stream]\n0x004F3F5D | 48 89 C7 | mov     rdi, rax; stream\n0x004F3F60 | E8 FB 32 F1 FF | call    _fileno\n0x004F3F65 | 89 C2 | mov     edx, eax\n0x004F3F67 | 8B 45 FC | mov     eax, [rbp+fd]\n0x004F3F6A | 89 D6 | mov     esi, edx\n0x004F3F6C | 89 C7 | mov     edi, eax\n0x004F3F6E | E8 F3 73 F1 FF | call    sub_40B366\n0x004F3F73 | 8B 45 FC | mov     eax, [rbp+fd]\n0x004F3F76 | 89 C7 | mov     edi, eax; fd\n0x004F3F78 | E8 93 2E F1 FF | call    _close\n0x004F3F7D | 48 8B 45 E8 | mov     rax, [rbp+stream]\n0x004F3F81 | 48 89 C6 | mov     rsi, rax; stream\n0x004F3F84 | BF 0A 00 00 00 | mov     edi, 0Ah; c\n0x004F3F89 | E8 A2 33 F1 FF | call    _putc_unlocked\n0x004F3F8E | 90 | nop\n0x004F3F8F | C9 | leave\n0x004F3F90 | C3 | retn\n\n Ourput decompiled code:\nstatic void dump_file(FILE *fp, const char *filename)\n{\n\tint fd = open(filename, O_RDONLY);\n\tif (fd >= 0) {\n\t\tfputs(G.jiffy_line, fp);\n\t\tfflush(fp);\n\t\tbb_copyfd_eof(fd, fileno(fp));\n\t\tclose(fd);\n\t\tfputc('\\n', fp);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x005073F7 | 55 | push    rbp\n0x005073F8 | 48 89 E5 | mov     rbp, rsp\n0x005073FB | 48 83 EC 20 | sub     rsp, 20h\n0x005073FF | 48 89 7D E8 | mov     [rbp+file], rdi\n0x00507403 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00507407 | 48 8B 45 E8 | mov     rax, [rbp+file]\n0x0050740B | BE 00 00 00 00 | mov     esi, 0; oflag\n0x00507410 | 48 89 C7 | mov     rdi, rax; file\n0x00507413 | B8 00 00 00 00 | mov     eax, 0\n0x00507418 | E8 B3 02 F0 FF | call    _open64\n0x0050741D | 89 45 FC | mov     [rbp+fd], eax\n0x00507420 | 83 7D FC 00 | cmp     [rbp+fd], 0\n0x00507424 | 79 07 | jns     short loc_50742D\n0x00507426 | B8 00 00 00 00 | mov     eax, 0\n0x0050742B | EB 23 | jmp     short locret_507450\n0x0050742D | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00507431 | 8B 45 FC | mov     eax, [rbp+fd]\n0x00507434 | 48 89 D6 | mov     rsi, rdx\n0x00507437 | 89 C7 | mov     edi, eax\n0x00507439 | E8 26 FE FF FF | call    sub_507264\n0x0050743E | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x00507442 | 8B 45 FC | mov     eax, [rbp+fd]\n0x00507445 | 89 C7 | mov     edi, eax; fd\n0x00507447 | E8 C4 F9 EF FF | call    _close\n0x0050744C | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00507450 | C9 | leave\n0x00507451 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC xmalloc_open_read_close(const char *filename, size_t *maxsz_p)\n{\n\tchar *buf;\n\tsize_t size;\n\tint fd;\n\toff_t len;\n\n\tfd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\t/* /proc/N/stat files report len 0 here */\n\t/* In order to make such files readable, we add small const */\n\tsize = 0x3ff; /* read only 1k on unseekable files */\n\tlen = lseek(fd, 0, SEEK_END) | 0x3ff; /* + up to 1k */\n\tif (len != (off_t)-1) {\n\t\txlseek(fd, 0, SEEK_SET);\n\t\tsize = maxsz_p ? *maxsz_p : (INT_MAX - 4095);\n\t\tif (len < size)\n\t\t\tsize = len;\n\t}\n\n\tbuf = xmalloc(size + 1);\n\tsize = read_close(fd, buf, size);\n\tif ((ssize_t)size < 0) {\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tbuf = xrealloc(buf, size + 1);\n\tbuf[size] = '\\0';\n\n\tif (maxsz_p)\n\t\t*maxsz_p = size;\n\treturn buf;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00408CFF | 55 | push    rbp\n0x00408D00 | 48 89 E5 | mov     rbp, rsp\n0x00408D03 | 48 83 EC 20 | sub     rsp, 20h\n0x00408D07 | 48 89 7D E8 | mov     [rbp+s1], rdi\n0x00408D0B | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00408D0F | 48 8B 45 E8 | mov     rax, [rbp+s1]\n0x00408D13 | 48 89 C7 | mov     rdi, rax\n0x00408D16 | E8 4D F3 FF FF | call    sub_408068\n0x00408D1B | 89 45 FC | mov     [rbp+var_4], eax\n0x00408D1E | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x00408D22 | 78 11 | js      short loc_408D35\n0x00408D24 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00408D28 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00408D2B | 48 89 D6 | mov     rsi, rdx\n0x00408D2E | 89 C7 | mov     edi, eax\n0x00408D30 | E8 FE FE FF FF | call    sub_408C33\n0x00408D35 | 48 8B 45 E8 | mov     rax, [rbp+s1]\n0x00408D39 | BA 07 00 00 00 | mov     edx, 7; n\n0x00408D3E | BE 3F 4D 51 00 | mov     esi, offset aBusybox; \"busybox\"\n0x00408D43 | 48 89 C7 | mov     rdi, rax; s1\n0x00408D46 | E8 55 DA FF FF | call    _strncmp\n0x00408D4B | 85 C0 | test    eax, eax\n0x00408D4D | 75 13 | jnz     short loc_408D62\n0x00408D4F | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00408D53 | 48 89 C7 | mov     rdi, rax\n0x00408D56 | E8 4E FB FF FF | call    sub_4088A9\n0x00408D5B | 89 C7 | mov     edi, eax; status\n0x00408D5D | E8 5E ED FF FF | call    _exit\n0x00408D62 | 90 | nop\n0x00408D63 | C9 | leave\n0x00408D64 | C3 | retn",
        "output": "\n\nstatic void\nrun_busybox(const char *s1, const char *s2)\n{\n\tint status;\n\tint fd;\n\n\tfd = open_zipped(s1);\n\tif (fd < 0)\n\t\tfd = open(s1, 0);\n\tif (fd < 0)\n\t\texit(strncmp(s1, \"busybox\", 7) ?\n\t\t    run_busybox_or_exit(s2) :\n\t\t    run_busybox_or_exit(s1));\n\tstatus = run_busybox_or_exit(fd);\n\texit(status);\n}",
        "source_code": "void FAST_FUNC run_applet_and_exit(const char *name, char **argv)\n{\n\tint applet = find_applet_by_name(name);\n\tif (applet >= 0)\n\t\trun_applet_no_and_exit(applet, argv);\n\tif (strncmp(name, \"busybox\", 7) == 0)\n\t\texit(busybox_main(argv));\n}",
        "parsed_output": "\n\nstatic void\nrun_busybox(const char *s1, const char *s2)\n{\n\tint status;\n\tint fd;\n\n\tfd = open_zipped(s1);\n\tif (fd < 0)\n\t\tfd = open(s1, 0);\n\tif (fd < 0)\n\t\texit(strncmp(s1, \"busybox\", 7) ?\n\t\t    run_busybox_or_exit(s2) :\n\t\t    run_busybox_or_exit(s1));\n\tstatus = run_busybox_or_exit(fd);\n\texit(status);\n}",
        "baseline_code_stripped": "int __fastcall sub_408CFF(const void *a1, const char *a2)\n{\n  int result; // eax\n  int v3; // eax\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  v4 = sub_408068(a1);\n  if ( v4 >= 0 )\n    sub_408C33(v4, a2);\n  result = strncmp((const char *)a1, \"busybox\", 7uLL);\n  if ( !result )\n  {\n    v3 = sub_4088A9((__int64)a2);\n    exit(v3);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl run_applet_and_exit(const char *name, char **argv)\n{\n  int v2; // eax\n  int applet; // [rsp+1Ch] [rbp-4h]\n\n  applet = find_applet_by_name(name);\n  if ( applet >= 0 )\n    run_applet_no_and_exit(applet, argv);\n  if ( !strncmp(name, \"busybox\", 7uLL) )\n  {\n    v2 = busybox_main(argv);\n    exit(v2);\n  }\n}\n",
        "similarity_score_unixcoder": 0.7410198450088501,
        "similarity_score_baseline_stripped": 0.6401079297065735,
        "similarity_score_baseline_debug": 0.877385675907135
    },
    {
        "func_name": "reload_inittab",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004E9DD5 | 55 | push    rbp\n0x004E9DD6 | 48 89 E5 | mov     rbp, rsp\n0x004E9DD9 | 48 83 EC 20 | sub     rsp, 20h\n0x004E9DDD | 48 89 7D E8 | mov     [rbp+s2], rdi\n0x004E9DE1 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004E9DE6 | 48 8B 80 88 00 00 00 | mov     rax, [rax+88h]\n0x004E9DED | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004E9DF1 | EB 45 | jmp     short loc_4E9E38\n0x004E9DF3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004E9DF7 | 0F B6 40 46 | movzx   eax, byte ptr [rax+46h]\n0x004E9DFB | 3C 3A | cmp     al, 3Ah ; ':'\n0x004E9DFD | 75 2E | jnz     short loc_4E9E2D\n0x004E9DFF | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004E9E03 | 48 8B 40 38 | mov     rax, [rax+38h]\n0x004E9E07 | 48 85 C0 | test    rax, rax\n0x004E9E0A | 74 21 | jz      short loc_4E9E2D\n0x004E9E0C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004E9E10 | 48 8B 40 38 | mov     rax, [rax+38h]\n0x004E9E14 | 48 8B 55 E8 | mov     rdx, [rbp+s2]\n0x004E9E18 | 48 89 D6 | mov     rsi, rdx; s2\n0x004E9E1B | 48 89 C7 | mov     rdi, rax; s1\n0x004E9E1E | E8 2D D2 F1 FF | call    _strcmp\n0x004E9E23 | 85 C0 | test    eax, eax\n0x004E9E25 | 75 06 | jnz     short loc_4E9E2D\n0x004E9E27 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004E9E2B | EB 28 | jmp     short locret_4E9E55\n0x004E9E2D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004E9E31 | 48 8B 00 | mov     rax, [rax]\n0x004E9E34 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004E9E38 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004E9E3D | 75 B4 | jnz     short loc_4E9DF3\n0x004E9E3F | 48 8B 45 E8 | mov     rax, [rbp+s2]\n0x004E9E43 | 48 89 C6 | mov     rsi, rax\n0x004E9E46 | BF 30 6F 52 00 | mov     edi, offset aCanTFindLabelF; \"can't find label for jump to '%s'\"\n0x004E9E4B | B8 00 00 00 00 | mov     eax, 0\n0x004E9E50 | E8 49 F8 F1 FF | call    sub_40969E\n0x004E9E55 | C9 | leave\n0x004E9E56 | C3 | retn\n\n Ourput decompiled code:\nstatic sed_cmd_t *branch_to(char *label)\n{\n\tsed_cmd_t *sed_cmd;\n\n\tfor (sed_cmd = G.sed_cmd_head; sed_cmd; sed_cmd = sed_cmd->next) {\n\t\tif (sed_cmd->cmd == ':' && sed_cmd->string && !strcmp(sed_cmd->string, label)) {\n\t\t\treturn sed_cmd;\n\t\t}\n\t}\n\tbb_error_msg_and_die(\"can't find label for jump to '%s'\", label);\n}\n\n## Example:\n\n Input assembly code:\n0x0042DD7A | 55 | push    rbp\n0x0042DD7B | 48 89 E5 | mov     rbp, rsp\n0x0042DD7E | 48 83 EC 20 | sub     rsp, 20h\n0x0042DD82 | 48 89 7D E8 | mov     [rbp+s1], rdi\n0x0042DD86 | 48 8B 05 7B F6 32 00 | mov     rax, cs:qword_75D408\n0x0042DD8D | 48 8B 80 38 01 00 00 | mov     rax, [rax+138h]\n0x0042DD94 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0042DD98 | EB 3F | jmp     short loc_42DDD9\n0x0042DD9A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0042DD9E | 48 8B 40 08 | mov     rax, [rax+8]\n0x0042DDA2 | 48 89 C7 | mov     rdi, rax; s\n0x0042DDA5 | E8 26 8D FD FF | call    _strlen\n0x0042DDAA | 48 89 C2 | mov     rdx, rax; n\n0x0042DDAD | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0042DDB1 | 48 8B 48 08 | mov     rcx, [rax+8]\n0x0042DDB5 | 48 8B 45 E8 | mov     rax, [rbp+s1]\n0x0042DDB9 | 48 89 CE | mov     rsi, rcx; s2\n0x0042DDBC | 48 89 C7 | mov     rdi, rax; s1\n0x0042DDBF | E8 DC 89 FD FF | call    _strncmp\n0x0042DDC4 | 85 C0 | test    eax, eax\n0x0042DDC6 | 75 06 | jnz     short loc_42DDCE\n0x0042DDC8 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0042DDCC | EB 17 | jmp     short locret_42DDE5\n0x0042DDCE | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0042DDD2 | 48 8B 00 | mov     rax, [rax]\n0x0042DDD5 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0042DDD9 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0042DDDE | 75 BA | jnz     short loc_42DD9A\n0x0042DDE0 | B8 00 00 00 00 | mov     eax, 0\n0x0042DDE5 | C9 | leave\n0x0042DDE6 | C3 | retn\n\n Ourput decompiled code:\nif ENABLE_FEATURE_HTTPD_PROXY\nstatic Htaccess_Proxy *find_proxy_entry(const char *url)\n{\n\tHtaccess_Proxy *p;\n\tfor (p = proxy; p; p = p->next) {\n\t\tif (strncmp(url, p->url_from, strlen(p->url_from)) == 0)\n\t\t\treturn p;\n\t}\n\treturn NULL;\n}\n\n## Example:\n\n Input assembly code:\n0x0045B51E | 55 | push    rbp\n0x0045B51F | 48 89 E5 | mov     rbp, rsp\n0x0045B522 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0045B526 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0045B52B | 48 8B 40 08 | mov     rax, [rax+8]\n0x0045B52F | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0045B533 | EB 4F | jmp     short loc_45B584\n0x0045B535 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045B539 | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x0045B53D | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0045B541 | 48 8B 00 | mov     rax, [rax]\n0x0045B544 | 48 39 C2 | cmp     rdx, rax\n0x0045B547 | 75 30 | jnz     short loc_45B579\n0x0045B549 | 8B 05 01 1F 30 00 | mov     eax, cs:dword_75D450\n0x0045B54F | 83 E0 01 | and     eax, 1\n0x0045B552 | 85 C0 | test    eax, eax\n0x0045B554 | 74 07 | jz      short loc_45B55D\n0x0045B556 | B8 01 00 00 00 | mov     eax, 1\n0x0045B55B | EB 33 | jmp     short loc_45B590\n0x0045B55D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045B561 | 48 8B 50 08 | mov     rdx, [rax+8]\n0x0045B565 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0045B569 | 48 8B 40 08 | mov     rax, [rax+8]\n0x0045B56D | 48 39 C2 | cmp     rdx, rax\n0x0045B570 | 75 07 | jnz     short loc_45B579\n0x0045B572 | B8 01 00 00 00 | mov     eax, 1\n0x0045B577 | EB 17 | jmp     short loc_45B590\n0x0045B579 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0045B57D | 48 8B 00 | mov     rax, [rax]\n0x0045B580 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0045B584 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0045B589 | 75 AA | jnz     short loc_45B535\n0x0045B58B | B8 00 00 00 00 | mov     eax, 0\n0x0045B590 | 5D | pop     rbp\n0x0045B591 | C3 | retn\n\n Ourput decompiled code:\nstatic smallint search_dev_inode(const struct stat *st)\n{\n\tinode_list *ilist = G.inode_list_head;\n\n\twhile (ilist) {\n\t\tif (ilist->dev == st->st_dev) {\n\t\t\tif (option_mask32 & OPT_MOUNT)\n\t\t\t\treturn 1;\n\t\t\tif (ilist->inode == st->st_ino)\n\t\t\t\treturn 1;\n\t\t}\n\t\tilist = ilist->next;\n\t}\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F5915 | 55 | push    rbp\n0x004F5916 | 48 89 E5 | mov     rbp, rsp\n0x004F5919 | 48 83 EC 10 | sub     rsp, 10h\n0x004F591D | BE F8 39 53 00 | mov     esi, offset aReloadingEtcIn; \"reloading /etc/inittab\"\n0x004F5922 | BF 01 00 00 00 | mov     edi, 1\n0x004F5927 | B8 00 00 00 00 | mov     eax, 0\n0x004F592C | E8 91 F2 FF FF | call    sub_4F4BC2\n0x004F5931 | 48 8B 05 78 59 26 00 | mov     rax, cs:qword_75B2B0\n0x004F5938 | 48 89 45 F8 | mov     [rbp+ptr], rax\n0x004F593C | EB 13 | jmp     short loc_4F5951\n0x004F593E | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004F5942 | C6 40 0C 00 | mov     byte ptr [rax+0Ch], 0\n0x004F5946 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004F594A | 48 8B 00 | mov     rax, [rax]\n0x004F594D | 48 89 45 F8 | mov     [rbp+ptr], rax\n0x004F5951 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0\n0x004F5956 | 75 E6 | jnz     short loc_4F593E\n0x004F5958 | E8 A6 FB FF FF | call    sub_4F5503\n0x004F595D | 48 C7 45 F0 B0 B2 75 00 | mov     [rbp+var_10], offset qword_75B2B0\n0x004F5965 | EB 36 | jmp     short loc_4F599D\n0x004F5967 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004F596B | 0F B6 40 0C | movzx   eax, byte ptr [rax+0Ch]\n0x004F596F | 0F B6 C0 | movzx   eax, al\n0x004F5972 | 83 E0 FE | and     eax, 0FFFFFFFEh\n0x004F5975 | 85 C0 | test    eax, eax\n0x004F5977 | 75 1C | jnz     short loc_4F5995\n0x004F5979 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004F597D | 48 8B 10 | mov     rdx, [rax]\n0x004F5980 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004F5984 | 48 89 10 | mov     [rax], rdx\n0x004F5987 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004F598B | 48 89 C7 | mov     rdi, rax; ptr\n0x004F598E | E8 CD 0C F1 FF | call    _free\n0x004F5993 | EB 08 | jmp     short loc_4F599D\n0x004F5995 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004F5999 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x004F599D | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004F59A1 | 48 8B 00 | mov     rax, [rax]\n0x004F59A4 | 48 89 45 F8 | mov     [rbp+ptr], rax\n0x004F59A8 | 48 83 7D F8 00 | cmp     [rbp+ptr], 0\n0x004F59AD | 75 B8 | jnz     short loc_4F5967\n0x004F59AF | 90 | nop\n0x004F59B0 | C9 | leave\n0x004F59B1 | C3 | retn",
        "output": "\n\nstatic void\nreload_etc_inittab(void)\n{\n\tinittab_list *ilist;\n\n\tbb_simple_msg(1, \"reloading /etc/inittab\");\n\n\tfor (ilist = G.inittab_list_head; ilist; ilist = ilist->next)\n\t\tilist->inittab->i_flags = 0;\n\n\tfree_inittab_list();\n\n\tG.inittab = G.inittab_list_head;\n\tfor (ilist = G.inittab_list_head; ilist; ilist = ilist->next) {\n\t\tif (!(ilist->inittab->i_flags & ~1)) {\n\t\t\tG.inittab = ilist->inittab;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree_inittab_list_ptr(ilist);\n}",
        "source_code": "if ENABLE_FEATURE_USE_INITTAB\nstatic void reload_inittab(void)\n{\n\tstruct init_action *a, **nextp;\n\n\tmessage(L_LOG, \"reloading /etc/inittab\");\n\n\t/* Disable old entries */\n\tfor (a = init_action_list; a; a = a->next)\n\t\ta->action_type = 0;\n\n\t/* Append new entries, or modify existing entries\n\t * (incl. setting a->action_type) if cmd and device name\n\t * match new ones. End result: only entries with\n\t * a->action_type == 0 are stale.\n\t */\n\tparse_inittab();\n\n#if ENABLE_FEATURE_KILL_REMOVED\n\t/* Kill stale entries */\n\t/* Be nice and send SIGTERM first */\n\tfor (a = init_action_list; a; a = a->next)\n\t\tif (a->action_type == 0 && a->pid != 0)\n\t\t\tkill(a->pid, SIGTERM);\n\tif (CONFIG_FEATURE_KILL_DELAY) {\n\t\t/* NB: parent will wait in NOMMU case */\n\t\tif ((BB_MMU ? fork() : vfork()) == 0) { /* child */\n\t\t\tsleep(CONFIG_FEATURE_KILL_DELAY);\n\t\t\tfor (a = init_action_list; a; a = a->next)\n\t\t\t\tif (a->action_type == 0 && a->pid != 0)\n\t\t\t\t\tkill(a->pid, SIGKILL);\n\t\t\t_exit(EXIT_SUCCESS);\n\t\t}\n\t}\n#endif\n\n\t/* Remove stale entries and SYSINIT entries.\n\t * We never rerun SYSINIT entries anyway,\n\t * removing them too saves a few bytes */\n\tnextp = &init_action_list;\n\twhile ((a = *nextp) != NULL) {\n\t\tif ((a->action_type & ~SYSINIT) == 0) {\n\t\t\t*nextp = a->next;\n\t\t\tfree(a);\n\t\t} else {\n\t\t\tnextp = &a->next;\n\t\t}\n\t}\n\n\t/* Not needed: */\n\t/* run_actions(RESPAWN | ASKFIRST); */\n\t/* - we return to main loop, which does this automagically */\n}",
        "parsed_output": "\n\nstatic void\nreload_etc_inittab(void)\n{\n\tinittab_list *ilist;\n\n\tbb_simple_msg(1, \"reloading /etc/inittab\");\n\n\tfor (ilist = G.inittab_list_head; ilist; ilist = ilist->next)\n\t\tilist->inittab->i_flags = 0;\n\n\tfree_inittab_list();\n\n\tG.inittab = G.inittab_list_head;\n\tfor (ilist = G.inittab_list_head; ilist; ilist = ilist->next) {\n\t\tif (!(ilist->inittab->i_flags & ~1)) {\n\t\t\tG.inittab = ilist->inittab;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree_inittab_list_ptr(ilist);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4F5915(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 result; // rax\n  __int64 *v7; // [rsp+0h] [rbp-10h]\n  _BYTE *ptr; // [rsp+8h] [rbp-8h]\n  _BYTE *ptra; // [rsp+8h] [rbp-8h]\n\n  sub_4F4BC2(1, \"reloading /etc/inittab\", a3, a4, a5, a6);\n  for ( ptr = (_BYTE *)qword_75B2B0; ptr; ptr = *(_BYTE **)ptr )\n    ptr[12] = 0;\n  sub_4F5503();\n  v7 = &qword_75B2B0;\n  while ( 1 )\n  {\n    result = *v7;\n    ptra = (_BYTE *)*v7;\n    if ( !*v7 )\n      break;\n    if ( (ptra[12] & 0xFE) != 0 )\n    {\n      v7 = (__int64 *)*v7;\n    }\n    else\n    {\n      *v7 = *(_QWORD *)ptra;\n      free(ptra);\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl reload_inittab()\n{\n  init_action **nextp; // [rsp+0h] [rbp-10h]\n  init_action *a; // [rsp+8h] [rbp-8h]\n  init_action *aa; // [rsp+8h] [rbp-8h]\n\n  message(1, \"reloading /etc/inittab\");\n  for ( a = init_action_list; a; a = a->next )\n    a->action_type = 0;\n  parse_inittab();\n  nextp = &init_action_list;\n  while ( 1 )\n  {\n    aa = *nextp;\n    if ( !*nextp )\n      break;\n    if ( (aa->action_type & 0xFE) != 0 )\n    {\n      nextp = (init_action **)*nextp;\n    }\n    else\n    {\n      *nextp = aa->next;\n      free(aa);\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.6838207244873047,
        "similarity_score_baseline_stripped": 0.6020675897598267,
        "similarity_score_baseline_debug": 0.8100898265838623
    },
    {
        "func_name": "sfp_to_d",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00454080 | 55 | push    rbp\n0x00454081 | 48 89 E5 | mov     rbp, rsp\n0x00454084 | 48 83 EC 20 | sub     rsp, 20h\n0x00454088 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0045408C | 89 F0 | mov     eax, esi\n0x0045408E | 88 45 E4 | mov     [rbp+var_1C], al\n0x00454091 | 0F BE 55 E4 | movsx   edx, [rbp+var_1C]\n0x00454095 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00454099 | 89 D6 | mov     esi, edx\n0x0045409B | 48 89 C7 | mov     rdi, rax\n0x0045409E | E8 A1 47 00 00 | call    sub_458844\n0x004540A3 | E8 CD FF FF FF | call    sub_454075\n0x004540A8 | 89 C2 | mov     edx, eax\n0x004540AA | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004540AE | 89 50 04 | mov     [rax+4], edx\n0x004540B1 | E8 2C 7C FB FF | call    sub_40BCE2\n0x004540B6 | 89 C2 | mov     edx, eax\n0x004540B8 | B8 F8 C3 75 00 | mov     eax, offset unk_75C3F8\n0x004540BD | 66 89 50 72 | mov     [rax+72h], dx\n0x004540C1 | B8 F8 C3 75 00 | mov     eax, offset unk_75C3F8\n0x004540C6 | 0F B7 40 70 | movzx   eax, word ptr [rax+70h]\n0x004540CA | 66 85 C0 | test    ax, ax\n0x004540CD | 75 12 | jnz     short loc_4540E1\n0x004540CF | B8 F8 C3 75 00 | mov     eax, offset unk_75C3F8\n0x004540D4 | BA F8 C3 75 00 | mov     edx, offset unk_75C3F8\n0x004540D9 | 0F B7 40 72 | movzx   eax, word ptr [rax+72h]\n0x004540DD | 66 89 42 70 | mov     [rdx+70h], ax\n0x004540E1 | B8 F8 C3 75 00 | mov     eax, offset unk_75C3F8\n0x004540E6 | 0F B7 50 72 | movzx   edx, word ptr [rax+72h]\n0x004540EA | B8 F8 C3 75 00 | mov     eax, offset unk_75C3F8\n0x004540EF | 0F B7 40 70 | movzx   eax, word ptr [rax+70h]\n0x004540F3 | 29 C2 | sub     edx, eax\n0x004540F5 | 89 D0 | mov     eax, edx\n0x004540F7 | 66 89 45 FE | mov     [rbp+var_2], ax\n0x004540FB | 0F B7 45 FE | movzx   eax, [rbp+var_2]\n0x004540FF | 89 C7 | mov     edi, eax; hostshort\n0x00454101 | E8 6A 2A FB FF | call    _htons\n0x00454106 | 89 C2 | mov     edx, eax\n0x00454108 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0045410C | 66 89 50 08 | mov     [rax+8], dx\n0x00454110 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00454114 | 48 83 C0 1C | add     rax, 1Ch\n0x00454118 | BA 06 00 00 00 | mov     edx, 6; n\n0x0045411D | BE F8 C3 75 00 | mov     esi, offset unk_75C3F8; src\n0x00454122 | 48 89 C7 | mov     rdi, rax; dest\n0x00454125 | E8 76 30 FB FF | call    _memcpy\n0x0045412A | B8 F8 C3 75 00 | mov     eax, offset unk_75C3F8\n0x0045412F | 48 8B 40 50 | mov     rax, [rax+50h]\n0x00454133 | 48 85 C0 | test    rax, rax\n0x00454136 | 74 18 | jz      short loc_454150\n0x00454138 | B8 F8 C3 75 00 | mov     eax, offset unk_75C3F8\n0x0045413D | 48 8B 50 50 | mov     rdx, [rax+50h]\n0x00454141 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00454145 | 48 89 D6 | mov     rsi, rdx\n0x00454148 | 48 89 C7 | mov     rdi, rax\n0x0045414B | E8 32 5A 00 00 | call    sub_459B82\n0x00454150 | 90 | nop\n0x00454151 | C9 | leave\n0x00454152 | C3 | retn\n\n Ourput decompiled code:\nstatic void init_packet(struct dhcp_packet *packet, char type)\n{\n\tuint16_t secs;\n\n\t/* Fill in: op, htype, hlen, cookie fields; message type option: */\n\tudhcp_init_header(packet, type);\n\n\tpacket->xid = random_xid();\n\n\tclient_config.last_secs = monotonic_sec();\n\tif (client_config.first_secs == 0)\n\t\tclient_config.first_secs = client_config.last_secs;\n\tsecs = client_config.last_secs - client_config.first_secs;\n\tpacket->secs = htons(secs);\n\n\tmemcpy(packet->chaddr, client_config.client_mac, 6);\n\tif (client_config.clientid)\n\t\tudhcp_add_binary_option(packet, client_config.clientid);\n}\n\n## Example:\n\n Input assembly code:\n0x00412E8A | 55 | push    rbp\n0x00412E8B | 48 89 E5 | mov     rbp, rsp\n0x00412E8E | 48 83 EC 20 | sub     rsp, 20h\n0x00412E92 | 89 7D EC | mov     [rbp+algorithm], edi\n0x00412E95 | 48 C7 45 F8 10 50 51 00 | mov     [rbp+format], offset aSMinMaxPriorit; \"%s min/max priority\\t: %u/%u\\n\"\n0x00412E9D | 8B 45 EC | mov     eax, [rbp+algorithm]\n0x00412EA0 | 89 C7 | mov     edi, eax; algorithm\n0x00412EA2 | E8 39 4C FF FF | call    _sched_get_priority_max\n0x00412EA7 | 89 45 F4 | mov     [rbp+var_C], eax\n0x00412EAA | 8B 45 EC | mov     eax, [rbp+algorithm]\n0x00412EAD | 89 C7 | mov     edi, eax; algorithm\n0x00412EAF | E8 0C 45 FF FF | call    _sched_get_priority_min\n0x00412EB4 | 89 45 F0 | mov     [rbp+var_10], eax\n0x00412EB7 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x00412EBA | 0B 45 F0 | or      eax, [rbp+var_10]\n0x00412EBD | 85 C0 | test    eax, eax\n0x00412EBF | 79 08 | jns     short loc_412EC9\n0x00412EC1 | 48 C7 45 F8 2D 50 51 00 | mov     [rbp+format], offset aSNotSupported; \"%s not supported\\n\"\n0x00412EC9 | 8B 45 EC | mov     eax, [rbp+algorithm]\n0x00412ECC | 48 98 | cdqe\n0x00412ECE | 48 C1 E0 04 | shl     rax, 4\n0x00412ED2 | 48 05 E0 4F 51 00 | add     rax, 514FE0h\n0x00412ED8 | 48 8D 70 04 | lea     rsi, [rax+4]\n0x00412EDC | 8B 4D F4 | mov     ecx, [rbp+var_C]\n0x00412EDF | 8B 55 F0 | mov     edx, [rbp+var_10]\n0x00412EE2 | 48 8B 45 F8 | mov     rax, [rbp+format]\n0x00412EE6 | 48 89 C7 | mov     rdi, rax; format\n0x00412EE9 | B8 00 00 00 00 | mov     eax, 0\n0x00412EEE | E8 DD 3C FF FF | call    _printf\n0x00412EF3 | 90 | nop\n0x00412EF4 | C9 | leave\n0x00412EF5 | C3 | retn\n\n Ourput decompiled code:\nSCHED_IDLE\n\nstatic void show_min_max(int pol)\n{\n\tconst char *fmt = \"%s min/max priority\\t: %u/%u\\n\";\n\tint max, min;\n\n\tmax = sched_get_priority_max(pol);\n\tmin = sched_get_priority_min(pol);\n\tif ((max|min) < 0)\n\t\tfmt = \"%s not supported\\n\";\n\tprintf(fmt, policies[pol].name, min, max);\n}\n\n## Example:\n\n Input assembly code:\n0x0043B3F6 | 55 | push    rbp\n0x0043B3F7 | 48 89 E5 | mov     rbp, rsp\n0x0043B3FA | 48 83 EC 20 | sub     rsp, 20h\n0x0043B3FE | F2 0F 11 45 E8 | movsd   [rbp+var_18], xmm0\n0x0043B403 | F2 0F 2C 45 E8 | cvttsd2si eax, [rbp+var_18]\n0x0043B408 | 66 89 45 FC | mov     word ptr [rbp+var_4], ax\n0x0043B40C | 0F B7 45 FC | movzx   eax, word ptr [rbp+var_4]\n0x0043B410 | 0F B7 C0 | movzx   eax, ax\n0x0043B413 | F2 0F 2A C8 | cvtsi2sd xmm1, eax\n0x0043B417 | F2 0F 10 45 E8 | movsd   xmm0, [rbp+var_18]\n0x0043B41C | F2 0F 5C C1 | subsd   xmm0, xmm1\n0x0043B420 | 66 0F 28 C8 | movapd  xmm1, xmm0\n0x0043B424 | F2 0F 10 05 0C A9 0E 00 | movsd   xmm0, cs:qword_525D38\n0x0043B42C | F2 0F 59 C1 | mulsd   xmm0, xmm1\n0x0043B430 | F2 0F 2C C0 | cvttsd2si eax, xmm0\n0x0043B434 | 66 89 45 FE | mov     word ptr [rbp+var_4+2], ax\n0x0043B438 | 0F B7 45 FC | movzx   eax, word ptr [rbp+var_4]\n0x0043B43C | 0F B7 C0 | movzx   eax, ax\n0x0043B43F | 89 C7 | mov     edi, eax; hostshort\n0x0043B441 | E8 2A B7 FC FF | call    _htons\n0x0043B446 | 66 89 45 FC | mov     word ptr [rbp+var_4], ax\n0x0043B44A | 0F B7 45 FE | movzx   eax, word ptr [rbp+var_4+2]\n0x0043B44E | 0F B7 C0 | movzx   eax, ax\n0x0043B451 | 89 C7 | mov     edi, eax; hostshort\n0x0043B453 | E8 18 B7 FC FF | call    _htons\n0x0043B458 | 66 89 45 FE | mov     word ptr [rbp+var_4+2], ax\n0x0043B45C | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0043B45F | C9 | leave\n0x0043B460 | C3 | retn\n\n Ourput decompiled code:\nstatic s_fixedpt_t\nd_to_sfp(double d)\n{\n\ts_fixedpt_t sfp;\n\tsfp.int_parts = (uint16_t)d;\n\tsfp.fractions = (uint16_t)((d - sfp.int_parts) * USHRT_MAX);\n\tsfp.int_parts = htons(sfp.int_parts);\n\tsfp.fractions = htons(sfp.fractions);\n\treturn sfp;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043B318 | 55 | push    rbp\n0x0043B319 | 48 89 E5 | mov     rbp, rsp\n0x0043B31C | 48 83 EC 20 | sub     rsp, 20h\n0x0043B320 | 89 7D EC | mov     [rbp+var_14], edi\n0x0043B323 | 0F B7 45 EC | movzx   eax, word ptr [rbp+var_14]\n0x0043B327 | 0F B7 C0 | movzx   eax, ax\n0x0043B32A | 89 C7 | mov     edi, eax; netshort\n0x0043B32C | E8 1F C3 FC FF | call    _ntohs\n0x0043B331 | 66 89 45 EC | mov     word ptr [rbp+var_14], ax\n0x0043B335 | 0F B7 45 EE | movzx   eax, word ptr [rbp+var_14+2]\n0x0043B339 | 0F B7 C0 | movzx   eax, ax\n0x0043B33C | 89 C7 | mov     edi, eax; netshort\n0x0043B33E | E8 0D C3 FC FF | call    _ntohs\n0x0043B343 | 66 89 45 EE | mov     word ptr [rbp+var_14+2], ax\n0x0043B347 | 0F B7 45 EC | movzx   eax, word ptr [rbp+var_14]\n0x0043B34B | 0F B7 C0 | movzx   eax, ax\n0x0043B34E | F2 0F 2A C8 | cvtsi2sd xmm1, eax\n0x0043B352 | 0F B7 45 EE | movzx   eax, word ptr [rbp+var_14+2]\n0x0043B356 | 0F B7 C0 | movzx   eax, ax\n0x0043B359 | F2 0F 2A C0 | cvtsi2sd xmm0, eax\n0x0043B35D | F2 0F 10 15 D3 A9 0E 00 | movsd   xmm2, cs:qword_525D38\n0x0043B365 | F2 0F 5E C2 | divsd   xmm0, xmm2\n0x0043B369 | F2 0F 58 C1 | addsd   xmm0, xmm1\n0x0043B36D | F2 0F 11 45 F8 | movsd   [rbp+var_8], xmm0\n0x0043B372 | F2 0F 10 45 F8 | movsd   xmm0, [rbp+var_8]\n0x0043B377 | C9 | leave\n0x0043B378 | C3 | retn",
        "output": "\nstatic s_fixedpt_t\nntoh_sfp(s_fixedpt_t sfp)\n{\n\tsfp.int_parts = ntohs(sfp.int_parts);\n\tsfp.fractions = ntohs(sfp.fractions);\n\tsfp.d = (double)sfp.int_parts + (double)sfp.fractions / USHRT_MAX;\n\treturn sfp;\n}",
        "source_code": "static double\nsfp_to_d(s_fixedpt_t sfp)\n{\n\tdouble ret;\n\tsfp.int_parts = ntohs(sfp.int_parts);\n\tsfp.fractions = ntohs(sfp.fractions);\n\tret = (double)sfp.int_parts + ((double)sfp.fractions / USHRT_MAX);\n\treturn ret;\n}",
        "parsed_output": "\nstatic s_fixedpt_t\nntoh_sfp(s_fixedpt_t sfp)\n{\n\tsfp.int_parts = ntohs(sfp.int_parts);\n\tsfp.fractions = ntohs(sfp.fractions);\n\tsfp.d = (double)sfp.int_parts + (double)sfp.fractions / USHRT_MAX;\n\treturn sfp;\n}",
        "baseline_code_stripped": "double __fastcall sub_43B318(int a1)\n{\n  uint16_t v2; // [rsp+Ch] [rbp-14h]\n\n  v2 = ntohs(a1);\n  return (double)ntohs(HIWORD(a1)) / 65535.0 + (double)v2;\n}\n",
        "baseline_code_debug": "double __cdecl sfp_to_d(s_fixedpt_t sfp)\n{\n  uint16_t sfpa; // [rsp+Ch] [rbp-14h]\n\n  sfpa = ntohs(sfp.int_parts);\n  return (double)ntohs(sfp.fractions) / 65535.0 + (double)sfpa;\n}\n",
        "similarity_score_unixcoder": 0.9653112292289734,
        "similarity_score_baseline_stripped": 0.5352324843406677,
        "similarity_score_baseline_debug": 0.8530838489532471
    },
    {
        "func_name": "xclose",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0040A851 | 55 | push    rbp\n0x0040A852 | 48 89 E5 | mov     rbp, rsp\n0x0040A855 | 48 83 EC 10 | sub     rsp, 10h\n0x0040A859 | 89 7D FC | mov     [rbp+gid], edi\n0x0040A85C | 8B 45 FC | mov     eax, [rbp+gid]\n0x0040A85F | 89 C7 | mov     edi, eax; gid\n0x0040A861 | E8 0A CF FF FF | call    _setgid\n0x0040A866 | 85 C0 | test    eax, eax\n0x0040A868 | 74 0F | jz      short loc_40A879\n0x0040A86A | BF D4 80 52 00 | mov     edi, offset aSetgid_0; \"setgid\"\n0x0040A86F | B8 00 00 00 00 | mov     eax, 0\n0x0040A874 | E8 29 EA FF FF | call    sub_4092A2\n0x0040A879 | 90 | nop\n0x0040A87A | C9 | leave\n0x0040A87B | C3 | retn\n\n Ourput decompiled code:\nvoid FAST_FUNC xsetgid(gid_t gid)\n{\n\tif (setgid(gid)) bb_perror_msg_and_die(\"setgid\");\n}\n\n## Example:\n\n Input assembly code:\n0x0040A87C | 55 | push    rbp\n0x0040A87D | 48 89 E5 | mov     rbp, rsp\n0x0040A880 | 48 83 EC 10 | sub     rsp, 10h\n0x0040A884 | 89 7D FC | mov     [rbp+uid], edi\n0x0040A887 | 8B 45 FC | mov     eax, [rbp+uid]\n0x0040A88A | 89 C7 | mov     edi, eax; uid\n0x0040A88C | E8 CF D2 FF FF | call    _setuid\n0x0040A891 | 85 C0 | test    eax, eax\n0x0040A893 | 74 0F | jz      short loc_40A8A4\n0x0040A895 | BF DB 80 52 00 | mov     edi, offset aSetuid_0; \"setuid\"\n0x0040A89A | B8 00 00 00 00 | mov     eax, 0\n0x0040A89F | E8 FE E9 FF FF | call    sub_4092A2\n0x0040A8A4 | 90 | nop\n0x0040A8A5 | C9 | leave\n0x0040A8A6 | C3 | retn\n\n Ourput decompiled code:\nvoid FAST_FUNC xsetuid(uid_t uid)\n{\n\tif (setuid(uid)) bb_perror_msg_and_die(\"setuid\");\n}\n\n## Example:\n\n Input assembly code:\n0x004C6E96 | 55 | push    rbp\n0x004C6E97 | 48 89 E5 | mov     rbp, rsp\n0x004C6E9A | 48 83 EC 10 | sub     rsp, 10h\n0x004C6E9E | 89 7D FC | mov     [rbp+var_4], edi\n0x004C6EA1 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004C6EA4 | 83 E0 04 | and     eax, 4\n0x004C6EA7 | 85 C0 | test    eax, eax\n0x004C6EA9 | 74 0A | jz      short loc_4C6EB5\n0x004C6EAB | BF EC 6A 53 00 | mov     edi, offset aTzUtc0; \"TZ=UTC0\"\n0x004C6EB0 | E8 5B 01 F4 FF | call    _putenv\n0x004C6EB5 | 90 | nop\n0x004C6EB6 | C9 | leave\n0x004C6EB7 | C3 | retn\n\n Ourput decompiled code:\nstatic void maybe_set_utc(int opt)\n{\n\tif (opt & OPT_UTC)\n\t\tputenv((char*)\"TZ=UTC0\");\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0040A52C | 55 | push    rbp\n0x0040A52D | 48 89 E5 | mov     rbp, rsp\n0x0040A530 | 48 83 EC 10 | sub     rsp, 10h\n0x0040A534 | 89 7D FC | mov     [rbp+fd], edi\n0x0040A537 | 8B 45 FC | mov     eax, [rbp+fd]\n0x0040A53A | 89 C7 | mov     edi, eax; fd\n0x0040A53C | E8 CF C8 FF FF | call    _close\n0x0040A541 | 85 C0 | test    eax, eax\n0x0040A543 | 74 0F | jz      short loc_40A554\n0x0040A545 | BF 8C 80 52 00 | mov     edi, offset aCloseFailed; \"close failed\"\n0x0040A54A | B8 00 00 00 00 | mov     eax, 0\n0x0040A54F | E8 4E ED FF FF | call    sub_4092A2\n0x0040A554 | 90 | nop\n0x0040A555 | C9 | leave\n0x0040A556 | C3 | retn",
        "output": "\n\nvoid FAST_FUNC xclose(int fd)\n{\n\tif (close(fd)) bb_perror_msg_and_die(\"close failed\");\n}",
        "source_code": "void FAST_FUNC xclose(int fd)\n{\n\tif (close(fd))\n\t\tbb_perror_msg_and_die(\"close failed\");\n}",
        "parsed_output": "\n\nvoid FAST_FUNC xclose(int fd)\n{\n\tif (close(fd)) bb_perror_msg_and_die(\"close failed\");\n}",
        "baseline_code_stripped": "int __fastcall sub_40A52C(int a1, __int64 a2)\n{\n  int result; // eax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n\n  result = close(a1);\n  if ( result )\n    sub_4092A2((__int64)\"close failed\", a2, v3, v4, v5, v6);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl xclose(int fd)\n{\n  if ( close(fd) )\n    bb_perror_msg_and_die(\"close failed\");\n}\n",
        "similarity_score_unixcoder": 0.8845459818840027,
        "similarity_score_baseline_stripped": 0.5306940078735352,
        "similarity_score_baseline_debug": 0.9230630993843079
    },
    {
        "func_name": "dirname_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0047F17A | 55 | push    rbp\n0x0047F17B | 48 89 E5 | mov     rbp, rsp\n0x0047F17E | 48 83 EC 10 | sub     rsp, 10h\n0x0047F182 | 89 7D FC | mov     [rbp+var_4], edi\n0x0047F185 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x0047F189 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0047F18D | 48 89 C7 | mov     rdi, rax\n0x0047F190 | E8 7E CD 00 00 | call    sub_48BF13\n0x0047F195 | C9 | leave\n0x0047F196 | C3 | retn\n\n Ourput decompiled code:\nstatic int FAST_FUNC\nulimitcmd(int argc UNUSED_PARAM, char **argv)\n{\n\treturn shell_builtin_ulimit(argv);\n}\n\n## Example:\n\n Input assembly code:\n0x004D8AD5 | 55 | push    rbp\n0x004D8AD6 | 48 89 E5 | mov     rbp, rsp\n0x004D8AD9 | 48 83 EC 10 | sub     rsp, 10h\n0x004D8ADD | 89 7D FC | mov     [rbp+var_4], edi\n0x004D8AE0 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004D8AE4 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004D8AE8 | 48 83 C0 08 | add     rax, 8\n0x004D8AEC | 48 8B 00 | mov     rax, [rax]\n0x004D8AEF | 48 85 C0 | test    rax, rax\n0x004D8AF2 | 74 05 | jz      short loc_4D8AF9\n0x004D8AF4 | E8 6B F4 F2 FF | call    sub_407F64\n0x004D8AF9 | E8 62 E2 F2 FF | call    _geteuid\n0x004D8AFE | 89 C7 | mov     edi, eax\n0x004D8B00 | E8 6C D8 01 00 | call    sub_4F6371\n0x004D8B05 | 48 89 C7 | mov     rdi, rax; s\n0x004D8B08 | E8 03 DD F2 FF | call    _puts\n0x004D8B0D | E8 37 1B F3 FF | call    sub_40A649\n0x004D8B12 | C9 | leave\n0x004D8B13 | C3 | retn\n\n Ourput decompiled code:\nint whoami_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tif (argv[1])\n\t\tbb_show_usage();\n\n\t/* Will complain and die if username not found */\n\tputs(xuid2uname(geteuid()));\n\n\treturn fflush_all();\n}\n\n## Example:\n\n Input assembly code:\n0x0044629E | 55 | push    rbp\n0x0044629F | 48 89 E5 | mov     rbp, rsp\n0x004462A2 | 48 83 EC 10 | sub     rsp, 10h\n0x004462A6 | 89 7D FC | mov     [rbp+var_4], edi\n0x004462A9 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004462AD | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004462B1 | 48 89 C6 | mov     rsi, rax\n0x004462B4 | BF 00 00 00 00 | mov     edi, 0\n0x004462B9 | E8 F9 F2 FF FF | call    sub_4455B7\n0x004462BE | C9 | leave\n0x004462BF | C3 | retn\n\n Ourput decompiled code:\nint traceroute_main(int argc UNUSED_PARAM, char **argv)\n{\n\treturn common_traceroute_main(0, argv);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C8347 | 55 | push    rbp\n0x004C8348 | 48 89 E5 | mov     rbp, rsp\n0x004C834B | 48 83 EC 10 | sub     rsp, 10h\n0x004C834F | 89 7D FC | mov     [rbp+var_4], edi\n0x004C8352 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004C8356 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004C835A | 48 89 C7 | mov     rdi, rax\n0x004C835D | E8 97 02 04 00 | call    sub_5085F9\n0x004C8362 | 48 89 C7 | mov     rdi, rax; path\n0x004C8365 | E8 16 E9 F3 FF | call    _dirname\n0x004C836A | 48 89 C7 | mov     rdi, rax; s\n0x004C836D | E8 9E E4 F3 FF | call    _puts\n0x004C8372 | E8 D2 22 F4 FF | call    sub_40A649\n0x004C8377 | C9 | leave\n0x004C8378 | C3 | retn",
        "output": "\n\nint pwd_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tchar *path;\n\n\tpath = xrealpath(argv[1]);\n\tputs(dirname(path));\n\n\treturn fflush_all();\n}",
        "source_code": "int dirname_main(int argc UNUSED_PARAM, char **argv)\n{\n\tputs(dirname(single_argv(argv)));\n\treturn fflush_all();\n}",
        "parsed_output": "\n\nint pwd_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tchar *path;\n\n\tpath = xrealpath(argv[1]);\n\tputs(dirname(path));\n\n\treturn fflush_all();\n}",
        "baseline_code_stripped": "int __fastcall sub_4C8347(__int64 a1, __int64 a2)\n{\n  char *v2; // rax\n  char *v3; // rax\n\n  v2 = (char *)sub_5085F9(a2);\n  v3 = dirname(v2);\n  puts(v3);\n  return sub_40A649();\n}\n",
        "baseline_code_debug": "int __cdecl dirname_main(int argc, char **argv)\n{\n  char *v2; // rax\n  char *v3; // rax\n\n  v2 = single_argv(argv);\n  v3 = dirname(v2);\n  puts(v3);\n  return fflush_all();\n}\n",
        "similarity_score_unixcoder": 0.8420486450195312,
        "similarity_score_baseline_stripped": 0.5534166693687439,
        "similarity_score_baseline_debug": 0.801508903503418
    },
    {
        "func_name": "is_nip_reserved",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00503608 | 55 | push    rbp\n0x00503609 | 48 89 E5 | mov     rbp, rsp\n0x0050360C | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00503610 | 89 75 F4 | mov     [rbp+var_C], esi\n0x00503613 | EB 01 | jmp     short loc_503616\n0x00503615 | 90 | nop\n0x00503616 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0050361A | 48 8D 50 01 | lea     rdx, [rax+1]\n0x0050361E | 48 89 55 F8 | mov     [rbp+var_8], rdx\n0x00503622 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00503625 | 3C 20 | cmp     al, 20h ; ' '\n0x00503627 | 75 EC | jnz     short loc_503615\n0x00503629 | 83 6D F4 01 | sub     [rbp+var_C], 1\n0x0050362D | 83 7D F4 00 | cmp     [rbp+var_C], 0\n0x00503631 | 75 E3 | jnz     short loc_503616\n0x00503633 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00503637 | 5D | pop     rbp\n0x00503638 | C3 | retn\n\n Ourput decompiled code:\nendif\n\nstatic char *skip_fields(char *str, int count)\n{\n\tdo {\n\t\twhile (*str++ != ' ')\n\t\t\tcontinue;\n\t\t/* we found a space char, str points after it */\n\t} while (--count);\n\treturn str;\n}\n\n## Example:\n\n Input assembly code:\n0x0046EDFC | 55 | push    rbp\n0x0046EDFD | 48 89 E5 | mov     rbp, rsp\n0x0046EE00 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0046EE04 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x0046EE08 | EB 29 | jmp     short loc_46EE33\n0x0046EE0A | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0046EE0E | 48 8D 50 01 | lea     rdx, [rax+1]\n0x0046EE12 | 48 89 55 F0 | mov     [rbp+var_10], rdx\n0x0046EE16 | 0F B6 08 | movzx   ecx, byte ptr [rax]\n0x0046EE19 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0046EE1D | 48 8D 50 01 | lea     rdx, [rax+1]\n0x0046EE21 | 48 89 55 F8 | mov     [rbp+var_8], rdx\n0x0046EE25 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0046EE28 | 38 C1 | cmp     cl, al\n0x0046EE2A | 74 07 | jz      short loc_46EE33\n0x0046EE2C | B8 00 00 00 00 | mov     eax, 0\n0x0046EE31 | EB 0F | jmp     short loc_46EE42\n0x0046EE33 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0046EE37 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0046EE3A | 84 C0 | test    al, al\n0x0046EE3C | 75 CC | jnz     short loc_46EE0A\n0x0046EE3E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0046EE42 | 5D | pop     rbp\n0x0046EE43 | C3 | retn\n\n Ourput decompiled code:\nstatic char *\nprefix(const char *string, const char *pfx)\n{\n\twhile (*pfx) {\n\t\tif (*pfx++ != *string++)\n\t\t\treturn NULL;\n\t}\n\treturn (char *) string;\n}\n\n## Example:\n\n Input assembly code:\n0x00459CD1 | 55 | push    rbp\n0x00459CD2 | 48 89 E5 | mov     rbp, rsp\n0x00459CD5 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00459CD9 | 89 F0 | mov     eax, esi\n0x00459CDB | 88 45 F4 | mov     [rbp+var_C], al\n0x00459CDE | EB 0C | jmp     short loc_459CEC\n0x00459CE0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00459CE4 | 48 8B 40 08 | mov     rax, [rax+8]\n0x00459CE8 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00459CEC | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00459CF1 | 74 0F | jz      short loc_459D02\n0x00459CF3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00459CF7 | 48 8B 00 | mov     rax, [rax]\n0x00459CFA | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00459CFD | 38 45 F4 | cmp     [rbp+var_C], al\n0x00459D00 | 77 DE | ja      short loc_459CE0\n0x00459D02 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00459D07 | 74 15 | jz      short loc_459D1E\n0x00459D09 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00459D0D | 48 8B 00 | mov     rax, [rax]\n0x00459D10 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00459D13 | 38 45 F4 | cmp     [rbp+var_C], al\n0x00459D16 | 75 06 | jnz     short loc_459D1E\n0x00459D18 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00459D1C | EB 05 | jmp     short loc_459D23\n0x00459D1E | B8 00 00 00 00 | mov     eax, 0\n0x00459D23 | 5D | pop     rbp\n0x00459D24 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC udhcp_find_option(struct option_set *opt_list, uint8_t code)\n{\n\twhile (opt_list && opt_list->data[OPT_CODE] < code)\n\t\topt_list = opt_list->next;\n\n\tif (opt_list && opt_list->data[OPT_CODE] == code)\n\t\treturn opt_list;\n\treturn NULL;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00459481 | 55 | push    rbp\n0x00459482 | 48 89 E5 | mov     rbp, rsp\n0x00459485 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00459489 | 89 75 F4 | mov     [rbp+var_C], esi\n0x0045948C | EB 1E | jmp     short loc_4594AC\n0x0045948E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00459492 | 8B 40 08 | mov     eax, [rax+8]\n0x00459495 | 39 45 F4 | cmp     [rbp+var_C], eax\n0x00459498 | 75 07 | jnz     short loc_4594A1\n0x0045949A | B8 01 00 00 00 | mov     eax, 1\n0x0045949F | EB 17 | jmp     short loc_4594B8\n0x004594A1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004594A5 | 48 8B 00 | mov     rax, [rax]\n0x004594A8 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004594AC | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004594B1 | 75 DB | jnz     short loc_45948E\n0x004594B3 | B8 00 00 00 00 | mov     eax, 0\n0x004594B8 | 5D | pop     rbp\n0x004594B9 | C3 | retn",
        "output": "\n\nstatic int\nudhcp_find_opt(struct option_set *opt_list, uint8_t code)\n{\n\twhile (opt_list) {\n\t\tif (opt_list->data[OPT_CODE] == code)\n\t\t\treturn 1;\n\t\topt_list = opt_list->next;\n\t}\n\treturn 0;\n}",
        "source_code": "int FAST_FUNC is_nip_reserved(struct static_lease *st_lease, uint32_t nip)\n{\n\twhile (st_lease) {\n\t\tif (st_lease->nip == nip)\n\t\t\treturn 1;\n\t\tst_lease = st_lease->next;\n\t}\n\n\treturn 0;\n}",
        "parsed_output": "\n\nstatic int\nudhcp_find_opt(struct option_set *opt_list, uint8_t code)\n{\n\twhile (opt_list) {\n\t\tif (opt_list->data[OPT_CODE] == code)\n\t\t\treturn 1;\n\t\topt_list = opt_list->next;\n\t}\n\treturn 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_459481(__int64 *a1, int a2)\n{\n  while ( a1 )\n  {\n    if ( a2 == *((_DWORD *)a1 + 2) )\n      return 1LL;\n    a1 = (__int64 *)*a1;\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl is_nip_reserved(static_lease *st_lease, uint32_t nip)\n{\n  while ( st_lease )\n  {\n    if ( nip == st_lease->nip )\n      return 1;\n    st_lease = st_lease->next;\n  }\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.49343085289001465,
        "similarity_score_baseline_stripped": 0.4304907023906708,
        "similarity_score_baseline_debug": 0.9490572214126587
    },
    {
        "func_name": "setvar_p",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0048B66A | 55 | push    rbp\n0x0048B66B | 48 89 E5 | mov     rbp, rsp\n0x0048B66E | 48 83 EC 10 | sub     rsp, 10h\n0x0048B672 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0048B676 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x0048B67A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B67E | 48 C7 00 00 00 00 00 | mov     qword ptr [rax], 0\n0x0048B685 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B689 | 48 C7 40 18 00 00 00 00 | mov     qword ptr [rax+18h], 0\n0x0048B691 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x0048B695 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B699 | 48 89 D6 | mov     rsi, rdx\n0x0048B69C | 48 89 C7 | mov     rdi, rax\n0x0048B69F | E8 F3 FA FF FF | call    sub_48B197\n0x0048B6A4 | C9 | leave\n0x0048B6A5 | C3 | retn\n\n Ourput decompiled code:\narith_t FAST_FUNC\narith(arith_state_t *math_state, const char *expr)\n{\n\tmath_state->errmsg = NULL;\n\tmath_state->list_of_recursed_names = NULL;\n\treturn evaluate_string(math_state, expr);\n}\n\n## Example:\n\n Input assembly code:\n0x0046ED88 | 55 | push    rbp\n0x0046ED89 | 48 89 E5 | mov     rbp, rsp\n0x0046ED8C | 48 83 EC 10 | sub     rsp, 10h\n0x0046ED90 | 48 89 7D F8 | mov     [rbp+s], rdi\n0x0046ED94 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x0046ED98 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x0046ED9C | 48 89 C7 | mov     rdi, rax; s\n0x0046ED9F | E8 2C 7D F9 FF | call    _strlen\n0x0046EDA4 | 48 89 C1 | mov     rcx, rax\n0x0046EDA7 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x0046EDAB | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x0046EDAF | 48 89 CE | mov     rsi, rcx\n0x0046EDB2 | 48 89 C7 | mov     rdi, rax\n0x0046EDB5 | E8 78 FF FF FF | call    sub_46ED32\n0x0046EDBA | C9 | leave\n0x0046EDBB | C3 | retn\n\n Ourput decompiled code:\nstatic char *\nstack_putstr(const char *s, char *p)\n{\n\treturn stack_nputstr(s, strlen(s), p);\n}\n\n## Example:\n\n Input assembly code:\n0x004C92AB | 55 | push    rbp\n0x004C92AC | 48 89 E5 | mov     rbp, rsp\n0x004C92AF | 48 83 EC 20 | sub     rsp, 20h\n0x004C92B3 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004C92B7 | BF 10 00 00 00 | mov     edi, 10h\n0x004C92BC | E8 27 0E F4 FF | call    sub_40A0E8\n0x004C92C1 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004C92C5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C92C9 | 48 8B 55 E8 | mov     rdx, [rbp+var_18]\n0x004C92CD | 48 89 50 08 | mov     [rax+8], rdx\n0x004C92D1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004C92D5 | C9 | leave\n0x004C92D6 | C3 | retn\n\n Ourput decompiled code:\nstatic VALUE *int_value(arith_t i)\n{\n\tVALUE *v;\n\n\tv = xzalloc(sizeof(VALUE));\n\tif (INTEGER) /* otherwise xzaaloc did it already */\n\t\tv->type = INTEGER;\n\tv->u.i = i;\n\treturn v;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004DC8ED | 55 | push    rbp\n0x004DC8EE | 48 89 E5 | mov     rbp, rsp\n0x004DC8F1 | 48 83 EC 10 | sub     rsp, 10h\n0x004DC8F5 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004DC8F9 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004DC8FD | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004DC901 | 48 89 C7 | mov     rdi, rax\n0x004DC904 | E8 83 FF FF FF | call    sub_4DC88C\n0x004DC909 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004DC90D | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x004DC911 | 48 89 50 10 | mov     [rax+10h], rdx\n0x004DC915 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004DC919 | 48 89 C7 | mov     rdi, rax\n0x004DC91C | E8 EA 26 00 00 | call    sub_4DF00B\n0x004DC921 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004DC925 | C9 | leave\n0x004DC926 | C3 | retn",
        "output": "\n\nstatic VALUE *float_value(double d, char *s)\n{\n\tVALUE *v;\n\n\tv = xzalloc(sizeof(VALUE));\n\tif (FLOAT) /* otherwise xzaaloc did it already */\n\t\tv->type = FLOAT;\n\tv->u.d = d;\n\tv->s = s;\n\tstack_push(v);\n\treturn v;\n}",
        "source_code": "static var *setvar_p(var *v, char *value)\n{\n\tclrvar(v);\n\tv->string = value;\n\thandle_special(v);\n\treturn v;\n}",
        "parsed_output": "\n\nstatic VALUE *float_value(double d, char *s)\n{\n\tVALUE *v;\n\n\tv = xzalloc(sizeof(VALUE));\n\tif (FLOAT) /* otherwise xzaaloc did it already */\n\t\tv->type = FLOAT;\n\tv->u.d = d;\n\tv->s = s;\n\tstack_push(v);\n\treturn v;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4DC8ED(__int64 a1, __int64 a2)\n{\n  sub_4DC88C((int *)a1);\n  *(_QWORD *)(a1 + 16) = a2;\n  sub_4DF00B(a1);\n  return a1;\n}\n",
        "baseline_code_debug": "var_0 *__cdecl setvar_p(var_0 *v, char *value)\n{\n  clrvar(v);\n  v->string = value;\n  handle_special(v);\n  return v;\n}\n",
        "similarity_score_unixcoder": 0.5395974516868591,
        "similarity_score_baseline_stripped": 0.3281662166118622,
        "similarity_score_baseline_debug": 0.9088380336761475
    },
    {
        "func_name": "bufsum",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004F7534 | 55 | push    rbp\n0x004F7535 | 48 89 E5 | mov     rbp, rsp\n0x004F7538 | 89 7D EC | mov     [rbp+var_14], edi\n0x004F753B | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004F753F | 89 55 E8 | mov     [rbp+var_18], edx\n0x004F7542 | 48 89 4D D8 | mov     [rbp+var_28], rcx\n0x004F7546 | 8B 55 E8 | mov     edx, [rbp+var_18]\n0x004F7549 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004F754D | 48 01 D0 | add     rax, rdx\n0x004F7550 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004F7554 | EB 32 | jmp     short loc_4F7588\n0x004F7556 | 8B 45 EC | mov     eax, [rbp+var_14]\n0x004F7559 | 89 C2 | mov     edx, eax\n0x004F755B | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004F755F | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004F7562 | 31 D0 | xor     eax, edx\n0x004F7564 | 0F B6 C0 | movzx   eax, al\n0x004F7567 | 48 8D 14 85 00 00 00 00 | lea     rdx, ds:0[rax*4]\n0x004F756F | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004F7573 | 48 01 D0 | add     rax, rdx\n0x004F7576 | 8B 00 | mov     eax, [rax]\n0x004F7578 | 8B 55 EC | mov     edx, [rbp+var_14]\n0x004F757B | C1 EA 08 | shr     edx, 8\n0x004F757E | 31 D0 | xor     eax, edx\n0x004F7580 | 89 45 EC | mov     [rbp+var_14], eax\n0x004F7583 | 48 83 45 E0 01 | add     [rbp+var_20], 1\n0x004F7588 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004F758C | 48 3B 45 F8 | cmp     rax, [rbp+var_8]\n0x004F7590 | 75 C4 | jnz     short loc_4F7556\n0x004F7592 | 8B 45 EC | mov     eax, [rbp+var_14]\n0x004F7595 | 5D | pop     rbp\n0x004F7596 | C3 | retn\n\n Ourput decompiled code:\nuint32_t FAST_FUNC crc32_block_endian0(uint32_t val, const void *buf, unsigned len, uint32_t *crc_table)\n{\n\tconst void *end = (uint8_t*)buf + len;\n\n\twhile (buf != end) {\n\t\tval = crc_table[(uint8_t)val ^ *(uint8_t*)buf] ^ (val >> 8);\n\t\tbuf = (uint8_t*)buf + 1;\n\t}\n\treturn val;\n}\n\n## Example:\n\n Input assembly code:\n0x00456E02 | 55 | push    rbp\n0x00456E03 | 48 89 E5 | mov     rbp, rsp\n0x00456E06 | 53 | push    rbx\n0x00456E07 | 48 83 EC 38 | sub     rsp, 38h\n0x00456E0B | 48 89 7D D8 | mov     [rbp+var_28], rdi\n0x00456E0F | 89 75 D4 | mov     [rbp+var_2C], esi\n0x00456E12 | 48 89 55 C8 | mov     [rbp+var_38], rdx\n0x00456E16 | C7 45 E8 00 00 00 00 | mov     [rbp+var_18], 0\n0x00456E1D | C7 45 EC 00 00 00 00 | mov     [rbp+var_14], 0\n0x00456E24 | EB 74 | jmp     short loc_456E9A\n0x00456E26 | 8B 45 EC | mov     eax, [rbp+var_14]\n0x00456E29 | 48 98 | cdqe\n0x00456E2B | 48 8D 14 C5 00 00 00 00 | lea     rdx, ds:0[rax*8]\n0x00456E33 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00456E37 | 48 01 D0 | add     rax, rdx\n0x00456E3A | 48 8B 00 | mov     rax, [rax]\n0x00456E3D | 8B 55 EC | mov     edx, [rbp+var_14]\n0x00456E40 | 48 63 D2 | movsxd  rdx, edx\n0x00456E43 | 48 8D 0C 95 00 00 00 00 | lea     rcx, ds:0[rdx*4]\n0x00456E4B | 48 8B 55 C8 | mov     rdx, [rbp+var_38]\n0x00456E4F | 48 8D 1C 11 | lea     rbx, [rcx+rdx]\n0x00456E53 | 48 89 C6 | mov     rsi, rax\n0x00456E56 | BF 43 00 00 00 | mov     edi, 43h ; 'C'\n0x00456E5B | E8 59 24 00 00 | call    sub_4592B9\n0x00456E60 | 89 03 | mov     [rbx], eax\n0x00456E62 | 8B 45 EC | mov     eax, [rbp+var_14]\n0x00456E65 | 48 98 | cdqe\n0x00456E67 | 48 8D 14 85 00 00 00 00 | lea     rdx, ds:0[rax*4]\n0x00456E6F | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x00456E73 | 48 01 D0 | add     rax, rdx\n0x00456E76 | 8B 00 | mov     eax, [rax]\n0x00456E78 | 39 45 E8 | cmp     [rbp+var_18], eax\n0x00456E7B | 7D 19 | jge     short loc_456E96\n0x00456E7D | 8B 45 EC | mov     eax, [rbp+var_14]\n0x00456E80 | 48 98 | cdqe\n0x00456E82 | 48 8D 14 85 00 00 00 00 | lea     rdx, ds:0[rax*4]\n0x00456E8A | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x00456E8E | 48 01 D0 | add     rax, rdx\n0x00456E91 | 8B 00 | mov     eax, [rax]\n0x00456E93 | 89 45 E8 | mov     [rbp+var_18], eax\n0x00456E96 | 83 45 EC 01 | add     [rbp+var_14], 1\n0x00456E9A | 8B 45 EC | mov     eax, [rbp+var_14]\n0x00456E9D | 3B 45 D4 | cmp     eax, [rbp+var_2C]\n0x00456EA0 | 7C 84 | jl      short loc_456E26\n0x00456EA2 | 8B 45 E8 | mov     eax, [rbp+var_18]\n0x00456EA5 | 48 83 C4 38 | add     rsp, 38h\n0x00456EA9 | 5B | pop     rbx\n0x00456EAA | 5D | pop     rbp\n0x00456EAB | C3 | retn\n\n Ourput decompiled code:\nstatic int init_sockets(char **iface_list, int num_clients, int *fds)\n{\n\tint i, n;\n\n\tn = 0;\n\tfor (i = 0; i < num_clients; i++) {\n\t\tfds[i] = udhcp_listen_socket(/*INADDR_ANY,*/ SERVER_PORT, iface_list[i]);\n\t\tif (n < fds[i])\n\t\t\tn = fds[i];\n\t}\n\treturn n;\n}\n\n## Example:\n\n Input assembly code:\n0x0043FF9E | 55 | push    rbp\n0x0043FF9F | 48 89 E5 | mov     rbp, rsp\n0x0043FFA2 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0043FFA6 | 89 75 E4 | mov     [rbp+var_1C], esi\n0x0043FFA9 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043FFAD | 48 8D 50 01 | lea     rdx, [rax+1]\n0x0043FFB1 | 48 89 55 E8 | mov     [rbp+var_18], rdx\n0x0043FFB5 | C6 00 55 | mov     byte ptr [rax], 55h ; 'U'\n0x0043FFB8 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x0043FFBF | EB 1E | jmp     short loc_43FFDF\n0x0043FFC1 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0043FFC4 | 48 98 | cdqe\n0x0043FFC6 | 8B 14 85 A0 A4 51 00 | mov     edx, ds:dword_51A4A0[rax*4]\n0x0043FFCD | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x0043FFD0 | 21 D0 | and     eax, edx\n0x0043FFD2 | 85 C0 | test    eax, eax\n0x0043FFD4 | 74 05 | jz      short loc_43FFDB\n0x0043FFD6 | 48 83 45 E8 01 | add     [rbp+var_18], 1\n0x0043FFDB | 83 45 FC 01 | add     [rbp+var_4], 1\n0x0043FFDF | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0043FFE2 | 48 98 | cdqe\n0x0043FFE4 | 0F B6 90 C0 A4 51 00 | movzx   edx, ds:byte_51A4C0[rax]\n0x0043FFEB | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043FFEF | 88 10 | mov     [rax], dl\n0x0043FFF1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043FFF5 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0043FFF8 | 84 C0 | test    al, al\n0x0043FFFA | 75 C5 | jnz     short loc_43FFC1\n0x0043FFFC | 90 | nop\n0x0043FFFD | 5D | pop     rbp\n0x0043FFFE | C3 | retn\n\n Ourput decompiled code:\nstatic void set_flags(char *flagstr, int flags)\n{\n\tint i;\n\n\t*flagstr++ = 'U';\n\n\tfor (i = 0; (*flagstr = flagchars[i]) != 0; i++) {\n\t\tif (flags & flagvals[i]) {\n\t\t\t++flagstr;\n\t\t}\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004EFD23 | 55 | push    rbp\n0x004EFD24 | 48 89 E5 | mov     rbp, rsp\n0x004EFD27 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004EFD2B | 89 75 E4 | mov     [rbp+var_1C], esi\n0x004EFD2E | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x004EFD35 | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x004EFD38 | 48 63 D0 | movsxd  rdx, eax\n0x004EFD3B | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004EFD3F | 48 01 D0 | add     rax, rdx\n0x004EFD42 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x004EFD46 | EB 15 | jmp     short loc_4EFD5D\n0x004EFD48 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004EFD4C | 48 8D 50 01 | lea     rdx, [rax+1]\n0x004EFD50 | 48 89 55 E8 | mov     [rbp+var_18], rdx\n0x004EFD54 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004EFD57 | 0F B6 C0 | movzx   eax, al\n0x004EFD5A | 01 45 FC | add     [rbp+var_4], eax\n0x004EFD5D | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004EFD61 | 48 3B 45 F0 | cmp     rax, [rbp+var_10]\n0x004EFD65 | 72 E1 | jb      short loc_4EFD48\n0x004EFD67 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004EFD6A | 5D | pop     rbp\n0x004EFD6B | C3 | retn",
        "output": "\n\nstatic int get_flags(char *flagstr, int flags)\n{\n\tint i;\n\n\tfor (i = 0; flagstr[i] != 0; i++) {\n\t\tflags += flagvals[flagchars[i]];\n\t}\n\treturn flags;\n}",
        "source_code": "static int bufsum(char *buf, int count)\n{\n\tint sum = 0;\n\tchar *e = buf + count;\n\n\twhile (buf < e)\n\t\tsum += (unsigned char) *buf++;\n\treturn sum;\n}",
        "parsed_output": "\n\nstatic int get_flags(char *flagstr, int flags)\n{\n\tint i;\n\n\tfor (i = 0; flagstr[i] != 0; i++) {\n\t\tflags += flagvals[flagchars[i]];\n\t}\n\treturn flags;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4EFD23(unsigned __int64 a1, int a2)\n{\n  unsigned __int8 *v2; // rax\n  unsigned __int64 v4; // [rsp+4h] [rbp-18h]\n  unsigned int v5; // [rsp+18h] [rbp-4h]\n\n  v4 = a1;\n  v5 = 0;\n  while ( v4 < a2 + a1 )\n  {\n    v2 = (unsigned __int8 *)v4++;\n    v5 += *v2;\n  }\n  return v5;\n}\n",
        "baseline_code_debug": "int __cdecl bufsum(char *buf, int count)\n{\n  char *v2; // rax\n  char *bufa; // [rsp+4h] [rbp-18h]\n  int sum; // [rsp+18h] [rbp-4h]\n\n  bufa = buf;\n  sum = 0;\n  while ( bufa < &buf[count] )\n  {\n    v2 = bufa++;\n    sum += (unsigned __int8)*v2;\n  }\n  return sum;\n}\n",
        "similarity_score_unixcoder": 0.6017571687698364,
        "similarity_score_baseline_stripped": 0.5471217632293701,
        "similarity_score_baseline_debug": 0.7934107780456543
    },
    {
        "func_name": "interrupted",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004A181C | 55 | push    rbp\n0x004A181D | 48 89 E5 | mov     rbp, rsp\n0x004A1820 | 48 83 EC 10 | sub     rsp, 10h\n0x004A1824 | 89 7D FC | mov     [rbp+var_4], edi\n0x004A1827 | BF 0A 00 00 00 | mov     edi, 0Ah\n0x004A182C | E8 58 85 F6 FF | call    sub_409D89\n0x004A1831 | BA FC B3 75 00 | mov     edx, offset dest.c_oflag; termios_p\n0x004A1836 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004A183B | 8B 00 | mov     eax, [rax]\n0x004A183D | BE 00 00 00 00 | mov     esi, 0; optional_actions\n0x004A1842 | 89 C7 | mov     edi, eax; fd\n0x004A1844 | E8 87 5F F6 FF | call    _tcsetattr\n0x004A1849 | BF 01 00 00 00 | mov     edi, 1; status\n0x004A184E | E8 6D 4F F6 FF | call    __exit\n\n Ourput decompiled code:\nstatic void gotsig(int sig UNUSED_PARAM)\n{\n\t/* bb_putchar_stderr doesn't use stdio buffering,\n\t * therefore it is safe in signal handler */\n\tbb_putchar_stderr('\\n');\n\tsetTermSettings(cin_fileno, &initial_settings);\n\t_exit(EXIT_FAILURE);\n}\n\n## Example:\n\n Input assembly code:\n0x004C4692 | 55 | push    rbp\n0x004C4693 | 48 89 E5 | mov     rbp, rsp\n0x004C4696 | 48 83 EC 10 | sub     rsp, 10h\n0x004C469A | 89 7D FC | mov     [rbp+var_4], edi\n0x004C469D | BA F8 B3 75 00 | mov     edx, offset dest; termios_p\n0x004C46A2 | BE 00 00 00 00 | mov     esi, 0; optional_actions\n0x004C46A7 | BF 02 00 00 00 | mov     edi, 2; fd\n0x004C46AC | E8 1F 31 F4 FF | call    _tcsetattr\n0x004C46B1 | BF 01 00 00 00 | mov     edi, 1; status\n0x004C46B6 | E8 05 21 F4 FF | call    __exit\n\n Ourput decompiled code:\nstatic void\nonintr(int sig UNUSED_PARAM)\n{\n\ttcsetattr(STDERR_FILENO, TCSANOW, old_termios_p);\n\t_exit(EXIT_FAILURE);\n}\n\n## Example:\n\n Input assembly code:\n0x004EF4E0 | 55 | push    rbp\n0x004EF4E1 | 48 89 E5 | mov     rbp, rsp\n0x004EF4E4 | 48 83 EC 10 | sub     rsp, 10h\n0x004EF4E8 | 89 7D FC | mov     [rbp+val], edi\n0x004EF4EB | BE E0 F4 4E 00 | mov     esi, offset sub_4EF4E0; handler\n0x004EF4F0 | BF 02 00 00 00 | mov     edi, 2; sig\n0x004EF4F5 | E8 76 7B F1 FF | call    _signal\n0x004EF4FA | 48 8B 05 07 DF 26 00 | mov     rax, cs:qword_75D408\n0x004EF501 | 48 8D 90 88 02 00 00 | lea     rdx, [rax+288h]\n0x004EF508 | 8B 45 FC | mov     eax, [rbp+val]\n0x004EF50B | 89 C6 | mov     esi, eax; val\n0x004EF50D | 48 89 D7 | mov     rdi, rdx; env\n0x004EF510 | E8 3B 77 F1 FF | call    _siglongjmp\n\n Ourput decompiled code:\nstatic void catch_sig(int sig)\n{\n\tsignal(SIGINT, catch_sig);\n\tsiglongjmp(restart, sig);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0048C5A7 | 55 | push    rbp\n0x0048C5A8 | 48 89 E5 | mov     rbp, rsp\n0x0048C5AB | 48 83 EC 10 | sub     rsp, 10h\n0x0048C5AF | 89 7D FC | mov     [rbp+var_4], edi\n0x0048C5B2 | BE 01 00 00 00 | mov     esi, 1; handler\n0x0048C5B7 | BF 02 00 00 00 | mov     edi, 2; sig\n0x0048C5BC | E8 AF AA F7 FF | call    _signal\n0x0048C5C1 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0048C5C6 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x0048C5CA | 48 89 C7 | mov     rdi, rax; shmaddr\n0x0048C5CD | E8 3E A3 F7 FF | call    _shmdt\n0x0048C5D2 | BF 00 00 00 00 | mov     edi, 0; status\n0x0048C5D7 | E8 E4 B4 F7 FF | call    _exit",
        "output": "\n\nstatic void\nonintr(int sig UNUSED_PARAM)\n{\n\tsignal(SIGINT, onintr);\n\tshmdt(*(void **)dest);\n\texit(0);\n}",
        "source_code": "static void interrupted(int sig UNUSED_PARAM)\n{\n\tsignal(SIGINT, SIG_IGN);\n\tshmdt(shbuf);\n\texit(EXIT_SUCCESS);\n}",
        "parsed_output": "\n\nstatic void\nonintr(int sig UNUSED_PARAM)\n{\n\tsignal(SIGINT, onintr);\n\tshmdt(*(void **)dest);\n\texit(0);\n}",
        "baseline_code_stripped": "void __noreturn sub_48C5A7()\n{\n  signal(2, (__sighandler_t)1);\n  shmdt(*(const void **)&dest.c_cc[7]);\n  exit(0);\n}\n",
        "baseline_code_debug": "void __cdecl __noreturn interrupted(int sig)\n{\n  signal(2, (__sighandler_t)1);\n  shmdt(*(const void **)&bb_common_bufsiz1.c_cc[7]);\n  exit(0);\n}\n",
        "similarity_score_unixcoder": 0.8518779873847961,
        "similarity_score_baseline_stripped": 0.6504632830619812,
        "similarity_score_baseline_debug": 0.6600350737571716
    },
    {
        "func_name": "outcslow",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00490876 | 55 | push    rbp\n0x00490877 | 48 89 E5 | mov     rbp, rsp\n0x0049087A | 48 83 EC 10 | sub     rsp, 10h\n0x0049087E | 89 7D FC | mov     [rbp+var_4], edi\n0x00490881 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x00490885 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00490888 | 89 C7 | mov     edi, eax\n0x0049088A | E8 26 FD FF FF | call    sub_4905B5\n0x0049088F | 48 8B 05 72 CB 2C 00 | mov     rax, cs:qword_75D408\n0x00490896 | 8B 40 18 | mov     eax, [rax+18h]\n0x00490899 | 89 C2 | mov     edx, eax\n0x0049089B | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0049089F | 48 89 C6 | mov     rsi, rax\n0x004908A2 | BF 03 00 00 00 | mov     edi, 3\n0x004908A7 | E8 FF 9B F7 FF | call    sub_40A4AB\n0x004908AC | 90 | nop\n0x004908AD | C9 | leave\n0x004908AE | C3 | retn\n\n Ourput decompiled code:\nstatic void\nwrite_sector(sector_t secno, const void *buf)\n{\n\tseek_sector(secno);\n\txwrite(dev_fd, buf, sector_size);\n}\n\n## Example:\n\n Input assembly code:\n0x0046E097 | 55 | push    rbp\n0x0046E098 | 48 89 E5 | mov     rbp, rsp\n0x0046E09B | 48 83 EC 10 | sub     rsp, 10h\n0x0046E09F | 48 89 7D F8 | mov     [rbp+s], rdi\n0x0046E0A3 | 48 89 75 F0 | mov     [rbp+stream], rsi\n0x0046E0A7 | 48 8B 05 6A F3 2E 00 | mov     rax, cs:qword_75D418\n0x0046E0AE | 8B 50 30 | mov     edx, [rax+30h]\n0x0046E0B1 | 83 C2 01 | add     edx, 1\n0x0046E0B4 | 89 50 30 | mov     [rax+30h], edx\n0x0046E0B7 | 48 8B 55 F0 | mov     rdx, [rbp+stream]\n0x0046E0BB | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x0046E0BF | 48 89 D6 | mov     rsi, rdx; stream\n0x0046E0C2 | 48 89 C7 | mov     rdi, rax; s\n0x0046E0C5 | E8 F6 8E F9 FF | call    _fputs_unlocked\n0x0046E0CA | E8 70 FF FF FF | call    sub_46E03F\n0x0046E0CF | 90 | nop\n0x0046E0D0 | C9 | leave\n0x0046E0D1 | C3 | retn\n\n Ourput decompiled code:\nstatic void\noutstr(const char *p, FILE *file)\n{\n\tINT_OFF;\n\tfputs(p, file);\n\tINT_ON;\n}\n\n## Example:\n\n Input assembly code:\n0x004B2734 | 55 | push    rbp\n0x004B2735 | 48 89 E5 | mov     rbp, rsp\n0x004B2738 | 48 83 EC 10 | sub     rsp, 10h\n0x004B273C | 89 7D FC | mov     [rbp+var_4], edi\n0x004B273F | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x004B2743 | 89 55 F8 | mov     [rbp+var_8], edx\n0x004B2746 | 48 8B 0D EB AC 2A 00 | mov     rcx, cs:qword_75D438\n0x004B274D | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004B2750 | F7 D0 | not     eax\n0x004B2752 | 89 C7 | mov     edi, eax\n0x004B2754 | 8B 55 F8 | mov     edx, [rbp+var_8]\n0x004B2757 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004B275B | 48 89 C6 | mov     rsi, rax\n0x004B275E | E8 D1 4D 04 00 | call    sub_4F7534\n0x004B2763 | F7 D0 | not     eax\n0x004B2765 | C9 | leave\n0x004B2766 | C3 | retn\n\n Ourput decompiled code:\nstatic FAST_FUNC uint32_t\nlzo_crc32(uint32_t c, const uint8_t* buf, unsigned len)\n{\n\t//if (buf == NULL) - impossible\n\t//\treturn 0;\n\n\treturn ~crc32_block_endian0(~c, buf, len, global_crc32_table);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0046E0F3 | 55 | push    rbp\n0x0046E0F4 | 48 89 E5 | mov     rbp, rsp\n0x0046E0F7 | 48 83 EC 10 | sub     rsp, 10h\n0x0046E0FB | 89 7D FC | mov     [rbp+c], edi\n0x0046E0FE | 48 89 75 F0 | mov     [rbp+stream], rsi\n0x0046E102 | 48 8B 05 0F F3 2E 00 | mov     rax, cs:qword_75D418\n0x0046E109 | 8B 50 30 | mov     edx, [rax+30h]\n0x0046E10C | 83 C2 01 | add     edx, 1\n0x0046E10F | 89 50 30 | mov     [rax+30h], edx\n0x0046E112 | 48 8B 55 F0 | mov     rdx, [rbp+stream]\n0x0046E116 | 8B 45 FC | mov     eax, [rbp+c]\n0x0046E119 | 48 89 D6 | mov     rsi, rdx; stream\n0x0046E11C | 89 C7 | mov     edi, eax; c\n0x0046E11E | E8 0D 92 F9 FF | call    _putc_unlocked\n0x0046E123 | 48 8B 45 F0 | mov     rax, [rbp+stream]\n0x0046E127 | 48 89 C7 | mov     rdi, rax; stream\n0x0046E12A | E8 51 92 F9 FF | call    _fflush\n0x0046E12F | E8 0B FF FF FF | call    sub_46E03F\n0x0046E134 | 90 | nop\n0x0046E135 | C9 | leave\n0x0046E136 | C3 | retn",
        "output": "\n\nstatic void\noutch(int c, FILE *file)\n{\n\tINT_OFF;\n\tputc_unlocked(c, file);\n\tfflush(file);\n\tINT_ON;\n}",
        "source_code": "static void\noutcslow(int c, FILE *dest)\n{\n\tINT_OFF;\n\tputc(c, dest);\n\tfflush(dest);\n\tINT_ON;\n}",
        "parsed_output": "\n\nstatic void\noutch(int c, FILE *file)\n{\n\tINT_OFF;\n\tputc_unlocked(c, file);\n\tfflush(file);\n\tINT_ON;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_46E0F3(int a1, FILE *a2)\n{\n  ++*(_DWORD *)(qword_75D418 + 48);\n  putc_unlocked(a1, a2);\n  fflush(a2);\n  return sub_46E03F(a2, a2);\n}\n",
        "baseline_code_debug": "void __cdecl outcslow(int c, FILE *dest)\n{\n  ++ash_ptr_to_globals_misc->suppress_int;\n  putc_unlocked(c, dest);\n  fflush(dest);\n  int_on();\n}\n",
        "similarity_score_unixcoder": 0.9133595824241638,
        "similarity_score_baseline_stripped": 0.5513155460357666,
        "similarity_score_baseline_debug": 0.742590069770813
    },
    {
        "func_name": "valid_domain_label",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00464183 | 55 | push    rbp\n0x00464184 | 48 89 E5 | mov     rbp, rsp\n0x00464187 | 48 83 EC 30 | sub     rsp, 30h\n0x0046418B | 48 89 7D D8 | mov     [rbp+var_28], rdi\n0x0046418F | C7 45 F4 00 00 00 00 | mov     [rbp+var_C], 0\n0x00464196 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x0046419A | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0046419E | EB 7D | jmp     short loc_46421D\n0x004641A0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004641A4 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004641A7 | 3C 5C | cmp     al, 5Ch ; '\\'\n0x004641A9 | 75 10 | jnz     short loc_4641BB\n0x004641AB | BF C9 61 53 00 | mov     edi, offset asc_5361C9; \"\\\\\\\\\"\n0x004641B0 | E8 7D FC FF FF | call    sub_463E32\n0x004641B5 | 83 45 F4 02 | add     [rbp+var_C], 2\n0x004641B9 | EB 5D | jmp     short loc_464218\n0x004641BB | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004641BF | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004641C2 | 3C 1F | cmp     al, 1Fh\n0x004641C4 | 7E 22 | jle     short loc_4641E8\n0x004641C6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004641CA | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004641CD | 3C 7F | cmp     al, 7Fh\n0x004641CF | 74 17 | jz      short loc_4641E8\n0x004641D1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004641D5 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004641D8 | 0F BE C0 | movsx   eax, al\n0x004641DB | 89 C7 | mov     edi, eax\n0x004641DD | E8 F3 FB FF FF | call    sub_463DD5\n0x004641E2 | 83 45 F4 01 | add     [rbp+var_C], 1\n0x004641E6 | EB 30 | jmp     short loc_464218\n0x004641E8 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004641EC | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004641EF | 0F B6 D0 | movzx   edx, al\n0x004641F2 | 48 8D 45 EF | lea     rax, [rbp+s]\n0x004641F6 | BE CC 61 53 00 | mov     esi, offset a03o; \"\\\\%03o\"\n0x004641FB | 48 89 C7 | mov     rdi, rax; s\n0x004641FE | B8 00 00 00 00 | mov     eax, 0\n0x00464203 | E8 78 38 FA FF | call    _sprintf\n0x00464208 | 48 8D 45 EF | lea     rax, [rbp+s]\n0x0046420C | 48 89 C7 | mov     rdi, rax\n0x0046420F | E8 1E FC FF FF | call    sub_463E32\n0x00464214 | 83 45 F4 04 | add     [rbp+var_C], 4\n0x00464218 | 48 83 45 F8 01 | add     [rbp+var_8], 1\n0x0046421D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00464221 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00464224 | 84 C0 | test    al, al\n0x00464226 | 0F 85 74 FF FF FF | jnz     loc_4641A0\n0x0046422C | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x0046422F | C9 | leave\n0x00464230 | C3 | retn\n\n Ourput decompiled code:\nstatic int out_args(const char *mystr)\n{\n\tconst char *here;\n\tint strcount = 0;\n\tchar tmpstr[5];\n\n\tfor (here = mystr; *here; here++) {\n\t\tif (*here == '\\\\') {\n\t\t\tout_string(\"\\\\\\\\\");\n\t\t\tstrcount += 2;\n\t\t} else if (*here >= ' ' && *here < 0x7f) {\n\t\t\tout_char(*here);\n\t\t\tstrcount++;\n\t\t} else {\n\t\t\tsprintf(tmpstr, \"\\\\%03o\", (unsigned char) *here);\n\t\t\tout_string(tmpstr);\n\t\t\tstrcount += 4;\n\t\t}\n\t}\n\n\treturn strcount;\n}\n\n## Example:\n\n Input assembly code:\n0x0046DEFF | 55 | push    rbp\n0x0046DF00 | 48 89 E5 | mov     rbp, rsp\n0x0046DF03 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0046DF07 | C7 45 FC 0A 00 00 00 | mov     [rbp+var_4], 0Ah\n0x0046DF0E | EB 05 | jmp     short loc_46DF15\n0x0046DF10 | 48 83 45 E8 01 | add     [rbp+var_18], 1\n0x0046DF15 | 83 6D FC 01 | sub     [rbp+var_4], 1\n0x0046DF19 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x0046DF1D | 74 0E | jz      short loc_46DF2D\n0x0046DF1F | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0046DF23 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0046DF26 | 83 E8 30 | sub     eax, 30h ; '0'\n0x0046DF29 | 3C 09 | cmp     al, 9\n0x0046DF2B | 76 E3 | jbe     short loc_46DF10\n0x0046DF2D | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0046DF31 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0046DF34 | 84 C0 | test    al, al\n0x0046DF36 | 0F 94 C0 | setz    al\n0x0046DF39 | 0F B6 C0 | movzx   eax, al\n0x0046DF3C | 5D | pop     rbp\n0x0046DF3D | C3 | retn\n\n Ourput decompiled code:\nstatic int isdigit_str9(const char *str)\n{\n\tint maxlen = 9 + 1; /* max 9 digits: 999999999 */\n\twhile (--maxlen && isdigit(*str))\n\t\tstr++;\n\treturn (*str == '\\0');\n}\n\n## Example:\n\n Input assembly code:\n0x0048B79A | 55 | push    rbp\n0x0048B79B | 48 89 E5 | mov     rbp, rsp\n0x0048B79E | 48 83 EC 10 | sub     rsp, 10h\n0x0048B7A2 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0048B7A6 | 89 F0 | mov     eax, esi\n0x0048B7A8 | 88 45 F4 | mov     [rbp+var_C], al\n0x0048B7AB | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0048B7B0 | 74 1C | jz      short loc_48B7CE\n0x0048B7B2 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B7B6 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0048B7B9 | 83 C8 20 | or      eax, 20h\n0x0048B7BC | 83 E8 61 | sub     eax, 61h ; 'a'\n0x0048B7BF | 3C 19 | cmp     al, 19h\n0x0048B7C1 | 76 12 | jbe     short loc_48B7D5\n0x0048B7C3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B7C7 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0048B7CA | 3C 5F | cmp     al, 5Fh ; '_'\n0x0048B7CC | 74 07 | jz      short loc_48B7D5\n0x0048B7CE | B8 00 00 00 00 | mov     eax, 0\n0x0048B7D3 | EB 35 | jmp     short locret_48B80A\n0x0048B7D5 | 48 83 45 F8 01 | add     [rbp+var_8], 1\n0x0048B7DA | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B7DE | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0048B7E1 | 0F B6 C0 | movzx   eax, al\n0x0048B7E4 | 89 C7 | mov     edi, eax\n0x0048B7E6 | E8 71 FF FF FF | call    sub_48B75C\n0x0048B7EB | 85 C0 | test    eax, eax\n0x0048B7ED | 75 E6 | jnz     short loc_48B7D5\n0x0048B7EF | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B7F3 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0048B7F6 | 3C 5F | cmp     al, 5Fh ; '_'\n0x0048B7F8 | 74 DB | jz      short loc_48B7D5\n0x0048B7FA | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B7FE | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0048B801 | 38 45 F4 | cmp     [rbp+var_C], al\n0x0048B804 | 0F 94 C0 | setz    al\n0x0048B807 | 0F B6 C0 | movzx   eax, al\n0x0048B80A | C9 | leave\n0x0048B80B | C3 | retn\n\n Ourput decompiled code:\nint FAST_FUNC is_well_formed_var_name(const char *s, char terminator)\n{\n\tif (!s || !(isalpha(*s) || *s == '_'))\n\t\treturn 0;\n\n\tdo\n\t\ts++;\n\twhile (isalnum(*s) || *s == '_');\n\n\treturn *s == terminator;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004534CD | 55 | push    rbp\n0x004534CE | 48 89 E5 | mov     rbp, rsp\n0x004534D1 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004534D5 | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x004534DC | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004534E0 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004534E3 | 88 45 FB | mov     [rbp+var_5], al\n0x004534E6 | 0F B6 45 FB | movzx   eax, [rbp+var_5]\n0x004534EA | 83 C8 20 | or      eax, 20h\n0x004534ED | 3C 60 | cmp     al, 60h ; '`'\n0x004534EF | 76 0B | jbe     short loc_4534FC\n0x004534F1 | 0F B6 45 FB | movzx   eax, [rbp+var_5]\n0x004534F5 | 83 C8 20 | or      eax, 20h\n0x004534F8 | 3C 7A | cmp     al, 7Ah ; 'z'\n0x004534FA | 76 3E | jbe     short loc_45353A\n0x004534FC | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x00453500 | 75 07 | jnz     short loc_453509\n0x00453502 | B8 00 00 00 00 | mov     eax, 0\n0x00453507 | EB 3C | jmp     short loc_453545\n0x00453509 | 80 7D FB 2F | cmp     [rbp+var_5], 2Fh ; '/'\n0x0045350D | 76 06 | jbe     short loc_453515\n0x0045350F | 80 7D FB 39 | cmp     [rbp+var_5], 39h ; '9'\n0x00453513 | 76 25 | jbe     short loc_45353A\n0x00453515 | 80 7D FB 00 | cmp     [rbp+var_5], 0\n0x00453519 | 74 06 | jz      short loc_453521\n0x0045351B | 80 7D FB 2E | cmp     [rbp+var_5], 2Eh ; '.'\n0x0045351F | 75 06 | jnz     short loc_453527\n0x00453521 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00453525 | EB 1E | jmp     short loc_453545\n0x00453527 | 80 7D FB 2D | cmp     [rbp+var_5], 2Dh ; '-'\n0x0045352B | 74 0D | jz      short loc_45353A\n0x0045352D | 80 7D FB 5F | cmp     [rbp+var_5], 5Fh ; '_'\n0x00453531 | 74 07 | jz      short loc_45353A\n0x00453533 | B8 00 00 00 00 | mov     eax, 0\n0x00453538 | EB 0B | jmp     short loc_453545\n0x0045353A | 48 83 45 E8 01 | add     [rbp+var_18], 1\n0x0045353F | 83 45 FC 01 | add     [rbp+var_4], 1\n0x00453543 | EB 97 | jmp     short loc_4534DC\n0x00453545 | 5D | pop     rbp\n0x00453546 | C3 | retn",
        "output": "",
        "source_code": "static const char *valid_domain_label(const char *label)\n{\n\tunsigned char ch;\n\tunsigned pos = 0;\n\n\tfor (;;) {\n\t\tch = *label;\n\t\tif ((ch|0x20) < 'a' || (ch|0x20) > 'z') {\n\t\t\tif (pos == 0) {\n\t\t\t\t/* label must begin with letter */\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (ch < '0' || ch > '9') {\n\t\t\t\tif (ch == '\\0' || ch == '.')\n\t\t\t\t\treturn label;\n\t\t\t\t/* DNS allows only '-', but we are more permissive */\n\t\t\t\tif (ch != '-' && ch != '_')\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tlabel++;\n\t\tpos++;\n\t\t//Do we want this?\n\t\t//if (pos > 63) /* NS_MAXLABEL; labels must be 63 chars or less */\n\t\t//\treturn NULL;\n\t}\n}",
        "parsed_output": "",
        "baseline_code_stripped": "unsigned __int8 *__fastcall sub_4534CD(unsigned __int8 *a1)\n{\n  unsigned __int8 v3; // [rsp+13h] [rbp-5h]\n  int i; // [rsp+14h] [rbp-4h]\n\n  for ( i = 0; ; ++i )\n  {\n    v3 = *a1;\n    if ( (*a1 | 0x20u) <= 0x60 || (v3 | 0x20u) > 0x7A )\n    {\n      if ( !i )\n        return 0LL;\n      if ( v3 <= 0x2Fu || v3 > 0x39u )\n      {\n        if ( !v3 || v3 == 46 )\n          return a1;\n        if ( v3 != 45 && v3 != 95 )\n          break;\n      }\n    }\n    ++a1;\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "const char *__cdecl valid_domain_label(const char *label)\n{\n  unsigned __int8 ch_0; // [rsp+13h] [rbp-5h]\n  unsigned int pos; // [rsp+14h] [rbp-4h]\n\n  for ( pos = 0; ; ++pos )\n  {\n    ch_0 = *label;\n    if ( (*label | 0x20u) <= 0x60 || (ch_0 | 0x20u) > 0x7A )\n    {\n      if ( !pos )\n        return 0LL;\n      if ( ch_0 <= 0x2Fu || ch_0 > 0x39u )\n      {\n        if ( !ch_0 || ch_0 == 46 )\n          return label;\n        if ( ch_0 != 45 && ch_0 != 95 )\n          break;\n      }\n    }\n    ++label;\n  }\n  return 0LL;\n}\n",
        "similarity_score_unixcoder": 0.011022599413990974,
        "similarity_score_baseline_stripped": 0.6187375783920288,
        "similarity_score_baseline_debug": 0.8385323286056519
    },
    {
        "func_name": "open_a_console",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0050190E | 55 | push    rbp\n0x0050190F | 48 89 E5 | mov     rbp, rsp\n0x00501912 | 48 83 EC 20 | sub     rsp, 20h\n0x00501916 | 48 89 7D E8 | mov     [rbp+file], rdi\n0x0050191A | 48 8B 45 E8 | mov     rax, [rbp+file]\n0x0050191E | BE 00 00 00 00 | mov     esi, 0; oflag\n0x00501923 | 48 89 C7 | mov     rdi, rax; file\n0x00501926 | B8 00 00 00 00 | mov     eax, 0\n0x0050192B | E8 A0 5D F0 FF | call    _open64\n0x00501930 | 89 45 FC | mov     [rbp+fd], eax\n0x00501933 | 83 7D FC 00 | cmp     [rbp+fd], 0\n0x00501937 | 79 07 | jns     short loc_501940\n0x00501939 | B8 01 00 00 00 | mov     eax, 1\n0x0050193E | EB 29 | jmp     short locret_501969\n0x00501940 | 8B 45 FC | mov     eax, [rbp+fd]\n0x00501943 | BA 00 00 00 00 | mov     edx, 0\n0x00501948 | BE 01 4C 00 00 | mov     esi, 4C01h; request\n0x0050194D | 89 C7 | mov     edi, eax; fd\n0x0050194F | B8 00 00 00 00 | mov     eax, 0\n0x00501954 | E8 47 54 F0 FF | call    _ioctl\n0x00501959 | 89 45 F8 | mov     [rbp+var_8], eax\n0x0050195C | 8B 45 FC | mov     eax, [rbp+fd]\n0x0050195F | 89 C7 | mov     edi, eax; fd\n0x00501961 | E8 AA 54 F0 FF | call    _close\n0x00501966 | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x00501969 | C9 | leave\n0x0050196A | C3 | retn\n\n Ourput decompiled code:\nint FAST_FUNC del_loop(const char *device)\n{\n\tint fd, rc;\n\n\tfd = open(device, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 1;\n\trc = ioctl(fd, LOOP_CLR_FD, 0);\n\tclose(fd);\n\n\treturn rc;\n}\n\n## Example:\n\n Input assembly code:\n0x0050A55F | 55 | push    rbp\n0x0050A560 | 48 89 E5 | mov     rbp, rsp\n0x0050A563 | 48 83 EC 20 | sub     rsp, 20h\n0x0050A567 | 48 89 7D E8 | mov     [rbp+argv], rdi\n0x0050A56B | E8 D9 00 F0 FF | call    sub_40A649\n0x0050A570 | C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0\n0x0050A577 | E8 34 D3 EF FF | call    _vfork\n0x0050A57C | 89 45 FC | mov     [rbp+var_4], eax\n0x0050A57F | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x0050A583 | 79 05 | jns     short loc_50A58A\n0x0050A585 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0050A588 | EB 63 | jmp     short locret_50A5ED\n0x0050A58A | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x0050A58E | 75 2C | jnz     short loc_50A5BC\n0x0050A590 | 48 8B 45 E8 | mov     rax, [rbp+argv]\n0x0050A594 | 48 8B 00 | mov     rax, [rax]\n0x0050A597 | 48 8B 55 E8 | mov     rdx, [rbp+argv]\n0x0050A59B | 48 89 D6 | mov     rsi, rdx; argv\n0x0050A59E | 48 89 C7 | mov     rdi, rax; file\n0x0050A5A1 | E8 EA D3 EF FF | call    _execvp\n0x0050A5A6 | 48 8B 05 53 2E 25 00 | mov     rax, cs:qword_75D400\n0x0050A5AD | 8B 00 | mov     eax, [rax]\n0x0050A5AF | 89 45 F8 | mov     [rbp+var_8], eax\n0x0050A5B2 | BF 6F 00 00 00 | mov     edi, 6Fh ; 'o'; status\n0x0050A5B7 | E8 04 C2 EF FF | call    __exit\n0x0050A5BC | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x0050A5BF | 85 C0 | test    eax, eax\n0x0050A5C1 | 74 27 | jz      short loc_50A5EA\n0x0050A5C3 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0050A5C6 | BA 00 00 00 00 | mov     edx, 0\n0x0050A5CB | BE 00 00 00 00 | mov     esi, 0\n0x0050A5D0 | 89 C7 | mov     edi, eax\n0x0050A5D2 | E8 71 F9 EF FF | call    sub_409F48\n0x0050A5D7 | 48 8B 05 22 2E 25 00 | mov     rax, cs:qword_75D400\n0x0050A5DE | 8B 55 F8 | mov     edx, [rbp+var_8]\n0x0050A5E1 | 89 10 | mov     [rax], edx\n0x0050A5E3 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x0050A5E8 | EB 03 | jmp     short locret_50A5ED\n0x0050A5EA | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0050A5ED | C9 | leave\n0x0050A5EE | C3 | retn\n\n Ourput decompiled code:\npid_t FAST_FUNC spawn(char **argv)\n{\n\t/* Compiler should not optimize stores here */\n\tvolatile int failed;\n\tpid_t pid;\n\n\tfflush_all();\n\n\t/* Be nice to nommu machines. */\n\tfailed = 0;\n\tpid = vfork();\n\tif (pid < 0) /* error */\n\t\treturn pid;\n\tif (!pid) { /* child */\n\t\t/* This macro is ok - it doesn't do NOEXEC/NOFORK tricks */\n\t\tBB_EXECVP(argv[0], argv);\n\n\t\t/* We are (maybe) sharing a stack with blocked parent,\n\t\t * let parent know we failed and then exit to unblock parent\n\t\t * (but don't run atexit() stuff, which would screw up parent.)\n\t\t */\n\t\tfailed = errno;\n\t\t/* mount, for example, does not want the message */\n\t\t/*bb_perror_msg(\"can't execute '%s'\", argv[0]);*/\n\t\t_exit(111);\n\t}\n\t/* parent */\n\t/* Unfortunately, this is not reliable: according to standards\n\t * vfork() can be equivalent to fork() and we won't see value\n\t * of 'failed'.\n\t * Interested party can wait on pid and learn exit code.\n\t * If 111 - then it (most probably) failed to exec */\n\tif (failed) {\n\t\tsafe_waitpid(pid, NULL, 0); /* prevent zombie */\n\t\terrno = failed;\n\t\treturn -1;\n\t}\n\treturn pid;\n}\n\n## Example:\n\n Input assembly code:\n0x004C33AC | 55 | push    rbp\n0x004C33AD | 48 89 E5 | mov     rbp, rsp\n0x004C33B0 | 48 83 EC 20 | sub     rsp, 20h\n0x004C33B4 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004C33B8 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004C33BC | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004C33C0 | 48 89 C7 | mov     rdi, rax\n0x004C33C3 | E8 12 FF FF FF | call    sub_4C32DA\n0x004C33C8 | 89 45 FC | mov     [rbp+fd], eax\n0x004C33CB | 83 7D FC 00 | cmp     [rbp+fd], 0\n0x004C33CF | 79 07 | jns     short loc_4C33D8\n0x004C33D1 | B8 00 00 00 00 | mov     eax, 0\n0x004C33D6 | EB 40 | jmp     short locret_4C3418\n0x004C33D8 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x004C33DC | 8B 45 FC | mov     eax, [rbp+fd]\n0x004C33DF | 48 89 D6 | mov     rsi, rdx\n0x004C33E2 | 89 C7 | mov     edi, eax\n0x004C33E4 | E8 7B 3E 04 00 | call    sub_507264\n0x004C33E9 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x004C33ED | 48 83 7D F0 00 | cmp     [rbp+var_10], 0\n0x004C33F2 | 75 16 | jnz     short loc_4C340A\n0x004C33F4 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004C33F8 | 48 89 C6 | mov     rsi, rax\n0x004C33FB | BF B6 68 53 00 | mov     edi, offset aReadErrorFromS; \"read error from '%s'\"\n0x004C3400 | B8 00 00 00 00 | mov     eax, 0\n0x004C3405 | E8 CF 5D F4 FF | call    sub_4091D9\n0x004C340A | 8B 45 FC | mov     eax, [rbp+fd]\n0x004C340D | 89 C7 | mov     edi, eax; fd\n0x004C340F | E8 FC 39 F4 FF | call    _close\n0x004C3414 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004C3418 | C9 | leave\n0x004C3419 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC xmalloc_open_zipped_read_close(const char *fname, size_t *maxsz_p)\n{\n\tint fd;\n\tchar *image;\n\n\tfd = open_zipped(fname);\n\tif (fd < 0)\n\t\treturn NULL;\n\n\timage = xmalloc_read(fd, maxsz_p);\n\tif (!image)\n\t\tbb_perror_msg(\"read error from '%s'\", fname);\n\tclose(fd);\n\n\treturn image;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004F9CA0 | 55 | push    rbp\n0x004F9CA1 | 48 89 E5 | mov     rbp, rsp\n0x004F9CA4 | 48 83 EC 20 | sub     rsp, 20h\n0x004F9CA8 | 48 89 7D E8 | mov     [rbp+file], rdi\n0x004F9CAC | 48 8B 45 E8 | mov     rax, [rbp+file]\n0x004F9CB0 | BE 02 00 00 00 | mov     esi, 2; oflag\n0x004F9CB5 | 48 89 C7 | mov     rdi, rax; file\n0x004F9CB8 | B8 00 00 00 00 | mov     eax, 0\n0x004F9CBD | E8 0E DA F0 FF | call    _open64\n0x004F9CC2 | 89 45 FC | mov     [rbp+var_4], eax\n0x004F9CC5 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004F9CC9 | 79 27 | jns     short loc_4F9CF2\n0x004F9CCB | 48 8B 05 2E 37 26 00 | mov     rax, cs:qword_75D400\n0x004F9CD2 | 8B 00 | mov     eax, [rax]\n0x004F9CD4 | 83 F8 0D | cmp     eax, 0Dh\n0x004F9CD7 | 75 19 | jnz     short loc_4F9CF2\n0x004F9CD9 | 48 8B 45 E8 | mov     rax, [rbp+file]\n0x004F9CDD | BE 00 00 00 00 | mov     esi, 0; oflag\n0x004F9CE2 | 48 89 C7 | mov     rdi, rax; file\n0x004F9CE5 | B8 00 00 00 00 | mov     eax, 0\n0x004F9CEA | E8 E1 D9 F0 FF | call    _open64\n0x004F9CEF | 89 45 FC | mov     [rbp+var_4], eax\n0x004F9CF2 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004F9CF6 | 79 27 | jns     short loc_4F9D1F\n0x004F9CF8 | 48 8B 05 01 37 26 00 | mov     rax, cs:qword_75D400\n0x004F9CFF | 8B 00 | mov     eax, [rax]\n0x004F9D01 | 83 F8 0D | cmp     eax, 0Dh\n0x004F9D04 | 75 19 | jnz     short loc_4F9D1F\n0x004F9D06 | 48 8B 45 E8 | mov     rax, [rbp+file]\n0x004F9D0A | BE 01 00 00 00 | mov     esi, 1; oflag\n0x004F9D0F | 48 89 C7 | mov     rdi, rax; file\n0x004F9D12 | B8 00 00 00 00 | mov     eax, 0\n0x004F9D17 | E8 B4 D9 F0 FF | call    _open64\n0x004F9D1C | 89 45 FC | mov     [rbp+var_4], eax\n0x004F9D1F | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004F9D22 | C9 | leave\n0x004F9D23 | C3 | retn",
        "output": "",
        "source_code": "static int open_a_console(const char *fnam)\n{\n\tint fd;\n\n\t/* try read-write */\n\tfd = open(fnam, O_RDWR);\n\n\t/* if failed, try read-only */\n\tif (fd < 0 && errno == EACCES)\n\t\tfd = open(fnam, O_RDONLY);\n\n\t/* if failed, try write-only */\n\tif (fd < 0 && errno == EACCES)\n\t\tfd = open(fnam, O_WRONLY);\n\n\treturn fd;\n}",
        "parsed_output": "",
        "baseline_code_stripped": "__int64 __fastcall sub_4F9CA0(const char *a1)\n{\n  int v2; // [rsp+1Ch] [rbp-4h]\n\n  v2 = open64(a1, 2);\n  if ( v2 < 0 && *(_DWORD *)qword_75D400 == 13 )\n    v2 = open64(a1, 0);\n  if ( v2 < 0 && *(_DWORD *)qword_75D400 == 13 )\n    return (unsigned int)open64(a1, 1);\n  return (unsigned int)v2;\n}\n",
        "baseline_code_debug": "int __cdecl open_a_console(const char *fnam)\n{\n  int fd; // [rsp+1Ch] [rbp-4h]\n\n  fd = open64(fnam, 2);\n  if ( fd < 0 && *bb_errno == 13 )\n    fd = open64(fnam, 0);\n  if ( fd < 0 && *bb_errno == 13 )\n    return open64(fnam, 1);\n  return fd;\n}\n",
        "similarity_score_unixcoder": -0.008259560912847519,
        "similarity_score_baseline_stripped": 0.5214998126029968,
        "similarity_score_baseline_debug": 0.711554229259491
    },
    {
        "func_name": "rtnl_rtrealm_initialize",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00452770 | 55 | push    rbp\n0x00452771 | 48 89 E5 | mov     rbp, rsp\n0x00452774 | 48 8B 05 55 8A 30 00 | mov     rax, cs:qword_75B1D0\n0x0045277B | 48 85 C0 | test    rax, rax\n0x0045277E | 75 3A | jnz     short loc_4527BA\n0x00452780 | BF 10 08 00 00 | mov     edi, 810h\n0x00452785 | E8 5E 79 FB FF | call    sub_40A0E8\n0x0045278A | 48 89 05 3F 8A 30 00 | mov     cs:qword_75B1D0, rax\n0x00452791 | 48 8B 05 38 8A 30 00 | mov     rax, cs:qword_75B1D0\n0x00452798 | 48 C7 40 10 F9 AC 51 00 | mov     qword ptr [rax+10h], offset a0_1; \"0\"\n0x004527A0 | 48 8B 05 29 8A 30 00 | mov     rax, cs:qword_75B1D0\n0x004527A7 | 48 83 C0 10 | add     rax, 10h\n0x004527AB | 48 89 C6 | mov     rsi, rax\n0x004527AE | BF FB AC 51 00 | mov     edi, offset aEtcIproute2RtD; \"/etc/iproute2/rt_dsfield\"\n0x004527B3 | E8 60 FA FF FF | call    sub_452218\n0x004527B8 | EB 01 | jmp     short loc_4527BB\n0x004527BA | 90 | nop\n0x004527BB | 5D | pop     rbp\n0x004527BC | C3 | retn\n\n Ourput decompiled code:\nstatic void rtnl_rtdsfield_initialize(void)\n{\n\tif (rtnl_rtdsfield_tab) return;\n\trtnl_rtdsfield_tab = xzalloc(sizeof(*rtnl_rtdsfield_tab));\n\trtnl_rtdsfield_tab->tab[0] = \"0\";\n\trtnl_tab_initialize(\"/etc/iproute2/rt_dsfield\", rtnl_rtdsfield_tab->tab);\n}\n\n## Example:\n\n Input assembly code:\n0x004523E0 | 55 | push    rbp\n0x004523E1 | 48 89 E5 | mov     rbp, rsp\n0x004523E4 | 48 8B 05 CD 8D 30 00 | mov     rax, cs:qword_75B1B8\n0x004523EB | 48 85 C0 | test    rax, rax\n0x004523EE | 75 48 | jnz     short loc_452438\n0x004523F0 | BF 10 08 00 00 | mov     edi, 810h\n0x004523F5 | E8 EE 7C FB FF | call    sub_40A0E8\n0x004523FA | 48 89 05 B7 8D 30 00 | mov     cs:qword_75B1B8, rax\n0x00452401 | 48 8B 05 B0 8D 30 00 | mov     rax, cs:qword_75B1B8\n0x00452408 | 48 83 C0 10 | add     rax, 10h\n0x0045240C | BA 68 00 00 00 | mov     edx, 68h ; 'h'; n\n0x00452411 | BE A0 AD 51 00 | mov     esi, offset off_51ADA0; src\n0x00452416 | 48 89 C7 | mov     rdi, rax; dest\n0x00452419 | E8 82 4D FB FF | call    _memcpy\n0x0045241E | 48 8B 05 93 8D 30 00 | mov     rax, cs:qword_75B1B8\n0x00452425 | 48 83 C0 10 | add     rax, 10h\n0x00452429 | 48 89 C6 | mov     rsi, rax\n0x0045242C | BF 88 AC 51 00 | mov     edi, offset aEtcIproute2RtP; \"/etc/iproute2/rt_protos\"\n0x00452431 | E8 E2 FD FF FF | call    sub_452218\n0x00452436 | EB 01 | jmp     short loc_452439\n0x00452438 | 90 | nop\n0x00452439 | 5D | pop     rbp\n0x0045243A | C3 | retn\n\n Ourput decompiled code:\nstatic void rtnl_rtprot_initialize(void)\n{\n\tstatic const char *const init_tab[] = {\n\t\t\"none\",\n\t\t\"redirect\",\n\t\t\"kernel\",\n\t\t\"boot\",\n\t\t\"static\",\n\t\tNULL,\n\t\tNULL,\n\t\tNULL,\n\t\t\"gated\",\n\t\t\"ra\",\n\t\t\"mrt\",\n\t\t\"zebra\",\n\t\t\"bird\",\n\t};\n\n\tif (rtnl_rtprot_tab)\n\t\treturn;\n\trtnl_rtprot_tab = xzalloc(sizeof(*rtnl_rtprot_tab));\n\tmemcpy(rtnl_rtprot_tab->tab, init_tab, sizeof(init_tab));\n\trtnl_tab_initialize(\"/etc/iproute2/rt_protos\", rtnl_rtprot_tab->tab);\n}\n\n## Example:\n\n Input assembly code:\n0x00452882 | 55 | push    rbp\n0x00452883 | 48 89 E5 | mov     rbp, rsp\n0x00452886 | 48 8B 05 43 89 30 00 | mov     rax, cs:qword_75B1D0\n0x0045288D | 48 85 C0 | test    rax, rax\n0x00452890 | 75 70 | jnz     short loc_452902\n0x00452892 | BF 10 08 00 00 | mov     edi, 810h\n0x00452897 | E8 4C 78 FB FF | call    sub_40A0E8\n0x0045289C | 48 89 05 35 89 30 00 | mov     cs:qword_75B1D8, rax\n0x004528A3 | 48 8B 05 2E 89 30 00 | mov     rax, cs:qword_75B1D8\n0x004528AA | 48 C7 40 10 1B AD 51 00 | mov     qword ptr [rax+10h], offset aUnspec; \"unspec\"\n0x004528B2 | 48 8B 05 1F 89 30 00 | mov     rax, cs:qword_75B1D8\n0x004528B9 | 48 C7 80 08 08 00 00 22 AD 51 00 | mov     qword ptr [rax+808h], offset aLocal_0; \"local\"\n0x004528C4 | 48 8B 05 0D 89 30 00 | mov     rax, cs:qword_75B1D8\n0x004528CB | 48 C7 80 00 08 00 00 28 AD 51 00 | mov     qword ptr [rax+800h], offset aMain; \"main\"\n0x004528D6 | 48 8B 05 FB 88 30 00 | mov     rax, cs:qword_75B1D8\n0x004528DD | 48 C7 80 F8 07 00 00 2D AD 51 00 | mov     qword ptr [rax+7F8h], offset aDefault_2; \"default\"\n0x004528E8 | 48 8B 05 E9 88 30 00 | mov     rax, cs:qword_75B1D8\n0x004528EF | 48 83 C0 10 | add     rax, 10h\n0x004528F3 | 48 89 C6 | mov     rsi, rax\n0x004528F6 | BF 35 AD 51 00 | mov     edi, offset aEtcIproute2RtT; \"/etc/iproute2/rt_tables\"\n0x004528FB | E8 18 F9 FF FF | call    sub_452218\n0x00452900 | EB 01 | jmp     short loc_452903\n0x00452902 | 90 | nop\n0x00452903 | 5D | pop     rbp\n0x00452904 | C3 | retn\n\n Ourput decompiled code:\nstatic void rtnl_rttable_initialize(void)\n{\n\tif (rtnl_rtdsfield_tab) return;\n\trtnl_rttable_tab = xzalloc(sizeof(*rtnl_rttable_tab));\n\trtnl_rttable_tab->tab[0] = \"unspec\";\n\trtnl_rttable_tab->tab[255] = \"local\";\n\trtnl_rttable_tab->tab[254] = \"main\";\n\trtnl_rttable_tab->tab[253] = \"default\";\n\trtnl_tab_initialize(\"/etc/iproute2/rt_tables\", rtnl_rttable_tab->tab);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0045265E | 55 | push    rbp\n0x0045265F | 48 89 E5 | mov     rbp, rsp\n0x00452662 | 48 8B 05 5F 8B 30 00 | mov     rax, cs:qword_75B1C8\n0x00452669 | 48 85 C0 | test    rax, rax\n0x0045266C | 75 3A | jnz     short loc_4526A8\n0x0045266E | BF 10 08 00 00 | mov     edi, 810h\n0x00452673 | E8 70 7A FB FF | call    sub_40A0E8\n0x00452678 | 48 89 05 49 8B 30 00 | mov     cs:qword_75B1C8, rax\n0x0045267F | 48 8B 05 42 8B 30 00 | mov     rax, cs:qword_75B1C8\n0x00452686 | 48 C7 40 10 D9 AC 51 00 | mov     qword ptr [rax+10h], offset aUnknown_9; \"unknown\"\n0x0045268E | 48 8B 05 33 8B 30 00 | mov     rax, cs:qword_75B1C8\n0x00452695 | 48 83 C0 10 | add     rax, 10h\n0x00452699 | 48 89 C6 | mov     rsi, rax\n0x0045269C | BF E1 AC 51 00 | mov     edi, offset aEtcIproute2RtR; \"/etc/iproute2/rt_realms\"\n0x004526A1 | E8 72 FB FF FF | call    sub_452218\n0x004526A6 | EB 01 | jmp     short loc_4526A9\n0x004526A8 | 90 | nop\n0x004526A9 | 5D | pop     rbp\n0x004526AA | C3 | retn",
        "output": "\n\nstatic void rtnl_rtrealm_initialize(void)\n{\n\tif (rtnl_rtrealm_tab) return;\n\trtnl_rtrealm_tab = xzalloc(sizeof(*rtnl_rtrealm_tab));\n\trtnl_rtrealm_tab->tab[0] = \"unknown\";\n\trtnl_tab_initialize(\"/etc/iproute2/rt_realms\", rtnl_rtrealm_tab->tab);\n}",
        "source_code": "static void rtnl_rtrealm_initialize(void)\n{\n\tif (rtnl_rtrealm_tab) return;\n\trtnl_rtrealm_tab = xzalloc(sizeof(*rtnl_rtrealm_tab));\n\trtnl_rtrealm_tab->tab[0] = \"unknown\";\n\trtnl_tab_initialize(\"/etc/iproute2/rt_realms\", rtnl_rtrealm_tab->tab);\n}",
        "parsed_output": "\n\nstatic void rtnl_rtrealm_initialize(void)\n{\n\tif (rtnl_rtrealm_tab) return;\n\trtnl_rtrealm_tab = xzalloc(sizeof(*rtnl_rtrealm_tab));\n\trtnl_rtrealm_tab->tab[0] = \"unknown\";\n\trtnl_tab_initialize(\"/etc/iproute2/rt_realms\", rtnl_rtrealm_tab->tab);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_45265E(__int64 a1, __int64 a2)\n{\n  __int64 result; // rax\n\n  result = qword_75B1C8;\n  if ( !qword_75B1C8 )\n  {\n    qword_75B1C8 = (__int64)sub_40A0E8(0x810uLL, a2);\n    *(_QWORD *)(qword_75B1C8 + 16) = \"unknown\";\n    return sub_452218((__int64)\"/etc/iproute2/rt_realms\", qword_75B1C8 + 16);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl rtnl_rtrealm_initialize()\n{\n  if ( !rtnl_rtrealm_tab )\n  {\n    rtnl_rtrealm_tab = (rtnl_tab_t_0 *)xzalloc(0x810uLL);\n    rtnl_rtrealm_tab->tab[0] = \"unknown\";\n    rtnl_tab_initialize(\"/etc/iproute2/rt_realms\", rtnl_rtrealm_tab->tab);\n  }\n}\n",
        "similarity_score_unixcoder": 0.9849998950958252,
        "similarity_score_baseline_stripped": 0.4924604594707489,
        "similarity_score_baseline_debug": 0.9493629932403564
    },
    {
        "func_name": "read_maybe_empty",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00489651 | 55 | push    rbp\n0x00489652 | 48 89 E5 | mov     rbp, rsp\n0x00489655 | 48 83 EC 10 | sub     rsp, 10h\n0x00489659 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0048965D | 48 8B 05 A4 3D 2D 00 | mov     rax, cs:qword_75D408\n0x00489664 | 8B 80 98 00 00 00 | mov     eax, [rax+98h]\n0x0048966A | 85 C0 | test    eax, eax\n0x0048966C | 75 20 | jnz     short loc_48968E\n0x0048966E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00489672 | 48 8B 00 | mov     rax, [rax]\n0x00489675 | 48 89 C6 | mov     rsi, rax\n0x00489678 | BF 21 EF 51 00 | mov     edi, offset aSNotInAFunctio; \"%s: not in a function\"\n0x0048967D | B8 00 00 00 00 | mov     eax, 0\n0x00489682 | E8 C0 00 F8 FF | call    sub_409747\n0x00489687 | B8 01 00 00 00 | mov     eax, 1\n0x0048968C | EB 25 | jmp     short locret_4896B3\n0x0048968E | 48 8B 05 73 3D 2D 00 | mov     rax, cs:qword_75D408\n0x00489695 | 8B 80 98 00 00 00 | mov     eax, [rax+98h]\n0x0048969B | 89 C2 | mov     edx, eax\n0x0048969D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004896A1 | BE 00 00 00 00 | mov     esi, 0\n0x004896A6 | 48 89 C7 | mov     rdi, rax\n0x004896A9 | E8 72 FD FF FF | call    sub_489420\n0x004896AE | B8 00 00 00 00 | mov     eax, 0\n0x004896B3 | C9 | leave\n0x004896B4 | C3 | retn\n\n Ourput decompiled code:\nif ENABLE_HUSH_LOCAL\nstatic int FAST_FUNC builtin_local(char **argv)\n{\n\tif (G.func_nest_level == 0) {\n\t\tbb_error_msg(\"%s: not in a function\", argv[0]);\n\t\treturn EXIT_FAILURE; /* bash compat */\n\t}\n\thelper_export_local(argv, 0, G.func_nest_level);\n\treturn EXIT_SUCCESS;\n}\n\n## Example:\n\n Input assembly code:\n0x004892A0 | 55 | push    rbp\n0x004892A1 | 48 89 E5 | mov     rbp, rsp\n0x004892A4 | 48 83 EC 10 | sub     rsp, 10h\n0x004892A8 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004892AC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004892B0 | 48 89 C7 | mov     rdi, rax\n0x004892B3 | E8 95 FE FF FF | call    sub_48914D\n0x004892B8 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004892BC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004892C0 | 48 8B 00 | mov     rax, [rax]\n0x004892C3 | 48 85 C0 | test    rax, rax\n0x004892C6 | 75 07 | jnz     short loc_4892CF\n0x004892C8 | B8 00 00 00 00 | mov     eax, 0\n0x004892CD | EB 4B | jmp     short locret_48931A\n0x004892CF | 48 8B 05 32 41 2D 00 | mov     rax, cs:qword_75D408\n0x004892D6 | 8B 40 3C | mov     eax, [rax+3Ch]\n0x004892D9 | 85 C0 | test    eax, eax\n0x004892DB | 74 31 | jz      short loc_48930E\n0x004892DD | E8 9E D6 F7 FF | call    _getpid\n0x004892E2 | 89 C2 | mov     edx, eax\n0x004892E4 | 48 8B 05 1D 41 2D 00 | mov     rax, cs:qword_75D408\n0x004892EB | 8B 40 20 | mov     eax, [rax+20h]\n0x004892EE | 39 C2 | cmp     edx, eax\n0x004892F0 | 75 1C | jnz     short loc_48930E\n0x004892F2 | 48 8B 05 0F 41 2D 00 | mov     rax, cs:qword_75D408\n0x004892F9 | 8B 50 3C | mov     edx, [rax+3Ch]\n0x004892FC | 48 8B 05 05 41 2D 00 | mov     rax, cs:qword_75D408\n0x00489303 | 8B 00 | mov     eax, [rax]\n0x00489305 | 89 D6 | mov     esi, edx; pgrp_id\n0x00489307 | 89 C7 | mov     edi, eax; fd\n0x00489309 | E8 B2 E4 F7 FF | call    _tcsetpgrp\n0x0048930E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00489312 | 48 89 C7 | mov     rdi, rax\n0x00489315 | E8 46 D8 FF FF | call    sub_486B60\n0x0048931A | C9 | leave\n0x0048931B | C3 | retn\n\n Ourput decompiled code:\nstatic int FAST_FUNC builtin_exec(char **argv)\n{\n\targv = skip_dash_dash(argv);\n\tif (argv[0] == NULL)\n\t\treturn EXIT_SUCCESS; /* bash does this */\n\n\t/* Careful: we can end up here after [v]fork. Do not restore\n\t * tty pgrp then, only top-level shell process does that */\n\tif (G_saved_tty_pgrp && getpid() == G.root_pid)\n\t\ttcsetpgrp(G_interactive_fd, G_saved_tty_pgrp);\n\n\t/* TODO: if exec fails, bash does NOT exit! We do.\n\t * We'll need to undo trap cleanup (it's inside execvp_or_die)\n\t * and tcsetpgrp, and this is inherently racy.\n\t */\n\texecvp_or_die(argv);\n}\n\n## Example:\n\n Input assembly code:\n0x00460DE5 | 55 | push    rbp\n0x00460DE6 | 48 89 E5 | mov     rbp, rsp\n0x00460DE9 | 48 83 EC 10 | sub     rsp, 10h\n0x00460DED | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00460DF1 | 48 8B 05 10 C6 2F 00 | mov     rax, cs:qword_75D408\n0x00460DF8 | 0F B6 10 | movzx   edx, byte ptr [rax]\n0x00460DFB | 48 8B 05 06 C6 2F 00 | mov     rax, cs:qword_75D408\n0x00460E02 | 83 F2 01 | xor     edx, 1\n0x00460E05 | 88 10 | mov     [rax], dl\n0x00460E07 | EB 2C | jmp     short loc_460E35\n0x00460E09 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00460E0D | 48 8B 40 10 | mov     rax, [rax+10h]\n0x00460E11 | 48 89 C7 | mov     rdi, rax\n0x00460E14 | E8 82 E8 FF FF | call    sub_45F69B\n0x00460E19 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00460E1D | 48 8B 40 08 | mov     rax, [rax+8]\n0x00460E21 | 48 8B 55 F8 | mov     rdx, [rbp+var_8]\n0x00460E25 | 48 89 D7 | mov     rdi, rdx\n0x00460E28 | FF D0 | call    rax\n0x00460E2A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00460E2E | 48 8B 00 | mov     rax, [rax]\n0x00460E31 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00460E35 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00460E3A | 75 CD | jnz     short loc_460E09\n0x00460E3C | 90 | nop\n0x00460E3D | C9 | leave\n0x00460E3E | C3 | retn\n\n Ourput decompiled code:\nstatic void FAST_FUNC collect_info(s_stat *s)\n{\n\tgen ^= 1;\n\twhile (s) {\n\t\tput(s->label);\n\t\ts->collect(s);\n\t\ts = s->next;\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004907A9 | 55 | push    rbp\n0x004907AA | 48 89 E5 | mov     rbp, rsp\n0x004907AD | 48 83 EC 10 | sub     rsp, 10h\n0x004907B1 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004907B5 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004907B9 | 48 89 C7 | mov     rdi, rax\n0x004907BC | E8 48 FE FF FF | call    sub_490609\n0x004907C1 | 85 C0 | test    eax, eax\n0x004907C3 | 75 36 | jnz     short loc_4907FB\n0x004907C5 | 48 8B 15 3C CC 2C 00 | mov     rdx, cs:qword_75D408\n0x004907CC | 48 8B 05 35 CC 2C 00 | mov     rax, cs:qword_75D408\n0x004907D3 | 48 81 C2 28 01 00 00 | add     rdx, 128h\n0x004907DA | 48 89 10 | mov     [rax], rdx\n0x004907DD | 48 8B 05 24 CC 2C 00 | mov     rax, cs:qword_75D408\n0x004907E4 | 48 8B 00 | mov     rax, [rax]\n0x004907E7 | C6 00 0A | mov     byte ptr [rax], 0Ah\n0x004907EA | 48 8B 05 17 CC 2C 00 | mov     rax, cs:qword_75D408\n0x004907F1 | 48 8B 00 | mov     rax, [rax]\n0x004907F4 | 48 83 C0 01 | add     rax, 1\n0x004907F8 | C6 00 00 | mov     byte ptr [rax], 0\n0x004907FB | 48 8B 05 06 CC 2C 00 | mov     rax, cs:qword_75D408\n0x00490802 | 48 8B 00 | mov     rax, [rax]\n0x00490805 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00490808 | C9 | leave\n0x00490809 | C3 | retn",
        "output": "\n\nstatic int FAST_FUNC builtin_info(char **argv)\n{\n\tif (!is_interactive(argv)) {\n\t\tG.info_buffer[1024] = '\\n';\n\t\tG.info_buffer[1024 + 1] = '\\0';\n\t\treturn EXIT_SUCCESS;\n\t}\n\treturn EXIT_FAILURE;\n}",
        "source_code": "static char\nread_maybe_empty(const char *mesg)\n{\n\tif (!read_line(mesg)) {\n\t\tline_ptr = line_buffer;\n\t\tline_ptr[0] = '\\n';\n\t\tline_ptr[1] = '\\0';\n\t}\n\treturn line_ptr[0];\n}",
        "parsed_output": "\n\nstatic int FAST_FUNC builtin_info(char **argv)\n{\n\tif (!is_interactive(argv)) {\n\t\tG.info_buffer[1024] = '\\n';\n\t\tG.info_buffer[1024 + 1] = '\\0';\n\t\treturn EXIT_SUCCESS;\n\t}\n\treturn EXIT_FAILURE;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4907A9(__int64 a1)\n{\n  if ( !(unsigned int)sub_490609(a1) )\n  {\n    *(_QWORD *)qword_75D408 = (char *)qword_75D408 + 296;\n    **(_BYTE **)qword_75D408 = 10;\n    *(_BYTE *)(*(_QWORD *)qword_75D408 + 1LL) = 0;\n  }\n  return **(unsigned __int8 **)qword_75D408;\n}\n",
        "baseline_code_debug": "char __cdecl read_maybe_empty(const char *mesg)\n{\n  if ( !read_line(mesg) )\n  {\n    *(_QWORD *)&ptr_to_globals->timeout = (char *)ptr_to_globals + 296;\n    **(_BYTE **)&ptr_to_globals->timeout = 10;\n    *(_BYTE *)(*(_QWORD *)&ptr_to_globals->timeout + 1LL) = 0;\n  }\n  return **(_BYTE **)&ptr_to_globals->timeout;\n}\n",
        "similarity_score_unixcoder": 0.5666292905807495,
        "similarity_score_baseline_stripped": 0.460329532623291,
        "similarity_score_baseline_debug": 0.6738876104354858
    },
    {
        "func_name": "check_zone_nr",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004BB517 | 55 | push    rbp\n0x004BB518 | 48 89 E5 | mov     rbp, rsp\n0x004BB51B | 48 83 EC 30 | sub     rsp, 30h\n0x004BB51F | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004BB523 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004BB527 | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x004BB52B | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x004BB52F | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004BB533 | 48 89 D6 | mov     rsi, rdx\n0x004BB536 | 48 89 C7 | mov     rdi, rax\n0x004BB539 | E8 02 FF FF FF | call    sub_4BB440\n0x004BB53E | 89 45 FC | mov     [rbp+var_4], eax\n0x004BB541 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004BB545 | 8B 00 | mov     eax, [rax]\n0x004BB547 | 8D 14 00 | lea     edx, [rax+rax]\n0x004BB54A | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004BB54D | 01 C2 | add     edx, eax\n0x004BB54F | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004BB553 | 89 10 | mov     [rax], edx\n0x004BB555 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004BB558 | C9 | leave\n0x004BB559 | C3 | retn\n\n Ourput decompiled code:\nstatic speed_inline int rc_get_bit(rc_t *rc, uint16_t *p, int *symbol)\n{\n\tint ret = rc_is_bit_1(rc, p);\n\t*symbol = *symbol * 2 + ret;\n\treturn ret;\n}\n\n## Example:\n\n Input assembly code:\n0x00497671 | 55 | push    rbp\n0x00497672 | 48 89 E5 | mov     rbp, rsp\n0x00497675 | 48 83 EC 20 | sub     rsp, 20h\n0x00497679 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0049767D | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00497681 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00497685 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00497689 | 48 89 D6 | mov     rsi, rdx\n0x0049768C | 48 89 C7 | mov     rdi, rax\n0x0049768F | E8 29 EC FF FF | call    sub_4962BD\n0x00497694 | 89 45 FC | mov     [rbp+var_4], eax\n0x00497697 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x0049769B | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0049769E | 48 89 D6 | mov     rsi, rdx\n0x004976A1 | 89 C7 | mov     edi, eax\n0x004976A3 | E8 65 FE FF FF | call    sub_49750D\n0x004976A8 | 89 45 FC | mov     [rbp+var_4], eax\n0x004976AB | 83 7D FC FF | cmp     [rbp+var_4], 0FFFFFFFFh\n0x004976AF | 75 10 | jnz     short loc_4976C1\n0x004976B1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004976B5 | 66 C7 00 00 00 | mov     word ptr [rax], 0\n0x004976BA | C7 45 FC 00 00 00 00 | mov     [rbp+var_4], 0\n0x004976C1 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004976C4 | C9 | leave\n0x004976C5 | C3 | retn\n\n Ourput decompiled code:\nstatic int add_zone(uint16_t *znr, smallint *corrected)\n{\n\tint block;\n\n\tblock = check_zone_nr(znr, corrected);\n\tblock = add_zone_common(block, corrected);\n\tif (block == -1) {\n\t\t*znr = 0;\n\t\tblock = 0;\n\t}\n\treturn block;\n}\n\n## Example:\n\n Input assembly code:\n0x0050BDEA | 55 | push    rbp\n0x0050BDEB | 48 89 E5 | mov     rbp, rsp\n0x0050BDEE | 48 83 EC 20 | sub     rsp, 20h\n0x0050BDF2 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0050BDF6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0050BDFA | 0F B7 40 04 | movzx   eax, word ptr [rax+4]\n0x0050BDFE | 0F B7 C0 | movzx   eax, ax\n0x0050BE01 | BA 00 00 00 00 | mov     edx, 0\n0x0050BE06 | BE 01 00 00 00 | mov     esi, 1\n0x0050BE0B | 89 C7 | mov     edi, eax\n0x0050BE0D | E8 87 EB EF FF | call    sub_40A999\n0x0050BE12 | 89 45 FC | mov     [rbp+var_4], eax\n0x0050BE15 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0050BE19 | 8B 10 | mov     edx, [rax]\n0x0050BE1B | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0050BE1F | 48 8D 48 04 | lea     rcx, [rax+4]\n0x0050BE23 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0050BE26 | 48 89 CE | mov     rsi, rcx\n0x0050BE29 | 89 C7 | mov     edi, eax\n0x0050BE2B | E8 AD F6 FF FF | call    sub_50B4DD\n0x0050BE30 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0050BE33 | C9 | leave\n0x0050BE34 | C3 | retn\n\n Ourput decompiled code:\nint FAST_FUNC xconnect_stream(const len_and_sockaddr *lsa)\n{\n\tint fd = xsocket(lsa->u.sa.sa_family, SOCK_STREAM, 0);\n\txconnect(fd, &lsa->u.sa, lsa->len);\n\treturn fd;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004962BD | 55 | push    rbp\n0x004962BE | 48 89 E5 | mov     rbp, rsp\n0x004962C1 | 48 83 EC 20 | sub     rsp, 20h\n0x004962C5 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004962C9 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x004962CD | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004962D1 | 0F B7 00 | movzx   eax, word ptr [rax]\n0x004962D4 | 0F B7 C0 | movzx   eax, ax\n0x004962D7 | 89 45 F8 | mov     [rbp+var_8], eax\n0x004962DA | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x004962DE | 48 8D 45 F8 | lea     rax, [rbp+var_8]\n0x004962E2 | 48 89 D6 | mov     rsi, rdx\n0x004962E5 | 48 89 C7 | mov     rdi, rax\n0x004962E8 | E8 E5 FE FF FF | call    sub_4961D2\n0x004962ED | 89 45 FC | mov     [rbp+var_4], eax\n0x004962F0 | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x004962F3 | 89 C2 | mov     edx, eax\n0x004962F5 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004962F9 | 66 89 10 | mov     [rax], dx\n0x004962FC | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004962FF | C9 | leave\n0x00496300 | C3 | retn",
        "output": "\n\nstatic int check_zone_nr(uint16_t *znr, smallint *corrected)\n{\n\tint block;\n\tuint16_t cznr = *znr;\n\tuint16_t ccorrected = *corrected;\n\n\tcznr = cznr & 0x00ff;\n\tccorrected = ccorrected & 0x00ff;\n\tblock = check_zone_nr_common(&cznr, &ccorrected, corrected);\n\t*znr = cznr;\n\t*corrected = ccorrected;\n\treturn block;\n}",
        "source_code": "static int check_zone_nr(uint16_t *nr, smallint *corrected)\n{\n\tuint32_t nr32 = *nr;\n\tint r = check_zone_nr2(&nr32, corrected);\n\t*nr = (uint16_t)nr32;\n\treturn r;\n}",
        "parsed_output": "\n\nstatic int check_zone_nr(uint16_t *znr, smallint *corrected)\n{\n\tint block;\n\tuint16_t cznr = *znr;\n\tuint16_t ccorrected = *corrected;\n\n\tcznr = cznr & 0x00ff;\n\tccorrected = ccorrected & 0x00ff;\n\tblock = check_zone_nr_common(&cznr, &ccorrected, corrected);\n\t*znr = cznr;\n\t*corrected = ccorrected;\n\treturn block;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4962BD(_WORD *a1, _BYTE *a2)\n{\n  unsigned int v3; // [rsp+18h] [rbp-8h] BYREF\n  unsigned int v4; // [rsp+1Ch] [rbp-4h]\n\n  v3 = (unsigned __int16)*a1;\n  v4 = sub_4961D2(&v3, a2);\n  *a1 = v3;\n  return v4;\n}\n",
        "baseline_code_debug": "int __cdecl check_zone_nr(uint16_t *nr, smallint *corrected)\n{\n  uint32_t nr32; // [rsp+18h] [rbp-8h] BYREF\n  int r; // [rsp+1Ch] [rbp-4h]\n\n  nr32 = *nr;\n  r = check_zone_nr2(&nr32, corrected);\n  *nr = nr32;\n  return r;\n}\n",
        "similarity_score_unixcoder": 0.8560489416122437,
        "similarity_score_baseline_stripped": 0.5371667146682739,
        "similarity_score_baseline_debug": 0.9019346833229065
    },
    {
        "func_name": "check_signature16",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00453171 | 55 | push    rbp\n0x00453172 | 48 89 E5 | mov     rbp, rsp\n0x00453175 | 48 83 EC 20 | sub     rsp, 20h\n0x00453179 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0045317D | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x00453181 | 89 55 EC | mov     [rbp+var_14], edx\n0x00453184 | 83 7D EC 11 | cmp     [rbp+var_14], 11h\n0x00453188 | 75 1B | jnz     short loc_4531A5\n0x0045318A | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0045318E | BA 5E CD 52 00 | mov     edx, offset aAddress_0; \"address\"\n0x00453193 | 48 89 C6 | mov     rsi, rax\n0x00453196 | BF 68 CD 52 00 | mov     edi, offset aSMayBeInetSBut; \"\\\"%s\\\" may be inet %s, but it is not al\"...\n0x0045319B | B8 00 00 00 00 | mov     eax, 0\n0x004531A0 | E8 F9 64 FB FF | call    sub_40969E\n0x004531A5 | 8B 55 EC | mov     edx, [rbp+var_14]\n0x004531A8 | 48 8B 4D F0 | mov     rcx, [rbp+var_10]\n0x004531AC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004531B0 | 48 89 CE | mov     rsi, rcx\n0x004531B3 | 48 89 C7 | mov     rdi, rax\n0x004531B6 | E8 F0 FB FF FF | call    sub_452DAB\n0x004531BB | 85 C0 | test    eax, eax\n0x004531BD | 74 20 | jz      short loc_4531DF\n0x004531BF | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004531C3 | 48 89 C1 | mov     rcx, rax\n0x004531C6 | BA 5E CD 52 00 | mov     edx, offset aAddress_0; \"address\"\n0x004531CB | BE 2F CD 52 00 | mov     esi, offset aInet_4; \"inet\"\n0x004531D0 | BF 38 CD 52 00 | mov     edi, offset aAnSSIsExpected; \"an %s %s is expected rather than \\\"%s\\\"\"\n0x004531D5 | B8 00 00 00 00 | mov     eax, 0\n0x004531DA | E8 BF 64 FB FF | call    sub_40969E\n0x004531DF | B8 00 00 00 00 | mov     eax, 0\n0x004531E4 | C9 | leave\n0x004531E5 | C3 | retn\n\n Ourput decompiled code:\nint get_addr(inet_prefix *dst, char *arg, int family)\n{\n\tif (family == AF_PACKET) {\n\t\tbb_error_msg_and_die(\"\\\"%s\\\" may be inet %s, but it is not allowed in this context\", arg, \"address\");\n\t}\n\tif (get_addr_1(dst, arg, family)) {\n\t\tbb_error_msg_and_die(\"an %s %s is expected rather than \\\"%s\\\"\", \"inet\", \"address\", arg);\n\t}\n\treturn 0;\n}\n\n## Example:\n\n Input assembly code:\n0x0043A0F8 | 55 | push    rbp\n0x0043A0F9 | 48 89 E5 | mov     rbp, rsp\n0x0043A0FC | 48 83 EC 20 | sub     rsp, 20h\n0x0043A100 | 89 7D EC | mov     [rbp+port], edi\n0x0043A103 | 48 89 75 E0 | mov     [rbp+proto], rsi\n0x0043A107 | 89 55 E8 | mov     [rbp+var_18], edx\n0x0043A10A | 83 7D EC 00 | cmp     [rbp+port], 0\n0x0043A10E | 75 07 | jnz     short loc_43A117\n0x0043A110 | B8 0D A0 51 00 | mov     eax, offset asc_51A00D; \"*\"\n0x0043A115 | EB 42 | jmp     short locret_43A159\n0x0043A117 | 83 7D E8 00 | cmp     [rbp+var_18], 0\n0x0043A11B | 75 25 | jnz     short loc_43A142\n0x0043A11D | 48 8B 55 E0 | mov     rdx, [rbp+proto]\n0x0043A121 | 8B 45 EC | mov     eax, [rbp+port]\n0x0043A124 | 48 89 D6 | mov     rsi, rdx; proto\n0x0043A127 | 89 C7 | mov     edi, eax; port\n0x0043A129 | E8 52 DA FC FF | call    _getservbyport\n0x0043A12E | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0043A132 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0043A137 | 74 09 | jz      short loc_43A142\n0x0043A139 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0043A13D | 48 8B 00 | mov     rax, [rax]\n0x0043A140 | EB 17 | jmp     short locret_43A159\n0x0043A142 | 8B 45 EC | mov     eax, [rbp+port]\n0x0043A145 | 0F B7 C0 | movzx   eax, ax\n0x0043A148 | 89 C7 | mov     edi, eax; netshort\n0x0043A14A | E8 01 D5 FC FF | call    _ntohs\n0x0043A14F | 0F B7 C0 | movzx   eax, ax\n0x0043A152 | 89 C7 | mov     edi, eax\n0x0043A154 | E8 33 FA FC FF | call    sub_409B8C\n0x0043A159 | C9 | leave\n0x0043A15A | C3 | retn\n\n Ourput decompiled code:\nstatic const char *get_sname(int port, const char *proto, int numeric)\n{\n\tif (!port)\n\t\treturn \"*\";\n\tif (!numeric) {\n\t\tstruct servent *se = getservbyport(port, proto);\n\t\tif (se)\n\t\t\treturn se->s_name;\n\t}\n\t/* hummm, we may return static buffer here!! */\n\treturn itoa(ntohs(port));\n}\n\n## Example:\n\n Input assembly code:\n0x0045045A | 55 | push    rbp\n0x0045045B | 48 89 E5 | mov     rbp, rsp\n0x0045045E | 48 83 EC 50 | sub     rsp, 50h\n0x00450462 | 89 7D BC | mov     [rbp+var_44], edi\n0x00450465 | 48 89 75 B0 | mov     [rbp+var_50], rsi\n0x00450469 | 48 8D 55 C0 | lea     rdx, [rbp+var_40]\n0x0045046D | 8B 4D BC | mov     ecx, [rbp+var_44]\n0x00450470 | 48 8B 45 B0 | mov     rax, [rbp+var_50]\n0x00450474 | 89 CE | mov     esi, ecx\n0x00450476 | 48 89 C7 | mov     rdi, rax\n0x00450479 | E8 64 F4 FF FF | call    sub_44F8E2\n0x0045047E | 0F B6 45 E8 | movzx   eax, [rbp+var_18]\n0x00450482 | 84 C0 | test    al, al\n0x00450484 | 74 18 | jz      short loc_45049E\n0x00450486 | 0F B7 45 E6 | movzx   eax, [rbp+var_1A]\n0x0045048A | 66 85 C0 | test    ax, ax\n0x0045048D | 75 0F | jnz     short loc_45049E\n0x0045048F | BF 10 C9 52 00 | mov     edi, offset aTtl0AndNoptmud; \"ttl != 0 and noptmudisc are incompatibl\"...\n0x00450494 | B8 00 00 00 00 | mov     eax, 0\n0x00450499 | E8 00 92 FB FF | call    sub_40969E\n0x0045049E | 0F B6 45 E9 | movzx   eax, [rbp+var_17]\n0x004504A2 | 0F B6 C0 | movzx   eax, al\n0x004504A5 | 83 F8 29 | cmp     eax, 29h ; ')'\n0x004504A8 | 74 34 | jz      short loc_4504DE\n0x004504AA | 83 F8 2F | cmp     eax, 2Fh ; '/'\n0x004504AD | 74 1A | jz      short loc_4504C9\n0x004504AF | 83 F8 04 | cmp     eax, 4\n0x004504B2 | 75 3F | jnz     short loc_4504F3\n0x004504B4 | 48 8D 55 C0 | lea     rdx, [rbp+var_40]\n0x004504B8 | 8B 45 BC | mov     eax, [rbp+var_44]\n0x004504BB | BE 39 C9 52 00 | mov     esi, offset aTunl0; \"tunl0\"\n0x004504C0 | 89 C7 | mov     edi, eax\n0x004504C2 | E8 D6 F2 FF FF | call    sub_44F79D\n0x004504C7 | EB 39 | jmp     short locret_450502\n0x004504C9 | 48 8D 55 C0 | lea     rdx, [rbp+var_40]\n0x004504CD | 8B 45 BC | mov     eax, [rbp+var_44]\n0x004504D0 | BE 3F C9 52 00 | mov     esi, offset aGre0; \"gre0\"\n0x004504D5 | 89 C7 | mov     edi, eax\n0x004504D7 | E8 C1 F2 FF FF | call    sub_44F79D\n0x004504DC | EB 24 | jmp     short locret_450502\n0x004504DE | 48 8D 55 C0 | lea     rdx, [rbp+var_40]\n0x004504E2 | 8B 45 BC | mov     eax, [rbp+var_44]\n0x004504E5 | BE 44 C9 52 00 | mov     esi, offset aSit0; \"sit0\"\n0x004504EA | 89 C7 | mov     edi, eax\n0x004504EC | E8 AC F2 FF FF | call    sub_44F79D\n0x004504F1 | EB 0F | jmp     short locret_450502\n0x004504F3 | BF 50 C9 52 00 | mov     edi, offset aCanTDetermineT; \"can't determine tunnel mode (ipip, gre \"...\n0x004504F8 | B8 00 00 00 00 | mov     eax, 0\n0x004504FD | E8 9C 91 FB FF | call    sub_40969E\n0x00450502 | C9 | leave\n0x00450503 | C3 | retn\n\n Ourput decompiled code:\nstatic int do_add(int cmd, char **argv)\n{\n\tstruct ip_tunnel_parm p;\n\n\tparse_args(argv, cmd, &p);\n\n\tif (p.iph.ttl && p.iph.frag_off == 0) {\n\t\tbb_error_msg_and_die(\"ttl != 0 and noptmudisc are incompatible\");\n\t}\n\n\tswitch (p.iph.protocol) {\n\tcase IPPROTO_IPIP:\n\t\treturn do_add_ioctl(cmd, \"tunl0\", &p);\n\tcase IPPROTO_GRE:\n\t\treturn do_add_ioctl(cmd, \"gre0\", &p);\n\tcase IPPROTO_IPV6:\n\t\treturn do_add_ioctl(cmd, \"sit0\", &p);\n\tdefault:\n\t\tbb_error_msg_and_die(\"can't determine tunnel mode (ipip, gre or sit)\");\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004C30B5 | 55 | push    rbp\n0x004C30B6 | 48 89 E5 | mov     rbp, rsp\n0x004C30B9 | 48 83 EC 20 | sub     rsp, 20h\n0x004C30BD | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004C30C1 | 89 75 E4 | mov     [rbp+var_1C], esi\n0x004C30C4 | 89 55 E0 | mov     [rbp+var_20], edx\n0x004C30C7 | 48 83 7D E8 00 | cmp     [rbp+var_18], 0\n0x004C30CC | 74 49 | jz      short loc_4C3117\n0x004C30CE | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004C30D2 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004C30D5 | 84 C0 | test    al, al\n0x004C30D7 | 74 3E | jz      short loc_4C3117\n0x004C30D9 | 48 8D 4D FE | lea     rcx, [rbp+var_2]\n0x004C30DD | 8B 45 E4 | mov     eax, [rbp+var_1C]\n0x004C30E0 | BA 02 00 00 00 | mov     edx, 2\n0x004C30E5 | 48 89 CE | mov     rsi, rcx\n0x004C30E8 | 89 C7 | mov     edi, eax\n0x004C30EA | E8 57 83 F4 FF | call    sub_40B446\n0x004C30EF | 48 83 F8 02 | cmp     rax, 2\n0x004C30F3 | 75 0C | jnz     short loc_4C3101\n0x004C30F5 | 0F B7 45 FE | movzx   eax, [rbp+var_2]\n0x004C30F9 | 0F B7 C0 | movzx   eax, ax\n0x004C30FC | 39 45 E0 | cmp     [rbp+var_20], eax\n0x004C30FF | 74 16 | jz      short loc_4C3117\n0x004C3101 | BF 82 68 53 00 | mov     edi, offset aInvalidMagic_0; \"invalid magic\"\n0x004C3106 | B8 00 00 00 00 | mov     eax, 0\n0x004C310B | E8 37 66 F4 FF | call    sub_409747\n0x004C3110 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x004C3115 | EB 05 | jmp     short locret_4C311C\n0x004C3117 | B8 00 00 00 00 | mov     eax, 0\n0x004C311C | C9 | leave\n0x004C311D | C3 | retn",
        "output": "\n\nstatic int check_magic(void *p, int size, int magic)\n{\n\tstruct iphdr *iph = p;\n\tunsigned short *m;\n\n\tif (iph->tot_len == 0 || iph->protocol == 0)\n\t\treturn 0;\n\n\tm = (unsigned short *) ((char *) iph + iph->tot_len - 2);\n\tif (read_word(iph->protocol, m, 2) != 2 || *m != magic) {\n\t\tbb_error_msg_and_die(\"invalid magic\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "source_code": "int FAST_FUNC check_signature16(transformer_aux_data_t *aux, int src_fd, unsigned magic16)\n{\n\tif (aux && aux->check_signature) {\n\t\tuint16_t magic2;\n\t\tif (full_read(src_fd, &magic2, 2) != 2 || magic2 != magic16) {\n\t\t\tbb_error_msg(\"invalid magic\");\n#if 0 /* possible future extension */\n\t\t\tif (aux->check_signature > 1)\n\t\t\t\txfunc_die();\n#endif\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "parsed_output": "\n\nstatic int check_magic(void *p, int size, int magic)\n{\n\tstruct iphdr *iph = p;\n\tunsigned short *m;\n\n\tif (iph->tot_len == 0 || iph->protocol == 0)\n\t\treturn 0;\n\n\tm = (unsigned short *) ((char *) iph + iph->tot_len - 2);\n\tif (read_word(iph->protocol, m, 2) != 2 || *m != magic) {\n\t\tbb_error_msg_and_die(\"invalid magic\");\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4C30B5(_BYTE *a1, int a2, unsigned int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  unsigned __int64 v8; // [rsp+0h] [rbp-20h]\n  unsigned __int16 v9; // [rsp+1Eh] [rbp-2h] BYREF\n\n  v8 = __PAIR64__(a2, a3);\n  if ( !a1 || !*a1 || sub_40B446(a2, (char *)&v9, 2uLL) == 2 && (_DWORD)v8 == v9 )\n    return 0LL;\n  sub_409747(\"invalid magic\", (__int64)&v9, v3, v4, v5, v6, v8);\n  return 0xFFFFFFFFLL;\n}\n",
        "baseline_code_debug": "int __cdecl check_signature16(transformer_aux_data_t_0 *aux, int src_fd, unsigned int magic16)\n{\n  uint16_t magic2; // [rsp+1Eh] [rbp-2h] BYREF\n\n  if ( !aux || !aux->check_signature || full_read(src_fd, &magic2, 2uLL) == 2 && magic16 == magic2 )\n    return 0;\n  bb_error_msg(\"invalid magic\");\n  return -1;\n}\n",
        "similarity_score_unixcoder": 0.6971268653869629,
        "similarity_score_baseline_stripped": 0.5259256362915039,
        "similarity_score_baseline_debug": 0.8694804906845093
    },
    {
        "func_name": "set_pwd_var",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004B2837 | 55 | push    rbp\n0x004B2838 | 48 89 E5 | mov     rbp, rsp\n0x004B283B | 48 83 EC 10 | sub     rsp, 10h\n0x004B283F | 89 7D FC | mov     [rbp+hostlong], edi\n0x004B2842 | 8B 45 FC | mov     eax, [rbp+hostlong]\n0x004B2845 | 89 C7 | mov     edi, eax; hostlong\n0x004B2847 | E8 E4 44 F5 FF | call    _htonl\n0x004B284C | 89 45 FC | mov     [rbp+hostlong], eax\n0x004B284F | 48 8D 45 FC | lea     rax, [rbp+hostlong]\n0x004B2853 | BA 04 00 00 00 | mov     edx, 4\n0x004B2858 | 48 89 C6 | mov     rsi, rax\n0x004B285B | BF 01 00 00 00 | mov     edi, 1\n0x004B2860 | E8 46 7C F5 FF | call    sub_40A4AB\n0x004B2865 | 90 | nop\n0x004B2866 | C9 | leave\n0x004B2867 | C3 | retn\n\n Ourput decompiled code:\nstatic void write32(uint32_t v)\n{\n\tv = htonl(v);\n\txwrite(1, &v, 4);\n}\n\n## Example:\n\n Input assembly code:\n0x00429778 | 55 | push    rbp\n0x00429779 | 48 89 E5 | mov     rbp, rsp\n0x0042977C | 48 83 EC 10 | sub     rsp, 10h\n0x00429780 | 89 7D FC | mov     [rbp+var_4], edi\n0x00429783 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00429786 | BE 7C B2 52 00 | mov     esi, offset aFeatures; \"-Features:\"\n0x0042978B | 89 C7 | mov     edi, eax\n0x0042978D | E8 FC FC FF FF | call    sub_42948E\n0x00429792 | BF 88 B2 52 00 | mov     edi, offset aEpsvPasvRestSt; \" EPSV\\r\\n PASV\\r\\n REST STREAM\\r\\n MDTM\"...\n0x00429797 | E8 1C FE FF FF | call    sub_4295B8\n0x0042979C | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0042979F | BE B3 B2 52 00 | mov     esi, offset aOk; \" Ok\"\n0x004297A4 | 89 C7 | mov     edi, eax\n0x004297A6 | E8 E3 FC FF FF | call    sub_42948E\n0x004297AB | 90 | nop\n0x004297AC | C9 | leave\n0x004297AD | C3 | retn\n\n Ourput decompiled code:\nstatic void\nhandle_feat(unsigned status)\n{\n\tcmdio_write(status, \"-Features:\");\n\tcmdio_write_raw(\" EPSV\\r\\n\"\n\t\t\t\" PASV\\r\\n\"\n\t\t\t\" REST STREAM\\r\\n\"\n\t\t\t\" MDTM\\r\\n\"\n\t\t\t\" SIZE\\r\\n\");\n\tcmdio_write(status, \" Ok\");\n}\n\n## Example:\n\n Input assembly code:\n0x00490876 | 55 | push    rbp\n0x00490877 | 48 89 E5 | mov     rbp, rsp\n0x0049087A | 48 83 EC 10 | sub     rsp, 10h\n0x0049087E | 89 7D FC | mov     [rbp+var_4], edi\n0x00490881 | 48 89 75 F0 | mov     [rbp+var_10], rsi\n0x00490885 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00490888 | 89 C7 | mov     edi, eax\n0x0049088A | E8 26 FD FF FF | call    sub_4905B5\n0x0049088F | 48 8B 05 72 CB 2C 00 | mov     rax, cs:qword_75D408\n0x00490896 | 8B 40 18 | mov     eax, [rax+18h]\n0x00490899 | 89 C2 | mov     edx, eax\n0x0049089B | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0049089F | 48 89 C6 | mov     rsi, rax\n0x004908A2 | BF 03 00 00 00 | mov     edi, 3\n0x004908A7 | E8 FF 9B F7 FF | call    sub_40A4AB\n0x004908AC | 90 | nop\n0x004908AD | C9 | leave\n0x004908AE | C3 | retn\n\n Ourput decompiled code:\nstatic void\nwrite_sector(sector_t secno, const void *buf)\n{\n\tseek_sector(secno);\n\txwrite(dev_fd, buf, sector_size);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00480BCB | 55 | push    rbp\n0x00480BCC | 48 89 E5 | mov     rbp, rsp\n0x00480BCF | 48 83 EC 10 | sub     rsp, 10h\n0x00480BD3 | 89 7D FC | mov     [rbp+var_4], edi\n0x00480BD6 | BF 01 00 00 00 | mov     edi, 1\n0x00480BDB | E8 FD FA FF FF | call    sub_4806DD\n0x00480BE0 | 48 89 C6 | mov     rsi, rax\n0x00480BE3 | BF 2B E6 51 00 | mov     edi, offset aPwdS; \"PWD=%s\"\n0x00480BE8 | B8 00 00 00 00 | mov     eax, 0\n0x00480BED | E8 C1 9A F8 FF | call    sub_40A6B3\n0x00480BF2 | 48 89 C1 | mov     rcx, rax\n0x00480BF5 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x00480BF8 | BA 00 00 00 00 | mov     edx, 0\n0x00480BFD | 89 C6 | mov     esi, eax\n0x00480BFF | 48 89 CF | mov     rdi, rcx\n0x00480C02 | E8 12 FD FF FF | call    sub_480919\n0x00480C07 | 90 | nop\n0x00480C08 | C9 | leave\n0x00480C09 | C3 | retn",
        "output": "\n\nstatic void\nhandle_pwd(unsigned status)\n{\n\tchar *pwd;\n\n\tpwd = cmdio_getstr(1, \"PWD=%s\", 0);\n\tcmdio_write(status, aPwdS, pwd, NULL);\n}",
        "source_code": "static void set_pwd_var(int exp)\n{\n\tset_local_var(xasprintf(\"PWD=%s\", get_cwd(/*force:*/ 1)),\n\t\t/*exp:*/ exp, /*lvl:*/ 0, /*ro:*/ 0);\n}",
        "parsed_output": "\n\nstatic void\nhandle_pwd(unsigned status)\n{\n\tchar *pwd;\n\n\tpwd = cmdio_getstr(1, \"PWD=%s\", 0);\n\tcmdio_write(status, aPwdS, pwd, NULL);\n}",
        "baseline_code_stripped": "int __fastcall sub_480BCB(int a1)\n{\n  __int64 v1; // rax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  char *v6; // rax\n\n  v1 = sub_4806DD(1);\n  v6 = sub_40A6B3(\"PWD=%s\", v1, v2, v3, v4, v5);\n  return sub_480919(v6, a1, 0);\n}\n",
        "baseline_code_debug": "void __cdecl set_pwd_var(int exp)\n{\n  const char *cwd; // rax\n  char *v2; // rax\n\n  cwd = get_cwd(1);\n  v2 = xasprintf(\"PWD=%s\", cwd);\n  set_local_var(v2, exp, 0);\n}\n",
        "similarity_score_unixcoder": 0.7282869815826416,
        "similarity_score_baseline_stripped": 0.5741243362426758,
        "similarity_score_baseline_debug": 0.8569480776786804
    },
    {
        "func_name": "get_prefix",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00502E59 | 55 | push    rbp\n0x00502E5A | 48 89 E5 | mov     rbp, rsp\n0x00502E5D | 48 83 EC 30 | sub     rsp, 30h\n0x00502E61 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00502E65 | 48 89 75 E0 | mov     [rbp+s], rsi\n0x00502E69 | 89 55 DC | mov     [rbp+var_24], edx\n0x00502E6C | 48 89 4D D0 | mov     [rbp+var_30], rcx\n0x00502E70 | 48 C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0\n0x00502E78 | EB 61 | jmp     short loc_502EDB\n0x00502E7A | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00502E7E | 8B 00 | mov     eax, [rax]\n0x00502E80 | 23 45 DC | and     eax, [rbp+var_24]\n0x00502E83 | 85 C0 | test    eax, eax\n0x00502E85 | 74 3B | jz      short loc_502EC2\n0x00502E87 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00502E8C | 74 06 | jz      short loc_502E94\n0x00502E8E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00502E92 | EB 05 | jmp     short loc_502E99\n0x00502E94 | B8 F0 73 53 00 | mov     eax, offset unk_5373F0\n0x00502E99 | 48 8B 55 E0 | mov     rdx, [rbp+s]\n0x00502E9D | 48 89 C6 | mov     rsi, rax\n0x00502EA0 | BF F1 73 53 00 | mov     edi, offset aSS_67; \"%s%s\"\n0x00502EA5 | B8 00 00 00 00 | mov     eax, 0\n0x00502EAA | E8 21 3D F0 FF | call    _printf\n0x00502EAF | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x00502EB3 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00502EB7 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00502EBB | 8B 00 | mov     eax, [rax]\n0x00502EBD | F7 D0 | not     eax\n0x00502EBF | 21 45 DC | and     [rbp+var_24], eax\n0x00502EC2 | 48 83 45 E8 04 | add     [rbp+var_18], 4\n0x00502EC7 | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x00502ECB | 48 89 C7 | mov     rdi, rax; s\n0x00502ECE | E8 FD 3B F0 FF | call    _strlen\n0x00502ED3 | 48 83 C0 01 | add     rax, 1\n0x00502ED7 | 48 01 45 E0 | add     [rbp+s], rax\n0x00502EDB | 48 8B 45 E0 | mov     rax, [rbp+s]\n0x00502EDF | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00502EE2 | 84 C0 | test    al, al\n0x00502EE4 | 75 94 | jnz     short loc_502E7A\n0x00502EE6 | 8B 45 DC | mov     eax, [rbp+var_24]\n0x00502EE9 | C9 | leave\n0x00502EEA | C3 | retn\n\n Ourput decompiled code:\nint FAST_FUNC print_flags_separated(const int *masks, const char *labels, int flags, const char *separator)\n{\n\tconst char *need_separator = NULL;\n\twhile (*labels) {\n\t\tif (flags & *masks) {\n\t\t\tprintf(\"%s%s\",\n\t\t\t\tneed_separator ? need_separator : \"\",\n\t\t\t\tlabels);\n\t\t\tneed_separator = separator;\n\t\t\tflags &= ~ *masks;\n\t\t}\n\t\tmasks++;\n\t\tlabels += strlen(labels) + 1;\n\t}\n\treturn flags;\n}\n\n## Example:\n\n Input assembly code:\n0x0048BEA2 | 55 | push    rbp\n0x0048BEA3 | 48 89 E5 | mov     rbp, rsp\n0x0048BEA6 | 48 83 EC 30 | sub     rsp, 30h\n0x0048BEAA | 89 7D EC | mov     [rbp+var_14], edi\n0x0048BEAD | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x0048BEB1 | 48 89 55 D8 | mov     [rbp+var_28], rdx\n0x0048BEB5 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0048BEB9 | 48 8B 40 08 | mov     rax, [rax+8]\n0x0048BEBD | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0048BEC1 | 8B 45 EC | mov     eax, [rbp+var_14]\n0x0048BEC4 | 83 E0 01 | and     eax, 1\n0x0048BEC7 | 85 C0 | test    eax, eax\n0x0048BEC9 | 75 0B | jnz     short loc_48BED6\n0x0048BECB | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0048BECF | 48 8B 00 | mov     rax, [rax]\n0x0048BED2 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0048BED6 | 48 83 7D F8 FF | cmp     [rbp+var_8], 0FFFFFFFFFFFFFFFFh\n0x0048BEDB | 75 0C | jnz     short loc_48BEE9\n0x0048BEDD | BF CC F4 51 00 | mov     edi, offset aUnlimited; \"unlimited\"\n0x0048BEE2 | E8 29 A9 F7 FF | call    _puts\n0x0048BEE7 | EB 27 | jmp     short loc_48BF10\n0x0048BEE9 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x0048BEED | 0F B6 40 01 | movzx   eax, byte ptr [rax+1]\n0x0048BEF1 | 0F B6 C0 | movzx   eax, al\n0x0048BEF4 | 89 C1 | mov     ecx, eax\n0x0048BEF6 | 48 D3 6D F8 | shr     [rbp+var_8], cl\n0x0048BEFA | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048BEFE | 48 89 C6 | mov     rsi, rax\n0x0048BF01 | BF D6 F4 51 00 | mov     edi, offset aLlu_2; \"%llu\\n\"\n0x0048BF06 | B8 00 00 00 00 | mov     eax, 0\n0x0048BF0B | E8 C0 AC F7 FF | call    _printf\n0x0048BF10 | 90 | nop\n0x0048BF11 | C9 | leave\n0x0048BF12 | C3 | retn\n\n Ourput decompiled code:\nstatic void printlim(unsigned opts, const struct rlimit *limit,\n\t\t\tconst struct limits *l)\n{\n\trlim_t val;\n\n\tval = limit->rlim_max;\n\tif (!(opts & OPT_hard))\n\t\tval = limit->rlim_cur;\n\n\tif (val == RLIM_INFINITY)\n\t\tprintf(\"unlimited\\n\");\n\telse {\n\t\tval >>= l->factor_shift;\n\t\tprintf(\"%llu\\n\", (long long) val);\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x004ADC8A | 55 | push    rbp\n0x004ADC8B | 48 89 E5 | mov     rbp, rsp\n0x004ADC8E | 48 83 EC 20 | sub     rsp, 20h\n0x004ADC92 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004ADC96 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004ADC9A | F7 D8 | neg     eax\n0x004ADC9C | 83 E0 03 | and     eax, 3\n0x004ADC9F | 89 45 FC | mov     [rbp+var_4], eax\n0x004ADCA2 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x004ADCA5 | 48 98 | cdqe\n0x004ADCA7 | 48 01 45 E8 | add     [rbp+var_18], rax\n0x004ADCAB | EB 0A | jmp     short loc_4ADCB7\n0x004ADCAD | BF 00 00 00 00 | mov     edi, 0\n0x004ADCB2 | E8 A2 C9 F5 FF | call    sub_40A659\n0x004ADCB7 | 83 6D FC 01 | sub     [rbp+var_4], 1\n0x004ADCBB | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x004ADCBF | 79 EC | jns     short loc_4ADCAD\n0x004ADCC1 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004ADCC5 | C9 | leave\n0x004ADCC6 | C3 | retn\n\n Ourput decompiled code:\nif ENABLE_FEATURE_CPIO_O\nstatic off_t cpio_pad4(off_t size)\n{\n\tint i;\n\n\ti = (- size) & 3;\n\tsize += i;\n\twhile (--i >= 0)\n\t\tbb_putchar('\\0');\n\treturn size;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0043841E | 55 | push    rbp\n0x0043841F | 48 89 E5 | mov     rbp, rsp\n0x00438422 | 48 83 EC 20 | sub     rsp, 20h\n0x00438426 | 48 89 7D E8 | mov     qword ptr [rbp+hostlong], rdi\n0x0043842A | B8 00 00 00 80 | mov     eax, 80000000h\n0x0043842F | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00438433 | C7 45 F4 00 00 00 00 | mov     [rbp+var_C], 0\n0x0043843A | 48 8B 45 E8 | mov     rax, qword ptr [rbp+hostlong]\n0x0043843E | 89 C7 | mov     edi, eax; hostlong\n0x00438440 | E8 EB E8 FC FF | call    _htonl\n0x00438445 | 89 C0 | mov     eax, eax\n0x00438447 | 48 89 45 E8 | mov     qword ptr [rbp+hostlong], rax\n0x0043844B | EB 15 | jmp     short loc_438462\n0x0043844D | 48 8B 45 E8 | mov     rax, qword ptr [rbp+hostlong]\n0x00438451 | 48 23 45 F8 | and     rax, [rbp+var_8]\n0x00438455 | 48 85 C0 | test    rax, rax\n0x00438458 | 74 04 | jz      short loc_43845E\n0x0043845A | 83 45 F4 01 | add     [rbp+var_C], 1\n0x0043845E | 48 D1 6D F8 | shr     [rbp+var_8], 1\n0x00438462 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00438467 | 75 E4 | jnz     short loc_43844D\n0x00438469 | 8B 45 F4 | mov     eax, [rbp+var_C]\n0x0043846C | C9 | leave\n0x0043846D | C3 | retn",
        "output": "\n\nstatic int\nFAST_FUNC htobe32(int32_t hostlong)\n{\n\tuint32_t netlong;\n\tuint8_t c;\n\n\tnetlong = hostlong;\n\tc = 0;\n\n#if BYTE_ORDER == BIG_ENDIAN\n\treturn (netlong);\n#else\n\tnetlong = htonl(netlong);\n#endif\n\tfor (c = 0; netlong != 0; c++) {\n\t\tnetlong = netlong & (uint32_t) 0xFF00FF00U;\n\t\tnetlong = netlong >> 8;\n\t}\n\treturn (c);\n}",
        "source_code": "if ENABLE_FEATURE_IPCALC_FANCY\nstatic int get_prefix(unsigned long netmask)\n{\n\tunsigned long msk = 0x80000000;\n\tint ret = 0;\n\n\tnetmask = htonl(netmask);\n\twhile (msk) {\n\t\tif (netmask & msk)\n\t\t\tret++;\n\t\tmsk >>= 1;\n\t}\n\treturn ret;\n}",
        "parsed_output": "\n\nstatic int\nFAST_FUNC htobe32(int32_t hostlong)\n{\n\tuint32_t netlong;\n\tuint8_t c;\n\n\tnetlong = hostlong;\n\tc = 0;\n\n#if BYTE_ORDER == BIG_ENDIAN\n\treturn (netlong);\n#else\n\tnetlong = htonl(netlong);\n#endif\n\tfor (c = 0; netlong != 0; c++) {\n\t\tnetlong = netlong & (uint32_t) 0xFF00FF00U;\n\t\tnetlong = netlong >> 8;\n\t}\n\treturn (c);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_43841E(uint32_t a1)\n{\n  __int64 hostlong; // [rsp+8h] [rbp-18h]\n  unsigned int v3; // [rsp+14h] [rbp-Ch]\n  unsigned __int64 v4; // [rsp+18h] [rbp-8h]\n\n  v4 = 0x80000000LL;\n  v3 = 0;\n  hostlong = htonl(a1);\n  while ( v4 )\n  {\n    if ( (v4 & hostlong) != 0 )\n      ++v3;\n    v4 >>= 1;\n  }\n  return v3;\n}\n",
        "baseline_code_debug": "int __cdecl get_prefix(unsigned __int64 netmask)\n{\n  unsigned __int64 netmaska; // [rsp+8h] [rbp-18h]\n  int ret; // [rsp+14h] [rbp-Ch]\n  unsigned __int64 msk; // [rsp+18h] [rbp-8h]\n\n  msk = 0x80000000LL;\n  ret = 0;\n  netmaska = htonl(netmask);\n  while ( msk )\n  {\n    if ( (msk & netmaska) != 0 )\n      ++ret;\n    msk >>= 1;\n  }\n  return ret;\n}\n",
        "similarity_score_unixcoder": 0.5707613229751587,
        "similarity_score_baseline_stripped": 0.4614025354385376,
        "similarity_score_baseline_debug": 0.776064932346344
    },
    {
        "func_name": "invalid_name",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0048B130 | 55 | push    rbp\n0x0048B131 | 48 89 E5 | mov     rbp, rsp\n0x0048B134 | 48 83 EC 08 | sub     rsp, 8\n0x0048B138 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0048B13C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B140 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0048B143 | 3C 5F | cmp     al, 5Fh ; '_'\n0x0048B145 | 74 37 | jz      short loc_48B17E\n0x0048B147 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B14B | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0048B14E | 83 C8 20 | or      eax, 20h\n0x0048B151 | 83 E8 61 | sub     eax, 61h ; 'a'\n0x0048B154 | 3C 19 | cmp     al, 19h\n0x0048B156 | 76 26 | jbe     short loc_48B17E\n0x0048B158 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B15C | EB 37 | jmp     short locret_48B195\n0x0048B15E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B162 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0048B165 | 3C 5F | cmp     al, 5Fh ; '_'\n0x0048B167 | 74 15 | jz      short loc_48B17E\n0x0048B169 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B16D | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0048B170 | 0F B6 C0 | movzx   eax, al\n0x0048B173 | 89 C7 | mov     edi, eax\n0x0048B175 | E8 45 F9 FF FF | call    sub_48AABF\n0x0048B17A | 85 C0 | test    eax, eax\n0x0048B17C | 74 12 | jz      short loc_48B190\n0x0048B17E | 48 83 45 F8 01 | add     [rbp+var_8], 1\n0x0048B183 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B187 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0048B18A | 84 C0 | test    al, al\n0x0048B18C | 75 D0 | jnz     short loc_48B15E\n0x0048B18E | EB 01 | jmp     short loc_48B191\n0x0048B190 | 90 | nop\n0x0048B191 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0048B195 | C9 | leave\n0x0048B196 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC\nendofname(const char *name)\n{\n\tif (!is_name(*name))\n\t\treturn name;\n\twhile (*++name) {\n\t\tif (!is_in_name(*name))\n\t\t\tbreak;\n\t}\n\treturn name;\n}\n\n## Example:\n\n Input assembly code:\n0x0041153F | 55 | push    rbp\n0x00411540 | 48 89 E5 | mov     rbp, rsp\n0x00411543 | 48 83 EC 18 | sub     rsp, 18h\n0x00411547 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0041154B | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0041154F | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00411553 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00411557 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x0041155B | EB 5B | jmp     short loc_4115B8\n0x0041155D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00411561 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00411564 | 0F B6 C0 | movzx   eax, al\n0x00411567 | 89 C7 | mov     edi, eax\n0x00411569 | E8 00 FE FF FF | call    sub_41136E\n0x0041156E | 85 C0 | test    eax, eax\n0x00411570 | 75 2C | jnz     short loc_41159E\n0x00411572 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00411576 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00411579 | 3C 5F | cmp     al, 5Fh ; '_'\n0x0041157B | 74 21 | jz      short loc_41159E\n0x0041157D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00411581 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00411584 | 3C 2D | cmp     al, 2Dh ; '-'\n0x00411586 | 74 16 | jz      short loc_41159E\n0x00411588 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0041158C | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0041158F | 3C 2E | cmp     al, 2Eh ; '.'\n0x00411591 | 74 0B | jz      short loc_41159E\n0x00411593 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00411597 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0041159A | 3C 40 | cmp     al, 40h ; '@'\n0x0041159C | 75 15 | jnz     short loc_4115B3\n0x0041159E | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004115A2 | 48 8D 50 01 | lea     rdx, [rax+1]\n0x004115A6 | 48 89 55 F0 | mov     [rbp+var_10], rdx\n0x004115AA | 48 8B 55 F8 | mov     rdx, [rbp+var_8]\n0x004115AE | 0F B6 12 | movzx   edx, byte ptr [rdx]\n0x004115B1 | 88 10 | mov     [rax], dl\n0x004115B3 | 48 83 45 F8 01 | add     [rbp+var_8], 1\n0x004115B8 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004115BC | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004115BF | 84 C0 | test    al, al\n0x004115C1 | 75 9A | jnz     short loc_41155D\n0x004115C3 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004115C7 | C6 00 00 | mov     byte ptr [rax], 0\n0x004115CA | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004115CE | C9 | leave\n0x004115CF | C3 | retn\n\n Ourput decompiled code:\nstrip argument of bad chars\nstatic char *sane_address(char *str)\n{\n\tchar *s = str;\n\tchar *p = s;\n\twhile (*s) {\n\t\tif (isalnum(*s) || '_' == *s || '-' == *s || '.' == *s || '@' == *s) {\n\t\t\t*p++ = *s;\n\t\t}\n\t\ts++;\n\t}\n\t*p = '\\0';\n\treturn str;\n}\n\n## Example:\n\n Input assembly code:\n0x00453547 | 55 | push    rbp\n0x00453548 | 48 89 E5 | mov     rbp, rsp\n0x0045354B | 48 83 EC 08 | sub     rsp, 8\n0x0045354F | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x00453553 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00453557 | 48 89 C7 | mov     rdi, rax\n0x0045355A | E8 6E FF FF FF | call    sub_4534CD\n0x0045355F | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00453563 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00453568 | 75 07 | jnz     short loc_453571\n0x0045356A | B8 00 00 00 00 | mov     eax, 0\n0x0045356F | EB 19 | jmp     short locret_45358A\n0x00453571 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00453575 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00453578 | 84 C0 | test    al, al\n0x0045357A | 75 07 | jnz     short loc_453583\n0x0045357C | B8 01 00 00 00 | mov     eax, 1\n0x00453581 | EB 07 | jmp     short locret_45358A\n0x00453583 | 48 83 45 F8 01 | add     [rbp+var_8], 1\n0x00453588 | EB C9 | jmp     short loc_453553\n0x0045358A | C9 | leave\n0x0045358B | C3 | retn\n\n Ourput decompiled code:\nstatic int good_hostname(const char *name)\n{\n\t//const char *start = name;\n\n\tfor (;;) {\n\t\tname = valid_domain_label(name);\n\t\tif (!name)\n\t\t\treturn 0;\n\t\tif (!name[0])\n\t\t\treturn 1;\n\t\t\t//Do we want this?\n\t\t\t//return ((name - start) < 1025); /* NS_MAXDNAME */\n\t\tname++;\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004D8EBD | 55 | push    rbp\n0x004D8EBE | 48 89 E5 | mov     rbp, rsp\n0x004D8EC1 | 48 83 EC 10 | sub     rsp, 10h\n0x004D8EC5 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004D8EC9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004D8ECD | 48 89 C7 | mov     rdi, rax\n0x004D8ED0 | E8 BF FF F2 FF | call    sub_408E94\n0x004D8ED5 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004D8ED9 | EB 05 | jmp     short loc_4D8EE0\n0x004D8EDB | 48 83 45 F8 01 | add     [rbp+var_8], 1\n0x004D8EE0 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004D8EE4 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004D8EE7 | 84 C0 | test    al, al\n0x004D8EE9 | 74 2B | jz      short loc_4D8F16\n0x004D8EEB | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004D8EEF | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004D8EF2 | 0F B6 C0 | movzx   eax, al\n0x004D8EF5 | 89 C7 | mov     edi, eax\n0x004D8EF7 | E8 83 FF FF FF | call    sub_4D8E7F\n0x004D8EFC | 85 C0 | test    eax, eax\n0x004D8EFE | 75 DB | jnz     short loc_4D8EDB\n0x004D8F00 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004D8F04 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004D8F07 | 3C 5F | cmp     al, 5Fh ; '_'\n0x004D8F09 | 74 D0 | jz      short loc_4D8EDB\n0x004D8F0B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004D8F0F | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004D8F12 | 3C 2D | cmp     al, 2Dh ; '-'\n0x004D8F14 | 74 C5 | jz      short loc_4D8EDB\n0x004D8F16 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004D8F1A | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004D8F1D | 84 C0 | test    al, al\n0x004D8F1F | 0F 95 C0 | setnz   al\n0x004D8F22 | C9 | leave\n0x004D8F23 | C3 | retn",
        "output": "\n\nstatic int good_hostname(const char *name)\n{\n\tconst char *s = name;\n\n\tfor (;;) {\n\t\ts = valid_domain_label(s);\n\t\tif (!s)\n\t\t\treturn 0;\n\t\twhile (*s) {\n\t\t\tif (!isalnum(*s) && *s != '_' && *s != '-')\n\t\t\t\treturn 0;\n\t\t\ts++;\n\t\t}\n\t\tif (!*s)\n\t\t\treturn 1;\n\t\ts++;\n\t}\n}",
        "source_code": "static bool invalid_name(const char *c)\n{\n\tc = bb_basename(c);\n\n\twhile (*c && (isalnum(*c) || *c == '_' || *c == '-'))\n\t\tc++;\n\n\treturn *c; /* TRUE (!0) if terminating NUL is not reached */\n}",
        "parsed_output": "\n\nstatic int good_hostname(const char *name)\n{\n\tconst char *s = name;\n\n\tfor (;;) {\n\t\ts = valid_domain_label(s);\n\t\tif (!s)\n\t\t\treturn 0;\n\t\twhile (*s) {\n\t\t\tif (!isalnum(*s) && *s != '_' && *s != '-')\n\t\t\t\treturn 0;\n\t\t\ts++;\n\t\t}\n\t\tif (!*s)\n\t\t\treturn 1;\n\t\ts++;\n\t}\n}",
        "baseline_code_stripped": "bool __fastcall sub_4D8EBD(const char *a1)\n{\n  const char *i; // [rsp+8h] [rbp-8h]\n\n  for ( i = sub_408E94(a1); *i && (sub_4D8E7F(*i) || *i == 95 || *i == 45); ++i )\n    ;\n  return *i != 0;\n}\n",
        "baseline_code_debug": "bool __cdecl invalid_name(const char *c)\n{\n  unsigned __int8 *ca; // [rsp+8h] [rbp-8h]\n\n  for ( ca = (unsigned __int8 *)bb_basename(c); *ca && (bb_ascii_isalnum_12(*ca) || *ca == 95 || *ca == 45); ++ca )\n    ;\n  return *ca != 0;\n}\n",
        "similarity_score_unixcoder": 0.7678402662277222,
        "similarity_score_baseline_stripped": 0.4820033013820648,
        "similarity_score_baseline_debug": 0.7663618922233582
    },
    {
        "func_name": "get_u16",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00452C74 | 55 | push    rbp\n0x00452C75 | 48 89 E5 | mov     rbp, rsp\n0x00452C78 | 48 83 EC 20 | sub     rsp, 20h\n0x00452C7C | 48 89 7D E8 | mov     [rbp+nptr], rdi\n0x00452C80 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00452C84 | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x00452C88 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00452C8B | 84 C0 | test    al, al\n0x00452C8D | 74 38 | jz      short loc_452CC7\n0x00452C8F | 48 8D 4D F0 | lea     rcx, [rbp+endptr]\n0x00452C93 | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x00452C97 | BA 00 00 00 00 | mov     edx, 0; base\n0x00452C9C | 48 89 CE | mov     rsi, rcx; endptr\n0x00452C9F | 48 89 C7 | mov     rdi, rax; nptr\n0x00452CA2 | E8 B9 4C FB FF | call    _strtoul\n0x00452CA7 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00452CAB | 48 8B 45 F0 | mov     rax, [rbp+endptr]\n0x00452CAF | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00452CB2 | 84 C0 | test    al, al\n0x00452CB4 | 75 11 | jnz     short loc_452CC7\n0x00452CB6 | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x00452CBB | 48 39 45 F8 | cmp     [rbp+var_8], rax\n0x00452CBF | 77 06 | ja      short loc_452CC7\n0x00452CC1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00452CC5 | EB 13 | jmp     short locret_452CDA\n0x00452CC7 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00452CCB | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x00452CCF | 48 89 D6 | mov     rsi, rdx\n0x00452CD2 | 48 89 C7 | mov     rdi, rax\n0x00452CD5 | E8 B9 05 00 00 | call    sub_453293\n0x00452CDA | C9 | leave\n0x00452CDB | C3 | retn\n\n Ourput decompiled code:\nunsigned get_unsigned(char *arg, const char *errmsg)\n{\n\tunsigned long res;\n\tchar *ptr;\n\n\tif (*arg) {\n\t\tres = strtoul(arg, &ptr, 0);\n//FIXME: \"\" will be accepted too, is it correct?!\n\t\tif (!*ptr && res <= UINT_MAX) {\n\t\t\treturn res;\n\t\t}\n\t}\n\tinvarg(arg, errmsg); /* does not return */\n}\n\n## Example:\n\n Input assembly code:\n0x00452CDC | 55 | push    rbp\n0x00452CDD | 48 89 E5 | mov     rbp, rsp\n0x00452CE0 | 48 83 EC 20 | sub     rsp, 20h\n0x00452CE4 | 48 89 7D E8 | mov     [rbp+nptr], rdi\n0x00452CE8 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00452CEC | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x00452CF0 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00452CF3 | 84 C0 | test    al, al\n0x00452CF5 | 74 38 | jz      short loc_452D2F\n0x00452CF7 | 48 8D 4D F0 | lea     rcx, [rbp+endptr]\n0x00452CFB | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x00452CFF | BA 00 00 00 00 | mov     edx, 0; base\n0x00452D04 | 48 89 CE | mov     rsi, rcx; endptr\n0x00452D07 | 48 89 C7 | mov     rdi, rax; nptr\n0x00452D0A | E8 51 4C FB FF | call    _strtoul\n0x00452D0F | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00452D13 | 48 8B 45 F0 | mov     rax, [rbp+endptr]\n0x00452D17 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00452D1A | 84 C0 | test    al, al\n0x00452D1C | 75 11 | jnz     short loc_452D2F\n0x00452D1E | B8 FF FF FF FF | mov     eax, 0FFFFFFFFh\n0x00452D23 | 48 39 45 F8 | cmp     [rbp+var_8], rax\n0x00452D27 | 77 06 | ja      short loc_452D2F\n0x00452D29 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00452D2D | EB 13 | jmp     short locret_452D42\n0x00452D2F | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00452D33 | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x00452D37 | 48 89 D6 | mov     rsi, rdx\n0x00452D3A | 48 89 C7 | mov     rdi, rax\n0x00452D3D | E8 51 05 00 00 | call    sub_453293\n0x00452D42 | C9 | leave\n0x00452D43 | C3 | retn\n\n Ourput decompiled code:\nuint32_t get_u32(char *arg, const char *errmsg)\n{\n\tunsigned long res;\n\tchar *ptr;\n\n\tif (*arg) {\n\t\tres = strtoul(arg, &ptr, 0);\n//FIXME: \"\" will be accepted too, is it correct?!\n\t\tif (!*ptr && res <= 0xFFFFFFFFUL) {\n\t\t\treturn res;\n\t\t}\n\t}\n\tinvarg(arg, errmsg); /* does not return */\n}\n\n## Example:\n\n Input assembly code:\n0x00508790 | 55 | push    rbp\n0x00508791 | 48 89 E5 | mov     rbp, rsp\n0x00508794 | 48 83 EC 20 | sub     rsp, 20h\n0x00508798 | 48 89 7D E8 | mov     [rbp+s], rdi\n0x0050879C | 48 89 75 E0 | mov     [rbp+needle], rsi\n0x005087A0 | 48 C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0\n0x005087A8 | 48 8B 45 E0 | mov     rax, [rbp+needle]\n0x005087AC | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x005087AF | 84 C0 | test    al, al\n0x005087B1 | 75 18 | jnz     short loc_5087CB\n0x005087B3 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x005087B7 | 48 89 C7 | mov     rdi, rax; s\n0x005087BA | E8 11 E3 EF FF | call    _strlen\n0x005087BF | 48 89 C2 | mov     rdx, rax\n0x005087C2 | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x005087C6 | 48 01 D0 | add     rax, rdx\n0x005087C9 | EB 3A | jmp     short locret_508805\n0x005087CB | 48 8B 55 E0 | mov     rdx, [rbp+needle]\n0x005087CF | 48 8B 45 E8 | mov     rax, [rbp+s]\n0x005087D3 | 48 89 D6 | mov     rsi, rdx; needle\n0x005087D6 | 48 89 C7 | mov     rdi, rax; haystack\n0x005087D9 | E8 E2 F4 EF FF | call    _strstr\n0x005087DE | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x005087E2 | 48 83 7D F0 00 | cmp     [rbp+var_10], 0\n0x005087E7 | 75 06 | jnz     short loc_5087EF\n0x005087E9 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x005087ED | EB 16 | jmp     short locret_508805\n0x005087EF | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x005087F3 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x005087F7 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x005087FB | 48 83 C0 01 | add     rax, 1\n0x005087FF | 48 89 45 E8 | mov     [rbp+s], rax\n0x00508803 | EB C6 | jmp     short loc_5087CB\n0x00508805 | C9 | leave\n0x00508806 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC strrstr(const char *haystack, const char *needle)\n{\n\tchar *r = NULL;\n\n\tif (!needle[0])\n\t\treturn (char*)haystack + strlen(haystack);\n\twhile (1) {\n\t\tchar *p = strstr(haystack, needle);\n\t\tif (!p)\n\t\t\treturn r;\n\t\tr = p;\n\t\thaystack = p + 1;\n\t}\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00452D44 | 55 | push    rbp\n0x00452D45 | 48 89 E5 | mov     rbp, rsp\n0x00452D48 | 48 83 EC 20 | sub     rsp, 20h\n0x00452D4C | 48 89 7D E8 | mov     [rbp+nptr], rdi\n0x00452D50 | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00452D54 | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x00452D58 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00452D5B | 84 C0 | test    al, al\n0x00452D5D | 74 37 | jz      short loc_452D96\n0x00452D5F | 48 8D 4D F0 | lea     rcx, [rbp+endptr]\n0x00452D63 | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x00452D67 | BA 00 00 00 00 | mov     edx, 0; base\n0x00452D6C | 48 89 CE | mov     rsi, rcx; endptr\n0x00452D6F | 48 89 C7 | mov     rdi, rax; nptr\n0x00452D72 | E8 E9 4B FB FF | call    _strtoul\n0x00452D77 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00452D7B | 48 8B 45 F0 | mov     rax, [rbp+endptr]\n0x00452D7F | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00452D82 | 84 C0 | test    al, al\n0x00452D84 | 75 10 | jnz     short loc_452D96\n0x00452D86 | 48 81 7D F8 FF FF 00 00 | cmp     [rbp+var_8], 0FFFFh\n0x00452D8E | 77 06 | ja      short loc_452D96\n0x00452D90 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00452D94 | EB 13 | jmp     short locret_452DA9\n0x00452D96 | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00452D9A | 48 8B 45 E8 | mov     rax, [rbp+nptr]\n0x00452D9E | 48 89 D6 | mov     rsi, rdx\n0x00452DA1 | 48 89 C7 | mov     rdi, rax\n0x00452DA4 | E8 EA 04 00 00 | call    sub_453293\n0x00452DA9 | C9 | leave\n0x00452DAA | C3 | retn",
        "output": "\n\n Ourput decompiled code:\nuint16_t get_u16(char *arg, const char *errmsg)\n{\n\tunsigned long res;\n\tchar *ptr;\n\n\tif (*arg) {\n\t\tres = strtoul(arg, &ptr, 0);\n//FIXME: \"\" will be accepted too, is it correct?!\n\t\tif (!*ptr && res <= 0xFFFFUL) {\n\t\t\treturn res;\n\t\t}\n\t}\n\tinvarg(arg, errmsg); /* does not return */\n}",
        "source_code": "uint16_t get_u16(char *arg, const char *errmsg)\n{\n\tunsigned long res;\n\tchar *ptr;\n\n\tif (*arg) {\n\t\tres = strtoul(arg, &ptr, 0);\n//FIXME: \"\" will be accepted too, is it correct?!\n\t\tif (!*ptr && res <= 0xFFFF) {\n\t\t\treturn res;\n\t\t}\n\t}\n\tinvarg(arg, errmsg); /* does not return */\n}",
        "parsed_output": "\n\n Ourput decompiled code:\nuint16_t get_u16(char *arg, const char *errmsg)\n{\n\tunsigned long res;\n\tchar *ptr;\n\n\tif (*arg) {\n\t\tres = strtoul(arg, &ptr, 0);\n//FIXME: \"\" will be accepted too, is it correct?!\n\t\tif (!*ptr && res <= 0xFFFFUL) {\n\t\t\treturn res;\n\t\t}\n\t}\n\tinvarg(arg, errmsg); /* does not return */\n}",
        "baseline_code_stripped": "unsigned __int64 __fastcall sub_452D44(const char *a1, __int64 a2)\n{\n  char *endptr; // [rsp+10h] [rbp-10h] BYREF\n  unsigned __int64 v4; // [rsp+18h] [rbp-8h]\n\n  if ( !*a1 || (v4 = strtoul(a1, &endptr, 0), *endptr) || v4 > 0xFFFF )\n    sub_453293(a1, a2);\n  return v4;\n}\n",
        "baseline_code_debug": "uint16_t __cdecl get_u16(char *arg, const char *errmsg)\n{\n  char *ptr; // [rsp+10h] [rbp-10h] BYREF\n  unsigned __int64 res; // [rsp+18h] [rbp-8h]\n\n  if ( !*arg || (res = strtoul(arg, &ptr, 0), *ptr) || res > 0xFFFF )\n    invarg(arg, errmsg);\n  return res;\n}\n",
        "similarity_score_unixcoder": 0.9575338959693909,
        "similarity_score_baseline_stripped": 0.5988190770149231,
        "similarity_score_baseline_debug": 0.7909490466117859
    },
    {
        "func_name": "query_loop",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x00503388 | 55 | push    rbp\n0x00503389 | 48 89 E5 | mov     rbp, rsp\n0x0050338C | 48 83 EC 20 | sub     rsp, 20h\n0x00503390 | 48 89 7D E8 | mov     [rbp+file], rdi\n0x00503394 | 48 89 75 E0 | mov     [rbp+buf], rsi\n0x00503398 | 48 C7 45 F8 FF FF FF FF | mov     [rbp+var_8], 0FFFFFFFFFFFFFFFFh\n0x005033A0 | 48 8B 45 E8 | mov     rax, [rbp+file]\n0x005033A4 | BE 00 00 00 00 | mov     esi, 0; oflag\n0x005033A9 | 48 89 C7 | mov     rdi, rax; file\n0x005033AC | B8 00 00 00 00 | mov     eax, 0\n0x005033B1 | E8 1A 43 F0 FF | call    _open64\n0x005033B6 | 89 45 F4 | mov     [rbp+fd], eax\n0x005033B9 | 83 7D F4 00 | cmp     [rbp+fd], 0\n0x005033BD | 78 24 | js      short loc_5033E3\n0x005033BF | 48 8B 4D E0 | mov     rcx, [rbp+buf]\n0x005033C3 | 8B 45 F4 | mov     eax, [rbp+fd]\n0x005033C6 | BA FF 03 00 00 | mov     edx, 3FFh; nbytes\n0x005033CB | 48 89 CE | mov     rsi, rcx; buf\n0x005033CE | 89 C7 | mov     edi, eax; fd\n0x005033D0 | E8 6B 3B F0 FF | call    _read\n0x005033D5 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x005033D9 | 8B 45 F4 | mov     eax, [rbp+fd]\n0x005033DC | 89 C7 | mov     edi, eax; fd\n0x005033DE | E8 2D 3A F0 FF | call    _close\n0x005033E3 | B8 00 00 00 00 | mov     eax, 0\n0x005033E8 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x005033ED | 48 0F 49 45 F8 | cmovns  rax, [rbp+var_8]\n0x005033F2 | 48 89 C2 | mov     rdx, rax\n0x005033F5 | 48 8B 45 E0 | mov     rax, [rbp+buf]\n0x005033F9 | 48 01 D0 | add     rax, rdx\n0x005033FC | C6 00 00 | mov     byte ptr [rax], 0\n0x005033FF | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00503403 | C9 | leave\n0x00503404 | C3 | retn\n\n Ourput decompiled code:\ndefine PROCPS_BUFSIZE 1024\n\nstatic int read_to_buf(const char *filename, void *buf)\n{\n\tint fd;\n\t/* open_read_close() would do two reads, checking for EOF.\n\t * When you have 10000 /proc/$NUM/stat to read, it isn't desirable */\n\tssize_t ret = -1;\n\tfd = open(filename, O_RDONLY);\n\tif (fd >= 0) {\n\t\tret = read(fd, buf, PROCPS_BUFSIZE-1);\n\t\tclose(fd);\n\t}\n\t((char *)buf)[ret > 0 ? ret : 0] = '\\0';\n\treturn ret;\n}\n\n## Example:\n\n Input assembly code:\n0x004178BF | 55 | push    rbp\n0x004178C0 | 48 89 E5 | mov     rbp, rsp\n0x004178C3 | 48 83 EC 30 | sub     rsp, 30h\n0x004178C7 | 48 89 7D D8 | mov     [rbp+var_28], rdi\n0x004178CB | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x004178CF | BE F5 A7 50 00 | mov     esi, offset sub_50A7F5\n0x004178D4 | 48 89 C7 | mov     rdi, rax\n0x004178D7 | E8 74 AB 0E 00 | call    sub_502450\n0x004178DC | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004178E0 | EB 5F | jmp     short loc_417941\n0x004178E2 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004178E6 | 48 89 C7 | mov     rdi, rax\n0x004178E9 | E8 18 3A 0F 00 | call    sub_50B306\n0x004178EE | 89 45 F4 | mov     [rbp+var_C], eax\n0x004178F1 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x004178F5 | 48 89 C6 | mov     rsi, rax\n0x004178F8 | BF AD 55 53 00 | mov     edi, offset aBarWidth; \"BAR_WIDTH\"\n0x004178FD | E8 64 ED 0D 00 | call    sub_4F6666\n0x00417902 | 89 45 F0 | mov     [rbp+var_10], eax\n0x00417905 | 83 7D F0 00 | cmp     [rbp+var_10], 0\n0x00417909 | 79 16 | jns     short loc_417921\n0x0041790B | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0041790F | 48 89 C6 | mov     rsi, rax\n0x00417912 | BF 73 55 53 00 | mov     edi, offset aSyntaxErrorS; \"syntax error: %s\"\n0x00417917 | B8 00 00 00 00 | mov     eax, 0\n0x0041791C | E8 7D 1D FF FF | call    sub_40969E\n0x00417921 | 83 7D F0 00 | cmp     [rbp+var_10], 0\n0x00417925 | 78 1A | js      short loc_417941\n0x00417927 | 83 7D F0 06 | cmp     [rbp+var_10], 6\n0x0041792B | 7F 14 | jg      short loc_417941\n0x0041792D | 48 8B 05 D4 5A 34 00 | mov     rax, cs:qword_75D408\n0x00417934 | 8B 55 F0 | mov     edx, [rbp+var_10]\n0x00417937 | 48 63 D2 | movsxd  rdx, edx\n0x0041793A | 8B 4D F4 | mov     ecx, [rbp+var_C]\n0x0041793D | 89 4C 90 08 | mov     [rax+rdx*4+8], ecx\n0x00417941 | 48 8D 75 E0 | lea     rsi, [rbp+var_20]\n0x00417945 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00417949 | B9 84 55 53 00 | mov     ecx, offset asc_535584; \"#=\"\n0x0041794E | BA 02 02 54 00 | mov     edx, offset unk_540202\n0x00417953 | 48 89 C7 | mov     rdi, rax\n0x00417956 | E8 40 AD 0E 00 | call    sub_50269B\n0x0041795B | 85 C0 | test    eax, eax\n0x0041795D | 75 83 | jnz     short loc_4178E2\n0x0041795F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00417963 | 48 89 C7 | mov     rdi, rax\n0x00417966 | E8 52 AB 0E 00 | call    sub_5024BD\n0x0041796B | 90 | nop\n0x0041796C | C9 | leave\n0x0041796D | C3 | retn\n\n Ourput decompiled code:\nstatic void init(const char *cfg_filename)\n{\n\tstatic const char param_names[] ALIGN1 =\n\t\t\"BAR_WIDTH\\0\" \"BAR_HEIGHT\\0\"\n\t\t\"BAR_LEFT\\0\" \"BAR_TOP\\0\"\n\t\t\"BAR_R\\0\" \"BAR_G\\0\" \"BAR_B\\0\"\n#if DEBUG\n\t\t\"DEBUG\\0\"\n#endif\n\t\t;\n\tchar *token[2];\n\tparser_t *parser = config_open2(cfg_filename, xfopen_stdin);\n\twhile (config_read(parser, token, 2, 2, \"#=\",\n\t\t\t\t(PARSE_NORMAL | PARSE_MIN_DIE) & ~(PARSE_TRIM | PARSE_COLLAPSE))) {\n\t\tunsigned val = xatoi_positive(token[1]);\n\t\tint i = index_in_strings(param_names, token[0]);\n\t\tif (i < 0)\n\t\t\tbb_error_msg_and_die(\"syntax error: %s\", token[0]);\n\t\tif (i >= 0 && i < 7)\n\t\t\tG.ns[i] = val;\n#if DEBUG\n\t\tif (i == 7) {\n\t\t\tG.bdebug_messages = val;\n\t\t\tif (G.bdebug_messages)\n\t\t\t\tG.logfile_fd = xfopen_for_write(\"/tmp/fbsplash.log\");\n\t\t}\n#endif\n\t}\n\tconfig_close(parser);\n}\n\n## Example:\n\n Input assembly code:\n0x0049F475 | 55 | push    rbp\n0x0049F476 | 48 89 E5 | mov     rbp, rsp\n0x0049F479 | 48 83 EC 20 | sub     rsp, 20h\n0x0049F47D | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0049F481 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0049F485 | BE 02 00 00 00 | mov     esi, 2\n0x0049F48A | 48 89 C7 | mov     rdi, rax\n0x0049F48D | E8 03 AE F6 FF | call    sub_40A295\n0x0049F492 | 89 45 FC | mov     [rbp+fd], eax\n0x0049F495 | 48 8D 55 F0 | lea     rdx, [rbp+var_10]\n0x0049F499 | 8B 45 FC | mov     eax, [rbp+fd]\n0x0049F49C | BE 60 12 00 00 | mov     esi, 1260h; request\n0x0049F4A1 | 89 C7 | mov     edi, eax; fd\n0x0049F4A3 | B8 00 00 00 00 | mov     eax, 0\n0x0049F4A8 | E8 F3 78 F6 FF | call    _ioctl\n0x0049F4AD | 85 C0 | test    eax, eax\n0x0049F4AF | 78 13 | js      short loc_49F4C4\n0x0049F4B1 | 8B 45 FC | mov     eax, [rbp+fd]\n0x0049F4B4 | 89 C7 | mov     edi, eax; fd\n0x0049F4B6 | E8 55 79 F6 FF | call    _close\n0x0049F4BB | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0049F4BF | C1 E0 09 | shl     eax, 9\n0x0049F4C2 | EB 1E | jmp     short locret_49F4E2\n0x0049F4C4 | 8B 45 FC | mov     eax, [rbp+fd]\n0x0049F4C7 | 89 C7 | mov     edi, eax\n0x0049F4C9 | E8 15 FF FF FF | call    sub_49F3E3\n0x0049F4CE | 48 98 | cdqe\n0x0049F4D0 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x0049F4D4 | 8B 45 FC | mov     eax, [rbp+fd]\n0x0049F4D7 | 89 C7 | mov     edi, eax; fd\n0x0049F4D9 | E8 32 79 F6 FF | call    _close\n0x0049F4DE | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0049F4E2 | C9 | leave\n0x0049F4E3 | C3 | retn\n\n Ourput decompiled code:\nstatic int get_size(const char *file)\n{\n\tint fd;\n\tlong size;\n\n\tfd = xopen(file, O_RDWR);\n\tif (ioctl(fd, BLKGETSIZE, &size) >= 0) {\n\t\tclose(fd);\n\t\treturn (size * 512);\n\t}\n\n\tsize = count_blocks(fd);\n\tclose(fd);\n\treturn size;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00501875 | 55 | push    rbp\n0x00501876 | 48 89 E5 | mov     rbp, rsp\n0x00501879 | 48 81 EC 10 01 00 00 | sub     rsp, 110h\n0x00501880 | 48 89 BD F8 FE FF FF | mov     [rbp+file], rdi\n0x00501887 | 48 C7 45 F8 00 00 00 00 | mov     [rbp+var_8], 0\n0x0050188F | 48 8B 85 F8 FE FF FF | mov     rax, [rbp+file]\n0x00501896 | BE 00 00 00 00 | mov     esi, 0; oflag\n0x0050189B | 48 89 C7 | mov     rdi, rax; file\n0x0050189E | B8 00 00 00 00 | mov     eax, 0\n0x005018A3 | E8 28 5E F0 FF | call    _open64\n0x005018A8 | 89 45 F4 | mov     [rbp+fd], eax\n0x005018AB | 83 7D F4 00 | cmp     [rbp+fd], 0\n0x005018AF | 78 57 | js      short loc_501908\n0x005018B1 | 48 8D 95 00 FF FF FF | lea     rdx, [rbp+var_100]\n0x005018B8 | 8B 45 F4 | mov     eax, [rbp+fd]\n0x005018BB | BE 05 4C 00 00 | mov     esi, 4C05h; request\n0x005018C0 | 89 C7 | mov     edi, eax; fd\n0x005018C2 | B8 00 00 00 00 | mov     eax, 0\n0x005018C7 | E8 D4 54 F0 FF | call    _ioctl\n0x005018CC | 85 C0 | test    eax, eax\n0x005018CE | 75 2E | jnz     short loc_5018FE\n0x005018D0 | 48 8B 85 18 FF FF FF | mov     rax, [rbp+var_E8]\n0x005018D7 | 48 89 C1 | mov     rcx, rax\n0x005018DA | 48 8D 85 00 FF FF FF | lea     rax, [rbp+var_100]\n0x005018E1 | 48 83 C0 38 | add     rax, 38h ; '8'\n0x005018E5 | 48 89 C2 | mov     rdx, rax\n0x005018E8 | 48 89 CE | mov     rsi, rcx\n0x005018EB | BF 19 73 53 00 | mov     edi, offset aLuS; \"%lu %s\"\n0x005018F0 | B8 00 00 00 00 | mov     eax, 0\n0x005018F5 | E8 B9 8D F0 FF | call    sub_40A6B3\n0x005018FA | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x005018FE | 8B 45 F4 | mov     eax, [rbp+fd]\n0x00501901 | 89 C7 | mov     edi, eax; fd\n0x00501903 | E8 08 55 F0 FF | call    _close\n0x00501908 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0050190C | C9 | leave\n0x0050190D | C3 | retn",
        "output": "\n\nstatic char *get_size_str(const char *file)\n{\n\tint fd;\n\tstruct statvfs st;\n\tchar *ret = NULL;\n\n\tfd = open64(file, O_RDONLY, 0);\n\tif (fd >= 0) {\n\t\tif (ioctl(fd, ST_DEVINFO, &st) == 0) {\n\t\t\tret = xasprintf(\"%lu %s\",\n\t\t\t\t\t(unsigned long)st.f_bsize * (unsigned long)st.f_blocks,\n\t\t\t\t\taLuS);\n\t\t}\n\t\tclose(fd);\n\t}\n\treturn ret;\n}",
        "source_code": "FAST_FUNC query_loop(const char *device)\n{\n\tint fd;\n\tbb_loop_info loopinfo;\n\tchar *dev = NULL;\n\n\tfd = open(device, O_RDONLY);\n\tif (fd >= 0) {\n\t\tif (ioctl(fd, BB_LOOP_GET_STATUS, &loopinfo) == 0) {\n\t\t\tdev = xasprintf(\"%\"OFF_FMT\"u %s\", (off_t) loopinfo.lo_offset,\n\t\t\t\t\t(char *)loopinfo.lo_file_name);\n\t\t}\n\t\tclose(fd);\n\t}\n\n\treturn dev;\n}",
        "parsed_output": "\n\nstatic char *get_size_str(const char *file)\n{\n\tint fd;\n\tstruct statvfs st;\n\tchar *ret = NULL;\n\n\tfd = open64(file, O_RDONLY, 0);\n\tif (fd >= 0) {\n\t\tif (ioctl(fd, ST_DEVINFO, &st) == 0) {\n\t\t\tret = xasprintf(\"%lu %s\",\n\t\t\t\t\t(unsigned long)st.f_bsize * (unsigned long)st.f_blocks,\n\t\t\t\t\taLuS);\n\t\t}\n\t\tclose(fd);\n\t}\n\treturn ret;\n}",
        "baseline_code_stripped": "char *__fastcall sub_501875(const char *a1)\n{\n  __int64 v1; // r8\n  __int64 v2; // r9\n  char v4[24]; // [rsp+10h] [rbp-100h] BYREF\n  __int64 v5; // [rsp+28h] [rbp-E8h]\n  __int64 v6; // [rsp+48h] [rbp-C8h] BYREF\n  int fd; // [rsp+104h] [rbp-Ch]\n  char *v8; // [rsp+108h] [rbp-8h]\n\n  v8 = 0LL;\n  fd = open64(a1, 0);\n  if ( fd >= 0 )\n  {\n    if ( !ioctl(fd, 0x4C05uLL, v4) )\n      v8 = sub_40A6B3(\"%lu %s\", v5, (__int64)&v6, v5, v1, v2);\n    close(fd);\n  }\n  return v8;\n}\n",
        "baseline_code_debug": "char *__cdecl query_loop(const char *device)\n{\n  bb_loop_info loopinfo; // [rsp+10h] [rbp-100h] BYREF\n  int fd; // [rsp+104h] [rbp-Ch]\n  char *dev; // [rsp+108h] [rbp-8h]\n\n  dev = 0LL;\n  fd = open64(device, 0);\n  if ( fd >= 0 )\n  {\n    if ( !ioctl(fd, 0x4C05uLL, &loopinfo) )\n      dev = xasprintf(\"%lu %s\", loopinfo.lo_offset, (const char *)loopinfo.lo_file_name);\n    close(fd);\n  }\n  return dev;\n}\n",
        "similarity_score_unixcoder": 0.610284686088562,
        "similarity_score_baseline_stripped": 0.43119335174560547,
        "similarity_score_baseline_debug": 0.8568956851959229
    },
    {
        "func_name": "ash_arith",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004780F0 | 55 | push    rbp\n0x004780F1 | 48 89 E5 | mov     rbp, rsp\n0x004780F4 | 48 83 EC 20 | sub     rsp, 20h\n0x004780F8 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004780FC | 48 89 75 E0 | mov     [rbp+var_20], rsi\n0x00478100 | 48 8B 05 11 53 2E 00 | mov     rax, cs:qword_75D418\n0x00478107 | 8B 50 30 | mov     edx, [rax+30h]\n0x0047810A | 83 C2 01 | add     edx, 1\n0x0047810D | 89 50 30 | mov     [rax+30h], edx\n0x00478110 | C6 45 F0 01 | mov     [rbp+var_10], 1\n0x00478114 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00478118 | 48 89 C7 | mov     rdi, rax\n0x0047811B | E8 3F FF FF FF | call    sub_47805F\n0x00478120 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00478124 | 48 8D 55 F0 | lea     rdx, [rbp+var_10]\n0x00478128 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0047812C | 48 89 D6 | mov     rsi, rdx\n0x0047812F | 48 89 C7 | mov     rdi, rax\n0x00478132 | E8 0D F0 FF FF | call    sub_477144\n0x00478137 | E8 03 5F FF FF | call    sub_46E03F\n0x0047813C | 90 | nop\n0x0047813D | C9 | leave\n0x0047813E | C3 | retn\n\n Ourput decompiled code:\nstatic void\ndefun(char *name, union node *func)\n{\n\tstruct cmdentry entry;\n\n\tINT_OFF;\n\tentry.cmdtype = CMDFUNCTION;\n\tentry.u.func = copyfunc(func);\n\taddcmdentry(name, &entry);\n\tINT_ON;\n}\n\n## Example:\n\n Input assembly code:\n0x004707B3 | 55 | push    rbp\n0x004707B4 | 48 89 E5 | mov     rbp, rsp\n0x004707B7 | 48 83 EC 20 | sub     rsp, 20h\n0x004707BB | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004707BF | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004707C3 | 48 89 C7 | mov     rdi, rax\n0x004707C6 | E8 97 FD FF FF | call    sub_470562\n0x004707CB | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004707CF | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004707D3 | 48 8B 00 | mov     rax, [rax]\n0x004707D6 | 48 85 C0 | test    rax, rax\n0x004707D9 | 74 35 | jz      short loc_470810\n0x004707DB | 48 8B 05 36 CC 2E 00 | mov     rax, cs:qword_75D418\n0x004707E2 | 8B 50 30 | mov     edx, [rax+30h]\n0x004707E5 | 83 C2 01 | add     edx, 1\n0x004707E8 | 89 50 30 | mov     [rax+30h], edx\n0x004707EB | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004707EF | 48 8B 00 | mov     rax, [rax]\n0x004707F2 | 48 89 C7 | mov     rdi, rax\n0x004707F5 | E8 6E FE FF FF | call    sub_470668\n0x004707FA | 48 89 C2 | mov     rdx, rax\n0x004707FD | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00470801 | 48 89 10 | mov     [rax], rdx\n0x00470804 | E8 36 D8 FF FF | call    sub_46E03F\n0x00470809 | B8 00 00 00 00 | mov     eax, 0\n0x0047080E | EB 05 | jmp     short locret_470815\n0x00470810 | B8 01 00 00 00 | mov     eax, 1\n0x00470815 | C9 | leave\n0x00470816 | C3 | retn\n\n Ourput decompiled code:\nstatic int\nunalias(const char *name)\n{\n\tstruct alias **app;\n\n\tapp = __lookupalias(name);\n\n\tif (*app) {\n\t\tINT_OFF;\n\t\t*app = freealias(*app);\n\t\tINT_ON;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n## Example:\n\n Input assembly code:\n0x00422B9A | 55 | push    rbp\n0x00422B9B | 48 89 E5 | mov     rbp, rsp\n0x00422B9E | 48 83 EC 20 | sub     rsp, 20h\n0x00422BA2 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00422BA6 | 48 C7 45 F8 77 A4 52 00 | mov     [rbp+format], (offset aS_23+1); \"%s\"\n0x00422BAE | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00422BB2 | 48 8B 10 | mov     rdx, [rax]\n0x00422BB5 | 48 8B 45 F8 | mov     rax, [rbp+format]\n0x00422BB9 | 48 89 D6 | mov     rsi, rdx\n0x00422BBC | 48 89 C7 | mov     rdi, rax; format\n0x00422BBF | B8 00 00 00 00 | mov     eax, 0\n0x00422BC4 | E8 07 40 FE FF | call    _printf\n0x00422BC9 | 48 C7 45 F8 76 A4 52 00 | mov     [rbp+format], offset aS_23; \" %s\"\n0x00422BD1 | 48 83 45 E8 08 | add     [rbp+var_18], 8\n0x00422BD6 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00422BDA | 48 8B 00 | mov     rax, [rax]\n0x00422BDD | 48 85 C0 | test    rax, rax\n0x00422BE0 | 75 CC | jnz     short loc_422BAE\n0x00422BE2 | 90 | nop\n0x00422BE3 | C9 | leave\n0x00422BE4 | C3 | retn\n\n Ourput decompiled code:\nstatic void printargv(char *const *argv)\n{\n\tconst char *fmt = \" %s\" + 1;\n\tdo {\n\t\tprintf(fmt, *argv);\n\t\tfmt = \" %s\";\n\t} while (*++argv);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00473BC5 | 55 | push    rbp\n0x00473BC6 | 48 89 E5 | mov     rbp, rsp\n0x00473BC9 | 48 83 EC 40 | sub     rsp, 40h\n0x00473BCD | 48 89 7D C8 | mov     [rbp+var_38], rdi\n0x00473BD1 | 48 C7 45 D8 38 F4 46 00 | mov     [rbp+var_28], offset sub_46F438\n0x00473BD9 | 48 C7 45 E0 03 F8 46 00 | mov     [rbp+var_20], offset sub_46F803\n0x00473BE1 | 48 8B 05 30 98 2E 00 | mov     rax, cs:qword_75D418\n0x00473BE8 | 8B 50 30 | mov     edx, [rax+30h]\n0x00473BEB | 83 C2 01 | add     edx, 1\n0x00473BEE | 89 50 30 | mov     [rax+30h], edx\n0x00473BF1 | 48 8B 55 C8 | mov     rdx, [rbp+var_38]\n0x00473BF5 | 48 8D 45 D0 | lea     rax, [rbp+var_30]\n0x00473BF9 | 48 89 D6 | mov     rsi, rdx\n0x00473BFC | 48 89 C7 | mov     rdi, rax\n0x00473BFF | E8 66 7A 01 00 | call    sub_48B66A\n0x00473C04 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00473C08 | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x00473C0C | 48 85 C0 | test    rax, rax\n0x00473C0F | 74 11 | jz      short loc_473C22\n0x00473C11 | 48 8B 45 D0 | mov     rax, [rbp+var_30]\n0x00473C15 | 48 89 C7 | mov     rdi, rax\n0x00473C18 | B8 00 00 00 00 | mov     eax, 0\n0x00473C1D | E8 51 A8 FF FF | call    sub_46E473\n0x00473C22 | E8 18 A4 FF FF | call    sub_46E03F\n0x00473C27 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00473C2B | C9 | leave\n0x00473C2C | C3 | retn",
        "output": "\n\nstatic struct cmdentry *\nlookupcmd(char *name)\n{\n\tstruct cmdentry *entry;\n\tstruct cmdentry key;\n\n\tkey.cmdname = name;\n\tkey.cmdtype = CMDFUNCTION;\n\tkey.u.func = findfunc;\n\tentry = bsearch(&key, cmdtable, cmdtable_size, sizeof(struct cmdentry),\n\t    (int (*)(const void *, const void *)) cmdcmp);\n\tif (key.u.func)\n\t\tfindfunc(key.u.func);\n\tINT_ON;\n\treturn (entry);\n}",
        "source_code": "if ENABLE_SH_MATH_SUPPORT\nstatic arith_t\nash_arith(const char *s)\n{\n\tarith_state_t math_state;\n\tarith_t result;\n\n\tmath_state.lookupvar = lookupvar;\n\tmath_state.setvar    = setvar2;\n\t//math_state.endofname = endofname;\n\n\tINT_OFF;\n\tresult = arith(&math_state, s);\n\tif (math_state.errmsg)\n\t\tash_msg_and_raise_error(math_state.errmsg);\n\tINT_ON;\n\n\treturn result;\n}",
        "parsed_output": "\n\nstatic struct cmdentry *\nlookupcmd(char *name)\n{\n\tstruct cmdentry *entry;\n\tstruct cmdentry key;\n\n\tkey.cmdname = name;\n\tkey.cmdtype = CMDFUNCTION;\n\tkey.u.func = findfunc;\n\tentry = bsearch(&key, cmdtable, cmdtable_size, sizeof(struct cmdentry),\n\t    (int (*)(const void *, const void *)) cmdcmp);\n\tif (key.u.func)\n\t\tfindfunc(key.u.func);\n\tINT_ON;\n\treturn (entry);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_473BC5(__int64 a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  const char *v6[5]; // [rsp+10h] [rbp-30h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-8h]\n\n  v6[1] = (const char *)sub_46F438;\n  v6[2] = (const char *)sub_46F803;\n  ++*(_DWORD *)(qword_75D418 + 48);\n  v7 = sub_48B66A(v6, a1);\n  if ( v6[0] )\n    sub_46E473(v6[0], a1, v1, v2, v3, v4);\n  sub_46E03F(v6, a1);\n  return v7;\n}\n",
        "baseline_code_debug": "arith_t __cdecl ash_arith(const char *s)\n{\n  arith_state_t_0 math_state; // [rsp+10h] [rbp-30h] BYREF\n  arith_t result; // [rsp+38h] [rbp-8h]\n\n  math_state.lookupvar = (arith_var_lookup_t)lookupvar;\n  math_state.setvar = (arith_var_set_t)setvar2;\n  ++ash_ptr_to_globals_misc->suppress_int;\n  result = arith(&math_state, s);\n  if ( math_state.errmsg )\n    ash_msg_and_raise_error(math_state.errmsg);\n  int_on();\n  return result;\n}\n",
        "similarity_score_unixcoder": 0.5372333526611328,
        "similarity_score_baseline_stripped": 0.4964475631713867,
        "similarity_score_baseline_debug": 0.8432464599609375
    },
    {
        "func_name": "skip_non_whitespace",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004093B4 | 55 | push    rbp\n0x004093B5 | 48 89 E5 | mov     rbp, rsp\n0x004093B8 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004093BC | EB 05 | jmp     short loc_4093C3\n0x004093BE | 48 83 45 F8 01 | add     [rbp+var_8], 1\n0x004093C3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004093C7 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004093CA | 3C 20 | cmp     al, 20h ; ' '\n0x004093CC | 74 F0 | jz      short loc_4093BE\n0x004093CE | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004093D2 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004093D5 | 83 E8 09 | sub     eax, 9\n0x004093D8 | 3C 04 | cmp     al, 4\n0x004093DA | 76 E2 | jbe     short loc_4093BE\n0x004093DC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004093E0 | 5D | pop     rbp\n0x004093E1 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC skip_whitespace(const char *s)\n{\n\t/* In POSIX/C locale (the only locale we care about: do we REALLY want\n\t * to allow Unicode whitespace in, say, .conf files? nuts!)\n\t * isspace is only these chars: \"\\t\\n\\v\\f\\r\" and space.\n\t * \"\\t\\n\\v\\f\\r\" happen to have ASCII codes 9,10,11,12,13.\n\t * Use that.\n\t */\n\twhile (*s == ' ' || (unsigned char)(*s - 9) <= (13 - 9))\n\t\ts++;\n\n\treturn (char *) s;\n}\n\n## Example:\n\n Input assembly code:\n0x0046DF3E | 55 | push    rbp\n0x0046DF3F | 48 89 E5 | mov     rbp, rsp\n0x0046DF42 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0046DF46 | EB 13 | jmp     short loc_46DF5B\n0x0046DF48 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0046DF4C | 48 8D 50 01 | lea     rdx, [rax+1]\n0x0046DF50 | 48 89 55 F8 | mov     [rbp+var_8], rdx\n0x0046DF54 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0046DF57 | 3C 3D | cmp     al, 3Dh ; '='\n0x0046DF59 | 74 0D | jz      short loc_46DF68\n0x0046DF5B | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0046DF5F | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0046DF62 | 84 C0 | test    al, al\n0x0046DF64 | 75 E2 | jnz     short loc_46DF48\n0x0046DF66 | EB 01 | jmp     short loc_46DF69\n0x0046DF68 | 90 | nop\n0x0046DF69 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0046DF6D | 5D | pop     rbp\n0x0046DF6E | C3 | retn\n\n Ourput decompiled code:\nstatic const char *var_end(const char *var)\n{\n\twhile (*var)\n\t\tif (*var++ == '=')\n\t\t\tbreak;\n\treturn var;\n}\n\n## Example:\n\n Input assembly code:\n0x0044B2EE | 55 | push    rbp\n0x0044B2EF | 48 89 E5 | mov     rbp, rsp\n0x0044B2F2 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x0044B2F6 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0044B2FA | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0044B2FD | 3C 02 | cmp     al, 2\n0x0044B2FF | 75 22 | jnz     short loc_44B323\n0x0044B301 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0044B305 | 0F B6 40 01 | movzx   eax, byte ptr [rax+1]\n0x0044B309 | 84 C0 | test    al, al\n0x0044B30B | 74 16 | jz      short loc_44B323\n0x0044B30D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0044B311 | 48 83 C0 04 | add     rax, 4\n0x0044B315 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0044B318 | 3C 7F | cmp     al, 7Fh\n0x0044B31A | 75 07 | jnz     short loc_44B323\n0x0044B31C | B8 FE 00 00 00 | mov     eax, 0FEh\n0x0044B321 | EB 05 | jmp     short loc_44B328\n0x0044B323 | B8 00 00 00 00 | mov     eax, 0\n0x0044B328 | 5D | pop     rbp\n0x0044B329 | C3 | retn\n\n Ourput decompiled code:\nstatic int default_scope(inet_prefix *lcl)\n{\n\tif (lcl->family == AF_INET) {\n\t\tif (lcl->bytelen >= 1 && *(uint8_t*)&lcl->data == 127)\n\t\t\treturn RT_SCOPE_HOST;\n\t}\n\treturn 0;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004093E2 | 55 | push    rbp\n0x004093E3 | 48 89 E5 | mov     rbp, rsp\n0x004093E6 | 48 89 7D F8 | mov     [rbp+var_8], rdi\n0x004093EA | EB 05 | jmp     short loc_4093F1\n0x004093EC | 48 83 45 F8 01 | add     [rbp+var_8], 1\n0x004093F1 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004093F5 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004093F8 | 84 C0 | test    al, al\n0x004093FA | 74 19 | jz      short loc_409415\n0x004093FC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00409400 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x00409403 | 3C 20 | cmp     al, 20h ; ' '\n0x00409405 | 74 0E | jz      short loc_409415\n0x00409407 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0040940B | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0040940E | 83 E8 09 | sub     eax, 9\n0x00409411 | 3C 04 | cmp     al, 4\n0x00409413 | 77 D7 | ja      short loc_4093EC\n0x00409415 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00409419 | 5D | pop     rbp\n0x0040941A | C3 | retn",
        "output": "\n\nstatic char *skip_whitespace(const char *s)\n{\n\t/* In POSIX/C locale (the only locale we care about: do we REALLY want\n\t * to allow Unicode whitespace in, say, .conf files? nuts!)\n\t * isspace is only these chars: \"\\t\\n\\v\\f\\r\" and space.\n\t * \"\\t\\n\\v\\f\\r\" happen to have ASCII codes 9,10,11,12,13.\n\t * Use that.\n\t */\n\twhile (*s && (*s == ' ' || (unsigned char)(*s - 9) <= (13 - 9)))\n\t\ts++;\n\n\treturn (char *) s;\n}",
        "source_code": "FAST_FUNC skip_non_whitespace(const char *s)\n{\n\twhile (*s != '\\0' && *s != ' ' && (unsigned char)(*s - 9) > (13 - 9))\n\t\ts++;\n\n\treturn (char *) s;\n}",
        "parsed_output": "\n\nstatic char *skip_whitespace(const char *s)\n{\n\t/* In POSIX/C locale (the only locale we care about: do we REALLY want\n\t * to allow Unicode whitespace in, say, .conf files? nuts!)\n\t * isspace is only these chars: \"\\t\\n\\v\\f\\r\" and space.\n\t * \"\\t\\n\\v\\f\\r\" happen to have ASCII codes 9,10,11,12,13.\n\t * Use that.\n\t */\n\twhile (*s && (*s == ' ' || (unsigned char)(*s - 9) <= (13 - 9)))\n\t\ts++;\n\n\treturn (char *) s;\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_4093E2(_BYTE *a1)\n{\n  while ( *a1 && *a1 != 32 && (unsigned __int8)(*a1 - 9) > 4u )\n    ++a1;\n  return a1;\n}\n",
        "baseline_code_debug": "char *__cdecl skip_non_whitespace(const char *s)\n{\n  while ( *s && *s != 32 && (unsigned __int8)(*s - 9) > 4u )\n    ++s;\n  return (char *)s;\n}\n",
        "similarity_score_unixcoder": 0.8300263285636902,
        "similarity_score_baseline_stripped": 0.6370589733123779,
        "similarity_score_baseline_debug": 0.9166108965873718
    },
    {
        "func_name": "peektoken",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004C4435 | 55 | push    rbp\n0x004C4436 | 48 89 E5 | mov     rbp, rsp\n0x004C4439 | 48 83 EC 10 | sub     rsp, 10h\n0x004C443D | E8 84 FF FF FF | call    sub_4C43C6\n0x004C4442 | 89 45 FC | mov     [rbp+fd], eax\n0x004C4445 | 48 8B 05 B4 8F 29 00 | mov     rax, cs:qword_75D400\n0x004C444C | C7 00 00 00 00 00 | mov     dword ptr [rax], 0\n0x004C4452 | 48 8D 55 F8 | lea     rdx, [rbp+var_8]\n0x004C4456 | 8B 45 FC | mov     eax, [rbp+fd]\n0x004C4459 | BE 00 56 00 00 | mov     esi, 5600h; request\n0x004C445E | 89 C7 | mov     edi, eax; fd\n0x004C4460 | B8 00 00 00 00 | mov     eax, 0\n0x004C4465 | E8 36 29 F4 FF | call    _ioctl\n0x004C446A | 85 C0 | test    eax, eax\n0x004C446C | 75 07 | jnz     short loc_4C4475\n0x004C446E | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x004C4471 | 85 C0 | test    eax, eax\n0x004C4473 | 7F 0F | jg      short loc_4C4484\n0x004C4475 | BF DD 69 53 00 | mov     edi, offset aCanTFindOpenVt; \"can't find open VT\"\n0x004C447A | B8 00 00 00 00 | mov     eax, 0\n0x004C447F | E8 1E 4E F4 FF | call    sub_4092A2\n0x004C4484 | 8B 45 F8 | mov     eax, [rbp+var_8]\n0x004C4487 | C9 | leave\n0x004C4488 | C3 | retn\n\n Ourput decompiled code:\nstatic int find_free_vtno(void)\n{\n\tint vtno;\n\tint fd = get_vt_fd();\n\n\terrno = 0;\n\t/*xfunc_error_retval = 3; - do we need compat? */\n\tif (ioctl(fd, VT_OPENQRY, &vtno) != 0 || vtno <= 0)\n\t\tbb_perror_msg_and_die(\"can't find open VT\");\n// Not really needed, grep for DAEMON_ONLY_SANITIZE\n//\tif (fd > 2)\n//\t\tclose(fd);\n\treturn vtno;\n}\n\n## Example:\n\n Input assembly code:\n0x0043CF39 | 55 | push    rbp\n0x0043CF3A | 48 89 E5 | mov     rbp, rsp\n0x0043CF3D | 48 83 EC 10 | sub     rsp, 10h\n0x0043CF41 | C7 45 FC 05 00 00 00 | mov     [rbp+var_4], 5\n0x0043CF48 | E8 C3 A3 FC FF | call    _random\n0x0043CF4D | 89 45 F8 | mov     [rbp+var_8], eax\n0x0043CF50 | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0043CF53 | C9 | leave\n0x0043CF54 | C3 | retn\n\n Ourput decompiled code:\nstatic unsigned\nretry_interval(void)\n{\n\t/* Local problem, want to retry soon */\n\tunsigned interval, r;\n\tinterval = RETRY_INTERVAL;\n\tr = random();\n\tinterval += r % (unsigned)(RETRY_INTERVAL / 4);\n\tVERB3 bb_error_msg(\"chose retry interval:%u\", interval);\n\treturn interval;\n}\n\n## Example:\n\n Input assembly code:\n0x0040AEE6 | 55 | push    rbp\n0x0040AEE7 | 48 89 E5 | mov     rbp, rsp\n0x0040AEEA | 48 83 EC 10 | sub     rsp, 10h\n0x0040AEEE | E8 BD CD FF FF | call    _fork\n0x0040AEF3 | 89 45 FC | mov     [rbp+var_4], eax\n0x0040AEF6 | 83 7D FC 00 | cmp     [rbp+var_4], 0\n0x0040AEFA | 79 12 | jns     short loc_40AF0E\n0x0040AEFC | B8 82 81 52 00 | mov     eax, offset aFork; \"fork\"\n0x0040AF01 | 48 89 C7 | mov     rdi, rax\n0x0040AF04 | B8 00 00 00 00 | mov     eax, 0\n0x0040AF09 | E8 94 E3 FF FF | call    sub_4092A2\n0x0040AF0E | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0040AF11 | C9 | leave\n0x0040AF12 | C3 | retn\n\n Ourput decompiled code:\nif BB_MMU\npid_t FAST_FUNC xfork(void)\n{\n\tpid_t pid;\n\tpid = fork();\n\tif (pid < 0) /* wtf? */\n\t\tbb_perror_msg_and_die(\"vfork\"+1);\n\treturn pid;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0047DC18 | 55 | push    rbp\n0x0047DC19 | 48 89 E5 | mov     rbp, rsp\n0x0047DC1C | 48 83 EC 10 | sub     rsp, 10h\n0x0047DC20 | E8 EE FE FF FF | call    sub_47DB13\n0x0047DC25 | 89 45 FC | mov     [rbp+var_4], eax\n0x0047DC28 | C6 05 2A D4 2D 00 01 | mov     cs:byte_75B059, 1\n0x0047DC2F | 8B 45 FC | mov     eax, [rbp+var_4]\n0x0047DC32 | 48 98 | cdqe\n0x0047DC34 | 48 8B 04 C5 20 D2 51 00 | mov     rax, ds:off_51D220[rax*8]\n0x0047DC3C | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0047DC3F | C9 | leave\n0x0047DC40 | C3 | retn",
        "output": "\n\nstatic unsigned char\nget_vt_fd(void)\n{\n\tint fd = open_original_vt();\n\tunsigned char *p;\n\tbb_want_to_quit = 1;\n\tp = (unsigned char *)&fd;\n\treturn *p;\n}",
        "source_code": "static char\npeektoken(void)\n{\n\tint t;\n\n\tt = readtoken();\n\ttokpushback = 1;\n\treturn tokname_array[t][0];\n}",
        "parsed_output": "\n\nstatic unsigned char\nget_vt_fd(void)\n{\n\tint fd = open_original_vt();\n\tunsigned char *p;\n\tbb_want_to_quit = 1;\n\tp = (unsigned char *)&fd;\n\treturn *p;\n}",
        "baseline_code_stripped": "__int64 sub_47DC18()\n{\n  int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_47DB13();\n  byte_75B059 = 1;\n  return *(unsigned __int8 *)*(&off_51D220 + v1);\n}\n",
        "baseline_code_debug": "char __cdecl peektoken()\n{\n  int t; // [rsp+Ch] [rbp-4h]\n\n  t = readtoken();\n  tokpushback = 1;\n  return *tokname_array[t];\n}\n",
        "similarity_score_unixcoder": 0.5109409689903259,
        "similarity_score_baseline_stripped": 0.4183512330055237,
        "similarity_score_baseline_debug": 0.8403681516647339
    },
    {
        "func_name": "makestrspace",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004DF493 | 55 | push    rbp\n0x004DF494 | 48 89 E5 | mov     rbp, rsp\n0x004DF497 | 48 83 EC 20 | sub     rsp, 20h\n0x004DF49B | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004DF49F | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DF4A3 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x004DF4A7 | 48 89 45 F8 | mov     [rbp+ptr], rax\n0x004DF4AB | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004DF4AF | 48 8B 50 08 | mov     rdx, [rax+8]\n0x004DF4B3 | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004DF4B7 | 48 8B 00 | mov     rax, [rax]\n0x004DF4BA | 48 39 C2 | cmp     rdx, rax\n0x004DF4BD | 72 2B | jb      short loc_4DF4EA\n0x004DF4BF | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004DF4C3 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004DF4C7 | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x004DF4CB | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004DF4CF | 48 89 C7 | mov     rdi, rax; ptr\n0x004DF4D2 | E8 89 71 F2 FF | call    _free\n0x004DF4D7 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DF4DB | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x004DF4DF | 48 89 50 18 | mov     [rax+18h], rdx\n0x004DF4E3 | B8 00 00 00 00 | mov     eax, 0\n0x004DF4E8 | EB 27 | jmp     short locret_4DF511\n0x004DF4EA | 48 8B 45 F8 | mov     rax, [rbp+ptr]\n0x004DF4EE | 48 83 C0 08 | add     rax, 8\n0x004DF4F2 | 48 89 C7 | mov     rdi, rax\n0x004DF4F5 | E8 65 D0 FF FF | call    sub_4DC55F\n0x004DF4FA | 48 89 C2 | mov     rdx, rax\n0x004DF4FD | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x004DF501 | 48 89 D6 | mov     rsi, rdx\n0x004DF504 | 48 89 C7 | mov     rdi, rax\n0x004DF507 | E8 1B D4 FF FF | call    sub_4DC927\n0x004DF50C | B8 01 00 00 00 | mov     eax, 1\n0x004DF511 | C9 | leave\n0x004DF512 | C3 | retn\n\n Ourput decompiled code:\nstatic int hashwalk_next(var *v)\n{\n\twalker_list *w = v->x.walker;\n\n\tif (w->cur >= w->end) {\n\t\twalker_list *prev_walker = w->prev;\n\n\t\tdebug_printf_walker(\"end of iteration, free(walker@%p:%p), prev_walker:%p\\n\", &v->x.walker, w, prev_walker);\n\t\tfree(w);\n\t\tv->x.walker = prev_walker;\n\t\treturn FALSE;\n\t}\n\n\tsetvar_s(v, nextword(&w->cur));\n\treturn TRUE;\n}\n\n## Example:\n\n Input assembly code:\n0x004CE68B | 55 | push    rbp\n0x004CE68C | 48 89 E5 | mov     rbp, rsp\n0x004CE68F | 48 83 EC 40 | sub     rsp, 40h\n0x004CE693 | 48 89 7D C8 | mov     [rbp+var_38], rdi\n0x004CE697 | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x004CE69B | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004CE69F | E9 83 00 00 00 | jmp     loc_4CE727\n0x004CE6A4 | 48 8D 55 D0 | lea     rdx, [rbp+src]\n0x004CE6A8 | 48 8B 4D C8 | mov     rcx, [rbp+var_38]\n0x004CE6AC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004CE6B0 | 48 89 CE | mov     rsi, rcx\n0x004CE6B3 | 48 89 C7 | mov     rdi, rax\n0x004CE6B6 | E8 5C FB FF FF | call    sub_4CE217\n0x004CE6BB | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x004CE6BF | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x004CE6C3 | 48 89 45 C8 | mov     [rbp+var_38], rax\n0x004CE6C7 | 48 8B 05 42 CB 28 00 | mov     rax, cs:qword_75B210\n0x004CE6CE | 89 C2 | mov     edx, eax\n0x004CE6D0 | 48 8B 05 41 CB 28 00 | mov     rax, cs:qword_75B218\n0x004CE6D7 | BE 04 20 00 00 | mov     esi, 2004h\n0x004CE6DC | 48 89 C7 | mov     rdi, rax\n0x004CE6DF | E8 FD D9 03 00 | call    sub_50C0E1\n0x004CE6E4 | 48 89 05 2D CB 28 00 | mov     cs:qword_75B218, rax\n0x004CE6EB | 48 8B 05 26 CB 28 00 | mov     rax, cs:qword_75B218\n0x004CE6F2 | 48 8B 15 17 CB 28 00 | mov     rdx, cs:qword_75B210\n0x004CE6F9 | 48 C1 E2 05 | shl     rdx, 5\n0x004CE6FD | 48 8D 0C 10 | lea     rcx, [rax+rdx]\n0x004CE701 | 48 8D 45 D0 | lea     rax, [rbp+src]\n0x004CE705 | BA 20 00 00 00 | mov     edx, 20h ; ' '; n\n0x004CE70A | 48 89 C6 | mov     rsi, rax; src\n0x004CE70D | 48 89 CF | mov     rdi, rcx; dest\n0x004CE710 | E8 8B 8A F3 FF | call    _memcpy\n0x004CE715 | 48 8B 05 F4 CA 28 00 | mov     rax, cs:qword_75B210\n0x004CE71C | 48 83 C0 01 | add     rax, 1\n0x004CE720 | 48 89 05 E9 CA 28 00 | mov     cs:qword_75B210, rax\n0x004CE727 | 48 8B 45 C8 | mov     rax, [rbp+var_38]\n0x004CE72B | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004CE72E | 84 C0 | test    al, al\n0x004CE730 | 0F 85 6E FF FF FF | jnz     loc_4CE6A4\n0x004CE736 | 90 | nop\n0x004CE737 | C9 | leave\n0x004CE738 | C3 | retn\n\n Ourput decompiled code:\nstatic void\ndecode_format_string(const char *s)\n{\n\tconst char *s_orig = s;\n\n\twhile (*s != '\\0') {\n\t\tstruct tspec tspec;\n\t\tconst char *next;\n\n\t\tnext = decode_one_format(s_orig, s, &tspec);\n\n\t\tassert(s != next);\n\t\ts = next;\n\t\tspec = xrealloc_vector(spec, 4, n_specs);\n\t\tmemcpy(&spec[n_specs], &tspec, sizeof(spec[0]));\n\t\tn_specs++;\n\t}\n}\n\n## Example:\n\n Input assembly code:\n0x004368DE | 55 | push    rbp\n0x004368DF | 48 89 E5 | mov     rbp, rsp\n0x004368E2 | 48 83 EC 20 | sub     rsp, 20h\n0x004368E6 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004368EA | 48 8B 05 9F 48 32 00 | mov     rax, cs:qword_75B190\n0x004368F1 | 48 85 C0 | test    rax, rax\n0x004368F4 | 75 11 | jnz     short loc_436907\n0x004368F6 | BF 31 00 00 00 | mov     edi, 31h ; '1'\n0x004368FB | E8 5F 37 FD FF | call    sub_40A05F\n0x00436900 | 48 89 05 89 48 32 00 | mov     cs:qword_75B190, rax\n0x00436907 | 48 8B 05 82 48 32 00 | mov     rax, cs:qword_75B190\n0x0043690E | 48 89 45 F8 | mov     [rbp+s], rax\n0x00436912 | C7 45 F4 00 00 00 00 | mov     [rbp+var_C], 0\n0x00436919 | EB 31 | jmp     short loc_43694C\n0x0043691B | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0043691F | 48 8D 50 01 | lea     rdx, [rax+1]\n0x00436923 | 48 89 55 E8 | mov     [rbp+var_18], rdx\n0x00436927 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x0043692A | 0F B6 D0 | movzx   edx, al\n0x0043692D | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x00436931 | BE F0 95 51 00 | mov     esi, offset a02x; \"%02X-\"\n0x00436936 | 48 89 C7 | mov     rdi, rax; s\n0x00436939 | B8 00 00 00 00 | mov     eax, 0\n0x0043693E | E8 3D 11 FD FF | call    _sprintf\n0x00436943 | 48 83 45 F8 03 | add     [rbp+s], 3\n0x00436948 | 83 45 F4 01 | add     [rbp+var_C], 1\n0x0043694C | 83 7D F4 0F | cmp     [rbp+var_C], 0Fh\n0x00436950 | 76 C9 | jbe     short loc_43691B\n0x00436952 | 48 83 6D F8 01 | sub     [rbp+s], 1\n0x00436957 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x0043695B | C6 00 00 | mov     byte ptr [rax], 0\n0x0043695E | 48 8B 05 2B 48 32 00 | mov     rax, cs:qword_75B190\n0x00436965 | C9 | leave\n0x00436966 | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC UNSPEC_print(unsigned char *ptr)\n{\n\tstatic char *buff;\n\n\tchar *pos;\n\tunsigned int i;\n\n\tif (!buff)\n\t\tbuff = xmalloc(sizeof(struct sockaddr) * 3 + 1);\n\tpos = buff;\n\tfor (i = 0; i < sizeof(struct sockaddr); i++) {\n\t\t/* careful -- not every libc's sprintf returns # bytes written */\n\t\tsprintf(pos, \"%02X-\", (*ptr++ & 0377));\n\t\tpos += 3;\n\t}\n\t/* Erase trailing \"-\".  Works as long as sizeof(struct sockaddr) != 0 */\n\t*--pos = '\\0';\n\treturn buff;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0046ECB9 | 55 | push    rbp\n0x0046ECBA | 48 89 E5 | mov     rbp, rsp\n0x0046ECBD | 48 83 EC 30 | sub     rsp, 30h\n0x0046ECC1 | 48 89 7D D8 | mov     [rbp+var_28], rdi\n0x0046ECC5 | 48 89 75 D0 | mov     [rbp+var_30], rsi\n0x0046ECC9 | 48 8B 05 58 E7 2E 00 | mov     rax, cs:qword_75D428\n0x0046ECD0 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x0046ECD4 | 48 8B 55 D0 | mov     rdx, [rbp+var_30]\n0x0046ECD8 | 48 29 C2 | sub     rdx, rax\n0x0046ECDB | 48 89 D0 | mov     rax, rdx\n0x0046ECDE | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0046ECE2 | 48 8B 05 3F E7 2E 00 | mov     rax, cs:qword_75D428\n0x0046ECE9 | 48 8B 40 20 | mov     rax, [rax+20h]\n0x0046ECED | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x0046ECF1 | 48 8B 05 30 E7 2E 00 | mov     rax, cs:qword_75D428\n0x0046ECF8 | 48 8B 40 20 | mov     rax, [rax+20h]\n0x0046ECFC | 48 89 45 F0 | mov     [rbp+var_10], rax\n0x0046ED00 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0046ED04 | 48 2B 45 F8 | sub     rax, [rbp+var_8]\n0x0046ED08 | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x0046ED0C | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x0046ED10 | 48 3B 45 D8 | cmp     rax, [rbp+var_28]\n0x0046ED14 | 73 07 | jnb     short loc_46ED1D\n0x0046ED16 | E8 BA FC FF FF | call    sub_46E9D5\n0x0046ED1B | EB D4 | jmp     short loc_46ECF1\n0x0046ED1D | 90 | nop\n0x0046ED1E | 48 8B 05 03 E7 2E 00 | mov     rax, cs:qword_75D428\n0x0046ED25 | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x0046ED29 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0046ED2D | 48 01 D0 | add     rax, rdx\n0x0046ED30 | C9 | leave\n0x0046ED31 | C3 | retn",
        "output": "\n\nstatic const char *\nUNSPEC_print(unsigned char *ptr, size_t len)\n{\n\tstatic char buff[1024];\n\tsize_t i;\n\n\tchar *pos = buff;\n\n\tfor (i = *(size_t *)ptr; i < *(size_t *)(ptr + len - sizeof(size_t)); i++) {\n\t\tsprintf(pos, \"%02X-\", *ptr++ & 0377);\n\t\tpos += 3;\n\t}\n\t*--pos = '\\0';\n\treturn buff;\n}",
        "source_code": "static char *\nmakestrspace(size_t newlen, char *p)\n{\n\tsize_t len = p - g_stacknxt;\n\tsize_t size = stackblocksize();\n\n\tfor (;;) {\n\t\tsize_t nleft;\n\n\t\tsize = stackblocksize();\n\t\tnleft = size - len;\n\t\tif (nleft >= newlen)\n\t\t\tbreak;\n\t\tgrowstackblock();\n\t}\n\treturn (char *)stackblock() + len;\n}",
        "parsed_output": "\n\nstatic const char *\nUNSPEC_print(unsigned char *ptr, size_t len)\n{\n\tstatic char buff[1024];\n\tsize_t i;\n\n\tchar *pos = buff;\n\n\tfor (i = *(size_t *)ptr; i < *(size_t *)(ptr + len - sizeof(size_t)); i++) {\n\t\tsprintf(pos, \"%02X-\", *ptr++ & 0377);\n\t\tpos += 3;\n\t}\n\t*--pos = '\\0';\n\treturn buff;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_46ECB9(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v8; // [rsp+28h] [rbp-8h]\n\n  v6 = a2 - *(_QWORD *)(qword_75D428 + 16);\n  v8 = v6;\n  while ( *(_QWORD *)(qword_75D428 + 32) - v8 < a1 )\n    sub_46E9D5(a1, a2, v6, a4, a5, a6);\n  return *(_QWORD *)(qword_75D428 + 16) + v8;\n}\n",
        "baseline_code_debug": "char *__cdecl makestrspace(size_t newlen, char *p)\n{\n  size_t len; // [rsp+28h] [rbp-8h]\n\n  len = p - ash_ptr_to_globals_memstack->g_stacknxt;\n  while ( ash_ptr_to_globals_memstack->g_stacknleft - len < newlen )\n    growstackblock();\n  return &ash_ptr_to_globals_memstack->g_stacknxt[len];\n}\n",
        "similarity_score_unixcoder": 0.4778062105178833,
        "similarity_score_baseline_stripped": 0.4307440221309662,
        "similarity_score_baseline_debug": 0.8452684879302979
    },
    {
        "func_name": "gotsig",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0048C5A7 | 55 | push    rbp\n0x0048C5A8 | 48 89 E5 | mov     rbp, rsp\n0x0048C5AB | 48 83 EC 10 | sub     rsp, 10h\n0x0048C5AF | 89 7D FC | mov     [rbp+var_4], edi\n0x0048C5B2 | BE 01 00 00 00 | mov     esi, 1; handler\n0x0048C5B7 | BF 02 00 00 00 | mov     edi, 2; sig\n0x0048C5BC | E8 AF AA F7 FF | call    _signal\n0x0048C5C1 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x0048C5C6 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x0048C5CA | 48 89 C7 | mov     rdi, rax; shmaddr\n0x0048C5CD | E8 3E A3 F7 FF | call    _shmdt\n0x0048C5D2 | BF 00 00 00 00 | mov     edi, 0; status\n0x0048C5D7 | E8 E4 B4 F7 FF | call    _exit\n\n Ourput decompiled code:\nstatic void interrupted(int sig UNUSED_PARAM)\n{\n\tsignal(SIGINT, SIG_IGN);\n\tshmdt(shbuf);\n\texit(EXIT_SUCCESS);\n}\n\n## Example:\n\n Input assembly code:\n0x004C4692 | 55 | push    rbp\n0x004C4693 | 48 89 E5 | mov     rbp, rsp\n0x004C4696 | 48 83 EC 10 | sub     rsp, 10h\n0x004C469A | 89 7D FC | mov     [rbp+var_4], edi\n0x004C469D | BA F8 B3 75 00 | mov     edx, offset dest; termios_p\n0x004C46A2 | BE 00 00 00 00 | mov     esi, 0; optional_actions\n0x004C46A7 | BF 02 00 00 00 | mov     edi, 2; fd\n0x004C46AC | E8 1F 31 F4 FF | call    _tcsetattr\n0x004C46B1 | BF 01 00 00 00 | mov     edi, 1; status\n0x004C46B6 | E8 05 21 F4 FF | call    __exit\n\n Ourput decompiled code:\nstatic void\nonintr(int sig UNUSED_PARAM)\n{\n\ttcsetattr(STDERR_FILENO, TCSANOW, old_termios_p);\n\t_exit(EXIT_FAILURE);\n}\n\n## Example:\n\n Input assembly code:\n0x004EF4E0 | 55 | push    rbp\n0x004EF4E1 | 48 89 E5 | mov     rbp, rsp\n0x004EF4E4 | 48 83 EC 10 | sub     rsp, 10h\n0x004EF4E8 | 89 7D FC | mov     [rbp+val], edi\n0x004EF4EB | BE E0 F4 4E 00 | mov     esi, offset sub_4EF4E0; handler\n0x004EF4F0 | BF 02 00 00 00 | mov     edi, 2; sig\n0x004EF4F5 | E8 76 7B F1 FF | call    _signal\n0x004EF4FA | 48 8B 05 07 DF 26 00 | mov     rax, cs:qword_75D408\n0x004EF501 | 48 8D 90 88 02 00 00 | lea     rdx, [rax+288h]\n0x004EF508 | 8B 45 FC | mov     eax, [rbp+val]\n0x004EF50B | 89 C6 | mov     esi, eax; val\n0x004EF50D | 48 89 D7 | mov     rdi, rdx; env\n0x004EF510 | E8 3B 77 F1 FF | call    _siglongjmp\n\n Ourput decompiled code:\nstatic void catch_sig(int sig)\n{\n\tsignal(SIGINT, catch_sig);\n\tsiglongjmp(restart, sig);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x004A181C | 55 | push    rbp\n0x004A181D | 48 89 E5 | mov     rbp, rsp\n0x004A1820 | 48 83 EC 10 | sub     rsp, 10h\n0x004A1824 | 89 7D FC | mov     [rbp+var_4], edi\n0x004A1827 | BF 0A 00 00 00 | mov     edi, 0Ah\n0x004A182C | E8 58 85 F6 FF | call    sub_409D89\n0x004A1831 | BA FC B3 75 00 | mov     edx, offset dest.c_oflag; termios_p\n0x004A1836 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004A183B | 8B 00 | mov     eax, [rax]\n0x004A183D | BE 00 00 00 00 | mov     esi, 0; optional_actions\n0x004A1842 | 89 C7 | mov     edi, eax; fd\n0x004A1844 | E8 87 5F F6 FF | call    _tcsetattr\n0x004A1849 | BF 01 00 00 00 | mov     edi, 1; status\n0x004A184E | E8 6D 4F F6 FF | call    __exit",
        "output": "\n\nstatic void\nonintr(int sig UNUSED_PARAM)\n{\n\ttcsetattr(STDERR_FILENO, TCSANOW, old_termios_p);\n\t_exit(EXIT_FAILURE);\n}",
        "source_code": "static void gotsig(int sig UNUSED_PARAM)\n{\n\t/* bb_putchar_stderr doesn't use stdio buffering,\n\t * therefore it is safe in signal handler */\n\tbb_putchar_stderr('\\n');\n\tsetTermSettings(cin_fileno, &initial_settings);\n\t_exit(EXIT_FAILURE);\n}",
        "parsed_output": "\n\nstatic void\nonintr(int sig UNUSED_PARAM)\n{\n\ttcsetattr(STDERR_FILENO, TCSANOW, old_termios_p);\n\t_exit(EXIT_FAILURE);\n}",
        "baseline_code_stripped": "void __noreturn sub_4A181C()\n{\n  sub_409D89(10);\n  tcsetattr(dest.c_iflag, 0, (const struct termios *)&dest.c_oflag);\n  _exit(1);\n}\n",
        "baseline_code_debug": "void __cdecl __noreturn gotsig(int sig)\n{\n  bb_putchar_stderr(10);\n  tcsetattr(bb_common_bufsiz1.c_iflag, 0, (const struct termios *)&bb_common_bufsiz1.c_oflag);\n  _exit(1);\n}\n",
        "similarity_score_unixcoder": 0.8359205722808838,
        "similarity_score_baseline_stripped": 0.6328858733177185,
        "similarity_score_baseline_debug": 0.7952092289924622
    },
    {
        "func_name": "collect_ctx",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004606B5 | 55 | push    rbp\n0x004606B6 | 48 89 E5 | mov     rbp, rsp\n0x004606B9 | 48 83 EC 20 | sub     rsp, 20h\n0x004606BD | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x004606C1 | 48 8B 05 40 CD 2F 00 | mov     rax, cs:qword_75D408\n0x004606C8 | 48 83 C0 30 | add     rax, 30h ; '0'\n0x004606CC | 48 89 C7 | mov     rdi, rax\n0x004606CF | E8 A5 F1 FF FF | call    sub_45F879\n0x004606D4 | 48 89 C7 | mov     rdi, rax\n0x004606D7 | 48 8D 45 F0 | lea     rax, [rbp+var_10]\n0x004606DB | B9 01 00 00 00 | mov     ecx, 1\n0x004606E0 | 48 89 C2 | mov     rdx, rax\n0x004606E3 | BE 11 BE 51 00 | mov     esi, offset aProcesses; \"processes\"\n0x004606E8 | B8 00 00 00 00 | mov     eax, 0\n0x004606ED | E8 CD F3 FF FF | call    sub_45FABF\n0x004606F2 | 85 C0 | test    eax, eax\n0x004606F4 | 74 0C | jz      short loc_460702\n0x004606F6 | BF 04 00 00 00 | mov     edi, 4\n0x004606FB | E8 6C F0 FF FF | call    sub_45F76C\n0x00460700 | EB 3A | jmp     short locret_46073C\n0x00460702 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00460706 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x0046070A | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0046070E | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00460712 | 48 39 45 F8 | cmp     [rbp+var_8], rax\n0x00460716 | 76 08 | jbe     short loc_460720\n0x00460718 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0046071C | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00460720 | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x00460724 | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00460728 | 48 89 50 18 | mov     [rax+18h], rdx\n0x0046072C | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00460730 | 48 2B 45 F8 | sub     rax, [rbp+var_8]\n0x00460734 | 48 89 C7 | mov     rdi, rax\n0x00460737 | E8 D2 F6 FF FF | call    sub_45FE0E\n0x0046073C | C9 | leave\n0x0046073D | C3 | retn\n\n Ourput decompiled code:\nstatic void FAST_FUNC collect_fork(fork_stat *s)\n{\n\tullong data[1];\n\tullong old;\n\n\tif (rdval(get_file(&proc_stat), \"processes\", data, 1)) {\n\t\tput_question_marks(4);\n\t\treturn;\n\t}\n\n\told = s->old;\n\tif (data[0] < old) old = data[0];\t//sanitize\n\ts->old = data[0];\n\tscale(data[0] - old);\n}\n\n## Example:\n\n Input assembly code:\n0x00460B19 | 55 | push    rbp\n0x00460B1A | 48 89 E5 | mov     rbp, rsp\n0x00460B1D | 48 83 EC 20 | sub     rsp, 20h\n0x00460B21 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00460B25 | 48 8B 05 DC C8 2F 00 | mov     rax, cs:qword_75D408\n0x00460B2C | 48 83 C0 60 | add     rax, 60h ; '`'\n0x00460B30 | 48 89 C7 | mov     rdi, rax\n0x00460B33 | E8 41 ED FF FF | call    sub_45F879\n0x00460B38 | 48 89 C7 | mov     rdi, rax\n0x00460B3B | 48 8D 45 F8 | lea     rax, [rbp+var_8]\n0x00460B3F | B9 01 00 00 00 | mov     ecx, 1\n0x00460B44 | 48 89 C2 | mov     rdx, rax\n0x00460B47 | BE 49 BE 51 00 | mov     esi, offset aSwaptotal; \"SwapTotal:\"\n0x00460B4C | B8 00 00 00 00 | mov     eax, 0\n0x00460B51 | E8 69 EF FF FF | call    sub_45FABF\n0x00460B56 | 85 C0 | test    eax, eax\n0x00460B58 | 75 2A | jnz     short loc_460B84\n0x00460B5A | 48 8B 05 A7 C8 2F 00 | mov     rax, cs:qword_75D408\n0x00460B61 | 48 8B 40 60 | mov     rax, [rax+60h]\n0x00460B65 | 48 8D 55 F0 | lea     rdx, [rbp+var_10]\n0x00460B69 | B9 01 00 00 00 | mov     ecx, 1\n0x00460B6E | BE 54 BE 51 00 | mov     esi, offset aSwapfree; \"SwapFree:\"\n0x00460B73 | 48 89 C7 | mov     rdi, rax\n0x00460B76 | B8 00 00 00 00 | mov     eax, 0\n0x00460B7B | E8 3F EF FF FF | call    sub_45FABF\n0x00460B80 | 85 C0 | test    eax, eax\n0x00460B82 | 74 0C | jz      short loc_460B90\n0x00460B84 | BF 04 00 00 00 | mov     edi, 4\n0x00460B89 | E8 DE EB FF FF | call    sub_45F76C\n0x00460B8E | EB 1A | jmp     short locret_460BAA\n0x00460B90 | 48 8B 55 F8 | mov     rdx, [rbp+var_8]\n0x00460B94 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00460B98 | 48 29 C2 | sub     rdx, rax\n0x00460B9B | 48 89 D0 | mov     rax, rdx\n0x00460B9E | 48 C1 E0 0A | shl     rax, 0Ah\n0x00460BA2 | 48 89 C7 | mov     rdi, rax\n0x00460BA5 | E8 64 F2 FF FF | call    sub_45FE0E\n0x00460BAA | C9 | leave\n0x00460BAB | C3 | retn\n\n Ourput decompiled code:\nstatic void FAST_FUNC collect_swp(swp_stat *s UNUSED_PARAM)\n{\n\tullong s_total[1];\n\tullong s_free[1];\n\tif (rdval(get_file(&proc_meminfo), \"SwapTotal:\", s_total, 1)\n\t || rdval(proc_meminfo.file,       \"SwapFree:\" , s_free,  1)\n\t) {\n\t\tput_question_marks(4);\n\t\treturn;\n\t}\n\tscale((s_total[0]-s_free[0]) << 10);\n}\n\n## Example:\n\n Input assembly code:\n0x0046031C | 55 | push    rbp\n0x0046031D | 48 89 E5 | mov     rbp, rsp\n0x00460320 | 53 | push    rbx\n0x00460321 | 48 83 EC 28 | sub     rsp, 28h\n0x00460325 | 48 89 7D D8 | mov     [rbp+var_28], rdi\n0x00460329 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x0046032D | 8B 58 20 | mov     ebx, [rax+20h]\n0x00460330 | 48 8B 05 D1 D0 2F 00 | mov     rax, cs:qword_75D408\n0x00460337 | 48 83 C0 30 | add     rax, 30h ; '0'\n0x0046033B | 48 89 C7 | mov     rdi, rax\n0x0046033E | E8 36 F5 FF FF | call    sub_45F879\n0x00460343 | 48 89 C7 | mov     rdi, rax\n0x00460346 | 48 8D 45 E0 | lea     rax, [rbp+var_20]\n0x0046034A | 89 D9 | mov     ecx, ebx\n0x0046034C | 48 89 C2 | mov     rdx, rax\n0x0046034F | BE 02 BE 51 00 | mov     esi, offset aIntr_0; \"intr\"\n0x00460354 | B8 00 00 00 00 | mov     eax, 0\n0x00460359 | E8 61 F7 FF FF | call    sub_45FABF\n0x0046035E | 85 C0 | test    eax, eax\n0x00460360 | 74 0C | jz      short loc_46036E\n0x00460362 | BF 04 00 00 00 | mov     edi, 4\n0x00460367 | E8 00 F4 FF FF | call    sub_45F76C\n0x0046036C | EB 3A | jmp     short loc_4603A8\n0x0046036E | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00460372 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x00460376 | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x0046037A | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0046037E | 48 39 45 E8 | cmp     [rbp+var_18], rax\n0x00460382 | 76 08 | jbe     short loc_46038C\n0x00460384 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x00460388 | 48 89 45 E8 | mov     [rbp+var_18], rax\n0x0046038C | 48 8B 55 E0 | mov     rdx, [rbp+var_20]\n0x00460390 | 48 8B 45 D8 | mov     rax, [rbp+var_28]\n0x00460394 | 48 89 50 18 | mov     [rax+18h], rdx\n0x00460398 | 48 8B 45 E0 | mov     rax, [rbp+var_20]\n0x0046039C | 48 2B 45 E8 | sub     rax, [rbp+var_18]\n0x004603A0 | 48 89 C7 | mov     rdi, rax\n0x004603A3 | E8 66 FA FF FF | call    sub_45FE0E\n0x004603A8 | 48 83 C4 28 | add     rsp, 28h\n0x004603AC | 5B | pop     rbx\n0x004603AD | 5D | pop     rbp\n0x004603AE | C3 | retn\n\n Ourput decompiled code:\nstatic void FAST_FUNC collect_int(int_stat *s)\n{\n\tullong data[1];\n\tullong old;\n\n\tif (rdval(get_file(&proc_stat), \"intr\", data, s->no)) {\n\t\tput_question_marks(4);\n\t\treturn;\n\t}\n\n\told = s->old;\n\tif (data[0] < old) old = data[0];\t\t//sanitize\n\ts->old = data[0];\n\tscale(data[0] - old);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x0046040F | 55 | push    rbp\n0x00460410 | 48 89 E5 | mov     rbp, rsp\n0x00460413 | 48 83 EC 20 | sub     rsp, 20h\n0x00460417 | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x0046041B | 48 8B 05 E6 CF 2F 00 | mov     rax, cs:qword_75D408\n0x00460422 | 48 83 C0 30 | add     rax, 30h ; '0'\n0x00460426 | 48 89 C7 | mov     rdi, rax\n0x00460429 | E8 4B F4 FF FF | call    sub_45F879\n0x0046042E | 48 89 C7 | mov     rdi, rax\n0x00460431 | 48 8D 45 F0 | lea     rax, [rbp+var_10]\n0x00460435 | B9 01 00 00 00 | mov     ecx, 1\n0x0046043A | 48 89 C2 | mov     rdx, rax\n0x0046043D | BE 07 BE 51 00 | mov     esi, offset aCtxt; \"ctxt\"\n0x00460442 | B8 00 00 00 00 | mov     eax, 0\n0x00460447 | E8 73 F6 FF FF | call    sub_45FABF\n0x0046044C | 85 C0 | test    eax, eax\n0x0046044E | 74 0C | jz      short loc_46045C\n0x00460450 | BF 04 00 00 00 | mov     edi, 4\n0x00460455 | E8 12 F3 FF FF | call    sub_45F76C\n0x0046045A | EB 3A | jmp     short locret_460496\n0x0046045C | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00460460 | 48 8B 40 18 | mov     rax, [rax+18h]\n0x00460464 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x00460468 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0046046C | 48 39 45 F8 | cmp     [rbp+var_8], rax\n0x00460470 | 76 08 | jbe     short loc_46047A\n0x00460472 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x00460476 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0046047A | 48 8B 55 F0 | mov     rdx, [rbp+var_10]\n0x0046047E | 48 8B 45 E8 | mov     rax, [rbp+var_18]\n0x00460482 | 48 89 50 18 | mov     [rax+18h], rdx\n0x00460486 | 48 8B 45 F0 | mov     rax, [rbp+var_10]\n0x0046048A | 48 2B 45 F8 | sub     rax, [rbp+var_8]\n0x0046048E | 48 89 C7 | mov     rdi, rax\n0x00460491 | E8 78 F9 FF FF | call    sub_45FE0E\n0x00460496 | C9 | leave\n0x00460497 | C3 | retn",
        "output": "",
        "source_code": "static void FAST_FUNC collect_ctx(ctx_stat *s)\n{\n\tullong data[1];\n\tullong old;\n\n\tif (rdval(get_file(&proc_stat), \"ctxt\", data, 1)) {\n\t\tput_question_marks(4);\n\t\treturn;\n\t}\n\n\told = s->old;\n\tif (data[0] < old) old = data[0];\t\t//sanitize\n\ts->old = data[0];\n\tscale(data[0] - old);\n}",
        "parsed_output": "",
        "baseline_code_stripped": "void *__fastcall sub_46040F(__int64 a1)\n{\n  const char *v1; // rax\n  __int64 v2; // r8\n  __int64 v3; // r9\n  unsigned __int64 v5; // [rsp+10h] [rbp-10h] BYREF\n  unsigned __int64 v6; // [rsp+18h] [rbp-8h]\n\n  v1 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 48);\n  if ( (unsigned int)sub_45FABF(v1, \"ctxt\", &v5, 1LL, v2, v3) )\n    return (void *)sub_45F76C(4u);\n  v6 = *(_QWORD *)(a1 + 24);\n  if ( v6 > v5 )\n    v6 = v5;\n  *(_QWORD *)(a1 + 24) = v5;\n  return sub_45FE0E(v5 - v6);\n}\n",
        "baseline_code_debug": "void __cdecl collect_ctx(ctx_stat_0 *s)\n{\n  const char *file; // rax\n  ullong data[1]; // [rsp+10h] [rbp-10h] BYREF\n  ullong old; // [rsp+18h] [rbp-8h]\n\n  file = get_file((proc_file_0 *)&ptr_to_globals->numspeed);\n  if ( rdval(file, \"ctxt\", data, 1LL) )\n  {\n    put_question_marks(4);\n  }\n  else\n  {\n    old = s->old;\n    if ( old > data[0] )\n      old = data[0];\n    s->old = data[0];\n    scale_0(data[0] - old);\n  }\n}\n",
        "similarity_score_unixcoder": 0.07712340354919434,
        "similarity_score_baseline_stripped": 0.4337996244430542,
        "similarity_score_baseline_debug": 0.8380545973777771
    },
    {
        "func_name": "getpwd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x0045F8E2 | 55 | push    rbp\n0x0045F8E3 | 48 89 E5 | mov     rbp, rsp\n0x0045F8E6 | 48 83 EC 10 | sub     rsp, 10h\n0x0045F8EA | 48 89 7D F8 | mov     [rbp+s], rdi\n0x0045F8EE | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x0045F8F2 | BE 2F 00 00 00 | mov     esi, 2Fh ; '/'; c\n0x0045F8F7 | 48 89 C7 | mov     rdi, rax; s\n0x0045F8FA | E8 C1 72 FA FF | call    _strchr\n0x0045F8FF | 48 89 45 F8 | mov     [rbp+s], rax\n0x0045F903 | 48 83 7D F8 00 | cmp     [rbp+s], 0\n0x0045F908 | 75 07 | jnz     short loc_45F911\n0x0045F90A | B8 00 00 00 00 | mov     eax, 0\n0x0045F90F | EB 1A | jmp     short locret_45F92B\n0x0045F911 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x0045F915 | 48 83 C0 01 | add     rax, 1\n0x0045F919 | BA 0A 00 00 00 | mov     edx, 0Ah; base\n0x0045F91E | BE 00 00 00 00 | mov     esi, 0; endptr\n0x0045F923 | 48 89 C7 | mov     rdi, rax; nptr\n0x0045F926 | E8 B5 76 FA FF | call    _strtoull\n0x0045F92B | C9 | leave\n0x0045F92C | C3 | retn\n\n Ourput decompiled code:\nstatic ullong read_after_slash(const char *p)\n{\n\tp = strchr(p, '/');\n\tif (!p) return 0;\n\treturn strtoull(p+1, NULL, 10);\n}\n\n## Example:\n\n Input assembly code:\n0x00490C41 | 55 | push    rbp\n0x00490C42 | 48 89 E5 | mov     rbp, rsp\n0x00490C45 | 48 83 EC 10 | sub     rsp, 10h\n0x00490C49 | 48 89 7D F8 | mov     [rbp+s], rdi\n0x00490C4D | 48 83 7D F8 00 | cmp     [rbp+s], 0\n0x00490C52 | 74 16 | jz      short loc_490C6A\n0x00490C54 | 48 8B 45 F8 | mov     rax, [rbp+s]\n0x00490C58 | BA 10 00 00 00 | mov     edx, 10h; n\n0x00490C5D | BE 00 00 00 00 | mov     esi, 0; c\n0x00490C62 | 48 89 C7 | mov     rdi, rax; s\n0x00490C65 | E8 E6 60 F7 FF | call    _memset\n0x00490C6A | 90 | nop\n0x00490C6B | C9 | leave\n0x00490C6C | C3 | retn\n\n Ourput decompiled code:\nstatic void\nclear_partition(struct partition *p)\n{\n\tif (p)\n\t\tmemset(p, 0, sizeof(*p));\n}\n\n## Example:\n\n Input assembly code:\n0x0040A020 | 55 | push    rbp\n0x0040A021 | 48 89 E5 | mov     rbp, rsp\n0x0040A024 | 48 83 EC 20 | sub     rsp, 20h\n0x0040A028 | 48 89 7D E8 | mov     [rbp+size], rdi\n0x0040A02C | 48 8B 45 E8 | mov     rax, [rbp+size]\n0x0040A030 | 48 89 C7 | mov     rdi, rax; size\n0x0040A033 | E8 28 D3 FF FF | call    _malloc\n0x0040A038 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0040A03C | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x0040A041 | 75 16 | jnz     short loc_40A059\n0x0040A043 | 48 83 7D E8 00 | cmp     [rbp+size], 0\n0x0040A048 | 74 0F | jz      short loc_40A059\n0x0040A04A | BF 2A 4D 53 00 | mov     edi, offset aOutOfMemory; \"out of memory\"\n0x0040A04F | B8 00 00 00 00 | mov     eax, 0\n0x0040A054 | E8 EE F6 FF FF | call    sub_409747\n0x0040A059 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x0040A05D | C9 | leave\n0x0040A05E | C3 | retn\n\n Ourput decompiled code:\nFAST_FUNC malloc_or_warn(size_t size)\n{\n\tvoid *ptr = malloc(size);\n\tif (ptr == NULL && size != 0)\n\t\tbb_error_msg(bb_msg_memory_exhausted);\n\treturn ptr;\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00470064 | 55 | push    rbp\n0x00470065 | 48 89 E5 | mov     rbp, rsp\n0x00470068 | 48 83 EC 10 | sub     rsp, 10h\n0x0047006C | BE 00 00 00 00 | mov     esi, 0; size\n0x00470071 | BF 00 00 00 00 | mov     edi, 0; buf\n0x00470076 | E8 45 6D F9 FF | call    _getcwd\n0x0047007B | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x0047007F | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x00470084 | 75 0D | jnz     short loc_470093\n0x00470086 | 48 8B 05 8B D3 2E 00 | mov     rax, cs:qword_75D418\n0x0047008D | 48 83 C0 38 | add     rax, 38h ; '8'\n0x00470091 | EB 04 | jmp     short locret_470097\n0x00470093 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00470097 | C9 | leave\n0x00470098 | C3 | retn",
        "output": "\n\nstatic char *\nget_current_dir(void)\n{\n\tchar *buf = getcwd(NULL, 0);\n\tif (buf == NULL)\n\t\tbuf = (char *)&bb_msg_current_directory_unknown['8'];\n\treturn buf;\n}",
        "source_code": "static char *\ngetpwd(void)\n{\n\tchar *dir = getcwd(NULL, 0); /* huh, using glibc extension? */\n\treturn dir ? dir : nullstr;\n}",
        "parsed_output": "\n\nstatic char *\nget_current_dir(void)\n{\n\tchar *buf = getcwd(NULL, 0);\n\tif (buf == NULL)\n\t\tbuf = (char *)&bb_msg_current_directory_unknown['8'];\n\treturn buf;\n}",
        "baseline_code_stripped": "__int64 sub_470064()\n{\n  char *v1; // [rsp+8h] [rbp-8h]\n\n  v1 = getcwd(0LL, 0LL);\n  if ( v1 )\n    return (__int64)v1;\n  else\n    return qword_75D418 + 56;\n}\n",
        "baseline_code_debug": "char *__cdecl getpwd()\n{\n  char *dir; // [rsp+8h] [rbp-8h]\n\n  dir = getcwd(0LL, 0LL);\n  if ( dir )\n    return dir;\n  else\n    return ash_ptr_to_globals_misc->nullstr;\n}\n",
        "similarity_score_unixcoder": 0.7433938384056091,
        "similarity_score_baseline_stripped": 0.542474627494812,
        "similarity_score_baseline_debug": 0.8041582107543945
    },
    {
        "func_name": "builtin_help",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary ***FUNCTION***, with the form of the x86-64 assembly instructions (e.g., derived from the disassembling tools like IDA pro or Ghidra). Your task is to first fully comprehend the code, and then decompile provided assembly instructions into the C-like source code.\n\n\n# Input & Output format\n\nYour input data is a set of assembly instructions, and your output should be the decompiled C-like source code. Remember, your output will include the revised code ONLY and NOTHING ELSE. You DO NOT need to provide any extra text for explanation. *** NO additional text should be provided in your output***. \n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input assembly code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input assembly code:\n0x004A5902 | 55 | push    rbp\n0x004A5903 | 48 89 E5 | mov     rbp, rsp\n0x004A5906 | 48 83 EC 20 | sub     rsp, 20h\n0x004A590A | 48 89 7D E8 | mov     [rbp+s1], rdi\n0x004A590E | BF 01 00 00 00 | mov     edi, 1\n0x004A5913 | E8 54 FE FF FF | call    sub_4A576C\n0x004A5918 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004A591C | EB 47 | jmp     short loc_4A5965\n0x004A591E | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004A5922 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x004A5926 | 0F B6 00 | movzx   eax, byte ptr [rax]\n0x004A5929 | 84 C0 | test    al, al\n0x004A592B | 74 2D | jz      short loc_4A595A\n0x004A592D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004A5931 | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x004A5935 | 48 8B 45 E8 | mov     rax, [rbp+s1]\n0x004A5939 | 48 89 D6 | mov     rsi, rdx; s2\n0x004A593C | 48 89 C7 | mov     rdi, rax; s1\n0x004A593F | E8 0C 17 F6 FF | call    _strcmp\n0x004A5944 | 85 C0 | test    eax, eax\n0x004A5946 | 75 12 | jnz     short loc_4A595A\n0x004A5948 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004A594C | 48 8B 40 08 | mov     rax, [rax+8]\n0x004A5950 | 48 89 C7 | mov     rdi, rax\n0x004A5953 | E8 C7 47 F6 FF | call    sub_40A11F\n0x004A5958 | EB 17 | jmp     short locret_4A5971\n0x004A595A | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004A595E | 48 8B 00 | mov     rax, [rax]\n0x004A5961 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004A5965 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004A596A | 75 B2 | jnz     short loc_4A591E\n0x004A596C | B8 00 00 00 00 | mov     eax, 0\n0x004A5971 | C9 | leave\n0x004A5972 | C3 | retn\n\n Ourput decompiled code:\nchar *get_devname_from_label(const char *spec)\n{\n\tstruct uuidCache_s *uc;\n\n\tuc = uuidcache_init(/*scan_devices:*/ 1);\n\twhile (uc) {\n\t\tif (uc->label[0] && strcmp(spec, uc->label) == 0) {\n\t\t\treturn xstrdup(uc->device);\n\t\t}\n\t\tuc = uc->next;\n\t}\n\treturn NULL;\n}\n\n## Example:\n\n Input assembly code:\n0x004A5973 | 55 | push    rbp\n0x004A5974 | 48 89 E5 | mov     rbp, rsp\n0x004A5977 | 48 83 EC 20 | sub     rsp, 20h\n0x004A597B | 48 89 7D E8 | mov     [rbp+s1], rdi\n0x004A597F | BF 01 00 00 00 | mov     edi, 1\n0x004A5984 | E8 E3 FD FF FF | call    sub_4A576C\n0x004A5989 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004A598D | EB 38 | jmp     short loc_4A59C7\n0x004A598F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004A5993 | 48 8B 50 18 | mov     rdx, [rax+18h]\n0x004A5997 | 48 8B 45 E8 | mov     rax, [rbp+s1]\n0x004A599B | 48 89 D6 | mov     rsi, rdx; s2\n0x004A599E | 48 89 C7 | mov     rdi, rax; s1\n0x004A59A1 | E8 1A 0D F6 FF | call    _strcasecmp\n0x004A59A6 | 85 C0 | test    eax, eax\n0x004A59A8 | 75 12 | jnz     short loc_4A59BC\n0x004A59AA | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004A59AE | 48 8B 40 08 | mov     rax, [rax+8]\n0x004A59B2 | 48 89 C7 | mov     rdi, rax\n0x004A59B5 | E8 65 47 F6 FF | call    sub_40A11F\n0x004A59BA | EB 17 | jmp     short locret_4A59D3\n0x004A59BC | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004A59C0 | 48 8B 00 | mov     rax, [rax]\n0x004A59C3 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004A59C7 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004A59CC | 75 C1 | jnz     short loc_4A598F\n0x004A59CE | B8 00 00 00 00 | mov     eax, 0\n0x004A59D3 | C9 | leave\n0x004A59D4 | C3 | retn\n\n Ourput decompiled code:\nchar *get_devname_from_uuid(const char *spec)\n{\n\tstruct uuidCache_s *uc;\n\n\tuc = uuidcache_init(/*scan_devices:*/ 1);\n\twhile (uc) {\n\t\t/* case of hex numbers doesn't matter */\n\t\tif (strcasecmp(spec, uc->uc_uuid) == 0) {\n\t\t\treturn xstrdup(uc->device);\n\t\t}\n\t\tuc = uc->next;\n\t}\n\treturn NULL;\n}\n\n## Example:\n\n Input assembly code:\n0x004E9DD5 | 55 | push    rbp\n0x004E9DD6 | 48 89 E5 | mov     rbp, rsp\n0x004E9DD9 | 48 83 EC 20 | sub     rsp, 20h\n0x004E9DDD | 48 89 7D E8 | mov     [rbp+s2], rdi\n0x004E9DE1 | B8 F8 B3 75 00 | mov     eax, offset dest\n0x004E9DE6 | 48 8B 80 88 00 00 00 | mov     rax, [rax+88h]\n0x004E9DED | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004E9DF1 | EB 45 | jmp     short loc_4E9E38\n0x004E9DF3 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004E9DF7 | 0F B6 40 46 | movzx   eax, byte ptr [rax+46h]\n0x004E9DFB | 3C 3A | cmp     al, 3Ah ; ':'\n0x004E9DFD | 75 2E | jnz     short loc_4E9E2D\n0x004E9DFF | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004E9E03 | 48 8B 40 38 | mov     rax, [rax+38h]\n0x004E9E07 | 48 85 C0 | test    rax, rax\n0x004E9E0A | 74 21 | jz      short loc_4E9E2D\n0x004E9E0C | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004E9E10 | 48 8B 40 38 | mov     rax, [rax+38h]\n0x004E9E14 | 48 8B 55 E8 | mov     rdx, [rbp+s2]\n0x004E9E18 | 48 89 D6 | mov     rsi, rdx; s2\n0x004E9E1B | 48 89 C7 | mov     rdi, rax; s1\n0x004E9E1E | E8 2D D2 F1 FF | call    _strcmp\n0x004E9E23 | 85 C0 | test    eax, eax\n0x004E9E25 | 75 06 | jnz     short loc_4E9E2D\n0x004E9E27 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004E9E2B | EB 28 | jmp     short locret_4E9E55\n0x004E9E2D | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x004E9E31 | 48 8B 00 | mov     rax, [rax]\n0x004E9E34 | 48 89 45 F8 | mov     [rbp+var_8], rax\n0x004E9E38 | 48 83 7D F8 00 | cmp     [rbp+var_8], 0\n0x004E9E3D | 75 B4 | jnz     short loc_4E9DF3\n0x004E9E3F | 48 8B 45 E8 | mov     rax, [rbp+s2]\n0x004E9E43 | 48 89 C6 | mov     rsi, rax\n0x004E9E46 | BF 30 6F 52 00 | mov     edi, offset aCanTFindLabelF; \"can't find label for jump to '%s'\"\n0x004E9E4B | B8 00 00 00 00 | mov     eax, 0\n0x004E9E50 | E8 49 F8 F1 FF | call    sub_40969E\n0x004E9E55 | C9 | leave\n0x004E9E56 | C3 | retn\n\n Ourput decompiled code:\nstatic sed_cmd_t *branch_to(char *label)\n{\n\tsed_cmd_t *sed_cmd;\n\n\tfor (sed_cmd = G.sed_cmd_head; sed_cmd; sed_cmd = sed_cmd->next) {\n\t\tif (sed_cmd->cmd == ':' && sed_cmd->string && !strcmp(sed_cmd->string, label)) {\n\t\t\treturn sed_cmd;\n\t\t}\n\t}\n\tbb_error_msg_and_die(\"can't find label for jump to '%s'\", label);\n}\n# Data to be processed\n\nBelow is the assembly code you will process. You will analyze the code and output the decompiled code:\n0x00489C62 | 55 | push    rbp\n0x00489C63 | 48 89 E5 | mov     rbp, rsp\n0x00489C66 | 48 83 EC 20 | sub     rsp, 20h\n0x00489C6A | 48 89 7D E8 | mov     [rbp+var_18], rdi\n0x00489C6E | BF 18 F0 51 00 | mov     edi, offset aBuiltInCommand; \"Built-in commands:\\n------------------\"\n0x00489C73 | E8 98 CB F7 FF | call    _puts\n0x00489C78 | 48 C7 45 F8 80 E2 51 00 | mov     [rbp+var_8], offset off_51E280; \".\"\n0x00489C80 | EB 33 | jmp     short loc_489CB5\n0x00489C82 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00489C86 | 48 8B 40 10 | mov     rax, [rax+10h]\n0x00489C8A | 48 85 C0 | test    rax, rax\n0x00489C8D | 74 21 | jz      short loc_489CB0\n0x00489C8F | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00489C93 | 48 8B 50 10 | mov     rdx, [rax+10h]\n0x00489C97 | 48 8B 45 F8 | mov     rax, [rbp+var_8]\n0x00489C9B | 48 8B 00 | mov     rax, [rax]\n0x00489C9E | 48 89 C6 | mov     rsi, rax\n0x00489CA1 | BF 3E F0 51 00 | mov     edi, offset a10sS_0; \"%-10s%s\\n\"\n0x00489CA6 | B8 00 00 00 00 | mov     eax, 0\n0x00489CAB | E8 20 CF F7 FF | call    _printf\n0x00489CB0 | 48 83 45 F8 18 | add     [rbp+var_8], 18h\n0x00489CB5 | 48 81 7D F8 F0 E4 51 00 | cmp     [rbp+var_8], offset unk_51E4F0\n0x00489CBD | 75 C3 | jnz     short loc_489C82\n0x00489CBF | BF 0A 00 00 00 | mov     edi, 0Ah\n0x00489CC4 | E8 90 09 F8 FF | call    sub_40A659\n0x00489CC9 | B8 00 00 00 00 | mov     eax, 0\n0x00489CCE | C9 | leave\n0x00489CCF | C3 | retn",
        "output": "\n\nstatic void\nbuiltin_help(void)\n{\n\tchar *cp;\n\n\tputs(\"Built-in commands:\\n------------------\");\n\tfor (cp = (char *)&off_51E280; *(long *)cp; cp += sizeof(struct cmd)) {\n\t\tif (*(struct cmd *)cp) {\n\t\t\tprintf(\"%-10s%s\\n\",\n\t\t\t    ((struct cmd *)cp)->name,\n\t\t\t    ((struct cmd *)cp)->desc);\n\t\t}\n\t}\n\t(void)fflush(stdout);\n}",
        "source_code": "if ENABLE_HUSH_HELP\nstatic int FAST_FUNC builtin_help(char **argv UNUSED_PARAM)\n{\n\tconst struct built_in_command *x;\n\n\tprintf(\n\t\t\"Built-in commands:\\n\"\n\t\t\"------------------\\n\");\n\tfor (x = bltins1; x != &bltins1[ARRAY_SIZE(bltins1)]; x++) {\n\t\tif (x->b_descr)\n\t\t\tprintf(\"%-10s%s\\n\", x->b_cmd, x->b_descr);\n\t}\n\tbb_putchar('\\n');\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "\n\nstatic void\nbuiltin_help(void)\n{\n\tchar *cp;\n\n\tputs(\"Built-in commands:\\n------------------\");\n\tfor (cp = (char *)&off_51E280; *(long *)cp; cp += sizeof(struct cmd)) {\n\t\tif (*(struct cmd *)cp) {\n\t\t\tprintf(\"%-10s%s\\n\",\n\t\t\t    ((struct cmd *)cp)->name,\n\t\t\t    ((struct cmd *)cp)->desc);\n\t\t}\n\t}\n\t(void)fflush(stdout);\n}",
        "baseline_code_stripped": "__int64 sub_489C62()\n{\n  const char **i; // [rsp+18h] [rbp-8h]\n\n  puts(\"Built-in commands:\\n------------------\");\n  for ( i = (const char **)&off_51E280; i != (const char **)&unk_51E4F0; i += 3 )\n  {\n    if ( i[2] )\n      printf(\"%-10s%s\\n\", *i, i[2]);\n  }\n  sub_40A659(10);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl builtin_help(char **argv)\n{\n  const built_in_command *x; // [rsp+18h] [rbp-8h]\n\n  puts(\"Built-in commands:\\n------------------\");\n  for ( x = bltins1; x != &stru_51E4F0; ++x )\n  {\n    if ( x->b_descr )\n      printf(\"%-10s%s\\n\", x->b_cmd, x->b_descr);\n  }\n  bb_putchar(10);\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.8531654477119446,
        "similarity_score_baseline_stripped": 0.6579736471176147,
        "similarity_score_baseline_debug": 0.8908040523529053
    }
]
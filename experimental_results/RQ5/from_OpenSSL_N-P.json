[
    {
        "func_name": "rtnl_rtprot_n2a",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_45243B(__int64 a1, char *a2)\n{\n  if ( (unsigned int)a1 < 0x100 )\n  {\n    sub_4523E0(a1, (__int64)a2);\n    if ( *(_QWORD *)(qword_75B1B8 + 8 * ((int)a1 + 2LL)) )\n      return *(char **)(qword_75B1B8 + 8 * ((int)a1 + 2LL));\n  }\n  sprintf(a2, \"%d\", (unsigned int)a1);\n  return a2;\n}\n",
        "output": "char *formatIntegerAsString(__int64 number, char *buffer)\n{\n  if (number < 256)\n  {\n    processNumber(number, (__int64)buffer);\n    char **lookupResult = (char **)(qword_75B1B8 + 8 * (number + 2));\n    if (*lookupResult)\n      return *lookupResult;\n  }\n  sprintf(buffer, \"%d\", (unsigned int)number);\n  return buffer;\n}",
        "source_code": "FAST_FUNC rtnl_rtprot_n2a(int id, char *buf)\n{\n\tif (id < 0 || id >= 256) {\n\t\tsprintf(buf, \"%d\", id);\n\t\treturn buf;\n\t}\n\n\trtnl_rtprot_initialize();\n\n\tif (rtnl_rtprot_tab->tab[id])\n\t\treturn rtnl_rtprot_tab->tab[id];\n\t/* buf is SPRINT_BSIZE big */\n\tsprintf(buf, \"%d\", id);\n\treturn buf;\n}",
        "parsed_output": "char *formatIntegerAsString(__int64 number, char *buffer)\n{\n  if (number < 256)\n  {\n    processNumber(number, (__int64)buffer);\n    char **lookupResult = (char **)(qword_75B1B8 + 8 * (number + 2));\n    if (*lookupResult)\n      return *lookupResult;\n  }\n  sprintf(buffer, \"%d\", (unsigned int)number);\n  return buffer;\n}",
        "baseline_code_stripped": "char *__fastcall sub_45243B(__int64 a1, char *a2)\n{\n  if ( (unsigned int)a1 < 0x100 )\n  {\n    sub_4523E0(a1, (__int64)a2);\n    if ( *(_QWORD *)(qword_75B1B8 + 8 * ((int)a1 + 2LL)) )\n      return *(char **)(qword_75B1B8 + 8 * ((int)a1 + 2LL));\n  }\n  sprintf(a2, \"%d\", (unsigned int)a1);\n  return a2;\n}\n",
        "baseline_code_debug": "const char *__cdecl rtnl_rtprot_n2a(int id, char *buf)\n{\n  if ( (unsigned int)id < 0x100 )\n  {\n    rtnl_rtprot_initialize();\n    if ( rtnl_rtprot_tab->tab[id] )\n      return rtnl_rtprot_tab->tab[id];\n  }\n  sprintf(buf, \"%d\", (unsigned int)id);\n  return buf;\n}\n",
        "similarity_score_unixcoder": 0.5112435817718506,
        "similarity_score_baseline_stripped": 0.5272172689437866,
        "similarity_score_baseline_debug": 0.936894953250885
    },
    {
        "func_name": "parse_mount_options",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4A1EAA(const char *a1, char **a2)\n{\n  char *v2; // rax\n  unsigned int v3; // eax\n  __int64 v4; // rbx\n  size_t v5; // rax\n  int v6; // eax\n  char *s; // [rsp+8h] [rbp-58h]\n  char *v9; // [rsp+10h] [rbp-50h]\n  char *v10; // [rsp+10h] [rbp-50h]\n  __int64 v11; // [rsp+18h] [rbp-48h]\n  unsigned int n; // [rsp+24h] [rbp-3Ch]\n  size_t n_4; // [rsp+28h] [rbp-38h]\n  unsigned int v14; // [rsp+34h] [rbp-2Ch]\n  char *s1; // [rsp+38h] [rbp-28h]\n  unsigned int i; // [rsp+44h] [rbp-1Ch]\n  __int64 v17; // [rsp+48h] [rbp-18h]\n\n  s = (char *)a1;\n  v17 = 0x8000LL;\n  v2 = strchr(a1, 44);\n  while ( 2 )\n  {\n    n_4 = (size_t)v2;\n    s1 = \"loop\";\n    if ( v2 )\n      *v2 = 0;\n    for ( i = 0; i <= 0x2A; ++i )\n    {\n      n = strlen(s1);\n      if ( !strncasecmp(s1, s, n) && (!s[n] || s1[n - 1] == 61) )\n      {\n        v11 = dword_522120[i];\n        if ( (int)v11 >= 0 )\n          v17 |= v11;\n        else\n          v17 &= v11;\n        goto LABEL_21;\n      }\n      s1 += n + 1;\n    }\n    if ( *s && a2 )\n    {\n      v9 = *a2;\n      if ( *a2 )\n        v3 = strlen(v9);\n      else\n        v3 = 0;\n      v14 = v3;\n      v4 = v3;\n      v5 = strlen(s);\n      v10 = (char *)sub_40A09E(v9, v4 + v5 + 2);\n      *a2 = v10;\n      if ( v14 )\n      {\n        v6 = v14++;\n        v10[v6] = 44;\n      }\n      strcpy(&v10[v14], s);\n    }\nLABEL_21:\n    if ( n_4 )\n    {\n      *(_BYTE *)n_4 = 44;\n      s = (char *)(n_4 + 1);\n      v2 = strchr((const char *)(n_4 + 1), 44);\n      continue;\n    }\n    return v17;\n  }\n}\n",
        "output": "```c\n__int64 __fastcall parseAndSetFlags(const char *input, char **output)\n{\n  char *nextToken;\n  unsigned int outputLen;\n  __int64 flags;\n  size_t tokenLen;\n  int tempLen;\n  char *currentToken;\n  char *nextSubToken;\n  __int64 flagValue;\n  unsigned int subTokenLen;\n  size_t nextTokenLen;\n  unsigned int appendedLen;\n  char *subToken;\n  unsigned int subTokenIndex;\n  __int64 tempFlagValue;\n\n  currentToken = (char *)input;\n  flags = 0x8000LL;\n  nextToken = strchr(input, ',');\n  while (1)\n  {\n    tokenLen = (size_t)nextToken;\n    subToken = \"loop\";\n    if (nextToken)\n      *nextToken = '\\0';\n    for (subTokenIndex = 0; subTokenIndex <= 0x2A; ++subTokenIndex)\n    {\n      subTokenLen = strlen(subToken);\n      if (!strncasecmp(subToken, currentToken, subTokenLen) && (!currentToken[subTokenLen] || subToken[subTokenLen - 1] == '='))\n      {\n        flagValue = dword_522120[subTokenIndex];\n        if ((int)flagValue >= 0)\n          flags |= flagValue;\n        else\n          flags &= flagValue;\n        goto POST_TOKEN_PROCESSING;\n      }\n      subToken += subTokenLen + 1;\n    }\n    if (*currentToken && output)\n    {\n      nextSubToken = *output;\n      if (nextSubToken)\n        outputLen = strlen(nextSubToken);\n      else\n        outputLen = 0;\n      appendedLen = outputLen;\n      tempLen = outputLen;\n      nextTokenLen = strlen(currentToken);\n      nextSubToken = (char *)sub_40A09E(nextSubToken, tempLen + nextTokenLen + 2);\n      *output = nextSubToken;\n      if (appendedLen)\n      {\n        tempLen = appendedLen++;\n        nextSubToken[tempLen] = ',';\n      }\n      strcpy(&nextSubToken[appendedLen], currentToken);\n    }\nPOST_TOKEN_PROCESSING:\n    if (tokenLen)\n    {\n      *(_BYTE *)tokenLen = ',';\n      currentToken = (char *)(tokenLen + 1);\n      nextToken = strchr((const char *)(tokenLen + 1), ',');\n      continue;\n    }\n    return flags;\n  }\n}\n```",
        "source_code": "NULL\nstatic unsigned long parse_mount_options(char *options, char **unrecognized)\n{\n\tunsigned long flags = MS_SILENT;\n\n\t// Loop through options\n\tfor (;;) {\n\t\tunsigned i;\n\t\tchar *comma = strchr(options, ',');\n\t\tconst char *option_str = mount_option_str;\n\n\t\tif (comma) *comma = '\\0';\n\n// FIXME: use hasmntopt()\n\t\t// Find this option in mount_options\n\t\tfor (i = 0; i < ARRAY_SIZE(mount_options); i++) {\n\t\t\tunsigned opt_len = strlen(option_str);\n\n\t\t\tif (strncasecmp(option_str, options, opt_len) == 0\n\t\t\t && (options[opt_len] == '\\0'\n\t\t\t    /* or is it \"comment=\" thingy in fstab? */\n\t\t\t    IF_FEATURE_MOUNT_FSTAB(IF_DESKTOP( || option_str[opt_len-1] == '=' ))\n\t\t\t    )\n\t\t\t) {\n\t\t\t\tunsigned long fl = mount_options[i];\n\t\t\t\tif (fl & BB_MS_INVERTED_VALUE)\n\t\t\t\t\tflags &= fl;\n\t\t\t\telse\n\t\t\t\t\tflags |= fl;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t\toption_str += opt_len + 1;\n\t\t}\n\t\t// We did not recognize this option.\n\t\t// If \"unrecognized\" is not NULL, append option there.\n\t\t// Note that we should not append *empty* option -\n\t\t// in this case we want to pass NULL, not \"\", to \"data\"\n\t\t// parameter of mount(2) syscall.\n\t\t// This is crucial for filesystems that don't accept\n\t\t// any arbitrary mount options, like cgroup fs:\n\t\t// \"mount -t cgroup none /mnt\"\n\t\tif (options[0] && unrecognized) {\n\t\t\t// Add it to strflags, to pass on to kernel\n\t\t\tchar *p = *unrecognized;\n\t\t\tunsigned len = p ? strlen(p) : 0;\n\t\t\t*unrecognized = p = xrealloc(p, len + strlen(options) + 2);\n\n\t\t\t// Comma separated if it's not the first one\n\t\t\tif (len) p[len++] = ',';\n\t\t\tstrcpy(p + len, options);\n\t\t}\n found:\n\t\tif (!comma)\n\t\t\tbreak;\n\t\t// Advance to next option\n\t\t*comma = ',';\n\t\toptions = ++comma;\n\t}\n\n\treturn flags;\n}",
        "parsed_output": "__int64 __fastcall parseAndSetFlags(const char *input, char **output)\n{\n  char *nextToken;\n  unsigned int outputLen;\n  __int64 flags;\n  size_t tokenLen;\n  int tempLen;\n  char *currentToken;\n  char *nextSubToken;\n  __int64 flagValue;\n  unsigned int subTokenLen;\n  size_t nextTokenLen;\n  unsigned int appendedLen;\n  char *subToken;\n  unsigned int subTokenIndex;\n  __int64 tempFlagValue;\n\n  currentToken = (char *)input;\n  flags = 0x8000LL;\n  nextToken = strchr(input, ',');\n  while (1)\n  {\n    tokenLen = (size_t)nextToken;\n    subToken = \"loop\";\n    if (nextToken)\n      *nextToken = '\\0';\n    for (subTokenIndex = 0; subTokenIndex <= 0x2A; ++subTokenIndex)\n    {\n      subTokenLen = strlen(subToken);\n      if (!strncasecmp(subToken, currentToken, subTokenLen) && (!currentToken[subTokenLen] || subToken[subTokenLen - 1] == '='))\n      {\n        flagValue = dword_522120[subTokenIndex];\n        if ((int)flagValue >= 0)\n          flags |= flagValue;\n        else\n          flags &= flagValue;\n        goto POST_TOKEN_PROCESSING;\n      }\n      subToken += subTokenLen + 1;\n    }\n    if (*currentToken && output)\n    {\n      nextSubToken = *output;\n      if (nextSubToken)\n        outputLen = strlen(nextSubToken);\n      else\n        outputLen = 0;\n      appendedLen = outputLen;\n      tempLen = outputLen;\n      nextTokenLen = strlen(currentToken);\n      nextSubToken = (char *)sub_40A09E(nextSubToken, tempLen + nextTokenLen + 2);\n      *output = nextSubToken;\n      if (appendedLen)\n      {\n        tempLen = appendedLen++;\n        nextSubToken[tempLen] = ',';\n      }\n      strcpy(&nextSubToken[appendedLen], currentToken);\n    }\nPOST_TOKEN_PROCESSING:\n    if (tokenLen)\n    {\n      *(_BYTE *)tokenLen = ',';\n      currentToken = (char *)(tokenLen + 1);\n      nextToken = strchr((const char *)(tokenLen + 1), ',');\n      continue;\n    }\n    return flags;\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4A1EAA(const char *a1, char **a2)\n{\n  char *v2; // rax\n  unsigned int v3; // eax\n  __int64 v4; // rbx\n  size_t v5; // rax\n  int v6; // eax\n  char *s; // [rsp+8h] [rbp-58h]\n  char *v9; // [rsp+10h] [rbp-50h]\n  char *v10; // [rsp+10h] [rbp-50h]\n  __int64 v11; // [rsp+18h] [rbp-48h]\n  unsigned int n; // [rsp+24h] [rbp-3Ch]\n  size_t n_4; // [rsp+28h] [rbp-38h]\n  unsigned int v14; // [rsp+34h] [rbp-2Ch]\n  char *s1; // [rsp+38h] [rbp-28h]\n  unsigned int i; // [rsp+44h] [rbp-1Ch]\n  __int64 v17; // [rsp+48h] [rbp-18h]\n\n  s = (char *)a1;\n  v17 = 0x8000LL;\n  v2 = strchr(a1, 44);\n  while ( 2 )\n  {\n    n_4 = (size_t)v2;\n    s1 = \"loop\";\n    if ( v2 )\n      *v2 = 0;\n    for ( i = 0; i <= 0x2A; ++i )\n    {\n      n = strlen(s1);\n      if ( !strncasecmp(s1, s, n) && (!s[n] || s1[n - 1] == 61) )\n      {\n        v11 = dword_522120[i];\n        if ( (int)v11 >= 0 )\n          v17 |= v11;\n        else\n          v17 &= v11;\n        goto LABEL_21;\n      }\n      s1 += n + 1;\n    }\n    if ( *s && a2 )\n    {\n      v9 = *a2;\n      if ( *a2 )\n        v3 = strlen(v9);\n      else\n        v3 = 0;\n      v14 = v3;\n      v4 = v3;\n      v5 = strlen(s);\n      v10 = (char *)sub_40A09E(v9, v4 + v5 + 2);\n      *a2 = v10;\n      if ( v14 )\n      {\n        v6 = v14++;\n        v10[v6] = 44;\n      }\n      strcpy(&v10[v14], s);\n    }\nLABEL_21:\n    if ( n_4 )\n    {\n      *(_BYTE *)n_4 = 44;\n      s = (char *)(n_4 + 1);\n      v2 = strchr((const char *)(n_4 + 1), 44);\n      continue;\n    }\n    return v17;\n  }\n}\n",
        "baseline_code_debug": "unsigned __int64 __cdecl parse_mount_options(char *options, char **unrecognized)\n{\n  unsigned int v2; // eax\n  size_t v3; // rdx\n  unsigned int v4; // eax\n  char *p; // [rsp+10h] [rbp-50h]\n  char *pa; // [rsp+10h] [rbp-50h]\n  unsigned __int64 fl; // [rsp+18h] [rbp-48h]\n  unsigned int opt_len; // [rsp+24h] [rbp-3Ch]\n  char *comma; // [rsp+28h] [rbp-38h]\n  unsigned int len; // [rsp+34h] [rbp-2Ch]\n  const char *option_str; // [rsp+38h] [rbp-28h]\n  unsigned int i; // [rsp+44h] [rbp-1Ch]\n  unsigned __int64 flags; // [rsp+48h] [rbp-18h]\n\n  flags = 0x8000LL;\n  while ( 2 )\n  {\n    comma = strchr(options, 44);\n    option_str = mount_option_str;\n    if ( comma )\n      *comma = 0;\n    for ( i = 0; i <= 0x2A; ++i )\n    {\n      opt_len = strlen(option_str);\n      if ( !strncasecmp(option_str, options, opt_len) && (!options[opt_len] || option_str[opt_len - 1] == 61) )\n      {\n        fl = mount_options[i];\n        if ( (fl & 0x80000000) == 0LL )\n          flags |= fl;\n        else\n          flags &= fl;\n        goto found;\n      }\n      option_str += opt_len + 1;\n    }\n    if ( *options && unrecognized )\n    {\n      p = *unrecognized;\n      if ( *unrecognized )\n        v2 = strlen(p);\n      else\n        v2 = 0;\n      len = v2;\n      v3 = v2 + strlen(options) + 2;\n      pa = (char *)xrealloc(p, v3);\n      *unrecognized = pa;\n      if ( len )\n      {\n        v4 = len++;\n        pa[v4] = 44;\n      }\n      strcpy(&pa[len], options);\n    }\nfound:\n    if ( comma )\n    {\n      *comma = 44;\n      options = comma + 1;\n      continue;\n    }\n    return flags;\n  }\n}\n",
        "similarity_score_unixcoder": 0.6169434189796448,
        "similarity_score_baseline_stripped": 0.4761054217815399,
        "similarity_score_baseline_debug": 0.8356493711471558
    },
    {
        "func_name": "tty_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall __noreturn sub_4D7829(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int v6; // [rsp+10h] [rbp-10h]\n  unsigned int v7; // [rsp+14h] [rbp-Ch]\n  const char *s; // [rsp+18h] [rbp-8h]\n\n  byte_75AE48 = 2;\n  v6 = sub_4FA1EF(a2, (unsigned int)\"s\", a3, a4, a5, a6);\n  sub_50A77A(*(_QWORD *)(8LL * optind + a2));\n  v7 = 0;\n  s = sub_40AD9A(0, (__int64)\"s\");\n  if ( !s )\n  {\n    s = \"not a tty\";\n    v7 = 1;\n  }\n  if ( !v6 )\n    puts(s);\n  sub_4F93C9(v7);\n}\n",
        "output": "```c\nvoid __fastcall __noreturn terminate_with_message(__int64 arg_list, __int64 arg_count, int arg3, int arg4, int arg5, int arg6)\n{\n  int result; // [rsp+10h] [rbp-10h]\n  unsigned int is_not_tty; // [rsp+14h] [rbp-Ch]\n  const char *message; // [rsp+18h] [rbp-8h]\n\n  byte_75AE48 = 2;\n  result = process_arguments(arg_count, (unsigned int)\"s\", arg3, arg4, arg5, arg6);\n  handle_option(*(_QWORD *)(8LL * optind + arg_count));\n  is_not_tty = 0;\n  message = get_message(0, (__int64)\"s\");\n  if ( !message )\n  {\n    message = \"not a tty\";\n    is_not_tty = 1;\n  }\n  if ( !result )\n    puts(message);\n  finalize(is_not_tty);\n}\n```",
        "source_code": "int tty_main(int argc UNUSED_PARAM, char **argv)\n{\n\tconst char *s;\n\tIF_INCLUDE_SUSv2(int silent;)  /* Note: No longer relevant in SUSv3. */\n\tint retval;\n\n\txfunc_error_retval = 2;  /* SUSv3 requires > 1 for error. */\n\n\tIF_INCLUDE_SUSv2(silent = getopt32(argv, \"s\");)\n\tIF_INCLUDE_SUSv2(argv += optind;)\n\tIF_NOT_INCLUDE_SUSv2(argv += 1;)\n\n\t/* gnu tty outputs a warning that it is ignoring all args. */\n\tbb_warn_ignoring_args(argv[0]);\n\n\tretval = EXIT_SUCCESS;\n\n\ts = xmalloc_ttyname(STDIN_FILENO);\n\tif (s == NULL) {\n\t/* According to SUSv3, ttyname can fail with EBADF or ENOTTY.\n\t * We know the file descriptor is good, so failure means not a tty. */\n\t\ts = \"not a tty\";\n\t\tretval = EXIT_FAILURE;\n\t}\n\tIF_INCLUDE_SUSv2(if (!silent) puts(s);)\n\tIF_NOT_INCLUDE_SUSv2(puts(s);)\n\n\tfflush_stdout_and_exit(retval);\n}",
        "parsed_output": "void __fastcall __noreturn terminate_with_message(__int64 arg_list, __int64 arg_count, int arg3, int arg4, int arg5, int arg6)\n{\n  int result; // [rsp+10h] [rbp-10h]\n  unsigned int is_not_tty; // [rsp+14h] [rbp-Ch]\n  const char *message; // [rsp+18h] [rbp-8h]\n\n  byte_75AE48 = 2;\n  result = process_arguments(arg_count, (unsigned int)\"s\", arg3, arg4, arg5, arg6);\n  handle_option(*(_QWORD *)(8LL * optind + arg_count));\n  is_not_tty = 0;\n  message = get_message(0, (__int64)\"s\");\n  if ( !message )\n  {\n    message = \"not a tty\";\n    is_not_tty = 1;\n  }\n  if ( !result )\n    puts(message);\n  finalize(is_not_tty);\n}",
        "baseline_code_stripped": "void __fastcall __noreturn sub_4D7829(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int v6; // [rsp+10h] [rbp-10h]\n  unsigned int v7; // [rsp+14h] [rbp-Ch]\n  const char *s; // [rsp+18h] [rbp-8h]\n\n  byte_75AE48 = 2;\n  v6 = sub_4FA1EF(a2, (unsigned int)\"s\", a3, a4, a5, a6);\n  sub_50A77A(*(_QWORD *)(8LL * optind + a2));\n  v7 = 0;\n  s = sub_40AD9A(0, (__int64)\"s\");\n  if ( !s )\n  {\n    s = \"not a tty\";\n    v7 = 1;\n  }\n  if ( !v6 )\n    puts(s);\n  sub_4F93C9(v7);\n}\n",
        "baseline_code_debug": "int __cdecl __noreturn tty_main(int argc, char **argv)\n{\n  int silent; // [rsp+10h] [rbp-10h]\n  int retval; // [rsp+14h] [rbp-Ch]\n  char *s; // [rsp+18h] [rbp-8h]\n\n  xfunc_error_retval = 2;\n  silent = getopt32(argv, \"s\");\n  bb_warn_ignoring_args(argv[optind]);\n  retval = 0;\n  s = xmalloc_ttyname(0);\n  if ( !s )\n  {\n    s = \"not a tty\";\n    retval = 1;\n  }\n  if ( !silent )\n    puts(s);\n  fflush_stdout_and_exit(retval);\n}\n",
        "similarity_score_unixcoder": 0.6199332475662231,
        "similarity_score_baseline_stripped": 0.5403790473937988,
        "similarity_score_baseline_debug": 0.8379844427108765
    },
    {
        "func_name": "print_long",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4CDCF5(unsigned __int64 a1, _QWORD *a2, const char *a3)\n{\n  __int64 result; // rax\n  unsigned __int64 v6; // [rsp+18h] [rbp-18h]\n\n  v6 = a1 >> 3;\n  while ( 1 )\n  {\n    result = v6--;\n    if ( !result )\n      break;\n    printf(a3, *a2++);\n  }\n  return result;\n}\n",
        "output": "```c\nvoid print_elements(unsigned __int64 count, const uint64_t *elements, const char *format)\n{\n  for (unsigned __int64 i = count >> 3; i > 0; --i)\n  {\n    printf(format, *elements++);\n  }\n}\n```",
        "source_code": "else\nstatic void\nprint_long(size_t n_bytes, const char *block, const char *fmt_string)\n{\n\tn_bytes /= sizeof(unsigned long);\n\twhile (n_bytes--) {\n\t\tunsigned long tmp = *(unsigned long *) block;\n\t\tprintf(fmt_string, tmp);\n\t\tblock += sizeof(unsigned long);\n\t}\n}",
        "parsed_output": "void print_elements(unsigned __int64 count, const uint64_t *elements, const char *format)\n{\n  for (unsigned __int64 i = count >> 3; i > 0; --i)\n  {\n    printf(format, *elements++);\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4CDCF5(unsigned __int64 a1, _QWORD *a2, const char *a3)\n{\n  __int64 result; // rax\n  unsigned __int64 v6; // [rsp+18h] [rbp-18h]\n\n  v6 = a1 >> 3;\n  while ( 1 )\n  {\n    result = v6--;\n    if ( !result )\n      break;\n    printf(a3, *a2++);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl print_long(size_t n_bytes, const char *block, const char *fmt_string)\n{\n  size_t n_bytesa; // [rsp+18h] [rbp-18h]\n\n  n_bytesa = n_bytes >> 3;\n  while ( n_bytesa-- )\n  {\n    printf(fmt_string, *(_QWORD *)block);\n    block += 8;\n  }\n}\n",
        "similarity_score_unixcoder": 0.7420623898506165,
        "similarity_score_baseline_stripped": 0.6116040349006653,
        "similarity_score_baseline_debug": 0.8097018003463745
    },
    {
        "func_name": "printargv",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_422B9A(_QWORD *a1)\n{\n  __int64 result; // rax\n  char *format; // [rsp+18h] [rbp-8h]\n\n  format = \"%s\";\n  do\n  {\n    printf(format, *a1);\n    format = \" %s\";\n    result = *++a1;\n  }\n  while ( *a1 );\n  return result;\n}\n",
        "output": "```c\n#include <stdio.h>\n\nvoid printStrings(const char **strings)\n{\n  const char *separator = \"\";\n  while (*strings)\n  {\n    printf(\"%s%s\", separator, *strings);\n    separator = \" \";\n    ++strings;\n  }\n}\n```",
        "source_code": "static void printargv(char *const *argv)\n{\n\tconst char *fmt = \" %s\" + 1;\n\tdo {\n\t\tprintf(fmt, *argv);\n\t\tfmt = \" %s\";\n\t} while (*++argv);\n}",
        "parsed_output": "#include <stdio.h>\n\nvoid printStrings(const char **strings)\n{\n  const char *separator = \"\";\n  while (*strings)\n  {\n    printf(\"%s%s\", separator, *strings);\n    separator = \" \";\n    ++strings;\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_422B9A(_QWORD *a1)\n{\n  __int64 result; // rax\n  char *format; // [rsp+18h] [rbp-8h]\n\n  format = \"%s\";\n  do\n  {\n    printf(format, *a1);\n    format = \" %s\";\n    result = *++a1;\n  }\n  while ( *a1 );\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl printargv(char *const *argv)\n{\n  char *fmt; // [rsp+18h] [rbp-8h]\n\n  fmt = \"%s\";\n  do\n  {\n    printf(fmt, *argv);\n    fmt = \" %s\";\n    ++argv;\n  }\n  while ( *argv );\n}\n",
        "similarity_score_unixcoder": 0.7848034501075745,
        "similarity_score_baseline_stripped": 0.5717563629150391,
        "similarity_score_baseline_debug": 0.7810306549072266
    },
    {
        "func_name": "who_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4D88CD(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  void **v6; // rdx\n  char *v7; // rax\n  const char *v8; // rbx\n  char *v9; // rax\n  char filename[48]; // [rsp+10h] [rbp-100h] BYREF\n  struct stat64 stat_buf; // [rsp+40h] [rbp-D0h] BYREF\n  time_t timer; // [rsp+D8h] [rbp-38h] BYREF\n  _WORD v14[7]; // [rsp+E2h] [rbp-2Eh] BYREF\n  int v15; // [rsp+F0h] [rbp-20h]\n  _BOOL4 v16; // [rsp+F4h] [rbp-1Ch]\n  char *format; // [rsp+F8h] [rbp-18h]\n\n  v16 = *ident == 117;\n  format = \"%s\";\n  qword_75D440 = (__int64)\"=0\";\n  if ( v16 )\n    v6 = &off_532638;\n  else\n    LODWORD(v6) = 5449273;\n  v15 = sub_4FA1EF(a2, (_DWORD)v6, (_DWORD)v6, a4, a5, a6, a2);\n  if ( (v15 & 2) != 0 )\n    puts((const char *)&off_532638 + 4);\n  setutent();\n  while ( 1 )\n  {\n    *(_QWORD *)&v14[3] = getutent();\n    if ( !*(_QWORD *)&v14[3] )\n      break;\n    if ( *(_BYTE *)(*(_QWORD *)&v14[3] + 44LL) && ((v15 & 1) != 0 || **(_WORD **)&v14[3] == 7) )\n    {\n      if ( v16 )\n      {\n        printf(format, *(_QWORD *)&v14[3] + 44LL);\n        format = \" %s\";\n      }\n      else\n      {\n        strcpy((char *)v14, \"?\");\n        strcpy(filename, \"/dev/\");\n        if ( *(_BYTE *)(*(_QWORD *)&v14[3] + 8LL) == 47 )\n          v7 = filename;\n        else\n          v7 = &filename[5];\n        sub_507FC0(v7, *(_QWORD *)&v14[3] + 8LL, 33LL);\n        if ( !sub_407DF0(filename, &stat_buf) )\n          sub_4D87E9((char *)v14, stat_buf.st_atim.tv_sec);\n        timer = *(int *)(*(_QWORD *)&v14[3] + 340LL);\n        v8 = (const char *)(*(_QWORD *)&v14[3] + 76LL);\n        v9 = ctime(&timer);\n        printf(\n          \"%-15.*s %-15.*s %-7s %-16.16s %.*s\\n\",\n          32,\n          (const char *)(*(_QWORD *)&v14[3] + 44LL),\n          32,\n          (const char *)(*(_QWORD *)&v14[3] + 8LL),\n          (const char *)v14,\n          v9 + 4,\n          256,\n          v8);\n      }\n    }\n  }\n  if ( v16 )\n    sub_40A659(10);\n  return 0LL;\n}\n",
        "output": "```c\n#include <sys/stat.h>\n#include <time.h>\n#include <utmp.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nextern bool ident;\nextern void *off_532638;\nextern __int64 qword_75D440;\nextern int sub_4FA1EF(__int64, int, int, int, int, int, __int64);\nextern void setutent();\nextern struct utmp *getutent();\nextern int sub_507FC0(char *, __int64, __int64);\nextern int sub_407DF0(const char *, struct stat *);\nextern void sub_4D87E9(char *, time_t);\nextern void sub_40A659(int);\n\n__int64 sub_4D88CD(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  bool isIdent117 = ident == 117;\n  const char *format = \"%s\";\n  qword_75D440 = (__int64)\"=0\";\n  void *v6 = isIdent117 ? &off_532638 : (void *)5449273;\n  int v15 = sub_4FA1EF(a2, (int)v6, (int)v6, a4, a5, a6, a2);\n  if ((v15 & 2) != 0)\n    puts((const char *)&off_532638 + 4);\n  setutent();\n  while (true)\n  {\n    struct utmp *utmp_entry = getutent();\n    if (!utmp_entry)\n      break;\n    if (utmp_entry->ut_user[0] && ((v15 & 1) != 0 || utmp_entry->ut_type == USER_PROCESS))\n    {\n      if (isIdent117)\n      {\n        printf(format, utmp_entry->ut_user);\n        format = \" %s\";\n      }\n      else\n      {\n        char device[7] = \"?\";\n        char filename[48] = \"/dev/\";\n        if (utmp_entry->ut_line[0] == '/')\n          strcpy(filename, utmp_entry->ut_line);\n        else\n          sub_507FC0(filename + 5, (__int64)utmp_entry->ut_line, 33);\n        struct stat stat_buf;\n        if (!sub_407DF0(filename, &stat_buf))\n          sub_4D87E9(device, stat_buf.st_atime);\n        time_t login_time = utmp_entry->ut_tv.tv_sec;\n        const char *host = utmp_entry->ut_host;\n        char *time_str = ctime(&login_time);\n        printf(\n          \"%-15.*s %-15.*s %-7s %-16.16s %.*s\\n\",\n          32, utmp_entry->ut_user,\n          32, utmp_entry->ut_line,\n          device,\n          time_str + 4,\n          256, host);\n      }\n    }\n  }\n  if (isIdent117)\n    sub_40A659(10);\n  return 0;\n}\n```",
        "source_code": "int who_main(int argc UNUSED_PARAM, char **argv)\n{\n\tstruct utmp *ut;\n\tunsigned opt;\n\tint do_users = (ENABLE_USERS && (!ENABLE_WHO || applet_name[0] == 'u'));\n\tconst char *fmt = \"%s\";\n\n\topt_complementary = \"=0\";\n\topt = getopt32(argv, do_users ? \"\" : \"aH\");\n\tif (opt & 2) // -H\n\t\tprintf(\"USER\\t\\tTTY\\t\\tIDLE\\tTIME\\t\\t HOST\\n\");\n\n\tsetutent();\n\twhile ((ut = getutent()) != NULL) {\n\t\tif (ut->ut_user[0]\n\t\t && ((opt & 1) || ut->ut_type == USER_PROCESS)\n\t\t) {\n\t\t\tif (!do_users) {\n\t\t\t\tchar str6[6];\n\t\t\t\tchar name[sizeof(\"/dev/\") + sizeof(ut->ut_line) + 1];\n\t\t\t\tstruct stat st;\n\t\t\t\ttime_t seconds;\n\n\t\t\t\tstr6[0] = '?';\n\t\t\t\tstr6[1] = '\\0';\n\t\t\t\tstrcpy(name, \"/dev/\");\n\t\t\t\tsafe_strncpy(ut->ut_line[0] == '/' ? name : name + sizeof(\"/dev/\")-1,\n\t\t\t\t\tut->ut_line,\n\t\t\t\t\tsizeof(ut->ut_line)+1\n\t\t\t\t);\n\t\t\t\tif (stat(name, &st) == 0)\n\t\t\t\t\tidle_string(str6, st.st_atime);\n\t\t\t\t/* manpages say ut_tv.tv_sec *is* time_t,\n\t\t\t\t * but some systems have it wrong */\n\t\t\t\tseconds = ut->ut_tv.tv_sec;\n\t\t\t\t/* How wide time field can be?\n\t\t\t\t * \"Nov 10 19:33:20\": 15 chars\n\t\t\t\t * \"2010-11-10 19:33\": 16 chars\n\t\t\t\t */\n\t\t\t\tprintf(\"%-15.*s %-15.*s %-7s %-16.16s %.*s\\n\",\n\t\t\t\t\t\t(int)sizeof(ut->ut_user), ut->ut_user,\n\t\t\t\t\t\t(int)sizeof(ut->ut_line), ut->ut_line,\n\t\t\t\t\t\tstr6,\n\t\t\t\t\t\tctime(&seconds) + 4,\n\t\t\t\t\t\t(int)sizeof(ut->ut_host), ut->ut_host\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tprintf(fmt, ut->ut_user);\n\t\t\t\tfmt = \" %s\";\n\t\t\t}\n\t\t}\n\t}\n\tif (do_users)\n\t\tbb_putchar('\\n');\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tendutent();\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "#include <sys/stat.h>\n#include <time.h>\n#include <utmp.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nextern bool ident;\nextern void *off_532638;\nextern __int64 qword_75D440;\nextern int sub_4FA1EF(__int64, int, int, int, int, int, __int64);\nextern void setutent();\nextern struct utmp *getutent();\nextern int sub_507FC0(char *, __int64, __int64);\nextern int sub_407DF0(const char *, struct stat *);\nextern void sub_4D87E9(char *, time_t);\nextern void sub_40A659(int);\n\n__int64 sub_4D88CD(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  bool isIdent117 = ident == 117;\n  const char *format = \"%s\";\n  qword_75D440 = (__int64)\"=0\";\n  void *v6 = isIdent117 ? &off_532638 : (void *)5449273;\n  int v15 = sub_4FA1EF(a2, (int)v6, (int)v6, a4, a5, a6, a2);\n  if ((v15 & 2) != 0)\n    puts((const char *)&off_532638 + 4);\n  setutent();\n  while (true)\n  {\n    struct utmp *utmp_entry = getutent();\n    if (!utmp_entry)\n      break;\n    if (utmp_entry->ut_user[0] && ((v15 & 1) != 0 || utmp_entry->ut_type == USER_PROCESS))\n    {\n      if (isIdent117)\n      {\n        printf(format, utmp_entry->ut_user);\n        format = \" %s\";\n      }\n      else\n      {\n        char device[7] = \"?\";\n        char filename[48] = \"/dev/\";\n        if (utmp_entry->ut_line[0] == '/')\n          strcpy(filename, utmp_entry->ut_line);\n        else\n          sub_507FC0(filename + 5, (__int64)utmp_entry->ut_line, 33);\n        struct stat stat_buf;\n        if (!sub_407DF0(filename, &stat_buf))\n          sub_4D87E9(device, stat_buf.st_atime);\n        time_t login_time = utmp_entry->ut_tv.tv_sec;\n        const char *host = utmp_entry->ut_host;\n        char *time_str = ctime(&login_time);\n        printf(\n          \"%-15.*s %-15.*s %-7s %-16.16s %.*s\\n\",\n          32, utmp_entry->ut_user,\n          32, utmp_entry->ut_line,\n          device,\n          time_str + 4,\n          256, host);\n      }\n    }\n  }\n  if (isIdent117)\n    sub_40A659(10);\n  return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4D88CD(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  void **v6; // rdx\n  char *v7; // rax\n  const char *v8; // rbx\n  char *v9; // rax\n  char filename[48]; // [rsp+10h] [rbp-100h] BYREF\n  struct stat64 stat_buf; // [rsp+40h] [rbp-D0h] BYREF\n  time_t timer; // [rsp+D8h] [rbp-38h] BYREF\n  _WORD v14[7]; // [rsp+E2h] [rbp-2Eh] BYREF\n  int v15; // [rsp+F0h] [rbp-20h]\n  _BOOL4 v16; // [rsp+F4h] [rbp-1Ch]\n  char *format; // [rsp+F8h] [rbp-18h]\n\n  v16 = *ident == 117;\n  format = \"%s\";\n  qword_75D440 = (__int64)\"=0\";\n  if ( v16 )\n    v6 = &off_532638;\n  else\n    LODWORD(v6) = 5449273;\n  v15 = sub_4FA1EF(a2, (_DWORD)v6, (_DWORD)v6, a4, a5, a6, a2);\n  if ( (v15 & 2) != 0 )\n    puts((const char *)&off_532638 + 4);\n  setutent();\n  while ( 1 )\n  {\n    *(_QWORD *)&v14[3] = getutent();\n    if ( !*(_QWORD *)&v14[3] )\n      break;\n    if ( *(_BYTE *)(*(_QWORD *)&v14[3] + 44LL) && ((v15 & 1) != 0 || **(_WORD **)&v14[3] == 7) )\n    {\n      if ( v16 )\n      {\n        printf(format, *(_QWORD *)&v14[3] + 44LL);\n        format = \" %s\";\n      }\n      else\n      {\n        strcpy((char *)v14, \"?\");\n        strcpy(filename, \"/dev/\");\n        if ( *(_BYTE *)(*(_QWORD *)&v14[3] + 8LL) == 47 )\n          v7 = filename;\n        else\n          v7 = &filename[5];\n        sub_507FC0(v7, *(_QWORD *)&v14[3] + 8LL, 33LL);\n        if ( !sub_407DF0(filename, &stat_buf) )\n          sub_4D87E9((char *)v14, stat_buf.st_atim.tv_sec);\n        timer = *(int *)(*(_QWORD *)&v14[3] + 340LL);\n        v8 = (const char *)(*(_QWORD *)&v14[3] + 76LL);\n        v9 = ctime(&timer);\n        printf(\n          \"%-15.*s %-15.*s %-7s %-16.16s %.*s\\n\",\n          32,\n          (const char *)(*(_QWORD *)&v14[3] + 44LL),\n          32,\n          (const char *)(*(_QWORD *)&v14[3] + 8LL),\n          (const char *)v14,\n          v9 + 4,\n          256,\n          v8);\n      }\n    }\n  }\n  if ( v16 )\n    sub_40A659(10);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl who_main(int argc, char **argv)\n{\n  unsigned int v2; // eax\n  char *v3; // rax\n  char *ut_host; // rbx\n  char *v5; // rax\n  char name[39]; // [rsp+10h] [rbp-100h] BYREF\n  stat st; // [rsp+40h] [rbp-D0h] BYREF\n  time_t seconds; // [rsp+D8h] [rbp-38h] BYREF\n  char str6[6]; // [rsp+E2h] [rbp-2Eh] BYREF\n  utmp *ut; // [rsp+E8h] [rbp-28h]\n  unsigned int opt; // [rsp+F0h] [rbp-20h]\n  int do_users; // [rsp+F4h] [rbp-1Ch]\n  const char *fmt; // [rsp+F8h] [rbp-18h]\n\n  do_users = *applet_name == 117;\n  fmt = \"%s\";\n  opt_complementary = \"=0\";\n  if ( do_users )\n    v2 = getopt32(argv, off_532638);\n  else\n    v2 = getopt32(argv, &off_532638[1]);\n  opt = v2;\n  if ( (v2 & 2) != 0 )\n    puts(&off_532638[4]);\n  setutent();\n  while ( 1 )\n  {\n    ut = getutent();\n    if ( !ut )\n      break;\n    if ( ut->ut_user[0] && ((opt & 1) != 0 || ut->ut_type == 7) )\n    {\n      if ( do_users )\n      {\n        printf(fmt, ut->ut_user);\n        fmt = \" %s\";\n      }\n      else\n      {\n        strcpy(str6, \"?\");\n        strcpy(name, \"/dev/\");\n        if ( ut->ut_line[0] == 47 )\n          v3 = name;\n        else\n          v3 = &name[5];\n        safe_strncpy(v3, ut->ut_line, 0x21uLL);\n        if ( !stat64_0(name, (stat64 *)&st) )\n          idle_string(str6, st.st_atim.tv_sec);\n        seconds = ut->ut_tv.tv_sec;\n        ut_host = ut->ut_host;\n        v5 = ctime(&seconds);\n        printf(\"%-15.*s %-15.*s %-7s %-16.16s %.*s\\n\", 32, ut->ut_user, 32, ut->ut_line, str6, v5 + 4, 256, ut_host);\n      }\n    }\n  }\n  if ( do_users )\n    bb_putchar(10);\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.7810266613960266,
        "similarity_score_baseline_stripped": 0.6514782309532166,
        "similarity_score_baseline_debug": 0.8791863322257996
    },
    {
        "func_name": "get_devname_from_label",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_4A5902(const char *a1)\n{\n  const char *v1; // rsi\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = sub_4A576C(1); i; i = *(_QWORD *)i )\n  {\n    if ( **(_BYTE **)(i + 16) )\n    {\n      v1 = *(const char **)(i + 16);\n      if ( !strcmp(a1, v1) )\n        return sub_40A11F(*(const char **)(i + 8), (__int64)v1);\n    }\n  }\n  return 0LL;\n}\n",
        "output": "char *findMatchingEntry(const char *target)\n{\n  const char *entryName;\n  void *entryPtr;\n\n  for (entryPtr = getFirstEntry(1); entryPtr; entryPtr = *(void **)entryPtr)\n  {\n    entryName = *(const char **)((char *)entryPtr + 16);\n    if (entryName && !strcmp(target, entryName))\n    {\n      return processEntry(*(const char **)((char *)entryPtr + 8), entryName);\n    }\n  }\n  return NULL;\n}",
        "source_code": "char *get_devname_from_label(const char *spec)\n{\n\tstruct uuidCache_s *uc;\n\n\tuc = uuidcache_init(/*scan_devices:*/ 1);\n\twhile (uc) {\n\t\tif (uc->label[0] && strcmp(spec, uc->label) == 0) {\n\t\t\treturn xstrdup(uc->device);\n\t\t}\n\t\tuc = uc->next;\n\t}\n\treturn NULL;\n}",
        "parsed_output": "char *findMatchingEntry(const char *target)\n{\n  const char *entryName;\n  void *entryPtr;\n\n  for (entryPtr = getFirstEntry(1); entryPtr; entryPtr = *(void **)entryPtr)\n  {\n    entryName = *(const char **)((char *)entryPtr + 16);\n    if (entryName && !strcmp(target, entryName))\n    {\n      return processEntry(*(const char **)((char *)entryPtr + 8), entryName);\n    }\n  }\n  return NULL;\n}",
        "baseline_code_stripped": "char *__fastcall sub_4A5902(const char *a1)\n{\n  const char *v1; // rsi\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = sub_4A576C(1); i; i = *(_QWORD *)i )\n  {\n    if ( **(_BYTE **)(i + 16) )\n    {\n      v1 = *(const char **)(i + 16);\n      if ( !strcmp(a1, v1) )\n        return sub_40A11F(*(const char **)(i + 8), (__int64)v1);\n    }\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "char *__cdecl get_devname_from_label(const char *spec)\n{\n  uuidCache_s *uc; // [rsp+18h] [rbp-8h]\n\n  for ( uc = uuidcache_init(1); uc; uc = uc->next )\n  {\n    if ( *uc->label && !strcmp(spec, uc->label) )\n      return xstrdup(uc->device);\n  }\n  return 0LL;\n}\n",
        "similarity_score_unixcoder": 0.5310836434364319,
        "similarity_score_baseline_stripped": 0.4242667555809021,
        "similarity_score_baseline_debug": 0.8769363760948181
    },
    {
        "func_name": "scan_tree",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4AFD56(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+10h] [rbp-1Ch]\n  int v4; // [rsp+14h] [rbp-18h]\n  int v5; // [rsp+18h] [rbp-14h]\n  int v6; // [rsp+1Ch] [rbp-10h]\n  int v7; // [rsp+20h] [rbp-Ch]\n  int v8; // [rsp+24h] [rbp-8h]\n  unsigned int i; // [rsp+28h] [rbp-4h]\n\n  v8 = -1;\n  v7 = *(unsigned __int16 *)(a1 + 2);\n  v6 = 0;\n  v5 = 7;\n  v4 = 4;\n  if ( !*(_WORD *)(a1 + 2) )\n  {\n    v5 = 138;\n    v4 = 3;\n  }\n  *(_WORD *)(4 * (a2 + 1LL) + a1 + 2) = -1;\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i > a2 )\n      break;\n    v3 = v7;\n    v7 = *(unsigned __int16 *)(4 * ((int)i + 1LL) + a1 + 2);\n    if ( ++v6 >= v5 || v3 != v7 )\n    {\n      if ( v6 >= v4 )\n      {\n        if ( v3 )\n        {\n          if ( v3 != v8 )\n            ++*((_WORD *)qword_75D408 + 2 * v3 + 2482);\n          ++*((_WORD *)qword_75D408 + 2514);\n        }\n        else if ( v6 > 10 )\n        {\n          ++*((_WORD *)qword_75D408 + 2518);\n        }\n        else\n        {\n          ++*((_WORD *)qword_75D408 + 2516);\n        }\n      }\n      else\n      {\n        *((_WORD *)qword_75D408 + 2 * v3 + 2482) += v6;\n      }\n      v6 = 0;\n      v8 = v3;\n      v5 = 7;\n      v4 = 4;\n      if ( v7 )\n      {\n        if ( v3 == v7 )\n        {\n          v5 = 6;\n          v4 = 3;\n        }\n      }\n      else\n      {\n        v5 = 138;\n        v4 = 3;\n      }\n    }\n  }\n  return result;\n}\n",
        "output": "long long sub_4AFD56(long long a1, int a2)\n{\n  long long result;\n  int current_value;\n  int next_value;\n  int consecutive_count;\n  int max_consecutive;\n  int min_repeat;\n  int last_value;\n  unsigned int i;\n\n  last_value = -1;\n  current_value = *(unsigned short *)(a1 + 2);\n  consecutive_count = 0;\n  max_consecutive = 7;\n  min_repeat = 4;\n  if (current_value == 0)\n  {\n    max_consecutive = 138;\n    min_repeat = 3;\n  }\n  *(_WORD *)(4 * (a2 + 1) + a1 + 2) = -1;\n  for (i = 0; ; ++i)\n  {\n    result = i;\n    if ((int)i > a2)\n      break;\n    next_value = *(unsigned short *)(4 * (i + 1) + a1 + 2);\n    if (++consecutive_count >= max_consecutive || current_value != next_value)\n    {\n      if (consecutive_count >= min_repeat)\n      {\n        if (current_value)\n        {\n          if (current_value != last_value)\n            ++*((_WORD *)qword_75D408 + 2 * current_value + 2482);\n          ++*((_WORD *)qword_75D408 + 2514);\n        }\n        else if (consecutive_count > 10)\n        {\n          ++*((_WORD *)qword_75D408 + 2518);\n        }\n        else\n        {\n          ++*((_WORD *)qword_75D408 + 2516);\n        }\n      }\n      else\n      {\n        *((_WORD *)qword_75D408 + 2 * current_value + 2482) += consecutive_count;\n      }\n      consecutive_count = 0;\n      last_value = current_value;\n      max_consecutive = 7;\n      min_repeat = 4;\n      if (next_value)\n      {\n        if (current_value == next_value)\n        {\n          max_consecutive = 6;\n          min_repeat = 3;\n        }\n      }\n      else\n      {\n        max_consecutive = 138;\n        min_repeat = 3;\n      }\n    }\n    current_value = next_value;\n  }\n  return result;\n}",
        "source_code": "static void scan_tree(ct_data * tree, int max_code)\n{\n\tint n;\t\t\t\t/* iterates over all tree elements */\n\tint prevlen = -1;\t/* last emitted length */\n\tint curlen;\t\t\t/* length of current code */\n\tint nextlen = tree[0].Len;\t/* length of next code */\n\tint count = 0;\t\t/* repeat count of the current code */\n\tint max_count = 7;\t/* max repeat count */\n\tint min_count = 4;\t/* min repeat count */\n\n\tif (nextlen == 0) {\n\t\tmax_count = 138;\n\t\tmin_count = 3;\n\t}\n\ttree[max_code + 1].Len = 0xffff; /* guard */\n\n\tfor (n = 0; n <= max_code; n++) {\n\t\tcurlen = nextlen;\n\t\tnextlen = tree[n + 1].Len;\n\t\tif (++count < max_count && curlen == nextlen)\n\t\t\tcontinue;\n\n\t\tif (count < min_count) {\n\t\t\tG2.bl_tree[curlen].Freq += count;\n\t\t} else if (curlen != 0) {\n\t\t\tif (curlen != prevlen)\n\t\t\t\tG2.bl_tree[curlen].Freq++;\n\t\t\tG2.bl_tree[REP_3_6].Freq++;\n\t\t} else if (count <= 10) {\n\t\t\tG2.bl_tree[REPZ_3_10].Freq++;\n\t\t} else {\n\t\t\tG2.bl_tree[REPZ_11_138].Freq++;\n\t\t}\n\t\tcount = 0;\n\t\tprevlen = curlen;\n\n\t\tmax_count = 7;\n\t\tmin_count = 4;\n\t\tif (nextlen == 0) {\n\t\t\tmax_count = 138;\n\t\t\tmin_count = 3;\n\t\t} else if (curlen == nextlen) {\n\t\t\tmax_count = 6;\n\t\t\tmin_count = 3;\n\t\t}\n\t}\n}",
        "parsed_output": "long long sub_4AFD56(long long a1, int a2)\n{\n  long long result;\n  int current_value;\n  int next_value;\n  int consecutive_count;\n  int max_consecutive;\n  int min_repeat;\n  int last_value;\n  unsigned int i;\n\n  last_value = -1;\n  current_value = *(unsigned short *)(a1 + 2);\n  consecutive_count = 0;\n  max_consecutive = 7;\n  min_repeat = 4;\n  if (current_value == 0)\n  {\n    max_consecutive = 138;\n    min_repeat = 3;\n  }\n  *(_WORD *)(4 * (a2 + 1) + a1 + 2) = -1;\n  for (i = 0; ; ++i)\n  {\n    result = i;\n    if ((int)i > a2)\n      break;\n    next_value = *(unsigned short *)(4 * (i + 1) + a1 + 2);\n    if (++consecutive_count >= max_consecutive || current_value != next_value)\n    {\n      if (consecutive_count >= min_repeat)\n      {\n        if (current_value)\n        {\n          if (current_value != last_value)\n            ++*((_WORD *)qword_75D408 + 2 * current_value + 2482);\n          ++*((_WORD *)qword_75D408 + 2514);\n        }\n        else if (consecutive_count > 10)\n        {\n          ++*((_WORD *)qword_75D408 + 2518);\n        }\n        else\n        {\n          ++*((_WORD *)qword_75D408 + 2516);\n        }\n      }\n      else\n      {\n        *((_WORD *)qword_75D408 + 2 * current_value + 2482) += consecutive_count;\n      }\n      consecutive_count = 0;\n      last_value = current_value;\n      max_consecutive = 7;\n      min_repeat = 4;\n      if (next_value)\n      {\n        if (current_value == next_value)\n        {\n          max_consecutive = 6;\n          min_repeat = 3;\n        }\n      }\n      else\n      {\n        max_consecutive = 138;\n        min_repeat = 3;\n      }\n    }\n    current_value = next_value;\n  }\n  return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4AFD56(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+10h] [rbp-1Ch]\n  int v4; // [rsp+14h] [rbp-18h]\n  int v5; // [rsp+18h] [rbp-14h]\n  int v6; // [rsp+1Ch] [rbp-10h]\n  int v7; // [rsp+20h] [rbp-Ch]\n  int v8; // [rsp+24h] [rbp-8h]\n  unsigned int i; // [rsp+28h] [rbp-4h]\n\n  v8 = -1;\n  v7 = *(unsigned __int16 *)(a1 + 2);\n  v6 = 0;\n  v5 = 7;\n  v4 = 4;\n  if ( !*(_WORD *)(a1 + 2) )\n  {\n    v5 = 138;\n    v4 = 3;\n  }\n  *(_WORD *)(4 * (a2 + 1LL) + a1 + 2) = -1;\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i > a2 )\n      break;\n    v3 = v7;\n    v7 = *(unsigned __int16 *)(4 * ((int)i + 1LL) + a1 + 2);\n    if ( ++v6 >= v5 || v3 != v7 )\n    {\n      if ( v6 >= v4 )\n      {\n        if ( v3 )\n        {\n          if ( v3 != v8 )\n            ++*((_WORD *)qword_75D408 + 2 * v3 + 2482);\n          ++*((_WORD *)qword_75D408 + 2514);\n        }\n        else if ( v6 > 10 )\n        {\n          ++*((_WORD *)qword_75D408 + 2518);\n        }\n        else\n        {\n          ++*((_WORD *)qword_75D408 + 2516);\n        }\n      }\n      else\n      {\n        *((_WORD *)qword_75D408 + 2 * v3 + 2482) += v6;\n      }\n      v6 = 0;\n      v8 = v3;\n      v5 = 7;\n      v4 = 4;\n      if ( v7 )\n      {\n        if ( v3 == v7 )\n        {\n          v5 = 6;\n          v4 = 3;\n        }\n      }\n      else\n      {\n        v5 = 138;\n        v4 = 3;\n      }\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl scan_tree(ct_data_0 *tree, int max_code)\n{\n  int curlen; // [rsp+10h] [rbp-1Ch]\n  int min_count; // [rsp+14h] [rbp-18h]\n  int max_count; // [rsp+18h] [rbp-14h]\n  int count; // [rsp+1Ch] [rbp-10h]\n  int nextlen; // [rsp+20h] [rbp-Ch]\n  int prevlen; // [rsp+24h] [rbp-8h]\n  int n; // [rsp+28h] [rbp-4h]\n\n  prevlen = -1;\n  nextlen = tree->dl.dad;\n  count = 0;\n  max_count = 7;\n  min_count = 4;\n  if ( !tree->dl.dad )\n  {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[max_code + 1].dl.dad = -1;\n  for ( n = 0; n <= max_code; ++n )\n  {\n    curlen = nextlen;\n    nextlen = tree[n + 1].dl.dad;\n    if ( ++count >= max_count || curlen != nextlen )\n    {\n      if ( count >= min_count )\n      {\n        if ( curlen )\n        {\n          if ( curlen != prevlen )\n            ++LOWORD(ptr_to_globals[17].speeds[curlen + 4]);\n          ++*(_WORD *)&ptr_to_globals[17].tty_attrs.c_cc[19];\n        }\n        else if ( count > 10 )\n        {\n          ++*(_WORD *)&ptr_to_globals[17].tty_attrs.c_cc[27];\n        }\n        else\n        {\n          ++*(_WORD *)&ptr_to_globals[17].tty_attrs.c_cc[23];\n        }\n      }\n      else\n      {\n        LOWORD(ptr_to_globals[17].speeds[curlen + 4]) += count;\n      }\n      count = 0;\n      prevlen = curlen;\n      max_count = 7;\n      min_count = 4;\n      if ( nextlen )\n      {\n        if ( curlen == nextlen )\n        {\n          max_count = 6;\n          min_count = 3;\n        }\n      }\n      else\n      {\n        max_count = 138;\n        min_count = 3;\n      }\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.6160424947738647,
        "similarity_score_baseline_stripped": 0.47005003690719604,
        "similarity_score_baseline_debug": 0.7451967000961304
    },
    {
        "func_name": "clrvar",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint *__fastcall sub_4DC88C(int *a1)\n{\n  int v1; // eax\n\n  if ( (*a1 & 0x1000) == 0 )\n    free(*((void **)a1 + 2));\n  *a1 &= 0x6C02u;\n  v1 = *a1;\n  BYTE1(v1) = BYTE1(*a1) | 0x40;\n  *a1 = v1;\n  *((_QWORD *)a1 + 2) = 0LL;\n  return a1;\n}\n",
        "output": "int *clear_and_update_flags(int *flags_ptr)\n{\n  if ((*flags_ptr & 0x1000) == 0)\n    free((void *)*(flags_ptr + 2));\n  \n  *flags_ptr &= 0x6C02u;\n  *flags_ptr |= 0x4000;\n  *(long long *)(flags_ptr + 4) = 0;\n  \n  return flags_ptr;\n}",
        "source_code": "static var *clrvar(var *v)\n{\n\tif (!(v->type & VF_FSTR))\n\t\tfree(v->string);\n\n\tv->type &= VF_DONTTOUCH;\n\tv->type |= VF_DIRTY;\n\tv->string = NULL;\n\treturn v;\n}",
        "parsed_output": "int *clear_and_update_flags(int *flags_ptr)\n{\n  if ((*flags_ptr & 0x1000) == 0)\n    free((void *)*(flags_ptr + 2));\n  \n  *flags_ptr &= 0x6C02u;\n  *flags_ptr |= 0x4000;\n  *(long long *)(flags_ptr + 4) = 0;\n  \n  return flags_ptr;\n}",
        "baseline_code_stripped": "int *__fastcall sub_4DC88C(int *a1)\n{\n  int v1; // eax\n\n  if ( (*a1 & 0x1000) == 0 )\n    free(*((void **)a1 + 2));\n  *a1 &= 0x6C02u;\n  v1 = *a1;\n  BYTE1(v1) = BYTE1(*a1) | 0x40;\n  *a1 = v1;\n  *((_QWORD *)a1 + 2) = 0LL;\n  return a1;\n}\n",
        "baseline_code_debug": "var_0 *__cdecl clrvar(var_0 *v)\n{\n  unsigned int type; // eax\n\n  if ( (v->type & 0x1000) == 0 )\n    free(v->string);\n  v->type &= 0x6C02u;\n  type = v->type;\n  BYTE1(type) = BYTE1(v->type) | 0x40;\n  v->type = type;\n  v->string = 0LL;\n  return v;\n}\n",
        "similarity_score_unixcoder": 0.6167383790016174,
        "similarity_score_baseline_stripped": 0.5142403841018677,
        "similarity_score_baseline_debug": 0.7837625741958618
    },
    {
        "func_name": "open_as_user",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_415BB6(__int64 a1, const char *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  int v7; // eax\n  ssize_t v8; // rax\n  char v9; // [rsp+17h] [rbp-9h] BYREF\n  __pid_t v10; // [rsp+18h] [rbp-8h]\n  __pid_t v11; // [rsp+1Ch] [rbp-4h]\n\n  v11 = vfork();\n  if ( v11 < 0 )\n    sub_4092A2((__int64)\"vfork\", (__int64)a2, v2, v3, v4, v5);\n  v10 = v11;\n  if ( !v11 )\n  {\n    sub_4F6569(a1);\n    v7 = sub_40A295(a2, 0);\n    v8 = sub_40B3FF(v7, &v9, 1uLL);\n    _exit(v8 < 0);\n  }\n  if ( (unsigned int)sub_409FAE(v10) )\n    return -1;\n  else\n    return open64(a2, 0);\n}\n",
        "output": "```c\nint executeAndOpenFile(__int64 parentProcess, const char *filePath)\n{\n  __pid_t childPid, waitResult;\n  int execResult;\n  ssize_t writeResult;\n  char execStatus;\n\n  childPid = vfork();\n  if (childPid < 0)\n    logError(\"vfork\", filePath);\n  \n  if (childPid == 0) // Child process\n  {\n    prepareChildProcess(parentProcess);\n    execResult = execute(filePath, 0);\n    writeResult = writeExecStatus(execResult, &execStatus, 1);\n    _exit(writeResult < 0);\n  }\n  \n  waitResult = waitForChild(childPid);\n  if (waitResult != 0)\n    return -1;\n  \n  return openFile(filePath, 0);\n}\n```",
        "source_code": "static int open_as_user(const struct passwd *pas, const char *file)\n{\n\tpid_t pid;\n\tchar c;\n\n\tpid = xvfork();\n\tif (pid) { /* PARENT */\n\t\tif (wait4pid(pid) == 0) {\n\t\t\t/* exitcode 0: child says it can read */\n\t\t\treturn open(file, O_RDONLY);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* CHILD */\n\t/* initgroups, setgid, setuid */\n\tchange_identity(pas);\n\t/* We just try to read one byte. If it works, file is readable\n\t * under this user. We signal that by exiting with 0. */\n\t_exit(safe_read(xopen(file, O_RDONLY), &c, 1) < 0);\n}",
        "parsed_output": "int executeAndOpenFile(__int64 parentProcess, const char *filePath)\n{\n  __pid_t childPid, waitResult;\n  int execResult;\n  ssize_t writeResult;\n  char execStatus;\n\n  childPid = vfork();\n  if (childPid < 0)\n    logError(\"vfork\", filePath);\n  \n  if (childPid == 0) // Child process\n  {\n    prepareChildProcess(parentProcess);\n    execResult = execute(filePath, 0);\n    writeResult = writeExecStatus(execResult, &execStatus, 1);\n    _exit(writeResult < 0);\n  }\n  \n  waitResult = waitForChild(childPid);\n  if (waitResult != 0)\n    return -1;\n  \n  return openFile(filePath, 0);\n}",
        "baseline_code_stripped": "int __fastcall sub_415BB6(__int64 a1, const char *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  int v7; // eax\n  ssize_t v8; // rax\n  char v9; // [rsp+17h] [rbp-9h] BYREF\n  __pid_t v10; // [rsp+18h] [rbp-8h]\n  __pid_t v11; // [rsp+1Ch] [rbp-4h]\n\n  v11 = vfork();\n  if ( v11 < 0 )\n    sub_4092A2((__int64)\"vfork\", (__int64)a2, v2, v3, v4, v5);\n  v10 = v11;\n  if ( !v11 )\n  {\n    sub_4F6569(a1);\n    v7 = sub_40A295(a2, 0);\n    v8 = sub_40B3FF(v7, &v9, 1uLL);\n    _exit(v8 < 0);\n  }\n  if ( (unsigned int)sub_409FAE(v10) )\n    return -1;\n  else\n    return open64(a2, 0);\n}\n",
        "baseline_code_debug": "int __cdecl open_as_user(const passwd *pas, const char *file)\n{\n  int v3; // eax\n  ssize_t v4; // rax\n  char c; // [rsp+17h] [rbp-9h] BYREF\n  pid_t pid; // [rsp+18h] [rbp-8h]\n  pid_t bb__xvfork_pid; // [rsp+1Ch] [rbp-4h]\n\n  bb__xvfork_pid = vfork();\n  if ( bb__xvfork_pid < 0 )\n    bb_perror_msg_and_die(\"vfork\");\n  pid = bb__xvfork_pid;\n  if ( !bb__xvfork_pid )\n  {\n    change_identity(pas);\n    v3 = xopen(file, 0);\n    v4 = safe_read(v3, &c, 1uLL);\n    _exit(v4 < 0);\n  }\n  if ( wait4pid(pid) )\n    return -1;\n  else\n    return open64(file, 0);\n}\n",
        "similarity_score_unixcoder": 0.7685506939888,
        "similarity_score_baseline_stripped": 0.6169637441635132,
        "similarity_score_baseline_debug": 0.8045257925987244
    },
    {
        "func_name": "full_read",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nssize_t __fastcall sub_40B446(int a1, char *a2, size_t a3)\n{\n  ssize_t v6; // [rsp+20h] [rbp-10h]\n  __int64 v7; // [rsp+28h] [rbp-8h]\n\n  v7 = 0LL;\n  while ( 1 )\n  {\n    if ( !a3 )\n      return v7;\n    v6 = sub_40B3FF(a1, a2, a3);\n    if ( v6 < 0 )\n      break;\n    if ( !v6 )\n      return v7;\n    a2 += v6;\n    v7 += v6;\n    a3 -= v6;\n  }\n  if ( v7 )\n    return v7;\n  else\n    return v6;\n}\n",
        "output": "ssize_t read_data(int fd, char *buffer, size_t count)\n{\n  ssize_t bytesRead;\n  ssize_t totalBytesRead = 0;\n\n  while (count > 0)\n  {\n    bytesRead = read_from_fd(fd, buffer, count);\n    if (bytesRead < 0)\n      return (totalBytesRead > 0) ? totalBytesRead : bytesRead;\n\n    if (bytesRead == 0)\n      break;\n\n    buffer += bytesRead;\n    totalBytesRead += bytesRead;\n    count -= bytesRead;\n  }\n\n  return totalBytesRead;\n}",
        "source_code": "ssize_t FAST_FUNC full_read(int fd, void *buf, size_t len)\n{\n\tssize_t cc;\n\tssize_t total;\n\n\ttotal = 0;\n\n\twhile (len) {\n\t\tcc = safe_read(fd, buf, len);\n\n\t\tif (cc < 0) {\n\t\t\tif (total) {\n\t\t\t\t/* we already have some! */\n\t\t\t\t/* user can do another read to know the error code */\n\t\t\t\treturn total;\n\t\t\t}\n\t\t\treturn cc; /* read() returns -1 on failure. */\n\t\t}\n\t\tif (cc == 0)\n\t\t\tbreak;\n\t\tbuf = ((char *)buf) + cc;\n\t\ttotal += cc;\n\t\tlen -= cc;\n\t}\n\n\treturn total;\n}",
        "parsed_output": "ssize_t read_data(int fd, char *buffer, size_t count)\n{\n  ssize_t bytesRead;\n  ssize_t totalBytesRead = 0;\n\n  while (count > 0)\n  {\n    bytesRead = read_from_fd(fd, buffer, count);\n    if (bytesRead < 0)\n      return (totalBytesRead > 0) ? totalBytesRead : bytesRead;\n\n    if (bytesRead == 0)\n      break;\n\n    buffer += bytesRead;\n    totalBytesRead += bytesRead;\n    count -= bytesRead;\n  }\n\n  return totalBytesRead;\n}",
        "baseline_code_stripped": "ssize_t __fastcall sub_40B446(int a1, char *a2, size_t a3)\n{\n  ssize_t v6; // [rsp+20h] [rbp-10h]\n  __int64 v7; // [rsp+28h] [rbp-8h]\n\n  v7 = 0LL;\n  while ( 1 )\n  {\n    if ( !a3 )\n      return v7;\n    v6 = sub_40B3FF(a1, a2, a3);\n    if ( v6 < 0 )\n      break;\n    if ( !v6 )\n      return v7;\n    a2 += v6;\n    v7 += v6;\n    a3 -= v6;\n  }\n  if ( v7 )\n    return v7;\n  else\n    return v6;\n}\n",
        "baseline_code_debug": "ssize_t __cdecl full_read(int fd, void *buf, size_t len)\n{\n  __int64 cc; // [rsp+20h] [rbp-10h]\n  ssize_t total; // [rsp+28h] [rbp-8h]\n\n  total = 0LL;\n  while ( 1 )\n  {\n    if ( !len )\n      return total;\n    cc = safe_read(fd, buf, len);\n    if ( cc < 0 )\n      break;\n    if ( !cc )\n      return total;\n    buf = (char *)buf + cc;\n    total += cc;\n    len -= cc;\n  }\n  if ( total )\n    return total;\n  else\n    return cc;\n}\n",
        "similarity_score_unixcoder": 0.811086893081665,
        "similarity_score_baseline_stripped": 0.5284274816513062,
        "similarity_score_baseline_debug": 0.860867977142334
    },
    {
        "func_name": "xsocket",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40A999(int a1, unsigned int a2, int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v8; // [rsp+1Ch] [rbp-4h]\n\n  v8 = socket(a1, a2, a3);\n  if ( v8 < 0 )\n    sub_4092A2((__int64)\"socket\", a2, v3, v4, v5, v6);\n  return (unsigned int)v8;\n}\n",
        "output": "int create_socket(int domain, unsigned int type, int protocol)\n{\n  int sock_fd;\n\n  sock_fd = socket(domain, type, protocol);\n  if (sock_fd < 0)\n    error_handler(\"socket\", type);\n  return sock_fd;\n}",
        "source_code": "int FAST_FUNC xsocket(int domain, int type, int protocol)\n{\n\tint r = socket(domain, type, protocol);\n\n\tif (r < 0) {\n\t\t/* Hijack vaguely related config option */\n#if ENABLE_VERBOSE_RESOLUTION_ERRORS\n\t\tconst char *s = \"INET\";\n# ifdef AF_PACKET\n\t\tif (domain == AF_PACKET) s = \"PACKET\";\n# endif\n# ifdef AF_NETLINK\n\t\tif (domain == AF_NETLINK) s = \"NETLINK\";\n# endif\nIF_FEATURE_IPV6(if (domain == AF_INET6) s = \"INET6\";)\n\t\tbb_perror_msg_and_die(\"socket(AF_%s,%d,%d)\", s, type, protocol);\n#else\n\t\tbb_perror_msg_and_die(\"socket\");\n#endif\n\t}\n\n\treturn r;\n}",
        "parsed_output": "int create_socket(int domain, unsigned int type, int protocol)\n{\n  int sock_fd;\n\n  sock_fd = socket(domain, type, protocol);\n  if (sock_fd < 0)\n    error_handler(\"socket\", type);\n  return sock_fd;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40A999(int a1, unsigned int a2, int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v8; // [rsp+1Ch] [rbp-4h]\n\n  v8 = socket(a1, a2, a3);\n  if ( v8 < 0 )\n    sub_4092A2((__int64)\"socket\", a2, v3, v4, v5, v6);\n  return (unsigned int)v8;\n}\n",
        "baseline_code_debug": "int __cdecl xsocket(int domain, int type, int protocol)\n{\n  int r; // [rsp+1Ch] [rbp-4h]\n\n  r = socket(domain, type, protocol);\n  if ( r < 0 )\n    bb_perror_msg_and_die(\"socket\");\n  return r;\n}\n",
        "similarity_score_unixcoder": 0.8377505540847778,
        "similarity_score_baseline_stripped": 0.5743594169616699,
        "similarity_score_baseline_debug": 0.683788537979126
    },
    {
        "func_name": "ife_print6",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_437847(__int64 a1)\n{\n  FILE *v1; // rax\n  unsigned int v2; // ebx\n  const char *v3; // rax\n  unsigned int v4; // eax\n  char v6[5]; // [rsp+10h] [rbp-C0h] BYREF\n  char v7[5]; // [rsp+15h] [rbp-BBh] BYREF\n  char v8[5]; // [rsp+1Ah] [rbp-B6h] BYREF\n  char v9[5]; // [rsp+1Fh] [rbp-B1h] BYREF\n  char v10[5]; // [rsp+24h] [rbp-ACh] BYREF\n  char v11[5]; // [rsp+29h] [rbp-A7h] BYREF\n  char v12[5]; // [rsp+2Eh] [rbp-A2h] BYREF\n  char v13[21]; // [rsp+33h] [rbp-9Dh] BYREF\n  int v14; // [rsp+48h] [rbp-88h] BYREF\n  unsigned int v15; // [rsp+4Ch] [rbp-84h] BYREF\n  __int16 v16; // [rsp+50h] [rbp-80h] BYREF\n  __int64 v17; // [rsp+58h] [rbp-78h] BYREF\n  char s1[32]; // [rsp+70h] [rbp-60h] BYREF\n  char s[40]; // [rsp+90h] [rbp-40h] BYREF\n  FILE *stream; // [rsp+B8h] [rbp-18h]\n\n  v1 = sub_40982E(\"/proc/net/if_inet6\");\n  stream = v1;\n  if ( v1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        do\n        {\n          if ( fscanf(\n                 stream,\n                 \"%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\\n\",\n                 v6,\n                 v7,\n                 v8,\n                 v9,\n                 v10,\n                 v11,\n                 v12,\n                 v13,\n                 &v13[13],\n                 &v15,\n                 &v14,\n                 &v13[17],\n                 s1) == -1 )\n          {\n            LODWORD(v1) = fclose(stream);\n            return (int)v1;\n          }\n        }\n        while ( strcmp(s1, (const char *)(a1 + 16)) );\n        sprintf(s, \"%s:%s:%s:%s:%s:%s:%s:%s\", v6, v7, v8, v9, v10, v11, v12, v13);\n        inet_pton(10, s, &v17);\n        v16 = 10;\n        v2 = v15;\n        v3 = sub_43685A(&v16, 1u);\n        printf(\"          inet6 addr: %s/%d\", v3, v2);\n        printf(\" Scope:\");\n        v4 = v14 & 0xF0;\n        if ( v4 != 32 )\n          break;\n        puts(\"Link\");\n      }\n      if ( v4 > 0x20 )\n      {\n        if ( v4 == 64 )\n        {\n          puts(\"Site\");\n        }\n        else if ( v4 == 128 )\n        {\n          puts(\"Compat\");\n        }\n        else\n        {\nLABEL_17:\n          puts(\"Unknown\");\n        }\n      }\n      else if ( (v14 & 0xF0) != 0 )\n      {\n        if ( v4 != 16 )\n          goto LABEL_17;\n        puts(\"Host\");\n      }\n      else\n      {\n        puts(\"Global\");\n      }\n    }\n  }\n  return (int)v1;\n}\n",
        "output": "int __fastcall displayIPv6Info(__int64 interfaceNamePtr)\n{\n  FILE *file;\n  unsigned int prefixLength;\n  const char *formattedIPv6;\n  unsigned int scope;\n  char ipv6Part1[5];\n  char ipv6Part2[5];\n  char ipv6Part3[5];\n  char ipv6Part4[5];\n  char ipv6Part5[5];\n  char ipv6Part6[5];\n  char ipv6Part7[5];\n  char ipv6Part8[21];\n  int scopeId;\n  unsigned int scopeValue;\n  __int16 af;\n  __int64 in6addr;\n  char interfaceName[32];\n  char fullIPv6[40];\n  FILE *stream;\n\n  file = openProcNetIfInet6(\"/proc/net/if_inet6\");\n  stream = file;\n  if (file)\n  {\n    while (1)\n    {\n      if (fscanf(stream, \"%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\\n\",\n                 ipv6Part1, ipv6Part2, ipv6Part3, ipv6Part4,\n                 ipv6Part5, ipv6Part6, ipv6Part7, ipv6Part8,\n                 &ipv6Part8[13], &scopeValue, &scopeId, &ipv6Part8[17], interfaceName) == -1)\n      {\n        return fclose(stream);\n      }\n\n      if (strcmp(interfaceName, (const char *)(interfaceNamePtr + 16)) == 0)\n      {\n        sprintf(fullIPv6, \"%s:%s:%s:%s:%s:%s:%s:%s\", ipv6Part1, ipv6Part2, ipv6Part3, ipv6Part4,\n                ipv6Part5, ipv6Part6, ipv6Part7, ipv6Part8);\n        inet_pton(AF_INET6, fullIPv6, &in6addr);\n        af = AF_INET6;\n        prefixLength = scopeValue;\n        formattedIPv6 = formatIPv6Address(&af, 1u);\n        printf(\"          inet6 addr: %s/%d\", formattedIPv6, prefixLength);\n        printf(\" Scope:\");\n        scope = scopeId & 0xF0;\n        switch (scope)\n        {\n          case 0x20:\n            puts(\"Link\");\n            break;\n          case 0x40:\n            puts(\"Site\");\n            break;\n          case 0x80:\n            puts(\"Compat\");\n            break;\n          case 0x10:\n            puts(\"Host\");\n            break;\n          default:\n            if (scope > 0x20)\n            {\n              puts(\"Unknown\");\n            }\n            else if (scope == 0)\n            {\n              puts(\"Global\");\n            }\n            break;\n        }\n      }\n    }\n  }\n  return (int)file;\n}",
        "source_code": "static void ife_print6(struct interface *ptr)\n{\n\tFILE *f;\n\tchar addr6[40], devname[20];\n\tstruct sockaddr_in6 sap;\n\tint plen, scope, dad_status, if_idx;\n\tchar addr6p[8][5];\n\n\tf = fopen_for_read(_PATH_PROCNET_IFINET6);\n\tif (f == NULL)\n\t\treturn;\n\n\twhile (fscanf\n\t\t   (f, \"%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\\n\",\n\t\t\taddr6p[0], addr6p[1], addr6p[2], addr6p[3], addr6p[4],\n\t\t\taddr6p[5], addr6p[6], addr6p[7], &if_idx, &plen, &scope,\n\t\t\t&dad_status, devname) != EOF\n\t) {\n\t\tif (!strcmp(devname, ptr->name)) {\n\t\t\tsprintf(addr6, \"%s:%s:%s:%s:%s:%s:%s:%s\",\n\t\t\t\t\taddr6p[0], addr6p[1], addr6p[2], addr6p[3],\n\t\t\t\t\taddr6p[4], addr6p[5], addr6p[6], addr6p[7]);\n\t\t\tinet_pton(AF_INET6, addr6,\n\t\t\t\t\t  (struct sockaddr *) &sap.sin6_addr);\n\t\t\tsap.sin6_family = AF_INET6;\n\t\t\tprintf(\"          inet6 addr: %s/%d\",\n\t\t\t\tINET6_sprint((struct sockaddr *) &sap, 1),\n\t\t\t\tplen);\n\t\t\tprintf(\" Scope:\");\n\t\t\tswitch (scope & IPV6_ADDR_SCOPE_MASK) {\n\t\t\tcase 0:\n\t\t\t\tputs(\"Global\");\n\t\t\t\tbreak;\n\t\t\tcase IPV6_ADDR_LINKLOCAL:\n\t\t\t\tputs(\"Link\");\n\t\t\t\tbreak;\n\t\t\tcase IPV6_ADDR_SITELOCAL:\n\t\t\t\tputs(\"Site\");\n\t\t\t\tbreak;\n\t\t\tcase IPV6_ADDR_COMPATv4:\n\t\t\t\tputs(\"Compat\");\n\t\t\t\tbreak;\n\t\t\tcase IPV6_ADDR_LOOPBACK:\n\t\t\t\tputs(\"Host\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tputs(\"Unknown\");\n\t\t\t}\n\t\t}\n\t}\n\tfclose(f);\n}",
        "parsed_output": "int __fastcall displayIPv6Info(__int64 interfaceNamePtr)\n{\n  FILE *file;\n  unsigned int prefixLength;\n  const char *formattedIPv6;\n  unsigned int scope;\n  char ipv6Part1[5];\n  char ipv6Part2[5];\n  char ipv6Part3[5];\n  char ipv6Part4[5];\n  char ipv6Part5[5];\n  char ipv6Part6[5];\n  char ipv6Part7[5];\n  char ipv6Part8[21];\n  int scopeId;\n  unsigned int scopeValue;\n  __int16 af;\n  __int64 in6addr;\n  char interfaceName[32];\n  char fullIPv6[40];\n  FILE *stream;\n\n  file = openProcNetIfInet6(\"/proc/net/if_inet6\");\n  stream = file;\n  if (file)\n  {\n    while (1)\n    {\n      if (fscanf(stream, \"%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\\n\",\n                 ipv6Part1, ipv6Part2, ipv6Part3, ipv6Part4,\n                 ipv6Part5, ipv6Part6, ipv6Part7, ipv6Part8,\n                 &ipv6Part8[13], &scopeValue, &scopeId, &ipv6Part8[17], interfaceName) == -1)\n      {\n        return fclose(stream);\n      }\n\n      if (strcmp(interfaceName, (const char *)(interfaceNamePtr + 16)) == 0)\n      {\n        sprintf(fullIPv6, \"%s:%s:%s:%s:%s:%s:%s:%s\", ipv6Part1, ipv6Part2, ipv6Part3, ipv6Part4,\n                ipv6Part5, ipv6Part6, ipv6Part7, ipv6Part8);\n        inet_pton(AF_INET6, fullIPv6, &in6addr);\n        af = AF_INET6;\n        prefixLength = scopeValue;\n        formattedIPv6 = formatIPv6Address(&af, 1u);\n        printf(\"          inet6 addr: %s/%d\", formattedIPv6, prefixLength);\n        printf(\" Scope:\");\n        scope = scopeId & 0xF0;\n        switch (scope)\n        {\n          case 0x20:\n            puts(\"Link\");\n            break;\n          case 0x40:\n            puts(\"Site\");\n            break;\n          case 0x80:\n            puts(\"Compat\");\n            break;\n          case 0x10:\n            puts(\"Host\");\n            break;\n          default:\n            if (scope > 0x20)\n            {\n              puts(\"Unknown\");\n            }\n            else if (scope == 0)\n            {\n              puts(\"Global\");\n            }\n            break;\n        }\n      }\n    }\n  }\n  return (int)file;\n}",
        "baseline_code_stripped": "int __fastcall sub_437847(__int64 a1)\n{\n  FILE *v1; // rax\n  unsigned int v2; // ebx\n  const char *v3; // rax\n  unsigned int v4; // eax\n  char v6[5]; // [rsp+10h] [rbp-C0h] BYREF\n  char v7[5]; // [rsp+15h] [rbp-BBh] BYREF\n  char v8[5]; // [rsp+1Ah] [rbp-B6h] BYREF\n  char v9[5]; // [rsp+1Fh] [rbp-B1h] BYREF\n  char v10[5]; // [rsp+24h] [rbp-ACh] BYREF\n  char v11[5]; // [rsp+29h] [rbp-A7h] BYREF\n  char v12[5]; // [rsp+2Eh] [rbp-A2h] BYREF\n  char v13[21]; // [rsp+33h] [rbp-9Dh] BYREF\n  int v14; // [rsp+48h] [rbp-88h] BYREF\n  unsigned int v15; // [rsp+4Ch] [rbp-84h] BYREF\n  __int16 v16; // [rsp+50h] [rbp-80h] BYREF\n  __int64 v17; // [rsp+58h] [rbp-78h] BYREF\n  char s1[32]; // [rsp+70h] [rbp-60h] BYREF\n  char s[40]; // [rsp+90h] [rbp-40h] BYREF\n  FILE *stream; // [rsp+B8h] [rbp-18h]\n\n  v1 = sub_40982E(\"/proc/net/if_inet6\");\n  stream = v1;\n  if ( v1 )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        do\n        {\n          if ( fscanf(\n                 stream,\n                 \"%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\\n\",\n                 v6,\n                 v7,\n                 v8,\n                 v9,\n                 v10,\n                 v11,\n                 v12,\n                 v13,\n                 &v13[13],\n                 &v15,\n                 &v14,\n                 &v13[17],\n                 s1) == -1 )\n          {\n            LODWORD(v1) = fclose(stream);\n            return (int)v1;\n          }\n        }\n        while ( strcmp(s1, (const char *)(a1 + 16)) );\n        sprintf(s, \"%s:%s:%s:%s:%s:%s:%s:%s\", v6, v7, v8, v9, v10, v11, v12, v13);\n        inet_pton(10, s, &v17);\n        v16 = 10;\n        v2 = v15;\n        v3 = sub_43685A(&v16, 1u);\n        printf(\"          inet6 addr: %s/%d\", v3, v2);\n        printf(\" Scope:\");\n        v4 = v14 & 0xF0;\n        if ( v4 != 32 )\n          break;\n        puts(\"Link\");\n      }\n      if ( v4 > 0x20 )\n      {\n        if ( v4 == 64 )\n        {\n          puts(\"Site\");\n        }\n        else if ( v4 == 128 )\n        {\n          puts(\"Compat\");\n        }\n        else\n        {\nLABEL_17:\n          puts(\"Unknown\");\n        }\n      }\n      else if ( (v14 & 0xF0) != 0 )\n      {\n        if ( v4 != 16 )\n          goto LABEL_17;\n        puts(\"Host\");\n      }\n      else\n      {\n        puts(\"Global\");\n      }\n    }\n  }\n  return (int)v1;\n}\n",
        "baseline_code_debug": "void __cdecl ife_print6(interface *ptr)\n{\n  unsigned int v1; // ebx\n  const char *v2; // rax\n  unsigned int v3; // eax\n  char addr6p[8][5]; // [rsp+10h] [rbp-C0h] BYREF\n  int if_idx; // [rsp+40h] [rbp-90h] BYREF\n  int dad_status; // [rsp+44h] [rbp-8Ch] BYREF\n  int scope; // [rsp+48h] [rbp-88h] BYREF\n  int plen; // [rsp+4Ch] [rbp-84h] BYREF\n  sockaddr_in6 sap; // [rsp+50h] [rbp-80h] BYREF\n  char devname[20]; // [rsp+70h] [rbp-60h] BYREF\n  char addr6[40]; // [rsp+90h] [rbp-40h] BYREF\n  FILE *f; // [rsp+B8h] [rbp-18h]\n\n  f = fopen_for_read(\"/proc/net/if_inet6\");\n  if ( f )\n  {\n    while ( 1 )\n    {\n      while ( 1 )\n      {\n        do\n        {\n          if ( fscanf(\n                 f,\n                 \"%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\\n\",\n                 addr6p,\n                 addr6p[1],\n                 addr6p[2],\n                 addr6p[3],\n                 addr6p[4],\n                 addr6p[5],\n                 addr6p[6],\n                 addr6p[7],\n                 &if_idx,\n                 &plen,\n                 &scope,\n                 &dad_status,\n                 devname) == -1 )\n          {\n            fclose(f);\n            return;\n          }\n        }\n        while ( strcmp(devname, ptr->name) );\n        sprintf(\n          addr6,\n          \"%s:%s:%s:%s:%s:%s:%s:%s\",\n          addr6p[0],\n          addr6p[1],\n          addr6p[2],\n          addr6p[3],\n          addr6p[4],\n          addr6p[5],\n          addr6p[6],\n          addr6p[7]);\n        inet_pton(10, addr6, &sap.sin6_addr);\n        sap.sin6_family = 10;\n        v1 = plen;\n        v2 = INET6_sprint((sockaddr *)&sap, 1);\n        printf(\"          inet6 addr: %s/%d\", v2, v1);\n        printf(\" Scope:\");\n        v3 = scope & 0xF0;\n        if ( v3 != 32 )\n          break;\n        puts(\"Link\");\n      }\n      if ( v3 > 0x20 )\n      {\n        if ( v3 == 64 )\n        {\n          puts(\"Site\");\n        }\n        else if ( v3 == 128 )\n        {\n          puts(\"Compat\");\n        }\n        else\n        {\nLABEL_17:\n          puts(\"Unknown\");\n        }\n      }\n      else if ( (scope & 0xF0) != 0 )\n      {\n        if ( v3 != 16 )\n          goto LABEL_17;\n        puts(\"Host\");\n      }\n      else\n      {\n        puts(\"Global\");\n      }\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.8865941166877747,
        "similarity_score_baseline_stripped": 0.6921354532241821,
        "similarity_score_baseline_debug": 0.8936731815338135
    },
    {
        "func_name": "write_table",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_494DF3()\n{\n  __int64 v0; // rcx\n  __int64 v1; // r8\n  __int64 v2; // r9\n  char *v4; // [rsp+0h] [rbp-10h]\n  int i; // [rsp+Ch] [rbp-4h]\n  int j; // [rsp+Ch] [rbp-4h]\n\n  if ( !*((_BYTE *)qword_75D408 + 48) )\n  {\n    for ( i = 0; i <= 2; ++i )\n    {\n      if ( *((_BYTE *)qword_75D408 + 40 * i + 2536) )\n        *((_BYTE *)qword_75D408 + 2656) = 1;\n    }\n    for ( j = 3; j < *((_DWORD *)qword_75D408 + 4); ++j )\n    {\n      v4 = (char *)qword_75D408 + 40 * j + 2504;\n      if ( *((_BYTE *)qword_75D408 + 40 * j + 2536) )\n      {\n        sub_490756(*((_QWORD *)qword_75D408 + 5 * j + 316));\n        sub_490876(*((_DWORD *)v4 + 4), *((_QWORD *)v4 + 3), *((_QWORD *)v4 + 3), v0, v1, v2);\n      }\n    }\n  }\n  puts(\"The partition table has been altered.\");\n  return sub_494D94(1);\n}\n",
        "output": "```c\nvoid updatePartitionTableStatus()\n{\n  char *partitionEntry;\n  int index;\n\n  if (!globalPartitionTableStatus.modified)\n  {\n    // Check first three partition entries for modification\n    for (index = 0; index <= 2; ++index)\n    {\n      if (globalPartitionTable[index].modified)\n        globalPartitionTableStatus.anyModified = 1;\n    }\n    \n    // Check remaining partition entries for modification\n    for (index = 3; index < globalPartitionTableStatus.totalPartitions; ++index)\n    {\n      partitionEntry = (char *)&globalPartitionTable[index];\n      if (globalPartitionTable[index].modified)\n      {\n        processPartitionEntry(globalPartitionTable[index].data);\n        updatePartitionEntry(partitionEntry[16], partitionEntry[24], partitionEntry[24]);\n      }\n    }\n  }\n  \n  puts(\"The partition table has been altered.\");\n  finalizePartitionTableUpdate(1);\n}\n```",
        "source_code": "static void\nwrite_table(void)\n{\n\tint i;\n\n\tif (LABEL_IS_DOS) {\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tif (ptes[i].changed)\n\t\t\t\tptes[3].changed = 1;\n\t\tfor (i = 3; i < g_partitions; i++) {\n\t\t\tstruct pte *pe = &ptes[i];\n\t\t\tif (pe->changed) {\n\t\t\t\twrite_part_table_flag(pe->sectorbuffer);\n\t\t\t\twrite_sector(pe->offset_from_dev_start, pe->sectorbuffer);\n\t\t\t}\n\t\t}\n\t}\n\telse if (LABEL_IS_SGI) {\n\t\t/* no test on change? the printf below might be mistaken */\n\t\tsgi_write_table();\n\t}\n\telse if (LABEL_IS_SUN) {\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (ptes[i].changed) {\n\t\t\t\tsun_write_table();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"The partition table has been altered.\\n\");\n\treread_partition_table(1);\n}",
        "parsed_output": "void updatePartitionTableStatus()\n{\n  char *partitionEntry;\n  int index;\n\n  if (!globalPartitionTableStatus.modified)\n  {\n    // Check first three partition entries for modification\n    for (index = 0; index <= 2; ++index)\n    {\n      if (globalPartitionTable[index].modified)\n        globalPartitionTableStatus.anyModified = 1;\n    }\n    \n    // Check remaining partition entries for modification\n    for (index = 3; index < globalPartitionTableStatus.totalPartitions; ++index)\n    {\n      partitionEntry = (char *)&globalPartitionTable[index];\n      if (globalPartitionTable[index].modified)\n      {\n        processPartitionEntry(globalPartitionTable[index].data);\n        updatePartitionEntry(partitionEntry[16], partitionEntry[24], partitionEntry[24]);\n      }\n    }\n  }\n  \n  puts(\"The partition table has been altered.\");\n  finalizePartitionTableUpdate(1);\n}",
        "baseline_code_stripped": "__int64 sub_494DF3()\n{\n  __int64 v0; // rcx\n  __int64 v1; // r8\n  __int64 v2; // r9\n  char *v4; // [rsp+0h] [rbp-10h]\n  int i; // [rsp+Ch] [rbp-4h]\n  int j; // [rsp+Ch] [rbp-4h]\n\n  if ( !*((_BYTE *)qword_75D408 + 48) )\n  {\n    for ( i = 0; i <= 2; ++i )\n    {\n      if ( *((_BYTE *)qword_75D408 + 40 * i + 2536) )\n        *((_BYTE *)qword_75D408 + 2656) = 1;\n    }\n    for ( j = 3; j < *((_DWORD *)qword_75D408 + 4); ++j )\n    {\n      v4 = (char *)qword_75D408 + 40 * j + 2504;\n      if ( *((_BYTE *)qword_75D408 + 40 * j + 2536) )\n      {\n        sub_490756(*((_QWORD *)qword_75D408 + 5 * j + 316));\n        sub_490876(*((_DWORD *)v4 + 4), *((_QWORD *)v4 + 3), *((_QWORD *)v4 + 3), v0, v1, v2);\n      }\n    }\n  }\n  puts(\"The partition table has been altered.\");\n  return sub_494D94(1);\n}\n",
        "baseline_code_debug": "void __cdecl write_table()\n{\n  pte *pe; // [rsp+0h] [rbp-10h]\n  int i; // [rsp+Ch] [rbp-4h]\n  int ia; // [rsp+Ch] [rbp-4h]\n\n  if ( !LOBYTE(ptr_to_globals->numspeed) )\n  {\n    for ( i = 0; i <= 2; ++i )\n    {\n      if ( ptr_to_globals[8].line_buf[40 * i + 76] )\n        LOBYTE(ptr_to_globals[9].speeds[3]) = 1;\n    }\n    for ( ia = 3; ia < SLODWORD(ptr_to_globals->fakehost); ++ia )\n    {\n      pe = (pte *)&ptr_to_globals[8].line_buf[40 * ia + 44];\n      if ( ptr_to_globals[8].line_buf[40 * ia + 76] )\n      {\n        write_part_table_flag(*(char **)&ptr_to_globals[8].line_buf[40 * ia + 68]);\n        write_sector(pe->offset_from_dev_start, pe->sectorbuffer);\n      }\n    }\n  }\n  puts(\"The partition table has been altered.\");\n  reread_partition_table(1);\n}\n",
        "similarity_score_unixcoder": 0.6453128457069397,
        "similarity_score_baseline_stripped": 0.5433832406997681,
        "similarity_score_baseline_debug": 0.7738335132598877
    },
    {
        "func_name": "iamarray",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4DC779(__int64 a1, __int64 a2)\n{\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = a1; (*(_DWORD *)i & 0x2000) != 0; i = *(_QWORD *)(i + 24) )\n    ;\n  if ( (*(_DWORD *)i & 2) == 0 )\n  {\n    *(_DWORD *)i |= 2u;\n    *(_QWORD *)(i + 24) = sub_4DC126(a1, a2);\n  }\n  return *(_QWORD *)(i + 24);\n}\n",
        "output": "```c\ntypedef struct {\n    unsigned int flags;\n    // other fields\n    __int64 next;\n} Node;\n\nNode* find_next_available_node(Node* start) {\n    Node* current = start;\n    while (current->flags & 0x2000) {\n        current = (Node*)current->next;\n    }\n    if (!(current->flags & 2)) {\n        current->flags |= 2;\n        current->next = (__int64)sub_4DC126((__int64)start, a2);\n    }\n    return (Node*)current->next;\n}\n```",
        "source_code": "static xhash *iamarray(var *v)\n{\n\tvar *a = v;\n\n\twhile (a->type & VF_CHILD)\n\t\ta = a->x.parent;\n\n\tif (!(a->type & VF_ARRAY)) {\n\t\ta->type |= VF_ARRAY;\n\t\ta->x.array = hash_init();\n\t}\n\treturn a->x.array;\n}",
        "parsed_output": "typedef struct {\n    unsigned int flags;\n    // other fields\n    __int64 next;\n} Node;\n\nNode* find_next_available_node(Node* start) {\n    Node* current = start;\n    while (current->flags & 0x2000) {\n        current = (Node*)current->next;\n    }\n    if (!(current->flags & 2)) {\n        current->flags |= 2;\n        current->next = (__int64)sub_4DC126((__int64)start, a2);\n    }\n    return (Node*)current->next;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4DC779(__int64 a1, __int64 a2)\n{\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = a1; (*(_DWORD *)i & 0x2000) != 0; i = *(_QWORD *)(i + 24) )\n    ;\n  if ( (*(_DWORD *)i & 2) == 0 )\n  {\n    *(_DWORD *)i |= 2u;\n    *(_QWORD *)(i + 24) = sub_4DC126(a1, a2);\n  }\n  return *(_QWORD *)(i + 24);\n}\n",
        "baseline_code_debug": "xhash *__cdecl iamarray(var_0 *v)\n{\n  while ( (v->type & 0x2000) != 0 )\n    v = v->x.parent;\n  if ( (v->type & 2) == 0 )\n  {\n    v->type |= 2u;\n    v->x.array = hash_init();\n  }\n  return v->x.array;\n}\n",
        "similarity_score_unixcoder": 0.42792487144470215,
        "similarity_score_baseline_stripped": 0.4438897967338562,
        "similarity_score_baseline_debug": 0.806994616985321
    },
    {
        "func_name": "builtin_export",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_48953B(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  const char **v7; // rax\n  unsigned int v8; // ecx\n  const char **v9; // [rsp+8h] [rbp-28h]\n  char *v10; // [rsp+10h] [rbp-20h]\n  char *s; // [rsp+18h] [rbp-18h]\n  int v12; // [rsp+24h] [rbp-Ch]\n  const char **v13; // [rsp+28h] [rbp-8h]\n\n  v12 = sub_4FA1EF(a1, (unsigned int)\"!n\", a3, a4, a5, a6);\n  if ( v12 == -1 )\n    return 1LL;\n  v9 = (const char **)(8LL * optind + a1);\n  if ( *v9 )\n  {\n    if ( v12 )\n      v8 = -1;\n    else\n      v8 = 1;\n    sub_489420(v9, v8, 0);\n    return 0LL;\n  }\n  else\n  {\n    v13 = (const char **)environ;\n    if ( environ )\n    {\n      while ( *v13 )\n      {\n        v7 = v13++;\n        s = (char *)*v7;\n        v10 = strchr(*v7, 61);\n        if ( v10 )\n        {\n          printf(\"export %.*s\", (_DWORD)v10 - (_DWORD)s + 1, s);\n          sub_489379(v10 + 1);\n          putchar_unlocked(10);\n        }\n      }\n    }\n    return 0LL;\n  }\n}\n",
        "output": "```c\n__int64 __fastcall processArguments(__int64 argList, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int parseResult; // [rsp+24h] [rbp-Ch]\n  const char **currentArg; // [rsp+28h] [rbp-8h]\n  const char **argPointer; // [rsp+8h] [rbp-28h]\n  char *envValue; // [rsp+10h] [rbp-20h]\n  char *envString; // [rsp+18h] [rbp-18h]\n\n  parseResult = parseOptions(argList, (unsigned int)\"!n\", a3, a4, a5, a6);\n  if (parseResult == -1)\n    return 1LL;\n\n  argPointer = (const char **)(8LL * optind + argList);\n  if (*argPointer)\n  {\n    unsigned int flag = parseResult ? -1 : 1;\n    processOption(argPointer, flag, 0);\n    return 0LL;\n  }\n  else\n  {\n    currentArg = (const char **)environ;\n    if (environ)\n    {\n      while (*currentArg)\n      {\n        envString = (char *)*currentArg;\n        envValue = strchr(*currentArg, '=');\n        if (envValue)\n        {\n          printf(\"export %.*s\", (int)(envValue - envString) + 1, envString);\n          processEnvironmentVariable(envValue + 1);\n          putchar_unlocked('\\n');\n        }\n        currentArg++;\n      }\n    }\n    return 0LL;\n  }\n}\n```",
        "source_code": "static int FAST_FUNC builtin_export(char **argv)\n{\n\tunsigned opt_unexport;\n\n#if ENABLE_HUSH_EXPORT_N\n\t/* \"!\": do not abort on errors */\n\topt_unexport = getopt32(argv, \"!n\");\n\tif (opt_unexport == (uint32_t)-1)\n\t\treturn EXIT_FAILURE;\n\targv += optind;\n#else\n\topt_unexport = 0;\n\targv++;\n#endif\n\n\tif (argv[0] == NULL) {\n\t\tchar **e = environ;\n\t\tif (e) {\n\t\t\twhile (*e) {\n#if 0\n\t\t\t\tputs(*e++);\n#else\n\t\t\t\t/* ash emits: export VAR='VAL'\n\t\t\t\t * bash: declare -x VAR=\"VAL\"\n\t\t\t\t * we follow ash example */\n\t\t\t\tconst char *s = *e++;\n\t\t\t\tconst char *p = strchr(s, '=');\n\n\t\t\t\tif (!p) /* wtf? take next variable */\n\t\t\t\t\tcontinue;\n\t\t\t\t/* export var= */\n\t\t\t\tprintf(\"export %.*s\", (int)(p - s) + 1, s);\n\t\t\t\tprint_escaped(p + 1);\n\t\t\t\tputchar('\\n');\n#endif\n\t\t\t}\n\t\t\t/*fflush_all(); - done after each builtin anyway */\n\t\t}\n\t\treturn EXIT_SUCCESS;\n\t}\n\n\thelper_export_local(argv, (opt_unexport ? -1 : 1), 0);\n\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "__int64 __fastcall processArguments(__int64 argList, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int parseResult; // [rsp+24h] [rbp-Ch]\n  const char **currentArg; // [rsp+28h] [rbp-8h]\n  const char **argPointer; // [rsp+8h] [rbp-28h]\n  char *envValue; // [rsp+10h] [rbp-20h]\n  char *envString; // [rsp+18h] [rbp-18h]\n\n  parseResult = parseOptions(argList, (unsigned int)\"!n\", a3, a4, a5, a6);\n  if (parseResult == -1)\n    return 1LL;\n\n  argPointer = (const char **)(8LL * optind + argList);\n  if (*argPointer)\n  {\n    unsigned int flag = parseResult ? -1 : 1;\n    processOption(argPointer, flag, 0);\n    return 0LL;\n  }\n  else\n  {\n    currentArg = (const char **)environ;\n    if (environ)\n    {\n      while (*currentArg)\n      {\n        envString = (char *)*currentArg;\n        envValue = strchr(*currentArg, '=');\n        if (envValue)\n        {\n          printf(\"export %.*s\", (int)(envValue - envString) + 1, envString);\n          processEnvironmentVariable(envValue + 1);\n          putchar_unlocked('\\n');\n        }\n        currentArg++;\n      }\n    }\n    return 0LL;\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_48953B(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  const char **v7; // rax\n  unsigned int v8; // ecx\n  const char **v9; // [rsp+8h] [rbp-28h]\n  char *v10; // [rsp+10h] [rbp-20h]\n  char *s; // [rsp+18h] [rbp-18h]\n  int v12; // [rsp+24h] [rbp-Ch]\n  const char **v13; // [rsp+28h] [rbp-8h]\n\n  v12 = sub_4FA1EF(a1, (unsigned int)\"!n\", a3, a4, a5, a6);\n  if ( v12 == -1 )\n    return 1LL;\n  v9 = (const char **)(8LL * optind + a1);\n  if ( *v9 )\n  {\n    if ( v12 )\n      v8 = -1;\n    else\n      v8 = 1;\n    sub_489420(v9, v8, 0);\n    return 0LL;\n  }\n  else\n  {\n    v13 = (const char **)environ;\n    if ( environ )\n    {\n      while ( *v13 )\n      {\n        v7 = v13++;\n        s = (char *)*v7;\n        v10 = strchr(*v7, 61);\n        if ( v10 )\n        {\n          printf(\"export %.*s\", (_DWORD)v10 - (_DWORD)s + 1, s);\n          sub_489379(v10 + 1);\n          putchar_unlocked(10);\n        }\n      }\n    }\n    return 0LL;\n  }\n}\n",
        "baseline_code_debug": "int __cdecl builtin_export(char **argv)\n{\n  const char **v2; // rax\n  int v3; // ecx\n  char **argva; // [rsp+8h] [rbp-28h]\n  char *p; // [rsp+10h] [rbp-20h]\n  const char *s; // [rsp+18h] [rbp-18h]\n  unsigned int opt_unexport; // [rsp+24h] [rbp-Ch]\n  char **e; // [rsp+28h] [rbp-8h]\n\n  opt_unexport = getopt32(argv, \"!n\");\n  if ( opt_unexport == -1 )\n    return 1;\n  argva = &argv[optind];\n  if ( *argva )\n  {\n    if ( opt_unexport )\n      v3 = -1;\n    else\n      v3 = 1;\n    helper_export_local(argva, v3, 0);\n    return 0;\n  }\n  else\n  {\n    e = (char **)environ;\n    if ( environ )\n    {\n      while ( *e )\n      {\n        v2 = (const char **)e++;\n        s = *v2;\n        p = strchr(*v2, 61);\n        if ( p )\n        {\n          printf(\"export %.*s\", (_DWORD)p - (_DWORD)s + 1, s);\n          print_escaped(p + 1);\n          putchar_unlocked(10);\n        }\n      }\n    }\n    return 0;\n  }\n}\n",
        "similarity_score_unixcoder": 0.7476875185966492,
        "similarity_score_baseline_stripped": 0.690185546875,
        "similarity_score_baseline_debug": 0.8295559287071228
    },
    {
        "func_name": "find_in_path",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_486617(const char *a1)\n{\n  __int64 v2; // r8\n  __int64 v3; // r9\n  char *v4; // [rsp+18h] [rbp-18h]\n  const char *s; // [rsp+20h] [rbp-10h]\n  char *ptr; // [rsp+28h] [rbp-8h]\n\n  ptr = 0LL;\n  s = sub_4807EA(\"PATH\");\n  if ( !s )\n    return 0LL;\n  while ( 1 )\n  {\n    v4 = strchrnul(s, 58);\n    free(ptr);\n    ptr = (_DWORD)v4 == (_DWORD)s\n        ? sub_40A11F(a1, 58LL)\n        : sub_40A6B3(\"%.*s/%s\", (unsigned int)((_DWORD)v4 - (_DWORD)s), (__int64)s, (__int64)a1, v2, v3);\n    if ( !access(ptr, 0) )\n      break;\n    if ( !*v4 )\n    {\n      free(ptr);\n      return 0LL;\n    }\n    s = v4 + 1;\n  }\n  return ptr;\n}\n",
        "output": "char *findInPath(const char *filename)\n{\n  const char *pathEnv;\n  char *currentPath;\n  char *pathEnd;\n  char *resultPath;\n\n  resultPath = NULL;\n  pathEnv = getenv(\"PATH\");\n  if (!pathEnv)\n    return NULL;\n\n  while (1)\n  {\n    pathEnd = strchrnul(pathEnv, ':');\n    free(resultPath);\n    resultPath = (pathEnd == pathEnv)\n        ? constructPath(filename, ':')\n        : constructPathWithFormat(\"%.*s/%s\", (int)(pathEnd - pathEnv), pathEnv, filename);\n    if (!access(resultPath, F_OK))\n      break;\n    if (!*pathEnd)\n    {\n      free(resultPath);\n      return NULL;\n    }\n    pathEnv = pathEnd + 1;\n  }\n  return resultPath;\n}",
        "source_code": "static char *find_in_path(const char *arg)\n{\n\tchar *ret = NULL;\n\tconst char *PATH = get_local_var_value(\"PATH\");\n\n\tif (!PATH)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tconst char *end = strchrnul(PATH, ':');\n\t\tint sz = end - PATH; /* must be int! */\n\n\t\tfree(ret);\n\t\tif (sz != 0) {\n\t\t\tret = xasprintf(\"%.*s/%s\", sz, PATH, arg);\n\t\t} else {\n\t\t\t/* We have xxx::yyyy in $PATH,\n\t\t\t * it means \"use current dir\" */\n\t\t\tret = xstrdup(arg);\n\t\t}\n\t\tif (access(ret, F_OK) == 0)\n\t\t\tbreak;\n\n\t\tif (*end == '\\0') {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tPATH = end + 1;\n\t}\n\n\treturn ret;\n}",
        "parsed_output": "char *findInPath(const char *filename)\n{\n  const char *pathEnv;\n  char *currentPath;\n  char *pathEnd;\n  char *resultPath;\n\n  resultPath = NULL;\n  pathEnv = getenv(\"PATH\");\n  if (!pathEnv)\n    return NULL;\n\n  while (1)\n  {\n    pathEnd = strchrnul(pathEnv, ':');\n    free(resultPath);\n    resultPath = (pathEnd == pathEnv)\n        ? constructPath(filename, ':')\n        : constructPathWithFormat(\"%.*s/%s\", (int)(pathEnd - pathEnv), pathEnv, filename);\n    if (!access(resultPath, F_OK))\n      break;\n    if (!*pathEnd)\n    {\n      free(resultPath);\n      return NULL;\n    }\n    pathEnv = pathEnd + 1;\n  }\n  return resultPath;\n}",
        "baseline_code_stripped": "char *__fastcall sub_486617(const char *a1)\n{\n  __int64 v2; // r8\n  __int64 v3; // r9\n  char *v4; // [rsp+18h] [rbp-18h]\n  const char *s; // [rsp+20h] [rbp-10h]\n  char *ptr; // [rsp+28h] [rbp-8h]\n\n  ptr = 0LL;\n  s = sub_4807EA(\"PATH\");\n  if ( !s )\n    return 0LL;\n  while ( 1 )\n  {\n    v4 = strchrnul(s, 58);\n    free(ptr);\n    ptr = (_DWORD)v4 == (_DWORD)s\n        ? sub_40A11F(a1, 58LL)\n        : sub_40A6B3(\"%.*s/%s\", (unsigned int)((_DWORD)v4 - (_DWORD)s), (__int64)s, (__int64)a1, v2, v3);\n    if ( !access(ptr, 0) )\n      break;\n    if ( !*v4 )\n    {\n      free(ptr);\n      return 0LL;\n    }\n    s = v4 + 1;\n  }\n  return ptr;\n}\n",
        "baseline_code_debug": "char *__cdecl find_in_path(const char *arg)\n{\n  char *end; // [rsp+18h] [rbp-18h]\n  const char *PATH; // [rsp+20h] [rbp-10h]\n  char *ret; // [rsp+28h] [rbp-8h]\n\n  ret = 0LL;\n  PATH = get_local_var_value(\"PATH\");\n  if ( !PATH )\n    return 0LL;\n  while ( 1 )\n  {\n    end = strchrnul(PATH, 58);\n    free(ret);\n    ret = (_DWORD)end == (_DWORD)PATH ? xstrdup(arg) : xasprintf(\"%.*s/%s\", (int)end - (int)PATH, PATH, arg);\n    if ( !access(ret, 0) )\n      break;\n    if ( !*end )\n    {\n      free(ret);\n      return 0LL;\n    }\n    PATH = end + 1;\n  }\n  return ret;\n}\n",
        "similarity_score_unixcoder": 0.8108552694320679,
        "similarity_score_baseline_stripped": 0.6680409908294678,
        "similarity_score_baseline_debug": 0.8805899620056152
    },
    {
        "func_name": "end_cmd_q",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *sub_4EEE98()\n{\n  void *result; // rax\n\n  *((_DWORD *)qword_75D408 + 44) = 26;\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 118) = 0;\n  return result;\n}\n",
        "output": "```c\nvoid *setGlobalStructValues()\n{\n  // Set the integer value at offset 44 within the global structure to 26\n  *((int *)globalStruct + 44) = 26;\n  \n  // Set the byte value at offset 118 within the global structure to 0\n  *((char *)globalStruct + 118) = 0;\n  \n  // Return the pointer to the global structure\n  return globalStruct;\n}\n```",
        "source_code": "static void end_cmd_q(void)\n{\n#if ENABLE_FEATURE_VI_YANKMARK\n\tYDreg = 26;\t\t\t// go back to default Yank/Delete reg\n#endif\n\tadding2q = 0;\n}",
        "parsed_output": "void *setGlobalStructValues()\n{\n  // Set the integer value at offset 44 within the global structure to 26\n  *((int *)globalStruct + 44) = 26;\n  \n  // Set the byte value at offset 118 within the global structure to 0\n  *((char *)globalStruct + 118) = 0;\n  \n  // Return the pointer to the global structure\n  return globalStruct;\n}",
        "baseline_code_stripped": "void *sub_4EEE98()\n{\n  void *result; // rax\n\n  *((_DWORD *)qword_75D408 + 44) = 26;\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 118) = 0;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl end_cmd_q()\n{\n  *(_DWORD *)&ptr_to_globals->line_buf[20] = 26;\n  ptr_to_globals->tty_attrs.c_cc[5] = 0;\n}\n",
        "similarity_score_unixcoder": 0.3907129466533661,
        "similarity_score_baseline_stripped": 0.505116879940033,
        "similarity_score_baseline_debug": 0.5100896954536438
    },
    {
        "func_name": "format_header",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint sub_4639E2()\n{\n  int result; // eax\n  const char **v1; // [rsp+8h] [rbp-18h]\n  char *s; // [rsp+10h] [rbp-10h]\n  int v3; // [rsp+1Ch] [rbp-4h]\n\n  result = dest.c_lflag;\n  if ( result )\n  {\n    s = *(char **)&dest.c_cc[7];\n    v3 = 0;\n    if ( dest.c_cflag )\n    {\n      while ( 1 )\n      {\n        v1 = (const char **)(32LL * v3++ + *(_QWORD *)&dest.c_iflag);\n        if ( v3 == dest.c_cflag )\n          break;\n        s += sprintf(s, \"%-*s \", *(unsigned __int16 *)v1, v1[1]);\n      }\n      strcpy(s, v1[1]);\n    }\n    return printf(\"%.*s\\n\", *(_DWORD *)&dest.c_cc[15], *(const char **)&dest.c_cc[7]);\n  }\n  return result;\n}\n",
        "output": "```c\nint printFormattedOutput()\n{\n  int isLFlagSet; // eax\n  const char **entryPointer; // [rsp+8h] [rbp-18h]\n  char *outputBuffer; // [rsp+10h] [rbp-10h]\n  int entryIndex; // [rsp+1Ch] [rbp-4h]\n\n  isLFlagSet = dest.c_lflag;\n  if (isLFlagSet)\n  {\n    outputBuffer = *(char **)&dest.c_cc[7];\n    entryIndex = 0;\n    if (dest.c_cflag)\n    {\n      while (true)\n      {\n        entryPointer = (const char **)(32LL * entryIndex++ + *(_QWORD *)&dest.c_iflag);\n        if (entryIndex == dest.c_cflag)\n          break;\n        outputBuffer += sprintf(outputBuffer, \"%-*s \", *(unsigned short *)entryPointer, entryPointer[1]);\n      }\n      strcpy(outputBuffer, entryPointer[1]);\n    }\n    return printf(\"%.*s\\n\", *(_DWORD *)&dest.c_cc[15], *(const char **)&dest.c_cc[7]);\n  }\n  return isLFlagSet;\n}\n```",
        "source_code": "static void format_header(void)\n{\n\tint i;\n\tps_out_t* op;\n\tchar *p;\n\n\tif (!print_header)\n\t\treturn;\n\tp = buffer;\n\ti = 0;\n\tif (out_cnt) {\n\t\twhile (1) {\n\t\t\top = &out[i];\n\t\t\tif (++i == out_cnt) /* do not pad last field */\n\t\t\t\tbreak;\n\t\t\tp += sprintf(p, \"%-*s \", op->width, op->header);\n\t\t}\n\t\tstrcpy(p, op->header);\n\t}\n\tprintf(\"%.*s\\n\", terminal_width, buffer);\n}",
        "parsed_output": "int printFormattedOutput()\n{\n  int isLFlagSet; // eax\n  const char **entryPointer; // [rsp+8h] [rbp-18h]\n  char *outputBuffer; // [rsp+10h] [rbp-10h]\n  int entryIndex; // [rsp+1Ch] [rbp-4h]\n\n  isLFlagSet = dest.c_lflag;\n  if (isLFlagSet)\n  {\n    outputBuffer = *(char **)&dest.c_cc[7];\n    entryIndex = 0;\n    if (dest.c_cflag)\n    {\n      while (true)\n      {\n        entryPointer = (const char **)(32LL * entryIndex++ + *(_QWORD *)&dest.c_iflag);\n        if (entryIndex == dest.c_cflag)\n          break;\n        outputBuffer += sprintf(outputBuffer, \"%-*s \", *(unsigned short *)entryPointer, entryPointer[1]);\n      }\n      strcpy(outputBuffer, entryPointer[1]);\n    }\n    return printf(\"%.*s\\n\", *(_DWORD *)&dest.c_cc[15], *(const char **)&dest.c_cc[7]);\n  }\n  return isLFlagSet;\n}",
        "baseline_code_stripped": "int sub_4639E2()\n{\n  int result; // eax\n  const char **v1; // [rsp+8h] [rbp-18h]\n  char *s; // [rsp+10h] [rbp-10h]\n  int v3; // [rsp+1Ch] [rbp-4h]\n\n  result = dest.c_lflag;\n  if ( result )\n  {\n    s = *(char **)&dest.c_cc[7];\n    v3 = 0;\n    if ( dest.c_cflag )\n    {\n      while ( 1 )\n      {\n        v1 = (const char **)(32LL * v3++ + *(_QWORD *)&dest.c_iflag);\n        if ( v3 == dest.c_cflag )\n          break;\n        s += sprintf(s, \"%-*s \", *(unsigned __int16 *)v1, v1[1]);\n      }\n      strcpy(s, v1[1]);\n    }\n    return printf(\"%.*s\\n\", *(_DWORD *)&dest.c_cc[15], *(const char **)&dest.c_cc[7]);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl format_header()\n{\n  ps_out_t *op; // [rsp+8h] [rbp-18h]\n  char *p; // [rsp+10h] [rbp-10h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  if ( bb_common_bufsiz1.c_lflag )\n  {\n    p = *(char **)&bb_common_bufsiz1.c_cc[7];\n    i = 0;\n    if ( bb_common_bufsiz1.c_cflag )\n    {\n      while ( 1 )\n      {\n        op = (ps_out_t *)(32LL * i++ + *(_QWORD *)&bb_common_bufsiz1.c_iflag);\n        if ( i == bb_common_bufsiz1.c_cflag )\n          break;\n        p += sprintf(p, \"%-*s \", op->width, op->header);\n      }\n      strcpy(p, op->header);\n    }\n    printf(\"%.*s\\n\", *(_DWORD *)&bb_common_bufsiz1.c_cc[15], *(const char **)&bb_common_bufsiz1.c_cc[7]);\n  }\n}\n",
        "similarity_score_unixcoder": 0.6212376952171326,
        "similarity_score_baseline_stripped": 0.5552067756652832,
        "similarity_score_baseline_debug": 0.737819492816925
    },
    {
        "func_name": "get_cred_or_die",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_412053(unsigned int a1)\n{\n  const char *v1; // rax\n  _QWORD *v2; // rbx\n  const char *v3; // rax\n  _QWORD *v4; // rbx\n  __int64 v5; // rdx\n  __int64 v6; // rcx\n  __int64 v7; // r8\n  __int64 v8; // r9\n  _QWORD *v9; // rbx\n  _QWORD *v10; // rbx\n  __int64 result; // rax\n\n  if ( isatty(a1) )\n  {\n    v1 = (const char *)sub_4F5FA5(a1, 0LL, \"User: \");\n    v2 = qword_75D408;\n    v2[2] = sub_40A11F(v1, 0LL);\n    v3 = (const char *)sub_4F5FA5(a1, 0LL, \"Password: \");\n    v4 = qword_75D408;\n    v4[3] = sub_40A11F(v3, 0LL);\n  }\n  else\n  {\n    v9 = qword_75D408;\n    v9[2] = sub_507143(a1, 0LL);\n    v10 = qword_75D408;\n    v10[3] = sub_507143(a1, 0LL);\n  }\n  if ( !*((_QWORD *)qword_75D408 + 2)\n    || !**((_BYTE **)qword_75D408 + 2)\n    || (result = *((_QWORD *)qword_75D408 + 3)) == 0 )\n  {\n    sub_40969E(\"no username or password\", 0LL, v5, v6, v7, v8);\n  }\n  return result;\n}\n",
        "output": "long long __fastcall processCredentials(unsigned int fileDescriptor)\n{\n  const char *username;\n  const char *password;\n  long long *credentialsArray = qword_75D408;\n  long long result;\n\n  if (isatty(fileDescriptor))\n  {\n    username = (const char *)promptInput(fileDescriptor, \"User: \");\n    credentialsArray[2] = hashString(username);\n    password = (const char *)promptInput(fileDescriptor, \"Password: \");\n    credentialsArray[3] = hashString(password);\n  }\n  else\n  {\n    credentialsArray[2] = readFromFile(fileDescriptor);\n    credentialsArray[3] = readFromFile(fileDescriptor);\n  }\n\n  if (!credentialsArray[2] || !*(char *)(credentialsArray[2]) || !(result = credentialsArray[3]))\n  {\n    reportError(\"no username or password\");\n  }\n\n  return result;\n}",
        "source_code": "void FAST_FUNC get_cred_or_die(int fd)\n{\n\tif (isatty(fd)) {\n\t\tG.user = xstrdup(bb_ask(fd, /* timeout: */ 0, \"User: \"));\n\t\tG.pass = xstrdup(bb_ask(fd, /* timeout: */ 0, \"Password: \"));\n\t} else {\n\t\tG.user = xmalloc_reads(fd, /* maxsize: */ NULL);\n\t\tG.pass = xmalloc_reads(fd, /* maxsize: */ NULL);\n\t}\n\tif (!G.user || !*G.user || !G.pass)\n\t\tbb_error_msg_and_die(\"no username or password\");\n}",
        "parsed_output": "long long __fastcall processCredentials(unsigned int fileDescriptor)\n{\n  const char *username;\n  const char *password;\n  long long *credentialsArray = qword_75D408;\n  long long result;\n\n  if (isatty(fileDescriptor))\n  {\n    username = (const char *)promptInput(fileDescriptor, \"User: \");\n    credentialsArray[2] = hashString(username);\n    password = (const char *)promptInput(fileDescriptor, \"Password: \");\n    credentialsArray[3] = hashString(password);\n  }\n  else\n  {\n    credentialsArray[2] = readFromFile(fileDescriptor);\n    credentialsArray[3] = readFromFile(fileDescriptor);\n  }\n\n  if (!credentialsArray[2] || !*(char *)(credentialsArray[2]) || !(result = credentialsArray[3]))\n  {\n    reportError(\"no username or password\");\n  }\n\n  return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_412053(unsigned int a1)\n{\n  const char *v1; // rax\n  _QWORD *v2; // rbx\n  const char *v3; // rax\n  _QWORD *v4; // rbx\n  __int64 v5; // rdx\n  __int64 v6; // rcx\n  __int64 v7; // r8\n  __int64 v8; // r9\n  _QWORD *v9; // rbx\n  _QWORD *v10; // rbx\n  __int64 result; // rax\n\n  if ( isatty(a1) )\n  {\n    v1 = (const char *)sub_4F5FA5(a1, 0LL, \"User: \");\n    v2 = qword_75D408;\n    v2[2] = sub_40A11F(v1, 0LL);\n    v3 = (const char *)sub_4F5FA5(a1, 0LL, \"Password: \");\n    v4 = qword_75D408;\n    v4[3] = sub_40A11F(v3, 0LL);\n  }\n  else\n  {\n    v9 = qword_75D408;\n    v9[2] = sub_507143(a1, 0LL);\n    v10 = qword_75D408;\n    v10[3] = sub_507143(a1, 0LL);\n  }\n  if ( !*((_QWORD *)qword_75D408 + 2)\n    || !**((_BYTE **)qword_75D408 + 2)\n    || (result = *((_QWORD *)qword_75D408 + 3)) == 0 )\n  {\n    sub_40969E(\"no username or password\", 0LL, v5, v6, v7, v8);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl get_cred_or_die(int fd)\n{\n  char *v1; // rax\n  globals *v2; // rbx\n  char *v3; // rax\n  globals *v4; // rbx\n  globals *v5; // rbx\n  globals *v6; // rbx\n\n  if ( isatty(fd) )\n  {\n    v1 = bb_ask(fd, 0, \"User: \");\n    v2 = ptr_to_globals;\n    v2->fakehost = xstrdup(v1);\n    v3 = bb_ask(fd, 0, \"Password: \");\n    v4 = ptr_to_globals;\n    v4->tty_name = xstrdup(v3);\n  }\n  else\n  {\n    v5 = ptr_to_globals;\n    v5->fakehost = xmalloc_reads(fd, 0LL);\n    v6 = ptr_to_globals;\n    v6->tty_name = xmalloc_reads(fd, 0LL);\n  }\n  if ( !ptr_to_globals->fakehost || !*ptr_to_globals->fakehost || !ptr_to_globals->tty_name )\n    bb_error_msg_and_die(\"no username or password\");\n}\n",
        "similarity_score_unixcoder": 0.6588379740715027,
        "similarity_score_baseline_stripped": 0.48185139894485474,
        "similarity_score_baseline_debug": 0.8280889987945557
    },
    {
        "func_name": "unexpand",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_4C8F32(__int64 a1, unsigned int a2, char a3)\n{\n  void *result; // rax\n  char v6[8]; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v7; // [rsp+18h] [rbp-28h]\n  char v8; // [rsp+1Fh] [rbp-21h]\n  void *ptr; // [rsp+20h] [rbp-20h]\n  unsigned int v10; // [rsp+2Ch] [rbp-14h]\n  unsigned int v11; // [rsp+30h] [rbp-10h]\n  unsigned int v12; // [rsp+34h] [rbp-Ch]\n  char *s; // [rsp+38h] [rbp-8h]\n\n  for ( result = (void *)sub_4F9FD0(a1); ; result = (void *)sub_4F9FD0(a1) )\n  {\n    ptr = result;\n    if ( !result )\n      break;\n    s = (char *)ptr;\n    v12 = 0;\n    while ( *s )\n    {\n      v10 = 0;\n      while ( *s == 32 )\n      {\n        ++s;\n        ++v10;\n      }\n      v12 += v10;\n      if ( *s == 9 )\n      {\n        v12 += a2 - v12 % a2;\n        ++s;\n      }\n      else\n      {\n        v11 = v12 / a2;\n        if ( v12 / a2 )\n        {\n          v12 %= a2;\n          v10 = v12;\n          while ( v11-- )\n            putchar_unlocked(9);\n        }\n        if ( (a3 & 1) != 0 && s != ptr )\n        {\n          printf(\"%*s%s\", v10, (const char *)&unk_536BFE, s);\n          break;\n        }\n        v11 = strcspn(s, \"\\t \");\n        printf(\"%*s%.*s\", v10, (const char *)&unk_536BFE, v11, s);\n        v8 = s[v11];\n        s[v11] = 0;\n        sub_502FB1(v6, s);\n        v10 = v7;\n        s[v11] = v8;\n        s += v11;\n        v12 = (v12 + v10) % a2;\n      }\n    }\n    free(ptr);\n  }\n  return result;\n}\n",
        "output": "```c\nvoid *format_text(__int64 text_ptr, unsigned int tab_width, char options)\n{\n  void *current_text;\n  char buffer[8];\n  unsigned int space_count;\n  char last_char;\n  void *text_to_free;\n  unsigned int tab_count;\n  unsigned int char_count;\n  unsigned int total_char_count;\n  char *text;\n\n  for (current_text = (void *)get_next_text_block(text_ptr); current_text; current_text = (void *)get_next_text_block(text_ptr))\n  {\n    text_to_free = current_text;\n    text = (char *)text_to_free;\n    total_char_count = 0;\n    while (*text)\n    {\n      space_count = 0;\n      while (*text == ' ')\n      {\n        ++text;\n        ++space_count;\n      }\n      total_char_count += space_count;\n      if (*text == '\\t')\n      {\n        total_char_count += tab_width - total_char_count % tab_width;\n        ++text;\n      }\n      else\n      {\n        tab_count = total_char_count / tab_width;\n        if (tab_count)\n        {\n          total_char_count %= tab_width;\n          space_count = total_char_count;\n          while (tab_count--)\n            putchar_unlocked('\\t');\n        }\n        if ((options & 1) != 0 && text != text_to_free)\n        {\n          printf(\"%*s%s\", space_count, \"\", text);\n          break;\n        }\n        char_count = strcspn(text, \"\\t \");\n        printf(\"%*s%.*s\", space_count, \"\", char_count, text);\n        last_char = text[char_count];\n        text[char_count] = '\\0';\n        process_text(buffer, text);\n        space_count = buffer[0]; // Assuming buffer[0] contains the processed space count\n        text[char_count] = last_char;\n        text += char_count;\n        total_char_count = (total_char_count + space_count) % tab_width;\n      }\n    }\n    free(text_to_free);\n  }\n  return current_text;\n}\n```",
        "source_code": "if ENABLE_UNEXPAND\nstatic void unexpand(FILE *file, unsigned tab_size, unsigned opt)\n{\n\tchar *line;\n\n\twhile ((line = xmalloc_fgets(file)) != NULL) {\n\t\tchar *ptr = line;\n\t\tunsigned column = 0;\n\n\t\twhile (*ptr) {\n\t\t\tunsigned n;\n\t\t\tunsigned len = 0;\n\n\t\t\twhile (*ptr == ' ') {\n\t\t\t\tptr++;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tcolumn += len;\n\t\t\tif (*ptr == '\\t') {\n\t\t\t\tcolumn += tab_size - (column % tab_size);\n\t\t\t\tptr++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn = column / tab_size;\n\t\t\tif (n) {\n\t\t\t\tlen = column = column % tab_size;\n\t\t\t\twhile (n--)\n\t\t\t\t\tputchar('\\t');\n\t\t\t}\n\n\t\t\tif ((opt & OPT_INITIAL) && ptr != line) {\n\t\t\t\tprintf(\"%*s%s\", len, \"\", ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = strcspn(ptr, \"\\t \");\n\t\t\tprintf(\"%*s%.*s\", len, \"\", n, ptr);\n# if ENABLE_UNICODE_SUPPORT\n\t\t\t{\n\t\t\t\tchar c;\n\t\t\t\tuni_stat_t uni_stat;\n\t\t\t\tc = ptr[n];\n\t\t\t\tptr[n] = '\\0';\n\t\t\t\tprintable_string(&uni_stat, ptr);\n\t\t\t\tlen = uni_stat.unicode_width;\n\t\t\t\tptr[n] = c;\n\t\t\t}\n# else\n\t\t\tlen = n;\n# endif\n\t\t\tptr += n;\n\t\t\tcolumn = (column + len) % tab_size;\n\t\t}\n\t\tfree(line);\n\t}\n}",
        "parsed_output": "void *format_text(__int64 text_ptr, unsigned int tab_width, char options)\n{\n  void *current_text;\n  char buffer[8];\n  unsigned int space_count;\n  char last_char;\n  void *text_to_free;\n  unsigned int tab_count;\n  unsigned int char_count;\n  unsigned int total_char_count;\n  char *text;\n\n  for (current_text = (void *)get_next_text_block(text_ptr); current_text; current_text = (void *)get_next_text_block(text_ptr))\n  {\n    text_to_free = current_text;\n    text = (char *)text_to_free;\n    total_char_count = 0;\n    while (*text)\n    {\n      space_count = 0;\n      while (*text == ' ')\n      {\n        ++text;\n        ++space_count;\n      }\n      total_char_count += space_count;\n      if (*text == '\\t')\n      {\n        total_char_count += tab_width - total_char_count % tab_width;\n        ++text;\n      }\n      else\n      {\n        tab_count = total_char_count / tab_width;\n        if (tab_count)\n        {\n          total_char_count %= tab_width;\n          space_count = total_char_count;\n          while (tab_count--)\n            putchar_unlocked('\\t');\n        }\n        if ((options & 1) != 0 && text != text_to_free)\n        {\n          printf(\"%*s%s\", space_count, \"\", text);\n          break;\n        }\n        char_count = strcspn(text, \"\\t \");\n        printf(\"%*s%.*s\", space_count, \"\", char_count, text);\n        last_char = text[char_count];\n        text[char_count] = '\\0';\n        process_text(buffer, text);\n        space_count = buffer[0]; // Assuming buffer[0] contains the processed space count\n        text[char_count] = last_char;\n        text += char_count;\n        total_char_count = (total_char_count + space_count) % tab_width;\n      }\n    }\n    free(text_to_free);\n  }\n  return current_text;\n}",
        "baseline_code_stripped": "void *__fastcall sub_4C8F32(__int64 a1, unsigned int a2, char a3)\n{\n  void *result; // rax\n  char v6[8]; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v7; // [rsp+18h] [rbp-28h]\n  char v8; // [rsp+1Fh] [rbp-21h]\n  void *ptr; // [rsp+20h] [rbp-20h]\n  unsigned int v10; // [rsp+2Ch] [rbp-14h]\n  unsigned int v11; // [rsp+30h] [rbp-10h]\n  unsigned int v12; // [rsp+34h] [rbp-Ch]\n  char *s; // [rsp+38h] [rbp-8h]\n\n  for ( result = (void *)sub_4F9FD0(a1); ; result = (void *)sub_4F9FD0(a1) )\n  {\n    ptr = result;\n    if ( !result )\n      break;\n    s = (char *)ptr;\n    v12 = 0;\n    while ( *s )\n    {\n      v10 = 0;\n      while ( *s == 32 )\n      {\n        ++s;\n        ++v10;\n      }\n      v12 += v10;\n      if ( *s == 9 )\n      {\n        v12 += a2 - v12 % a2;\n        ++s;\n      }\n      else\n      {\n        v11 = v12 / a2;\n        if ( v12 / a2 )\n        {\n          v12 %= a2;\n          v10 = v12;\n          while ( v11-- )\n            putchar_unlocked(9);\n        }\n        if ( (a3 & 1) != 0 && s != ptr )\n        {\n          printf(\"%*s%s\", v10, (const char *)&unk_536BFE, s);\n          break;\n        }\n        v11 = strcspn(s, \"\\t \");\n        printf(\"%*s%.*s\", v10, (const char *)&unk_536BFE, v11, s);\n        v8 = s[v11];\n        s[v11] = 0;\n        sub_502FB1(v6, s);\n        v10 = v7;\n        s[v11] = v8;\n        s += v11;\n        v12 = (v12 + v10) % a2;\n      }\n    }\n    free(ptr);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl unexpand(FILE *file, unsigned int tab_size, unsigned int opt)\n{\n  char opta; // [rsp+0h] [rbp-40h]\n  uni_stat_t_0 uni_stat; // [rsp+10h] [rbp-30h] BYREF\n  char c; // [rsp+1Fh] [rbp-21h]\n  char *line; // [rsp+20h] [rbp-20h]\n  unsigned int len; // [rsp+2Ch] [rbp-14h]\n  unsigned int n; // [rsp+30h] [rbp-10h]\n  unsigned int column; // [rsp+34h] [rbp-Ch]\n  char *ptr; // [rsp+38h] [rbp-8h]\n\n  opta = opt;\n  while ( 1 )\n  {\n    line = xmalloc_fgets(file);\n    if ( !line )\n      break;\n    ptr = line;\n    column = 0;\n    while ( *ptr )\n    {\n      len = 0;\n      while ( *ptr == 32 )\n      {\n        ++ptr;\n        ++len;\n      }\n      column += len;\n      if ( *ptr == 9 )\n      {\n        column += tab_size - column % tab_size;\n        ++ptr;\n      }\n      else\n      {\n        n = column / tab_size;\n        if ( column / tab_size )\n        {\n          column %= tab_size;\n          len = column;\n          while ( n-- )\n            putchar_unlocked(9);\n        }\n        if ( (opta & 1) != 0 && ptr != line )\n        {\n          printf(\"%*s%s\", len, (const char *)&unk_536BFE, ptr);\n          break;\n        }\n        n = strcspn(ptr, \"\\t \");\n        printf(\"%*s%.*s\", len, (const char *)&unk_536BFE, n, ptr);\n        c = ptr[n];\n        ptr[n] = 0;\n        printable_string(&uni_stat, ptr);\n        len = uni_stat.unicode_width;\n        ptr[n] = c;\n        ptr += n;\n        column = (column + len) % tab_size;\n      }\n    }\n    free(line);\n  }\n}\n",
        "similarity_score_unixcoder": 0.7811317443847656,
        "similarity_score_baseline_stripped": 0.5681265592575073,
        "similarity_score_baseline_debug": 0.8401921987533569
    },
    {
        "func_name": "set_qlen",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_44BD19(const char *a1, int a2)\n{\n  char s[16]; // [rsp+10h] [rbp-30h] BYREF\n  int v4; // [rsp+20h] [rbp-20h]\n  int fd; // [rsp+3Ch] [rbp-4h]\n\n  fd = sub_44BBB0();\n  memset(s, 0, 0x28uLL);\n  sub_409A52(s, a1);\n  v4 = a2;\n  sub_40AD51(fd, 0x8943u, (__int64)s, (__int64)\"SIOCSIFTXQLEN\");\n  return close(fd);\n}\n",
        "output": "```c\nint setInterfaceTxQueueLength(const char *interfaceName, int queueLength)\n{\n  char ioctlBuffer[16];\n  int socketDescriptor;\n\n  socketDescriptor = openSocket();\n  memset(ioctlBuffer, 0, sizeof(ioctlBuffer));\n  copyInterfaceName(ioctlBuffer, interfaceName);\n  int txQueueLength = queueLength;\n  performIoctl(socketDescriptor, SIOCSIFTXQLEN, ioctlBuffer, \"SIOCSIFTXQLEN\");\n  return close(socketDescriptor);\n}\n```",
        "source_code": "static void set_qlen(char *dev, int qlen)\n{\n\tstruct ifreq ifr;\n\tint s;\n\n\ts = get_ctl_fd();\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy_IFNAMSIZ(ifr.ifr_name, dev);\n\tifr.ifr_qlen = qlen;\n\txioctl(s, SIOCSIFTXQLEN, &ifr);\n\tclose(s);\n}",
        "parsed_output": "int setInterfaceTxQueueLength(const char *interfaceName, int queueLength)\n{\n  char ioctlBuffer[16];\n  int socketDescriptor;\n\n  socketDescriptor = openSocket();\n  memset(ioctlBuffer, 0, sizeof(ioctlBuffer));\n  copyInterfaceName(ioctlBuffer, interfaceName);\n  int txQueueLength = queueLength;\n  performIoctl(socketDescriptor, SIOCSIFTXQLEN, ioctlBuffer, \"SIOCSIFTXQLEN\");\n  return close(socketDescriptor);\n}",
        "baseline_code_stripped": "int __fastcall sub_44BD19(const char *a1, int a2)\n{\n  char s[16]; // [rsp+10h] [rbp-30h] BYREF\n  int v4; // [rsp+20h] [rbp-20h]\n  int fd; // [rsp+3Ch] [rbp-4h]\n\n  fd = sub_44BBB0();\n  memset(s, 0, 0x28uLL);\n  sub_409A52(s, a1);\n  v4 = a2;\n  sub_40AD51(fd, 0x8943u, (__int64)s, (__int64)\"SIOCSIFTXQLEN\");\n  return close(fd);\n}\n",
        "baseline_code_debug": "void __cdecl set_qlen(char *dev, int qlen)\n{\n  ifreq ifr; // [rsp+10h] [rbp-30h] BYREF\n  int s; // [rsp+3Ch] [rbp-4h]\n\n  s = get_ctl_fd();\n  memset(&ifr, 0, sizeof(ifr));\n  strncpy_IFNAMSIZ(ifr.ifr_ifrn.ifrn_name, dev);\n  ifr.ifr_ifru.ifru_ivalue = qlen;\n  bb_xioctl(s, 0x8943u, &ifr, \"SIOCSIFTXQLEN\");\n  close(s);\n}\n",
        "similarity_score_unixcoder": 0.6931523680686951,
        "similarity_score_baseline_stripped": 0.4749789535999298,
        "similarity_score_baseline_debug": 0.8802815675735474
    },
    {
        "func_name": "resuse_end",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_422B21(int a1, __WAIT_STATUS a2)\n{\n  __int64 result; // rax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  union wait v7; // edx\n  __pid_t v8; // [rsp+1Ch] [rbp-4h]\n\n  while ( 1 )\n  {\n    v8 = wait3(a2, 0, (struct rusage *)&a2.__uptr[2]);\n    if ( v8 == a1 )\n      break;\n    if ( v8 == -1 && *(_DWORD *)qword_75D400 != 4 )\n      return sub_4091D9((__int64)\"wait\", 0LL, v3, v4, v5, v6);\n  }\n  v7.w_status = sub_40BC94() - a2.__uptr[38].w_status;\n  result = (__int64)a2.__uptr;\n  a2.__uptr[38].w_status = v7.w_status;\n  return result;\n}\n",
        "output": "int waitForProcess(int pid, int *status)\n{\n  int waitResult;\n  int exitStatus;\n  pid_t childPid;\n\n  while (true)\n  {\n    childPid = wait3(status, 0, NULL);\n    if (childPid == pid)\n      break;\n    if (childPid == -1 && errno != EINTR)\n      return reportError(\"wait\", 0);\n  }\n  exitStatus = getExitStatus() - status[9];\n  status[9] = exitStatus;\n  return (int)status;\n}",
        "source_code": "static void resuse_end(pid_t pid, resource_t *resp)\n{\n\tpid_t caught;\n\n\t/* Ignore signals, but don't ignore the children.  When wait3\n\t * returns the child process, set the time the command finished. */\n\twhile ((caught = wait3(&resp->waitstatus, 0, &resp->ru)) != pid) {\n\t\tif (caught == -1 && errno != EINTR) {\n\t\t\tbb_perror_msg(\"wait\");\n\t\t\treturn;\n\t\t}\n\t}\n\tresp->elapsed_ms = monotonic_ms() - resp->elapsed_ms;\n}",
        "parsed_output": "int waitForProcess(int pid, int *status)\n{\n  int waitResult;\n  int exitStatus;\n  pid_t childPid;\n\n  while (true)\n  {\n    childPid = wait3(status, 0, NULL);\n    if (childPid == pid)\n      break;\n    if (childPid == -1 && errno != EINTR)\n      return reportError(\"wait\", 0);\n  }\n  exitStatus = getExitStatus() - status[9];\n  status[9] = exitStatus;\n  return (int)status;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_422B21(int a1, __WAIT_STATUS a2)\n{\n  __int64 result; // rax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  union wait v7; // edx\n  __pid_t v8; // [rsp+1Ch] [rbp-4h]\n\n  while ( 1 )\n  {\n    v8 = wait3(a2, 0, (struct rusage *)&a2.__uptr[2]);\n    if ( v8 == a1 )\n      break;\n    if ( v8 == -1 && *(_DWORD *)qword_75D400 != 4 )\n      return sub_4091D9((__int64)\"wait\", 0LL, v3, v4, v5, v6);\n  }\n  v7.w_status = sub_40BC94() - a2.__uptr[38].w_status;\n  result = (__int64)a2.__uptr;\n  a2.__uptr[38].w_status = v7.w_status;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl resuse_end(pid_t pid, resource_t *resp)\n{\n  __pid_t caught; // [rsp+1Ch] [rbp-4h]\n\n  while ( 1 )\n  {\n    caught = wait3((__WAIT_STATUS)resp, 0, &resp->ru);\n    if ( caught == pid )\n      break;\n    if ( caught == -1 && *bb_errno != 4 )\n    {\n      bb_perror_msg(\"wait\");\n      return;\n    }\n  }\n  resp->elapsed_ms = monotonic_ms() - resp->elapsed_ms;\n}\n",
        "similarity_score_unixcoder": 0.7708542943000793,
        "similarity_score_baseline_stripped": 0.6460787653923035,
        "similarity_score_baseline_debug": 0.883979856967926
    },
    {
        "func_name": "letcmd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BOOL8 __fastcall sub_47EDCB(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 *v7; // [rsp+0h] [rbp-20h]\n  __int64 v8; // [rsp+18h] [rbp-8h]\n\n  v7 = (__int64 *)(a2 + 8);\n  if ( !*(_QWORD *)(a2 + 8) )\n    sub_46E473(\"expression expected\", a2, a3, a4, a5, a6);\n  do\n    v8 = sub_473BC5(*v7++);\n  while ( *v7 );\n  return v8 == 0;\n}\n",
        "output": "bool checkExpressions(long long exprListHead, long long a2, long long a3, long long a4, long long a5, long long a6)\n{\n  long long *currentExpr; // Pointer to the current expression\n  long long lastResult; // Result of the last expression evaluation\n\n  currentExpr = (long long *)(exprListHead + 8);\n  if ( !*currentExpr )\n    reportError(\"expression expected\", exprListHead, a2, a3, a4, a5, a6);\n  do\n    lastResult = evaluateExpression(*currentExpr++);\n  while ( *currentExpr );\n  return lastResult == 0;\n}",
        "source_code": "static int FAST_FUNC\nletcmd(int argc UNUSED_PARAM, char **argv)\n{\n\tarith_t i;\n\n\targv++;\n\tif (!*argv)\n\t\tash_msg_and_raise_error(\"expression expected\");\n\tdo {\n\t\ti = ash_arith(*argv);\n\t} while (*++argv);\n\n\treturn !i;\n}",
        "parsed_output": "bool checkExpressions(long long exprListHead, long long a2, long long a3, long long a4, long long a5, long long a6)\n{\n  long long *currentExpr; // Pointer to the current expression\n  long long lastResult; // Result of the last expression evaluation\n\n  currentExpr = (long long *)(exprListHead + 8);\n  if ( !*currentExpr )\n    reportError(\"expression expected\", exprListHead, a2, a3, a4, a5, a6);\n  do\n    lastResult = evaluateExpression(*currentExpr++);\n  while ( *currentExpr );\n  return lastResult == 0;\n}",
        "baseline_code_stripped": "_BOOL8 __fastcall sub_47EDCB(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 *v7; // [rsp+0h] [rbp-20h]\n  __int64 v8; // [rsp+18h] [rbp-8h]\n\n  v7 = (__int64 *)(a2 + 8);\n  if ( !*(_QWORD *)(a2 + 8) )\n    sub_46E473(\"expression expected\", a2, a3, a4, a5, a6);\n  do\n    v8 = sub_473BC5(*v7++);\n  while ( *v7 );\n  return v8 == 0;\n}\n",
        "baseline_code_debug": "int __cdecl letcmd(int argc, char **argv)\n{\n  char **argva; // [rsp+0h] [rbp-20h]\n  arith_t i; // [rsp+18h] [rbp-8h]\n\n  argva = argv + 1;\n  if ( !argv[1] )\n    ash_msg_and_raise_error(\"expression expected\");\n  do\n    i = ash_arith(*argva++);\n  while ( *argva );\n  return i == 0;\n}\n",
        "similarity_score_unixcoder": 0.6365148425102234,
        "similarity_score_baseline_stripped": 0.502423882484436,
        "similarity_score_baseline_debug": 0.8683790564537048
    },
    {
        "func_name": "new_node",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_DWORD *__fastcall sub_4DD854(int a1, __int64 a2)\n{\n  _DWORD *result; // rax\n\n  result = sub_40A0E8(0x20uLL, a2);\n  *result = a1;\n  result[1] = *((_DWORD *)qword_75D408 - 14);\n  return result;\n}\n",
        "output": "```c\nDWORD *createStructWithValues(int value, __int64 allocatorHint)\n{\n  DWORD *structPtr;\n\n  structPtr = allocateMemory(32uLL, allocatorHint);\n  structPtr[0] = value;\n  structPtr[1] = globalValue;\n  return structPtr;\n}\n```",
        "source_code": "static node *new_node(uint32_t info)\n{\n\tnode *n;\n\n\tn = xzalloc(sizeof(node));\n\tn->info = info;\n\tn->lineno = g_lineno;\n\treturn n;\n}",
        "parsed_output": "DWORD *createStructWithValues(int value, __int64 allocatorHint)\n{\n  DWORD *structPtr;\n\n  structPtr = allocateMemory(32uLL, allocatorHint);\n  structPtr[0] = value;\n  structPtr[1] = globalValue;\n  return structPtr;\n}",
        "baseline_code_stripped": "_DWORD *__fastcall sub_4DD854(int a1, __int64 a2)\n{\n  _DWORD *result; // rax\n\n  result = sub_40A0E8(0x20uLL, a2);\n  *result = a1;\n  result[1] = *((_DWORD *)qword_75D408 - 14);\n  return result;\n}\n",
        "baseline_code_debug": "node_0 *__cdecl new_node(uint32_t info)\n{\n  node_0 *result; // rax\n\n  result = (node_0 *)xzalloc(0x20uLL);\n  result->info = info;\n  result->lineno = *(_DWORD *)&ptr_to_globals[-1].line_buf[76];\n  return result;\n}\n",
        "similarity_score_unixcoder": 0.47674375772476196,
        "similarity_score_baseline_stripped": 0.44061926007270813,
        "similarity_score_baseline_debug": 0.8144229650497437
    },
    {
        "func_name": "store_param",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4F37C9(__int64 a1)\n{\n  __int64 v1; // rsi\n  int v2; // eax\n  _QWORD *v3; // rdx\n  __int64 result; // rax\n\n  if ( !(unsigned __int8)*(_DWORD *)&dest.c_line )\n    *(_QWORD *)&dest.c_iflag = sub_40A09E(*(void **)&dest.c_iflag, 8LL * (*(_DWORD *)&dest.c_line + 256));\n  v1 = *(_QWORD *)&dest.c_iflag;\n  v2 = *(_DWORD *)&dest.c_line;\n  *(_DWORD *)&dest.c_line = v2 + 1;\n  v3 = (_QWORD *)(v1 + 8LL * v2);\n  result = a1;\n  *v3 = a1;\n  return result;\n}\n",
        "output": "```c\n__int64 __fastcall updateBuffer(__int64 data)\n{\n  __int64 bufferAddress;\n  int lineIndex;\n  __int64 *linePointer;\n  __int64 result;\n\n  if (dest.c_line == 0)\n    dest.c_iflag = sub_40A09E(dest.c_iflag, 2048); // 8 * 256 = 2048\n\n  bufferAddress = dest.c_iflag;\n  lineIndex = dest.c_line;\n  dest.c_line = lineIndex + 1;\n  linePointer = (__int64 *)(bufferAddress + 8 * lineIndex);\n  result = data;\n  *linePointer = data;\n\n  return result;\n}\n```",
        "source_code": "static void store_param(char *s)\n{\n\t/* Grow by 256 elements at once */\n\tif (!(G.idx & 0xff)) { /* G.idx == N*256 */\n\t\t/* Enlarge, make G.args[(N+1)*256 - 1] last valid idx */\n\t\tG.args = xrealloc(G.args, sizeof(G.args[0]) * (G.idx + 0x100));\n\t}\n\tG.args[G.idx++] = s;\n}",
        "parsed_output": "__int64 __fastcall updateBuffer(__int64 data)\n{\n  __int64 bufferAddress;\n  int lineIndex;\n  __int64 *linePointer;\n  __int64 result;\n\n  if (dest.c_line == 0)\n    dest.c_iflag = sub_40A09E(dest.c_iflag, 2048); // 8 * 256 = 2048\n\n  bufferAddress = dest.c_iflag;\n  lineIndex = dest.c_line;\n  dest.c_line = lineIndex + 1;\n  linePointer = (__int64 *)(bufferAddress + 8 * lineIndex);\n  result = data;\n  *linePointer = data;\n\n  return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4F37C9(__int64 a1)\n{\n  __int64 v1; // rsi\n  int v2; // eax\n  _QWORD *v3; // rdx\n  __int64 result; // rax\n\n  if ( !(unsigned __int8)*(_DWORD *)&dest.c_line )\n    *(_QWORD *)&dest.c_iflag = sub_40A09E(*(void **)&dest.c_iflag, 8LL * (*(_DWORD *)&dest.c_line + 256));\n  v1 = *(_QWORD *)&dest.c_iflag;\n  v2 = *(_DWORD *)&dest.c_line;\n  *(_DWORD *)&dest.c_line = v2 + 1;\n  v3 = (_QWORD *)(v1 + 8LL * v2);\n  result = a1;\n  *v3 = a1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl store_param(char *s)\n{\n  __int64 v1; // rsi\n  int v2; // eax\n\n  if ( !(unsigned __int8)*(_DWORD *)&bb_common_bufsiz1.c_line )\n    *(_QWORD *)&bb_common_bufsiz1.c_iflag = xrealloc(\n                                              *(void **)&bb_common_bufsiz1.c_iflag,\n                                              8LL * (*(_DWORD *)&bb_common_bufsiz1.c_line + 256));\n  v1 = *(_QWORD *)&bb_common_bufsiz1.c_iflag;\n  v2 = *(_DWORD *)&bb_common_bufsiz1.c_line;\n  *(_DWORD *)&bb_common_bufsiz1.c_line = v2 + 1;\n  *(_QWORD *)(v1 + 8LL * v2) = s;\n}\n",
        "similarity_score_unixcoder": 0.4034024477005005,
        "similarity_score_baseline_stripped": 0.41945359110832214,
        "similarity_score_baseline_debug": 0.5844400525093079
    },
    {
        "func_name": "die_if_ferror",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_40A5F5(FILE *a1, __int64 a2)\n{\n  int result; // eax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n\n  result = ferror(a1);\n  if ( result )\n    sub_40969E(\"%s: I/O error\", a2, v3, v4, v5, v6);\n  return result;\n}\n",
        "output": "```c\nint checkIOErrorAndReport(FILE *file, const char *errorMsg)\n{\n  int ioError = ferror(file);\n  if (ioError)\n    reportError(errorMsg);\n  return ioError;\n}\n```",
        "source_code": "void FAST_FUNC die_if_ferror(FILE *fp, const char *fn)\n{\n\tif (ferror(fp)) {\n\t\t/* ferror doesn't set useful errno */\n\t\tbb_error_msg_and_die(\"%s: I/O error\", fn);\n\t}\n}",
        "parsed_output": "int checkIOErrorAndReport(FILE *file, const char *errorMsg)\n{\n  int ioError = ferror(file);\n  if (ioError)\n    reportError(errorMsg);\n  return ioError;\n}",
        "baseline_code_stripped": "int __fastcall sub_40A5F5(FILE *a1, __int64 a2)\n{\n  int result; // eax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n\n  result = ferror(a1);\n  if ( result )\n    sub_40969E(\"%s: I/O error\", a2, v3, v4, v5, v6);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl die_if_ferror(FILE *fp, const char *fn)\n{\n  if ( ferror(fp) )\n    bb_error_msg_and_die(\"%s: I/O error\", fn);\n}\n",
        "similarity_score_unixcoder": 0.7280721068382263,
        "similarity_score_baseline_stripped": 0.5729091763496399,
        "similarity_score_baseline_debug": 0.9314379096031189
    },
    {
        "func_name": "setarch_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall __noreturn sub_4A4B35(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char **argv; // [rsp+0h] [rbp-20h]\n  const char **argva; // [rsp+0h] [rbp-20h]\n  int v9; // [rsp+1Ch] [rbp-4h]\n\n  argv = (char **)a2;\n  if ( *ident == 115 )\n  {\n    if ( *(_QWORD *)(a2 + 8) )\n    {\n      v2 = *(_QWORD *)(a2 + 8);\n      *(_DWORD *)v2 = 1970170220;\n      *(_BYTE *)(v2 + 4) = 120;\n      if ( v2 )\n      {\n        ident = *(char **)(a2 + 8);\n        argv = (char **)(a2 + 8);\n      }\n    }\n  }\n  if ( ident[5] == 54 )\n  {\n    v9 = 0;\n  }\n  else\n  {\n    if ( ident[5] != 51 )\n      sub_407F64(a1);\n    v9 = 8;\n  }\n  argva = (const char **)(argv + 1);\n  if ( !*argva )\n    sub_407F64(a1);\n  if ( personality(v9) >= 0 )\n  {\n    a2 = (__int64)argva;\n    execvp(*argva, (char *const *)argva);\n  }\n  sub_409392((__int64)*argva, a2, v3, v4, v5, v6);\n}\n",
        "output": "```c\nvoid __fastcall __noreturn customFunction(__int64 arg1, __int64 arg2)\n{\n  __int64 pointerValue; // Temporary variable for pointer operations\n  char **arguments; // Pointer to arguments array\n  int personalityValue; // Value to be used with personality function\n\n  arguments = (char **)arg2;\n  if (*ident == 's') // Check if the first character of ident is 's'\n  {\n    if (*(_QWORD *)(arg2 + 8)) // Check if the second argument pointer is not NULL\n    {\n      pointerValue = *(_QWORD *)(arg2 + 8);\n      *(_DWORD *)pointerValue = 0x758AF4DC; // Set the value at the pointer to 0x758AF4DC\n      *(_BYTE *)(pointerValue + 4) = 'x'; // Set the fifth byte to 'x'\n      if (pointerValue)\n      {\n        ident = *(char **)(arg2 + 8);\n        arguments = (char **)(arg2 + 8);\n      }\n    }\n  }\n  if (ident[5] == '6') // Check if the sixth character of ident is '6'\n  {\n    personalityValue = 0;\n  }\n  else\n  {\n    if (ident[5] != '3') // Check if the sixth character of ident is not '3'\n      sub_407F64(arg1); // Call sub_407F64 with arg1\n    personalityValue = 8;\n  }\n  arguments++; // Move to the next argument\n  if (!*arguments) // Check if the next argument is NULL\n    sub_407F64(arg1); // Call sub_407F64 with arg1\n  if (personality(personalityValue) >= 0) // Check the return value of personality function\n  {\n    arg2 = (__int64)arguments;\n    execvp(*arguments, (char *const *)arguments); // Execute the command with arguments\n  }\n  sub_409392((__int64)*arguments, arg2, pointerValue); // Call sub_409392 with updated arguments\n}\n```",
        "source_code": "int setarch_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint pers;\n\n\t/* Figure out what personality we are supposed to switch to ...\n\t * we can be invoked as either:\n\t * argv[0],argv[1] == \"setarch\",\"personality\"\n\t * argv[0]         == \"personality\"\n\t */\n\tif (ENABLE_SETARCH && applet_name[0] == 's'\n\t && argv[1] && strncpy(argv[1], \"linux\", 5)\n\t) {\n\t\tapplet_name = argv[1];\n\t\targv++;\n\t}\n\tif (applet_name[5] == '6') /* linux64 */\n\t\tpers = PER_LINUX;\n\telse if (applet_name[5] == '3') /* linux32 */\n\t\tpers = PER_LINUX32;\n\telse\n\t\tbb_show_usage();\n\n\targv++;\n\tif (argv[0] == NULL)\n\t\tbb_show_usage();\n\n\t/* Try to set personality */\n\tif (personality(pers) >= 0) {\n\t\t/* Try to execute the program */\n\t\tBB_EXECVP(argv[0], argv);\n\t}\n\n\tbb_simple_perror_msg_and_die(argv[0]);\n}",
        "parsed_output": "void __fastcall __noreturn customFunction(__int64 arg1, __int64 arg2)\n{\n  __int64 pointerValue; // Temporary variable for pointer operations\n  char **arguments; // Pointer to arguments array\n  int personalityValue; // Value to be used with personality function\n\n  arguments = (char **)arg2;\n  if (*ident == 's') // Check if the first character of ident is 's'\n  {\n    if (*(_QWORD *)(arg2 + 8)) // Check if the second argument pointer is not NULL\n    {\n      pointerValue = *(_QWORD *)(arg2 + 8);\n      *(_DWORD *)pointerValue = 0x758AF4DC; // Set the value at the pointer to 0x758AF4DC\n      *(_BYTE *)(pointerValue + 4) = 'x'; // Set the fifth byte to 'x'\n      if (pointerValue)\n      {\n        ident = *(char **)(arg2 + 8);\n        arguments = (char **)(arg2 + 8);\n      }\n    }\n  }\n  if (ident[5] == '6') // Check if the sixth character of ident is '6'\n  {\n    personalityValue = 0;\n  }\n  else\n  {\n    if (ident[5] != '3') // Check if the sixth character of ident is not '3'\n      sub_407F64(arg1); // Call sub_407F64 with arg1\n    personalityValue = 8;\n  }\n  arguments++; // Move to the next argument\n  if (!*arguments) // Check if the next argument is NULL\n    sub_407F64(arg1); // Call sub_407F64 with arg1\n  if (personality(personalityValue) >= 0) // Check the return value of personality function\n  {\n    arg2 = (__int64)arguments;\n    execvp(*arguments, (char *const *)arguments); // Execute the command with arguments\n  }\n  sub_409392((__int64)*arguments, arg2, pointerValue); // Call sub_409392 with updated arguments\n}",
        "baseline_code_stripped": "void __fastcall __noreturn sub_4A4B35(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char **argv; // [rsp+0h] [rbp-20h]\n  const char **argva; // [rsp+0h] [rbp-20h]\n  int v9; // [rsp+1Ch] [rbp-4h]\n\n  argv = (char **)a2;\n  if ( *ident == 115 )\n  {\n    if ( *(_QWORD *)(a2 + 8) )\n    {\n      v2 = *(_QWORD *)(a2 + 8);\n      *(_DWORD *)v2 = 1970170220;\n      *(_BYTE *)(v2 + 4) = 120;\n      if ( v2 )\n      {\n        ident = *(char **)(a2 + 8);\n        argv = (char **)(a2 + 8);\n      }\n    }\n  }\n  if ( ident[5] == 54 )\n  {\n    v9 = 0;\n  }\n  else\n  {\n    if ( ident[5] != 51 )\n      sub_407F64(a1);\n    v9 = 8;\n  }\n  argva = (const char **)(argv + 1);\n  if ( !*argva )\n    sub_407F64(a1);\n  if ( personality(v9) >= 0 )\n  {\n    a2 = (__int64)argva;\n    execvp(*argva, (char *const *)argva);\n  }\n  sub_409392((__int64)*argva, a2, v3, v4, v5, v6);\n}\n",
        "baseline_code_debug": "int __cdecl __noreturn setarch_main(int argc, char **argv)\n{\n  char *v2; // rax\n  char **argva; // [rsp+0h] [rbp-20h]\n  const char **argvb; // [rsp+0h] [rbp-20h]\n  int pers; // [rsp+1Ch] [rbp-4h]\n\n  argva = argv;\n  if ( *applet_name == 115 )\n  {\n    if ( argv[1] )\n    {\n      v2 = argv[1];\n      *(_DWORD *)v2 = 1970170220;\n      v2[4] = 120;\n      if ( v2 )\n      {\n        applet_name = argv[1];\n        argva = argv + 1;\n      }\n    }\n  }\n  if ( applet_name[5] == 54 )\n  {\n    pers = 0;\n  }\n  else\n  {\n    if ( applet_name[5] != 51 )\n      bb_show_usage();\n    pers = 8;\n  }\n  argvb = (const char **)(argva + 1);\n  if ( !*argvb )\n    bb_show_usage();\n  if ( personality(pers) >= 0 )\n    execvp(*argvb, (char *const *)argvb);\n  bb_simple_perror_msg_and_die(*argvb);\n}\n",
        "similarity_score_unixcoder": 0.6964472532272339,
        "similarity_score_baseline_stripped": 0.6175282001495361,
        "similarity_score_baseline_debug": 0.8468164205551147
    },
    {
        "func_name": "sizenodelist",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_QWORD *__fastcall sub_4778AA(_QWORD *a1)\n{\n  _QWORD *result; // rax\n\n  while ( a1 )\n  {\n    dword_75B028 += 16;\n    sub_4778EC(a1[1]);\n    result = (_QWORD *)*a1;\n    a1 = (_QWORD *)*a1;\n  }\n  return result;\n}\n",
        "output": "```c\nvoid updateAndProcessEntries(_QWORD *entry)\n{\n  while (entry)\n  {\n    dword_75B028 += 16;\n    processEntry(entry[1]);\n    entry = (_QWORD *)*entry;\n  }\n}\n```",
        "source_code": "static void\nsizenodelist(struct nodelist *lp)\n{\n\twhile (lp) {\n\t\tfuncblocksize += SHELL_ALIGN(sizeof(struct nodelist));\n\t\tcalcsize(lp->n);\n\t\tlp = lp->next;\n\t}\n}",
        "parsed_output": "void updateAndProcessEntries(_QWORD *entry)\n{\n  while (entry)\n  {\n    dword_75B028 += 16;\n    processEntry(entry[1]);\n    entry = (_QWORD *)*entry;\n  }\n}",
        "baseline_code_stripped": "_QWORD *__fastcall sub_4778AA(_QWORD *a1)\n{\n  _QWORD *result; // rax\n\n  while ( a1 )\n  {\n    dword_75B028 += 16;\n    sub_4778EC(a1[1]);\n    result = (_QWORD *)*a1;\n    a1 = (_QWORD *)*a1;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl sizenodelist(nodelist *lp)\n{\n  while ( lp )\n  {\n    funcblocksize += 16;\n    calcsize(lp->n);\n    lp = lp->next;\n  }\n}\n",
        "similarity_score_unixcoder": 0.47041624784469604,
        "similarity_score_baseline_stripped": 0.44704699516296387,
        "similarity_score_baseline_debug": 0.9018113613128662
    },
    {
        "func_name": "format_address_paren",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_4CE8EF(__int64 a1, char a2)\n{\n  int result; // eax\n\n  putchar_unlocked(40);\n  result = sub_4CE8BB(a1, 41);\n  if ( a2 )\n    return putchar_unlocked(a2);\n  return result;\n}\n",
        "output": "int printWithParenthesesAndOptionalChar(__int64 number, char optionalChar)\n{\n  putchar_unlocked('(');\n  int result = printNumberWithClosingParenthesis(number);\n  if (optionalChar)\n    return putchar_unlocked(optionalChar);\n  return result;\n}",
        "source_code": "static void\nformat_address_paren(off_t address, char c)\n{\n\tputchar('(');\n\tformat_address_std(address, ')');\n\tif (c) putchar(c);\n}",
        "parsed_output": "int printWithParenthesesAndOptionalChar(__int64 number, char optionalChar)\n{\n  putchar_unlocked('(');\n  int result = printNumberWithClosingParenthesis(number);\n  if (optionalChar)\n    return putchar_unlocked(optionalChar);\n  return result;\n}",
        "baseline_code_stripped": "int __fastcall sub_4CE8EF(__int64 a1, char a2)\n{\n  int result; // eax\n\n  putchar_unlocked(40);\n  result = sub_4CE8BB(a1, 41);\n  if ( a2 )\n    return putchar_unlocked(a2);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl format_address_paren(off_t address, char c)\n{\n  putchar_unlocked(40);\n  format_address_std(address, 41);\n  if ( c )\n    putchar_unlocked(c);\n}\n",
        "similarity_score_unixcoder": 0.6671640276908875,
        "similarity_score_baseline_stripped": 0.5183325409889221,
        "similarity_score_baseline_debug": 0.8867987394332886
    },
    {
        "func_name": "ifsfree",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4760DE(__int64 a1, __int64 a2)\n{\n  _QWORD *v2; // rdi\n  _QWORD *v4; // [rsp+0h] [rbp-10h]\n  _QWORD *ptr; // [rsp+8h] [rbp-8h]\n\n  ++*(_DWORD *)(qword_75D418 + 48);\n  ptr = qword_75AFE0;\n  do\n  {\n    v4 = (_QWORD *)*ptr;\n    v2 = ptr;\n    free(ptr);\n    ptr = v4;\n  }\n  while ( v4 );\n  qword_75AFF8 = 0LL;\n  qword_75AFE0 = 0LL;\n  return sub_46E03F(v2, a2);\n}\n",
        "output": "```c\nvoid processLinkedListAndCall(__int64 a1, __int64 a2)\n{\n  _QWORD *currentNode;\n  _QWORD *nextNode;\n\n  ++*(_DWORD *)(globalCounter + 48);\n  currentNode = headNode;\n  while (currentNode)\n  {\n    nextNode = (_QWORD *)*currentNode;\n    free(currentNode);\n    currentNode = nextNode;\n  }\n  tailNode = 0LL;\n  headNode = 0LL;\n  sub_46E03F(currentNode, a2);\n}\n```",
        "source_code": "static void\nifsfree(void)\n{\n\tstruct ifsregion *p;\n\n\tINT_OFF;\n\tp = ifsfirst.next;\n\tdo {\n\t\tstruct ifsregion *ifsp;\n\t\tifsp = p->next;\n\t\tfree(p);\n\t\tp = ifsp;\n\t} while (p);\n\tifslastp = NULL;\n\tifsfirst.next = NULL;\n\tINT_ON;\n}",
        "parsed_output": "void processLinkedListAndCall(__int64 a1, __int64 a2)\n{\n  _QWORD *currentNode;\n  _QWORD *nextNode;\n\n  ++*(_DWORD *)(globalCounter + 48);\n  currentNode = headNode;\n  while (currentNode)\n  {\n    nextNode = (_QWORD *)*currentNode;\n    free(currentNode);\n    currentNode = nextNode;\n  }\n  tailNode = 0LL;\n  headNode = 0LL;\n  sub_46E03F(currentNode, a2);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4760DE(__int64 a1, __int64 a2)\n{\n  _QWORD *v2; // rdi\n  _QWORD *v4; // [rsp+0h] [rbp-10h]\n  _QWORD *ptr; // [rsp+8h] [rbp-8h]\n\n  ++*(_DWORD *)(qword_75D418 + 48);\n  ptr = qword_75AFE0;\n  do\n  {\n    v4 = (_QWORD *)*ptr;\n    v2 = ptr;\n    free(ptr);\n    ptr = v4;\n  }\n  while ( v4 );\n  qword_75AFF8 = 0LL;\n  qword_75AFE0 = 0LL;\n  return sub_46E03F(v2, a2);\n}\n",
        "baseline_code_debug": "void __cdecl ifsfree()\n{\n  ifsregion *ifsp; // [rsp+0h] [rbp-10h]\n  ifsregion *p; // [rsp+8h] [rbp-8h]\n\n  ++ash_ptr_to_globals_misc->suppress_int;\n  p = ifsfirst.next;\n  do\n  {\n    ifsp = p->next;\n    free(p);\n    p = ifsp;\n  }\n  while ( ifsp );\n  ifslastp = 0LL;\n  ifsfirst.next = 0LL;\n  int_on();\n}\n",
        "similarity_score_unixcoder": 0.48733389377593994,
        "similarity_score_baseline_stripped": 0.46128737926483154,
        "similarity_score_baseline_debug": 0.7786923050880432
    },
    {
        "func_name": "dec_stream_footer",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4BF718(__int64 a1)\n{\n  if ( memcmp((const void *)(a1 + 194), &unk_526CB7, 2uLL) )\n    return 7LL;\n  if ( *(_DWORD *)(a1 + 184) != (unsigned int)sub_4BBFB7(a1 + 188, 6u, 0) )\n    return 7LL;\n  if ( *(_QWORD *)(a1 + 128) >> 2 != *(_DWORD *)(a1 + 188) )\n    return 7LL;\n  if ( !*(_BYTE *)(a1 + 192) && *(unsigned __int8 *)(a1 + 193) == *(_DWORD *)(a1 + 36) )\n    return 1LL;\n  return 7LL;\n}\n",
        "output": "```c\nbool check_conditions(long ptr)\n{\n  const char expected_bytes[] = {0xB7, 0x26}; // Assuming unk_526CB7 is {0xB7, 0x26}\n  \n  // Check if two bytes at ptr+194 match expected_bytes\n  if (memcmp((const void *)(ptr + 194), expected_bytes, 2) != 0)\n    return false;\n  \n  // Check if value at ptr+184 matches the result of sub_4BBFB7 with given parameters\n  if (*(int *)(ptr + 184) != sub_4BBFB7(ptr + 188, 6, 0))\n    return false;\n  \n  // Check if the upper 62 bits of the value at ptr+128 match the value at ptr+188\n  if (*(long *)(ptr + 128) >> 2 != *(int *)(ptr + 188))\n    return false;\n  \n  // Check if the byte at ptr+192 is 0 and the byte at ptr+193 matches the value at ptr+36\n  if (*(char *)(ptr + 192) == 0 && *(unsigned char *)(ptr + 193) == *(int *)(ptr + 36))\n    return true;\n  \n  return false;\n}\n```",
        "source_code": "static enum xz_ret XZ_FUNC dec_stream_footer(struct xz_dec *s)\n{\n\tif (!memeq(s->temp.buf + 10, FOOTER_MAGIC, FOOTER_MAGIC_SIZE))\n\t\treturn XZ_DATA_ERROR;\n\n\tif (xz_crc32(s->temp.buf + 4, 6, 0) != get_le32(s->temp.buf))\n\t\treturn XZ_DATA_ERROR;\n\n\t/*\n\t * Validate Backward Size. Note that we never added the size of the\n\t * Index CRC32 field to s->index.size, thus we use s->index.size / 4\n\t * instead of s->index.size / 4 - 1.\n\t */\n\tif ((s->index.size >> 2) != get_le32(s->temp.buf + 4))\n\t\treturn XZ_DATA_ERROR;\n\n\tif (s->temp.buf[8] != 0 || s->temp.buf[9] != s->check_type)\n\t\treturn XZ_DATA_ERROR;\n\n\t/*\n\t * Use XZ_STREAM_END instead of XZ_OK to be more convenient\n\t * for the caller.\n\t */\n\treturn XZ_STREAM_END;\n}",
        "parsed_output": "bool check_conditions(long ptr)\n{\n  const char expected_bytes[] = {0xB7, 0x26}; // Assuming unk_526CB7 is {0xB7, 0x26}\n  \n  // Check if two bytes at ptr+194 match expected_bytes\n  if (memcmp((const void *)(ptr + 194), expected_bytes, 2) != 0)\n    return false;\n  \n  // Check if value at ptr+184 matches the result of sub_4BBFB7 with given parameters\n  if (*(int *)(ptr + 184) != sub_4BBFB7(ptr + 188, 6, 0))\n    return false;\n  \n  // Check if the upper 62 bits of the value at ptr+128 match the value at ptr+188\n  if (*(long *)(ptr + 128) >> 2 != *(int *)(ptr + 188))\n    return false;\n  \n  // Check if the byte at ptr+192 is 0 and the byte at ptr+193 matches the value at ptr+36\n  if (*(char *)(ptr + 192) == 0 && *(unsigned char *)(ptr + 193) == *(int *)(ptr + 36))\n    return true;\n  \n  return false;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4BF718(__int64 a1)\n{\n  if ( memcmp((const void *)(a1 + 194), &unk_526CB7, 2uLL) )\n    return 7LL;\n  if ( *(_DWORD *)(a1 + 184) != (unsigned int)sub_4BBFB7(a1 + 188, 6u, 0) )\n    return 7LL;\n  if ( *(_QWORD *)(a1 + 128) >> 2 != *(_DWORD *)(a1 + 188) )\n    return 7LL;\n  if ( !*(_BYTE *)(a1 + 192) && *(unsigned __int8 *)(a1 + 193) == *(_DWORD *)(a1 + 36) )\n    return 1LL;\n  return 7LL;\n}\n",
        "baseline_code_debug": "xz_ret __cdecl dec_stream_footer(xz_dec *s)\n{\n  if ( memcmp(&s->temp.buf[10], &unk_526CB7, 2uLL) )\n    return 7;\n  if ( *(_DWORD *)s->temp.buf != xz_crc32(&s->temp.buf[4], 6uLL, 0) )\n    return 7;\n  if ( s->index.size >> 2 != *(_DWORD *)&s->temp.buf[4] )\n    return 7;\n  if ( !s->temp.buf[8] && s->temp.buf[9] == s->check_type )\n    return 1;\n  return 7;\n}\n",
        "similarity_score_unixcoder": 0.5714061260223389,
        "similarity_score_baseline_stripped": 0.5678178668022156,
        "similarity_score_baseline_debug": 0.8711869716644287
    },
    {
        "func_name": "nameif_parse_selector",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_438B5F(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 result; // rax\n  _BYTE *v7; // rax\n  __int64 v8; // rdx\n  char *s1a; // [rsp+0h] [rbp-30h]\n  struct ether_addr *addr; // [rsp+18h] [rbp-18h]\n  _BYTE *v12; // [rsp+20h] [rbp-10h]\n  int v13; // [rsp+2Ch] [rbp-4h]\n\n  v13 = 0;\n  while ( 1 )\n  {\n    result = (unsigned __int8)*a2;\n    if ( !(_BYTE)result )\n      break;\n    s1a = sub_4093B4(a2);\n    *(_DWORD *)(a1 + 48) = -1;\n    result = (unsigned __int8)*s1a;\n    if ( !(_BYTE)result )\n      break;\n    v12 = sub_4093E2(s1a);\n    if ( *v12 )\n    {\n      v7 = v12++;\n      *v7 = 0;\n    }\n    if ( !strncmp(s1a, \"bus=\", 4uLL) )\n    {\n      a3 = (__int64)sub_40A11F(s1a + 4, (__int64)\"bus=\");\n      *(_QWORD *)(a1 + 32) = a3;\n      ++v13;\n    }\n    else if ( !strncmp(s1a, \"driver=\", 7uLL) )\n    {\n      a3 = (__int64)sub_40A11F(s1a + 7, (__int64)\"driver=\");\n      *(_QWORD *)(a1 + 40) = a3;\n      ++v13;\n    }\n    else if ( !strncmp(s1a, \"phyaddr=\", 8uLL) )\n    {\n      a3 = (unsigned int)sub_50B306(s1a + 8);\n      *(_DWORD *)(a1 + 48) = a3;\n      ++v13;\n    }\n    else\n    {\n      addr = (struct ether_addr *)sub_40A05F(6uLL, (__int64)\"phyaddr=\");\n      if ( !strncmp(s1a, \"mac=\", 4uLL) )\n        v8 = 4LL;\n      else\n        v8 = 0LL;\n      a3 = (__int64)ether_aton_r(&s1a[v8], addr);\n      *(_QWORD *)(a1 + 24) = a3;\n      if ( !*(_QWORD *)(a1 + 24) )\n        sub_40969E(\"can't parse %s\", (__int64)s1a, a3, a4, a5, a6);\n      ++v13;\n    }\n    a2 = v12;\n  }\n  if ( !v13 )\n    sub_40969E(\"no selectors found for %s\", *(_QWORD *)(a1 + 16), a3, a4, a5, a6);\n  return result;\n}\n",
        "output": "```c\n__int64 __fastcall parseSelectors(__int64 context, _BYTE *input, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 result;\n  _BYTE *nextToken;\n  char *token;\n  struct ether_addr *macAddress;\n  _BYTE *currentPosition;\n  int selectorsCount;\n\n  selectorsCount = 0;\n  while (1)\n  {\n    result = (unsigned __int8)*input;\n    if (!(_BYTE)result)\n      break;\n    token = getToken(input);\n    *(_DWORD *)(context + 48) = -1;\n    result = (unsigned __int8)*token;\n    if (!(_BYTE)result)\n      break;\n    currentPosition = getNextPosition(token);\n    if (*currentPosition)\n    {\n      nextToken = currentPosition++;\n      *nextToken = 0;\n    }\n    if (!strncmp(token, \"bus=\", 4uLL))\n    {\n      a3 = (__int64)parseBus(token + 4);\n      *(_QWORD *)(context + 32) = a3;\n      ++selectorsCount;\n    }\n    else if (!strncmp(token, \"driver=\", 7uLL))\n    {\n      a3 = (__int64)parseDriver(token + 7);\n      *(_QWORD *)(context + 40) = a3;\n      ++selectorsCount;\n    }\n    else if (!strncmp(token, \"phyaddr=\", 8uLL))\n    {\n      a3 = (unsigned int)parsePhyAddr(token + 8);\n      *(_DWORD *)(context + 48) = a3;\n      ++selectorsCount;\n    }\n    else\n    {\n      macAddress = (struct ether_addr *)allocateEtherAddr(6uLL);\n      if (!strncmp(token, \"mac=\", 4uLL))\n        currentPosition = token + 4;\n      else\n        currentPosition = token;\n      a3 = (__int64)parseMacAddress(currentPosition, macAddress);\n      *(_QWORD *)(context + 24) = a3;\n      if (!*(_QWORD *)(context + 24))\n        reportError(\"can't parse %s\", token);\n      ++selectorsCount;\n    }\n    input = currentPosition;\n  }\n  if (!selectorsCount)\n    reportError(\"no selectors found for %s\", *(_QWORD *)(context + 16));\n  return result;\n}\n```",
        "source_code": "endif\n\n\nstatic void nameif_parse_selector(ethtable_t *ch, char *selector)\n{\n\tstruct ether_addr *lmac;\n#if ENABLE_FEATURE_NAMEIF_EXTENDED\n\tint found_selector = 0;\n\n\twhile (*selector) {\n\t\tchar *next;\n#endif\n\t\tselector = skip_whitespace(selector);\n#if ENABLE_FEATURE_NAMEIF_EXTENDED\n\t\tch->phy_address = -1;\n\t\tif (*selector == '\\0')\n\t\t\tbreak;\n\t\t/* Search for the end .... */\n\t\tnext = skip_non_whitespace(selector);\n\t\tif (*next)\n\t\t\t*next++ = '\\0';\n\t\t/* Check for selectors, mac= is assumed */\n\t\tif (strncmp(selector, \"bus=\", 4) == 0) {\n\t\t\tch->bus_info = xstrdup(selector + 4);\n\t\t\tfound_selector++;\n\t\t} else if (strncmp(selector, \"driver=\", 7) == 0) {\n\t\t\tch->driver = xstrdup(selector + 7);\n\t\t\tfound_selector++;\n\t\t} else if (strncmp(selector, \"phyaddr=\", 8) == 0) {\n\t\t\tch->phy_address = xatoi_positive(selector + 8);\n\t\t\tfound_selector++;\n\t\t} else {\n#endif\n\t\t\tlmac = xmalloc(ETH_ALEN);\n\t\t\tch->mac = ether_aton_r(selector + (strncmp(selector, \"mac=\", 4) != 0 ? 0 : 4), lmac);\n\t\t\tif (ch->mac == NULL)\n\t\t\t\tbb_error_msg_and_die(\"can't parse %s\", selector);\n#if  ENABLE_FEATURE_NAMEIF_EXTENDED\n\t\t\tfound_selector++;\n\t\t};\n\t\tselector = next;\n\t}\n\tif (found_selector == 0)\n\t\tbb_error_msg_and_die(\"no selectors found for %s\", ch->ifname);\n#endif\n}",
        "parsed_output": "__int64 __fastcall parseSelectors(__int64 context, _BYTE *input, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 result;\n  _BYTE *nextToken;\n  char *token;\n  struct ether_addr *macAddress;\n  _BYTE *currentPosition;\n  int selectorsCount;\n\n  selectorsCount = 0;\n  while (1)\n  {\n    result = (unsigned __int8)*input;\n    if (!(_BYTE)result)\n      break;\n    token = getToken(input);\n    *(_DWORD *)(context + 48) = -1;\n    result = (unsigned __int8)*token;\n    if (!(_BYTE)result)\n      break;\n    currentPosition = getNextPosition(token);\n    if (*currentPosition)\n    {\n      nextToken = currentPosition++;\n      *nextToken = 0;\n    }\n    if (!strncmp(token, \"bus=\", 4uLL))\n    {\n      a3 = (__int64)parseBus(token + 4);\n      *(_QWORD *)(context + 32) = a3;\n      ++selectorsCount;\n    }\n    else if (!strncmp(token, \"driver=\", 7uLL))\n    {\n      a3 = (__int64)parseDriver(token + 7);\n      *(_QWORD *)(context + 40) = a3;\n      ++selectorsCount;\n    }\n    else if (!strncmp(token, \"phyaddr=\", 8uLL))\n    {\n      a3 = (unsigned int)parsePhyAddr(token + 8);\n      *(_DWORD *)(context + 48) = a3;\n      ++selectorsCount;\n    }\n    else\n    {\n      macAddress = (struct ether_addr *)allocateEtherAddr(6uLL);\n      if (!strncmp(token, \"mac=\", 4uLL))\n        currentPosition = token + 4;\n      else\n        currentPosition = token;\n      a3 = (__int64)parseMacAddress(currentPosition, macAddress);\n      *(_QWORD *)(context + 24) = a3;\n      if (!*(_QWORD *)(context + 24))\n        reportError(\"can't parse %s\", token);\n      ++selectorsCount;\n    }\n    input = currentPosition;\n  }\n  if (!selectorsCount)\n    reportError(\"no selectors found for %s\", *(_QWORD *)(context + 16));\n  return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_438B5F(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 result; // rax\n  _BYTE *v7; // rax\n  __int64 v8; // rdx\n  char *s1a; // [rsp+0h] [rbp-30h]\n  struct ether_addr *addr; // [rsp+18h] [rbp-18h]\n  _BYTE *v12; // [rsp+20h] [rbp-10h]\n  int v13; // [rsp+2Ch] [rbp-4h]\n\n  v13 = 0;\n  while ( 1 )\n  {\n    result = (unsigned __int8)*a2;\n    if ( !(_BYTE)result )\n      break;\n    s1a = sub_4093B4(a2);\n    *(_DWORD *)(a1 + 48) = -1;\n    result = (unsigned __int8)*s1a;\n    if ( !(_BYTE)result )\n      break;\n    v12 = sub_4093E2(s1a);\n    if ( *v12 )\n    {\n      v7 = v12++;\n      *v7 = 0;\n    }\n    if ( !strncmp(s1a, \"bus=\", 4uLL) )\n    {\n      a3 = (__int64)sub_40A11F(s1a + 4, (__int64)\"bus=\");\n      *(_QWORD *)(a1 + 32) = a3;\n      ++v13;\n    }\n    else if ( !strncmp(s1a, \"driver=\", 7uLL) )\n    {\n      a3 = (__int64)sub_40A11F(s1a + 7, (__int64)\"driver=\");\n      *(_QWORD *)(a1 + 40) = a3;\n      ++v13;\n    }\n    else if ( !strncmp(s1a, \"phyaddr=\", 8uLL) )\n    {\n      a3 = (unsigned int)sub_50B306(s1a + 8);\n      *(_DWORD *)(a1 + 48) = a3;\n      ++v13;\n    }\n    else\n    {\n      addr = (struct ether_addr *)sub_40A05F(6uLL, (__int64)\"phyaddr=\");\n      if ( !strncmp(s1a, \"mac=\", 4uLL) )\n        v8 = 4LL;\n      else\n        v8 = 0LL;\n      a3 = (__int64)ether_aton_r(&s1a[v8], addr);\n      *(_QWORD *)(a1 + 24) = a3;\n      if ( !*(_QWORD *)(a1 + 24) )\n        sub_40969E(\"can't parse %s\", (__int64)s1a, a3, a4, a5, a6);\n      ++v13;\n    }\n    a2 = v12;\n  }\n  if ( !v13 )\n    sub_40969E(\"no selectors found for %s\", *(_QWORD *)(a1 + 16), a3, a4, a5, a6);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl nameif_parse_selector(ethtable_t *ch_0, char *selector)\n{\n  char *v2; // rax\n  __int64 v3; // rdx\n  char *selectorb; // [rsp+0h] [rbp-30h]\n  struct ether_addr *lmac; // [rsp+18h] [rbp-18h]\n  char *next; // [rsp+20h] [rbp-10h]\n  int found_selector; // [rsp+2Ch] [rbp-4h]\n\n  found_selector = 0;\n  while ( *selector )\n  {\n    selectorb = skip_whitespace(selector);\n    ch_0->phy_address = -1;\n    if ( !*selectorb )\n      break;\n    next = skip_non_whitespace(selectorb);\n    if ( *next )\n    {\n      v2 = next++;\n      *v2 = 0;\n    }\n    if ( !strncmp(selectorb, \"bus=\", 4uLL) )\n    {\n      ch_0->bus_info = xstrdup(selectorb + 4);\n      ++found_selector;\n    }\n    else if ( !strncmp(selectorb, \"driver=\", 7uLL) )\n    {\n      ch_0->driver = xstrdup(selectorb + 7);\n      ++found_selector;\n    }\n    else if ( !strncmp(selectorb, \"phyaddr=\", 8uLL) )\n    {\n      ch_0->phy_address = xatoi_positive(selectorb + 8);\n      ++found_selector;\n    }\n    else\n    {\n      lmac = (struct ether_addr *)xmalloc(6uLL);\n      if ( !strncmp(selectorb, \"mac=\", 4uLL) )\n        v3 = 4LL;\n      else\n        v3 = 0LL;\n      ch_0->mac = ether_aton_r(&selectorb[v3], lmac);\n      if ( !ch_0->mac )\n        bb_error_msg_and_die(\"can't parse %s\", selectorb);\n      ++found_selector;\n    }\n    selector = next;\n  }\n  if ( !found_selector )\n    bb_error_msg_and_die(\"no selectors found for %s\", ch_0->ifname);\n}\n",
        "similarity_score_unixcoder": 0.7243116497993469,
        "similarity_score_baseline_stripped": 0.6412285566329956,
        "similarity_score_baseline_debug": 0.8882086873054504
    },
    {
        "func_name": "evalstring",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_47DE2C(const char *a1, __int64 a2)\n{\n  _QWORD *v2; // rdi\n  int v4; // [rsp+4h] [rbp-3Ch]\n  _QWORD v5[4]; // [rsp+10h] [rbp-30h] BYREF\n  char *v6; // [rsp+30h] [rbp-10h]\n  unsigned int v7; // [rsp+3Ch] [rbp-4h]\n\n  v4 = a2;\n  sub_47A810(a1, a2);\n  sub_46E8A1(v5);\n  v7 = 0;\n  do\n  {\n    v2 = 0LL;\n    v6 = (char *)sub_47DC41(0);\n    if ( v6 == (char *)-1LL )\n      break;\n    a2 = 0LL;\n    sub_4781FB(v6, 0);\n    v2 = v5;\n    sub_46E905(v5, 0LL);\n    v7 = byte_75B040;\n  }\n  while ( !byte_75B040 );\n  sub_47A5E5((__int64)v2, a2);\n  v7 &= v4;\n  byte_75B040 = v7;\n  return v7;\n}\n",
        "output": "```c\n__int64 __fastcall processInput(const char *input, __int64 flag)\n{\n  _QWORD *buffer; // rdi\n  int originalFlag; // [rsp+4h] [rbp-3Ch]\n  _QWORD tempBuffer[4]; // [rsp+10h] [rbp-30h] BYREF\n  char *data; // [rsp+30h] [rbp-10h]\n  unsigned int status; // [rsp+3Ch] [rbp-4h]\n\n  originalFlag = flag;\n  initializeWithInput(input, flag);\n  prepareTempBuffer(tempBuffer);\n  status = 0;\n  do\n  {\n    buffer = NULL;\n    data = (char *)fetchData(0);\n    if ( data == (char *)-1LL )\n      break;\n    flag = 0LL;\n    processFetchedData(data, 0);\n    buffer = tempBuffer;\n    updateBuffer(tempBuffer, 0LL);\n    status = globalStatusFlag;\n  }\n  while ( !globalStatusFlag );\n  finalizeBuffer((__int64)buffer, flag);\n  status &= originalFlag;\n  globalStatusFlag = status;\n  return status;\n}\n```",
        "source_code": "static int\nevalstring(char *s, int mask)\n{\n\tunion node *n;\n\tstruct stackmark smark;\n\tint skip;\n\n\tsetinputstring(s);\n\tsetstackmark(&smark);\n\n\tskip = 0;\n\twhile ((n = parsecmd(0)) != NODE_EOF) {\n\t\tevaltree(n, 0);\n\t\tpopstackmark(&smark);\n\t\tskip = evalskip;\n\t\tif (skip)\n\t\t\tbreak;\n\t}\n\tpopfile();\n\n\tskip &= mask;\n\tevalskip = skip;\n\treturn skip;\n}",
        "parsed_output": "__int64 __fastcall processInput(const char *input, __int64 flag)\n{\n  _QWORD *buffer; // rdi\n  int originalFlag; // [rsp+4h] [rbp-3Ch]\n  _QWORD tempBuffer[4]; // [rsp+10h] [rbp-30h] BYREF\n  char *data; // [rsp+30h] [rbp-10h]\n  unsigned int status; // [rsp+3Ch] [rbp-4h]\n\n  originalFlag = flag;\n  initializeWithInput(input, flag);\n  prepareTempBuffer(tempBuffer);\n  status = 0;\n  do\n  {\n    buffer = NULL;\n    data = (char *)fetchData(0);\n    if ( data == (char *)-1LL )\n      break;\n    flag = 0LL;\n    processFetchedData(data, 0);\n    buffer = tempBuffer;\n    updateBuffer(tempBuffer, 0LL);\n    status = globalStatusFlag;\n  }\n  while ( !globalStatusFlag );\n  finalizeBuffer((__int64)buffer, flag);\n  status &= originalFlag;\n  globalStatusFlag = status;\n  return status;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_47DE2C(const char *a1, __int64 a2)\n{\n  _QWORD *v2; // rdi\n  int v4; // [rsp+4h] [rbp-3Ch]\n  _QWORD v5[4]; // [rsp+10h] [rbp-30h] BYREF\n  char *v6; // [rsp+30h] [rbp-10h]\n  unsigned int v7; // [rsp+3Ch] [rbp-4h]\n\n  v4 = a2;\n  sub_47A810(a1, a2);\n  sub_46E8A1(v5);\n  v7 = 0;\n  do\n  {\n    v2 = 0LL;\n    v6 = (char *)sub_47DC41(0);\n    if ( v6 == (char *)-1LL )\n      break;\n    a2 = 0LL;\n    sub_4781FB(v6, 0);\n    v2 = v5;\n    sub_46E905(v5, 0LL);\n    v7 = byte_75B040;\n  }\n  while ( !byte_75B040 );\n  sub_47A5E5((__int64)v2, a2);\n  v7 &= v4;\n  byte_75B040 = v7;\n  return v7;\n}\n",
        "baseline_code_debug": "int __cdecl evalstring(char *s, int mask)\n{\n  stackmark smark; // [rsp+10h] [rbp-30h] BYREF\n  node *n; // [rsp+30h] [rbp-10h]\n  int skip; // [rsp+3Ch] [rbp-4h]\n\n  setinputstring(s);\n  setstackmark(&smark);\n  skip = 0;\n  do\n  {\n    n = parsecmd(0);\n    if ( n == (node *)-1LL )\n      break;\n    evaltree(n, 0);\n    popstackmark(&smark);\n    skip = evalskip[0];\n  }\n  while ( !evalskip[0] );\n  popfile();\n  skip &= mask;\n  evalskip[0] = skip;\n  return skip;\n}\n",
        "similarity_score_unixcoder": 0.52516108751297,
        "similarity_score_baseline_stripped": 0.46321845054626465,
        "similarity_score_baseline_debug": 0.9173325300216675
    },
    {
        "func_name": "examine_file",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_41E48A(__int64 a1, __int64 a2)\n{\n  void *v2; // rdi\n  _DWORD *v3; // rax\n  _BYTE *ptr; // [rsp+8h] [rbp-8h]\n\n  sub_41CB0F(\"Examine: \");\n  ptr = sub_41E385(9, a2);\n  if ( !*ptr )\n  {\n    sub_41D604();\nLABEL_3:\n    free(ptr);\n    return;\n  }\n  if ( access(ptr, 4) )\n  {\n    sub_41CB0F(\"Cannot read this file\");\n    goto LABEL_3;\n  }\n  v2 = (void *)*((_QWORD *)qword_75D408 + 13);\n  free(v2);\n  *((_QWORD *)qword_75D408 + 13) = ptr;\n  **((_QWORD **)qword_75D408 + 14) = *((_QWORD *)qword_75D408 + 13);\n  v3 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 25) = 1;\n  *((_DWORD *)qword_75D408 + 24) = v3[25];\n  sub_41E057(v2, 4uLL);\n}\n",
        "output": "```c\nvoid examineFileAndUpdateStatus(__int64 statusArrayPtr, __int64 a2) {\n  char *fileContent;\n  char *filePath;\n  \n  printMessage(\"Examine: \");\n  filePath = allocateAndReadFile(9, a2);\n  \n  if (!*filePath) {\n    handleEmptyFile();\n    free(filePath);\n    return;\n  }\n  \n  if (access(filePath, R_OK)) {\n    printMessage(\"Cannot read this file\");\n    free(filePath);\n    return;\n  }\n  \n  fileContent = (char *)*(statusArrayPtr + 104); // Assuming 8 bytes per pointer\n  free(fileContent);\n  \n  *(statusArrayPtr + 104) = filePath;\n  **(statusArrayPtr + 112) = filePath;\n  \n  *(statusArrayPtr + 100) = 1;\n  *(statusArrayPtr + 96) = *(statusArrayPtr + 100);\n  \n  updateFileStatus(fileContent, 4);\n}\n```",
        "source_code": "static void examine_file(void)\n{\n\tchar *new_fname;\n\n\tprint_statusline(\"Examine: \");\n\tnew_fname = less_gets(sizeof(\"Examine: \") - 1);\n\tif (!new_fname[0]) {\n\t\tstatus_print();\n err:\n\t\tfree(new_fname);\n\t\treturn;\n\t}\n\tif (access(new_fname, R_OK) != 0) {\n\t\tprint_statusline(\"Cannot read this file\");\n\t\tgoto err;\n\t}\n\tfree(filename);\n\tfilename = new_fname;\n\t/* files start by = argv. why we assume that argv is infinitely long??\n\tfiles[num_files] = filename;\n\tcurrent_file = num_files + 1;\n\tnum_files++; */\n\tfiles[0] = filename;\n\tnum_files = current_file = 1;\n\treinitialize();\n}",
        "parsed_output": "void examineFileAndUpdateStatus(__int64 statusArrayPtr, __int64 a2) {\n  char *fileContent;\n  char *filePath;\n  \n  printMessage(\"Examine: \");\n  filePath = allocateAndReadFile(9, a2);\n  \n  if (!*filePath) {\n    handleEmptyFile();\n    free(filePath);\n    return;\n  }\n  \n  if (access(filePath, R_OK)) {\n    printMessage(\"Cannot read this file\");\n    free(filePath);\n    return;\n  }\n  \n  fileContent = (char *)*(statusArrayPtr + 104); // Assuming 8 bytes per pointer\n  free(fileContent);\n  \n  *(statusArrayPtr + 104) = filePath;\n  **(statusArrayPtr + 112) = filePath;\n  \n  *(statusArrayPtr + 100) = 1;\n  *(statusArrayPtr + 96) = *(statusArrayPtr + 100);\n  \n  updateFileStatus(fileContent, 4);\n}",
        "baseline_code_stripped": "void __fastcall sub_41E48A(__int64 a1, __int64 a2)\n{\n  void *v2; // rdi\n  _DWORD *v3; // rax\n  _BYTE *ptr; // [rsp+8h] [rbp-8h]\n\n  sub_41CB0F(\"Examine: \");\n  ptr = sub_41E385(9, a2);\n  if ( !*ptr )\n  {\n    sub_41D604();\nLABEL_3:\n    free(ptr);\n    return;\n  }\n  if ( access(ptr, 4) )\n  {\n    sub_41CB0F(\"Cannot read this file\");\n    goto LABEL_3;\n  }\n  v2 = (void *)*((_QWORD *)qword_75D408 + 13);\n  free(v2);\n  *((_QWORD *)qword_75D408 + 13) = ptr;\n  **((_QWORD **)qword_75D408 + 14) = *((_QWORD *)qword_75D408 + 13);\n  v3 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 25) = 1;\n  *((_DWORD *)qword_75D408 + 24) = v3[25];\n  sub_41E057(v2, 4uLL);\n}\n",
        "baseline_code_debug": "void __cdecl examine_file()\n{\n  globals *v0; // rax\n  char *new_fname; // [rsp+8h] [rbp-8h]\n\n  print_statusline(\"Examine: \");\n  new_fname = less_gets(9);\n  if ( !*new_fname )\n  {\n    status_print();\nerr:\n    free(new_fname);\n    return;\n  }\n  if ( access(new_fname, 4) )\n  {\n    print_statusline(\"Cannot read this file\");\n    goto err;\n  }\n  free(*(void **)&ptr_to_globals->tty_attrs.c_cflag);\n  *(_QWORD *)&ptr_to_globals->tty_attrs.c_cflag = new_fname;\n  **(_QWORD **)&ptr_to_globals->tty_attrs.c_line = *(_QWORD *)&ptr_to_globals->tty_attrs.c_cflag;\n  v0 = ptr_to_globals;\n  ptr_to_globals->tty_attrs.c_oflag = 1;\n  ptr_to_globals->tty_attrs.c_iflag = v0->tty_attrs.c_oflag;\n  reinitialize();\n}\n",
        "similarity_score_unixcoder": 0.7165626883506775,
        "similarity_score_baseline_stripped": 0.5883354544639587,
        "similarity_score_baseline_debug": 0.7375499606132507
    },
    {
        "func_name": "safe_poll",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_507F47(struct pollfd *a1, nfds_t a2, int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v9; // [rsp+2Ch] [rbp-4h]\n\n  do\n  {\n    v9 = poll(a1, a2, a3);\n    if ( v9 >= 0 )\n      return (unsigned int)v9;\n    if ( a3 > 0 )\n      --a3;\n  }\n  while ( *(_DWORD *)qword_75D400 == 4 || *(_DWORD *)qword_75D400 == 12 );\n  sub_4091D9((__int64)\"poll\", a2, v3, v4, v5, v6);\n  return (unsigned int)v9;\n}\n",
        "output": "int RetryPoll(struct pollfd *fds, nfds_t nfds, int timeout)\n{\n  int pollResult;\n\n  do\n  {\n    pollResult = poll(fds, nfds, timeout);\n    if (pollResult >= 0)\n      return pollResult;\n    if (timeout > 0)\n      --timeout;\n  }\n  while (*(_DWORD *)GLOBAL_ERROR_STATE == EINTR || *(_DWORD *)GLOBAL_ERROR_STATE == EAGAIN);\n\n  LogError(\"poll\", nfds);\n  return pollResult;\n}",
        "source_code": "int FAST_FUNC safe_poll(struct pollfd *ufds, nfds_t nfds, int timeout)\n{\n\twhile (1) {\n\t\tint n = poll(ufds, nfds, timeout);\n\t\tif (n >= 0)\n\t\t\treturn n;\n\t\t/* Make sure we inch towards completion */\n\t\tif (timeout > 0)\n\t\t\ttimeout--;\n\t\t/* E.g. strace causes poll to return this */\n\t\tif (errno == EINTR)\n\t\t\tcontinue;\n\t\t/* Kernel is very low on memory. Retry. */\n\t\t/* I doubt many callers would handle this correctly! */\n\t\tif (errno == ENOMEM)\n\t\t\tcontinue;\n\t\tbb_perror_msg(\"poll\");\n\t\treturn n;\n\t}\n}",
        "parsed_output": "int RetryPoll(struct pollfd *fds, nfds_t nfds, int timeout)\n{\n  int pollResult;\n\n  do\n  {\n    pollResult = poll(fds, nfds, timeout);\n    if (pollResult >= 0)\n      return pollResult;\n    if (timeout > 0)\n      --timeout;\n  }\n  while (*(_DWORD *)GLOBAL_ERROR_STATE == EINTR || *(_DWORD *)GLOBAL_ERROR_STATE == EAGAIN);\n\n  LogError(\"poll\", nfds);\n  return pollResult;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_507F47(struct pollfd *a1, nfds_t a2, int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v9; // [rsp+2Ch] [rbp-4h]\n\n  do\n  {\n    v9 = poll(a1, a2, a3);\n    if ( v9 >= 0 )\n      return (unsigned int)v9;\n    if ( a3 > 0 )\n      --a3;\n  }\n  while ( *(_DWORD *)qword_75D400 == 4 || *(_DWORD *)qword_75D400 == 12 );\n  sub_4091D9((__int64)\"poll\", a2, v3, v4, v5, v6);\n  return (unsigned int)v9;\n}\n",
        "baseline_code_debug": "int __cdecl safe_poll(pollfd *ufds, nfds_t nfds, int timeout)\n{\n  int n; // [rsp+2Ch] [rbp-4h]\n\n  do\n  {\n    n = poll(ufds, nfds, timeout);\n    if ( n >= 0 )\n      return n;\n    if ( timeout > 0 )\n      --timeout;\n  }\n  while ( *bb_errno == 4 || *bb_errno == 12 );\n  bb_perror_msg(\"poll\");\n  return n;\n}\n",
        "similarity_score_unixcoder": 0.8405148386955261,
        "similarity_score_baseline_stripped": 0.5689689517021179,
        "similarity_score_baseline_debug": 0.890408456325531
    },
    {
        "func_name": "BZ2_blockSort",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4AB46E(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // [rsp+1Ch] [rbp-34h] BYREF\n  unsigned __int8 *v3; // [rsp+20h] [rbp-30h]\n  int v4; // [rsp+2Ch] [rbp-24h]\n  int *v5; // [rsp+30h] [rbp-20h]\n  unsigned __int8 *v6; // [rsp+38h] [rbp-18h]\n  __int64 v7; // [rsp+40h] [rbp-10h]\n  int i; // [rsp+4Ch] [rbp-4h]\n\n  v7 = *(_QWORD *)(a1 + 48);\n  v6 = *(unsigned __int8 **)(a1 + 56);\n  v5 = *(int **)(a1 + 40);\n  v4 = *(_DWORD *)(a1 + 96);\n  if ( v4 > 9999 )\n  {\n    i = v4 + 34;\n    if ( (((_BYTE)v4 + 34) & 1) != 0 )\n      ++i;\n    v3 = &v6[i];\n    v2 = 9 * v4;\n    sub_4AAAE7(a1, v7, v6, (__int64)v3, v5, v4, &v2);\n    if ( v2 < 0 )\n      sub_4A92A3(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), (__int64)v5, v4);\n  }\n  else\n  {\n    sub_4A92A3(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), (__int64)v5, v4);\n  }\n  *(_DWORD *)(a1 + 16) = -1;\n  for ( i = 0; ; ++i )\n  {\n    result = *(unsigned int *)(a1 + 96);\n    if ( i >= (int)result )\n      break;\n    if ( !*(_DWORD *)(4LL * i + v7) )\n    {\n      result = a1;\n      *(_DWORD *)(a1 + 16) = i;\n      return result;\n    }\n  }\n  return result;\n}\n",
        "output": "long long process_data(long long param)\n{\n  long long result;\n  int multiplier;\n  unsigned char *offset_ptr;\n  int data_size;\n  int *data_ptr;\n  unsigned char *data_buffer;\n  long long data_buffer_size;\n  int index;\n\n  data_buffer_size = *(_QWORD *)(param + 48);\n  data_buffer = *(unsigned char **)(param + 56);\n  data_ptr = *(int **)(param + 40);\n  data_size = *(_DWORD *)(param + 96);\n  \n  if (data_size > 9999)\n  {\n    index = data_size + 34;\n    if ((index & 1) != 0)\n      index++;\n    offset_ptr = &data_buffer[index];\n    multiplier = 9 * data_size;\n    sub_4AAAE7(param, data_buffer_size, data_buffer, (long long)offset_ptr, data_ptr, data_size, &multiplier);\n    if (multiplier < 0)\n      sub_4A92A3(*(_QWORD *)(param + 24), *(_QWORD *)(param + 32), (long long)data_ptr, data_size);\n  }\n  else\n  {\n    sub_4A92A3(*(_QWORD *)(param + 24), *(_QWORD *)(param + 32), (long long)data_ptr, data_size);\n  }\n  \n  *(_DWORD *)(param + 16) = -1;\n  for (index = 0; ; ++index)\n  {\n    result = *(unsigned int *)(param + 96);\n    if (index >= (int)result)\n      break;\n    if (!*(_DWORD *)(4LL * index + data_buffer_size))\n    {\n      result = param;\n      *(_DWORD *)(param + 16) = index;\n      return result;\n    }\n  }\n  return result;\n}",
        "source_code": "static NOINLINE\nvoid BZ2_blockSort(EState* s)\n{\n\t/* In original bzip2 1.0.4, it's a parameter, but 30\n\t * (which was the default) should work ok. */\n\tenum { wfact = 30 };\n\n\tuint32_t* ptr    = s->ptr;\n\tuint8_t*  block  = s->block;\n\tuint32_t* ftab   = s->ftab;\n\tint32_t   nblock = s->nblock;\n\tuint16_t* quadrant;\n\tint32_t   budget;\n\tint32_t   i;\n\n\tif (nblock < 10000) {\n\t\tfallbackSort(s->arr1, s->arr2, ftab, nblock);\n\t} else {\n\t\t/* Calculate the location for quadrant, remembering to get\n\t\t * the alignment right.  Assumes that &(block[0]) is at least\n\t\t * 2-byte aligned -- this should be ok since block is really\n\t\t * the first section of arr2.\n\t\t */\n\t\ti = nblock + BZ_N_OVERSHOOT;\n\t\tif (i & 1) i++;\n\t\tquadrant = (uint16_t*)(&(block[i]));\n\n\t\t/* (wfact-1) / 3 puts the default-factor-30\n\t\t * transition point at very roughly the same place as\n\t\t * with v0.1 and v0.9.0.\n\t\t * Not that it particularly matters any more, since the\n\t\t * resulting compressed stream is now the same regardless\n\t\t * of whether or not we use the main sort or fallback sort.\n\t\t */\n\t\tbudget = nblock * ((wfact-1) / 3);\n\n\t\tmainSort(s, ptr, block, quadrant, ftab, nblock, &budget);\n\t\tif (budget < 0) {\n\t\t\tfallbackSort(s->arr1, s->arr2, ftab, nblock);\n\t\t}\n\t}\n\n\ts->origPtr = -1;\n\tfor (i = 0; i < s->nblock; i++)\n\t\tif (ptr[i] == 0) {\n\t\t\ts->origPtr = i;\n\t\t\tbreak;\n\t\t};\n\n\tAssertH(s->origPtr != -1, 1003);\n}",
        "parsed_output": "long long process_data(long long param)\n{\n  long long result;\n  int multiplier;\n  unsigned char *offset_ptr;\n  int data_size;\n  int *data_ptr;\n  unsigned char *data_buffer;\n  long long data_buffer_size;\n  int index;\n\n  data_buffer_size = *(_QWORD *)(param + 48);\n  data_buffer = *(unsigned char **)(param + 56);\n  data_ptr = *(int **)(param + 40);\n  data_size = *(_DWORD *)(param + 96);\n  \n  if (data_size > 9999)\n  {\n    index = data_size + 34;\n    if ((index & 1) != 0)\n      index++;\n    offset_ptr = &data_buffer[index];\n    multiplier = 9 * data_size;\n    sub_4AAAE7(param, data_buffer_size, data_buffer, (long long)offset_ptr, data_ptr, data_size, &multiplier);\n    if (multiplier < 0)\n      sub_4A92A3(*(_QWORD *)(param + 24), *(_QWORD *)(param + 32), (long long)data_ptr, data_size);\n  }\n  else\n  {\n    sub_4A92A3(*(_QWORD *)(param + 24), *(_QWORD *)(param + 32), (long long)data_ptr, data_size);\n  }\n  \n  *(_DWORD *)(param + 16) = -1;\n  for (index = 0; ; ++index)\n  {\n    result = *(unsigned int *)(param + 96);\n    if (index >= (int)result)\n      break;\n    if (!*(_DWORD *)(4LL * index + data_buffer_size))\n    {\n      result = param;\n      *(_DWORD *)(param + 16) = index;\n      return result;\n    }\n  }\n  return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4AB46E(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // [rsp+1Ch] [rbp-34h] BYREF\n  unsigned __int8 *v3; // [rsp+20h] [rbp-30h]\n  int v4; // [rsp+2Ch] [rbp-24h]\n  int *v5; // [rsp+30h] [rbp-20h]\n  unsigned __int8 *v6; // [rsp+38h] [rbp-18h]\n  __int64 v7; // [rsp+40h] [rbp-10h]\n  int i; // [rsp+4Ch] [rbp-4h]\n\n  v7 = *(_QWORD *)(a1 + 48);\n  v6 = *(unsigned __int8 **)(a1 + 56);\n  v5 = *(int **)(a1 + 40);\n  v4 = *(_DWORD *)(a1 + 96);\n  if ( v4 > 9999 )\n  {\n    i = v4 + 34;\n    if ( (((_BYTE)v4 + 34) & 1) != 0 )\n      ++i;\n    v3 = &v6[i];\n    v2 = 9 * v4;\n    sub_4AAAE7(a1, v7, v6, (__int64)v3, v5, v4, &v2);\n    if ( v2 < 0 )\n      sub_4A92A3(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), (__int64)v5, v4);\n  }\n  else\n  {\n    sub_4A92A3(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), (__int64)v5, v4);\n  }\n  *(_DWORD *)(a1 + 16) = -1;\n  for ( i = 0; ; ++i )\n  {\n    result = *(unsigned int *)(a1 + 96);\n    if ( i >= (int)result )\n      break;\n    if ( !*(_DWORD *)(4LL * i + v7) )\n    {\n      result = a1;\n      *(_DWORD *)(a1 + 16) = i;\n      return result;\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl BZ2_blockSort(EState_0 *s)\n{\n  int32_t budget; // [rsp+1Ch] [rbp-34h] BYREF\n  uint16_t *quadrant; // [rsp+20h] [rbp-30h]\n  int32_t nblock; // [rsp+2Ch] [rbp-24h]\n  uint32_t *ftab; // [rsp+30h] [rbp-20h]\n  uint8_t *block; // [rsp+38h] [rbp-18h]\n  uint32_t *ptr; // [rsp+40h] [rbp-10h]\n  int32_t i; // [rsp+4Ch] [rbp-4h]\n\n  ptr = s->ptr;\n  block = s->block;\n  ftab = s->ftab;\n  nblock = s->nblock;\n  if ( nblock > 9999 )\n  {\n    i = nblock + 34;\n    if ( (((_BYTE)nblock + 34) & 1) != 0 )\n      ++i;\n    quadrant = (uint16_t *)&block[i];\n    budget = 9 * nblock;\n    mainSort(s, ptr, block, quadrant, ftab, nblock, &budget);\n    if ( budget < 0 )\n      fallbackSort(s->arr1, s->arr2, ftab, nblock);\n  }\n  else\n  {\n    fallbackSort(s->arr1, s->arr2, ftab, nblock);\n  }\n  s->origPtr = -1;\n  for ( i = 0; i < s->nblock; ++i )\n  {\n    if ( !ptr[i] )\n    {\n      s->origPtr = i;\n      return;\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.5348541140556335,
        "similarity_score_baseline_stripped": 0.5435144901275635,
        "similarity_score_baseline_debug": 0.891544759273529
    },
    {
        "func_name": "setup_alarm",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4A40E0(int a1, const time_t *a2, __int64 a3)\n{\n  char v5[4]; // [rsp+20h] [rbp-30h] BYREF\n  int v6[9]; // [rsp+24h] [rbp-2Ch] BYREF\n  struct tm *v7; // [rsp+48h] [rbp-8h]\n\n  v7 = localtime(a2);\n  v6[0] = v7->tm_sec;\n  v6[1] = v7->tm_min;\n  v6[2] = v7->tm_hour;\n  v6[3] = v7->tm_mday;\n  v6[4] = v7->tm_mon;\n  v6[5] = v7->tm_year;\n  v6[6] = -1;\n  v6[7] = -1;\n  v6[8] = -1;\n  if ( a3 + 86399 < *a2 )\n  {\n    v5[0] = 1;\n    return sub_40AD51(a1, 0x4028700Fu, (__int64)v5, (__int64)\"RTC_WKALM_SET\");\n  }\n  else\n  {\n    sub_40AD51(a1, 0x40247007u, (__int64)v6, (__int64)\"RTC_ALM_SET\");\n    return sub_40AD51(a1, 0x7001u, 0LL, (__int64)\"RTC_AIE_ON\");\n  }\n}\n",
        "output": "time_t __fastcall setAlarm(int alarmType, const time_t *currentTime, time_t alarmOffset)\n{\n  char alarmStatus[4]; // Buffer for alarm status\n  int timeComponents[9]; // Array to hold time components\n  struct tm *localTime; // Pointer to hold local time structure\n\n  localTime = localtime(currentTime);\n  timeComponents[0] = localTime->tm_sec;\n  timeComponents[1] = localTime->tm_min;\n  timeComponents[2] = localTime->tm_hour;\n  timeComponents[3] = localTime->tm_mday;\n  timeComponents[4] = localTime->tm_mon;\n  timeComponents[5] = localTime->tm_year;\n  timeComponents[6] = -1; // Unused\n  timeComponents[7] = -1; // Unused\n  timeComponents[8] = -1; // Unused\n\n  if (alarmOffset + 86399 < *currentTime)\n  {\n    alarmStatus[0] = 1;\n    return sendCommand(alarmType, 0x4028700Fu, alarmStatus, \"RTC_WKALM_SET\");\n  }\n  else\n  {\n    sendCommand(alarmType, 0x40247007u, timeComponents, \"RTC_ALM_SET\");\n    return sendCommand(alarmType, 0x7001u, 0LL, \"RTC_AIE_ON\");\n  }\n}",
        "source_code": "static NOINLINE void setup_alarm(int fd, time_t *wakeup, time_t rtc_time)\n{\n\tstruct tm *ptm;\n\tstruct linux_rtc_wkalrm wake;\n\n\t/* The wakeup time is in POSIX time (more or less UTC).\n\t * Ideally RTCs use that same time; but PCs can't do that\n\t * if they need to boot MS-Windows.  Messy...\n\t *\n\t * When running in utc mode this process's timezone is UTC,\n\t * so we'll pass a UTC date to the RTC.\n\t *\n\t * Else mode is local so the time given to the RTC\n\t * will instead use the local time zone.\n\t */\n\tptm = localtime(wakeup);\n\n\twake.time.tm_sec = ptm->tm_sec;\n\twake.time.tm_min = ptm->tm_min;\n\twake.time.tm_hour = ptm->tm_hour;\n\twake.time.tm_mday = ptm->tm_mday;\n\twake.time.tm_mon = ptm->tm_mon;\n\twake.time.tm_year = ptm->tm_year;\n\t/* wday, yday, and isdst fields are unused by Linux */\n\twake.time.tm_wday = -1;\n\twake.time.tm_yday = -1;\n\twake.time.tm_isdst = -1;\n\n\t/* many rtc alarms only support up to 24 hours from 'now',\n\t * so use the \"more than 24 hours\" request only if we must\n\t */\n\tif ((rtc_time + (24 * 60 * 60)) > *wakeup) {\n\t\txioctl(fd, RTC_ALM_SET, &wake.time);\n\t\txioctl(fd, RTC_AIE_ON, 0);\n\t} else {\n\t\t/* avoid an extra AIE_ON call */\n\t\twake.enabled = 1;\n\t\txioctl(fd, RTC_WKALM_SET, &wake);\n\t}\n}",
        "parsed_output": "time_t __fastcall setAlarm(int alarmType, const time_t *currentTime, time_t alarmOffset)\n{\n  char alarmStatus[4]; // Buffer for alarm status\n  int timeComponents[9]; // Array to hold time components\n  struct tm *localTime; // Pointer to hold local time structure\n\n  localTime = localtime(currentTime);\n  timeComponents[0] = localTime->tm_sec;\n  timeComponents[1] = localTime->tm_min;\n  timeComponents[2] = localTime->tm_hour;\n  timeComponents[3] = localTime->tm_mday;\n  timeComponents[4] = localTime->tm_mon;\n  timeComponents[5] = localTime->tm_year;\n  timeComponents[6] = -1; // Unused\n  timeComponents[7] = -1; // Unused\n  timeComponents[8] = -1; // Unused\n\n  if (alarmOffset + 86399 < *currentTime)\n  {\n    alarmStatus[0] = 1;\n    return sendCommand(alarmType, 0x4028700Fu, alarmStatus, \"RTC_WKALM_SET\");\n  }\n  else\n  {\n    sendCommand(alarmType, 0x40247007u, timeComponents, \"RTC_ALM_SET\");\n    return sendCommand(alarmType, 0x7001u, 0LL, \"RTC_AIE_ON\");\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4A40E0(int a1, const time_t *a2, __int64 a3)\n{\n  char v5[4]; // [rsp+20h] [rbp-30h] BYREF\n  int v6[9]; // [rsp+24h] [rbp-2Ch] BYREF\n  struct tm *v7; // [rsp+48h] [rbp-8h]\n\n  v7 = localtime(a2);\n  v6[0] = v7->tm_sec;\n  v6[1] = v7->tm_min;\n  v6[2] = v7->tm_hour;\n  v6[3] = v7->tm_mday;\n  v6[4] = v7->tm_mon;\n  v6[5] = v7->tm_year;\n  v6[6] = -1;\n  v6[7] = -1;\n  v6[8] = -1;\n  if ( a3 + 86399 < *a2 )\n  {\n    v5[0] = 1;\n    return sub_40AD51(a1, 0x4028700Fu, (__int64)v5, (__int64)\"RTC_WKALM_SET\");\n  }\n  else\n  {\n    sub_40AD51(a1, 0x40247007u, (__int64)v6, (__int64)\"RTC_ALM_SET\");\n    return sub_40AD51(a1, 0x7001u, 0LL, (__int64)\"RTC_AIE_ON\");\n  }\n}\n",
        "baseline_code_debug": "void __cdecl setup_alarm(int fd, time_t *wakeup, time_t rtc_time)\n{\n  linux_rtc_wkalrm wake; // [rsp+20h] [rbp-30h] BYREF\n  tm *ptm; // [rsp+48h] [rbp-8h]\n\n  ptm = localtime(wakeup);\n  wake.time.tm_sec = ptm->tm_sec;\n  wake.time.tm_min = ptm->tm_min;\n  wake.time.tm_hour = ptm->tm_hour;\n  wake.time.tm_mday = ptm->tm_mday;\n  wake.time.tm_mon = ptm->tm_mon;\n  wake.time.tm_year = ptm->tm_year;\n  wake.time.tm_wday = -1;\n  wake.time.tm_yday = -1;\n  wake.time.tm_isdst = -1;\n  if ( rtc_time + 86399 < *wakeup )\n  {\n    wake.enabled = 1;\n    bb_xioctl(fd, 0x4028700Fu, &wake, \"RTC_WKALM_SET\");\n  }\n  else\n  {\n    bb_xioctl(fd, 0x40247007u, &wake.time, \"RTC_ALM_SET\");\n    bb_xioctl(fd, 0x7001u, 0LL, \"RTC_AIE_ON\");\n  }\n}\n",
        "similarity_score_unixcoder": 0.7706746459007263,
        "similarity_score_baseline_stripped": 0.6652294993400574,
        "similarity_score_baseline_debug": 0.9293116927146912
    },
    {
        "func_name": "detect_link_wlan",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_430893()\n{\n  int v1; // [rsp+Ah] [rbp-36h]\n  __int16 v2; // [rsp+Eh] [rbp-32h]\n  char s[18]; // [rsp+10h] [rbp-30h] BYREF\n  int v4; // [rsp+22h] [rbp-1Eh]\n  __int16 v5; // [rsp+26h] [rbp-1Ah]\n  int i; // [rsp+3Ch] [rbp-4h]\n\n  memset(s, 0, 0x20uLL);\n  sub_409A52(s, *((const char **)qword_75D408 + 2));\n  if ( (int)sub_430676(35605, (__int64)s, (__int64)\"SIOCGIWAP\") < 0 )\n    return 0xFFFFFFFFLL;\n  v1 = v4;\n  v2 = v5;\n  if ( (_BYTE)v4 != 0xFF && (_BYTE)v1 != 68 && (_BYTE)v1 )\n    return 1LL;\n  for ( i = 1; i <= 5; ++i )\n  {\n    if ( *((_BYTE *)&v1 + i) != (_BYTE)v1 )\n      return 1LL;\n  }\n  return 0LL;\n}\n",
        "output": "```c\n#include <stdint.h>\n#include <string.h>\n\n#define MAX_SSID_LENGTH 18\n#define ERROR_CODE 0xFFFFFFFFLL\n#define SUCCESS_CODE 0LL\n#define FAILURE_CODE 1LL\n\nint64_t check_wireless_access_point()\n{\n  int ssid_part1; // First part of the SSID\n  int16_t ssid_part2; // Second part of the SSID\n  char ssid[MAX_SSID_LENGTH]; // Buffer for the SSID\n  int ssid_end_part1; // End part of the SSID (first section)\n  int16_t ssid_end_part2; // End part of the SSID (second section)\n  int i; // Loop counter\n\n  // Initialize the SSID buffer with zeros\n  memset(ssid, 0, sizeof(ssid));\n  // Retrieve the SSID using a custom function\n  sub_409A52(ssid, *((const char **)qword_75D408 + 2));\n  // Check if the SSID matches a specific pattern using another custom function\n  if (sub_430676(35605, (int64_t)ssid, (int64_t)\"SIOCGIWAP\") < 0)\n    return ERROR_CODE;\n\n  // Store the end parts of the SSID for comparison\n  ssid_part1 = ssid_end_part1;\n  ssid_part2 = ssid_end_part2;\n\n  // Check if the first byte of the SSID is not 0xFF, not 68, and not 0\n  if ((uint8_t)ssid_end_part1 != 0xFF && (uint8_t)ssid_part1 != 68 && (uint8_t)ssid_part1)\n    return SUCCESS_CODE;\n\n  // Check if the next 5 bytes of the SSID are different from the first byte\n  for (i = 1; i <= 5; ++i)\n  {\n    if (*((uint8_t *)&ssid_part1 + i) != (uint8_t)ssid_part1)\n      return SUCCESS_CODE;\n  }\n\n  // If all checks pass, return failure code\n  return FAILURE_CODE;\n}\n```",
        "source_code": "static smallint detect_link_wlan(void)\n{\n\tint i;\n\tstruct iwreq iwrequest;\n\tuint8_t mac[ETH_ALEN];\n\n\tmemset(&iwrequest, 0, sizeof(iwrequest));\n\tstrncpy_IFNAMSIZ(iwrequest.ifr_ifrn.ifrn_name, G.iface);\n\n\tif (network_ioctl(SIOCGIWAP, &iwrequest, \"SIOCGIWAP\") < 0) {\n\t\treturn IFSTATUS_ERR;\n\t}\n\n\tmemcpy(mac, &iwrequest.u.ap_addr.sa_data, ETH_ALEN);\n\n\tif (mac[0] == 0xFF || mac[0] == 0x44 || mac[0] == 0x00) {\n\t\tfor (i = 1; i < ETH_ALEN; ++i) {\n\t\t\tif (mac[i] != mac[0])\n\t\t\t\treturn IFSTATUS_UP;\n\t\t}\n\t\treturn IFSTATUS_DOWN;\n\t}\n\n\treturn IFSTATUS_UP;\n}",
        "parsed_output": "#include <stdint.h>\n#include <string.h>\n\n#define MAX_SSID_LENGTH 18\n#define ERROR_CODE 0xFFFFFFFFLL\n#define SUCCESS_CODE 0LL\n#define FAILURE_CODE 1LL\n\nint64_t check_wireless_access_point()\n{\n  int ssid_part1; // First part of the SSID\n  int16_t ssid_part2; // Second part of the SSID\n  char ssid[MAX_SSID_LENGTH]; // Buffer for the SSID\n  int ssid_end_part1; // End part of the SSID (first section)\n  int16_t ssid_end_part2; // End part of the SSID (second section)\n  int i; // Loop counter\n\n  // Initialize the SSID buffer with zeros\n  memset(ssid, 0, sizeof(ssid));\n  // Retrieve the SSID using a custom function\n  sub_409A52(ssid, *((const char **)qword_75D408 + 2));\n  // Check if the SSID matches a specific pattern using another custom function\n  if (sub_430676(35605, (int64_t)ssid, (int64_t)\"SIOCGIWAP\") < 0)\n    return ERROR_CODE;\n\n  // Store the end parts of the SSID for comparison\n  ssid_part1 = ssid_end_part1;\n  ssid_part2 = ssid_end_part2;\n\n  // Check if the first byte of the SSID is not 0xFF, not 68, and not 0\n  if ((uint8_t)ssid_end_part1 != 0xFF && (uint8_t)ssid_part1 != 68 && (uint8_t)ssid_part1)\n    return SUCCESS_CODE;\n\n  // Check if the next 5 bytes of the SSID are different from the first byte\n  for (i = 1; i <= 5; ++i)\n  {\n    if (*((uint8_t *)&ssid_part1 + i) != (uint8_t)ssid_part1)\n      return SUCCESS_CODE;\n  }\n\n  // If all checks pass, return failure code\n  return FAILURE_CODE;\n}",
        "baseline_code_stripped": "__int64 sub_430893()\n{\n  int v1; // [rsp+Ah] [rbp-36h]\n  __int16 v2; // [rsp+Eh] [rbp-32h]\n  char s[18]; // [rsp+10h] [rbp-30h] BYREF\n  int v4; // [rsp+22h] [rbp-1Eh]\n  __int16 v5; // [rsp+26h] [rbp-1Ah]\n  int i; // [rsp+3Ch] [rbp-4h]\n\n  memset(s, 0, 0x20uLL);\n  sub_409A52(s, *((const char **)qword_75D408 + 2));\n  if ( (int)sub_430676(35605, (__int64)s, (__int64)\"SIOCGIWAP\") < 0 )\n    return 0xFFFFFFFFLL;\n  v1 = v4;\n  v2 = v5;\n  if ( (_BYTE)v4 != 0xFF && (_BYTE)v1 != 68 && (_BYTE)v1 )\n    return 1LL;\n  for ( i = 1; i <= 5; ++i )\n  {\n    if ( *((_BYTE *)&v1 + i) != (_BYTE)v1 )\n      return 1LL;\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "smallint __cdecl detect_link_wlan()\n{\n  uint8_t mac[6]; // [rsp+Ah] [rbp-36h]\n  iwreq iwrequest; // [rsp+10h] [rbp-30h] BYREF\n  int i; // [rsp+3Ch] [rbp-4h]\n\n  memset(&iwrequest, 0, sizeof(iwrequest));\n  strncpy_IFNAMSIZ(iwrequest.ifr_ifrn.ifrn_name, ptr_to_globals->fakehost);\n  if ( network_ioctl(35605, &iwrequest, \"SIOCGIWAP\") < 0 )\n    return -1;\n  *(_DWORD *)mac = *(_DWORD *)((char *)&iwrequest.u.essid.pointer + 2);\n  *(_WORD *)&mac[4] = iwrequest.u.nwid.flags;\n  if ( iwrequest.u.name[2] != -1 && mac[0] != 68 && mac[0] )\n    return 1;\n  for ( i = 1; i <= 5; ++i )\n  {\n    if ( mac[i] != mac[0] )\n      return 1;\n  }\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.7036962509155273,
        "similarity_score_baseline_stripped": 0.47037196159362793,
        "similarity_score_baseline_debug": 0.8218579292297363
    },
    {
        "func_name": "pmap_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_461A9A(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  _QWORD *v6; // rax\n  _QWORD *v8; // [rsp+0h] [rbp-20h]\n  unsigned int v9; // [rsp+14h] [rbp-Ch]\n  unsigned int v10; // [rsp+18h] [rbp-8h]\n  unsigned int v11; // [rsp+1Ch] [rbp-4h]\n\n  v10 = sub_4FA1EF(a2, (unsigned int)\"xq\", a3, a4, a5, a6);\n  v8 = (_QWORD *)(8LL * optind + a2);\n  v11 = 0;\n  while ( *v8 )\n  {\n    v6 = v8++;\n    v9 = sub_50B306(*v6);\n    if ( (unsigned int)sub_46197E(v9, v10) )\n      v11 = 42;\n  }\n  return v11;\n}\n",
        "output": "long long sub_461A9A(long long a1, long long a2, int a3, int a4, int a5, int a6)\n{\n  unsigned long long *currentElementPointer;\n  unsigned int resultValue;\n  unsigned int comparisonValue;\n  unsigned int returnValue;\n\n  comparisonValue = sub_4FA1EF(a2, (unsigned int)\"xq\", a3, a4, a5, a6);\n  currentElementPointer = (unsigned long long *)(8 * optind + a2);\n  returnValue = 0;\n  while ( *currentElementPointer )\n  {\n    resultValue = sub_50B306(*currentElementPointer);\n    currentElementPointer++;\n    if ( sub_46197E(resultValue, comparisonValue) )\n      returnValue = 42;\n  }\n  return returnValue;\n}",
        "source_code": "int pmap_main(int argc UNUSED_PARAM, char **argv)\n{\n\tunsigned opts;\n\tint ret;\n\n\topts = getopt32(argv, \"xq\");\n\targv += optind;\n\n\tret = 0;\n\twhile (*argv) {\n\t\tpid_t pid = xatoi_positive(*argv++);\n\t\t/* GNU pmap returns 42 if any of the pids failed */\n\t\tif (procps_get_maps(pid, opts) != 0)\n\t\t\tret = 42;\n\t}\n\n\treturn ret;\n}",
        "parsed_output": "long long sub_461A9A(long long a1, long long a2, int a3, int a4, int a5, int a6)\n{\n  unsigned long long *currentElementPointer;\n  unsigned int resultValue;\n  unsigned int comparisonValue;\n  unsigned int returnValue;\n\n  comparisonValue = sub_4FA1EF(a2, (unsigned int)\"xq\", a3, a4, a5, a6);\n  currentElementPointer = (unsigned long long *)(8 * optind + a2);\n  returnValue = 0;\n  while ( *currentElementPointer )\n  {\n    resultValue = sub_50B306(*currentElementPointer);\n    currentElementPointer++;\n    if ( sub_46197E(resultValue, comparisonValue) )\n      returnValue = 42;\n  }\n  return returnValue;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_461A9A(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  _QWORD *v6; // rax\n  _QWORD *v8; // [rsp+0h] [rbp-20h]\n  unsigned int v9; // [rsp+14h] [rbp-Ch]\n  unsigned int v10; // [rsp+18h] [rbp-8h]\n  unsigned int v11; // [rsp+1Ch] [rbp-4h]\n\n  v10 = sub_4FA1EF(a2, (unsigned int)\"xq\", a3, a4, a5, a6);\n  v8 = (_QWORD *)(8LL * optind + a2);\n  v11 = 0;\n  while ( *v8 )\n  {\n    v6 = v8++;\n    v9 = sub_50B306(*v6);\n    if ( (unsigned int)sub_46197E(v9, v10) )\n      v11 = 42;\n  }\n  return v11;\n}\n",
        "baseline_code_debug": "int __cdecl pmap_main(int argc, char **argv)\n{\n  const char **v2; // rax\n  char **argva; // [rsp+0h] [rbp-20h]\n  int pid; // [rsp+14h] [rbp-Ch]\n  uint32_t opts; // [rsp+18h] [rbp-8h]\n  int ret; // [rsp+1Ch] [rbp-4h]\n\n  opts = getopt32(argv, \"xq\");\n  argva = &argv[optind];\n  ret = 0;\n  while ( *argva )\n  {\n    v2 = (const char **)argva++;\n    pid = xatoi_positive(*v2);\n    if ( procps_get_maps(pid, opts) )\n      ret = 42;\n  }\n  return ret;\n}\n",
        "similarity_score_unixcoder": 0.4682074785232544,
        "similarity_score_baseline_stripped": 0.46694985032081604,
        "similarity_score_baseline_debug": 0.8239701986312866
    },
    {
        "func_name": "getvar_i",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\ndouble __fastcall sub_4DCB18(int *a1)\n{\n  int v1; // eax\n  int v2; // eax\n  int v3; // eax\n  char *v5; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( (*a1 & 0x101) == 0 )\n  {\n    *((_QWORD *)a1 + 1) = 0LL;\n    v5 = (char *)*((_QWORD *)a1 + 2);\n    if ( v5 && *v5 )\n    {\n      *((double *)a1 + 1) = sub_4DC683(&v5);\n      if ( (*a1 & 0x200) != 0 )\n      {\n        v5 = sub_4DC502(v5);\n        if ( *v5 )\n        {\n          v1 = *a1;\n          BYTE1(v1) = BYTE1(*a1) & 0xFD;\n          *a1 = v1;\n        }\n      }\n    }\n    else\n    {\n      v2 = *a1;\n      BYTE1(v2) = BYTE1(*a1) & 0xFD;\n      *a1 = v2;\n    }\n    v3 = *a1;\n    BYTE1(v3) = BYTE1(*a1) | 1;\n    *a1 = v3;\n  }\n  return *((double *)a1 + 1);\n}\n",
        "output": "double processInput(int *inputFlags)\n{\n  char *stringPointer;\n\n  if ((*inputFlags & 0x101) == 0)\n  {\n    *((double *)inputFlags + 1) = 0.0;\n    stringPointer = (char *)*((long long *)inputFlags + 2);\n    \n    if (stringPointer && *stringPointer)\n    {\n      *((double *)inputFlags + 1) = calculateValue(&stringPointer);\n      \n      if ((*inputFlags & 0x200) != 0)\n      {\n        stringPointer = modifyString(stringPointer);\n        \n        if (*stringPointer)\n        {\n          *inputFlags &= 0xFFFFFDFF;\n        }\n      }\n    }\n    else\n    {\n      *inputFlags &= 0xFFFFFDFF;\n    }\n    \n    *inputFlags |= 0x100;\n  }\n  \n  return *((double *)inputFlags + 1);\n}",
        "source_code": "static double getvar_i(var *v)\n{\n\tchar *s;\n\n\tif ((v->type & (VF_NUMBER | VF_CACHED)) == 0) {\n\t\tv->number = 0;\n\t\ts = v->string;\n\t\tif (s && *s) {\n\t\t\tdebug_printf_eval(\"getvar_i: '%s'->\", s);\n\t\t\tv->number = my_strtod(&s);\n\t\t\tdebug_printf_eval(\"%f (s:'%s')\\n\", v->number, s);\n\t\t\tif (v->type & VF_USER) {\n\t\t\t\ts = skip_spaces(s);\n\t\t\t\tif (*s != '\\0')\n\t\t\t\t\tv->type &= ~VF_USER;\n\t\t\t}\n\t\t} else {\n\t\t\tdebug_printf_eval(\"getvar_i: '%s'->zero\\n\", s);\n\t\t\tv->type &= ~VF_USER;\n\t\t}\n\t\tv->type |= VF_CACHED;\n\t}\n\tdebug_printf_eval(\"getvar_i: %f\\n\", v->number);\n\treturn v->number;\n}",
        "parsed_output": "double processInput(int *inputFlags)\n{\n  char *stringPointer;\n\n  if ((*inputFlags & 0x101) == 0)\n  {\n    *((double *)inputFlags + 1) = 0.0;\n    stringPointer = (char *)*((long long *)inputFlags + 2);\n    \n    if (stringPointer && *stringPointer)\n    {\n      *((double *)inputFlags + 1) = calculateValue(&stringPointer);\n      \n      if ((*inputFlags & 0x200) != 0)\n      {\n        stringPointer = modifyString(stringPointer);\n        \n        if (*stringPointer)\n        {\n          *inputFlags &= 0xFFFFFDFF;\n        }\n      }\n    }\n    else\n    {\n      *inputFlags &= 0xFFFFFDFF;\n    }\n    \n    *inputFlags |= 0x100;\n  }\n  \n  return *((double *)inputFlags + 1);\n}",
        "baseline_code_stripped": "double __fastcall sub_4DCB18(int *a1)\n{\n  int v1; // eax\n  int v2; // eax\n  int v3; // eax\n  char *v5; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( (*a1 & 0x101) == 0 )\n  {\n    *((_QWORD *)a1 + 1) = 0LL;\n    v5 = (char *)*((_QWORD *)a1 + 2);\n    if ( v5 && *v5 )\n    {\n      *((double *)a1 + 1) = sub_4DC683(&v5);\n      if ( (*a1 & 0x200) != 0 )\n      {\n        v5 = sub_4DC502(v5);\n        if ( *v5 )\n        {\n          v1 = *a1;\n          BYTE1(v1) = BYTE1(*a1) & 0xFD;\n          *a1 = v1;\n        }\n      }\n    }\n    else\n    {\n      v2 = *a1;\n      BYTE1(v2) = BYTE1(*a1) & 0xFD;\n      *a1 = v2;\n    }\n    v3 = *a1;\n    BYTE1(v3) = BYTE1(*a1) | 1;\n    *a1 = v3;\n  }\n  return *((double *)a1 + 1);\n}\n",
        "baseline_code_debug": "double __cdecl getvar_i(var_0 *v)\n{\n  unsigned int type; // eax\n  unsigned int v2; // eax\n  unsigned int v3; // eax\n  char *s; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( (v->type & 0x101) == 0 )\n  {\n    v->number = 0.0;\n    s = v->string;\n    if ( s && *s )\n    {\n      v->number = my_strtod(&s);\n      if ( (v->type & 0x200) != 0 )\n      {\n        s = skip_spaces(s);\n        if ( *s )\n        {\n          type = v->type;\n          BYTE1(type) = BYTE1(v->type) & 0xFD;\n          v->type = type;\n        }\n      }\n    }\n    else\n    {\n      v2 = v->type;\n      BYTE1(v2) = BYTE1(v->type) & 0xFD;\n      v->type = v2;\n    }\n    v3 = v->type;\n    BYTE1(v3) = BYTE1(v->type) | 1;\n    v->type = v3;\n  }\n  return v->number;\n}\n",
        "similarity_score_unixcoder": 0.5824532508850098,
        "similarity_score_baseline_stripped": 0.5368391871452332,
        "similarity_score_baseline_debug": 0.7285971641540527
    },
    {
        "func_name": "loopback_down",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_431FE9(__int64 a1, __int64 (__fastcall *a2)(char *))\n{\n  _BOOL4 v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_431D4E(\"ip addr flush dev %iface%\", a1, a2);\n  if ( sub_431D4E(\"ip link set %iface% down\", a1, a2) + v3 == 2 )\n    return 2LL;\n  else\n    return 0LL;\n}\n",
        "output": "long long sub_431FE9(long long iface, long long (*executeCommand)(char *))\n{\n  int resultFlush, resultLinkDown;\n\n  resultFlush = sub_431D4E(\"ip addr flush dev %iface%\", iface, executeCommand);\n  resultLinkDown = sub_431D4E(\"ip link set %iface% down\", iface, executeCommand);\n  \n  if (resultFlush + resultLinkDown == 2)\n    return 2LL;\n  else\n    return 0LL;\n}",
        "source_code": "static int FAST_FUNC loopback_down(struct interface_defn_t *ifd, execfn *exec)\n{\n# if ENABLE_FEATURE_IFUPDOWN_IP\n\tint result;\n\tresult = execute(\"ip addr flush dev %iface%\", ifd, exec);\n\tresult += execute(\"ip link set %iface% down\", ifd, exec);\n\treturn ((result == 2) ? 2 : 0);\n# else\n\treturn execute(\"ifconfig %iface% 127.0.0.1 down\", ifd, exec);\n# endif\n}",
        "parsed_output": "long long sub_431FE9(long long iface, long long (*executeCommand)(char *))\n{\n  int resultFlush, resultLinkDown;\n\n  resultFlush = sub_431D4E(\"ip addr flush dev %iface%\", iface, executeCommand);\n  resultLinkDown = sub_431D4E(\"ip link set %iface% down\", iface, executeCommand);\n  \n  if (resultFlush + resultLinkDown == 2)\n    return 2LL;\n  else\n    return 0LL;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_431FE9(__int64 a1, __int64 (__fastcall *a2)(char *))\n{\n  _BOOL4 v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_431D4E(\"ip addr flush dev %iface%\", a1, a2);\n  if ( sub_431D4E(\"ip link set %iface% down\", a1, a2) + v3 == 2 )\n    return 2LL;\n  else\n    return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl loopback_down(interface_defn_t *ifd, execfn *exec)\n{\n  int result; // [rsp+1Ch] [rbp-4h]\n\n  result = execute(\"ip addr flush dev %iface%\", ifd, exec);\n  if ( execute(\"ip link set %iface% down\", ifd, exec) + result == 2 )\n    return 2;\n  else\n    return 0;\n}\n",
        "similarity_score_unixcoder": 0.7307382225990295,
        "similarity_score_baseline_stripped": 0.6248104572296143,
        "similarity_score_baseline_debug": 0.8635895252227783
    },
    {
        "func_name": "open_file_and_read_lines",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_41DFBB(__int64 a1, size_t a2)\n{\n  unsigned int v2; // eax\n  __int64 v3; // rdi\n  _QWORD *v4; // rbx\n\n  if ( *((_QWORD *)qword_75D408 + 13) )\n  {\n    v2 = sub_40A295(*((const char **)qword_75D408 + 13), 0);\n    a2 = 0LL;\n    v3 = v2;\n    sub_40A477(v2, 0);\n  }\n  else\n  {\n    v4 = qword_75D408;\n    v3 = (__int64)\"standard input\";\n    v4[13] = sub_40A11F(\"standard input\", a2);\n  }\n  *((_QWORD *)qword_75D408 + 7) = 0LL;\n  *((_QWORD *)qword_75D408 + 8) = 0LL;\n  *((_QWORD *)qword_75D408 + 2) = 0LL;\n  *((_BYTE *)qword_75D408 + 338) = 1;\n  return sub_41CE4B(v3, a2);\n}\n",
        "output": "void *initializeInputSource(__int64 globalStruct, size_t inputSize) {\n  unsigned int inputSourceId;\n  __int64 inputSourceName;\n  _QWORD *globalStructPtr;\n\n  if (*((_QWORD *)globalStruct + 13)) {\n    inputSourceId = getInputSourceId(*((const char **)globalStruct + 13), 0);\n    inputSize = 0;\n    inputSourceName = inputSourceId;\n    resetInputSource(inputSourceId, 0);\n  } else {\n    globalStructPtr = globalStruct;\n    inputSourceName = (__int64)\"standard input\";\n    globalStructPtr[13] = createInputSource(\"standard input\", inputSize);\n  }\n\n  *((_QWORD *)globalStruct + 7) = 0;\n  *((_QWORD *)globalStruct + 8) = 0;\n  *((_QWORD *)globalStruct + 2) = 0;\n  *((_BYTE *)globalStruct + 338) = 1;\n\n  return processInputSource(inputSourceName, inputSize);\n}",
        "source_code": "static void open_file_and_read_lines(void)\n{\n\tif (filename) {\n\t\txmove_fd(xopen(filename, O_RDONLY), STDIN_FILENO);\n\t} else {\n\t\t/* \"less\" with no arguments in argv[] */\n\t\t/* For status line only */\n\t\tfilename = xstrdup(bb_msg_standard_input);\n\t}\n\treadpos = 0;\n\treadeof = 0;\n\tlast_line_pos = 0;\n\tterminated = 1;\n\tread_lines();\n}",
        "parsed_output": "void *initializeInputSource(__int64 globalStruct, size_t inputSize) {\n  unsigned int inputSourceId;\n  __int64 inputSourceName;\n  _QWORD *globalStructPtr;\n\n  if (*((_QWORD *)globalStruct + 13)) {\n    inputSourceId = getInputSourceId(*((const char **)globalStruct + 13), 0);\n    inputSize = 0;\n    inputSourceName = inputSourceId;\n    resetInputSource(inputSourceId, 0);\n  } else {\n    globalStructPtr = globalStruct;\n    inputSourceName = (__int64)\"standard input\";\n    globalStructPtr[13] = createInputSource(\"standard input\", inputSize);\n  }\n\n  *((_QWORD *)globalStruct + 7) = 0;\n  *((_QWORD *)globalStruct + 8) = 0;\n  *((_QWORD *)globalStruct + 2) = 0;\n  *((_BYTE *)globalStruct + 338) = 1;\n\n  return processInputSource(inputSourceName, inputSize);\n}",
        "baseline_code_stripped": "void *__fastcall sub_41DFBB(__int64 a1, size_t a2)\n{\n  unsigned int v2; // eax\n  __int64 v3; // rdi\n  _QWORD *v4; // rbx\n\n  if ( *((_QWORD *)qword_75D408 + 13) )\n  {\n    v2 = sub_40A295(*((const char **)qword_75D408 + 13), 0);\n    a2 = 0LL;\n    v3 = v2;\n    sub_40A477(v2, 0);\n  }\n  else\n  {\n    v4 = qword_75D408;\n    v3 = (__int64)\"standard input\";\n    v4[13] = sub_40A11F(\"standard input\", a2);\n  }\n  *((_QWORD *)qword_75D408 + 7) = 0LL;\n  *((_QWORD *)qword_75D408 + 8) = 0LL;\n  *((_QWORD *)qword_75D408 + 2) = 0LL;\n  *((_BYTE *)qword_75D408 + 338) = 1;\n  return sub_41CE4B(v3, a2);\n}\n",
        "baseline_code_debug": "void __cdecl open_file_and_read_lines()\n{\n  int v0; // eax\n  globals *v1; // rbx\n\n  if ( *(_QWORD *)&ptr_to_globals->tty_attrs.c_cflag )\n  {\n    v0 = xopen(*(const char **)&ptr_to_globals->tty_attrs.c_cflag, 0);\n    xmove_fd(v0, 0);\n  }\n  else\n  {\n    v1 = ptr_to_globals;\n    *(_QWORD *)&v1->tty_attrs.c_cflag = xstrdup(\"standard input\");\n  }\n  *(_QWORD *)&ptr_to_globals->speeds[1] = 0LL;\n  *(_QWORD *)&ptr_to_globals->speeds[3] = 0LL;\n  ptr_to_globals->fakehost = 0LL;\n  BYTE2(ptr_to_globals[1].numspeed) = 1;\n  read_lines();\n}\n",
        "similarity_score_unixcoder": 0.46210819482803345,
        "similarity_score_baseline_stripped": 0.46279123425483704,
        "similarity_score_baseline_debug": 0.7188093662261963
    },
    {
        "func_name": "get_partition",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4920A7(int a1, unsigned int a2)\n{\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_491DF8(1u, 0, a2, 0, (__int64)\"Partition number\") - 1;\n  if ( a1 && !*(_BYTE *)(*((_QWORD *)qword_75D408 + 5 * v3 + 313) + 4LL) )\n    printf(\"Warning: partition %u has empty type\\n\", v3 + 1);\n  return v3;\n}\n",
        "output": "```c\nint checkPartitionType(int checkEnabled, unsigned int partitionIndex)\n{\n  unsigned int partitionNumber;\n\n  partitionNumber = getPartitionIndex(1, 0, partitionIndex, 0, \"Partition number\") - 1;\n  if (checkEnabled && !getPartitionTypeFlag(partitionNumber))\n    printf(\"Warning: partition %u has empty type\\n\", partitionNumber + 1);\n  return partitionNumber;\n}\n```",
        "source_code": "static unsigned\nget_partition(int warn, unsigned max)\n{\n\tstruct pte *pe;\n\tunsigned i;\n\n\ti = read_int(1, 0, max, 0, \"Partition number\") - 1;\n\tpe = &ptes[i];\n\n\tif (warn) {\n\t\tif ((!LABEL_IS_SUN && !LABEL_IS_SGI && !pe->part_table->sys_ind)\n\t\t || (LABEL_IS_SUN && (!sunlabel->partitions[i].num_sectors || !sunlabel->infos[i].id))\n\t\t || (LABEL_IS_SGI && !sgi_get_num_sectors(i))\n\t\t) {\n\t\t\tprintf(\"Warning: partition %u has empty type\\n\", i+1);\n\t\t}\n\t}\n\treturn i;\n}",
        "parsed_output": "int checkPartitionType(int checkEnabled, unsigned int partitionIndex)\n{\n  unsigned int partitionNumber;\n\n  partitionNumber = getPartitionIndex(1, 0, partitionIndex, 0, \"Partition number\") - 1;\n  if (checkEnabled && !getPartitionTypeFlag(partitionNumber))\n    printf(\"Warning: partition %u has empty type\\n\", partitionNumber + 1);\n  return partitionNumber;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4920A7(int a1, unsigned int a2)\n{\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_491DF8(1u, 0, a2, 0, (__int64)\"Partition number\") - 1;\n  if ( a1 && !*(_BYTE *)(*((_QWORD *)qword_75D408 + 5 * v3 + 313) + 4LL) )\n    printf(\"Warning: partition %u has empty type\\n\", v3 + 1);\n  return v3;\n}\n",
        "baseline_code_debug": "unsigned int __cdecl get_partition(int warn, unsigned int max)\n{\n  sector_t i; // [rsp+1Ch] [rbp-4h]\n\n  i = read_int(1u, 0, max, 0, \"Partition number\") - 1;\n  if ( warn && !*(_BYTE *)(*(_QWORD *)&ptr_to_globals[8].line_buf[40 * i + 44] + 4LL) )\n    printf(\"Warning: partition %u has empty type\\n\", i + 1);\n  return i;\n}\n",
        "similarity_score_unixcoder": 0.6381303668022156,
        "similarity_score_baseline_stripped": 0.5843066573143005,
        "similarity_score_baseline_debug": 0.7476709485054016
    },
    {
        "func_name": "ll_idx_n2a",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_45200D(unsigned int a1, char *a2)\n{\n  __int64 *v3; // [rsp+18h] [rbp-8h]\n\n  if ( !a1 )\n    return \"*\";\n  v3 = sub_451D87(a1);\n  if ( v3 )\n    return (const char *)(v3 + 4);\n  snprintf(a2, 0x10uLL, \"if%d\", a1);\n  return a2;\n}\n",
        "output": "const char *getInterfaceName(unsigned int interfaceId, char *buffer)\n{\n  __int64 *interfaceData;\n\n  if (interfaceId == 0)\n    return \"*\";\n\n  interfaceData = getInterfaceData(interfaceId);\n  if (interfaceData)\n    return (const char *)(interfaceData + 4);\n\n  snprintf(buffer, 16, \"if%d\", interfaceId);\n  return buffer;\n}",
        "source_code": "const char FAST_FUNC *ll_idx_n2a(int idx, char *buf)\n{\n\tstruct idxmap *im;\n\n\tif (idx == 0)\n\t\treturn \"*\";\n\tim = find_by_index(idx);\n\tif (im)\n\t\treturn im->name;\n\tsnprintf(buf, 16, \"if%d\", idx);\n\treturn buf;\n}",
        "parsed_output": "const char *getInterfaceName(unsigned int interfaceId, char *buffer)\n{\n  __int64 *interfaceData;\n\n  if (interfaceId == 0)\n    return \"*\";\n\n  interfaceData = getInterfaceData(interfaceId);\n  if (interfaceData)\n    return (const char *)(interfaceData + 4);\n\n  snprintf(buffer, 16, \"if%d\", interfaceId);\n  return buffer;\n}",
        "baseline_code_stripped": "const char *__fastcall sub_45200D(unsigned int a1, char *a2)\n{\n  __int64 *v3; // [rsp+18h] [rbp-8h]\n\n  if ( !a1 )\n    return \"*\";\n  v3 = sub_451D87(a1);\n  if ( v3 )\n    return (const char *)(v3 + 4);\n  snprintf(a2, 0x10uLL, \"if%d\", a1);\n  return a2;\n}\n",
        "baseline_code_debug": "const char *__cdecl ll_idx_n2a(int idx, char *buf)\n{\n  idxmap *im; // [rsp+18h] [rbp-8h]\n\n  if ( !idx )\n    return \"*\";\n  im = find_by_index(idx);\n  if ( im )\n    return im->name;\n  snprintf(buf, 0x10uLL, \"if%d\", (unsigned int)idx);\n  return buf;\n}\n",
        "similarity_score_unixcoder": 0.6144375205039978,
        "similarity_score_baseline_stripped": 0.5221630334854126,
        "similarity_score_baseline_debug": 0.8806375861167908
    },
    {
        "func_name": "fb_drawfullrectangle",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4173E7(\n        int a1,\n        int a2,\n        int a3,\n        int a4,\n        unsigned __int8 a5,\n        unsigned __int8 a6,\n        unsigned __int8 a7)\n{\n  __int64 result; // rax\n  int v10; // [rsp+24h] [rbp-1Ch]\n  __int64 v11; // [rsp+28h] [rbp-18h]\n  int v12; // [rsp+34h] [rbp-Ch]\n  int v13; // [rsp+38h] [rbp-8h]\n  int v14; // [rsp+3Ch] [rbp-4h]\n\n  v10 = sub_417020(a5, a6, a7);\n  v14 = a4 - a2;\n  v12 = a2;\n  do\n  {\n    v11 = *(_QWORD *)qword_75D408\n        + (unsigned int)(*((_DWORD *)qword_75D408 + 64) * v12)\n        + (unsigned __int64)(unsigned int)(*((_DWORD *)qword_75D408 + 72) * a1);\n    v13 = a3 - a1;\n    do\n    {\n      sub_417106(v11, v10);\n      result = *((unsigned int *)qword_75D408 + 72);\n      v11 += result;\n      --v13;\n    }\n    while ( v13 >= 0 );\n    ++v12;\n    --v14;\n  }\n  while ( v14 >= 0 );\n  return result;\n}\n",
        "output": "long long sub_4173E7(\n        int startX,\n        int startY,\n        int endX,\n        int endY,\n        unsigned char param5,\n        unsigned char param6,\n        unsigned char param7)\n{\n  long long finalResult;\n  int processedParams;\n  long long currentAddress;\n  int currentY;\n  int currentX;\n  int deltaX;\n\n  processedParams = sub_417020(param5, param6, param7);\n  deltaX = endY - startY;\n  currentY = startY;\n  do\n  {\n    currentAddress = *(_QWORD *)qword_75D408\n        + (unsigned int)(*((_DWORD *)qword_75D408 + 64) * currentY)\n        + (unsigned long long)(unsigned int)(*((_DWORD *)qword_75D408 + 72) * startX);\n    currentX = endX - startX;\n    do\n    {\n      sub_417106(currentAddress, processedParams);\n      finalResult = *((unsigned int *)qword_75D408 + 72);\n      currentAddress += finalResult;\n      --currentX;\n    }\n    while ( currentX >= 0 );\n    ++currentY;\n    --deltaX;\n  }\n  while ( deltaX >= 0 );\n  return finalResult;\n}",
        "source_code": "static void fb_drawfullrectangle(int nx1pos, int ny1pos, int nx2pos, int ny2pos,\n\tunsigned char nred, unsigned char ngreen, unsigned char nblue)\n{\n\tint cnt1, cnt2, nypos;\n\tunsigned thispix;\n\tunsigned char *ptr;\n\n\tthispix = fb_pixel_value(nred, ngreen, nblue);\n\n\tcnt1 = ny2pos - ny1pos;\n\tnypos = ny1pos;\n\tdo {\n\t\tptr = G.addr + nypos * G.scr_fix.line_length + nx1pos * G.bytes_per_pixel;\n\t\tcnt2 = nx2pos - nx1pos;\n\t\tdo {\n\t\t\tfb_write_pixel(ptr, thispix);\n\t\t\tptr += G.bytes_per_pixel;\n\t\t} while (--cnt2 >= 0);\n\n\t\tnypos++;\n\t} while (--cnt1 >= 0);\n}",
        "parsed_output": "long long sub_4173E7(\n        int startX,\n        int startY,\n        int endX,\n        int endY,\n        unsigned char param5,\n        unsigned char param6,\n        unsigned char param7)\n{\n  long long finalResult;\n  int processedParams;\n  long long currentAddress;\n  int currentY;\n  int currentX;\n  int deltaX;\n\n  processedParams = sub_417020(param5, param6, param7);\n  deltaX = endY - startY;\n  currentY = startY;\n  do\n  {\n    currentAddress = *(_QWORD *)qword_75D408\n        + (unsigned int)(*((_DWORD *)qword_75D408 + 64) * currentY)\n        + (unsigned long long)(unsigned int)(*((_DWORD *)qword_75D408 + 72) * startX);\n    currentX = endX - startX;\n    do\n    {\n      sub_417106(currentAddress, processedParams);\n      finalResult = *((unsigned int *)qword_75D408 + 72);\n      currentAddress += finalResult;\n      --currentX;\n    }\n    while ( currentX >= 0 );\n    ++currentY;\n    --deltaX;\n  }\n  while ( deltaX >= 0 );\n  return finalResult;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4173E7(\n        int a1,\n        int a2,\n        int a3,\n        int a4,\n        unsigned __int8 a5,\n        unsigned __int8 a6,\n        unsigned __int8 a7)\n{\n  __int64 result; // rax\n  int v10; // [rsp+24h] [rbp-1Ch]\n  __int64 v11; // [rsp+28h] [rbp-18h]\n  int v12; // [rsp+34h] [rbp-Ch]\n  int v13; // [rsp+38h] [rbp-8h]\n  int v14; // [rsp+3Ch] [rbp-4h]\n\n  v10 = sub_417020(a5, a6, a7);\n  v14 = a4 - a2;\n  v12 = a2;\n  do\n  {\n    v11 = *(_QWORD *)qword_75D408\n        + (unsigned int)(*((_DWORD *)qword_75D408 + 64) * v12)\n        + (unsigned __int64)(unsigned int)(*((_DWORD *)qword_75D408 + 72) * a1);\n    v13 = a3 - a1;\n    do\n    {\n      sub_417106(v11, v10);\n      result = *((unsigned int *)qword_75D408 + 72);\n      v11 += result;\n      --v13;\n    }\n    while ( v13 >= 0 );\n    ++v12;\n    --v14;\n  }\n  while ( v14 >= 0 );\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl fb_drawfullrectangle(\n        int nx1pos,\n        int ny1pos,\n        int nx2pos,\n        int ny2pos,\n        unsigned __int8 nred,\n        unsigned __int8 ngreen,\n        unsigned __int8 nblue)\n{\n  unsigned int thispix; // [rsp+24h] [rbp-1Ch]\n  unsigned __int8 *ptr; // [rsp+28h] [rbp-18h]\n  int nypos; // [rsp+34h] [rbp-Ch]\n  int cnt2; // [rsp+38h] [rbp-8h]\n  int cnt1; // [rsp+3Ch] [rbp-4h]\n\n  thispix = fb_pixel_value(nred, ngreen, nblue);\n  cnt1 = ny2pos - ny1pos;\n  nypos = ny1pos;\n  do\n  {\n    ptr = (unsigned __int8 *)(*(_QWORD *)&ptr_to_globals->timeout\n                            + (unsigned int)(*(_DWORD *)&ptr_to_globals->line_buf[100] * nypos)\n                            + (unsigned __int64)(ptr_to_globals[1].timeout * nx1pos));\n    cnt2 = nx2pos - nx1pos;\n    do\n    {\n      fb_write_pixel(ptr, thispix);\n      ptr += ptr_to_globals[1].timeout;\n      --cnt2;\n    }\n    while ( cnt2 >= 0 );\n    ++nypos;\n    --cnt1;\n  }\n  while ( cnt1 >= 0 );\n}\n",
        "similarity_score_unixcoder": 0.5077934861183167,
        "similarity_score_baseline_stripped": 0.5076518058776855,
        "similarity_score_baseline_debug": 0.8549080491065979
    },
    {
        "func_name": "route_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_44054D(int a1, const char **a2, __int64 a3, int a4, int a5, int a6)\n{\n  char *v6; // rdi\n  unsigned int v7; // eax\n  const char **v9; // [rsp+0h] [rbp-30h] BYREF\n  int v10; // [rsp+Ch] [rbp-24h]\n  char *s1; // [rsp+10h] [rbp-20h] BYREF\n  int v12; // [rsp+18h] [rbp-18h]\n  unsigned int v13; // [rsp+1Ch] [rbp-14h]\n  const char **v14; // [rsp+20h] [rbp-10h]\n  int v15; // [rsp+2Ch] [rbp-4h]\n\n  v10 = a1;\n  v9 = a2;\n  v14 = a2;\n  while ( *++v14 )\n  {\n    if ( !strcmp(*v14, \"-net\") || !strcmp(*v14, \"-host\") )\n      **v14 = 35;\n  }\n  v15 = sub_4FA1EF((_DWORD)v9, (unsigned int)\"A:ne\", (unsigned int)&s1, a4, a5, a6);\n  if ( (v15 & 1) != 0 && strcmp(s1, \"inet\") )\n  {\n    v6 = s1;\n    if ( strcmp(s1, \"inet6\") )\n      sub_407F64(v6);\n    v15 |= 8u;\n  }\n  v9 += optind;\n  if ( !*v9 )\n  {\n    if ( (v15 & 2) != 0 )\n      v7 = 4095;\n    else\n      v7 = 0;\n    v13 = v7;\n    if ( (v15 & 8) != 0 )\n      sub_4402AB();\n    else\n      sub_43FFFF(v13, v15 & 4);\n    sub_4F93C9(0LL);\n  }\n  v12 = sub_43F5F7(byte_51A67D, &v9);\n  if ( !v12 || !*v9 )\n    sub_407F64(byte_51A67D);\n  if ( (v15 & 8) != 0 )\n    sub_43FC83(v12, (__int64)v9);\n  else\n    sub_43F6BD(v12, v9);\n  return 0LL;\n}\n",
        "output": "```c\n__int64 __fastcall processArguments(int argc, const char **argv, __int64 a3, int a4, int a5, int a6)\n{\n  char *argValue; // rdi\n  unsigned int flagValue; // eax\n  const char **currentArg; // [rsp+0h] [rbp-30h] BYREF\n  int argIndex; // [rsp+Ch] [rbp-24h]\n  char *optionValue; // [rsp+10h] [rbp-20h] BYREF\n  int result; // [rsp+18h] [rbp-18h]\n  unsigned int errorCode; // [rsp+1Ch] [rbp-14h]\n  const char **argIterator; // [rsp+20h] [rbp-10h]\n  int statusFlags; // [rsp+2Ch] [rbp-4h]\n\n  argIndex = argc;\n  currentArg = argv;\n  argIterator = argv;\n  while ( *++argIterator )\n  {\n    if ( !strcmp(*argIterator, \"-net\") || !strcmp(*argIterator, \"-host\") )\n      **argIterator = '#';\n  }\n  statusFlags = sub_4FA1EF((_DWORD)currentArg, (unsigned int)\"A:ne\", (unsigned int)&optionValue, a4, a5, a6);\n  if ( (statusFlags & 1) != 0 && strcmp(optionValue, \"inet\") )\n  {\n    argValue = optionValue;\n    if ( strcmp(optionValue, \"inet6\") )\n      sub_407F64(argValue);\n    statusFlags |= 8u;\n  }\n  currentArg += optind;\n  if ( !*currentArg )\n  {\n    if ( (statusFlags & 2) != 0 )\n      flagValue = 4095;\n    else\n      flagValue = 0;\n    errorCode = flagValue;\n    if ( (statusFlags & 8) != 0 )\n      sub_4402AB();\n    else\n      sub_43FFFF(errorCode, statusFlags & 4);\n    sub_4F93C9(0LL);\n  }\n  result = sub_43F5F7(byte_51A67D, &currentArg);\n  if ( !result || !*currentArg )\n    sub_407F64(byte_51A67D);\n  if ( (statusFlags & 8) != 0 )\n    sub_43FC83(result, (__int64)currentArg);\n  else\n    sub_43F6BD(result, currentArg);\n  return 0LL;\n}\n```",
        "source_code": "int route_main(int argc UNUSED_PARAM, char **argv)\n{\n\tunsigned opt;\n\tint what;\n\tchar *family;\n\tchar **p;\n\n\t/* First, remap '-net' and '-host' to avoid getopt problems. */\n\tp = argv;\n\twhile (*++p) {\n\t\tif (strcmp(*p, \"-net\") == 0 || strcmp(*p, \"-host\") == 0) {\n\t\t\tp[0][0] = '#';\n\t\t}\n\t}\n\n\topt = getopt32(argv, \"A:ne\", &family);\n\n\tif ((opt & ROUTE_OPT_A) && strcmp(family, \"inet\") != 0) {\n#if ENABLE_FEATURE_IPV6\n\t\tif (strcmp(family, \"inet6\") == 0) {\n\t\t\topt |= ROUTE_OPT_INET6;\t/* Set flag for ipv6. */\n\t\t} else\n#endif\n\t\tbb_show_usage();\n\t}\n\n\targv += optind;\n\n\t/* No more args means display the routing table. */\n\tif (!*argv) {\n\t\tint noresolve = (opt & ROUTE_OPT_n) ? 0x0fff : 0;\n#if ENABLE_FEATURE_IPV6\n\t\tif (opt & ROUTE_OPT_INET6)\n\t\t\tINET6_displayroutes();\n\t\telse\n#endif\n\t\t\tbb_displayroutes(noresolve, opt & ROUTE_OPT_e);\n\n\t\tfflush_stdout_and_exit(EXIT_SUCCESS);\n\t}\n\n\t/* Check verb.  At the moment, must be add, del, or delete. */\n\twhat = kw_lookup(tbl_verb, &argv);\n\tif (!what || !*argv) {\t\t/* Unknown verb or no more args. */\n\t\tbb_show_usage();\n\t}\n\n#if ENABLE_FEATURE_IPV6\n\tif (opt & ROUTE_OPT_INET6)\n\t\tINET6_setroute(what, argv);\n\telse\n#endif\n\t\tINET_setroute(what, argv);\n\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "__int64 __fastcall processArguments(int argc, const char **argv, __int64 a3, int a4, int a5, int a6)\n{\n  char *argValue; // rdi\n  unsigned int flagValue; // eax\n  const char **currentArg; // [rsp+0h] [rbp-30h] BYREF\n  int argIndex; // [rsp+Ch] [rbp-24h]\n  char *optionValue; // [rsp+10h] [rbp-20h] BYREF\n  int result; // [rsp+18h] [rbp-18h]\n  unsigned int errorCode; // [rsp+1Ch] [rbp-14h]\n  const char **argIterator; // [rsp+20h] [rbp-10h]\n  int statusFlags; // [rsp+2Ch] [rbp-4h]\n\n  argIndex = argc;\n  currentArg = argv;\n  argIterator = argv;\n  while ( *++argIterator )\n  {\n    if ( !strcmp(*argIterator, \"-net\") || !strcmp(*argIterator, \"-host\") )\n      **argIterator = '#';\n  }\n  statusFlags = sub_4FA1EF((_DWORD)currentArg, (unsigned int)\"A:ne\", (unsigned int)&optionValue, a4, a5, a6);\n  if ( (statusFlags & 1) != 0 && strcmp(optionValue, \"inet\") )\n  {\n    argValue = optionValue;\n    if ( strcmp(optionValue, \"inet6\") )\n      sub_407F64(argValue);\n    statusFlags |= 8u;\n  }\n  currentArg += optind;\n  if ( !*currentArg )\n  {\n    if ( (statusFlags & 2) != 0 )\n      flagValue = 4095;\n    else\n      flagValue = 0;\n    errorCode = flagValue;\n    if ( (statusFlags & 8) != 0 )\n      sub_4402AB();\n    else\n      sub_43FFFF(errorCode, statusFlags & 4);\n    sub_4F93C9(0LL);\n  }\n  result = sub_43F5F7(byte_51A67D, &currentArg);\n  if ( !result || !*currentArg )\n    sub_407F64(byte_51A67D);\n  if ( (statusFlags & 8) != 0 )\n    sub_43FC83(result, (__int64)currentArg);\n  else\n    sub_43F6BD(result, currentArg);\n  return 0LL;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_44054D(int a1, const char **a2, __int64 a3, int a4, int a5, int a6)\n{\n  char *v6; // rdi\n  unsigned int v7; // eax\n  const char **v9; // [rsp+0h] [rbp-30h] BYREF\n  int v10; // [rsp+Ch] [rbp-24h]\n  char *s1; // [rsp+10h] [rbp-20h] BYREF\n  int v12; // [rsp+18h] [rbp-18h]\n  unsigned int v13; // [rsp+1Ch] [rbp-14h]\n  const char **v14; // [rsp+20h] [rbp-10h]\n  int v15; // [rsp+2Ch] [rbp-4h]\n\n  v10 = a1;\n  v9 = a2;\n  v14 = a2;\n  while ( *++v14 )\n  {\n    if ( !strcmp(*v14, \"-net\") || !strcmp(*v14, \"-host\") )\n      **v14 = 35;\n  }\n  v15 = sub_4FA1EF((_DWORD)v9, (unsigned int)\"A:ne\", (unsigned int)&s1, a4, a5, a6);\n  if ( (v15 & 1) != 0 && strcmp(s1, \"inet\") )\n  {\n    v6 = s1;\n    if ( strcmp(s1, \"inet6\") )\n      sub_407F64(v6);\n    v15 |= 8u;\n  }\n  v9 += optind;\n  if ( !*v9 )\n  {\n    if ( (v15 & 2) != 0 )\n      v7 = 4095;\n    else\n      v7 = 0;\n    v13 = v7;\n    if ( (v15 & 8) != 0 )\n      sub_4402AB();\n    else\n      sub_43FFFF(v13, v15 & 4);\n    sub_4F93C9(0LL);\n  }\n  v12 = sub_43F5F7(byte_51A67D, &v9);\n  if ( !v12 || !*v9 )\n    sub_407F64(byte_51A67D);\n  if ( (v15 & 8) != 0 )\n    sub_43FC83(v12, (__int64)v9);\n  else\n    sub_43F6BD(v12, v9);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl route_main(int argc, char **argv)\n{\n  int v2; // eax\n  char **argva; // [rsp+0h] [rbp-30h] BYREF\n  int argca; // [rsp+Ch] [rbp-24h]\n  char *family; // [rsp+10h] [rbp-20h] BYREF\n  int what; // [rsp+18h] [rbp-18h]\n  int noresolve; // [rsp+1Ch] [rbp-14h]\n  char **p; // [rsp+20h] [rbp-10h]\n  unsigned int opt; // [rsp+2Ch] [rbp-4h]\n\n  argca = argc;\n  argva = argv;\n  p = argv;\n  while ( *++p )\n  {\n    if ( !strcmp(*p, \"-net\") || !strcmp(*p, \"-host\") )\n      **p = 35;\n  }\n  opt = getopt32(argva, \"A:ne\", &family);\n  if ( (opt & 1) != 0 && strcmp(family, \"inet\") )\n  {\n    if ( strcmp(family, \"inet6\") )\n      bb_show_usage();\n    opt |= 8u;\n  }\n  argva += optind;\n  if ( !*argva )\n  {\n    if ( (opt & 2) != 0 )\n      v2 = 4095;\n    else\n      v2 = 0;\n    noresolve = v2;\n    if ( (opt & 8) != 0 )\n      INET6_displayroutes();\n    else\n      bb_displayroutes(noresolve, opt & 4);\n    fflush_stdout_and_exit(0);\n  }\n  what = kw_lookup(tbl_verb, &argva);\n  if ( !what || !*argva )\n    bb_show_usage();\n  if ( (opt & 8) != 0 )\n    INET6_setroute(what, argva);\n  else\n    INET_setroute(what, argva);\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.6566594243049622,
        "similarity_score_baseline_stripped": 0.5866158604621887,
        "similarity_score_baseline_debug": 0.9123625159263611
    },
    {
        "func_name": "fix_partition_table_order",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint sub_4932AD()\n{\n  char *v1; // rax\n  __int64 v2; // rdx\n  _QWORD *v3; // rcx\n  _QWORD *v4; // rcx\n  __int64 v5; // [rsp+0h] [rbp-50h]\n  __int64 v6; // [rsp+8h] [rbp-48h]\n  int v7; // [rsp+1Ch] [rbp-34h] BYREF\n  _QWORD *v8; // [rsp+20h] [rbp-30h]\n  _QWORD *v9; // [rsp+28h] [rbp-28h]\n  __int64 v10; // [rsp+30h] [rbp-20h]\n  char *v11; // [rsp+38h] [rbp-18h]\n  __int64 v12; // [rsp+40h] [rbp-10h]\n  int v13; // [rsp+4Ch] [rbp-4h]\n\n  if ( !(unsigned int)sub_492E03(0LL) )\n    return puts(\"Ordering is already correct\\n\");\n  while ( 1 )\n  {\n    v13 = sub_492E03(&v7);\n    if ( !v13 || v13 > 3 )\n      break;\n    v12 = (__int64)qword_75D408 + 40 * v13 + 2504;\n    v1 = (char *)qword_75D408 + 40 * v7 + 2496;\n    v11 = v1 + 8;\n    v10 = *((_QWORD *)qword_75D408 + 5 * v13 + 314);\n    *((_QWORD *)qword_75D408 + 5 * v13 + 314) = *((_QWORD *)v1 + 2);\n    *((_QWORD *)v11 + 1) = v10;\n    v9 = *(_QWORD **)v12;\n    v8 = *(_QWORD **)v11;\n    v5 = *v9;\n    v6 = v9[1];\n    v2 = v8[1];\n    v3 = v9;\n    *v9 = *v8;\n    v3[1] = v2;\n    v4 = v8;\n    *v8 = v5;\n    v4[1] = v6;\n    v11[32] = 1;\n    *(_BYTE *)(v12 + 32) = v11[32];\n  }\n  if ( v13 )\n    sub_492ED3();\n  return puts(\"Done.\");\n}\n",
        "output": "```c\nint reorderItems()\n{\n  int index; // Temporary variable to hold index\n  __int64 itemAddress; // Temporary variable to hold item address\n  __int64 *currentItem; // Pointer to current item\n  __int64 *nextItem; // Pointer to next item\n  __int64 currentItemValue; // Temporary variable to hold current item value\n  __int64 nextItemValue; // Temporary variable to hold next item value\n  int currentItemIndex; // Temporary variable to hold current item index\n  char *currentItemFlag; // Pointer to current item flag\n  __int64 currentItemExtra; // Temporary variable to hold current item extra data\n  int status; // Status of the reorder operation\n\n  if (!checkOrder(0LL))\n    return puts(\"Ordering is already correct\\n\");\n\n  while (1)\n  {\n    status = checkOrder(&index);\n    if (!status || status > 3)\n      break;\n\n    itemAddress = (__int64)baseAddress + 40 * status + 2504;\n    char *baseItem = (char *)baseAddress + 40 * index + 2496;\n    currentItemFlag = baseItem + 8;\n    currentItemExtra = *((__int64 *)baseAddress + 5 * status + 314);\n    *((__int64 *)baseAddress + 5 * status + 314) = *((__int64 *)baseItem + 2);\n    *((__int64 *)(currentItemFlag + 8)) = currentItemExtra;\n\n    nextItem = *(__int64 **)itemAddress;\n    currentItem = *(__int64 **)currentItemFlag;\n    currentItemValue = *nextItem;\n    nextItemValue = nextItem[1];\n    itemAddress = currentItem[1];\n\n    *nextItem = *currentItem;\n    nextItem[1] = itemAddress;\n    *currentItem = currentItemValue;\n    currentItem[1] = nextItemValue;\n\n    currentItemFlag[32] = 1;\n    *(_BYTE *)(itemAddress + 32) = currentItemFlag[32];\n  }\n\n  if (status)\n    handleError();\n\n  return puts(\"Done.\");\n}\n```",
        "source_code": "static void\nfix_partition_table_order(void)\n{\n\tstruct pte *pei, *pek;\n\tint i,k;\n\n\tif (!wrong_p_order(NULL)) {\n\t\tprintf(\"Ordering is already correct\\n\\n\");\n\t\treturn;\n\t}\n\n\twhile ((i = wrong_p_order(&k)) != 0 && i < 4) {\n\t\t/* partition i should have come earlier, move it */\n\t\t/* We have to move data in the MBR */\n\t\tstruct partition *pi, *pk, *pe, pbuf;\n\t\tpei = &ptes[i];\n\t\tpek = &ptes[k];\n\n\t\tpe = pei->ext_pointer;\n\t\tpei->ext_pointer = pek->ext_pointer;\n\t\tpek->ext_pointer = pe;\n\n\t\tpi = pei->part_table;\n\t\tpk = pek->part_table;\n\n\t\tmemmove(&pbuf, pi, sizeof(struct partition));\n\t\tmemmove(pi, pk, sizeof(struct partition));\n\t\tmemmove(pk, &pbuf, sizeof(struct partition));\n\n\t\tpei->changed = pek->changed = 1;\n\t}\n\n\tif (i)\n\t\tfix_chain_of_logicals();\n\n\tprintf(\"Done.\\n\");\n}",
        "parsed_output": "int reorderItems()\n{\n  int index; // Temporary variable to hold index\n  __int64 itemAddress; // Temporary variable to hold item address\n  __int64 *currentItem; // Pointer to current item\n  __int64 *nextItem; // Pointer to next item\n  __int64 currentItemValue; // Temporary variable to hold current item value\n  __int64 nextItemValue; // Temporary variable to hold next item value\n  int currentItemIndex; // Temporary variable to hold current item index\n  char *currentItemFlag; // Pointer to current item flag\n  __int64 currentItemExtra; // Temporary variable to hold current item extra data\n  int status; // Status of the reorder operation\n\n  if (!checkOrder(0LL))\n    return puts(\"Ordering is already correct\\n\");\n\n  while (1)\n  {\n    status = checkOrder(&index);\n    if (!status || status > 3)\n      break;\n\n    itemAddress = (__int64)baseAddress + 40 * status + 2504;\n    char *baseItem = (char *)baseAddress + 40 * index + 2496;\n    currentItemFlag = baseItem + 8;\n    currentItemExtra = *((__int64 *)baseAddress + 5 * status + 314);\n    *((__int64 *)baseAddress + 5 * status + 314) = *((__int64 *)baseItem + 2);\n    *((__int64 *)(currentItemFlag + 8)) = currentItemExtra;\n\n    nextItem = *(__int64 **)itemAddress;\n    currentItem = *(__int64 **)currentItemFlag;\n    currentItemValue = *nextItem;\n    nextItemValue = nextItem[1];\n    itemAddress = currentItem[1];\n\n    *nextItem = *currentItem;\n    nextItem[1] = itemAddress;\n    *currentItem = currentItemValue;\n    currentItem[1] = nextItemValue;\n\n    currentItemFlag[32] = 1;\n    *(_BYTE *)(itemAddress + 32) = currentItemFlag[32];\n  }\n\n  if (status)\n    handleError();\n\n  return puts(\"Done.\");\n}",
        "baseline_code_stripped": "int sub_4932AD()\n{\n  char *v1; // rax\n  __int64 v2; // rdx\n  _QWORD *v3; // rcx\n  _QWORD *v4; // rcx\n  __int64 v5; // [rsp+0h] [rbp-50h]\n  __int64 v6; // [rsp+8h] [rbp-48h]\n  int v7; // [rsp+1Ch] [rbp-34h] BYREF\n  _QWORD *v8; // [rsp+20h] [rbp-30h]\n  _QWORD *v9; // [rsp+28h] [rbp-28h]\n  __int64 v10; // [rsp+30h] [rbp-20h]\n  char *v11; // [rsp+38h] [rbp-18h]\n  __int64 v12; // [rsp+40h] [rbp-10h]\n  int v13; // [rsp+4Ch] [rbp-4h]\n\n  if ( !(unsigned int)sub_492E03(0LL) )\n    return puts(\"Ordering is already correct\\n\");\n  while ( 1 )\n  {\n    v13 = sub_492E03(&v7);\n    if ( !v13 || v13 > 3 )\n      break;\n    v12 = (__int64)qword_75D408 + 40 * v13 + 2504;\n    v1 = (char *)qword_75D408 + 40 * v7 + 2496;\n    v11 = v1 + 8;\n    v10 = *((_QWORD *)qword_75D408 + 5 * v13 + 314);\n    *((_QWORD *)qword_75D408 + 5 * v13 + 314) = *((_QWORD *)v1 + 2);\n    *((_QWORD *)v11 + 1) = v10;\n    v9 = *(_QWORD **)v12;\n    v8 = *(_QWORD **)v11;\n    v5 = *v9;\n    v6 = v9[1];\n    v2 = v8[1];\n    v3 = v9;\n    *v9 = *v8;\n    v3[1] = v2;\n    v4 = v8;\n    *v8 = v5;\n    v4[1] = v6;\n    v11[32] = 1;\n    *(_BYTE *)(v12 + 32) = v11[32];\n  }\n  if ( v13 )\n    sub_492ED3();\n  return puts(\"Done.\");\n}\n",
        "baseline_code_debug": "void __cdecl fix_partition_table_order()\n{\n  char *v0; // rax\n  __int64 v1; // rdx\n  partition *v2; // rcx\n  partition pbuf; // [rsp+0h] [rbp-50h]\n  int k; // [rsp+1Ch] [rbp-34h] BYREF\n  partition *pk; // [rsp+20h] [rbp-30h]\n  partition *pi; // [rsp+28h] [rbp-28h]\n  partition *pe; // [rsp+30h] [rbp-20h]\n  pte *pek; // [rsp+38h] [rbp-18h]\n  pte *pei; // [rsp+40h] [rbp-10h]\n  int i; // [rsp+4Ch] [rbp-4h]\n\n  if ( wrong_p_order(0LL) )\n  {\n    while ( 1 )\n    {\n      i = wrong_p_order(&k);\n      if ( !i || i > 3 )\n        break;\n      pei = (pte *)&ptr_to_globals[8].line_buf[40 * i + 44];\n      v0 = &ptr_to_globals[8].line_buf[40 * k + 36];\n      pek = (pte *)(v0 + 8);\n      pe = *(partition **)&ptr_to_globals[8].line_buf[40 * i + 52];\n      *(_QWORD *)&ptr_to_globals[8].line_buf[40 * i + 52] = *((_QWORD *)v0 + 2);\n      pek->ext_pointer = pe;\n      pi = pei->part_table;\n      pk = pek->part_table;\n      pbuf = *pi;\n      v1 = *(_QWORD *)pk->start4;\n      v2 = pi;\n      *(_QWORD *)&pi->boot_ind = *(_QWORD *)&pk->boot_ind;\n      *(_QWORD *)v2->start4 = v1;\n      *pk = pbuf;\n      pek->changed = 1;\n      pei->changed = pek->changed;\n    }\n    if ( i )\n      fix_chain_of_logicals();\n    puts(\"Done.\");\n  }\n  else\n  {\n    puts(\"Ordering is already correct\\n\");\n  }\n}\n",
        "similarity_score_unixcoder": 0.6029708981513977,
        "similarity_score_baseline_stripped": 0.46154457330703735,
        "similarity_score_baseline_debug": 0.7745316028594971
    },
    {
        "func_name": "rmescapes",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_473CD2(const char *a1, char a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // rax\n  const char *v8; // rdx\n  char *v9; // rax\n  char *s; // [rsp+8h] [rbp-48h]\n  int v11; // [rsp+1Ch] [rbp-34h]\n  __int64 v12; // [rsp+20h] [rbp-30h]\n  size_t n; // [rsp+28h] [rbp-28h]\n  int v14; // [rsp+30h] [rbp-20h]\n  int v15; // [rsp+34h] [rbp-1Ch]\n  char *v16; // [rsp+38h] [rbp-18h]\n  const char *dest; // [rsp+40h] [rbp-10h]\n  const char *v18; // [rsp+48h] [rbp-8h]\n\n  s = (char *)a1;\n  v18 = strpbrk(a1, &byte_51DF10);\n  if ( !v18 )\n    return a1;\n  dest = v18;\n  v16 = (char *)a1;\n  if ( (a2 & 1) != 0 )\n  {\n    n = v18 - a1;\n    v3 = strlen(v18);\n    v12 = v3 + v18 - a1 + 1;\n    if ( (a2 & 8) != 0 )\n    {\n      v11 = (_DWORD)a1 - *(_QWORD *)(qword_75D428 + 16);\n      v16 = (char *)sub_46ECB9(v12, qword_75AFC8, qword_75AFC8, v4, v5, v6);\n      s = (char *)(*(_QWORD *)(qword_75D428 + 16) + v11);\n      v18 = &s[n];\n    }\n    else\n    {\n      v16 = (a2 & 0x10) != 0\n          ? (char *)sub_40A05F(v12, (__int64)&byte_51DF10)\n          : (char *)sub_46E6A8(v12, (__int64)&byte_51DF10, v3, v4, v5, v6);\n    }\n    dest = v16;\n    if ( n )\n      dest = (char *)memcpy(v16, s, n) + n;\n  }\n  v15 = ~a2 & 4;\n  v14 = a2 & 2;\n  while ( *v18 )\n  {\n    if ( *v18 == -120 )\n    {\n      v15 = ~v15;\n      ++v18;\n      v14 = a2 & 2;\n    }\n    else\n    {\n      if ( *v18 == 92 )\n      {\n        v14 = 0;\n      }\n      else\n      {\n        if ( *v18 == -127 )\n        {\n          ++v18;\n          if ( v14 )\n          {\n            if ( v15 && *v18 != 47 )\n            {\n              v7 = (char *)dest++;\n              *v7 = 92;\n            }\n          }\n        }\n        v14 = a2 & 2;\n      }\n      v8 = v18++;\n      v9 = (char *)dest++;\n      *v9 = *v8;\n    }\n  }\n  *dest = 0;\n  if ( (a2 & 8) != 0 )\n    qword_75AFC8 = (__int64)(dest + 1);\n  return v16;\n}\n",
        "output": "const char *transformString(const char *input, char flags)\n{\n  const char *specialCharPos; // Position of special character in input\n  char *output; // Transformed string\n  char *tempInput; // Temporary pointer for input\n  size_t prefixLength; // Length of the unchanged prefix\n  size_t totalLength; // Total length of the transformed string\n  int toggleSlash; // Toggle for backslash\n  int hasEscapeChar; // Flag for escape character\n  char *outputPtr; // Pointer to current position in output\n  const char *inputPtr; // Pointer to current position in input\n\n  tempInput = (char *)input;\n  specialCharPos = strpbrk(input, &byte_51DF10);\n  if (!specialCharPos)\n    return input;\n\n  outputPtr = (char *)input;\n  if (flags & 1)\n  {\n    prefixLength = specialCharPos - input;\n    totalLength = strlen(specialCharPos) + prefixLength + 1;\n    if (flags & 8)\n    {\n      int offset = (int)input - *(_QWORD *)(qword_75D428 + 16);\n      outputPtr = (char *)sub_46ECB9(totalLength);\n      tempInput = (char *)(*(_QWORD *)(qword_75D428 + 16) + offset);\n      specialCharPos = &tempInput[prefixLength];\n    }\n    else\n    {\n      outputPtr = (flags & 0x10) ? (char *)sub_40A05F(totalLength) : (char *)sub_46E6A8(totalLength);\n    }\n    output = outputPtr;\n    if (prefixLength)\n      outputPtr = (char *)memcpy(outputPtr, tempInput, prefixLength) + prefixLength;\n  }\n\n  toggleSlash = ~(flags & 4);\n  hasEscapeChar = flags & 2;\n  while (*specialCharPos)\n  {\n    if (*specialCharPos == -120)\n    {\n      toggleSlash = ~toggleSlash;\n      ++specialCharPos;\n      hasEscapeChar = flags & 2;\n    }\n    else\n    {\n      if (*specialCharPos == 92)\n      {\n        hasEscapeChar = 0;\n      }\n      else\n      {\n        if (*specialCharPos == -127)\n        {\n          ++specialCharPos;\n          if (hasEscapeChar)\n          {\n            if (toggleSlash && *specialCharPos != 47)\n            {\n              *outputPtr++ = 92;\n            }\n          }\n        }\n        hasEscapeChar = flags & 2;\n      }\n      inputPtr = specialCharPos++;\n      *outputPtr++ = *inputPtr;\n    }\n  }\n  *outputPtr = 0;\n  if (flags & 8)\n    qword_75AFC8 = (__int64)(outputPtr + 1);\n\n  return output;\n}",
        "source_code": "static char *\nrmescapes(char *str, int flag)\n{\n\tstatic const char qchars[] ALIGN1 = { CTLESC, CTLQUOTEMARK, '\\0' };\n\n\tchar *p, *q, *r;\n\tunsigned inquotes;\n\tunsigned protect_against_glob;\n\tunsigned globbing;\n\n\tp = strpbrk(str, qchars);\n\tif (!p)\n\t\treturn str;\n\n\tq = p;\n\tr = str;\n\tif (flag & RMESCAPE_ALLOC) {\n\t\tsize_t len = p - str;\n\t\tsize_t fulllen = len + strlen(p) + 1;\n\n\t\tif (flag & RMESCAPE_GROW) {\n\t\t\tint strloc = str - (char *)stackblock();\n\t\t\tr = makestrspace(fulllen, expdest);\n\t\t\t/* p and str may be invalidated by makestrspace */\n\t\t\tstr = (char *)stackblock() + strloc;\n\t\t\tp = str + len;\n\t\t} else if (flag & RMESCAPE_HEAP) {\n\t\t\tr = ckmalloc(fulllen);\n\t\t} else {\n\t\t\tr = stalloc(fulllen);\n\t\t}\n\t\tq = r;\n\t\tif (len > 0) {\n\t\t\tq = (char *)memcpy(q, str, len) + len;\n\t\t}\n\t}\n\n\tinquotes = (flag & RMESCAPE_QUOTED) ^ RMESCAPE_QUOTED;\n\tglobbing = flag & RMESCAPE_GLOB;\n\tprotect_against_glob = globbing;\n\twhile (*p) {\n\t\tif ((unsigned char)*p == CTLQUOTEMARK) {\n// TODO: if no RMESCAPE_QUOTED in flags, inquotes never becomes 0\n// (alternates between RMESCAPE_QUOTED and ~RMESCAPE_QUOTED). Is it ok?\n// Note: both inquotes and protect_against_glob only affect whether\n// CTLESC,<ch> gets converted to <ch> or to \\<ch>\n\t\t\tinquotes = ~inquotes;\n\t\t\tp++;\n\t\t\tprotect_against_glob = globbing;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == '\\\\') {\n\t\t\t/* naked back slash */\n\t\t\tprotect_against_glob = 0;\n\t\t\tgoto copy;\n\t\t}\n\t\tif ((unsigned char)*p == CTLESC) {\n\t\t\tp++;\n\t\t\tif (protect_against_glob && inquotes && *p != '/') {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t}\n\t\t}\n\t\tprotect_against_glob = globbing;\n copy:\n\t\t*q++ = *p++;\n\t}\n\t*q = '\\0';\n\tif (flag & RMESCAPE_GROW) {\n\t\texpdest = r;\n\t\tSTADJUST(q - r + 1, expdest);\n\t}\n\treturn r;\n}",
        "parsed_output": "const char *transformString(const char *input, char flags)\n{\n  const char *specialCharPos; // Position of special character in input\n  char *output; // Transformed string\n  char *tempInput; // Temporary pointer for input\n  size_t prefixLength; // Length of the unchanged prefix\n  size_t totalLength; // Total length of the transformed string\n  int toggleSlash; // Toggle for backslash\n  int hasEscapeChar; // Flag for escape character\n  char *outputPtr; // Pointer to current position in output\n  const char *inputPtr; // Pointer to current position in input\n\n  tempInput = (char *)input;\n  specialCharPos = strpbrk(input, &byte_51DF10);\n  if (!specialCharPos)\n    return input;\n\n  outputPtr = (char *)input;\n  if (flags & 1)\n  {\n    prefixLength = specialCharPos - input;\n    totalLength = strlen(specialCharPos) + prefixLength + 1;\n    if (flags & 8)\n    {\n      int offset = (int)input - *(_QWORD *)(qword_75D428 + 16);\n      outputPtr = (char *)sub_46ECB9(totalLength);\n      tempInput = (char *)(*(_QWORD *)(qword_75D428 + 16) + offset);\n      specialCharPos = &tempInput[prefixLength];\n    }\n    else\n    {\n      outputPtr = (flags & 0x10) ? (char *)sub_40A05F(totalLength) : (char *)sub_46E6A8(totalLength);\n    }\n    output = outputPtr;\n    if (prefixLength)\n      outputPtr = (char *)memcpy(outputPtr, tempInput, prefixLength) + prefixLength;\n  }\n\n  toggleSlash = ~(flags & 4);\n  hasEscapeChar = flags & 2;\n  while (*specialCharPos)\n  {\n    if (*specialCharPos == -120)\n    {\n      toggleSlash = ~toggleSlash;\n      ++specialCharPos;\n      hasEscapeChar = flags & 2;\n    }\n    else\n    {\n      if (*specialCharPos == 92)\n      {\n        hasEscapeChar = 0;\n      }\n      else\n      {\n        if (*specialCharPos == -127)\n        {\n          ++specialCharPos;\n          if (hasEscapeChar)\n          {\n            if (toggleSlash && *specialCharPos != 47)\n            {\n              *outputPtr++ = 92;\n            }\n          }\n        }\n        hasEscapeChar = flags & 2;\n      }\n      inputPtr = specialCharPos++;\n      *outputPtr++ = *inputPtr;\n    }\n  }\n  *outputPtr = 0;\n  if (flags & 8)\n    qword_75AFC8 = (__int64)(outputPtr + 1);\n\n  return output;\n}",
        "baseline_code_stripped": "const char *__fastcall sub_473CD2(const char *a1, char a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // rax\n  const char *v8; // rdx\n  char *v9; // rax\n  char *s; // [rsp+8h] [rbp-48h]\n  int v11; // [rsp+1Ch] [rbp-34h]\n  __int64 v12; // [rsp+20h] [rbp-30h]\n  size_t n; // [rsp+28h] [rbp-28h]\n  int v14; // [rsp+30h] [rbp-20h]\n  int v15; // [rsp+34h] [rbp-1Ch]\n  char *v16; // [rsp+38h] [rbp-18h]\n  const char *dest; // [rsp+40h] [rbp-10h]\n  const char *v18; // [rsp+48h] [rbp-8h]\n\n  s = (char *)a1;\n  v18 = strpbrk(a1, &byte_51DF10);\n  if ( !v18 )\n    return a1;\n  dest = v18;\n  v16 = (char *)a1;\n  if ( (a2 & 1) != 0 )\n  {\n    n = v18 - a1;\n    v3 = strlen(v18);\n    v12 = v3 + v18 - a1 + 1;\n    if ( (a2 & 8) != 0 )\n    {\n      v11 = (_DWORD)a1 - *(_QWORD *)(qword_75D428 + 16);\n      v16 = (char *)sub_46ECB9(v12, qword_75AFC8, qword_75AFC8, v4, v5, v6);\n      s = (char *)(*(_QWORD *)(qword_75D428 + 16) + v11);\n      v18 = &s[n];\n    }\n    else\n    {\n      v16 = (a2 & 0x10) != 0\n          ? (char *)sub_40A05F(v12, (__int64)&byte_51DF10)\n          : (char *)sub_46E6A8(v12, (__int64)&byte_51DF10, v3, v4, v5, v6);\n    }\n    dest = v16;\n    if ( n )\n      dest = (char *)memcpy(v16, s, n) + n;\n  }\n  v15 = ~a2 & 4;\n  v14 = a2 & 2;\n  while ( *v18 )\n  {\n    if ( *v18 == -120 )\n    {\n      v15 = ~v15;\n      ++v18;\n      v14 = a2 & 2;\n    }\n    else\n    {\n      if ( *v18 == 92 )\n      {\n        v14 = 0;\n      }\n      else\n      {\n        if ( *v18 == -127 )\n        {\n          ++v18;\n          if ( v14 )\n          {\n            if ( v15 && *v18 != 47 )\n            {\n              v7 = (char *)dest++;\n              *v7 = 92;\n            }\n          }\n        }\n        v14 = a2 & 2;\n      }\n      v8 = v18++;\n      v9 = (char *)dest++;\n      *v9 = *v8;\n    }\n  }\n  *dest = 0;\n  if ( (a2 & 8) != 0 )\n    qword_75AFC8 = (__int64)(dest + 1);\n  return v16;\n}\n",
        "baseline_code_debug": "char *__cdecl rmescapes(char *str, int flag)\n{\n  char *v3; // rax\n  const char *v4; // rdx\n  char *v5; // rax\n  char *stra; // [rsp+8h] [rbp-48h]\n  int strloc; // [rsp+1Ch] [rbp-34h]\n  size_t fulllen; // [rsp+20h] [rbp-30h]\n  size_t len; // [rsp+28h] [rbp-28h]\n  int protect_against_glob; // [rsp+30h] [rbp-20h]\n  int inquotes; // [rsp+34h] [rbp-1Ch]\n  char *r; // [rsp+38h] [rbp-18h]\n  char *q; // [rsp+40h] [rbp-10h]\n  const char *p; // [rsp+48h] [rbp-8h]\n\n  stra = str;\n  p = strpbrk(str, qchars_9544);\n  if ( !p )\n    return str;\n  q = (char *)p;\n  r = str;\n  if ( (flag & 1) != 0 )\n  {\n    len = p - str;\n    fulllen = strlen(p) + p - str + 1;\n    if ( (flag & 8) != 0 )\n    {\n      strloc = (_DWORD)str - (unsigned __int64)ash_ptr_to_globals_memstack->g_stacknxt;\n      r = makestrspace(fulllen, expdest);\n      stra = &ash_ptr_to_globals_memstack->g_stacknxt[strloc];\n      p = &stra[len];\n    }\n    else\n    {\n      r = (char *)((flag & 0x10) != 0 ? xmalloc(fulllen) : stalloc(fulllen));\n    }\n    q = r;\n    if ( len )\n      q = (char *)memcpy(r, stra, len) + len;\n  }\n  inquotes = ~(_BYTE)flag & 4;\n  protect_against_glob = flag & 2;\n  while ( *p )\n  {\n    if ( *p == -120 )\n    {\n      inquotes = ~inquotes;\n      ++p;\n      protect_against_glob = flag & 2;\n    }\n    else\n    {\n      if ( *p == 92 )\n      {\n        protect_against_glob = 0;\n      }\n      else\n      {\n        if ( *p == -127 )\n        {\n          ++p;\n          if ( protect_against_glob )\n          {\n            if ( inquotes && *p != 47 )\n            {\n              v3 = q++;\n              *v3 = 92;\n            }\n          }\n        }\n        protect_against_glob = flag & 2;\n      }\n      v4 = p++;\n      v5 = q++;\n      *v5 = *v4;\n    }\n  }\n  *q = 0;\n  if ( (flag & 8) != 0 )\n    expdest = q + 1;\n  return r;\n}\n",
        "similarity_score_unixcoder": 0.6612178087234497,
        "similarity_score_baseline_stripped": 0.6050715446472168,
        "similarity_score_baseline_debug": 0.8785691261291504
    },
    {
        "func_name": "recursive_check",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_49828D(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 result; // rax\n  __int64 v8; // [rsp+10h] [rbp-10h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  v6 = 32LL * a1 - 32;\n  v8 = v6 + *((_QWORD *)qword_75D408 + 6);\n  if ( (*(_WORD *)v8 & 0xF000) != 0x4000 )\n    sub_495EC2((__int64)\"internal error\", a2, v6, a4, a5, a6);\n  if ( *(_DWORD *)(v8 + 4) < (unsigned int)(2 * *((char *)qword_75D408 + 4)) )\n  {\n    printf(\"%s: bad directory: size<32\", (const char *)qword_75D408 + 5540);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  for ( i = 0; ; i += *((char *)qword_75D408 + 4) )\n  {\n    result = *(unsigned int *)(v8 + 4);\n    if ( i >= (unsigned int)result )\n      break;\n    sub_497D29(v8, i);\n  }\n  return result;\n}\n",
        "output": "long long sub_49828D(unsigned int index, long long a2, long long a3, long long a4, long long a5, long long a6)\n{\n  long long directoryOffset;\n  long long result;\n  long long entryAddress;\n  unsigned int entrySize;\n  unsigned int i;\n\n  directoryOffset = 32LL * index - 32;\n  entryAddress = directoryOffset + *((long long *)globalVar_75D408 + 6);\n  if ( (*(_WORD *)entryAddress & 0xF000) != 0x4000 )\n    sub_495EC2(\"internal error\", a2, directoryOffset, a4, a5, a6);\n  entrySize = *(_DWORD *)(entryAddress + 4);\n  if ( entrySize < (unsigned int)(2 * *((char *)globalVar_75D408 + 4)) )\n  {\n    printf(\"%s: bad directory: size<32\", (const char *)globalVar_75D408 + 5540);\n    *((_BYTE *)globalVar_75D408 + 2) = 1;\n  }\n  for ( i = 0; i < entrySize; i += *((char *)globalVar_75D408 + 4) )\n  {\n    result = entrySize;\n    sub_497D29(entryAddress, i);\n  }\n  return result;\n}",
        "source_code": "endif\n\nstatic void recursive_check(unsigned ino)\n{\n\tstruct minix1_inode *dir;\n\tunsigned offset;\n\n\tdir = Inode1 + ino;\n\tif (!S_ISDIR(dir->i_mode))\n\t\tdie(\"internal error\");\n\tif (dir->i_size < 2 * dirsize) {\n\t\tprintf(\"%s: bad directory: size<32\", current_name);\n\t\terrors_uncorrected = 1;\n\t}\n\tfor (offset = 0; offset < dir->i_size; offset += dirsize)\n\t\tcheck_file(dir, offset);\n}",
        "parsed_output": "long long sub_49828D(unsigned int index, long long a2, long long a3, long long a4, long long a5, long long a6)\n{\n  long long directoryOffset;\n  long long result;\n  long long entryAddress;\n  unsigned int entrySize;\n  unsigned int i;\n\n  directoryOffset = 32LL * index - 32;\n  entryAddress = directoryOffset + *((long long *)globalVar_75D408 + 6);\n  if ( (*(_WORD *)entryAddress & 0xF000) != 0x4000 )\n    sub_495EC2(\"internal error\", a2, directoryOffset, a4, a5, a6);\n  entrySize = *(_DWORD *)(entryAddress + 4);\n  if ( entrySize < (unsigned int)(2 * *((char *)globalVar_75D408 + 4)) )\n  {\n    printf(\"%s: bad directory: size<32\", (const char *)globalVar_75D408 + 5540);\n    *((_BYTE *)globalVar_75D408 + 2) = 1;\n  }\n  for ( i = 0; i < entrySize; i += *((char *)globalVar_75D408 + 4) )\n  {\n    result = entrySize;\n    sub_497D29(entryAddress, i);\n  }\n  return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_49828D(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 result; // rax\n  __int64 v8; // [rsp+10h] [rbp-10h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  v6 = 32LL * a1 - 32;\n  v8 = v6 + *((_QWORD *)qword_75D408 + 6);\n  if ( (*(_WORD *)v8 & 0xF000) != 0x4000 )\n    sub_495EC2((__int64)\"internal error\", a2, v6, a4, a5, a6);\n  if ( *(_DWORD *)(v8 + 4) < (unsigned int)(2 * *((char *)qword_75D408 + 4)) )\n  {\n    printf(\"%s: bad directory: size<32\", (const char *)qword_75D408 + 5540);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  for ( i = 0; ; i += *((char *)qword_75D408 + 4) )\n  {\n    result = *(unsigned int *)(v8 + 4);\n    if ( i >= (unsigned int)result )\n      break;\n    sub_497D29(v8, i);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl recursive_check(unsigned int ino)\n{\n  minix1_inode *dir; // [rsp+10h] [rbp-10h]\n  unsigned int offset; // [rsp+1Ch] [rbp-4h]\n\n  dir = (minix1_inode *)(32LL * ino - 32 + *(_QWORD *)&ptr_to_globals->numspeed);\n  if ( (dir->i_mode & 0xF000) != 0x4000 )\n    die(\"internal error\");\n  if ( dir->i_size < 2 * *((char *)&ptr_to_globals->timeout + 4) )\n  {\n    printf(\"%s: bad directory: size<32\", (const char *)&ptr_to_globals[19].speeds[4]);\n    BYTE2(ptr_to_globals->timeout) = 1;\n  }\n  for ( offset = 0; offset < dir->i_size; offset += *((char *)&ptr_to_globals->timeout + 4) )\n    check_file(dir, offset);\n}\n",
        "similarity_score_unixcoder": 0.6894203424453735,
        "similarity_score_baseline_stripped": 0.5752251744270325,
        "similarity_score_baseline_debug": 0.7596282958984375
    },
    {
        "func_name": "init_block",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *sub_4AF093()\n{\n  _DWORD *v0; // rax\n  _DWORD *v1; // rdx\n  _DWORD *v2; // rax\n  void *result; // rax\n  int i; // [rsp+0h] [rbp-4h]\n  int j; // [rsp+0h] [rbp-4h]\n  int k; // [rsp+0h] [rbp-4h]\n\n  for ( i = 0; i <= 285; ++i )\n    *((_WORD *)qword_75D408 + 2 * i + 578) = 0;\n  for ( j = 0; j <= 29; ++j )\n    *((_WORD *)qword_75D408 + 2 * j + 1724) = 0;\n  for ( k = 0; k <= 18; ++k )\n    *((_WORD *)qword_75D408 + 2 * k + 2482) = 0;\n  *((_WORD *)qword_75D408 + 1090) = 1;\n  v0 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 1974) = 0;\n  *((_DWORD *)qword_75D408 + 1973) = v0[1974];\n  v1 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 1971) = 0;\n  v2 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 1970) = v1[1971];\n  *((_DWORD *)qword_75D408 + 1969) = v2[1970];\n  *((_BYTE *)qword_75D408 + 7888) = 0;\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 7889) = 1;\n  return result;\n}\n",
        "output": "```c\nvoid *initialize_data_structure()\n{\n  // Define base address of the data structure\n  uint16_t *base = (uint16_t *)qword_75D408;\n\n  // Initialize first section of the data structure\n  for (int i = 0; i <= 285; ++i)\n    base[289 + i] = 0;\n\n  // Initialize second section of the data structure\n  for (int j = 0; j <= 29; ++j)\n    base[862 + j] = 0;\n\n  // Initialize third section of the data structure\n  for (int k = 0; k <= 18; ++k)\n    base[1241 + k] = 0;\n\n  // Set specific values in the data structure\n  base[545] = 1; // Set a specific word to 1\n  base[3948] = 0; // Clear a specific double word\n  base[3947] = base[3948]; // Copy the cleared value\n  base[3946] = 0; // Clear another specific double word\n  base[3945] = base[3946]; // Copy the cleared value\n  base[3944] = base[3945]; // Copy the cleared value again\n\n  // Set specific bytes in the data structure\n  *((uint8_t *)base + 7888) = 0;\n  *((uint8_t *)base + 7889) = 1;\n\n  // Return the base address of the data structure\n  return base;\n}\n```",
        "source_code": "static void init_block(void)\n{\n\tint n; /* iterates over tree elements */\n\n\t/* Initialize the trees. */\n\tfor (n = 0; n < L_CODES; n++)\n\t\tG2.dyn_ltree[n].Freq = 0;\n\tfor (n = 0; n < D_CODES; n++)\n\t\tG2.dyn_dtree[n].Freq = 0;\n\tfor (n = 0; n < BL_CODES; n++)\n\t\tG2.bl_tree[n].Freq = 0;\n\n\tG2.dyn_ltree[END_BLOCK].Freq = 1;\n\tG2.opt_len = G2.static_len = 0;\n\tG2.last_lit = G2.last_dist = G2.last_flags = 0;\n\tG2.flags = 0;\n\tG2.flag_bit = 1;\n}",
        "parsed_output": "void *initialize_data_structure()\n{\n  // Define base address of the data structure\n  uint16_t *base = (uint16_t *)qword_75D408;\n\n  // Initialize first section of the data structure\n  for (int i = 0; i <= 285; ++i)\n    base[289 + i] = 0;\n\n  // Initialize second section of the data structure\n  for (int j = 0; j <= 29; ++j)\n    base[862 + j] = 0;\n\n  // Initialize third section of the data structure\n  for (int k = 0; k <= 18; ++k)\n    base[1241 + k] = 0;\n\n  // Set specific values in the data structure\n  base[545] = 1; // Set a specific word to 1\n  base[3948] = 0; // Clear a specific double word\n  base[3947] = base[3948]; // Copy the cleared value\n  base[3946] = 0; // Clear another specific double word\n  base[3945] = base[3946]; // Copy the cleared value\n  base[3944] = base[3945]; // Copy the cleared value again\n\n  // Set specific bytes in the data structure\n  *((uint8_t *)base + 7888) = 0;\n  *((uint8_t *)base + 7889) = 1;\n\n  // Return the base address of the data structure\n  return base;\n}",
        "baseline_code_stripped": "void *sub_4AF093()\n{\n  _DWORD *v0; // rax\n  _DWORD *v1; // rdx\n  _DWORD *v2; // rax\n  void *result; // rax\n  int i; // [rsp+0h] [rbp-4h]\n  int j; // [rsp+0h] [rbp-4h]\n  int k; // [rsp+0h] [rbp-4h]\n\n  for ( i = 0; i <= 285; ++i )\n    *((_WORD *)qword_75D408 + 2 * i + 578) = 0;\n  for ( j = 0; j <= 29; ++j )\n    *((_WORD *)qword_75D408 + 2 * j + 1724) = 0;\n  for ( k = 0; k <= 18; ++k )\n    *((_WORD *)qword_75D408 + 2 * k + 2482) = 0;\n  *((_WORD *)qword_75D408 + 1090) = 1;\n  v0 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 1974) = 0;\n  *((_DWORD *)qword_75D408 + 1973) = v0[1974];\n  v1 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 1971) = 0;\n  v2 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 1970) = v1[1971];\n  *((_DWORD *)qword_75D408 + 1969) = v2[1970];\n  *((_BYTE *)qword_75D408 + 7888) = 0;\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 7889) = 1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl init_block()\n{\n  globals *v0; // rax\n  globals *v1; // rdx\n  globals *v2; // rax\n  int n; // [rsp+0h] [rbp-4h]\n  int na; // [rsp+0h] [rbp-4h]\n  int nb; // [rsp+0h] [rbp-4h]\n\n  for ( n = 0; n <= 285; ++n )\n    *((_WORD *)&ptr_to_globals[4].timeout + 2 * n + 2) = 0;\n  for ( na = 0; na <= 29; ++na )\n    *(_WORD *)&ptr_to_globals[11].line_buf[4 * na + 124] = 0;\n  for ( nb = 0; nb <= 18; ++nb )\n    LOWORD(ptr_to_globals[17].speeds[nb + 4]) = 0;\n  *(_WORD *)&ptr_to_globals[7].line_buf[8] = 1;\n  v0 = ptr_to_globals;\n  *(_DWORD *)&ptr_to_globals[27].tty_attrs.c_cc[7] = 0;\n  *(_DWORD *)&ptr_to_globals[27].tty_attrs.c_cc[3] = *(_DWORD *)&v0[27].tty_attrs.c_cc[7];\n  v1 = ptr_to_globals;\n  ptr_to_globals[27].tty_attrs.c_lflag = 0;\n  v2 = ptr_to_globals;\n  ptr_to_globals[27].tty_attrs.c_cflag = v1[27].tty_attrs.c_lflag;\n  ptr_to_globals[27].tty_attrs.c_oflag = v2[27].tty_attrs.c_cflag;\n  ptr_to_globals[27].tty_attrs.c_line = 0;\n  ptr_to_globals[27].tty_attrs.c_cc[0] = 1;\n}\n",
        "similarity_score_unixcoder": 0.4955315589904785,
        "similarity_score_baseline_stripped": 0.42569422721862793,
        "similarity_score_baseline_debug": 0.49358752369880676
    },
    {
        "func_name": "open_tty",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_40E349(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  _QWORD *v6; // rbx\n  __int64 v7; // rdx\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  char *v11; // rax\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  char *result; // rax\n  char *v17; // [rsp+8h] [rbp-18h]\n\n  if ( **((_BYTE **)qword_75D408 + 3) == 45 && !*(_BYTE *)(*((_QWORD *)qword_75D408 + 3) + 1LL) )\n  {\n    if ( (fcntl(0, 3) & 3) != 2 )\n      sub_40969E(\"stdin is not open for read/write\", 3LL, v7, v8, v9, v10);\n    v17 = sub_40AD9A(0, 3LL);\n    if ( v17 )\n      *((_QWORD *)qword_75D408 + 3) = v17;\n  }\n  else\n  {\n    if ( **((_BYTE **)qword_75D408 + 3) != 47 )\n    {\n      v6 = qword_75D408;\n      v6[3] = sub_40A6B3(\"/dev/%s\", *((_QWORD *)qword_75D408 + 3), a3, a4, a5, a6);\n    }\n    close(0);\n    sub_40A295(*((const char **)qword_75D408 + 3), 2050);\n    fchown(0, 0, 0);\n    fchmod(0, 0x190u);\n  }\n  v11 = sub_40941B(*((const char **)qword_75D408 + 3));\n  result = sub_40A6B3(\"getty: %s\", (__int64)v11, v12, v13, v14, v15);\n  ident = result;\n  return result;\n}\n",
        "output": "char *configure_tty(__int64 tty_config, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  char *tty_path;\n  char *formatted_msg;\n  char *result;\n  char *new_tty_path;\n\n  if (global_tty_config[3][0] == '-' && global_tty_config[3][1] == '\\0')\n  {\n    if ((fcntl(STDIN_FILENO, F_GETFL) & O_ACCMODE) != O_RDWR)\n      log_error(\"stdin is not open for read/write\", 3LL);\n    new_tty_path = allocate_tty(0, 3LL);\n    if (new_tty_path)\n      global_tty_config[3] = new_tty_path;\n  }\n  else\n  {\n    if (global_tty_config[3][0] != '/')\n    {\n      tty_path = format_string(\"/dev/%s\", global_tty_config[3]);\n      global_tty_config[3] = tty_path;\n    }\n    close(STDIN_FILENO);\n    open_tty(global_tty_config[3], O_RDWR | O_NONBLOCK);\n    fchown(STDIN_FILENO, 0, 0);\n    fchmod(STDIN_FILENO, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);\n  }\n  formatted_msg = format_string(\"getty: %s\", get_tty_name(global_tty_config[3]));\n  ident = formatted_msg;\n  return formatted_msg;\n}",
        "source_code": "static void open_tty(void)\n{\n\t/* Set up new standard input, unless we are given an already opened port */\n\tif (NOT_LONE_DASH(G.tty_name)) {\n\t\tif (G.tty_name[0] != '/')\n\t\t\tG.tty_name = xasprintf(\"/dev/%s\", G.tty_name); /* will leak it */\n\n\t\t/* Open the tty as standard input */\n\t\tdebug(\"open(2)\\n\");\n\t\tclose(0);\n\t\txopen(G.tty_name, O_RDWR | O_NONBLOCK); /* uses fd 0 */\n\n\t\t/* Set proper protections and ownership */\n\t\tfchown(0, 0, 0);        /* 0:0 */\n\t\tfchmod(0, 0620);        /* crw--w---- */\n\t} else {\n\t\tchar *n;\n\t\t/*\n\t\t * Standard input should already be connected to an open port.\n\t\t * Make sure it is open for read/write.\n\t\t */\n\t\tif ((fcntl(0, F_GETFL) & (O_RDWR|O_RDONLY|O_WRONLY)) != O_RDWR)\n\t\t\tbb_error_msg_and_die(\"stdin is not open for read/write\");\n\n\t\t/* Try to get real tty name instead of \"-\" */\n\t\tn = xmalloc_ttyname(0);\n\t\tif (n)\n\t\t\tG.tty_name = n;\n\t}\n\tapplet_name = xasprintf(\"getty: %s\", skip_dev_pfx(G.tty_name));\n}",
        "parsed_output": "char *configure_tty(__int64 tty_config, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  char *tty_path;\n  char *formatted_msg;\n  char *result;\n  char *new_tty_path;\n\n  if (global_tty_config[3][0] == '-' && global_tty_config[3][1] == '\\0')\n  {\n    if ((fcntl(STDIN_FILENO, F_GETFL) & O_ACCMODE) != O_RDWR)\n      log_error(\"stdin is not open for read/write\", 3LL);\n    new_tty_path = allocate_tty(0, 3LL);\n    if (new_tty_path)\n      global_tty_config[3] = new_tty_path;\n  }\n  else\n  {\n    if (global_tty_config[3][0] != '/')\n    {\n      tty_path = format_string(\"/dev/%s\", global_tty_config[3]);\n      global_tty_config[3] = tty_path;\n    }\n    close(STDIN_FILENO);\n    open_tty(global_tty_config[3], O_RDWR | O_NONBLOCK);\n    fchown(STDIN_FILENO, 0, 0);\n    fchmod(STDIN_FILENO, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);\n  }\n  formatted_msg = format_string(\"getty: %s\", get_tty_name(global_tty_config[3]));\n  ident = formatted_msg;\n  return formatted_msg;\n}",
        "baseline_code_stripped": "char *__fastcall sub_40E349(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  _QWORD *v6; // rbx\n  __int64 v7; // rdx\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  char *v11; // rax\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  char *result; // rax\n  char *v17; // [rsp+8h] [rbp-18h]\n\n  if ( **((_BYTE **)qword_75D408 + 3) == 45 && !*(_BYTE *)(*((_QWORD *)qword_75D408 + 3) + 1LL) )\n  {\n    if ( (fcntl(0, 3) & 3) != 2 )\n      sub_40969E(\"stdin is not open for read/write\", 3LL, v7, v8, v9, v10);\n    v17 = sub_40AD9A(0, 3LL);\n    if ( v17 )\n      *((_QWORD *)qword_75D408 + 3) = v17;\n  }\n  else\n  {\n    if ( **((_BYTE **)qword_75D408 + 3) != 47 )\n    {\n      v6 = qword_75D408;\n      v6[3] = sub_40A6B3(\"/dev/%s\", *((_QWORD *)qword_75D408 + 3), a3, a4, a5, a6);\n    }\n    close(0);\n    sub_40A295(*((const char **)qword_75D408 + 3), 2050);\n    fchown(0, 0, 0);\n    fchmod(0, 0x190u);\n  }\n  v11 = sub_40941B(*((const char **)qword_75D408 + 3));\n  result = sub_40A6B3(\"getty: %s\", (__int64)v11, v12, v13, v14, v15);\n  ident = result;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl open_tty()\n{\n  globals *v0; // rbx\n  char *v1; // rax\n  const char *n; // [rsp+8h] [rbp-18h]\n\n  if ( *ptr_to_globals->tty_name == 45 && !*((_BYTE *)ptr_to_globals->tty_name + 1) )\n  {\n    if ( (fcntl(0, 3) & 3) != 2 )\n      bb_error_msg_and_die(\"stdin is not open for read/write\");\n    n = xmalloc_ttyname(0);\n    if ( n )\n      ptr_to_globals->tty_name = n;\n  }\n  else\n  {\n    if ( *ptr_to_globals->tty_name != 47 )\n    {\n      v0 = ptr_to_globals;\n      v0->tty_name = xasprintf(\"/dev/%s\", ptr_to_globals->tty_name);\n    }\n    close(0);\n    xopen(ptr_to_globals->tty_name, 2050);\n    fchown(0, 0, 0);\n    fchmod(0, 0x190u);\n  }\n  v1 = skip_dev_pfx(ptr_to_globals->tty_name);\n  applet_name = xasprintf(\"getty: %s\", v1);\n}\n",
        "similarity_score_unixcoder": 0.7601043581962585,
        "similarity_score_baseline_stripped": 0.5428214073181152,
        "similarity_score_baseline_debug": 0.8190609812736511
    },
    {
        "func_name": "stzalloc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_46E7E7(size_t a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  void *v6; // rax\n\n  v6 = (void *)sub_46E6A8(a1, a2, a3, a4, a5, a6);\n  return memset(v6, 0, a1);\n}\n",
        "output": "```c\nvoid *allocate_and_clear_memory(size_t size, __int64 param1, __int64 param2, __int64 param3, __int64 param4, __int64 param5)\n{\n  void *memory = (void *)allocate_memory(size, param1, param2, param3, param4, param5);\n  return memset(memory, 0, size);\n}\n```",
        "source_code": "static void *\nstzalloc(size_t nbytes)\n{\n\treturn memset(stalloc(nbytes), 0, nbytes);\n}",
        "parsed_output": "void *allocate_and_clear_memory(size_t size, __int64 param1, __int64 param2, __int64 param3, __int64 param4, __int64 param5)\n{\n  void *memory = (void *)allocate_memory(size, param1, param2, param3, param4, param5);\n  return memset(memory, 0, size);\n}",
        "baseline_code_stripped": "void *__fastcall sub_46E7E7(size_t a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  void *v6; // rax\n\n  v6 = (void *)sub_46E6A8(a1, a2, a3, a4, a5, a6);\n  return memset(v6, 0, a1);\n}\n",
        "baseline_code_debug": "void *__cdecl stzalloc(size_t nbytes)\n{\n  void *v1; // rcx\n\n  v1 = stalloc(nbytes);\n  return memset(v1, 0, nbytes);\n}\n",
        "similarity_score_unixcoder": 0.6932093501091003,
        "similarity_score_baseline_stripped": 0.540249764919281,
        "similarity_score_baseline_debug": 0.8589975237846375
    },
    {
        "func_name": "my_xstrtoull",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4CFB20(_BYTE *a1)\n{\n  __int64 v2; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( (unsigned int)sub_4CF9A2(a1, (__int64)&v2, (void (__fastcall *)(_BYTE *, __int64))sub_4CFA37) )\n    return 0LL;\n  return v2;\n}\n",
        "output": "```c\n__int64 __fastcall processInput(_BYTE *input)\n{\n  __int64 result; // Temporary variable to store the result\n\n  // If the function 'sub_4CF9A2' returns a non-zero value, return 0\n  if (sub_4CF9A2(input, &result, sub_4CFA37))\n    return 0LL;\n\n  // Otherwise, return the result obtained from 'sub_4CF9A2'\n  return result;\n}\n```",
        "source_code": "static unsigned long long my_xstrtoull(const char *arg)\n{\n\tunsigned long long result;\n\tif (multiconvert(arg, &result, conv_strtoull))\n\t\tresult = 0;\n\treturn result;\n}",
        "parsed_output": "__int64 __fastcall processInput(_BYTE *input)\n{\n  __int64 result; // Temporary variable to store the result\n\n  // If the function 'sub_4CF9A2' returns a non-zero value, return 0\n  if (sub_4CF9A2(input, &result, sub_4CFA37))\n    return 0LL;\n\n  // Otherwise, return the result obtained from 'sub_4CF9A2'\n  return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4CFB20(_BYTE *a1)\n{\n  __int64 v2; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( (unsigned int)sub_4CF9A2(a1, (__int64)&v2, (void (__fastcall *)(_BYTE *, __int64))sub_4CFA37) )\n    return 0LL;\n  return v2;\n}\n",
        "baseline_code_debug": "unsigned __int64 __cdecl my_xstrtoull(const char *arg)\n{\n  unsigned __int64 result; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( multiconvert(arg, &result, (converter)conv_strtoull) )\n    return 0LL;\n  return result;\n}\n",
        "similarity_score_unixcoder": 0.47999289631843567,
        "similarity_score_baseline_stripped": 0.401692271232605,
        "similarity_score_baseline_debug": 0.79386967420578
    },
    {
        "func_name": "inet_addr_match",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_453311(__int64 a1, __int64 a2, int a3)\n{\n  int v4; // [rsp+Ch] [rbp-34h]\n  int v5; // [rsp+24h] [rbp-1Ch]\n  int v6; // [rsp+28h] [rbp-18h]\n  int v7; // [rsp+2Ch] [rbp-14h]\n  void *s2; // [rsp+30h] [rbp-10h]\n  void *s1; // [rsp+38h] [rbp-8h]\n\n  s1 = (void *)(a1 + 4);\n  s2 = (void *)(a2 + 4);\n  v7 = a3 >> 5;\n  v4 = a3 & 0x1F;\n  if ( a3 >> 5 && memcmp(s1, s2, 4 * v7) )\n    return 0xFFFFFFFFLL;\n  if ( v4 )\n  {\n    v6 = *((_DWORD *)s1 + v7);\n    v5 = *((_DWORD *)s2 + v7);\n    if ( (htonl(-1 << (32 - v4)) & (v5 ^ v6)) != 0 )\n      return 1LL;\n  }\n  return 0LL;\n}\n",
        "output": "long long compareMemoryRegions(long long addr1, long long addr2, int numBits)\n{\n  int numDwords; // Number of full 32-bit words\n  int remainingBits; // Remaining bits after full 32-bit words\n  int dwordFromAddr1; // 32-bit word from addr1\n  int dwordFromAddr2; // 32-bit word from addr2\n  void *ptrToAddr1; // Pointer to addr1 data\n  void *ptrToAddr2; // Pointer to addr2 data\n\n  ptrToAddr1 = (void *)(addr1 + 4);\n  ptrToAddr2 = (void *)(addr2 + 4);\n  numDwords = numBits / 32;\n  remainingBits = numBits % 32;\n\n  if (numDwords && memcmp(ptrToAddr1, ptrToAddr2, 4 * numDwords))\n    return -1;\n\n  if (remainingBits)\n  {\n    dwordFromAddr1 = *((int *)ptrToAddr1 + numDwords);\n    dwordFromAddr2 = *((int *)ptrToAddr2 + numDwords);\n    if ((htonl(~0 << (32 - remainingBits)) & (dwordFromAddr2 ^ dwordFromAddr1)) != 0)\n      return 1;\n  }\n\n  return 0;\n}",
        "source_code": "int inet_addr_match(const inet_prefix *a, const inet_prefix *b, int bits)\n{\n\tconst uint32_t *a1 = a->data;\n\tconst uint32_t *a2 = b->data;\n\tint words = bits >> 5;\n\n\tbits &= 0x1f;\n\n\tif (words)\n\t\tif (memcmp(a1, a2, words << 2))\n\t\t\treturn -1;\n\n\tif (bits) {\n\t\tuint32_t w1, w2;\n\t\tuint32_t mask;\n\n\t\tw1 = a1[words];\n\t\tw2 = a2[words];\n\n\t\tmask = htonl((0xffffffff) << (0x20 - bits));\n\n\t\tif ((w1 ^ w2) & mask)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
        "parsed_output": "long long compareMemoryRegions(long long addr1, long long addr2, int numBits)\n{\n  int numDwords; // Number of full 32-bit words\n  int remainingBits; // Remaining bits after full 32-bit words\n  int dwordFromAddr1; // 32-bit word from addr1\n  int dwordFromAddr2; // 32-bit word from addr2\n  void *ptrToAddr1; // Pointer to addr1 data\n  void *ptrToAddr2; // Pointer to addr2 data\n\n  ptrToAddr1 = (void *)(addr1 + 4);\n  ptrToAddr2 = (void *)(addr2 + 4);\n  numDwords = numBits / 32;\n  remainingBits = numBits % 32;\n\n  if (numDwords && memcmp(ptrToAddr1, ptrToAddr2, 4 * numDwords))\n    return -1;\n\n  if (remainingBits)\n  {\n    dwordFromAddr1 = *((int *)ptrToAddr1 + numDwords);\n    dwordFromAddr2 = *((int *)ptrToAddr2 + numDwords);\n    if ((htonl(~0 << (32 - remainingBits)) & (dwordFromAddr2 ^ dwordFromAddr1)) != 0)\n      return 1;\n  }\n\n  return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_453311(__int64 a1, __int64 a2, int a3)\n{\n  int v4; // [rsp+Ch] [rbp-34h]\n  int v5; // [rsp+24h] [rbp-1Ch]\n  int v6; // [rsp+28h] [rbp-18h]\n  int v7; // [rsp+2Ch] [rbp-14h]\n  void *s2; // [rsp+30h] [rbp-10h]\n  void *s1; // [rsp+38h] [rbp-8h]\n\n  s1 = (void *)(a1 + 4);\n  s2 = (void *)(a2 + 4);\n  v7 = a3 >> 5;\n  v4 = a3 & 0x1F;\n  if ( a3 >> 5 && memcmp(s1, s2, 4 * v7) )\n    return 0xFFFFFFFFLL;\n  if ( v4 )\n  {\n    v6 = *((_DWORD *)s1 + v7);\n    v5 = *((_DWORD *)s2 + v7);\n    if ( (htonl(-1 << (32 - v4)) & (v5 ^ v6)) != 0 )\n      return 1LL;\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl inet_addr_match(const inet_prefix *a, const inet_prefix *b, int bits)\n{\n  int bitsa; // [rsp+Ch] [rbp-34h]\n  uint32_t w2; // [rsp+24h] [rbp-1Ch]\n  uint32_t w1; // [rsp+28h] [rbp-18h]\n  int words; // [rsp+2Ch] [rbp-14h]\n  uint32_t *a2; // [rsp+30h] [rbp-10h]\n  uint32_t *a1; // [rsp+38h] [rbp-8h]\n\n  a1 = a->data;\n  a2 = b->data;\n  words = bits >> 5;\n  bitsa = bits & 0x1F;\n  if ( bits >> 5 && memcmp(a1, a2, 4 * words) )\n    return -1;\n  if ( bitsa )\n  {\n    w1 = a1[words];\n    w2 = a2[words];\n    if ( (htonl(-1 << (32 - bitsa)) & (w2 ^ w1)) != 0 )\n      return 1;\n  }\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.7294727563858032,
        "similarity_score_baseline_stripped": 0.6058030128479004,
        "similarity_score_baseline_debug": 0.8865790963172913
    },
    {
        "func_name": "xmalloc_read",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_507264(int a1, unsigned __int64 *a2)\n{\n  unsigned __int64 v2; // rax\n  struct stat64 stat_buf; // [rsp+10h] [rbp-C0h] BYREF\n  unsigned __int64 v5; // [rsp+A8h] [rbp-28h]\n  unsigned __int64 v6; // [rsp+B0h] [rbp-20h]\n  unsigned __int64 v7; // [rsp+B8h] [rbp-18h]\n  size_t v8; // [rsp+C0h] [rbp-10h]\n  void *ptr; // [rsp+C8h] [rbp-8h]\n\n  if ( a2 )\n    v2 = *a2;\n  else\n    v2 = 2147479552LL;\n  v6 = v2;\n  stat_buf.st_size = 0LL;\n  sub_407E00(a1, &stat_buf);\n  v8 = (stat_buf.st_size | 0x3FF) + 1;\n  v7 = 0LL;\n  ptr = 0LL;\n  while ( 1 )\n  {\n    if ( v6 < v8 )\n      v8 = v6;\n    ptr = sub_40A09E(ptr, v7 + v8 + 1);\n    v5 = sub_40B446(a1, (char *)ptr + v7, v8);\n    if ( v5 == -1LL )\n    {\n      free(ptr);\n      return 0LL;\n    }\n    v7 += v5;\n    if ( v5 < v8 || v6 <= v5 )\n      break;\n    v6 -= v5;\n    v8 = ((v7 >> 3) | 0x3FF) + 1;\n    if ( v8 > 0x10000 )\n      v8 = 0x10000LL;\n  }\n  ptr = sub_40A09E(ptr, v7 + 1);\n  *((_BYTE *)ptr + v7) = 0;\n  if ( a2 )\n    *a2 = v7;\n  return ptr;\n}\n",
        "output": "void *read_file_to_buffer(int file_descriptor, unsigned __int64 *max_bytes)\n{\n  unsigned __int64 bytes_to_read;\n  struct stat64 file_stats;\n  unsigned __int64 read_size;\n  unsigned __int64 total_bytes_read;\n  unsigned __int64 buffer_size;\n  void *buffer;\n\n  bytes_to_read = max_bytes ? *max_bytes : 2147479552LL;\n  file_stats.st_size = 0LL;\n  get_file_stats(file_descriptor, &file_stats);\n  buffer_size = (file_stats.st_size | 0x3FF) + 1;\n  total_bytes_read = 0LL;\n  buffer = NULL;\n\n  while (true)\n  {\n    if (bytes_to_read < buffer_size)\n      buffer_size = bytes_to_read;\n    buffer = resize_buffer(buffer, total_bytes_read + buffer_size + 1);\n    read_size = read_from_file(file_descriptor, (char *)buffer + total_bytes_read, buffer_size);\n    if (read_size == -1LL)\n    {\n      free(buffer);\n      return NULL;\n    }\n    total_bytes_read += read_size;\n    if (read_size < buffer_size || bytes_to_read <= read_size)\n      break;\n    bytes_to_read -= read_size;\n    buffer_size = ((total_bytes_read >> 3) | 0x3FF) + 1;\n    if (buffer_size > 0x10000)\n      buffer_size = 0x10000LL;\n  }\n  buffer = resize_buffer(buffer, total_bytes_read + 1);\n  *((char *)buffer + total_bytes_read) = 0;\n  if (max_bytes)\n    *max_bytes = total_bytes_read;\n  return buffer;\n}",
        "source_code": "FAST_FUNC xmalloc_read(int fd, size_t *maxsz_p)\n{\n\tchar *buf;\n\tsize_t size, rd_size, total;\n\tsize_t to_read;\n\tstruct stat st;\n\n\tto_read = maxsz_p ? *maxsz_p : (INT_MAX - 4095); /* max to read */\n\n\t/* Estimate file size */\n\tst.st_size = 0; /* in case fstat fails, assume 0 */\n\tfstat(fd, &st);\n\t/* /proc/N/stat files report st_size 0 */\n\t/* In order to make such files readable, we add small const */\n\tsize = (st.st_size | 0x3ff) + 1;\n\n\ttotal = 0;\n\tbuf = NULL;\n\twhile (1) {\n\t\tif (to_read < size)\n\t\t\tsize = to_read;\n\t\tbuf = xrealloc(buf, total + size + 1);\n\t\trd_size = full_read(fd, buf + total, size);\n\t\tif ((ssize_t)rd_size == (ssize_t)(-1)) { /* error */\n\t\t\tfree(buf);\n\t\t\treturn NULL;\n\t\t}\n\t\ttotal += rd_size;\n\t\tif (rd_size < size) /* EOF */\n\t\t\tbreak;\n\t\tif (to_read <= rd_size)\n\t\t\tbreak;\n\t\tto_read -= rd_size;\n\t\t/* grow by 1/8, but in [1k..64k] bounds */\n\t\tsize = ((total / 8) | 0x3ff) + 1;\n\t\tif (size > 64*1024)\n\t\t\tsize = 64*1024;\n\t}\n\tbuf = xrealloc(buf, total + 1);\n\tbuf[total] = '\\0';\n\n\tif (maxsz_p)\n\t\t*maxsz_p = total;\n\treturn buf;\n}",
        "parsed_output": "void *read_file_to_buffer(int file_descriptor, unsigned __int64 *max_bytes)\n{\n  unsigned __int64 bytes_to_read;\n  struct stat64 file_stats;\n  unsigned __int64 read_size;\n  unsigned __int64 total_bytes_read;\n  unsigned __int64 buffer_size;\n  void *buffer;\n\n  bytes_to_read = max_bytes ? *max_bytes : 2147479552LL;\n  file_stats.st_size = 0LL;\n  get_file_stats(file_descriptor, &file_stats);\n  buffer_size = (file_stats.st_size | 0x3FF) + 1;\n  total_bytes_read = 0LL;\n  buffer = NULL;\n\n  while (true)\n  {\n    if (bytes_to_read < buffer_size)\n      buffer_size = bytes_to_read;\n    buffer = resize_buffer(buffer, total_bytes_read + buffer_size + 1);\n    read_size = read_from_file(file_descriptor, (char *)buffer + total_bytes_read, buffer_size);\n    if (read_size == -1LL)\n    {\n      free(buffer);\n      return NULL;\n    }\n    total_bytes_read += read_size;\n    if (read_size < buffer_size || bytes_to_read <= read_size)\n      break;\n    bytes_to_read -= read_size;\n    buffer_size = ((total_bytes_read >> 3) | 0x3FF) + 1;\n    if (buffer_size > 0x10000)\n      buffer_size = 0x10000LL;\n  }\n  buffer = resize_buffer(buffer, total_bytes_read + 1);\n  *((char *)buffer + total_bytes_read) = 0;\n  if (max_bytes)\n    *max_bytes = total_bytes_read;\n  return buffer;\n}",
        "baseline_code_stripped": "void *__fastcall sub_507264(int a1, unsigned __int64 *a2)\n{\n  unsigned __int64 v2; // rax\n  struct stat64 stat_buf; // [rsp+10h] [rbp-C0h] BYREF\n  unsigned __int64 v5; // [rsp+A8h] [rbp-28h]\n  unsigned __int64 v6; // [rsp+B0h] [rbp-20h]\n  unsigned __int64 v7; // [rsp+B8h] [rbp-18h]\n  size_t v8; // [rsp+C0h] [rbp-10h]\n  void *ptr; // [rsp+C8h] [rbp-8h]\n\n  if ( a2 )\n    v2 = *a2;\n  else\n    v2 = 2147479552LL;\n  v6 = v2;\n  stat_buf.st_size = 0LL;\n  sub_407E00(a1, &stat_buf);\n  v8 = (stat_buf.st_size | 0x3FF) + 1;\n  v7 = 0LL;\n  ptr = 0LL;\n  while ( 1 )\n  {\n    if ( v6 < v8 )\n      v8 = v6;\n    ptr = sub_40A09E(ptr, v7 + v8 + 1);\n    v5 = sub_40B446(a1, (char *)ptr + v7, v8);\n    if ( v5 == -1LL )\n    {\n      free(ptr);\n      return 0LL;\n    }\n    v7 += v5;\n    if ( v5 < v8 || v6 <= v5 )\n      break;\n    v6 -= v5;\n    v8 = ((v7 >> 3) | 0x3FF) + 1;\n    if ( v8 > 0x10000 )\n      v8 = 0x10000LL;\n  }\n  ptr = sub_40A09E(ptr, v7 + 1);\n  *((_BYTE *)ptr + v7) = 0;\n  if ( a2 )\n    *a2 = v7;\n  return ptr;\n}\n",
        "baseline_code_debug": "void *__cdecl xmalloc_read(int fd, size_t *maxsz_p)\n{\n  size_t v2; // rax\n  stat st; // [rsp+10h] [rbp-C0h] BYREF\n  size_t rd_size; // [rsp+A8h] [rbp-28h]\n  size_t to_read; // [rsp+B0h] [rbp-20h]\n  size_t total; // [rsp+B8h] [rbp-18h]\n  size_t size; // [rsp+C0h] [rbp-10h]\n  char *buf; // [rsp+C8h] [rbp-8h]\n\n  if ( maxsz_p )\n    v2 = *maxsz_p;\n  else\n    v2 = 2147479552LL;\n  to_read = v2;\n  st.st_size = 0LL;\n  fstat64(fd, (stat64 *)&st);\n  size = (st.st_size | 0x3FF) + 1;\n  total = 0LL;\n  buf = 0LL;\n  while ( 1 )\n  {\n    if ( to_read < size )\n      size = to_read;\n    buf = (char *)xrealloc(buf, total + size + 1);\n    rd_size = full_read(fd, &buf[total], size);\n    if ( rd_size == -1LL )\n    {\n      free(buf);\n      return 0LL;\n    }\n    total += rd_size;\n    if ( rd_size < size || to_read <= rd_size )\n      break;\n    to_read -= rd_size;\n    size = ((total >> 3) | 0x3FF) + 1;\n    if ( size > 0x10000 )\n      size = 0x10000LL;\n  }\n  buf = (char *)xrealloc(buf, total + 1);\n  buf[total] = 0;\n  if ( maxsz_p )\n    *maxsz_p = total;\n  return buf;\n}\n",
        "similarity_score_unixcoder": 0.8451259732246399,
        "similarity_score_baseline_stripped": 0.6092948913574219,
        "similarity_score_baseline_debug": 0.8989573121070862
    },
    {
        "func_name": "runsv",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_469B3D(__int64 a1)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  unsigned int v10; // [rsp+1Ch] [rbp-4h]\n\n  if ( byte_75D468 )\n    return 0LL;\n  v10 = vfork();\n  if ( v10 == -1 )\n  {\n    sub_469B15((__int64)\"vfork\", (__int64)&unk_53632F, v2, v3, v4, v5);\n    return 0LL;\n  }\n  else\n  {\n    if ( !v10 )\n    {\n      if ( (dword_75D450 & 1) != 0 )\n        setsid();\n      execlp(\"runsv\", \"runsv\", a1, 0LL);\n      sub_469AA1((__int64)\"start runsv \", a1, v6, v7, v8, v9);\n    }\n    return v10;\n  }\n}\n",
        "output": "long long sub_469B3D(long long a1)\n{\n  unsigned int childPid;\n\n  if (byte_75D468)\n    return 0;\n\n  childPid = vfork();\n  if (childPid == -1)\n  {\n    sub_469B15(\"vfork\", &unk_53632F);\n    return 0;\n  }\n  else\n  {\n    if (childPid == 0)\n    {\n      if (dword_75D450 & 1)\n        setsid();\n      execlp(\"runsv\", \"runsv\", a1, NULL);\n      sub_469AA1(\"start runsv \", a1);\n    }\n    return childPid;\n  }\n}",
        "source_code": "static NOINLINE pid_t runsv(const char *name)\n{\n\tpid_t pid;\n\n\t/* If we got signaled, stop spawning children at once! */\n\tif (bb_got_signal)\n\t\treturn 0;\n\n\tpid = vfork();\n\tif (pid == -1) {\n\t\twarn2_cannot(\"vfork\", \"\");\n\t\treturn 0;\n\t}\n\tif (pid == 0) {\n\t\t/* child */\n\t\tif (option_mask32 & 1) /* -P option? */\n\t\t\tsetsid();\n/* man execv:\n * \"Signals set to be caught by the calling process image\n *  shall be set to the default action in the new process image.\"\n * Therefore, we do not need this: */\n#if 0\n\t\tbb_signals(0\n\t\t\t| (1 << SIGHUP)\n\t\t\t| (1 << SIGTERM)\n\t\t\t, SIG_DFL);\n#endif\n\t\texeclp(\"runsv\", \"runsv\", name, (char *) NULL);\n\t\tfatal2_cannot(\"start runsv \", name);\n\t}\n\treturn pid;\n}",
        "parsed_output": "long long sub_469B3D(long long a1)\n{\n  unsigned int childPid;\n\n  if (byte_75D468)\n    return 0;\n\n  childPid = vfork();\n  if (childPid == -1)\n  {\n    sub_469B15(\"vfork\", &unk_53632F);\n    return 0;\n  }\n  else\n  {\n    if (childPid == 0)\n    {\n      if (dword_75D450 & 1)\n        setsid();\n      execlp(\"runsv\", \"runsv\", a1, NULL);\n      sub_469AA1(\"start runsv \", a1);\n    }\n    return childPid;\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_469B3D(__int64 a1)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  unsigned int v10; // [rsp+1Ch] [rbp-4h]\n\n  if ( byte_75D468 )\n    return 0LL;\n  v10 = vfork();\n  if ( v10 == -1 )\n  {\n    sub_469B15((__int64)\"vfork\", (__int64)&unk_53632F, v2, v3, v4, v5);\n    return 0LL;\n  }\n  else\n  {\n    if ( !v10 )\n    {\n      if ( (dword_75D450 & 1) != 0 )\n        setsid();\n      execlp(\"runsv\", \"runsv\", a1, 0LL);\n      sub_469AA1((__int64)\"start runsv \", a1, v6, v7, v8, v9);\n    }\n    return v10;\n  }\n}\n",
        "baseline_code_debug": "pid_t __cdecl runsv(const char *name)\n{\n  __pid_t pid; // [rsp+1Ch] [rbp-4h]\n\n  if ( bb_got_signal[0] )\n    return 0;\n  pid = vfork();\n  if ( pid == -1 )\n  {\n    warn2_cannot(\"vfork\", &byte_53632F);\n    return 0;\n  }\n  else\n  {\n    if ( !pid )\n    {\n      if ( (option_mask32 & 1) != 0 )\n        setsid();\n      execlp(\"runsv\", \"runsv\", name, 0LL);\n      fatal2_cannot_0(\"start runsv \", name);\n    }\n    return pid;\n  }\n}\n",
        "similarity_score_unixcoder": 0.8417757749557495,
        "similarity_score_baseline_stripped": 0.6746228933334351,
        "similarity_score_baseline_debug": 0.8853020668029785
    },
    {
        "func_name": "port_name",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_43F254(uint16_t a1)\n{\n  uint16_t v1; // ax\n  struct servent *v3; // [rsp+18h] [rbp-8h]\n\n  v1 = htons(a1);\n  v3 = getservbyport(v1, 0LL);\n  if ( v3 )\n    return v3->s_name;\n  else\n    return \"unknown\";\n}\n",
        "output": "const char *getServiceNameByPort(uint16_t port)\n{\n  uint16_t networkPort = htons(port);\n  struct servent *service = getservbyport(networkPort, NULL);\n\n  if (service)\n    return service->s_name;\n  else\n    return \"unknown\";\n}",
        "source_code": "endif\n\nstatic const char *port_name(unsigned port)\n{\n\tstruct servent *server;\n\n\tserver = getservbyport(htons(port), NULL);\n\tif (server)\n\t\treturn server->s_name;\n\treturn \"unknown\";\n}",
        "parsed_output": "const char *getServiceNameByPort(uint16_t port)\n{\n  uint16_t networkPort = htons(port);\n  struct servent *service = getservbyport(networkPort, NULL);\n\n  if (service)\n    return service->s_name;\n  else\n    return \"unknown\";\n}",
        "baseline_code_stripped": "const char *__fastcall sub_43F254(uint16_t a1)\n{\n  uint16_t v1; // ax\n  struct servent *v3; // [rsp+18h] [rbp-8h]\n\n  v1 = htons(a1);\n  v3 = getservbyport(v1, 0LL);\n  if ( v3 )\n    return v3->s_name;\n  else\n    return \"unknown\";\n}\n",
        "baseline_code_debug": "const char *__cdecl port_name(unsigned int port)\n{\n  uint16_t v1; // ax\n  struct servent *server; // [rsp+18h] [rbp-8h]\n\n  v1 = htons(port);\n  server = getservbyport(v1, 0LL);\n  if ( server )\n    return server->s_name;\n  else\n    return \"unknown\";\n}\n",
        "similarity_score_unixcoder": 0.8470339179039001,
        "similarity_score_baseline_stripped": 0.6130740642547607,
        "similarity_score_baseline_debug": 0.801088809967041
    },
    {
        "func_name": "collect_cpu",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_45FF10(__int64 a1)\n{\n  const char *v1; // rax\n  __int64 v3[3]; // [rsp+10h] [rbp-90h] BYREF\n  int v4; // [rsp+28h] [rbp-78h]\n  size_t v5; // [rsp+30h] [rbp-70h] BYREF\n  size_t v6; // [rsp+38h] [rbp-68h]\n  size_t n; // [rsp+40h] [rbp-60h]\n  __int64 v8; // [rsp+48h] [rbp-58h]\n  size_t v9; // [rsp+50h] [rbp-50h]\n  size_t v10; // [rsp+58h] [rbp-48h]\n  size_t v11; // [rsp+60h] [rbp-40h]\n  size_t v12; // [rsp+68h] [rbp-38h]\n  void *s; // [rsp+70h] [rbp-30h]\n  signed int v14; // [rsp+7Ch] [rbp-24h]\n  int v15; // [rsp+80h] [rbp-20h]\n  unsigned int v16; // [rsp+84h] [rbp-1Ch]\n  size_t v17; // [rsp+88h] [rbp-18h]\n  int i; // [rsp+90h] [rbp-10h]\n  int v19; // [rsp+94h] [rbp-Ch]\n  unsigned __int64 v20; // [rsp+98h] [rbp-8h]\n\n  v5 = 0LL;\n  v6 = 0LL;\n  n = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  memset(v3, 0, sizeof(v3));\n  v4 = 0;\n  v20 = 0LL;\n  v19 = 0;\n  v14 = *(_DWORD *)(a1 + 80);\n  s = *(void **)(a1 + 88);\n  v1 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 48);\n  if ( (unsigned int)sub_45FABF(v1, \"cpu \", &v5, 1LL, 2LL, 3LL, 4LL, 5LL, 6LL, 7LL) )\n    return (void *)sub_45F76C(v14);\n  for ( i = 0; i <= 6; ++i )\n  {\n    v17 = *(_QWORD *)(a1 + 8 * (i + 2LL) + 8);\n    if ( v17 > *(&v5 + i) )\n      v17 = *(&v5 + i);\n    *(_QWORD *)(a1 + 8 * (i + 2LL) + 8) = *(&v5 + i);\n    *(&v5 + i) -= v17;\n    v20 += *(&v5 + i);\n  }\n  if ( v20 )\n  {\n    for ( i = 0; i <= 6; ++i )\n    {\n      v12 = v14 * *(&v5 + i);\n      *(&v5 + i) = v12 / v20;\n      v19 += *(&v5 + i);\n      *((_DWORD *)v3 + i) = v12 % v20;\n    }\n    while ( v19 < v14 )\n    {\n      v16 = v3[0];\n      v15 = 0;\n      for ( i = 1; i <= 6; ++i )\n      {\n        if ( v16 < *((_DWORD *)v3 + i) )\n        {\n          v16 = *((_DWORD *)v3 + i);\n          v15 = i;\n        }\n      }\n      *((_DWORD *)v3 + v15) = 0;\n      ++*(&v5 + v15);\n      ++v19;\n    }\n    memset(s, 46, v14);\n    memset(s, 83, n);\n    s = (char *)s + n;\n    memset(s, 85, v5);\n    s = (char *)s + v5;\n    memset(s, 78, v6);\n    s = (char *)s + v6;\n    memset(s, 68, v9);\n    s = (char *)s + v9;\n    memset(s, 73, v10);\n    s = (char *)s + v10;\n    memset(s, 105, v11);\n    s = (char *)s + v11;\n  }\n  else\n  {\n    memset(s, 63, v14);\n  }\n  return sub_45F69B(*(const char **)(a1 + 88));\n}\n",
        "output": "```c\nvoid *distributeCpuLoad(__int64 configPtr)\n{\n  size_t loadValues[7] = {0}; // Corresponds to v5, v6, n, v8, v9, v10, v11\n  int loadDistribution[7] = {0}; // Corresponds to v3\n  int totalLoad = 0; // Corresponds to v20\n  int remainingLoad; // Corresponds to v19\n  int cpuLoadLimit; // Corresponds to v14\n  void *outputBuffer; // Corresponds to s\n  size_t load, maxLoad;\n  int i, maxLoadIdx;\n\n  cpuLoadLimit = *(_DWORD *)(configPtr + 80);\n  outputBuffer = *(void **)(configPtr + 88);\n  const char *cpuString = (const char *)getCpuString();\n  if (checkCpuString(cpuString, \"cpu \", loadValues, 1LL, 2LL, 3LL, 4LL, 5LL, 6LL, 7LL))\n    return handleCpuError(cpuLoadLimit);\n\n  for (i = 0; i <= 6; ++i)\n  {\n    load = *(_QWORD *)(configPtr + 8 * (i + 2) + 8);\n    if (load > loadValues[i])\n      load = loadValues[i];\n    *(_QWORD *)(configPtr + 8 * (i + 2) + 8) = loadValues[i];\n    loadValues[i] -= load;\n    totalLoad += loadValues[i];\n  }\n\n  if (totalLoad)\n  {\n    for (i = 0; i <= 6; ++i)\n    {\n      loadDistribution[i] = (cpuLoadLimit * loadValues[i]) / totalLoad;\n      remainingLoad += loadDistribution[i];\n      loadValues[i] = (cpuLoadLimit * loadValues[i]) % totalLoad;\n    }\n\n    while (remainingLoad < cpuLoadLimit)\n    {\n      maxLoad = loadValues[0];\n      maxLoadIdx = 0;\n      for (i = 1; i <= 6; ++i)\n      {\n        if (maxLoad < loadValues[i])\n        {\n          maxLoad = loadValues[i];\n          maxLoadIdx = i;\n        }\n      }\n      loadValues[maxLoadIdx] = 0;\n      ++loadDistribution[maxLoadIdx];\n      ++remainingLoad;\n    }\n\n    memset(outputBuffer, 46, cpuLoadLimit);\n    for (i = 0; i <= 6; ++i)\n    {\n      memset(outputBuffer, 83 + i, loadDistribution[i]);\n      outputBuffer = (char *)outputBuffer + loadDistribution[i];\n    }\n  }\n  else\n  {\n    memset(outputBuffer, 63, cpuLoadLimit);\n  }\n\n  return finalizeCpuLoad(*(const char **)(configPtr + 88));\n}\n```",
        "source_code": "static void FAST_FUNC collect_cpu(cpu_stat *s)\n{\n\tullong data[CPU_FIELDCNT] = { 0, 0, 0, 0, 0, 0, 0 };\n\tunsigned frac[CPU_FIELDCNT] = { 0, 0, 0, 0, 0, 0, 0 };\n\tullong all = 0;\n\tint norm_all = 0;\n\tint bar_sz = s->bar_sz;\n\tchar *bar = s->bar;\n\tint i;\n\n\tif (rdval(get_file(&proc_stat), \"cpu \", data, 1, 2, 3, 4, 5, 6, 7)) {\n\t\tput_question_marks(bar_sz);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < CPU_FIELDCNT; i++) {\n\t\tullong old = s->old[i];\n\t\tif (data[i] < old) old = data[i];\t\t//sanitize\n\t\ts->old[i] = data[i];\n\t\tall += (data[i] -= old);\n\t}\n\n\tif (all) {\n\t\tfor (i = 0; i < CPU_FIELDCNT; i++) {\n\t\t\tullong t = bar_sz * data[i];\n\t\t\tnorm_all += data[i] = t / all;\n\t\t\tfrac[i] = t % all;\n\t\t}\n\n\t\twhile (norm_all < bar_sz) {\n\t\t\tunsigned max = frac[0];\n\t\t\tint pos = 0;\n\t\t\tfor (i = 1; i < CPU_FIELDCNT; i++) {\n\t\t\t\tif (frac[i] > max) max = frac[i], pos = i;\n\t\t\t}\n\t\t\tfrac[pos] = 0;\t//avoid bumping up same value twice\n\t\t\tdata[pos]++;\n\t\t\tnorm_all++;\n\t\t}\n\n\t\tmemset(bar, '.', bar_sz);\n\t\tmemset(bar, 'S', data[2]); bar += data[2]; //sys\n\t\tmemset(bar, 'U', data[0]); bar += data[0]; //usr\n\t\tmemset(bar, 'N', data[1]); bar += data[1]; //nice\n\t\tmemset(bar, 'D', data[4]); bar += data[4]; //iowait\n\t\tmemset(bar, 'I', data[5]); bar += data[5]; //irq\n\t\tmemset(bar, 'i', data[6]); bar += data[6]; //softirq\n\t} else {\n\t\tmemset(bar, '?', bar_sz);\n\t}\n\tput(s->bar);\n}",
        "parsed_output": "void *distributeCpuLoad(__int64 configPtr)\n{\n  size_t loadValues[7] = {0}; // Corresponds to v5, v6, n, v8, v9, v10, v11\n  int loadDistribution[7] = {0}; // Corresponds to v3\n  int totalLoad = 0; // Corresponds to v20\n  int remainingLoad; // Corresponds to v19\n  int cpuLoadLimit; // Corresponds to v14\n  void *outputBuffer; // Corresponds to s\n  size_t load, maxLoad;\n  int i, maxLoadIdx;\n\n  cpuLoadLimit = *(_DWORD *)(configPtr + 80);\n  outputBuffer = *(void **)(configPtr + 88);\n  const char *cpuString = (const char *)getCpuString();\n  if (checkCpuString(cpuString, \"cpu \", loadValues, 1LL, 2LL, 3LL, 4LL, 5LL, 6LL, 7LL))\n    return handleCpuError(cpuLoadLimit);\n\n  for (i = 0; i <= 6; ++i)\n  {\n    load = *(_QWORD *)(configPtr + 8 * (i + 2) + 8);\n    if (load > loadValues[i])\n      load = loadValues[i];\n    *(_QWORD *)(configPtr + 8 * (i + 2) + 8) = loadValues[i];\n    loadValues[i] -= load;\n    totalLoad += loadValues[i];\n  }\n\n  if (totalLoad)\n  {\n    for (i = 0; i <= 6; ++i)\n    {\n      loadDistribution[i] = (cpuLoadLimit * loadValues[i]) / totalLoad;\n      remainingLoad += loadDistribution[i];\n      loadValues[i] = (cpuLoadLimit * loadValues[i]) % totalLoad;\n    }\n\n    while (remainingLoad < cpuLoadLimit)\n    {\n      maxLoad = loadValues[0];\n      maxLoadIdx = 0;\n      for (i = 1; i <= 6; ++i)\n      {\n        if (maxLoad < loadValues[i])\n        {\n          maxLoad = loadValues[i];\n          maxLoadIdx = i;\n        }\n      }\n      loadValues[maxLoadIdx] = 0;\n      ++loadDistribution[maxLoadIdx];\n      ++remainingLoad;\n    }\n\n    memset(outputBuffer, 46, cpuLoadLimit);\n    for (i = 0; i <= 6; ++i)\n    {\n      memset(outputBuffer, 83 + i, loadDistribution[i]);\n      outputBuffer = (char *)outputBuffer + loadDistribution[i];\n    }\n  }\n  else\n  {\n    memset(outputBuffer, 63, cpuLoadLimit);\n  }\n\n  return finalizeCpuLoad(*(const char **)(configPtr + 88));\n}",
        "baseline_code_stripped": "void *__fastcall sub_45FF10(__int64 a1)\n{\n  const char *v1; // rax\n  __int64 v3[3]; // [rsp+10h] [rbp-90h] BYREF\n  int v4; // [rsp+28h] [rbp-78h]\n  size_t v5; // [rsp+30h] [rbp-70h] BYREF\n  size_t v6; // [rsp+38h] [rbp-68h]\n  size_t n; // [rsp+40h] [rbp-60h]\n  __int64 v8; // [rsp+48h] [rbp-58h]\n  size_t v9; // [rsp+50h] [rbp-50h]\n  size_t v10; // [rsp+58h] [rbp-48h]\n  size_t v11; // [rsp+60h] [rbp-40h]\n  size_t v12; // [rsp+68h] [rbp-38h]\n  void *s; // [rsp+70h] [rbp-30h]\n  signed int v14; // [rsp+7Ch] [rbp-24h]\n  int v15; // [rsp+80h] [rbp-20h]\n  unsigned int v16; // [rsp+84h] [rbp-1Ch]\n  size_t v17; // [rsp+88h] [rbp-18h]\n  int i; // [rsp+90h] [rbp-10h]\n  int v19; // [rsp+94h] [rbp-Ch]\n  unsigned __int64 v20; // [rsp+98h] [rbp-8h]\n\n  v5 = 0LL;\n  v6 = 0LL;\n  n = 0LL;\n  v8 = 0LL;\n  v9 = 0LL;\n  v10 = 0LL;\n  v11 = 0LL;\n  memset(v3, 0, sizeof(v3));\n  v4 = 0;\n  v20 = 0LL;\n  v19 = 0;\n  v14 = *(_DWORD *)(a1 + 80);\n  s = *(void **)(a1 + 88);\n  v1 = (const char *)sub_45F879((_BYTE *)qword_75D408 + 48);\n  if ( (unsigned int)sub_45FABF(v1, \"cpu \", &v5, 1LL, 2LL, 3LL, 4LL, 5LL, 6LL, 7LL) )\n    return (void *)sub_45F76C(v14);\n  for ( i = 0; i <= 6; ++i )\n  {\n    v17 = *(_QWORD *)(a1 + 8 * (i + 2LL) + 8);\n    if ( v17 > *(&v5 + i) )\n      v17 = *(&v5 + i);\n    *(_QWORD *)(a1 + 8 * (i + 2LL) + 8) = *(&v5 + i);\n    *(&v5 + i) -= v17;\n    v20 += *(&v5 + i);\n  }\n  if ( v20 )\n  {\n    for ( i = 0; i <= 6; ++i )\n    {\n      v12 = v14 * *(&v5 + i);\n      *(&v5 + i) = v12 / v20;\n      v19 += *(&v5 + i);\n      *((_DWORD *)v3 + i) = v12 % v20;\n    }\n    while ( v19 < v14 )\n    {\n      v16 = v3[0];\n      v15 = 0;\n      for ( i = 1; i <= 6; ++i )\n      {\n        if ( v16 < *((_DWORD *)v3 + i) )\n        {\n          v16 = *((_DWORD *)v3 + i);\n          v15 = i;\n        }\n      }\n      *((_DWORD *)v3 + v15) = 0;\n      ++*(&v5 + v15);\n      ++v19;\n    }\n    memset(s, 46, v14);\n    memset(s, 83, n);\n    s = (char *)s + n;\n    memset(s, 85, v5);\n    s = (char *)s + v5;\n    memset(s, 78, v6);\n    s = (char *)s + v6;\n    memset(s, 68, v9);\n    s = (char *)s + v9;\n    memset(s, 73, v10);\n    s = (char *)s + v10;\n    memset(s, 105, v11);\n    s = (char *)s + v11;\n  }\n  else\n  {\n    memset(s, 63, v14);\n  }\n  return sub_45F69B(*(const char **)(a1 + 88));\n}\n",
        "baseline_code_debug": "void __cdecl collect_cpu(cpu_stat_0 *s)\n{\n  const char *file; // rax\n  unsigned int frac[7]; // [rsp+10h] [rbp-90h] BYREF\n  ullong data[7]; // [rsp+30h] [rbp-70h] BYREF\n  ullong t; // [rsp+68h] [rbp-38h]\n  char *bar; // [rsp+70h] [rbp-30h]\n  int bar_sz; // [rsp+7Ch] [rbp-24h]\n  int pos; // [rsp+80h] [rbp-20h]\n  unsigned int max; // [rsp+84h] [rbp-1Ch]\n  ullong old; // [rsp+88h] [rbp-18h]\n  int i; // [rsp+90h] [rbp-10h]\n  int norm_all; // [rsp+94h] [rbp-Ch]\n  ullong all; // [rsp+98h] [rbp-8h]\n\n  memset(data, 0, sizeof(data));\n  memset(frac, 0, sizeof(frac));\n  all = 0LL;\n  norm_all = 0;\n  bar_sz = s->bar_sz;\n  bar = s->bar;\n  file = get_file((proc_file_0 *)&ptr_to_globals->numspeed);\n  if ( rdval(file, \"cpu \", data, 1LL, 2LL, 3LL, 4LL, 5LL, 6LL, 7LL) )\n  {\n    put_question_marks(bar_sz);\n  }\n  else\n  {\n    for ( i = 0; i <= 6; ++i )\n    {\n      old = s->old[i];\n      if ( old > data[i] )\n        old = data[i];\n      s->old[i] = data[i];\n      data[i] -= old;\n      all += data[i];\n    }\n    if ( all )\n    {\n      for ( i = 0; i <= 6; ++i )\n      {\n        t = bar_sz * data[i];\n        data[i] = t / all;\n        norm_all += data[i];\n        frac[i] = t % all;\n      }\n      while ( norm_all < bar_sz )\n      {\n        max = frac[0];\n        pos = 0;\n        for ( i = 1; i <= 6; ++i )\n        {\n          if ( max < frac[i] )\n          {\n            max = frac[i];\n            pos = i;\n          }\n        }\n        frac[pos] = 0;\n        ++data[pos];\n        ++norm_all;\n      }\n      memset(bar, 46, bar_sz);\n      memset(bar, 83, data[2]);\n      bar += data[2];\n      memset(bar, 85, data[0]);\n      bar += data[0];\n      memset(bar, 78, data[1]);\n      bar += data[1];\n      memset(bar, 68, data[4]);\n      bar += data[4];\n      memset(bar, 73, data[5]);\n      bar += data[5];\n      memset(bar, 105, data[6]);\n      bar += data[6];\n    }\n    else\n    {\n      memset(bar, 63, bar_sz);\n    }\n    put(s->bar);\n  }\n}\n",
        "similarity_score_unixcoder": 0.6686627268791199,
        "similarity_score_baseline_stripped": 0.5443696975708008,
        "similarity_score_baseline_debug": 0.8781501054763794
    },
    {
        "func_name": "uid2uname_utoa",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_4F6415(unsigned int a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_4F63B5(a1, a2);\n  if ( v3 )\n    return (_BYTE *)v3;\n  else\n    return sub_409B63(a1);\n}\n",
        "output": "```c\n_BYTE *sub_4F6415(unsigned int a1, __int64 a2)\n{\n  __int64 result = sub_4F63B5(a1, a2);\n  if (result)\n    return (_BYTE *)result;\n  else\n    return sub_409B63(a1);\n}\n```",
        "source_code": "FAST_FUNC uid2uname_utoa(uid_t uid)\n{\n\tchar *name = uid2uname(uid);\n\treturn (name) ? name : utoa(uid);\n}",
        "parsed_output": "_BYTE *sub_4F6415(unsigned int a1, __int64 a2)\n{\n  __int64 result = sub_4F63B5(a1, a2);\n  if (result)\n    return (_BYTE *)result;\n  else\n    return sub_409B63(a1);\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_4F6415(unsigned int a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_4F63B5(a1, a2);\n  if ( v3 )\n    return (_BYTE *)v3;\n  else\n    return sub_409B63(a1);\n}\n",
        "baseline_code_debug": "char *__cdecl uid2uname_utoa(uid_t uid)\n{\n  char *name; // [rsp+18h] [rbp-8h]\n\n  name = uid2uname(uid);\n  if ( name )\n    return name;\n  else\n    return utoa(uid);\n}\n",
        "similarity_score_unixcoder": 0.4341820180416107,
        "similarity_score_baseline_stripped": 0.3769398629665375,
        "similarity_score_baseline_debug": 0.8265640735626221
    },
    {
        "func_name": "ptok",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nunsigned __int64 __fastcall sub_422BE5(unsigned int a1, unsigned __int64 a2)\n{\n  if ( a2 <= 0x7FFFFFFFFFFFFFFFLL / a1 )\n    return (a2 * a1) >> 10;\n  else\n    return (a2 >> 10) * a1;\n}\n",
        "output": "unsigned __int64 multiplyAndShift(unsigned int multiplier, unsigned __int64 value)\n{\n  const unsigned __int64 maxSafeValue = 0x7FFFFFFFFFFFFFFFLL / multiplier;\n  \n  if (value <= maxSafeValue)\n    return (value * multiplier) >> 10;\n  else\n    return (value >> 10) * multiplier;\n}",
        "source_code": "static unsigned long ptok(const unsigned pagesize, const unsigned long pages)\n{\n\tunsigned long tmp;\n\n\t/* Conversion.  */\n\tif (pages > (LONG_MAX / pagesize)) { /* Could overflow.  */\n\t\ttmp = pages / 1024;     /* Smaller first, */\n\t\treturn tmp * pagesize;  /* then larger.  */\n\t}\n\t/* Could underflow.  */\n\ttmp = pages * pagesize; /* Larger first, */\n\treturn tmp / 1024;      /* then smaller.  */\n}",
        "parsed_output": "unsigned __int64 multiplyAndShift(unsigned int multiplier, unsigned __int64 value)\n{\n  const unsigned __int64 maxSafeValue = 0x7FFFFFFFFFFFFFFFLL / multiplier;\n  \n  if (value <= maxSafeValue)\n    return (value * multiplier) >> 10;\n  else\n    return (value >> 10) * multiplier;\n}",
        "baseline_code_stripped": "unsigned __int64 __fastcall sub_422BE5(unsigned int a1, unsigned __int64 a2)\n{\n  if ( a2 <= 0x7FFFFFFFFFFFFFFFLL / a1 )\n    return (a2 * a1) >> 10;\n  else\n    return (a2 >> 10) * a1;\n}\n",
        "baseline_code_debug": "unsigned __int64 __cdecl ptok(const unsigned int pagesize, const unsigned __int64 pages)\n{\n  if ( pages <= 0x7FFFFFFFFFFFFFFFLL / pagesize )\n    return (pages * pagesize) >> 10;\n  else\n    return (pages >> 10) * pagesize;\n}\n",
        "similarity_score_unixcoder": 0.6299622058868408,
        "similarity_score_baseline_stripped": 0.5574182271957397,
        "similarity_score_baseline_debug": 0.8006270527839661
    },
    {
        "func_name": "strip_unsafe_prefix",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_4C0C5F(__int64 a1)\n{\n  __int64 v1; // r8\n  __int64 v2; // r9\n  char *v4; // [rsp+10h] [rbp-10h]\n  char *s1; // [rsp+18h] [rbp-8h]\n\n  for ( s1 = (char *)a1; ; s1 = v4 + 4 )\n  {\n    while ( 1 )\n    {\n      while ( *s1 == 47 )\n        ++s1;\n      if ( strncmp(s1, \"../\", 3uLL) )\n        break;\n      s1 += 3;\n    }\n    v4 = strstr(s1, \"/../\");\n    if ( !v4 )\n      break;\n  }\n  if ( s1 != (char *)a1 && !byte_75B301 )\n  {\n    byte_75B301 = 1;\n    sub_409747(\n      \"removing leading '%.*s' from member names\",\n      (unsigned int)((_DWORD)s1 - a1),\n      a1,\n      (unsigned int)((_DWORD)s1 - a1),\n      v1,\n      v2);\n  }\n  return s1;\n}\n",
        "output": "char *normalizePath(char *path)\n{\n  char *nextSegment;\n  char *current;\n\n  for (current = path; ; current = nextSegment + 4)\n  {\n    // Skip all single forward slashes\n    while (*current == '/')\n      ++current;\n\n    // If \"../\" is found, skip it\n    if (strncmp(current, \"../\", 3) != 0)\n      break;\n\n    current += 3;\n  }\n\n  // Find the next occurrence of \"/../\"\n  nextSegment = strstr(current, \"/../\");\n  if (!nextSegment)\n    break;\n\n  // If not at the beginning and a certain condition is met, log the removal\n  if (current != path && !byte_75B301)\n  {\n    byte_75B301 = 1;\n    logRemoval(\n      \"removing leading '%.*s' from member names\",\n      (unsigned int)(current - path),\n      path,\n      (unsigned int)(current - path),\n      v1,\n      v2);\n  }\n\n  return current;\n}",
        "source_code": "FAST_FUNC strip_unsafe_prefix(const char *str)\n{\n\tconst char *cp = str;\n\twhile (1) {\n\t\tchar *cp2;\n\t\tif (*cp == '/') {\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncmp(cp, \"/../\"+1, 3) == 0) {\n\t\t\tcp += 3;\n\t\t\tcontinue;\n\t\t}\n\t\tcp2 = strstr(cp, \"/../\");\n\t\tif (!cp2)\n\t\t\tbreak;\n\t\tcp = cp2 + 4;\n\t}\n\tif (cp != str) {\n\t\tstatic smallint warned = 0;\n\t\tif (!warned) {\n\t\t\twarned = 1;\n\t\t\tbb_error_msg(\"removing leading '%.*s' from member names\",\n\t\t\t\t(int)(cp - str), str);\n\t\t}\n\t}\n\treturn cp;\n}",
        "parsed_output": "char *normalizePath(char *path)\n{\n  char *nextSegment;\n  char *current;\n\n  for (current = path; ; current = nextSegment + 4)\n  {\n    // Skip all single forward slashes\n    while (*current == '/')\n      ++current;\n\n    // If \"../\" is found, skip it\n    if (strncmp(current, \"../\", 3) != 0)\n      break;\n\n    current += 3;\n  }\n\n  // Find the next occurrence of \"/../\"\n  nextSegment = strstr(current, \"/../\");\n  if (!nextSegment)\n    break;\n\n  // If not at the beginning and a certain condition is met, log the removal\n  if (current != path && !byte_75B301)\n  {\n    byte_75B301 = 1;\n    logRemoval(\n      \"removing leading '%.*s' from member names\",\n      (unsigned int)(current - path),\n      path,\n      (unsigned int)(current - path),\n      v1,\n      v2);\n  }\n\n  return current;\n}",
        "baseline_code_stripped": "char *__fastcall sub_4C0C5F(__int64 a1)\n{\n  __int64 v1; // r8\n  __int64 v2; // r9\n  char *v4; // [rsp+10h] [rbp-10h]\n  char *s1; // [rsp+18h] [rbp-8h]\n\n  for ( s1 = (char *)a1; ; s1 = v4 + 4 )\n  {\n    while ( 1 )\n    {\n      while ( *s1 == 47 )\n        ++s1;\n      if ( strncmp(s1, \"../\", 3uLL) )\n        break;\n      s1 += 3;\n    }\n    v4 = strstr(s1, \"/../\");\n    if ( !v4 )\n      break;\n  }\n  if ( s1 != (char *)a1 && !byte_75B301 )\n  {\n    byte_75B301 = 1;\n    sub_409747(\n      \"removing leading '%.*s' from member names\",\n      (unsigned int)((_DWORD)s1 - a1),\n      a1,\n      (unsigned int)((_DWORD)s1 - a1),\n      v1,\n      v2);\n  }\n  return s1;\n}\n",
        "baseline_code_debug": "const char *__cdecl strip_unsafe_prefix(const char *str)\n{\n  char *cp2; // [rsp+10h] [rbp-10h]\n  const char *cp; // [rsp+18h] [rbp-8h]\n\n  for ( cp = str; ; cp = cp2 + 4 )\n  {\n    while ( 1 )\n    {\n      while ( *cp == 47 )\n        ++cp;\n      if ( strncmp(cp, \"../\", 3uLL) )\n        break;\n      cp += 3;\n    }\n    cp2 = strstr(cp, \"/../\");\n    if ( !cp2 )\n      break;\n  }\n  if ( cp != str && !warned_8303 )\n  {\n    warned_8303 = 1;\n    bb_error_msg(\"removing leading '%.*s' from member names\", (unsigned int)((_DWORD)cp - (_DWORD)str), str);\n  }\n  return cp;\n}\n",
        "similarity_score_unixcoder": 0.7489813566207886,
        "similarity_score_baseline_stripped": 0.6971070170402527,
        "similarity_score_baseline_debug": 0.8886622190475464
    },
    {
        "func_name": "ask",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_49602F(__int64 a1, unsigned int a2)\n{\n  unsigned int v3; // [rsp+4h] [rbp-1Ch]\n  int v4; // [rsp+1Ch] [rbp-4h]\n  int v5; // [rsp+1Ch] [rbp-4h]\n\n  v3 = a2;\n  if ( (dword_75D450 & 4) != 0 )\n  {\n    if ( (dword_75D450 & 2) != 0 )\n    {\n      sub_40A659(10);\n      if ( !a2 )\n        *((_BYTE *)qword_75D408 + 2) = 1;\n      return a2;\n    }\n    else\n    {\n      if ( a2 )\n        printf(\"%s (y/n)? \", a1);\n      else\n        printf(\"%s (n/y)? \", a1);\n      while ( 1 )\n      {\n        sub_40A649();\n        v4 = getchar_unlocked();\n        if ( v4 == -1 )\n          break;\n        if ( v4 == 10 )\n          goto LABEL_19;\n        v5 = v4 | 0x20;\n        if ( v5 == 121 )\n        {\n          v3 = 1;\nLABEL_19:\n          if ( v3 )\n          {\n            puts(\"y\");\n          }\n          else\n          {\n            puts(\"n\");\n            *((_BYTE *)qword_75D408 + 2) = 1;\n          }\n          return v3;\n        }\n        if ( v5 == 110 )\n        {\n          v3 = 0;\n          goto LABEL_19;\n        }\n      }\n      if ( !a2 )\n        *((_BYTE *)qword_75D408 + 2) = 1;\n      return a2;\n    }\n  }\n  else\n  {\n    sub_40A659(10);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n    return 0LL;\n  }\n}\n",
        "output": "```c\nint promptUserConfirmation(const char *message, unsigned int defaultChoice)\n{\n  unsigned int userChoice = defaultChoice;\n  int inputChar;\n  int lowerCaseChar;\n\n  if (globalFlags & 4)\n  {\n    if (globalFlags & 2)\n    {\n      flushInputBuffer(10);\n      if (!defaultChoice)\n        globalStateByte = 1;\n      return defaultChoice;\n    }\n    else\n    {\n      printf(\"%s (y/n)? \", message);\n      while (1)\n      {\n        flushInputBuffer();\n        inputChar = getchar_unlocked();\n        if (inputChar == EOF)\n          break;\n        if (inputChar == '\\n')\n          goto OUTPUT_CHOICE;\n        lowerCaseChar = tolower(inputChar);\n        if (lowerCaseChar == 'y')\n        {\n          userChoice = 1;\nOUTPUT_CHOICE:\n          if (userChoice)\n          {\n            puts(\"y\");\n          }\n          else\n          {\n            puts(\"n\");\n            globalStateByte = 1;\n          }\n          return userChoice;\n        }\n        if (lowerCaseChar == 'n')\n        {\n          userChoice = 0;\n          goto OUTPUT_CHOICE;\n        }\n      }\n      if (!defaultChoice)\n        globalStateByte = 1;\n      return defaultChoice;\n    }\n  }\n  else\n  {\n    flushInputBuffer(10);\n    globalStateByte = 1;\n    return 0;\n  }\n}\n```",
        "source_code": "int ask (e2fsck_t ctx, const char * string, int def)\n{\n\tif (ctx->options & E2F_OPT_NO) {\n\t\tprintf(_(\"%s? no\\n\\n\"), string);\n\t\treturn 0;\n\t}\n\tif (ctx->options & E2F_OPT_YES) {\n\t\tprintf(_(\"%s? yes\\n\\n\"), string);\n\t\treturn 1;\n\t}\n\tif (ctx->options & E2F_OPT_PREEN) {\n\t\tprintf(\"%s? %s\\n\\n\", string, def ? _(\"yes\") : _(\"no\"));\n\t\treturn def;\n\t}\n\treturn ask_yn(string, def);\n}",
        "parsed_output": "int promptUserConfirmation(const char *message, unsigned int defaultChoice)\n{\n  unsigned int userChoice = defaultChoice;\n  int inputChar;\n  int lowerCaseChar;\n\n  if (globalFlags & 4)\n  {\n    if (globalFlags & 2)\n    {\n      flushInputBuffer(10);\n      if (!defaultChoice)\n        globalStateByte = 1;\n      return defaultChoice;\n    }\n    else\n    {\n      printf(\"%s (y/n)? \", message);\n      while (1)\n      {\n        flushInputBuffer();\n        inputChar = getchar_unlocked();\n        if (inputChar == EOF)\n          break;\n        if (inputChar == '\\n')\n          goto OUTPUT_CHOICE;\n        lowerCaseChar = tolower(inputChar);\n        if (lowerCaseChar == 'y')\n        {\n          userChoice = 1;\nOUTPUT_CHOICE:\n          if (userChoice)\n          {\n            puts(\"y\");\n          }\n          else\n          {\n            puts(\"n\");\n            globalStateByte = 1;\n          }\n          return userChoice;\n        }\n        if (lowerCaseChar == 'n')\n        {\n          userChoice = 0;\n          goto OUTPUT_CHOICE;\n        }\n      }\n      if (!defaultChoice)\n        globalStateByte = 1;\n      return defaultChoice;\n    }\n  }\n  else\n  {\n    flushInputBuffer(10);\n    globalStateByte = 1;\n    return 0;\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_49602F(__int64 a1, unsigned int a2)\n{\n  unsigned int v3; // [rsp+4h] [rbp-1Ch]\n  int v4; // [rsp+1Ch] [rbp-4h]\n  int v5; // [rsp+1Ch] [rbp-4h]\n\n  v3 = a2;\n  if ( (dword_75D450 & 4) != 0 )\n  {\n    if ( (dword_75D450 & 2) != 0 )\n    {\n      sub_40A659(10);\n      if ( !a2 )\n        *((_BYTE *)qword_75D408 + 2) = 1;\n      return a2;\n    }\n    else\n    {\n      if ( a2 )\n        printf(\"%s (y/n)? \", a1);\n      else\n        printf(\"%s (n/y)? \", a1);\n      while ( 1 )\n      {\n        sub_40A649();\n        v4 = getchar_unlocked();\n        if ( v4 == -1 )\n          break;\n        if ( v4 == 10 )\n          goto LABEL_19;\n        v5 = v4 | 0x20;\n        if ( v5 == 121 )\n        {\n          v3 = 1;\nLABEL_19:\n          if ( v3 )\n          {\n            puts(\"y\");\n          }\n          else\n          {\n            puts(\"n\");\n            *((_BYTE *)qword_75D408 + 2) = 1;\n          }\n          return v3;\n        }\n        if ( v5 == 110 )\n        {\n          v3 = 0;\n          goto LABEL_19;\n        }\n      }\n      if ( !a2 )\n        *((_BYTE *)qword_75D408 + 2) = 1;\n      return a2;\n    }\n  }\n  else\n  {\n    sub_40A659(10);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n    return 0LL;\n  }\n}\n",
        "baseline_code_debug": "int __cdecl ask(const char *string, int def)\n{\n  int defa; // [rsp+4h] [rbp-1Ch]\n  int c; // [rsp+1Ch] [rbp-4h]\n  int ca; // [rsp+1Ch] [rbp-4h]\n\n  defa = def;\n  if ( (option_mask32 & 4) != 0 )\n  {\n    if ( (option_mask32 & 2) != 0 )\n    {\n      bb_putchar(10);\n      if ( !def )\n        BYTE2(ptr_to_globals->timeout) = 1;\n      return def;\n    }\n    else\n    {\n      if ( def )\n        printf(\"%s (y/n)? \", string);\n      else\n        printf(\"%s (n/y)? \", string);\n      while ( 1 )\n      {\n        fflush_all();\n        c = getchar_unlocked();\n        if ( c == -1 )\n          break;\n        if ( c == 10 )\n          goto LABEL_19;\n        ca = c | 0x20;\n        if ( ca == 121 )\n        {\n          defa = 1;\nLABEL_19:\n          if ( defa )\n          {\n            puts(\"y\");\n          }\n          else\n          {\n            puts(\"n\");\n            BYTE2(ptr_to_globals->timeout) = 1;\n          }\n          return defa;\n        }\n        if ( ca == 110 )\n        {\n          defa = 0;\n          goto LABEL_19;\n        }\n      }\n      if ( !def )\n        BYTE2(ptr_to_globals->timeout) = 1;\n      return def;\n    }\n  }\n  else\n  {\n    bb_putchar(10);\n    BYTE2(ptr_to_globals->timeout) = 1;\n    return 0;\n  }\n}\n",
        "similarity_score_unixcoder": 0.65595543384552,
        "similarity_score_baseline_stripped": 0.4866630733013153,
        "similarity_score_baseline_debug": 0.7005268931388855
    },
    {
        "func_name": "stoppedjobs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_472FFC()\n{\n  unsigned int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = 0;\n  if ( !*(_BYTE *)(qword_75D418 + 748) && qword_75AFB0 && *(_BYTE *)(qword_75AFB0 + 30) == 1 )\n  {\n    sub_46E2EB(\"You have stopped jobs.\\n\");\n    *(_BYTE *)(qword_75D418 + 748) = 2;\n    return 1;\n  }\n  return v1;\n}\n",
        "output": "int checkAndNotifyStoppedJobs()\n{\n  int result = 0;\n  bool isJobStopped = *(char *)(jobStatusAddress + 748) == 0;\n  bool hasJobInfo = jobInfoAddress != 0;\n  bool isJobInfoValid = *(char *)(jobInfoAddress + 30) == 1;\n\n  if (isJobStopped && hasJobInfo && isJobInfoValid)\n  {\n    notify(\"You have stopped jobs.\\n\");\n    *(char *)(jobStatusAddress + 748) = 2;\n    result = 1;\n  }\n\n  return result;\n}",
        "source_code": "static int\nstoppedjobs(void)\n{\n\tstruct job *jp;\n\tint retval;\n\n\tretval = 0;\n\tif (job_warning)\n\t\tgoto out;\n\tjp = curjob;\n\tif (jp && jp->state == JOBSTOPPED) {\n\t\tout2str(\"You have stopped jobs.\\n\");\n\t\tjob_warning = 2;\n\t\tretval++;\n\t}\n out:\n\treturn retval;\n}",
        "parsed_output": "int checkAndNotifyStoppedJobs()\n{\n  int result = 0;\n  bool isJobStopped = *(char *)(jobStatusAddress + 748) == 0;\n  bool hasJobInfo = jobInfoAddress != 0;\n  bool isJobInfoValid = *(char *)(jobInfoAddress + 30) == 1;\n\n  if (isJobStopped && hasJobInfo && isJobInfoValid)\n  {\n    notify(\"You have stopped jobs.\\n\");\n    *(char *)(jobStatusAddress + 748) = 2;\n    result = 1;\n  }\n\n  return result;\n}",
        "baseline_code_stripped": "__int64 sub_472FFC()\n{\n  unsigned int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = 0;\n  if ( !*(_BYTE *)(qword_75D418 + 748) && qword_75AFB0 && *(_BYTE *)(qword_75AFB0 + 30) == 1 )\n  {\n    sub_46E2EB(\"You have stopped jobs.\\n\");\n    *(_BYTE *)(qword_75D418 + 748) = 2;\n    return 1;\n  }\n  return v1;\n}\n",
        "baseline_code_debug": "int __cdecl stoppedjobs()\n{\n  int retval; // [rsp+Ch] [rbp-4h]\n\n  retval = 0;\n  if ( !ash_ptr_to_globals_misc->job_warning && curjob && *((_BYTE *)curjob + 30) == 1 )\n  {\n    out2str(\"You have stopped jobs.\\n\");\n    ash_ptr_to_globals_misc->job_warning = 2;\n    return 1;\n  }\n  return retval;\n}\n",
        "similarity_score_unixcoder": 0.7312017679214478,
        "similarity_score_baseline_stripped": 0.5042272210121155,
        "similarity_score_baseline_debug": 0.8050308227539062
    },
    {
        "func_name": "read_pid",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_430F61(const char *a1)\n{\n  char v2[140]; // [rsp+10h] [rbp-90h] BYREF\n  int v3; // [rsp+9Ch] [rbp-4h]\n\n  v3 = sub_40B501(a1, v2, 0x7FuLL);\n  if ( v3 <= 0 )\n    return 0LL;\n  v2[v3] = 0;\n  return sub_43060C(v2, 0LL, 10);\n}\n",
        "output": "```c\nlong long sub_430F61(const char *input)\n{\n  char buffer[140];\n  int length;\n\n  length = sub_40B501(input, buffer, 127);\n  if (length <= 0)\n    return 0;\n  buffer[length] = '\\0';\n  return sub_43060C(buffer, 0, 10);\n}\n```",
        "source_code": "if ENABLE_FEATURE_PIDFILE\nstatic NOINLINE pid_t read_pid(const char *filename)\n{\n\tint len;\n\tchar buf[128];\n\n\tlen = open_read_close(filename, buf, 127);\n\tif (len > 0) {\n\t\tbuf[len] = '\\0';\n\t\t/* returns ULONG_MAX on error => -1 */\n\t\treturn bb_strtoul(buf, NULL, 10);\n\t}\n\treturn 0;\n}",
        "parsed_output": "long long sub_430F61(const char *input)\n{\n  char buffer[140];\n  int length;\n\n  length = sub_40B501(input, buffer, 127);\n  if (length <= 0)\n    return 0;\n  buffer[length] = '\\0';\n  return sub_43060C(buffer, 0, 10);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_430F61(const char *a1)\n{\n  char v2[140]; // [rsp+10h] [rbp-90h] BYREF\n  int v3; // [rsp+9Ch] [rbp-4h]\n\n  v3 = sub_40B501(a1, v2, 0x7FuLL);\n  if ( v3 <= 0 )\n    return 0LL;\n  v2[v3] = 0;\n  return sub_43060C(v2, 0LL, 10);\n}\n",
        "baseline_code_debug": "pid_t __cdecl read_pid(const char *filename)\n{\n  char buf[128]; // [rsp+10h] [rbp-90h] BYREF\n  int len; // [rsp+9Ch] [rbp-4h]\n\n  len = open_read_close(filename, buf, 0x7FuLL);\n  if ( len <= 0 )\n    return 0;\n  buf[len] = 0;\n  return bb_strtoul_0(buf, 0LL, 10);\n}\n",
        "similarity_score_unixcoder": 0.5541483163833618,
        "similarity_score_baseline_stripped": 0.4914260506629944,
        "similarity_score_baseline_debug": 0.7908037900924683
    },
    {
        "func_name": "get_sname",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_43A0F8(int a1, const char *a2, int a3)\n{\n  uint16_t v4; // ax\n  struct servent *v5; // [rsp+18h] [rbp-8h]\n\n  if ( !a1 )\n    return \"*\";\n  if ( !a3 )\n  {\n    v5 = getservbyport(a1, a2);\n    if ( v5 )\n      return v5->s_name;\n  }\n  v4 = ntohs(a1);\n  return sub_409B8C(v4);\n}\n",
        "output": "const char *getServiceNameByPort(int port, const char *protocol, int useNumeric)\n{\n  uint16_t portNetworkByteOrder;\n  struct servent *serviceEntry;\n\n  if (port == 0)\n    return \"*\";\n  \n  if (!useNumeric)\n  {\n    serviceEntry = getservbyport(port, protocol);\n    if (serviceEntry)\n      return serviceEntry->s_name;\n  }\n  \n  portNetworkByteOrder = ntohs(port);\n  return getNumericServiceName(portNetworkByteOrder);\n}",
        "source_code": "static const char *get_sname(int port, const char *proto, int numeric)\n{\n\tif (!port)\n\t\treturn \"*\";\n\tif (!numeric) {\n\t\tstruct servent *se = getservbyport(port, proto);\n\t\tif (se)\n\t\t\treturn se->s_name;\n\t}\n\t/* hummm, we may return static buffer here!! */\n\treturn itoa(ntohs(port));\n}",
        "parsed_output": "const char *getServiceNameByPort(int port, const char *protocol, int useNumeric)\n{\n  uint16_t portNetworkByteOrder;\n  struct servent *serviceEntry;\n\n  if (port == 0)\n    return \"*\";\n  \n  if (!useNumeric)\n  {\n    serviceEntry = getservbyport(port, protocol);\n    if (serviceEntry)\n      return serviceEntry->s_name;\n  }\n  \n  portNetworkByteOrder = ntohs(port);\n  return getNumericServiceName(portNetworkByteOrder);\n}",
        "baseline_code_stripped": "const char *__fastcall sub_43A0F8(int a1, const char *a2, int a3)\n{\n  uint16_t v4; // ax\n  struct servent *v5; // [rsp+18h] [rbp-8h]\n\n  if ( !a1 )\n    return \"*\";\n  if ( !a3 )\n  {\n    v5 = getservbyport(a1, a2);\n    if ( v5 )\n      return v5->s_name;\n  }\n  v4 = ntohs(a1);\n  return sub_409B8C(v4);\n}\n",
        "baseline_code_debug": "const char *__cdecl get_sname(int port, const char *proto, int numeric)\n{\n  uint16_t v4; // ax\n  struct servent *se; // [rsp+18h] [rbp-8h]\n\n  if ( !port )\n    return \"*\";\n  if ( !numeric )\n  {\n    se = getservbyport(port, proto);\n    if ( se )\n      return se->s_name;\n  }\n  v4 = ntohs(port);\n  return itoa(v4);\n}\n",
        "similarity_score_unixcoder": 0.8047495484352112,
        "similarity_score_baseline_stripped": 0.6137388348579407,
        "similarity_score_baseline_debug": 0.7830277681350708
    },
    {
        "func_name": "inflate_codes_setup",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4B90C7(__int64 a1, int a2, int a3)\n{\n  __int64 result; // rax\n\n  *(_DWORD *)(a1 + 112) = a2;\n  *(_DWORD *)(a1 + 116) = a3;\n  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a1 + 40);\n  *(_DWORD *)(a1 + 84) = *(unsigned __int8 *)(a1 + 44);\n  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 16);\n  *(_DWORD *)(a1 + 72) = (unsigned __int16)word_534E56[*(unsigned int *)(a1 + 112)];\n  result = a1;\n  *(_DWORD *)(a1 + 76) = (unsigned __int16)word_534E56[*(unsigned int *)(a1 + 116)];\n  return result;\n}\n",
        "output": "```c\nvoid updateStructureFields(void *structure, int field1Value, int field2Value)\n{\n  int *intPtr = (int *)structure;\n\n  intPtr[28] = field1Value; // Update field at offset 112\n  intPtr[29] = field2Value; // Update field at offset 116\n  intPtr[20] = intPtr[10];  // Copy value from offset 40 to offset 80\n  intPtr[21] = *((unsigned char *)structure + 44); // Copy value from offset 44 to offset 84\n  intPtr[22] = intPtr[4];   // Copy value from offset 16 to offset 88\n\n  // Lookup and store 16-bit value from external array 'word_534E56' using 'field1Value'\n  *((unsigned short *)(structure + 72)) = ((unsigned short *)word_534E56)[field1Value];\n\n  // Lookup and store 16-bit value from external array 'word_534E56' using 'field2Value'\n  *((unsigned short *)(structure + 76)) = ((unsigned short *)word_534E56)[field2Value];\n}\n```",
        "source_code": "define dd inflate_codes_dd\nstatic void inflate_codes_setup(STATE_PARAM unsigned my_bl, unsigned my_bd)\n{\n\tbl = my_bl;\n\tbd = my_bd;\n\t/* make local copies of globals */\n\tbb = gunzip_bb;\t\t\t/* initialize bit buffer */\n\tk = gunzip_bk;\n\tw = gunzip_outbuf_count;\t/* initialize gunzip_window position */\n\t/* inflate the coded data */\n\tml = mask_bits[bl];\t\t/* precompute masks for speed */\n\tmd = mask_bits[bd];\n}",
        "parsed_output": "void updateStructureFields(void *structure, int field1Value, int field2Value)\n{\n  int *intPtr = (int *)structure;\n\n  intPtr[28] = field1Value; // Update field at offset 112\n  intPtr[29] = field2Value; // Update field at offset 116\n  intPtr[20] = intPtr[10];  // Copy value from offset 40 to offset 80\n  intPtr[21] = *((unsigned char *)structure + 44); // Copy value from offset 44 to offset 84\n  intPtr[22] = intPtr[4];   // Copy value from offset 16 to offset 88\n\n  // Lookup and store 16-bit value from external array 'word_534E56' using 'field1Value'\n  *((unsigned short *)(structure + 72)) = ((unsigned short *)word_534E56)[field1Value];\n\n  // Lookup and store 16-bit value from external array 'word_534E56' using 'field2Value'\n  *((unsigned short *)(structure + 76)) = ((unsigned short *)word_534E56)[field2Value];\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4B90C7(__int64 a1, int a2, int a3)\n{\n  __int64 result; // rax\n\n  *(_DWORD *)(a1 + 112) = a2;\n  *(_DWORD *)(a1 + 116) = a3;\n  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a1 + 40);\n  *(_DWORD *)(a1 + 84) = *(unsigned __int8 *)(a1 + 44);\n  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 16);\n  *(_DWORD *)(a1 + 72) = (unsigned __int16)word_534E56[*(unsigned int *)(a1 + 112)];\n  result = a1;\n  *(_DWORD *)(a1 + 76) = (unsigned __int16)word_534E56[*(unsigned int *)(a1 + 116)];\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl inflate_codes_setup(state_t_0 *state, unsigned int my_bl, unsigned int my_bd)\n{\n  state->inflate_codes_bl = my_bl;\n  state->inflate_codes_bd = my_bd;\n  state->inflate_codes_bb = state->gunzip_bb;\n  state->inflate_codes_k = state->gunzip_bk;\n  state->inflate_codes_w = state->gunzip_outbuf_count;\n  state->inflate_codes_ml = mask_bits[state->inflate_codes_bl];\n  state->inflate_codes_md = mask_bits[state->inflate_codes_bd];\n}\n",
        "similarity_score_unixcoder": 0.386239618062973,
        "similarity_score_baseline_stripped": 0.4139185845851898,
        "similarity_score_baseline_debug": 0.8907904624938965
    },
    {
        "func_name": "to64_msb_first",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_505B2A(_BYTE *a1, unsigned int a2)\n{\n  char v2; // dl\n  _BYTE *result; // rax\n\n  *a1 = sub_504A59(a2 >> 18);\n  a1[1] = sub_504A59(a2 >> 12);\n  a1[2] = sub_504A59(a2 >> 6);\n  v2 = sub_504A59(a2);\n  result = a1 + 3;\n  a1[3] = v2;\n  return result;\n}\n",
        "output": "char *encode_four_bytes(char *buffer, unsigned int value)\n{\n  buffer[0] = encode_six_bits(value >> 18);\n  buffer[1] = encode_six_bits(value >> 12);\n  buffer[2] = encode_six_bits(value >> 6);\n  buffer[3] = encode_six_bits(value);\n  return buffer + 4;\n}",
        "source_code": "define DES_OUT_BUFSIZE 21\n\nstatic void\nto64_msb_first(char *s, unsigned v)\n{\n#if 0\n\t*s++ = ascii64[(v >> 18) & 0x3f]; /* bits 23..18 */\n\t*s++ = ascii64[(v >> 12) & 0x3f]; /* bits 17..12 */\n\t*s++ = ascii64[(v >> 6) & 0x3f]; /* bits 11..6 */\n\t*s   = ascii64[v & 0x3f]; /* bits 5..0 */\n#endif\n\t*s++ = i64c(v >> 18); /* bits 23..18 */\n\t*s++ = i64c(v >> 12); /* bits 17..12 */\n\t*s++ = i64c(v >> 6); /* bits 11..6 */\n\t*s   = i64c(v); /* bits 5..0 */\n}",
        "parsed_output": "char *encode_four_bytes(char *buffer, unsigned int value)\n{\n  buffer[0] = encode_six_bits(value >> 18);\n  buffer[1] = encode_six_bits(value >> 12);\n  buffer[2] = encode_six_bits(value >> 6);\n  buffer[3] = encode_six_bits(value);\n  return buffer + 4;\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_505B2A(_BYTE *a1, unsigned int a2)\n{\n  char v2; // dl\n  _BYTE *result; // rax\n\n  *a1 = sub_504A59(a2 >> 18);\n  a1[1] = sub_504A59(a2 >> 12);\n  a1[2] = sub_504A59(a2 >> 6);\n  v2 = sub_504A59(a2);\n  result = a1 + 3;\n  a1[3] = v2;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl to64_msb_first(char *s, unsigned int v)\n{\n  *s = i64c(v >> 18);\n  s[1] = i64c(v >> 12);\n  s[2] = i64c(v >> 6);\n  s[3] = i64c(v);\n}\n",
        "similarity_score_unixcoder": 0.7172127366065979,
        "similarity_score_baseline_stripped": 0.5809218883514404,
        "similarity_score_baseline_debug": 0.7810748815536499
    },
    {
        "func_name": "edir",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_467E33(const char *a1)\n{\n  __int64 v1; // rsi\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  __int64 v10; // rcx\n  __int64 v11; // r8\n  __int64 v12; // r9\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  char s[263]; // [rsp+10h] [rbp-130h] BYREF\n  unsigned __int8 v19; // [rsp+117h] [rbp-29h]\n  int v20; // [rsp+118h] [rbp-28h]\n  int v21; // [rsp+11Ch] [rbp-24h]\n  struct dirent64 *v22; // [rsp+120h] [rbp-20h]\n  DIR *dirp; // [rsp+128h] [rbp-18h]\n  int fd; // [rsp+134h] [rbp-Ch]\n  char *v25; // [rsp+138h] [rbp-8h]\n\n  v1 = 2048LL;\n  fd = sub_40A295(\".\", 2048);\n  sub_40A8A7(a1);\n  dirp = sub_40A95A(\".\");\n  while ( 1 )\n  {\n    *(_DWORD *)qword_75D400 = 0;\n    v22 = readdir64(dirp);\n    if ( !v22 )\n      break;\n    if ( v22->d_name[0] != 46 )\n    {\n      v1 = 2048LL;\n      v21 = open64(v22->d_name, 2048);\n      if ( v21 >= 0 )\n      {\n        v1 = (__int64)s;\n        v20 = sub_40B446(v21, s, 0xFFuLL);\n        close(v21);\n        if ( v20 < 0 )\n          sub_4092A2((__int64)\"read %s/%s\", (__int64)a1, (__int64)v22->d_name, v13, v14, v15);\n        if ( v20 )\n        {\n          s[v20] = 10;\n          v25 = strchr(s, 10);\n          do\n          {\n            *v25-- = 0;\n            if ( v25 < s )\n              break;\n            v19 = *v25 - 9;\n          }\n          while ( v19 == 23 || v19 <= 4u );\n          v1 = (__int64)s;\n          sub_40A780(v22->d_name, s);\n        }\n        else\n        {\n          unsetenv(v22->d_name);\n        }\n      }\n      else\n      {\n        if ( *(_DWORD *)qword_75D400 != 21 || !a1 )\n          sub_4092A2((__int64)\"open %s/%s\", (__int64)a1, (__int64)v22->d_name, v10, v11, v12);\n        if ( (dword_75D450 & 0x10000) != 0 )\n        {\n          v1 = (__int64)a1;\n          sub_4091D9((__int64)\"warning: %s/%s is a directory\", (__int64)a1, (__int64)v22->d_name, v10, v11, v12);\n        }\n      }\n    }\n  }\n  if ( *(_DWORD *)qword_75D400 )\n    sub_4092A2((__int64)\"readdir %s\", (__int64)a1, v2, v3, v4, v5);\n  closedir(dirp);\n  if ( fchdir(fd) == -1 )\n    sub_4092A2((__int64)\"fchdir\", v1, v6, v7, v8, v9);\n  return close(fd);\n}\n",
        "output": "```c\nint processDirectoryEntries(const char *directoryPath)\n{\n  int fileDescriptor;\n  int bytesRead;\n  int openResult;\n  struct dirent64 *entry;\n  DIR *directory;\n  char buffer[263];\n  unsigned char charDiff;\n  char *newlinePos;\n\n  fileDescriptor = openCurrentDirectory(\".\", 2048);\n  prepareForDirectoryProcessing(directoryPath);\n  directory = openDirectoryStream(\".\");\n  \n  while (1)\n  {\n    resetErrorState();\n    entry = readdir64(directory);\n    if (!entry)\n      break;\n    \n    if (entry->d_name[0] != '.')\n    {\n      openResult = openFileReadOnly(entry->d_name);\n      if (openResult >= 0)\n      {\n        bytesRead = readFile(openResult, buffer, 0xFF);\n        close(openResult);\n        \n        if (bytesRead < 0)\n          logError(\"read %s/%s\", directoryPath, entry->d_name);\n        \n        if (bytesRead)\n        {\n          buffer[bytesRead] = '\\n';\n          newlinePos = strchr(buffer, '\\n');\n          \n          do\n          {\n            *newlinePos-- = '\\0';\n            if (newlinePos < buffer)\n              break;\n            charDiff = *newlinePos - '\\t';\n          }\n          while (charDiff == 23 || charDiff <= 4);\n          \n          processFileContent(entry->d_name, buffer);\n        }\n        else\n        {\n          unsetEnvironmentVariable(entry->d_name);\n        }\n      }\n      else\n      {\n        if (getErrorState() != 21 || !directoryPath)\n          logError(\"open %s/%s\", directoryPath, entry->d_name);\n        \n        if (isDirectoryFlagSet())\n        {\n          logWarning(\"warning: %s/%s is a directory\", directoryPath, entry->d_name);\n        }\n      }\n    }\n  }\n  \n  if (getErrorState())\n    logError(\"readdir %s\", directoryPath);\n  \n  closeDirectoryStream(directory);\n  \n  if (returnToPreviousDirectory(fileDescriptor) == -1)\n    logError(\"fchdir\");\n  \n  return close(fileDescriptor);\n}\n```",
        "source_code": "static NOINLINE void edir(const char *directory_name)\n{\n\tint wdir;\n\tDIR *dir;\n\tstruct dirent *d;\n\tint fd;\n\n\twdir = xopen(\".\", O_RDONLY | O_NDELAY);\n\txchdir(directory_name);\n\tdir = xopendir(\".\");\n\tfor (;;) {\n\t\tchar buf[256];\n\t\tchar *tail;\n\t\tint size;\n\n\t\terrno = 0;\n\t\td = readdir(dir);\n\t\tif (!d) {\n\t\t\tif (errno)\n\t\t\t\tbb_perror_msg_and_die(\"readdir %s\",\n\t\t\t\t\t\tdirectory_name);\n\t\t\tbreak;\n\t\t}\n\t\tif (d->d_name[0] == '.')\n\t\t\tcontinue;\n\t\tfd = open(d->d_name, O_RDONLY | O_NDELAY);\n\t\tif (fd < 0) {\n\t\t\tif ((errno == EISDIR) && directory_name) {\n\t\t\t\tif (option_mask32 & OPT_v)\n\t\t\t\t\tbb_perror_msg(\"warning: %s/%s is a directory\",\n\t\t\t\t\t\tdirectory_name, d->d_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbb_perror_msg_and_die(\"open %s/%s\",\n\t\t\t\t\t\tdirectory_name, d->d_name);\n\t\t}\n\t\tsize = full_read(fd, buf, sizeof(buf)-1);\n\t\tclose(fd);\n\t\tif (size < 0)\n\t\t\tbb_perror_msg_and_die(\"read %s/%s\",\n\t\t\t\t\tdirectory_name, d->d_name);\n\t\tif (size == 0) {\n\t\t\tunsetenv(d->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\tbuf[size] = '\\n';\n\t\ttail = strchr(buf, '\\n');\n\t\t/* skip trailing whitespace */\n\t\twhile (1) {\n\t\t\t*tail = '\\0';\n\t\t\ttail--;\n\t\t\tif (tail < buf || !isspace(*tail))\n\t\t\t\tbreak;\n\t\t}\n\t\txsetenv(d->d_name, buf);\n\t}\n\tclosedir(dir);\n\tif (fchdir(wdir) == -1)\n\t\tbb_perror_msg_and_die(\"fchdir\");\n\tclose(wdir);\n}",
        "parsed_output": "int processDirectoryEntries(const char *directoryPath)\n{\n  int fileDescriptor;\n  int bytesRead;\n  int openResult;\n  struct dirent64 *entry;\n  DIR *directory;\n  char buffer[263];\n  unsigned char charDiff;\n  char *newlinePos;\n\n  fileDescriptor = openCurrentDirectory(\".\", 2048);\n  prepareForDirectoryProcessing(directoryPath);\n  directory = openDirectoryStream(\".\");\n  \n  while (1)\n  {\n    resetErrorState();\n    entry = readdir64(directory);\n    if (!entry)\n      break;\n    \n    if (entry->d_name[0] != '.')\n    {\n      openResult = openFileReadOnly(entry->d_name);\n      if (openResult >= 0)\n      {\n        bytesRead = readFile(openResult, buffer, 0xFF);\n        close(openResult);\n        \n        if (bytesRead < 0)\n          logError(\"read %s/%s\", directoryPath, entry->d_name);\n        \n        if (bytesRead)\n        {\n          buffer[bytesRead] = '\\n';\n          newlinePos = strchr(buffer, '\\n');\n          \n          do\n          {\n            *newlinePos-- = '\\0';\n            if (newlinePos < buffer)\n              break;\n            charDiff = *newlinePos - '\\t';\n          }\n          while (charDiff == 23 || charDiff <= 4);\n          \n          processFileContent(entry->d_name, buffer);\n        }\n        else\n        {\n          unsetEnvironmentVariable(entry->d_name);\n        }\n      }\n      else\n      {\n        if (getErrorState() != 21 || !directoryPath)\n          logError(\"open %s/%s\", directoryPath, entry->d_name);\n        \n        if (isDirectoryFlagSet())\n        {\n          logWarning(\"warning: %s/%s is a directory\", directoryPath, entry->d_name);\n        }\n      }\n    }\n  }\n  \n  if (getErrorState())\n    logError(\"readdir %s\", directoryPath);\n  \n  closeDirectoryStream(directory);\n  \n  if (returnToPreviousDirectory(fileDescriptor) == -1)\n    logError(\"fchdir\");\n  \n  return close(fileDescriptor);\n}",
        "baseline_code_stripped": "int __fastcall sub_467E33(const char *a1)\n{\n  __int64 v1; // rsi\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  __int64 v10; // rcx\n  __int64 v11; // r8\n  __int64 v12; // r9\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  char s[263]; // [rsp+10h] [rbp-130h] BYREF\n  unsigned __int8 v19; // [rsp+117h] [rbp-29h]\n  int v20; // [rsp+118h] [rbp-28h]\n  int v21; // [rsp+11Ch] [rbp-24h]\n  struct dirent64 *v22; // [rsp+120h] [rbp-20h]\n  DIR *dirp; // [rsp+128h] [rbp-18h]\n  int fd; // [rsp+134h] [rbp-Ch]\n  char *v25; // [rsp+138h] [rbp-8h]\n\n  v1 = 2048LL;\n  fd = sub_40A295(\".\", 2048);\n  sub_40A8A7(a1);\n  dirp = sub_40A95A(\".\");\n  while ( 1 )\n  {\n    *(_DWORD *)qword_75D400 = 0;\n    v22 = readdir64(dirp);\n    if ( !v22 )\n      break;\n    if ( v22->d_name[0] != 46 )\n    {\n      v1 = 2048LL;\n      v21 = open64(v22->d_name, 2048);\n      if ( v21 >= 0 )\n      {\n        v1 = (__int64)s;\n        v20 = sub_40B446(v21, s, 0xFFuLL);\n        close(v21);\n        if ( v20 < 0 )\n          sub_4092A2((__int64)\"read %s/%s\", (__int64)a1, (__int64)v22->d_name, v13, v14, v15);\n        if ( v20 )\n        {\n          s[v20] = 10;\n          v25 = strchr(s, 10);\n          do\n          {\n            *v25-- = 0;\n            if ( v25 < s )\n              break;\n            v19 = *v25 - 9;\n          }\n          while ( v19 == 23 || v19 <= 4u );\n          v1 = (__int64)s;\n          sub_40A780(v22->d_name, s);\n        }\n        else\n        {\n          unsetenv(v22->d_name);\n        }\n      }\n      else\n      {\n        if ( *(_DWORD *)qword_75D400 != 21 || !a1 )\n          sub_4092A2((__int64)\"open %s/%s\", (__int64)a1, (__int64)v22->d_name, v10, v11, v12);\n        if ( (dword_75D450 & 0x10000) != 0 )\n        {\n          v1 = (__int64)a1;\n          sub_4091D9((__int64)\"warning: %s/%s is a directory\", (__int64)a1, (__int64)v22->d_name, v10, v11, v12);\n        }\n      }\n    }\n  }\n  if ( *(_DWORD *)qword_75D400 )\n    sub_4092A2((__int64)\"readdir %s\", (__int64)a1, v2, v3, v4, v5);\n  closedir(dirp);\n  if ( fchdir(fd) == -1 )\n    sub_4092A2((__int64)\"fchdir\", v1, v6, v7, v8, v9);\n  return close(fd);\n}\n",
        "baseline_code_debug": "void __cdecl edir(const char *directory_name)\n{\n  char buf[256]; // [rsp+10h] [rbp-130h] BYREF\n  unsigned __int8 bb__isspace; // [rsp+117h] [rbp-29h]\n  int size; // [rsp+118h] [rbp-28h]\n  int fd; // [rsp+11Ch] [rbp-24h]\n  dirent *d; // [rsp+120h] [rbp-20h]\n  DIR *dir; // [rsp+128h] [rbp-18h]\n  int wdir; // [rsp+134h] [rbp-Ch]\n  char *tail; // [rsp+138h] [rbp-8h]\n\n  wdir = xopen(\".\", 2048);\n  xchdir(directory_name);\n  dir = xopendir(\".\");\n  while ( 1 )\n  {\n    *bb_errno = 0;\n    d = (dirent *)readdir64(dir);\n    if ( !d )\n      break;\n    if ( d->d_name[0] != 46 )\n    {\n      fd = open64(d->d_name, 2048);\n      if ( fd >= 0 )\n      {\n        size = full_read(fd, buf, 0xFFuLL);\n        close(fd);\n        if ( size < 0 )\n          bb_perror_msg_and_die(\"read %s/%s\", directory_name, d->d_name);\n        if ( size )\n        {\n          buf[size] = 10;\n          tail = strchr(buf, 10);\n          do\n          {\n            *tail-- = 0;\n            if ( tail < buf )\n              break;\n            bb__isspace = *tail - 9;\n          }\n          while ( bb__isspace == 23 || bb__isspace <= 4u );\n          xsetenv(d->d_name, buf);\n        }\n        else\n        {\n          unsetenv(d->d_name);\n        }\n      }\n      else\n      {\n        if ( *bb_errno != 21 || !directory_name )\n          bb_perror_msg_and_die(\"open %s/%s\", directory_name, d->d_name);\n        if ( (option_mask32 & 0x10000) != 0 )\n          bb_perror_msg(\"warning: %s/%s is a directory\", directory_name, d->d_name);\n      }\n    }\n  }\n  if ( *bb_errno )\n    bb_perror_msg_and_die(\"readdir %s\", directory_name);\n  closedir(dir);\n  if ( fchdir(wdir) == -1 )\n    bb_perror_msg_and_die(\"fchdir\");\n  close(wdir);\n}\n",
        "similarity_score_unixcoder": 0.7929733991622925,
        "similarity_score_baseline_stripped": 0.6583225727081299,
        "similarity_score_baseline_debug": 0.8760815858840942
    },
    {
        "func_name": "status_line",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *sub_4EFFAB(const char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)\n{\n  void *result; // rax\n  gcc_va_list arg; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v8; // [rsp+38h] [rbp-A8h]\n  __int64 v9; // [rsp+40h] [rbp-A0h]\n  __int64 v10; // [rsp+48h] [rbp-98h]\n  __int64 v11; // [rsp+50h] [rbp-90h]\n  __int64 v12; // [rsp+58h] [rbp-88h]\n\n  va_start(arg, a6);\n  v8 = a2;\n  v9 = a3;\n  v10 = a4;\n  v11 = a5;\n  v12 = a6;\n  arg[0].gp_offset = 8;\n  vsprintf((char *)qword_75D408 + 1008, a1, arg);\n  result = qword_75D408;\n  *((_DWORD *)qword_75D408 + 18) = 1;\n  return result;\n}\n",
        "output": "void *format_and_store_message(const char *format, __int64 arg1, __int64 arg2, __int64 arg3, __int64 arg4, __int64 arg5, ...)\n{\n  void *message_storage; // rax\n  va_list args; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 stored_arg1; // [rsp+38h] [rbp-A8h]\n  __int64 stored_arg2; // [rsp+40h] [rbp-A0h]\n  __int64 stored_arg3; // [rsp+48h] [rbp-98h]\n  __int64 stored_arg4; // [rsp+50h] [rbp-90h]\n  __int64 stored_arg5; // [rsp+58h] [rbp-88h]\n\n  va_start(args, arg5);\n  stored_arg1 = arg1;\n  stored_arg2 = arg2;\n  stored_arg3 = arg3;\n  stored_arg4 = arg4;\n  stored_arg5 = arg5;\n  args[0].gp_offset = 8;\n  vsprintf((char *)qword_75D408 + 1008, format, args);\n  message_storage = qword_75D408;\n  *((_DWORD *)qword_75D408 + 18) = 1;\n  return message_storage;\n}",
        "source_code": "format status buffer\nstatic void status_line(const char *format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tvsprintf(status_buffer, format, args);\n\tva_end(args);\n\n\thave_status_msg = 1;\n}",
        "parsed_output": "void *format_and_store_message(const char *format, __int64 arg1, __int64 arg2, __int64 arg3, __int64 arg4, __int64 arg5, ...)\n{\n  void *message_storage; // rax\n  va_list args; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 stored_arg1; // [rsp+38h] [rbp-A8h]\n  __int64 stored_arg2; // [rsp+40h] [rbp-A0h]\n  __int64 stored_arg3; // [rsp+48h] [rbp-98h]\n  __int64 stored_arg4; // [rsp+50h] [rbp-90h]\n  __int64 stored_arg5; // [rsp+58h] [rbp-88h]\n\n  va_start(args, arg5);\n  stored_arg1 = arg1;\n  stored_arg2 = arg2;\n  stored_arg3 = arg3;\n  stored_arg4 = arg4;\n  stored_arg5 = arg5;\n  args[0].gp_offset = 8;\n  vsprintf((char *)qword_75D408 + 1008, format, args);\n  message_storage = qword_75D408;\n  *((_DWORD *)qword_75D408 + 18) = 1;\n  return message_storage;\n}",
        "baseline_code_stripped": "void *sub_4EFFAB(const char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)\n{\n  void *result; // rax\n  gcc_va_list arg; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v8; // [rsp+38h] [rbp-A8h]\n  __int64 v9; // [rsp+40h] [rbp-A0h]\n  __int64 v10; // [rsp+48h] [rbp-98h]\n  __int64 v11; // [rsp+50h] [rbp-90h]\n  __int64 v12; // [rsp+58h] [rbp-88h]\n\n  va_start(arg, a6);\n  v8 = a2;\n  v9 = a3;\n  v10 = a4;\n  v11 = a5;\n  v12 = a6;\n  arg[0].gp_offset = 8;\n  vsprintf((char *)qword_75D408 + 1008, a1, arg);\n  result = qword_75D408;\n  *((_DWORD *)qword_75D408 + 18) = 1;\n  return result;\n}\n",
        "baseline_code_debug": "void status_line(const char *format, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list args; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(args, format);\n  v3 = va_arg(args, _QWORD);\n  v1 = va_arg(args, _QWORD);\n  v2 = va_arg(args, _QWORD);\n  v4 = va_arg(args, _QWORD);\n  v5 = va_arg(args, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  args[0].gp_offset = 8;\n  vsprintf((char *)&ptr_to_globals[3].tty_attrs.c_cc[31], format, args);\n  ptr_to_globals->speeds[5] = 1;\n}\n",
        "similarity_score_unixcoder": 0.499937504529953,
        "similarity_score_baseline_stripped": 0.4656757414340973,
        "similarity_score_baseline_debug": 0.5573415160179138
    },
    {
        "func_name": "cttyhack_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_47FB1D(__int64 a1, __int64 a2)\n{\n  int v3; // eax\n  __int16 v4[2]; // [rsp+10h] [rbp-120h] BYREF\n  unsigned int v5; // [rsp+14h] [rbp-11Ch]\n  char file[32]; // [rsp+100h] [rbp-30h] BYREF\n  char *v7; // [rsp+120h] [rbp-10h]\n  int v8; // [rsp+128h] [rbp-8h]\n  int fd; // [rsp+12Ch] [rbp-4h]\n\n  strcpy(file, \"/dev/tty\");\n  fd = open64(file, 2);\n  if ( fd < 0 )\n  {\n    v8 = sub_40B501(\"/sys/class/tty/console/active\", &file[5], 0x17uLL);\n    if ( v8 <= 0 )\n    {\n      if ( ioctl(0, 0x5603uLL, v4) )\n      {\n        if ( ioctl(0, 0x541EuLL, v4) )\n          file[0] = 0;\n        else\n          sprintf(&file[8], \"S%u\", v5);\n      }\n      else\n      {\n        sprintf(&file[8], \"%u\", (unsigned __int16)v4[0]);\n      }\n    }\n    else\n    {\n      file[v8 + 4] = 0;\n      v7 = strrchr(&file[5], 32);\n      if ( v7 )\n        sub_50800D(&file[5], v7 + 1);\n    }\n  }\n  if ( *(_QWORD *)(a2 + 8) )\n  {\n    if ( fd >= 0 || (fd = sub_40A32A(file, 2), fd >= 0) )\n    {\n      dup2(fd, 0);\n      dup2(fd, 1);\n      dup2(fd, 2);\n      while ( fd > 2 )\n      {\n        v3 = fd--;\n        close(v3);\n      }\n      ioctl(0, 0x540EuLL, 1LL);\n    }\n    sub_4F931D(a2 + 8);\n  }\n  if ( !file[0] )\n    return 1LL;\n  puts(file);\n  return 0LL;\n}\n",
        "output": "```c\nint openConsole(char *consolePath, int flags)\n{\n  int consoleDescriptor; // File descriptor for the console\n  __int16 ioctlData[2]; // Data for ioctl calls\n  unsigned int ioctlValue; // Value for ioctl calls\n  char defaultConsolePath[32]; // Default console path\n  char *activeConsole; // Pointer to the active console\n  int activeConsoleLength; // Length of the active console path\n  int fileDescriptor; // File descriptor for the active console\n\n  strcpy(defaultConsolePath, \"/dev/tty\");\n  fileDescriptor = open64(defaultConsolePath, flags);\n  if (fileDescriptor < 0)\n  {\n    activeConsoleLength = readActiveConsole(\"/sys/class/tty/console/active\", &defaultConsolePath[5], 0x17u);\n    if (activeConsoleLength <= 0)\n    {\n      if (ioctl(0, 0x5603u, ioctlData))\n      {\n        if (ioctl(0, 0x541Eu, ioctlData))\n          defaultConsolePath[0] = 0;\n        else\n          sprintf(&defaultConsolePath[8], \"S%u\", ioctlValue);\n      }\n      else\n      {\n        sprintf(&defaultConsolePath[8], \"%u\", (unsigned __int16)ioctlData[0]);\n      }\n    }\n    else\n    {\n      defaultConsolePath[activeConsoleLength + 4] = 0;\n      activeConsole = strrchr(&defaultConsolePath[5], ' ');\n      if (activeConsole)\n        removeSpaces(&defaultConsolePath[5], activeConsole + 1);\n    }\n  }\n  if (*(_QWORD *)(consolePath + 8))\n  {\n    if (fileDescriptor >= 0 || (fileDescriptor = openConsole(defaultConsolePath, flags), fileDescriptor >= 0))\n    {\n      dup2(fileDescriptor, STDIN_FILENO);\n      dup2(fileDescriptor, STDOUT_FILENO);\n      dup2(fileDescriptor, STDERR_FILENO);\n      while (fileDescriptor > STDERR_FILENO)\n      {\n        consoleDescriptor = fileDescriptor--;\n        close(consoleDescriptor);\n      }\n      ioctl(STDIN_FILENO, 0x540Eu, 1LL);\n    }\n    finalizeConsole(consolePath + 8);\n  }\n  if (!defaultConsolePath[0])\n    return 1;\n  puts(defaultConsolePath);\n  return 0;\n}\n```",
        "source_code": "int cttyhack_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint fd;\n\tchar console[sizeof(int)*3 + 16];\n\tunion {\n\t\tstruct vt_stat vt;\n\t\tstruct serial_struct sr;\n\t\tchar paranoia[sizeof(struct serial_struct) * 3];\n\t} u;\n\n\tstrcpy(console, \"/dev/tty\");\n\tfd = open(console, O_RDWR);\n\tif (fd < 0) {\n\t\t/* We don't have ctty (or don't have \"/dev/tty\" node...) */\n\t\tdo {\n#ifdef __linux__\n\t\t\t/* Note that this method does not use _stdin_.\n\t\t\t * Thus, \"cttyhack </dev/something\" can't be used.\n\t\t\t * However, this method is more reliable than\n\t\t\t * TIOCGSERIAL check, which assumes that all\n\t\t\t * serial lines follow /dev/ttySn convention -\n\t\t\t * which is not always the case.\n\t\t\t * Therefore, we use this method first:\n\t\t\t */\n\t\t\tint s = open_read_close(\"/sys/class/tty/console/active\",\n\t\t\t\tconsole + 5, sizeof(console) - 5);\n\t\t\tif (s > 0) {\n\t\t\t\tchar *last;\n\t\t\t\t/* Found active console via sysfs (Linux 2.6.38+).\n\t\t\t\t * It looks like \"[tty0 ]ttyS0\\n\" so zap the newline:\n\t\t\t\t */\n\t\t\t\tconsole[4 + s] = '\\0';\n\t\t\t\t/* If there are multiple consoles,\n\t\t\t\t * take the last one:\n\t\t\t\t */\n\t\t\t\tlast = strrchr(console + 5, ' ');\n\t\t\t\tif (last)\n\t\t\t\t\toverlapping_strcpy(console + 5, last + 1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (ioctl(0, VT_GETSTATE, &u.vt) == 0) {\n\t\t\t\t/* this is linux virtual tty */\n\t\t\t\tsprintf(console + 8, \"S%u\" + 1, (int)u.vt.v_active);\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n#ifdef TIOCGSERIAL\n\t\t\tif (ioctl(0, TIOCGSERIAL, &u.sr) == 0) {\n\t\t\t\t/* this is a serial console; assuming it is named /dev/ttySn */\n\t\t\t\tsprintf(console + 8, \"S%u\", (int)u.sr.line);\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\t/* nope, could not find it */\n\t\t\tconsole[0] = '\\0';\n\t\t} while (0);\n\t}\n\n\targv++;\n\tif (!argv[0]) {\n\t\tif (!console[0])\n\t\t\treturn EXIT_FAILURE;\n\t\tputs(console);\n\t\treturn EXIT_SUCCESS;\n\t}\n\n\tif (fd < 0) {\n\t\tfd = open_or_warn(console, O_RDWR);\n\t\tif (fd < 0)\n\t\t\tgoto ret;\n\t}\n\t//bb_error_msg(\"switching to '%s'\", console);\n\tdup2(fd, 0);\n\tdup2(fd, 1);\n\tdup2(fd, 2);\n\twhile (fd > 2)\n\t\tclose(fd--);\n\t/* Some other session may have it as ctty,\n\t * try to steal it from them:\n\t */\n\tioctl(0, TIOCSCTTY, 1);\n ret:\n\tBB_EXECVP_or_die(argv);\n}",
        "parsed_output": "int openConsole(char *consolePath, int flags)\n{\n  int consoleDescriptor; // File descriptor for the console\n  __int16 ioctlData[2]; // Data for ioctl calls\n  unsigned int ioctlValue; // Value for ioctl calls\n  char defaultConsolePath[32]; // Default console path\n  char *activeConsole; // Pointer to the active console\n  int activeConsoleLength; // Length of the active console path\n  int fileDescriptor; // File descriptor for the active console\n\n  strcpy(defaultConsolePath, \"/dev/tty\");\n  fileDescriptor = open64(defaultConsolePath, flags);\n  if (fileDescriptor < 0)\n  {\n    activeConsoleLength = readActiveConsole(\"/sys/class/tty/console/active\", &defaultConsolePath[5], 0x17u);\n    if (activeConsoleLength <= 0)\n    {\n      if (ioctl(0, 0x5603u, ioctlData))\n      {\n        if (ioctl(0, 0x541Eu, ioctlData))\n          defaultConsolePath[0] = 0;\n        else\n          sprintf(&defaultConsolePath[8], \"S%u\", ioctlValue);\n      }\n      else\n      {\n        sprintf(&defaultConsolePath[8], \"%u\", (unsigned __int16)ioctlData[0]);\n      }\n    }\n    else\n    {\n      defaultConsolePath[activeConsoleLength + 4] = 0;\n      activeConsole = strrchr(&defaultConsolePath[5], ' ');\n      if (activeConsole)\n        removeSpaces(&defaultConsolePath[5], activeConsole + 1);\n    }\n  }\n  if (*(_QWORD *)(consolePath + 8))\n  {\n    if (fileDescriptor >= 0 || (fileDescriptor = openConsole(defaultConsolePath, flags), fileDescriptor >= 0))\n    {\n      dup2(fileDescriptor, STDIN_FILENO);\n      dup2(fileDescriptor, STDOUT_FILENO);\n      dup2(fileDescriptor, STDERR_FILENO);\n      while (fileDescriptor > STDERR_FILENO)\n      {\n        consoleDescriptor = fileDescriptor--;\n        close(consoleDescriptor);\n      }\n      ioctl(STDIN_FILENO, 0x540Eu, 1LL);\n    }\n    finalizeConsole(consolePath + 8);\n  }\n  if (!defaultConsolePath[0])\n    return 1;\n  puts(defaultConsolePath);\n  return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_47FB1D(__int64 a1, __int64 a2)\n{\n  int v3; // eax\n  __int16 v4[2]; // [rsp+10h] [rbp-120h] BYREF\n  unsigned int v5; // [rsp+14h] [rbp-11Ch]\n  char file[32]; // [rsp+100h] [rbp-30h] BYREF\n  char *v7; // [rsp+120h] [rbp-10h]\n  int v8; // [rsp+128h] [rbp-8h]\n  int fd; // [rsp+12Ch] [rbp-4h]\n\n  strcpy(file, \"/dev/tty\");\n  fd = open64(file, 2);\n  if ( fd < 0 )\n  {\n    v8 = sub_40B501(\"/sys/class/tty/console/active\", &file[5], 0x17uLL);\n    if ( v8 <= 0 )\n    {\n      if ( ioctl(0, 0x5603uLL, v4) )\n      {\n        if ( ioctl(0, 0x541EuLL, v4) )\n          file[0] = 0;\n        else\n          sprintf(&file[8], \"S%u\", v5);\n      }\n      else\n      {\n        sprintf(&file[8], \"%u\", (unsigned __int16)v4[0]);\n      }\n    }\n    else\n    {\n      file[v8 + 4] = 0;\n      v7 = strrchr(&file[5], 32);\n      if ( v7 )\n        sub_50800D(&file[5], v7 + 1);\n    }\n  }\n  if ( *(_QWORD *)(a2 + 8) )\n  {\n    if ( fd >= 0 || (fd = sub_40A32A(file, 2), fd >= 0) )\n    {\n      dup2(fd, 0);\n      dup2(fd, 1);\n      dup2(fd, 2);\n      while ( fd > 2 )\n      {\n        v3 = fd--;\n        close(v3);\n      }\n      ioctl(0, 0x540EuLL, 1LL);\n    }\n    sub_4F931D(a2 + 8);\n  }\n  if ( !file[0] )\n    return 1LL;\n  puts(file);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl cttyhack_main(int argc, char **argv)\n{\n  int v3; // eax\n  cttyhack_main::$70BFC931D189B98CCBC096C3CF87EBE1 u; // [rsp+10h] [rbp-120h] BYREF\n  char console[28]; // [rsp+100h] [rbp-30h] BYREF\n  char *last; // [rsp+120h] [rbp-10h]\n  int s; // [rsp+128h] [rbp-8h]\n  int fd; // [rsp+12Ch] [rbp-4h]\n\n  strcpy(console, \"/dev/tty\");\n  fd = open64(console, 2);\n  if ( fd < 0 )\n  {\n    s = open_read_close(\"/sys/class/tty/console/active\", &console[5], 0x17uLL);\n    if ( s <= 0 )\n    {\n      if ( ioctl(0, 0x5603uLL, &u) )\n      {\n        if ( ioctl(0, 0x541EuLL, &u) )\n          console[0] = 0;\n        else\n          sprintf(&console[8], \"S%u\", (unsigned int)u.sr.line);\n      }\n      else\n      {\n        sprintf(&console[8], \"%u\", u.vt.v_active);\n      }\n    }\n    else\n    {\n      console[s + 4] = 0;\n      last = strrchr(&console[5], 32);\n      if ( last )\n        overlapping_strcpy(&console[5], last + 1);\n    }\n  }\n  if ( argv[1] )\n  {\n    if ( fd >= 0 || (fd = open_or_warn(console, 2), fd >= 0) )\n    {\n      dup2(fd, 0);\n      dup2(fd, 1);\n      dup2(fd, 2);\n      while ( fd > 2 )\n      {\n        v3 = fd--;\n        close(v3);\n      }\n      ioctl(0, 0x540EuLL, 1LL);\n    }\n    BB_EXECVP_or_die(argv + 1);\n  }\n  if ( !console[0] )\n    return 1;\n  puts(console);\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.7951364517211914,
        "similarity_score_baseline_stripped": 0.6866053938865662,
        "similarity_score_baseline_debug": 0.8573370575904846
    },
    {
        "func_name": "new_peer",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_438778(__int64 a1, __int64 a2)\n{\n  int v3; // eax\n  int v4; // [rsp+14h] [rbp-Ch]\n  _DWORD *v5; // [rsp+18h] [rbp-8h]\n\n  v5 = sub_40A0E8(0x40uLL, a2);\n  v4 = sub_449167(a1, v5);\n  if ( v4 < 0 )\n    return 0LL;\n  if ( (int)sub_448FDE(a1, (unsigned int)v4, (unsigned int)a2) < 0 )\n    return (unsigned int)v4;\n  v3 = fcntl(a2, 3);\n  BYTE1(v3) |= 8u;\n  v5[1] = v3;\n  sub_448DB4(a1, (unsigned int)a2);\n  return 0LL;\n}\n",
        "output": "```c\n__int64 __fastcall sub_438778(__int64 a1, __int64 a2)\n{\n  int result; // eax\n  int status; // [rsp+14h] [rbp-Ch]\n  _DWORD *buffer; // [rsp+18h] [rbp-8h]\n\n  buffer = sub_40A0E8(0x40uLL, a2);\n  status = sub_449167(a1, buffer);\n  if (status < 0)\n    return 0LL;\n  if (sub_448FDE(a1, (unsigned int)status, (unsigned int)a2) < 0)\n    return (unsigned int)status;\n  result = fcntl(a2, 3);\n  BYTE1(result) |= 8u;\n  buffer[1] = result;\n  sub_448DB4(a1, (unsigned int)a2);\n  return 0LL;\n}\n```",
        "source_code": "define bogouser bb_common_bufsiz1\n\nstatic int new_peer(isrv_state_t *state, int fd)\n{\n\tint peer;\n\tidentd_buf_t *buf = xzalloc(sizeof(*buf));\n\n\tpeer = isrv_register_peer(state, buf);\n\tif (peer < 0)\n\t\treturn 0; /* failure */\n\tif (isrv_register_fd(state, peer, fd) < 0)\n\t\treturn peer; /* failure, unregister peer */\n\n\tbuf->fd_flag = fcntl(fd, F_GETFL) | O_NONBLOCK;\n\tisrv_want_rd(state, fd);\n\treturn 0;\n}",
        "parsed_output": "__int64 __fastcall sub_438778(__int64 a1, __int64 a2)\n{\n  int result; // eax\n  int status; // [rsp+14h] [rbp-Ch]\n  _DWORD *buffer; // [rsp+18h] [rbp-8h]\n\n  buffer = sub_40A0E8(0x40uLL, a2);\n  status = sub_449167(a1, buffer);\n  if (status < 0)\n    return 0LL;\n  if (sub_448FDE(a1, (unsigned int)status, (unsigned int)a2) < 0)\n    return (unsigned int)status;\n  result = fcntl(a2, 3);\n  BYTE1(result) |= 8u;\n  buffer[1] = result;\n  sub_448DB4(a1, (unsigned int)a2);\n  return 0LL;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_438778(__int64 a1, __int64 a2)\n{\n  int v3; // eax\n  int v4; // [rsp+14h] [rbp-Ch]\n  _DWORD *v5; // [rsp+18h] [rbp-8h]\n\n  v5 = sub_40A0E8(0x40uLL, a2);\n  v4 = sub_449167(a1, v5);\n  if ( v4 < 0 )\n    return 0LL;\n  if ( (int)sub_448FDE(a1, (unsigned int)v4, (unsigned int)a2) < 0 )\n    return (unsigned int)v4;\n  v3 = fcntl(a2, 3);\n  BYTE1(v3) |= 8u;\n  v5[1] = v3;\n  sub_448DB4(a1, (unsigned int)a2);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl new_peer(isrv_state_t_0 *state, int fd)\n{\n  int v3; // eax\n  int peer; // [rsp+14h] [rbp-Ch]\n  identd_buf_t_0 *buf; // [rsp+18h] [rbp-8h]\n\n  buf = (identd_buf_t_0 *)xzalloc(0x40uLL);\n  peer = isrv_register_peer(state, buf);\n  if ( peer < 0 )\n    return 0;\n  if ( isrv_register_fd(state, peer, fd) < 0 )\n    return peer;\n  v3 = fcntl(fd, 3);\n  BYTE1(v3) |= 8u;\n  buf->fd_flag = v3;\n  isrv_want_rd(state, fd);\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.5307093858718872,
        "similarity_score_baseline_stripped": 0.46771714091300964,
        "similarity_score_baseline_debug": 0.8481420278549194
    },
    {
        "func_name": "vlock_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall __noreturn sub_4101A8(__int64 a1, int a2)\n{\n  __uid_t v2; // eax\n  int v3; // edx\n  int v4; // ecx\n  int v5; // r8d\n  int v6; // r9d\n  int v7; // eax\n  const char *v8; // rcx\n  struct termios termios_p; // [rsp+10h] [rbp-A0h] BYREF\n  struct termios v10; // [rsp+50h] [rbp-60h] BYREF\n  __int64 v11; // [rsp+98h] [rbp-18h] BYREF\n  __int64 v12; // [rsp+A0h] [rbp-10h] BYREF\n  const char **v13; // [rsp+A8h] [rbp-8h]\n\n  v2 = getuid();\n  v13 = (const char **)sub_4F62FD(v2);\n  qword_75D440 = (__int64)\"=0\";\n  sub_4FA1EF(a2, (unsigned int)\"a\", v3, v4, v5, v6, a2);\n  sub_508201(7471118LL, 1LL);\n  sub_5083CE(10LL, sub_41014E);\n  sub_5083CE(12LL, sub_410181);\n  sub_508327(10LL);\n  sub_508327(12LL);\n  v7 = sub_40A295(\"/dev/tty\", 2);\n  sub_40A477(v7, 0);\n  sub_40A443(0, 1u);\n  sub_40AD51(0, 0x5601u, (__int64)&v12, (__int64)\"VT_GETMODE\");\n  v11 = v12;\n  LOBYTE(v12) = 1;\n  *(_DWORD *)((char *)&v12 + 2) = 786442;\n  ioctl(0, 0x5602uLL, &v12);\n  tcgetattr(0, &termios_p);\n  v10.c_oflag = termios_p.c_oflag;\n  *(_QWORD *)&v10.c_cflag = *(_QWORD *)&termios_p.c_cflag & 0xFFFFFDF6FFFFFFFFLL;\n  *(_QWORD *)&v10.c_line = *(_QWORD *)&termios_p.c_line;\n  *(_QWORD *)&v10.c_cc[7] = *(_QWORD *)&termios_p.c_cc[7];\n  *(_QWORD *)&v10.c_cc[15] = *(_QWORD *)&termios_p.c_cc[15];\n  *(_QWORD *)&v10.c_cc[23] = *(_QWORD *)&termios_p.c_cc[23];\n  *(_QWORD *)&v10.c_cc[31] = *(_QWORD *)&termios_p.c_cc[31];\n  v10.c_ospeed = termios_p.c_ospeed;\n  v10.c_iflag = termios_p.c_iflag & 0xFFFFFFFC | 1;\n  sub_409F24(&v10);\n  while ( 1 )\n  {\n    if ( dword_75D450 )\n      v8 = \"s\";\n    else\n      v8 = \"\";\n    printf(\"Virtual console%s locked by %s.\\n\", v8, *v13);\n    if ( (unsigned int)sub_4F72A1(v13) )\n    {\n      ioctl(0, 0x5602uLL, &v11);\n      sub_409F24(&termios_p);\n      sub_4F93C9(0LL);\n    }\n    sub_4F620B(3LL);\n    puts(\"Incorrect password\");\n  }\n}\n",
        "output": "```c\n#include <termios.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <stdio.h>\n\n#define VT_GETMODE 0x5601\n#define VT_SETMODE 0x5602\n#define TTY_DEVICE \"/dev/tty\"\n\nextern void sub_4F62FD();\nextern void sub_4FA1EF();\nextern void sub_508201();\nextern void sub_5083CE();\nextern void sub_508327();\nextern int sub_40A295();\nextern void sub_40A477();\nextern void sub_40A443();\nextern void sub_40AD51();\nextern void sub_409F24();\nextern int sub_4F72A1();\nextern void sub_4F93C9();\nextern void sub_4F620B();\n\nextern int dword_75D450;\nextern const char *qword_75D440;\n\nvoid __fastcall __noreturn main(int argc)\n{\n  uid_t userId;\n  const char *userName;\n  struct termios originalTermios, modifiedTermios;\n  __int64 vtMode, originalVtMode;\n  int ttyFd;\n\n  userId = getuid();\n  userName = (const char *)sub_4F62FD(userId);\n  qword_75D440 = \"=0\";\n  sub_4FA1EF(argc, \"a\");\n  sub_508201(7471118LL, 1LL);\n  sub_5083CE(10LL, sub_41014E);\n  sub_5083CE(12LL, sub_410181);\n  sub_508327(10LL);\n  sub_508327(12LL);\n  ttyFd = sub_40A295(TTY_DEVICE, 2);\n  sub_40A477(ttyFd, 0);\n  sub_40A443(0, 1u);\n  sub_40AD51(0, VT_GETMODE, &originalVtMode, \"VT_GETMODE\");\n  vtMode = originalVtMode;\n  *((char *)&vtMode) = 1;\n  *((unsigned int *)((char *)&vtMode + 2)) = 786442;\n  ioctl(0, VT_SETMODE, &vtMode);\n  tcgetattr(0, &originalTermios);\n  modifiedTermios = originalTermios;\n  modifiedTermios.c_cflag &= 0xFFFFFDF6FFFFFFFFLL;\n  modifiedTermios.c_iflag = (originalTermios.c_iflag & 0xFFFFFFFC) | 1;\n  sub_409F24(&modifiedTermios);\n  \n  while (1)\n  {\n    const char *lockStatus = dword_75D450 ? \"s\" : \"\";\n    printf(\"Virtual console%s locked by %s.\\n\", lockStatus, userName);\n    if (sub_4F72A1(&userName))\n    {\n      ioctl(0, VT_SETMODE, &originalVtMode);\n      sub_409F24(&originalTermios);\n      sub_4F93C9(0LL);\n    }\n    sub_4F620B(3LL);\n    puts(\"Incorrect password\");\n  }\n}\n```",
        "source_code": "int vlock_main(int argc UNUSED_PARAM, char **argv)\n{\n#ifdef __linux__\n\tstruct vt_mode vtm;\n\tstruct vt_mode ovtm;\n#endif\n\tstruct termios term;\n\tstruct termios oterm;\n\tstruct passwd *pw;\n\n\tpw = xgetpwuid(getuid());\n\topt_complementary = \"=0\"; /* no params! */\n\tgetopt32(argv, \"a\");\n\n\t/* Ignore some signals so that we don't get killed by them */\n\tbb_signals(0\n\t\t+ (1 << SIGTSTP)\n\t\t+ (1 << SIGTTIN)\n\t\t+ (1 << SIGTTOU)\n\t\t+ (1 << SIGHUP )\n\t\t+ (1 << SIGCHLD) /* paranoia :) */\n\t\t+ (1 << SIGQUIT)\n\t\t+ (1 << SIGINT )\n\t\t, SIG_IGN);\n\n#ifdef __linux__\n\t/* We will use SIGUSRx for console switch control: */\n\t/* 1: set handlers */\n\tsignal_SA_RESTART_empty_mask(SIGUSR1, release_vt);\n\tsignal_SA_RESTART_empty_mask(SIGUSR2, acquire_vt);\n\t/* 2: unmask them */\n\tsig_unblock(SIGUSR1);\n\tsig_unblock(SIGUSR2);\n#endif\n\n\t/* Revert stdin/out to our controlling tty\n\t * (or die if we have none) */\n\txmove_fd(xopen(CURRENT_TTY, O_RDWR), STDIN_FILENO);\n\txdup2(STDIN_FILENO, STDOUT_FILENO);\n\n#ifdef __linux__\n\txioctl(STDIN_FILENO, VT_GETMODE, &vtm);\n\tovtm = vtm;\n\t/* \"console switches are controlled by us, not kernel!\" */\n\tvtm.mode = VT_PROCESS;\n\tvtm.relsig = SIGUSR1;\n\tvtm.acqsig = SIGUSR2;\n\tioctl(STDIN_FILENO, VT_SETMODE, &vtm);\n#endif\n\n\ttcgetattr(STDIN_FILENO, &oterm);\n\tterm = oterm;\n\tterm.c_iflag &= ~BRKINT;\n\tterm.c_iflag |= IGNBRK;\n\tterm.c_lflag &= ~ISIG;\n\tterm.c_lflag &= ~(ECHO | ECHOCTL);\n\ttcsetattr_stdin_TCSANOW(&term);\n\n\twhile (1) {\n\t\tprintf(\"Virtual console%s locked by %s.\\n\",\n\t\t\t\t/* \"s\" if -a, else \"\": */ \"s\" + !option_mask32,\n\t\t\t\tpw->pw_name\n\t\t);\n\t\tif (correct_password(pw)) {\n\t\t\tbreak;\n\t\t}\n\t\tbb_do_delay(LOGIN_FAIL_DELAY);\n\t\tputs(\"Incorrect password\");\n\t}\n\n#ifdef __linux__\n\tioctl(STDIN_FILENO, VT_SETMODE, &ovtm);\n#endif\n\ttcsetattr_stdin_TCSANOW(&oterm);\n\tfflush_stdout_and_exit(EXIT_SUCCESS);\n}",
        "parsed_output": "#include <termios.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <stdio.h>\n\n#define VT_GETMODE 0x5601\n#define VT_SETMODE 0x5602\n#define TTY_DEVICE \"/dev/tty\"\n\nextern void sub_4F62FD();\nextern void sub_4FA1EF();\nextern void sub_508201();\nextern void sub_5083CE();\nextern void sub_508327();\nextern int sub_40A295();\nextern void sub_40A477();\nextern void sub_40A443();\nextern void sub_40AD51();\nextern void sub_409F24();\nextern int sub_4F72A1();\nextern void sub_4F93C9();\nextern void sub_4F620B();\n\nextern int dword_75D450;\nextern const char *qword_75D440;\n\nvoid __fastcall __noreturn main(int argc)\n{\n  uid_t userId;\n  const char *userName;\n  struct termios originalTermios, modifiedTermios;\n  __int64 vtMode, originalVtMode;\n  int ttyFd;\n\n  userId = getuid();\n  userName = (const char *)sub_4F62FD(userId);\n  qword_75D440 = \"=0\";\n  sub_4FA1EF(argc, \"a\");\n  sub_508201(7471118LL, 1LL);\n  sub_5083CE(10LL, sub_41014E);\n  sub_5083CE(12LL, sub_410181);\n  sub_508327(10LL);\n  sub_508327(12LL);\n  ttyFd = sub_40A295(TTY_DEVICE, 2);\n  sub_40A477(ttyFd, 0);\n  sub_40A443(0, 1u);\n  sub_40AD51(0, VT_GETMODE, &originalVtMode, \"VT_GETMODE\");\n  vtMode = originalVtMode;\n  *((char *)&vtMode) = 1;\n  *((unsigned int *)((char *)&vtMode + 2)) = 786442;\n  ioctl(0, VT_SETMODE, &vtMode);\n  tcgetattr(0, &originalTermios);\n  modifiedTermios = originalTermios;\n  modifiedTermios.c_cflag &= 0xFFFFFDF6FFFFFFFFLL;\n  modifiedTermios.c_iflag = (originalTermios.c_iflag & 0xFFFFFFFC) | 1;\n  sub_409F24(&modifiedTermios);\n  \n  while (1)\n  {\n    const char *lockStatus = dword_75D450 ? \"s\" : \"\";\n    printf(\"Virtual console%s locked by %s.\\n\", lockStatus, userName);\n    if (sub_4F72A1(&userName))\n    {\n      ioctl(0, VT_SETMODE, &originalVtMode);\n      sub_409F24(&originalTermios);\n      sub_4F93C9(0LL);\n    }\n    sub_4F620B(3LL);\n    puts(\"Incorrect password\");\n  }\n}",
        "baseline_code_stripped": "void __fastcall __noreturn sub_4101A8(__int64 a1, int a2)\n{\n  __uid_t v2; // eax\n  int v3; // edx\n  int v4; // ecx\n  int v5; // r8d\n  int v6; // r9d\n  int v7; // eax\n  const char *v8; // rcx\n  struct termios termios_p; // [rsp+10h] [rbp-A0h] BYREF\n  struct termios v10; // [rsp+50h] [rbp-60h] BYREF\n  __int64 v11; // [rsp+98h] [rbp-18h] BYREF\n  __int64 v12; // [rsp+A0h] [rbp-10h] BYREF\n  const char **v13; // [rsp+A8h] [rbp-8h]\n\n  v2 = getuid();\n  v13 = (const char **)sub_4F62FD(v2);\n  qword_75D440 = (__int64)\"=0\";\n  sub_4FA1EF(a2, (unsigned int)\"a\", v3, v4, v5, v6, a2);\n  sub_508201(7471118LL, 1LL);\n  sub_5083CE(10LL, sub_41014E);\n  sub_5083CE(12LL, sub_410181);\n  sub_508327(10LL);\n  sub_508327(12LL);\n  v7 = sub_40A295(\"/dev/tty\", 2);\n  sub_40A477(v7, 0);\n  sub_40A443(0, 1u);\n  sub_40AD51(0, 0x5601u, (__int64)&v12, (__int64)\"VT_GETMODE\");\n  v11 = v12;\n  LOBYTE(v12) = 1;\n  *(_DWORD *)((char *)&v12 + 2) = 786442;\n  ioctl(0, 0x5602uLL, &v12);\n  tcgetattr(0, &termios_p);\n  v10.c_oflag = termios_p.c_oflag;\n  *(_QWORD *)&v10.c_cflag = *(_QWORD *)&termios_p.c_cflag & 0xFFFFFDF6FFFFFFFFLL;\n  *(_QWORD *)&v10.c_line = *(_QWORD *)&termios_p.c_line;\n  *(_QWORD *)&v10.c_cc[7] = *(_QWORD *)&termios_p.c_cc[7];\n  *(_QWORD *)&v10.c_cc[15] = *(_QWORD *)&termios_p.c_cc[15];\n  *(_QWORD *)&v10.c_cc[23] = *(_QWORD *)&termios_p.c_cc[23];\n  *(_QWORD *)&v10.c_cc[31] = *(_QWORD *)&termios_p.c_cc[31];\n  v10.c_ospeed = termios_p.c_ospeed;\n  v10.c_iflag = termios_p.c_iflag & 0xFFFFFFFC | 1;\n  sub_409F24(&v10);\n  while ( 1 )\n  {\n    if ( dword_75D450 )\n      v8 = \"s\";\n    else\n      v8 = \"\";\n    printf(\"Virtual console%s locked by %s.\\n\", v8, *v13);\n    if ( (unsigned int)sub_4F72A1(v13) )\n    {\n      ioctl(0, 0x5602uLL, &v11);\n      sub_409F24(&termios_p);\n      sub_4F93C9(0LL);\n    }\n    sub_4F620B(3LL);\n    puts(\"Incorrect password\");\n  }\n}\n",
        "baseline_code_debug": "int __cdecl __noreturn vlock_main(int argc, char **argv)\n{\n  __uid_t v2; // eax\n  int v3; // eax\n  const char *v4; // rcx\n  termios oterm; // [rsp+10h] [rbp-A0h] BYREF\n  termios term; // [rsp+50h] [rbp-60h] BYREF\n  vt_mode ovtm; // [rsp+98h] [rbp-18h] BYREF\n  vt_mode vtm; // [rsp+A0h] [rbp-10h] BYREF\n  passwd *pw; // [rsp+A8h] [rbp-8h]\n\n  v2 = getuid();\n  pw = xgetpwuid(v2);\n  opt_complementary = \"=0\";\n  getopt32(argv, \"a\");\n  bb_signals(7471118, (void (*)(int))1);\n  signal_SA_RESTART_empty_mask(10, (void (*)(int))release_vt);\n  signal_SA_RESTART_empty_mask(12, (void (*)(int))acquire_vt);\n  sig_unblock(10);\n  sig_unblock(12);\n  v3 = xopen(\"/dev/tty\", 2);\n  xmove_fd(v3, 0);\n  xdup2(0, 1);\n  bb_xioctl(0, 0x5601u, &vtm, \"VT_GETMODE\");\n  ovtm = vtm;\n  vtm.mode = 1;\n  vtm.relsig = 10;\n  vtm.acqsig = 12;\n  ioctl(0, 0x5602uLL, &vtm);\n  tcgetattr(0, &oterm);\n  term.c_oflag = oterm.c_oflag;\n  term.c_cflag = oterm.c_cflag;\n  *(_QWORD *)&term.c_line = *(_QWORD *)&oterm.c_line;\n  *(_QWORD *)&term.c_cc[7] = *(_QWORD *)&oterm.c_cc[7];\n  *(_QWORD *)&term.c_cc[15] = *(_QWORD *)&oterm.c_cc[15];\n  *(_QWORD *)&term.c_cc[23] = *(_QWORD *)&oterm.c_cc[23];\n  *(_QWORD *)&term.c_cc[31] = *(_QWORD *)&oterm.c_cc[31];\n  term.c_ospeed = oterm.c_ospeed;\n  term.c_iflag = oterm.c_iflag & 0xFFFFFFFC | 1;\n  term.c_lflag = oterm.c_lflag & 0xFFFFFDF6;\n  tcsetattr_stdin_TCSANOW(&term);\n  while ( 1 )\n  {\n    if ( option_mask32 )\n      v4 = \"s\";\n    else\n      v4 = \"\";\n    printf(\"Virtual console%s locked by %s.\\n\", v4, pw->pw_name);\n    if ( correct_password(pw) )\n    {\n      ioctl(0, 0x5602uLL, &ovtm);\n      tcsetattr_stdin_TCSANOW(&oterm);\n      fflush_stdout_and_exit(0);\n    }\n    bb_do_delay(3);\n    puts(\"Incorrect password\");\n  }\n}\n",
        "similarity_score_unixcoder": 0.7930235862731934,
        "similarity_score_baseline_stripped": 0.7419371008872986,
        "similarity_score_baseline_debug": 0.8954256176948547
    },
    {
        "func_name": "rtc_xopen",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_507C1B(const char **a1, int a2)\n{\n  int v3; // [rsp+1Ch] [rbp-4h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  if ( !*a1 )\n  {\n    *a1 = \"/dev/rtc\";\n    v3 = open64(*a1, a2);\n    if ( v3 >= 0 )\n      return (unsigned int)v3;\n    *a1 = \"/dev/rtc0\";\n    v4 = open64(*a1, a2);\n    if ( v4 >= 0 )\n      return (unsigned int)v4;\n    *a1 = \"/dev/misc/rtc\";\n  }\n  return sub_40A295(*a1, a2);\n}\n",
        "output": "```c\nint openRealTimeClock(const char **devicePath, int flags)\n{\n  int fileDescriptor;\n\n  if (!*devicePath)\n  {\n    *devicePath = \"/dev/rtc\";\n    fileDescriptor = open64(*devicePath, flags);\n    if (fileDescriptor >= 0)\n      return fileDescriptor;\n\n    *devicePath = \"/dev/rtc0\";\n    fileDescriptor = open64(*devicePath, flags);\n    if (fileDescriptor >= 0)\n      return fileDescriptor;\n\n    *devicePath = \"/dev/misc/rtc\";\n  }\n  return openDevice(*devicePath, flags);\n}\n```",
        "source_code": "int FAST_FUNC rtc_xopen(const char **default_rtc, int flags)\n{\n\tint rtc;\n\n\tif (!*default_rtc) {\n\t\t*default_rtc = \"/dev/rtc\";\n\t\trtc = open(*default_rtc, flags);\n\t\tif (rtc >= 0)\n\t\t\treturn rtc;\n\t\t*default_rtc = \"/dev/rtc0\";\n\t\trtc = open(*default_rtc, flags);\n\t\tif (rtc >= 0)\n\t\t\treturn rtc;\n\t\t*default_rtc = \"/dev/misc/rtc\";\n\t}\n\n\treturn xopen(*default_rtc, flags);\n}",
        "parsed_output": "int openRealTimeClock(const char **devicePath, int flags)\n{\n  int fileDescriptor;\n\n  if (!*devicePath)\n  {\n    *devicePath = \"/dev/rtc\";\n    fileDescriptor = open64(*devicePath, flags);\n    if (fileDescriptor >= 0)\n      return fileDescriptor;\n\n    *devicePath = \"/dev/rtc0\";\n    fileDescriptor = open64(*devicePath, flags);\n    if (fileDescriptor >= 0)\n      return fileDescriptor;\n\n    *devicePath = \"/dev/misc/rtc\";\n  }\n  return openDevice(*devicePath, flags);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_507C1B(const char **a1, int a2)\n{\n  int v3; // [rsp+1Ch] [rbp-4h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  if ( !*a1 )\n  {\n    *a1 = \"/dev/rtc\";\n    v3 = open64(*a1, a2);\n    if ( v3 >= 0 )\n      return (unsigned int)v3;\n    *a1 = \"/dev/rtc0\";\n    v4 = open64(*a1, a2);\n    if ( v4 >= 0 )\n      return (unsigned int)v4;\n    *a1 = \"/dev/misc/rtc\";\n  }\n  return sub_40A295(*a1, a2);\n}\n",
        "baseline_code_debug": "int __cdecl rtc_xopen(const char **default_rtc, int flags)\n{\n  int rtc; // [rsp+1Ch] [rbp-4h]\n  int rtca; // [rsp+1Ch] [rbp-4h]\n\n  if ( !*default_rtc )\n  {\n    *default_rtc = \"/dev/rtc\";\n    rtc = open64(*default_rtc, flags);\n    if ( rtc >= 0 )\n      return rtc;\n    *default_rtc = \"/dev/rtc0\";\n    rtca = open64(*default_rtc, flags);\n    if ( rtca >= 0 )\n      return rtca;\n    *default_rtc = \"/dev/misc/rtc\";\n  }\n  return xopen(*default_rtc, flags);\n}\n",
        "similarity_score_unixcoder": 0.8112115859985352,
        "similarity_score_baseline_stripped": 0.7127187252044678,
        "similarity_score_baseline_debug": 0.9098696708679199
    },
    {
        "func_name": "bzip2_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4ADBC4(unsigned int a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int v6; // ecx\n  int v7; // r8d\n  int v8; // r9d\n  unsigned int v10; // [rsp+1Ch] [rbp-4h]\n  unsigned int v11; // [rsp+1Ch] [rbp-4h]\n\n  qword_75D440 = (__int64)\"s2\";\n  v10 = sub_4FA1EF(a2, (unsigned int)\"cfvdt123456789qzs\", a3, a4, a5, a6);\n  if ( (v10 & 0x18) != 0 )\n    return sub_4A891B(a1, a2, a2, v6, v7, v8);\n  v11 = (unsigned __int8)(v10 >> 5) | 0x100;\n  byte_75B300 = 1;\n  while ( (v11 & 1) == 0 )\n  {\n    ++byte_75B300;\n    v11 >>= 1;\n  }\n  dword_75D450 &= 7u;\n  return sub_4A8417(\n           (char **)(8LL * optind + a2),\n           (const char *)sub_4ADB07,\n           (__int64 (__fastcall *)(char *, __int64))sub_4A83EB,\n           (__int64)\"bz2\");\n}\n",
        "output": "```c\n__int64 __fastcall processInput(unsigned int inputFlag, __int64 dataPtr, int arg3, int arg4, int arg5, int arg6)\n{\n  unsigned int resultFlag;\n  unsigned int shiftedFlag;\n\n  globalString = \"s2\";\n  resultFlag = performOperation(dataPtr, \"cfvdt123456789qzs\", arg3, arg4, arg5, arg6);\n  if ((resultFlag & 0x18) != 0)\n    return handleError(inputFlag, dataPtr, dataPtr, arg3, arg4, arg5);\n  \n  shiftedFlag = (unsigned __int8)(resultFlag >> 5) | 0x100;\n  globalCounter = 1;\n  while ((shiftedFlag & 1) == 0)\n  {\n    ++globalCounter;\n    shiftedFlag >>= 1;\n  }\n  \n  globalStatus &= 7u;\n  return processSubOperation(\n           (char **)(8LL * optind + dataPtr),\n           (const char *)getSubOperation,\n           (__int64 (__fastcall *)(char *, __int64))subOperation,\n           \"bz2\");\n}\n```",
        "source_code": "int bzip2_main(int argc UNUSED_PARAM, char **argv)\n{\n\tunsigned opt;\n\n\t/* standard bzip2 flags\n\t * -d --decompress force decompression\n\t * -z --compress force compression\n\t * -k --keep     keep (don't delete) input files\n\t * -f --force    overwrite existing output files\n\t * -t --test     test compressed file integrity\n\t * -c --stdout   output to standard out\n\t * -q --quiet    suppress noncritical error messages\n\t * -v --verbose  be verbose (a 2nd -v gives more)\n\t * -s --small    use less memory (at most 2500k)\n\t * -1 .. -9      set block size to 100k .. 900k\n\t * --fast        alias for -1\n\t * --best        alias for -9\n\t */\n\n\topt_complementary = \"s2\"; /* -s means -2 (compatibility) */\n\t/* Must match bbunzip's constants OPT_STDOUT, OPT_FORCE! */\n\topt = getopt32(argv, \"cfv\" IF_BUNZIP2(\"dt\") \"123456789qzs\");\n#if ENABLE_BUNZIP2 /* bunzip2_main may not be visible... */\n\tif (opt & 0x18) // -d and/or -t\n\t\treturn bunzip2_main(argc, argv);\n\topt >>= 5;\n#else\n\topt >>= 3;\n#endif\n\topt = (uint8_t)opt; /* isolate bits for -1..-8 */\n\topt |= 0x100; /* if nothing else, assume -9 */\n\tlevel = 1;\n\twhile (!(opt & 1)) {\n\t\tlevel++;\n\t\topt >>= 1;\n\t}\n\n\targv += optind;\n\toption_mask32 &= 0x7; /* ignore all except -cfv */\n\treturn bbunpack(argv, compressStream, append_ext, \"bz2\");\n}",
        "parsed_output": "__int64 __fastcall processInput(unsigned int inputFlag, __int64 dataPtr, int arg3, int arg4, int arg5, int arg6)\n{\n  unsigned int resultFlag;\n  unsigned int shiftedFlag;\n\n  globalString = \"s2\";\n  resultFlag = performOperation(dataPtr, \"cfvdt123456789qzs\", arg3, arg4, arg5, arg6);\n  if ((resultFlag & 0x18) != 0)\n    return handleError(inputFlag, dataPtr, dataPtr, arg3, arg4, arg5);\n  \n  shiftedFlag = (unsigned __int8)(resultFlag >> 5) | 0x100;\n  globalCounter = 1;\n  while ((shiftedFlag & 1) == 0)\n  {\n    ++globalCounter;\n    shiftedFlag >>= 1;\n  }\n  \n  globalStatus &= 7u;\n  return processSubOperation(\n           (char **)(8LL * optind + dataPtr),\n           (const char *)getSubOperation,\n           (__int64 (__fastcall *)(char *, __int64))subOperation,\n           \"bz2\");\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4ADBC4(unsigned int a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int v6; // ecx\n  int v7; // r8d\n  int v8; // r9d\n  unsigned int v10; // [rsp+1Ch] [rbp-4h]\n  unsigned int v11; // [rsp+1Ch] [rbp-4h]\n\n  qword_75D440 = (__int64)\"s2\";\n  v10 = sub_4FA1EF(a2, (unsigned int)\"cfvdt123456789qzs\", a3, a4, a5, a6);\n  if ( (v10 & 0x18) != 0 )\n    return sub_4A891B(a1, a2, a2, v6, v7, v8);\n  v11 = (unsigned __int8)(v10 >> 5) | 0x100;\n  byte_75B300 = 1;\n  while ( (v11 & 1) == 0 )\n  {\n    ++byte_75B300;\n    v11 >>= 1;\n  }\n  dword_75D450 &= 7u;\n  return sub_4A8417(\n           (char **)(8LL * optind + a2),\n           (const char *)sub_4ADB07,\n           (__int64 (__fastcall *)(char *, __int64))sub_4A83EB,\n           (__int64)\"bz2\");\n}\n",
        "baseline_code_debug": "int __cdecl bzip2_main(int argc, char **argv)\n{\n  unsigned int opt; // [rsp+1Ch] [rbp-4h]\n  unsigned int opta; // [rsp+1Ch] [rbp-4h]\n\n  opt_complementary = \"s2\";\n  opt = getopt32(argv, \"cfvdt123456789qzs\");\n  if ( (opt & 0x18) != 0 )\n    return bunzip2_main(argc, argv);\n  opta = (unsigned __int8)(opt >> 5) | 0x100;\n  level = 1;\n  while ( (opta & 1) == 0 )\n  {\n    ++level;\n    opta >>= 1;\n  }\n  option_mask32 &= 7u;\n  return bbunpack(\n           &argv[optind],\n           (__int64 (*)(transformer_aux_data_t_0 *))compressStream,\n           (char *(*)(char *, const char *))append_ext,\n           \"bz2\");\n}\n",
        "similarity_score_unixcoder": 0.5148314833641052,
        "similarity_score_baseline_stripped": 0.5557436347007751,
        "similarity_score_baseline_debug": 0.8256049156188965
    },
    {
        "func_name": "and",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_416213(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  double v10; // xmm0_8\n  unsigned __int64 v11; // rbx\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  double v16; // xmm0_8\n  unsigned __int64 v17; // rax\n  __int64 v18; // rax\n  double v19; // xmm0_8\n\n  v10 = sub_416051(a1, a2, a3, a4, a5, a6);\n  if ( v10 >= 9.223372036854776e18 )\n    v11 = (unsigned int)(int)(v10 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v11 = (unsigned int)(int)v10;\n  v16 = sub_416051(a1, a2, v6, v7, v8, v9);\n  if ( v16 >= 9.223372036854776e18 )\n  {\n    v12 = 0x8000000000000000LL;\n    v17 = (unsigned int)(int)(v16 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  }\n  else\n  {\n    v17 = (unsigned int)(int)v16;\n  }\n  v18 = v11 & v17;\n  if ( v18 < 0 )\n  {\n    v12 = v18 & 1 | ((unsigned __int64)v18 >> 1);\n    v19 = (double)(int)v12 + (double)(int)v12;\n  }\n  else\n  {\n    v19 = (double)(int)v18;\n  }\n  return sub_416006(v19, a1, a2, v12, v13, v14, v15);\n}\n",
        "output": "long long sub_416213(long long a1, long long a2, long long a3, long long a4, long long a5, long long a6)\n{\n  double firstResult;\n  unsigned long long firstProcessed;\n  double secondResult;\n  unsigned long long secondProcessed;\n  long long combinedResult;\n  double finalResult;\n\n  firstResult = sub_416051(a1, a2, a3, a4, a5, a6);\n  if (firstResult >= 9.223372036854776e18)\n    firstProcessed = (unsigned int)(int)(firstResult - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    firstProcessed = (unsigned int)(int)firstResult;\n\n  secondResult = sub_416051(a1, a2, a3, a4, a5, a6);\n  if (secondResult >= 9.223372036854776e18)\n    secondProcessed = (unsigned int)(int)(secondResult - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    secondProcessed = (unsigned int)(int)secondResult;\n\n  combinedResult = firstProcessed & secondProcessed;\n  if (combinedResult < 0)\n  {\n    combinedResult = (combinedResult & 1) | ((unsigned long long)combinedResult >> 1);\n    finalResult = (double)(int)combinedResult * 2;\n  }\n  else\n  {\n    finalResult = (double)(int)combinedResult;\n  }\n\n  return sub_416006(finalResult, a1, a2, combinedResult, a3, a4, a5);\n}",
        "source_code": "static void and(void)\n{\n\tpush((data_t) pop() & (data_t) pop());\n}",
        "parsed_output": "long long sub_416213(long long a1, long long a2, long long a3, long long a4, long long a5, long long a6)\n{\n  double firstResult;\n  unsigned long long firstProcessed;\n  double secondResult;\n  unsigned long long secondProcessed;\n  long long combinedResult;\n  double finalResult;\n\n  firstResult = sub_416051(a1, a2, a3, a4, a5, a6);\n  if (firstResult >= 9.223372036854776e18)\n    firstProcessed = (unsigned int)(int)(firstResult - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    firstProcessed = (unsigned int)(int)firstResult;\n\n  secondResult = sub_416051(a1, a2, a3, a4, a5, a6);\n  if (secondResult >= 9.223372036854776e18)\n    secondProcessed = (unsigned int)(int)(secondResult - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    secondProcessed = (unsigned int)(int)secondResult;\n\n  combinedResult = firstProcessed & secondProcessed;\n  if (combinedResult < 0)\n  {\n    combinedResult = (combinedResult & 1) | ((unsigned long long)combinedResult >> 1);\n    finalResult = (double)(int)combinedResult * 2;\n  }\n  else\n  {\n    finalResult = (double)(int)combinedResult;\n  }\n\n  return sub_416006(finalResult, a1, a2, combinedResult, a3, a4, a5);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_416213(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  double v10; // xmm0_8\n  unsigned __int64 v11; // rbx\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  double v16; // xmm0_8\n  unsigned __int64 v17; // rax\n  __int64 v18; // rax\n  double v19; // xmm0_8\n\n  v10 = sub_416051(a1, a2, a3, a4, a5, a6);\n  if ( v10 >= 9.223372036854776e18 )\n    v11 = (unsigned int)(int)(v10 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v11 = (unsigned int)(int)v10;\n  v16 = sub_416051(a1, a2, v6, v7, v8, v9);\n  if ( v16 >= 9.223372036854776e18 )\n  {\n    v12 = 0x8000000000000000LL;\n    v17 = (unsigned int)(int)(v16 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  }\n  else\n  {\n    v17 = (unsigned int)(int)v16;\n  }\n  v18 = v11 & v17;\n  if ( v18 < 0 )\n  {\n    v12 = v18 & 1 | ((unsigned __int64)v18 >> 1);\n    v19 = (double)(int)v12 + (double)(int)v12;\n  }\n  else\n  {\n    v19 = (double)(int)v18;\n  }\n  return sub_416006(v19, a1, a2, v12, v13, v14, v15);\n}\n",
        "baseline_code_debug": "void __cdecl and()\n{\n  double v0; // xmm0_8\n  unsigned __int64 v1; // rbx\n  double v2; // xmm0_8\n  unsigned __int64 v3; // rax\n  __int64 v4; // rax\n  double v5; // xmm0_8\n\n  v0 = pop();\n  if ( v0 >= 9.223372036854776e18 )\n    v1 = (unsigned int)(int)(v0 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v1 = (unsigned int)(int)v0;\n  v2 = pop();\n  if ( v2 >= 9.223372036854776e18 )\n    v3 = (unsigned int)(int)(v2 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v3 = (unsigned int)(int)v2;\n  v4 = v1 & v3;\n  if ( v4 < 0 )\n    v5 = (double)(int)(v4 & 1 | ((unsigned __int64)v4 >> 1)) + (double)(int)(v4 & 1 | ((unsigned __int64)v4 >> 1));\n  else\n    v5 = (double)(int)v4;\n  push(v5);\n}\n",
        "similarity_score_unixcoder": 0.4249269366264343,
        "similarity_score_baseline_stripped": 0.39724287390708923,
        "similarity_score_baseline_debug": 0.5733987092971802
    },
    {
        "func_name": "handle_upload_common",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_42A2E9(int a1, __int64 a2)\n{\n  const char *v2; // rax\n  struct stat64 stat_buf; // [rsp+10h] [rbp-C0h] BYREF\n  __int64 v4; // [rsp+A8h] [rbp-28h]\n  int fd; // [rsp+B4h] [rbp-1Ch]\n  __off64_t v6; // [rsp+B8h] [rbp-18h]\n  int oflag; // [rsp+C0h] [rbp-10h]\n  int fildes; // [rsp+C4h] [rbp-Ch]\n  void *ptr; // [rsp+C8h] [rbp-8h]\n\n  v6 = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&dest.c_cc[15] = 0LL;\n  if ( (unsigned int)sub_4298DE() )\n  {\n    ptr = 0LL;\n    fildes = -1;\n    if ( (_DWORD)a2 )\n    {\n      ptr = sub_40A11F(\" FILE: uniq.XXXXXX\", a2);\n      fildes = mkstemp64((char *)ptr + 7);\n    }\n    else if ( *((_QWORD *)&dest + 8) )\n    {\n      oflag = 577;\n      if ( a1 )\n        oflag = 1089;\n      if ( v6 )\n        oflag = 65;\n      fildes = open64(*((const char **)&dest + 8), oflag, 438LL);\n    }\n    if ( fildes >= 0 && !sub_407E00(fildes, &stat_buf) && (stat_buf.st_mode & 0xF000) == 0x8000 )\n    {\n      dest.c_oflag = fildes;\n      if ( v6 )\n        sub_40A557(fildes, v6, 0);\n      if ( ptr )\n        v2 = (const char *)ptr;\n      else\n        v2 = \" Ok to send data\";\n      fd = sub_429885(v2);\n      free(ptr);\n      if ( fd >= 0 )\n      {\n        v4 = sub_40B366(fd, fildes);\n        close(fd);\n        if ( v4 >= 0 )\n          sub_429527(540422706);\n        else\n          sub_429570(540095796);\n      }\n    }\n    else\n    {\n      free(ptr);\n      sub_429570(540226869);\n      if ( fildes < 0 )\n        return;\n    }\n    close(fildes);\n    dest.c_oflag = 0;\n  }\n}\n",
        "output": "```c\nvoid __fastcall sub_42A2E9(int use_alternate_file, __int64 temp_file_prefix)\n{\n  struct stat64 stat_buf;\n  __int64 v6; // Previously unknown purpose variable\n  int file_descriptor;\n  __off64_t file_offset;\n  int open_flags;\n  int temp_file_descriptor;\n  void *temp_file_name;\n\n  file_offset = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&dest.c_cc[15] = 0LL;\n\n  if (sub_4298DE()) // Check some condition\n  {\n    temp_file_name = NULL;\n    temp_file_descriptor = -1;\n\n    if (temp_file_prefix)\n    {\n      temp_file_name = sub_40A11F(\" FILE: uniq.XXXXXX\", temp_file_prefix);\n      temp_file_descriptor = mkstemp64((char *)temp_file_name + 7);\n    }\n    else if (*((__int64 *)&dest + 8))\n    {\n      open_flags = O_RDWR | O_CREAT;\n      if (use_alternate_file)\n        open_flags = O_RDWR | O_CREAT | O_EXCL;\n      if (v6)\n        open_flags = O_RDONLY;\n\n      temp_file_descriptor = open64(*((__int64 *)&dest + 8), open_flags, 0666);\n    }\n\n    if (temp_file_descriptor >= 0 && !sub_407E00(temp_file_descriptor, &stat_buf) && (stat_buf.st_mode & S_IFMT) == S_IFREG)\n    {\n      dest.c_oflag = temp_file_descriptor;\n\n      if (v6)\n        sub_40A557(temp_file_descriptor, file_offset, 0);\n\n      const char *message = temp_file_name ? (const char *)temp_file_name : \" Ok to send data\";\n      file_descriptor = sub_429885(message);\n      free(temp_file_name);\n\n      if (file_descriptor >= 0)\n      {\n        __int64 result = sub_40B366(file_descriptor, temp_file_descriptor);\n        close(file_descriptor);\n\n        if (result >= 0)\n          sub_429527(540422706); // Success case\n        else\n          sub_429570(540095796); // Failure case\n      }\n    }\n    else\n    {\n      free(temp_file_name);\n      sub_429570(540226869); // Error case\n\n      if (temp_file_descriptor < 0)\n        return;\n    }\n\n    close(temp_file_descriptor);\n    dest.c_oflag = 0;\n  }\n}\n```",
        "source_code": "static void\nhandle_upload_common(int is_append, int is_unique)\n{\n\tstruct stat statbuf;\n\tchar *tempname;\n\toff_t bytes_transferred;\n\toff_t offset;\n\tint local_file_fd;\n\tint remote_fd;\n\n\toffset = G.restart_pos;\n\tG.restart_pos = 0;\n\n\tif (!port_or_pasv_was_seen())\n\t\treturn; /* port_or_pasv_was_seen emitted error response */\n\n\ttempname = NULL;\n\tlocal_file_fd = -1;\n\tif (is_unique) {\n\t\ttempname = xstrdup(\" FILE: uniq.XXXXXX\");\n\t\tlocal_file_fd = mkstemp(tempname + 7);\n\t} else if (G.ftp_arg) {\n\t\tint flags = O_WRONLY | O_CREAT | O_TRUNC;\n\t\tif (is_append)\n\t\t\tflags = O_WRONLY | O_CREAT | O_APPEND;\n\t\tif (offset)\n\t\t\tflags = O_WRONLY | O_CREAT;\n\t\tlocal_file_fd = open(G.ftp_arg, flags, 0666);\n\t}\n\n\tif (local_file_fd < 0\n\t || fstat(local_file_fd, &statbuf) != 0\n\t || !S_ISREG(statbuf.st_mode)\n\t) {\n\t\tfree(tempname);\n\t\tWRITE_ERR(FTP_UPLOADFAIL);\n\t\tif (local_file_fd >= 0)\n\t\t\tgoto close_local_and_bail;\n\t\treturn;\n\t}\n\tG.local_file_fd = local_file_fd;\n\n\tif (offset)\n\t\txlseek(local_file_fd, offset, SEEK_SET);\n\n\tremote_fd = get_remote_transfer_fd(tempname ? tempname : \" Ok to send data\");\n\tfree(tempname);\n\n\tif (remote_fd < 0)\n\t\tgoto close_local_and_bail;\n\n\tbytes_transferred = bb_copyfd_eof(remote_fd, local_file_fd);\n\tclose(remote_fd);\n\tif (bytes_transferred < 0)\n\t\tWRITE_ERR(FTP_BADSENDFILE);\n\telse\n\t\tWRITE_OK(FTP_TRANSFEROK);\n\n close_local_and_bail:\n\tclose(local_file_fd);\n\tG.local_file_fd = 0;\n}",
        "parsed_output": "void __fastcall sub_42A2E9(int use_alternate_file, __int64 temp_file_prefix)\n{\n  struct stat64 stat_buf;\n  __int64 v6; // Previously unknown purpose variable\n  int file_descriptor;\n  __off64_t file_offset;\n  int open_flags;\n  int temp_file_descriptor;\n  void *temp_file_name;\n\n  file_offset = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&dest.c_cc[15] = 0LL;\n\n  if (sub_4298DE()) // Check some condition\n  {\n    temp_file_name = NULL;\n    temp_file_descriptor = -1;\n\n    if (temp_file_prefix)\n    {\n      temp_file_name = sub_40A11F(\" FILE: uniq.XXXXXX\", temp_file_prefix);\n      temp_file_descriptor = mkstemp64((char *)temp_file_name + 7);\n    }\n    else if (*((__int64 *)&dest + 8))\n    {\n      open_flags = O_RDWR | O_CREAT;\n      if (use_alternate_file)\n        open_flags = O_RDWR | O_CREAT | O_EXCL;\n      if (v6)\n        open_flags = O_RDONLY;\n\n      temp_file_descriptor = open64(*((__int64 *)&dest + 8), open_flags, 0666);\n    }\n\n    if (temp_file_descriptor >= 0 && !sub_407E00(temp_file_descriptor, &stat_buf) && (stat_buf.st_mode & S_IFMT) == S_IFREG)\n    {\n      dest.c_oflag = temp_file_descriptor;\n\n      if (v6)\n        sub_40A557(temp_file_descriptor, file_offset, 0);\n\n      const char *message = temp_file_name ? (const char *)temp_file_name : \" Ok to send data\";\n      file_descriptor = sub_429885(message);\n      free(temp_file_name);\n\n      if (file_descriptor >= 0)\n      {\n        __int64 result = sub_40B366(file_descriptor, temp_file_descriptor);\n        close(file_descriptor);\n\n        if (result >= 0)\n          sub_429527(540422706); // Success case\n        else\n          sub_429570(540095796); // Failure case\n      }\n    }\n    else\n    {\n      free(temp_file_name);\n      sub_429570(540226869); // Error case\n\n      if (temp_file_descriptor < 0)\n        return;\n    }\n\n    close(temp_file_descriptor);\n    dest.c_oflag = 0;\n  }\n}",
        "baseline_code_stripped": "void __fastcall sub_42A2E9(int a1, __int64 a2)\n{\n  const char *v2; // rax\n  struct stat64 stat_buf; // [rsp+10h] [rbp-C0h] BYREF\n  __int64 v4; // [rsp+A8h] [rbp-28h]\n  int fd; // [rsp+B4h] [rbp-1Ch]\n  __off64_t v6; // [rsp+B8h] [rbp-18h]\n  int oflag; // [rsp+C0h] [rbp-10h]\n  int fildes; // [rsp+C4h] [rbp-Ch]\n  void *ptr; // [rsp+C8h] [rbp-8h]\n\n  v6 = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&dest.c_cc[15] = 0LL;\n  if ( (unsigned int)sub_4298DE() )\n  {\n    ptr = 0LL;\n    fildes = -1;\n    if ( (_DWORD)a2 )\n    {\n      ptr = sub_40A11F(\" FILE: uniq.XXXXXX\", a2);\n      fildes = mkstemp64((char *)ptr + 7);\n    }\n    else if ( *((_QWORD *)&dest + 8) )\n    {\n      oflag = 577;\n      if ( a1 )\n        oflag = 1089;\n      if ( v6 )\n        oflag = 65;\n      fildes = open64(*((const char **)&dest + 8), oflag, 438LL);\n    }\n    if ( fildes >= 0 && !sub_407E00(fildes, &stat_buf) && (stat_buf.st_mode & 0xF000) == 0x8000 )\n    {\n      dest.c_oflag = fildes;\n      if ( v6 )\n        sub_40A557(fildes, v6, 0);\n      if ( ptr )\n        v2 = (const char *)ptr;\n      else\n        v2 = \" Ok to send data\";\n      fd = sub_429885(v2);\n      free(ptr);\n      if ( fd >= 0 )\n      {\n        v4 = sub_40B366(fd, fildes);\n        close(fd);\n        if ( v4 >= 0 )\n          sub_429527(540422706);\n        else\n          sub_429570(540095796);\n      }\n    }\n    else\n    {\n      free(ptr);\n      sub_429570(540226869);\n      if ( fildes < 0 )\n        return;\n    }\n    close(fildes);\n    dest.c_oflag = 0;\n  }\n}\n",
        "baseline_code_debug": "void __cdecl handle_upload_common(int is_append, int is_unique)\n{\n  char *v2; // rax\n  stat statbuf; // [rsp+10h] [rbp-C0h] BYREF\n  off_t bytes_transferred; // [rsp+A8h] [rbp-28h]\n  int remote_fd; // [rsp+B4h] [rbp-1Ch]\n  off_t offset; // [rsp+B8h] [rbp-18h]\n  int flags; // [rsp+C0h] [rbp-10h]\n  int local_file_fd; // [rsp+C4h] [rbp-Ch]\n  char *tempname; // [rsp+C8h] [rbp-8h]\n\n  offset = *(_QWORD *)&bb_common_bufsiz1.c_cc[15];\n  *(_QWORD *)&bb_common_bufsiz1.c_cc[15] = 0LL;\n  if ( port_or_pasv_was_seen() )\n  {\n    tempname = 0LL;\n    local_file_fd = -1;\n    if ( is_unique )\n    {\n      tempname = xstrdup(\" FILE: uniq.XXXXXX\");\n      local_file_fd = mkstemp64(tempname + 7);\n    }\n    else if ( *((_QWORD *)&bb_common_bufsiz1 + 8) )\n    {\n      flags = 577;\n      if ( is_append )\n        flags = 1089;\n      if ( offset )\n        flags = 65;\n      local_file_fd = open64(*((const char **)&bb_common_bufsiz1 + 8), flags, 438LL);\n    }\n    if ( local_file_fd >= 0 && !fstat64(local_file_fd, (stat64 *)&statbuf) && (statbuf.st_mode & 0xF000) == 0x8000 )\n    {\n      bb_common_bufsiz1.c_oflag = local_file_fd;\n      if ( offset )\n        xlseek(local_file_fd, offset, 0);\n      if ( tempname )\n        v2 = tempname;\n      else\n        v2 = \" Ok to send data\";\n      remote_fd = get_remote_transfer_fd(v2);\n      free(tempname);\n      if ( remote_fd >= 0 )\n      {\n        bytes_transferred = bb_copyfd_eof(remote_fd, local_file_fd);\n        close(remote_fd);\n        if ( bytes_transferred >= 0 )\n          cmdio_write_ok(0x20363232u);\n        else\n          cmdio_write_error(0x20313534u);\n      }\n    }\n    else\n    {\n      free(tempname);\n      cmdio_write_error(0x20333535u);\n      if ( local_file_fd < 0 )\n        return;\n    }\n    close(local_file_fd);\n    bb_common_bufsiz1.c_oflag = 0;\n  }\n}\n",
        "similarity_score_unixcoder": 0.6821755170822144,
        "similarity_score_baseline_stripped": 0.6097482442855835,
        "similarity_score_baseline_debug": 0.8599432706832886
    },
    {
        "func_name": "msort",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4765B8(__int64 a1, int a2)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h] BYREF\n  unsigned int v4; // [rsp+10h] [rbp-20h]\n  int v5; // [rsp+14h] [rbp-1Ch]\n  __int64 *v6; // [rsp+18h] [rbp-18h]\n  __int64 v7; // [rsp+20h] [rbp-10h]\n  __int64 v8; // [rsp+28h] [rbp-8h]\n\n  v3 = a1;\n  v7 = 0LL;\n  if ( a2 <= 1 )\n    return v3;\n  v4 = a2 >> 1;\n  v8 = v3;\n  v5 = a2 >> 1;\n  while ( --v5 >= 0 )\n  {\n    v7 = v8;\n    v8 = *(_QWORD *)v8;\n  }\n  *(_QWORD *)v7 = 0LL;\n  v7 = sub_4765B8(v3, v4);\n  v8 = sub_4765B8(v8, a2 - v4);\n  v6 = &v3;\n  do\n  {\n    while ( strcmp(*(const char **)(v8 + 8), *(const char **)(v7 + 8)) < 0 )\n    {\n      *v6 = v8;\n      v6 = (__int64 *)v8;\n      v8 = *(_QWORD *)v8;\n      if ( !v8 )\n      {\n        *v6 = v7;\n        return v3;\n      }\n    }\n    *v6 = v7;\n    v6 = (__int64 *)v7;\n    v7 = *(_QWORD *)v7;\n  }\n  while ( v7 );\n  *v6 = v8;\n  return v3;\n}\n",
        "output": "```c\ntypedef struct Node {\n    struct Node *next;\n    const char *data;\n} Node;\n\nNode* mergeSortLinkedList(Node *head, int count) {\n    Node *midPrev = NULL;\n    Node *slow = head;\n    Node *fast = head;\n    Node **indirect;\n\n    if (count <= 1) {\n        return head;\n    }\n\n    int midCount = count >> 1;\n    for (int i = 0; i < midCount; ++i) {\n        midPrev = slow;\n        slow = slow->next;\n    }\n    midPrev->next = NULL;\n\n    Node *leftHalf = mergeSortLinkedList(head, midCount);\n    Node *rightHalf = mergeSortLinkedList(slow, count - midCount);\n\n    indirect = &head;\n    while (leftHalf && rightHalf) {\n        if (strcmp(rightHalf->data, leftHalf->data) < 0) {\n            *indirect = rightHalf;\n            indirect = &rightHalf->next;\n            rightHalf = rightHalf->next;\n        } else {\n            *indirect = leftHalf;\n            indirect = &leftHalf->next;\n            leftHalf = leftHalf->next;\n        }\n    }\n\n    *indirect = (leftHalf == NULL) ? rightHalf : leftHalf;\n    return head;\n}\n```",
        "source_code": "static struct strlist *\nmsort(struct strlist *list, int len)\n{\n\tstruct strlist *p, *q = NULL;\n\tstruct strlist **lpp;\n\tint half;\n\tint n;\n\n\tif (len <= 1)\n\t\treturn list;\n\thalf = len >> 1;\n\tp = list;\n\tfor (n = half; --n >= 0;) {\n\t\tq = p;\n\t\tp = p->next;\n\t}\n\tq->next = NULL;                 /* terminate first half of list */\n\tq = msort(list, half);          /* sort first half of list */\n\tp = msort(p, len - half);               /* sort second half */\n\tlpp = &list;\n\tfor (;;) {\n#if ENABLE_LOCALE_SUPPORT\n\t\tif (strcoll(p->text, q->text) < 0)\n#else\n\t\tif (strcmp(p->text, q->text) < 0)\n#endif\n\t\t\t\t\t\t{\n\t\t\t*lpp = p;\n\t\t\tlpp = &p->next;\n\t\t\tp = *lpp;\n\t\t\tif (p == NULL) {\n\t\t\t\t*lpp = q;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t*lpp = q;\n\t\t\tlpp = &q->next;\n\t\t\tq = *lpp;\n\t\t\tif (q == NULL) {\n\t\t\t\t*lpp = p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}",
        "parsed_output": "typedef struct Node {\n    struct Node *next;\n    const char *data;\n} Node;\n\nNode* mergeSortLinkedList(Node *head, int count) {\n    Node *midPrev = NULL;\n    Node *slow = head;\n    Node *fast = head;\n    Node **indirect;\n\n    if (count <= 1) {\n        return head;\n    }\n\n    int midCount = count >> 1;\n    for (int i = 0; i < midCount; ++i) {\n        midPrev = slow;\n        slow = slow->next;\n    }\n    midPrev->next = NULL;\n\n    Node *leftHalf = mergeSortLinkedList(head, midCount);\n    Node *rightHalf = mergeSortLinkedList(slow, count - midCount);\n\n    indirect = &head;\n    while (leftHalf && rightHalf) {\n        if (strcmp(rightHalf->data, leftHalf->data) < 0) {\n            *indirect = rightHalf;\n            indirect = &rightHalf->next;\n            rightHalf = rightHalf->next;\n        } else {\n            *indirect = leftHalf;\n            indirect = &leftHalf->next;\n            leftHalf = leftHalf->next;\n        }\n    }\n\n    *indirect = (leftHalf == NULL) ? rightHalf : leftHalf;\n    return head;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4765B8(__int64 a1, int a2)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h] BYREF\n  unsigned int v4; // [rsp+10h] [rbp-20h]\n  int v5; // [rsp+14h] [rbp-1Ch]\n  __int64 *v6; // [rsp+18h] [rbp-18h]\n  __int64 v7; // [rsp+20h] [rbp-10h]\n  __int64 v8; // [rsp+28h] [rbp-8h]\n\n  v3 = a1;\n  v7 = 0LL;\n  if ( a2 <= 1 )\n    return v3;\n  v4 = a2 >> 1;\n  v8 = v3;\n  v5 = a2 >> 1;\n  while ( --v5 >= 0 )\n  {\n    v7 = v8;\n    v8 = *(_QWORD *)v8;\n  }\n  *(_QWORD *)v7 = 0LL;\n  v7 = sub_4765B8(v3, v4);\n  v8 = sub_4765B8(v8, a2 - v4);\n  v6 = &v3;\n  do\n  {\n    while ( strcmp(*(const char **)(v8 + 8), *(const char **)(v7 + 8)) < 0 )\n    {\n      *v6 = v8;\n      v6 = (__int64 *)v8;\n      v8 = *(_QWORD *)v8;\n      if ( !v8 )\n      {\n        *v6 = v7;\n        return v3;\n      }\n    }\n    *v6 = v7;\n    v6 = (__int64 *)v7;\n    v7 = *(_QWORD *)v7;\n  }\n  while ( v7 );\n  *v6 = v8;\n  return v3;\n}\n",
        "baseline_code_debug": "strlist *__cdecl msort(strlist *list, int len)\n{\n  strlist *lista; // [rsp+8h] [rbp-28h] BYREF\n  int half; // [rsp+10h] [rbp-20h]\n  int n; // [rsp+14h] [rbp-1Ch]\n  strlist **lpp; // [rsp+18h] [rbp-18h]\n  strlist *q; // [rsp+20h] [rbp-10h]\n  strlist *p; // [rsp+28h] [rbp-8h]\n\n  lista = list;\n  q = 0LL;\n  if ( len <= 1 )\n    return lista;\n  half = len >> 1;\n  p = lista;\n  n = len >> 1;\n  while ( --n >= 0 )\n  {\n    q = p;\n    p = p->next;\n  }\n  q->next = 0LL;\n  q = msort(lista, half);\n  p = msort(p, len - half);\n  lpp = &lista;\n  do\n  {\n    while ( strcmp(p->text, q->text) < 0 )\n    {\n      *lpp = p;\n      lpp = &p->next;\n      p = p->next;\n      if ( !p )\n      {\n        *lpp = q;\n        return lista;\n      }\n    }\n    *lpp = q;\n    lpp = &q->next;\n    q = q->next;\n  }\n  while ( q );\n  *lpp = p;\n  return lista;\n}\n",
        "similarity_score_unixcoder": 0.6644049882888794,
        "similarity_score_baseline_stripped": 0.5225478410720825,
        "similarity_score_baseline_debug": 0.8608744740486145
    },
    {
        "func_name": "alloc_dumper",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_DWORD *__fastcall sub_4F76DC(__int64 a1, __int64 a2)\n{\n  _DWORD *result; // rax\n\n  result = sub_40A0E8(0x58uLL, a2);\n  result[2] = -1;\n  *((_BYTE *)result + 12) = 2;\n  *((_BYTE *)result + 70) = 1;\n  return result;\n}\n",
        "output": "```c\nDWORD *createObject(__int64 size, __int64 initValue)\n{\n  DWORD *object = allocateMemory(0x58, initValue);\n  object[2] = -1;\n  object[12] = 2;\n  object[70] = 1;\n  return object;\n}\n```",
        "source_code": "FAST_FUNC alloc_dumper(void)\n{\n\tpriv_dumper_t *dumper = xzalloc(sizeof(*dumper));\n\tdumper->pub.dump_length = -1;\n\tdumper->pub.dump_vflag = FIRST;\n\tdumper->get__ateof = 1;\n\treturn &dumper->pub;\n}",
        "parsed_output": "DWORD *createObject(__int64 size, __int64 initValue)\n{\n  DWORD *object = allocateMemory(0x58, initValue);\n  object[2] = -1;\n  object[12] = 2;\n  object[70] = 1;\n  return object;\n}",
        "baseline_code_stripped": "_DWORD *__fastcall sub_4F76DC(__int64 a1, __int64 a2)\n{\n  _DWORD *result; // rax\n\n  result = sub_40A0E8(0x58uLL, a2);\n  result[2] = -1;\n  *((_BYTE *)result + 12) = 2;\n  *((_BYTE *)result + 70) = 1;\n  return result;\n}\n",
        "baseline_code_debug": "dumper_t_0 *__cdecl alloc_dumper()\n{\n  dumper_t_0 *result; // rax\n\n  result = (dumper_t_0 *)xzalloc(0x58uLL);\n  result->dump_length = -1;\n  result->dump_vflag = 2;\n  BYTE6(result[2].fshead) = 1;\n  return result;\n}\n",
        "similarity_score_unixcoder": 0.4723377227783203,
        "similarity_score_baseline_stripped": 0.43467000126838684,
        "similarity_score_baseline_debug": 0.7627012729644775
    },
    {
        "func_name": "set_shell",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_499ADE(const char *a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  int v5; // eax\n\n  if ( strcmp(a1, \"bash\") && strcmp(a1, \"sh\") )\n  {\n    if ( !strcmp(a1, \"tcsh\") || !strcmp(a1, \"csh\") )\n    {\n      v5 = dword_75D450;\n      BYTE1(v5) = BYTE1(dword_75D450) | 0x80;\n      dword_75D450 = v5;\n    }\n    else\n    {\n      sub_409747(\"unknown shell '%s', assuming bash\", (__int64)a1, v1, v2, v3, v4);\n    }\n  }\n}\n",
        "output": "```c\nvoid setShellFlag(const char *shellName)\n{\n  int shellFlag;\n\n  if (strcmp(shellName, \"bash\") != 0 && strcmp(shellName, \"sh\") != 0)\n  {\n    if (strcmp(shellName, \"tcsh\") == 0 || strcmp(shellName, \"csh\") == 0)\n    {\n      shellFlag = globalShellFlag;\n      shellFlag |= 0x8000; // Set a specific bit flag\n      globalShellFlag = shellFlag;\n    }\n    else\n    {\n      logError(\"unknown shell '%s', assuming bash\", shellName);\n    }\n  }\n}\n```\n\nNote: The original variable names like `dword_75D450` and `sub_409747` have been replaced with more descriptive names like `globalShellFlag` and `logError` respectively. The actual names would depend on the context of the code and the naming conventions used in the project.",
        "source_code": "endif\n\nstatic void set_shell(const char *new_shell)\n{\n\tif (!strcmp(new_shell, \"bash\") || !strcmp(new_shell, \"sh\"))\n\t\treturn;\n\tif (!strcmp(new_shell, \"tcsh\") || !strcmp(new_shell, \"csh\"))\n\t\toption_mask32 |= SHELL_IS_TCSH;\n\telse\n\t\tbb_error_msg(\"unknown shell '%s', assuming bash\", new_shell);\n}",
        "parsed_output": "void setShellFlag(const char *shellName)\n{\n  int shellFlag;\n\n  if (strcmp(shellName, \"bash\") != 0 && strcmp(shellName, \"sh\") != 0)\n  {\n    if (strcmp(shellName, \"tcsh\") == 0 || strcmp(shellName, \"csh\") == 0)\n    {\n      shellFlag = globalShellFlag;\n      shellFlag |= 0x8000; // Set a specific bit flag\n      globalShellFlag = shellFlag;\n    }\n    else\n    {\n      logError(\"unknown shell '%s', assuming bash\", shellName);\n    }\n  }\n}",
        "baseline_code_stripped": "void __fastcall sub_499ADE(const char *a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  int v5; // eax\n\n  if ( strcmp(a1, \"bash\") && strcmp(a1, \"sh\") )\n  {\n    if ( !strcmp(a1, \"tcsh\") || !strcmp(a1, \"csh\") )\n    {\n      v5 = dword_75D450;\n      BYTE1(v5) = BYTE1(dword_75D450) | 0x80;\n      dword_75D450 = v5;\n    }\n    else\n    {\n      sub_409747(\"unknown shell '%s', assuming bash\", (__int64)a1, v1, v2, v3, v4);\n    }\n  }\n}\n",
        "baseline_code_debug": "void __cdecl set_shell(const char *new_shell)\n{\n  uint32_t v1; // eax\n\n  if ( strcmp(new_shell, \"bash\") && strcmp(new_shell, \"sh\") )\n  {\n    if ( !strcmp(new_shell, \"tcsh\") || !strcmp(new_shell, \"csh\") )\n    {\n      v1 = option_mask32;\n      BYTE1(v1) = BYTE1(option_mask32) | 0x80;\n      option_mask32 = v1;\n    }\n    else\n    {\n      bb_error_msg(\"unknown shell '%s', assuming bash\", new_shell);\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.8035070300102234,
        "similarity_score_baseline_stripped": 0.6911394596099854,
        "similarity_score_baseline_debug": 0.88873291015625
    },
    {
        "func_name": "INET_rresolve",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_4FD6B1(__int64 a1, __int64 a2, int a3)\n{\n  char *v4; // rax\n  char *v5; // rax\n  size_t v6; // rax\n  char *v7; // rcx\n  __int64 v8; // rdx\n  uint32_t netlong; // [rsp+1Ch] [rbp-24h] BYREF\n  struct hostent *v10; // [rsp+20h] [rbp-20h]\n  uint32_t v11; // [rsp+28h] [rbp-18h]\n  int v12; // [rsp+2Ch] [rbp-14h]\n  char *s; // [rsp+30h] [rbp-10h]\n  char *i; // [rsp+38h] [rbp-8h]\n\n  v12 = 0;\n  if ( *(_WORD *)a1 == 2 )\n  {\n    netlong = *(_DWORD *)(a1 + 4);\n    if ( netlong || (a2 & 0xFFF) != 0 )\n    {\n      if ( (a2 & 0xFFF) != 0 )\n      {\n        v4 = inet_ntoa(*(struct in_addr *)(a1 + 4));\n        return sub_40A11F(v4, a2);\n      }\n      else\n      {\n        if ( (~a3 & netlong) != 0 || (a2 & 0x4000) != 0 )\n          v12 = 1;\n        for ( i = (char *)qword_75B2C8; i; i = *(char **)i )\n        {\n          if ( *((_DWORD *)i + 3) == netlong && v12 == *((_DWORD *)i + 6) )\n            return sub_40A11F(i + 28, a2);\n        }\n        v11 = ntohl(netlong);\n        s = 0LL;\n        if ( v12 )\n        {\n          a2 = 4LL;\n          v10 = gethostbyaddr(&netlong, 4u, 2);\n          if ( v10 )\n            s = sub_40A11F(v10->h_name, 4LL);\n        }\n        if ( !s )\n        {\n          v5 = inet_ntoa(*(struct in_addr *)(a1 + 4));\n          s = sub_40A11F(v5, a2);\n        }\n        v6 = strlen(s);\n        i = (char *)sub_40A05F(v6 + 32, a2);\n        *(_QWORD *)i = qword_75B2C8;\n        v7 = i;\n        v8 = *(_QWORD *)(a1 + 8);\n        *((_QWORD *)i + 1) = *(_QWORD *)a1;\n        *((_QWORD *)v7 + 2) = v8;\n        *((_DWORD *)i + 6) = v12;\n        strcpy(i + 28, s);\n        qword_75B2C8 = (__int64)i;\n        return s;\n      }\n    }\n    else if ( (a2 & 0x8000) != 0 )\n    {\n      return sub_40A11F(\"default\", a2);\n    }\n    else\n    {\n      return sub_40A11F(\"*\", a2);\n    }\n  }\n  else\n  {\n    *(_DWORD *)qword_75D400 = 97;\n    return 0LL;\n  }\n}\n",
        "output": "char *resolveHostOrAddress(__int64 addressFamily, __int64 flags, int mask)\n{\n  char *ipString;\n  char *result;\n  size_t nameLength;\n  char *name;\n  char *entry;\n  uint32_t ipNetworkOrder;\n  struct hostent *hostEntry;\n  uint32_t ipHostOrder;\n  int isSpecialCase;\n  char *hostName;\n  char *currentEntry;\n\n  isSpecialCase = 0;\n  if (*(_WORD *)addressFamily == AF_INET)\n  {\n    ipNetworkOrder = *(_DWORD *)(addressFamily + 4);\n    if (ipNetworkOrder || (flags & 0xFFF) != 0)\n    {\n      if ((flags & 0xFFF) != 0)\n      {\n        ipString = inet_ntoa(*(struct in_addr *)(addressFamily + 4));\n        return customFormat(ipString, flags);\n      }\n      else\n      {\n        if ((~mask & ipNetworkOrder) != 0 || (flags & 0x4000) != 0)\n          isSpecialCase = 1;\n        for (currentEntry = (char *)globalListHead; currentEntry; currentEntry = *(char **)currentEntry)\n        {\n          if (*((uint32_t *)currentEntry + 3) == ipNetworkOrder && isSpecialCase == *((uint32_t *)currentEntry + 6))\n            return customFormat(currentEntry + 28, flags);\n        }\n        ipHostOrder = ntohl(ipNetworkOrder);\n        hostName = NULL;\n        if (isSpecialCase)\n        {\n          flags = AF_INET;\n          hostEntry = gethostbyaddr(&ipNetworkOrder, sizeof(ipNetworkOrder), AF_INET);\n          if (hostEntry)\n            hostName = customFormat(hostEntry->h_name, AF_INET);\n        }\n        if (!hostName)\n        {\n          ipString = inet_ntoa(*(struct in_addr *)(addressFamily + 4));\n          hostName = customFormat(ipString, flags);\n        }\n        nameLength = strlen(hostName);\n        entry = (char *)allocateMemory(nameLength + 32, flags);\n        *(_QWORD *)entry = globalListHead;\n        name = entry;\n        *((_QWORD *)entry + 1) = *(_QWORD *)addressFamily;\n        *((_QWORD *)name + 2) = *(_QWORD *)(addressFamily + 8);\n        *((uint32_t *)entry + 6) = isSpecialCase;\n        strcpy(entry + 28, hostName);\n        globalListHead = (__int64)entry;\n        return hostName;\n      }\n    }\n    else if ((flags & 0x8000) != 0)\n    {\n      return customFormat(\"default\", flags);\n    }\n    else\n    {\n      return customFormat(\"*\", flags);\n    }\n  }\n  else\n  {\n    *(_DWORD *)globalError = ERROR_CODE;\n    return NULL;\n  }\n}",
        "source_code": "FAST_FUNC INET_rresolve(struct sockaddr_in *s_in, int numeric, uint32_t netmask)\n{\n\t/* addr-to-name cache */\n\tstruct addr {\n\t\tstruct addr *next;\n\t\tstruct sockaddr_in addr;\n\t\tint host;\n\t\tchar name[1];\n\t};\n\tstatic struct addr *cache = NULL;\n\n\tstruct addr *pn;\n\tchar *name;\n\tuint32_t ad, host_ad;\n\tint host = 0;\n\n\tif (s_in->sin_family != AF_INET) {\n#ifdef DEBUG\n\t\tbb_error_msg(\"rresolve: unsupported address family %d!\",\n\t\t\t\ts_in->sin_family);\n#endif\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tad = s_in->sin_addr.s_addr;\n#ifdef DEBUG\n\tbb_error_msg(\"rresolve: %08x, mask %08x, num %08x\", (unsigned)ad, netmask, numeric);\n#endif\n\tif (ad == INADDR_ANY) {\n\t\tif ((numeric & 0x0FFF) == 0) {\n\t\t\tif (numeric & 0x8000)\n\t\t\t\treturn xstrdup(\"default\");\n\t\t\treturn xstrdup(\"*\");\n\t\t}\n\t}\n\tif (numeric & 0x0FFF)\n\t\treturn xstrdup(inet_ntoa(s_in->sin_addr));\n\n\tif ((ad & (~netmask)) != 0 || (numeric & 0x4000))\n\t\thost = 1;\n\tpn = cache;\n\twhile (pn) {\n\t\tif (pn->addr.sin_addr.s_addr == ad && pn->host == host) {\n#ifdef DEBUG\n\t\t\tbb_error_msg(\"rresolve: found %s %08x in cache\",\n\t\t\t\t\t  (host ? \"host\" : \"net\"), (unsigned)ad);\n#endif\n\t\t\treturn xstrdup(pn->name);\n\t\t}\n\t\tpn = pn->next;\n\t}\n\n\thost_ad = ntohl(ad);\n\tname = NULL;\n\tif (host) {\n\t\tstruct hostent *ent;\n#ifdef DEBUG\n\t\tbb_error_msg(\"gethostbyaddr (%08x)\", (unsigned)ad);\n#endif\n\t\tent = gethostbyaddr((char *) &ad, 4, AF_INET);\n\t\tif (ent)\n\t\t\tname = xstrdup(ent->h_name);\n\t} else if (ENABLE_FEATURE_ETC_NETWORKS) {\n\t\tstruct netent *np;\n#ifdef DEBUG\n\t\tbb_error_msg(\"getnetbyaddr (%08x)\", (unsigned)host_ad);\n#endif\n\t\tnp = getnetbyaddr(host_ad, AF_INET);\n\t\tif (np)\n\t\t\tname = xstrdup(np->n_name);\n\t}\n\tif (!name)\n\t\tname = xstrdup(inet_ntoa(s_in->sin_addr));\n\tpn = xmalloc(sizeof(*pn) + strlen(name)); /* no '+ 1', it's already accounted for */\n\tpn->next = cache;\n\tpn->addr = *s_in;\n\tpn->host = host;\n\tstrcpy(pn->name, name);\n\tcache = pn;\n\treturn name;\n}",
        "parsed_output": "char *resolveHostOrAddress(__int64 addressFamily, __int64 flags, int mask)\n{\n  char *ipString;\n  char *result;\n  size_t nameLength;\n  char *name;\n  char *entry;\n  uint32_t ipNetworkOrder;\n  struct hostent *hostEntry;\n  uint32_t ipHostOrder;\n  int isSpecialCase;\n  char *hostName;\n  char *currentEntry;\n\n  isSpecialCase = 0;\n  if (*(_WORD *)addressFamily == AF_INET)\n  {\n    ipNetworkOrder = *(_DWORD *)(addressFamily + 4);\n    if (ipNetworkOrder || (flags & 0xFFF) != 0)\n    {\n      if ((flags & 0xFFF) != 0)\n      {\n        ipString = inet_ntoa(*(struct in_addr *)(addressFamily + 4));\n        return customFormat(ipString, flags);\n      }\n      else\n      {\n        if ((~mask & ipNetworkOrder) != 0 || (flags & 0x4000) != 0)\n          isSpecialCase = 1;\n        for (currentEntry = (char *)globalListHead; currentEntry; currentEntry = *(char **)currentEntry)\n        {\n          if (*((uint32_t *)currentEntry + 3) == ipNetworkOrder && isSpecialCase == *((uint32_t *)currentEntry + 6))\n            return customFormat(currentEntry + 28, flags);\n        }\n        ipHostOrder = ntohl(ipNetworkOrder);\n        hostName = NULL;\n        if (isSpecialCase)\n        {\n          flags = AF_INET;\n          hostEntry = gethostbyaddr(&ipNetworkOrder, sizeof(ipNetworkOrder), AF_INET);\n          if (hostEntry)\n            hostName = customFormat(hostEntry->h_name, AF_INET);\n        }\n        if (!hostName)\n        {\n          ipString = inet_ntoa(*(struct in_addr *)(addressFamily + 4));\n          hostName = customFormat(ipString, flags);\n        }\n        nameLength = strlen(hostName);\n        entry = (char *)allocateMemory(nameLength + 32, flags);\n        *(_QWORD *)entry = globalListHead;\n        name = entry;\n        *((_QWORD *)entry + 1) = *(_QWORD *)addressFamily;\n        *((_QWORD *)name + 2) = *(_QWORD *)(addressFamily + 8);\n        *((uint32_t *)entry + 6) = isSpecialCase;\n        strcpy(entry + 28, hostName);\n        globalListHead = (__int64)entry;\n        return hostName;\n      }\n    }\n    else if ((flags & 0x8000) != 0)\n    {\n      return customFormat(\"default\", flags);\n    }\n    else\n    {\n      return customFormat(\"*\", flags);\n    }\n  }\n  else\n  {\n    *(_DWORD *)globalError = ERROR_CODE;\n    return NULL;\n  }\n}",
        "baseline_code_stripped": "char *__fastcall sub_4FD6B1(__int64 a1, __int64 a2, int a3)\n{\n  char *v4; // rax\n  char *v5; // rax\n  size_t v6; // rax\n  char *v7; // rcx\n  __int64 v8; // rdx\n  uint32_t netlong; // [rsp+1Ch] [rbp-24h] BYREF\n  struct hostent *v10; // [rsp+20h] [rbp-20h]\n  uint32_t v11; // [rsp+28h] [rbp-18h]\n  int v12; // [rsp+2Ch] [rbp-14h]\n  char *s; // [rsp+30h] [rbp-10h]\n  char *i; // [rsp+38h] [rbp-8h]\n\n  v12 = 0;\n  if ( *(_WORD *)a1 == 2 )\n  {\n    netlong = *(_DWORD *)(a1 + 4);\n    if ( netlong || (a2 & 0xFFF) != 0 )\n    {\n      if ( (a2 & 0xFFF) != 0 )\n      {\n        v4 = inet_ntoa(*(struct in_addr *)(a1 + 4));\n        return sub_40A11F(v4, a2);\n      }\n      else\n      {\n        if ( (~a3 & netlong) != 0 || (a2 & 0x4000) != 0 )\n          v12 = 1;\n        for ( i = (char *)qword_75B2C8; i; i = *(char **)i )\n        {\n          if ( *((_DWORD *)i + 3) == netlong && v12 == *((_DWORD *)i + 6) )\n            return sub_40A11F(i + 28, a2);\n        }\n        v11 = ntohl(netlong);\n        s = 0LL;\n        if ( v12 )\n        {\n          a2 = 4LL;\n          v10 = gethostbyaddr(&netlong, 4u, 2);\n          if ( v10 )\n            s = sub_40A11F(v10->h_name, 4LL);\n        }\n        if ( !s )\n        {\n          v5 = inet_ntoa(*(struct in_addr *)(a1 + 4));\n          s = sub_40A11F(v5, a2);\n        }\n        v6 = strlen(s);\n        i = (char *)sub_40A05F(v6 + 32, a2);\n        *(_QWORD *)i = qword_75B2C8;\n        v7 = i;\n        v8 = *(_QWORD *)(a1 + 8);\n        *((_QWORD *)i + 1) = *(_QWORD *)a1;\n        *((_QWORD *)v7 + 2) = v8;\n        *((_DWORD *)i + 6) = v12;\n        strcpy(i + 28, s);\n        qword_75B2C8 = (__int64)i;\n        return s;\n      }\n    }\n    else if ( (a2 & 0x8000) != 0 )\n    {\n      return sub_40A11F(\"default\", a2);\n    }\n    else\n    {\n      return sub_40A11F(\"*\", a2);\n    }\n  }\n  else\n  {\n    *(_DWORD *)qword_75D400 = 97;\n    return 0LL;\n  }\n}\n",
        "baseline_code_debug": "char *__cdecl INET_rresolve(sockaddr_in *s_in, int numeric, uint32_t netmask)\n{\n  char *v4; // rax\n  char *v5; // rax\n  size_t v6; // rax\n  INET_rresolve::addr *v7; // rcx\n  __int64 v8; // rdx\n  uint32_t ad; // [rsp+1Ch] [rbp-24h] BYREF\n  hostent *ent; // [rsp+20h] [rbp-20h]\n  uint32_t host_ad; // [rsp+28h] [rbp-18h]\n  int host; // [rsp+2Ch] [rbp-14h]\n  char *name; // [rsp+30h] [rbp-10h]\n  INET_rresolve::addr *pn; // [rsp+38h] [rbp-8h]\n\n  host = 0;\n  if ( s_in->sin_family == 2 )\n  {\n    ad = s_in->sin_addr.s_addr;\n    if ( ad || (numeric & 0xFFF) != 0 )\n    {\n      if ( (numeric & 0xFFF) != 0 )\n      {\n        v4 = inet_ntoa(s_in->sin_addr);\n        return xstrdup(v4);\n      }\n      else\n      {\n        if ( (~netmask & ad) != 0 || (numeric & 0x4000) != 0 )\n          host = 1;\n        for ( pn = cache_8131; pn; pn = pn->next )\n        {\n          if ( pn->addr.sin_addr.s_addr == ad && host == pn->host )\n            return xstrdup(pn->name);\n        }\n        host_ad = ntohl(ad);\n        name = 0LL;\n        if ( host )\n        {\n          ent = gethostbyaddr(&ad, 4u, 2);\n          if ( ent )\n            name = xstrdup(ent->h_name);\n        }\n        if ( !name )\n        {\n          v5 = inet_ntoa(s_in->sin_addr);\n          name = xstrdup(v5);\n        }\n        v6 = strlen(name);\n        pn = (INET_rresolve::addr *)xmalloc(v6 + 32);\n        pn->next = cache_8131;\n        v7 = pn;\n        v8 = *(_QWORD *)s_in->sin_zero;\n        *(_QWORD *)&pn->addr.sin_family = *(_QWORD *)&s_in->sin_family;\n        *(_QWORD *)v7->addr.sin_zero = v8;\n        pn->host = host;\n        strcpy(pn->name, name);\n        cache_8131 = pn;\n        return name;\n      }\n    }\n    else if ( (numeric & 0x8000) != 0 )\n    {\n      return xstrdup(\"default\");\n    }\n    else\n    {\n      return xstrdup(\"*\");\n    }\n  }\n  else\n  {\n    *bb_errno = 97;\n    return 0LL;\n  }\n}\n",
        "similarity_score_unixcoder": 0.8214855194091797,
        "similarity_score_baseline_stripped": 0.6738392114639282,
        "similarity_score_baseline_debug": 0.8852221369743347
    },
    {
        "func_name": "restore_state_and_exit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall __noreturn sub_44076F(int a1)\n{\n  __int64 v1; // rcx\n  __int64 v2; // rcx\n  __int64 v3; // rcx\n  struct termios termios_p; // [rsp+10h] [rbp-40h] BYREF\n\n  if ( (int)sub_40AD08(dest.c_iflag, 0x5423u, 7713788LL, (__int64)\"TIOCSETD\") < 0 )\n    a1 = 1;\n  v1 = *(_QWORD *)&dest.c_line;\n  *(_QWORD *)&termios_p.c_iflag = *(_QWORD *)&dest.c_cflag;\n  *(_QWORD *)&termios_p.c_cflag = v1;\n  v2 = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&termios_p.c_line = *(_QWORD *)&dest.c_cc[7];\n  *(_QWORD *)&termios_p.c_cc[7] = v2;\n  v3 = *(_QWORD *)&dest.c_cc[31];\n  *(_QWORD *)&termios_p.c_cc[15] = *(_QWORD *)&dest.c_cc[23];\n  *(_QWORD *)&termios_p.c_cc[23] = v3;\n  *(_QWORD *)&termios_p.c_cc[31] = *(_QWORD *)&dest.c_ospeed;\n  termios_p.c_ospeed = *((_DWORD *)&dest + 16);\n  cfsetispeed(&termios_p, 0);\n  cfsetospeed(&termios_p, 0);\n  if ( (unsigned int)sub_440726(&termios_p) )\n    a1 = 1;\n  sleep(1u);\n  if ( (unsigned int)sub_440726((const struct termios *)&dest.c_cflag) )\n    exit(1);\n  exit(a1);\n}\n",
        "output": "```c\nvoid __fastcall __noreturn configureTerminalSettings(int exitCode)\n{\n  struct termios newSettings; // [rsp+10h] [rbp-40h] BYREF\n\n  if (sub_40AD08(dest.c_iflag, 0x5423u, 7713788LL, \"TIOCSETD\") < 0)\n    exitCode = 1;\n\n  // Copy and swap fields from dest to newSettings\n  memcpy(&newSettings.c_iflag, &dest.c_cflag, sizeof(newSettings.c_iflag));\n  memcpy(&newSettings.c_cflag, &dest.c_line, sizeof(newSettings.c_cflag));\n  memcpy(&newSettings.c_line, &dest.c_cc[7], sizeof(newSettings.c_line));\n  memcpy(&newSettings.c_cc[7], &dest.c_cc[15], sizeof(newSettings.c_cc[7]));\n  memcpy(&newSettings.c_cc[15], &dest.c_cc[23], sizeof(newSettings.c_cc[15]));\n  memcpy(&newSettings.c_cc[23], &dest.c_cc[31], sizeof(newSettings.c_cc[23]));\n  memcpy(&newSettings.c_cc[31], &dest.c_ospeed, sizeof(newSettings.c_cc[31]));\n  newSettings.c_ospeed = dest.c_ispeed;\n\n  // Set input and output speeds to 0\n  cfsetispeed(&newSettings, 0);\n  cfsetospeed(&newSettings, 0);\n\n  // Apply the new terminal settings\n  if (sub_440726(&newSettings))\n    exitCode = 1;\n\n  sleep(1);\n\n  // Revert to original terminal settings\n  if (sub_440726((const struct termios *)&dest.c_cflag))\n    exit(1);\n\n  exit(exitCode);\n}\n```",
        "source_code": "static void restore_state_and_exit(int exitcode)\n{\n\tstruct termios state;\n\n\t/* Restore line discipline */\n\tif (ioctl_or_warn(handle, TIOCSETD, &saved_disc) < 0) {\n\t\texitcode = 1;\n\t}\n\n\t/* Hangup */\n\tmemcpy(&state, &saved_state, sizeof(state));\n\tcfsetispeed(&state, B0);\n\tcfsetospeed(&state, B0);\n\tif (set_termios_state_or_warn(&state))\n\t\texitcode = 1;\n\tsleep(1);\n\n\t/* Restore line status */\n\tif (set_termios_state_or_warn(&saved_state))\n\t\texit(EXIT_FAILURE);\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tclose(handle);\n\n\texit(exitcode);\n}",
        "parsed_output": "void __fastcall __noreturn configureTerminalSettings(int exitCode)\n{\n  struct termios newSettings; // [rsp+10h] [rbp-40h] BYREF\n\n  if (sub_40AD08(dest.c_iflag, 0x5423u, 7713788LL, \"TIOCSETD\") < 0)\n    exitCode = 1;\n\n  // Copy and swap fields from dest to newSettings\n  memcpy(&newSettings.c_iflag, &dest.c_cflag, sizeof(newSettings.c_iflag));\n  memcpy(&newSettings.c_cflag, &dest.c_line, sizeof(newSettings.c_cflag));\n  memcpy(&newSettings.c_line, &dest.c_cc[7], sizeof(newSettings.c_line));\n  memcpy(&newSettings.c_cc[7], &dest.c_cc[15], sizeof(newSettings.c_cc[7]));\n  memcpy(&newSettings.c_cc[15], &dest.c_cc[23], sizeof(newSettings.c_cc[15]));\n  memcpy(&newSettings.c_cc[23], &dest.c_cc[31], sizeof(newSettings.c_cc[23]));\n  memcpy(&newSettings.c_cc[31], &dest.c_ospeed, sizeof(newSettings.c_cc[31]));\n  newSettings.c_ospeed = dest.c_ispeed;\n\n  // Set input and output speeds to 0\n  cfsetispeed(&newSettings, 0);\n  cfsetospeed(&newSettings, 0);\n\n  // Apply the new terminal settings\n  if (sub_440726(&newSettings))\n    exitCode = 1;\n\n  sleep(1);\n\n  // Revert to original terminal settings\n  if (sub_440726((const struct termios *)&dest.c_cflag))\n    exit(1);\n\n  exit(exitCode);\n}",
        "baseline_code_stripped": "void __fastcall __noreturn sub_44076F(int a1)\n{\n  __int64 v1; // rcx\n  __int64 v2; // rcx\n  __int64 v3; // rcx\n  struct termios termios_p; // [rsp+10h] [rbp-40h] BYREF\n\n  if ( (int)sub_40AD08(dest.c_iflag, 0x5423u, 7713788LL, (__int64)\"TIOCSETD\") < 0 )\n    a1 = 1;\n  v1 = *(_QWORD *)&dest.c_line;\n  *(_QWORD *)&termios_p.c_iflag = *(_QWORD *)&dest.c_cflag;\n  *(_QWORD *)&termios_p.c_cflag = v1;\n  v2 = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&termios_p.c_line = *(_QWORD *)&dest.c_cc[7];\n  *(_QWORD *)&termios_p.c_cc[7] = v2;\n  v3 = *(_QWORD *)&dest.c_cc[31];\n  *(_QWORD *)&termios_p.c_cc[15] = *(_QWORD *)&dest.c_cc[23];\n  *(_QWORD *)&termios_p.c_cc[23] = v3;\n  *(_QWORD *)&termios_p.c_cc[31] = *(_QWORD *)&dest.c_ospeed;\n  termios_p.c_ospeed = *((_DWORD *)&dest + 16);\n  cfsetispeed(&termios_p, 0);\n  cfsetospeed(&termios_p, 0);\n  if ( (unsigned int)sub_440726(&termios_p) )\n    a1 = 1;\n  sleep(1u);\n  if ( (unsigned int)sub_440726((const struct termios *)&dest.c_cflag) )\n    exit(1);\n  exit(a1);\n}\n",
        "baseline_code_debug": "void __cdecl __noreturn restore_state_and_exit(int exitcode)\n{\n  termios state; // [rsp+10h] [rbp-40h] BYREF\n\n  if ( bb_ioctl_or_warn(bb_common_bufsiz1.c_iflag, 0x5423u, &bb_common_bufsiz1.c_oflag, \"TIOCSETD\") < 0 )\n    exitcode = 1;\n  *(_QWORD *)&state.c_iflag = *(_QWORD *)&bb_common_bufsiz1.c_cflag;\n  *(_QWORD *)&state.c_cflag = *(_QWORD *)&bb_common_bufsiz1.c_line;\n  *(_QWORD *)&state.c_line = *(_QWORD *)&bb_common_bufsiz1.c_cc[7];\n  *(_QWORD *)&state.c_cc[7] = *(_QWORD *)&bb_common_bufsiz1.c_cc[15];\n  *(_QWORD *)&state.c_cc[15] = *(_QWORD *)&bb_common_bufsiz1.c_cc[23];\n  *(_QWORD *)&state.c_cc[23] = *(_QWORD *)&bb_common_bufsiz1.c_cc[31];\n  *(_QWORD *)&state.c_cc[31] = *(_QWORD *)&bb_common_bufsiz1.c_ospeed;\n  state.c_ospeed = dst.data[0];\n  cfsetispeed(&state, 0);\n  cfsetospeed(&state, 0);\n  if ( set_termios_state_or_warn(&state) )\n    exitcode = 1;\n  sleep(1u);\n  if ( set_termios_state_or_warn((termios *)&bb_common_bufsiz1.c_cflag) )\n    exit(1);\n  exit(exitcode);\n}\n",
        "similarity_score_unixcoder": 0.6885206699371338,
        "similarity_score_baseline_stripped": 0.5837101936340332,
        "similarity_score_baseline_debug": 0.7493524551391602
    },
    {
        "func_name": "ping4",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nunsigned __int64 __fastcall sub_43E93D(__int64 a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  void *v6; // rsi\n  __int64 v7; // rdx\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  unsigned __int64 result; // rax\n  socklen_t addr_len; // [rsp+1Ch] [rbp-34h] BYREF\n  struct sockaddr addr; // [rsp+20h] [rbp-30h] BYREF\n  int optval; // [rsp+38h] [rbp-18h] BYREF\n  signed int v15; // [rsp+3Ch] [rbp-14h]\n\n  dest.c_iflag = sub_4F75F9();\n  v1 = *(_QWORD *)(a1 + 12);\n  *((_QWORD *)&dest + 17) = *(_QWORD *)(a1 + 4);\n  *((_QWORD *)&dest + 18) = v1;\n  if ( *(_QWORD *)&dest.c_line )\n  {\n    if ( setsockopt(dest.c_iflag, 0, 32, (const void *)(*(_QWORD *)&dest.c_line + 4LL), **(_DWORD **)&dest.c_line) )\n      sub_40969E(\"can't set multicast source interface\", 0LL, v2, v3, v4, v5);\n    sub_40A9D9(dest.c_iflag, (const struct sockaddr *)(*(_QWORD *)&dest.c_line + 4LL), **(_DWORD **)&dest.c_line);\n  }\n  if ( *(_QWORD *)&dest.c_cflag )\n    sub_50B3A7(dest.c_iflag, *(_QWORD *)&dest.c_cflag);\n  sub_50B37B(dest.c_iflag);\n  optval = 2 * (*(_DWORD *)&dest.c_cc[7] + 3584);\n  setsockopt(dest.c_iflag, 1, 8, &optval, 4u);\n  if ( *(_DWORD *)&dest.c_cc[15] )\n  {\n    setsockopt(dest.c_iflag, 0, 2, &dest.c_cc[15], 4u);\n    setsockopt(dest.c_iflag, 0, 33, &dest.c_cc[15], 4u);\n  }\n  signal(2, (__sighandler_t)sub_43DEF7);\n  sub_43E2ED();\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      addr_len = 16;\n      v6 = (void *)*((_QWORD *)&dest + 13);\n      v15 = recvfrom(dest.c_iflag, v6, *((unsigned int *)&dest + 25), 0, &addr, &addr_len);\n      if ( v15 >= 0 )\n        break;\n      if ( *(_DWORD *)qword_75D400 != 4 )\n        sub_4091D9((__int64)\"recvfrom\", (__int64)v6, v7, v8, v9, v10);\n    }\n    sub_43E6EF(*((_BYTE **)&dest + 13), v15, (struct in_addr *)&addr);\n    if ( *(_DWORD *)&dest.c_cc[11] )\n    {\n      result = *(_QWORD *)&dest.c_cc[31];\n      if ( result >= *(unsigned int *)&dest.c_cc[11] )\n        break;\n    }\n  }\n  return result;\n}\n",
        "output": "unsigned __int64 __fastcall receiveData(__int64 socketDescriptor)\n{\n  __int64 multicastInterface;\n  __int64 multicastGroup;\n  unsigned __int64 result; // rax\n  socklen_t addr_len; // [rsp+1Ch] [rbp-34h] BYREF\n  struct sockaddr addr; // [rsp+20h] [rbp-30h] BYREF\n  int optval; // [rsp+38h] [rbp-18h] BYREF\n  signed int receivedBytes; // [rsp+3Ch] [rbp-14h]\n  struct socketOptions {\n    int c_iflag;\n    __int64 c_line;\n    __int64 c_cflag;\n    char c_cc[64];\n  } dest;\n\n  dest.c_iflag = getSocket();\n  multicastInterface = *(_QWORD *)(socketDescriptor + 12);\n  dest.c_line = *(_QWORD *)(socketDescriptor + 4);\n  dest.c_cflag = multicastInterface;\n  if ( dest.c_line )\n  {\n    if ( setsockopt(dest.c_iflag, 0, 32, (const void *)(dest.c_line + 4), *(int *)(dest.c_line)) )\n      logError(\"can't set multicast source interface\");\n    joinMulticastGroup(dest.c_iflag, (const struct sockaddr *)(dest.c_line + 4), *(int *)(dest.c_line));\n  }\n  if ( dest.c_cflag )\n    setMulticastLoop(dest.c_iflag, dest.c_cflag);\n  disableMulticastLoop(dest.c_iflag);\n  optval = 2 * (*(int *)&dest.c_cc[7] + 3584);\n  setsockopt(dest.c_iflag, 1, 8, &optval, sizeof(optval));\n  if ( *(int *)&dest.c_cc[15] )\n  {\n    setsockopt(dest.c_iflag, 0, 2, &dest.c_cc[15], sizeof(int));\n    setsockopt(dest.c_iflag, 0, 33, &dest.c_cc[15], sizeof(int));\n  }\n  signal(SIGINT, (__sighandler_t)handleSignal);\n  initializeSignalHandling();\n  while ( true )\n  {\n    while ( true )\n    {\n      addr_len = sizeof(addr);\n      void *buffer = (void *)dest.c_cc + 52; // Assuming c_cc[52] is the buffer start\n      receivedBytes = recvfrom(dest.c_iflag, buffer, *(unsigned int *)&dest.c_cc[25], 0, &addr, &addr_len);\n      if ( receivedBytes >= 0 )\n        break;\n      if ( getErrorCode() != EINTR )\n        logRecvError(\"recvfrom\", buffer);\n    }\n    processData(buffer, receivedBytes, (struct in_addr *)&addr);\n    if ( *(int *)&dest.c_cc[11] )\n    {\n      result = *(unsigned __int64 *)&dest.c_cc[31];\n      if ( result >= *(unsigned int *)&dest.c_cc[11] )\n        break;\n    }\n  }\n  return result;\n}",
        "source_code": "static void ping4(len_and_sockaddr *lsa)\n{\n\tstruct icmp *pkt;\n\tint pingsock, c;\n\n\tpingsock = create_icmp_socket();\n\n\tpkt = (struct icmp *) G.packet;\n\tmemset(pkt, 0, sizeof(G.packet));\n\tpkt->icmp_type = ICMP_ECHO;\n\tpkt->icmp_cksum = inet_cksum((uint16_t *) pkt, sizeof(G.packet));\n\n\txsendto(pingsock, G.packet, DEFDATALEN + ICMP_MINLEN, &lsa->u.sa, lsa->len);\n\n\t/* listen for replies */\n\twhile (1) {\n\t\tstruct sockaddr_in from;\n\t\tsocklen_t fromlen = sizeof(from);\n\n\t\tc = recvfrom(pingsock, G.packet, sizeof(G.packet), 0,\n\t\t\t\t(struct sockaddr *) &from, &fromlen);\n\t\tif (c < 0) {\n\t\t\tif (errno != EINTR)\n\t\t\t\tbb_perror_msg(\"recvfrom\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (c >= 76) {\t\t\t/* ip + icmp */\n\t\t\tstruct iphdr *iphdr = (struct iphdr *) G.packet;\n\n\t\t\tpkt = (struct icmp *) (G.packet + (iphdr->ihl << 2));\t/* skip ip hdr */\n\t\t\tif (pkt->icmp_type == ICMP_ECHOREPLY)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tclose(pingsock);\n}",
        "parsed_output": "unsigned __int64 __fastcall receiveData(__int64 socketDescriptor)\n{\n  __int64 multicastInterface;\n  __int64 multicastGroup;\n  unsigned __int64 result; // rax\n  socklen_t addr_len; // [rsp+1Ch] [rbp-34h] BYREF\n  struct sockaddr addr; // [rsp+20h] [rbp-30h] BYREF\n  int optval; // [rsp+38h] [rbp-18h] BYREF\n  signed int receivedBytes; // [rsp+3Ch] [rbp-14h]\n  struct socketOptions {\n    int c_iflag;\n    __int64 c_line;\n    __int64 c_cflag;\n    char c_cc[64];\n  } dest;\n\n  dest.c_iflag = getSocket();\n  multicastInterface = *(_QWORD *)(socketDescriptor + 12);\n  dest.c_line = *(_QWORD *)(socketDescriptor + 4);\n  dest.c_cflag = multicastInterface;\n  if ( dest.c_line )\n  {\n    if ( setsockopt(dest.c_iflag, 0, 32, (const void *)(dest.c_line + 4), *(int *)(dest.c_line)) )\n      logError(\"can't set multicast source interface\");\n    joinMulticastGroup(dest.c_iflag, (const struct sockaddr *)(dest.c_line + 4), *(int *)(dest.c_line));\n  }\n  if ( dest.c_cflag )\n    setMulticastLoop(dest.c_iflag, dest.c_cflag);\n  disableMulticastLoop(dest.c_iflag);\n  optval = 2 * (*(int *)&dest.c_cc[7] + 3584);\n  setsockopt(dest.c_iflag, 1, 8, &optval, sizeof(optval));\n  if ( *(int *)&dest.c_cc[15] )\n  {\n    setsockopt(dest.c_iflag, 0, 2, &dest.c_cc[15], sizeof(int));\n    setsockopt(dest.c_iflag, 0, 33, &dest.c_cc[15], sizeof(int));\n  }\n  signal(SIGINT, (__sighandler_t)handleSignal);\n  initializeSignalHandling();\n  while ( true )\n  {\n    while ( true )\n    {\n      addr_len = sizeof(addr);\n      void *buffer = (void *)dest.c_cc + 52; // Assuming c_cc[52] is the buffer start\n      receivedBytes = recvfrom(dest.c_iflag, buffer, *(unsigned int *)&dest.c_cc[25], 0, &addr, &addr_len);\n      if ( receivedBytes >= 0 )\n        break;\n      if ( getErrorCode() != EINTR )\n        logRecvError(\"recvfrom\", buffer);\n    }\n    processData(buffer, receivedBytes, (struct in_addr *)&addr);\n    if ( *(int *)&dest.c_cc[11] )\n    {\n      result = *(unsigned __int64 *)&dest.c_cc[31];\n      if ( result >= *(unsigned int *)&dest.c_cc[11] )\n        break;\n    }\n  }\n  return result;\n}",
        "baseline_code_stripped": "unsigned __int64 __fastcall sub_43E93D(__int64 a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  void *v6; // rsi\n  __int64 v7; // rdx\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  unsigned __int64 result; // rax\n  socklen_t addr_len; // [rsp+1Ch] [rbp-34h] BYREF\n  struct sockaddr addr; // [rsp+20h] [rbp-30h] BYREF\n  int optval; // [rsp+38h] [rbp-18h] BYREF\n  signed int v15; // [rsp+3Ch] [rbp-14h]\n\n  dest.c_iflag = sub_4F75F9();\n  v1 = *(_QWORD *)(a1 + 12);\n  *((_QWORD *)&dest + 17) = *(_QWORD *)(a1 + 4);\n  *((_QWORD *)&dest + 18) = v1;\n  if ( *(_QWORD *)&dest.c_line )\n  {\n    if ( setsockopt(dest.c_iflag, 0, 32, (const void *)(*(_QWORD *)&dest.c_line + 4LL), **(_DWORD **)&dest.c_line) )\n      sub_40969E(\"can't set multicast source interface\", 0LL, v2, v3, v4, v5);\n    sub_40A9D9(dest.c_iflag, (const struct sockaddr *)(*(_QWORD *)&dest.c_line + 4LL), **(_DWORD **)&dest.c_line);\n  }\n  if ( *(_QWORD *)&dest.c_cflag )\n    sub_50B3A7(dest.c_iflag, *(_QWORD *)&dest.c_cflag);\n  sub_50B37B(dest.c_iflag);\n  optval = 2 * (*(_DWORD *)&dest.c_cc[7] + 3584);\n  setsockopt(dest.c_iflag, 1, 8, &optval, 4u);\n  if ( *(_DWORD *)&dest.c_cc[15] )\n  {\n    setsockopt(dest.c_iflag, 0, 2, &dest.c_cc[15], 4u);\n    setsockopt(dest.c_iflag, 0, 33, &dest.c_cc[15], 4u);\n  }\n  signal(2, (__sighandler_t)sub_43DEF7);\n  sub_43E2ED();\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      addr_len = 16;\n      v6 = (void *)*((_QWORD *)&dest + 13);\n      v15 = recvfrom(dest.c_iflag, v6, *((unsigned int *)&dest + 25), 0, &addr, &addr_len);\n      if ( v15 >= 0 )\n        break;\n      if ( *(_DWORD *)qword_75D400 != 4 )\n        sub_4091D9((__int64)\"recvfrom\", (__int64)v6, v7, v8, v9, v10);\n    }\n    sub_43E6EF(*((_BYTE **)&dest + 13), v15, (struct in_addr *)&addr);\n    if ( *(_DWORD *)&dest.c_cc[11] )\n    {\n      result = *(_QWORD *)&dest.c_cc[31];\n      if ( result >= *(unsigned int *)&dest.c_cc[11] )\n        break;\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl ping4(len_and_sockaddr_0 *lsa)\n{\n  __int64 v1; // rdx\n  socklen_t fromlen; // [rsp+1Ch] [rbp-34h] BYREF\n  sockaddr_in from; // [rsp+20h] [rbp-30h] BYREF\n  int sockopt; // [rsp+38h] [rbp-18h] BYREF\n  int c; // [rsp+3Ch] [rbp-14h]\n\n  bb_common_bufsiz1.c_iflag = create_icmp_socket();\n  v1 = *(_QWORD *)lsa->u.sin6.sin6_addr.__u6_addr8;\n  *((_QWORD *)&bb_common_bufsiz1 + 17) = *(_QWORD *)&lsa->u.sa.sa_family;\n  *((_QWORD *)&bb_common_bufsiz1 + 18) = v1;\n  if ( *(_QWORD *)&bb_common_bufsiz1.c_line )\n  {\n    if ( setsockopt(\n           bb_common_bufsiz1.c_iflag,\n           0,\n           32,\n           (const void *)(*(_QWORD *)&bb_common_bufsiz1.c_line + 4LL),\n           **(_DWORD **)&bb_common_bufsiz1.c_line) )\n    {\n      bb_error_msg_and_die(\"can't set multicast source interface\");\n    }\n    xbind(\n      bb_common_bufsiz1.c_iflag,\n      (sockaddr *)(*(_QWORD *)&bb_common_bufsiz1.c_line + 4LL),\n      **(_DWORD **)&bb_common_bufsiz1.c_line);\n  }\n  if ( *(_QWORD *)&bb_common_bufsiz1.c_cflag )\n    setsockopt_bindtodevice(bb_common_bufsiz1.c_iflag, *(const char **)&bb_common_bufsiz1.c_cflag);\n  setsockopt_broadcast(bb_common_bufsiz1.c_iflag);\n  sockopt = 2 * (*(_DWORD *)&bb_common_bufsiz1.c_cc[7] + 3584);\n  setsockopt(bb_common_bufsiz1.c_iflag, 1, 8, &sockopt, 4u);\n  if ( *(_DWORD *)&bb_common_bufsiz1.c_cc[15] )\n  {\n    setsockopt(bb_common_bufsiz1.c_iflag, 0, 2, &bb_common_bufsiz1.c_cc[15], 4u);\n    setsockopt(bb_common_bufsiz1.c_iflag, 0, 33, &bb_common_bufsiz1.c_cc[15], 4u);\n  }\n  signal(2, (__sighandler_t)print_stats_and_exit);\n  sendping4(0);\n  do\n  {\n    while ( 1 )\n    {\n      fromlen = 16;\n      c = recvfrom(\n            bb_common_bufsiz1.c_iflag,\n            *((void **)&bb_common_bufsiz1 + 13),\n            *((unsigned int *)&bb_common_bufsiz1 + 25),\n            0,\n            (struct sockaddr *)&from,\n            &fromlen);\n      if ( c >= 0 )\n        break;\n      if ( *bb_errno != 4 )\n        bb_perror_msg(\"recvfrom\");\n    }\n    unpack4(*((char **)&bb_common_bufsiz1 + 13), c, &from);\n  }\n  while ( !*(_DWORD *)&bb_common_bufsiz1.c_cc[11]\n       || *(_QWORD *)&bb_common_bufsiz1.c_cc[31] < (unsigned __int64)*(unsigned int *)&bb_common_bufsiz1.c_cc[11] );\n}\n",
        "similarity_score_unixcoder": 0.6753522753715515,
        "similarity_score_baseline_stripped": 0.5445713996887207,
        "similarity_score_baseline_debug": 0.6472686529159546
    },
    {
        "func_name": "pick_sighandler",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid (__fastcall __noreturn *__fastcall sub_4803D0(unsigned int a1))(int a1)\n{\n  int v2; // [rsp+8h] [rbp-Ch]\n  int (__fastcall *v3)(int); // [rsp+Ch] [rbp-8h]\n\n  v3 = 0LL;\n  if ( a1 <= 0x1F )\n  {\n    v2 = 1 << a1;\n    if ( ((1 << a1) & *((_DWORD *)qword_75D408 + 40)) != 0 )\n    {\n      return sub_480360;\n    }\n    else if ( (v2 & *((_DWORD *)qword_75D408 + 39)) != 0 )\n    {\n      v3 = sub_4802DC;\n      if ( (v2 & 0x700000) != 0 )\n        return (void (__fastcall __noreturn *)(int))1;\n    }\n  }\n  return (void (__fastcall __noreturn *)(int))v3;\n}\n",
        "output": "FunctionPointer sub_4803D0(unsigned int flagIndex)\n{\n  int flagMask;\n  FunctionPointer resultFunction = NULL;\n\n  if (flagIndex <= 31)\n  {\n    flagMask = 1 << flagIndex;\n    if ((flagMask & globalFlagsArray[40]) != 0)\n    {\n      return sub_480360;\n    }\n    else if ((flagMask & globalFlagsArray[39]) != 0)\n    {\n      resultFunction = sub_4802DC;\n      if ((flagMask & 0x700000) != 0)\n        return (FunctionPointer)1;\n    }\n  }\n  return resultFunction;\n}",
        "source_code": "endif\n\nstatic sighandler_t pick_sighandler(unsigned sig)\n{\n\tsighandler_t handler = SIG_DFL;\n\tif (sig < sizeof(unsigned)*8) {\n\t\tunsigned sigmask = (1 << sig);\n\n#if ENABLE_HUSH_JOB\n\t\t/* is sig fatal? */\n\t\tif (G_fatal_sig_mask & sigmask)\n\t\t\thandler = sigexit;\n\t\telse\n#endif\n\t\t/* sig has special handling? */\n\t\tif (G.special_sig_mask & sigmask) {\n\t\t\thandler = record_pending_signo;\n\t\t\t/* TTIN/TTOU/TSTP can't be set to record_pending_signo\n\t\t\t * in order to ignore them: they will be raised\n\t\t\t * in an endless loop when we try to do some\n\t\t\t * terminal ioctls! We do have to _ignore_ these.\n\t\t\t */\n\t\t\tif (SPECIAL_JOBSTOP_SIGS & sigmask)\n\t\t\t\thandler = SIG_IGN;\n\t\t}\n\t}\n\treturn handler;\n}",
        "parsed_output": "FunctionPointer sub_4803D0(unsigned int flagIndex)\n{\n  int flagMask;\n  FunctionPointer resultFunction = NULL;\n\n  if (flagIndex <= 31)\n  {\n    flagMask = 1 << flagIndex;\n    if ((flagMask & globalFlagsArray[40]) != 0)\n    {\n      return sub_480360;\n    }\n    else if ((flagMask & globalFlagsArray[39]) != 0)\n    {\n      resultFunction = sub_4802DC;\n      if ((flagMask & 0x700000) != 0)\n        return (FunctionPointer)1;\n    }\n  }\n  return resultFunction;\n}",
        "baseline_code_stripped": "void (__fastcall __noreturn *__fastcall sub_4803D0(unsigned int a1))(int a1)\n{\n  int v2; // [rsp+8h] [rbp-Ch]\n  int (__fastcall *v3)(int); // [rsp+Ch] [rbp-8h]\n\n  v3 = 0LL;\n  if ( a1 <= 0x1F )\n  {\n    v2 = 1 << a1;\n    if ( ((1 << a1) & *((_DWORD *)qword_75D408 + 40)) != 0 )\n    {\n      return sub_480360;\n    }\n    else if ( (v2 & *((_DWORD *)qword_75D408 + 39)) != 0 )\n    {\n      v3 = sub_4802DC;\n      if ( (v2 & 0x700000) != 0 )\n        return (void (__fastcall __noreturn *)(int))1;\n    }\n  }\n  return (void (__fastcall __noreturn *)(int))v3;\n}\n",
        "baseline_code_debug": "sighandler_t __cdecl pick_sighandler(unsigned int sig)\n{\n  unsigned int sigmask; // [rsp+8h] [rbp-Ch]\n  void (*handler)(int); // [rsp+Ch] [rbp-8h]\n\n  handler = 0LL;\n  if ( sig <= 0x1F )\n  {\n    sigmask = 1 << sig;\n    if ( ((1 << sig) & *(_DWORD *)&ptr_to_globals->line_buf[4]) != 0 )\n    {\n      return (sighandler_t)sigexit;\n    }\n    else if ( (sigmask & *(_DWORD *)ptr_to_globals->line_buf) != 0 )\n    {\n      handler = (void (*)(int))record_pending_signo;\n      if ( (sigmask & 0x700000) != 0 )\n        return (sighandler_t)1;\n    }\n  }\n  return handler;\n}\n",
        "similarity_score_unixcoder": 0.4150443375110626,
        "similarity_score_baseline_stripped": 0.470350444316864,
        "similarity_score_baseline_debug": 0.8141953349113464
    },
    {
        "func_name": "new_group",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40D471(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v7; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v8; // [rsp+20h] [rbp-20h]\n  char *v9; // [rsp+38h] [rbp-8h]\n\n  v8 = a2;\n  v7 = a1;\n  sub_40D371((__int64)&v7, a2);\n  v9 = sub_40A6B3(\"x:%u:\", v8, v2, v3, v4, v5);\n  if ( (int)sub_50967B(\"/etc/group\", a1, v9, 0LL) < 0 )\n    exit(1);\n  return sub_50967B(\"/etc/gshadow\", a1, \"!::\", 0LL);\n}\n",
        "output": "long long sub_40D471(long long a1, long long a2)\n{\n  long long ref_a1;\n  unsigned int a2_copy;\n  char *formatted_string;\n\n  a2_copy = a2;\n  ref_a1 = a1;\n  sub_40D371(&ref_a1, a2);\n  formatted_string = sub_40A6B3(\"x:%u:\", a2_copy);\n  if (sub_50967B(\"/etc/group\", a1, formatted_string, 0) < 0)\n    exit(1);\n  return sub_50967B(\"/etc/gshadow\", a1, \"!::\", 0);\n}",
        "source_code": "static void new_group(char *group, gid_t gid)\n{\n\tstruct group gr;\n\tchar *p;\n\n\t/* make sure gid and group haven't already been allocated */\n\tgr.gr_gid = gid;\n\tgr.gr_name = group;\n\txgroup_study(&gr);\n\n\t/* add entry to group */\n\tp = xasprintf(\"x:%u:\", (unsigned) gr.gr_gid);\n\tif (update_passwd(bb_path_group_file, group, p, NULL) < 0)\n\t\texit(EXIT_FAILURE);\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tfree(p);\n#if ENABLE_FEATURE_SHADOWPASSWDS\n\t/* /etc/gshadow fields:\n\t * 1. Group name.\n\t * 2. Encrypted password.\n\t *    If set, non-members of the group can join the group\n\t *    by typing the password for that group using the newgrp command.\n\t *    If the value is of this field ! then no user is allowed\n\t *    to access the group using the newgrp command. A value of !!\n\t *    is treated the same as a value of ! only it indicates\n\t *    that a password has never been set before. If the value is null,\n\t *    only group members can log into the group.\n\t * 3. Group administrators (comma delimited list).\n\t *    Group members listed here can add or remove group members\n\t *    using the gpasswd command.\n\t * 4. Group members (comma delimited list).\n\t */\n\t/* Ignore errors: if file is missing we assume admin doesn't want it */\n\tupdate_passwd(bb_path_gshadow_file, group, \"!::\", NULL);\n#endif\n}",
        "parsed_output": "long long sub_40D471(long long a1, long long a2)\n{\n  long long ref_a1;\n  unsigned int a2_copy;\n  char *formatted_string;\n\n  a2_copy = a2;\n  ref_a1 = a1;\n  sub_40D371(&ref_a1, a2);\n  formatted_string = sub_40A6B3(\"x:%u:\", a2_copy);\n  if (sub_50967B(\"/etc/group\", a1, formatted_string, 0) < 0)\n    exit(1);\n  return sub_50967B(\"/etc/gshadow\", a1, \"!::\", 0);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40D471(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v7; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v8; // [rsp+20h] [rbp-20h]\n  char *v9; // [rsp+38h] [rbp-8h]\n\n  v8 = a2;\n  v7 = a1;\n  sub_40D371((__int64)&v7, a2);\n  v9 = sub_40A6B3(\"x:%u:\", v8, v2, v3, v4, v5);\n  if ( (int)sub_50967B(\"/etc/group\", a1, v9, 0LL) < 0 )\n    exit(1);\n  return sub_50967B(\"/etc/gshadow\", a1, \"!::\", 0LL);\n}\n",
        "baseline_code_debug": "void __cdecl new_group(char *group, gid_t gid)\n{\n  group gr; // [rsp+10h] [rbp-30h] BYREF\n  char *p; // [rsp+38h] [rbp-8h]\n\n  gr.gr_gid = gid;\n  gr.gr_name = group;\n  xgroup_study(&gr);\n  p = xasprintf(\"x:%u:\", gr.gr_gid);\n  if ( update_passwd(\"/etc/group\", group, p, 0LL) < 0 )\n    exit(1);\n  update_passwd(\"/etc/gshadow\", group, \"!::\", 0LL);\n}\n",
        "similarity_score_unixcoder": 0.5888610482215881,
        "similarity_score_baseline_stripped": 0.5368414521217346,
        "similarity_score_baseline_debug": 0.8370885252952576
    },
    {
        "func_name": "xid_expire",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\ntime_t sub_456B9C()\n{\n  time_t result; // rax\n  int v1; // [rsp+Ch] [rbp-14h]\n  struct termios *v2; // [rsp+10h] [rbp-10h]\n  struct termios *ptr; // [rsp+18h] [rbp-8h]\n\n  ptr = *(struct termios **)&dest.c_cc[15];\n  v2 = &dest;\n  result = sub_40BCE2();\n  v1 = result;\n  while ( ptr )\n  {\n    if ( v1 - ptr->c_iflag <= 0x78 )\n    {\n      v2 = ptr;\n      result = *(_QWORD *)&ptr->c_cc[15];\n    }\n    else\n    {\n      *(_QWORD *)&v2->c_cc[15] = *(_QWORD *)&ptr->c_cc[15];\n      free(ptr);\n      result = *(_QWORD *)&v2->c_cc[15];\n    }\n    ptr = (struct termios *)result;\n  }\n  return result;\n}\n",
        "output": "time_t update_terminal_settings()\n{\n  time_t currentTime; \n  int timeDifference; \n  struct termios *currentTermios; \n  struct termios *nextTermios; \n\n  currentTermios = *(struct termios **)&dest.c_cc[15];\n  nextTermios = &dest;\n  currentTime = get_current_time();\n  timeDifference = currentTime;\n  \n  while (currentTermios)\n  {\n    if (timeDifference - currentTermios->c_iflag <= 0x78)\n    {\n      nextTermios = currentTermios;\n      currentTime = *(_QWORD *)&currentTermios->c_cc[15];\n    }\n    else\n    {\n      *(_QWORD *)&nextTermios->c_cc[15] = *(_QWORD *)&currentTermios->c_cc[15];\n      free(currentTermios);\n      currentTime = *(_QWORD *)&nextTermios->c_cc[15];\n    }\n    currentTermios = (struct termios *)currentTime;\n  }\n  return currentTime;\n}",
        "source_code": "static void xid_expire(void)\n{\n\tstruct xid_item *item = dhcprelay_xid_list.next;\n\tstruct xid_item *last = &dhcprelay_xid_list;\n\tunsigned current_time = monotonic_sec();\n\n\twhile (item != NULL) {\n\t\tif ((current_time - item->timestamp) > MAX_LIFETIME) {\n\t\t\tlast->next = item->next;\n\t\t\tfree(item);\n\t\t\titem = last->next;\n\t\t} else {\n\t\t\tlast = item;\n\t\t\titem = item->next;\n\t\t}\n\t}\n}",
        "parsed_output": "time_t update_terminal_settings()\n{\n  time_t currentTime; \n  int timeDifference; \n  struct termios *currentTermios; \n  struct termios *nextTermios; \n\n  currentTermios = *(struct termios **)&dest.c_cc[15];\n  nextTermios = &dest;\n  currentTime = get_current_time();\n  timeDifference = currentTime;\n  \n  while (currentTermios)\n  {\n    if (timeDifference - currentTermios->c_iflag <= 0x78)\n    {\n      nextTermios = currentTermios;\n      currentTime = *(_QWORD *)&currentTermios->c_cc[15];\n    }\n    else\n    {\n      *(_QWORD *)&nextTermios->c_cc[15] = *(_QWORD *)&currentTermios->c_cc[15];\n      free(currentTermios);\n      currentTime = *(_QWORD *)&nextTermios->c_cc[15];\n    }\n    currentTermios = (struct termios *)currentTime;\n  }\n  return currentTime;\n}",
        "baseline_code_stripped": "time_t sub_456B9C()\n{\n  time_t result; // rax\n  int v1; // [rsp+Ch] [rbp-14h]\n  struct termios *v2; // [rsp+10h] [rbp-10h]\n  struct termios *ptr; // [rsp+18h] [rbp-8h]\n\n  ptr = *(struct termios **)&dest.c_cc[15];\n  v2 = &dest;\n  result = sub_40BCE2();\n  v1 = result;\n  while ( ptr )\n  {\n    if ( v1 - ptr->c_iflag <= 0x78 )\n    {\n      v2 = ptr;\n      result = *(_QWORD *)&ptr->c_cc[15];\n    }\n    else\n    {\n      *(_QWORD *)&v2->c_cc[15] = *(_QWORD *)&ptr->c_cc[15];\n      free(ptr);\n      result = *(_QWORD *)&v2->c_cc[15];\n    }\n    ptr = (struct termios *)result;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl xid_expire()\n{\n  unsigned int current_time; // [rsp+Ch] [rbp-14h]\n  xid_item *last; // [rsp+10h] [rbp-10h]\n  xid_item *item; // [rsp+18h] [rbp-8h]\n\n  item = *(xid_item **)&bb_common_bufsiz1.c_cc[15];\n  last = (xid_item *)&bb_common_bufsiz1;\n  current_time = monotonic_sec();\n  while ( item )\n  {\n    if ( current_time - item->timestamp <= 0x78 )\n    {\n      last = item;\n      item = item->next;\n    }\n    else\n    {\n      last->next = item->next;\n      free(item);\n      item = last->next;\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.4675300717353821,
        "similarity_score_baseline_stripped": 0.4869289994239807,
        "similarity_score_baseline_debug": 0.7836233377456665
    },
    {
        "func_name": "xrtnl_open",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_DWORD *__fastcall sub_450EAB(_DWORD *a1)\n{\n  int v1; // edx\n  _DWORD *result; // rax\n  socklen_t len; // [rsp+1Ch] [rbp-4h] BYREF\n\n  memset(a1, 0, 0x24uLL);\n  *a1 = sub_40A999(16, 3u, 0);\n  *((_WORD *)a1 + 2) = 16;\n  sub_40A9D9(*a1, (const struct sockaddr *)(a1 + 1), 0xCu);\n  len = 12;\n  getsockname(*a1, (struct sockaddr *)(a1 + 1), &len);\n  v1 = time(0LL);\n  result = a1;\n  a1[7] = v1;\n  return result;\n}\n",
        "output": "```c\n#include <sys/socket.h>\n#include <string.h>\n#include <time.h>\n\n#define ADDRESS_SIZE 16\n#define SOCKET_OPTION_VALUE 3\n\nint *initialize_socket(int *socket_info)\n{\n  int current_time;\n  int *result;\n  socklen_t address_length;\n\n  // Clear the socket_info memory with zeros\n  memset(socket_info, 0, 0x24);\n\n  // Create a socket and store the file descriptor in the first element\n  *socket_info = create_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\n  // Set the second element (as a short) to the size of the address\n  *((short *)socket_info + 2) = ADDRESS_SIZE;\n\n  // Bind the socket to an address\n  bind_socket(*socket_info, (const struct sockaddr *)(socket_info + 1), sizeof(struct sockaddr_in));\n\n  // Prepare the length of the address\n  address_length = sizeof(struct sockaddr_in);\n\n  // Get the current name associated with the socket\n  getsockname(*socket_info, (struct sockaddr *)(socket_info + 1), &address_length);\n\n  // Get the current time\n  current_time = time(NULL);\n\n  // Store the result in the socket_info and set the timestamp\n  result = socket_info;\n  socket_info[7] = current_time;\n\n  return result;\n}\n```",
        "source_code": "void FAST_FUNC xrtnl_open(struct rtnl_handle *rth/*, unsigned subscriptions*/)\n{\n\tsocklen_t addr_len;\n\n\tmemset(rth, 0, sizeof(*rth));\n\trth->fd = xsocket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);\n\trth->local.nl_family = AF_NETLINK;\n\t/*rth->local.nl_groups = subscriptions;*/\n\n\txbind(rth->fd, (struct sockaddr*)&rth->local, sizeof(rth->local));\n\taddr_len = sizeof(rth->local);\n\tgetsockname(rth->fd, (struct sockaddr*)&rth->local, &addr_len);\n\n/* too much paranoia\n\tif (getsockname(rth->fd, (struct sockaddr*)&rth->local, &addr_len) < 0)\n\t\tbb_perror_msg_and_die(\"getsockname\");\n\tif (addr_len != sizeof(rth->local))\n\t\tbb_error_msg_and_die(\"wrong address length %d\", addr_len);\n\tif (rth->local.nl_family != AF_NETLINK)\n\t\tbb_error_msg_and_die(\"wrong address family %d\", rth->local.nl_family);\n*/\n\trth->seq = time(NULL);\n}",
        "parsed_output": "#include <sys/socket.h>\n#include <string.h>\n#include <time.h>\n\n#define ADDRESS_SIZE 16\n#define SOCKET_OPTION_VALUE 3\n\nint *initialize_socket(int *socket_info)\n{\n  int current_time;\n  int *result;\n  socklen_t address_length;\n\n  // Clear the socket_info memory with zeros\n  memset(socket_info, 0, 0x24);\n\n  // Create a socket and store the file descriptor in the first element\n  *socket_info = create_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\n  // Set the second element (as a short) to the size of the address\n  *((short *)socket_info + 2) = ADDRESS_SIZE;\n\n  // Bind the socket to an address\n  bind_socket(*socket_info, (const struct sockaddr *)(socket_info + 1), sizeof(struct sockaddr_in));\n\n  // Prepare the length of the address\n  address_length = sizeof(struct sockaddr_in);\n\n  // Get the current name associated with the socket\n  getsockname(*socket_info, (struct sockaddr *)(socket_info + 1), &address_length);\n\n  // Get the current time\n  current_time = time(NULL);\n\n  // Store the result in the socket_info and set the timestamp\n  result = socket_info;\n  socket_info[7] = current_time;\n\n  return result;\n}",
        "baseline_code_stripped": "_DWORD *__fastcall sub_450EAB(_DWORD *a1)\n{\n  int v1; // edx\n  _DWORD *result; // rax\n  socklen_t len; // [rsp+1Ch] [rbp-4h] BYREF\n\n  memset(a1, 0, 0x24uLL);\n  *a1 = sub_40A999(16, 3u, 0);\n  *((_WORD *)a1 + 2) = 16;\n  sub_40A9D9(*a1, (const struct sockaddr *)(a1 + 1), 0xCu);\n  len = 12;\n  getsockname(*a1, (struct sockaddr *)(a1 + 1), &len);\n  v1 = time(0LL);\n  result = a1;\n  a1[7] = v1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl xrtnl_open(rtnl_handle *rth)\n{\n  socklen_t addr_len; // [rsp+1Ch] [rbp-4h] BYREF\n\n  memset(rth, 0, sizeof(rtnl_handle));\n  rth->fd = xsocket(16, 3, 0);\n  rth->local.nl_family = 16;\n  xbind(rth->fd, (sockaddr *)&rth->local, 0xCu);\n  addr_len = 12;\n  getsockname(rth->fd, (struct sockaddr *)&rth->local, &addr_len);\n  rth->seq = time(0LL);\n}\n",
        "similarity_score_unixcoder": 0.6127424836158752,
        "similarity_score_baseline_stripped": 0.5923880338668823,
        "similarity_score_baseline_debug": 0.8651880621910095
    },
    {
        "func_name": "nvalloc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nunsigned __int64 __fastcall sub_4DCDF7(int a1, __int64 a2)\n{\n  int v2; // eax\n  char *v3; // rbx\n  unsigned __int64 v5; // [rsp+10h] [rbp-30h]\n  int v6; // [rsp+1Ch] [rbp-24h]\n  unsigned __int64 v7; // [rsp+20h] [rbp-20h]\n  int *v8; // [rsp+28h] [rbp-18h]\n\n  v8 = 0LL;\n  while ( *((_QWORD *)qword_75D408 - 4) )\n  {\n    v8 = (int *)*((_QWORD *)qword_75D408 - 4);\n    if ( a1 + ((__int64)(*((_QWORD *)v8 + 1) - (_QWORD)(v8 + 8)) >> 5) <= *v8 )\n      break;\n    *((_QWORD *)qword_75D408 - 4) = *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 24LL);\n  }\n  if ( !*((_QWORD *)qword_75D408 - 4) )\n  {\n    v2 = 64;\n    if ( a1 >= 64 )\n      v2 = a1;\n    v6 = v2;\n    v3 = (char *)qword_75D408 - 208;\n    *((_QWORD *)v3 + 22) = sub_40A0E8(32 * (v2 + 1LL), a2);\n    **((_DWORD **)qword_75D408 - 4) = v6;\n    *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) = *((_QWORD *)qword_75D408 - 4) + 32LL;\n    *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 16LL) = v8;\n    if ( v8 )\n      *((_QWORD *)v8 + 3) = *((_QWORD *)qword_75D408 - 4);\n  }\n  v5 = *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL);\n  v7 = v5;\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) = 32LL * a1 + v5;\n  while ( v7 < *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) )\n  {\n    *(_DWORD *)v7 = 0;\n    *(_QWORD *)(v7 + 16) = 0LL;\n    v7 += 32LL;\n  }\n  return v5;\n}\n",
        "output": "```c\nunsigned __int64 __fastcall allocate_and_initialize_memory(int num_elements, __int64 a2)\n{\n  unsigned __int64 allocated_memory;\n  unsigned __int64 current_position;\n  int *previous_block;\n  int required_size;\n  char *base_address;\n\n  previous_block = NULL;\n  while ( *((_QWORD *)global_ptr - 4) )\n  {\n    previous_block = (int *)*((_QWORD *)global_ptr - 4);\n    if ( num_elements + (((*(_QWORD *)(previous_block + 2)) - (_QWORD)(previous_block + 8)) >> 5) <= *previous_block )\n      break;\n    *((_QWORD *)global_ptr - 4) = *(_QWORD *)(*((_QWORD *)global_ptr - 4) + 24LL);\n  }\n  if ( !*((_QWORD *)global_ptr - 4) )\n  {\n    required_size = (num_elements >= 64) ? num_elements : 64;\n    base_address = (char *)global_ptr - 208;\n    *((_QWORD *)base_address + 22) = allocate_memory(32 * (required_size + 1LL), a2);\n    **((_DWORD **)global_ptr - 4) = required_size;\n    *(_QWORD *)(*((_QWORD *)global_ptr - 4) + 8LL) = *((_QWORD *)global_ptr - 4) + 32LL;\n    *(_QWORD *)(*((_QWORD *)global_ptr - 4) + 16LL) = previous_block;\n    if ( previous_block )\n      *((_QWORD *)previous_block + 3) = *((_QWORD *)global_ptr - 4);\n  }\n  allocated_memory = *(_QWORD *)(*((_QWORD *)global_ptr - 4) + 8LL);\n  current_position = allocated_memory;\n  *(_QWORD *)(*((_QWORD *)global_ptr - 4) + 8LL) = 32LL * num_elements + allocated_memory;\n  while ( current_position < *(_QWORD *)(*((_QWORD *)global_ptr - 4) + 8LL) )\n  {\n    *(_DWORD *)current_position = 0;\n    *(_QWORD *)(current_position + 16) = 0LL;\n    current_position += 32LL;\n  }\n  return allocated_memory;\n}\n```",
        "source_code": "static var *nvalloc(int n)\n{\n\tnvblock *pb = NULL;\n\tvar *v, *r;\n\tint size;\n\n\twhile (g_cb) {\n\t\tpb = g_cb;\n\t\tif ((g_cb->pos - g_cb->nv) + n <= g_cb->size)\n\t\t\tbreak;\n\t\tg_cb = g_cb->next;\n\t}\n\n\tif (!g_cb) {\n\t\tsize = (n <= MINNVBLOCK) ? MINNVBLOCK : n;\n\t\tg_cb = xzalloc(sizeof(nvblock) + size * sizeof(var));\n\t\tg_cb->size = size;\n\t\tg_cb->pos = g_cb->nv;\n\t\tg_cb->prev = pb;\n\t\t/*g_cb->next = NULL; - xzalloc did it */\n\t\tif (pb)\n\t\t\tpb->next = g_cb;\n\t}\n\n\tv = r = g_cb->pos;\n\tg_cb->pos += n;\n\n\twhile (v < g_cb->pos) {\n\t\tv->type = 0;\n\t\tv->string = NULL;\n\t\tv++;\n\t}\n\n\treturn r;\n}",
        "parsed_output": "unsigned __int64 __fastcall allocate_and_initialize_memory(int num_elements, __int64 a2)\n{\n  unsigned __int64 allocated_memory;\n  unsigned __int64 current_position;\n  int *previous_block;\n  int required_size;\n  char *base_address;\n\n  previous_block = NULL;\n  while ( *((_QWORD *)global_ptr - 4) )\n  {\n    previous_block = (int *)*((_QWORD *)global_ptr - 4);\n    if ( num_elements + (((*(_QWORD *)(previous_block + 2)) - (_QWORD)(previous_block + 8)) >> 5) <= *previous_block )\n      break;\n    *((_QWORD *)global_ptr - 4) = *(_QWORD *)(*((_QWORD *)global_ptr - 4) + 24LL);\n  }\n  if ( !*((_QWORD *)global_ptr - 4) )\n  {\n    required_size = (num_elements >= 64) ? num_elements : 64;\n    base_address = (char *)global_ptr - 208;\n    *((_QWORD *)base_address + 22) = allocate_memory(32 * (required_size + 1LL), a2);\n    **((_DWORD **)global_ptr - 4) = required_size;\n    *(_QWORD *)(*((_QWORD *)global_ptr - 4) + 8LL) = *((_QWORD *)global_ptr - 4) + 32LL;\n    *(_QWORD *)(*((_QWORD *)global_ptr - 4) + 16LL) = previous_block;\n    if ( previous_block )\n      *((_QWORD *)previous_block + 3) = *((_QWORD *)global_ptr - 4);\n  }\n  allocated_memory = *(_QWORD *)(*((_QWORD *)global_ptr - 4) + 8LL);\n  current_position = allocated_memory;\n  *(_QWORD *)(*((_QWORD *)global_ptr - 4) + 8LL) = 32LL * num_elements + allocated_memory;\n  while ( current_position < *(_QWORD *)(*((_QWORD *)global_ptr - 4) + 8LL) )\n  {\n    *(_DWORD *)current_position = 0;\n    *(_QWORD *)(current_position + 16) = 0LL;\n    current_position += 32LL;\n  }\n  return allocated_memory;\n}",
        "baseline_code_stripped": "unsigned __int64 __fastcall sub_4DCDF7(int a1, __int64 a2)\n{\n  int v2; // eax\n  char *v3; // rbx\n  unsigned __int64 v5; // [rsp+10h] [rbp-30h]\n  int v6; // [rsp+1Ch] [rbp-24h]\n  unsigned __int64 v7; // [rsp+20h] [rbp-20h]\n  int *v8; // [rsp+28h] [rbp-18h]\n\n  v8 = 0LL;\n  while ( *((_QWORD *)qword_75D408 - 4) )\n  {\n    v8 = (int *)*((_QWORD *)qword_75D408 - 4);\n    if ( a1 + ((__int64)(*((_QWORD *)v8 + 1) - (_QWORD)(v8 + 8)) >> 5) <= *v8 )\n      break;\n    *((_QWORD *)qword_75D408 - 4) = *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 24LL);\n  }\n  if ( !*((_QWORD *)qword_75D408 - 4) )\n  {\n    v2 = 64;\n    if ( a1 >= 64 )\n      v2 = a1;\n    v6 = v2;\n    v3 = (char *)qword_75D408 - 208;\n    *((_QWORD *)v3 + 22) = sub_40A0E8(32 * (v2 + 1LL), a2);\n    **((_DWORD **)qword_75D408 - 4) = v6;\n    *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) = *((_QWORD *)qword_75D408 - 4) + 32LL;\n    *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 16LL) = v8;\n    if ( v8 )\n      *((_QWORD *)v8 + 3) = *((_QWORD *)qword_75D408 - 4);\n  }\n  v5 = *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL);\n  v7 = v5;\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) = 32LL * a1 + v5;\n  while ( v7 < *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) )\n  {\n    *(_DWORD *)v7 = 0;\n    *(_QWORD *)(v7 + 16) = 0LL;\n    v7 += 32LL;\n  }\n  return v5;\n}\n",
        "baseline_code_debug": "var_0 *__cdecl nvalloc(int n)\n{\n  int v1; // eax\n  int *v2; // rbx\n  var_0 *r; // [rsp+10h] [rbp-30h]\n  int size; // [rsp+1Ch] [rbp-24h]\n  var_0 *v; // [rsp+20h] [rbp-20h]\n  nvblock *pb; // [rsp+28h] [rbp-18h]\n\n  pb = 0LL;\n  while ( *(_QWORD *)&ptr_to_globals[-1].line_buf[100] )\n  {\n    pb = *(nvblock **)&ptr_to_globals[-1].line_buf[100];\n    if ( n + pb->pos - pb->nv <= pb->size )\n      break;\n    *(_QWORD *)&ptr_to_globals[-1].line_buf[100] = *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 24LL);\n  }\n  if ( !*(_QWORD *)&ptr_to_globals[-1].line_buf[100] )\n  {\n    v1 = 64;\n    if ( n >= 64 )\n      v1 = n;\n    size = v1;\n    v2 = &ptr_to_globals[-1].speeds[7];\n    *((_QWORD *)v2 + 22) = xzalloc(32 * (v1 + 1LL));\n    **(_DWORD **)&ptr_to_globals[-1].line_buf[100] = size;\n    *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 8LL) = *(_QWORD *)&ptr_to_globals[-1].line_buf[100]\n                                                                    + 32LL;\n    *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 16LL) = pb;\n    if ( pb )\n      pb->next = *(nvblock_s **)&ptr_to_globals[-1].line_buf[100];\n  }\n  r = *(var_0 **)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 8LL);\n  v = r;\n  *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 8LL) = &r[n];\n  while ( (unsigned __int64)v < *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 8LL) )\n  {\n    v->type = 0;\n    v->string = 0LL;\n    ++v;\n  }\n  return r;\n}\n",
        "similarity_score_unixcoder": 0.5259674787521362,
        "similarity_score_baseline_stripped": 0.4669768214225769,
        "similarity_score_baseline_debug": 0.7178249359130859
    },
    {
        "func_name": "open_read_close",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nssize_t __fastcall sub_40B501(const char *a1, char *a2, size_t a3)\n{\n  int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = open64(a1, 0);\n  if ( v5 >= 0 )\n    return sub_40B4C5(v5, a2, a3);\n  else\n    return v5;\n}\n",
        "output": "ssize_t openAndReadFile(const char *filePath, char *buffer, size_t bufferSize)\n{\n  int fileDescriptor; // File descriptor for the opened file\n\n  fileDescriptor = open64(filePath, O_RDONLY); // Open file for reading only\n  if (fileDescriptor >= 0)\n    return readFileContents(fileDescriptor, buffer, bufferSize); // Read contents if file opened successfully\n  else\n    return fileDescriptor; // Return error code if file failed to open\n}",
        "source_code": "ssize_t FAST_FUNC open_read_close(const char *filename, void *buf, size_t size)\n{\n\tint fd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\treturn fd;\n\treturn read_close(fd, buf, size);\n}",
        "parsed_output": "ssize_t openAndReadFile(const char *filePath, char *buffer, size_t bufferSize)\n{\n  int fileDescriptor; // File descriptor for the opened file\n\n  fileDescriptor = open64(filePath, O_RDONLY); // Open file for reading only\n  if (fileDescriptor >= 0)\n    return readFileContents(fileDescriptor, buffer, bufferSize); // Read contents if file opened successfully\n  else\n    return fileDescriptor; // Return error code if file failed to open\n}",
        "baseline_code_stripped": "ssize_t __fastcall sub_40B501(const char *a1, char *a2, size_t a3)\n{\n  int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = open64(a1, 0);\n  if ( v5 >= 0 )\n    return sub_40B4C5(v5, a2, a3);\n  else\n    return v5;\n}\n",
        "baseline_code_debug": "ssize_t __cdecl open_read_close(const char *filename, void *buf, size_t size)\n{\n  int fd; // [rsp+2Ch] [rbp-4h]\n\n  fd = open64(filename, 0);\n  if ( fd >= 0 )\n    return read_close(fd, buf, size);\n  else\n    return fd;\n}\n",
        "similarity_score_unixcoder": 0.8032728433609009,
        "similarity_score_baseline_stripped": 0.5384160280227661,
        "similarity_score_baseline_debug": 0.8004591464996338
    },
    {
        "func_name": "do_lzo_decompress",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4B363F(__int64 a1, __int64 a2)\n{\n  unsigned __int8 v3[304]; // [rsp+0h] [rbp-130h] BYREF\n\n  sub_4B30FE();\n  sub_4B34DF(v3);\n  return sub_4B2DF3((__int64)v3, a2);\n}\n",
        "output": "```c\nvoid initializeSystem();\nvoid prepareBuffer(unsigned char *buffer);\n__int64 processBuffer(__int64 buffer, __int64 parameter);\n\n__int64 sub_4B363F(__int64 a1, __int64 a2)\n{\n  unsigned char buffer[304];\n\n  initializeSystem();\n  prepareBuffer(buffer);\n  return processBuffer((__int64)buffer, a2);\n}\n```",
        "source_code": "static smallint do_lzo_decompress(void)\n{\n\theader_t header;\n\n\tcheck_magic();\n\tp_header(&header);\n\treturn lzo_decompress(&header);\n}",
        "parsed_output": "void initializeSystem();\nvoid prepareBuffer(unsigned char *buffer);\n__int64 processBuffer(__int64 buffer, __int64 parameter);\n\n__int64 sub_4B363F(__int64 a1, __int64 a2)\n{\n  unsigned char buffer[304];\n\n  initializeSystem();\n  prepareBuffer(buffer);\n  return processBuffer((__int64)buffer, a2);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4B363F(__int64 a1, __int64 a2)\n{\n  unsigned __int8 v3[304]; // [rsp+0h] [rbp-130h] BYREF\n\n  sub_4B30FE();\n  sub_4B34DF(v3);\n  return sub_4B2DF3((__int64)v3, a2);\n}\n",
        "baseline_code_debug": "smallint __cdecl do_lzo_decompress()\n{\n  header_t_0 header; // [rsp+0h] [rbp-130h] BYREF\n\n  check_magic();\n  p_header(&header);\n  return lzo_decompress(&header);\n}\n",
        "similarity_score_unixcoder": 0.313426673412323,
        "similarity_score_baseline_stripped": 0.3258238434791565,
        "similarity_score_baseline_debug": 0.8164466619491577
    },
    {
        "func_name": "tunctl_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4462E2(__int64 a1, int a2)\n{\n  __int64 v2; // r8\n  __int64 v3; // r9\n  __int64 v4; // r8\n  __int64 v5; // r9\n  int v6; // ecx\n  int v7; // r8d\n  int v8; // r9d\n  __int64 v10; // r8\n  __int64 v11; // r9\n  __int64 v12; // r8\n  __int64 v13; // r9\n  __int64 v14; // r8\n  __int64 v15; // r9\n  __int64 v16; // [rsp+18h] [rbp-60h] BYREF\n  __int64 v17; // [rsp+20h] [rbp-58h] BYREF\n  const char *v18; // [rsp+28h] [rbp-50h] BYREF\n  const char *v19; // [rsp+30h] [rbp-48h] BYREF\n  char s[16]; // [rsp+38h] [rbp-40h] BYREF\n  __int16 v21; // [rsp+48h] [rbp-30h]\n  int v22; // [rsp+60h] [rbp-18h]\n  int v23; // [rsp+64h] [rbp-14h]\n  __int64 v24; // [rsp+68h] [rbp-10h]\n  __int64 v25; // [rsp+70h] [rbp-8h]\n\n  v19 = \"tap%d\";\n  v18 = \"/dev/net/tun\";\n  v25 = -1LL;\n  v24 = -1LL;\n  qword_75D440 = (__int64)\"=0:t--d:d--t\";\n  v23 = sub_4FA1EF(\n          a2,\n          (unsigned int)\"f:t:d:u:g:b\",\n          (unsigned int)&v18,\n          (unsigned int)&v19,\n          (unsigned int)&v19,\n          (unsigned int)&v17,\n          &v16);\n  memset(s, 0, 0x28uLL);\n  v21 = 4098;\n  sub_409A52(s, v19);\n  v22 = sub_40A295(v18, 2);\n  sub_40AB31(v22, 0x400454CAu, (__int64)s, 0LL, v2, v3);\n  if ( (v23 & 4) != 0 )\n  {\n    sub_40AB31(v22, 0x400454CBu, 0LL, 0LL, v4, v5);\n    sub_4FDABC((unsigned int)\"Set '%s' %spersistent\", (unsigned int)s, (unsigned int)\"non\", v6, v7, v8);\n    return 0LL;\n  }\n  else\n  {\n    if ( (v23 & 0x10) != 0 )\n    {\n      v24 = sub_4F64A0(v16);\n      sub_40AB31(v22, 0x400454CEu, v24, 0LL, v10, v11);\n    }\n    else\n    {\n      v25 = geteuid();\n    }\n    if ( (v23 & 8) != 0 )\n      v25 = sub_4F6479(v17);\n    sub_40AB31(v22, 0x400454CCu, v25, 0LL, v12, v13);\n    sub_40AB31(v22, 0x400454CBu, 1LL, 0LL, v14, v15);\n    if ( (v23 & 0x20) != 0 )\n    {\n      puts(s);\n    }\n    else\n    {\n      printf(\"Set '%s' %spersistent\", s, (const char *)&unk_535D39);\n      printf(\" and owned by uid %ld\", v25);\n      if ( v24 != -1 )\n        printf(\" gid %ld\", v24);\n      sub_40A659(10);\n    }\n    return 0LL;\n  }\n}\n",
        "output": "```c\nlong long configureTunDevice(int configFlags)\n{\n  long long uid; // User ID\n  long long gid; // Group ID\n  long long fd; // File descriptor\n  long long persistent; // Persistent flag\n  int parseResult; // Result of parsing command line arguments\n  long long refUID; // Reference to User ID\n  long long refGID; // Reference to Group ID\n  const char *formatDevice; // Format string for device name\n  const char *devicePath; // Path to the network device\n  char deviceName[16]; // Device name buffer\n  short flags; // Flags for the device\n  int deviceFd; // File descriptor for the device\n\n  formatDevice = \"tap%d\";\n  devicePath = \"/dev/net/tun\";\n  gid = -1;\n  uid = -1;\n  globalString = \"=0:t--d:d--t\";\n  parseResult = parseArguments(\n          configFlags,\n          \"f:t:d:u:g:b\",\n          &devicePath,\n          &formatDevice,\n          &formatDevice,\n          &refGID,\n          &refUID);\n  memset(deviceName, 0, sizeof(deviceName));\n  flags = 4098;\n  generateDeviceName(deviceName, formatDevice);\n  deviceFd = openDevice(devicePath, 2);\n  ioctlSet(deviceFd, TUNSETIFF, deviceName, 0, 0, 0);\n  if (parseResult & FLAG_PERSISTENT)\n  {\n    ioctlSet(deviceFd, TUNSETPERSIST, 0, 0, 0, 0);\n    logMessage(\"Set '%s' nonpersistent\", deviceName);\n    return 0;\n  }\n  else\n  {\n    if (parseResult & FLAG_USER)\n    {\n      uid = getUserId(refUID);\n      ioctlSet(deviceFd, TUNSETOWNER, uid, 0, 0, 0);\n    }\n    else\n    {\n      uid = geteuid();\n    }\n    if (parseResult & FLAG_GROUP)\n      gid = getGroupId(refGID);\n    ioctlSet(deviceFd, TUNSETGROUP, gid, 0, 0, 0);\n    ioctlSet(deviceFd, TUNSETPERSIST, 1, 0, 0, 0);\n    if (parseResult & FLAG_VERBOSE)\n    {\n      puts(deviceName);\n    }\n    else\n    {\n      printf(\"Set '%s' persistent\", deviceName);\n      printf(\" and owned by uid %ld\", uid);\n      if (gid != -1)\n        printf(\" gid %ld\", gid);\n      sleep(10);\n    }\n    return 0;\n  }\n}\n```",
        "source_code": "int tunctl_main(int argc UNUSED_PARAM, char **argv)\n{\n\tstruct ifreq ifr;\n\tint fd;\n\tconst char *opt_name = \"tap%d\";\n\tconst char *opt_device = \"/dev/net/tun\";\n#if ENABLE_FEATURE_TUNCTL_UG\n\tconst char *opt_user, *opt_group;\n\tlong user = -1, group = -1;\n#endif\n\tunsigned opts;\n\n\tenum {\n\t\tOPT_f = 1 << 0, // control device name (/dev/net/tun)\n\t\tOPT_t = 1 << 1, // create named interface\n\t\tOPT_d = 1 << 2, // delete named interface\n#if ENABLE_FEATURE_TUNCTL_UG\n\t\tOPT_u = 1 << 3, // set new interface owner\n\t\tOPT_g = 1 << 4, // set new interface group\n\t\tOPT_b = 1 << 5, // brief output\n#endif\n\t};\n\n\topt_complementary = \"=0:t--d:d--t\"; // no arguments; t ^ d\n\topts = getopt32(argv, \"f:t:d:\" IF_FEATURE_TUNCTL_UG(\"u:g:b\"),\n\t\t\t&opt_device, &opt_name, &opt_name\n\t\t\tIF_FEATURE_TUNCTL_UG(, &opt_user, &opt_group));\n\n\t// select device\n\tmemset(&ifr, 0, sizeof(ifr));\n\tifr.ifr_flags = IFF_TAP | IFF_NO_PI;\n\tstrncpy_IFNAMSIZ(ifr.ifr_name, opt_name);\n\n\t// open device\n\tfd = xopen(opt_device, O_RDWR);\n\tIOCTL(fd, TUNSETIFF, (void *)&ifr);\n\n\t// delete?\n\tif (opts & OPT_d) {\n\t\tIOCTL(fd, TUNSETPERSIST, (void *)(uintptr_t)0);\n\t\tbb_info_msg(\"Set '%s' %spersistent\", ifr.ifr_name, \"non\");\n\t\treturn EXIT_SUCCESS;\n\t}\n\n\t// create\n#if ENABLE_FEATURE_TUNCTL_UG\n\tif (opts & OPT_g) {\n\t\tgroup = xgroup2gid(opt_group);\n\t\tIOCTL(fd, TUNSETGROUP, (void *)(uintptr_t)group);\n\t} else\n\t\tuser = geteuid();\n\tif (opts & OPT_u)\n\t\tuser = xuname2uid(opt_user);\n\tIOCTL(fd, TUNSETOWNER, (void *)(uintptr_t)user);\n#endif\n\tIOCTL(fd, TUNSETPERSIST, (void *)(uintptr_t)1);\n\n\t// show info\n#if ENABLE_FEATURE_TUNCTL_UG\n\tif (opts & OPT_b) {\n\t\tputs(ifr.ifr_name);\n\t} else {\n\t\tprintf(\"Set '%s' %spersistent\", ifr.ifr_name, \"\");\n\t\tprintf(\" and owned by uid %ld\", user);\n\t\tif (group != -1)\n\t\t\tprintf(\" gid %ld\", group);\n\t\tbb_putchar('\\n');\n\t}\n#else\n\tputs(ifr.ifr_name);\n#endif\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "long long configureTunDevice(int configFlags)\n{\n  long long uid; // User ID\n  long long gid; // Group ID\n  long long fd; // File descriptor\n  long long persistent; // Persistent flag\n  int parseResult; // Result of parsing command line arguments\n  long long refUID; // Reference to User ID\n  long long refGID; // Reference to Group ID\n  const char *formatDevice; // Format string for device name\n  const char *devicePath; // Path to the network device\n  char deviceName[16]; // Device name buffer\n  short flags; // Flags for the device\n  int deviceFd; // File descriptor for the device\n\n  formatDevice = \"tap%d\";\n  devicePath = \"/dev/net/tun\";\n  gid = -1;\n  uid = -1;\n  globalString = \"=0:t--d:d--t\";\n  parseResult = parseArguments(\n          configFlags,\n          \"f:t:d:u:g:b\",\n          &devicePath,\n          &formatDevice,\n          &formatDevice,\n          &refGID,\n          &refUID);\n  memset(deviceName, 0, sizeof(deviceName));\n  flags = 4098;\n  generateDeviceName(deviceName, formatDevice);\n  deviceFd = openDevice(devicePath, 2);\n  ioctlSet(deviceFd, TUNSETIFF, deviceName, 0, 0, 0);\n  if (parseResult & FLAG_PERSISTENT)\n  {\n    ioctlSet(deviceFd, TUNSETPERSIST, 0, 0, 0, 0);\n    logMessage(\"Set '%s' nonpersistent\", deviceName);\n    return 0;\n  }\n  else\n  {\n    if (parseResult & FLAG_USER)\n    {\n      uid = getUserId(refUID);\n      ioctlSet(deviceFd, TUNSETOWNER, uid, 0, 0, 0);\n    }\n    else\n    {\n      uid = geteuid();\n    }\n    if (parseResult & FLAG_GROUP)\n      gid = getGroupId(refGID);\n    ioctlSet(deviceFd, TUNSETGROUP, gid, 0, 0, 0);\n    ioctlSet(deviceFd, TUNSETPERSIST, 1, 0, 0, 0);\n    if (parseResult & FLAG_VERBOSE)\n    {\n      puts(deviceName);\n    }\n    else\n    {\n      printf(\"Set '%s' persistent\", deviceName);\n      printf(\" and owned by uid %ld\", uid);\n      if (gid != -1)\n        printf(\" gid %ld\", gid);\n      sleep(10);\n    }\n    return 0;\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4462E2(__int64 a1, int a2)\n{\n  __int64 v2; // r8\n  __int64 v3; // r9\n  __int64 v4; // r8\n  __int64 v5; // r9\n  int v6; // ecx\n  int v7; // r8d\n  int v8; // r9d\n  __int64 v10; // r8\n  __int64 v11; // r9\n  __int64 v12; // r8\n  __int64 v13; // r9\n  __int64 v14; // r8\n  __int64 v15; // r9\n  __int64 v16; // [rsp+18h] [rbp-60h] BYREF\n  __int64 v17; // [rsp+20h] [rbp-58h] BYREF\n  const char *v18; // [rsp+28h] [rbp-50h] BYREF\n  const char *v19; // [rsp+30h] [rbp-48h] BYREF\n  char s[16]; // [rsp+38h] [rbp-40h] BYREF\n  __int16 v21; // [rsp+48h] [rbp-30h]\n  int v22; // [rsp+60h] [rbp-18h]\n  int v23; // [rsp+64h] [rbp-14h]\n  __int64 v24; // [rsp+68h] [rbp-10h]\n  __int64 v25; // [rsp+70h] [rbp-8h]\n\n  v19 = \"tap%d\";\n  v18 = \"/dev/net/tun\";\n  v25 = -1LL;\n  v24 = -1LL;\n  qword_75D440 = (__int64)\"=0:t--d:d--t\";\n  v23 = sub_4FA1EF(\n          a2,\n          (unsigned int)\"f:t:d:u:g:b\",\n          (unsigned int)&v18,\n          (unsigned int)&v19,\n          (unsigned int)&v19,\n          (unsigned int)&v17,\n          &v16);\n  memset(s, 0, 0x28uLL);\n  v21 = 4098;\n  sub_409A52(s, v19);\n  v22 = sub_40A295(v18, 2);\n  sub_40AB31(v22, 0x400454CAu, (__int64)s, 0LL, v2, v3);\n  if ( (v23 & 4) != 0 )\n  {\n    sub_40AB31(v22, 0x400454CBu, 0LL, 0LL, v4, v5);\n    sub_4FDABC((unsigned int)\"Set '%s' %spersistent\", (unsigned int)s, (unsigned int)\"non\", v6, v7, v8);\n    return 0LL;\n  }\n  else\n  {\n    if ( (v23 & 0x10) != 0 )\n    {\n      v24 = sub_4F64A0(v16);\n      sub_40AB31(v22, 0x400454CEu, v24, 0LL, v10, v11);\n    }\n    else\n    {\n      v25 = geteuid();\n    }\n    if ( (v23 & 8) != 0 )\n      v25 = sub_4F6479(v17);\n    sub_40AB31(v22, 0x400454CCu, v25, 0LL, v12, v13);\n    sub_40AB31(v22, 0x400454CBu, 1LL, 0LL, v14, v15);\n    if ( (v23 & 0x20) != 0 )\n    {\n      puts(s);\n    }\n    else\n    {\n      printf(\"Set '%s' %spersistent\", s, (const char *)&unk_535D39);\n      printf(\" and owned by uid %ld\", v25);\n      if ( v24 != -1 )\n        printf(\" gid %ld\", v24);\n      sub_40A659(10);\n    }\n    return 0LL;\n  }\n}\n",
        "baseline_code_debug": "int __cdecl tunctl_main(int argc, char **argv)\n{\n  const char *opt_group; // [rsp+18h] [rbp-60h] BYREF\n  const char *opt_user; // [rsp+20h] [rbp-58h] BYREF\n  const char *opt_device; // [rsp+28h] [rbp-50h] BYREF\n  const char *opt_name; // [rsp+30h] [rbp-48h] BYREF\n  ifreq ifr; // [rsp+38h] [rbp-40h] BYREF\n  int fd; // [rsp+60h] [rbp-18h]\n  unsigned int opts; // [rsp+64h] [rbp-14h]\n  __int64 group; // [rsp+68h] [rbp-10h]\n  __int64 user; // [rsp+70h] [rbp-8h]\n\n  opt_name = \"tap%d\";\n  opt_device = \"/dev/net/tun\";\n  user = -1LL;\n  group = -1LL;\n  opt_complementary = \"=0:t--d:d--t\";\n  opts = getopt32(argv, \"f:t:d:u:g:b\", &opt_device, &opt_name, &opt_name, &opt_user, &opt_group);\n  memset(&ifr, 0, sizeof(ifr));\n  ifr.ifr_ifru.ifru_addr.sa_family = 4098;\n  strncpy_IFNAMSIZ(ifr.ifr_ifrn.ifrn_name, opt_name);\n  fd = xopen(opt_device, 2);\n  ioctl_or_perror_and_die(fd, 0x400454CAu, &ifr, 0LL);\n  if ( (opts & 4) != 0 )\n  {\n    ioctl_or_perror_and_die(fd, 0x400454CBu, 0LL, 0LL);\n    bb_info_msg(\"Set '%s' %spersistent\", ifr.ifr_ifrn.ifrn_name, \"non\");\n    return 0;\n  }\n  else\n  {\n    if ( (opts & 0x10) != 0 )\n    {\n      group = xgroup2gid(opt_group);\n      ioctl_or_perror_and_die(fd, 0x400454CEu, (void *)group, 0LL);\n    }\n    else\n    {\n      user = geteuid();\n    }\n    if ( (opts & 8) != 0 )\n      user = xuname2uid(opt_user);\n    ioctl_or_perror_and_die(fd, 0x400454CCu, (void *)user, 0LL);\n    ioctl_or_perror_and_die(fd, 0x400454CBu, (void *)1, 0LL);\n    if ( (opts & 0x20) != 0 )\n    {\n      puts(ifr.ifr_ifrn.ifrn_name);\n    }\n    else\n    {\n      printf(\"Set '%s' %spersistent\", ifr.ifr_ifrn.ifrn_name, (const char *)&unk_535D39);\n      printf(\" and owned by uid %ld\", user);\n      if ( group != -1 )\n        printf(\" gid %ld\", group);\n      bb_putchar(10);\n    }\n    return 0;\n  }\n}\n",
        "similarity_score_unixcoder": 0.7800842523574829,
        "similarity_score_baseline_stripped": 0.5457553863525391,
        "similarity_score_baseline_debug": 0.8852790594100952
    },
    {
        "func_name": "eor",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_416357(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  double v10; // xmm0_8\n  unsigned __int64 v11; // rbx\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  double v16; // xmm0_8\n  unsigned __int64 v17; // rax\n  __int64 v18; // rax\n  double v19; // xmm0_8\n\n  v10 = sub_416051(a1, a2, a3, a4, a5, a6);\n  if ( v10 >= 9.223372036854776e18 )\n    v11 = (unsigned int)(int)(v10 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v11 = (unsigned int)(int)v10;\n  v16 = sub_416051(a1, a2, v6, v7, v8, v9);\n  if ( v16 >= 9.223372036854776e18 )\n  {\n    v12 = 0x8000000000000000LL;\n    v17 = (unsigned int)(int)(v16 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  }\n  else\n  {\n    v17 = (unsigned int)(int)v16;\n  }\n  v18 = v11 ^ v17;\n  if ( v18 < 0 )\n  {\n    v12 = v18 & 1 | ((unsigned __int64)v18 >> 1);\n    v19 = (double)(int)v12 + (double)(int)v12;\n  }\n  else\n  {\n    v19 = (double)(int)v18;\n  }\n  return sub_416006(v19, a1, a2, v12, v13, v14, v15);\n}\n",
        "output": "long long sub_416357(long long a1, long long a2, long long a3, long long a4, long long a5, long long a6)\n{\n  double firstResult = sub_416051(a1, a2, a3, a4, a5, a6);\n  unsigned long long firstProcessed;\n  \n  if (firstResult >= 9.223372036854776e18)\n    firstProcessed = (unsigned int)(firstResult - 9.223372036854776e18) ^ 0x8000000000000000ULL;\n  else\n    firstProcessed = (unsigned int)firstResult;\n  \n  double secondResult = sub_416051(a1, a2, a3, a4, a5, a6);\n  unsigned long long secondProcessed;\n  \n  if (secondResult >= 9.223372036854776e18)\n    secondProcessed = (unsigned int)(secondResult - 9.223372036854776e18) ^ 0x8000000000000000ULL;\n  else\n    secondProcessed = (unsigned int)secondResult;\n  \n  long long xorResult = firstProcessed ^ secondProcessed;\n  double finalResult;\n  \n  if (xorResult < 0)\n  {\n    long long temp = (xorResult & 1) | ((unsigned long long)xorResult >> 1);\n    finalResult = (double)(int)temp * 2;\n  }\n  else\n  {\n    finalResult = (double)(int)xorResult;\n  }\n  \n  return sub_416006(finalResult, a1, a2, a3, a4, a5, a6);\n}",
        "source_code": "static void eor(void)\n{\n\tpush((data_t) pop() ^ (data_t) pop());\n}",
        "parsed_output": "long long sub_416357(long long a1, long long a2, long long a3, long long a4, long long a5, long long a6)\n{\n  double firstResult = sub_416051(a1, a2, a3, a4, a5, a6);\n  unsigned long long firstProcessed;\n  \n  if (firstResult >= 9.223372036854776e18)\n    firstProcessed = (unsigned int)(firstResult - 9.223372036854776e18) ^ 0x8000000000000000ULL;\n  else\n    firstProcessed = (unsigned int)firstResult;\n  \n  double secondResult = sub_416051(a1, a2, a3, a4, a5, a6);\n  unsigned long long secondProcessed;\n  \n  if (secondResult >= 9.223372036854776e18)\n    secondProcessed = (unsigned int)(secondResult - 9.223372036854776e18) ^ 0x8000000000000000ULL;\n  else\n    secondProcessed = (unsigned int)secondResult;\n  \n  long long xorResult = firstProcessed ^ secondProcessed;\n  double finalResult;\n  \n  if (xorResult < 0)\n  {\n    long long temp = (xorResult & 1) | ((unsigned long long)xorResult >> 1);\n    finalResult = (double)(int)temp * 2;\n  }\n  else\n  {\n    finalResult = (double)(int)xorResult;\n  }\n  \n  return sub_416006(finalResult, a1, a2, a3, a4, a5, a6);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_416357(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  double v10; // xmm0_8\n  unsigned __int64 v11; // rbx\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  double v16; // xmm0_8\n  unsigned __int64 v17; // rax\n  __int64 v18; // rax\n  double v19; // xmm0_8\n\n  v10 = sub_416051(a1, a2, a3, a4, a5, a6);\n  if ( v10 >= 9.223372036854776e18 )\n    v11 = (unsigned int)(int)(v10 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v11 = (unsigned int)(int)v10;\n  v16 = sub_416051(a1, a2, v6, v7, v8, v9);\n  if ( v16 >= 9.223372036854776e18 )\n  {\n    v12 = 0x8000000000000000LL;\n    v17 = (unsigned int)(int)(v16 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  }\n  else\n  {\n    v17 = (unsigned int)(int)v16;\n  }\n  v18 = v11 ^ v17;\n  if ( v18 < 0 )\n  {\n    v12 = v18 & 1 | ((unsigned __int64)v18 >> 1);\n    v19 = (double)(int)v12 + (double)(int)v12;\n  }\n  else\n  {\n    v19 = (double)(int)v18;\n  }\n  return sub_416006(v19, a1, a2, v12, v13, v14, v15);\n}\n",
        "baseline_code_debug": "void __cdecl eor()\n{\n  double v0; // xmm0_8\n  unsigned __int64 v1; // rbx\n  double v2; // xmm0_8\n  unsigned __int64 v3; // rax\n  __int64 v4; // rax\n  double v5; // xmm0_8\n\n  v0 = pop();\n  if ( v0 >= 9.223372036854776e18 )\n    v1 = (unsigned int)(int)(v0 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v1 = (unsigned int)(int)v0;\n  v2 = pop();\n  if ( v2 >= 9.223372036854776e18 )\n    v3 = (unsigned int)(int)(v2 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v3 = (unsigned int)(int)v2;\n  v4 = v1 ^ v3;\n  if ( v4 < 0 )\n    v5 = (double)(int)(v4 & 1 | ((unsigned __int64)v4 >> 1)) + (double)(int)(v4 & 1 | ((unsigned __int64)v4 >> 1));\n  else\n    v5 = (double)(int)v4;\n  push(v5);\n}\n",
        "similarity_score_unixcoder": 0.5073667168617249,
        "similarity_score_baseline_stripped": 0.4363482892513275,
        "similarity_score_baseline_debug": 0.6281893253326416
    },
    {
        "func_name": "addgroup_wrapper",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40D7F2(__int64 a1, const char *a2)\n{\n  const char *v3; // [rsp+10h] [rbp-30h] BYREF\n  const char *v4; // [rsp+18h] [rbp-28h]\n  _BYTE *v5; // [rsp+20h] [rbp-20h]\n  const char *v6; // [rsp+28h] [rbp-18h]\n  _BYTE *v7; // [rsp+30h] [rbp-10h]\n  __int64 v8; // [rsp+38h] [rbp-8h]\n\n  v3 = \"addgroup\";\n  if ( a2 )\n  {\n    v4 = \"--\";\n    v5 = *(_BYTE **)a1;\n    v6 = a2;\n    v7 = 0LL;\n  }\n  else\n  {\n    v4 = \"--gid\";\n    v5 = sub_409B63(*(_DWORD *)(a1 + 20));\n    v6 = \"--\";\n    v7 = *(_BYTE **)a1;\n    v8 = 0LL;\n  }\n  return sub_50A624(&v3);\n}\n",
        "output": "```c\n__int64 __fastcall addGroupOrGid(__int64 userData, const char *option)\n{\n  const char *command = \"addgroup\";\n  const char *prefix;\n  _BYTE *firstArg;\n  const char *secondPrefix;\n  _BYTE *secondArg;\n  __int64 unusedVariable; // This variable seems to be unused in the function\n\n  if (option)\n  {\n    prefix = \"--\";\n    firstArg = *(_BYTE **)userData;\n    secondPrefix = option;\n    secondArg = NULL;\n  }\n  else\n  {\n    prefix = \"--gid\";\n    firstArg = getGid(*(_DWORD *)(userData + 20));\n    secondPrefix = \"--\";\n    secondArg = *(_BYTE **)userData;\n    unusedVariable = 0LL; // This line is redundant as the variable is not used afterwards\n  }\n  return executeCommand(&command);\n}\n```",
        "source_code": "static int addgroup_wrapper(struct passwd *p, const char *group_name)\n{\n\tchar *argv[6];\n\n\targv[0] = (char*)\"addgroup\";\n\tif (group_name) {\n\t\t/* Add user to existing group */\n\t\targv[1] = (char*)\"--\";\n\t\targv[2] = p->pw_name;\n\t\targv[3] = (char*)group_name;\n\t\targv[4] = NULL;\n\t} else {\n\t\t/* Add user to his own group with the first free gid\n\t\t * found in passwd_study.\n\t\t */\n#if ENABLE_FEATURE_ADDGROUP_LONG_OPTIONS || !ENABLE_ADDGROUP\n\t\t/* We try to use --gid, not -g, because \"standard\" addgroup\n\t\t * has no short option -g, it has only long --gid.\n\t\t */\n\t\targv[1] = (char*)\"--gid\";\n#else\n\t\t/* Breaks if system in fact does NOT use busybox addgroup */\n\t\targv[1] = (char*)\"-g\";\n#endif\n\t\targv[2] = utoa(p->pw_gid);\n\t\targv[3] = (char*)\"--\";\n\t\targv[4] = p->pw_name;\n\t\targv[5] = NULL;\n\t}\n\n\treturn spawn_and_wait(argv);\n}",
        "parsed_output": "__int64 __fastcall addGroupOrGid(__int64 userData, const char *option)\n{\n  const char *command = \"addgroup\";\n  const char *prefix;\n  _BYTE *firstArg;\n  const char *secondPrefix;\n  _BYTE *secondArg;\n  __int64 unusedVariable; // This variable seems to be unused in the function\n\n  if (option)\n  {\n    prefix = \"--\";\n    firstArg = *(_BYTE **)userData;\n    secondPrefix = option;\n    secondArg = NULL;\n  }\n  else\n  {\n    prefix = \"--gid\";\n    firstArg = getGid(*(_DWORD *)(userData + 20));\n    secondPrefix = \"--\";\n    secondArg = *(_BYTE **)userData;\n    unusedVariable = 0LL; // This line is redundant as the variable is not used afterwards\n  }\n  return executeCommand(&command);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40D7F2(__int64 a1, const char *a2)\n{\n  const char *v3; // [rsp+10h] [rbp-30h] BYREF\n  const char *v4; // [rsp+18h] [rbp-28h]\n  _BYTE *v5; // [rsp+20h] [rbp-20h]\n  const char *v6; // [rsp+28h] [rbp-18h]\n  _BYTE *v7; // [rsp+30h] [rbp-10h]\n  __int64 v8; // [rsp+38h] [rbp-8h]\n\n  v3 = \"addgroup\";\n  if ( a2 )\n  {\n    v4 = \"--\";\n    v5 = *(_BYTE **)a1;\n    v6 = a2;\n    v7 = 0LL;\n  }\n  else\n  {\n    v4 = \"--gid\";\n    v5 = sub_409B63(*(_DWORD *)(a1 + 20));\n    v6 = \"--\";\n    v7 = *(_BYTE **)a1;\n    v8 = 0LL;\n  }\n  return sub_50A624(&v3);\n}\n",
        "baseline_code_debug": "int __cdecl addgroup_wrapper(passwd *p, const char *group_name)\n{\n  char *argv[6]; // [rsp+10h] [rbp-30h] BYREF\n\n  argv[0] = \"addgroup\";\n  if ( group_name )\n  {\n    argv[1] = \"--\";\n    argv[2] = p->pw_name;\n    argv[3] = (char *)group_name;\n    argv[4] = 0LL;\n  }\n  else\n  {\n    argv[1] = \"--gid\";\n    argv[2] = utoa(p->pw_gid);\n    argv[3] = \"--\";\n    argv[4] = p->pw_name;\n    argv[5] = 0LL;\n  }\n  return spawn_and_wait(argv);\n}\n",
        "similarity_score_unixcoder": 0.6304059624671936,
        "similarity_score_baseline_stripped": 0.5966931581497192,
        "similarity_score_baseline_debug": 0.8558531403541565
    },
    {
        "func_name": "pivot_root_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4A32AA(__int64 a1, __int64 a2)\n{\n  if ( (_DWORD)a1 != 3 )\n    sub_407F64(a1);\n  if ( (int)pivot_root(*(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16)) < 0 )\n    sub_502D54();\n  return 0LL;\n}\n",
        "output": "```c\nvoid sub_4A32AA(int a1, __int64 a2)\n{\n  if (a1 != 3)\n    sub_407F64(a1);\n  \n  if (pivot_root(*(__int64 *)(a2 + 8), *(__int64 *)(a2 + 16)) < 0)\n    sub_502D54();\n}\n```",
        "source_code": "int pivot_root_main(int argc, char **argv)\n{\n\tif (argc != 3)\n\t\tbb_show_usage();\n\n\tif (pivot_root(argv[1], argv[2]) < 0) {\n\t\t/* prints \"pivot_root: <strerror text>\" */\n\t\tbb_perror_nomsg_and_die();\n\t}\n\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "void sub_4A32AA(int a1, __int64 a2)\n{\n  if (a1 != 3)\n    sub_407F64(a1);\n  \n  if (pivot_root(*(__int64 *)(a2 + 8), *(__int64 *)(a2 + 16)) < 0)\n    sub_502D54();\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4A32AA(__int64 a1, __int64 a2)\n{\n  if ( (_DWORD)a1 != 3 )\n    sub_407F64(a1);\n  if ( (int)pivot_root(*(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16)) < 0 )\n    sub_502D54();\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl pivot_root_main(int argc, char **argv)\n{\n  if ( argc != 3 )\n    bb_show_usage();\n  if ( (int)pivot_root(argv[1], argv[2]) < 0 )\n    bb_perror_nomsg_and_die();\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.6124475002288818,
        "similarity_score_baseline_stripped": 0.5956843495368958,
        "similarity_score_baseline_debug": 0.885185718536377
    },
    {
        "func_name": "make_new_name_generic",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_4A872C(const char *a1, const char *a2)\n{\n  char *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = strrchr(a1, 46);\n  if ( !v3 || strcmp(v3 + 1, a2) )\n    return 0LL;\n  *v3 = 0;\n  return a1;\n}\n",
        "output": "const char *extractFilenameWithoutExtension(const char *filename, const char *extension)\n{\n  char *lastDotPosition;\n\n  lastDotPosition = strrchr(filename, '.');\n  if (lastDotPosition == NULL || strcmp(lastDotPosition + 1, extension) != 0)\n    return NULL;\n  \n  *lastDotPosition = '\\0';\n  return filename;\n}",
        "source_code": "FAST_FUNC make_new_name_generic(char *filename, const char *expected_ext)\n{\n\tchar *extension = strrchr(filename, '.');\n\tif (!extension || strcmp(extension + 1, expected_ext) != 0) {\n\t\t/* Mimic GNU gunzip - \"real\" bunzip2 tries to */\n\t\t/* unpack file anyway, to file.out */\n\t\treturn NULL;\n\t}\n\t*extension = '\\0';\n\treturn filename;\n}",
        "parsed_output": "const char *extractFilenameWithoutExtension(const char *filename, const char *extension)\n{\n  char *lastDotPosition;\n\n  lastDotPosition = strrchr(filename, '.');\n  if (lastDotPosition == NULL || strcmp(lastDotPosition + 1, extension) != 0)\n    return NULL;\n  \n  *lastDotPosition = '\\0';\n  return filename;\n}",
        "baseline_code_stripped": "const char *__fastcall sub_4A872C(const char *a1, const char *a2)\n{\n  char *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = strrchr(a1, 46);\n  if ( !v3 || strcmp(v3 + 1, a2) )\n    return 0LL;\n  *v3 = 0;\n  return a1;\n}\n",
        "baseline_code_debug": "char *__cdecl make_new_name_generic(char *filename, const char *expected_ext)\n{\n  char *extension; // [rsp+18h] [rbp-8h]\n\n  extension = strrchr(filename, 46);\n  if ( !extension || strcmp(extension + 1, expected_ext) )\n    return 0LL;\n  *extension = 0;\n  return filename;\n}\n",
        "similarity_score_unixcoder": 0.6561521291732788,
        "similarity_score_baseline_stripped": 0.5035704970359802,
        "similarity_score_baseline_debug": 0.7739710807800293
    },
    {
        "func_name": "free_instance",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_4DA7BB(void **a1)\n{\n  free(a1[2]);\n  free(a1[3]);\n  free(a1[4]);\n  free(a1);\n}\n",
        "output": "void freeResources(void **resources)\n{\n  free(resources[2]);\n  free(resources[3]);\n  free(resources[4]);\n  free(resources);\n}",
        "source_code": "static void free_instance(struct fsck_instance *p)\n{\n\tfree(p->prog);\n\tfree(p->device);\n\tfree(p->base_device);\n\tfree(p);\n}",
        "parsed_output": "void freeResources(void **resources)\n{\n  free(resources[2]);\n  free(resources[3]);\n  free(resources[4]);\n  free(resources);\n}",
        "baseline_code_stripped": "void __fastcall sub_4DA7BB(void **a1)\n{\n  free(a1[2]);\n  free(a1[3]);\n  free(a1[4]);\n  free(a1);\n}\n",
        "baseline_code_debug": "void __cdecl free_instance(fsck_instance *p)\n{\n  free(p->prog);\n  free(p->device);\n  free(p->base_device);\n  free(p);\n}\n",
        "similarity_score_unixcoder": 0.6041508316993713,
        "similarity_score_baseline_stripped": 0.5425723791122437,
        "similarity_score_baseline_debug": 0.929505467414856
    },
    {
        "func_name": "print_queuelen",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_449C97(const char *a1)\n{\n  int result; // eax\n  char s[16]; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v3; // [rsp+20h] [rbp-20h]\n  int fd; // [rsp+3Ch] [rbp-4h]\n\n  result = socket(2, 1, 0);\n  fd = result;\n  if ( result >= 0 )\n  {\n    memset(s, 0, 0x28uLL);\n    sub_409A52(s, a1);\n    if ( (int)sub_40AD08(fd, 0x8942u, (__int64)s, (__int64)\"SIOCGIFTXQLEN\") >= 0 )\n    {\n      close(fd);\n      result = v3;\n      if ( v3 )\n        return printf(\"qlen %d\", v3);\n    }\n    else\n    {\n      return close(fd);\n    }\n  }\n  return result;\n}\n",
        "output": "int createSocketAndQueryQueueLength(const char *interfaceName)\n{\n  int socketFd;\n  char buffer[16];\n  unsigned int queueLength;\n  int result;\n\n  socketFd = socket(AF_INET, SOCK_STREAM, 0);\n  if (socketFd >= 0)\n  {\n    memset(buffer, 0, sizeof(buffer));\n    prepareInterfaceRequest(buffer, interfaceName);\n    result = performIoctl(socketFd, SIOCGIFTXQLEN, buffer, \"SIOCGIFTXQLEN\");\n    if (result >= 0)\n    {\n      close(socketFd);\n      if (queueLength)\n        return printf(\"qlen %d\", queueLength);\n    }\n    else\n    {\n      close(socketFd);\n    }\n  }\n  return socketFd;\n}",
        "source_code": "static void print_queuelen(char *name)\n{\n\tstruct ifreq ifr;\n\tint s;\n\n\ts = socket(AF_INET, SOCK_STREAM, 0);\n\tif (s < 0)\n\t\treturn;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy_IFNAMSIZ(ifr.ifr_name, name);\n\tif (ioctl_or_warn(s, SIOCGIFTXQLEN, &ifr) < 0) {\n\t\tclose(s);\n\t\treturn;\n\t}\n\tclose(s);\n\n\tif (ifr.ifr_qlen)\n\t\tprintf(\"qlen %d\", ifr.ifr_qlen);\n}",
        "parsed_output": "int createSocketAndQueryQueueLength(const char *interfaceName)\n{\n  int socketFd;\n  char buffer[16];\n  unsigned int queueLength;\n  int result;\n\n  socketFd = socket(AF_INET, SOCK_STREAM, 0);\n  if (socketFd >= 0)\n  {\n    memset(buffer, 0, sizeof(buffer));\n    prepareInterfaceRequest(buffer, interfaceName);\n    result = performIoctl(socketFd, SIOCGIFTXQLEN, buffer, \"SIOCGIFTXQLEN\");\n    if (result >= 0)\n    {\n      close(socketFd);\n      if (queueLength)\n        return printf(\"qlen %d\", queueLength);\n    }\n    else\n    {\n      close(socketFd);\n    }\n  }\n  return socketFd;\n}",
        "baseline_code_stripped": "int __fastcall sub_449C97(const char *a1)\n{\n  int result; // eax\n  char s[16]; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v3; // [rsp+20h] [rbp-20h]\n  int fd; // [rsp+3Ch] [rbp-4h]\n\n  result = socket(2, 1, 0);\n  fd = result;\n  if ( result >= 0 )\n  {\n    memset(s, 0, 0x28uLL);\n    sub_409A52(s, a1);\n    if ( (int)sub_40AD08(fd, 0x8942u, (__int64)s, (__int64)\"SIOCGIFTXQLEN\") >= 0 )\n    {\n      close(fd);\n      result = v3;\n      if ( v3 )\n        return printf(\"qlen %d\", v3);\n    }\n    else\n    {\n      return close(fd);\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl print_queuelen(char *name)\n{\n  ifreq ifr; // [rsp+10h] [rbp-30h] BYREF\n  int s; // [rsp+3Ch] [rbp-4h]\n\n  s = socket(2, 1, 0);\n  if ( s >= 0 )\n  {\n    memset(&ifr, 0, sizeof(ifr));\n    strncpy_IFNAMSIZ(ifr.ifr_ifrn.ifrn_name, name);\n    if ( bb_ioctl_or_warn(s, 0x8942u, &ifr, \"SIOCGIFTXQLEN\") >= 0 )\n    {\n      close(s);\n      if ( ifr.ifr_ifru.ifru_ivalue )\n        printf(\"qlen %d\", (unsigned int)ifr.ifr_ifru.ifru_ivalue);\n    }\n    else\n    {\n      close(s);\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.8079572319984436,
        "similarity_score_baseline_stripped": 0.5541179776191711,
        "similarity_score_baseline_debug": 0.8101906180381775
    },
    {
        "func_name": "colon_process",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_41E736(__int64 a1, size_t a2)\n{\n  sub_41CB0F(\" :\");\n  switch ( (unsigned int)sub_41E32F(2) )\n  {\n    case 'd':\n      sub_41E610(2LL, a2);\n      break;\n    case 'e':\n      sub_41E48A(2LL, a2);\n      break;\n    case 'f':\n      sub_41D49C();\n      break;\n    case 'n':\n      sub_41E546(1, a2);\n      break;\n    case 'p':\n      sub_41E546(-1, a2);\n      break;\n    case 'q':\n      sub_41CB48(0);\n    case 'x':\n      sub_41E546(0, a2);\n      break;\n    default:\n      return;\n  }\n}\n",
        "output": "```c\nvoid processInput(__int64 option, size_t dataSize)\n{\n  printDelimiter(\" :\");\n  switch (getInputOption(2))\n  {\n    case 'd':\n      processDataDecrement(2LL, dataSize);\n      break;\n    case 'e':\n      processDataEncrypt(2LL, dataSize);\n      break;\n    case 'f':\n      processFile();\n      break;\n    case 'n':\n      processDataIncrement(1, dataSize);\n      break;\n    case 'p':\n      processDataDecrement(1, dataSize);\n      break;\n    case 'q':\n      exitProgram(0);\n      // Fall through to 'x' case is intentional\n    case 'x':\n      processDataReset(0, dataSize);\n      break;\n    default:\n      return;\n  }\n}\n```",
        "source_code": "static void colon_process(void)\n{\n\tint keypress;\n\n\t/* Clear the current line and print a prompt */\n\tprint_statusline(\" :\");\n\n\tkeypress = less_getch(2);\n\tswitch (keypress) {\n\tcase 'd':\n\t\tremove_current_file();\n\t\tbreak;\n\tcase 'e':\n\t\texamine_file();\n\t\tbreak;\n#if ENABLE_FEATURE_LESS_FLAGS\n\tcase 'f':\n\t\tm_status_print();\n\t\tbreak;\n#endif\n\tcase 'n':\n\t\tchange_file(1);\n\t\tbreak;\n\tcase 'p':\n\t\tchange_file(-1);\n\t\tbreak;\n\tcase 'q':\n\t\tless_exit(EXIT_SUCCESS);\n\t\tbreak;\n\tcase 'x':\n\t\tchange_file(0);\n\t\tbreak;\n\t}\n}",
        "parsed_output": "void processInput(__int64 option, size_t dataSize)\n{\n  printDelimiter(\" :\");\n  switch (getInputOption(2))\n  {\n    case 'd':\n      processDataDecrement(2LL, dataSize);\n      break;\n    case 'e':\n      processDataEncrypt(2LL, dataSize);\n      break;\n    case 'f':\n      processFile();\n      break;\n    case 'n':\n      processDataIncrement(1, dataSize);\n      break;\n    case 'p':\n      processDataDecrement(1, dataSize);\n      break;\n    case 'q':\n      exitProgram(0);\n      // Fall through to 'x' case is intentional\n    case 'x':\n      processDataReset(0, dataSize);\n      break;\n    default:\n      return;\n  }\n}",
        "baseline_code_stripped": "void __fastcall sub_41E736(__int64 a1, size_t a2)\n{\n  sub_41CB0F(\" :\");\n  switch ( (unsigned int)sub_41E32F(2) )\n  {\n    case 'd':\n      sub_41E610(2LL, a2);\n      break;\n    case 'e':\n      sub_41E48A(2LL, a2);\n      break;\n    case 'f':\n      sub_41D49C();\n      break;\n    case 'n':\n      sub_41E546(1, a2);\n      break;\n    case 'p':\n      sub_41E546(-1, a2);\n      break;\n    case 'q':\n      sub_41CB48(0);\n    case 'x':\n      sub_41E546(0, a2);\n      break;\n    default:\n      return;\n  }\n}\n",
        "baseline_code_debug": "void __cdecl colon_process()\n{\n  print_statusline(\" :\");\n  switch ( (unsigned int)less_getch(2) )\n  {\n    case 'd':\n      remove_current_file();\n      break;\n    case 'e':\n      examine_file();\n      break;\n    case 'f':\n      m_status_print();\n      break;\n    case 'n':\n      change_file(1);\n      break;\n    case 'p':\n      change_file(-1);\n      break;\n    case 'q':\n      less_exit(0);\n      return;\n    case 'x':\n      change_file(0);\n      break;\n    default:\n      return;\n  }\n}\n",
        "similarity_score_unixcoder": 0.6191883087158203,
        "similarity_score_baseline_stripped": 0.5506695508956909,
        "similarity_score_baseline_debug": 0.8896037340164185
    },
    {
        "func_name": "next_rule",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nstruct termios *__fastcall sub_49CCDF(__int64 a1, FILE *(__fastcall *a2)(const char *a1))\n{\n  __int64 v2; // rsi\n  speed_t c_ospeed; // eax\n  void *v5; // rax\n  __int64 v6; // rsi\n  speed_t v7; // eax\n  struct termios *v8; // [rsp+8h] [rbp-18h]\n\n  if ( !*(_QWORD *)&dest.c_cc[23] && *(_QWORD *)&dest.c_cc[15] )\n  {\n    a2 = sub_40982E;\n    *(_QWORD *)&dest.c_cc[23] = sub_502450(*(_QWORD *)&dest.c_cc[15], sub_40982E);\n    *(_QWORD *)&dest.c_cc[15] = 0LL;\n  }\n  if ( *(_QWORD *)&dest.c_cc[31] )\n  {\n    if ( *(_QWORD *)(8LL * dest.c_ospeed + *(_QWORD *)&dest.c_cc[31]) )\n    {\n      v2 = *(_QWORD *)&dest.c_cc[31];\n      c_ospeed = dest.c_ospeed;\n      dest.c_ospeed = c_ospeed + 1;\n      return *(struct termios **)(v2 + 8LL * c_ospeed);\n    }\n    sub_49C7AA();\n  }\n  else\n  {\n    sub_49C7E0();\n  }\n  v8 = &stru_75B438;\n  if ( *(_QWORD *)&dest.c_cc[23] )\n  {\n    sub_49C9E6();\n    if ( *(_QWORD *)&dest.c_cc[31] )\n    {\n      v5 = sub_40A05F(0x80uLL, (__int64)a2);\n      v8 = (struct termios *)memcpy(v5, &stru_75B438, 0x80uLL);\n      *(_QWORD *)&dest.c_cc[31] = sub_50C0E1(*(_QWORD *)&dest.c_cc[31], 2052LL, dest.c_ospeed);\n      v6 = *(_QWORD *)&dest.c_cc[31];\n      v7 = dest.c_ospeed;\n      dest.c_ospeed = v7 + 1;\n      *(_QWORD *)(v6 + 8LL * v7) = v8;\n    }\n  }\n  return v8;\n}\n",
        "output": "```c\nstruct termios *update_termios_settings(__int64 settings, FILE *(*open_function)(const char *filename))\n{\n  __int64 settings_ptr;\n  speed_t current_speed;\n  void *allocated_memory;\n  __int64 settings_base_ptr;\n  speed_t new_speed;\n  struct termios *result_termios;\n\n  // Check if the custom open function is not set and the default one is set\n  if (!dest.c_cc[VEOL2] && dest.c_cc[VSTART]) \n  {\n    open_function = default_open; // Set the custom open function to default\n    dest.c_cc[VEOL2] = custom_open(dest.c_cc[VSTART], default_open); // Update VEOL2 with the result of custom_open\n    dest.c_cc[VSTART] = 0; // Clear VSTART\n  }\n\n  // Check if there is a settings base pointer\n  if (dest.c_cc[VMIN]) \n  {\n    // Check if the settings for the current speed are set\n    if (*(struct termios **)(dest.c_cc[VMIN] + dest.c_ospeed * sizeof(struct termios *)))\n    {\n      settings_ptr = dest.c_cc[VMIN];\n      current_speed = dest.c_ospeed;\n      dest.c_ospeed = current_speed + 1; // Increment the speed\n      return *(struct termios **)(settings_ptr + current_speed * sizeof(struct termios *));\n    }\n    handle_no_speed_settings(); // Handle the case when there are no settings for the current speed\n  }\n  else\n  {\n    handle_no_base_settings(); // Handle the case when there is no settings base pointer\n  }\n\n  result_termios = &default_termios; // Set the result to the address of default_termios\n\n  // Check if the custom open function is set\n  if (dest.c_cc[VEOL2]) \n  {\n    handle_custom_open_set(); // Handle the case when the custom open function is set\n\n    // Check again if there is a settings base pointer\n    if (dest.c_cc[VMIN]) \n    {\n      allocated_memory = allocate_memory(0x80); // Allocate 128 bytes of memory\n      result_termios = (struct termios *)memcpy(allocated_memory, &default_termios, 0x80); // Copy the default_termios to the allocated memory\n      dest.c_cc[VMIN] = update_settings_base(dest.c_cc[VMIN], 2052, dest.c_ospeed); // Update the settings base pointer\n      settings_base_ptr = dest.c_cc[VMIN];\n      new_speed = dest.c_ospeed;\n      dest.c_ospeed = new_speed + 1; // Increment the speed\n      *(struct termios **)(settings_base_ptr + new_speed * sizeof(struct termios *)) = result_termios; // Set the termios pointer for the new speed\n    }\n  }\n\n  return result_termios; // Return the result termios pointer\n}\n```",
        "source_code": "static const struct rule *next_rule(void)\n{\n\tstruct rule *rule;\n\n\t/* Open conf file if we didn't do it yet */\n\tif (!G.parser && G.filename) {\n\t\tdbg3(\"config_open('%s')\", G.filename);\n\t\tG.parser = config_open2(G.filename, fopen_for_read);\n\t\tG.filename = NULL;\n\t}\n\n\tif (G.rule_vec) {\n\t\t/* mdev -s */\n\t\t/* Do we have rule parsed already? */\n\t\tif (G.rule_vec[G.rule_idx]) {\n\t\t\tdbg3(\"< G.rule_vec[G.rule_idx:%d]=%p\", G.rule_idx, G.rule_vec[G.rule_idx]);\n\t\t\treturn G.rule_vec[G.rule_idx++];\n\t\t}\n\t\tmake_default_cur_rule();\n\t} else {\n\t\t/* not mdev -s */\n\t\tclean_up_cur_rule();\n\t}\n\n\t/* Parse one more rule if file isn't fully read */\n\trule = &G.cur_rule;\n\tif (G.parser) {\n\t\tparse_next_rule();\n\t\tif (G.rule_vec) { /* mdev -s */\n\t\t\trule = memcpy(xmalloc(sizeof(G.cur_rule)), &G.cur_rule, sizeof(G.cur_rule));\n\t\t\tG.rule_vec = xrealloc_vector(G.rule_vec, 4, G.rule_idx);\n\t\t\tG.rule_vec[G.rule_idx++] = rule;\n\t\t\tdbg3(\"> G.rule_vec[G.rule_idx:%d]=%p\", G.rule_idx, G.rule_vec[G.rule_idx]);\n\t\t}\n\t}\n\n\treturn rule;\n}",
        "parsed_output": "struct termios *update_termios_settings(__int64 settings, FILE *(*open_function)(const char *filename))\n{\n  __int64 settings_ptr;\n  speed_t current_speed;\n  void *allocated_memory;\n  __int64 settings_base_ptr;\n  speed_t new_speed;\n  struct termios *result_termios;\n\n  // Check if the custom open function is not set and the default one is set\n  if (!dest.c_cc[VEOL2] && dest.c_cc[VSTART]) \n  {\n    open_function = default_open; // Set the custom open function to default\n    dest.c_cc[VEOL2] = custom_open(dest.c_cc[VSTART], default_open); // Update VEOL2 with the result of custom_open\n    dest.c_cc[VSTART] = 0; // Clear VSTART\n  }\n\n  // Check if there is a settings base pointer\n  if (dest.c_cc[VMIN]) \n  {\n    // Check if the settings for the current speed are set\n    if (*(struct termios **)(dest.c_cc[VMIN] + dest.c_ospeed * sizeof(struct termios *)))\n    {\n      settings_ptr = dest.c_cc[VMIN];\n      current_speed = dest.c_ospeed;\n      dest.c_ospeed = current_speed + 1; // Increment the speed\n      return *(struct termios **)(settings_ptr + current_speed * sizeof(struct termios *));\n    }\n    handle_no_speed_settings(); // Handle the case when there are no settings for the current speed\n  }\n  else\n  {\n    handle_no_base_settings(); // Handle the case when there is no settings base pointer\n  }\n\n  result_termios = &default_termios; // Set the result to the address of default_termios\n\n  // Check if the custom open function is set\n  if (dest.c_cc[VEOL2]) \n  {\n    handle_custom_open_set(); // Handle the case when the custom open function is set\n\n    // Check again if there is a settings base pointer\n    if (dest.c_cc[VMIN]) \n    {\n      allocated_memory = allocate_memory(0x80); // Allocate 128 bytes of memory\n      result_termios = (struct termios *)memcpy(allocated_memory, &default_termios, 0x80); // Copy the default_termios to the allocated memory\n      dest.c_cc[VMIN] = update_settings_base(dest.c_cc[VMIN], 2052, dest.c_ospeed); // Update the settings base pointer\n      settings_base_ptr = dest.c_cc[VMIN];\n      new_speed = dest.c_ospeed;\n      dest.c_ospeed = new_speed + 1; // Increment the speed\n      *(struct termios **)(settings_base_ptr + new_speed * sizeof(struct termios *)) = result_termios; // Set the termios pointer for the new speed\n    }\n  }\n\n  return result_termios; // Return the result termios pointer\n}",
        "baseline_code_stripped": "struct termios *__fastcall sub_49CCDF(__int64 a1, FILE *(__fastcall *a2)(const char *a1))\n{\n  __int64 v2; // rsi\n  speed_t c_ospeed; // eax\n  void *v5; // rax\n  __int64 v6; // rsi\n  speed_t v7; // eax\n  struct termios *v8; // [rsp+8h] [rbp-18h]\n\n  if ( !*(_QWORD *)&dest.c_cc[23] && *(_QWORD *)&dest.c_cc[15] )\n  {\n    a2 = sub_40982E;\n    *(_QWORD *)&dest.c_cc[23] = sub_502450(*(_QWORD *)&dest.c_cc[15], sub_40982E);\n    *(_QWORD *)&dest.c_cc[15] = 0LL;\n  }\n  if ( *(_QWORD *)&dest.c_cc[31] )\n  {\n    if ( *(_QWORD *)(8LL * dest.c_ospeed + *(_QWORD *)&dest.c_cc[31]) )\n    {\n      v2 = *(_QWORD *)&dest.c_cc[31];\n      c_ospeed = dest.c_ospeed;\n      dest.c_ospeed = c_ospeed + 1;\n      return *(struct termios **)(v2 + 8LL * c_ospeed);\n    }\n    sub_49C7AA();\n  }\n  else\n  {\n    sub_49C7E0();\n  }\n  v8 = &stru_75B438;\n  if ( *(_QWORD *)&dest.c_cc[23] )\n  {\n    sub_49C9E6();\n    if ( *(_QWORD *)&dest.c_cc[31] )\n    {\n      v5 = sub_40A05F(0x80uLL, (__int64)a2);\n      v8 = (struct termios *)memcpy(v5, &stru_75B438, 0x80uLL);\n      *(_QWORD *)&dest.c_cc[31] = sub_50C0E1(*(_QWORD *)&dest.c_cc[31], 2052LL, dest.c_ospeed);\n      v6 = *(_QWORD *)&dest.c_cc[31];\n      v7 = dest.c_ospeed;\n      dest.c_ospeed = v7 + 1;\n      *(_QWORD *)(v6 + 8LL * v7) = v8;\n    }\n  }\n  return v8;\n}\n",
        "baseline_code_debug": "const rule *__cdecl next_rule()\n{\n  __int64 v0; // rsi\n  speed_t c_ospeed; // eax\n  void *v3; // rax\n  __int64 v4; // rsi\n  speed_t v5; // eax\n  rule *rule; // [rsp+8h] [rbp-18h]\n\n  if ( !*(_QWORD *)&bb_common_bufsiz1.c_cc[23] && *(_QWORD *)&bb_common_bufsiz1.c_cc[15] )\n  {\n    *(_QWORD *)&bb_common_bufsiz1.c_cc[23] = config_open2(\n                                               *(const char **)&bb_common_bufsiz1.c_cc[15],\n                                               (FILE *(*)(const char *))fopen_for_read);\n    *(_QWORD *)&bb_common_bufsiz1.c_cc[15] = 0LL;\n  }\n  if ( *(_QWORD *)&bb_common_bufsiz1.c_cc[31] )\n  {\n    if ( *(_QWORD *)(8LL * bb_common_bufsiz1.c_ospeed + *(_QWORD *)&bb_common_bufsiz1.c_cc[31]) )\n    {\n      v0 = *(_QWORD *)&bb_common_bufsiz1.c_cc[31];\n      c_ospeed = bb_common_bufsiz1.c_ospeed;\n      bb_common_bufsiz1.c_ospeed = c_ospeed + 1;\n      return *(const rule **)(v0 + 8LL * c_ospeed);\n    }\n    make_default_cur_rule();\n  }\n  else\n  {\n    clean_up_cur_rule();\n  }\n  rule = (rule *)(&dst + 4);\n  if ( *(_QWORD *)&bb_common_bufsiz1.c_cc[23] )\n  {\n    parse_next_rule();\n    if ( *(_QWORD *)&bb_common_bufsiz1.c_cc[31] )\n    {\n      v3 = xmalloc(0x80uLL);\n      rule = (rule *)memcpy(v3, dst.data, 0x80uLL);\n      *(_QWORD *)&bb_common_bufsiz1.c_cc[31] = xrealloc_vector_helper(\n                                                 *(void **)&bb_common_bufsiz1.c_cc[31],\n                                                 0x804u,\n                                                 bb_common_bufsiz1.c_ospeed);\n      v4 = *(_QWORD *)&bb_common_bufsiz1.c_cc[31];\n      v5 = bb_common_bufsiz1.c_ospeed;\n      bb_common_bufsiz1.c_ospeed = v5 + 1;\n      *(_QWORD *)(v4 + 8LL * v5) = rule;\n    }\n  }\n  return rule;\n}\n",
        "similarity_score_unixcoder": 0.5487772822380066,
        "similarity_score_baseline_stripped": 0.45151954889297485,
        "similarity_score_baseline_debug": 0.7387024164199829
    },
    {
        "func_name": "xfopen_stdin",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Data to be processed\n\nBelow is the code you will process:\n\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nFILE *__fastcall sub_50A7F5(__int64 a1)\n{\n  FILE *v2; // [rsp+18h] [rbp-8h]\n\n  v2 = sub_50A79F(a1);\n  if ( !v2 )\n    sub_40992F();\n  return v2;\n}\n",
        "output": "FILE *openFile(__int64 filePath)\n{\n  FILE *fileHandle = getFileHandle(filePath);\n  if (fileHandle == NULL)\n    handleFileError();\n  return fileHandle;\n}",
        "source_code": "FAST_FUNC xfopen_stdin(const char *filename)\n{\n\tFILE *fp = fopen_or_warn_stdin(filename);\n\tif (fp)\n\t\treturn fp;\n\txfunc_die();  /* We already output an error message. */\n}",
        "parsed_output": "FILE *openFile(__int64 filePath)\n{\n  FILE *fileHandle = getFileHandle(filePath);\n  if (fileHandle == NULL)\n    handleFileError();\n  return fileHandle;\n}",
        "baseline_code_stripped": "FILE *__fastcall sub_50A7F5(__int64 a1)\n{\n  FILE *v2; // [rsp+18h] [rbp-8h]\n\n  v2 = sub_50A79F(a1);\n  if ( !v2 )\n    sub_40992F();\n  return v2;\n}\n",
        "baseline_code_debug": "FILE *__cdecl xfopen_stdin(const char *filename)\n{\n  FILE *fp; // [rsp+18h] [rbp-8h]\n\n  fp = fopen_or_warn_stdin(filename);\n  if ( !fp )\n    xfunc_die();\n  return fp;\n}\n",
        "similarity_score_unixcoder": 0.6157107353210449,
        "similarity_score_baseline_stripped": 0.4857487380504608,
        "similarity_score_baseline_debug": 0.8808138966560364
    }
]
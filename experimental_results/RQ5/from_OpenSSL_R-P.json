[
    {
        "func_name": "rtnl_rtprot_n2a",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl type_str(unsigned __int64 value, void *arg)\n{\n  unsigned __int64 types; // [rsp+18h] [rbp-8h]\n\n  types = *(_QWORD *)arg;\n  if ( (*(_QWORD *)arg & 2) != 0 && !is_printable(value) )\n    types &= ~2uLL;\n  if ( (types & 0x10) != 0 && value > 0x7F )\n    types &= ~0x10uLL;\n  if ( (types & 4) != 0 && value > 0xFF )\n    types &= ~4uLL;\n  if ( (types & 0x800) != 0 && value > 0xFFFF )\n    types &= ~0x800uLL;\n  if ( !types )\n    return -1;\n  *(_QWORD *)arg = types;\n  return 1;\n}\n\n\n Revised code:\nstatic int type_str(unsigned long value, void *arg)\n{\n    unsigned long types;\n    types = *((unsigned long *)arg);\n    if ((types & B_ASN1_PRINTABLESTRING) && !is_printable(value))\n        types &= ~B_ASN1_PRINTABLESTRING;\n    if ((types & B_ASN1_IA5STRING) && (value > 127))\n        types &= ~B_ASN1_IA5STRING;\n    if ((types & B_ASN1_T61STRING) && (value > 0xff))\n        types &= ~B_ASN1_T61STRING;\n    if ((types & B_ASN1_BMPSTRING) && (value > 0xffff))\n        types &= ~B_ASN1_BMPSTRING;\n    if (!types)\n        return -1;\n    *((unsigned long *)arg) = types;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_utf8(unsigned __int64 value, void *arg)\n{\n  *(_QWORD *)arg += UTF8_putc(*(unsigned __int8 **)arg, 255, value);\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_utf8(unsigned long value, void *arg)\n{\n    unsigned char **p;\n    int ret;\n    p = arg;\n    /* We already know there is enough room so pass 0xff as the length */\n    ret = UTF8_putc(*p, 0xff, value);\n    *p += ret;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_45243B(__int64 a1, char *a2)\n{\n  if ( (unsigned int)a1 < 0x100 )\n  {\n    sub_4523E0(a1, (__int64)a2);\n    if ( *(_QWORD *)(qword_75B1B8 + 8 * ((int)a1 + 2LL)) )\n      return *(char **)(qword_75B1B8 + 8 * ((int)a1 + 2LL));\n  }\n  sprintf(a2, \"%d\", (unsigned int)a1);\n  return a2;\n}\n",
        "output": "static char *sub_45243B(unsigned int value, char *buffer)\n{\n    if (value < 256)\n    {\n        sub_4523E0(value, (long long)buffer);\n        if (*(unsigned long long *)(qword_75B1B8 + 8 * (value + 2)))\n            return *(char **)(qword_75B1B8 + 8 * (value + 2));\n    }\n    sprintf(buffer, \"%u\", value);\n    return buffer;\n}",
        "source_code": "FAST_FUNC rtnl_rtprot_n2a(int id, char *buf)\n{\n\tif (id < 0 || id >= 256) {\n\t\tsprintf(buf, \"%d\", id);\n\t\treturn buf;\n\t}\n\n\trtnl_rtprot_initialize();\n\n\tif (rtnl_rtprot_tab->tab[id])\n\t\treturn rtnl_rtprot_tab->tab[id];\n\t/* buf is SPRINT_BSIZE big */\n\tsprintf(buf, \"%d\", id);\n\treturn buf;\n}",
        "parsed_output": "static char *sub_45243B(unsigned int value, char *buffer)\n{\n    if (value < 256)\n    {\n        sub_4523E0(value, (long long)buffer);\n        if (*(unsigned long long *)(qword_75B1B8 + 8 * (value + 2)))\n            return *(char **)(qword_75B1B8 + 8 * (value + 2));\n    }\n    sprintf(buffer, \"%u\", value);\n    return buffer;\n}",
        "baseline_code_stripped": "char *__fastcall sub_45243B(__int64 a1, char *a2)\n{\n  if ( (unsigned int)a1 < 0x100 )\n  {\n    sub_4523E0(a1, (__int64)a2);\n    if ( *(_QWORD *)(qword_75B1B8 + 8 * ((int)a1 + 2LL)) )\n      return *(char **)(qword_75B1B8 + 8 * ((int)a1 + 2LL));\n  }\n  sprintf(a2, \"%d\", (unsigned int)a1);\n  return a2;\n}\n",
        "baseline_code_debug": "const char *__cdecl rtnl_rtprot_n2a(int id, char *buf)\n{\n  if ( (unsigned int)id < 0x100 )\n  {\n    rtnl_rtprot_initialize();\n    if ( rtnl_rtprot_tab->tab[id] )\n      return rtnl_rtprot_tab->tab[id];\n  }\n  sprintf(buf, \"%d\", (unsigned int)id);\n  return buf;\n}\n",
        "similarity_score_unixcoder": 0.5176326632499695,
        "similarity_score_baseline_stripped": 0.5272172689437866,
        "similarity_score_baseline_debug": 0.936894953250885
    },
    {
        "func_name": "parse_mount_options",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl t_fromb64(unsigned __int8 *a, const char *src)\n{\n  int v2; // eax\n  unsigned __int8 *v3; // rcx\n  int v4; // eax\n  char *loc; // [rsp+18h] [rbp-18h]\n  int size; // [rsp+24h] [rbp-Ch]\n  int sizea; // [rsp+24h] [rbp-Ch]\n  int j; // [rsp+28h] [rbp-8h]\n  int i; // [rsp+2Ch] [rbp-4h]\n  int ia; // [rsp+2Ch] [rbp-4h]\n  int ib; // [rsp+2Ch] [rbp-4h]\n  int ic; // [rsp+2Ch] [rbp-4h]\n  int id; // [rsp+2Ch] [rbp-4h]\n  int ie; // [rsp+2Ch] [rbp-4h]\n\n  while ( *src && (*src == 32 || *src == 9 || *src == 10) )\n    ++src;\n  size = strlen(src);\n  for ( i = 0; i < size; ++i )\n  {\n    loc = strchr(b64table, src[i]);\n    if ( !loc )\n      break;\n    a[i] = loc - b64table;\n  }\n  sizea = i;\n  ia = i - 1;\n  j = sizea;\n  do\n  {\n    a[j] = a[ia];\n    ib = ia - 1;\n    if ( ib < 0 )\n      break;\n    a[j--] |= a[ib] << 6;\n    a[j] = ((int)a[ib] >> 2) & 0xF;\n    ic = ib - 1;\n    if ( ic < 0 )\n      break;\n    a[j--] |= 16 * a[ic];\n    a[j] = ((int)a[ic] >> 4) & 3;\n    id = ic - 1;\n    if ( id < 0 )\n      break;\n    a[j--] |= 4 * a[id];\n    a[j] = 0;\n    ia = id - 1;\n  }\n  while ( ia >= 0 );\n  while ( !a[j] && j <= sizea )\n    ++j;\n  ie = 0;\n  while ( j <= sizea )\n  {\n    v2 = j++;\n    v3 = &a[v2];\n    v4 = ie++;\n    a[v4] = *v3;\n  }\n  return ie;\n}\n\n\n Revised code:\nstatic int t_fromb64(unsigned char *a, const char *src)\n{\n    char *loc;\n    int i, j;\n    int size;\n\n    while (*src && (*src == ' ' || *src == '\\t' || *src == '\\n'))\n        ++src;\n    size = strlen(src);\n    i = 0;\n    while (i < size) {\n        loc = strchr(b64table, src[i]);\n        if (loc == (char *)0)\n            break;\n        else\n            a[i] = loc - b64table;\n        ++i;\n    }\n    /* if nothing valid to process we have a zero length response */\n    if (i == 0)\n        return 0;\n    size = i;\n    i = size - 1;\n    j = size;\n    while (1) {\n        a[j] = a[i];\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] & 3) << 6;\n        --j;\n        a[j] = (unsigned char)((a[i] & 0x3c) >> 2);\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] & 0xf) << 4;\n        --j;\n        a[j] = (unsigned char)((a[i] & 0x30) >> 4);\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] << 2);\n\n        a[--j] = 0;\n        if (--i < 0)\n            break;\n    }\n    while (a[j] == 0 && j <= size)\n        ++j;\n    i = 0;\n    while (j <= size)\n        a[i++] = a[j++];\n    return i;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nchar *__cdecl t_tob64(char *dst, const unsigned __int8 *src, int size)\n{\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  int v7; // eax\n  char *dsta; // [rsp+Ch] [rbp-28h]\n  int c; // [rsp+20h] [rbp-14h]\n  int ca; // [rsp+20h] [rbp-14h]\n  unsigned __int8 notleading; // [rsp+2Ch] [rbp-8h]\n  unsigned __int8 b2; // [rsp+2Dh] [rbp-7h]\n  unsigned __int8 b1; // [rsp+2Eh] [rbp-6h]\n  unsigned __int8 b0; // [rsp+2Fh] [rbp-5h]\n  int pos; // [rsp+30h] [rbp-4h]\n\n  dsta = dst;\n  pos = size % 3;\n  b0 = 0;\n  b1 = 0;\n  b2 = 0;\n  notleading = 0;\n  if ( size % 3 == 1 )\n  {\n    b2 = *src;\n  }\n  else if ( pos == 2 )\n  {\n    b1 = *src;\n    b2 = src[1];\n  }\n  while ( 1 )\n  {\n    if ( notleading || b0 >> 2 )\n    {\n      v3 = dsta++;\n      *v3 = b64table[b0 >> 2];\n      notleading = 1;\n    }\n    c = (16 * b0) & 0x30 | (b1 >> 4);\n    if ( notleading || c )\n    {\n      v4 = dsta++;\n      *v4 = b64table[c];\n      notleading = 1;\n    }\n    ca = (4 * b1) & 0x3C | (b2 >> 6);\n    if ( notleading || ca )\n    {\n      v5 = dsta++;\n      *v5 = b64table[ca];\n      notleading = 1;\n    }\n    if ( notleading || (b2 & 0x3F) != 0 )\n    {\n      v6 = dsta++;\n      *v6 = b64table[b2 & 0x3F];\n      notleading = 1;\n    }\n    if ( pos >= size )\n      break;\n    b0 = src[pos];\n    b1 = src[pos + 1];\n    v7 = pos + 2;\n    pos += 3;\n    b2 = src[v7];\n  }\n  *dsta = 0;\n  return dst;\n}\n\n\n Revised code:\nstatic char *t_tob64(char *dst, const unsigned char *src, int size)\n{\n    int c, pos = size % 3;\n    unsigned char b0 = 0, b1 = 0, b2 = 0, notleading = 0;\n    char *olddst = dst;\n\n    switch (pos) {\n    case 1:\n        b2 = src[0];\n        break;\n    case 2:\n        b1 = src[0];\n        b2 = src[1];\n        break;\n    }\n\n    while (1) {\n        c = (b0 & 0xfc) >> 2;\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = ((b0 & 3) << 4) | ((b1 & 0xf0) >> 4);\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = ((b1 & 0xf) << 2) | ((b2 & 0xc0) >> 6);\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = b2 & 0x3f;\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        if (pos >= size)\n            break;\n        else {\n            b0 = src[pos++];\n            b1 = src[pos++];\n            b2 = src[pos++];\n        }\n    }\n\n    *dst++ = '\\0';\n    return olddst;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4A1EAA(const char *a1, char **a2)\n{\n  char *v2; // rax\n  unsigned int v3; // eax\n  __int64 v4; // rbx\n  size_t v5; // rax\n  int v6; // eax\n  char *s; // [rsp+8h] [rbp-58h]\n  char *v9; // [rsp+10h] [rbp-50h]\n  char *v10; // [rsp+10h] [rbp-50h]\n  __int64 v11; // [rsp+18h] [rbp-48h]\n  unsigned int n; // [rsp+24h] [rbp-3Ch]\n  size_t n_4; // [rsp+28h] [rbp-38h]\n  unsigned int v14; // [rsp+34h] [rbp-2Ch]\n  char *s1; // [rsp+38h] [rbp-28h]\n  unsigned int i; // [rsp+44h] [rbp-1Ch]\n  __int64 v17; // [rsp+48h] [rbp-18h]\n\n  s = (char *)a1;\n  v17 = 0x8000LL;\n  v2 = strchr(a1, 44);\n  while ( 2 )\n  {\n    n_4 = (size_t)v2;\n    s1 = \"loop\";\n    if ( v2 )\n      *v2 = 0;\n    for ( i = 0; i <= 0x2A; ++i )\n    {\n      n = strlen(s1);\n      if ( !strncasecmp(s1, s, n) && (!s[n] || s1[n - 1] == 61) )\n      {\n        v11 = dword_522120[i];\n        if ( (int)v11 >= 0 )\n          v17 |= v11;\n        else\n          v17 &= v11;\n        goto LABEL_21;\n      }\n      s1 += n + 1;\n    }\n    if ( *s && a2 )\n    {\n      v9 = *a2;\n      if ( *a2 )\n        v3 = strlen(v9);\n      else\n        v3 = 0;\n      v14 = v3;\n      v4 = v3;\n      v5 = strlen(s);\n      v10 = (char *)sub_40A09E(v9, v4 + v5 + 2);\n      *a2 = v10;\n      if ( v14 )\n      {\n        v6 = v14++;\n        v10[v6] = 44;\n      }\n      strcpy(&v10[v14], s);\n    }\nLABEL_21:\n    if ( n_4 )\n    {\n      *(_BYTE *)n_4 = 44;\n      s = (char *)(n_4 + 1);\n      v2 = strchr((const char *)(n_4 + 1), 44);\n      continue;\n    }\n    return v17;\n  }\n}\n",
        "output": "```c\nstatic __int64 sub_4A1EAA(const char *input, char **output)\n{\n    const char *current;\n    char *commaPos;\n    __int64 flags = 0x8000LL;\n    unsigned int i, length;\n    size_t inputLen;\n    const char *keywords = \"loop\";\n\n    current = input;\n    commaPos = strchr(input, ',');\n    while (1)\n    {\n        if (commaPos)\n            *commaPos = '\\0';\n\n        for (i = 0; i <= 0x2A; ++i)\n        {\n            length = strlen(keywords);\n            if (!strncasecmp(keywords, current, length) && (!current[length] || keywords[length - 1] == '='))\n            {\n                __int64 keywordFlag = dword_522120[i];\n                if ((int)keywordFlag >= 0)\n                    flags |= keywordFlag;\n                else\n                    flags &= keywordFlag;\n                goto NEXT_SEGMENT;\n            }\n            keywords += length + 1;\n        }\n\n        if (*current && output)\n        {\n            char *outStr = *output;\n            unsigned int outLen = outStr ? strlen(outStr) : 0;\n            inputLen = strlen(current);\n            char *newOutStr = (char *)sub_40A09E(outStr, outLen + inputLen + 2);\n            *output = newOutStr;\n            if (outLen)\n            {\n                newOutStr[outLen++] = ',';\n            }\n            strcpy(&newOutStr[outLen], current);\n        }\n\n    NEXT_SEGMENT:\n        if (commaPos)\n        {\n            *commaPos = ',';\n            current = commaPos + 1;\n            commaPos = strchr(current, ',');\n        }\n        else\n        {\n            break;\n        }\n    }\n    return flags;\n}\n```",
        "source_code": "NULL\nstatic unsigned long parse_mount_options(char *options, char **unrecognized)\n{\n\tunsigned long flags = MS_SILENT;\n\n\t// Loop through options\n\tfor (;;) {\n\t\tunsigned i;\n\t\tchar *comma = strchr(options, ',');\n\t\tconst char *option_str = mount_option_str;\n\n\t\tif (comma) *comma = '\\0';\n\n// FIXME: use hasmntopt()\n\t\t// Find this option in mount_options\n\t\tfor (i = 0; i < ARRAY_SIZE(mount_options); i++) {\n\t\t\tunsigned opt_len = strlen(option_str);\n\n\t\t\tif (strncasecmp(option_str, options, opt_len) == 0\n\t\t\t && (options[opt_len] == '\\0'\n\t\t\t    /* or is it \"comment=\" thingy in fstab? */\n\t\t\t    IF_FEATURE_MOUNT_FSTAB(IF_DESKTOP( || option_str[opt_len-1] == '=' ))\n\t\t\t    )\n\t\t\t) {\n\t\t\t\tunsigned long fl = mount_options[i];\n\t\t\t\tif (fl & BB_MS_INVERTED_VALUE)\n\t\t\t\t\tflags &= fl;\n\t\t\t\telse\n\t\t\t\t\tflags |= fl;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t\toption_str += opt_len + 1;\n\t\t}\n\t\t// We did not recognize this option.\n\t\t// If \"unrecognized\" is not NULL, append option there.\n\t\t// Note that we should not append *empty* option -\n\t\t// in this case we want to pass NULL, not \"\", to \"data\"\n\t\t// parameter of mount(2) syscall.\n\t\t// This is crucial for filesystems that don't accept\n\t\t// any arbitrary mount options, like cgroup fs:\n\t\t// \"mount -t cgroup none /mnt\"\n\t\tif (options[0] && unrecognized) {\n\t\t\t// Add it to strflags, to pass on to kernel\n\t\t\tchar *p = *unrecognized;\n\t\t\tunsigned len = p ? strlen(p) : 0;\n\t\t\t*unrecognized = p = xrealloc(p, len + strlen(options) + 2);\n\n\t\t\t// Comma separated if it's not the first one\n\t\t\tif (len) p[len++] = ',';\n\t\t\tstrcpy(p + len, options);\n\t\t}\n found:\n\t\tif (!comma)\n\t\t\tbreak;\n\t\t// Advance to next option\n\t\t*comma = ',';\n\t\toptions = ++comma;\n\t}\n\n\treturn flags;\n}",
        "parsed_output": "static __int64 sub_4A1EAA(const char *input, char **output)\n{\n    const char *current;\n    char *commaPos;\n    __int64 flags = 0x8000LL;\n    unsigned int i, length;\n    size_t inputLen;\n    const char *keywords = \"loop\";\n\n    current = input;\n    commaPos = strchr(input, ',');\n    while (1)\n    {\n        if (commaPos)\n            *commaPos = '\\0';\n\n        for (i = 0; i <= 0x2A; ++i)\n        {\n            length = strlen(keywords);\n            if (!strncasecmp(keywords, current, length) && (!current[length] || keywords[length - 1] == '='))\n            {\n                __int64 keywordFlag = dword_522120[i];\n                if ((int)keywordFlag >= 0)\n                    flags |= keywordFlag;\n                else\n                    flags &= keywordFlag;\n                goto NEXT_SEGMENT;\n            }\n            keywords += length + 1;\n        }\n\n        if (*current && output)\n        {\n            char *outStr = *output;\n            unsigned int outLen = outStr ? strlen(outStr) : 0;\n            inputLen = strlen(current);\n            char *newOutStr = (char *)sub_40A09E(outStr, outLen + inputLen + 2);\n            *output = newOutStr;\n            if (outLen)\n            {\n                newOutStr[outLen++] = ',';\n            }\n            strcpy(&newOutStr[outLen], current);\n        }\n\n    NEXT_SEGMENT:\n        if (commaPos)\n        {\n            *commaPos = ',';\n            current = commaPos + 1;\n            commaPos = strchr(current, ',');\n        }\n        else\n        {\n            break;\n        }\n    }\n    return flags;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4A1EAA(const char *a1, char **a2)\n{\n  char *v2; // rax\n  unsigned int v3; // eax\n  __int64 v4; // rbx\n  size_t v5; // rax\n  int v6; // eax\n  char *s; // [rsp+8h] [rbp-58h]\n  char *v9; // [rsp+10h] [rbp-50h]\n  char *v10; // [rsp+10h] [rbp-50h]\n  __int64 v11; // [rsp+18h] [rbp-48h]\n  unsigned int n; // [rsp+24h] [rbp-3Ch]\n  size_t n_4; // [rsp+28h] [rbp-38h]\n  unsigned int v14; // [rsp+34h] [rbp-2Ch]\n  char *s1; // [rsp+38h] [rbp-28h]\n  unsigned int i; // [rsp+44h] [rbp-1Ch]\n  __int64 v17; // [rsp+48h] [rbp-18h]\n\n  s = (char *)a1;\n  v17 = 0x8000LL;\n  v2 = strchr(a1, 44);\n  while ( 2 )\n  {\n    n_4 = (size_t)v2;\n    s1 = \"loop\";\n    if ( v2 )\n      *v2 = 0;\n    for ( i = 0; i <= 0x2A; ++i )\n    {\n      n = strlen(s1);\n      if ( !strncasecmp(s1, s, n) && (!s[n] || s1[n - 1] == 61) )\n      {\n        v11 = dword_522120[i];\n        if ( (int)v11 >= 0 )\n          v17 |= v11;\n        else\n          v17 &= v11;\n        goto LABEL_21;\n      }\n      s1 += n + 1;\n    }\n    if ( *s && a2 )\n    {\n      v9 = *a2;\n      if ( *a2 )\n        v3 = strlen(v9);\n      else\n        v3 = 0;\n      v14 = v3;\n      v4 = v3;\n      v5 = strlen(s);\n      v10 = (char *)sub_40A09E(v9, v4 + v5 + 2);\n      *a2 = v10;\n      if ( v14 )\n      {\n        v6 = v14++;\n        v10[v6] = 44;\n      }\n      strcpy(&v10[v14], s);\n    }\nLABEL_21:\n    if ( n_4 )\n    {\n      *(_BYTE *)n_4 = 44;\n      s = (char *)(n_4 + 1);\n      v2 = strchr((const char *)(n_4 + 1), 44);\n      continue;\n    }\n    return v17;\n  }\n}\n",
        "baseline_code_debug": "unsigned __int64 __cdecl parse_mount_options(char *options, char **unrecognized)\n{\n  unsigned int v2; // eax\n  size_t v3; // rdx\n  unsigned int v4; // eax\n  char *p; // [rsp+10h] [rbp-50h]\n  char *pa; // [rsp+10h] [rbp-50h]\n  unsigned __int64 fl; // [rsp+18h] [rbp-48h]\n  unsigned int opt_len; // [rsp+24h] [rbp-3Ch]\n  char *comma; // [rsp+28h] [rbp-38h]\n  unsigned int len; // [rsp+34h] [rbp-2Ch]\n  const char *option_str; // [rsp+38h] [rbp-28h]\n  unsigned int i; // [rsp+44h] [rbp-1Ch]\n  unsigned __int64 flags; // [rsp+48h] [rbp-18h]\n\n  flags = 0x8000LL;\n  while ( 2 )\n  {\n    comma = strchr(options, 44);\n    option_str = mount_option_str;\n    if ( comma )\n      *comma = 0;\n    for ( i = 0; i <= 0x2A; ++i )\n    {\n      opt_len = strlen(option_str);\n      if ( !strncasecmp(option_str, options, opt_len) && (!options[opt_len] || option_str[opt_len - 1] == 61) )\n      {\n        fl = mount_options[i];\n        if ( (fl & 0x80000000) == 0LL )\n          flags |= fl;\n        else\n          flags &= fl;\n        goto found;\n      }\n      option_str += opt_len + 1;\n    }\n    if ( *options && unrecognized )\n    {\n      p = *unrecognized;\n      if ( *unrecognized )\n        v2 = strlen(p);\n      else\n        v2 = 0;\n      len = v2;\n      v3 = v2 + strlen(options) + 2;\n      pa = (char *)xrealloc(p, v3);\n      *unrecognized = pa;\n      if ( len )\n      {\n        v4 = len++;\n        pa[v4] = 44;\n      }\n      strcpy(&pa[len], options);\n    }\nfound:\n    if ( comma )\n    {\n      *comma = 44;\n      options = comma + 1;\n      continue;\n    }\n    return flags;\n  }\n}\n",
        "similarity_score_unixcoder": 0.5694109201431274,
        "similarity_score_baseline_stripped": 0.4761054217815399,
        "similarity_score_baseline_debug": 0.8356493711471558
    },
    {
        "func_name": "tty_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall __noreturn sub_4D7829(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int v6; // [rsp+10h] [rbp-10h]\n  unsigned int v7; // [rsp+14h] [rbp-Ch]\n  const char *s; // [rsp+18h] [rbp-8h]\n\n  byte_75AE48 = 2;\n  v6 = sub_4FA1EF(a2, (unsigned int)\"s\", a3, a4, a5, a6);\n  sub_50A77A(*(_QWORD *)(8LL * optind + a2));\n  v7 = 0;\n  s = sub_40AD9A(0, (__int64)\"s\");\n  if ( !s )\n  {\n    s = \"not a tty\";\n    v7 = 1;\n  }\n  if ( !v6 )\n    puts(s);\n  sub_4F93C9(v7);\n}\n",
        "output": "```c\nvoid __fastcall __noreturn terminate_with_message(__int64 argv, __int64 argc, int a3, int a4, int a5, int a6)\n{\n    int check_result;\n    unsigned int error_flag;\n    const char *message;\n\n    global_flag = 2;\n    check_result = check_some_condition(argc, (unsigned int)\"s\", a3, a4, a5, a6);\n    process_argument(*(char **)(8LL * option_index + argv));\n    error_flag = 0;\n    message = get_error_message(0, (__int64)\"s\");\n    if (!message)\n    {\n        message = \"not a tty\";\n        error_flag = 1;\n    }\n    if (!check_result)\n        puts(message);\n    finalize_process(error_flag);\n}\n```",
        "source_code": "int tty_main(int argc UNUSED_PARAM, char **argv)\n{\n\tconst char *s;\n\tIF_INCLUDE_SUSv2(int silent;)  /* Note: No longer relevant in SUSv3. */\n\tint retval;\n\n\txfunc_error_retval = 2;  /* SUSv3 requires > 1 for error. */\n\n\tIF_INCLUDE_SUSv2(silent = getopt32(argv, \"s\");)\n\tIF_INCLUDE_SUSv2(argv += optind;)\n\tIF_NOT_INCLUDE_SUSv2(argv += 1;)\n\n\t/* gnu tty outputs a warning that it is ignoring all args. */\n\tbb_warn_ignoring_args(argv[0]);\n\n\tretval = EXIT_SUCCESS;\n\n\ts = xmalloc_ttyname(STDIN_FILENO);\n\tif (s == NULL) {\n\t/* According to SUSv3, ttyname can fail with EBADF or ENOTTY.\n\t * We know the file descriptor is good, so failure means not a tty. */\n\t\ts = \"not a tty\";\n\t\tretval = EXIT_FAILURE;\n\t}\n\tIF_INCLUDE_SUSv2(if (!silent) puts(s);)\n\tIF_NOT_INCLUDE_SUSv2(puts(s);)\n\n\tfflush_stdout_and_exit(retval);\n}",
        "parsed_output": "void __fastcall __noreturn terminate_with_message(__int64 argv, __int64 argc, int a3, int a4, int a5, int a6)\n{\n    int check_result;\n    unsigned int error_flag;\n    const char *message;\n\n    global_flag = 2;\n    check_result = check_some_condition(argc, (unsigned int)\"s\", a3, a4, a5, a6);\n    process_argument(*(char **)(8LL * option_index + argv));\n    error_flag = 0;\n    message = get_error_message(0, (__int64)\"s\");\n    if (!message)\n    {\n        message = \"not a tty\";\n        error_flag = 1;\n    }\n    if (!check_result)\n        puts(message);\n    finalize_process(error_flag);\n}",
        "baseline_code_stripped": "void __fastcall __noreturn sub_4D7829(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int v6; // [rsp+10h] [rbp-10h]\n  unsigned int v7; // [rsp+14h] [rbp-Ch]\n  const char *s; // [rsp+18h] [rbp-8h]\n\n  byte_75AE48 = 2;\n  v6 = sub_4FA1EF(a2, (unsigned int)\"s\", a3, a4, a5, a6);\n  sub_50A77A(*(_QWORD *)(8LL * optind + a2));\n  v7 = 0;\n  s = sub_40AD9A(0, (__int64)\"s\");\n  if ( !s )\n  {\n    s = \"not a tty\";\n    v7 = 1;\n  }\n  if ( !v6 )\n    puts(s);\n  sub_4F93C9(v7);\n}\n",
        "baseline_code_debug": "int __cdecl __noreturn tty_main(int argc, char **argv)\n{\n  int silent; // [rsp+10h] [rbp-10h]\n  int retval; // [rsp+14h] [rbp-Ch]\n  char *s; // [rsp+18h] [rbp-8h]\n\n  xfunc_error_retval = 2;\n  silent = getopt32(argv, \"s\");\n  bb_warn_ignoring_args(argv[optind]);\n  retval = 0;\n  s = xmalloc_ttyname(0);\n  if ( !s )\n  {\n    s = \"not a tty\";\n    retval = 1;\n  }\n  if ( !silent )\n    puts(s);\n  fflush_stdout_and_exit(retval);\n}\n",
        "similarity_score_unixcoder": 0.684599757194519,
        "similarity_score_baseline_stripped": 0.5403790473937988,
        "similarity_score_baseline_debug": 0.8379844427108765
    },
    {
        "func_name": "print_long",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl ctr64_add(unsigned __int8 *counter, size_t inc)\n{\n  unsigned __int64 v2; // rdx\n  unsigned __int8 *countera; // [rsp+8h] [rbp-18h]\n  size_t val; // [rsp+10h] [rbp-10h]\n  size_t n; // [rsp+18h] [rbp-8h]\n\n  n = 8LL;\n  val = 0LL;\n  countera = counter + 8;\n  do\n  {\n    v2 = countera[--n] + (unsigned __int64)(unsigned __int8)inc + val;\n    countera[n] = v2;\n    val = v2 >> 8;\n    inc >>= 8;\n  }\n  while ( n && (inc || val) );\n}\n\n\n Revised code:\nstatic void ctr64_add(unsigned char *counter, size_t inc)\n{\n    size_t n = 8, val = 0;\n\n    counter += 8;\n    do {\n        --n;\n        val += counter[n] + (inc & 0xff);\n        counter[n] = (unsigned char)val;\n        val >>= 8;              /* carry bit */\n        inc >>= 8;\n    } while (n && (inc || val));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4CDCF5(unsigned __int64 a1, _QWORD *a2, const char *a3)\n{\n  __int64 result; // rax\n  unsigned __int64 v6; // [rsp+18h] [rbp-18h]\n\n  v6 = a1 >> 3;\n  while ( 1 )\n  {\n    result = v6--;\n    if ( !result )\n      break;\n    printf(a3, *a2++);\n  }\n  return result;\n}\n",
        "output": "```c\nstatic void sub_4CDCF5(unsigned long long a1, const unsigned long long *a2, const char *format)\n{\n    unsigned long long count = a1 >> 3;\n\n    while (count--)\n    {\n        printf(format, *a2++);\n    }\n}\n```",
        "source_code": "else\nstatic void\nprint_long(size_t n_bytes, const char *block, const char *fmt_string)\n{\n\tn_bytes /= sizeof(unsigned long);\n\twhile (n_bytes--) {\n\t\tunsigned long tmp = *(unsigned long *) block;\n\t\tprintf(fmt_string, tmp);\n\t\tblock += sizeof(unsigned long);\n\t}\n}",
        "parsed_output": "static void sub_4CDCF5(unsigned long long a1, const unsigned long long *a2, const char *format)\n{\n    unsigned long long count = a1 >> 3;\n\n    while (count--)\n    {\n        printf(format, *a2++);\n    }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4CDCF5(unsigned __int64 a1, _QWORD *a2, const char *a3)\n{\n  __int64 result; // rax\n  unsigned __int64 v6; // [rsp+18h] [rbp-18h]\n\n  v6 = a1 >> 3;\n  while ( 1 )\n  {\n    result = v6--;\n    if ( !result )\n      break;\n    printf(a3, *a2++);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl print_long(size_t n_bytes, const char *block, const char *fmt_string)\n{\n  size_t n_bytesa; // [rsp+18h] [rbp-18h]\n\n  n_bytesa = n_bytes >> 3;\n  while ( n_bytesa-- )\n  {\n    printf(fmt_string, *(_QWORD *)block);\n    block += 8;\n  }\n}\n",
        "similarity_score_unixcoder": 0.6930314898490906,
        "similarity_score_baseline_stripped": 0.6116040349006653,
        "similarity_score_baseline_debug": 0.8097018003463745
    },
    {
        "func_name": "printargv",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl get_ip(const char *str, unsigned __int8 *ip_0)\n{\n  const char *v2; // rax\n  unsigned int tmp[4]; // [rsp+10h] [rbp-20h]\n  int c; // [rsp+24h] [rbp-Ch]\n  int ok; // [rsp+28h] [rbp-8h]\n  int num; // [rsp+2Ch] [rbp-4h]\n\n  num = 0;\n  ok = 0;\n  tmp[3] = 0;\n  tmp[2] = 0;\n  tmp[1] = 0;\n  tmp[0] = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v2 = str++;\n      c = *v2;\n      if ( c <= 47 || c > 57 )\n        break;\n      ok = 1;\n      tmp[num] = 10 * tmp[num] + c - 48;\n      if ( tmp[num] > 0xFF )\n        return 0;\n    }\n    if ( c != 46 )\n      break;\n    if ( !ok )\n      return -1;\n    if ( num == 3 )\n      return 0;\n    ++num;\n    ok = 0;\n  }\n  if ( c || num != 3 || !ok )\n    return 0;\n  *ip_0 = tmp[0];\n  ip_0[1] = tmp[1];\n  ip_0[2] = tmp[2];\n  ip_0[3] = tmp[3];\n  return 1;\n}\n\n\n Revised code:\nstatic int get_ip(const char *str, unsigned char ip[4])\n{\n    unsigned int tmp[4];\n    int num = 0, c, ok = 0;\n\n    tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;\n\n    for (;;) {\n        c = *(str++);\n        if ((c >= '0') && (c <= '9')) {\n            ok = 1;\n            tmp[num] = tmp[num] * 10 + c - '0';\n            if (tmp[num] > 255)\n                return (0);\n        } else if (c == '.') {\n            if (!ok)\n                return (-1);\n            if (num == 3)\n                return (0);\n            num++;\n            ok = 0;\n        } else if (c == '\\0' && (num == 3) && ok)\n            break;\n        else\n            return (0);\n    }\n    ip[0] = tmp[0];\n    ip[1] = tmp[1];\n    ip[2] = tmp[2];\n    ip[3] = tmp[3];\n    return (1);\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl type_str(unsigned __int64 value, void *arg)\n{\n  unsigned __int64 types; // [rsp+18h] [rbp-8h]\n\n  types = *(_QWORD *)arg;\n  if ( (*(_QWORD *)arg & 2) != 0 && !is_printable(value) )\n    types &= ~2uLL;\n  if ( (types & 0x10) != 0 && value > 0x7F )\n    types &= ~0x10uLL;\n  if ( (types & 4) != 0 && value > 0xFF )\n    types &= ~4uLL;\n  if ( (types & 0x800) != 0 && value > 0xFFFF )\n    types &= ~0x800uLL;\n  if ( !types )\n    return -1;\n  *(_QWORD *)arg = types;\n  return 1;\n}\n\n\n Revised code:\nstatic int type_str(unsigned long value, void *arg)\n{\n    unsigned long types;\n    types = *((unsigned long *)arg);\n    if ((types & B_ASN1_PRINTABLESTRING) && !is_printable(value))\n        types &= ~B_ASN1_PRINTABLESTRING;\n    if ((types & B_ASN1_IA5STRING) && (value > 127))\n        types &= ~B_ASN1_IA5STRING;\n    if ((types & B_ASN1_T61STRING) && (value > 0xff))\n        types &= ~B_ASN1_T61STRING;\n    if ((types & B_ASN1_BMPSTRING) && (value > 0xffff))\n        types &= ~B_ASN1_BMPSTRING;\n    if (!types)\n        return -1;\n    *((unsigned long *)arg) = types;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_422B9A(_QWORD *a1)\n{\n  __int64 result; // rax\n  char *format; // [rsp+18h] [rbp-8h]\n\n  format = \"%s\";\n  do\n  {\n    printf(format, *a1);\n    format = \" %s\";\n    result = *++a1;\n  }\n  while ( *a1 );\n  return result;\n}\n",
        "output": "```c\nstatic void print_strings(const char **strings)\n{\n    const char *separator = \"\";\n    while (*strings) {\n        printf(\"%s%s\", separator, *strings++);\n        separator = \" \";\n    }\n}\n```",
        "source_code": "static void printargv(char *const *argv)\n{\n\tconst char *fmt = \" %s\" + 1;\n\tdo {\n\t\tprintf(fmt, *argv);\n\t\tfmt = \" %s\";\n\t} while (*++argv);\n}",
        "parsed_output": "static void print_strings(const char **strings)\n{\n    const char *separator = \"\";\n    while (*strings) {\n        printf(\"%s%s\", separator, *strings++);\n        separator = \" \";\n    }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_422B9A(_QWORD *a1)\n{\n  __int64 result; // rax\n  char *format; // [rsp+18h] [rbp-8h]\n\n  format = \"%s\";\n  do\n  {\n    printf(format, *a1);\n    format = \" %s\";\n    result = *++a1;\n  }\n  while ( *a1 );\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl printargv(char *const *argv)\n{\n  char *fmt; // [rsp+18h] [rbp-8h]\n\n  fmt = \"%s\";\n  do\n  {\n    printf(fmt, *argv);\n    fmt = \" %s\";\n    ++argv;\n  }\n  while ( *argv );\n}\n",
        "similarity_score_unixcoder": 0.8100765943527222,
        "similarity_score_baseline_stripped": 0.5717563629150391,
        "similarity_score_baseline_debug": 0.7810306549072266
    },
    {
        "func_name": "get_devname_from_label",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl OPENSSL_memcmp(const void *v1, const void *v2, size_t n)\n{\n  int ret; // [rsp+24h] [rbp-14h]\n\n  ret = 0;\n  while ( n )\n  {\n    ret = *(unsigned __int8 *)v1 - *(unsigned __int8 *)v2;\n    if ( ret )\n      break;\n    --n;\n    v1 = (char *)v1 + 1;\n    v2 = (char *)v2 + 1;\n  }\n  return ret;\n}\n\n\n Revised code:\nint OPENSSL_memcmp(const void *v1, const void *v2, size_t n)\n{\n    const unsigned char *c1 = v1, *c2 = v2;\n    int ret = 0;\n\n    while (n && (ret = *c1 - *c2) == 0)\n        n--, c1++, c2++;\n\n    return ret;\n}\n\n## Example:\n\n Input code:\nint __cdecl get_ip(const char *str, unsigned __int8 *ip_0)\n{\n  const char *v2; // rax\n  unsigned int tmp[4]; // [rsp+10h] [rbp-20h]\n  int c; // [rsp+24h] [rbp-Ch]\n  int ok; // [rsp+28h] [rbp-8h]\n  int num; // [rsp+2Ch] [rbp-4h]\n\n  num = 0;\n  ok = 0;\n  tmp[3] = 0;\n  tmp[2] = 0;\n  tmp[1] = 0;\n  tmp[0] = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v2 = str++;\n      c = *v2;\n      if ( c <= 47 || c > 57 )\n        break;\n      ok = 1;\n      tmp[num] = 10 * tmp[num] + c - 48;\n      if ( tmp[num] > 0xFF )\n        return 0;\n    }\n    if ( c != 46 )\n      break;\n    if ( !ok )\n      return -1;\n    if ( num == 3 )\n      return 0;\n    ++num;\n    ok = 0;\n  }\n  if ( c || num != 3 || !ok )\n    return 0;\n  *ip_0 = tmp[0];\n  ip_0[1] = tmp[1];\n  ip_0[2] = tmp[2];\n  ip_0[3] = tmp[3];\n  return 1;\n}\n\n\n Revised code:\nstatic int get_ip(const char *str, unsigned char ip[4])\n{\n    unsigned int tmp[4];\n    int num = 0, c, ok = 0;\n\n    tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;\n\n    for (;;) {\n        c = *(str++);\n        if ((c >= '0') && (c <= '9')) {\n            ok = 1;\n            tmp[num] = tmp[num] * 10 + c - '0';\n            if (tmp[num] > 255)\n                return (0);\n        } else if (c == '.') {\n            if (!ok)\n                return (-1);\n            if (num == 3)\n                return (0);\n            num++;\n            ok = 0;\n        } else if (c == '\\0' && (num == 3) && ok)\n            break;\n        else\n            return (0);\n    }\n    ip[0] = tmp[0];\n    ip[1] = tmp[1];\n    ip[2] = tmp[2];\n    ip[3] = tmp[3];\n    return (1);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_4A5902(const char *a1)\n{\n  const char *v1; // rsi\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = sub_4A576C(1); i; i = *(_QWORD *)i )\n  {\n    if ( **(_BYTE **)(i + 16) )\n    {\n      v1 = *(const char **)(i + 16);\n      if ( !strcmp(a1, v1) )\n        return sub_40A11F(*(const char **)(i + 8), (__int64)v1);\n    }\n  }\n  return 0LL;\n}\n",
        "output": "```c\nchar *find_matching_entry(const char *target)\n{\n    __int64 entry_ptr;\n\n    for (entry_ptr = get_first_entry(1); entry_ptr; entry_ptr = *(_QWORD *)entry_ptr)\n    {\n        const char *entry_name = *(_BYTE **)(entry_ptr + 16);\n        if (*entry_name && !strcmp(target, entry_name))\n            return process_entry(*(_BYTE **)(entry_ptr + 8), entry_name);\n    }\n    return NULL;\n}\n```",
        "source_code": "char *get_devname_from_label(const char *spec)\n{\n\tstruct uuidCache_s *uc;\n\n\tuc = uuidcache_init(/*scan_devices:*/ 1);\n\twhile (uc) {\n\t\tif (uc->label[0] && strcmp(spec, uc->label) == 0) {\n\t\t\treturn xstrdup(uc->device);\n\t\t}\n\t\tuc = uc->next;\n\t}\n\treturn NULL;\n}",
        "parsed_output": "char *find_matching_entry(const char *target)\n{\n    __int64 entry_ptr;\n\n    for (entry_ptr = get_first_entry(1); entry_ptr; entry_ptr = *(_QWORD *)entry_ptr)\n    {\n        const char *entry_name = *(_BYTE **)(entry_ptr + 16);\n        if (*entry_name && !strcmp(target, entry_name))\n            return process_entry(*(_BYTE **)(entry_ptr + 8), entry_name);\n    }\n    return NULL;\n}",
        "baseline_code_stripped": "char *__fastcall sub_4A5902(const char *a1)\n{\n  const char *v1; // rsi\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = sub_4A576C(1); i; i = *(_QWORD *)i )\n  {\n    if ( **(_BYTE **)(i + 16) )\n    {\n      v1 = *(const char **)(i + 16);\n      if ( !strcmp(a1, v1) )\n        return sub_40A11F(*(const char **)(i + 8), (__int64)v1);\n    }\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "char *__cdecl get_devname_from_label(const char *spec)\n{\n  uuidCache_s *uc; // [rsp+18h] [rbp-8h]\n\n  for ( uc = uuidcache_init(1); uc; uc = uc->next )\n  {\n    if ( *uc->label && !strcmp(spec, uc->label) )\n      return xstrdup(uc->device);\n  }\n  return 0LL;\n}\n",
        "similarity_score_unixcoder": 0.5573486089706421,
        "similarity_score_baseline_stripped": 0.4242667555809021,
        "similarity_score_baseline_debug": 0.8769363760948181
    },
    {
        "func_name": "scan_tree",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl RC2_decrypt(unsigned __int64 *d, RC2_KEY *key)\n{\n  unsigned int v2; // r12d\n  unsigned int v3; // r14d\n  unsigned int v4; // ebx\n  unsigned int v5; // r13d\n  unsigned int *v6; // r15\n  unsigned int *v7; // rax\n  int v8; // eax\n  unsigned __int64 l; // [rsp+10h] [rbp-38h]\n  int n; // [rsp+18h] [rbp-30h]\n  int i; // [rsp+1Ch] [rbp-2Ch]\n\n  v2 = (unsigned __int16)*d;\n  v3 = *d >> 16;\n  l = d[1];\n  v4 = (unsigned __int16)l;\n  v5 = l >> 16;\n  n = 3;\n  i = 5;\n  v6 = &key->data[63];\n  while ( 1 )\n  {\n    do\n    {\n      v5 = (unsigned __int16)((((_WORD)v5 << 11) | (v5 >> 5)) - (v2 & ~(_WORD)v4) - (v4 & v3) - *v6);\n      LOWORD(v4) = (((_WORD)v4 << 13) | (v4 >> 3)) - (v5 & ~(_WORD)v3) - (v3 & v2) - *(v6 - 1);\n      v3 = (unsigned __int16)((((_WORD)v3 << 14) | (v3 >> 2)) - (v4 & ~(_WORD)v2) - (v2 & v5) - *(v6 - 2));\n      v7 = v6 - 3;\n      v6 -= 4;\n      LOWORD(v2) = (((_WORD)v2 << 15) | (v2 >> 1)) - (v3 & ~(_WORD)v5) - (v5 & v4) - *(_WORD *)v7;\n      --i;\n    }\n    while ( i );\n    if ( !--n )\n      break;\n    if ( n == 2 )\n      v8 = 6;\n    else\n      v8 = 5;\n    i = v8;\n    v5 = (unsigned __int16)(v5 - key->data[v4 & 0x3F]);\n    v4 = (unsigned __int16)(v4 - key->data[v3 & 0x3F]);\n    v3 = (unsigned __int16)(v3 - key->data[v2 & 0x3F]);\n    v2 = (unsigned __int16)(v2 - key->data[v5 & 0x3F]);\n  }\n  *d = (unsigned __int16)v2 | (unsigned __int64)(v3 << 16);\n  d[1] = (v5 << 16) | (unsigned __int64)(unsigned __int16)v4;\n}\n\n\n Revised code:\nvoid RC2_decrypt(unsigned long *d, RC2_KEY *key)\n{\n    int i, n;\n    register RC2_INT *p0, *p1;\n    register RC2_INT x0, x1, x2, x3, t;\n    unsigned long l;\n\n    l = d[0];\n    x0 = (RC2_INT) l & 0xffff;\n    x1 = (RC2_INT) (l >> 16L);\n    l = d[1];\n    x2 = (RC2_INT) l & 0xffff;\n    x3 = (RC2_INT) (l >> 16L);\n\n    n = 3;\n    i = 5;\n\n    p0 = &(key->data[63]);\n    p1 = &(key->data[0]);\n    for (;;) {\n        t = ((x3 << 11) | (x3 >> 5)) & 0xffff;\n        x3 = (t - (x0 & ~x2) - (x1 & x2) - *(p0--)) & 0xffff;\n        t = ((x2 << 13) | (x2 >> 3)) & 0xffff;\n        x2 = (t - (x3 & ~x1) - (x0 & x1) - *(p0--)) & 0xffff;\n        t = ((x1 << 14) | (x1 >> 2)) & 0xffff;\n        x1 = (t - (x2 & ~x0) - (x3 & x0) - *(p0--)) & 0xffff;\n        t = ((x0 << 15) | (x0 >> 1)) & 0xffff;\n        x0 = (t - (x1 & ~x3) - (x2 & x3) - *(p0--)) & 0xffff;\n\n        if (--i == 0) {\n            if (--n == 0)\n                break;\n            i = (n == 2) ? 6 : 5;\n\n            x3 = (x3 - p1[x2 & 0x3f]) & 0xffff;\n            x2 = (x2 - p1[x1 & 0x3f]) & 0xffff;\n            x1 = (x1 - p1[x0 & 0x3f]) & 0xffff;\n            x0 = (x0 - p1[x3 & 0x3f]) & 0xffff;\n        }\n    }\n\n    d[0] =\n        (unsigned long)(x0 & 0xffff) | ((unsigned long)(x1 & 0xffff) << 16L);\n    d[1] =\n        (unsigned long)(x2 & 0xffff) | ((unsigned long)(x3 & 0xffff) << 16L);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl private_RC4_set_key(RC4_KEY *key, int len, const unsigned __int8 *data)\n{\n  unsigned __int8 *v3; // r12\n  int v4; // ebx\n  int v5; // r13d\n  unsigned __int8 v6; // r14\n  int v7; // ebx\n  int v8; // r13d\n  unsigned __int8 v9; // r14\n  int v10; // ebx\n  int v11; // r13d\n  unsigned __int8 v12; // r14\n  int v13; // ebx\n  int v14; // r13d\n  unsigned __int8 v15; // r14\n  unsigned int i; // [rsp+24h] [rbp-24h]\n  unsigned int ia; // [rsp+24h] [rbp-24h]\n\n  v3 = key->data;\n  key->x = 0;\n  key->y = 0;\n  LOBYTE(v4) = 0;\n  v5 = 0;\n  for ( i = 0; i <= 0xFF; ++i )\n    v3[i] = i;\n  for ( ia = 0; ia <= 0xFF; ia += 4 )\n  {\n    v6 = v3[ia];\n    v7 = (unsigned __int8)(v4 + data[v5] + v6);\n    v8 = v5 + 1;\n    if ( v8 == len )\n      v8 = 0;\n    v3[ia] = v3[v7];\n    v3[v7] = v6;\n    v9 = v3[ia + 1];\n    v10 = (unsigned __int8)(v7 + data[v8] + v9);\n    v11 = v8 + 1;\n    if ( v11 == len )\n      v11 = 0;\n    v3[ia + 1] = v3[v10];\n    v3[v10] = v9;\n    v12 = v3[ia + 2];\n    v13 = (unsigned __int8)(v10 + data[v11] + v12);\n    v14 = v11 + 1;\n    if ( v14 == len )\n      v14 = 0;\n    v3[ia + 2] = v3[v13];\n    v3[v13] = v12;\n    v15 = v3[ia + 3];\n    v4 = (unsigned __int8)(v13 + data[v14] + v15);\n    v5 = v14 + 1;\n    if ( v5 == len )\n      v5 = 0;\n    v3[ia + 3] = v3[v4];\n    v3[v4] = v15;\n  }\n}\n\n\n Revised code:\nvoid private_RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)\n{\n    register RC4_INT tmp;\n    register int id1, id2;\n    register RC4_INT *d;\n    unsigned int i;\n\n    d = &(key->data[0]);\n    key->x = 0;\n    key->y = 0;\n    id1 = id2 = 0;\n\n#define SK_LOOP(d,n) { \\\n                tmp=d[(n)]; \\\n                id2 = (data[id1] + tmp + id2) & 0xff; \\\n                if (++id1 == len) id1=0; \\\n                d[(n)]=d[id2]; \\\n                d[id2]=tmp; }\n\n    for (i = 0; i < 256; i++)\n        d[i] = i;\n    for (i = 0; i < 256; i += 4) {\n        SK_LOOP(d, i + 0);\n        SK_LOOP(d, i + 1);\n        SK_LOOP(d, i + 2);\n        SK_LOOP(d, i + 3);\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4AFD56(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+10h] [rbp-1Ch]\n  int v4; // [rsp+14h] [rbp-18h]\n  int v5; // [rsp+18h] [rbp-14h]\n  int v6; // [rsp+1Ch] [rbp-10h]\n  int v7; // [rsp+20h] [rbp-Ch]\n  int v8; // [rsp+24h] [rbp-8h]\n  unsigned int i; // [rsp+28h] [rbp-4h]\n\n  v8 = -1;\n  v7 = *(unsigned __int16 *)(a1 + 2);\n  v6 = 0;\n  v5 = 7;\n  v4 = 4;\n  if ( !*(_WORD *)(a1 + 2) )\n  {\n    v5 = 138;\n    v4 = 3;\n  }\n  *(_WORD *)(4 * (a2 + 1LL) + a1 + 2) = -1;\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i > a2 )\n      break;\n    v3 = v7;\n    v7 = *(unsigned __int16 *)(4 * ((int)i + 1LL) + a1 + 2);\n    if ( ++v6 >= v5 || v3 != v7 )\n    {\n      if ( v6 >= v4 )\n      {\n        if ( v3 )\n        {\n          if ( v3 != v8 )\n            ++*((_WORD *)qword_75D408 + 2 * v3 + 2482);\n          ++*((_WORD *)qword_75D408 + 2514);\n        }\n        else if ( v6 > 10 )\n        {\n          ++*((_WORD *)qword_75D408 + 2518);\n        }\n        else\n        {\n          ++*((_WORD *)qword_75D408 + 2516);\n        }\n      }\n      else\n      {\n        *((_WORD *)qword_75D408 + 2 * v3 + 2482) += v6;\n      }\n      v6 = 0;\n      v8 = v3;\n      v5 = 7;\n      v4 = 4;\n      if ( v7 )\n      {\n        if ( v3 == v7 )\n        {\n          v5 = 6;\n          v4 = 3;\n        }\n      }\n      else\n      {\n        v5 = 138;\n        v4 = 3;\n      }\n    }\n  }\n  return result;\n}\n",
        "output": "int process_data(int a1, int a2)\n{\n    int result;\n    int current_value, previous_value;\n    int repeat_count;\n    int base_run_length, extended_run_length;\n    int base_threshold, extended_threshold;\n    unsigned int i;\n\n    base_threshold = -1;\n    previous_value = *(unsigned short *)(a1 + 2);\n    repeat_count = 0;\n    base_run_length = 7;\n    extended_run_length = 4;\n    if (!*(unsigned short *)(a1 + 2))\n    {\n        base_run_length = 138;\n        extended_run_length = 3;\n    }\n    *(unsigned short *)(4 * (a2 + 1) + a1 + 2) = -1;\n    for (i = 0; i <= a2; ++i)\n    {\n        current_value = *(unsigned short *)(4 * (i + 1) + a1 + 2);\n        if (++repeat_count >= base_run_length || previous_value != current_value)\n        {\n            if (repeat_count >= extended_run_length)\n            {\n                if (previous_value)\n                {\n                    if (previous_value != base_threshold)\n                        ++*((unsigned short *)global_array + 2 * previous_value + 2482);\n                    ++*((unsigned short *)global_array + 2514);\n                }\n                else if (repeat_count > 10)\n                {\n                    ++*((unsigned short *)global_array + 2518);\n                }\n                else\n                {\n                    ++*((unsigned short *)global_array + 2516);\n                }\n            }\n            else\n            {\n                *((unsigned short *)global_array + 2 * previous_value + 2482) += repeat_count;\n            }\n            repeat_count = 0;\n            base_threshold = previous_value;\n            base_run_length = 7;\n            extended_run_length = 4;\n            if (current_value)\n            {\n                if (previous_value == current_value)\n                {\n                    base_run_length = 6;\n                    extended_run_length = 3;\n                }\n            }\n            else\n            {\n                base_run_length = 138;\n                extended_run_length = 3;\n            }\n        }\n        previous_value = current_value;\n    }\n    result = i;\n    return result;\n}",
        "source_code": "static void scan_tree(ct_data * tree, int max_code)\n{\n\tint n;\t\t\t\t/* iterates over all tree elements */\n\tint prevlen = -1;\t/* last emitted length */\n\tint curlen;\t\t\t/* length of current code */\n\tint nextlen = tree[0].Len;\t/* length of next code */\n\tint count = 0;\t\t/* repeat count of the current code */\n\tint max_count = 7;\t/* max repeat count */\n\tint min_count = 4;\t/* min repeat count */\n\n\tif (nextlen == 0) {\n\t\tmax_count = 138;\n\t\tmin_count = 3;\n\t}\n\ttree[max_code + 1].Len = 0xffff; /* guard */\n\n\tfor (n = 0; n <= max_code; n++) {\n\t\tcurlen = nextlen;\n\t\tnextlen = tree[n + 1].Len;\n\t\tif (++count < max_count && curlen == nextlen)\n\t\t\tcontinue;\n\n\t\tif (count < min_count) {\n\t\t\tG2.bl_tree[curlen].Freq += count;\n\t\t} else if (curlen != 0) {\n\t\t\tif (curlen != prevlen)\n\t\t\t\tG2.bl_tree[curlen].Freq++;\n\t\t\tG2.bl_tree[REP_3_6].Freq++;\n\t\t} else if (count <= 10) {\n\t\t\tG2.bl_tree[REPZ_3_10].Freq++;\n\t\t} else {\n\t\t\tG2.bl_tree[REPZ_11_138].Freq++;\n\t\t}\n\t\tcount = 0;\n\t\tprevlen = curlen;\n\n\t\tmax_count = 7;\n\t\tmin_count = 4;\n\t\tif (nextlen == 0) {\n\t\t\tmax_count = 138;\n\t\t\tmin_count = 3;\n\t\t} else if (curlen == nextlen) {\n\t\t\tmax_count = 6;\n\t\t\tmin_count = 3;\n\t\t}\n\t}\n}",
        "parsed_output": "int process_data(int a1, int a2)\n{\n    int result;\n    int current_value, previous_value;\n    int repeat_count;\n    int base_run_length, extended_run_length;\n    int base_threshold, extended_threshold;\n    unsigned int i;\n\n    base_threshold = -1;\n    previous_value = *(unsigned short *)(a1 + 2);\n    repeat_count = 0;\n    base_run_length = 7;\n    extended_run_length = 4;\n    if (!*(unsigned short *)(a1 + 2))\n    {\n        base_run_length = 138;\n        extended_run_length = 3;\n    }\n    *(unsigned short *)(4 * (a2 + 1) + a1 + 2) = -1;\n    for (i = 0; i <= a2; ++i)\n    {\n        current_value = *(unsigned short *)(4 * (i + 1) + a1 + 2);\n        if (++repeat_count >= base_run_length || previous_value != current_value)\n        {\n            if (repeat_count >= extended_run_length)\n            {\n                if (previous_value)\n                {\n                    if (previous_value != base_threshold)\n                        ++*((unsigned short *)global_array + 2 * previous_value + 2482);\n                    ++*((unsigned short *)global_array + 2514);\n                }\n                else if (repeat_count > 10)\n                {\n                    ++*((unsigned short *)global_array + 2518);\n                }\n                else\n                {\n                    ++*((unsigned short *)global_array + 2516);\n                }\n            }\n            else\n            {\n                *((unsigned short *)global_array + 2 * previous_value + 2482) += repeat_count;\n            }\n            repeat_count = 0;\n            base_threshold = previous_value;\n            base_run_length = 7;\n            extended_run_length = 4;\n            if (current_value)\n            {\n                if (previous_value == current_value)\n                {\n                    base_run_length = 6;\n                    extended_run_length = 3;\n                }\n            }\n            else\n            {\n                base_run_length = 138;\n                extended_run_length = 3;\n            }\n        }\n        previous_value = current_value;\n    }\n    result = i;\n    return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4AFD56(__int64 a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+10h] [rbp-1Ch]\n  int v4; // [rsp+14h] [rbp-18h]\n  int v5; // [rsp+18h] [rbp-14h]\n  int v6; // [rsp+1Ch] [rbp-10h]\n  int v7; // [rsp+20h] [rbp-Ch]\n  int v8; // [rsp+24h] [rbp-8h]\n  unsigned int i; // [rsp+28h] [rbp-4h]\n\n  v8 = -1;\n  v7 = *(unsigned __int16 *)(a1 + 2);\n  v6 = 0;\n  v5 = 7;\n  v4 = 4;\n  if ( !*(_WORD *)(a1 + 2) )\n  {\n    v5 = 138;\n    v4 = 3;\n  }\n  *(_WORD *)(4 * (a2 + 1LL) + a1 + 2) = -1;\n  for ( i = 0; ; ++i )\n  {\n    result = i;\n    if ( (int)i > a2 )\n      break;\n    v3 = v7;\n    v7 = *(unsigned __int16 *)(4 * ((int)i + 1LL) + a1 + 2);\n    if ( ++v6 >= v5 || v3 != v7 )\n    {\n      if ( v6 >= v4 )\n      {\n        if ( v3 )\n        {\n          if ( v3 != v8 )\n            ++*((_WORD *)qword_75D408 + 2 * v3 + 2482);\n          ++*((_WORD *)qword_75D408 + 2514);\n        }\n        else if ( v6 > 10 )\n        {\n          ++*((_WORD *)qword_75D408 + 2518);\n        }\n        else\n        {\n          ++*((_WORD *)qword_75D408 + 2516);\n        }\n      }\n      else\n      {\n        *((_WORD *)qword_75D408 + 2 * v3 + 2482) += v6;\n      }\n      v6 = 0;\n      v8 = v3;\n      v5 = 7;\n      v4 = 4;\n      if ( v7 )\n      {\n        if ( v3 == v7 )\n        {\n          v5 = 6;\n          v4 = 3;\n        }\n      }\n      else\n      {\n        v5 = 138;\n        v4 = 3;\n      }\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl scan_tree(ct_data_0 *tree, int max_code)\n{\n  int curlen; // [rsp+10h] [rbp-1Ch]\n  int min_count; // [rsp+14h] [rbp-18h]\n  int max_count; // [rsp+18h] [rbp-14h]\n  int count; // [rsp+1Ch] [rbp-10h]\n  int nextlen; // [rsp+20h] [rbp-Ch]\n  int prevlen; // [rsp+24h] [rbp-8h]\n  int n; // [rsp+28h] [rbp-4h]\n\n  prevlen = -1;\n  nextlen = tree->dl.dad;\n  count = 0;\n  max_count = 7;\n  min_count = 4;\n  if ( !tree->dl.dad )\n  {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[max_code + 1].dl.dad = -1;\n  for ( n = 0; n <= max_code; ++n )\n  {\n    curlen = nextlen;\n    nextlen = tree[n + 1].dl.dad;\n    if ( ++count >= max_count || curlen != nextlen )\n    {\n      if ( count >= min_count )\n      {\n        if ( curlen )\n        {\n          if ( curlen != prevlen )\n            ++LOWORD(ptr_to_globals[17].speeds[curlen + 4]);\n          ++*(_WORD *)&ptr_to_globals[17].tty_attrs.c_cc[19];\n        }\n        else if ( count > 10 )\n        {\n          ++*(_WORD *)&ptr_to_globals[17].tty_attrs.c_cc[27];\n        }\n        else\n        {\n          ++*(_WORD *)&ptr_to_globals[17].tty_attrs.c_cc[23];\n        }\n      }\n      else\n      {\n        LOWORD(ptr_to_globals[17].speeds[curlen + 4]) += count;\n      }\n      count = 0;\n      prevlen = curlen;\n      max_count = 7;\n      min_count = 4;\n      if ( nextlen )\n      {\n        if ( curlen == nextlen )\n        {\n          max_count = 6;\n          min_count = 3;\n        }\n      }\n      else\n      {\n        max_count = 138;\n        min_count = 3;\n      }\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.5787101984024048,
        "similarity_score_baseline_stripped": 0.47005003690719604,
        "similarity_score_baseline_debug": 0.7451967000961304
    },
    {
        "func_name": "clrvar",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl make_kn(unsigned __int8 *k1_0, unsigned __int8 *l, int bl_0)\n{\n  unsigned __int8 v3; // dl\n  char v4; // al\n  int i; // [rsp+20h] [rbp-4h]\n\n  for ( i = 0; i < bl_0; ++i )\n  {\n    k1_0[i] = 2 * l[i];\n    if ( i < bl_0 - 1 && (l[i + 1] & 0x80u) != 0 )\n      k1_0[i] |= 1u;\n  }\n  if ( (*l & 0x80u) != 0 )\n  {\n    v3 = k1_0[bl_0 - 1];\n    if ( bl_0 == 16 )\n      v4 = -121;\n    else\n      v4 = 27;\n    k1_0[bl_0 - 1] = v3 ^ v4;\n  }\n}\n\n\n Revised code:\nstatic void make_kn(unsigned char *k1, unsigned char *l, int bl)\n{\n    int i;\n    /* Shift block to left, including carry */\n    for (i = 0; i < bl; i++) {\n        k1[i] = l[i] << 1;\n        if (i < bl - 1 && l[i + 1] & 0x80)\n            k1[i] |= 1;\n    }\n    /* If MSB set fixup with R */\n    if (l[0] & 0x80)\n        k1[bl - 1] ^= bl == 16 ? 0x87 : 0x1b;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint *__fastcall sub_4DC88C(int *a1)\n{\n  int v1; // eax\n\n  if ( (*a1 & 0x1000) == 0 )\n    free(*((void **)a1 + 2));\n  *a1 &= 0x6C02u;\n  v1 = *a1;\n  BYTE1(v1) = BYTE1(*a1) | 0x40;\n  *a1 = v1;\n  *((_QWORD *)a1 + 2) = 0LL;\n  return a1;\n}\n",
        "output": "```c\nstatic int *sub_4DC88C(int *a1)\n{\n    if ((*a1 & 0x1000) == 0)\n        free((void *)*(a1 + 2));\n    *a1 &= 0x6C02;\n    *a1 |= 0x4000;\n    *(a1 + 4) = 0; // Assuming sizeof(int) == 4 and hence a1 + 4 is equivalent to ((long long *)a1 + 2)\n    *(a1 + 5) = 0; // Clearing the upper 32 bits of the 64-bit value at a1 + 4\n    return a1;\n}\n```",
        "source_code": "static var *clrvar(var *v)\n{\n\tif (!(v->type & VF_FSTR))\n\t\tfree(v->string);\n\n\tv->type &= VF_DONTTOUCH;\n\tv->type |= VF_DIRTY;\n\tv->string = NULL;\n\treturn v;\n}",
        "parsed_output": "static int *sub_4DC88C(int *a1)\n{\n    if ((*a1 & 0x1000) == 0)\n        free((void *)*(a1 + 2));\n    *a1 &= 0x6C02;\n    *a1 |= 0x4000;\n    *(a1 + 4) = 0; // Assuming sizeof(int) == 4 and hence a1 + 4 is equivalent to ((long long *)a1 + 2)\n    *(a1 + 5) = 0; // Clearing the upper 32 bits of the 64-bit value at a1 + 4\n    return a1;\n}",
        "baseline_code_stripped": "int *__fastcall sub_4DC88C(int *a1)\n{\n  int v1; // eax\n\n  if ( (*a1 & 0x1000) == 0 )\n    free(*((void **)a1 + 2));\n  *a1 &= 0x6C02u;\n  v1 = *a1;\n  BYTE1(v1) = BYTE1(*a1) | 0x40;\n  *a1 = v1;\n  *((_QWORD *)a1 + 2) = 0LL;\n  return a1;\n}\n",
        "baseline_code_debug": "var_0 *__cdecl clrvar(var_0 *v)\n{\n  unsigned int type; // eax\n\n  if ( (v->type & 0x1000) == 0 )\n    free(v->string);\n  v->type &= 0x6C02u;\n  type = v->type;\n  BYTE1(type) = BYTE1(v->type) | 0x40;\n  v->type = type;\n  v->string = 0LL;\n  return v;\n}\n",
        "similarity_score_unixcoder": 0.4978790879249573,
        "similarity_score_baseline_stripped": 0.5142403841018677,
        "similarity_score_baseline_debug": 0.7837625741958618
    },
    {
        "func_name": "open_as_user",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nint BIO_printf(BIO *bio, const char *format, ...)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list args; // [rsp+10h] [rbp-D0h] BYREF\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(args, format);\n  v2 = va_arg(args, _QWORD);\n  v3 = va_arg(args, _QWORD);\n  v4 = va_arg(args, _QWORD);\n  v5 = va_arg(args, _QWORD);\n  v8 = v2;\n  v9 = v3;\n  v10 = v4;\n  v11 = v5;\n  args[0].gp_offset = 16;\n  return BIO_vprintf(bio, format, args);\n}\n\n\n Revised code:\nint BIO_printf(BIO *bio, const char *format, ...)\n{\n    va_list args;\n    int ret;\n\n    va_start(args, format);\n\n    ret = BIO_vprintf(bio, format, args);\n\n    va_end(args);\n    return (ret);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_415BB6(__int64 a1, const char *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  int v7; // eax\n  ssize_t v8; // rax\n  char v9; // [rsp+17h] [rbp-9h] BYREF\n  __pid_t v10; // [rsp+18h] [rbp-8h]\n  __pid_t v11; // [rsp+1Ch] [rbp-4h]\n\n  v11 = vfork();\n  if ( v11 < 0 )\n    sub_4092A2((__int64)\"vfork\", (__int64)a2, v2, v3, v4, v5);\n  v10 = v11;\n  if ( !v11 )\n  {\n    sub_4F6569(a1);\n    v7 = sub_40A295(a2, 0);\n    v8 = sub_40B3FF(v7, &v9, 1uLL);\n    _exit(v8 < 0);\n  }\n  if ( (unsigned int)sub_409FAE(v10) )\n    return -1;\n  else\n    return open64(a2, 0);\n}\n",
        "output": "```c\nint sub_415BB6(int filedes, const char *pathname)\n{\n    pid_t pid;\n    int status;\n    ssize_t num_read;\n    char buf;\n    int fd;\n\n    pid = vfork();\n    if (pid < 0) {\n        perror(\"vfork\");\n        return -1;\n    }\n\n    if (pid == 0) { // Child process\n        close(filedes);\n        fd = open(pathname, O_RDONLY);\n        num_read = read(fd, &buf, 1);\n        _exit(num_read < 0); // Exit with failure if read is unsuccessful\n    } else { // Parent process\n        if (waitpid(pid, &status, 0) == -1) {\n            return -1; // Wait for child process to finish\n        }\n        if (WIFEXITED(status) && WEXITSTATUS(status) != 0) {\n            return -1; // Child process failed\n        }\n        return open64(pathname, O_RDONLY); // Open the file in the parent process\n    }\n}\n```",
        "source_code": "static int open_as_user(const struct passwd *pas, const char *file)\n{\n\tpid_t pid;\n\tchar c;\n\n\tpid = xvfork();\n\tif (pid) { /* PARENT */\n\t\tif (wait4pid(pid) == 0) {\n\t\t\t/* exitcode 0: child says it can read */\n\t\t\treturn open(file, O_RDONLY);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* CHILD */\n\t/* initgroups, setgid, setuid */\n\tchange_identity(pas);\n\t/* We just try to read one byte. If it works, file is readable\n\t * under this user. We signal that by exiting with 0. */\n\t_exit(safe_read(xopen(file, O_RDONLY), &c, 1) < 0);\n}",
        "parsed_output": "int sub_415BB6(int filedes, const char *pathname)\n{\n    pid_t pid;\n    int status;\n    ssize_t num_read;\n    char buf;\n    int fd;\n\n    pid = vfork();\n    if (pid < 0) {\n        perror(\"vfork\");\n        return -1;\n    }\n\n    if (pid == 0) { // Child process\n        close(filedes);\n        fd = open(pathname, O_RDONLY);\n        num_read = read(fd, &buf, 1);\n        _exit(num_read < 0); // Exit with failure if read is unsuccessful\n    } else { // Parent process\n        if (waitpid(pid, &status, 0) == -1) {\n            return -1; // Wait for child process to finish\n        }\n        if (WIFEXITED(status) && WEXITSTATUS(status) != 0) {\n            return -1; // Child process failed\n        }\n        return open64(pathname, O_RDONLY); // Open the file in the parent process\n    }\n}",
        "baseline_code_stripped": "int __fastcall sub_415BB6(__int64 a1, const char *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  int v7; // eax\n  ssize_t v8; // rax\n  char v9; // [rsp+17h] [rbp-9h] BYREF\n  __pid_t v10; // [rsp+18h] [rbp-8h]\n  __pid_t v11; // [rsp+1Ch] [rbp-4h]\n\n  v11 = vfork();\n  if ( v11 < 0 )\n    sub_4092A2((__int64)\"vfork\", (__int64)a2, v2, v3, v4, v5);\n  v10 = v11;\n  if ( !v11 )\n  {\n    sub_4F6569(a1);\n    v7 = sub_40A295(a2, 0);\n    v8 = sub_40B3FF(v7, &v9, 1uLL);\n    _exit(v8 < 0);\n  }\n  if ( (unsigned int)sub_409FAE(v10) )\n    return -1;\n  else\n    return open64(a2, 0);\n}\n",
        "baseline_code_debug": "int __cdecl open_as_user(const passwd *pas, const char *file)\n{\n  int v3; // eax\n  ssize_t v4; // rax\n  char c; // [rsp+17h] [rbp-9h] BYREF\n  pid_t pid; // [rsp+18h] [rbp-8h]\n  pid_t bb__xvfork_pid; // [rsp+1Ch] [rbp-4h]\n\n  bb__xvfork_pid = vfork();\n  if ( bb__xvfork_pid < 0 )\n    bb_perror_msg_and_die(\"vfork\");\n  pid = bb__xvfork_pid;\n  if ( !bb__xvfork_pid )\n  {\n    change_identity(pas);\n    v3 = xopen(file, 0);\n    v4 = safe_read(v3, &c, 1uLL);\n    _exit(v4 < 0);\n  }\n  if ( wait4pid(pid) )\n    return -1;\n  else\n    return open64(file, 0);\n}\n",
        "similarity_score_unixcoder": 0.8132215738296509,
        "similarity_score_baseline_stripped": 0.6169637441635132,
        "similarity_score_baseline_debug": 0.8045257925987244
    },
    {
        "func_name": "full_read",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nunsigned __int64 __cdecl bn_sub_words(unsigned __int64 *r, const unsigned __int64 *a, const unsigned __int64 *b, int n)\n{\n  int na; // [rsp+0h] [rbp-3Ch]\n  unsigned __int64 t2; // [rsp+24h] [rbp-18h]\n  unsigned __int64 t2a; // [rsp+24h] [rbp-18h]\n  unsigned __int64 t2b; // [rsp+24h] [rbp-18h]\n  unsigned __int64 t2c; // [rsp+24h] [rbp-18h]\n  unsigned __int64 t2d; // [rsp+24h] [rbp-18h]\n  unsigned __int64 t1; // [rsp+2Ch] [rbp-10h]\n  unsigned __int64 t1a; // [rsp+2Ch] [rbp-10h]\n  unsigned __int64 t1b; // [rsp+2Ch] [rbp-10h]\n  unsigned __int64 t1c; // [rsp+2Ch] [rbp-10h]\n  unsigned __int64 t1d; // [rsp+2Ch] [rbp-10h]\n  int c; // [rsp+38h] [rbp-4h]\n\n  na = n;\n  c = 0;\n  if ( n <= 0 )\n    return 0LL;\n  while ( (na & 0xFFFFFFFC) != 0 )\n  {\n    t1 = *a;\n    t2 = *b;\n    *r = *a - *b - c;\n    if ( t1 != t2 )\n      c = t1 < t2;\n    t1a = a[1];\n    t2a = b[1];\n    r[1] = t1a - t2a - c;\n    if ( t1a != t2a )\n      c = t1a < t2a;\n    t1b = a[2];\n    t2b = b[2];\n    r[2] = t1b - t2b - c;\n    if ( t1b != t2b )\n      c = t1b < t2b;\n    t1c = a[3];\n    t2c = b[3];\n    r[3] = t1c - t2c - c;\n    if ( t1c != t2c )\n      c = t1c < t2c;\n    a += 4;\n    b += 4;\n    r += 4;\n    na -= 4;\n  }\n  while ( na )\n  {\n    t1d = *a;\n    t2d = *b;\n    *r = *a - *b - c;\n    if ( t1d != t2d )\n      c = t1d < t2d;\n    ++a;\n    ++b;\n    ++r;\n    --na;\n  }\n  return c;\n}\n\n\n Revised code:\nBN_ULONG bn_sub_words(BN_ULONG *r, const BN_ULONG *a, const BN_ULONG *b,\n                      int n)\n{\n    BN_ULONG t1, t2;\n    int c = 0;\n\n    assert(n >= 0);\n    if (n <= 0)\n        return ((BN_ULONG)0);\n\n#ifndef OPENSSL_SMALL_FOOTPRINT\n    while (n & ~3) {\n        t1 = a[0];\n        t2 = b[0];\n        r[0] = (t1 - t2 - c) & BN_MASK2;\n        if (t1 != t2)\n            c = (t1 < t2);\n        t1 = a[1];\n        t2 = b[1];\n        r[1] = (t1 - t2 - c) & BN_MASK2;\n        if (t1 != t2)\n            c = (t1 < t2);\n        t1 = a[2];\n        t2 = b[2];\n        r[2] = (t1 - t2 - c) & BN_MASK2;\n        if (t1 != t2)\n            c = (t1 < t2);\n        t1 = a[3];\n        t2 = b[3];\n        r[3] = (t1 - t2 - c) & BN_MASK2;\n        if (t1 != t2)\n            c = (t1 < t2);\n        a += 4;\n        b += 4;\n        r += 4;\n        n -= 4;\n    }\n#endif\n    while (n) {\n        t1 = a[0];\n        t2 = b[0];\n        r[0] = (t1 - t2 - c) & BN_MASK2;\n        if (t1 != t2)\n            c = (t1 < t2);\n        a++;\n        b++;\n        r++;\n        n--;\n    }\n    return (c);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl BUF_reverse(unsigned __int8 *out, const unsigned __int8 *in, size_t size)\n{\n  const unsigned __int8 *v3; // rdx\n  unsigned __int8 *v4; // rax\n  unsigned __int8 *v5; // rax\n  char *v6; // rax\n  const unsigned __int8 *ina; // [rsp+8h] [rbp-30h]\n  unsigned __int8 *outa; // [rsp+10h] [rbp-28h]\n  unsigned __int8 *outb; // [rsp+10h] [rbp-28h]\n  char c; // [rsp+27h] [rbp-11h]\n  unsigned __int8 *q; // [rsp+28h] [rbp-10h]\n  size_t i; // [rsp+30h] [rbp-8h]\n  size_t ia; // [rsp+30h] [rbp-8h]\n\n  outa = out;\n  ina = in;\n  if ( in )\n  {\n    outb = &out[size - 1];\n    for ( i = 0LL; i < size; ++i )\n    {\n      v3 = ina++;\n      v4 = outb--;\n      *v4 = *v3;\n    }\n  }\n  else\n  {\n    q = &out[size - 1];\n    for ( ia = 0LL; ia < size >> 1; ++ia )\n    {\n      c = *q;\n      v5 = q--;\n      *v5 = *outa;\n      v6 = (char *)outa++;\n      *v6 = c;\n    }\n  }\n}\n\n\n Revised code:\nvoid BUF_reverse(unsigned char *out, const unsigned char *in, size_t size)\n{\n    size_t i;\n    if (in) {\n        out += size - 1;\n        for (i = 0; i < size; i++)\n            *out-- = *in++;\n    } else {\n        unsigned char *q;\n        char c;\n        q = out + size - 1;\n        for (i = 0; i < size / 2; i++) {\n            c = *q;\n            *q-- = *out;\n            *out++ = c;\n        }\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nssize_t __fastcall sub_40B446(int a1, char *a2, size_t a3)\n{\n  ssize_t v6; // [rsp+20h] [rbp-10h]\n  __int64 v7; // [rsp+28h] [rbp-8h]\n\n  v7 = 0LL;\n  while ( 1 )\n  {\n    if ( !a3 )\n      return v7;\n    v6 = sub_40B3FF(a1, a2, a3);\n    if ( v6 < 0 )\n      break;\n    if ( !v6 )\n      return v7;\n    a2 += v6;\n    v7 += v6;\n    a3 -= v6;\n  }\n  if ( v7 )\n    return v7;\n  else\n    return v6;\n}\n",
        "output": "```c\nssize_t read_fully(int fd, char *buf, size_t count)\n{\n    ssize_t total_read = 0;\n    ssize_t bytes_read;\n\n    while (count > 0) {\n        bytes_read = read(fd, buf, count);\n        if (bytes_read < 0)\n            return (total_read > 0) ? total_read : bytes_read;\n        if (bytes_read == 0)\n            break;\n        buf += bytes_read;\n        total_read += bytes_read;\n        count -= bytes_read;\n    }\n\n    return total_read;\n}\n```",
        "source_code": "ssize_t FAST_FUNC full_read(int fd, void *buf, size_t len)\n{\n\tssize_t cc;\n\tssize_t total;\n\n\ttotal = 0;\n\n\twhile (len) {\n\t\tcc = safe_read(fd, buf, len);\n\n\t\tif (cc < 0) {\n\t\t\tif (total) {\n\t\t\t\t/* we already have some! */\n\t\t\t\t/* user can do another read to know the error code */\n\t\t\t\treturn total;\n\t\t\t}\n\t\t\treturn cc; /* read() returns -1 on failure. */\n\t\t}\n\t\tif (cc == 0)\n\t\t\tbreak;\n\t\tbuf = ((char *)buf) + cc;\n\t\ttotal += cc;\n\t\tlen -= cc;\n\t}\n\n\treturn total;\n}",
        "parsed_output": "ssize_t read_fully(int fd, char *buf, size_t count)\n{\n    ssize_t total_read = 0;\n    ssize_t bytes_read;\n\n    while (count > 0) {\n        bytes_read = read(fd, buf, count);\n        if (bytes_read < 0)\n            return (total_read > 0) ? total_read : bytes_read;\n        if (bytes_read == 0)\n            break;\n        buf += bytes_read;\n        total_read += bytes_read;\n        count -= bytes_read;\n    }\n\n    return total_read;\n}",
        "baseline_code_stripped": "ssize_t __fastcall sub_40B446(int a1, char *a2, size_t a3)\n{\n  ssize_t v6; // [rsp+20h] [rbp-10h]\n  __int64 v7; // [rsp+28h] [rbp-8h]\n\n  v7 = 0LL;\n  while ( 1 )\n  {\n    if ( !a3 )\n      return v7;\n    v6 = sub_40B3FF(a1, a2, a3);\n    if ( v6 < 0 )\n      break;\n    if ( !v6 )\n      return v7;\n    a2 += v6;\n    v7 += v6;\n    a3 -= v6;\n  }\n  if ( v7 )\n    return v7;\n  else\n    return v6;\n}\n",
        "baseline_code_debug": "ssize_t __cdecl full_read(int fd, void *buf, size_t len)\n{\n  __int64 cc; // [rsp+20h] [rbp-10h]\n  ssize_t total; // [rsp+28h] [rbp-8h]\n\n  total = 0LL;\n  while ( 1 )\n  {\n    if ( !len )\n      return total;\n    cc = safe_read(fd, buf, len);\n    if ( cc < 0 )\n      break;\n    if ( !cc )\n      return total;\n    buf = (char *)buf + cc;\n    total += cc;\n    len -= cc;\n  }\n  if ( total )\n    return total;\n  else\n    return cc;\n}\n",
        "similarity_score_unixcoder": 0.8575340509414673,
        "similarity_score_baseline_stripped": 0.5284274816513062,
        "similarity_score_baseline_debug": 0.860867977142334
    },
    {
        "func_name": "xsocket",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl BIO_socket_ioctl(int fd, __int64 type, void *arg)\n{\n  int *v3; // rax\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  i = ioctl(fd, type, arg);\n  if ( i < 0 )\n  {\n    v3 = __errno_location();\n    ERR_put_error(2, 5, *v3, \"b_sock.c\", 580);\n  }\n  return i;\n}\n\n\n Revised code:\n70000000\n\nint BIO_socket_ioctl(int fd, long type, void *arg)\n{\n    int i;\n\n#  ifdef __DJGPP__\n    i = ioctlsocket(fd, type, (char *)arg);\n#  else\n#   if defined(OPENSSL_SYS_VMS)\n    /*-\n     * 2011-02-18 SMS.\n     * VMS ioctl() can't tolerate a 64-bit \"void *arg\", but we\n     * observe that all the consumers pass in an \"unsigned long *\",\n     * so we arrange a local copy with a short pointer, and use\n     * that, instead.\n     */\n#    if __INITIAL_POINTER_SIZE == 64\n#     define ARG arg_32p\n#     pragma pointer_size save\n#     pragma pointer_size 32\n    unsigned long arg_32;\n    unsigned long *arg_32p;\n#     pragma pointer_size restore\n    arg_32p = &arg_32;\n    arg_32 = *((unsigned long *)arg);\n#    else                       /* __INITIAL_POINTER_SIZE == 64 */\n#     define ARG arg\n#    endif                      /* __INITIAL_POINTER_SIZE == 64 [else] */\n#   else                        /* defined(OPENSSL_SYS_VMS) */\n#    define ARG arg\n#   endif                       /* defined(OPENSSL_SYS_VMS) [else] */\n\n    i = ioctlsocket(fd, type, ARG);\n#  endif                        /* __DJGPP__ */\n    if (i < 0)\n        SYSerr(SYS_F_IOCTLSOCKET, get_last_socket_error());\n    return (i);\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\n__int64 __cdecl null_ctrl(BIO *b, int cmd, __int64 num, void *ptr)\n{\n  __int64 ret; // [rsp+28h] [rbp-8h]\n\n  switch ( cmd )\n  {\n    case 1:\n    case 2:\n    case 4:\n    case 9:\n    case 11:\n    case 12:\n      ret = 1LL;\n      break;\n    default:\n      ret = 0LL;\n      break;\n  }\n  return ret;\n}\n\n\n Revised code:\nstatic long null_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    long ret = 1;\n\n    switch (cmd) {\n    case BIO_CTRL_RESET:\n    case BIO_CTRL_EOF:\n    case BIO_CTRL_SET:\n    case BIO_CTRL_SET_CLOSE:\n    case BIO_CTRL_FLUSH:\n    case BIO_CTRL_DUP:\n        ret = 1;\n        break;\n    case BIO_CTRL_GET_CLOSE:\n    case BIO_CTRL_INFO:\n    case BIO_CTRL_GET:\n    case BIO_CTRL_PENDING:\n    case BIO_CTRL_WPENDING:\n    default:\n        ret = 0;\n        break;\n    }\n    return (ret);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40A999(int a1, unsigned int a2, int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v8; // [rsp+1Ch] [rbp-4h]\n\n  v8 = socket(a1, a2, a3);\n  if ( v8 < 0 )\n    sub_4092A2((__int64)\"socket\", a2, v3, v4, v5, v6);\n  return (unsigned int)v8;\n}\n",
        "output": "int create_socket(int domain, unsigned int type, int protocol)\n{\n    int sock_fd;\n\n    sock_fd = socket(domain, type, protocol);\n    if (sock_fd < 0)\n        report_error(\"socket\", type);\n    return sock_fd;\n}",
        "source_code": "int FAST_FUNC xsocket(int domain, int type, int protocol)\n{\n\tint r = socket(domain, type, protocol);\n\n\tif (r < 0) {\n\t\t/* Hijack vaguely related config option */\n#if ENABLE_VERBOSE_RESOLUTION_ERRORS\n\t\tconst char *s = \"INET\";\n# ifdef AF_PACKET\n\t\tif (domain == AF_PACKET) s = \"PACKET\";\n# endif\n# ifdef AF_NETLINK\n\t\tif (domain == AF_NETLINK) s = \"NETLINK\";\n# endif\nIF_FEATURE_IPV6(if (domain == AF_INET6) s = \"INET6\";)\n\t\tbb_perror_msg_and_die(\"socket(AF_%s,%d,%d)\", s, type, protocol);\n#else\n\t\tbb_perror_msg_and_die(\"socket\");\n#endif\n\t}\n\n\treturn r;\n}",
        "parsed_output": "int create_socket(int domain, unsigned int type, int protocol)\n{\n    int sock_fd;\n\n    sock_fd = socket(domain, type, protocol);\n    if (sock_fd < 0)\n        report_error(\"socket\", type);\n    return sock_fd;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40A999(int a1, unsigned int a2, int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  int v8; // [rsp+1Ch] [rbp-4h]\n\n  v8 = socket(a1, a2, a3);\n  if ( v8 < 0 )\n    sub_4092A2((__int64)\"socket\", a2, v3, v4, v5, v6);\n  return (unsigned int)v8;\n}\n",
        "baseline_code_debug": "int __cdecl xsocket(int domain, int type, int protocol)\n{\n  int r; // [rsp+1Ch] [rbp-4h]\n\n  r = socket(domain, type, protocol);\n  if ( r < 0 )\n    bb_perror_msg_and_die(\"socket\");\n  return r;\n}\n",
        "similarity_score_unixcoder": 0.8354623913764954,
        "similarity_score_baseline_stripped": 0.5743594169616699,
        "similarity_score_baseline_debug": 0.683788537979126
    },
    {
        "func_name": "write_table",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nunsigned int __cdecl inverse(unsigned int xin)\n{\n  __int64 t; // [rsp+Ch] [rbp-38h]\n  __int64 q; // [rsp+14h] [rbp-30h]\n  __int64 r; // [rsp+1Ch] [rbp-28h]\n  __int64 b2; // [rsp+24h] [rbp-20h]\n  __int64 b1; // [rsp+2Ch] [rbp-18h]\n  __int64 n2; // [rsp+34h] [rbp-10h]\n  __int64 n1; // [rsp+3Ch] [rbp-8h]\n\n  if ( xin )\n  {\n    n1 = 65537LL;\n    n2 = xin;\n    b2 = 1LL;\n    b1 = 0LL;\n    do\n    {\n      r = n1 % n2;\n      q = (n1 - n1 % n2) / n2;\n      if ( n1 % n2 )\n      {\n        n1 = n2;\n        n2 = r;\n        t = b2;\n        b2 = b1 - b2 * q;\n        b1 = t;\n      }\n      else\n      {\n        b2 += b2 < 0 ? 0x10001uLL : 0;\n      }\n    }\n    while ( r );\n  }\n  else\n  {\n    LODWORD(b2) = 0;\n  }\n  return b2;\n}\n\n\n Revised code:\nstatic IDEA_INT inverse(unsigned int xin)\n{\n    long n1, n2, q, r, b1, b2, t;\n\n    if (xin == 0)\n        b2 = 0;\n    else {\n        n1 = 0x10001;\n        n2 = xin;\n        b2 = 1;\n        b1 = 0;\n\n        do {\n            r = (n1 % n2);\n            q = (n1 - r) / n2;\n            if (r == 0) {\n                if (b2 < 0)\n                    b2 = 0x10001 + b2;\n            } else {\n                n1 = n2;\n                n2 = r;\n                t = b2;\n                b2 = b1 - q * b2;\n                b1 = t;\n            }\n        } while (r != 0);\n    }\n    return ((IDEA_INT) b2);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl longswap(void *_ptr, size_t len)\n{\n  unsigned __int8 c; // [rsp+1Fh] [rbp-11h]\n  unsigned __int8 ca; // [rsp+1Fh] [rbp-11h]\n  size_t i; // [rsp+28h] [rbp-8h]\n\n  for ( i = 0LL; i < len; i += 4LL )\n  {\n    c = *(_BYTE *)_ptr;\n    *(_BYTE *)_ptr = *((_BYTE *)_ptr + 3);\n    *((_BYTE *)_ptr + 3) = c;\n    ca = *((_BYTE *)_ptr + 1);\n    *((_BYTE *)_ptr + 1) = *((_BYTE *)_ptr + 2);\n    *((_BYTE *)_ptr + 2) = ca;\n  }\n}\n\n\n Revised code:\nstatic void longswap(void *_ptr, size_t len)\n{\n    const union {\n        long one;\n        char little;\n    } is_endian = {\n        1\n    };\n\n    if (is_endian.little) {\n        size_t i;\n        unsigned char *p = _ptr, c;\n\n        for (i = 0; i < len; i += 4) {\n            c = p[0], p[0] = p[3], p[3] = c;\n            c = p[1], p[1] = p[2], p[2] = c;\n        }\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_494DF3()\n{\n  __int64 v0; // rcx\n  __int64 v1; // r8\n  __int64 v2; // r9\n  char *v4; // [rsp+0h] [rbp-10h]\n  int i; // [rsp+Ch] [rbp-4h]\n  int j; // [rsp+Ch] [rbp-4h]\n\n  if ( !*((_BYTE *)qword_75D408 + 48) )\n  {\n    for ( i = 0; i <= 2; ++i )\n    {\n      if ( *((_BYTE *)qword_75D408 + 40 * i + 2536) )\n        *((_BYTE *)qword_75D408 + 2656) = 1;\n    }\n    for ( j = 3; j < *((_DWORD *)qword_75D408 + 4); ++j )\n    {\n      v4 = (char *)qword_75D408 + 40 * j + 2504;\n      if ( *((_BYTE *)qword_75D408 + 40 * j + 2536) )\n      {\n        sub_490756(*((_QWORD *)qword_75D408 + 5 * j + 316));\n        sub_490876(*((_DWORD *)v4 + 4), *((_QWORD *)v4 + 3), *((_QWORD *)v4 + 3), v0, v1, v2);\n      }\n    }\n  }\n  puts(\"The partition table has been altered.\");\n  return sub_494D94(1);\n}\n",
        "output": "```c\nstatic __int64 update_partition_table()\n{\n    int i, j;\n    char *entry;\n    __int64 result;\n\n    if (!partition_table_modified)\n    {\n        // Check first three entries for changes\n        for (i = 0; i <= 2; ++i)\n        {\n            if (partition_entries[i].changed)\n                partition_table_changed_flag = 1;\n        }\n\n        // Check remaining entries for changes\n        for (j = 3; j < total_partition_entries; ++j)\n        {\n            entry = &partition_entries[j];\n            if (entry->changed)\n            {\n                process_partition_entry(entry->data);\n                update_partition_entry(entry->param1, entry->param2, entry->param3);\n            }\n        }\n    }\n\n    puts(\"The partition table has been altered.\");\n    result = finalize_partition_changes(1);\n    return result;\n}\n```",
        "source_code": "static void\nwrite_table(void)\n{\n\tint i;\n\n\tif (LABEL_IS_DOS) {\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tif (ptes[i].changed)\n\t\t\t\tptes[3].changed = 1;\n\t\tfor (i = 3; i < g_partitions; i++) {\n\t\t\tstruct pte *pe = &ptes[i];\n\t\t\tif (pe->changed) {\n\t\t\t\twrite_part_table_flag(pe->sectorbuffer);\n\t\t\t\twrite_sector(pe->offset_from_dev_start, pe->sectorbuffer);\n\t\t\t}\n\t\t}\n\t}\n\telse if (LABEL_IS_SGI) {\n\t\t/* no test on change? the printf below might be mistaken */\n\t\tsgi_write_table();\n\t}\n\telse if (LABEL_IS_SUN) {\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (ptes[i].changed) {\n\t\t\t\tsun_write_table();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"The partition table has been altered.\\n\");\n\treread_partition_table(1);\n}",
        "parsed_output": "static __int64 update_partition_table()\n{\n    int i, j;\n    char *entry;\n    __int64 result;\n\n    if (!partition_table_modified)\n    {\n        // Check first three entries for changes\n        for (i = 0; i <= 2; ++i)\n        {\n            if (partition_entries[i].changed)\n                partition_table_changed_flag = 1;\n        }\n\n        // Check remaining entries for changes\n        for (j = 3; j < total_partition_entries; ++j)\n        {\n            entry = &partition_entries[j];\n            if (entry->changed)\n            {\n                process_partition_entry(entry->data);\n                update_partition_entry(entry->param1, entry->param2, entry->param3);\n            }\n        }\n    }\n\n    puts(\"The partition table has been altered.\");\n    result = finalize_partition_changes(1);\n    return result;\n}",
        "baseline_code_stripped": "__int64 sub_494DF3()\n{\n  __int64 v0; // rcx\n  __int64 v1; // r8\n  __int64 v2; // r9\n  char *v4; // [rsp+0h] [rbp-10h]\n  int i; // [rsp+Ch] [rbp-4h]\n  int j; // [rsp+Ch] [rbp-4h]\n\n  if ( !*((_BYTE *)qword_75D408 + 48) )\n  {\n    for ( i = 0; i <= 2; ++i )\n    {\n      if ( *((_BYTE *)qword_75D408 + 40 * i + 2536) )\n        *((_BYTE *)qword_75D408 + 2656) = 1;\n    }\n    for ( j = 3; j < *((_DWORD *)qword_75D408 + 4); ++j )\n    {\n      v4 = (char *)qword_75D408 + 40 * j + 2504;\n      if ( *((_BYTE *)qword_75D408 + 40 * j + 2536) )\n      {\n        sub_490756(*((_QWORD *)qword_75D408 + 5 * j + 316));\n        sub_490876(*((_DWORD *)v4 + 4), *((_QWORD *)v4 + 3), *((_QWORD *)v4 + 3), v0, v1, v2);\n      }\n    }\n  }\n  puts(\"The partition table has been altered.\");\n  return sub_494D94(1);\n}\n",
        "baseline_code_debug": "void __cdecl write_table()\n{\n  pte *pe; // [rsp+0h] [rbp-10h]\n  int i; // [rsp+Ch] [rbp-4h]\n  int ia; // [rsp+Ch] [rbp-4h]\n\n  if ( !LOBYTE(ptr_to_globals->numspeed) )\n  {\n    for ( i = 0; i <= 2; ++i )\n    {\n      if ( ptr_to_globals[8].line_buf[40 * i + 76] )\n        LOBYTE(ptr_to_globals[9].speeds[3]) = 1;\n    }\n    for ( ia = 3; ia < SLODWORD(ptr_to_globals->fakehost); ++ia )\n    {\n      pe = (pte *)&ptr_to_globals[8].line_buf[40 * ia + 44];\n      if ( ptr_to_globals[8].line_buf[40 * ia + 76] )\n      {\n        write_part_table_flag(*(char **)&ptr_to_globals[8].line_buf[40 * ia + 68]);\n        write_sector(pe->offset_from_dev_start, pe->sectorbuffer);\n      }\n    }\n  }\n  puts(\"The partition table has been altered.\");\n  reread_partition_table(1);\n}\n",
        "similarity_score_unixcoder": 0.6836745738983154,
        "similarity_score_baseline_stripped": 0.5433832406997681,
        "similarity_score_baseline_debug": 0.7738335132598877
    },
    {
        "func_name": "iamarray",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl ctr64_inc(unsigned __int8 *counter)\n{\n  unsigned __int8 *countera; // [rsp+0h] [rbp-18h]\n  u8 c; // [rsp+13h] [rbp-5h]\n  unsigned int n; // [rsp+14h] [rbp-4h]\n\n  n = 8;\n  countera = counter + 8;\n  do\n  {\n    c = countera[--n] + 1;\n    countera[n] = c;\n  }\n  while ( !c && n );\n}\n\n\n Revised code:\nstatic void ctr64_inc(unsigned char *counter)\n{\n    int n = 8;\n    unsigned char c;\n\n    do {\n        --n;\n        c = counter[n];\n        ++c;\n        counter[n] = c;\n        if (c)\n            return;\n    } while (n);\n}\n\n## Example:\n\n Input code:\nunsigned int __cdecl inverse(unsigned int xin)\n{\n  __int64 t; // [rsp+Ch] [rbp-38h]\n  __int64 q; // [rsp+14h] [rbp-30h]\n  __int64 r; // [rsp+1Ch] [rbp-28h]\n  __int64 b2; // [rsp+24h] [rbp-20h]\n  __int64 b1; // [rsp+2Ch] [rbp-18h]\n  __int64 n2; // [rsp+34h] [rbp-10h]\n  __int64 n1; // [rsp+3Ch] [rbp-8h]\n\n  if ( xin )\n  {\n    n1 = 65537LL;\n    n2 = xin;\n    b2 = 1LL;\n    b1 = 0LL;\n    do\n    {\n      r = n1 % n2;\n      q = (n1 - n1 % n2) / n2;\n      if ( n1 % n2 )\n      {\n        n1 = n2;\n        n2 = r;\n        t = b2;\n        b2 = b1 - b2 * q;\n        b1 = t;\n      }\n      else\n      {\n        b2 += b2 < 0 ? 0x10001uLL : 0;\n      }\n    }\n    while ( r );\n  }\n  else\n  {\n    LODWORD(b2) = 0;\n  }\n  return b2;\n}\n\n\n Revised code:\nstatic IDEA_INT inverse(unsigned int xin)\n{\n    long n1, n2, q, r, b1, b2, t;\n\n    if (xin == 0)\n        b2 = 0;\n    else {\n        n1 = 0x10001;\n        n2 = xin;\n        b2 = 1;\n        b1 = 0;\n\n        do {\n            r = (n1 % n2);\n            q = (n1 - r) / n2;\n            if (r == 0) {\n                if (b2 < 0)\n                    b2 = 0x10001 + b2;\n            } else {\n                n1 = n2;\n                n2 = r;\n                t = b2;\n                b2 = b1 - q * b2;\n                b1 = t;\n            }\n        } while (r != 0);\n    }\n    return ((IDEA_INT) b2);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4DC779(__int64 a1, __int64 a2)\n{\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = a1; (*(_DWORD *)i & 0x2000) != 0; i = *(_QWORD *)(i + 24) )\n    ;\n  if ( (*(_DWORD *)i & 2) == 0 )\n  {\n    *(_DWORD *)i |= 2u;\n    *(_QWORD *)(i + 24) = sub_4DC126(a1, a2);\n  }\n  return *(_QWORD *)(i + 24);\n}\n",
        "output": "```c\nstatic long sub_4DC779(long a1, long a2)\n{\n    long i;\n\n    for (i = a1; (*(int *)i & 0x2000) != 0; i = *(long *)(i + 24))\n        ;\n    if ((*(int *)i & 2) == 0)\n    {\n        *(int *)i |= 2;\n        *(long *)(i + 24) = sub_4DC126(a1, a2);\n    }\n    return *(long *)(i + 24);\n}\n```",
        "source_code": "static xhash *iamarray(var *v)\n{\n\tvar *a = v;\n\n\twhile (a->type & VF_CHILD)\n\t\ta = a->x.parent;\n\n\tif (!(a->type & VF_ARRAY)) {\n\t\ta->type |= VF_ARRAY;\n\t\ta->x.array = hash_init();\n\t}\n\treturn a->x.array;\n}",
        "parsed_output": "static long sub_4DC779(long a1, long a2)\n{\n    long i;\n\n    for (i = a1; (*(int *)i & 0x2000) != 0; i = *(long *)(i + 24))\n        ;\n    if ((*(int *)i & 2) == 0)\n    {\n        *(int *)i |= 2;\n        *(long *)(i + 24) = sub_4DC126(a1, a2);\n    }\n    return *(long *)(i + 24);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4DC779(__int64 a1, __int64 a2)\n{\n  __int64 i; // [rsp+18h] [rbp-8h]\n\n  for ( i = a1; (*(_DWORD *)i & 0x2000) != 0; i = *(_QWORD *)(i + 24) )\n    ;\n  if ( (*(_DWORD *)i & 2) == 0 )\n  {\n    *(_DWORD *)i |= 2u;\n    *(_QWORD *)(i + 24) = sub_4DC126(a1, a2);\n  }\n  return *(_QWORD *)(i + 24);\n}\n",
        "baseline_code_debug": "xhash *__cdecl iamarray(var_0 *v)\n{\n  while ( (v->type & 0x2000) != 0 )\n    v = v->x.parent;\n  if ( (v->type & 2) == 0 )\n  {\n    v->type |= 2u;\n    v->x.array = hash_init();\n  }\n  return v->x.array;\n}\n",
        "similarity_score_unixcoder": 0.5158799290657043,
        "similarity_score_baseline_stripped": 0.4438897967338562,
        "similarity_score_baseline_debug": 0.806994616985321
    },
    {
        "func_name": "builtin_export",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl rinf_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg)\n{\n  int result; // eax\n  ASN1_VALUE *rinf; // [rsp+28h] [rbp-8h]\n\n  rinf = *pval;\n  result = 1;\n  if ( operation == 1 )\n  {\n    *((_QWORD *)rinf + 6) = sk_new_null();\n    if ( !*((_QWORD *)rinf + 6) )\n      return 0;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic int rinf_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\n                   void *exarg)\n{\n    X509_REQ_INFO *rinf = (X509_REQ_INFO *)*pval;\n\n    if (operation == ASN1_OP_NEW_POST) {\n        rinf->attributes = sk_X509_ATTRIBUTE_new_null();\n        if (!rinf->attributes)\n            return 0;\n    }\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n\n## Example:\n\n Input code:\nint __cdecl parse_http_line1(char *line)\n{\n  char *v2; // rax\n  size_t v3; // rax\n  char *r; // [rsp+10h] [rbp-20h] BYREF\n  int retcode; // [rsp+1Ch] [rbp-14h]\n  char *q; // [rsp+20h] [rbp-10h]\n  char *p; // [rsp+28h] [rbp-8h]\n\n  for ( p = line; *p && ((*__ctype_b_loc())[(unsigned __int8)*p] & 0x2000) == 0; ++p )\n    ;\n  if ( *p )\n  {\n    while ( *p && ((*__ctype_b_loc())[(unsigned __int8)*p] & 0x2000) != 0 )\n      ++p;\n    if ( *p )\n    {\n      for ( q = p; *q && ((*__ctype_b_loc())[(unsigned __int8)*q] & 0x2000) == 0; ++q )\n        ;\n      if ( *q )\n      {\n        v2 = q++;\n        *v2 = 0;\n        retcode = strtoul(p, &r, 10);\n        if ( *r )\n        {\n          return 0;\n        }\n        else\n        {\n          while ( *q && ((*__ctype_b_loc())[(unsigned __int8)*q] & 0x2000) != 0 )\n            ++q;\n          if ( *q )\n          {\n            v3 = strlen(q);\n            for ( r = &q[v3 - 1]; ((*__ctype_b_loc())[(unsigned __int8)*r] & 0x2000) != 0; --r )\n              *r = 0;\n          }\n          if ( retcode == 200 )\n          {\n            return 1;\n          }\n          else\n          {\n            ERR_put_error(39, 118, 114, \"ocsp_ht.c\", 250);\n            if ( *q )\n              ERR_add_error_data(4, \"Code=\", p, \",Reason=\", q);\n            else\n              ERR_add_error_data(2, \"Code=\", p);\n            return 0;\n          }\n        }\n      }\n      else\n      {\n        ERR_put_error(39, 118, 115, \"ocsp_ht.c\", 222);\n        return 0;\n      }\n    }\n    else\n    {\n      ERR_put_error(39, 118, 115, \"ocsp_ht.c\", 211);\n      return 0;\n    }\n  }\n  else\n  {\n    ERR_put_error(39, 118, 115, \"ocsp_ht.c\", 200);\n    return 0;\n  }\n}\n\n\n Revised code:\nstatic int parse_http_line1(char *line)\n{\n    int retcode;\n    char *p, *q, *r;\n    /* Skip to first white space (passed protocol info) */\n\n    for (p = line; *p && !isspace((unsigned char)*p); p++)\n        continue;\n    if (!*p) {\n        OCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_PARSE_ERROR);\n        return 0;\n    }\n\n    /* Skip past white space to start of response code */\n    while (*p && isspace((unsigned char)*p))\n        p++;\n\n    if (!*p) {\n        OCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_PARSE_ERROR);\n        return 0;\n    }\n\n    /* Find end of response code: first whitespace after start of code */\n    for (q = p; *q && !isspace((unsigned char)*q); q++)\n        continue;\n\n    if (!*q) {\n        OCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_PARSE_ERROR);\n        return 0;\n    }\n\n    /* Set end of response code and start of message */\n    *q++ = 0;\n\n    /* Attempt to parse numeric code */\n    retcode = strtoul(p, &r, 10);\n\n    if (*r)\n        return 0;\n\n    /* Skip over any leading white space in message */\n    while (*q && isspace((unsigned char)*q))\n        q++;\n\n    if (*q) {\n        /*\n         * Finally zap any trailing white space in message (include CRLF)\n         */\n\n        /* We know q has a non white space character so this is OK */\n        for (r = q + strlen(q) - 1; isspace((unsigned char)*r); r--)\n            *r = 0;\n    }\n    if (retcode != 200) {\n        OCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_ERROR);\n        if (!*q)\n            ERR_add_error_data(2, \"Code=\", p);\n        else\n            ERR_add_error_data(4, \"Code=\", p, \",Reason=\", q);\n        return 0;\n    }\n\n    return 1;\n\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_48953B(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  const char **v7; // rax\n  unsigned int v8; // ecx\n  const char **v9; // [rsp+8h] [rbp-28h]\n  char *v10; // [rsp+10h] [rbp-20h]\n  char *s; // [rsp+18h] [rbp-18h]\n  int v12; // [rsp+24h] [rbp-Ch]\n  const char **v13; // [rsp+28h] [rbp-8h]\n\n  v12 = sub_4FA1EF(a1, (unsigned int)\"!n\", a3, a4, a5, a6);\n  if ( v12 == -1 )\n    return 1LL;\n  v9 = (const char **)(8LL * optind + a1);\n  if ( *v9 )\n  {\n    if ( v12 )\n      v8 = -1;\n    else\n      v8 = 1;\n    sub_489420(v9, v8, 0);\n    return 0LL;\n  }\n  else\n  {\n    v13 = (const char **)environ;\n    if ( environ )\n    {\n      while ( *v13 )\n      {\n        v7 = v13++;\n        s = (char *)*v7;\n        v10 = strchr(*v7, 61);\n        if ( v10 )\n        {\n          printf(\"export %.*s\", (_DWORD)v10 - (_DWORD)s + 1, s);\n          sub_489379(v10 + 1);\n          putchar_unlocked(10);\n        }\n      }\n    }\n    return 0LL;\n  }\n}\n",
        "output": "```c\nint export_environment_variables(__int64 envp, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int parse_result;\n  const char **arg;\n  char *value;\n  char *env_entry;\n  int v12;\n  const char **env;\n\n  parse_result = parse_options(envp, (unsigned int)\"!n\", a3, a4, a5, a6);\n  if (parse_result == -1)\n    return 1;\n  arg = (const char **)(8LL * optind + envp);\n  if (*arg)\n  {\n    sub_489420(arg, parse_result ? -1 : 1, 0);\n    return 0;\n  }\n  else\n  {\n    env = (const char **)environ;\n    if (environ)\n    {\n      while (*env)\n      {\n        env_entry = (char *)*env;\n        value = strchr(*env, '=');\n        if (value)\n        {\n          printf(\"export %.*s\", (int)(value - env_entry + 1), env_entry);\n          sub_489379(value + 1);\n          putchar_unlocked('\\n');\n        }\n        env++;\n      }\n    }\n    return 0;\n  }\n}\n```",
        "source_code": "static int FAST_FUNC builtin_export(char **argv)\n{\n\tunsigned opt_unexport;\n\n#if ENABLE_HUSH_EXPORT_N\n\t/* \"!\": do not abort on errors */\n\topt_unexport = getopt32(argv, \"!n\");\n\tif (opt_unexport == (uint32_t)-1)\n\t\treturn EXIT_FAILURE;\n\targv += optind;\n#else\n\topt_unexport = 0;\n\targv++;\n#endif\n\n\tif (argv[0] == NULL) {\n\t\tchar **e = environ;\n\t\tif (e) {\n\t\t\twhile (*e) {\n#if 0\n\t\t\t\tputs(*e++);\n#else\n\t\t\t\t/* ash emits: export VAR='VAL'\n\t\t\t\t * bash: declare -x VAR=\"VAL\"\n\t\t\t\t * we follow ash example */\n\t\t\t\tconst char *s = *e++;\n\t\t\t\tconst char *p = strchr(s, '=');\n\n\t\t\t\tif (!p) /* wtf? take next variable */\n\t\t\t\t\tcontinue;\n\t\t\t\t/* export var= */\n\t\t\t\tprintf(\"export %.*s\", (int)(p - s) + 1, s);\n\t\t\t\tprint_escaped(p + 1);\n\t\t\t\tputchar('\\n');\n#endif\n\t\t\t}\n\t\t\t/*fflush_all(); - done after each builtin anyway */\n\t\t}\n\t\treturn EXIT_SUCCESS;\n\t}\n\n\thelper_export_local(argv, (opt_unexport ? -1 : 1), 0);\n\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "int export_environment_variables(__int64 envp, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int parse_result;\n  const char **arg;\n  char *value;\n  char *env_entry;\n  int v12;\n  const char **env;\n\n  parse_result = parse_options(envp, (unsigned int)\"!n\", a3, a4, a5, a6);\n  if (parse_result == -1)\n    return 1;\n  arg = (const char **)(8LL * optind + envp);\n  if (*arg)\n  {\n    sub_489420(arg, parse_result ? -1 : 1, 0);\n    return 0;\n  }\n  else\n  {\n    env = (const char **)environ;\n    if (environ)\n    {\n      while (*env)\n      {\n        env_entry = (char *)*env;\n        value = strchr(*env, '=');\n        if (value)\n        {\n          printf(\"export %.*s\", (int)(value - env_entry + 1), env_entry);\n          sub_489379(value + 1);\n          putchar_unlocked('\\n');\n        }\n        env++;\n      }\n    }\n    return 0;\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_48953B(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  const char **v7; // rax\n  unsigned int v8; // ecx\n  const char **v9; // [rsp+8h] [rbp-28h]\n  char *v10; // [rsp+10h] [rbp-20h]\n  char *s; // [rsp+18h] [rbp-18h]\n  int v12; // [rsp+24h] [rbp-Ch]\n  const char **v13; // [rsp+28h] [rbp-8h]\n\n  v12 = sub_4FA1EF(a1, (unsigned int)\"!n\", a3, a4, a5, a6);\n  if ( v12 == -1 )\n    return 1LL;\n  v9 = (const char **)(8LL * optind + a1);\n  if ( *v9 )\n  {\n    if ( v12 )\n      v8 = -1;\n    else\n      v8 = 1;\n    sub_489420(v9, v8, 0);\n    return 0LL;\n  }\n  else\n  {\n    v13 = (const char **)environ;\n    if ( environ )\n    {\n      while ( *v13 )\n      {\n        v7 = v13++;\n        s = (char *)*v7;\n        v10 = strchr(*v7, 61);\n        if ( v10 )\n        {\n          printf(\"export %.*s\", (_DWORD)v10 - (_DWORD)s + 1, s);\n          sub_489379(v10 + 1);\n          putchar_unlocked(10);\n        }\n      }\n    }\n    return 0LL;\n  }\n}\n",
        "baseline_code_debug": "int __cdecl builtin_export(char **argv)\n{\n  const char **v2; // rax\n  int v3; // ecx\n  char **argva; // [rsp+8h] [rbp-28h]\n  char *p; // [rsp+10h] [rbp-20h]\n  const char *s; // [rsp+18h] [rbp-18h]\n  unsigned int opt_unexport; // [rsp+24h] [rbp-Ch]\n  char **e; // [rsp+28h] [rbp-8h]\n\n  opt_unexport = getopt32(argv, \"!n\");\n  if ( opt_unexport == -1 )\n    return 1;\n  argva = &argv[optind];\n  if ( *argva )\n  {\n    if ( opt_unexport )\n      v3 = -1;\n    else\n      v3 = 1;\n    helper_export_local(argva, v3, 0);\n    return 0;\n  }\n  else\n  {\n    e = (char **)environ;\n    if ( environ )\n    {\n      while ( *e )\n      {\n        v2 = (const char **)e++;\n        s = *v2;\n        p = strchr(*v2, 61);\n        if ( p )\n        {\n          printf(\"export %.*s\", (_DWORD)p - (_DWORD)s + 1, s);\n          print_escaped(p + 1);\n          putchar_unlocked(10);\n        }\n      }\n    }\n    return 0;\n  }\n}\n",
        "similarity_score_unixcoder": 0.802021861076355,
        "similarity_score_baseline_stripped": 0.690185546875,
        "similarity_score_baseline_debug": 0.8295559287071228
    },
    {
        "func_name": "find_in_path",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl dlfcn_pathbyaddr(void *addr, char *path, int sz)\n{\n  int v4; // eax\n  char *v5; // rax\n  const void *addra; // [rsp+18h] [rbp-48h]\n  Dl_info dli; // [rsp+30h] [rbp-30h] BYREF\n  int len; // [rsp+5Ch] [rbp-4h]\n\n  addra = addr;\n  if ( !addr )\n    addra = dlfcn_pathbyaddr;\n  if ( dladdr(addra, &dli) )\n  {\n    len = strlen(dli.dli_fname);\n    if ( sz > 0 )\n    {\n      if ( len >= sz )\n        len = sz - 1;\n      memcpy(path, dli.dli_fname, len);\n      v4 = len++;\n      path[v4] = 0;\n      return len;\n    }\n    else\n    {\n      return len + 1;\n    }\n  }\n  else\n  {\n    v5 = dlerror();\n    ERR_add_error_data(4, \"dlfcn_pathbyaddr(): \", v5);\n    return -1;\n  }\n}\n\n\n Revised code:\nstatic int dlfcn_pathbyaddr(void *addr, char *path, int sz)\n{\n# ifdef HAVE_DLINFO\n    Dl_info dli;\n    int len;\n\n    if (addr == NULL) {\n        union {\n            int (*f) (void *, char *, int);\n            void *p;\n        } t = {\n            dlfcn_pathbyaddr\n        };\n        addr = t.p;\n    }\n\n    if (dladdr(addr, &dli)) {\n        len = (int)strlen(dli.dli_fname);\n        if (sz <= 0)\n            return len + 1;\n        if (len >= sz)\n            len = sz - 1;\n        memcpy(path, dli.dli_fname, len);\n        path[len++] = 0;\n        return len;\n    }\n\n    ERR_add_error_data(2, \"dlfcn_pathbyaddr(): \", dlerror());\n# endif\n    return -1;\n}\n\n## Example:\n\n Input code:\n__int64 __cdecl slg_ctrl(BIO *b, int cmd, __int64 num, void *ptr)\n{\n  int numa; // [rsp+8h] [rbp-18h]\n\n  numa = num;\n  if ( cmd == 4 )\n  {\n    xcloselog(b);\n    xopenlog(b, (char *)ptr, numa);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic long MS_CALLBACK slg_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    switch (cmd) {\n    case BIO_CTRL_SET:\n        xcloselog(b);\n        xopenlog(b, ptr, num);\n        break;\n    default:\n        break;\n    }\n    return (0);\n}\n\n## Example:\n\n Input code:\nint __cdecl get_ip(const char *str, unsigned __int8 *ip_0)\n{\n  const char *v2; // rax\n  unsigned int tmp[4]; // [rsp+10h] [rbp-20h]\n  int c; // [rsp+24h] [rbp-Ch]\n  int ok; // [rsp+28h] [rbp-8h]\n  int num; // [rsp+2Ch] [rbp-4h]\n\n  num = 0;\n  ok = 0;\n  tmp[3] = 0;\n  tmp[2] = 0;\n  tmp[1] = 0;\n  tmp[0] = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v2 = str++;\n      c = *v2;\n      if ( c <= 47 || c > 57 )\n        break;\n      ok = 1;\n      tmp[num] = 10 * tmp[num] + c - 48;\n      if ( tmp[num] > 0xFF )\n        return 0;\n    }\n    if ( c != 46 )\n      break;\n    if ( !ok )\n      return -1;\n    if ( num == 3 )\n      return 0;\n    ++num;\n    ok = 0;\n  }\n  if ( c || num != 3 || !ok )\n    return 0;\n  *ip_0 = tmp[0];\n  ip_0[1] = tmp[1];\n  ip_0[2] = tmp[2];\n  ip_0[3] = tmp[3];\n  return 1;\n}\n\n\n Revised code:\nstatic int get_ip(const char *str, unsigned char ip[4])\n{\n    unsigned int tmp[4];\n    int num = 0, c, ok = 0;\n\n    tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;\n\n    for (;;) {\n        c = *(str++);\n        if ((c >= '0') && (c <= '9')) {\n            ok = 1;\n            tmp[num] = tmp[num] * 10 + c - '0';\n            if (tmp[num] > 255)\n                return (0);\n        } else if (c == '.') {\n            if (!ok)\n                return (-1);\n            if (num == 3)\n                return (0);\n            num++;\n            ok = 0;\n        } else if (c == '\\0' && (num == 3) && ok)\n            break;\n        else\n            return (0);\n    }\n    ip[0] = tmp[0];\n    ip[1] = tmp[1];\n    ip[2] = tmp[2];\n    ip[3] = tmp[3];\n    return (1);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_486617(const char *a1)\n{\n  __int64 v2; // r8\n  __int64 v3; // r9\n  char *v4; // [rsp+18h] [rbp-18h]\n  const char *s; // [rsp+20h] [rbp-10h]\n  char *ptr; // [rsp+28h] [rbp-8h]\n\n  ptr = 0LL;\n  s = sub_4807EA(\"PATH\");\n  if ( !s )\n    return 0LL;\n  while ( 1 )\n  {\n    v4 = strchrnul(s, 58);\n    free(ptr);\n    ptr = (_DWORD)v4 == (_DWORD)s\n        ? sub_40A11F(a1, 58LL)\n        : sub_40A6B3(\"%.*s/%s\", (unsigned int)((_DWORD)v4 - (_DWORD)s), (__int64)s, (__int64)a1, v2, v3);\n    if ( !access(ptr, 0) )\n      break;\n    if ( !*v4 )\n    {\n      free(ptr);\n      return 0LL;\n    }\n    s = v4 + 1;\n  }\n  return ptr;\n}\n",
        "output": "```c\nchar *find_executable_in_path(const char *executable_name)\n{\n    const char *path_env;\n    char *path_segment;\n    char *full_path = NULL;\n    const char *current;\n\n    path_env = getenv(\"PATH\");\n    if (!path_env)\n        return NULL;\n\n    current = path_env;\n    while (1) {\n        path_segment = strchrnul(current, ':');\n        free(full_path);\n        if (*current == *path_segment) {\n            full_path = construct_path(executable_name, \":\");\n        } else {\n            int segment_length = path_segment - current;\n            full_path = construct_path_with_format(\"%.*s/%s\", segment_length, current, executable_name);\n        }\n        if (access(full_path, F_OK) == 0)\n            break;\n        if (*path_segment == '\\0') {\n            free(full_path);\n            return NULL;\n        }\n        current = path_segment + 1;\n    }\n    return full_path;\n}\n```",
        "source_code": "static char *find_in_path(const char *arg)\n{\n\tchar *ret = NULL;\n\tconst char *PATH = get_local_var_value(\"PATH\");\n\n\tif (!PATH)\n\t\treturn NULL;\n\n\twhile (1) {\n\t\tconst char *end = strchrnul(PATH, ':');\n\t\tint sz = end - PATH; /* must be int! */\n\n\t\tfree(ret);\n\t\tif (sz != 0) {\n\t\t\tret = xasprintf(\"%.*s/%s\", sz, PATH, arg);\n\t\t} else {\n\t\t\t/* We have xxx::yyyy in $PATH,\n\t\t\t * it means \"use current dir\" */\n\t\t\tret = xstrdup(arg);\n\t\t}\n\t\tif (access(ret, F_OK) == 0)\n\t\t\tbreak;\n\n\t\tif (*end == '\\0') {\n\t\t\tfree(ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tPATH = end + 1;\n\t}\n\n\treturn ret;\n}",
        "parsed_output": "char *find_executable_in_path(const char *executable_name)\n{\n    const char *path_env;\n    char *path_segment;\n    char *full_path = NULL;\n    const char *current;\n\n    path_env = getenv(\"PATH\");\n    if (!path_env)\n        return NULL;\n\n    current = path_env;\n    while (1) {\n        path_segment = strchrnul(current, ':');\n        free(full_path);\n        if (*current == *path_segment) {\n            full_path = construct_path(executable_name, \":\");\n        } else {\n            int segment_length = path_segment - current;\n            full_path = construct_path_with_format(\"%.*s/%s\", segment_length, current, executable_name);\n        }\n        if (access(full_path, F_OK) == 0)\n            break;\n        if (*path_segment == '\\0') {\n            free(full_path);\n            return NULL;\n        }\n        current = path_segment + 1;\n    }\n    return full_path;\n}",
        "baseline_code_stripped": "char *__fastcall sub_486617(const char *a1)\n{\n  __int64 v2; // r8\n  __int64 v3; // r9\n  char *v4; // [rsp+18h] [rbp-18h]\n  const char *s; // [rsp+20h] [rbp-10h]\n  char *ptr; // [rsp+28h] [rbp-8h]\n\n  ptr = 0LL;\n  s = sub_4807EA(\"PATH\");\n  if ( !s )\n    return 0LL;\n  while ( 1 )\n  {\n    v4 = strchrnul(s, 58);\n    free(ptr);\n    ptr = (_DWORD)v4 == (_DWORD)s\n        ? sub_40A11F(a1, 58LL)\n        : sub_40A6B3(\"%.*s/%s\", (unsigned int)((_DWORD)v4 - (_DWORD)s), (__int64)s, (__int64)a1, v2, v3);\n    if ( !access(ptr, 0) )\n      break;\n    if ( !*v4 )\n    {\n      free(ptr);\n      return 0LL;\n    }\n    s = v4 + 1;\n  }\n  return ptr;\n}\n",
        "baseline_code_debug": "char *__cdecl find_in_path(const char *arg)\n{\n  char *end; // [rsp+18h] [rbp-18h]\n  const char *PATH; // [rsp+20h] [rbp-10h]\n  char *ret; // [rsp+28h] [rbp-8h]\n\n  ret = 0LL;\n  PATH = get_local_var_value(\"PATH\");\n  if ( !PATH )\n    return 0LL;\n  while ( 1 )\n  {\n    end = strchrnul(PATH, 58);\n    free(ret);\n    ret = (_DWORD)end == (_DWORD)PATH ? xstrdup(arg) : xasprintf(\"%.*s/%s\", (int)end - (int)PATH, PATH, arg);\n    if ( !access(ret, 0) )\n      break;\n    if ( !*end )\n    {\n      free(ret);\n      return 0LL;\n    }\n    PATH = end + 1;\n  }\n  return ret;\n}\n",
        "similarity_score_unixcoder": 0.8004633188247681,
        "similarity_score_baseline_stripped": 0.6680409908294678,
        "similarity_score_baseline_debug": 0.8805899620056152
    },
    {
        "func_name": "end_cmd_q",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\ndouble __cdecl abs_val(double value)\n{\n  double result; // [rsp+10h] [rbp-8h]\n\n  result = value;\n  if ( value < 0.0 )\n    return -value;\n  return result;\n}\n\n\n Revised code:\nstatic LDOUBLE abs_val(LDOUBLE value)\n{\n    LDOUBLE result = value;\n    if (value < 0)\n        result = -value;\n    return result;\n}\n\n## Example:\n\n Input code:\n__int64 __cdecl roundv(double value)\n{\n  __int64 intpart; // [rsp+10h] [rbp-8h]\n\n  intpart = (unsigned int)(int)value;\n  if ( value - (double)(int)value >= 0.5 )\n    ++intpart;\n  return intpart;\n}\n\n\n Revised code:\nstatic long roundv(LDOUBLE value)\n{\n    long intpart;\n    intpart = (long)value;\n    value = value - intpart;\n    if (value >= 0.5)\n        intpart++;\n    return intpart;\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *sub_4EEE98()\n{\n  void *result; // rax\n\n  *((_DWORD *)qword_75D408 + 44) = 26;\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 118) = 0;\n  return result;\n}\n",
        "output": "```c\nstatic void *set_values()\n{\n    *((int *)qword_75D408 + 44) = 26;\n    *((char *)qword_75D408 + 118) = 0;\n    return qword_75D408;\n}\n```",
        "source_code": "static void end_cmd_q(void)\n{\n#if ENABLE_FEATURE_VI_YANKMARK\n\tYDreg = 26;\t\t\t// go back to default Yank/Delete reg\n#endif\n\tadding2q = 0;\n}",
        "parsed_output": "static void *set_values()\n{\n    *((int *)qword_75D408 + 44) = 26;\n    *((char *)qword_75D408 + 118) = 0;\n    return qword_75D408;\n}",
        "baseline_code_stripped": "void *sub_4EEE98()\n{\n  void *result; // rax\n\n  *((_DWORD *)qword_75D408 + 44) = 26;\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 118) = 0;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl end_cmd_q()\n{\n  *(_DWORD *)&ptr_to_globals->line_buf[20] = 26;\n  ptr_to_globals->tty_attrs.c_cc[5] = 0;\n}\n",
        "similarity_score_unixcoder": 0.5105148553848267,
        "similarity_score_baseline_stripped": 0.505116879940033,
        "similarity_score_baseline_debug": 0.5100896954536438
    },
    {
        "func_name": "format_header",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl print_bin(BIO *fp, const char *name, const unsigned __int8 *buf, size_t len, int off)\n{\n  const char *v6; // rax\n  int offa; // [rsp+Ch] [rbp-B4h]\n  char str[128]; // [rsp+30h] [rbp-90h] BYREF\n  size_t i; // [rsp+B8h] [rbp-8h]\n\n  offa = off;\n  if ( !buf )\n    return 1;\n  if ( !off )\n    goto LABEL_8;\n  if ( off > 128 )\n    offa = 128;\n  memset(str, 32, offa);\n  if ( BIO_write(fp, str, offa) <= 0 )\n    return 0;\nLABEL_8:\n  if ( BIO_printf(fp, \"%s\", name) <= 0 )\n    return 0;\n  for ( i = 0LL; i < len; ++i )\n  {\n    if ( !(i % 0xF) )\n    {\n      str[0] = 10;\n      memset(&str[1], 32, offa + 4);\n      if ( BIO_write(fp, str, offa + 5) <= 0 )\n        return 0;\n    }\n    if ( len == i + 1 )\n      v6 = (const char *)&unk_1A5A15;\n    else\n      v6 = \":\";\n    if ( BIO_printf(fp, \"%02x%s\", buf[i], v6) <= 0 )\n      return 0;\n  }\n  return BIO_write(fp, \"\\n\", 1) > 0;\n}\n\n\n Revised code:\nstatic int print_bin(BIO *fp, const char *name, const unsigned char *buf,\n                     size_t len, int off)\n{\n    size_t i;\n    char str[128];\n\n    if (buf == NULL)\n        return 1;\n    if (off > 0) {\n        if (off > 128)\n            off = 128;\n        memset(str, ' ', off);\n        if (BIO_write(fp, str, off) <= 0)\n            return 0;\n    } else {\n        off = 0;\n    }\n\n    if (BIO_printf(fp, \"%s\", name) <= 0)\n        return 0;\n\n    for (i = 0; i < len; i++) {\n        if ((i % 15) == 0) {\n            str[0] = '\\n';\n            memset(&(str[1]), ' ', off + 4);\n            if (BIO_write(fp, str, off + 1 + 4) <= 0)\n                return 0;\n        }\n        if (BIO_printf(fp, \"%02x%s\", buf[i], ((i + 1) == len) ? \"\" : \":\") <=\n            0)\n            return 0;\n    }\n    if (BIO_write(fp, \"\\n\", 1) <= 0)\n        return 0;\n\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl get_ip(const char *str, unsigned __int8 *ip_0)\n{\n  const char *v2; // rax\n  unsigned int tmp[4]; // [rsp+10h] [rbp-20h]\n  int c; // [rsp+24h] [rbp-Ch]\n  int ok; // [rsp+28h] [rbp-8h]\n  int num; // [rsp+2Ch] [rbp-4h]\n\n  num = 0;\n  ok = 0;\n  tmp[3] = 0;\n  tmp[2] = 0;\n  tmp[1] = 0;\n  tmp[0] = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v2 = str++;\n      c = *v2;\n      if ( c <= 47 || c > 57 )\n        break;\n      ok = 1;\n      tmp[num] = 10 * tmp[num] + c - 48;\n      if ( tmp[num] > 0xFF )\n        return 0;\n    }\n    if ( c != 46 )\n      break;\n    if ( !ok )\n      return -1;\n    if ( num == 3 )\n      return 0;\n    ++num;\n    ok = 0;\n  }\n  if ( c || num != 3 || !ok )\n    return 0;\n  *ip_0 = tmp[0];\n  ip_0[1] = tmp[1];\n  ip_0[2] = tmp[2];\n  ip_0[3] = tmp[3];\n  return 1;\n}\n\n\n Revised code:\nstatic int get_ip(const char *str, unsigned char ip[4])\n{\n    unsigned int tmp[4];\n    int num = 0, c, ok = 0;\n\n    tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;\n\n    for (;;) {\n        c = *(str++);\n        if ((c >= '0') && (c <= '9')) {\n            ok = 1;\n            tmp[num] = tmp[num] * 10 + c - '0';\n            if (tmp[num] > 255)\n                return (0);\n        } else if (c == '.') {\n            if (!ok)\n                return (-1);\n            if (num == 3)\n                return (0);\n            num++;\n            ok = 0;\n        } else if (c == '\\0' && (num == 3) && ok)\n            break;\n        else\n            return (0);\n    }\n    ip[0] = tmp[0];\n    ip[1] = tmp[1];\n    ip[2] = tmp[2];\n    ip[3] = tmp[3];\n    return (1);\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl BUF_strlcpy(char *dst, const char *src, size_t size)\n{\n  const char *v3; // rdx\n  char *v4; // rax\n  size_t l; // [rsp+28h] [rbp-8h]\n\n  l = 0LL;\n  while ( size > 1 && *src )\n  {\n    v3 = src++;\n    v4 = dst++;\n    *v4 = *v3;\n    ++l;\n    --size;\n  }\n  if ( size )\n    *dst = 0;\n  return strlen(src) + l;\n}\n\n\n Revised code:\nsize_t BUF_strlcpy(char *dst, const char *src, size_t size)\n{\n    size_t l = 0;\n    for (; size > 1 && *src; size--) {\n        *dst++ = *src++;\n        l++;\n    }\n    if (size)\n        *dst = '\\0';\n    return l + strlen(src);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint sub_4639E2()\n{\n  int result; // eax\n  const char **v1; // [rsp+8h] [rbp-18h]\n  char *s; // [rsp+10h] [rbp-10h]\n  int v3; // [rsp+1Ch] [rbp-4h]\n\n  result = dest.c_lflag;\n  if ( result )\n  {\n    s = *(char **)&dest.c_cc[7];\n    v3 = 0;\n    if ( dest.c_cflag )\n    {\n      while ( 1 )\n      {\n        v1 = (const char **)(32LL * v3++ + *(_QWORD *)&dest.c_iflag);\n        if ( v3 == dest.c_cflag )\n          break;\n        s += sprintf(s, \"%-*s \", *(unsigned __int16 *)v1, v1[1]);\n      }\n      strcpy(s, v1[1]);\n    }\n    return printf(\"%.*s\\n\", *(_DWORD *)&dest.c_cc[15], *(const char **)&dest.c_cc[7]);\n  }\n  return result;\n}\n",
        "output": "```c\nstatic int print_flags_and_names()\n{\n    int result;\n    const char **entry;\n    char *buffer;\n    int count;\n\n    result = dest.c_lflag;\n    if (result)\n    {\n        buffer = (char *)&dest.c_cc[7];\n        count = 0;\n        if (dest.c_cflag)\n        {\n            while (1)\n            {\n                entry = (const char **)((size_t)count * 32 + *(size_t *)&dest.c_iflag);\n                if (count == dest.c_cflag - 1)\n                {\n                    strcpy(buffer, entry[1]);\n                    break;\n                }\n                buffer += sprintf(buffer, \"%-*s \", *(unsigned short *)entry, entry[1]);\n                count++;\n            }\n        }\n        return printf(\"%.*s\\n\", *(int *)&dest.c_cc[15], (char *)&dest.c_cc[7]);\n    }\n    return result;\n}\n```",
        "source_code": "static void format_header(void)\n{\n\tint i;\n\tps_out_t* op;\n\tchar *p;\n\n\tif (!print_header)\n\t\treturn;\n\tp = buffer;\n\ti = 0;\n\tif (out_cnt) {\n\t\twhile (1) {\n\t\t\top = &out[i];\n\t\t\tif (++i == out_cnt) /* do not pad last field */\n\t\t\t\tbreak;\n\t\t\tp += sprintf(p, \"%-*s \", op->width, op->header);\n\t\t}\n\t\tstrcpy(p, op->header);\n\t}\n\tprintf(\"%.*s\\n\", terminal_width, buffer);\n}",
        "parsed_output": "static int print_flags_and_names()\n{\n    int result;\n    const char **entry;\n    char *buffer;\n    int count;\n\n    result = dest.c_lflag;\n    if (result)\n    {\n        buffer = (char *)&dest.c_cc[7];\n        count = 0;\n        if (dest.c_cflag)\n        {\n            while (1)\n            {\n                entry = (const char **)((size_t)count * 32 + *(size_t *)&dest.c_iflag);\n                if (count == dest.c_cflag - 1)\n                {\n                    strcpy(buffer, entry[1]);\n                    break;\n                }\n                buffer += sprintf(buffer, \"%-*s \", *(unsigned short *)entry, entry[1]);\n                count++;\n            }\n        }\n        return printf(\"%.*s\\n\", *(int *)&dest.c_cc[15], (char *)&dest.c_cc[7]);\n    }\n    return result;\n}",
        "baseline_code_stripped": "int sub_4639E2()\n{\n  int result; // eax\n  const char **v1; // [rsp+8h] [rbp-18h]\n  char *s; // [rsp+10h] [rbp-10h]\n  int v3; // [rsp+1Ch] [rbp-4h]\n\n  result = dest.c_lflag;\n  if ( result )\n  {\n    s = *(char **)&dest.c_cc[7];\n    v3 = 0;\n    if ( dest.c_cflag )\n    {\n      while ( 1 )\n      {\n        v1 = (const char **)(32LL * v3++ + *(_QWORD *)&dest.c_iflag);\n        if ( v3 == dest.c_cflag )\n          break;\n        s += sprintf(s, \"%-*s \", *(unsigned __int16 *)v1, v1[1]);\n      }\n      strcpy(s, v1[1]);\n    }\n    return printf(\"%.*s\\n\", *(_DWORD *)&dest.c_cc[15], *(const char **)&dest.c_cc[7]);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl format_header()\n{\n  ps_out_t *op; // [rsp+8h] [rbp-18h]\n  char *p; // [rsp+10h] [rbp-10h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  if ( bb_common_bufsiz1.c_lflag )\n  {\n    p = *(char **)&bb_common_bufsiz1.c_cc[7];\n    i = 0;\n    if ( bb_common_bufsiz1.c_cflag )\n    {\n      while ( 1 )\n      {\n        op = (ps_out_t *)(32LL * i++ + *(_QWORD *)&bb_common_bufsiz1.c_iflag);\n        if ( i == bb_common_bufsiz1.c_cflag )\n          break;\n        p += sprintf(p, \"%-*s \", op->width, op->header);\n      }\n      strcpy(p, op->header);\n    }\n    printf(\"%.*s\\n\", *(_DWORD *)&bb_common_bufsiz1.c_cc[15], *(const char **)&bb_common_bufsiz1.c_cc[7]);\n  }\n}\n",
        "similarity_score_unixcoder": 0.6458144783973694,
        "similarity_score_baseline_stripped": 0.5552067756652832,
        "similarity_score_baseline_debug": 0.737819492816925
    },
    {
        "func_name": "get_cred_or_die",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nunsigned __int8 *__cdecl string_to_hex(const char *str, __int64 *len)\n{\n  int v3; // eax\n  unsigned __int8 *v4; // rax\n  unsigned __int8 *v5; // rax\n  unsigned __int8 *v6; // rax\n  unsigned __int8 *hexbuf; // [rsp+10h] [rbp-20h]\n  unsigned __int8 *p; // [rsp+18h] [rbp-18h]\n  unsigned __int8 cl_0; // [rsp+26h] [rbp-Ah]\n  unsigned __int8 cl_0a; // [rsp+26h] [rbp-Ah]\n  unsigned __int8 ch_0; // [rsp+27h] [rbp-9h]\n  unsigned __int8 ch_0a; // [rsp+27h] [rbp-9h]\n  unsigned __int8 *q; // [rsp+28h] [rbp-8h]\n\n  if ( str )\n  {\n    v3 = strlen(str);\n    hexbuf = (unsigned __int8 *)CRYPTO_malloc(v3 >> 1, \"v3_utl.c\", 400);\n    if ( hexbuf )\n    {\n      p = (unsigned __int8 *)str;\n      q = hexbuf;\n      while ( *p )\n      {\n        v4 = p++;\n        ch_0 = *v4;\n        if ( *v4 != 58 )\n        {\n          v5 = p++;\n          cl_0 = *v5;\n          if ( !*v5 )\n          {\n            ERR_put_error(34, 113, 112, \"v3_utl.c\", 412);\n            CRYPTO_free(hexbuf);\n            return 0LL;\n          }\n          if ( ((*__ctype_b_loc())[ch_0] & 0x100) != 0 )\n            ch_0 = tolower(ch_0);\n          if ( ((*__ctype_b_loc())[cl_0] & 0x100) != 0 )\n            cl_0 = tolower(cl_0);\n          if ( ch_0 <= 0x2Fu || ch_0 > 0x39u )\n          {\n            if ( ch_0 <= 0x60u || ch_0 > 0x66u )\n            {\nbadhex:\n              CRYPTO_free(hexbuf);\n              ERR_put_error(34, 113, 113, \"v3_utl.c\", 441);\n              return 0LL;\n            }\n            ch_0a = ch_0 - 87;\n          }\n          else\n          {\n            ch_0a = ch_0 - 48;\n          }\n          if ( cl_0 <= 0x2Fu || cl_0 > 0x39u )\n          {\n            if ( cl_0 <= 0x60u || cl_0 > 0x66u )\n              goto badhex;\n            cl_0a = cl_0 - 87;\n          }\n          else\n          {\n            cl_0a = cl_0 - 48;\n          }\n          v6 = q++;\n          *v6 = cl_0a | (16 * ch_0a);\n        }\n      }\n      if ( len )\n        *len = q - hexbuf;\n      return hexbuf;\n    }\n    else\n    {\n      ERR_put_error(34, 113, 65, \"v3_utl.c\", 436);\n      return 0LL;\n    }\n  }\n  else\n  {\n    ERR_put_error(34, 113, 107, \"v3_utl.c\", 397);\n    return 0LL;\n  }\n}\n\n\n Revised code:\nunsigned char *string_to_hex(const char *str, long *len)\n{\n    unsigned char *hexbuf, *q;\n    unsigned char ch, cl, *p;\n    if (!str) {\n        X509V3err(X509V3_F_STRING_TO_HEX, X509V3_R_INVALID_NULL_ARGUMENT);\n        return NULL;\n    }\n    if (!(hexbuf = OPENSSL_malloc(strlen(str) >> 1)))\n        goto err;\n    for (p = (unsigned char *)str, q = hexbuf; *p;) {\n        ch = *p++;\n#ifdef CHARSET_EBCDIC\n        ch = os_toebcdic[ch];\n#endif\n        if (ch == ':')\n            continue;\n        cl = *p++;\n#ifdef CHARSET_EBCDIC\n        cl = os_toebcdic[cl];\n#endif\n        if (!cl) {\n            X509V3err(X509V3_F_STRING_TO_HEX, X509V3_R_ODD_NUMBER_OF_DIGITS);\n            OPENSSL_free(hexbuf);\n            return NULL;\n        }\n        if (isupper(ch))\n            ch = tolower(ch);\n        if (isupper(cl))\n            cl = tolower(cl);\n\n        if ((ch >= '0') && (ch <= '9'))\n            ch -= '0';\n        else if ((ch >= 'a') && (ch <= 'f'))\n            ch -= 'a' - 10;\n        else\n            goto badhex;\n\n        if ((cl >= '0') && (cl <= '9'))\n            cl -= '0';\n        else if ((cl >= 'a') && (cl <= 'f'))\n            cl -= 'a' - 10;\n        else\n            goto badhex;\n\n        *q++ = (ch << 4) | cl;\n    }\n\n    if (len)\n        *len = q - hexbuf;\n\n    return hexbuf;\n\n err:\n    if (hexbuf)\n        OPENSSL_free(hexbuf);\n    X509V3err(X509V3_F_STRING_TO_HEX, ERR_R_MALLOC_FAILURE);\n    return NULL;\n\n badhex:\n    OPENSSL_free(hexbuf);\n    X509V3err(X509V3_F_STRING_TO_HEX, X509V3_R_ILLEGAL_HEX_DIGIT);\n    return NULL;\n\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_412053(unsigned int a1)\n{\n  const char *v1; // rax\n  _QWORD *v2; // rbx\n  const char *v3; // rax\n  _QWORD *v4; // rbx\n  __int64 v5; // rdx\n  __int64 v6; // rcx\n  __int64 v7; // r8\n  __int64 v8; // r9\n  _QWORD *v9; // rbx\n  _QWORD *v10; // rbx\n  __int64 result; // rax\n\n  if ( isatty(a1) )\n  {\n    v1 = (const char *)sub_4F5FA5(a1, 0LL, \"User: \");\n    v2 = qword_75D408;\n    v2[2] = sub_40A11F(v1, 0LL);\n    v3 = (const char *)sub_4F5FA5(a1, 0LL, \"Password: \");\n    v4 = qword_75D408;\n    v4[3] = sub_40A11F(v3, 0LL);\n  }\n  else\n  {\n    v9 = qword_75D408;\n    v9[2] = sub_507143(a1, 0LL);\n    v10 = qword_75D408;\n    v10[3] = sub_507143(a1, 0LL);\n  }\n  if ( !*((_QWORD *)qword_75D408 + 2)\n    || !**((_BYTE **)qword_75D408 + 2)\n    || (result = *((_QWORD *)qword_75D408 + 3)) == 0 )\n  {\n    sub_40969E(\"no username or password\", 0LL, v5, v6, v7, v8);\n  }\n  return result;\n}\n",
        "output": "```c\nlong long sub_412053(unsigned int fd)\n{\n    const char *user_input;\n    long long *global_data;\n    long long result;\n\n    if (isatty(fd)) {\n        user_input = sub_4F5FA5(fd, 0, \"User: \");\n        global_data = qword_75D408;\n        global_data[2] = sub_40A11F(user_input, 0);\n\n        user_input = sub_4F5FA5(fd, 0, \"Password: \");\n        global_data[3] = sub_40A11F(user_input, 0);\n    } else {\n        global_data = qword_75D408;\n        global_data[2] = sub_507143(fd, 0);\n        global_data[3] = sub_507143(fd, 0);\n    }\n\n    if (!global_data[2] || !*(char *)(global_data[2]) || !(result = global_data[3])) {\n        sub_40969E(\"no username or password\", 0, 0, 0, 0, 0);\n    }\n\n    return result;\n}\n```",
        "source_code": "void FAST_FUNC get_cred_or_die(int fd)\n{\n\tif (isatty(fd)) {\n\t\tG.user = xstrdup(bb_ask(fd, /* timeout: */ 0, \"User: \"));\n\t\tG.pass = xstrdup(bb_ask(fd, /* timeout: */ 0, \"Password: \"));\n\t} else {\n\t\tG.user = xmalloc_reads(fd, /* maxsize: */ NULL);\n\t\tG.pass = xmalloc_reads(fd, /* maxsize: */ NULL);\n\t}\n\tif (!G.user || !*G.user || !G.pass)\n\t\tbb_error_msg_and_die(\"no username or password\");\n}",
        "parsed_output": "long long sub_412053(unsigned int fd)\n{\n    const char *user_input;\n    long long *global_data;\n    long long result;\n\n    if (isatty(fd)) {\n        user_input = sub_4F5FA5(fd, 0, \"User: \");\n        global_data = qword_75D408;\n        global_data[2] = sub_40A11F(user_input, 0);\n\n        user_input = sub_4F5FA5(fd, 0, \"Password: \");\n        global_data[3] = sub_40A11F(user_input, 0);\n    } else {\n        global_data = qword_75D408;\n        global_data[2] = sub_507143(fd, 0);\n        global_data[3] = sub_507143(fd, 0);\n    }\n\n    if (!global_data[2] || !*(char *)(global_data[2]) || !(result = global_data[3])) {\n        sub_40969E(\"no username or password\", 0, 0, 0, 0, 0);\n    }\n\n    return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_412053(unsigned int a1)\n{\n  const char *v1; // rax\n  _QWORD *v2; // rbx\n  const char *v3; // rax\n  _QWORD *v4; // rbx\n  __int64 v5; // rdx\n  __int64 v6; // rcx\n  __int64 v7; // r8\n  __int64 v8; // r9\n  _QWORD *v9; // rbx\n  _QWORD *v10; // rbx\n  __int64 result; // rax\n\n  if ( isatty(a1) )\n  {\n    v1 = (const char *)sub_4F5FA5(a1, 0LL, \"User: \");\n    v2 = qword_75D408;\n    v2[2] = sub_40A11F(v1, 0LL);\n    v3 = (const char *)sub_4F5FA5(a1, 0LL, \"Password: \");\n    v4 = qword_75D408;\n    v4[3] = sub_40A11F(v3, 0LL);\n  }\n  else\n  {\n    v9 = qword_75D408;\n    v9[2] = sub_507143(a1, 0LL);\n    v10 = qword_75D408;\n    v10[3] = sub_507143(a1, 0LL);\n  }\n  if ( !*((_QWORD *)qword_75D408 + 2)\n    || !**((_BYTE **)qword_75D408 + 2)\n    || (result = *((_QWORD *)qword_75D408 + 3)) == 0 )\n  {\n    sub_40969E(\"no username or password\", 0LL, v5, v6, v7, v8);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl get_cred_or_die(int fd)\n{\n  char *v1; // rax\n  globals *v2; // rbx\n  char *v3; // rax\n  globals *v4; // rbx\n  globals *v5; // rbx\n  globals *v6; // rbx\n\n  if ( isatty(fd) )\n  {\n    v1 = bb_ask(fd, 0, \"User: \");\n    v2 = ptr_to_globals;\n    v2->fakehost = xstrdup(v1);\n    v3 = bb_ask(fd, 0, \"Password: \");\n    v4 = ptr_to_globals;\n    v4->tty_name = xstrdup(v3);\n  }\n  else\n  {\n    v5 = ptr_to_globals;\n    v5->fakehost = xmalloc_reads(fd, 0LL);\n    v6 = ptr_to_globals;\n    v6->tty_name = xmalloc_reads(fd, 0LL);\n  }\n  if ( !ptr_to_globals->fakehost || !*ptr_to_globals->fakehost || !ptr_to_globals->tty_name )\n    bb_error_msg_and_die(\"no username or password\");\n}\n",
        "similarity_score_unixcoder": 0.6311121582984924,
        "similarity_score_baseline_stripped": 0.48185139894485474,
        "similarity_score_baseline_debug": 0.8280889987945557
    },
    {
        "func_name": "unexpand",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nchar *__cdecl t_tob64(char *dst, const unsigned __int8 *src, int size)\n{\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  int v7; // eax\n  char *dsta; // [rsp+Ch] [rbp-28h]\n  int c; // [rsp+20h] [rbp-14h]\n  int ca; // [rsp+20h] [rbp-14h]\n  unsigned __int8 notleading; // [rsp+2Ch] [rbp-8h]\n  unsigned __int8 b2; // [rsp+2Dh] [rbp-7h]\n  unsigned __int8 b1; // [rsp+2Eh] [rbp-6h]\n  unsigned __int8 b0; // [rsp+2Fh] [rbp-5h]\n  int pos; // [rsp+30h] [rbp-4h]\n\n  dsta = dst;\n  pos = size % 3;\n  b0 = 0;\n  b1 = 0;\n  b2 = 0;\n  notleading = 0;\n  if ( size % 3 == 1 )\n  {\n    b2 = *src;\n  }\n  else if ( pos == 2 )\n  {\n    b1 = *src;\n    b2 = src[1];\n  }\n  while ( 1 )\n  {\n    if ( notleading || b0 >> 2 )\n    {\n      v3 = dsta++;\n      *v3 = b64table[b0 >> 2];\n      notleading = 1;\n    }\n    c = (16 * b0) & 0x30 | (b1 >> 4);\n    if ( notleading || c )\n    {\n      v4 = dsta++;\n      *v4 = b64table[c];\n      notleading = 1;\n    }\n    ca = (4 * b1) & 0x3C | (b2 >> 6);\n    if ( notleading || ca )\n    {\n      v5 = dsta++;\n      *v5 = b64table[ca];\n      notleading = 1;\n    }\n    if ( notleading || (b2 & 0x3F) != 0 )\n    {\n      v6 = dsta++;\n      *v6 = b64table[b2 & 0x3F];\n      notleading = 1;\n    }\n    if ( pos >= size )\n      break;\n    b0 = src[pos];\n    b1 = src[pos + 1];\n    v7 = pos + 2;\n    pos += 3;\n    b2 = src[v7];\n  }\n  *dsta = 0;\n  return dst;\n}\n\n\n Revised code:\nstatic char *t_tob64(char *dst, const unsigned char *src, int size)\n{\n    int c, pos = size % 3;\n    unsigned char b0 = 0, b1 = 0, b2 = 0, notleading = 0;\n    char *olddst = dst;\n\n    switch (pos) {\n    case 1:\n        b2 = src[0];\n        break;\n    case 2:\n        b1 = src[0];\n        b2 = src[1];\n        break;\n    }\n\n    while (1) {\n        c = (b0 & 0xfc) >> 2;\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = ((b0 & 3) << 4) | ((b1 & 0xf0) >> 4);\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = ((b1 & 0xf) << 2) | ((b2 & 0xc0) >> 6);\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = b2 & 0x3f;\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        if (pos >= size)\n            break;\n        else {\n            b0 = src[pos++];\n            b1 = src[pos++];\n            b2 = src[pos++];\n        }\n    }\n\n    *dst++ = '\\0';\n    return olddst;\n}\n\n## Example:\n\n Input code:\nint __cdecl t_fromb64(unsigned __int8 *a, const char *src)\n{\n  int v2; // eax\n  unsigned __int8 *v3; // rcx\n  int v4; // eax\n  char *loc; // [rsp+18h] [rbp-18h]\n  int size; // [rsp+24h] [rbp-Ch]\n  int sizea; // [rsp+24h] [rbp-Ch]\n  int j; // [rsp+28h] [rbp-8h]\n  int i; // [rsp+2Ch] [rbp-4h]\n  int ia; // [rsp+2Ch] [rbp-4h]\n  int ib; // [rsp+2Ch] [rbp-4h]\n  int ic; // [rsp+2Ch] [rbp-4h]\n  int id; // [rsp+2Ch] [rbp-4h]\n  int ie; // [rsp+2Ch] [rbp-4h]\n\n  while ( *src && (*src == 32 || *src == 9 || *src == 10) )\n    ++src;\n  size = strlen(src);\n  for ( i = 0; i < size; ++i )\n  {\n    loc = strchr(b64table, src[i]);\n    if ( !loc )\n      break;\n    a[i] = loc - b64table;\n  }\n  sizea = i;\n  ia = i - 1;\n  j = sizea;\n  do\n  {\n    a[j] = a[ia];\n    ib = ia - 1;\n    if ( ib < 0 )\n      break;\n    a[j--] |= a[ib] << 6;\n    a[j] = ((int)a[ib] >> 2) & 0xF;\n    ic = ib - 1;\n    if ( ic < 0 )\n      break;\n    a[j--] |= 16 * a[ic];\n    a[j] = ((int)a[ic] >> 4) & 3;\n    id = ic - 1;\n    if ( id < 0 )\n      break;\n    a[j--] |= 4 * a[id];\n    a[j] = 0;\n    ia = id - 1;\n  }\n  while ( ia >= 0 );\n  while ( !a[j] && j <= sizea )\n    ++j;\n  ie = 0;\n  while ( j <= sizea )\n  {\n    v2 = j++;\n    v3 = &a[v2];\n    v4 = ie++;\n    a[v4] = *v3;\n  }\n  return ie;\n}\n\n\n Revised code:\nstatic int t_fromb64(unsigned char *a, const char *src)\n{\n    char *loc;\n    int i, j;\n    int size;\n\n    while (*src && (*src == ' ' || *src == '\\t' || *src == '\\n'))\n        ++src;\n    size = strlen(src);\n    i = 0;\n    while (i < size) {\n        loc = strchr(b64table, src[i]);\n        if (loc == (char *)0)\n            break;\n        else\n            a[i] = loc - b64table;\n        ++i;\n    }\n    /* if nothing valid to process we have a zero length response */\n    if (i == 0)\n        return 0;\n    size = i;\n    i = size - 1;\n    j = size;\n    while (1) {\n        a[j] = a[i];\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] & 3) << 6;\n        --j;\n        a[j] = (unsigned char)((a[i] & 0x3c) >> 2);\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] & 0xf) << 4;\n        --j;\n        a[j] = (unsigned char)((a[i] & 0x30) >> 4);\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] << 2);\n\n        a[--j] = 0;\n        if (--i < 0)\n            break;\n    }\n    while (a[j] == 0 && j <= size)\n        ++j;\n    i = 0;\n    while (j <= size)\n        a[i++] = a[j++];\n    return i;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_4C8F32(__int64 a1, unsigned int a2, char a3)\n{\n  void *result; // rax\n  char v6[8]; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v7; // [rsp+18h] [rbp-28h]\n  char v8; // [rsp+1Fh] [rbp-21h]\n  void *ptr; // [rsp+20h] [rbp-20h]\n  unsigned int v10; // [rsp+2Ch] [rbp-14h]\n  unsigned int v11; // [rsp+30h] [rbp-10h]\n  unsigned int v12; // [rsp+34h] [rbp-Ch]\n  char *s; // [rsp+38h] [rbp-8h]\n\n  for ( result = (void *)sub_4F9FD0(a1); ; result = (void *)sub_4F9FD0(a1) )\n  {\n    ptr = result;\n    if ( !result )\n      break;\n    s = (char *)ptr;\n    v12 = 0;\n    while ( *s )\n    {\n      v10 = 0;\n      while ( *s == 32 )\n      {\n        ++s;\n        ++v10;\n      }\n      v12 += v10;\n      if ( *s == 9 )\n      {\n        v12 += a2 - v12 % a2;\n        ++s;\n      }\n      else\n      {\n        v11 = v12 / a2;\n        if ( v12 / a2 )\n        {\n          v12 %= a2;\n          v10 = v12;\n          while ( v11-- )\n            putchar_unlocked(9);\n        }\n        if ( (a3 & 1) != 0 && s != ptr )\n        {\n          printf(\"%*s%s\", v10, (const char *)&unk_536BFE, s);\n          break;\n        }\n        v11 = strcspn(s, \"\\t \");\n        printf(\"%*s%.*s\", v10, (const char *)&unk_536BFE, v11, s);\n        v8 = s[v11];\n        s[v11] = 0;\n        sub_502FB1(v6, s);\n        v10 = v7;\n        s[v11] = v8;\n        s += v11;\n        v12 = (v12 + v10) % a2;\n      }\n    }\n    free(ptr);\n  }\n  return result;\n}\n",
        "output": "```c\nstatic void *sub_4C8F32(long long a1, unsigned int a2, char a3)\n{\n    void *result;\n    char v6[8];\n    unsigned int v7;\n    char v8;\n    void *ptr;\n    unsigned int v10, v11, v12;\n    char *s;\n\n    while ((ptr = (void *)sub_4F9FD0(a1)) != NULL) {\n        s = (char *)ptr;\n        v12 = 0;\n        while (*s) {\n            v10 = 0;\n            while (*s == ' ') {\n                ++s;\n                ++v10;\n            }\n            v12 += v10;\n            if (*s == '\\t') {\n                v12 += a2 - v12 % a2;\n                ++s;\n            } else {\n                v11 = v12 / a2;\n                v12 %= a2;\n                v10 = v12;\n                while (v11--)\n                    putchar_unlocked('\\t');\n                if ((a3 & 1) && s != ptr) {\n                    printf(\"%*s%s\", v10, \"\", s);\n                    break;\n                }\n                v11 = strcspn(s, \"\\t \");\n                printf(\"%*s%.*s\", v10, \"\", v11, s);\n                v8 = s[v11];\n                s[v11] = '\\0';\n                sub_502FB1(v6, s);\n                v10 = v7;\n                s[v11] = v8;\n                s += v11;\n                v12 = (v12 + v10) % a2;\n            }\n        }\n        free(ptr);\n    }\n    return NULL;\n}\n```",
        "source_code": "if ENABLE_UNEXPAND\nstatic void unexpand(FILE *file, unsigned tab_size, unsigned opt)\n{\n\tchar *line;\n\n\twhile ((line = xmalloc_fgets(file)) != NULL) {\n\t\tchar *ptr = line;\n\t\tunsigned column = 0;\n\n\t\twhile (*ptr) {\n\t\t\tunsigned n;\n\t\t\tunsigned len = 0;\n\n\t\t\twhile (*ptr == ' ') {\n\t\t\t\tptr++;\n\t\t\t\tlen++;\n\t\t\t}\n\t\t\tcolumn += len;\n\t\t\tif (*ptr == '\\t') {\n\t\t\t\tcolumn += tab_size - (column % tab_size);\n\t\t\t\tptr++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn = column / tab_size;\n\t\t\tif (n) {\n\t\t\t\tlen = column = column % tab_size;\n\t\t\t\twhile (n--)\n\t\t\t\t\tputchar('\\t');\n\t\t\t}\n\n\t\t\tif ((opt & OPT_INITIAL) && ptr != line) {\n\t\t\t\tprintf(\"%*s%s\", len, \"\", ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tn = strcspn(ptr, \"\\t \");\n\t\t\tprintf(\"%*s%.*s\", len, \"\", n, ptr);\n# if ENABLE_UNICODE_SUPPORT\n\t\t\t{\n\t\t\t\tchar c;\n\t\t\t\tuni_stat_t uni_stat;\n\t\t\t\tc = ptr[n];\n\t\t\t\tptr[n] = '\\0';\n\t\t\t\tprintable_string(&uni_stat, ptr);\n\t\t\t\tlen = uni_stat.unicode_width;\n\t\t\t\tptr[n] = c;\n\t\t\t}\n# else\n\t\t\tlen = n;\n# endif\n\t\t\tptr += n;\n\t\t\tcolumn = (column + len) % tab_size;\n\t\t}\n\t\tfree(line);\n\t}\n}",
        "parsed_output": "static void *sub_4C8F32(long long a1, unsigned int a2, char a3)\n{\n    void *result;\n    char v6[8];\n    unsigned int v7;\n    char v8;\n    void *ptr;\n    unsigned int v10, v11, v12;\n    char *s;\n\n    while ((ptr = (void *)sub_4F9FD0(a1)) != NULL) {\n        s = (char *)ptr;\n        v12 = 0;\n        while (*s) {\n            v10 = 0;\n            while (*s == ' ') {\n                ++s;\n                ++v10;\n            }\n            v12 += v10;\n            if (*s == '\\t') {\n                v12 += a2 - v12 % a2;\n                ++s;\n            } else {\n                v11 = v12 / a2;\n                v12 %= a2;\n                v10 = v12;\n                while (v11--)\n                    putchar_unlocked('\\t');\n                if ((a3 & 1) && s != ptr) {\n                    printf(\"%*s%s\", v10, \"\", s);\n                    break;\n                }\n                v11 = strcspn(s, \"\\t \");\n                printf(\"%*s%.*s\", v10, \"\", v11, s);\n                v8 = s[v11];\n                s[v11] = '\\0';\n                sub_502FB1(v6, s);\n                v10 = v7;\n                s[v11] = v8;\n                s += v11;\n                v12 = (v12 + v10) % a2;\n            }\n        }\n        free(ptr);\n    }\n    return NULL;\n}",
        "baseline_code_stripped": "void *__fastcall sub_4C8F32(__int64 a1, unsigned int a2, char a3)\n{\n  void *result; // rax\n  char v6[8]; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v7; // [rsp+18h] [rbp-28h]\n  char v8; // [rsp+1Fh] [rbp-21h]\n  void *ptr; // [rsp+20h] [rbp-20h]\n  unsigned int v10; // [rsp+2Ch] [rbp-14h]\n  unsigned int v11; // [rsp+30h] [rbp-10h]\n  unsigned int v12; // [rsp+34h] [rbp-Ch]\n  char *s; // [rsp+38h] [rbp-8h]\n\n  for ( result = (void *)sub_4F9FD0(a1); ; result = (void *)sub_4F9FD0(a1) )\n  {\n    ptr = result;\n    if ( !result )\n      break;\n    s = (char *)ptr;\n    v12 = 0;\n    while ( *s )\n    {\n      v10 = 0;\n      while ( *s == 32 )\n      {\n        ++s;\n        ++v10;\n      }\n      v12 += v10;\n      if ( *s == 9 )\n      {\n        v12 += a2 - v12 % a2;\n        ++s;\n      }\n      else\n      {\n        v11 = v12 / a2;\n        if ( v12 / a2 )\n        {\n          v12 %= a2;\n          v10 = v12;\n          while ( v11-- )\n            putchar_unlocked(9);\n        }\n        if ( (a3 & 1) != 0 && s != ptr )\n        {\n          printf(\"%*s%s\", v10, (const char *)&unk_536BFE, s);\n          break;\n        }\n        v11 = strcspn(s, \"\\t \");\n        printf(\"%*s%.*s\", v10, (const char *)&unk_536BFE, v11, s);\n        v8 = s[v11];\n        s[v11] = 0;\n        sub_502FB1(v6, s);\n        v10 = v7;\n        s[v11] = v8;\n        s += v11;\n        v12 = (v12 + v10) % a2;\n      }\n    }\n    free(ptr);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl unexpand(FILE *file, unsigned int tab_size, unsigned int opt)\n{\n  char opta; // [rsp+0h] [rbp-40h]\n  uni_stat_t_0 uni_stat; // [rsp+10h] [rbp-30h] BYREF\n  char c; // [rsp+1Fh] [rbp-21h]\n  char *line; // [rsp+20h] [rbp-20h]\n  unsigned int len; // [rsp+2Ch] [rbp-14h]\n  unsigned int n; // [rsp+30h] [rbp-10h]\n  unsigned int column; // [rsp+34h] [rbp-Ch]\n  char *ptr; // [rsp+38h] [rbp-8h]\n\n  opta = opt;\n  while ( 1 )\n  {\n    line = xmalloc_fgets(file);\n    if ( !line )\n      break;\n    ptr = line;\n    column = 0;\n    while ( *ptr )\n    {\n      len = 0;\n      while ( *ptr == 32 )\n      {\n        ++ptr;\n        ++len;\n      }\n      column += len;\n      if ( *ptr == 9 )\n      {\n        column += tab_size - column % tab_size;\n        ++ptr;\n      }\n      else\n      {\n        n = column / tab_size;\n        if ( column / tab_size )\n        {\n          column %= tab_size;\n          len = column;\n          while ( n-- )\n            putchar_unlocked(9);\n        }\n        if ( (opta & 1) != 0 && ptr != line )\n        {\n          printf(\"%*s%s\", len, (const char *)&unk_536BFE, ptr);\n          break;\n        }\n        n = strcspn(ptr, \"\\t \");\n        printf(\"%*s%.*s\", len, (const char *)&unk_536BFE, n, ptr);\n        c = ptr[n];\n        ptr[n] = 0;\n        printable_string(&uni_stat, ptr);\n        len = uni_stat.unicode_width;\n        ptr[n] = c;\n        ptr += n;\n        column = (column + len) % tab_size;\n      }\n    }\n    free(line);\n  }\n}\n",
        "similarity_score_unixcoder": 0.6777538657188416,
        "similarity_score_baseline_stripped": 0.5681265592575073,
        "similarity_score_baseline_debug": 0.8401921987533569
    },
    {
        "func_name": "set_qlen",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl SRP_user_pwd_set_sv(SRP_user_pwd *vinfo, const char *s, const char *v)\n{\n  unsigned __int8 tmp[2500]; // [rsp+20h] [rbp-9D0h] BYREF\n  int len; // [rsp+9ECh] [rbp-4h]\n\n  if ( strlen(s) > 0x9C4 || strlen(v) > 0x9C4 )\n    return 0;\n  len = t_fromb64(tmp, v);\n  vinfo->v = BN_bin2bn(tmp, len, 0LL);\n  if ( !vinfo->v )\n    return 0;\n  len = t_fromb64(tmp, s);\n  vinfo->s = BN_bin2bn(tmp, len, 0LL);\n  return vinfo->s != 0LL;\n}\n\n\n Revised code:\nstatic int SRP_user_pwd_set_sv(SRP_user_pwd *vinfo, const char *s,\n                               const char *v)\n{\n    unsigned char tmp[MAX_LEN];\n    int len;\n\n    if (strlen(s) > MAX_LEN || strlen(v) > MAX_LEN)\n        return 0;\n    len = t_fromb64(tmp, v);\n    if (NULL == (vinfo->v = BN_bin2bn(tmp, len, NULL)))\n        return 0;\n    len = t_fromb64(tmp, s);\n    return ((vinfo->s = BN_bin2bn(tmp, len, NULL)) != NULL);\n}\n\n## Example:\n\n Input code:\n__int64 __cdecl slg_ctrl(BIO *b, int cmd, __int64 num, void *ptr)\n{\n  int numa; // [rsp+8h] [rbp-18h]\n\n  numa = num;\n  if ( cmd == 4 )\n  {\n    xcloselog(b);\n    xopenlog(b, (char *)ptr, numa);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic long MS_CALLBACK slg_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    switch (cmd) {\n    case BIO_CTRL_SET:\n        xcloselog(b);\n        xopenlog(b, ptr, num);\n        break;\n    default:\n        break;\n    }\n    return (0);\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_44BD19(const char *a1, int a2)\n{\n  char s[16]; // [rsp+10h] [rbp-30h] BYREF\n  int v4; // [rsp+20h] [rbp-20h]\n  int fd; // [rsp+3Ch] [rbp-4h]\n\n  fd = sub_44BBB0();\n  memset(s, 0, 0x28uLL);\n  sub_409A52(s, a1);\n  v4 = a2;\n  sub_40AD51(fd, 0x8943u, (__int64)s, (__int64)\"SIOCSIFTXQLEN\");\n  return close(fd);\n}\n",
        "output": "```c\nstatic int set_interface_tx_queue_length(const char *interface_name, int queue_length)\n{\n    char ioctl_data[16];\n    int socket_fd;\n\n    socket_fd = open_socket();\n    memset(ioctl_data, 0, sizeof(ioctl_data));\n    prepare_ioctl_data(ioctl_data, interface_name);\n    perform_ioctl(socket_fd, SIOCSIFTXQLEN, ioctl_data, \"SIOCSIFTXQLEN\");\n    return close(socket_fd);\n}\n```",
        "source_code": "static void set_qlen(char *dev, int qlen)\n{\n\tstruct ifreq ifr;\n\tint s;\n\n\ts = get_ctl_fd();\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy_IFNAMSIZ(ifr.ifr_name, dev);\n\tifr.ifr_qlen = qlen;\n\txioctl(s, SIOCSIFTXQLEN, &ifr);\n\tclose(s);\n}",
        "parsed_output": "static int set_interface_tx_queue_length(const char *interface_name, int queue_length)\n{\n    char ioctl_data[16];\n    int socket_fd;\n\n    socket_fd = open_socket();\n    memset(ioctl_data, 0, sizeof(ioctl_data));\n    prepare_ioctl_data(ioctl_data, interface_name);\n    perform_ioctl(socket_fd, SIOCSIFTXQLEN, ioctl_data, \"SIOCSIFTXQLEN\");\n    return close(socket_fd);\n}",
        "baseline_code_stripped": "int __fastcall sub_44BD19(const char *a1, int a2)\n{\n  char s[16]; // [rsp+10h] [rbp-30h] BYREF\n  int v4; // [rsp+20h] [rbp-20h]\n  int fd; // [rsp+3Ch] [rbp-4h]\n\n  fd = sub_44BBB0();\n  memset(s, 0, 0x28uLL);\n  sub_409A52(s, a1);\n  v4 = a2;\n  sub_40AD51(fd, 0x8943u, (__int64)s, (__int64)\"SIOCSIFTXQLEN\");\n  return close(fd);\n}\n",
        "baseline_code_debug": "void __cdecl set_qlen(char *dev, int qlen)\n{\n  ifreq ifr; // [rsp+10h] [rbp-30h] BYREF\n  int s; // [rsp+3Ch] [rbp-4h]\n\n  s = get_ctl_fd();\n  memset(&ifr, 0, sizeof(ifr));\n  strncpy_IFNAMSIZ(ifr.ifr_ifrn.ifrn_name, dev);\n  ifr.ifr_ifru.ifru_ivalue = qlen;\n  bb_xioctl(s, 0x8943u, &ifr, \"SIOCSIFTXQLEN\");\n  close(s);\n}\n",
        "similarity_score_unixcoder": 0.6956782937049866,
        "similarity_score_baseline_stripped": 0.4749789535999298,
        "similarity_score_baseline_debug": 0.8802815675735474
    },
    {
        "func_name": "resuse_end",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nint __cdecl der_cmp(const void *a, const void *b)\n{\n  int v2; // eax\n  int i; // [rsp+18h] [rbp-18h]\n\n  v2 = *((_DWORD *)a + 2);\n  if ( *((_DWORD *)b + 2) <= v2 )\n    v2 = *((_DWORD *)b + 2);\n  i = memcmp(*(const void **)a, *(const void **)b, v2);\n  if ( i )\n    return i;\n  else\n    return *((_DWORD *)a + 2) - *((_DWORD *)b + 2);\n}\n\n\n Revised code:\nstatic int der_cmp(const void *a, const void *b)\n{\n    const DER_ENC *d1 = a, *d2 = b;\n    int cmplen, i;\n    cmplen = (d1->length < d2->length) ? d1->length : d2->length;\n    i = memcmp(d1->data, d2->data, cmplen);\n    if (i)\n        return i;\n    return d1->length - d2->length;\n}\n\n## Example:\n\n Input code:\nunsigned int __cdecl read_ledword(const unsigned __int8 **in)\n{\n  int v1; // eax\n  int ret; // [rsp+Ch] [rbp-Ch]\n\n  ret = ((*in)[2] << 16) | *(unsigned __int16 *)*in;\n  v1 = (*in)[3] << 24;\n  *in += 4;\n  return v1 | ret;\n}\n\n\n Revised code:\nstatic unsigned int read_ledword(const unsigned char **in)\n{\n    const unsigned char *p = *in;\n    unsigned int ret;\n    ret = *p++;\n    ret |= (*p++ << 8);\n    ret |= (*p++ << 16);\n    ret |= (*p++ << 24);\n    *in = p;\n    return ret;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_422B21(int a1, __WAIT_STATUS a2)\n{\n  __int64 result; // rax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  union wait v7; // edx\n  __pid_t v8; // [rsp+1Ch] [rbp-4h]\n\n  while ( 1 )\n  {\n    v8 = wait3(a2, 0, (struct rusage *)&a2.__uptr[2]);\n    if ( v8 == a1 )\n      break;\n    if ( v8 == -1 && *(_DWORD *)qword_75D400 != 4 )\n      return sub_4091D9((__int64)\"wait\", 0LL, v3, v4, v5, v6);\n  }\n  v7.w_status = sub_40BC94() - a2.__uptr[38].w_status;\n  result = (__int64)a2.__uptr;\n  a2.__uptr[38].w_status = v7.w_status;\n  return result;\n}\n",
        "output": "```c\npid_t wait_for_process(pid_t pid, int *status_out)\n{\n    pid_t wpid;\n    int status;\n    union wait wait_status;\n\n    while (1)\n    {\n        wpid = wait3(&status, 0, NULL);\n        if (wpid == pid)\n            break;\n        if (wpid == -1 && errno != EINTR)\n            return handle_error(\"wait\", 0);\n    }\n    wait_status.w_status = get_status_diff() - status;\n    *status_out = wait_status.w_status;\n    return wpid;\n}\n```",
        "source_code": "static void resuse_end(pid_t pid, resource_t *resp)\n{\n\tpid_t caught;\n\n\t/* Ignore signals, but don't ignore the children.  When wait3\n\t * returns the child process, set the time the command finished. */\n\twhile ((caught = wait3(&resp->waitstatus, 0, &resp->ru)) != pid) {\n\t\tif (caught == -1 && errno != EINTR) {\n\t\t\tbb_perror_msg(\"wait\");\n\t\t\treturn;\n\t\t}\n\t}\n\tresp->elapsed_ms = monotonic_ms() - resp->elapsed_ms;\n}",
        "parsed_output": "pid_t wait_for_process(pid_t pid, int *status_out)\n{\n    pid_t wpid;\n    int status;\n    union wait wait_status;\n\n    while (1)\n    {\n        wpid = wait3(&status, 0, NULL);\n        if (wpid == pid)\n            break;\n        if (wpid == -1 && errno != EINTR)\n            return handle_error(\"wait\", 0);\n    }\n    wait_status.w_status = get_status_diff() - status;\n    *status_out = wait_status.w_status;\n    return wpid;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_422B21(int a1, __WAIT_STATUS a2)\n{\n  __int64 result; // rax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  union wait v7; // edx\n  __pid_t v8; // [rsp+1Ch] [rbp-4h]\n\n  while ( 1 )\n  {\n    v8 = wait3(a2, 0, (struct rusage *)&a2.__uptr[2]);\n    if ( v8 == a1 )\n      break;\n    if ( v8 == -1 && *(_DWORD *)qword_75D400 != 4 )\n      return sub_4091D9((__int64)\"wait\", 0LL, v3, v4, v5, v6);\n  }\n  v7.w_status = sub_40BC94() - a2.__uptr[38].w_status;\n  result = (__int64)a2.__uptr;\n  a2.__uptr[38].w_status = v7.w_status;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl resuse_end(pid_t pid, resource_t *resp)\n{\n  __pid_t caught; // [rsp+1Ch] [rbp-4h]\n\n  while ( 1 )\n  {\n    caught = wait3((__WAIT_STATUS)resp, 0, &resp->ru);\n    if ( caught == pid )\n      break;\n    if ( caught == -1 && *bb_errno != 4 )\n    {\n      bb_perror_msg(\"wait\");\n      return;\n    }\n  }\n  resp->elapsed_ms = monotonic_ms() - resp->elapsed_ms;\n}\n",
        "similarity_score_unixcoder": 0.7218877077102661,
        "similarity_score_baseline_stripped": 0.6460787653923035,
        "similarity_score_baseline_debug": 0.883979856967926
    },
    {
        "func_name": "letcmd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BOOL8 __fastcall sub_47EDCB(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 *v7; // [rsp+0h] [rbp-20h]\n  __int64 v8; // [rsp+18h] [rbp-8h]\n\n  v7 = (__int64 *)(a2 + 8);\n  if ( !*(_QWORD *)(a2 + 8) )\n    sub_46E473(\"expression expected\", a2, a3, a4, a5, a6);\n  do\n    v8 = sub_473BC5(*v7++);\n  while ( *v7 );\n  return v8 == 0;\n}\n",
        "output": "```c\nbool sub_47EDCB(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6)\n{\n    int64_t *expressions = (int64_t *)(a2 + 8);\n    int64_t lastResult;\n\n    if (!*expressions)\n        sub_46E473(\"expression expected\", a2, a3, a4, a5, a6);\n\n    do {\n        lastResult = sub_473BC5(*expressions++);\n    } while (*expressions);\n\n    return lastResult == 0;\n}\n```",
        "source_code": "static int FAST_FUNC\nletcmd(int argc UNUSED_PARAM, char **argv)\n{\n\tarith_t i;\n\n\targv++;\n\tif (!*argv)\n\t\tash_msg_and_raise_error(\"expression expected\");\n\tdo {\n\t\ti = ash_arith(*argv);\n\t} while (*++argv);\n\n\treturn !i;\n}",
        "parsed_output": "bool sub_47EDCB(int64_t a1, int64_t a2, int64_t a3, int64_t a4, int64_t a5, int64_t a6)\n{\n    int64_t *expressions = (int64_t *)(a2 + 8);\n    int64_t lastResult;\n\n    if (!*expressions)\n        sub_46E473(\"expression expected\", a2, a3, a4, a5, a6);\n\n    do {\n        lastResult = sub_473BC5(*expressions++);\n    } while (*expressions);\n\n    return lastResult == 0;\n}",
        "baseline_code_stripped": "_BOOL8 __fastcall sub_47EDCB(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 *v7; // [rsp+0h] [rbp-20h]\n  __int64 v8; // [rsp+18h] [rbp-8h]\n\n  v7 = (__int64 *)(a2 + 8);\n  if ( !*(_QWORD *)(a2 + 8) )\n    sub_46E473(\"expression expected\", a2, a3, a4, a5, a6);\n  do\n    v8 = sub_473BC5(*v7++);\n  while ( *v7 );\n  return v8 == 0;\n}\n",
        "baseline_code_debug": "int __cdecl letcmd(int argc, char **argv)\n{\n  char **argva; // [rsp+0h] [rbp-20h]\n  arith_t i; // [rsp+18h] [rbp-8h]\n\n  argva = argv + 1;\n  if ( !argv[1] )\n    ash_msg_and_raise_error(\"expression expected\");\n  do\n    i = ash_arith(*argva++);\n  while ( *argva );\n  return i == 0;\n}\n",
        "similarity_score_unixcoder": 0.6046208739280701,
        "similarity_score_baseline_stripped": 0.502423882484436,
        "similarity_score_baseline_debug": 0.8683790564537048
    },
    {
        "func_name": "new_node",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl bn_sqr_words(unsigned __int64 *r, const unsigned __int64 *a, int n)\n{\n  int na; // [rsp+0h] [rbp-44h]\n\n  na = n;\n  if ( n > 0 )\n  {\n    while ( (na & 0xFFFFFFFC) != 0 )\n    {\n      *(_OWORD *)r = *a * (unsigned __int128)*a;\n      *((_OWORD *)r + 1) = a[1] * (unsigned __int128)a[1];\n      *((_OWORD *)r + 2) = a[2] * (unsigned __int128)a[2];\n      *((_OWORD *)r + 3) = a[3] * (unsigned __int128)a[3];\n      a += 4;\n      r += 8;\n      na -= 4;\n    }\n    while ( na )\n    {\n      *(_OWORD *)r = *a * (unsigned __int128)*a;\n      ++a;\n      r += 2;\n      --na;\n    }\n  }\n}\n\n\n Revised code:\nvoid bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)\n{\n    assert(n >= 0);\n    if (n <= 0)\n        return;\n\n# ifndef OPENSSL_SMALL_FOOTPRINT\n    while (n & ~3) {\n        sqr(r[0], r[1], a[0]);\n        sqr(r[2], r[3], a[1]);\n        sqr(r[4], r[5], a[2]);\n        sqr(r[6], r[7], a[3]);\n        a += 4;\n        r += 8;\n        n -= 4;\n    }\n# endif\n    while (n) {\n        sqr(r[0], r[1], a[0]);\n        a++;\n        r += 2;\n        n--;\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl BN_sub_word(BIGNUM *a, unsigned __int64 w)\n{\n  int result; // eax\n  unsigned __int64 wa; // [rsp+0h] [rbp-20h]\n  int i; // [rsp+1Ch] [rbp-4h]\n  int ia; // [rsp+1Ch] [rbp-4h]\n\n  wa = w;\n  if ( !w )\n    return 1;\n  if ( a->top )\n  {\n    if ( a->neg )\n    {\n      a->neg = 0;\n      result = BN_add_word(a, w);\n      a->neg = 1;\n    }\n    else if ( a->top == 1 && w > *a->d )\n    {\n      *a->d = w - *a->d;\n      a->neg = 1;\n      return 1;\n    }\n    else\n    {\n      for ( ia = 0; wa > a->d[ia]; ++ia )\n      {\n        a->d[ia] -= wa;\n        wa = 1LL;\n      }\n      a->d[ia] -= wa;\n      if ( !a->d[ia] && ia == a->top - 1 )\n        --a->top;\n      return 1;\n    }\n  }\n  else\n  {\n    i = BN_set_word(a, w);\n    if ( i )\n      BN_set_negative(a, 1);\n    return i;\n  }\n  return result;\n}\n\n\n Revised code:\nint BN_sub_word(BIGNUM *a, BN_ULONG w)\n{\n    int i;\n\n    bn_check_top(a);\n    w &= BN_MASK2;\n\n    /* degenerate case: w is zero */\n    if (!w)\n        return 1;\n    /* degenerate case: a is zero */\n    if (BN_is_zero(a)) {\n        i = BN_set_word(a, w);\n        if (i != 0)\n            BN_set_negative(a, 1);\n        return i;\n    }\n    /* handle 'a' when negative */\n    if (a->neg) {\n        a->neg = 0;\n        i = BN_add_word(a, w);\n        a->neg = 1;\n        return (i);\n    }\n\n    if ((a->top == 1) && (a->d[0] < w)) {\n        a->d[0] = w - a->d[0];\n        a->neg = 1;\n        return (1);\n    }\n    i = 0;\n    for (;;) {\n        if (a->d[i] >= w) {\n            a->d[i] -= w;\n            break;\n        } else {\n            a->d[i] = (a->d[i] - w) & BN_MASK2;\n            i++;\n            w = 1;\n        }\n    }\n    if ((a->d[i] == 0) && (i == (a->top - 1)))\n        a->top--;\n    bn_check_top(a);\n    return (1);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_DWORD *__fastcall sub_4DD854(int a1, __int64 a2)\n{\n  _DWORD *result; // rax\n\n  result = sub_40A0E8(0x20uLL, a2);\n  *result = a1;\n  result[1] = *((_DWORD *)qword_75D408 - 14);\n  return result;\n}\n",
        "output": "```c\nDWORD *sub_4DD854(int value, __int64 allocatorContext)\n{\n    DWORD *allocatedMemory;\n\n    allocatedMemory = allocateMemory(0x20, allocatorContext);\n    *allocatedMemory = value;\n    allocatedMemory[1] = globalVariable;\n    return allocatedMemory;\n}\n```",
        "source_code": "static node *new_node(uint32_t info)\n{\n\tnode *n;\n\n\tn = xzalloc(sizeof(node));\n\tn->info = info;\n\tn->lineno = g_lineno;\n\treturn n;\n}",
        "parsed_output": "DWORD *sub_4DD854(int value, __int64 allocatorContext)\n{\n    DWORD *allocatedMemory;\n\n    allocatedMemory = allocateMemory(0x20, allocatorContext);\n    *allocatedMemory = value;\n    allocatedMemory[1] = globalVariable;\n    return allocatedMemory;\n}",
        "baseline_code_stripped": "_DWORD *__fastcall sub_4DD854(int a1, __int64 a2)\n{\n  _DWORD *result; // rax\n\n  result = sub_40A0E8(0x20uLL, a2);\n  *result = a1;\n  result[1] = *((_DWORD *)qword_75D408 - 14);\n  return result;\n}\n",
        "baseline_code_debug": "node_0 *__cdecl new_node(uint32_t info)\n{\n  node_0 *result; // rax\n\n  result = (node_0 *)xzalloc(0x20uLL);\n  result->info = info;\n  result->lineno = *(_DWORD *)&ptr_to_globals[-1].line_buf[76];\n  return result;\n}\n",
        "similarity_score_unixcoder": 0.41207727789878845,
        "similarity_score_baseline_stripped": 0.44061926007270813,
        "similarity_score_baseline_debug": 0.8144229650497437
    },
    {
        "func_name": "store_param",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4F37C9(__int64 a1)\n{\n  __int64 v1; // rsi\n  int v2; // eax\n  _QWORD *v3; // rdx\n  __int64 result; // rax\n\n  if ( !(unsigned __int8)*(_DWORD *)&dest.c_line )\n    *(_QWORD *)&dest.c_iflag = sub_40A09E(*(void **)&dest.c_iflag, 8LL * (*(_DWORD *)&dest.c_line + 256));\n  v1 = *(_QWORD *)&dest.c_iflag;\n  v2 = *(_DWORD *)&dest.c_line;\n  *(_DWORD *)&dest.c_line = v2 + 1;\n  v3 = (_QWORD *)(v1 + 8LL * v2);\n  result = a1;\n  *v3 = a1;\n  return result;\n}\n",
        "output": "```c\nlong sub_4F37C9(long a1)\n{\n    static long *buffer = NULL;\n    static int index = 0;\n\n    if (buffer == NULL)\n        buffer = (long *)sub_40A09E(&buffer, 2048 * sizeof(long));\n\n    buffer[index++] = a1;\n\n    return a1;\n}\n```",
        "source_code": "static void store_param(char *s)\n{\n\t/* Grow by 256 elements at once */\n\tif (!(G.idx & 0xff)) { /* G.idx == N*256 */\n\t\t/* Enlarge, make G.args[(N+1)*256 - 1] last valid idx */\n\t\tG.args = xrealloc(G.args, sizeof(G.args[0]) * (G.idx + 0x100));\n\t}\n\tG.args[G.idx++] = s;\n}",
        "parsed_output": "long sub_4F37C9(long a1)\n{\n    static long *buffer = NULL;\n    static int index = 0;\n\n    if (buffer == NULL)\n        buffer = (long *)sub_40A09E(&buffer, 2048 * sizeof(long));\n\n    buffer[index++] = a1;\n\n    return a1;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4F37C9(__int64 a1)\n{\n  __int64 v1; // rsi\n  int v2; // eax\n  _QWORD *v3; // rdx\n  __int64 result; // rax\n\n  if ( !(unsigned __int8)*(_DWORD *)&dest.c_line )\n    *(_QWORD *)&dest.c_iflag = sub_40A09E(*(void **)&dest.c_iflag, 8LL * (*(_DWORD *)&dest.c_line + 256));\n  v1 = *(_QWORD *)&dest.c_iflag;\n  v2 = *(_DWORD *)&dest.c_line;\n  *(_DWORD *)&dest.c_line = v2 + 1;\n  v3 = (_QWORD *)(v1 + 8LL * v2);\n  result = a1;\n  *v3 = a1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl store_param(char *s)\n{\n  __int64 v1; // rsi\n  int v2; // eax\n\n  if ( !(unsigned __int8)*(_DWORD *)&bb_common_bufsiz1.c_line )\n    *(_QWORD *)&bb_common_bufsiz1.c_iflag = xrealloc(\n                                              *(void **)&bb_common_bufsiz1.c_iflag,\n                                              8LL * (*(_DWORD *)&bb_common_bufsiz1.c_line + 256));\n  v1 = *(_QWORD *)&bb_common_bufsiz1.c_iflag;\n  v2 = *(_DWORD *)&bb_common_bufsiz1.c_line;\n  *(_DWORD *)&bb_common_bufsiz1.c_line = v2 + 1;\n  *(_QWORD *)(v1 + 8LL * v2) = s;\n}\n",
        "similarity_score_unixcoder": 0.5252724289894104,
        "similarity_score_baseline_stripped": 0.41945359110832214,
        "similarity_score_baseline_debug": 0.5844400525093079
    },
    {
        "func_name": "die_if_ferror",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n\n## Example:\n\n Input code:\nint __cdecl BIO_socket_ioctl(int fd, __int64 type, void *arg)\n{\n  int *v3; // rax\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  i = ioctl(fd, type, arg);\n  if ( i < 0 )\n  {\n    v3 = __errno_location();\n    ERR_put_error(2, 5, *v3, \"b_sock.c\", 580);\n  }\n  return i;\n}\n\n\n Revised code:\n70000000\n\nint BIO_socket_ioctl(int fd, long type, void *arg)\n{\n    int i;\n\n#  ifdef __DJGPP__\n    i = ioctlsocket(fd, type, (char *)arg);\n#  else\n#   if defined(OPENSSL_SYS_VMS)\n    /*-\n     * 2011-02-18 SMS.\n     * VMS ioctl() can't tolerate a 64-bit \"void *arg\", but we\n     * observe that all the consumers pass in an \"unsigned long *\",\n     * so we arrange a local copy with a short pointer, and use\n     * that, instead.\n     */\n#    if __INITIAL_POINTER_SIZE == 64\n#     define ARG arg_32p\n#     pragma pointer_size save\n#     pragma pointer_size 32\n    unsigned long arg_32;\n    unsigned long *arg_32p;\n#     pragma pointer_size restore\n    arg_32p = &arg_32;\n    arg_32 = *((unsigned long *)arg);\n#    else                       /* __INITIAL_POINTER_SIZE == 64 */\n#     define ARG arg\n#    endif                      /* __INITIAL_POINTER_SIZE == 64 [else] */\n#   else                        /* defined(OPENSSL_SYS_VMS) */\n#    define ARG arg\n#   endif                       /* defined(OPENSSL_SYS_VMS) [else] */\n\n    i = ioctlsocket(fd, type, ARG);\n#  endif                        /* __DJGPP__ */\n    if (i < 0)\n        SYSerr(SYS_F_IOCTLSOCKET, get_last_socket_error());\n    return (i);\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_40A5F5(FILE *a1, __int64 a2)\n{\n  int result; // eax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n\n  result = ferror(a1);\n  if ( result )\n    sub_40969E(\"%s: I/O error\", a2, v3, v4, v5, v6);\n  return result;\n}\n",
        "output": "int check_and_report_io_error(FILE *file, const char *message)\n{\n    if (ferror(file))\n    {\n        fprintf(stderr, \"%s: I/O error\\n\", message);\n        return 1;\n    }\n    return 0;\n}",
        "source_code": "void FAST_FUNC die_if_ferror(FILE *fp, const char *fn)\n{\n\tif (ferror(fp)) {\n\t\t/* ferror doesn't set useful errno */\n\t\tbb_error_msg_and_die(\"%s: I/O error\", fn);\n\t}\n}",
        "parsed_output": "int check_and_report_io_error(FILE *file, const char *message)\n{\n    if (ferror(file))\n    {\n        fprintf(stderr, \"%s: I/O error\\n\", message);\n        return 1;\n    }\n    return 0;\n}",
        "baseline_code_stripped": "int __fastcall sub_40A5F5(FILE *a1, __int64 a2)\n{\n  int result; // eax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n\n  result = ferror(a1);\n  if ( result )\n    sub_40969E(\"%s: I/O error\", a2, v3, v4, v5, v6);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl die_if_ferror(FILE *fp, const char *fn)\n{\n  if ( ferror(fp) )\n    bb_error_msg_and_die(\"%s: I/O error\", fn);\n}\n",
        "similarity_score_unixcoder": 0.7780043482780457,
        "similarity_score_baseline_stripped": 0.5729091763496399,
        "similarity_score_baseline_debug": 0.9314379096031189
    },
    {
        "func_name": "setarch_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint BIO_printf(BIO *bio, const char *format, ...)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list args; // [rsp+10h] [rbp-D0h] BYREF\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(args, format);\n  v2 = va_arg(args, _QWORD);\n  v3 = va_arg(args, _QWORD);\n  v4 = va_arg(args, _QWORD);\n  v5 = va_arg(args, _QWORD);\n  v8 = v2;\n  v9 = v3;\n  v10 = v4;\n  v11 = v5;\n  args[0].gp_offset = 16;\n  return BIO_vprintf(bio, format, args);\n}\n\n\n Revised code:\nint BIO_printf(BIO *bio, const char *format, ...)\n{\n    va_list args;\n    int ret;\n\n    va_start(args, format);\n\n    ret = BIO_vprintf(bio, format, args);\n\n    va_end(args);\n    return (ret);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall __noreturn sub_4A4B35(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char **argv; // [rsp+0h] [rbp-20h]\n  const char **argva; // [rsp+0h] [rbp-20h]\n  int v9; // [rsp+1Ch] [rbp-4h]\n\n  argv = (char **)a2;\n  if ( *ident == 115 )\n  {\n    if ( *(_QWORD *)(a2 + 8) )\n    {\n      v2 = *(_QWORD *)(a2 + 8);\n      *(_DWORD *)v2 = 1970170220;\n      *(_BYTE *)(v2 + 4) = 120;\n      if ( v2 )\n      {\n        ident = *(char **)(a2 + 8);\n        argv = (char **)(a2 + 8);\n      }\n    }\n  }\n  if ( ident[5] == 54 )\n  {\n    v9 = 0;\n  }\n  else\n  {\n    if ( ident[5] != 51 )\n      sub_407F64(a1);\n    v9 = 8;\n  }\n  argva = (const char **)(argv + 1);\n  if ( !*argva )\n    sub_407F64(a1);\n  if ( personality(v9) >= 0 )\n  {\n    a2 = (__int64)argva;\n    execvp(*argva, (char *const *)argva);\n  }\n  sub_409392((__int64)*argva, a2, v3, v4, v5, v6);\n}\n",
        "output": "```c\nvoid __fastcall __noreturn sub_4A4B35(__int64 a1, __int64 a2)\n{\n    char **argv = (char **)a2;\n    int mode = 0;\n\n    if (*ident == 's') // ASCII value for 's' is 115\n    {\n        __int64 ptr = *(_QWORD *)(a2 + 8);\n        if (ptr)\n        {\n            *(_DWORD *)ptr = 0x756E6547; // ASCII for \"Genu\", little-endian\n            *(_BYTE *)(ptr + 4) = 'x'; // ASCII for 'x'\n            ident = *(char **)(a2 + 8);\n        }\n    }\n\n    if (ident[5] == '6') // ASCII value for '6' is 54\n    {\n        mode = 0;\n    }\n    else\n    {\n        if (ident[5] != '3') // ASCII value for '3' is 51\n            sub_407F64(a1); // Some error handling function\n        mode = 8;\n    }\n\n    const char **nextArg = (const char **)(argv + 1);\n    if (!*nextArg)\n        sub_407F64(a1); // Some error handling function\n\n    if (personality(mode) >= 0)\n    {\n        execvp(*nextArg, (char *const *)nextArg);\n    }\n\n    // Error handling or alternative execution path\n    sub_409392((__int64)*nextArg, a2, 0, 0, 0, 0); // Removed unused variables\n}\n```",
        "source_code": "int setarch_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint pers;\n\n\t/* Figure out what personality we are supposed to switch to ...\n\t * we can be invoked as either:\n\t * argv[0],argv[1] == \"setarch\",\"personality\"\n\t * argv[0]         == \"personality\"\n\t */\n\tif (ENABLE_SETARCH && applet_name[0] == 's'\n\t && argv[1] && strncpy(argv[1], \"linux\", 5)\n\t) {\n\t\tapplet_name = argv[1];\n\t\targv++;\n\t}\n\tif (applet_name[5] == '6') /* linux64 */\n\t\tpers = PER_LINUX;\n\telse if (applet_name[5] == '3') /* linux32 */\n\t\tpers = PER_LINUX32;\n\telse\n\t\tbb_show_usage();\n\n\targv++;\n\tif (argv[0] == NULL)\n\t\tbb_show_usage();\n\n\t/* Try to set personality */\n\tif (personality(pers) >= 0) {\n\t\t/* Try to execute the program */\n\t\tBB_EXECVP(argv[0], argv);\n\t}\n\n\tbb_simple_perror_msg_and_die(argv[0]);\n}",
        "parsed_output": "void __fastcall __noreturn sub_4A4B35(__int64 a1, __int64 a2)\n{\n    char **argv = (char **)a2;\n    int mode = 0;\n\n    if (*ident == 's') // ASCII value for 's' is 115\n    {\n        __int64 ptr = *(_QWORD *)(a2 + 8);\n        if (ptr)\n        {\n            *(_DWORD *)ptr = 0x756E6547; // ASCII for \"Genu\", little-endian\n            *(_BYTE *)(ptr + 4) = 'x'; // ASCII for 'x'\n            ident = *(char **)(a2 + 8);\n        }\n    }\n\n    if (ident[5] == '6') // ASCII value for '6' is 54\n    {\n        mode = 0;\n    }\n    else\n    {\n        if (ident[5] != '3') // ASCII value for '3' is 51\n            sub_407F64(a1); // Some error handling function\n        mode = 8;\n    }\n\n    const char **nextArg = (const char **)(argv + 1);\n    if (!*nextArg)\n        sub_407F64(a1); // Some error handling function\n\n    if (personality(mode) >= 0)\n    {\n        execvp(*nextArg, (char *const *)nextArg);\n    }\n\n    // Error handling or alternative execution path\n    sub_409392((__int64)*nextArg, a2, 0, 0, 0, 0); // Removed unused variables\n}",
        "baseline_code_stripped": "void __fastcall __noreturn sub_4A4B35(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char **argv; // [rsp+0h] [rbp-20h]\n  const char **argva; // [rsp+0h] [rbp-20h]\n  int v9; // [rsp+1Ch] [rbp-4h]\n\n  argv = (char **)a2;\n  if ( *ident == 115 )\n  {\n    if ( *(_QWORD *)(a2 + 8) )\n    {\n      v2 = *(_QWORD *)(a2 + 8);\n      *(_DWORD *)v2 = 1970170220;\n      *(_BYTE *)(v2 + 4) = 120;\n      if ( v2 )\n      {\n        ident = *(char **)(a2 + 8);\n        argv = (char **)(a2 + 8);\n      }\n    }\n  }\n  if ( ident[5] == 54 )\n  {\n    v9 = 0;\n  }\n  else\n  {\n    if ( ident[5] != 51 )\n      sub_407F64(a1);\n    v9 = 8;\n  }\n  argva = (const char **)(argv + 1);\n  if ( !*argva )\n    sub_407F64(a1);\n  if ( personality(v9) >= 0 )\n  {\n    a2 = (__int64)argva;\n    execvp(*argva, (char *const *)argva);\n  }\n  sub_409392((__int64)*argva, a2, v3, v4, v5, v6);\n}\n",
        "baseline_code_debug": "int __cdecl __noreturn setarch_main(int argc, char **argv)\n{\n  char *v2; // rax\n  char **argva; // [rsp+0h] [rbp-20h]\n  const char **argvb; // [rsp+0h] [rbp-20h]\n  int pers; // [rsp+1Ch] [rbp-4h]\n\n  argva = argv;\n  if ( *applet_name == 115 )\n  {\n    if ( argv[1] )\n    {\n      v2 = argv[1];\n      *(_DWORD *)v2 = 1970170220;\n      v2[4] = 120;\n      if ( v2 )\n      {\n        applet_name = argv[1];\n        argva = argv + 1;\n      }\n    }\n  }\n  if ( applet_name[5] == 54 )\n  {\n    pers = 0;\n  }\n  else\n  {\n    if ( applet_name[5] != 51 )\n      bb_show_usage();\n    pers = 8;\n  }\n  argvb = (const char **)(argva + 1);\n  if ( !*argvb )\n    bb_show_usage();\n  if ( personality(pers) >= 0 )\n    execvp(*argvb, (char *const *)argvb);\n  bb_simple_perror_msg_and_die(*argvb);\n}\n",
        "similarity_score_unixcoder": 0.6878557801246643,
        "similarity_score_baseline_stripped": 0.6175282001495361,
        "similarity_score_baseline_debug": 0.8468164205551147
    },
    {
        "func_name": "sizenodelist",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl bn_sqr_words(unsigned __int64 *r, const unsigned __int64 *a, int n)\n{\n  int na; // [rsp+0h] [rbp-44h]\n\n  na = n;\n  if ( n > 0 )\n  {\n    while ( (na & 0xFFFFFFFC) != 0 )\n    {\n      *(_OWORD *)r = *a * (unsigned __int128)*a;\n      *((_OWORD *)r + 1) = a[1] * (unsigned __int128)a[1];\n      *((_OWORD *)r + 2) = a[2] * (unsigned __int128)a[2];\n      *((_OWORD *)r + 3) = a[3] * (unsigned __int128)a[3];\n      a += 4;\n      r += 8;\n      na -= 4;\n    }\n    while ( na )\n    {\n      *(_OWORD *)r = *a * (unsigned __int128)*a;\n      ++a;\n      r += 2;\n      --na;\n    }\n  }\n}\n\n\n Revised code:\nvoid bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)\n{\n    assert(n >= 0);\n    if (n <= 0)\n        return;\n\n# ifndef OPENSSL_SMALL_FOOTPRINT\n    while (n & ~3) {\n        sqr(r[0], r[1], a[0]);\n        sqr(r[2], r[3], a[1]);\n        sqr(r[4], r[5], a[2]);\n        sqr(r[6], r[7], a[3]);\n        a += 4;\n        r += 8;\n        n -= 4;\n    }\n# endif\n    while (n) {\n        sqr(r[0], r[1], a[0]);\n        a++;\n        r += 2;\n        n--;\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl BN_sub_word(BIGNUM *a, unsigned __int64 w)\n{\n  int result; // eax\n  unsigned __int64 wa; // [rsp+0h] [rbp-20h]\n  int i; // [rsp+1Ch] [rbp-4h]\n  int ia; // [rsp+1Ch] [rbp-4h]\n\n  wa = w;\n  if ( !w )\n    return 1;\n  if ( a->top )\n  {\n    if ( a->neg )\n    {\n      a->neg = 0;\n      result = BN_add_word(a, w);\n      a->neg = 1;\n    }\n    else if ( a->top == 1 && w > *a->d )\n    {\n      *a->d = w - *a->d;\n      a->neg = 1;\n      return 1;\n    }\n    else\n    {\n      for ( ia = 0; wa > a->d[ia]; ++ia )\n      {\n        a->d[ia] -= wa;\n        wa = 1LL;\n      }\n      a->d[ia] -= wa;\n      if ( !a->d[ia] && ia == a->top - 1 )\n        --a->top;\n      return 1;\n    }\n  }\n  else\n  {\n    i = BN_set_word(a, w);\n    if ( i )\n      BN_set_negative(a, 1);\n    return i;\n  }\n  return result;\n}\n\n\n Revised code:\nint BN_sub_word(BIGNUM *a, BN_ULONG w)\n{\n    int i;\n\n    bn_check_top(a);\n    w &= BN_MASK2;\n\n    /* degenerate case: w is zero */\n    if (!w)\n        return 1;\n    /* degenerate case: a is zero */\n    if (BN_is_zero(a)) {\n        i = BN_set_word(a, w);\n        if (i != 0)\n            BN_set_negative(a, 1);\n        return i;\n    }\n    /* handle 'a' when negative */\n    if (a->neg) {\n        a->neg = 0;\n        i = BN_add_word(a, w);\n        a->neg = 1;\n        return (i);\n    }\n\n    if ((a->top == 1) && (a->d[0] < w)) {\n        a->d[0] = w - a->d[0];\n        a->neg = 1;\n        return (1);\n    }\n    i = 0;\n    for (;;) {\n        if (a->d[i] >= w) {\n            a->d[i] -= w;\n            break;\n        } else {\n            a->d[i] = (a->d[i] - w) & BN_MASK2;\n            i++;\n            w = 1;\n        }\n    }\n    if ((a->d[i] == 0) && (i == (a->top - 1)))\n        a->top--;\n    bn_check_top(a);\n    return (1);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl bn_sqr_normal(unsigned __int64 *r, const unsigned __int64 *a, int n, unsigned __int64 *tmp)\n{\n  unsigned __int64 *v4; // rax\n  int max; // [rsp+24h] [rbp-2Ch]\n  unsigned __int64 *rp; // [rsp+28h] [rbp-28h]\n  const unsigned __int64 *ap; // [rsp+30h] [rbp-20h]\n  int j; // [rsp+38h] [rbp-18h]\n  int i; // [rsp+3Ch] [rbp-14h]\n\n  max = 2 * n;\n  ap = a;\n  v4 = &r[2 * n - 1];\n  *v4 = 0LL;\n  *r = *v4;\n  rp = r + 1;\n  j = n - 1;\n  if ( n - 1 > 0 )\n  {\n    ap = a + 1;\n    rp[j] = bn_mul_words(rp, a + 1, j, *a);\n    rp = r + 3;\n  }\n  for ( i = n - 2; i > 0; --i )\n  {\n    --j;\n    ++ap;\n    rp[j] = bn_mul_add_words(rp, ap, j, *(ap - 1));\n    rp += 2;\n  }\n  bn_add_words(r, r, r, max);\n  bn_sqr_words(tmp, a, n);\n  bn_add_words(r, r, tmp, max);\n}\n\n\n Revised code:\nvoid bn_sqr_normal(BN_ULONG *r, const BN_ULONG *a, int n, BN_ULONG *tmp)\n{\n    int i, j, max;\n    const BN_ULONG *ap;\n    BN_ULONG *rp;\n\n    max = n * 2;\n    ap = a;\n    rp = r;\n    rp[0] = rp[max - 1] = 0;\n    rp++;\n    j = n;\n\n    if (--j > 0) {\n        ap++;\n        rp[j] = bn_mul_words(rp, ap, j, ap[-1]);\n        rp += 2;\n    }\n\n    for (i = n - 2; i > 0; i--) {\n        j--;\n        ap++;\n        rp[j] = bn_mul_add_words(rp, ap, j, ap[-1]);\n        rp += 2;\n    }\n\n    bn_add_words(r, r, r, max);\n\n    /* There will not be a carry */\n\n    bn_sqr_words(tmp, a, n);\n\n    bn_add_words(r, r, tmp, max);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_QWORD *__fastcall sub_4778AA(_QWORD *a1)\n{\n  _QWORD *result; // rax\n\n  while ( a1 )\n  {\n    dword_75B028 += 16;\n    sub_4778EC(a1[1]);\n    result = (_QWORD *)*a1;\n    a1 = (_QWORD *)*a1;\n  }\n  return result;\n}\n",
        "output": "```c\nvoid processList(Node *head)\n{\n    while (head != NULL)\n    {\n        counter += 16;\n        processNode(head->next);\n        head = head->next;\n    }\n}\n```",
        "source_code": "static void\nsizenodelist(struct nodelist *lp)\n{\n\twhile (lp) {\n\t\tfuncblocksize += SHELL_ALIGN(sizeof(struct nodelist));\n\t\tcalcsize(lp->n);\n\t\tlp = lp->next;\n\t}\n}",
        "parsed_output": "void processList(Node *head)\n{\n    while (head != NULL)\n    {\n        counter += 16;\n        processNode(head->next);\n        head = head->next;\n    }\n}",
        "baseline_code_stripped": "_QWORD *__fastcall sub_4778AA(_QWORD *a1)\n{\n  _QWORD *result; // rax\n\n  while ( a1 )\n  {\n    dword_75B028 += 16;\n    sub_4778EC(a1[1]);\n    result = (_QWORD *)*a1;\n    a1 = (_QWORD *)*a1;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl sizenodelist(nodelist *lp)\n{\n  while ( lp )\n  {\n    funcblocksize += 16;\n    calcsize(lp->n);\n    lp = lp->next;\n  }\n}\n",
        "similarity_score_unixcoder": 0.677453339099884,
        "similarity_score_baseline_stripped": 0.44704699516296387,
        "similarity_score_baseline_debug": 0.9018113613128662
    },
    {
        "func_name": "format_address_paren",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nint __cdecl BN_sub_word(BIGNUM *a, unsigned __int64 w)\n{\n  int result; // eax\n  unsigned __int64 wa; // [rsp+0h] [rbp-20h]\n  int i; // [rsp+1Ch] [rbp-4h]\n  int ia; // [rsp+1Ch] [rbp-4h]\n\n  wa = w;\n  if ( !w )\n    return 1;\n  if ( a->top )\n  {\n    if ( a->neg )\n    {\n      a->neg = 0;\n      result = BN_add_word(a, w);\n      a->neg = 1;\n    }\n    else if ( a->top == 1 && w > *a->d )\n    {\n      *a->d = w - *a->d;\n      a->neg = 1;\n      return 1;\n    }\n    else\n    {\n      for ( ia = 0; wa > a->d[ia]; ++ia )\n      {\n        a->d[ia] -= wa;\n        wa = 1LL;\n      }\n      a->d[ia] -= wa;\n      if ( !a->d[ia] && ia == a->top - 1 )\n        --a->top;\n      return 1;\n    }\n  }\n  else\n  {\n    i = BN_set_word(a, w);\n    if ( i )\n      BN_set_negative(a, 1);\n    return i;\n  }\n  return result;\n}\n\n\n Revised code:\nint BN_sub_word(BIGNUM *a, BN_ULONG w)\n{\n    int i;\n\n    bn_check_top(a);\n    w &= BN_MASK2;\n\n    /* degenerate case: w is zero */\n    if (!w)\n        return 1;\n    /* degenerate case: a is zero */\n    if (BN_is_zero(a)) {\n        i = BN_set_word(a, w);\n        if (i != 0)\n            BN_set_negative(a, 1);\n        return i;\n    }\n    /* handle 'a' when negative */\n    if (a->neg) {\n        a->neg = 0;\n        i = BN_add_word(a, w);\n        a->neg = 1;\n        return (i);\n    }\n\n    if ((a->top == 1) && (a->d[0] < w)) {\n        a->d[0] = w - a->d[0];\n        a->neg = 1;\n        return (1);\n    }\n    i = 0;\n    for (;;) {\n        if (a->d[i] >= w) {\n            a->d[i] -= w;\n            break;\n        } else {\n            a->d[i] = (a->d[i] - w) & BN_MASK2;\n            i++;\n            w = 1;\n        }\n    }\n    if ((a->d[i] == 0) && (i == (a->top - 1)))\n        a->top--;\n    bn_check_top(a);\n    return (1);\n}\n\n## Example:\n\n Input code:\nint __cdecl BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\n{\n  int result; // eax\n  const BIGNUM *ba; // [rsp+8h] [rbp-38h]\n  const BIGNUM *aa; // [rsp+10h] [rbp-30h]\n  int a_neg; // [rsp+3Ch] [rbp-4h]\n\n  aa = a;\n  ba = b;\n  a_neg = a->neg;\n  if ( a_neg == b->neg )\n  {\n    result = BN_uadd(r, a, b);\n    r->neg = a_neg;\n  }\n  else\n  {\n    if ( a_neg )\n    {\n      aa = b;\n      ba = a;\n    }\n    if ( BN_ucmp(aa, ba) >= 0 )\n    {\n      if ( !BN_usub(r, aa, ba) )\n        return 0;\n      r->neg = 0;\n    }\n    else\n    {\n      if ( !BN_usub(r, ba, aa) )\n        return 0;\n      r->neg = 1;\n    }\n    return 1;\n  }\n  return result;\n}\n\n\n Revised code:\nint BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b)\n{\n    const BIGNUM *tmp;\n    int a_neg = a->neg, ret;\n\n    bn_check_top(a);\n    bn_check_top(b);\n\n    /*-\n     *  a +  b      a+b\n     *  a + -b      a-b\n     * -a +  b      b-a\n     * -a + -b      -(a+b)\n     */\n    if (a_neg ^ b->neg) {\n        /* only one is negative */\n        if (a_neg) {\n            tmp = a;\n            a = b;\n            b = tmp;\n        }\n\n        /* we are now a - b */\n\n        if (BN_ucmp(a, b) < 0) {\n            if (!BN_usub(r, b, a))\n                return (0);\n            r->neg = 1;\n        } else {\n            if (!BN_usub(r, a, b))\n                return (0);\n            r->neg = 0;\n        }\n        return (1);\n    }\n\n    ret = BN_uadd(r, a, b);\n    r->neg = a_neg;\n    bn_check_top(r);\n    return ret;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_4CE8EF(__int64 a1, char a2)\n{\n  int result; // eax\n\n  putchar_unlocked(40);\n  result = sub_4CE8BB(a1, 41);\n  if ( a2 )\n    return putchar_unlocked(a2);\n  return result;\n}\n",
        "output": "int print_with_parentheses(__int64 value, char delimiter)\n{\n    putchar_unlocked('(');\n    int result = print_value_and_close_paren(value);\n    if (delimiter)\n        return putchar_unlocked(delimiter);\n    return result;\n}",
        "source_code": "static void\nformat_address_paren(off_t address, char c)\n{\n\tputchar('(');\n\tformat_address_std(address, ')');\n\tif (c) putchar(c);\n}",
        "parsed_output": "int print_with_parentheses(__int64 value, char delimiter)\n{\n    putchar_unlocked('(');\n    int result = print_value_and_close_paren(value);\n    if (delimiter)\n        return putchar_unlocked(delimiter);\n    return result;\n}",
        "baseline_code_stripped": "int __fastcall sub_4CE8EF(__int64 a1, char a2)\n{\n  int result; // eax\n\n  putchar_unlocked(40);\n  result = sub_4CE8BB(a1, 41);\n  if ( a2 )\n    return putchar_unlocked(a2);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl format_address_paren(off_t address, char c)\n{\n  putchar_unlocked(40);\n  format_address_std(address, 41);\n  if ( c )\n    putchar_unlocked(c);\n}\n",
        "similarity_score_unixcoder": 0.6737856268882751,
        "similarity_score_baseline_stripped": 0.5183325409889221,
        "similarity_score_baseline_debug": 0.8867987394332886
    },
    {
        "func_name": "ifsfree",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl ctr64_add(unsigned __int8 *counter, size_t inc)\n{\n  unsigned __int64 v2; // rdx\n  unsigned __int8 *countera; // [rsp+8h] [rbp-18h]\n  size_t val; // [rsp+10h] [rbp-10h]\n  size_t n; // [rsp+18h] [rbp-8h]\n\n  n = 8LL;\n  val = 0LL;\n  countera = counter + 8;\n  do\n  {\n    v2 = countera[--n] + (unsigned __int64)(unsigned __int8)inc + val;\n    countera[n] = v2;\n    val = v2 >> 8;\n    inc >>= 8;\n  }\n  while ( n && (inc || val) );\n}\n\n\n Revised code:\nstatic void ctr64_add(unsigned char *counter, size_t inc)\n{\n    size_t n = 8, val = 0;\n\n    counter += 8;\n    do {\n        --n;\n        val += counter[n] + (inc & 0xff);\n        counter[n] = (unsigned char)val;\n        val >>= 8;              /* carry bit */\n        inc >>= 8;\n    } while (n && (inc || val));\n}\n\n## Example:\n\n Input code:\nvoid __cdecl write_lebn(unsigned __int8 **out, const BIGNUM *bn, int len)\n{\n  unsigned __int8 *v3; // rax\n  unsigned __int8 *v4; // rax\n  int lenb; // [rsp+Ch] [rbp-34h]\n  unsigned __int8 c; // [rsp+23h] [rbp-1Dh]\n  int nb; // [rsp+24h] [rbp-1Ch]\n  unsigned __int8 *q; // [rsp+28h] [rbp-18h]\n  unsigned __int8 *p; // [rsp+30h] [rbp-10h]\n  int i; // [rsp+3Ch] [rbp-4h]\n\n  p = *out;\n  nb = (BN_num_bits(bn) + 7) / 8;\n  BN_bn2bin(bn, p);\n  q = &p[nb - 1];\n  for ( i = 0; i < nb / 2; ++i )\n  {\n    c = *p;\n    v3 = p++;\n    *v3 = *q;\n    v4 = q--;\n    *v4 = c;\n  }\n  *out += nb;\n  if ( len > 0 )\n  {\n    lenb = len - nb;\n    if ( lenb > 0 )\n    {\n      memset(*out, 0, lenb);\n      *out += lenb;\n    }\n  }\n}\n\n\n Revised code:\nstatic void write_lebn(unsigned char **out, const BIGNUM *bn, int len)\n{\n    int nb, i;\n    unsigned char *p = *out, *q, c;\n    nb = BN_num_bytes(bn);\n    BN_bn2bin(bn, p);\n    q = p + nb - 1;\n    /* In place byte order reversal */\n    for (i = 0; i < nb / 2; i++) {\n        c = *p;\n        *p++ = *q;\n        *q-- = c;\n    }\n    *out += nb;\n    /* Pad with zeroes if we have to */\n    if (len > 0) {\n        len -= nb;\n        if (len > 0) {\n            memset(*out, 0, len);\n            *out += len;\n        }\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4760DE(__int64 a1, __int64 a2)\n{\n  _QWORD *v2; // rdi\n  _QWORD *v4; // [rsp+0h] [rbp-10h]\n  _QWORD *ptr; // [rsp+8h] [rbp-8h]\n\n  ++*(_DWORD *)(qword_75D418 + 48);\n  ptr = qword_75AFE0;\n  do\n  {\n    v4 = (_QWORD *)*ptr;\n    v2 = ptr;\n    free(ptr);\n    ptr = v4;\n  }\n  while ( v4 );\n  qword_75AFF8 = 0LL;\n  qword_75AFE0 = 0LL;\n  return sub_46E03F(v2, a2);\n}\n",
        "output": "```c\nstatic __int64 sub_4760DE(__int64 a1, __int64 a2)\n{\n    _QWORD *current;\n    _QWORD *next;\n\n    ++*(_DWORD *)(qword_75D418 + 48);\n    current = qword_75AFE0;\n    while (current) {\n        next = (_QWORD *)*current;\n        free(current);\n        current = next;\n    }\n    qword_75AFF8 = 0LL;\n    qword_75AFE0 = 0LL;\n    return sub_46E03F(current, a2);\n}\n```",
        "source_code": "static void\nifsfree(void)\n{\n\tstruct ifsregion *p;\n\n\tINT_OFF;\n\tp = ifsfirst.next;\n\tdo {\n\t\tstruct ifsregion *ifsp;\n\t\tifsp = p->next;\n\t\tfree(p);\n\t\tp = ifsp;\n\t} while (p);\n\tifslastp = NULL;\n\tifsfirst.next = NULL;\n\tINT_ON;\n}",
        "parsed_output": "static __int64 sub_4760DE(__int64 a1, __int64 a2)\n{\n    _QWORD *current;\n    _QWORD *next;\n\n    ++*(_DWORD *)(qword_75D418 + 48);\n    current = qword_75AFE0;\n    while (current) {\n        next = (_QWORD *)*current;\n        free(current);\n        current = next;\n    }\n    qword_75AFF8 = 0LL;\n    qword_75AFE0 = 0LL;\n    return sub_46E03F(current, a2);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4760DE(__int64 a1, __int64 a2)\n{\n  _QWORD *v2; // rdi\n  _QWORD *v4; // [rsp+0h] [rbp-10h]\n  _QWORD *ptr; // [rsp+8h] [rbp-8h]\n\n  ++*(_DWORD *)(qword_75D418 + 48);\n  ptr = qword_75AFE0;\n  do\n  {\n    v4 = (_QWORD *)*ptr;\n    v2 = ptr;\n    free(ptr);\n    ptr = v4;\n  }\n  while ( v4 );\n  qword_75AFF8 = 0LL;\n  qword_75AFE0 = 0LL;\n  return sub_46E03F(v2, a2);\n}\n",
        "baseline_code_debug": "void __cdecl ifsfree()\n{\n  ifsregion *ifsp; // [rsp+0h] [rbp-10h]\n  ifsregion *p; // [rsp+8h] [rbp-8h]\n\n  ++ash_ptr_to_globals_misc->suppress_int;\n  p = ifsfirst.next;\n  do\n  {\n    ifsp = p->next;\n    free(p);\n    p = ifsp;\n  }\n  while ( ifsp );\n  ifslastp = 0LL;\n  ifsfirst.next = 0LL;\n  int_on();\n}\n",
        "similarity_score_unixcoder": 0.5121743083000183,
        "similarity_score_baseline_stripped": 0.46128737926483154,
        "similarity_score_baseline_debug": 0.7786923050880432
    },
    {
        "func_name": "dec_stream_footer",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl make_kn(unsigned __int8 *k1_0, unsigned __int8 *l, int bl_0)\n{\n  unsigned __int8 v3; // dl\n  char v4; // al\n  int i; // [rsp+20h] [rbp-4h]\n\n  for ( i = 0; i < bl_0; ++i )\n  {\n    k1_0[i] = 2 * l[i];\n    if ( i < bl_0 - 1 && (l[i + 1] & 0x80u) != 0 )\n      k1_0[i] |= 1u;\n  }\n  if ( (*l & 0x80u) != 0 )\n  {\n    v3 = k1_0[bl_0 - 1];\n    if ( bl_0 == 16 )\n      v4 = -121;\n    else\n      v4 = 27;\n    k1_0[bl_0 - 1] = v3 ^ v4;\n  }\n}\n\n\n Revised code:\nstatic void make_kn(unsigned char *k1, unsigned char *l, int bl)\n{\n    int i;\n    /* Shift block to left, including carry */\n    for (i = 0; i < bl; i++) {\n        k1[i] = l[i] << 1;\n        if (i < bl - 1 && l[i + 1] & 0x80)\n            k1[i] |= 1;\n    }\n    /* If MSB set fixup with R */\n    if (l[0] & 0x80)\n        k1[bl - 1] ^= bl == 16 ? 0x87 : 0x1b;\n}\n\n## Example:\n\n Input code:\nint __cdecl BN_BLINDING_update(BN_BLINDING *b, BN_CTX *ctx)\n{\n  int ret; // [rsp+1Ch] [rbp-4h]\n\n  ret = 0;\n  if ( !b->A || !b->Ai )\n  {\n    ERR_put_error(3, 103, 107, \"bn_blind.c\", 192);\n    goto err;\n  }\n  if ( b->counter == -1 )\n    b->counter = 0;\n  if ( ++b->counter == 32 && b->e && (b->flags & 2) == 0 )\n  {\n    if ( !BN_BLINDING_create_param(b, 0LL, 0LL, ctx, 0LL, 0LL) )\n      goto err;\nLABEL_14:\n    ret = 1;\n    goto err;\n  }\n  if ( (b->flags & 1) != 0 || BN_mod_mul(b->A, b->A, b->A, b->mod, ctx) && BN_mod_mul(b->Ai, b->Ai, b->Ai, b->mod, ctx) )\n    goto LABEL_14;\nerr:\n  if ( b->counter == 32 )\n    b->counter = 0;\n  return ret;\n}\n\n\n Revised code:\nint BN_BLINDING_update(BN_BLINDING *b, BN_CTX *ctx)\n{\n    int ret = 0;\n\n    if ((b->A == NULL) || (b->Ai == NULL)) {\n        BNerr(BN_F_BN_BLINDING_UPDATE, BN_R_NOT_INITIALIZED);\n        goto err;\n    }\n\n    if (b->counter == -1)\n        b->counter = 0;\n\n    if (++b->counter == BN_BLINDING_COUNTER && b->e != NULL &&\n        !(b->flags & BN_BLINDING_NO_RECREATE)) {\n        /* re-create blinding parameters */\n        if (!BN_BLINDING_create_param(b, NULL, NULL, ctx, NULL, NULL))\n            goto err;\n    } else if (!(b->flags & BN_BLINDING_NO_UPDATE)) {\n        if (!BN_mod_mul(b->A, b->A, b->A, b->mod, ctx))\n            goto err;\n        if (!BN_mod_mul(b->Ai, b->Ai, b->Ai, b->mod, ctx))\n            goto err;\n    }\n\n    ret = 1;\n err:\n    if (b->counter == BN_BLINDING_COUNTER)\n        b->counter = 0;\n    return (ret);\n}\n\n## Example:\n\n Input code:\n__int64 __cdecl ASN1_INTEGER_get(const ASN1_INTEGER *a)\n{\n  __int64 r; // [rsp+8h] [rbp-10h]\n  int i; // [rsp+10h] [rbp-8h]\n  int ia; // [rsp+10h] [rbp-8h]\n  int neg; // [rsp+14h] [rbp-4h]\n\n  neg = 0;\n  r = 0LL;\n  if ( !a )\n    return 0LL;\n  i = a->type;\n  if ( i == 258 )\n  {\n    neg = 1;\n  }\n  else if ( i != 2 )\n  {\n    return -1LL;\n  }\n  if ( a->length > 8 )\n    return -1LL;\n  if ( !a->data )\n    return 0LL;\n  for ( ia = 0; ia < a->length; ++ia )\n    r = a->data[ia] | (unsigned __int64)(r << 8);\n  if ( neg )\n    return -r;\n  return r;\n}\n\n\n Revised code:\nlong ASN1_INTEGER_get(const ASN1_INTEGER *a)\n{\n    int neg = 0, i;\n    long r = 0;\n\n    if (a == NULL)\n        return (0L);\n    i = a->type;\n    if (i == V_ASN1_NEG_INTEGER)\n        neg = 1;\n    else if (i != V_ASN1_INTEGER)\n        return -1;\n\n    if (a->length > (int)sizeof(long)) {\n        /* hmm... a bit ugly, return all ones */\n        return -1;\n    }\n    if (a->data == NULL)\n        return 0;\n\n    for (i = 0; i < a->length; i++) {\n        r <<= 8;\n        r |= (unsigned char)a->data[i];\n    }\n    if (neg)\n        r = -r;\n    return (r);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4BF718(__int64 a1)\n{\n  if ( memcmp((const void *)(a1 + 194), &unk_526CB7, 2uLL) )\n    return 7LL;\n  if ( *(_DWORD *)(a1 + 184) != (unsigned int)sub_4BBFB7(a1 + 188, 6u, 0) )\n    return 7LL;\n  if ( *(_QWORD *)(a1 + 128) >> 2 != *(_DWORD *)(a1 + 188) )\n    return 7LL;\n  if ( !*(_BYTE *)(a1 + 192) && *(unsigned __int8 *)(a1 + 193) == *(_DWORD *)(a1 + 36) )\n    return 1LL;\n  return 7LL;\n}\n",
        "output": "```c\nlong check_values(long ptr)\n{\n    // Check if the first two bytes at offset 194 match a known value\n    if (memcmp((const void *)(ptr + 194), &known_value, 2) != 0)\n        return 7;\n\n    // Check if the value at offset 184 matches the result of sub_4BBFB7\n    if (*(unsigned int *)(ptr + 184) != sub_4BBFB7(ptr + 188, 6, 0))\n        return 7;\n\n    // Check if the value at offset 128 shifted right by 2 bits matches the value at offset 188\n    if (*(unsigned long *)(ptr + 128) >> 2 != *(unsigned int *)(ptr + 188))\n        return 7;\n\n    // Check if the byte at offset 192 is zero and the byte at offset 193 matches the value at offset 36\n    if (!*(unsigned char *)(ptr + 192) && *(unsigned char *)(ptr + 193) == *(unsigned int *)(ptr + 36))\n        return 1;\n\n    return 7;\n}\n```",
        "source_code": "static enum xz_ret XZ_FUNC dec_stream_footer(struct xz_dec *s)\n{\n\tif (!memeq(s->temp.buf + 10, FOOTER_MAGIC, FOOTER_MAGIC_SIZE))\n\t\treturn XZ_DATA_ERROR;\n\n\tif (xz_crc32(s->temp.buf + 4, 6, 0) != get_le32(s->temp.buf))\n\t\treturn XZ_DATA_ERROR;\n\n\t/*\n\t * Validate Backward Size. Note that we never added the size of the\n\t * Index CRC32 field to s->index.size, thus we use s->index.size / 4\n\t * instead of s->index.size / 4 - 1.\n\t */\n\tif ((s->index.size >> 2) != get_le32(s->temp.buf + 4))\n\t\treturn XZ_DATA_ERROR;\n\n\tif (s->temp.buf[8] != 0 || s->temp.buf[9] != s->check_type)\n\t\treturn XZ_DATA_ERROR;\n\n\t/*\n\t * Use XZ_STREAM_END instead of XZ_OK to be more convenient\n\t * for the caller.\n\t */\n\treturn XZ_STREAM_END;\n}",
        "parsed_output": "long check_values(long ptr)\n{\n    // Check if the first two bytes at offset 194 match a known value\n    if (memcmp((const void *)(ptr + 194), &known_value, 2) != 0)\n        return 7;\n\n    // Check if the value at offset 184 matches the result of sub_4BBFB7\n    if (*(unsigned int *)(ptr + 184) != sub_4BBFB7(ptr + 188, 6, 0))\n        return 7;\n\n    // Check if the value at offset 128 shifted right by 2 bits matches the value at offset 188\n    if (*(unsigned long *)(ptr + 128) >> 2 != *(unsigned int *)(ptr + 188))\n        return 7;\n\n    // Check if the byte at offset 192 is zero and the byte at offset 193 matches the value at offset 36\n    if (!*(unsigned char *)(ptr + 192) && *(unsigned char *)(ptr + 193) == *(unsigned int *)(ptr + 36))\n        return 1;\n\n    return 7;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4BF718(__int64 a1)\n{\n  if ( memcmp((const void *)(a1 + 194), &unk_526CB7, 2uLL) )\n    return 7LL;\n  if ( *(_DWORD *)(a1 + 184) != (unsigned int)sub_4BBFB7(a1 + 188, 6u, 0) )\n    return 7LL;\n  if ( *(_QWORD *)(a1 + 128) >> 2 != *(_DWORD *)(a1 + 188) )\n    return 7LL;\n  if ( !*(_BYTE *)(a1 + 192) && *(unsigned __int8 *)(a1 + 193) == *(_DWORD *)(a1 + 36) )\n    return 1LL;\n  return 7LL;\n}\n",
        "baseline_code_debug": "xz_ret __cdecl dec_stream_footer(xz_dec *s)\n{\n  if ( memcmp(&s->temp.buf[10], &unk_526CB7, 2uLL) )\n    return 7;\n  if ( *(_DWORD *)s->temp.buf != xz_crc32(&s->temp.buf[4], 6uLL, 0) )\n    return 7;\n  if ( s->index.size >> 2 != *(_DWORD *)&s->temp.buf[4] )\n    return 7;\n  if ( !s->temp.buf[8] && s->temp.buf[9] == s->check_type )\n    return 1;\n  return 7;\n}\n",
        "similarity_score_unixcoder": 0.611922562122345,
        "similarity_score_baseline_stripped": 0.5678178668022156,
        "similarity_score_baseline_debug": 0.8711869716644287
    },
    {
        "func_name": "evalstring",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nunsigned int __cdecl inverse(unsigned int xin)\n{\n  __int64 t; // [rsp+Ch] [rbp-38h]\n  __int64 q; // [rsp+14h] [rbp-30h]\n  __int64 r; // [rsp+1Ch] [rbp-28h]\n  __int64 b2; // [rsp+24h] [rbp-20h]\n  __int64 b1; // [rsp+2Ch] [rbp-18h]\n  __int64 n2; // [rsp+34h] [rbp-10h]\n  __int64 n1; // [rsp+3Ch] [rbp-8h]\n\n  if ( xin )\n  {\n    n1 = 65537LL;\n    n2 = xin;\n    b2 = 1LL;\n    b1 = 0LL;\n    do\n    {\n      r = n1 % n2;\n      q = (n1 - n1 % n2) / n2;\n      if ( n1 % n2 )\n      {\n        n1 = n2;\n        n2 = r;\n        t = b2;\n        b2 = b1 - b2 * q;\n        b1 = t;\n      }\n      else\n      {\n        b2 += b2 < 0 ? 0x10001uLL : 0;\n      }\n    }\n    while ( r );\n  }\n  else\n  {\n    LODWORD(b2) = 0;\n  }\n  return b2;\n}\n\n\n Revised code:\nstatic IDEA_INT inverse(unsigned int xin)\n{\n    long n1, n2, q, r, b1, b2, t;\n\n    if (xin == 0)\n        b2 = 0;\n    else {\n        n1 = 0x10001;\n        n2 = xin;\n        b2 = 1;\n        b1 = 0;\n\n        do {\n            r = (n1 % n2);\n            q = (n1 - r) / n2;\n            if (r == 0) {\n                if (b2 < 0)\n                    b2 = 0x10001 + b2;\n            } else {\n                n1 = n2;\n                n2 = r;\n                t = b2;\n                b2 = b1 - q * b2;\n                b1 = t;\n            }\n        } while (r != 0);\n    }\n    return ((IDEA_INT) b2);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl ctr64_add(unsigned __int8 *counter, size_t inc)\n{\n  unsigned __int64 v2; // rdx\n  unsigned __int8 *countera; // [rsp+8h] [rbp-18h]\n  size_t val; // [rsp+10h] [rbp-10h]\n  size_t n; // [rsp+18h] [rbp-8h]\n\n  n = 8LL;\n  val = 0LL;\n  countera = counter + 8;\n  do\n  {\n    v2 = countera[--n] + (unsigned __int64)(unsigned __int8)inc + val;\n    countera[n] = v2;\n    val = v2 >> 8;\n    inc >>= 8;\n  }\n  while ( n && (inc || val) );\n}\n\n\n Revised code:\nstatic void ctr64_add(unsigned char *counter, size_t inc)\n{\n    size_t n = 8, val = 0;\n\n    counter += 8;\n    do {\n        --n;\n        val += counter[n] + (inc & 0xff);\n        counter[n] = (unsigned char)val;\n        val >>= 8;              /* carry bit */\n        inc >>= 8;\n    } while (n && (inc || val));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_47DE2C(const char *a1, __int64 a2)\n{\n  _QWORD *v2; // rdi\n  int v4; // [rsp+4h] [rbp-3Ch]\n  _QWORD v5[4]; // [rsp+10h] [rbp-30h] BYREF\n  char *v6; // [rsp+30h] [rbp-10h]\n  unsigned int v7; // [rsp+3Ch] [rbp-4h]\n\n  v4 = a2;\n  sub_47A810(a1, a2);\n  sub_46E8A1(v5);\n  v7 = 0;\n  do\n  {\n    v2 = 0LL;\n    v6 = (char *)sub_47DC41(0);\n    if ( v6 == (char *)-1LL )\n      break;\n    a2 = 0LL;\n    sub_4781FB(v6, 0);\n    v2 = v5;\n    sub_46E905(v5, 0LL);\n    v7 = byte_75B040;\n  }\n  while ( !byte_75B040 );\n  sub_47A5E5((__int64)v2, a2);\n  v7 &= v4;\n  byte_75B040 = v7;\n  return v7;\n}\n",
        "output": "```c\nstatic unsigned int sub_47DE2C(const char *a1, int a2)\n{\n    unsigned int result;\n    _QWORD buffer[4]; // Assuming _QWORD is an 8-byte data type\n    char *ptr;\n    unsigned int flag;\n\n    sub_47A810(a1, a2); // Some function call with a1 and a2 as arguments\n    sub_46E8A1(buffer); // Some function call that presumably initializes buffer\n    flag = 0;\n\n    do {\n        ptr = (char *)sub_47DC41(0); // Some function call that returns a pointer or -1\n        if (ptr == (char *)-1)\n            break;\n\n        sub_4781FB(ptr, 0); // Some function call with ptr and 0 as arguments\n        sub_46E905(buffer, 0); // Some function call with buffer and 0 as arguments\n        flag = byte_75B040; // byte_75B040 is a global variable\n    } while (!byte_75B040);\n\n    sub_47A5E5((__int64)buffer, 0); // Some function call with buffer and 0 as arguments\n    result = flag & a2; // Combine flag with input a2 using bitwise AND\n    byte_75B040 = result; // Update global variable with the result\n\n    return result;\n}\n```",
        "source_code": "static int\nevalstring(char *s, int mask)\n{\n\tunion node *n;\n\tstruct stackmark smark;\n\tint skip;\n\n\tsetinputstring(s);\n\tsetstackmark(&smark);\n\n\tskip = 0;\n\twhile ((n = parsecmd(0)) != NODE_EOF) {\n\t\tevaltree(n, 0);\n\t\tpopstackmark(&smark);\n\t\tskip = evalskip;\n\t\tif (skip)\n\t\t\tbreak;\n\t}\n\tpopfile();\n\n\tskip &= mask;\n\tevalskip = skip;\n\treturn skip;\n}",
        "parsed_output": "static unsigned int sub_47DE2C(const char *a1, int a2)\n{\n    unsigned int result;\n    _QWORD buffer[4]; // Assuming _QWORD is an 8-byte data type\n    char *ptr;\n    unsigned int flag;\n\n    sub_47A810(a1, a2); // Some function call with a1 and a2 as arguments\n    sub_46E8A1(buffer); // Some function call that presumably initializes buffer\n    flag = 0;\n\n    do {\n        ptr = (char *)sub_47DC41(0); // Some function call that returns a pointer or -1\n        if (ptr == (char *)-1)\n            break;\n\n        sub_4781FB(ptr, 0); // Some function call with ptr and 0 as arguments\n        sub_46E905(buffer, 0); // Some function call with buffer and 0 as arguments\n        flag = byte_75B040; // byte_75B040 is a global variable\n    } while (!byte_75B040);\n\n    sub_47A5E5((__int64)buffer, 0); // Some function call with buffer and 0 as arguments\n    result = flag & a2; // Combine flag with input a2 using bitwise AND\n    byte_75B040 = result; // Update global variable with the result\n\n    return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_47DE2C(const char *a1, __int64 a2)\n{\n  _QWORD *v2; // rdi\n  int v4; // [rsp+4h] [rbp-3Ch]\n  _QWORD v5[4]; // [rsp+10h] [rbp-30h] BYREF\n  char *v6; // [rsp+30h] [rbp-10h]\n  unsigned int v7; // [rsp+3Ch] [rbp-4h]\n\n  v4 = a2;\n  sub_47A810(a1, a2);\n  sub_46E8A1(v5);\n  v7 = 0;\n  do\n  {\n    v2 = 0LL;\n    v6 = (char *)sub_47DC41(0);\n    if ( v6 == (char *)-1LL )\n      break;\n    a2 = 0LL;\n    sub_4781FB(v6, 0);\n    v2 = v5;\n    sub_46E905(v5, 0LL);\n    v7 = byte_75B040;\n  }\n  while ( !byte_75B040 );\n  sub_47A5E5((__int64)v2, a2);\n  v7 &= v4;\n  byte_75B040 = v7;\n  return v7;\n}\n",
        "baseline_code_debug": "int __cdecl evalstring(char *s, int mask)\n{\n  stackmark smark; // [rsp+10h] [rbp-30h] BYREF\n  node *n; // [rsp+30h] [rbp-10h]\n  int skip; // [rsp+3Ch] [rbp-4h]\n\n  setinputstring(s);\n  setstackmark(&smark);\n  skip = 0;\n  do\n  {\n    n = parsecmd(0);\n    if ( n == (node *)-1LL )\n      break;\n    evaltree(n, 0);\n    popstackmark(&smark);\n    skip = evalskip[0];\n  }\n  while ( !evalskip[0] );\n  popfile();\n  skip &= mask;\n  evalskip[0] = skip;\n  return skip;\n}\n",
        "similarity_score_unixcoder": 0.4977964460849762,
        "similarity_score_baseline_stripped": 0.46321845054626465,
        "similarity_score_baseline_debug": 0.9173325300216675
    },
    {
        "func_name": "examine_file",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __cdecl slg_ctrl(BIO *b, int cmd, __int64 num, void *ptr)\n{\n  int numa; // [rsp+8h] [rbp-18h]\n\n  numa = num;\n  if ( cmd == 4 )\n  {\n    xcloselog(b);\n    xopenlog(b, (char *)ptr, numa);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic long MS_CALLBACK slg_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    switch (cmd) {\n    case BIO_CTRL_SET:\n        xcloselog(b);\n        xopenlog(b, ptr, num);\n        break;\n    default:\n        break;\n    }\n    return (0);\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_41E48A(__int64 a1, __int64 a2)\n{\n  void *v2; // rdi\n  _DWORD *v3; // rax\n  _BYTE *ptr; // [rsp+8h] [rbp-8h]\n\n  sub_41CB0F(\"Examine: \");\n  ptr = sub_41E385(9, a2);\n  if ( !*ptr )\n  {\n    sub_41D604();\nLABEL_3:\n    free(ptr);\n    return;\n  }\n  if ( access(ptr, 4) )\n  {\n    sub_41CB0F(\"Cannot read this file\");\n    goto LABEL_3;\n  }\n  v2 = (void *)*((_QWORD *)qword_75D408 + 13);\n  free(v2);\n  *((_QWORD *)qword_75D408 + 13) = ptr;\n  **((_QWORD **)qword_75D408 + 14) = *((_QWORD *)qword_75D408 + 13);\n  v3 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 25) = 1;\n  *((_DWORD *)qword_75D408 + 24) = v3[25];\n  sub_41E057(v2, 4uLL);\n}\n",
        "output": "```c\nvoid examine_file_and_update_state(__int64 state, __int64 a2)\n{\n    char *filename;\n    char *old_filename;\n\n    print_message(\"Examine: \");\n    filename = allocate_and_copy_string(9, a2);\n    if (!*filename)\n    {\n        handle_error();\n        goto cleanup;\n    }\n    if (access(filename, R_OK))\n    {\n        print_message(\"Cannot read this file\");\n        goto cleanup;\n    }\n    old_filename = global_state[13];\n    free(old_filename);\n    global_state[13] = filename;\n    *global_state[14] = filename;\n    global_state[25] = 1;\n    global_state[24] = global_state[25];\n    update_state(old_filename, 4);\n\ncleanup:\n    free(filename);\n}\n```",
        "source_code": "static void examine_file(void)\n{\n\tchar *new_fname;\n\n\tprint_statusline(\"Examine: \");\n\tnew_fname = less_gets(sizeof(\"Examine: \") - 1);\n\tif (!new_fname[0]) {\n\t\tstatus_print();\n err:\n\t\tfree(new_fname);\n\t\treturn;\n\t}\n\tif (access(new_fname, R_OK) != 0) {\n\t\tprint_statusline(\"Cannot read this file\");\n\t\tgoto err;\n\t}\n\tfree(filename);\n\tfilename = new_fname;\n\t/* files start by = argv. why we assume that argv is infinitely long??\n\tfiles[num_files] = filename;\n\tcurrent_file = num_files + 1;\n\tnum_files++; */\n\tfiles[0] = filename;\n\tnum_files = current_file = 1;\n\treinitialize();\n}",
        "parsed_output": "void examine_file_and_update_state(__int64 state, __int64 a2)\n{\n    char *filename;\n    char *old_filename;\n\n    print_message(\"Examine: \");\n    filename = allocate_and_copy_string(9, a2);\n    if (!*filename)\n    {\n        handle_error();\n        goto cleanup;\n    }\n    if (access(filename, R_OK))\n    {\n        print_message(\"Cannot read this file\");\n        goto cleanup;\n    }\n    old_filename = global_state[13];\n    free(old_filename);\n    global_state[13] = filename;\n    *global_state[14] = filename;\n    global_state[25] = 1;\n    global_state[24] = global_state[25];\n    update_state(old_filename, 4);\n\ncleanup:\n    free(filename);\n}",
        "baseline_code_stripped": "void __fastcall sub_41E48A(__int64 a1, __int64 a2)\n{\n  void *v2; // rdi\n  _DWORD *v3; // rax\n  _BYTE *ptr; // [rsp+8h] [rbp-8h]\n\n  sub_41CB0F(\"Examine: \");\n  ptr = sub_41E385(9, a2);\n  if ( !*ptr )\n  {\n    sub_41D604();\nLABEL_3:\n    free(ptr);\n    return;\n  }\n  if ( access(ptr, 4) )\n  {\n    sub_41CB0F(\"Cannot read this file\");\n    goto LABEL_3;\n  }\n  v2 = (void *)*((_QWORD *)qword_75D408 + 13);\n  free(v2);\n  *((_QWORD *)qword_75D408 + 13) = ptr;\n  **((_QWORD **)qword_75D408 + 14) = *((_QWORD *)qword_75D408 + 13);\n  v3 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 25) = 1;\n  *((_DWORD *)qword_75D408 + 24) = v3[25];\n  sub_41E057(v2, 4uLL);\n}\n",
        "baseline_code_debug": "void __cdecl examine_file()\n{\n  globals *v0; // rax\n  char *new_fname; // [rsp+8h] [rbp-8h]\n\n  print_statusline(\"Examine: \");\n  new_fname = less_gets(9);\n  if ( !*new_fname )\n  {\n    status_print();\nerr:\n    free(new_fname);\n    return;\n  }\n  if ( access(new_fname, 4) )\n  {\n    print_statusline(\"Cannot read this file\");\n    goto err;\n  }\n  free(*(void **)&ptr_to_globals->tty_attrs.c_cflag);\n  *(_QWORD *)&ptr_to_globals->tty_attrs.c_cflag = new_fname;\n  **(_QWORD **)&ptr_to_globals->tty_attrs.c_line = *(_QWORD *)&ptr_to_globals->tty_attrs.c_cflag;\n  v0 = ptr_to_globals;\n  ptr_to_globals->tty_attrs.c_oflag = 1;\n  ptr_to_globals->tty_attrs.c_iflag = v0->tty_attrs.c_oflag;\n  reinitialize();\n}\n",
        "similarity_score_unixcoder": 0.7050453424453735,
        "similarity_score_baseline_stripped": 0.5883354544639587,
        "similarity_score_baseline_debug": 0.7375499606132507
    },
    {
        "func_name": "BZ2_blockSort",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl private_RC4_set_key(RC4_KEY *key, int len, const unsigned __int8 *data)\n{\n  unsigned __int8 *v3; // r12\n  int v4; // ebx\n  int v5; // r13d\n  unsigned __int8 v6; // r14\n  int v7; // ebx\n  int v8; // r13d\n  unsigned __int8 v9; // r14\n  int v10; // ebx\n  int v11; // r13d\n  unsigned __int8 v12; // r14\n  int v13; // ebx\n  int v14; // r13d\n  unsigned __int8 v15; // r14\n  unsigned int i; // [rsp+24h] [rbp-24h]\n  unsigned int ia; // [rsp+24h] [rbp-24h]\n\n  v3 = key->data;\n  key->x = 0;\n  key->y = 0;\n  LOBYTE(v4) = 0;\n  v5 = 0;\n  for ( i = 0; i <= 0xFF; ++i )\n    v3[i] = i;\n  for ( ia = 0; ia <= 0xFF; ia += 4 )\n  {\n    v6 = v3[ia];\n    v7 = (unsigned __int8)(v4 + data[v5] + v6);\n    v8 = v5 + 1;\n    if ( v8 == len )\n      v8 = 0;\n    v3[ia] = v3[v7];\n    v3[v7] = v6;\n    v9 = v3[ia + 1];\n    v10 = (unsigned __int8)(v7 + data[v8] + v9);\n    v11 = v8 + 1;\n    if ( v11 == len )\n      v11 = 0;\n    v3[ia + 1] = v3[v10];\n    v3[v10] = v9;\n    v12 = v3[ia + 2];\n    v13 = (unsigned __int8)(v10 + data[v11] + v12);\n    v14 = v11 + 1;\n    if ( v14 == len )\n      v14 = 0;\n    v3[ia + 2] = v3[v13];\n    v3[v13] = v12;\n    v15 = v3[ia + 3];\n    v4 = (unsigned __int8)(v13 + data[v14] + v15);\n    v5 = v14 + 1;\n    if ( v5 == len )\n      v5 = 0;\n    v3[ia + 3] = v3[v4];\n    v3[v4] = v15;\n  }\n}\n\n\n Revised code:\nvoid private_RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)\n{\n    register RC4_INT tmp;\n    register int id1, id2;\n    register RC4_INT *d;\n    unsigned int i;\n\n    d = &(key->data[0]);\n    key->x = 0;\n    key->y = 0;\n    id1 = id2 = 0;\n\n#define SK_LOOP(d,n) { \\\n                tmp=d[(n)]; \\\n                id2 = (data[id1] + tmp + id2) & 0xff; \\\n                if (++id1 == len) id1=0; \\\n                d[(n)]=d[id2]; \\\n                d[id2]=tmp; }\n\n    for (i = 0; i < 256; i++)\n        d[i] = i;\n    for (i = 0; i < 256; i += 4) {\n        SK_LOOP(d, i + 0);\n        SK_LOOP(d, i + 1);\n        SK_LOOP(d, i + 2);\n        SK_LOOP(d, i + 3);\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nunsigned __int64 __cdecl bn_mul_words(unsigned __int64 *rp, const unsigned __int64 *ap, int num, unsigned __int64 w)\n{\n  int numa; // [rsp+Ch] [rbp-C4h]\n  unsigned __int64 ret_3; // [rsp+28h] [rbp-A8h]\n  unsigned __int64 ret_2; // [rsp+48h] [rbp-88h]\n  unsigned __int64 ta_2; // [rsp+60h] [rbp-70h]\n  unsigned __int64 ret_1; // [rsp+68h] [rbp-68h]\n  unsigned __int64 ta_1; // [rsp+80h] [rbp-50h]\n  unsigned __int64 ret_0; // [rsp+88h] [rbp-48h]\n  unsigned __int64 ta_0; // [rsp+A0h] [rbp-30h]\n  unsigned __int64 ret; // [rsp+A8h] [rbp-28h]\n  unsigned __int64 low; // [rsp+B8h] [rbp-18h]\n  unsigned __int64 c1; // [rsp+C8h] [rbp-8h]\n  unsigned __int64 c1a; // [rsp+C8h] [rbp-8h]\n\n  numa = num;\n  c1 = 0LL;\n  if ( num <= 0 )\n    return 0LL;\n  while ( (numa & 0xFFFFFFFC) != 0 )\n  {\n    low = *ap * w;\n    ret = low + c1;\n    c1a = (*ap * (unsigned __int128)w) >> 64;\n    *rp = ret;\n    ta_0 = ap[1];\n    ret_0 = ta_0 * w + (ret < low) + c1a;\n    rp[1] = ret_0;\n    ta_1 = ap[2];\n    ret_1 = ta_1 * w + (ret_0 < ta_0 * w) + ((ta_0 * (unsigned __int128)w) >> 64);\n    rp[2] = ret_1;\n    ta_2 = ap[3];\n    ret_2 = ta_2 * w + (ret_1 < ta_1 * w) + ((ta_1 * (unsigned __int128)w) >> 64);\n    c1 = (ret_2 < ta_2 * w) + ((ta_2 * (unsigned __int128)w) >> 64);\n    rp[3] = ret_2;\n    ap += 4;\n    rp += 4;\n    numa -= 4;\n  }\n  while ( numa )\n  {\n    ret_3 = *ap * w + c1;\n    c1 = (ret_3 < *ap * w) + ((*ap * (unsigned __int128)w) >> 64);\n    *rp = ret_3;\n    ++ap;\n    ++rp;\n    --numa;\n  }\n  return c1;\n}\n\n\n Revised code:\nBN_ULONG bn_mul_words(BN_ULONG *rp, const BN_ULONG *ap, int num, BN_ULONG w)\n{\n    BN_ULONG c1 = 0;\n\n    assert(num >= 0);\n    if (num <= 0)\n        return (c1);\n\n# ifndef OPENSSL_SMALL_FOOTPRINT\n    while (num & ~3) {\n        mul(rp[0], ap[0], w, c1);\n        mul(rp[1], ap[1], w, c1);\n        mul(rp[2], ap[2], w, c1);\n        mul(rp[3], ap[3], w, c1);\n        ap += 4;\n        rp += 4;\n        num -= 4;\n    }\n# endif\n    while (num) {\n        mul(rp[0], ap[0], w, c1);\n        ap++;\n        rp++;\n        num--;\n    }\n    return (c1);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4AB46E(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // [rsp+1Ch] [rbp-34h] BYREF\n  unsigned __int8 *v3; // [rsp+20h] [rbp-30h]\n  int v4; // [rsp+2Ch] [rbp-24h]\n  int *v5; // [rsp+30h] [rbp-20h]\n  unsigned __int8 *v6; // [rsp+38h] [rbp-18h]\n  __int64 v7; // [rsp+40h] [rbp-10h]\n  int i; // [rsp+4Ch] [rbp-4h]\n\n  v7 = *(_QWORD *)(a1 + 48);\n  v6 = *(unsigned __int8 **)(a1 + 56);\n  v5 = *(int **)(a1 + 40);\n  v4 = *(_DWORD *)(a1 + 96);\n  if ( v4 > 9999 )\n  {\n    i = v4 + 34;\n    if ( (((_BYTE)v4 + 34) & 1) != 0 )\n      ++i;\n    v3 = &v6[i];\n    v2 = 9 * v4;\n    sub_4AAAE7(a1, v7, v6, (__int64)v3, v5, v4, &v2);\n    if ( v2 < 0 )\n      sub_4A92A3(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), (__int64)v5, v4);\n  }\n  else\n  {\n    sub_4A92A3(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), (__int64)v5, v4);\n  }\n  *(_DWORD *)(a1 + 16) = -1;\n  for ( i = 0; ; ++i )\n  {\n    result = *(unsigned int *)(a1 + 96);\n    if ( i >= (int)result )\n      break;\n    if ( !*(_DWORD *)(4LL * i + v7) )\n    {\n      result = a1;\n      *(_DWORD *)(a1 + 16) = i;\n      return result;\n    }\n  }\n  return result;\n}\n",
        "output": "int process_data(int data)\n{\n    int result;\n    int multiplier;\n    unsigned char *buffer;\n    int data_size;\n    int *data_ptr;\n    unsigned char *data_end;\n    __int64 data_offset;\n    int index;\n\n    data_offset = *(__int64 *)(data + 48);\n    data_end = *(unsigned char **)(data + 56);\n    data_ptr = *(int **)(data + 40);\n    data_size = *(_DWORD *)(data + 96);\n    if (data_size > 9999)\n    {\n        index = data_size + 34;\n        if ((index & 1) != 0)\n            index++;\n        buffer = &data_end[index];\n        multiplier = 9 * data_size;\n        sub_function(data, data_offset, data_end, (__int64)buffer, data_ptr, data_size, &multiplier);\n        if (multiplier < 0)\n            another_sub_function(*(_QWORD *)(data + 24), *(_QWORD *)(data + 32), (__int64)data_ptr, data_size);\n    }\n    else\n    {\n        another_sub_function(*(_QWORD *)(data + 24), *(_QWORD *)(data + 32), (__int64)data_ptr, data_size);\n    }\n    *(_DWORD *)(data + 16) = -1;\n    for (index = 0; ; ++index)\n    {\n        result = *(unsigned int *)(data + 96);\n        if (index >= result)\n            break;\n        if (!*(_DWORD *)(4LL * index + data_offset))\n        {\n            result = data;\n            *(_DWORD *)(data + 16) = index;\n            return result;\n        }\n    }\n    return result;\n}",
        "source_code": "static NOINLINE\nvoid BZ2_blockSort(EState* s)\n{\n\t/* In original bzip2 1.0.4, it's a parameter, but 30\n\t * (which was the default) should work ok. */\n\tenum { wfact = 30 };\n\n\tuint32_t* ptr    = s->ptr;\n\tuint8_t*  block  = s->block;\n\tuint32_t* ftab   = s->ftab;\n\tint32_t   nblock = s->nblock;\n\tuint16_t* quadrant;\n\tint32_t   budget;\n\tint32_t   i;\n\n\tif (nblock < 10000) {\n\t\tfallbackSort(s->arr1, s->arr2, ftab, nblock);\n\t} else {\n\t\t/* Calculate the location for quadrant, remembering to get\n\t\t * the alignment right.  Assumes that &(block[0]) is at least\n\t\t * 2-byte aligned -- this should be ok since block is really\n\t\t * the first section of arr2.\n\t\t */\n\t\ti = nblock + BZ_N_OVERSHOOT;\n\t\tif (i & 1) i++;\n\t\tquadrant = (uint16_t*)(&(block[i]));\n\n\t\t/* (wfact-1) / 3 puts the default-factor-30\n\t\t * transition point at very roughly the same place as\n\t\t * with v0.1 and v0.9.0.\n\t\t * Not that it particularly matters any more, since the\n\t\t * resulting compressed stream is now the same regardless\n\t\t * of whether or not we use the main sort or fallback sort.\n\t\t */\n\t\tbudget = nblock * ((wfact-1) / 3);\n\n\t\tmainSort(s, ptr, block, quadrant, ftab, nblock, &budget);\n\t\tif (budget < 0) {\n\t\t\tfallbackSort(s->arr1, s->arr2, ftab, nblock);\n\t\t}\n\t}\n\n\ts->origPtr = -1;\n\tfor (i = 0; i < s->nblock; i++)\n\t\tif (ptr[i] == 0) {\n\t\t\ts->origPtr = i;\n\t\t\tbreak;\n\t\t};\n\n\tAssertH(s->origPtr != -1, 1003);\n}",
        "parsed_output": "int process_data(int data)\n{\n    int result;\n    int multiplier;\n    unsigned char *buffer;\n    int data_size;\n    int *data_ptr;\n    unsigned char *data_end;\n    __int64 data_offset;\n    int index;\n\n    data_offset = *(__int64 *)(data + 48);\n    data_end = *(unsigned char **)(data + 56);\n    data_ptr = *(int **)(data + 40);\n    data_size = *(_DWORD *)(data + 96);\n    if (data_size > 9999)\n    {\n        index = data_size + 34;\n        if ((index & 1) != 0)\n            index++;\n        buffer = &data_end[index];\n        multiplier = 9 * data_size;\n        sub_function(data, data_offset, data_end, (__int64)buffer, data_ptr, data_size, &multiplier);\n        if (multiplier < 0)\n            another_sub_function(*(_QWORD *)(data + 24), *(_QWORD *)(data + 32), (__int64)data_ptr, data_size);\n    }\n    else\n    {\n        another_sub_function(*(_QWORD *)(data + 24), *(_QWORD *)(data + 32), (__int64)data_ptr, data_size);\n    }\n    *(_DWORD *)(data + 16) = -1;\n    for (index = 0; ; ++index)\n    {\n        result = *(unsigned int *)(data + 96);\n        if (index >= result)\n            break;\n        if (!*(_DWORD *)(4LL * index + data_offset))\n        {\n            result = data;\n            *(_DWORD *)(data + 16) = index;\n            return result;\n        }\n    }\n    return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4AB46E(__int64 a1)\n{\n  __int64 result; // rax\n  int v2; // [rsp+1Ch] [rbp-34h] BYREF\n  unsigned __int8 *v3; // [rsp+20h] [rbp-30h]\n  int v4; // [rsp+2Ch] [rbp-24h]\n  int *v5; // [rsp+30h] [rbp-20h]\n  unsigned __int8 *v6; // [rsp+38h] [rbp-18h]\n  __int64 v7; // [rsp+40h] [rbp-10h]\n  int i; // [rsp+4Ch] [rbp-4h]\n\n  v7 = *(_QWORD *)(a1 + 48);\n  v6 = *(unsigned __int8 **)(a1 + 56);\n  v5 = *(int **)(a1 + 40);\n  v4 = *(_DWORD *)(a1 + 96);\n  if ( v4 > 9999 )\n  {\n    i = v4 + 34;\n    if ( (((_BYTE)v4 + 34) & 1) != 0 )\n      ++i;\n    v3 = &v6[i];\n    v2 = 9 * v4;\n    sub_4AAAE7(a1, v7, v6, (__int64)v3, v5, v4, &v2);\n    if ( v2 < 0 )\n      sub_4A92A3(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), (__int64)v5, v4);\n  }\n  else\n  {\n    sub_4A92A3(*(_QWORD *)(a1 + 24), *(_QWORD *)(a1 + 32), (__int64)v5, v4);\n  }\n  *(_DWORD *)(a1 + 16) = -1;\n  for ( i = 0; ; ++i )\n  {\n    result = *(unsigned int *)(a1 + 96);\n    if ( i >= (int)result )\n      break;\n    if ( !*(_DWORD *)(4LL * i + v7) )\n    {\n      result = a1;\n      *(_DWORD *)(a1 + 16) = i;\n      return result;\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl BZ2_blockSort(EState_0 *s)\n{\n  int32_t budget; // [rsp+1Ch] [rbp-34h] BYREF\n  uint16_t *quadrant; // [rsp+20h] [rbp-30h]\n  int32_t nblock; // [rsp+2Ch] [rbp-24h]\n  uint32_t *ftab; // [rsp+30h] [rbp-20h]\n  uint8_t *block; // [rsp+38h] [rbp-18h]\n  uint32_t *ptr; // [rsp+40h] [rbp-10h]\n  int32_t i; // [rsp+4Ch] [rbp-4h]\n\n  ptr = s->ptr;\n  block = s->block;\n  ftab = s->ftab;\n  nblock = s->nblock;\n  if ( nblock > 9999 )\n  {\n    i = nblock + 34;\n    if ( (((_BYTE)nblock + 34) & 1) != 0 )\n      ++i;\n    quadrant = (uint16_t *)&block[i];\n    budget = 9 * nblock;\n    mainSort(s, ptr, block, quadrant, ftab, nblock, &budget);\n    if ( budget < 0 )\n      fallbackSort(s->arr1, s->arr2, ftab, nblock);\n  }\n  else\n  {\n    fallbackSort(s->arr1, s->arr2, ftab, nblock);\n  }\n  s->origPtr = -1;\n  for ( i = 0; i < s->nblock; ++i )\n  {\n    if ( !ptr[i] )\n    {\n      s->origPtr = i;\n      return;\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.5708633661270142,
        "similarity_score_baseline_stripped": 0.5435144901275635,
        "similarity_score_baseline_debug": 0.891544759273529
    },
    {
        "func_name": "setup_alarm",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nASN1_GENERALIZEDTIME *__cdecl TS_RESP_set_genTime_with_precision(\n        ASN1_GENERALIZEDTIME *asn1_time,\n        __int64 sec,\n        __int64 usec,\n        unsigned int precision)\n{\n  int v4; // eax\n  size_t v5; // rax\n  char *v6; // rax\n  char *v7; // rax\n  ASN1_GENERALIZEDTIME *asn1_timea; // [rsp+18h] [rbp-48h]\n  char genTime_str[23]; // [rsp+20h] [rbp-40h] BYREF\n  char v13; // [rsp+37h] [rbp-29h] BYREF\n  time_t time_sec; // [rsp+40h] [rbp-20h] BYREF\n  char *p_end; // [rsp+48h] [rbp-18h]\n  tm *tm; // [rsp+50h] [rbp-10h]\n  char *p; // [rsp+58h] [rbp-8h]\n\n  asn1_timea = asn1_time;\n  time_sec = sec;\n  tm = 0LL;\n  p = genTime_str;\n  p_end = &v13;\n  if ( precision <= 6 )\n  {\n    tm = gmtime(&time_sec);\n    if ( tm )\n    {\n      v4 = BIO_snprintf(\n             p,\n             p_end - p,\n             \"%04d%02d%02d%02d%02d%02d\",\n             (unsigned int)(tm->tm_year + 1900),\n             (unsigned int)(tm->tm_mon + 1),\n             (unsigned int)tm->tm_mday,\n             (unsigned int)tm->tm_hour,\n             (unsigned int)tm->tm_min,\n             (unsigned int)tm->tm_sec);\n      p += v4;\n      if ( precision )\n      {\n        BIO_snprintf(p, precision + 2, \".%ld\", usec);\n        v5 = strlen(p);\n        p += v5;\n        do\n          --p;\n        while ( *p == 48 );\n        if ( *p != 46 )\n          ++p;\n      }\n      v6 = p++;\n      *v6 = 90;\n      v7 = p++;\n      *v7 = 0;\n      if ( asn1_timea || (asn1_timea = ASN1_STRING_type_new(24)) != 0LL )\n      {\n        if ( ASN1_GENERALIZEDTIME_set_string(asn1_timea, genTime_str) )\n          return asn1_timea;\n        ASN1_GENERALIZEDTIME_free(asn1_timea);\n      }\n    }\n  }\n  ERR_put_error(47, 134, 115, \"ts_rsp_sign.c\", 1018);\n  return 0LL;\n}\n\n\n Revised code:\nstatic ASN1_GENERALIZEDTIME\n*TS_RESP_set_genTime_with_precision(ASN1_GENERALIZEDTIME *asn1_time,\n                                    long sec, long usec, unsigned precision)\n{\n    time_t time_sec = (time_t)sec;\n    struct tm *tm = NULL;\n    char genTime_str[17 + TS_MAX_CLOCK_PRECISION_DIGITS];\n    char *p = genTime_str;\n    char *p_end = genTime_str + sizeof(genTime_str);\n\n    if (precision > TS_MAX_CLOCK_PRECISION_DIGITS)\n        goto err;\n\n    if (!(tm = gmtime(&time_sec)))\n        goto err;\n\n    /*\n     * Put \"genTime_str\" in GeneralizedTime format.  We work around the\n     * restrictions imposed by rfc3280 (i.e. \"GeneralizedTime values MUST\n     * NOT include fractional seconds\") and OpenSSL related functions to\n     * meet the rfc3161 requirement: \"GeneralizedTime syntax can include\n     * fraction-of-second details\".\n     */\n    p += BIO_snprintf(p, p_end - p,\n                      \"%04d%02d%02d%02d%02d%02d\",\n                      tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,\n                      tm->tm_hour, tm->tm_min, tm->tm_sec);\n    if (precision > 0) {\n        /* Add fraction of seconds (leave space for dot and null). */\n        BIO_snprintf(p, 2 + precision, \".%06ld\", usec);\n        /*\n         * We cannot use the snprintf return value, because it might have\n         * been truncated.\n         */\n        p += strlen(p);\n\n        /*\n         * To make things a bit harder, X.690 | ISO/IEC 8825-1 provides the\n         * following restrictions for a DER-encoding, which OpenSSL\n         * (specifically ASN1_GENERALIZEDTIME_check() function) doesn't\n         * support: \"The encoding MUST terminate with a \"Z\" (which means\n         * \"Zulu\" time). The decimal point element, if present, MUST be the\n         * point option \".\". The fractional-seconds elements, if present,\n         * MUST omit all trailing 0's; if the elements correspond to 0, they\n         * MUST be wholly omitted, and the decimal point element also MUST be\n         * omitted.\"\n         */\n        /*\n         * Remove trailing zeros. The dot guarantees the exit condition of\n         * this loop even if all the digits are zero.\n         */\n        while (*--p == '0')\n            /*\n             * empty\n             */ ;\n        /* p points to either the dot or the last non-zero digit. */\n        if (*p != '.')\n            ++p;\n    }\n    /* Add the trailing Z and the terminating null. */\n    *p++ = 'Z';\n    *p++ = '\\0';\n\n    /* Now call OpenSSL to check and set our genTime value */\n    if (!asn1_time && !(asn1_time = M_ASN1_GENERALIZEDTIME_new()))\n        goto err;\n    if (!ASN1_GENERALIZEDTIME_set_string(asn1_time, genTime_str)) {\n        ASN1_GENERALIZEDTIME_free(asn1_time);\n        goto err;\n    }\n\n    return asn1_time;\n err:\n    TSerr(TS_F_TS_RESP_SET_GENTIME_WITH_PRECISION, TS_R_COULD_NOT_SET_TIME);\n    return NULL;\n}\n\n## Example:\n\n Input code:\nASN1_GENERALIZEDTIME *__cdecl ASN1_GENERALIZEDTIME_adj(\n        ASN1_GENERALIZEDTIME *s,\n        time_t t,\n        int offset_day,\n        __int64 offset_sec)\n{\n  int v5; // eax\n  time_t ta; // [rsp+10h] [rbp-60h] BYREF\n  ASN1_GENERALIZEDTIME *sa; // [rsp+18h] [rbp-58h]\n  tm data; // [rsp+20h] [rbp-50h] BYREF\n  tm *ts; // [rsp+58h] [rbp-18h]\n  size_t len; // [rsp+60h] [rbp-10h]\n  char *p; // [rsp+68h] [rbp-8h]\n\n  sa = s;\n  ta = t;\n  len = 20LL;\n  if ( !s )\n    sa = ASN1_STRING_type_new(24);\n  if ( !sa )\n    return 0LL;\n  ts = OPENSSL_gmtime(&ta, &data);\n  if ( !ts )\n    return 0LL;\n  if ( (offset_day || offset_sec) && !OPENSSL_gmtime_adj(ts, offset_day, offset_sec) )\n    return 0LL;\n  p = (char *)sa->data;\n  if ( !p || len > sa->length )\n  {\n    p = (char *)CRYPTO_malloc(len, \"a_gentm.c\", 243);\n    if ( !p )\n    {\n      ERR_put_error(13, 216, 65, \"a_gentm.c\", 247);\n      return 0LL;\n    }\n    if ( sa->data )\n      CRYPTO_free(sa->data);\n    sa->data = (unsigned __int8 *)p;\n  }\n  BIO_snprintf(\n    p,\n    len,\n    \"%04d%02d%02d%02d%02d%02dZ\",\n    (unsigned int)(ts->tm_year + 1900),\n    (unsigned int)(ts->tm_mon + 1),\n    (unsigned int)ts->tm_mday,\n    (unsigned int)ts->tm_hour,\n    (unsigned int)ts->tm_min,\n    (unsigned int)ts->tm_sec);\n  v5 = strlen(p);\n  sa->length = v5;\n  sa->type = 24;\n  return sa;\n}\n\n\n Revised code:\nASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_adj(ASN1_GENERALIZEDTIME *s,\n                                               time_t t, int offset_day,\n                                               long offset_sec)\n{\n    char *p;\n    struct tm *ts;\n    struct tm data;\n    size_t len = 20;\n\n    if (s == NULL)\n        s = M_ASN1_GENERALIZEDTIME_new();\n    if (s == NULL)\n        return (NULL);\n\n    ts = OPENSSL_gmtime(&t, &data);\n    if (ts == NULL)\n        return (NULL);\n\n    if (offset_day || offset_sec) {\n        if (!OPENSSL_gmtime_adj(ts, offset_day, offset_sec))\n            return NULL;\n    }\n\n    p = (char *)s->data;\n    if ((p == NULL) || ((size_t)s->length < len)) {\n        p = OPENSSL_malloc(len);\n        if (p == NULL) {\n            ASN1err(ASN1_F_ASN1_GENERALIZEDTIME_ADJ, ERR_R_MALLOC_FAILURE);\n            return (NULL);\n        }\n        if (s->data != NULL)\n            OPENSSL_free(s->data);\n        s->data = (unsigned char *)p;\n    }\n\n    BIO_snprintf(p, len, \"%04d%02d%02d%02d%02d%02dZ\", ts->tm_year + 1900,\n                 ts->tm_mon + 1, ts->tm_mday, ts->tm_hour, ts->tm_min,\n                 ts->tm_sec);\n    s->length = strlen(p);\n    s->type = V_ASN1_GENERALIZEDTIME;\n#ifdef CHARSET_EBCDIC_not\n    ebcdic2ascii(s->data, s->data, s->length);\n#endif\n    return (s);\n}\n\n## Example:\n\n Input code:\nASN1_UTCTIME *__cdecl ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t, int offset_day, __int64 offset_sec)\n{\n  int v5; // eax\n  time_t ta; // [rsp+10h] [rbp-70h] BYREF\n  ASN1_UTCTIME *sa; // [rsp+18h] [rbp-68h]\n  tm data; // [rsp+20h] [rbp-60h] BYREF\n  tm *ts; // [rsp+58h] [rbp-28h]\n  size_t len; // [rsp+60h] [rbp-20h]\n  char *p; // [rsp+68h] [rbp-18h]\n\n  sa = s;\n  ta = t;\n  len = 20LL;\n  if ( !s )\n    sa = ASN1_STRING_type_new(23);\n  if ( !sa )\n    return 0LL;\n  ts = OPENSSL_gmtime(&ta, &data);\n  if ( !ts )\n    return 0LL;\n  if ( (offset_day || offset_sec) && !OPENSSL_gmtime_adj(ts, offset_day, offset_sec) )\n    return 0LL;\n  if ( ts->tm_year <= 49 || ts->tm_year > 149 )\n    return 0LL;\n  p = (char *)sa->data;\n  if ( !p || len > sa->length )\n  {\n    p = (char *)CRYPTO_malloc(len, \"a_utctm.c\", 221);\n    if ( !p )\n    {\n      ERR_put_error(13, 218, 65, \"a_utctm.c\", 224);\n      return 0LL;\n    }\n    if ( sa->data )\n      CRYPTO_free(sa->data);\n    sa->data = (unsigned __int8 *)p;\n  }\n  BIO_snprintf(\n    p,\n    len,\n    \"%02d%02d%02d%02d%02d%02dZ\",\n    (unsigned int)(ts->tm_year % 100),\n    (unsigned int)(ts->tm_mon + 1),\n    (unsigned int)ts->tm_mday,\n    (unsigned int)ts->tm_hour,\n    (unsigned int)ts->tm_min,\n    (unsigned int)ts->tm_sec);\n  v5 = strlen(p);\n  sa->length = v5;\n  sa->type = 23;\n  return sa;\n}\n\n\n Revised code:\nASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t,\n                               int offset_day, long offset_sec)\n{\n    char *p;\n    struct tm *ts;\n    struct tm data;\n    size_t len = 20;\n    int free_s = 0;\n\n    if (s == NULL) {\n        free_s = 1;\n        s = M_ASN1_UTCTIME_new();\n    }\n    if (s == NULL)\n        goto err;\n\n    ts = OPENSSL_gmtime(&t, &data);\n    if (ts == NULL)\n        goto err;\n\n    if (offset_day || offset_sec) {\n        if (!OPENSSL_gmtime_adj(ts, offset_day, offset_sec))\n            goto err;\n    }\n\n    if ((ts->tm_year < 50) || (ts->tm_year >= 150))\n        goto err;\n\n    p = (char *)s->data;\n    if ((p == NULL) || ((size_t)s->length < len)) {\n        p = OPENSSL_malloc(len);\n        if (p == NULL) {\n            ASN1err(ASN1_F_ASN1_UTCTIME_ADJ, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        if (s->data != NULL)\n            OPENSSL_free(s->data);\n        s->data = (unsigned char *)p;\n    }\n\n    BIO_snprintf(p, len, \"%02d%02d%02d%02d%02d%02dZ\", ts->tm_year % 100,\n                 ts->tm_mon + 1, ts->tm_mday, ts->tm_hour, ts->tm_min,\n                 ts->tm_sec);\n    s->length = strlen(p);\n    s->type = V_ASN1_UTCTIME;\n#ifdef CHARSET_EBCDIC_not\n    ebcdic2ascii(s->data, s->data, s->length);\n#endif\n    return (s);\n err:\n    if (free_s && s)\n        M_ASN1_UTCTIME_free(s);\n    return NULL;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4A40E0(int a1, const time_t *a2, __int64 a3)\n{\n  char v5[4]; // [rsp+20h] [rbp-30h] BYREF\n  int v6[9]; // [rsp+24h] [rbp-2Ch] BYREF\n  struct tm *v7; // [rsp+48h] [rbp-8h]\n\n  v7 = localtime(a2);\n  v6[0] = v7->tm_sec;\n  v6[1] = v7->tm_min;\n  v6[2] = v7->tm_hour;\n  v6[3] = v7->tm_mday;\n  v6[4] = v7->tm_mon;\n  v6[5] = v7->tm_year;\n  v6[6] = -1;\n  v6[7] = -1;\n  v6[8] = -1;\n  if ( a3 + 86399 < *a2 )\n  {\n    v5[0] = 1;\n    return sub_40AD51(a1, 0x4028700Fu, (__int64)v5, (__int64)\"RTC_WKALM_SET\");\n  }\n  else\n  {\n    sub_40AD51(a1, 0x40247007u, (__int64)v6, (__int64)\"RTC_ALM_SET\");\n    return sub_40AD51(a1, 0x7001u, 0LL, (__int64)\"RTC_AIE_ON\");\n  }\n}\n",
        "output": "```c\nint set_alarm(int alarm_id, const time_t *time_ptr, time_t alarm_offset)\n{\n    struct tm *local_time;\n    int alarm_time[9];\n\n    local_time = localtime(time_ptr);\n    alarm_time[0] = local_time->tm_sec;\n    alarm_time[1] = local_time->tm_min;\n    alarm_time[2] = local_time->tm_hour;\n    alarm_time[3] = local_time->tm_mday;\n    alarm_time[4] = local_time->tm_mon;\n    alarm_time[5] = local_time->tm_year;\n    alarm_time[6] = -1; // tm_wday not set\n    alarm_time[7] = -1; // tm_yday not set\n    alarm_time[8] = -1; // tm_isdst not set\n\n    if (*time_ptr + alarm_offset < *time_ptr)\n    {\n        char alarm_enabled = 1;\n        return set_system_call(alarm_id, RTC_WKALM_SET, &alarm_enabled, \"RTC_WKALM_SET\");\n    }\n    else\n    {\n        set_system_call(alarm_id, RTC_ALM_SET, alarm_time, \"RTC_ALM_SET\");\n        return set_system_call(alarm_id, RTC_AIE_ON, NULL, \"RTC_AIE_ON\");\n    }\n}\n```",
        "source_code": "static NOINLINE void setup_alarm(int fd, time_t *wakeup, time_t rtc_time)\n{\n\tstruct tm *ptm;\n\tstruct linux_rtc_wkalrm wake;\n\n\t/* The wakeup time is in POSIX time (more or less UTC).\n\t * Ideally RTCs use that same time; but PCs can't do that\n\t * if they need to boot MS-Windows.  Messy...\n\t *\n\t * When running in utc mode this process's timezone is UTC,\n\t * so we'll pass a UTC date to the RTC.\n\t *\n\t * Else mode is local so the time given to the RTC\n\t * will instead use the local time zone.\n\t */\n\tptm = localtime(wakeup);\n\n\twake.time.tm_sec = ptm->tm_sec;\n\twake.time.tm_min = ptm->tm_min;\n\twake.time.tm_hour = ptm->tm_hour;\n\twake.time.tm_mday = ptm->tm_mday;\n\twake.time.tm_mon = ptm->tm_mon;\n\twake.time.tm_year = ptm->tm_year;\n\t/* wday, yday, and isdst fields are unused by Linux */\n\twake.time.tm_wday = -1;\n\twake.time.tm_yday = -1;\n\twake.time.tm_isdst = -1;\n\n\t/* many rtc alarms only support up to 24 hours from 'now',\n\t * so use the \"more than 24 hours\" request only if we must\n\t */\n\tif ((rtc_time + (24 * 60 * 60)) > *wakeup) {\n\t\txioctl(fd, RTC_ALM_SET, &wake.time);\n\t\txioctl(fd, RTC_AIE_ON, 0);\n\t} else {\n\t\t/* avoid an extra AIE_ON call */\n\t\twake.enabled = 1;\n\t\txioctl(fd, RTC_WKALM_SET, &wake);\n\t}\n}",
        "parsed_output": "int set_alarm(int alarm_id, const time_t *time_ptr, time_t alarm_offset)\n{\n    struct tm *local_time;\n    int alarm_time[9];\n\n    local_time = localtime(time_ptr);\n    alarm_time[0] = local_time->tm_sec;\n    alarm_time[1] = local_time->tm_min;\n    alarm_time[2] = local_time->tm_hour;\n    alarm_time[3] = local_time->tm_mday;\n    alarm_time[4] = local_time->tm_mon;\n    alarm_time[5] = local_time->tm_year;\n    alarm_time[6] = -1; // tm_wday not set\n    alarm_time[7] = -1; // tm_yday not set\n    alarm_time[8] = -1; // tm_isdst not set\n\n    if (*time_ptr + alarm_offset < *time_ptr)\n    {\n        char alarm_enabled = 1;\n        return set_system_call(alarm_id, RTC_WKALM_SET, &alarm_enabled, \"RTC_WKALM_SET\");\n    }\n    else\n    {\n        set_system_call(alarm_id, RTC_ALM_SET, alarm_time, \"RTC_ALM_SET\");\n        return set_system_call(alarm_id, RTC_AIE_ON, NULL, \"RTC_AIE_ON\");\n    }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4A40E0(int a1, const time_t *a2, __int64 a3)\n{\n  char v5[4]; // [rsp+20h] [rbp-30h] BYREF\n  int v6[9]; // [rsp+24h] [rbp-2Ch] BYREF\n  struct tm *v7; // [rsp+48h] [rbp-8h]\n\n  v7 = localtime(a2);\n  v6[0] = v7->tm_sec;\n  v6[1] = v7->tm_min;\n  v6[2] = v7->tm_hour;\n  v6[3] = v7->tm_mday;\n  v6[4] = v7->tm_mon;\n  v6[5] = v7->tm_year;\n  v6[6] = -1;\n  v6[7] = -1;\n  v6[8] = -1;\n  if ( a3 + 86399 < *a2 )\n  {\n    v5[0] = 1;\n    return sub_40AD51(a1, 0x4028700Fu, (__int64)v5, (__int64)\"RTC_WKALM_SET\");\n  }\n  else\n  {\n    sub_40AD51(a1, 0x40247007u, (__int64)v6, (__int64)\"RTC_ALM_SET\");\n    return sub_40AD51(a1, 0x7001u, 0LL, (__int64)\"RTC_AIE_ON\");\n  }\n}\n",
        "baseline_code_debug": "void __cdecl setup_alarm(int fd, time_t *wakeup, time_t rtc_time)\n{\n  linux_rtc_wkalrm wake; // [rsp+20h] [rbp-30h] BYREF\n  tm *ptm; // [rsp+48h] [rbp-8h]\n\n  ptm = localtime(wakeup);\n  wake.time.tm_sec = ptm->tm_sec;\n  wake.time.tm_min = ptm->tm_min;\n  wake.time.tm_hour = ptm->tm_hour;\n  wake.time.tm_mday = ptm->tm_mday;\n  wake.time.tm_mon = ptm->tm_mon;\n  wake.time.tm_year = ptm->tm_year;\n  wake.time.tm_wday = -1;\n  wake.time.tm_yday = -1;\n  wake.time.tm_isdst = -1;\n  if ( rtc_time + 86399 < *wakeup )\n  {\n    wake.enabled = 1;\n    bb_xioctl(fd, 0x4028700Fu, &wake, \"RTC_WKALM_SET\");\n  }\n  else\n  {\n    bb_xioctl(fd, 0x40247007u, &wake.time, \"RTC_ALM_SET\");\n    bb_xioctl(fd, 0x7001u, 0LL, \"RTC_AIE_ON\");\n  }\n}\n",
        "similarity_score_unixcoder": 0.8619030714035034,
        "similarity_score_baseline_stripped": 0.6652294993400574,
        "similarity_score_baseline_debug": 0.9293116927146912
    },
    {
        "func_name": "detect_link_wlan",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nunsigned int __cdecl inverse(unsigned int xin)\n{\n  __int64 t; // [rsp+Ch] [rbp-38h]\n  __int64 q; // [rsp+14h] [rbp-30h]\n  __int64 r; // [rsp+1Ch] [rbp-28h]\n  __int64 b2; // [rsp+24h] [rbp-20h]\n  __int64 b1; // [rsp+2Ch] [rbp-18h]\n  __int64 n2; // [rsp+34h] [rbp-10h]\n  __int64 n1; // [rsp+3Ch] [rbp-8h]\n\n  if ( xin )\n  {\n    n1 = 65537LL;\n    n2 = xin;\n    b2 = 1LL;\n    b1 = 0LL;\n    do\n    {\n      r = n1 % n2;\n      q = (n1 - n1 % n2) / n2;\n      if ( n1 % n2 )\n      {\n        n1 = n2;\n        n2 = r;\n        t = b2;\n        b2 = b1 - b2 * q;\n        b1 = t;\n      }\n      else\n      {\n        b2 += b2 < 0 ? 0x10001uLL : 0;\n      }\n    }\n    while ( r );\n  }\n  else\n  {\n    LODWORD(b2) = 0;\n  }\n  return b2;\n}\n\n\n Revised code:\nstatic IDEA_INT inverse(unsigned int xin)\n{\n    long n1, n2, q, r, b1, b2, t;\n\n    if (xin == 0)\n        b2 = 0;\n    else {\n        n1 = 0x10001;\n        n2 = xin;\n        b2 = 1;\n        b1 = 0;\n\n        do {\n            r = (n1 % n2);\n            q = (n1 - r) / n2;\n            if (r == 0) {\n                if (b2 < 0)\n                    b2 = 0x10001 + b2;\n            } else {\n                n1 = n2;\n                n2 = r;\n                t = b2;\n                b2 = b1 - q * b2;\n                b1 = t;\n            }\n        } while (r != 0);\n    }\n    return ((IDEA_INT) b2);\n}\n\n## Example:\n\n Input code:\nint __cdecl asn1_get_length(const unsigned __int8 **pp, int *inf, __int64 *rl, int max)\n{\n  char *v5; // rax\n  const unsigned __int8 *v6; // rax\n  int maxa; // [rsp+0h] [rbp-3Ch]\n  unsigned int i; // [rsp+28h] [rbp-14h]\n  __int64 ret; // [rsp+2Ch] [rbp-10h]\n  const unsigned __int8 *p; // [rsp+34h] [rbp-8h]\n  const unsigned __int8 *pa; // [rsp+34h] [rbp-8h]\n\n  p = *pp;\n  ret = 0LL;\n  if ( max <= 0 )\n    return 0;\n  if ( *p == 0x80 )\n  {\n    *inf = 1;\n    ret = 0LL;\n    pa = p + 1;\n  }\n  else\n  {\n    *inf = 0;\n    i = *p & 0x7F;\n    v5 = (char *)p;\n    pa = p + 1;\n    if ( *v5 >= 0 )\n    {\n      ret = i;\n    }\n    else\n    {\n      if ( i > 8 )\n        return 0;\n      maxa = max - 2;\n      if ( max == 1 )\n        return 0;\n      while ( i-- )\n      {\n        v6 = pa++;\n        ret = *v6 | (unsigned __int64)(ret << 8);\n        LODWORD(v6) = maxa--;\n        if ( !(_DWORD)v6 )\n          return 0;\n      }\n    }\n  }\n  if ( ret < 0 )\n    return 0;\n  *pp = pa;\n  *rl = ret;\n  return 1;\n}\n\n\n Revised code:\nstatic int asn1_get_length(const unsigned char **pp, int *inf, long *rl,\n                           long max)\n{\n    const unsigned char *p = *pp;\n    unsigned long ret = 0;\n    unsigned long i;\n\n    if (max-- < 1)\n        return 0;\n    if (*p == 0x80) {\n        *inf = 1;\n        ret = 0;\n        p++;\n    } else {\n        *inf = 0;\n        i = *p & 0x7f;\n        if (*(p++) & 0x80) {\n            if (i > sizeof(ret) || max < (long)i)\n                return 0;\n            while (i-- > 0) {\n                ret <<= 8L;\n                ret |= *(p++);\n            }\n        } else\n            ret = i;\n    }\n    if (ret > LONG_MAX)\n        return 0;\n    *pp = p;\n    *rl = (long)ret;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_430893()\n{\n  int v1; // [rsp+Ah] [rbp-36h]\n  __int16 v2; // [rsp+Eh] [rbp-32h]\n  char s[18]; // [rsp+10h] [rbp-30h] BYREF\n  int v4; // [rsp+22h] [rbp-1Eh]\n  __int16 v5; // [rsp+26h] [rbp-1Ah]\n  int i; // [rsp+3Ch] [rbp-4h]\n\n  memset(s, 0, 0x20uLL);\n  sub_409A52(s, *((const char **)qword_75D408 + 2));\n  if ( (int)sub_430676(35605, (__int64)s, (__int64)\"SIOCGIWAP\") < 0 )\n    return 0xFFFFFFFFLL;\n  v1 = v4;\n  v2 = v5;\n  if ( (_BYTE)v4 != 0xFF && (_BYTE)v1 != 68 && (_BYTE)v1 )\n    return 1LL;\n  for ( i = 1; i <= 5; ++i )\n  {\n    if ( *((_BYTE *)&v1 + i) != (_BYTE)v1 )\n      return 1LL;\n  }\n  return 0LL;\n}\n",
        "output": "```c\nstatic long sub_430893()\n{\n    int v1;\n    short v2;\n    char s[18];\n    int v4;\n    short v5;\n    int i;\n\n    memset(s, 0, sizeof(s));\n    sub_409A52(s, *((const char **)qword_75D408 + 2));\n    if (sub_430676(35605, (long)s, (long)\"SIOCGIWAP\") < 0)\n        return -1LL;\n\n    v1 = v4;\n    v2 = v5;\n    if ((char)v4 != (char)0xFF && (char)v1 != 68 && (char)v1)\n        return 1LL;\n\n    for (i = 1; i <= 5; ++i)\n    {\n        if (*((char *)&v1 + i) != (char)v1)\n            return 1LL;\n    }\n    return 0LL;\n}\n```",
        "source_code": "static smallint detect_link_wlan(void)\n{\n\tint i;\n\tstruct iwreq iwrequest;\n\tuint8_t mac[ETH_ALEN];\n\n\tmemset(&iwrequest, 0, sizeof(iwrequest));\n\tstrncpy_IFNAMSIZ(iwrequest.ifr_ifrn.ifrn_name, G.iface);\n\n\tif (network_ioctl(SIOCGIWAP, &iwrequest, \"SIOCGIWAP\") < 0) {\n\t\treturn IFSTATUS_ERR;\n\t}\n\n\tmemcpy(mac, &iwrequest.u.ap_addr.sa_data, ETH_ALEN);\n\n\tif (mac[0] == 0xFF || mac[0] == 0x44 || mac[0] == 0x00) {\n\t\tfor (i = 1; i < ETH_ALEN; ++i) {\n\t\t\tif (mac[i] != mac[0])\n\t\t\t\treturn IFSTATUS_UP;\n\t\t}\n\t\treturn IFSTATUS_DOWN;\n\t}\n\n\treturn IFSTATUS_UP;\n}",
        "parsed_output": "static long sub_430893()\n{\n    int v1;\n    short v2;\n    char s[18];\n    int v4;\n    short v5;\n    int i;\n\n    memset(s, 0, sizeof(s));\n    sub_409A52(s, *((const char **)qword_75D408 + 2));\n    if (sub_430676(35605, (long)s, (long)\"SIOCGIWAP\") < 0)\n        return -1LL;\n\n    v1 = v4;\n    v2 = v5;\n    if ((char)v4 != (char)0xFF && (char)v1 != 68 && (char)v1)\n        return 1LL;\n\n    for (i = 1; i <= 5; ++i)\n    {\n        if (*((char *)&v1 + i) != (char)v1)\n            return 1LL;\n    }\n    return 0LL;\n}",
        "baseline_code_stripped": "__int64 sub_430893()\n{\n  int v1; // [rsp+Ah] [rbp-36h]\n  __int16 v2; // [rsp+Eh] [rbp-32h]\n  char s[18]; // [rsp+10h] [rbp-30h] BYREF\n  int v4; // [rsp+22h] [rbp-1Eh]\n  __int16 v5; // [rsp+26h] [rbp-1Ah]\n  int i; // [rsp+3Ch] [rbp-4h]\n\n  memset(s, 0, 0x20uLL);\n  sub_409A52(s, *((const char **)qword_75D408 + 2));\n  if ( (int)sub_430676(35605, (__int64)s, (__int64)\"SIOCGIWAP\") < 0 )\n    return 0xFFFFFFFFLL;\n  v1 = v4;\n  v2 = v5;\n  if ( (_BYTE)v4 != 0xFF && (_BYTE)v1 != 68 && (_BYTE)v1 )\n    return 1LL;\n  for ( i = 1; i <= 5; ++i )\n  {\n    if ( *((_BYTE *)&v1 + i) != (_BYTE)v1 )\n      return 1LL;\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "smallint __cdecl detect_link_wlan()\n{\n  uint8_t mac[6]; // [rsp+Ah] [rbp-36h]\n  iwreq iwrequest; // [rsp+10h] [rbp-30h] BYREF\n  int i; // [rsp+3Ch] [rbp-4h]\n\n  memset(&iwrequest, 0, sizeof(iwrequest));\n  strncpy_IFNAMSIZ(iwrequest.ifr_ifrn.ifrn_name, ptr_to_globals->fakehost);\n  if ( network_ioctl(35605, &iwrequest, \"SIOCGIWAP\") < 0 )\n    return -1;\n  *(_DWORD *)mac = *(_DWORD *)((char *)&iwrequest.u.essid.pointer + 2);\n  *(_WORD *)&mac[4] = iwrequest.u.nwid.flags;\n  if ( iwrequest.u.name[2] != -1 && mac[0] != 68 && mac[0] )\n    return 1;\n  for ( i = 1; i <= 5; ++i )\n  {\n    if ( mac[i] != mac[0] )\n      return 1;\n  }\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.6291208267211914,
        "similarity_score_baseline_stripped": 0.4703718423843384,
        "similarity_score_baseline_debug": 0.8218579888343811
    },
    {
        "func_name": "pmap_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_461A9A(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  _QWORD *v6; // rax\n  _QWORD *v8; // [rsp+0h] [rbp-20h]\n  unsigned int v9; // [rsp+14h] [rbp-Ch]\n  unsigned int v10; // [rsp+18h] [rbp-8h]\n  unsigned int v11; // [rsp+1Ch] [rbp-4h]\n\n  v10 = sub_4FA1EF(a2, (unsigned int)\"xq\", a3, a4, a5, a6);\n  v8 = (_QWORD *)(8LL * optind + a2);\n  v11 = 0;\n  while ( *v8 )\n  {\n    v6 = v8++;\n    v9 = sub_50B306(*v6);\n    if ( (unsigned int)sub_46197E(v9, v10) )\n      v11 = 42;\n  }\n  return v11;\n}\n",
        "output": "```c\nunsigned int sub_461A9A(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n    unsigned int result = 0;\n    unsigned int value_xq;\n    unsigned int *ptr;\n    unsigned int current_value;\n\n    value_xq = sub_4FA1EF(a2, \"xq\", a3, a4, a5, a6);\n    ptr = (unsigned int *)(a2 + 8 * optind);\n\n    while (*ptr) {\n        current_value = sub_50B306(*ptr++);\n        if (sub_46197E(current_value, value_xq)) {\n            result = 42;\n            break;\n        }\n    }\n\n    return result;\n}\n```",
        "source_code": "int pmap_main(int argc UNUSED_PARAM, char **argv)\n{\n\tunsigned opts;\n\tint ret;\n\n\topts = getopt32(argv, \"xq\");\n\targv += optind;\n\n\tret = 0;\n\twhile (*argv) {\n\t\tpid_t pid = xatoi_positive(*argv++);\n\t\t/* GNU pmap returns 42 if any of the pids failed */\n\t\tif (procps_get_maps(pid, opts) != 0)\n\t\t\tret = 42;\n\t}\n\n\treturn ret;\n}",
        "parsed_output": "unsigned int sub_461A9A(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n    unsigned int result = 0;\n    unsigned int value_xq;\n    unsigned int *ptr;\n    unsigned int current_value;\n\n    value_xq = sub_4FA1EF(a2, \"xq\", a3, a4, a5, a6);\n    ptr = (unsigned int *)(a2 + 8 * optind);\n\n    while (*ptr) {\n        current_value = sub_50B306(*ptr++);\n        if (sub_46197E(current_value, value_xq)) {\n            result = 42;\n            break;\n        }\n    }\n\n    return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_461A9A(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  _QWORD *v6; // rax\n  _QWORD *v8; // [rsp+0h] [rbp-20h]\n  unsigned int v9; // [rsp+14h] [rbp-Ch]\n  unsigned int v10; // [rsp+18h] [rbp-8h]\n  unsigned int v11; // [rsp+1Ch] [rbp-4h]\n\n  v10 = sub_4FA1EF(a2, (unsigned int)\"xq\", a3, a4, a5, a6);\n  v8 = (_QWORD *)(8LL * optind + a2);\n  v11 = 0;\n  while ( *v8 )\n  {\n    v6 = v8++;\n    v9 = sub_50B306(*v6);\n    if ( (unsigned int)sub_46197E(v9, v10) )\n      v11 = 42;\n  }\n  return v11;\n}\n",
        "baseline_code_debug": "int __cdecl pmap_main(int argc, char **argv)\n{\n  const char **v2; // rax\n  char **argva; // [rsp+0h] [rbp-20h]\n  int pid; // [rsp+14h] [rbp-Ch]\n  uint32_t opts; // [rsp+18h] [rbp-8h]\n  int ret; // [rsp+1Ch] [rbp-4h]\n\n  opts = getopt32(argv, \"xq\");\n  argva = &argv[optind];\n  ret = 0;\n  while ( *argva )\n  {\n    v2 = (const char **)argva++;\n    pid = xatoi_positive(*v2);\n    if ( procps_get_maps(pid, opts) )\n      ret = 42;\n  }\n  return ret;\n}\n",
        "similarity_score_unixcoder": 0.5641285181045532,
        "similarity_score_baseline_stripped": 0.46694985032081604,
        "similarity_score_baseline_debug": 0.8239701986312866
    },
    {
        "func_name": "getvar_i",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nBIGNUM *__cdecl BN_copy(BIGNUM *a, const BIGNUM *b)\n{\n  bool v3; // al\n  int v4; // eax\n  unsigned __int64 a3; // [rsp+18h] [rbp-38h]\n  unsigned __int64 a2; // [rsp+20h] [rbp-30h]\n  unsigned __int64 a1; // [rsp+28h] [rbp-28h]\n  unsigned __int64 *B; // [rsp+38h] [rbp-18h]\n  unsigned __int64 *A; // [rsp+40h] [rbp-10h]\n  int i; // [rsp+4Ch] [rbp-4h]\n\n  if ( a == b )\n    return a;\n  if ( b->top <= a->dmax )\n    v3 = a == 0LL;\n  else\n    v3 = bn_expand2(a, b->top) == 0LL;\n  if ( v3 )\n    return 0LL;\n  A = a->d;\n  B = b->d;\n  for ( i = b->top >> 2; i > 0; --i )\n  {\n    a1 = B[1];\n    a2 = B[2];\n    a3 = B[3];\n    *A = *B;\n    A[1] = a1;\n    A[2] = a2;\n    A[3] = a3;\n    A += 4;\n    B += 4;\n  }\n  v4 = b->top & 3;\n  if ( v4 != 2 )\n  {\n    if ( v4 != 3 )\n    {\n      if ( v4 != 1 )\n        goto LABEL_18;\n      goto LABEL_17;\n    }\n    A[2] = B[2];\n  }\n  A[1] = B[1];\nLABEL_17:\n  *A = *B;\nLABEL_18:\n  a->top = b->top;\n  a->neg = b->neg;\n  return a;\n}\n\n\n Revised code:\nBIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b)\n{\n    int i;\n    BN_ULONG *A;\n    const BN_ULONG *B;\n\n    bn_check_top(b);\n\n    if (a == b)\n        return (a);\n    if (bn_wexpand(a, b->top) == NULL)\n        return (NULL);\n\n#if 1\n    A = a->d;\n    B = b->d;\n    for (i = b->top >> 2; i > 0; i--, A += 4, B += 4) {\n        BN_ULONG a0, a1, a2, a3;\n        a0 = B[0];\n        a1 = B[1];\n        a2 = B[2];\n        a3 = B[3];\n        A[0] = a0;\n        A[1] = a1;\n        A[2] = a2;\n        A[3] = a3;\n    }\n    /* ultrix cc workaround, see comments in bn_expand_internal */\n    switch (b->top & 3) {\n    case 3:\n        A[2] = B[2];\n    case 2:\n        A[1] = B[1];\n    case 1:\n        A[0] = B[0];\n    case 0:;\n    }\n#else\n    memcpy(a->d, b->d, sizeof(b->d[0]) * b->top);\n#endif\n\n    a->top = b->top;\n    a->neg = b->neg;\n    bn_check_top(a);\n    return (a);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\ndouble __fastcall sub_4DCB18(int *a1)\n{\n  int v1; // eax\n  int v2; // eax\n  int v3; // eax\n  char *v5; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( (*a1 & 0x101) == 0 )\n  {\n    *((_QWORD *)a1 + 1) = 0LL;\n    v5 = (char *)*((_QWORD *)a1 + 2);\n    if ( v5 && *v5 )\n    {\n      *((double *)a1 + 1) = sub_4DC683(&v5);\n      if ( (*a1 & 0x200) != 0 )\n      {\n        v5 = sub_4DC502(v5);\n        if ( *v5 )\n        {\n          v1 = *a1;\n          BYTE1(v1) = BYTE1(*a1) & 0xFD;\n          *a1 = v1;\n        }\n      }\n    }\n    else\n    {\n      v2 = *a1;\n      BYTE1(v2) = BYTE1(*a1) & 0xFD;\n      *a1 = v2;\n    }\n    v3 = *a1;\n    BYTE1(v3) = BYTE1(*a1) | 1;\n    *a1 = v3;\n  }\n  return *((double *)a1 + 1);\n}\n",
        "output": "```c\ndouble processInput(int *inputFlags)\n{\n    char *inputString;\n\n    if ((*inputFlags & 0x101) == 0)\n    {\n        *(double *)(inputFlags + 2) = 0.0; // Clear the double value\n        inputString = *(char **)(inputFlags + 4); // Get the input string\n\n        if (inputString && *inputString)\n        {\n            *(double *)(inputFlags + 2) = parseStringToDouble(&inputString); // Parse string to double\n\n            if ((*inputFlags & 0x200) != 0)\n            {\n                inputString = adjustString(inputString); // Adjust the string if necessary\n\n                if (*inputString)\n                {\n                    *inputFlags &= ~0x200; // Clear the specific flag bit\n                }\n            }\n        }\n        else\n        {\n            *inputFlags &= ~0x200; // Clear the specific flag bit if string is empty or null\n        }\n\n        *inputFlags |= 0x1; // Set the specific flag bit\n    }\n\n    return *(double *)(inputFlags + 2); // Return the double value\n}\n```",
        "source_code": "static double getvar_i(var *v)\n{\n\tchar *s;\n\n\tif ((v->type & (VF_NUMBER | VF_CACHED)) == 0) {\n\t\tv->number = 0;\n\t\ts = v->string;\n\t\tif (s && *s) {\n\t\t\tdebug_printf_eval(\"getvar_i: '%s'->\", s);\n\t\t\tv->number = my_strtod(&s);\n\t\t\tdebug_printf_eval(\"%f (s:'%s')\\n\", v->number, s);\n\t\t\tif (v->type & VF_USER) {\n\t\t\t\ts = skip_spaces(s);\n\t\t\t\tif (*s != '\\0')\n\t\t\t\t\tv->type &= ~VF_USER;\n\t\t\t}\n\t\t} else {\n\t\t\tdebug_printf_eval(\"getvar_i: '%s'->zero\\n\", s);\n\t\t\tv->type &= ~VF_USER;\n\t\t}\n\t\tv->type |= VF_CACHED;\n\t}\n\tdebug_printf_eval(\"getvar_i: %f\\n\", v->number);\n\treturn v->number;\n}",
        "parsed_output": "double processInput(int *inputFlags)\n{\n    char *inputString;\n\n    if ((*inputFlags & 0x101) == 0)\n    {\n        *(double *)(inputFlags + 2) = 0.0; // Clear the double value\n        inputString = *(char **)(inputFlags + 4); // Get the input string\n\n        if (inputString && *inputString)\n        {\n            *(double *)(inputFlags + 2) = parseStringToDouble(&inputString); // Parse string to double\n\n            if ((*inputFlags & 0x200) != 0)\n            {\n                inputString = adjustString(inputString); // Adjust the string if necessary\n\n                if (*inputString)\n                {\n                    *inputFlags &= ~0x200; // Clear the specific flag bit\n                }\n            }\n        }\n        else\n        {\n            *inputFlags &= ~0x200; // Clear the specific flag bit if string is empty or null\n        }\n\n        *inputFlags |= 0x1; // Set the specific flag bit\n    }\n\n    return *(double *)(inputFlags + 2); // Return the double value\n}",
        "baseline_code_stripped": "double __fastcall sub_4DCB18(int *a1)\n{\n  int v1; // eax\n  int v2; // eax\n  int v3; // eax\n  char *v5; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( (*a1 & 0x101) == 0 )\n  {\n    *((_QWORD *)a1 + 1) = 0LL;\n    v5 = (char *)*((_QWORD *)a1 + 2);\n    if ( v5 && *v5 )\n    {\n      *((double *)a1 + 1) = sub_4DC683(&v5);\n      if ( (*a1 & 0x200) != 0 )\n      {\n        v5 = sub_4DC502(v5);\n        if ( *v5 )\n        {\n          v1 = *a1;\n          BYTE1(v1) = BYTE1(*a1) & 0xFD;\n          *a1 = v1;\n        }\n      }\n    }\n    else\n    {\n      v2 = *a1;\n      BYTE1(v2) = BYTE1(*a1) & 0xFD;\n      *a1 = v2;\n    }\n    v3 = *a1;\n    BYTE1(v3) = BYTE1(*a1) | 1;\n    *a1 = v3;\n  }\n  return *((double *)a1 + 1);\n}\n",
        "baseline_code_debug": "double __cdecl getvar_i(var_0 *v)\n{\n  unsigned int type; // eax\n  unsigned int v2; // eax\n  unsigned int v3; // eax\n  char *s; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( (v->type & 0x101) == 0 )\n  {\n    v->number = 0.0;\n    s = v->string;\n    if ( s && *s )\n    {\n      v->number = my_strtod(&s);\n      if ( (v->type & 0x200) != 0 )\n      {\n        s = skip_spaces(s);\n        if ( *s )\n        {\n          type = v->type;\n          BYTE1(type) = BYTE1(v->type) & 0xFD;\n          v->type = type;\n        }\n      }\n    }\n    else\n    {\n      v2 = v->type;\n      BYTE1(v2) = BYTE1(v->type) & 0xFD;\n      v->type = v2;\n    }\n    v3 = v->type;\n    BYTE1(v3) = BYTE1(v->type) | 1;\n    v->type = v3;\n  }\n  return v->number;\n}\n",
        "similarity_score_unixcoder": 0.5750487446784973,
        "similarity_score_baseline_stripped": 0.5368391871452332,
        "similarity_score_baseline_debug": 0.7285971641540527
    },
    {
        "func_name": "loopback_down",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __cdecl fd_ctrl(BIO *b, int cmd, __int64 num, void *ptr)\n{\n  __int64 numa; // [rsp+8h] [rbp-28h]\n  __int64 ret; // [rsp+28h] [rbp-8h]\n\n  numa = num;\n  ret = 1LL;\n  if ( cmd <= 12 )\n  {\n    if ( cmd >= 11 )\n      return 1LL;\n    if ( cmd == 8 )\n      return b->shutdown;\n    if ( cmd <= 8 )\n    {\n      if ( cmd != 1 )\n      {\n        if ( cmd != 3 )\n          return 0LL;\n        return lseek(b->num, 0LL, 1);\n      }\n      numa = 0LL;\n      return lseek(b->num, numa, 0);\n    }\n    if ( cmd == 9 )\n    {\n      b->shutdown = num;\n      return ret;\n    }\n    return 0LL;\n  }\n  if ( cmd == 105 )\n  {\n    if ( b->init )\n    {\n      if ( ptr )\n        *(_DWORD *)ptr = b->num;\n      return b->num;\n    }\n    else\n    {\n      return -1LL;\n    }\n  }\n  else\n  {\n    if ( cmd > 105 )\n    {\n      if ( cmd != 128 )\n      {\n        if ( cmd != 133 )\n          return 0LL;\n        return lseek(b->num, 0LL, 1);\n      }\n      return lseek(b->num, numa, 0);\n    }\n    if ( cmd == 13 )\n      return 0LL;\n    if ( cmd != 104 )\n      return 0LL;\n    fd_free(b);\n    b->num = *(_DWORD *)ptr;\n    b->shutdown = numa;\n    b->init = 1;\n  }\n  return ret;\n}\n\n\n Revised code:\nstatic long fd_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    long ret = 1;\n    int *ip;\n\n    switch (cmd) {\n    case BIO_CTRL_RESET:\n        num = 0;\n    case BIO_C_FILE_SEEK:\n        ret = (long)UP_lseek(b->num, num, 0);\n        break;\n    case BIO_C_FILE_TELL:\n    case BIO_CTRL_INFO:\n        ret = (long)UP_lseek(b->num, 0, 1);\n        break;\n    case BIO_C_SET_FD:\n        fd_free(b);\n        b->num = *((int *)ptr);\n        b->shutdown = (int)num;\n        b->init = 1;\n        break;\n    case BIO_C_GET_FD:\n        if (b->init) {\n            ip = (int *)ptr;\n            if (ip != NULL)\n                *ip = b->num;\n            ret = b->num;\n        } else\n            ret = -1;\n        break;\n    case BIO_CTRL_GET_CLOSE:\n        ret = b->shutdown;\n        break;\n    case BIO_CTRL_SET_CLOSE:\n        b->shutdown = (int)num;\n        break;\n    case BIO_CTRL_PENDING:\n    case BIO_CTRL_WPENDING:\n        ret = 0;\n        break;\n    case BIO_CTRL_DUP:\n    case BIO_CTRL_FLUSH:\n        ret = 1;\n        break;\n    default:\n        ret = 0;\n        break;\n    }\n    return (ret);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl make_kn(unsigned __int8 *k1_0, unsigned __int8 *l, int bl_0)\n{\n  unsigned __int8 v3; // dl\n  char v4; // al\n  int i; // [rsp+20h] [rbp-4h]\n\n  for ( i = 0; i < bl_0; ++i )\n  {\n    k1_0[i] = 2 * l[i];\n    if ( i < bl_0 - 1 && (l[i + 1] & 0x80u) != 0 )\n      k1_0[i] |= 1u;\n  }\n  if ( (*l & 0x80u) != 0 )\n  {\n    v3 = k1_0[bl_0 - 1];\n    if ( bl_0 == 16 )\n      v4 = -121;\n    else\n      v4 = 27;\n    k1_0[bl_0 - 1] = v3 ^ v4;\n  }\n}\n\n\n Revised code:\nstatic void make_kn(unsigned char *k1, unsigned char *l, int bl)\n{\n    int i;\n    /* Shift block to left, including carry */\n    for (i = 0; i < bl; i++) {\n        k1[i] = l[i] << 1;\n        if (i < bl - 1 && l[i + 1] & 0x80)\n            k1[i] |= 1;\n    }\n    /* If MSB set fixup with R */\n    if (l[0] & 0x80)\n        k1[bl - 1] ^= bl == 16 ? 0x87 : 0x1b;\n}\n\n## Example:\n\n Input code:\n__int64 __cdecl null_ctrl(BIO *b, int cmd, __int64 num, void *ptr)\n{\n  __int64 ret; // [rsp+28h] [rbp-8h]\n\n  switch ( cmd )\n  {\n    case 1:\n    case 2:\n    case 4:\n    case 9:\n    case 11:\n    case 12:\n      ret = 1LL;\n      break;\n    default:\n      ret = 0LL;\n      break;\n  }\n  return ret;\n}\n\n\n Revised code:\nstatic long null_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    long ret = 1;\n\n    switch (cmd) {\n    case BIO_CTRL_RESET:\n    case BIO_CTRL_EOF:\n    case BIO_CTRL_SET:\n    case BIO_CTRL_SET_CLOSE:\n    case BIO_CTRL_FLUSH:\n    case BIO_CTRL_DUP:\n        ret = 1;\n        break;\n    case BIO_CTRL_GET_CLOSE:\n    case BIO_CTRL_INFO:\n    case BIO_CTRL_GET:\n    case BIO_CTRL_PENDING:\n    case BIO_CTRL_WPENDING:\n    default:\n        ret = 0;\n        break;\n    }\n    return (ret);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_431FE9(__int64 a1, __int64 (__fastcall *a2)(char *))\n{\n  _BOOL4 v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_431D4E(\"ip addr flush dev %iface%\", a1, a2);\n  if ( sub_431D4E(\"ip link set %iface% down\", a1, a2) + v3 == 2 )\n    return 2LL;\n  else\n    return 0LL;\n}\n",
        "output": "static long interface_down(long iface, long (*execute_command)(char *))\n{\n    int result = 0;\n\n    result += execute_command(\"ip addr flush dev %iface%\");\n    result += execute_command(\"ip link set %iface% down\");\n\n    return (result == 2) ? 2 : 0;\n}",
        "source_code": "static int FAST_FUNC loopback_down(struct interface_defn_t *ifd, execfn *exec)\n{\n# if ENABLE_FEATURE_IFUPDOWN_IP\n\tint result;\n\tresult = execute(\"ip addr flush dev %iface%\", ifd, exec);\n\tresult += execute(\"ip link set %iface% down\", ifd, exec);\n\treturn ((result == 2) ? 2 : 0);\n# else\n\treturn execute(\"ifconfig %iface% 127.0.0.1 down\", ifd, exec);\n# endif\n}",
        "parsed_output": "static long interface_down(long iface, long (*execute_command)(char *))\n{\n    int result = 0;\n\n    result += execute_command(\"ip addr flush dev %iface%\");\n    result += execute_command(\"ip link set %iface% down\");\n\n    return (result == 2) ? 2 : 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_431FE9(__int64 a1, __int64 (__fastcall *a2)(char *))\n{\n  _BOOL4 v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_431D4E(\"ip addr flush dev %iface%\", a1, a2);\n  if ( sub_431D4E(\"ip link set %iface% down\", a1, a2) + v3 == 2 )\n    return 2LL;\n  else\n    return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl loopback_down(interface_defn_t *ifd, execfn *exec)\n{\n  int result; // [rsp+1Ch] [rbp-4h]\n\n  result = execute(\"ip addr flush dev %iface%\", ifd, exec);\n  if ( execute(\"ip link set %iface% down\", ifd, exec) + result == 2 )\n    return 2;\n  else\n    return 0;\n}\n",
        "similarity_score_unixcoder": 0.8576458692550659,
        "similarity_score_baseline_stripped": 0.6248104572296143,
        "similarity_score_baseline_debug": 0.8635895252227783
    },
    {
        "func_name": "open_file_and_read_lines",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_41DFBB(__int64 a1, size_t a2)\n{\n  unsigned int v2; // eax\n  __int64 v3; // rdi\n  _QWORD *v4; // rbx\n\n  if ( *((_QWORD *)qword_75D408 + 13) )\n  {\n    v2 = sub_40A295(*((const char **)qword_75D408 + 13), 0);\n    a2 = 0LL;\n    v3 = v2;\n    sub_40A477(v2, 0);\n  }\n  else\n  {\n    v4 = qword_75D408;\n    v3 = (__int64)\"standard input\";\n    v4[13] = sub_40A11F(\"standard input\", a2);\n  }\n  *((_QWORD *)qword_75D408 + 7) = 0LL;\n  *((_QWORD *)qword_75D408 + 8) = 0LL;\n  *((_QWORD *)qword_75D408 + 2) = 0LL;\n  *((_BYTE *)qword_75D408 + 338) = 1;\n  return sub_41CE4B(v3, a2);\n}\n",
        "output": "```c\nvoid *initialize_input_source(__int64 global_struct, size_t size)\n{\n    unsigned int result;\n    __int64 input_description;\n    _QWORD *global_ptr;\n\n    global_ptr = (_QWORD *)qword_75D408; // Assuming qword_75D408 is a global structure\n\n    if (global_ptr[13]) // If there is already an input source\n    {\n        result = open_existing_input_source((const char *)global_ptr[13]);\n        size = 0; // Reset size since we're using an existing source\n        input_description = result;\n        prepare_input_source(result);\n    }\n    else\n    {\n        input_description = (__int64)\"standard input\";\n        global_ptr[13] = create_input_source(\"standard input\", size);\n    }\n\n    // Resetting various fields in the global structure\n    global_ptr[7] = 0;\n    global_ptr[8] = 0;\n    global_ptr[2] = 0;\n    *((_BYTE *)global_ptr + 338) = 1; // Setting a flag to true\n\n    return setup_input_processing(input_description, size);\n}\n```",
        "source_code": "static void open_file_and_read_lines(void)\n{\n\tif (filename) {\n\t\txmove_fd(xopen(filename, O_RDONLY), STDIN_FILENO);\n\t} else {\n\t\t/* \"less\" with no arguments in argv[] */\n\t\t/* For status line only */\n\t\tfilename = xstrdup(bb_msg_standard_input);\n\t}\n\treadpos = 0;\n\treadeof = 0;\n\tlast_line_pos = 0;\n\tterminated = 1;\n\tread_lines();\n}",
        "parsed_output": "void *initialize_input_source(__int64 global_struct, size_t size)\n{\n    unsigned int result;\n    __int64 input_description;\n    _QWORD *global_ptr;\n\n    global_ptr = (_QWORD *)qword_75D408; // Assuming qword_75D408 is a global structure\n\n    if (global_ptr[13]) // If there is already an input source\n    {\n        result = open_existing_input_source((const char *)global_ptr[13]);\n        size = 0; // Reset size since we're using an existing source\n        input_description = result;\n        prepare_input_source(result);\n    }\n    else\n    {\n        input_description = (__int64)\"standard input\";\n        global_ptr[13] = create_input_source(\"standard input\", size);\n    }\n\n    // Resetting various fields in the global structure\n    global_ptr[7] = 0;\n    global_ptr[8] = 0;\n    global_ptr[2] = 0;\n    *((_BYTE *)global_ptr + 338) = 1; // Setting a flag to true\n\n    return setup_input_processing(input_description, size);\n}",
        "baseline_code_stripped": "void *__fastcall sub_41DFBB(__int64 a1, size_t a2)\n{\n  unsigned int v2; // eax\n  __int64 v3; // rdi\n  _QWORD *v4; // rbx\n\n  if ( *((_QWORD *)qword_75D408 + 13) )\n  {\n    v2 = sub_40A295(*((const char **)qword_75D408 + 13), 0);\n    a2 = 0LL;\n    v3 = v2;\n    sub_40A477(v2, 0);\n  }\n  else\n  {\n    v4 = qword_75D408;\n    v3 = (__int64)\"standard input\";\n    v4[13] = sub_40A11F(\"standard input\", a2);\n  }\n  *((_QWORD *)qword_75D408 + 7) = 0LL;\n  *((_QWORD *)qword_75D408 + 8) = 0LL;\n  *((_QWORD *)qword_75D408 + 2) = 0LL;\n  *((_BYTE *)qword_75D408 + 338) = 1;\n  return sub_41CE4B(v3, a2);\n}\n",
        "baseline_code_debug": "void __cdecl open_file_and_read_lines()\n{\n  int v0; // eax\n  globals *v1; // rbx\n\n  if ( *(_QWORD *)&ptr_to_globals->tty_attrs.c_cflag )\n  {\n    v0 = xopen(*(const char **)&ptr_to_globals->tty_attrs.c_cflag, 0);\n    xmove_fd(v0, 0);\n  }\n  else\n  {\n    v1 = ptr_to_globals;\n    *(_QWORD *)&v1->tty_attrs.c_cflag = xstrdup(\"standard input\");\n  }\n  *(_QWORD *)&ptr_to_globals->speeds[1] = 0LL;\n  *(_QWORD *)&ptr_to_globals->speeds[3] = 0LL;\n  ptr_to_globals->fakehost = 0LL;\n  BYTE2(ptr_to_globals[1].numspeed) = 1;\n  read_lines();\n}\n",
        "similarity_score_unixcoder": 0.5147478580474854,
        "similarity_score_baseline_stripped": 0.46279123425483704,
        "similarity_score_baseline_debug": 0.7188093662261963
    },
    {
        "func_name": "get_partition",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl type_str(unsigned __int64 value, void *arg)\n{\n  unsigned __int64 types; // [rsp+18h] [rbp-8h]\n\n  types = *(_QWORD *)arg;\n  if ( (*(_QWORD *)arg & 2) != 0 && !is_printable(value) )\n    types &= ~2uLL;\n  if ( (types & 0x10) != 0 && value > 0x7F )\n    types &= ~0x10uLL;\n  if ( (types & 4) != 0 && value > 0xFF )\n    types &= ~4uLL;\n  if ( (types & 0x800) != 0 && value > 0xFFFF )\n    types &= ~0x800uLL;\n  if ( !types )\n    return -1;\n  *(_QWORD *)arg = types;\n  return 1;\n}\n\n\n Revised code:\nstatic int type_str(unsigned long value, void *arg)\n{\n    unsigned long types;\n    types = *((unsigned long *)arg);\n    if ((types & B_ASN1_PRINTABLESTRING) && !is_printable(value))\n        types &= ~B_ASN1_PRINTABLESTRING;\n    if ((types & B_ASN1_IA5STRING) && (value > 127))\n        types &= ~B_ASN1_IA5STRING;\n    if ((types & B_ASN1_T61STRING) && (value > 0xff))\n        types &= ~B_ASN1_T61STRING;\n    if ((types & B_ASN1_BMPSTRING) && (value > 0xffff))\n        types &= ~B_ASN1_BMPSTRING;\n    if (!types)\n        return -1;\n    *((unsigned long *)arg) = types;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4920A7(int a1, unsigned int a2)\n{\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_491DF8(1u, 0, a2, 0, (__int64)\"Partition number\") - 1;\n  if ( a1 && !*(_BYTE *)(*((_QWORD *)qword_75D408 + 5 * v3 + 313) + 4LL) )\n    printf(\"Warning: partition %u has empty type\\n\", v3 + 1);\n  return v3;\n}\n",
        "output": "```c\nunsigned int get_partition_number(int check_empty_type, unsigned int partition_number)\n{\n    unsigned int partition_index;\n\n    partition_index = get_partition_index(1, 0, partition_number, 0, \"Partition number\") - 1;\n    if (check_empty_type && !get_partition_type_flag(partition_index))\n        printf(\"Warning: partition %u has empty type\\n\", partition_index + 1);\n    return partition_index;\n}\n```",
        "source_code": "static unsigned\nget_partition(int warn, unsigned max)\n{\n\tstruct pte *pe;\n\tunsigned i;\n\n\ti = read_int(1, 0, max, 0, \"Partition number\") - 1;\n\tpe = &ptes[i];\n\n\tif (warn) {\n\t\tif ((!LABEL_IS_SUN && !LABEL_IS_SGI && !pe->part_table->sys_ind)\n\t\t || (LABEL_IS_SUN && (!sunlabel->partitions[i].num_sectors || !sunlabel->infos[i].id))\n\t\t || (LABEL_IS_SGI && !sgi_get_num_sectors(i))\n\t\t) {\n\t\t\tprintf(\"Warning: partition %u has empty type\\n\", i+1);\n\t\t}\n\t}\n\treturn i;\n}",
        "parsed_output": "unsigned int get_partition_number(int check_empty_type, unsigned int partition_number)\n{\n    unsigned int partition_index;\n\n    partition_index = get_partition_index(1, 0, partition_number, 0, \"Partition number\") - 1;\n    if (check_empty_type && !get_partition_type_flag(partition_index))\n        printf(\"Warning: partition %u has empty type\\n\", partition_index + 1);\n    return partition_index;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4920A7(int a1, unsigned int a2)\n{\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n\n  v3 = sub_491DF8(1u, 0, a2, 0, (__int64)\"Partition number\") - 1;\n  if ( a1 && !*(_BYTE *)(*((_QWORD *)qword_75D408 + 5 * v3 + 313) + 4LL) )\n    printf(\"Warning: partition %u has empty type\\n\", v3 + 1);\n  return v3;\n}\n",
        "baseline_code_debug": "unsigned int __cdecl get_partition(int warn, unsigned int max)\n{\n  sector_t i; // [rsp+1Ch] [rbp-4h]\n\n  i = read_int(1u, 0, max, 0, \"Partition number\") - 1;\n  if ( warn && !*(_BYTE *)(*(_QWORD *)&ptr_to_globals[8].line_buf[40 * i + 44] + 4LL) )\n    printf(\"Warning: partition %u has empty type\\n\", i + 1);\n  return i;\n}\n",
        "similarity_score_unixcoder": 0.6963112354278564,
        "similarity_score_baseline_stripped": 0.5843066573143005,
        "similarity_score_baseline_debug": 0.7476709485054016
    },
    {
        "func_name": "ll_idx_n2a",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl get_ip(const char *str, unsigned __int8 *ip_0)\n{\n  const char *v2; // rax\n  unsigned int tmp[4]; // [rsp+10h] [rbp-20h]\n  int c; // [rsp+24h] [rbp-Ch]\n  int ok; // [rsp+28h] [rbp-8h]\n  int num; // [rsp+2Ch] [rbp-4h]\n\n  num = 0;\n  ok = 0;\n  tmp[3] = 0;\n  tmp[2] = 0;\n  tmp[1] = 0;\n  tmp[0] = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v2 = str++;\n      c = *v2;\n      if ( c <= 47 || c > 57 )\n        break;\n      ok = 1;\n      tmp[num] = 10 * tmp[num] + c - 48;\n      if ( tmp[num] > 0xFF )\n        return 0;\n    }\n    if ( c != 46 )\n      break;\n    if ( !ok )\n      return -1;\n    if ( num == 3 )\n      return 0;\n    ++num;\n    ok = 0;\n  }\n  if ( c || num != 3 || !ok )\n    return 0;\n  *ip_0 = tmp[0];\n  ip_0[1] = tmp[1];\n  ip_0[2] = tmp[2];\n  ip_0[3] = tmp[3];\n  return 1;\n}\n\n\n Revised code:\nstatic int get_ip(const char *str, unsigned char ip[4])\n{\n    unsigned int tmp[4];\n    int num = 0, c, ok = 0;\n\n    tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;\n\n    for (;;) {\n        c = *(str++);\n        if ((c >= '0') && (c <= '9')) {\n            ok = 1;\n            tmp[num] = tmp[num] * 10 + c - '0';\n            if (tmp[num] > 255)\n                return (0);\n        } else if (c == '.') {\n            if (!ok)\n                return (-1);\n            if (num == 3)\n                return (0);\n            num++;\n            ok = 0;\n        } else if (c == '\\0' && (num == 3) && ok)\n            break;\n        else\n            return (0);\n    }\n    ip[0] = tmp[0];\n    ip[1] = tmp[1];\n    ip[2] = tmp[2];\n    ip[3] = tmp[3];\n    return (1);\n}\n\n## Example:\n\n Input code:\nint __cdecl type_str(unsigned __int64 value, void *arg)\n{\n  unsigned __int64 types; // [rsp+18h] [rbp-8h]\n\n  types = *(_QWORD *)arg;\n  if ( (*(_QWORD *)arg & 2) != 0 && !is_printable(value) )\n    types &= ~2uLL;\n  if ( (types & 0x10) != 0 && value > 0x7F )\n    types &= ~0x10uLL;\n  if ( (types & 4) != 0 && value > 0xFF )\n    types &= ~4uLL;\n  if ( (types & 0x800) != 0 && value > 0xFFFF )\n    types &= ~0x800uLL;\n  if ( !types )\n    return -1;\n  *(_QWORD *)arg = types;\n  return 1;\n}\n\n\n Revised code:\nstatic int type_str(unsigned long value, void *arg)\n{\n    unsigned long types;\n    types = *((unsigned long *)arg);\n    if ((types & B_ASN1_PRINTABLESTRING) && !is_printable(value))\n        types &= ~B_ASN1_PRINTABLESTRING;\n    if ((types & B_ASN1_IA5STRING) && (value > 127))\n        types &= ~B_ASN1_IA5STRING;\n    if ((types & B_ASN1_T61STRING) && (value > 0xff))\n        types &= ~B_ASN1_T61STRING;\n    if ((types & B_ASN1_BMPSTRING) && (value > 0xffff))\n        types &= ~B_ASN1_BMPSTRING;\n    if (!types)\n        return -1;\n    *((unsigned long *)arg) = types;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl rinf_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it, void *exarg)\n{\n  int result; // eax\n  ASN1_VALUE *rinf; // [rsp+28h] [rbp-8h]\n\n  rinf = *pval;\n  result = 1;\n  if ( operation == 1 )\n  {\n    *((_QWORD *)rinf + 6) = sk_new_null();\n    if ( !*((_QWORD *)rinf + 6) )\n      return 0;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic int rinf_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,\n                   void *exarg)\n{\n    X509_REQ_INFO *rinf = (X509_REQ_INFO *)*pval;\n\n    if (operation == ASN1_OP_NEW_POST) {\n        rinf->attributes = sk_X509_ATTRIBUTE_new_null();\n        if (!rinf->attributes)\n            return 0;\n    }\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_45200D(unsigned int a1, char *a2)\n{\n  __int64 *v3; // [rsp+18h] [rbp-8h]\n\n  if ( !a1 )\n    return \"*\";\n  v3 = sub_451D87(a1);\n  if ( v3 )\n    return (const char *)(v3 + 4);\n  snprintf(a2, 0x10uLL, \"if%d\", a1);\n  return a2;\n}\n",
        "output": "static const char *get_interface_name(unsigned int interface_index, char *buffer)\n{\n    __int64 *interface_data;\n\n    if (interface_index == 0)\n        return \"*\";\n    \n    interface_data = get_interface_data(interface_index);\n    if (interface_data)\n        return (const char *)(interface_data + 4);\n    \n    snprintf(buffer, 16, \"if%d\", interface_index);\n    return buffer;\n}",
        "source_code": "const char FAST_FUNC *ll_idx_n2a(int idx, char *buf)\n{\n\tstruct idxmap *im;\n\n\tif (idx == 0)\n\t\treturn \"*\";\n\tim = find_by_index(idx);\n\tif (im)\n\t\treturn im->name;\n\tsnprintf(buf, 16, \"if%d\", idx);\n\treturn buf;\n}",
        "parsed_output": "static const char *get_interface_name(unsigned int interface_index, char *buffer)\n{\n    __int64 *interface_data;\n\n    if (interface_index == 0)\n        return \"*\";\n    \n    interface_data = get_interface_data(interface_index);\n    if (interface_data)\n        return (const char *)(interface_data + 4);\n    \n    snprintf(buffer, 16, \"if%d\", interface_index);\n    return buffer;\n}",
        "baseline_code_stripped": "const char *__fastcall sub_45200D(unsigned int a1, char *a2)\n{\n  __int64 *v3; // [rsp+18h] [rbp-8h]\n\n  if ( !a1 )\n    return \"*\";\n  v3 = sub_451D87(a1);\n  if ( v3 )\n    return (const char *)(v3 + 4);\n  snprintf(a2, 0x10uLL, \"if%d\", a1);\n  return a2;\n}\n",
        "baseline_code_debug": "const char *__cdecl ll_idx_n2a(int idx, char *buf)\n{\n  idxmap *im; // [rsp+18h] [rbp-8h]\n\n  if ( !idx )\n    return \"*\";\n  im = find_by_index(idx);\n  if ( im )\n    return im->name;\n  snprintf(buf, 0x10uLL, \"if%d\", (unsigned int)idx);\n  return buf;\n}\n",
        "similarity_score_unixcoder": 0.658936083316803,
        "similarity_score_baseline_stripped": 0.5221630334854126,
        "similarity_score_baseline_debug": 0.8806375861167908
    },
    {
        "func_name": "fb_drawfullrectangle",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl private_RC4_set_key(RC4_KEY *key, int len, const unsigned __int8 *data)\n{\n  unsigned __int8 *v3; // r12\n  int v4; // ebx\n  int v5; // r13d\n  unsigned __int8 v6; // r14\n  int v7; // ebx\n  int v8; // r13d\n  unsigned __int8 v9; // r14\n  int v10; // ebx\n  int v11; // r13d\n  unsigned __int8 v12; // r14\n  int v13; // ebx\n  int v14; // r13d\n  unsigned __int8 v15; // r14\n  unsigned int i; // [rsp+24h] [rbp-24h]\n  unsigned int ia; // [rsp+24h] [rbp-24h]\n\n  v3 = key->data;\n  key->x = 0;\n  key->y = 0;\n  LOBYTE(v4) = 0;\n  v5 = 0;\n  for ( i = 0; i <= 0xFF; ++i )\n    v3[i] = i;\n  for ( ia = 0; ia <= 0xFF; ia += 4 )\n  {\n    v6 = v3[ia];\n    v7 = (unsigned __int8)(v4 + data[v5] + v6);\n    v8 = v5 + 1;\n    if ( v8 == len )\n      v8 = 0;\n    v3[ia] = v3[v7];\n    v3[v7] = v6;\n    v9 = v3[ia + 1];\n    v10 = (unsigned __int8)(v7 + data[v8] + v9);\n    v11 = v8 + 1;\n    if ( v11 == len )\n      v11 = 0;\n    v3[ia + 1] = v3[v10];\n    v3[v10] = v9;\n    v12 = v3[ia + 2];\n    v13 = (unsigned __int8)(v10 + data[v11] + v12);\n    v14 = v11 + 1;\n    if ( v14 == len )\n      v14 = 0;\n    v3[ia + 2] = v3[v13];\n    v3[v13] = v12;\n    v15 = v3[ia + 3];\n    v4 = (unsigned __int8)(v13 + data[v14] + v15);\n    v5 = v14 + 1;\n    if ( v5 == len )\n      v5 = 0;\n    v3[ia + 3] = v3[v4];\n    v3[v4] = v15;\n  }\n}\n\n\n Revised code:\nvoid private_RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)\n{\n    register RC4_INT tmp;\n    register int id1, id2;\n    register RC4_INT *d;\n    unsigned int i;\n\n    d = &(key->data[0]);\n    key->x = 0;\n    key->y = 0;\n    id1 = id2 = 0;\n\n#define SK_LOOP(d,n) { \\\n                tmp=d[(n)]; \\\n                id2 = (data[id1] + tmp + id2) & 0xff; \\\n                if (++id1 == len) id1=0; \\\n                d[(n)]=d[id2]; \\\n                d[id2]=tmp; }\n\n    for (i = 0; i < 256; i++)\n        d[i] = i;\n    for (i = 0; i < 256; i += 4) {\n        SK_LOOP(d, i + 0);\n        SK_LOOP(d, i + 1);\n        SK_LOOP(d, i + 2);\n        SK_LOOP(d, i + 3);\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4173E7(\n        int a1,\n        int a2,\n        int a3,\n        int a4,\n        unsigned __int8 a5,\n        unsigned __int8 a6,\n        unsigned __int8 a7)\n{\n  __int64 result; // rax\n  int v10; // [rsp+24h] [rbp-1Ch]\n  __int64 v11; // [rsp+28h] [rbp-18h]\n  int v12; // [rsp+34h] [rbp-Ch]\n  int v13; // [rsp+38h] [rbp-8h]\n  int v14; // [rsp+3Ch] [rbp-4h]\n\n  v10 = sub_417020(a5, a6, a7);\n  v14 = a4 - a2;\n  v12 = a2;\n  do\n  {\n    v11 = *(_QWORD *)qword_75D408\n        + (unsigned int)(*((_DWORD *)qword_75D408 + 64) * v12)\n        + (unsigned __int64)(unsigned int)(*((_DWORD *)qword_75D408 + 72) * a1);\n    v13 = a3 - a1;\n    do\n    {\n      sub_417106(v11, v10);\n      result = *((unsigned int *)qword_75D408 + 72);\n      v11 += result;\n      --v13;\n    }\n    while ( v13 >= 0 );\n    ++v12;\n    --v14;\n  }\n  while ( v14 >= 0 );\n  return result;\n}\n",
        "output": "```c\nvoid sub_4173E7(int rows, int cols, int startRow, int startCol, unsigned char param5, unsigned char param6, unsigned char param7)\n{\n    int value;\n    int remainingRows;\n    int currentRow;\n    int remainingCols;\n    __int64 address;\n\n    value = sub_417020(param5, param6, param7);\n    remainingRows = cols - startCol;\n    currentRow = startCol;\n    do\n    {\n        address = *(_QWORD *)qword_75D408\n                + (unsigned int)(*((_DWORD *)qword_75D408 + 64) * currentRow)\n                + (unsigned __int64)(unsigned int)(*((_DWORD *)qword_75D408 + 72) * rows);\n        remainingCols = startRow - rows;\n        do\n        {\n            sub_417106(address, value);\n            address += *((unsigned int *)qword_75D408 + 72);\n            --remainingCols;\n        }\n        while (remainingCols >= 0);\n        ++currentRow;\n        --remainingRows;\n    }\n    while (remainingRows >= 0);\n}\n```",
        "source_code": "static void fb_drawfullrectangle(int nx1pos, int ny1pos, int nx2pos, int ny2pos,\n\tunsigned char nred, unsigned char ngreen, unsigned char nblue)\n{\n\tint cnt1, cnt2, nypos;\n\tunsigned thispix;\n\tunsigned char *ptr;\n\n\tthispix = fb_pixel_value(nred, ngreen, nblue);\n\n\tcnt1 = ny2pos - ny1pos;\n\tnypos = ny1pos;\n\tdo {\n\t\tptr = G.addr + nypos * G.scr_fix.line_length + nx1pos * G.bytes_per_pixel;\n\t\tcnt2 = nx2pos - nx1pos;\n\t\tdo {\n\t\t\tfb_write_pixel(ptr, thispix);\n\t\t\tptr += G.bytes_per_pixel;\n\t\t} while (--cnt2 >= 0);\n\n\t\tnypos++;\n\t} while (--cnt1 >= 0);\n}",
        "parsed_output": "void sub_4173E7(int rows, int cols, int startRow, int startCol, unsigned char param5, unsigned char param6, unsigned char param7)\n{\n    int value;\n    int remainingRows;\n    int currentRow;\n    int remainingCols;\n    __int64 address;\n\n    value = sub_417020(param5, param6, param7);\n    remainingRows = cols - startCol;\n    currentRow = startCol;\n    do\n    {\n        address = *(_QWORD *)qword_75D408\n                + (unsigned int)(*((_DWORD *)qword_75D408 + 64) * currentRow)\n                + (unsigned __int64)(unsigned int)(*((_DWORD *)qword_75D408 + 72) * rows);\n        remainingCols = startRow - rows;\n        do\n        {\n            sub_417106(address, value);\n            address += *((unsigned int *)qword_75D408 + 72);\n            --remainingCols;\n        }\n        while (remainingCols >= 0);\n        ++currentRow;\n        --remainingRows;\n    }\n    while (remainingRows >= 0);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4173E7(\n        int a1,\n        int a2,\n        int a3,\n        int a4,\n        unsigned __int8 a5,\n        unsigned __int8 a6,\n        unsigned __int8 a7)\n{\n  __int64 result; // rax\n  int v10; // [rsp+24h] [rbp-1Ch]\n  __int64 v11; // [rsp+28h] [rbp-18h]\n  int v12; // [rsp+34h] [rbp-Ch]\n  int v13; // [rsp+38h] [rbp-8h]\n  int v14; // [rsp+3Ch] [rbp-4h]\n\n  v10 = sub_417020(a5, a6, a7);\n  v14 = a4 - a2;\n  v12 = a2;\n  do\n  {\n    v11 = *(_QWORD *)qword_75D408\n        + (unsigned int)(*((_DWORD *)qword_75D408 + 64) * v12)\n        + (unsigned __int64)(unsigned int)(*((_DWORD *)qword_75D408 + 72) * a1);\n    v13 = a3 - a1;\n    do\n    {\n      sub_417106(v11, v10);\n      result = *((unsigned int *)qword_75D408 + 72);\n      v11 += result;\n      --v13;\n    }\n    while ( v13 >= 0 );\n    ++v12;\n    --v14;\n  }\n  while ( v14 >= 0 );\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl fb_drawfullrectangle(\n        int nx1pos,\n        int ny1pos,\n        int nx2pos,\n        int ny2pos,\n        unsigned __int8 nred,\n        unsigned __int8 ngreen,\n        unsigned __int8 nblue)\n{\n  unsigned int thispix; // [rsp+24h] [rbp-1Ch]\n  unsigned __int8 *ptr; // [rsp+28h] [rbp-18h]\n  int nypos; // [rsp+34h] [rbp-Ch]\n  int cnt2; // [rsp+38h] [rbp-8h]\n  int cnt1; // [rsp+3Ch] [rbp-4h]\n\n  thispix = fb_pixel_value(nred, ngreen, nblue);\n  cnt1 = ny2pos - ny1pos;\n  nypos = ny1pos;\n  do\n  {\n    ptr = (unsigned __int8 *)(*(_QWORD *)&ptr_to_globals->timeout\n                            + (unsigned int)(*(_DWORD *)&ptr_to_globals->line_buf[100] * nypos)\n                            + (unsigned __int64)(ptr_to_globals[1].timeout * nx1pos));\n    cnt2 = nx2pos - nx1pos;\n    do\n    {\n      fb_write_pixel(ptr, thispix);\n      ptr += ptr_to_globals[1].timeout;\n      --cnt2;\n    }\n    while ( cnt2 >= 0 );\n    ++nypos;\n    --cnt1;\n  }\n  while ( cnt1 >= 0 );\n}\n",
        "similarity_score_unixcoder": 0.5224042534828186,
        "similarity_score_baseline_stripped": 0.5076518058776855,
        "similarity_score_baseline_debug": 0.8549080491065979
    },
    {
        "func_name": "fix_partition_table_order",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl private_RC4_set_key(RC4_KEY *key, int len, const unsigned __int8 *data)\n{\n  unsigned __int8 *v3; // r12\n  int v4; // ebx\n  int v5; // r13d\n  unsigned __int8 v6; // r14\n  int v7; // ebx\n  int v8; // r13d\n  unsigned __int8 v9; // r14\n  int v10; // ebx\n  int v11; // r13d\n  unsigned __int8 v12; // r14\n  int v13; // ebx\n  int v14; // r13d\n  unsigned __int8 v15; // r14\n  unsigned int i; // [rsp+24h] [rbp-24h]\n  unsigned int ia; // [rsp+24h] [rbp-24h]\n\n  v3 = key->data;\n  key->x = 0;\n  key->y = 0;\n  LOBYTE(v4) = 0;\n  v5 = 0;\n  for ( i = 0; i <= 0xFF; ++i )\n    v3[i] = i;\n  for ( ia = 0; ia <= 0xFF; ia += 4 )\n  {\n    v6 = v3[ia];\n    v7 = (unsigned __int8)(v4 + data[v5] + v6);\n    v8 = v5 + 1;\n    if ( v8 == len )\n      v8 = 0;\n    v3[ia] = v3[v7];\n    v3[v7] = v6;\n    v9 = v3[ia + 1];\n    v10 = (unsigned __int8)(v7 + data[v8] + v9);\n    v11 = v8 + 1;\n    if ( v11 == len )\n      v11 = 0;\n    v3[ia + 1] = v3[v10];\n    v3[v10] = v9;\n    v12 = v3[ia + 2];\n    v13 = (unsigned __int8)(v10 + data[v11] + v12);\n    v14 = v11 + 1;\n    if ( v14 == len )\n      v14 = 0;\n    v3[ia + 2] = v3[v13];\n    v3[v13] = v12;\n    v15 = v3[ia + 3];\n    v4 = (unsigned __int8)(v13 + data[v14] + v15);\n    v5 = v14 + 1;\n    if ( v5 == len )\n      v5 = 0;\n    v3[ia + 3] = v3[v4];\n    v3[v4] = v15;\n  }\n}\n\n\n Revised code:\nvoid private_RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)\n{\n    register RC4_INT tmp;\n    register int id1, id2;\n    register RC4_INT *d;\n    unsigned int i;\n\n    d = &(key->data[0]);\n    key->x = 0;\n    key->y = 0;\n    id1 = id2 = 0;\n\n#define SK_LOOP(d,n) { \\\n                tmp=d[(n)]; \\\n                id2 = (data[id1] + tmp + id2) & 0xff; \\\n                if (++id1 == len) id1=0; \\\n                d[(n)]=d[id2]; \\\n                d[id2]=tmp; }\n\n    for (i = 0; i < 256; i++)\n        d[i] = i;\n    for (i = 0; i < 256; i += 4) {\n        SK_LOOP(d, i + 0);\n        SK_LOOP(d, i + 1);\n        SK_LOOP(d, i + 2);\n        SK_LOOP(d, i + 3);\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint sub_4932AD()\n{\n  char *v1; // rax\n  __int64 v2; // rdx\n  _QWORD *v3; // rcx\n  _QWORD *v4; // rcx\n  __int64 v5; // [rsp+0h] [rbp-50h]\n  __int64 v6; // [rsp+8h] [rbp-48h]\n  int v7; // [rsp+1Ch] [rbp-34h] BYREF\n  _QWORD *v8; // [rsp+20h] [rbp-30h]\n  _QWORD *v9; // [rsp+28h] [rbp-28h]\n  __int64 v10; // [rsp+30h] [rbp-20h]\n  char *v11; // [rsp+38h] [rbp-18h]\n  __int64 v12; // [rsp+40h] [rbp-10h]\n  int v13; // [rsp+4Ch] [rbp-4h]\n\n  if ( !(unsigned int)sub_492E03(0LL) )\n    return puts(\"Ordering is already correct\\n\");\n  while ( 1 )\n  {\n    v13 = sub_492E03(&v7);\n    if ( !v13 || v13 > 3 )\n      break;\n    v12 = (__int64)qword_75D408 + 40 * v13 + 2504;\n    v1 = (char *)qword_75D408 + 40 * v7 + 2496;\n    v11 = v1 + 8;\n    v10 = *((_QWORD *)qword_75D408 + 5 * v13 + 314);\n    *((_QWORD *)qword_75D408 + 5 * v13 + 314) = *((_QWORD *)v1 + 2);\n    *((_QWORD *)v11 + 1) = v10;\n    v9 = *(_QWORD **)v12;\n    v8 = *(_QWORD **)v11;\n    v5 = *v9;\n    v6 = v9[1];\n    v2 = v8[1];\n    v3 = v9;\n    *v9 = *v8;\n    v3[1] = v2;\n    v4 = v8;\n    *v8 = v5;\n    v4[1] = v6;\n    v11[32] = 1;\n    *(_BYTE *)(v12 + 32) = v11[32];\n  }\n  if ( v13 )\n    sub_492ED3();\n  return puts(\"Done.\");\n}\n",
        "output": "```c\nint reorder_items()\n{\n  int currentItemIndex; // Current item index\n  int nextItemIndex; // Next item index\n  __int64 currentItemPtr; // Pointer to current item\n  __int64 nextItemPtr; // Pointer to next item\n  int result; // Result of sub_492E03\n  int *itemOrderArray; // Pointer to item order array\n  __int64 *currentItem; // Pointer to current item data\n  __int64 *nextItem; // Pointer to next item data\n  __int64 tempData1; // Temporary data storage\n  __int64 tempData2; // Temporary data storage\n  int tempOrder; // Temporary order storage\n\n  if (!sub_492E03(0LL))\n    return puts(\"Ordering is already correct\\n\");\n\n  while (1)\n  {\n    result = sub_492E03(&currentItemIndex);\n    if (!result || result > 3)\n      break;\n\n    nextItemIndex = result;\n    currentItemPtr = (__int64)&itemOrderArray[nextItemIndex];\n    nextItemPtr = currentItemPtr + 8;\n    currentItem = (__int64 *)(currentItemPtr + 2504);\n    nextItem = (__int64 *)(nextItemPtr + 2496);\n\n    // Swap the data of current and next items\n    tempData1 = *currentItem;\n    tempData2 = currentItem[1];\n    *currentItem = *nextItem;\n    currentItem[1] = nextItem[1];\n    *nextItem = tempData1;\n    nextItem[1] = tempData2;\n\n    // Mark the items as swapped\n    ((char *)nextItemPtr)[32] = 1;\n    *((char *)currentItem + 32) = ((char *)nextItemPtr)[32];\n  }\n\n  if (result)\n    sub_492ED3();\n\n  return puts(\"Done.\");\n}\n```",
        "source_code": "static void\nfix_partition_table_order(void)\n{\n\tstruct pte *pei, *pek;\n\tint i,k;\n\n\tif (!wrong_p_order(NULL)) {\n\t\tprintf(\"Ordering is already correct\\n\\n\");\n\t\treturn;\n\t}\n\n\twhile ((i = wrong_p_order(&k)) != 0 && i < 4) {\n\t\t/* partition i should have come earlier, move it */\n\t\t/* We have to move data in the MBR */\n\t\tstruct partition *pi, *pk, *pe, pbuf;\n\t\tpei = &ptes[i];\n\t\tpek = &ptes[k];\n\n\t\tpe = pei->ext_pointer;\n\t\tpei->ext_pointer = pek->ext_pointer;\n\t\tpek->ext_pointer = pe;\n\n\t\tpi = pei->part_table;\n\t\tpk = pek->part_table;\n\n\t\tmemmove(&pbuf, pi, sizeof(struct partition));\n\t\tmemmove(pi, pk, sizeof(struct partition));\n\t\tmemmove(pk, &pbuf, sizeof(struct partition));\n\n\t\tpei->changed = pek->changed = 1;\n\t}\n\n\tif (i)\n\t\tfix_chain_of_logicals();\n\n\tprintf(\"Done.\\n\");\n}",
        "parsed_output": "int reorder_items()\n{\n  int currentItemIndex; // Current item index\n  int nextItemIndex; // Next item index\n  __int64 currentItemPtr; // Pointer to current item\n  __int64 nextItemPtr; // Pointer to next item\n  int result; // Result of sub_492E03\n  int *itemOrderArray; // Pointer to item order array\n  __int64 *currentItem; // Pointer to current item data\n  __int64 *nextItem; // Pointer to next item data\n  __int64 tempData1; // Temporary data storage\n  __int64 tempData2; // Temporary data storage\n  int tempOrder; // Temporary order storage\n\n  if (!sub_492E03(0LL))\n    return puts(\"Ordering is already correct\\n\");\n\n  while (1)\n  {\n    result = sub_492E03(&currentItemIndex);\n    if (!result || result > 3)\n      break;\n\n    nextItemIndex = result;\n    currentItemPtr = (__int64)&itemOrderArray[nextItemIndex];\n    nextItemPtr = currentItemPtr + 8;\n    currentItem = (__int64 *)(currentItemPtr + 2504);\n    nextItem = (__int64 *)(nextItemPtr + 2496);\n\n    // Swap the data of current and next items\n    tempData1 = *currentItem;\n    tempData2 = currentItem[1];\n    *currentItem = *nextItem;\n    currentItem[1] = nextItem[1];\n    *nextItem = tempData1;\n    nextItem[1] = tempData2;\n\n    // Mark the items as swapped\n    ((char *)nextItemPtr)[32] = 1;\n    *((char *)currentItem + 32) = ((char *)nextItemPtr)[32];\n  }\n\n  if (result)\n    sub_492ED3();\n\n  return puts(\"Done.\");\n}",
        "baseline_code_stripped": "int sub_4932AD()\n{\n  char *v1; // rax\n  __int64 v2; // rdx\n  _QWORD *v3; // rcx\n  _QWORD *v4; // rcx\n  __int64 v5; // [rsp+0h] [rbp-50h]\n  __int64 v6; // [rsp+8h] [rbp-48h]\n  int v7; // [rsp+1Ch] [rbp-34h] BYREF\n  _QWORD *v8; // [rsp+20h] [rbp-30h]\n  _QWORD *v9; // [rsp+28h] [rbp-28h]\n  __int64 v10; // [rsp+30h] [rbp-20h]\n  char *v11; // [rsp+38h] [rbp-18h]\n  __int64 v12; // [rsp+40h] [rbp-10h]\n  int v13; // [rsp+4Ch] [rbp-4h]\n\n  if ( !(unsigned int)sub_492E03(0LL) )\n    return puts(\"Ordering is already correct\\n\");\n  while ( 1 )\n  {\n    v13 = sub_492E03(&v7);\n    if ( !v13 || v13 > 3 )\n      break;\n    v12 = (__int64)qword_75D408 + 40 * v13 + 2504;\n    v1 = (char *)qword_75D408 + 40 * v7 + 2496;\n    v11 = v1 + 8;\n    v10 = *((_QWORD *)qword_75D408 + 5 * v13 + 314);\n    *((_QWORD *)qword_75D408 + 5 * v13 + 314) = *((_QWORD *)v1 + 2);\n    *((_QWORD *)v11 + 1) = v10;\n    v9 = *(_QWORD **)v12;\n    v8 = *(_QWORD **)v11;\n    v5 = *v9;\n    v6 = v9[1];\n    v2 = v8[1];\n    v3 = v9;\n    *v9 = *v8;\n    v3[1] = v2;\n    v4 = v8;\n    *v8 = v5;\n    v4[1] = v6;\n    v11[32] = 1;\n    *(_BYTE *)(v12 + 32) = v11[32];\n  }\n  if ( v13 )\n    sub_492ED3();\n  return puts(\"Done.\");\n}\n",
        "baseline_code_debug": "void __cdecl fix_partition_table_order()\n{\n  char *v0; // rax\n  __int64 v1; // rdx\n  partition *v2; // rcx\n  partition pbuf; // [rsp+0h] [rbp-50h]\n  int k; // [rsp+1Ch] [rbp-34h] BYREF\n  partition *pk; // [rsp+20h] [rbp-30h]\n  partition *pi; // [rsp+28h] [rbp-28h]\n  partition *pe; // [rsp+30h] [rbp-20h]\n  pte *pek; // [rsp+38h] [rbp-18h]\n  pte *pei; // [rsp+40h] [rbp-10h]\n  int i; // [rsp+4Ch] [rbp-4h]\n\n  if ( wrong_p_order(0LL) )\n  {\n    while ( 1 )\n    {\n      i = wrong_p_order(&k);\n      if ( !i || i > 3 )\n        break;\n      pei = (pte *)&ptr_to_globals[8].line_buf[40 * i + 44];\n      v0 = &ptr_to_globals[8].line_buf[40 * k + 36];\n      pek = (pte *)(v0 + 8);\n      pe = *(partition **)&ptr_to_globals[8].line_buf[40 * i + 52];\n      *(_QWORD *)&ptr_to_globals[8].line_buf[40 * i + 52] = *((_QWORD *)v0 + 2);\n      pek->ext_pointer = pe;\n      pi = pei->part_table;\n      pk = pek->part_table;\n      pbuf = *pi;\n      v1 = *(_QWORD *)pk->start4;\n      v2 = pi;\n      *(_QWORD *)&pi->boot_ind = *(_QWORD *)&pk->boot_ind;\n      *(_QWORD *)v2->start4 = v1;\n      *pk = pbuf;\n      pek->changed = 1;\n      pei->changed = pek->changed;\n    }\n    if ( i )\n      fix_chain_of_logicals();\n    puts(\"Done.\");\n  }\n  else\n  {\n    puts(\"Ordering is already correct\\n\");\n  }\n}\n",
        "similarity_score_unixcoder": 0.6204110383987427,
        "similarity_score_baseline_stripped": 0.46154457330703735,
        "similarity_score_baseline_debug": 0.7745316028594971
    },
    {
        "func_name": "rmescapes",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nchar *__cdecl t_tob64(char *dst, const unsigned __int8 *src, int size)\n{\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  int v7; // eax\n  char *dsta; // [rsp+Ch] [rbp-28h]\n  int c; // [rsp+20h] [rbp-14h]\n  int ca; // [rsp+20h] [rbp-14h]\n  unsigned __int8 notleading; // [rsp+2Ch] [rbp-8h]\n  unsigned __int8 b2; // [rsp+2Dh] [rbp-7h]\n  unsigned __int8 b1; // [rsp+2Eh] [rbp-6h]\n  unsigned __int8 b0; // [rsp+2Fh] [rbp-5h]\n  int pos; // [rsp+30h] [rbp-4h]\n\n  dsta = dst;\n  pos = size % 3;\n  b0 = 0;\n  b1 = 0;\n  b2 = 0;\n  notleading = 0;\n  if ( size % 3 == 1 )\n  {\n    b2 = *src;\n  }\n  else if ( pos == 2 )\n  {\n    b1 = *src;\n    b2 = src[1];\n  }\n  while ( 1 )\n  {\n    if ( notleading || b0 >> 2 )\n    {\n      v3 = dsta++;\n      *v3 = b64table[b0 >> 2];\n      notleading = 1;\n    }\n    c = (16 * b0) & 0x30 | (b1 >> 4);\n    if ( notleading || c )\n    {\n      v4 = dsta++;\n      *v4 = b64table[c];\n      notleading = 1;\n    }\n    ca = (4 * b1) & 0x3C | (b2 >> 6);\n    if ( notleading || ca )\n    {\n      v5 = dsta++;\n      *v5 = b64table[ca];\n      notleading = 1;\n    }\n    if ( notleading || (b2 & 0x3F) != 0 )\n    {\n      v6 = dsta++;\n      *v6 = b64table[b2 & 0x3F];\n      notleading = 1;\n    }\n    if ( pos >= size )\n      break;\n    b0 = src[pos];\n    b1 = src[pos + 1];\n    v7 = pos + 2;\n    pos += 3;\n    b2 = src[v7];\n  }\n  *dsta = 0;\n  return dst;\n}\n\n\n Revised code:\nstatic char *t_tob64(char *dst, const unsigned char *src, int size)\n{\n    int c, pos = size % 3;\n    unsigned char b0 = 0, b1 = 0, b2 = 0, notleading = 0;\n    char *olddst = dst;\n\n    switch (pos) {\n    case 1:\n        b2 = src[0];\n        break;\n    case 2:\n        b1 = src[0];\n        b2 = src[1];\n        break;\n    }\n\n    while (1) {\n        c = (b0 & 0xfc) >> 2;\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = ((b0 & 3) << 4) | ((b1 & 0xf0) >> 4);\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = ((b1 & 0xf) << 2) | ((b2 & 0xc0) >> 6);\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = b2 & 0x3f;\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        if (pos >= size)\n            break;\n        else {\n            b0 = src[pos++];\n            b1 = src[pos++];\n            b2 = src[pos++];\n        }\n    }\n\n    *dst++ = '\\0';\n    return olddst;\n}\n\n## Example:\n\n Input code:\nunsigned __int8 *__cdecl string_to_hex(const char *str, __int64 *len)\n{\n  int v3; // eax\n  unsigned __int8 *v4; // rax\n  unsigned __int8 *v5; // rax\n  unsigned __int8 *v6; // rax\n  unsigned __int8 *hexbuf; // [rsp+10h] [rbp-20h]\n  unsigned __int8 *p; // [rsp+18h] [rbp-18h]\n  unsigned __int8 cl_0; // [rsp+26h] [rbp-Ah]\n  unsigned __int8 cl_0a; // [rsp+26h] [rbp-Ah]\n  unsigned __int8 ch_0; // [rsp+27h] [rbp-9h]\n  unsigned __int8 ch_0a; // [rsp+27h] [rbp-9h]\n  unsigned __int8 *q; // [rsp+28h] [rbp-8h]\n\n  if ( str )\n  {\n    v3 = strlen(str);\n    hexbuf = (unsigned __int8 *)CRYPTO_malloc(v3 >> 1, \"v3_utl.c\", 400);\n    if ( hexbuf )\n    {\n      p = (unsigned __int8 *)str;\n      q = hexbuf;\n      while ( *p )\n      {\n        v4 = p++;\n        ch_0 = *v4;\n        if ( *v4 != 58 )\n        {\n          v5 = p++;\n          cl_0 = *v5;\n          if ( !*v5 )\n          {\n            ERR_put_error(34, 113, 112, \"v3_utl.c\", 412);\n            CRYPTO_free(hexbuf);\n            return 0LL;\n          }\n          if ( ((*__ctype_b_loc())[ch_0] & 0x100) != 0 )\n            ch_0 = tolower(ch_0);\n          if ( ((*__ctype_b_loc())[cl_0] & 0x100) != 0 )\n            cl_0 = tolower(cl_0);\n          if ( ch_0 <= 0x2Fu || ch_0 > 0x39u )\n          {\n            if ( ch_0 <= 0x60u || ch_0 > 0x66u )\n            {\nbadhex:\n              CRYPTO_free(hexbuf);\n              ERR_put_error(34, 113, 113, \"v3_utl.c\", 441);\n              return 0LL;\n            }\n            ch_0a = ch_0 - 87;\n          }\n          else\n          {\n            ch_0a = ch_0 - 48;\n          }\n          if ( cl_0 <= 0x2Fu || cl_0 > 0x39u )\n          {\n            if ( cl_0 <= 0x60u || cl_0 > 0x66u )\n              goto badhex;\n            cl_0a = cl_0 - 87;\n          }\n          else\n          {\n            cl_0a = cl_0 - 48;\n          }\n          v6 = q++;\n          *v6 = cl_0a | (16 * ch_0a);\n        }\n      }\n      if ( len )\n        *len = q - hexbuf;\n      return hexbuf;\n    }\n    else\n    {\n      ERR_put_error(34, 113, 65, \"v3_utl.c\", 436);\n      return 0LL;\n    }\n  }\n  else\n  {\n    ERR_put_error(34, 113, 107, \"v3_utl.c\", 397);\n    return 0LL;\n  }\n}\n\n\n Revised code:\nunsigned char *string_to_hex(const char *str, long *len)\n{\n    unsigned char *hexbuf, *q;\n    unsigned char ch, cl, *p;\n    if (!str) {\n        X509V3err(X509V3_F_STRING_TO_HEX, X509V3_R_INVALID_NULL_ARGUMENT);\n        return NULL;\n    }\n    if (!(hexbuf = OPENSSL_malloc(strlen(str) >> 1)))\n        goto err;\n    for (p = (unsigned char *)str, q = hexbuf; *p;) {\n        ch = *p++;\n#ifdef CHARSET_EBCDIC\n        ch = os_toebcdic[ch];\n#endif\n        if (ch == ':')\n            continue;\n        cl = *p++;\n#ifdef CHARSET_EBCDIC\n        cl = os_toebcdic[cl];\n#endif\n        if (!cl) {\n            X509V3err(X509V3_F_STRING_TO_HEX, X509V3_R_ODD_NUMBER_OF_DIGITS);\n            OPENSSL_free(hexbuf);\n            return NULL;\n        }\n        if (isupper(ch))\n            ch = tolower(ch);\n        if (isupper(cl))\n            cl = tolower(cl);\n\n        if ((ch >= '0') && (ch <= '9'))\n            ch -= '0';\n        else if ((ch >= 'a') && (ch <= 'f'))\n            ch -= 'a' - 10;\n        else\n            goto badhex;\n\n        if ((cl >= '0') && (cl <= '9'))\n            cl -= '0';\n        else if ((cl >= 'a') && (cl <= 'f'))\n            cl -= 'a' - 10;\n        else\n            goto badhex;\n\n        *q++ = (ch << 4) | cl;\n    }\n\n    if (len)\n        *len = q - hexbuf;\n\n    return hexbuf;\n\n err:\n    if (hexbuf)\n        OPENSSL_free(hexbuf);\n    X509V3err(X509V3_F_STRING_TO_HEX, ERR_R_MALLOC_FAILURE);\n    return NULL;\n\n badhex:\n    OPENSSL_free(hexbuf);\n    X509V3err(X509V3_F_STRING_TO_HEX, X509V3_R_ILLEGAL_HEX_DIGIT);\n    return NULL;\n\n}\n\n## Example:\n\n Input code:\nvoid __cdecl private_RC4_set_key(RC4_KEY *key, int len, const unsigned __int8 *data)\n{\n  unsigned __int8 *v3; // r12\n  int v4; // ebx\n  int v5; // r13d\n  unsigned __int8 v6; // r14\n  int v7; // ebx\n  int v8; // r13d\n  unsigned __int8 v9; // r14\n  int v10; // ebx\n  int v11; // r13d\n  unsigned __int8 v12; // r14\n  int v13; // ebx\n  int v14; // r13d\n  unsigned __int8 v15; // r14\n  unsigned int i; // [rsp+24h] [rbp-24h]\n  unsigned int ia; // [rsp+24h] [rbp-24h]\n\n  v3 = key->data;\n  key->x = 0;\n  key->y = 0;\n  LOBYTE(v4) = 0;\n  v5 = 0;\n  for ( i = 0; i <= 0xFF; ++i )\n    v3[i] = i;\n  for ( ia = 0; ia <= 0xFF; ia += 4 )\n  {\n    v6 = v3[ia];\n    v7 = (unsigned __int8)(v4 + data[v5] + v6);\n    v8 = v5 + 1;\n    if ( v8 == len )\n      v8 = 0;\n    v3[ia] = v3[v7];\n    v3[v7] = v6;\n    v9 = v3[ia + 1];\n    v10 = (unsigned __int8)(v7 + data[v8] + v9);\n    v11 = v8 + 1;\n    if ( v11 == len )\n      v11 = 0;\n    v3[ia + 1] = v3[v10];\n    v3[v10] = v9;\n    v12 = v3[ia + 2];\n    v13 = (unsigned __int8)(v10 + data[v11] + v12);\n    v14 = v11 + 1;\n    if ( v14 == len )\n      v14 = 0;\n    v3[ia + 2] = v3[v13];\n    v3[v13] = v12;\n    v15 = v3[ia + 3];\n    v4 = (unsigned __int8)(v13 + data[v14] + v15);\n    v5 = v14 + 1;\n    if ( v5 == len )\n      v5 = 0;\n    v3[ia + 3] = v3[v4];\n    v3[v4] = v15;\n  }\n}\n\n\n Revised code:\nvoid private_RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)\n{\n    register RC4_INT tmp;\n    register int id1, id2;\n    register RC4_INT *d;\n    unsigned int i;\n\n    d = &(key->data[0]);\n    key->x = 0;\n    key->y = 0;\n    id1 = id2 = 0;\n\n#define SK_LOOP(d,n) { \\\n                tmp=d[(n)]; \\\n                id2 = (data[id1] + tmp + id2) & 0xff; \\\n                if (++id1 == len) id1=0; \\\n                d[(n)]=d[id2]; \\\n                d[id2]=tmp; }\n\n    for (i = 0; i < 256; i++)\n        d[i] = i;\n    for (i = 0; i < 256; i += 4) {\n        SK_LOOP(d, i + 0);\n        SK_LOOP(d, i + 1);\n        SK_LOOP(d, i + 2);\n        SK_LOOP(d, i + 3);\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_473CD2(const char *a1, char a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // rax\n  const char *v8; // rdx\n  char *v9; // rax\n  char *s; // [rsp+8h] [rbp-48h]\n  int v11; // [rsp+1Ch] [rbp-34h]\n  __int64 v12; // [rsp+20h] [rbp-30h]\n  size_t n; // [rsp+28h] [rbp-28h]\n  int v14; // [rsp+30h] [rbp-20h]\n  int v15; // [rsp+34h] [rbp-1Ch]\n  char *v16; // [rsp+38h] [rbp-18h]\n  const char *dest; // [rsp+40h] [rbp-10h]\n  const char *v18; // [rsp+48h] [rbp-8h]\n\n  s = (char *)a1;\n  v18 = strpbrk(a1, &byte_51DF10);\n  if ( !v18 )\n    return a1;\n  dest = v18;\n  v16 = (char *)a1;\n  if ( (a2 & 1) != 0 )\n  {\n    n = v18 - a1;\n    v3 = strlen(v18);\n    v12 = v3 + v18 - a1 + 1;\n    if ( (a2 & 8) != 0 )\n    {\n      v11 = (_DWORD)a1 - *(_QWORD *)(qword_75D428 + 16);\n      v16 = (char *)sub_46ECB9(v12, qword_75AFC8, qword_75AFC8, v4, v5, v6);\n      s = (char *)(*(_QWORD *)(qword_75D428 + 16) + v11);\n      v18 = &s[n];\n    }\n    else\n    {\n      v16 = (a2 & 0x10) != 0\n          ? (char *)sub_40A05F(v12, (__int64)&byte_51DF10)\n          : (char *)sub_46E6A8(v12, (__int64)&byte_51DF10, v3, v4, v5, v6);\n    }\n    dest = v16;\n    if ( n )\n      dest = (char *)memcpy(v16, s, n) + n;\n  }\n  v15 = ~a2 & 4;\n  v14 = a2 & 2;\n  while ( *v18 )\n  {\n    if ( *v18 == -120 )\n    {\n      v15 = ~v15;\n      ++v18;\n      v14 = a2 & 2;\n    }\n    else\n    {\n      if ( *v18 == 92 )\n      {\n        v14 = 0;\n      }\n      else\n      {\n        if ( *v18 == -127 )\n        {\n          ++v18;\n          if ( v14 )\n          {\n            if ( v15 && *v18 != 47 )\n            {\n              v7 = (char *)dest++;\n              *v7 = 92;\n            }\n          }\n        }\n        v14 = a2 & 2;\n      }\n      v8 = v18++;\n      v9 = (char *)dest++;\n      *v9 = *v8;\n    }\n  }\n  *dest = 0;\n  if ( (a2 & 8) != 0 )\n    qword_75AFC8 = (__int64)(dest + 1);\n  return v16;\n}\n",
        "output": "```c\nconst char *sub_473CD2(const char *input, char flags)\n{\n    const char *special_chars_ptr;\n    const char *src;\n    char *dst;\n    size_t prefix_len;\n    size_t total_len;\n    int escape_next_char = 0;\n    int invert_slash_logic = flags & 4;\n    int handle_slashes = flags & 2;\n    char *output;\n    const char *result;\n\n    src = input;\n    special_chars_ptr = strpbrk(input, special_chars);\n    if (!special_chars_ptr)\n        return input;\n\n    result = special_chars_ptr;\n    output = (char *)input;\n    if (flags & 1) {\n        prefix_len = special_chars_ptr - input;\n        total_len = strlen(special_chars_ptr) + prefix_len + 1;\n        if (flags & 8) {\n            int offset = input - global_offset;\n            output = allocate_memory(total_len);\n            src = global_offset + offset;\n            special_chars_ptr = src + prefix_len;\n        } else {\n            output = (flags & 0x10) ? allocate_memory_alt(total_len) : allocate_memory(total_len);\n        }\n        result = output;\n        if (prefix_len)\n            result = (char *)memcpy(output, src, prefix_len) + prefix_len;\n    }\n\n    while (*special_chars_ptr) {\n        if (*special_chars_ptr == -120) {\n            invert_slash_logic = ~invert_slash_logic;\n            ++special_chars_ptr;\n            handle_slashes = flags & 2;\n        } else {\n            if (*special_chars_ptr == 92) {\n                handle_slashes = 0;\n            } else {\n                if (*special_chars_ptr == -127) {\n                    ++special_chars_ptr;\n                    if (handle_slashes) {\n                        if (invert_slash_logic && *special_chars_ptr != '/') {\n                            *result++ = 92;\n                        }\n                    }\n                }\n                handle_slashes = flags & 2;\n            }\n            *result++ = *special_chars_ptr++;\n        }\n    }\n    *result = '\\0';\n    if (flags & 8)\n        global_pointer = result + 1;\n\n    return output;\n}\n```",
        "source_code": "static char *\nrmescapes(char *str, int flag)\n{\n\tstatic const char qchars[] ALIGN1 = { CTLESC, CTLQUOTEMARK, '\\0' };\n\n\tchar *p, *q, *r;\n\tunsigned inquotes;\n\tunsigned protect_against_glob;\n\tunsigned globbing;\n\n\tp = strpbrk(str, qchars);\n\tif (!p)\n\t\treturn str;\n\n\tq = p;\n\tr = str;\n\tif (flag & RMESCAPE_ALLOC) {\n\t\tsize_t len = p - str;\n\t\tsize_t fulllen = len + strlen(p) + 1;\n\n\t\tif (flag & RMESCAPE_GROW) {\n\t\t\tint strloc = str - (char *)stackblock();\n\t\t\tr = makestrspace(fulllen, expdest);\n\t\t\t/* p and str may be invalidated by makestrspace */\n\t\t\tstr = (char *)stackblock() + strloc;\n\t\t\tp = str + len;\n\t\t} else if (flag & RMESCAPE_HEAP) {\n\t\t\tr = ckmalloc(fulllen);\n\t\t} else {\n\t\t\tr = stalloc(fulllen);\n\t\t}\n\t\tq = r;\n\t\tif (len > 0) {\n\t\t\tq = (char *)memcpy(q, str, len) + len;\n\t\t}\n\t}\n\n\tinquotes = (flag & RMESCAPE_QUOTED) ^ RMESCAPE_QUOTED;\n\tglobbing = flag & RMESCAPE_GLOB;\n\tprotect_against_glob = globbing;\n\twhile (*p) {\n\t\tif ((unsigned char)*p == CTLQUOTEMARK) {\n// TODO: if no RMESCAPE_QUOTED in flags, inquotes never becomes 0\n// (alternates between RMESCAPE_QUOTED and ~RMESCAPE_QUOTED). Is it ok?\n// Note: both inquotes and protect_against_glob only affect whether\n// CTLESC,<ch> gets converted to <ch> or to \\<ch>\n\t\t\tinquotes = ~inquotes;\n\t\t\tp++;\n\t\t\tprotect_against_glob = globbing;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == '\\\\') {\n\t\t\t/* naked back slash */\n\t\t\tprotect_against_glob = 0;\n\t\t\tgoto copy;\n\t\t}\n\t\tif ((unsigned char)*p == CTLESC) {\n\t\t\tp++;\n\t\t\tif (protect_against_glob && inquotes && *p != '/') {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t}\n\t\t}\n\t\tprotect_against_glob = globbing;\n copy:\n\t\t*q++ = *p++;\n\t}\n\t*q = '\\0';\n\tif (flag & RMESCAPE_GROW) {\n\t\texpdest = r;\n\t\tSTADJUST(q - r + 1, expdest);\n\t}\n\treturn r;\n}",
        "parsed_output": "const char *sub_473CD2(const char *input, char flags)\n{\n    const char *special_chars_ptr;\n    const char *src;\n    char *dst;\n    size_t prefix_len;\n    size_t total_len;\n    int escape_next_char = 0;\n    int invert_slash_logic = flags & 4;\n    int handle_slashes = flags & 2;\n    char *output;\n    const char *result;\n\n    src = input;\n    special_chars_ptr = strpbrk(input, special_chars);\n    if (!special_chars_ptr)\n        return input;\n\n    result = special_chars_ptr;\n    output = (char *)input;\n    if (flags & 1) {\n        prefix_len = special_chars_ptr - input;\n        total_len = strlen(special_chars_ptr) + prefix_len + 1;\n        if (flags & 8) {\n            int offset = input - global_offset;\n            output = allocate_memory(total_len);\n            src = global_offset + offset;\n            special_chars_ptr = src + prefix_len;\n        } else {\n            output = (flags & 0x10) ? allocate_memory_alt(total_len) : allocate_memory(total_len);\n        }\n        result = output;\n        if (prefix_len)\n            result = (char *)memcpy(output, src, prefix_len) + prefix_len;\n    }\n\n    while (*special_chars_ptr) {\n        if (*special_chars_ptr == -120) {\n            invert_slash_logic = ~invert_slash_logic;\n            ++special_chars_ptr;\n            handle_slashes = flags & 2;\n        } else {\n            if (*special_chars_ptr == 92) {\n                handle_slashes = 0;\n            } else {\n                if (*special_chars_ptr == -127) {\n                    ++special_chars_ptr;\n                    if (handle_slashes) {\n                        if (invert_slash_logic && *special_chars_ptr != '/') {\n                            *result++ = 92;\n                        }\n                    }\n                }\n                handle_slashes = flags & 2;\n            }\n            *result++ = *special_chars_ptr++;\n        }\n    }\n    *result = '\\0';\n    if (flags & 8)\n        global_pointer = result + 1;\n\n    return output;\n}",
        "baseline_code_stripped": "const char *__fastcall sub_473CD2(const char *a1, char a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // rax\n  const char *v8; // rdx\n  char *v9; // rax\n  char *s; // [rsp+8h] [rbp-48h]\n  int v11; // [rsp+1Ch] [rbp-34h]\n  __int64 v12; // [rsp+20h] [rbp-30h]\n  size_t n; // [rsp+28h] [rbp-28h]\n  int v14; // [rsp+30h] [rbp-20h]\n  int v15; // [rsp+34h] [rbp-1Ch]\n  char *v16; // [rsp+38h] [rbp-18h]\n  const char *dest; // [rsp+40h] [rbp-10h]\n  const char *v18; // [rsp+48h] [rbp-8h]\n\n  s = (char *)a1;\n  v18 = strpbrk(a1, &byte_51DF10);\n  if ( !v18 )\n    return a1;\n  dest = v18;\n  v16 = (char *)a1;\n  if ( (a2 & 1) != 0 )\n  {\n    n = v18 - a1;\n    v3 = strlen(v18);\n    v12 = v3 + v18 - a1 + 1;\n    if ( (a2 & 8) != 0 )\n    {\n      v11 = (_DWORD)a1 - *(_QWORD *)(qword_75D428 + 16);\n      v16 = (char *)sub_46ECB9(v12, qword_75AFC8, qword_75AFC8, v4, v5, v6);\n      s = (char *)(*(_QWORD *)(qword_75D428 + 16) + v11);\n      v18 = &s[n];\n    }\n    else\n    {\n      v16 = (a2 & 0x10) != 0\n          ? (char *)sub_40A05F(v12, (__int64)&byte_51DF10)\n          : (char *)sub_46E6A8(v12, (__int64)&byte_51DF10, v3, v4, v5, v6);\n    }\n    dest = v16;\n    if ( n )\n      dest = (char *)memcpy(v16, s, n) + n;\n  }\n  v15 = ~a2 & 4;\n  v14 = a2 & 2;\n  while ( *v18 )\n  {\n    if ( *v18 == -120 )\n    {\n      v15 = ~v15;\n      ++v18;\n      v14 = a2 & 2;\n    }\n    else\n    {\n      if ( *v18 == 92 )\n      {\n        v14 = 0;\n      }\n      else\n      {\n        if ( *v18 == -127 )\n        {\n          ++v18;\n          if ( v14 )\n          {\n            if ( v15 && *v18 != 47 )\n            {\n              v7 = (char *)dest++;\n              *v7 = 92;\n            }\n          }\n        }\n        v14 = a2 & 2;\n      }\n      v8 = v18++;\n      v9 = (char *)dest++;\n      *v9 = *v8;\n    }\n  }\n  *dest = 0;\n  if ( (a2 & 8) != 0 )\n    qword_75AFC8 = (__int64)(dest + 1);\n  return v16;\n}\n",
        "baseline_code_debug": "char *__cdecl rmescapes(char *str, int flag)\n{\n  char *v3; // rax\n  const char *v4; // rdx\n  char *v5; // rax\n  char *stra; // [rsp+8h] [rbp-48h]\n  int strloc; // [rsp+1Ch] [rbp-34h]\n  size_t fulllen; // [rsp+20h] [rbp-30h]\n  size_t len; // [rsp+28h] [rbp-28h]\n  int protect_against_glob; // [rsp+30h] [rbp-20h]\n  int inquotes; // [rsp+34h] [rbp-1Ch]\n  char *r; // [rsp+38h] [rbp-18h]\n  char *q; // [rsp+40h] [rbp-10h]\n  const char *p; // [rsp+48h] [rbp-8h]\n\n  stra = str;\n  p = strpbrk(str, qchars_9544);\n  if ( !p )\n    return str;\n  q = (char *)p;\n  r = str;\n  if ( (flag & 1) != 0 )\n  {\n    len = p - str;\n    fulllen = strlen(p) + p - str + 1;\n    if ( (flag & 8) != 0 )\n    {\n      strloc = (_DWORD)str - (unsigned __int64)ash_ptr_to_globals_memstack->g_stacknxt;\n      r = makestrspace(fulllen, expdest);\n      stra = &ash_ptr_to_globals_memstack->g_stacknxt[strloc];\n      p = &stra[len];\n    }\n    else\n    {\n      r = (char *)((flag & 0x10) != 0 ? xmalloc(fulllen) : stalloc(fulllen));\n    }\n    q = r;\n    if ( len )\n      q = (char *)memcpy(r, stra, len) + len;\n  }\n  inquotes = ~(_BYTE)flag & 4;\n  protect_against_glob = flag & 2;\n  while ( *p )\n  {\n    if ( *p == -120 )\n    {\n      inquotes = ~inquotes;\n      ++p;\n      protect_against_glob = flag & 2;\n    }\n    else\n    {\n      if ( *p == 92 )\n      {\n        protect_against_glob = 0;\n      }\n      else\n      {\n        if ( *p == -127 )\n        {\n          ++p;\n          if ( protect_against_glob )\n          {\n            if ( inquotes && *p != 47 )\n            {\n              v3 = q++;\n              *v3 = 92;\n            }\n          }\n        }\n        protect_against_glob = flag & 2;\n      }\n      v4 = p++;\n      v5 = q++;\n      *v5 = *v4;\n    }\n  }\n  *q = 0;\n  if ( (flag & 8) != 0 )\n    expdest = q + 1;\n  return r;\n}\n",
        "similarity_score_unixcoder": 0.6815804839134216,
        "similarity_score_baseline_stripped": 0.6050715446472168,
        "similarity_score_baseline_debug": 0.8785691261291504
    },
    {
        "func_name": "recursive_check",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl get_ip(const char *str, unsigned __int8 *ip_0)\n{\n  const char *v2; // rax\n  unsigned int tmp[4]; // [rsp+10h] [rbp-20h]\n  int c; // [rsp+24h] [rbp-Ch]\n  int ok; // [rsp+28h] [rbp-8h]\n  int num; // [rsp+2Ch] [rbp-4h]\n\n  num = 0;\n  ok = 0;\n  tmp[3] = 0;\n  tmp[2] = 0;\n  tmp[1] = 0;\n  tmp[0] = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v2 = str++;\n      c = *v2;\n      if ( c <= 47 || c > 57 )\n        break;\n      ok = 1;\n      tmp[num] = 10 * tmp[num] + c - 48;\n      if ( tmp[num] > 0xFF )\n        return 0;\n    }\n    if ( c != 46 )\n      break;\n    if ( !ok )\n      return -1;\n    if ( num == 3 )\n      return 0;\n    ++num;\n    ok = 0;\n  }\n  if ( c || num != 3 || !ok )\n    return 0;\n  *ip_0 = tmp[0];\n  ip_0[1] = tmp[1];\n  ip_0[2] = tmp[2];\n  ip_0[3] = tmp[3];\n  return 1;\n}\n\n\n Revised code:\nstatic int get_ip(const char *str, unsigned char ip[4])\n{\n    unsigned int tmp[4];\n    int num = 0, c, ok = 0;\n\n    tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;\n\n    for (;;) {\n        c = *(str++);\n        if ((c >= '0') && (c <= '9')) {\n            ok = 1;\n            tmp[num] = tmp[num] * 10 + c - '0';\n            if (tmp[num] > 255)\n                return (0);\n        } else if (c == '.') {\n            if (!ok)\n                return (-1);\n            if (num == 3)\n                return (0);\n            num++;\n            ok = 0;\n        } else if (c == '\\0' && (num == 3) && ok)\n            break;\n        else\n            return (0);\n    }\n    ip[0] = tmp[0];\n    ip[1] = tmp[1];\n    ip[2] = tmp[2];\n    ip[3] = tmp[3];\n    return (1);\n}\n\n## Example:\n\n Input code:\nint __cdecl asn1_get_length(const unsigned __int8 **pp, int *inf, __int64 *rl, int max)\n{\n  char *v5; // rax\n  const unsigned __int8 *v6; // rax\n  int maxa; // [rsp+0h] [rbp-3Ch]\n  unsigned int i; // [rsp+28h] [rbp-14h]\n  __int64 ret; // [rsp+2Ch] [rbp-10h]\n  const unsigned __int8 *p; // [rsp+34h] [rbp-8h]\n  const unsigned __int8 *pa; // [rsp+34h] [rbp-8h]\n\n  p = *pp;\n  ret = 0LL;\n  if ( max <= 0 )\n    return 0;\n  if ( *p == 0x80 )\n  {\n    *inf = 1;\n    ret = 0LL;\n    pa = p + 1;\n  }\n  else\n  {\n    *inf = 0;\n    i = *p & 0x7F;\n    v5 = (char *)p;\n    pa = p + 1;\n    if ( *v5 >= 0 )\n    {\n      ret = i;\n    }\n    else\n    {\n      if ( i > 8 )\n        return 0;\n      maxa = max - 2;\n      if ( max == 1 )\n        return 0;\n      while ( i-- )\n      {\n        v6 = pa++;\n        ret = *v6 | (unsigned __int64)(ret << 8);\n        LODWORD(v6) = maxa--;\n        if ( !(_DWORD)v6 )\n          return 0;\n      }\n    }\n  }\n  if ( ret < 0 )\n    return 0;\n  *pp = pa;\n  *rl = ret;\n  return 1;\n}\n\n\n Revised code:\nstatic int asn1_get_length(const unsigned char **pp, int *inf, long *rl,\n                           long max)\n{\n    const unsigned char *p = *pp;\n    unsigned long ret = 0;\n    unsigned long i;\n\n    if (max-- < 1)\n        return 0;\n    if (*p == 0x80) {\n        *inf = 1;\n        ret = 0;\n        p++;\n    } else {\n        *inf = 0;\n        i = *p & 0x7f;\n        if (*(p++) & 0x80) {\n            if (i > sizeof(ret) || max < (long)i)\n                return 0;\n            while (i-- > 0) {\n                ret <<= 8L;\n                ret |= *(p++);\n            }\n        } else\n            ret = i;\n    }\n    if (ret > LONG_MAX)\n        return 0;\n    *pp = p;\n    *rl = (long)ret;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_49828D(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 result; // rax\n  __int64 v8; // [rsp+10h] [rbp-10h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  v6 = 32LL * a1 - 32;\n  v8 = v6 + *((_QWORD *)qword_75D408 + 6);\n  if ( (*(_WORD *)v8 & 0xF000) != 0x4000 )\n    sub_495EC2((__int64)\"internal error\", a2, v6, a4, a5, a6);\n  if ( *(_DWORD *)(v8 + 4) < (unsigned int)(2 * *((char *)qword_75D408 + 4)) )\n  {\n    printf(\"%s: bad directory: size<32\", (const char *)qword_75D408 + 5540);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  for ( i = 0; ; i += *((char *)qword_75D408 + 4) )\n  {\n    result = *(unsigned int *)(v8 + 4);\n    if ( i >= (unsigned int)result )\n      break;\n    sub_497D29(v8, i);\n  }\n  return result;\n}\n",
        "output": "```c\nstatic void sub_49828D(unsigned int index, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n    __int64 directoryOffset;\n    __int64 directoryEntry;\n    unsigned int directorySize;\n    unsigned int entrySize;\n    unsigned int i;\n\n    directoryOffset = 32LL * index - 32;\n    directoryEntry = directoryOffset + *((_QWORD *)qword_75D408 + 6);\n    if ((*(_WORD *)directoryEntry & 0xF000) != 0x4000)\n        sub_495EC2((__int64)\"internal error\", a2, directoryOffset, a4, a5, a6);\n    \n    directorySize = *(_DWORD *)(directoryEntry + 4);\n    entrySize = 2 * *((char *)qword_75D408 + 4);\n    if (directorySize < entrySize)\n    {\n        printf(\"%s: bad directory: size<32\", (const char *)qword_75D408 + 5540);\n        *((_BYTE *)qword_75D408 + 2) = 1;\n    }\n    \n    for (i = 0; i < directorySize; i += entrySize)\n    {\n        sub_497D29(directoryEntry, i);\n    }\n}\n```",
        "source_code": "endif\n\nstatic void recursive_check(unsigned ino)\n{\n\tstruct minix1_inode *dir;\n\tunsigned offset;\n\n\tdir = Inode1 + ino;\n\tif (!S_ISDIR(dir->i_mode))\n\t\tdie(\"internal error\");\n\tif (dir->i_size < 2 * dirsize) {\n\t\tprintf(\"%s: bad directory: size<32\", current_name);\n\t\terrors_uncorrected = 1;\n\t}\n\tfor (offset = 0; offset < dir->i_size; offset += dirsize)\n\t\tcheck_file(dir, offset);\n}",
        "parsed_output": "static void sub_49828D(unsigned int index, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n    __int64 directoryOffset;\n    __int64 directoryEntry;\n    unsigned int directorySize;\n    unsigned int entrySize;\n    unsigned int i;\n\n    directoryOffset = 32LL * index - 32;\n    directoryEntry = directoryOffset + *((_QWORD *)qword_75D408 + 6);\n    if ((*(_WORD *)directoryEntry & 0xF000) != 0x4000)\n        sub_495EC2((__int64)\"internal error\", a2, directoryOffset, a4, a5, a6);\n    \n    directorySize = *(_DWORD *)(directoryEntry + 4);\n    entrySize = 2 * *((char *)qword_75D408 + 4);\n    if (directorySize < entrySize)\n    {\n        printf(\"%s: bad directory: size<32\", (const char *)qword_75D408 + 5540);\n        *((_BYTE *)qword_75D408 + 2) = 1;\n    }\n    \n    for (i = 0; i < directorySize; i += entrySize)\n    {\n        sub_497D29(directoryEntry, i);\n    }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_49828D(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 result; // rax\n  __int64 v8; // [rsp+10h] [rbp-10h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  v6 = 32LL * a1 - 32;\n  v8 = v6 + *((_QWORD *)qword_75D408 + 6);\n  if ( (*(_WORD *)v8 & 0xF000) != 0x4000 )\n    sub_495EC2((__int64)\"internal error\", a2, v6, a4, a5, a6);\n  if ( *(_DWORD *)(v8 + 4) < (unsigned int)(2 * *((char *)qword_75D408 + 4)) )\n  {\n    printf(\"%s: bad directory: size<32\", (const char *)qword_75D408 + 5540);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  for ( i = 0; ; i += *((char *)qword_75D408 + 4) )\n  {\n    result = *(unsigned int *)(v8 + 4);\n    if ( i >= (unsigned int)result )\n      break;\n    sub_497D29(v8, i);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl recursive_check(unsigned int ino)\n{\n  minix1_inode *dir; // [rsp+10h] [rbp-10h]\n  unsigned int offset; // [rsp+1Ch] [rbp-4h]\n\n  dir = (minix1_inode *)(32LL * ino - 32 + *(_QWORD *)&ptr_to_globals->numspeed);\n  if ( (dir->i_mode & 0xF000) != 0x4000 )\n    die(\"internal error\");\n  if ( dir->i_size < 2 * *((char *)&ptr_to_globals->timeout + 4) )\n  {\n    printf(\"%s: bad directory: size<32\", (const char *)&ptr_to_globals[19].speeds[4]);\n    BYTE2(ptr_to_globals->timeout) = 1;\n  }\n  for ( offset = 0; offset < dir->i_size; offset += *((char *)&ptr_to_globals->timeout + 4) )\n    check_file(dir, offset);\n}\n",
        "similarity_score_unixcoder": 0.6589275002479553,
        "similarity_score_baseline_stripped": 0.5752251744270325,
        "similarity_score_baseline_debug": 0.7596282958984375
    },
    {
        "func_name": "init_block",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl private_RC4_set_key(RC4_KEY *key, int len, const unsigned __int8 *data)\n{\n  unsigned __int8 *v3; // r12\n  int v4; // ebx\n  int v5; // r13d\n  unsigned __int8 v6; // r14\n  int v7; // ebx\n  int v8; // r13d\n  unsigned __int8 v9; // r14\n  int v10; // ebx\n  int v11; // r13d\n  unsigned __int8 v12; // r14\n  int v13; // ebx\n  int v14; // r13d\n  unsigned __int8 v15; // r14\n  unsigned int i; // [rsp+24h] [rbp-24h]\n  unsigned int ia; // [rsp+24h] [rbp-24h]\n\n  v3 = key->data;\n  key->x = 0;\n  key->y = 0;\n  LOBYTE(v4) = 0;\n  v5 = 0;\n  for ( i = 0; i <= 0xFF; ++i )\n    v3[i] = i;\n  for ( ia = 0; ia <= 0xFF; ia += 4 )\n  {\n    v6 = v3[ia];\n    v7 = (unsigned __int8)(v4 + data[v5] + v6);\n    v8 = v5 + 1;\n    if ( v8 == len )\n      v8 = 0;\n    v3[ia] = v3[v7];\n    v3[v7] = v6;\n    v9 = v3[ia + 1];\n    v10 = (unsigned __int8)(v7 + data[v8] + v9);\n    v11 = v8 + 1;\n    if ( v11 == len )\n      v11 = 0;\n    v3[ia + 1] = v3[v10];\n    v3[v10] = v9;\n    v12 = v3[ia + 2];\n    v13 = (unsigned __int8)(v10 + data[v11] + v12);\n    v14 = v11 + 1;\n    if ( v14 == len )\n      v14 = 0;\n    v3[ia + 2] = v3[v13];\n    v3[v13] = v12;\n    v15 = v3[ia + 3];\n    v4 = (unsigned __int8)(v13 + data[v14] + v15);\n    v5 = v14 + 1;\n    if ( v5 == len )\n      v5 = 0;\n    v3[ia + 3] = v3[v4];\n    v3[v4] = v15;\n  }\n}\n\n\n Revised code:\nvoid private_RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)\n{\n    register RC4_INT tmp;\n    register int id1, id2;\n    register RC4_INT *d;\n    unsigned int i;\n\n    d = &(key->data[0]);\n    key->x = 0;\n    key->y = 0;\n    id1 = id2 = 0;\n\n#define SK_LOOP(d,n) { \\\n                tmp=d[(n)]; \\\n                id2 = (data[id1] + tmp + id2) & 0xff; \\\n                if (++id1 == len) id1=0; \\\n                d[(n)]=d[id2]; \\\n                d[id2]=tmp; }\n\n    for (i = 0; i < 256; i++)\n        d[i] = i;\n    for (i = 0; i < 256; i += 4) {\n        SK_LOOP(d, i + 0);\n        SK_LOOP(d, i + 1);\n        SK_LOOP(d, i + 2);\n        SK_LOOP(d, i + 3);\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl EVP_DecodeBlock(unsigned __int8 *t, const unsigned __int8 *f, int n)\n{\n  const unsigned __int8 *v4; // rax\n  unsigned __int8 *v5; // rax\n  __int16 l; // [rsp+14h] [rbp-20h]\n  int d; // [rsp+1Ch] [rbp-18h]\n  int c; // [rsp+20h] [rbp-14h]\n  int b; // [rsp+24h] [rbp-10h]\n  int a; // [rsp+28h] [rbp-Ch]\n  int ret; // [rsp+2Ch] [rbp-8h]\n  int i; // [rsp+30h] [rbp-4h]\n\n  ret = 0;\n  while ( data_ascii2bin[*f & 0x7F] == 0xE0 && n > 0 )\n  {\n    ++f;\n    --n;\n  }\n  while ( n > 3 && (data_ascii2bin[f[n - 1] & 0x7F] | 0x13) == 0xF3 )\n    --n;\n  if ( (n & 3) != 0 )\n    return -1;\n  for ( i = 0; i < n; i += 4 )\n  {\n    a = data_ascii2bin[*f & 0x7F];\n    b = data_ascii2bin[f[1] & 0x7F];\n    c = data_ascii2bin[f[2] & 0x7F];\n    v4 = f + 3;\n    f += 4;\n    d = data_ascii2bin[*v4 & 0x7F];\n    if ( (a & 0x80) != 0 || (b & 0x80) != 0 || (c & 0x80) != 0 || (d & 0x80) != 0 )\n      return -1;\n    l = ((_WORD)c << 6) | ((_WORD)b << 12) | data_ascii2bin[*v4 & 0x7F];\n    *t = ((c << 6) | (b << 12) | (a << 18) | (unsigned int)d) >> 16;\n    t[1] = HIBYTE(l);\n    v5 = t + 2;\n    t += 3;\n    *v5 = l;\n    ret += 3;\n  }\n  return ret;\n}\n\n\n Revised code:\nint EVP_DecodeBlock(unsigned char *t, const unsigned char *f, int n)\n{\n    int i, ret = 0, a, b, c, d;\n    unsigned long l;\n\n    /* trim white space from the start of the line. */\n    while ((conv_ascii2bin(*f) == B64_WS) && (n > 0)) {\n        f++;\n        n--;\n    }\n\n    /*\n     * strip off stuff at the end of the line ascii2bin values B64_WS,\n     * B64_EOLN, B64_EOLN and B64_EOF\n     */\n    while ((n > 3) && (B64_NOT_BASE64(conv_ascii2bin(f[n - 1]))))\n        n--;\n\n    if (n % 4 != 0)\n        return (-1);\n\n    for (i = 0; i < n; i += 4) {\n        a = conv_ascii2bin(*(f++));\n        b = conv_ascii2bin(*(f++));\n        c = conv_ascii2bin(*(f++));\n        d = conv_ascii2bin(*(f++));\n        if ((a & 0x80) || (b & 0x80) || (c & 0x80) || (d & 0x80))\n            return (-1);\n        l = ((((unsigned long)a) << 18L) |\n             (((unsigned long)b) << 12L) |\n             (((unsigned long)c) << 6L) | (((unsigned long)d)));\n        *(t++) = (unsigned char)(l >> 16L) & 0xff;\n        *(t++) = (unsigned char)(l >> 8L) & 0xff;\n        *(t++) = (unsigned char)(l) & 0xff;\n        ret += 3;\n    }\n    return (ret);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *sub_4AF093()\n{\n  _DWORD *v0; // rax\n  _DWORD *v1; // rdx\n  _DWORD *v2; // rax\n  void *result; // rax\n  int i; // [rsp+0h] [rbp-4h]\n  int j; // [rsp+0h] [rbp-4h]\n  int k; // [rsp+0h] [rbp-4h]\n\n  for ( i = 0; i <= 285; ++i )\n    *((_WORD *)qword_75D408 + 2 * i + 578) = 0;\n  for ( j = 0; j <= 29; ++j )\n    *((_WORD *)qword_75D408 + 2 * j + 1724) = 0;\n  for ( k = 0; k <= 18; ++k )\n    *((_WORD *)qword_75D408 + 2 * k + 2482) = 0;\n  *((_WORD *)qword_75D408 + 1090) = 1;\n  v0 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 1974) = 0;\n  *((_DWORD *)qword_75D408 + 1973) = v0[1974];\n  v1 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 1971) = 0;\n  v2 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 1970) = v1[1971];\n  *((_DWORD *)qword_75D408 + 1969) = v2[1970];\n  *((_BYTE *)qword_75D408 + 7888) = 0;\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 7889) = 1;\n  return result;\n}\n",
        "output": "```c\nvoid *initialize_data_structure()\n{\n    unsigned short *data;\n    int i;\n\n    data = (unsigned short *)qword_75D408;\n\n    // Initialize the first 286 elements to 0\n    for (i = 0; i <= 285; ++i)\n        data[i] = 0;\n\n    // Initialize the next 30 elements to 0\n    for (i = 286; i <= 315; ++i)\n        data[i] = 0;\n\n    // Initialize the next 19 elements to 0\n    for (i = 316; i <= 334; ++i)\n        data[i] = 0;\n\n    // Set a specific value to 1\n    data[545] = 1;\n\n    // Reset four DWORDs to 0\n    *((DWORD *)data + 1974) = 0;\n    *((DWORD *)data + 1973) = 0;\n    *((DWORD *)data + 1971) = 0;\n    *((DWORD *)data + 1970) = 0;\n    *((DWORD *)data + 1969) = 0;\n\n    // Set two bytes at the end to 0 and 1\n    *((BYTE *)data + 7888) = 0;\n    *((BYTE *)data + 7889) = 1;\n\n    return data;\n}\n```",
        "source_code": "static void init_block(void)\n{\n\tint n; /* iterates over tree elements */\n\n\t/* Initialize the trees. */\n\tfor (n = 0; n < L_CODES; n++)\n\t\tG2.dyn_ltree[n].Freq = 0;\n\tfor (n = 0; n < D_CODES; n++)\n\t\tG2.dyn_dtree[n].Freq = 0;\n\tfor (n = 0; n < BL_CODES; n++)\n\t\tG2.bl_tree[n].Freq = 0;\n\n\tG2.dyn_ltree[END_BLOCK].Freq = 1;\n\tG2.opt_len = G2.static_len = 0;\n\tG2.last_lit = G2.last_dist = G2.last_flags = 0;\n\tG2.flags = 0;\n\tG2.flag_bit = 1;\n}",
        "parsed_output": "void *initialize_data_structure()\n{\n    unsigned short *data;\n    int i;\n\n    data = (unsigned short *)qword_75D408;\n\n    // Initialize the first 286 elements to 0\n    for (i = 0; i <= 285; ++i)\n        data[i] = 0;\n\n    // Initialize the next 30 elements to 0\n    for (i = 286; i <= 315; ++i)\n        data[i] = 0;\n\n    // Initialize the next 19 elements to 0\n    for (i = 316; i <= 334; ++i)\n        data[i] = 0;\n\n    // Set a specific value to 1\n    data[545] = 1;\n\n    // Reset four DWORDs to 0\n    *((DWORD *)data + 1974) = 0;\n    *((DWORD *)data + 1973) = 0;\n    *((DWORD *)data + 1971) = 0;\n    *((DWORD *)data + 1970) = 0;\n    *((DWORD *)data + 1969) = 0;\n\n    // Set two bytes at the end to 0 and 1\n    *((BYTE *)data + 7888) = 0;\n    *((BYTE *)data + 7889) = 1;\n\n    return data;\n}",
        "baseline_code_stripped": "void *sub_4AF093()\n{\n  _DWORD *v0; // rax\n  _DWORD *v1; // rdx\n  _DWORD *v2; // rax\n  void *result; // rax\n  int i; // [rsp+0h] [rbp-4h]\n  int j; // [rsp+0h] [rbp-4h]\n  int k; // [rsp+0h] [rbp-4h]\n\n  for ( i = 0; i <= 285; ++i )\n    *((_WORD *)qword_75D408 + 2 * i + 578) = 0;\n  for ( j = 0; j <= 29; ++j )\n    *((_WORD *)qword_75D408 + 2 * j + 1724) = 0;\n  for ( k = 0; k <= 18; ++k )\n    *((_WORD *)qword_75D408 + 2 * k + 2482) = 0;\n  *((_WORD *)qword_75D408 + 1090) = 1;\n  v0 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 1974) = 0;\n  *((_DWORD *)qword_75D408 + 1973) = v0[1974];\n  v1 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 1971) = 0;\n  v2 = qword_75D408;\n  *((_DWORD *)qword_75D408 + 1970) = v1[1971];\n  *((_DWORD *)qword_75D408 + 1969) = v2[1970];\n  *((_BYTE *)qword_75D408 + 7888) = 0;\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 7889) = 1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl init_block()\n{\n  globals *v0; // rax\n  globals *v1; // rdx\n  globals *v2; // rax\n  int n; // [rsp+0h] [rbp-4h]\n  int na; // [rsp+0h] [rbp-4h]\n  int nb; // [rsp+0h] [rbp-4h]\n\n  for ( n = 0; n <= 285; ++n )\n    *((_WORD *)&ptr_to_globals[4].timeout + 2 * n + 2) = 0;\n  for ( na = 0; na <= 29; ++na )\n    *(_WORD *)&ptr_to_globals[11].line_buf[4 * na + 124] = 0;\n  for ( nb = 0; nb <= 18; ++nb )\n    LOWORD(ptr_to_globals[17].speeds[nb + 4]) = 0;\n  *(_WORD *)&ptr_to_globals[7].line_buf[8] = 1;\n  v0 = ptr_to_globals;\n  *(_DWORD *)&ptr_to_globals[27].tty_attrs.c_cc[7] = 0;\n  *(_DWORD *)&ptr_to_globals[27].tty_attrs.c_cc[3] = *(_DWORD *)&v0[27].tty_attrs.c_cc[7];\n  v1 = ptr_to_globals;\n  ptr_to_globals[27].tty_attrs.c_lflag = 0;\n  v2 = ptr_to_globals;\n  ptr_to_globals[27].tty_attrs.c_cflag = v1[27].tty_attrs.c_lflag;\n  ptr_to_globals[27].tty_attrs.c_oflag = v2[27].tty_attrs.c_cflag;\n  ptr_to_globals[27].tty_attrs.c_line = 0;\n  ptr_to_globals[27].tty_attrs.c_cc[0] = 1;\n}\n",
        "similarity_score_unixcoder": 0.5046874284744263,
        "similarity_score_baseline_stripped": 0.42569422721862793,
        "similarity_score_baseline_debug": 0.49358752369880676
    },
    {
        "func_name": "stzalloc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl bn_sqr_words(unsigned __int64 *r, const unsigned __int64 *a, int n)\n{\n  int na; // [rsp+0h] [rbp-44h]\n\n  na = n;\n  if ( n > 0 )\n  {\n    while ( (na & 0xFFFFFFFC) != 0 )\n    {\n      *(_OWORD *)r = *a * (unsigned __int128)*a;\n      *((_OWORD *)r + 1) = a[1] * (unsigned __int128)a[1];\n      *((_OWORD *)r + 2) = a[2] * (unsigned __int128)a[2];\n      *((_OWORD *)r + 3) = a[3] * (unsigned __int128)a[3];\n      a += 4;\n      r += 8;\n      na -= 4;\n    }\n    while ( na )\n    {\n      *(_OWORD *)r = *a * (unsigned __int128)*a;\n      ++a;\n      r += 2;\n      --na;\n    }\n  }\n}\n\n\n Revised code:\nvoid bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)\n{\n    assert(n >= 0);\n    if (n <= 0)\n        return;\n\n# ifndef OPENSSL_SMALL_FOOTPRINT\n    while (n & ~3) {\n        sqr(r[0], r[1], a[0]);\n        sqr(r[2], r[3], a[1]);\n        sqr(r[4], r[5], a[2]);\n        sqr(r[6], r[7], a[3]);\n        a += 4;\n        r += 8;\n        n -= 4;\n    }\n# endif\n    while (n) {\n        sqr(r[0], r[1], a[0]);\n        a++;\n        r += 2;\n        n--;\n    }\n}\n\n## Example:\n\n Input code:\nvoid __cdecl bn_sqr_normal(unsigned __int64 *r, const unsigned __int64 *a, int n, unsigned __int64 *tmp)\n{\n  unsigned __int64 *v4; // rax\n  int max; // [rsp+24h] [rbp-2Ch]\n  unsigned __int64 *rp; // [rsp+28h] [rbp-28h]\n  const unsigned __int64 *ap; // [rsp+30h] [rbp-20h]\n  int j; // [rsp+38h] [rbp-18h]\n  int i; // [rsp+3Ch] [rbp-14h]\n\n  max = 2 * n;\n  ap = a;\n  v4 = &r[2 * n - 1];\n  *v4 = 0LL;\n  *r = *v4;\n  rp = r + 1;\n  j = n - 1;\n  if ( n - 1 > 0 )\n  {\n    ap = a + 1;\n    rp[j] = bn_mul_words(rp, a + 1, j, *a);\n    rp = r + 3;\n  }\n  for ( i = n - 2; i > 0; --i )\n  {\n    --j;\n    ++ap;\n    rp[j] = bn_mul_add_words(rp, ap, j, *(ap - 1));\n    rp += 2;\n  }\n  bn_add_words(r, r, r, max);\n  bn_sqr_words(tmp, a, n);\n  bn_add_words(r, r, tmp, max);\n}\n\n\n Revised code:\nvoid bn_sqr_normal(BN_ULONG *r, const BN_ULONG *a, int n, BN_ULONG *tmp)\n{\n    int i, j, max;\n    const BN_ULONG *ap;\n    BN_ULONG *rp;\n\n    max = n * 2;\n    ap = a;\n    rp = r;\n    rp[0] = rp[max - 1] = 0;\n    rp++;\n    j = n;\n\n    if (--j > 0) {\n        ap++;\n        rp[j] = bn_mul_words(rp, ap, j, ap[-1]);\n        rp += 2;\n    }\n\n    for (i = n - 2; i > 0; i--) {\n        j--;\n        ap++;\n        rp[j] = bn_mul_add_words(rp, ap, j, ap[-1]);\n        rp += 2;\n    }\n\n    bn_add_words(r, r, r, max);\n\n    /* There will not be a carry */\n\n    bn_sqr_words(tmp, a, n);\n\n    bn_add_words(r, r, tmp, max);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_46E7E7(size_t a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  void *v6; // rax\n\n  v6 = (void *)sub_46E6A8(a1, a2, a3, a4, a5, a6);\n  return memset(v6, 0, a1);\n}\n",
        "output": "```c\nvoid *allocate_and_zero(size_t size, __int64 param1, __int64 param2, __int64 param3, __int64 param4, __int64 param5)\n{\n    void *memory = allocate_memory(size, param1, param2, param3, param4, param5);\n    return memset(memory, 0, size);\n}\n```",
        "source_code": "static void *\nstzalloc(size_t nbytes)\n{\n\treturn memset(stalloc(nbytes), 0, nbytes);\n}",
        "parsed_output": "void *allocate_and_zero(size_t size, __int64 param1, __int64 param2, __int64 param3, __int64 param4, __int64 param5)\n{\n    void *memory = allocate_memory(size, param1, param2, param3, param4, param5);\n    return memset(memory, 0, size);\n}",
        "baseline_code_stripped": "void *__fastcall sub_46E7E7(size_t a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  void *v6; // rax\n\n  v6 = (void *)sub_46E6A8(a1, a2, a3, a4, a5, a6);\n  return memset(v6, 0, a1);\n}\n",
        "baseline_code_debug": "void *__cdecl stzalloc(size_t nbytes)\n{\n  void *v1; // rcx\n\n  v1 = stalloc(nbytes);\n  return memset(v1, 0, nbytes);\n}\n",
        "similarity_score_unixcoder": 0.6886894106864929,
        "similarity_score_baseline_stripped": 0.540249764919281,
        "similarity_score_baseline_debug": 0.8589975237846375
    },
    {
        "func_name": "my_xstrtoull",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl interleaved_array_to_bn_512(BIGNUM *b, UINT64 *array)\n{\n  int v2; // eax\n  unsigned __int8 tmp[64]; // [rsp+10h] [rbp-50h] BYREF\n  int i; // [rsp+58h] [rbp-8h]\n  int n; // [rsp+5Ch] [rbp-4h]\n\n  n = 8;\n  while ( 1 )\n  {\n    v2 = n--;\n    if ( v2 <= 0 )\n      break;\n    for ( i = 7; i >= 0; --i )\n      tmp[63 - (8 * n + i)] = array[n] >> (8 * (unsigned __int8)i);\n  }\n  BN_bin2bn(tmp, 64, b);\n  return 0;\n}\n\n\n Revised code:\nstatic int interleaved_array_to_bn_512(BIGNUM *b, UINT64 *array)\n{\n    unsigned char tmp[64];\n    int n = 8;\n    int i;\n    while (n-- > 0) {\n        for (i = 7; i >= 0; i--) {\n            tmp[63 - (n * 8 + i)] = (unsigned char)(array[n] >> (8 * i));\n    }}\n    BN_bin2bn(tmp, 64, b);\n    return 0;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl ctr64_add(unsigned __int8 *counter, size_t inc)\n{\n  unsigned __int64 v2; // rdx\n  unsigned __int8 *countera; // [rsp+8h] [rbp-18h]\n  size_t val; // [rsp+10h] [rbp-10h]\n  size_t n; // [rsp+18h] [rbp-8h]\n\n  n = 8LL;\n  val = 0LL;\n  countera = counter + 8;\n  do\n  {\n    v2 = countera[--n] + (unsigned __int64)(unsigned __int8)inc + val;\n    countera[n] = v2;\n    val = v2 >> 8;\n    inc >>= 8;\n  }\n  while ( n && (inc || val) );\n}\n\n\n Revised code:\nstatic void ctr64_add(unsigned char *counter, size_t inc)\n{\n    size_t n = 8, val = 0;\n\n    counter += 8;\n    do {\n        --n;\n        val += counter[n] + (inc & 0xff);\n        counter[n] = (unsigned char)val;\n        val >>= 8;              /* carry bit */\n        inc >>= 8;\n    } while (n && (inc || val));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4CFB20(_BYTE *a1)\n{\n  __int64 v2; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( (unsigned int)sub_4CF9A2(a1, (__int64)&v2, (void (__fastcall *)(_BYTE *, __int64))sub_4CFA37) )\n    return 0LL;\n  return v2;\n}\n",
        "output": "```c\nstatic __int64 sub_4CFB20(unsigned char *a1)\n{\n    __int64 result;\n\n    if (sub_4CF9A2(a1, &result, sub_4CFA37)) {\n        return 0;\n    }\n    return result;\n}\n```",
        "source_code": "static unsigned long long my_xstrtoull(const char *arg)\n{\n\tunsigned long long result;\n\tif (multiconvert(arg, &result, conv_strtoull))\n\t\tresult = 0;\n\treturn result;\n}",
        "parsed_output": "static __int64 sub_4CFB20(unsigned char *a1)\n{\n    __int64 result;\n\n    if (sub_4CF9A2(a1, &result, sub_4CFA37)) {\n        return 0;\n    }\n    return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4CFB20(_BYTE *a1)\n{\n  __int64 v2; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( (unsigned int)sub_4CF9A2(a1, (__int64)&v2, (void (__fastcall *)(_BYTE *, __int64))sub_4CFA37) )\n    return 0LL;\n  return v2;\n}\n",
        "baseline_code_debug": "unsigned __int64 __cdecl my_xstrtoull(const char *arg)\n{\n  unsigned __int64 result; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( multiconvert(arg, &result, (converter)conv_strtoull) )\n    return 0LL;\n  return result;\n}\n",
        "similarity_score_unixcoder": 0.4622995853424072,
        "similarity_score_baseline_stripped": 0.401692271232605,
        "similarity_score_baseline_debug": 0.79386967420578
    },
    {
        "func_name": "inet_addr_match",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl ctr64_add(unsigned __int8 *counter, size_t inc)\n{\n  unsigned __int64 v2; // rdx\n  unsigned __int8 *countera; // [rsp+8h] [rbp-18h]\n  size_t val; // [rsp+10h] [rbp-10h]\n  size_t n; // [rsp+18h] [rbp-8h]\n\n  n = 8LL;\n  val = 0LL;\n  countera = counter + 8;\n  do\n  {\n    v2 = countera[--n] + (unsigned __int64)(unsigned __int8)inc + val;\n    countera[n] = v2;\n    val = v2 >> 8;\n    inc >>= 8;\n  }\n  while ( n && (inc || val) );\n}\n\n\n Revised code:\nstatic void ctr64_add(unsigned char *counter, size_t inc)\n{\n    size_t n = 8, val = 0;\n\n    counter += 8;\n    do {\n        --n;\n        val += counter[n] + (inc & 0xff);\n        counter[n] = (unsigned char)val;\n        val >>= 8;              /* carry bit */\n        inc >>= 8;\n    } while (n && (inc || val));\n}\n\n## Example:\n\n Input code:\nunsigned int __cdecl inverse(unsigned int xin)\n{\n  __int64 t; // [rsp+Ch] [rbp-38h]\n  __int64 q; // [rsp+14h] [rbp-30h]\n  __int64 r; // [rsp+1Ch] [rbp-28h]\n  __int64 b2; // [rsp+24h] [rbp-20h]\n  __int64 b1; // [rsp+2Ch] [rbp-18h]\n  __int64 n2; // [rsp+34h] [rbp-10h]\n  __int64 n1; // [rsp+3Ch] [rbp-8h]\n\n  if ( xin )\n  {\n    n1 = 65537LL;\n    n2 = xin;\n    b2 = 1LL;\n    b1 = 0LL;\n    do\n    {\n      r = n1 % n2;\n      q = (n1 - n1 % n2) / n2;\n      if ( n1 % n2 )\n      {\n        n1 = n2;\n        n2 = r;\n        t = b2;\n        b2 = b1 - b2 * q;\n        b1 = t;\n      }\n      else\n      {\n        b2 += b2 < 0 ? 0x10001uLL : 0;\n      }\n    }\n    while ( r );\n  }\n  else\n  {\n    LODWORD(b2) = 0;\n  }\n  return b2;\n}\n\n\n Revised code:\nstatic IDEA_INT inverse(unsigned int xin)\n{\n    long n1, n2, q, r, b1, b2, t;\n\n    if (xin == 0)\n        b2 = 0;\n    else {\n        n1 = 0x10001;\n        n2 = xin;\n        b2 = 1;\n        b1 = 0;\n\n        do {\n            r = (n1 % n2);\n            q = (n1 - r) / n2;\n            if (r == 0) {\n                if (b2 < 0)\n                    b2 = 0x10001 + b2;\n            } else {\n                n1 = n2;\n                n2 = r;\n                t = b2;\n                b2 = b1 - q * b2;\n                b1 = t;\n            }\n        } while (r != 0);\n    }\n    return ((IDEA_INT) b2);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_453311(__int64 a1, __int64 a2, int a3)\n{\n  int v4; // [rsp+Ch] [rbp-34h]\n  int v5; // [rsp+24h] [rbp-1Ch]\n  int v6; // [rsp+28h] [rbp-18h]\n  int v7; // [rsp+2Ch] [rbp-14h]\n  void *s2; // [rsp+30h] [rbp-10h]\n  void *s1; // [rsp+38h] [rbp-8h]\n\n  s1 = (void *)(a1 + 4);\n  s2 = (void *)(a2 + 4);\n  v7 = a3 >> 5;\n  v4 = a3 & 0x1F;\n  if ( a3 >> 5 && memcmp(s1, s2, 4 * v7) )\n    return 0xFFFFFFFFLL;\n  if ( v4 )\n  {\n    v6 = *((_DWORD *)s1 + v7);\n    v5 = *((_DWORD *)s2 + v7);\n    if ( (htonl(-1 << (32 - v4)) & (v5 ^ v6)) != 0 )\n      return 1LL;\n  }\n  return 0LL;\n}\n",
        "output": "```c\nstatic int64_t sub_453311(int64_t a1, int64_t a2, int a3)\n{\n    int v4, v5, v6, v7;\n    void *s1, *s2;\n\n    s1 = (void *)(a1 + 4);\n    s2 = (void *)(a2 + 4);\n    v7 = a3 / 32; // Number of full 32-bit blocks\n    v4 = a3 % 32; // Number of bits in the last, partial block\n\n    // Compare full 32-bit blocks\n    if (v7 && memcmp(s1, s2, v7 * sizeof(int)) != 0)\n        return -1;\n\n    // Compare remaining bits, if any\n    if (v4) {\n        v6 = *((int *)s1 + v7);\n        v5 = *((int *)s2 + v7);\n        if ((htonl(~0 << (32 - v4)) & (v5 ^ v6)) != 0)\n            return 1;\n    }\n\n    return 0;\n}\n```",
        "source_code": "int inet_addr_match(const inet_prefix *a, const inet_prefix *b, int bits)\n{\n\tconst uint32_t *a1 = a->data;\n\tconst uint32_t *a2 = b->data;\n\tint words = bits >> 5;\n\n\tbits &= 0x1f;\n\n\tif (words)\n\t\tif (memcmp(a1, a2, words << 2))\n\t\t\treturn -1;\n\n\tif (bits) {\n\t\tuint32_t w1, w2;\n\t\tuint32_t mask;\n\n\t\tw1 = a1[words];\n\t\tw2 = a2[words];\n\n\t\tmask = htonl((0xffffffff) << (0x20 - bits));\n\n\t\tif ((w1 ^ w2) & mask)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
        "parsed_output": "static int64_t sub_453311(int64_t a1, int64_t a2, int a3)\n{\n    int v4, v5, v6, v7;\n    void *s1, *s2;\n\n    s1 = (void *)(a1 + 4);\n    s2 = (void *)(a2 + 4);\n    v7 = a3 / 32; // Number of full 32-bit blocks\n    v4 = a3 % 32; // Number of bits in the last, partial block\n\n    // Compare full 32-bit blocks\n    if (v7 && memcmp(s1, s2, v7 * sizeof(int)) != 0)\n        return -1;\n\n    // Compare remaining bits, if any\n    if (v4) {\n        v6 = *((int *)s1 + v7);\n        v5 = *((int *)s2 + v7);\n        if ((htonl(~0 << (32 - v4)) & (v5 ^ v6)) != 0)\n            return 1;\n    }\n\n    return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_453311(__int64 a1, __int64 a2, int a3)\n{\n  int v4; // [rsp+Ch] [rbp-34h]\n  int v5; // [rsp+24h] [rbp-1Ch]\n  int v6; // [rsp+28h] [rbp-18h]\n  int v7; // [rsp+2Ch] [rbp-14h]\n  void *s2; // [rsp+30h] [rbp-10h]\n  void *s1; // [rsp+38h] [rbp-8h]\n\n  s1 = (void *)(a1 + 4);\n  s2 = (void *)(a2 + 4);\n  v7 = a3 >> 5;\n  v4 = a3 & 0x1F;\n  if ( a3 >> 5 && memcmp(s1, s2, 4 * v7) )\n    return 0xFFFFFFFFLL;\n  if ( v4 )\n  {\n    v6 = *((_DWORD *)s1 + v7);\n    v5 = *((_DWORD *)s2 + v7);\n    if ( (htonl(-1 << (32 - v4)) & (v5 ^ v6)) != 0 )\n      return 1LL;\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl inet_addr_match(const inet_prefix *a, const inet_prefix *b, int bits)\n{\n  int bitsa; // [rsp+Ch] [rbp-34h]\n  uint32_t w2; // [rsp+24h] [rbp-1Ch]\n  uint32_t w1; // [rsp+28h] [rbp-18h]\n  int words; // [rsp+2Ch] [rbp-14h]\n  uint32_t *a2; // [rsp+30h] [rbp-10h]\n  uint32_t *a1; // [rsp+38h] [rbp-8h]\n\n  a1 = a->data;\n  a2 = b->data;\n  words = bits >> 5;\n  bitsa = bits & 0x1F;\n  if ( bits >> 5 && memcmp(a1, a2, 4 * words) )\n    return -1;\n  if ( bitsa )\n  {\n    w1 = a1[words];\n    w2 = a2[words];\n    if ( (htonl(-1 << (32 - bitsa)) & (w2 ^ w1)) != 0 )\n      return 1;\n  }\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.7532808184623718,
        "similarity_score_baseline_stripped": 0.6058030128479004,
        "similarity_score_baseline_debug": 0.8865790963172913
    },
    {
        "func_name": "xmalloc_read",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nchar *__cdecl t_tob64(char *dst, const unsigned __int8 *src, int size)\n{\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  int v7; // eax\n  char *dsta; // [rsp+Ch] [rbp-28h]\n  int c; // [rsp+20h] [rbp-14h]\n  int ca; // [rsp+20h] [rbp-14h]\n  unsigned __int8 notleading; // [rsp+2Ch] [rbp-8h]\n  unsigned __int8 b2; // [rsp+2Dh] [rbp-7h]\n  unsigned __int8 b1; // [rsp+2Eh] [rbp-6h]\n  unsigned __int8 b0; // [rsp+2Fh] [rbp-5h]\n  int pos; // [rsp+30h] [rbp-4h]\n\n  dsta = dst;\n  pos = size % 3;\n  b0 = 0;\n  b1 = 0;\n  b2 = 0;\n  notleading = 0;\n  if ( size % 3 == 1 )\n  {\n    b2 = *src;\n  }\n  else if ( pos == 2 )\n  {\n    b1 = *src;\n    b2 = src[1];\n  }\n  while ( 1 )\n  {\n    if ( notleading || b0 >> 2 )\n    {\n      v3 = dsta++;\n      *v3 = b64table[b0 >> 2];\n      notleading = 1;\n    }\n    c = (16 * b0) & 0x30 | (b1 >> 4);\n    if ( notleading || c )\n    {\n      v4 = dsta++;\n      *v4 = b64table[c];\n      notleading = 1;\n    }\n    ca = (4 * b1) & 0x3C | (b2 >> 6);\n    if ( notleading || ca )\n    {\n      v5 = dsta++;\n      *v5 = b64table[ca];\n      notleading = 1;\n    }\n    if ( notleading || (b2 & 0x3F) != 0 )\n    {\n      v6 = dsta++;\n      *v6 = b64table[b2 & 0x3F];\n      notleading = 1;\n    }\n    if ( pos >= size )\n      break;\n    b0 = src[pos];\n    b1 = src[pos + 1];\n    v7 = pos + 2;\n    pos += 3;\n    b2 = src[v7];\n  }\n  *dsta = 0;\n  return dst;\n}\n\n\n Revised code:\nstatic char *t_tob64(char *dst, const unsigned char *src, int size)\n{\n    int c, pos = size % 3;\n    unsigned char b0 = 0, b1 = 0, b2 = 0, notleading = 0;\n    char *olddst = dst;\n\n    switch (pos) {\n    case 1:\n        b2 = src[0];\n        break;\n    case 2:\n        b1 = src[0];\n        b2 = src[1];\n        break;\n    }\n\n    while (1) {\n        c = (b0 & 0xfc) >> 2;\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = ((b0 & 3) << 4) | ((b1 & 0xf0) >> 4);\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = ((b1 & 0xf) << 2) | ((b2 & 0xc0) >> 6);\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = b2 & 0x3f;\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        if (pos >= size)\n            break;\n        else {\n            b0 = src[pos++];\n            b1 = src[pos++];\n            b2 = src[pos++];\n        }\n    }\n\n    *dst++ = '\\0';\n    return olddst;\n}\n\n## Example:\n\n Input code:\nint __cdecl t_fromb64(unsigned __int8 *a, const char *src)\n{\n  int v2; // eax\n  unsigned __int8 *v3; // rcx\n  int v4; // eax\n  char *loc; // [rsp+18h] [rbp-18h]\n  int size; // [rsp+24h] [rbp-Ch]\n  int sizea; // [rsp+24h] [rbp-Ch]\n  int j; // [rsp+28h] [rbp-8h]\n  int i; // [rsp+2Ch] [rbp-4h]\n  int ia; // [rsp+2Ch] [rbp-4h]\n  int ib; // [rsp+2Ch] [rbp-4h]\n  int ic; // [rsp+2Ch] [rbp-4h]\n  int id; // [rsp+2Ch] [rbp-4h]\n  int ie; // [rsp+2Ch] [rbp-4h]\n\n  while ( *src && (*src == 32 || *src == 9 || *src == 10) )\n    ++src;\n  size = strlen(src);\n  for ( i = 0; i < size; ++i )\n  {\n    loc = strchr(b64table, src[i]);\n    if ( !loc )\n      break;\n    a[i] = loc - b64table;\n  }\n  sizea = i;\n  ia = i - 1;\n  j = sizea;\n  do\n  {\n    a[j] = a[ia];\n    ib = ia - 1;\n    if ( ib < 0 )\n      break;\n    a[j--] |= a[ib] << 6;\n    a[j] = ((int)a[ib] >> 2) & 0xF;\n    ic = ib - 1;\n    if ( ic < 0 )\n      break;\n    a[j--] |= 16 * a[ic];\n    a[j] = ((int)a[ic] >> 4) & 3;\n    id = ic - 1;\n    if ( id < 0 )\n      break;\n    a[j--] |= 4 * a[id];\n    a[j] = 0;\n    ia = id - 1;\n  }\n  while ( ia >= 0 );\n  while ( !a[j] && j <= sizea )\n    ++j;\n  ie = 0;\n  while ( j <= sizea )\n  {\n    v2 = j++;\n    v3 = &a[v2];\n    v4 = ie++;\n    a[v4] = *v3;\n  }\n  return ie;\n}\n\n\n Revised code:\nstatic int t_fromb64(unsigned char *a, const char *src)\n{\n    char *loc;\n    int i, j;\n    int size;\n\n    while (*src && (*src == ' ' || *src == '\\t' || *src == '\\n'))\n        ++src;\n    size = strlen(src);\n    i = 0;\n    while (i < size) {\n        loc = strchr(b64table, src[i]);\n        if (loc == (char *)0)\n            break;\n        else\n            a[i] = loc - b64table;\n        ++i;\n    }\n    /* if nothing valid to process we have a zero length response */\n    if (i == 0)\n        return 0;\n    size = i;\n    i = size - 1;\n    j = size;\n    while (1) {\n        a[j] = a[i];\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] & 3) << 6;\n        --j;\n        a[j] = (unsigned char)((a[i] & 0x3c) >> 2);\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] & 0xf) << 4;\n        --j;\n        a[j] = (unsigned char)((a[i] & 0x30) >> 4);\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] << 2);\n\n        a[--j] = 0;\n        if (--i < 0)\n            break;\n    }\n    while (a[j] == 0 && j <= size)\n        ++j;\n    i = 0;\n    while (j <= size)\n        a[i++] = a[j++];\n    return i;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_507264(int a1, unsigned __int64 *a2)\n{\n  unsigned __int64 v2; // rax\n  struct stat64 stat_buf; // [rsp+10h] [rbp-C0h] BYREF\n  unsigned __int64 v5; // [rsp+A8h] [rbp-28h]\n  unsigned __int64 v6; // [rsp+B0h] [rbp-20h]\n  unsigned __int64 v7; // [rsp+B8h] [rbp-18h]\n  size_t v8; // [rsp+C0h] [rbp-10h]\n  void *ptr; // [rsp+C8h] [rbp-8h]\n\n  if ( a2 )\n    v2 = *a2;\n  else\n    v2 = 2147479552LL;\n  v6 = v2;\n  stat_buf.st_size = 0LL;\n  sub_407E00(a1, &stat_buf);\n  v8 = (stat_buf.st_size | 0x3FF) + 1;\n  v7 = 0LL;\n  ptr = 0LL;\n  while ( 1 )\n  {\n    if ( v6 < v8 )\n      v8 = v6;\n    ptr = sub_40A09E(ptr, v7 + v8 + 1);\n    v5 = sub_40B446(a1, (char *)ptr + v7, v8);\n    if ( v5 == -1LL )\n    {\n      free(ptr);\n      return 0LL;\n    }\n    v7 += v5;\n    if ( v5 < v8 || v6 <= v5 )\n      break;\n    v6 -= v5;\n    v8 = ((v7 >> 3) | 0x3FF) + 1;\n    if ( v8 > 0x10000 )\n      v8 = 0x10000LL;\n  }\n  ptr = sub_40A09E(ptr, v7 + 1);\n  *((_BYTE *)ptr + v7) = 0;\n  if ( a2 )\n    *a2 = v7;\n  return ptr;\n}\n",
        "output": "```c\nvoid *read_file_to_buffer(int file_descriptor, unsigned __int64 *size_ptr)\n{\n    struct stat64 stat_buf;\n    unsigned __int64 max_size, read_size, total_read, buffer_size;\n    void *buffer;\n\n    // Determine the maximum size to read\n    max_size = (size_ptr != NULL) ? *size_ptr : 2147479552ULL;\n\n    // Get file statistics\n    stat_buf.st_size = 0LL;\n    fstat64(file_descriptor, &stat_buf);\n\n    // Calculate initial buffer size\n    buffer_size = (stat_buf.st_size | 0x3FF) + 1;\n    total_read = 0LL;\n    buffer = NULL;\n\n    while (1)\n    {\n        // Adjust buffer size if it exceeds max_size\n        if (max_size < buffer_size)\n            buffer_size = max_size;\n\n        // Allocate or resize buffer\n        buffer = realloc(buffer, total_read + buffer_size + 1);\n\n        // Read data into buffer\n        read_size = read(file_descriptor, (char *)buffer + total_read, buffer_size);\n        if (read_size == (size_t)-1)\n        {\n            // Read error, free buffer and return NULL\n            free(buffer);\n            return NULL;\n        }\n\n        // Update total bytes read\n        total_read += read_size;\n\n        // Check if read operation is complete\n        if (read_size < buffer_size || max_size <= read_size)\n            break;\n\n        // Calculate remaining size and adjust buffer_size for next read\n        max_size -= read_size;\n        buffer_size = ((total_read >> 3) | 0x3FF) + 1;\n        if (buffer_size > 0x10000)\n            buffer_size = 0x10000ULL;\n    }\n\n    // Finalize buffer\n    buffer = realloc(buffer, total_read + 1);\n    *((char *)buffer + total_read) = 0; // Null-terminate the buffer\n\n    // Update size if size_ptr is provided\n    if (size_ptr)\n        *size_ptr = total_read;\n\n    return buffer;\n}\n```",
        "source_code": "FAST_FUNC xmalloc_read(int fd, size_t *maxsz_p)\n{\n\tchar *buf;\n\tsize_t size, rd_size, total;\n\tsize_t to_read;\n\tstruct stat st;\n\n\tto_read = maxsz_p ? *maxsz_p : (INT_MAX - 4095); /* max to read */\n\n\t/* Estimate file size */\n\tst.st_size = 0; /* in case fstat fails, assume 0 */\n\tfstat(fd, &st);\n\t/* /proc/N/stat files report st_size 0 */\n\t/* In order to make such files readable, we add small const */\n\tsize = (st.st_size | 0x3ff) + 1;\n\n\ttotal = 0;\n\tbuf = NULL;\n\twhile (1) {\n\t\tif (to_read < size)\n\t\t\tsize = to_read;\n\t\tbuf = xrealloc(buf, total + size + 1);\n\t\trd_size = full_read(fd, buf + total, size);\n\t\tif ((ssize_t)rd_size == (ssize_t)(-1)) { /* error */\n\t\t\tfree(buf);\n\t\t\treturn NULL;\n\t\t}\n\t\ttotal += rd_size;\n\t\tif (rd_size < size) /* EOF */\n\t\t\tbreak;\n\t\tif (to_read <= rd_size)\n\t\t\tbreak;\n\t\tto_read -= rd_size;\n\t\t/* grow by 1/8, but in [1k..64k] bounds */\n\t\tsize = ((total / 8) | 0x3ff) + 1;\n\t\tif (size > 64*1024)\n\t\t\tsize = 64*1024;\n\t}\n\tbuf = xrealloc(buf, total + 1);\n\tbuf[total] = '\\0';\n\n\tif (maxsz_p)\n\t\t*maxsz_p = total;\n\treturn buf;\n}",
        "parsed_output": "void *read_file_to_buffer(int file_descriptor, unsigned __int64 *size_ptr)\n{\n    struct stat64 stat_buf;\n    unsigned __int64 max_size, read_size, total_read, buffer_size;\n    void *buffer;\n\n    // Determine the maximum size to read\n    max_size = (size_ptr != NULL) ? *size_ptr : 2147479552ULL;\n\n    // Get file statistics\n    stat_buf.st_size = 0LL;\n    fstat64(file_descriptor, &stat_buf);\n\n    // Calculate initial buffer size\n    buffer_size = (stat_buf.st_size | 0x3FF) + 1;\n    total_read = 0LL;\n    buffer = NULL;\n\n    while (1)\n    {\n        // Adjust buffer size if it exceeds max_size\n        if (max_size < buffer_size)\n            buffer_size = max_size;\n\n        // Allocate or resize buffer\n        buffer = realloc(buffer, total_read + buffer_size + 1);\n\n        // Read data into buffer\n        read_size = read(file_descriptor, (char *)buffer + total_read, buffer_size);\n        if (read_size == (size_t)-1)\n        {\n            // Read error, free buffer and return NULL\n            free(buffer);\n            return NULL;\n        }\n\n        // Update total bytes read\n        total_read += read_size;\n\n        // Check if read operation is complete\n        if (read_size < buffer_size || max_size <= read_size)\n            break;\n\n        // Calculate remaining size and adjust buffer_size for next read\n        max_size -= read_size;\n        buffer_size = ((total_read >> 3) | 0x3FF) + 1;\n        if (buffer_size > 0x10000)\n            buffer_size = 0x10000ULL;\n    }\n\n    // Finalize buffer\n    buffer = realloc(buffer, total_read + 1);\n    *((char *)buffer + total_read) = 0; // Null-terminate the buffer\n\n    // Update size if size_ptr is provided\n    if (size_ptr)\n        *size_ptr = total_read;\n\n    return buffer;\n}",
        "baseline_code_stripped": "void *__fastcall sub_507264(int a1, unsigned __int64 *a2)\n{\n  unsigned __int64 v2; // rax\n  struct stat64 stat_buf; // [rsp+10h] [rbp-C0h] BYREF\n  unsigned __int64 v5; // [rsp+A8h] [rbp-28h]\n  unsigned __int64 v6; // [rsp+B0h] [rbp-20h]\n  unsigned __int64 v7; // [rsp+B8h] [rbp-18h]\n  size_t v8; // [rsp+C0h] [rbp-10h]\n  void *ptr; // [rsp+C8h] [rbp-8h]\n\n  if ( a2 )\n    v2 = *a2;\n  else\n    v2 = 2147479552LL;\n  v6 = v2;\n  stat_buf.st_size = 0LL;\n  sub_407E00(a1, &stat_buf);\n  v8 = (stat_buf.st_size | 0x3FF) + 1;\n  v7 = 0LL;\n  ptr = 0LL;\n  while ( 1 )\n  {\n    if ( v6 < v8 )\n      v8 = v6;\n    ptr = sub_40A09E(ptr, v7 + v8 + 1);\n    v5 = sub_40B446(a1, (char *)ptr + v7, v8);\n    if ( v5 == -1LL )\n    {\n      free(ptr);\n      return 0LL;\n    }\n    v7 += v5;\n    if ( v5 < v8 || v6 <= v5 )\n      break;\n    v6 -= v5;\n    v8 = ((v7 >> 3) | 0x3FF) + 1;\n    if ( v8 > 0x10000 )\n      v8 = 0x10000LL;\n  }\n  ptr = sub_40A09E(ptr, v7 + 1);\n  *((_BYTE *)ptr + v7) = 0;\n  if ( a2 )\n    *a2 = v7;\n  return ptr;\n}\n",
        "baseline_code_debug": "void *__cdecl xmalloc_read(int fd, size_t *maxsz_p)\n{\n  size_t v2; // rax\n  stat st; // [rsp+10h] [rbp-C0h] BYREF\n  size_t rd_size; // [rsp+A8h] [rbp-28h]\n  size_t to_read; // [rsp+B0h] [rbp-20h]\n  size_t total; // [rsp+B8h] [rbp-18h]\n  size_t size; // [rsp+C0h] [rbp-10h]\n  char *buf; // [rsp+C8h] [rbp-8h]\n\n  if ( maxsz_p )\n    v2 = *maxsz_p;\n  else\n    v2 = 2147479552LL;\n  to_read = v2;\n  st.st_size = 0LL;\n  fstat64(fd, (stat64 *)&st);\n  size = (st.st_size | 0x3FF) + 1;\n  total = 0LL;\n  buf = 0LL;\n  while ( 1 )\n  {\n    if ( to_read < size )\n      size = to_read;\n    buf = (char *)xrealloc(buf, total + size + 1);\n    rd_size = full_read(fd, &buf[total], size);\n    if ( rd_size == -1LL )\n    {\n      free(buf);\n      return 0LL;\n    }\n    total += rd_size;\n    if ( rd_size < size || to_read <= rd_size )\n      break;\n    to_read -= rd_size;\n    size = ((total >> 3) | 0x3FF) + 1;\n    if ( size > 0x10000 )\n      size = 0x10000LL;\n  }\n  buf = (char *)xrealloc(buf, total + 1);\n  buf[total] = 0;\n  if ( maxsz_p )\n    *maxsz_p = total;\n  return buf;\n}\n",
        "similarity_score_unixcoder": 0.8498529195785522,
        "similarity_score_baseline_stripped": 0.6092948913574219,
        "similarity_score_baseline_debug": 0.8989573121070862
    },
    {
        "func_name": "runsv",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\n__int64 __cdecl fd_ctrl(BIO *b, int cmd, __int64 num, void *ptr)\n{\n  __int64 numa; // [rsp+8h] [rbp-28h]\n  __int64 ret; // [rsp+28h] [rbp-8h]\n\n  numa = num;\n  ret = 1LL;\n  if ( cmd <= 12 )\n  {\n    if ( cmd >= 11 )\n      return 1LL;\n    if ( cmd == 8 )\n      return b->shutdown;\n    if ( cmd <= 8 )\n    {\n      if ( cmd != 1 )\n      {\n        if ( cmd != 3 )\n          return 0LL;\n        return lseek(b->num, 0LL, 1);\n      }\n      numa = 0LL;\n      return lseek(b->num, numa, 0);\n    }\n    if ( cmd == 9 )\n    {\n      b->shutdown = num;\n      return ret;\n    }\n    return 0LL;\n  }\n  if ( cmd == 105 )\n  {\n    if ( b->init )\n    {\n      if ( ptr )\n        *(_DWORD *)ptr = b->num;\n      return b->num;\n    }\n    else\n    {\n      return -1LL;\n    }\n  }\n  else\n  {\n    if ( cmd > 105 )\n    {\n      if ( cmd != 128 )\n      {\n        if ( cmd != 133 )\n          return 0LL;\n        return lseek(b->num, 0LL, 1);\n      }\n      return lseek(b->num, numa, 0);\n    }\n    if ( cmd == 13 )\n      return 0LL;\n    if ( cmd != 104 )\n      return 0LL;\n    fd_free(b);\n    b->num = *(_DWORD *)ptr;\n    b->shutdown = numa;\n    b->init = 1;\n  }\n  return ret;\n}\n\n\n Revised code:\nstatic long fd_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    long ret = 1;\n    int *ip;\n\n    switch (cmd) {\n    case BIO_CTRL_RESET:\n        num = 0;\n    case BIO_C_FILE_SEEK:\n        ret = (long)UP_lseek(b->num, num, 0);\n        break;\n    case BIO_C_FILE_TELL:\n    case BIO_CTRL_INFO:\n        ret = (long)UP_lseek(b->num, 0, 1);\n        break;\n    case BIO_C_SET_FD:\n        fd_free(b);\n        b->num = *((int *)ptr);\n        b->shutdown = (int)num;\n        b->init = 1;\n        break;\n    case BIO_C_GET_FD:\n        if (b->init) {\n            ip = (int *)ptr;\n            if (ip != NULL)\n                *ip = b->num;\n            ret = b->num;\n        } else\n            ret = -1;\n        break;\n    case BIO_CTRL_GET_CLOSE:\n        ret = b->shutdown;\n        break;\n    case BIO_CTRL_SET_CLOSE:\n        b->shutdown = (int)num;\n        break;\n    case BIO_CTRL_PENDING:\n    case BIO_CTRL_WPENDING:\n        ret = 0;\n        break;\n    case BIO_CTRL_DUP:\n    case BIO_CTRL_FLUSH:\n        ret = 1;\n        break;\n    default:\n        ret = 0;\n        break;\n    }\n    return (ret);\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_469B3D(__int64 a1)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  unsigned int v10; // [rsp+1Ch] [rbp-4h]\n\n  if ( byte_75D468 )\n    return 0LL;\n  v10 = vfork();\n  if ( v10 == -1 )\n  {\n    sub_469B15((__int64)\"vfork\", (__int64)&unk_53632F, v2, v3, v4, v5);\n    return 0LL;\n  }\n  else\n  {\n    if ( !v10 )\n    {\n      if ( (dword_75D450 & 1) != 0 )\n        setsid();\n      execlp(\"runsv\", \"runsv\", a1, 0LL);\n      sub_469AA1((__int64)\"start runsv \", a1, v6, v7, v8, v9);\n    }\n    return v10;\n  }\n}\n",
        "output": "```c\npid_t sub_469B3D(const char *a1)\n{\n    pid_t pid;\n\n    if (byte_75D468)\n        return 0;\n\n    pid = vfork();\n    if (pid == -1)\n    {\n        sub_469B15(\"vfork\", &unk_53632F);\n        return 0;\n    }\n    else\n    {\n        if (pid == 0) // Child process\n        {\n            if (dword_75D450 & 1)\n                setsid();\n            execlp(\"runsv\", \"runsv\", a1, NULL);\n            sub_469AA1(\"start runsv \", a1);\n            _exit(1); // If execlp fails, exit child process with error code\n        }\n        return pid; // Parent process returns the PID of the child\n    }\n}\n```",
        "source_code": "static NOINLINE pid_t runsv(const char *name)\n{\n\tpid_t pid;\n\n\t/* If we got signaled, stop spawning children at once! */\n\tif (bb_got_signal)\n\t\treturn 0;\n\n\tpid = vfork();\n\tif (pid == -1) {\n\t\twarn2_cannot(\"vfork\", \"\");\n\t\treturn 0;\n\t}\n\tif (pid == 0) {\n\t\t/* child */\n\t\tif (option_mask32 & 1) /* -P option? */\n\t\t\tsetsid();\n/* man execv:\n * \"Signals set to be caught by the calling process image\n *  shall be set to the default action in the new process image.\"\n * Therefore, we do not need this: */\n#if 0\n\t\tbb_signals(0\n\t\t\t| (1 << SIGHUP)\n\t\t\t| (1 << SIGTERM)\n\t\t\t, SIG_DFL);\n#endif\n\t\texeclp(\"runsv\", \"runsv\", name, (char *) NULL);\n\t\tfatal2_cannot(\"start runsv \", name);\n\t}\n\treturn pid;\n}",
        "parsed_output": "pid_t sub_469B3D(const char *a1)\n{\n    pid_t pid;\n\n    if (byte_75D468)\n        return 0;\n\n    pid = vfork();\n    if (pid == -1)\n    {\n        sub_469B15(\"vfork\", &unk_53632F);\n        return 0;\n    }\n    else\n    {\n        if (pid == 0) // Child process\n        {\n            if (dword_75D450 & 1)\n                setsid();\n            execlp(\"runsv\", \"runsv\", a1, NULL);\n            sub_469AA1(\"start runsv \", a1);\n            _exit(1); // If execlp fails, exit child process with error code\n        }\n        return pid; // Parent process returns the PID of the child\n    }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_469B3D(__int64 a1)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  unsigned int v10; // [rsp+1Ch] [rbp-4h]\n\n  if ( byte_75D468 )\n    return 0LL;\n  v10 = vfork();\n  if ( v10 == -1 )\n  {\n    sub_469B15((__int64)\"vfork\", (__int64)&unk_53632F, v2, v3, v4, v5);\n    return 0LL;\n  }\n  else\n  {\n    if ( !v10 )\n    {\n      if ( (dword_75D450 & 1) != 0 )\n        setsid();\n      execlp(\"runsv\", \"runsv\", a1, 0LL);\n      sub_469AA1((__int64)\"start runsv \", a1, v6, v7, v8, v9);\n    }\n    return v10;\n  }\n}\n",
        "baseline_code_debug": "pid_t __cdecl runsv(const char *name)\n{\n  __pid_t pid; // [rsp+1Ch] [rbp-4h]\n\n  if ( bb_got_signal[0] )\n    return 0;\n  pid = vfork();\n  if ( pid == -1 )\n  {\n    warn2_cannot(\"vfork\", &byte_53632F);\n    return 0;\n  }\n  else\n  {\n    if ( !pid )\n    {\n      if ( (option_mask32 & 1) != 0 )\n        setsid();\n      execlp(\"runsv\", \"runsv\", name, 0LL);\n      fatal2_cannot_0(\"start runsv \", name);\n    }\n    return pid;\n  }\n}\n",
        "similarity_score_unixcoder": 0.8621852993965149,
        "similarity_score_baseline_stripped": 0.6746228933334351,
        "similarity_score_baseline_debug": 0.8853020668029785
    },
    {
        "func_name": "port_name",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl get_ip(const char *str, unsigned __int8 *ip_0)\n{\n  const char *v2; // rax\n  unsigned int tmp[4]; // [rsp+10h] [rbp-20h]\n  int c; // [rsp+24h] [rbp-Ch]\n  int ok; // [rsp+28h] [rbp-8h]\n  int num; // [rsp+2Ch] [rbp-4h]\n\n  num = 0;\n  ok = 0;\n  tmp[3] = 0;\n  tmp[2] = 0;\n  tmp[1] = 0;\n  tmp[0] = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v2 = str++;\n      c = *v2;\n      if ( c <= 47 || c > 57 )\n        break;\n      ok = 1;\n      tmp[num] = 10 * tmp[num] + c - 48;\n      if ( tmp[num] > 0xFF )\n        return 0;\n    }\n    if ( c != 46 )\n      break;\n    if ( !ok )\n      return -1;\n    if ( num == 3 )\n      return 0;\n    ++num;\n    ok = 0;\n  }\n  if ( c || num != 3 || !ok )\n    return 0;\n  *ip_0 = tmp[0];\n  ip_0[1] = tmp[1];\n  ip_0[2] = tmp[2];\n  ip_0[3] = tmp[3];\n  return 1;\n}\n\n\n Revised code:\nstatic int get_ip(const char *str, unsigned char ip[4])\n{\n    unsigned int tmp[4];\n    int num = 0, c, ok = 0;\n\n    tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;\n\n    for (;;) {\n        c = *(str++);\n        if ((c >= '0') && (c <= '9')) {\n            ok = 1;\n            tmp[num] = tmp[num] * 10 + c - '0';\n            if (tmp[num] > 255)\n                return (0);\n        } else if (c == '.') {\n            if (!ok)\n                return (-1);\n            if (num == 3)\n                return (0);\n            num++;\n            ok = 0;\n        } else if (c == '\\0' && (num == 3) && ok)\n            break;\n        else\n            return (0);\n    }\n    ip[0] = tmp[0];\n    ip[1] = tmp[1];\n    ip[2] = tmp[2];\n    ip[3] = tmp[3];\n    return (1);\n}\n\n## Example:\n\n Input code:\nconst char *__cdecl ASN1_tag2str(int tag)\n{\n  unsigned int taga; // [rsp+0h] [rbp-4h]\n\n  taga = tag;\n  if ( tag == 258 || tag == 266 )\n    taga = tag & 0xFFFFFEFF;\n  if ( taga < 0x1F )\n    return tag2str_6982[taga];\n  else\n    return \"(unknown)\";\n}\n\n\n Revised code:\nconst char *ASN1_tag2str(int tag)\n{\n    static const char *const tag2str[] = {\n        /* 0-4 */\n        \"EOC\", \"BOOLEAN\", \"INTEGER\", \"BIT STRING\", \"OCTET STRING\",\n        /* 5-9 */\n        \"NULL\", \"OBJECT\", \"OBJECT DESCRIPTOR\", \"EXTERNAL\", \"REAL\",\n        /* 10-13 */\n        \"ENUMERATED\", \"<ASN1 11>\", \"UTF8STRING\", \"<ASN1 13>\",\n        /* 15-17 */\n        \"<ASN1 14>\", \"<ASN1 15>\", \"SEQUENCE\", \"SET\",\n        /* 18-20 */\n        \"NUMERICSTRING\", \"PRINTABLESTRING\", \"T61STRING\",\n        /* 21-24 */\n        \"VIDEOTEXSTRING\", \"IA5STRING\", \"UTCTIME\", \"GENERALIZEDTIME\",\n        /* 25-27 */\n        \"GRAPHICSTRING\", \"VISIBLESTRING\", \"GENERALSTRING\",\n        /* 28-30 */\n        \"UNIVERSALSTRING\", \"<ASN1 29>\", \"BMPSTRING\"\n    };\n\n    if ((tag == V_ASN1_NEG_INTEGER) || (tag == V_ASN1_NEG_ENUMERATED))\n        tag &= ~0x100;\n\n    if (tag < 0 || tag > 30)\n        return \"(unknown)\";\n    return tag2str[tag];\n}\n\n## Example:\n\n Input code:\nvoid __cdecl pushsig()\n{\n  sigaction sa; // [rsp+0h] [rbp-A0h] BYREF\n  int i; // [rsp+9Ch] [rbp-4h]\n\n  memset(&sa, 0, sizeof(sa));\n  sa.sa_handler = (__sighandler_t)recsig;\n  for ( i = 1; i <= 31; ++i )\n  {\n    if ( i != 10 && i != 12 && i != 9 )\n      sigaction(i, &sa, &savsig[i]);\n  }\n  signal(28, 0LL);\n}\n\n\n Revised code:\nstatic void pushsig(void)\n{\n    int i;\n# ifdef SIGACTION\n    struct sigaction sa;\n\n    memset(&sa, 0, sizeof sa);\n    sa.sa_handler = recsig;\n# endif\n\n    for (i = 1; i < NX509_SIG; i++) {\n# ifdef SIGUSR1\n        if (i == SIGUSR1)\n            continue;\n# endif\n# ifdef SIGUSR2\n        if (i == SIGUSR2)\n            continue;\n# endif\n# ifdef SIGACTION\n        sigaction(i, &sa, &savsig[i]);\n# else\n        savsig[i] = signal(i, recsig);\n# endif\n    }\n\n# ifdef SIGWINCH\n    signal(SIGWINCH, SIG_DFL);\n# endif\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_43F254(uint16_t a1)\n{\n  uint16_t v1; // ax\n  struct servent *v3; // [rsp+18h] [rbp-8h]\n\n  v1 = htons(a1);\n  v3 = getservbyport(v1, 0LL);\n  if ( v3 )\n    return v3->s_name;\n  else\n    return \"unknown\";\n}\n",
        "output": "const char *get_service_name_by_port(uint16_t port)\n{\n    struct servent *service_entry;\n\n    port = htons(port);\n    service_entry = getservbyport(port, NULL);\n    if (service_entry)\n        return service_entry->s_name;\n    else\n        return \"unknown\";\n}",
        "source_code": "endif\n\nstatic const char *port_name(unsigned port)\n{\n\tstruct servent *server;\n\n\tserver = getservbyport(htons(port), NULL);\n\tif (server)\n\t\treturn server->s_name;\n\treturn \"unknown\";\n}",
        "parsed_output": "const char *get_service_name_by_port(uint16_t port)\n{\n    struct servent *service_entry;\n\n    port = htons(port);\n    service_entry = getservbyport(port, NULL);\n    if (service_entry)\n        return service_entry->s_name;\n    else\n        return \"unknown\";\n}",
        "baseline_code_stripped": "const char *__fastcall sub_43F254(uint16_t a1)\n{\n  uint16_t v1; // ax\n  struct servent *v3; // [rsp+18h] [rbp-8h]\n\n  v1 = htons(a1);\n  v3 = getservbyport(v1, 0LL);\n  if ( v3 )\n    return v3->s_name;\n  else\n    return \"unknown\";\n}\n",
        "baseline_code_debug": "const char *__cdecl port_name(unsigned int port)\n{\n  uint16_t v1; // ax\n  struct servent *server; // [rsp+18h] [rbp-8h]\n\n  v1 = htons(port);\n  server = getservbyport(v1, 0LL);\n  if ( server )\n    return server->s_name;\n  else\n    return \"unknown\";\n}\n",
        "similarity_score_unixcoder": 0.8517045974731445,
        "similarity_score_baseline_stripped": 0.6130740642547607,
        "similarity_score_baseline_debug": 0.801088809967041
    },
    {
        "func_name": "uid2uname_utoa",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\n__int64 __cdecl roundv(double value)\n{\n  __int64 intpart; // [rsp+10h] [rbp-8h]\n\n  intpart = (unsigned int)(int)value;\n  if ( value - (double)(int)value >= 0.5 )\n    ++intpart;\n  return intpart;\n}\n\n\n Revised code:\nstatic long roundv(LDOUBLE value)\n{\n    long intpart;\n    intpart = (long)value;\n    value = value - intpart;\n    if (value >= 0.5)\n        intpart++;\n    return intpart;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_4F6415(unsigned int a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_4F63B5(a1, a2);\n  if ( v3 )\n    return (_BYTE *)v3;\n  else\n    return sub_409B63(a1);\n}\n",
        "output": "```c\nunsigned char *sub_4F6415(unsigned int a1, __int64 a2)\n{\n    __int64 result = sub_4F63B5(a1, a2);\n    if (result)\n        return (unsigned char *)result;\n    else\n        return sub_409B63(a1);\n}\n```",
        "source_code": "FAST_FUNC uid2uname_utoa(uid_t uid)\n{\n\tchar *name = uid2uname(uid);\n\treturn (name) ? name : utoa(uid);\n}",
        "parsed_output": "unsigned char *sub_4F6415(unsigned int a1, __int64 a2)\n{\n    __int64 result = sub_4F63B5(a1, a2);\n    if (result)\n        return (unsigned char *)result;\n    else\n        return sub_409B63(a1);\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_4F6415(unsigned int a1, __int64 a2)\n{\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_4F63B5(a1, a2);\n  if ( v3 )\n    return (_BYTE *)v3;\n  else\n    return sub_409B63(a1);\n}\n",
        "baseline_code_debug": "char *__cdecl uid2uname_utoa(uid_t uid)\n{\n  char *name; // [rsp+18h] [rbp-8h]\n\n  name = uid2uname(uid);\n  if ( name )\n    return name;\n  else\n    return utoa(uid);\n}\n",
        "similarity_score_unixcoder": 0.44866248965263367,
        "similarity_score_baseline_stripped": 0.3769398629665375,
        "similarity_score_baseline_debug": 0.8265640735626221
    },
    {
        "func_name": "ptok",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __cdecl ASN1_INTEGER_get(const ASN1_INTEGER *a)\n{\n  __int64 r; // [rsp+8h] [rbp-10h]\n  int i; // [rsp+10h] [rbp-8h]\n  int ia; // [rsp+10h] [rbp-8h]\n  int neg; // [rsp+14h] [rbp-4h]\n\n  neg = 0;\n  r = 0LL;\n  if ( !a )\n    return 0LL;\n  i = a->type;\n  if ( i == 258 )\n  {\n    neg = 1;\n  }\n  else if ( i != 2 )\n  {\n    return -1LL;\n  }\n  if ( a->length > 8 )\n    return -1LL;\n  if ( !a->data )\n    return 0LL;\n  for ( ia = 0; ia < a->length; ++ia )\n    r = a->data[ia] | (unsigned __int64)(r << 8);\n  if ( neg )\n    return -r;\n  return r;\n}\n\n\n Revised code:\nlong ASN1_INTEGER_get(const ASN1_INTEGER *a)\n{\n    int neg = 0, i;\n    long r = 0;\n\n    if (a == NULL)\n        return (0L);\n    i = a->type;\n    if (i == V_ASN1_NEG_INTEGER)\n        neg = 1;\n    else if (i != V_ASN1_INTEGER)\n        return -1;\n\n    if (a->length > (int)sizeof(long)) {\n        /* hmm... a bit ugly, return all ones */\n        return -1;\n    }\n    if (a->data == NULL)\n        return 0;\n\n    for (i = 0; i < a->length; i++) {\n        r <<= 8;\n        r |= (unsigned char)a->data[i];\n    }\n    if (neg)\n        r = -r;\n    return (r);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl bn_sqr_words(unsigned __int64 *r, const unsigned __int64 *a, int n)\n{\n  int na; // [rsp+0h] [rbp-44h]\n\n  na = n;\n  if ( n > 0 )\n  {\n    while ( (na & 0xFFFFFFFC) != 0 )\n    {\n      *(_OWORD *)r = *a * (unsigned __int128)*a;\n      *((_OWORD *)r + 1) = a[1] * (unsigned __int128)a[1];\n      *((_OWORD *)r + 2) = a[2] * (unsigned __int128)a[2];\n      *((_OWORD *)r + 3) = a[3] * (unsigned __int128)a[3];\n      a += 4;\n      r += 8;\n      na -= 4;\n    }\n    while ( na )\n    {\n      *(_OWORD *)r = *a * (unsigned __int128)*a;\n      ++a;\n      r += 2;\n      --na;\n    }\n  }\n}\n\n\n Revised code:\nvoid bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)\n{\n    assert(n >= 0);\n    if (n <= 0)\n        return;\n\n# ifndef OPENSSL_SMALL_FOOTPRINT\n    while (n & ~3) {\n        sqr(r[0], r[1], a[0]);\n        sqr(r[2], r[3], a[1]);\n        sqr(r[4], r[5], a[2]);\n        sqr(r[6], r[7], a[3]);\n        a += 4;\n        r += 8;\n        n -= 4;\n    }\n# endif\n    while (n) {\n        sqr(r[0], r[1], a[0]);\n        a++;\n        r += 2;\n        n--;\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl BN_add_word(BIGNUM *a, unsigned __int64 w)\n{\n  bool v3; // al\n  unsigned __int64 wa; // [rsp+0h] [rbp-20h]\n  unsigned __int64 l; // [rsp+10h] [rbp-10h]\n  int i; // [rsp+1Ch] [rbp-4h]\n  int ia; // [rsp+1Ch] [rbp-4h]\n\n  wa = w;\n  if ( !w )\n    return 1;\n  if ( !a->top )\n    return BN_set_word(a, w);\n  if ( a->neg )\n  {\n    a->neg = 0;\n    i = BN_sub_word(a, w);\n    if ( a->top )\n      a->neg = a->neg == 0;\n    return i;\n  }\n  else\n  {\n    for ( ia = 0; wa && ia < a->top; ++ia )\n    {\n      l = a->d[ia] + wa;\n      a->d[ia] = l;\n      wa = wa > l;\n    }\n    if ( wa && ia == a->top )\n    {\n      if ( a->top < a->dmax )\n        v3 = a == 0LL;\n      else\n        v3 = bn_expand2(a, a->top + 1) == 0LL;\n      if ( v3 )\n        return 0;\n      ++a->top;\n      a->d[ia] = wa;\n    }\n    return 1;\n  }\n}\n\n\n Revised code:\nint BN_add_word(BIGNUM *a, BN_ULONG w)\n{\n    BN_ULONG l;\n    int i;\n\n    bn_check_top(a);\n    w &= BN_MASK2;\n\n    /* degenerate case: w is zero */\n    if (!w)\n        return 1;\n    /* degenerate case: a is zero */\n    if (BN_is_zero(a))\n        return BN_set_word(a, w);\n    /* handle 'a' when negative */\n    if (a->neg) {\n        a->neg = 0;\n        i = BN_sub_word(a, w);\n        if (!BN_is_zero(a))\n            a->neg = !(a->neg);\n        return (i);\n    }\n    for (i = 0; w != 0 && i < a->top; i++) {\n        a->d[i] = l = (a->d[i] + w) & BN_MASK2;\n        w = (w > l) ? 1 : 0;\n    }\n    if (w && i == a->top) {\n        if (bn_wexpand(a, a->top + 1) == NULL)\n            return 0;\n        a->top++;\n        a->d[i] = w;\n    }\n    bn_check_top(a);\n    return (1);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nunsigned __int64 __fastcall sub_422BE5(unsigned int a1, unsigned __int64 a2)\n{\n  if ( a2 <= 0x7FFFFFFFFFFFFFFFLL / a1 )\n    return (a2 * a1) >> 10;\n  else\n    return (a2 >> 10) * a1;\n}\n",
        "output": "unsigned long long multiply_and_shift(unsigned int multiplier, unsigned long long value)\n{\n    if (value <= 0x7FFFFFFFFFFFFFFFLL / multiplier)\n        return (value * multiplier) >> 10;\n    else\n        return (value >> 10) * multiplier;\n}",
        "source_code": "static unsigned long ptok(const unsigned pagesize, const unsigned long pages)\n{\n\tunsigned long tmp;\n\n\t/* Conversion.  */\n\tif (pages > (LONG_MAX / pagesize)) { /* Could overflow.  */\n\t\ttmp = pages / 1024;     /* Smaller first, */\n\t\treturn tmp * pagesize;  /* then larger.  */\n\t}\n\t/* Could underflow.  */\n\ttmp = pages * pagesize; /* Larger first, */\n\treturn tmp / 1024;      /* then smaller.  */\n}",
        "parsed_output": "unsigned long long multiply_and_shift(unsigned int multiplier, unsigned long long value)\n{\n    if (value <= 0x7FFFFFFFFFFFFFFFLL / multiplier)\n        return (value * multiplier) >> 10;\n    else\n        return (value >> 10) * multiplier;\n}",
        "baseline_code_stripped": "unsigned __int64 __fastcall sub_422BE5(unsigned int a1, unsigned __int64 a2)\n{\n  if ( a2 <= 0x7FFFFFFFFFFFFFFFLL / a1 )\n    return (a2 * a1) >> 10;\n  else\n    return (a2 >> 10) * a1;\n}\n",
        "baseline_code_debug": "unsigned __int64 __cdecl ptok(const unsigned int pagesize, const unsigned __int64 pages)\n{\n  if ( pages <= 0x7FFFFFFFFFFFFFFFLL / pagesize )\n    return (pages * pagesize) >> 10;\n  else\n    return (pages >> 10) * pagesize;\n}\n",
        "similarity_score_unixcoder": 0.6081663966178894,
        "similarity_score_baseline_stripped": 0.5574182271957397,
        "similarity_score_baseline_debug": 0.8006270527839661
    },
    {
        "func_name": "strip_unsafe_prefix",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nchar *__cdecl strip_start(char *name)\n{\n  unsigned __int8 c; // [rsp+17h] [rbp-9h]\n\n  while ( 1 )\n  {\n    c = *name;\n    if ( !*name )\n      return 0LL;\n    if ( c == 34 )\n      break;\n    if ( ((*__ctype_b_loc())[c] & 0x2000) == 0 )\n      return name;\n    ++name;\n  }\n  if ( name[1] )\n    return name + 1;\n  else\n    return 0LL;\n}\n\n\n Revised code:\nstatic char *strip_start(char *name)\n{\n    char *p, c;\n    /* Look for first non white space or quote */\n    for (p = name; (c = *p); p++) {\n        if (c == '\"') {\n            /* Next char is start of string if non null */\n            if (p[1])\n                return p + 1;\n            /* Else null string */\n            return NULL;\n        }\n        if (!isspace((unsigned char)c))\n            return p;\n    }\n    return NULL;\n}\n\n## Example:\n\n Input code:\nchar *__cdecl strip_end(char *name)\n{\n  unsigned __int8 c; // [rsp+17h] [rbp-9h]\n  char *p; // [rsp+18h] [rbp-8h]\n\n  if ( !name )\n    return 0LL;\n  for ( p = &name[strlen(name) - 1]; ; --p )\n  {\n    if ( p < name )\n      return 0LL;\n    if ( *p == 34 )\n      break;\n    c = *p;\n    if ( ((*__ctype_b_loc())[c] & 0x2000) == 0 )\n      return name;\n    *p = 0;\n  }\n  if ( name == p - 1 )\n    return 0LL;\n  *p = 0;\n  return name;\n}\n\n\n Revised code:\nstatic char *strip_end(char *name)\n{\n    char *p, c;\n    if (!name)\n        return NULL;\n    /* Look for first non white space or quote */\n    for (p = name + strlen(name) - 1; p >= name; p--) {\n        c = *p;\n        if (c == '\"') {\n            if (p - 1 == name)\n                return NULL;\n            *p = 0;\n            return name;\n        }\n        if (isspace((unsigned char)c))\n            *p = 0;\n        else\n            return name;\n    }\n    return NULL;\n}\n\n## Example:\n\n Input code:\nchar *__cdecl strip_spaces(char *name)\n{\n  char *q; // [rsp+10h] [rbp-10h]\n\n  while ( *name && ((*__ctype_b_loc())[(unsigned __int8)*name] & 0x2000) != 0 )\n    ++name;\n  if ( !*name )\n    return 0LL;\n  for ( q = &name[strlen(name) - 1]; q != name && ((*__ctype_b_loc())[(unsigned __int8)*q] & 0x2000) != 0; --q )\n    ;\n  if ( name != q )\n    q[1] = 0;\n  if ( *name )\n    return name;\n  else\n    return 0LL;\n}\n\n\n Revised code:\nstatic char *strip_spaces(char *name)\n{\n    char *p, *q;\n    /* Skip over leading spaces */\n    p = name;\n    while (*p && isspace((unsigned char)*p))\n        p++;\n    if (!*p)\n        return NULL;\n    q = p + strlen(p) - 1;\n    while ((q != p) && isspace((unsigned char)*q))\n        q--;\n    if (p != q)\n        q[1] = 0;\n    if (!*p)\n        return NULL;\n    return p;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_4C0C5F(__int64 a1)\n{\n  __int64 v1; // r8\n  __int64 v2; // r9\n  char *v4; // [rsp+10h] [rbp-10h]\n  char *s1; // [rsp+18h] [rbp-8h]\n\n  for ( s1 = (char *)a1; ; s1 = v4 + 4 )\n  {\n    while ( 1 )\n    {\n      while ( *s1 == 47 )\n        ++s1;\n      if ( strncmp(s1, \"../\", 3uLL) )\n        break;\n      s1 += 3;\n    }\n    v4 = strstr(s1, \"/../\");\n    if ( !v4 )\n      break;\n  }\n  if ( s1 != (char *)a1 && !byte_75B301 )\n  {\n    byte_75B301 = 1;\n    sub_409747(\n      \"removing leading '%.*s' from member names\",\n      (unsigned int)((_DWORD)s1 - a1),\n      a1,\n      (unsigned int)((_DWORD)s1 - a1),\n      v1,\n      v2);\n  }\n  return s1;\n}\n",
        "output": "```c\nstatic char *normalize_path(char *path)\n{\n    char *sub_path;\n    char *parent_dir;\n\n    for (sub_path = path; ; sub_path = parent_dir + 4) {\n        // Skip all leading slashes\n        while (*sub_path == '/')\n            ++sub_path;\n\n        // If not \"../\", stop processing\n        if (strncmp(sub_path, \"../\", 3) != 0)\n            break;\n\n        // Skip over \"../\"\n        sub_path += 3;\n    }\n\n    // Find the next occurrence of \"/../\"\n    parent_dir = strstr(sub_path, \"/../\");\n    while (parent_dir) {\n        sub_path = parent_dir + 4;\n        parent_dir = strstr(sub_path, \"/../\");\n    }\n\n    // If sub_path is not at the beginning and logging is not done yet\n    if (sub_path != path && !byte_75B301) {\n        byte_75B301 = 1; // Mark logging as done\n        log_normalized_path(\"removing leading '%.*s' from member names\", sub_path - path, path);\n    }\n\n    return sub_path;\n}\n```",
        "source_code": "FAST_FUNC strip_unsafe_prefix(const char *str)\n{\n\tconst char *cp = str;\n\twhile (1) {\n\t\tchar *cp2;\n\t\tif (*cp == '/') {\n\t\t\tcp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (strncmp(cp, \"/../\"+1, 3) == 0) {\n\t\t\tcp += 3;\n\t\t\tcontinue;\n\t\t}\n\t\tcp2 = strstr(cp, \"/../\");\n\t\tif (!cp2)\n\t\t\tbreak;\n\t\tcp = cp2 + 4;\n\t}\n\tif (cp != str) {\n\t\tstatic smallint warned = 0;\n\t\tif (!warned) {\n\t\t\twarned = 1;\n\t\t\tbb_error_msg(\"removing leading '%.*s' from member names\",\n\t\t\t\t(int)(cp - str), str);\n\t\t}\n\t}\n\treturn cp;\n}",
        "parsed_output": "static char *normalize_path(char *path)\n{\n    char *sub_path;\n    char *parent_dir;\n\n    for (sub_path = path; ; sub_path = parent_dir + 4) {\n        // Skip all leading slashes\n        while (*sub_path == '/')\n            ++sub_path;\n\n        // If not \"../\", stop processing\n        if (strncmp(sub_path, \"../\", 3) != 0)\n            break;\n\n        // Skip over \"../\"\n        sub_path += 3;\n    }\n\n    // Find the next occurrence of \"/../\"\n    parent_dir = strstr(sub_path, \"/../\");\n    while (parent_dir) {\n        sub_path = parent_dir + 4;\n        parent_dir = strstr(sub_path, \"/../\");\n    }\n\n    // If sub_path is not at the beginning and logging is not done yet\n    if (sub_path != path && !byte_75B301) {\n        byte_75B301 = 1; // Mark logging as done\n        log_normalized_path(\"removing leading '%.*s' from member names\", sub_path - path, path);\n    }\n\n    return sub_path;\n}",
        "baseline_code_stripped": "char *__fastcall sub_4C0C5F(__int64 a1)\n{\n  __int64 v1; // r8\n  __int64 v2; // r9\n  char *v4; // [rsp+10h] [rbp-10h]\n  char *s1; // [rsp+18h] [rbp-8h]\n\n  for ( s1 = (char *)a1; ; s1 = v4 + 4 )\n  {\n    while ( 1 )\n    {\n      while ( *s1 == 47 )\n        ++s1;\n      if ( strncmp(s1, \"../\", 3uLL) )\n        break;\n      s1 += 3;\n    }\n    v4 = strstr(s1, \"/../\");\n    if ( !v4 )\n      break;\n  }\n  if ( s1 != (char *)a1 && !byte_75B301 )\n  {\n    byte_75B301 = 1;\n    sub_409747(\n      \"removing leading '%.*s' from member names\",\n      (unsigned int)((_DWORD)s1 - a1),\n      a1,\n      (unsigned int)((_DWORD)s1 - a1),\n      v1,\n      v2);\n  }\n  return s1;\n}\n",
        "baseline_code_debug": "const char *__cdecl strip_unsafe_prefix(const char *str)\n{\n  char *cp2; // [rsp+10h] [rbp-10h]\n  const char *cp; // [rsp+18h] [rbp-8h]\n\n  for ( cp = str; ; cp = cp2 + 4 )\n  {\n    while ( 1 )\n    {\n      while ( *cp == 47 )\n        ++cp;\n      if ( strncmp(cp, \"../\", 3uLL) )\n        break;\n      cp += 3;\n    }\n    cp2 = strstr(cp, \"/../\");\n    if ( !cp2 )\n      break;\n  }\n  if ( cp != str && !warned_8303 )\n  {\n    warned_8303 = 1;\n    bb_error_msg(\"removing leading '%.*s' from member names\", (unsigned int)((_DWORD)cp - (_DWORD)str), str);\n  }\n  return cp;\n}\n",
        "similarity_score_unixcoder": 0.7006017565727234,
        "similarity_score_baseline_stripped": 0.6971070170402527,
        "similarity_score_baseline_debug": 0.8886622190475464
    },
    {
        "func_name": "ask",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nunsigned int __cdecl inverse(unsigned int xin)\n{\n  __int64 t; // [rsp+Ch] [rbp-38h]\n  __int64 q; // [rsp+14h] [rbp-30h]\n  __int64 r; // [rsp+1Ch] [rbp-28h]\n  __int64 b2; // [rsp+24h] [rbp-20h]\n  __int64 b1; // [rsp+2Ch] [rbp-18h]\n  __int64 n2; // [rsp+34h] [rbp-10h]\n  __int64 n1; // [rsp+3Ch] [rbp-8h]\n\n  if ( xin )\n  {\n    n1 = 65537LL;\n    n2 = xin;\n    b2 = 1LL;\n    b1 = 0LL;\n    do\n    {\n      r = n1 % n2;\n      q = (n1 - n1 % n2) / n2;\n      if ( n1 % n2 )\n      {\n        n1 = n2;\n        n2 = r;\n        t = b2;\n        b2 = b1 - b2 * q;\n        b1 = t;\n      }\n      else\n      {\n        b2 += b2 < 0 ? 0x10001uLL : 0;\n      }\n    }\n    while ( r );\n  }\n  else\n  {\n    LODWORD(b2) = 0;\n  }\n  return b2;\n}\n\n\n Revised code:\nstatic IDEA_INT inverse(unsigned int xin)\n{\n    long n1, n2, q, r, b1, b2, t;\n\n    if (xin == 0)\n        b2 = 0;\n    else {\n        n1 = 0x10001;\n        n2 = xin;\n        b2 = 1;\n        b1 = 0;\n\n        do {\n            r = (n1 % n2);\n            q = (n1 - r) / n2;\n            if (r == 0) {\n                if (b2 < 0)\n                    b2 = 0x10001 + b2;\n            } else {\n                n1 = n2;\n                n2 = r;\n                t = b2;\n                b2 = b1 - q * b2;\n                b1 = t;\n            }\n        } while (r != 0);\n    }\n    return ((IDEA_INT) b2);\n}\n\n## Example:\n\n Input code:\nunsigned __int8 *__cdecl string_to_hex(const char *str, __int64 *len)\n{\n  int v3; // eax\n  unsigned __int8 *v4; // rax\n  unsigned __int8 *v5; // rax\n  unsigned __int8 *v6; // rax\n  unsigned __int8 *hexbuf; // [rsp+10h] [rbp-20h]\n  unsigned __int8 *p; // [rsp+18h] [rbp-18h]\n  unsigned __int8 cl_0; // [rsp+26h] [rbp-Ah]\n  unsigned __int8 cl_0a; // [rsp+26h] [rbp-Ah]\n  unsigned __int8 ch_0; // [rsp+27h] [rbp-9h]\n  unsigned __int8 ch_0a; // [rsp+27h] [rbp-9h]\n  unsigned __int8 *q; // [rsp+28h] [rbp-8h]\n\n  if ( str )\n  {\n    v3 = strlen(str);\n    hexbuf = (unsigned __int8 *)CRYPTO_malloc(v3 >> 1, \"v3_utl.c\", 400);\n    if ( hexbuf )\n    {\n      p = (unsigned __int8 *)str;\n      q = hexbuf;\n      while ( *p )\n      {\n        v4 = p++;\n        ch_0 = *v4;\n        if ( *v4 != 58 )\n        {\n          v5 = p++;\n          cl_0 = *v5;\n          if ( !*v5 )\n          {\n            ERR_put_error(34, 113, 112, \"v3_utl.c\", 412);\n            CRYPTO_free(hexbuf);\n            return 0LL;\n          }\n          if ( ((*__ctype_b_loc())[ch_0] & 0x100) != 0 )\n            ch_0 = tolower(ch_0);\n          if ( ((*__ctype_b_loc())[cl_0] & 0x100) != 0 )\n            cl_0 = tolower(cl_0);\n          if ( ch_0 <= 0x2Fu || ch_0 > 0x39u )\n          {\n            if ( ch_0 <= 0x60u || ch_0 > 0x66u )\n            {\nbadhex:\n              CRYPTO_free(hexbuf);\n              ERR_put_error(34, 113, 113, \"v3_utl.c\", 441);\n              return 0LL;\n            }\n            ch_0a = ch_0 - 87;\n          }\n          else\n          {\n            ch_0a = ch_0 - 48;\n          }\n          if ( cl_0 <= 0x2Fu || cl_0 > 0x39u )\n          {\n            if ( cl_0 <= 0x60u || cl_0 > 0x66u )\n              goto badhex;\n            cl_0a = cl_0 - 87;\n          }\n          else\n          {\n            cl_0a = cl_0 - 48;\n          }\n          v6 = q++;\n          *v6 = cl_0a | (16 * ch_0a);\n        }\n      }\n      if ( len )\n        *len = q - hexbuf;\n      return hexbuf;\n    }\n    else\n    {\n      ERR_put_error(34, 113, 65, \"v3_utl.c\", 436);\n      return 0LL;\n    }\n  }\n  else\n  {\n    ERR_put_error(34, 113, 107, \"v3_utl.c\", 397);\n    return 0LL;\n  }\n}\n\n\n Revised code:\nunsigned char *string_to_hex(const char *str, long *len)\n{\n    unsigned char *hexbuf, *q;\n    unsigned char ch, cl, *p;\n    if (!str) {\n        X509V3err(X509V3_F_STRING_TO_HEX, X509V3_R_INVALID_NULL_ARGUMENT);\n        return NULL;\n    }\n    if (!(hexbuf = OPENSSL_malloc(strlen(str) >> 1)))\n        goto err;\n    for (p = (unsigned char *)str, q = hexbuf; *p;) {\n        ch = *p++;\n#ifdef CHARSET_EBCDIC\n        ch = os_toebcdic[ch];\n#endif\n        if (ch == ':')\n            continue;\n        cl = *p++;\n#ifdef CHARSET_EBCDIC\n        cl = os_toebcdic[cl];\n#endif\n        if (!cl) {\n            X509V3err(X509V3_F_STRING_TO_HEX, X509V3_R_ODD_NUMBER_OF_DIGITS);\n            OPENSSL_free(hexbuf);\n            return NULL;\n        }\n        if (isupper(ch))\n            ch = tolower(ch);\n        if (isupper(cl))\n            cl = tolower(cl);\n\n        if ((ch >= '0') && (ch <= '9'))\n            ch -= '0';\n        else if ((ch >= 'a') && (ch <= 'f'))\n            ch -= 'a' - 10;\n        else\n            goto badhex;\n\n        if ((cl >= '0') && (cl <= '9'))\n            cl -= '0';\n        else if ((cl >= 'a') && (cl <= 'f'))\n            cl -= 'a' - 10;\n        else\n            goto badhex;\n\n        *q++ = (ch << 4) | cl;\n    }\n\n    if (len)\n        *len = q - hexbuf;\n\n    return hexbuf;\n\n err:\n    if (hexbuf)\n        OPENSSL_free(hexbuf);\n    X509V3err(X509V3_F_STRING_TO_HEX, ERR_R_MALLOC_FAILURE);\n    return NULL;\n\n badhex:\n    OPENSSL_free(hexbuf);\n    X509V3err(X509V3_F_STRING_TO_HEX, X509V3_R_ILLEGAL_HEX_DIGIT);\n    return NULL;\n\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_49602F(__int64 a1, unsigned int a2)\n{\n  unsigned int v3; // [rsp+4h] [rbp-1Ch]\n  int v4; // [rsp+1Ch] [rbp-4h]\n  int v5; // [rsp+1Ch] [rbp-4h]\n\n  v3 = a2;\n  if ( (dword_75D450 & 4) != 0 )\n  {\n    if ( (dword_75D450 & 2) != 0 )\n    {\n      sub_40A659(10);\n      if ( !a2 )\n        *((_BYTE *)qword_75D408 + 2) = 1;\n      return a2;\n    }\n    else\n    {\n      if ( a2 )\n        printf(\"%s (y/n)? \", a1);\n      else\n        printf(\"%s (n/y)? \", a1);\n      while ( 1 )\n      {\n        sub_40A649();\n        v4 = getchar_unlocked();\n        if ( v4 == -1 )\n          break;\n        if ( v4 == 10 )\n          goto LABEL_19;\n        v5 = v4 | 0x20;\n        if ( v5 == 121 )\n        {\n          v3 = 1;\nLABEL_19:\n          if ( v3 )\n          {\n            puts(\"y\");\n          }\n          else\n          {\n            puts(\"n\");\n            *((_BYTE *)qword_75D408 + 2) = 1;\n          }\n          return v3;\n        }\n        if ( v5 == 110 )\n        {\n          v3 = 0;\n          goto LABEL_19;\n        }\n      }\n      if ( !a2 )\n        *((_BYTE *)qword_75D408 + 2) = 1;\n      return a2;\n    }\n  }\n  else\n  {\n    sub_40A659(10);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n    return 0LL;\n  }\n}\n",
        "output": "```c\nint confirm_action(const char *message, unsigned int default_choice)\n{\n    unsigned int choice = default_choice;\n    int input_char;\n    int lower_char;\n\n    if (global_flags & FLAG_INTERACTIVE_MODE) {\n        if (global_flags & FLAG_FORCE_YES) {\n            perform_action(YES_ACTION);\n            if (!default_choice)\n                global_state_field = YES_CHOSEN;\n            return default_choice;\n        } else {\n            printf(\"%s (y/n)? \", message);\n            while (1) {\n                flush_input_buffer();\n                input_char = getchar_unlocked();\n                if (input_char == EOF)\n                    break;\n                if (input_char == '\\n')\n                    goto OUTPUT_CHOICE;\n                lower_char = tolower(input_char);\n                if (lower_char == 'y') {\n                    choice = 1;\n                    goto OUTPUT_CHOICE;\n                }\n                if (lower_char == 'n') {\n                    choice = 0;\n                    goto OUTPUT_CHOICE;\n                }\n            }\n            if (!default_choice)\n                global_state_field = YES_CHOSEN;\n            return default_choice;\n        }\n    } else {\n        perform_action(NO_ACTION);\n        global_state_field = YES_CHOSEN;\n        return NO_CHOSEN;\n    }\n\nOUTPUT_CHOICE:\n    if (choice) {\n        puts(\"y\");\n    } else {\n        puts(\"n\");\n        global_state_field = YES_CHOSEN;\n    }\n    return choice;\n}\n```",
        "source_code": "int ask (e2fsck_t ctx, const char * string, int def)\n{\n\tif (ctx->options & E2F_OPT_NO) {\n\t\tprintf(_(\"%s? no\\n\\n\"), string);\n\t\treturn 0;\n\t}\n\tif (ctx->options & E2F_OPT_YES) {\n\t\tprintf(_(\"%s? yes\\n\\n\"), string);\n\t\treturn 1;\n\t}\n\tif (ctx->options & E2F_OPT_PREEN) {\n\t\tprintf(\"%s? %s\\n\\n\", string, def ? _(\"yes\") : _(\"no\"));\n\t\treturn def;\n\t}\n\treturn ask_yn(string, def);\n}",
        "parsed_output": "int confirm_action(const char *message, unsigned int default_choice)\n{\n    unsigned int choice = default_choice;\n    int input_char;\n    int lower_char;\n\n    if (global_flags & FLAG_INTERACTIVE_MODE) {\n        if (global_flags & FLAG_FORCE_YES) {\n            perform_action(YES_ACTION);\n            if (!default_choice)\n                global_state_field = YES_CHOSEN;\n            return default_choice;\n        } else {\n            printf(\"%s (y/n)? \", message);\n            while (1) {\n                flush_input_buffer();\n                input_char = getchar_unlocked();\n                if (input_char == EOF)\n                    break;\n                if (input_char == '\\n')\n                    goto OUTPUT_CHOICE;\n                lower_char = tolower(input_char);\n                if (lower_char == 'y') {\n                    choice = 1;\n                    goto OUTPUT_CHOICE;\n                }\n                if (lower_char == 'n') {\n                    choice = 0;\n                    goto OUTPUT_CHOICE;\n                }\n            }\n            if (!default_choice)\n                global_state_field = YES_CHOSEN;\n            return default_choice;\n        }\n    } else {\n        perform_action(NO_ACTION);\n        global_state_field = YES_CHOSEN;\n        return NO_CHOSEN;\n    }\n\nOUTPUT_CHOICE:\n    if (choice) {\n        puts(\"y\");\n    } else {\n        puts(\"n\");\n        global_state_field = YES_CHOSEN;\n    }\n    return choice;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_49602F(__int64 a1, unsigned int a2)\n{\n  unsigned int v3; // [rsp+4h] [rbp-1Ch]\n  int v4; // [rsp+1Ch] [rbp-4h]\n  int v5; // [rsp+1Ch] [rbp-4h]\n\n  v3 = a2;\n  if ( (dword_75D450 & 4) != 0 )\n  {\n    if ( (dword_75D450 & 2) != 0 )\n    {\n      sub_40A659(10);\n      if ( !a2 )\n        *((_BYTE *)qword_75D408 + 2) = 1;\n      return a2;\n    }\n    else\n    {\n      if ( a2 )\n        printf(\"%s (y/n)? \", a1);\n      else\n        printf(\"%s (n/y)? \", a1);\n      while ( 1 )\n      {\n        sub_40A649();\n        v4 = getchar_unlocked();\n        if ( v4 == -1 )\n          break;\n        if ( v4 == 10 )\n          goto LABEL_19;\n        v5 = v4 | 0x20;\n        if ( v5 == 121 )\n        {\n          v3 = 1;\nLABEL_19:\n          if ( v3 )\n          {\n            puts(\"y\");\n          }\n          else\n          {\n            puts(\"n\");\n            *((_BYTE *)qword_75D408 + 2) = 1;\n          }\n          return v3;\n        }\n        if ( v5 == 110 )\n        {\n          v3 = 0;\n          goto LABEL_19;\n        }\n      }\n      if ( !a2 )\n        *((_BYTE *)qword_75D408 + 2) = 1;\n      return a2;\n    }\n  }\n  else\n  {\n    sub_40A659(10);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n    return 0LL;\n  }\n}\n",
        "baseline_code_debug": "int __cdecl ask(const char *string, int def)\n{\n  int defa; // [rsp+4h] [rbp-1Ch]\n  int c; // [rsp+1Ch] [rbp-4h]\n  int ca; // [rsp+1Ch] [rbp-4h]\n\n  defa = def;\n  if ( (option_mask32 & 4) != 0 )\n  {\n    if ( (option_mask32 & 2) != 0 )\n    {\n      bb_putchar(10);\n      if ( !def )\n        BYTE2(ptr_to_globals->timeout) = 1;\n      return def;\n    }\n    else\n    {\n      if ( def )\n        printf(\"%s (y/n)? \", string);\n      else\n        printf(\"%s (n/y)? \", string);\n      while ( 1 )\n      {\n        fflush_all();\n        c = getchar_unlocked();\n        if ( c == -1 )\n          break;\n        if ( c == 10 )\n          goto LABEL_19;\n        ca = c | 0x20;\n        if ( ca == 121 )\n        {\n          defa = 1;\nLABEL_19:\n          if ( defa )\n          {\n            puts(\"y\");\n          }\n          else\n          {\n            puts(\"n\");\n            BYTE2(ptr_to_globals->timeout) = 1;\n          }\n          return defa;\n        }\n        if ( ca == 110 )\n        {\n          defa = 0;\n          goto LABEL_19;\n        }\n      }\n      if ( !def )\n        BYTE2(ptr_to_globals->timeout) = 1;\n      return def;\n    }\n  }\n  else\n  {\n    bb_putchar(10);\n    BYTE2(ptr_to_globals->timeout) = 1;\n    return 0;\n  }\n}\n",
        "similarity_score_unixcoder": 0.66012042760849,
        "similarity_score_baseline_stripped": 0.4866630733013153,
        "similarity_score_baseline_debug": 0.7005268931388855
    },
    {
        "func_name": "stoppedjobs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nunsigned int __cdecl read_ledword(const unsigned __int8 **in)\n{\n  int v1; // eax\n  int ret; // [rsp+Ch] [rbp-Ch]\n\n  ret = ((*in)[2] << 16) | *(unsigned __int16 *)*in;\n  v1 = (*in)[3] << 24;\n  *in += 4;\n  return v1 | ret;\n}\n\n\n Revised code:\nstatic unsigned int read_ledword(const unsigned char **in)\n{\n    const unsigned char *p = *in;\n    unsigned int ret;\n    ret = *p++;\n    ret |= (*p++ << 8);\n    ret |= (*p++ << 16);\n    ret |= (*p++ << 24);\n    *in = p;\n    return ret;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_472FFC()\n{\n  unsigned int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = 0;\n  if ( !*(_BYTE *)(qword_75D418 + 748) && qword_75AFB0 && *(_BYTE *)(qword_75AFB0 + 30) == 1 )\n  {\n    sub_46E2EB(\"You have stopped jobs.\\n\");\n    *(_BYTE *)(qword_75D418 + 748) = 2;\n    return 1;\n  }\n  return v1;\n}\n",
        "output": "```c\nstatic int check_and_notify_stopped_jobs()\n{\n    int has_stopped_jobs = 0;\n\n    if (!flag_stopped_jobs && ptr_job_list && *(char *)(ptr_job_list + 30) == 1)\n    {\n        notify_user(\"You have stopped jobs.\\n\");\n        flag_stopped_jobs = 2;\n        has_stopped_jobs = 1;\n    }\n\n    return has_stopped_jobs;\n}\n```",
        "source_code": "static int\nstoppedjobs(void)\n{\n\tstruct job *jp;\n\tint retval;\n\n\tretval = 0;\n\tif (job_warning)\n\t\tgoto out;\n\tjp = curjob;\n\tif (jp && jp->state == JOBSTOPPED) {\n\t\tout2str(\"You have stopped jobs.\\n\");\n\t\tjob_warning = 2;\n\t\tretval++;\n\t}\n out:\n\treturn retval;\n}",
        "parsed_output": "static int check_and_notify_stopped_jobs()\n{\n    int has_stopped_jobs = 0;\n\n    if (!flag_stopped_jobs && ptr_job_list && *(char *)(ptr_job_list + 30) == 1)\n    {\n        notify_user(\"You have stopped jobs.\\n\");\n        flag_stopped_jobs = 2;\n        has_stopped_jobs = 1;\n    }\n\n    return has_stopped_jobs;\n}",
        "baseline_code_stripped": "__int64 sub_472FFC()\n{\n  unsigned int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = 0;\n  if ( !*(_BYTE *)(qword_75D418 + 748) && qword_75AFB0 && *(_BYTE *)(qword_75AFB0 + 30) == 1 )\n  {\n    sub_46E2EB(\"You have stopped jobs.\\n\");\n    *(_BYTE *)(qword_75D418 + 748) = 2;\n    return 1;\n  }\n  return v1;\n}\n",
        "baseline_code_debug": "int __cdecl stoppedjobs()\n{\n  int retval; // [rsp+Ch] [rbp-4h]\n\n  retval = 0;\n  if ( !ash_ptr_to_globals_misc->job_warning && curjob && *((_BYTE *)curjob + 30) == 1 )\n  {\n    out2str(\"You have stopped jobs.\\n\");\n    ash_ptr_to_globals_misc->job_warning = 2;\n    return 1;\n  }\n  return retval;\n}\n",
        "similarity_score_unixcoder": 0.7598178386688232,
        "similarity_score_baseline_stripped": 0.5042272210121155,
        "similarity_score_baseline_debug": 0.8050308227539062
    },
    {
        "func_name": "read_pid",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl ipv4_from_asc(unsigned __int8 *v4, const char *in)\n{\n  int a3; // [rsp+10h] [rbp-10h] BYREF\n  int a2; // [rsp+14h] [rbp-Ch] BYREF\n  int a1; // [rsp+18h] [rbp-8h] BYREF\n  int a0; // [rsp+1Ch] [rbp-4h] BYREF\n\n  if ( (unsigned int)__isoc99_sscanf(in, \"%d.%d.%d.%d\", &a0, &a1, &a2, &a3) != 4 )\n    return 0;\n  if ( (unsigned int)a0 > 0xFF || (unsigned int)a1 > 0xFF || (unsigned int)a2 > 0xFF || (unsigned int)a3 >= 0x100 )\n    return 0;\n  *v4 = a0;\n  v4[1] = a1;\n  v4[2] = a2;\n  v4[3] = a3;\n  return 1;\n}\n\n\n Revised code:\nstatic int ipv4_from_asc(unsigned char *v4, const char *in)\n{\n    int a0, a1, a2, a3;\n    if (sscanf(in, \"%d.%d.%d.%d\", &a0, &a1, &a2, &a3) != 4)\n        return 0;\n    if ((a0 < 0) || (a0 > 255) || (a1 < 0) || (a1 > 255)\n        || (a2 < 0) || (a2 > 255) || (a3 < 0) || (a3 > 255))\n        return 0;\n    v4[0] = a0;\n    v4[1] = a1;\n    v4[2] = a2;\n    v4[3] = a3;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_430F61(const char *a1)\n{\n  char v2[140]; // [rsp+10h] [rbp-90h] BYREF\n  int v3; // [rsp+9Ch] [rbp-4h]\n\n  v3 = sub_40B501(a1, v2, 0x7FuLL);\n  if ( v3 <= 0 )\n    return 0LL;\n  v2[v3] = 0;\n  return sub_43060C(v2, 0LL, 10);\n}\n",
        "output": "```c\nlong long sub_430F61(const char *input)\n{\n    char buffer[140];\n    int length;\n\n    length = sub_40B501(input, buffer, 127);\n    if (length <= 0)\n        return 0LL;\n    buffer[length] = '\\0';\n    return sub_43060C(buffer, 0LL, 10);\n}\n```",
        "source_code": "if ENABLE_FEATURE_PIDFILE\nstatic NOINLINE pid_t read_pid(const char *filename)\n{\n\tint len;\n\tchar buf[128];\n\n\tlen = open_read_close(filename, buf, 127);\n\tif (len > 0) {\n\t\tbuf[len] = '\\0';\n\t\t/* returns ULONG_MAX on error => -1 */\n\t\treturn bb_strtoul(buf, NULL, 10);\n\t}\n\treturn 0;\n}",
        "parsed_output": "long long sub_430F61(const char *input)\n{\n    char buffer[140];\n    int length;\n\n    length = sub_40B501(input, buffer, 127);\n    if (length <= 0)\n        return 0LL;\n    buffer[length] = '\\0';\n    return sub_43060C(buffer, 0LL, 10);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_430F61(const char *a1)\n{\n  char v2[140]; // [rsp+10h] [rbp-90h] BYREF\n  int v3; // [rsp+9Ch] [rbp-4h]\n\n  v3 = sub_40B501(a1, v2, 0x7FuLL);\n  if ( v3 <= 0 )\n    return 0LL;\n  v2[v3] = 0;\n  return sub_43060C(v2, 0LL, 10);\n}\n",
        "baseline_code_debug": "pid_t __cdecl read_pid(const char *filename)\n{\n  char buf[128]; // [rsp+10h] [rbp-90h] BYREF\n  int len; // [rsp+9Ch] [rbp-4h]\n\n  len = open_read_close(filename, buf, 0x7FuLL);\n  if ( len <= 0 )\n    return 0;\n  buf[len] = 0;\n  return bb_strtoul_0(buf, 0LL, 10);\n}\n",
        "similarity_score_unixcoder": 0.5599889159202576,
        "similarity_score_baseline_stripped": 0.4914260506629944,
        "similarity_score_baseline_debug": 0.7908037900924683
    },
    {
        "func_name": "get_sname",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl get_ip(const char *str, unsigned __int8 *ip_0)\n{\n  const char *v2; // rax\n  unsigned int tmp[4]; // [rsp+10h] [rbp-20h]\n  int c; // [rsp+24h] [rbp-Ch]\n  int ok; // [rsp+28h] [rbp-8h]\n  int num; // [rsp+2Ch] [rbp-4h]\n\n  num = 0;\n  ok = 0;\n  tmp[3] = 0;\n  tmp[2] = 0;\n  tmp[1] = 0;\n  tmp[0] = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v2 = str++;\n      c = *v2;\n      if ( c <= 47 || c > 57 )\n        break;\n      ok = 1;\n      tmp[num] = 10 * tmp[num] + c - 48;\n      if ( tmp[num] > 0xFF )\n        return 0;\n    }\n    if ( c != 46 )\n      break;\n    if ( !ok )\n      return -1;\n    if ( num == 3 )\n      return 0;\n    ++num;\n    ok = 0;\n  }\n  if ( c || num != 3 || !ok )\n    return 0;\n  *ip_0 = tmp[0];\n  ip_0[1] = tmp[1];\n  ip_0[2] = tmp[2];\n  ip_0[3] = tmp[3];\n  return 1;\n}\n\n\n Revised code:\nstatic int get_ip(const char *str, unsigned char ip[4])\n{\n    unsigned int tmp[4];\n    int num = 0, c, ok = 0;\n\n    tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;\n\n    for (;;) {\n        c = *(str++);\n        if ((c >= '0') && (c <= '9')) {\n            ok = 1;\n            tmp[num] = tmp[num] * 10 + c - '0';\n            if (tmp[num] > 255)\n                return (0);\n        } else if (c == '.') {\n            if (!ok)\n                return (-1);\n            if (num == 3)\n                return (0);\n            num++;\n            ok = 0;\n        } else if (c == '\\0' && (num == 3) && ok)\n            break;\n        else\n            return (0);\n    }\n    ip[0] = tmp[0];\n    ip[1] = tmp[1];\n    ip[2] = tmp[2];\n    ip[3] = tmp[3];\n    return (1);\n}\n\n## Example:\n\n Input code:\nint __cdecl a2i_ipadd(unsigned __int8 *ipout, const char *ipasc)\n{\n  if ( strchr(ipasc, 58) )\n  {\n    if ( ipv6_from_asc(ipout, ipasc) )\n      return 16;\n    else\n      return 0;\n  }\n  else if ( ipv4_from_asc(ipout, ipasc) )\n  {\n    return 4;\n  }\n  else\n  {\n    return 0;\n  }\n}\n\n\n Revised code:\nint a2i_ipadd(unsigned char *ipout, const char *ipasc)\n{\n    /* If string contains a ':' assume IPv6 */\n\n    if (strchr(ipasc, ':')) {\n        if (!ipv6_from_asc(ipout, ipasc))\n            return 0;\n        return 16;\n    } else {\n        if (!ipv4_from_asc(ipout, ipasc))\n            return 0;\n        return 4;\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl ipv6_hex(unsigned __int8 *out, const char *in, int inlen)\n{\n  const char *v4; // rax\n  int inlena; // [rsp+0h] [rbp-24h]\n  unsigned __int8 c; // [rsp+1Fh] [rbp-5h]\n  int num; // [rsp+20h] [rbp-4h]\n  unsigned int numa; // [rsp+20h] [rbp-4h]\n\n  inlena = inlen;\n  num = 0;\n  if ( inlen > 4 )\n    return 0;\n  while ( inlena-- )\n  {\n    v4 = in++;\n    c = *v4;\n    numa = 16 * num;\n    if ( *v4 <= 0x2Fu || c > 0x39u )\n    {\n      if ( c <= 0x40u || c > 0x46u )\n      {\n        if ( c <= 0x60u || c > 0x66u )\n          return 0;\n        num = (c - 87) | numa;\n      }\n      else\n      {\n        num = (c - 55) | numa;\n      }\n    }\n    else\n    {\n      num = (c - 48) | numa;\n    }\n  }\n  *out = BYTE1(num);\n  out[1] = num;\n  return 1;\n}\n\n\n Revised code:\nstatic int ipv6_hex(unsigned char *out, const char *in, int inlen)\n{\n    unsigned char c;\n    unsigned int num = 0;\n    if (inlen > 4)\n        return 0;\n    while (inlen--) {\n        c = *in++;\n        num <<= 4;\n        if ((c >= '0') && (c <= '9'))\n            num |= c - '0';\n        else if ((c >= 'A') && (c <= 'F'))\n            num |= c - 'A' + 10;\n        else if ((c >= 'a') && (c <= 'f'))\n            num |= c - 'a' + 10;\n        else\n            return 0;\n    }\n    out[0] = num >> 8;\n    out[1] = num & 0xff;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_43A0F8(int a1, const char *a2, int a3)\n{\n  uint16_t v4; // ax\n  struct servent *v5; // [rsp+18h] [rbp-8h]\n\n  if ( !a1 )\n    return \"*\";\n  if ( !a3 )\n  {\n    v5 = getservbyport(a1, a2);\n    if ( v5 )\n      return v5->s_name;\n  }\n  v4 = ntohs(a1);\n  return sub_409B8C(v4);\n}\n",
        "output": "```c\nconst char *get_service_name(int port, const char *protocol, int numeric)\n{\n    struct servent *service;\n\n    if (port == 0)\n        return \"*\";\n    if (!numeric)\n    {\n        service = getservbyport(port, protocol);\n        if (service)\n            return service->s_name;\n    }\n    return sub_409B8C(ntohs(port));\n}\n```",
        "source_code": "static const char *get_sname(int port, const char *proto, int numeric)\n{\n\tif (!port)\n\t\treturn \"*\";\n\tif (!numeric) {\n\t\tstruct servent *se = getservbyport(port, proto);\n\t\tif (se)\n\t\t\treturn se->s_name;\n\t}\n\t/* hummm, we may return static buffer here!! */\n\treturn itoa(ntohs(port));\n}",
        "parsed_output": "const char *get_service_name(int port, const char *protocol, int numeric)\n{\n    struct servent *service;\n\n    if (port == 0)\n        return \"*\";\n    if (!numeric)\n    {\n        service = getservbyport(port, protocol);\n        if (service)\n            return service->s_name;\n    }\n    return sub_409B8C(ntohs(port));\n}",
        "baseline_code_stripped": "const char *__fastcall sub_43A0F8(int a1, const char *a2, int a3)\n{\n  uint16_t v4; // ax\n  struct servent *v5; // [rsp+18h] [rbp-8h]\n\n  if ( !a1 )\n    return \"*\";\n  if ( !a3 )\n  {\n    v5 = getservbyport(a1, a2);\n    if ( v5 )\n      return v5->s_name;\n  }\n  v4 = ntohs(a1);\n  return sub_409B8C(v4);\n}\n",
        "baseline_code_debug": "const char *__cdecl get_sname(int port, const char *proto, int numeric)\n{\n  uint16_t v4; // ax\n  struct servent *se; // [rsp+18h] [rbp-8h]\n\n  if ( !port )\n    return \"*\";\n  if ( !numeric )\n  {\n    se = getservbyport(port, proto);\n    if ( se )\n      return se->s_name;\n  }\n  v4 = ntohs(port);\n  return itoa(v4);\n}\n",
        "similarity_score_unixcoder": 0.8244801759719849,
        "similarity_score_baseline_stripped": 0.6137388348579407,
        "similarity_score_baseline_debug": 0.7830277681350708
    },
    {
        "func_name": "inflate_codes_setup",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl bn_sqr_words(unsigned __int64 *r, const unsigned __int64 *a, int n)\n{\n  int na; // [rsp+0h] [rbp-44h]\n\n  na = n;\n  if ( n > 0 )\n  {\n    while ( (na & 0xFFFFFFFC) != 0 )\n    {\n      *(_OWORD *)r = *a * (unsigned __int128)*a;\n      *((_OWORD *)r + 1) = a[1] * (unsigned __int128)a[1];\n      *((_OWORD *)r + 2) = a[2] * (unsigned __int128)a[2];\n      *((_OWORD *)r + 3) = a[3] * (unsigned __int128)a[3];\n      a += 4;\n      r += 8;\n      na -= 4;\n    }\n    while ( na )\n    {\n      *(_OWORD *)r = *a * (unsigned __int128)*a;\n      ++a;\n      r += 2;\n      --na;\n    }\n  }\n}\n\n\n Revised code:\nvoid bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)\n{\n    assert(n >= 0);\n    if (n <= 0)\n        return;\n\n# ifndef OPENSSL_SMALL_FOOTPRINT\n    while (n & ~3) {\n        sqr(r[0], r[1], a[0]);\n        sqr(r[2], r[3], a[1]);\n        sqr(r[4], r[5], a[2]);\n        sqr(r[6], r[7], a[3]);\n        a += 4;\n        r += 8;\n        n -= 4;\n    }\n# endif\n    while (n) {\n        sqr(r[0], r[1], a[0]);\n        a++;\n        r += 2;\n        n--;\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4B90C7(__int64 a1, int a2, int a3)\n{\n  __int64 result; // rax\n\n  *(_DWORD *)(a1 + 112) = a2;\n  *(_DWORD *)(a1 + 116) = a3;\n  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a1 + 40);\n  *(_DWORD *)(a1 + 84) = *(unsigned __int8 *)(a1 + 44);\n  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 16);\n  *(_DWORD *)(a1 + 72) = (unsigned __int16)word_534E56[*(unsigned int *)(a1 + 112)];\n  result = a1;\n  *(_DWORD *)(a1 + 76) = (unsigned __int16)word_534E56[*(unsigned int *)(a1 + 116)];\n  return result;\n}\n",
        "output": "```c\nvoid sub_4B90C7(void *ptr, int a2, int a3)\n{\n    *((int *)(ptr + 112)) = a2;\n    *((int *)(ptr + 116)) = a3;\n    *((int *)(ptr + 80)) = *((int *)(ptr + 40));\n    *((unsigned char *)(ptr + 84)) = *((unsigned char *)(ptr + 44));\n    *((int *)(ptr + 88)) = *((int *)(ptr + 16));\n    *((unsigned short *)(ptr + 72)) = word_534E56[*(unsigned int *)(ptr + 112)];\n    *((unsigned short *)(ptr + 76)) = word_534E56[*(unsigned int *)(ptr + 116)];\n}\n```",
        "source_code": "define dd inflate_codes_dd\nstatic void inflate_codes_setup(STATE_PARAM unsigned my_bl, unsigned my_bd)\n{\n\tbl = my_bl;\n\tbd = my_bd;\n\t/* make local copies of globals */\n\tbb = gunzip_bb;\t\t\t/* initialize bit buffer */\n\tk = gunzip_bk;\n\tw = gunzip_outbuf_count;\t/* initialize gunzip_window position */\n\t/* inflate the coded data */\n\tml = mask_bits[bl];\t\t/* precompute masks for speed */\n\tmd = mask_bits[bd];\n}",
        "parsed_output": "void sub_4B90C7(void *ptr, int a2, int a3)\n{\n    *((int *)(ptr + 112)) = a2;\n    *((int *)(ptr + 116)) = a3;\n    *((int *)(ptr + 80)) = *((int *)(ptr + 40));\n    *((unsigned char *)(ptr + 84)) = *((unsigned char *)(ptr + 44));\n    *((int *)(ptr + 88)) = *((int *)(ptr + 16));\n    *((unsigned short *)(ptr + 72)) = word_534E56[*(unsigned int *)(ptr + 112)];\n    *((unsigned short *)(ptr + 76)) = word_534E56[*(unsigned int *)(ptr + 116)];\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4B90C7(__int64 a1, int a2, int a3)\n{\n  __int64 result; // rax\n\n  *(_DWORD *)(a1 + 112) = a2;\n  *(_DWORD *)(a1 + 116) = a3;\n  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a1 + 40);\n  *(_DWORD *)(a1 + 84) = *(unsigned __int8 *)(a1 + 44);\n  *(_DWORD *)(a1 + 88) = *(_DWORD *)(a1 + 16);\n  *(_DWORD *)(a1 + 72) = (unsigned __int16)word_534E56[*(unsigned int *)(a1 + 112)];\n  result = a1;\n  *(_DWORD *)(a1 + 76) = (unsigned __int16)word_534E56[*(unsigned int *)(a1 + 116)];\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl inflate_codes_setup(state_t_0 *state, unsigned int my_bl, unsigned int my_bd)\n{\n  state->inflate_codes_bl = my_bl;\n  state->inflate_codes_bd = my_bd;\n  state->inflate_codes_bb = state->gunzip_bb;\n  state->inflate_codes_k = state->gunzip_bk;\n  state->inflate_codes_w = state->gunzip_outbuf_count;\n  state->inflate_codes_ml = mask_bits[state->inflate_codes_bl];\n  state->inflate_codes_md = mask_bits[state->inflate_codes_bd];\n}\n",
        "similarity_score_unixcoder": 0.4326019287109375,
        "similarity_score_baseline_stripped": 0.41391855478286743,
        "similarity_score_baseline_debug": 0.8907905220985413
    },
    {
        "func_name": "to64_msb_first",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl make_kn(unsigned __int8 *k1_0, unsigned __int8 *l, int bl_0)\n{\n  unsigned __int8 v3; // dl\n  char v4; // al\n  int i; // [rsp+20h] [rbp-4h]\n\n  for ( i = 0; i < bl_0; ++i )\n  {\n    k1_0[i] = 2 * l[i];\n    if ( i < bl_0 - 1 && (l[i + 1] & 0x80u) != 0 )\n      k1_0[i] |= 1u;\n  }\n  if ( (*l & 0x80u) != 0 )\n  {\n    v3 = k1_0[bl_0 - 1];\n    if ( bl_0 == 16 )\n      v4 = -121;\n    else\n      v4 = 27;\n    k1_0[bl_0 - 1] = v3 ^ v4;\n  }\n}\n\n\n Revised code:\nstatic void make_kn(unsigned char *k1, unsigned char *l, int bl)\n{\n    int i;\n    /* Shift block to left, including carry */\n    for (i = 0; i < bl; i++) {\n        k1[i] = l[i] << 1;\n        if (i < bl - 1 && l[i + 1] & 0x80)\n            k1[i] |= 1;\n    }\n    /* If MSB set fixup with R */\n    if (l[0] & 0x80)\n        k1[bl - 1] ^= bl == 16 ? 0x87 : 0x1b;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl BUF_reverse(unsigned __int8 *out, const unsigned __int8 *in, size_t size)\n{\n  const unsigned __int8 *v3; // rdx\n  unsigned __int8 *v4; // rax\n  unsigned __int8 *v5; // rax\n  char *v6; // rax\n  const unsigned __int8 *ina; // [rsp+8h] [rbp-30h]\n  unsigned __int8 *outa; // [rsp+10h] [rbp-28h]\n  unsigned __int8 *outb; // [rsp+10h] [rbp-28h]\n  char c; // [rsp+27h] [rbp-11h]\n  unsigned __int8 *q; // [rsp+28h] [rbp-10h]\n  size_t i; // [rsp+30h] [rbp-8h]\n  size_t ia; // [rsp+30h] [rbp-8h]\n\n  outa = out;\n  ina = in;\n  if ( in )\n  {\n    outb = &out[size - 1];\n    for ( i = 0LL; i < size; ++i )\n    {\n      v3 = ina++;\n      v4 = outb--;\n      *v4 = *v3;\n    }\n  }\n  else\n  {\n    q = &out[size - 1];\n    for ( ia = 0LL; ia < size >> 1; ++ia )\n    {\n      c = *q;\n      v5 = q--;\n      *v5 = *outa;\n      v6 = (char *)outa++;\n      *v6 = c;\n    }\n  }\n}\n\n\n Revised code:\nvoid BUF_reverse(unsigned char *out, const unsigned char *in, size_t size)\n{\n    size_t i;\n    if (in) {\n        out += size - 1;\n        for (i = 0; i < size; i++)\n            *out-- = *in++;\n    } else {\n        unsigned char *q;\n        char c;\n        q = out + size - 1;\n        for (i = 0; i < size / 2; i++) {\n            c = *q;\n            *q-- = *out;\n            *out++ = c;\n        }\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_505B2A(_BYTE *a1, unsigned int a2)\n{\n  char v2; // dl\n  _BYTE *result; // rax\n\n  *a1 = sub_504A59(a2 >> 18);\n  a1[1] = sub_504A59(a2 >> 12);\n  a1[2] = sub_504A59(a2 >> 6);\n  v2 = sub_504A59(a2);\n  result = a1 + 3;\n  a1[3] = v2;\n  return result;\n}\n",
        "output": "```c\nunsigned char *encode_triplet(unsigned char *output, unsigned int value)\n{\n    output[0] = encode_six_bits(value >> 18);\n    output[1] = encode_six_bits(value >> 12);\n    output[2] = encode_six_bits(value >> 6);\n    output[3] = encode_six_bits(value);\n    return output + 4;\n}\n```",
        "source_code": "define DES_OUT_BUFSIZE 21\n\nstatic void\nto64_msb_first(char *s, unsigned v)\n{\n#if 0\n\t*s++ = ascii64[(v >> 18) & 0x3f]; /* bits 23..18 */\n\t*s++ = ascii64[(v >> 12) & 0x3f]; /* bits 17..12 */\n\t*s++ = ascii64[(v >> 6) & 0x3f]; /* bits 11..6 */\n\t*s   = ascii64[v & 0x3f]; /* bits 5..0 */\n#endif\n\t*s++ = i64c(v >> 18); /* bits 23..18 */\n\t*s++ = i64c(v >> 12); /* bits 17..12 */\n\t*s++ = i64c(v >> 6); /* bits 11..6 */\n\t*s   = i64c(v); /* bits 5..0 */\n}",
        "parsed_output": "unsigned char *encode_triplet(unsigned char *output, unsigned int value)\n{\n    output[0] = encode_six_bits(value >> 18);\n    output[1] = encode_six_bits(value >> 12);\n    output[2] = encode_six_bits(value >> 6);\n    output[3] = encode_six_bits(value);\n    return output + 4;\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_505B2A(_BYTE *a1, unsigned int a2)\n{\n  char v2; // dl\n  _BYTE *result; // rax\n\n  *a1 = sub_504A59(a2 >> 18);\n  a1[1] = sub_504A59(a2 >> 12);\n  a1[2] = sub_504A59(a2 >> 6);\n  v2 = sub_504A59(a2);\n  result = a1 + 3;\n  a1[3] = v2;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl to64_msb_first(char *s, unsigned int v)\n{\n  *s = i64c(v >> 18);\n  s[1] = i64c(v >> 12);\n  s[2] = i64c(v >> 6);\n  s[3] = i64c(v);\n}\n",
        "similarity_score_unixcoder": 0.6040191650390625,
        "similarity_score_baseline_stripped": 0.5809218883514404,
        "similarity_score_baseline_debug": 0.7810748815536499
    },
    {
        "func_name": "status_line",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n\n## Example:\n\n Input code:\nint BIO_printf(BIO *bio, const char *format, ...)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list args; // [rsp+10h] [rbp-D0h] BYREF\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(args, format);\n  v2 = va_arg(args, _QWORD);\n  v3 = va_arg(args, _QWORD);\n  v4 = va_arg(args, _QWORD);\n  v5 = va_arg(args, _QWORD);\n  v8 = v2;\n  v9 = v3;\n  v10 = v4;\n  v11 = v5;\n  args[0].gp_offset = 16;\n  return BIO_vprintf(bio, format, args);\n}\n\n\n Revised code:\nint BIO_printf(BIO *bio, const char *format, ...)\n{\n    va_list args;\n    int ret;\n\n    va_start(args, format);\n\n    ret = BIO_vprintf(bio, format, args);\n\n    va_end(args);\n    return (ret);\n}\n\n## Example:\n\n Input code:\nint BIO_snprintf(char *buf, size_t n, const char *format, ...)\n{\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list args; // [rsp+20h] [rbp-D0h] BYREF\n  __int64 v8; // [rsp+58h] [rbp-98h]\n  __int64 v9; // [rsp+60h] [rbp-90h]\n  __int64 v10; // [rsp+68h] [rbp-88h]\n\n  va_start(args, format);\n  v3 = va_arg(args, _QWORD);\n  v4 = va_arg(args, _QWORD);\n  v5 = va_arg(args, _QWORD);\n  v8 = v3;\n  v9 = v4;\n  v10 = v5;\n  args[0].gp_offset = 24;\n  return BIO_vsnprintf(buf, n, format, args);\n}\n\n\n Revised code:\nint BIO_snprintf(char *buf, size_t n, const char *format, ...)\n{\n    va_list args;\n    int ret;\n\n    va_start(args, format);\n\n    ret = BIO_vsnprintf(buf, n, format, args);\n\n    va_end(args);\n    return (ret);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *sub_4EFFAB(const char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)\n{\n  void *result; // rax\n  gcc_va_list arg; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v8; // [rsp+38h] [rbp-A8h]\n  __int64 v9; // [rsp+40h] [rbp-A0h]\n  __int64 v10; // [rsp+48h] [rbp-98h]\n  __int64 v11; // [rsp+50h] [rbp-90h]\n  __int64 v12; // [rsp+58h] [rbp-88h]\n\n  va_start(arg, a6);\n  v8 = a2;\n  v9 = a3;\n  v10 = a4;\n  v11 = a5;\n  v12 = a6;\n  arg[0].gp_offset = 8;\n  vsprintf((char *)qword_75D408 + 1008, a1, arg);\n  result = qword_75D408;\n  *((_DWORD *)qword_75D408 + 18) = 1;\n  return result;\n}\n",
        "output": "void *sub_4EFFAB(const char *format, ...)\n{\n    va_list args;\n    void *result;\n\n    va_start(args, format);\n\n    vsprintf((char *)qword_75D408 + 1008, format, args);\n\n    va_end(args);\n\n    result = qword_75D408;\n    *((_DWORD *)qword_75D408 + 18) = 1;\n\n    return result;\n}",
        "source_code": "format status buffer\nstatic void status_line(const char *format, ...)\n{\n\tva_list args;\n\n\tva_start(args, format);\n\tvsprintf(status_buffer, format, args);\n\tva_end(args);\n\n\thave_status_msg = 1;\n}",
        "parsed_output": "void *sub_4EFFAB(const char *format, ...)\n{\n    va_list args;\n    void *result;\n\n    va_start(args, format);\n\n    vsprintf((char *)qword_75D408 + 1008, format, args);\n\n    va_end(args);\n\n    result = qword_75D408;\n    *((_DWORD *)qword_75D408 + 18) = 1;\n\n    return result;\n}",
        "baseline_code_stripped": "void *sub_4EFFAB(const char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, ...)\n{\n  void *result; // rax\n  gcc_va_list arg; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v8; // [rsp+38h] [rbp-A8h]\n  __int64 v9; // [rsp+40h] [rbp-A0h]\n  __int64 v10; // [rsp+48h] [rbp-98h]\n  __int64 v11; // [rsp+50h] [rbp-90h]\n  __int64 v12; // [rsp+58h] [rbp-88h]\n\n  va_start(arg, a6);\n  v8 = a2;\n  v9 = a3;\n  v10 = a4;\n  v11 = a5;\n  v12 = a6;\n  arg[0].gp_offset = 8;\n  vsprintf((char *)qword_75D408 + 1008, a1, arg);\n  result = qword_75D408;\n  *((_DWORD *)qword_75D408 + 18) = 1;\n  return result;\n}\n",
        "baseline_code_debug": "void status_line(const char *format, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list args; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(args, format);\n  v3 = va_arg(args, _QWORD);\n  v1 = va_arg(args, _QWORD);\n  v2 = va_arg(args, _QWORD);\n  v4 = va_arg(args, _QWORD);\n  v5 = va_arg(args, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  args[0].gp_offset = 8;\n  vsprintf((char *)&ptr_to_globals[3].tty_attrs.c_cc[31], format, args);\n  ptr_to_globals->speeds[5] = 1;\n}\n",
        "similarity_score_unixcoder": 0.6339794397354126,
        "similarity_score_baseline_stripped": 0.4656757414340973,
        "similarity_score_baseline_debug": 0.5573415160179138
    },
    {
        "func_name": "new_peer",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl make_kn(unsigned __int8 *k1_0, unsigned __int8 *l, int bl_0)\n{\n  unsigned __int8 v3; // dl\n  char v4; // al\n  int i; // [rsp+20h] [rbp-4h]\n\n  for ( i = 0; i < bl_0; ++i )\n  {\n    k1_0[i] = 2 * l[i];\n    if ( i < bl_0 - 1 && (l[i + 1] & 0x80u) != 0 )\n      k1_0[i] |= 1u;\n  }\n  if ( (*l & 0x80u) != 0 )\n  {\n    v3 = k1_0[bl_0 - 1];\n    if ( bl_0 == 16 )\n      v4 = -121;\n    else\n      v4 = 27;\n    k1_0[bl_0 - 1] = v3 ^ v4;\n  }\n}\n\n\n Revised code:\nstatic void make_kn(unsigned char *k1, unsigned char *l, int bl)\n{\n    int i;\n    /* Shift block to left, including carry */\n    for (i = 0; i < bl; i++) {\n        k1[i] = l[i] << 1;\n        if (i < bl - 1 && l[i + 1] & 0x80)\n            k1[i] |= 1;\n    }\n    /* If MSB set fixup with R */\n    if (l[0] & 0x80)\n        k1[bl - 1] ^= bl == 16 ? 0x87 : 0x1b;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_438778(__int64 a1, __int64 a2)\n{\n  int v3; // eax\n  int v4; // [rsp+14h] [rbp-Ch]\n  _DWORD *v5; // [rsp+18h] [rbp-8h]\n\n  v5 = sub_40A0E8(0x40uLL, a2);\n  v4 = sub_449167(a1, v5);\n  if ( v4 < 0 )\n    return 0LL;\n  if ( (int)sub_448FDE(a1, (unsigned int)v4, (unsigned int)a2) < 0 )\n    return (unsigned int)v4;\n  v3 = fcntl(a2, 3);\n  BYTE1(v3) |= 8u;\n  v5[1] = v3;\n  sub_448DB4(a1, (unsigned int)a2);\n  return 0LL;\n}\n",
        "output": "```c\nstatic __int64 sub_438778(__int64 a1, __int64 a2)\n{\n    int result;\n    int flags;\n    _DWORD *buffer;\n\n    buffer = sub_40A0E8(0x40uLL, a2);\n    result = sub_449167(a1, buffer);\n    if (result < 0)\n        return 0LL;\n    if (sub_448FDE(a1, (unsigned int)result, (unsigned int)a2) < 0)\n        return (unsigned int)result;\n    flags = fcntl(a2, 3); // F_GETFL to get the file access mode and the file status flags\n    BYTE1(flags) |= 8u; // Set O_NONBLOCK flag\n    buffer[1] = flags; // Store the updated flags back to buffer\n    sub_448DB4(a1, (unsigned int)a2); // Some operation, possibly related to applying the new flags\n    return 0LL;\n}\n```",
        "source_code": "define bogouser bb_common_bufsiz1\n\nstatic int new_peer(isrv_state_t *state, int fd)\n{\n\tint peer;\n\tidentd_buf_t *buf = xzalloc(sizeof(*buf));\n\n\tpeer = isrv_register_peer(state, buf);\n\tif (peer < 0)\n\t\treturn 0; /* failure */\n\tif (isrv_register_fd(state, peer, fd) < 0)\n\t\treturn peer; /* failure, unregister peer */\n\n\tbuf->fd_flag = fcntl(fd, F_GETFL) | O_NONBLOCK;\n\tisrv_want_rd(state, fd);\n\treturn 0;\n}",
        "parsed_output": "static __int64 sub_438778(__int64 a1, __int64 a2)\n{\n    int result;\n    int flags;\n    _DWORD *buffer;\n\n    buffer = sub_40A0E8(0x40uLL, a2);\n    result = sub_449167(a1, buffer);\n    if (result < 0)\n        return 0LL;\n    if (sub_448FDE(a1, (unsigned int)result, (unsigned int)a2) < 0)\n        return (unsigned int)result;\n    flags = fcntl(a2, 3); // F_GETFL to get the file access mode and the file status flags\n    BYTE1(flags) |= 8u; // Set O_NONBLOCK flag\n    buffer[1] = flags; // Store the updated flags back to buffer\n    sub_448DB4(a1, (unsigned int)a2); // Some operation, possibly related to applying the new flags\n    return 0LL;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_438778(__int64 a1, __int64 a2)\n{\n  int v3; // eax\n  int v4; // [rsp+14h] [rbp-Ch]\n  _DWORD *v5; // [rsp+18h] [rbp-8h]\n\n  v5 = sub_40A0E8(0x40uLL, a2);\n  v4 = sub_449167(a1, v5);\n  if ( v4 < 0 )\n    return 0LL;\n  if ( (int)sub_448FDE(a1, (unsigned int)v4, (unsigned int)a2) < 0 )\n    return (unsigned int)v4;\n  v3 = fcntl(a2, 3);\n  BYTE1(v3) |= 8u;\n  v5[1] = v3;\n  sub_448DB4(a1, (unsigned int)a2);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl new_peer(isrv_state_t_0 *state, int fd)\n{\n  int v3; // eax\n  int peer; // [rsp+14h] [rbp-Ch]\n  identd_buf_t_0 *buf; // [rsp+18h] [rbp-8h]\n\n  buf = (identd_buf_t_0 *)xzalloc(0x40uLL);\n  peer = isrv_register_peer(state, buf);\n  if ( peer < 0 )\n    return 0;\n  if ( isrv_register_fd(state, peer, fd) < 0 )\n    return peer;\n  v3 = fcntl(fd, 3);\n  BYTE1(v3) |= 8u;\n  buf->fd_flag = v3;\n  isrv_want_rd(state, fd);\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.5426290035247803,
        "similarity_score_baseline_stripped": 0.46771714091300964,
        "similarity_score_baseline_debug": 0.8481420278549194
    },
    {
        "func_name": "rtc_xopen",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __cdecl slg_ctrl(BIO *b, int cmd, __int64 num, void *ptr)\n{\n  int numa; // [rsp+8h] [rbp-18h]\n\n  numa = num;\n  if ( cmd == 4 )\n  {\n    xcloselog(b);\n    xopenlog(b, (char *)ptr, numa);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic long MS_CALLBACK slg_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    switch (cmd) {\n    case BIO_CTRL_SET:\n        xcloselog(b);\n        xopenlog(b, ptr, num);\n        break;\n    default:\n        break;\n    }\n    return (0);\n}\n\n## Example:\n\n Input code:\n__int64 __cdecl fd_ctrl(BIO *b, int cmd, __int64 num, void *ptr)\n{\n  __int64 numa; // [rsp+8h] [rbp-28h]\n  __int64 ret; // [rsp+28h] [rbp-8h]\n\n  numa = num;\n  ret = 1LL;\n  if ( cmd <= 12 )\n  {\n    if ( cmd >= 11 )\n      return 1LL;\n    if ( cmd == 8 )\n      return b->shutdown;\n    if ( cmd <= 8 )\n    {\n      if ( cmd != 1 )\n      {\n        if ( cmd != 3 )\n          return 0LL;\n        return lseek(b->num, 0LL, 1);\n      }\n      numa = 0LL;\n      return lseek(b->num, numa, 0);\n    }\n    if ( cmd == 9 )\n    {\n      b->shutdown = num;\n      return ret;\n    }\n    return 0LL;\n  }\n  if ( cmd == 105 )\n  {\n    if ( b->init )\n    {\n      if ( ptr )\n        *(_DWORD *)ptr = b->num;\n      return b->num;\n    }\n    else\n    {\n      return -1LL;\n    }\n  }\n  else\n  {\n    if ( cmd > 105 )\n    {\n      if ( cmd != 128 )\n      {\n        if ( cmd != 133 )\n          return 0LL;\n        return lseek(b->num, 0LL, 1);\n      }\n      return lseek(b->num, numa, 0);\n    }\n    if ( cmd == 13 )\n      return 0LL;\n    if ( cmd != 104 )\n      return 0LL;\n    fd_free(b);\n    b->num = *(_DWORD *)ptr;\n    b->shutdown = numa;\n    b->init = 1;\n  }\n  return ret;\n}\n\n\n Revised code:\nstatic long fd_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    long ret = 1;\n    int *ip;\n\n    switch (cmd) {\n    case BIO_CTRL_RESET:\n        num = 0;\n    case BIO_C_FILE_SEEK:\n        ret = (long)UP_lseek(b->num, num, 0);\n        break;\n    case BIO_C_FILE_TELL:\n    case BIO_CTRL_INFO:\n        ret = (long)UP_lseek(b->num, 0, 1);\n        break;\n    case BIO_C_SET_FD:\n        fd_free(b);\n        b->num = *((int *)ptr);\n        b->shutdown = (int)num;\n        b->init = 1;\n        break;\n    case BIO_C_GET_FD:\n        if (b->init) {\n            ip = (int *)ptr;\n            if (ip != NULL)\n                *ip = b->num;\n            ret = b->num;\n        } else\n            ret = -1;\n        break;\n    case BIO_CTRL_GET_CLOSE:\n        ret = b->shutdown;\n        break;\n    case BIO_CTRL_SET_CLOSE:\n        b->shutdown = (int)num;\n        break;\n    case BIO_CTRL_PENDING:\n    case BIO_CTRL_WPENDING:\n        ret = 0;\n        break;\n    case BIO_CTRL_DUP:\n    case BIO_CTRL_FLUSH:\n        ret = 1;\n        break;\n    default:\n        ret = 0;\n        break;\n    }\n    return (ret);\n}\n\n## Example:\n\n Input code:\nint __cdecl ipv4_from_asc(unsigned __int8 *v4, const char *in)\n{\n  int a3; // [rsp+10h] [rbp-10h] BYREF\n  int a2; // [rsp+14h] [rbp-Ch] BYREF\n  int a1; // [rsp+18h] [rbp-8h] BYREF\n  int a0; // [rsp+1Ch] [rbp-4h] BYREF\n\n  if ( (unsigned int)__isoc99_sscanf(in, \"%d.%d.%d.%d\", &a0, &a1, &a2, &a3) != 4 )\n    return 0;\n  if ( (unsigned int)a0 > 0xFF || (unsigned int)a1 > 0xFF || (unsigned int)a2 > 0xFF || (unsigned int)a3 >= 0x100 )\n    return 0;\n  *v4 = a0;\n  v4[1] = a1;\n  v4[2] = a2;\n  v4[3] = a3;\n  return 1;\n}\n\n\n Revised code:\nstatic int ipv4_from_asc(unsigned char *v4, const char *in)\n{\n    int a0, a1, a2, a3;\n    if (sscanf(in, \"%d.%d.%d.%d\", &a0, &a1, &a2, &a3) != 4)\n        return 0;\n    if ((a0 < 0) || (a0 > 255) || (a1 < 0) || (a1 > 255)\n        || (a2 < 0) || (a2 > 255) || (a3 < 0) || (a3 > 255))\n        return 0;\n    v4[0] = a0;\n    v4[1] = a1;\n    v4[2] = a2;\n    v4[3] = a3;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_507C1B(const char **a1, int a2)\n{\n  int v3; // [rsp+1Ch] [rbp-4h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  if ( !*a1 )\n  {\n    *a1 = \"/dev/rtc\";\n    v3 = open64(*a1, a2);\n    if ( v3 >= 0 )\n      return (unsigned int)v3;\n    *a1 = \"/dev/rtc0\";\n    v4 = open64(*a1, a2);\n    if ( v4 >= 0 )\n      return (unsigned int)v4;\n    *a1 = \"/dev/misc/rtc\";\n  }\n  return sub_40A295(*a1, a2);\n}\n",
        "output": "```c\nstatic int open_rtc_device(const char **device_path, int flags)\n{\n    int fd;\n\n    if (!*device_path) {\n        *device_path = \"/dev/rtc\";\n        fd = open64(*device_path, flags);\n        if (fd >= 0)\n            return fd;\n\n        *device_path = \"/dev/rtc0\";\n        fd = open64(*device_path, flags);\n        if (fd >= 0)\n            return fd;\n\n        *device_path = \"/dev/misc/rtc\";\n    }\n    return open_fallback_device(*device_path, flags);\n}\n```",
        "source_code": "int FAST_FUNC rtc_xopen(const char **default_rtc, int flags)\n{\n\tint rtc;\n\n\tif (!*default_rtc) {\n\t\t*default_rtc = \"/dev/rtc\";\n\t\trtc = open(*default_rtc, flags);\n\t\tif (rtc >= 0)\n\t\t\treturn rtc;\n\t\t*default_rtc = \"/dev/rtc0\";\n\t\trtc = open(*default_rtc, flags);\n\t\tif (rtc >= 0)\n\t\t\treturn rtc;\n\t\t*default_rtc = \"/dev/misc/rtc\";\n\t}\n\n\treturn xopen(*default_rtc, flags);\n}",
        "parsed_output": "static int open_rtc_device(const char **device_path, int flags)\n{\n    int fd;\n\n    if (!*device_path) {\n        *device_path = \"/dev/rtc\";\n        fd = open64(*device_path, flags);\n        if (fd >= 0)\n            return fd;\n\n        *device_path = \"/dev/rtc0\";\n        fd = open64(*device_path, flags);\n        if (fd >= 0)\n            return fd;\n\n        *device_path = \"/dev/misc/rtc\";\n    }\n    return open_fallback_device(*device_path, flags);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_507C1B(const char **a1, int a2)\n{\n  int v3; // [rsp+1Ch] [rbp-4h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  if ( !*a1 )\n  {\n    *a1 = \"/dev/rtc\";\n    v3 = open64(*a1, a2);\n    if ( v3 >= 0 )\n      return (unsigned int)v3;\n    *a1 = \"/dev/rtc0\";\n    v4 = open64(*a1, a2);\n    if ( v4 >= 0 )\n      return (unsigned int)v4;\n    *a1 = \"/dev/misc/rtc\";\n  }\n  return sub_40A295(*a1, a2);\n}\n",
        "baseline_code_debug": "int __cdecl rtc_xopen(const char **default_rtc, int flags)\n{\n  int rtc; // [rsp+1Ch] [rbp-4h]\n  int rtca; // [rsp+1Ch] [rbp-4h]\n\n  if ( !*default_rtc )\n  {\n    *default_rtc = \"/dev/rtc\";\n    rtc = open64(*default_rtc, flags);\n    if ( rtc >= 0 )\n      return rtc;\n    *default_rtc = \"/dev/rtc0\";\n    rtca = open64(*default_rtc, flags);\n    if ( rtca >= 0 )\n      return rtca;\n    *default_rtc = \"/dev/misc/rtc\";\n  }\n  return xopen(*default_rtc, flags);\n}\n",
        "similarity_score_unixcoder": 0.8753265738487244,
        "similarity_score_baseline_stripped": 0.7127187252044678,
        "similarity_score_baseline_debug": 0.9098696708679199
    },
    {
        "func_name": "bzip2_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl write_lebn(unsigned __int8 **out, const BIGNUM *bn, int len)\n{\n  unsigned __int8 *v3; // rax\n  unsigned __int8 *v4; // rax\n  int lenb; // [rsp+Ch] [rbp-34h]\n  unsigned __int8 c; // [rsp+23h] [rbp-1Dh]\n  int nb; // [rsp+24h] [rbp-1Ch]\n  unsigned __int8 *q; // [rsp+28h] [rbp-18h]\n  unsigned __int8 *p; // [rsp+30h] [rbp-10h]\n  int i; // [rsp+3Ch] [rbp-4h]\n\n  p = *out;\n  nb = (BN_num_bits(bn) + 7) / 8;\n  BN_bn2bin(bn, p);\n  q = &p[nb - 1];\n  for ( i = 0; i < nb / 2; ++i )\n  {\n    c = *p;\n    v3 = p++;\n    *v3 = *q;\n    v4 = q--;\n    *v4 = c;\n  }\n  *out += nb;\n  if ( len > 0 )\n  {\n    lenb = len - nb;\n    if ( lenb > 0 )\n    {\n      memset(*out, 0, lenb);\n      *out += lenb;\n    }\n  }\n}\n\n\n Revised code:\nstatic void write_lebn(unsigned char **out, const BIGNUM *bn, int len)\n{\n    int nb, i;\n    unsigned char *p = *out, *q, c;\n    nb = BN_num_bytes(bn);\n    BN_bn2bin(bn, p);\n    q = p + nb - 1;\n    /* In place byte order reversal */\n    for (i = 0; i < nb / 2; i++) {\n        c = *p;\n        *p++ = *q;\n        *q-- = c;\n    }\n    *out += nb;\n    /* Pad with zeroes if we have to */\n    if (len > 0) {\n        len -= nb;\n        if (len > 0) {\n            memset(*out, 0, len);\n            *out += len;\n        }\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4ADBC4(unsigned int a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int v6; // ecx\n  int v7; // r8d\n  int v8; // r9d\n  unsigned int v10; // [rsp+1Ch] [rbp-4h]\n  unsigned int v11; // [rsp+1Ch] [rbp-4h]\n\n  qword_75D440 = (__int64)\"s2\";\n  v10 = sub_4FA1EF(a2, (unsigned int)\"cfvdt123456789qzs\", a3, a4, a5, a6);\n  if ( (v10 & 0x18) != 0 )\n    return sub_4A891B(a1, a2, a2, v6, v7, v8);\n  v11 = (unsigned __int8)(v10 >> 5) | 0x100;\n  byte_75B300 = 1;\n  while ( (v11 & 1) == 0 )\n  {\n    ++byte_75B300;\n    v11 >>= 1;\n  }\n  dword_75D450 &= 7u;\n  return sub_4A8417(\n           (char **)(8LL * optind + a2),\n           (const char *)sub_4ADB07,\n           (__int64 (__fastcall *)(char *, __int64))sub_4A83EB,\n           (__int64)\"bz2\");\n}\n",
        "output": "```c\nstatic __int64 sub_4ADBC4(unsigned int a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n    unsigned int result;\n    unsigned int flag;\n\n    // Global variable assignment (possibly indicating an error or status message)\n    qword_75D440 = \"s2\";\n\n    // Call to another function, possibly to perform some operation and return a status\n    result = sub_4FA1EF(a2, \"cfvdt123456789qzs\", a3, a4, a5, a6);\n\n    // Check specific bits of the result for a condition\n    if ((result & 0x18) != 0)\n        return sub_4A891B(a1, a2, a2, a3, a4, a5); // a3, a4, a5 are likely the correct arguments\n\n    // Process the result to set another flag\n    flag = (unsigned __int8)(result >> 5) | 0x100;\n\n    // Set a global variable to 1 (possibly indicating a count or a new state)\n    byte_75B300 = 1;\n\n    // Loop to find the position of the first set bit in 'flag'\n    while ((flag & 1) == 0)\n    {\n        ++byte_75B300;\n        flag >>= 1;\n    }\n\n    // Perform a bitwise AND with 7 on a global variable (possibly resetting some bits)\n    dword_75D450 &= 7u;\n\n    // Call another function with a set of arguments, including a global function pointer\n    return sub_4A8417(\n        (char **)(8LL * optind + a2),\n        (const char *)sub_4ADB07,\n        (__int64 (__fastcall *)(char *, __int64))sub_4A83EB,\n        \"bz2\");\n}\n```",
        "source_code": "int bzip2_main(int argc UNUSED_PARAM, char **argv)\n{\n\tunsigned opt;\n\n\t/* standard bzip2 flags\n\t * -d --decompress force decompression\n\t * -z --compress force compression\n\t * -k --keep     keep (don't delete) input files\n\t * -f --force    overwrite existing output files\n\t * -t --test     test compressed file integrity\n\t * -c --stdout   output to standard out\n\t * -q --quiet    suppress noncritical error messages\n\t * -v --verbose  be verbose (a 2nd -v gives more)\n\t * -s --small    use less memory (at most 2500k)\n\t * -1 .. -9      set block size to 100k .. 900k\n\t * --fast        alias for -1\n\t * --best        alias for -9\n\t */\n\n\topt_complementary = \"s2\"; /* -s means -2 (compatibility) */\n\t/* Must match bbunzip's constants OPT_STDOUT, OPT_FORCE! */\n\topt = getopt32(argv, \"cfv\" IF_BUNZIP2(\"dt\") \"123456789qzs\");\n#if ENABLE_BUNZIP2 /* bunzip2_main may not be visible... */\n\tif (opt & 0x18) // -d and/or -t\n\t\treturn bunzip2_main(argc, argv);\n\topt >>= 5;\n#else\n\topt >>= 3;\n#endif\n\topt = (uint8_t)opt; /* isolate bits for -1..-8 */\n\topt |= 0x100; /* if nothing else, assume -9 */\n\tlevel = 1;\n\twhile (!(opt & 1)) {\n\t\tlevel++;\n\t\topt >>= 1;\n\t}\n\n\targv += optind;\n\toption_mask32 &= 0x7; /* ignore all except -cfv */\n\treturn bbunpack(argv, compressStream, append_ext, \"bz2\");\n}",
        "parsed_output": "static __int64 sub_4ADBC4(unsigned int a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n    unsigned int result;\n    unsigned int flag;\n\n    // Global variable assignment (possibly indicating an error or status message)\n    qword_75D440 = \"s2\";\n\n    // Call to another function, possibly to perform some operation and return a status\n    result = sub_4FA1EF(a2, \"cfvdt123456789qzs\", a3, a4, a5, a6);\n\n    // Check specific bits of the result for a condition\n    if ((result & 0x18) != 0)\n        return sub_4A891B(a1, a2, a2, a3, a4, a5); // a3, a4, a5 are likely the correct arguments\n\n    // Process the result to set another flag\n    flag = (unsigned __int8)(result >> 5) | 0x100;\n\n    // Set a global variable to 1 (possibly indicating a count or a new state)\n    byte_75B300 = 1;\n\n    // Loop to find the position of the first set bit in 'flag'\n    while ((flag & 1) == 0)\n    {\n        ++byte_75B300;\n        flag >>= 1;\n    }\n\n    // Perform a bitwise AND with 7 on a global variable (possibly resetting some bits)\n    dword_75D450 &= 7u;\n\n    // Call another function with a set of arguments, including a global function pointer\n    return sub_4A8417(\n        (char **)(8LL * optind + a2),\n        (const char *)sub_4ADB07,\n        (__int64 (__fastcall *)(char *, __int64))sub_4A83EB,\n        \"bz2\");\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4ADBC4(unsigned int a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int v6; // ecx\n  int v7; // r8d\n  int v8; // r9d\n  unsigned int v10; // [rsp+1Ch] [rbp-4h]\n  unsigned int v11; // [rsp+1Ch] [rbp-4h]\n\n  qword_75D440 = (__int64)\"s2\";\n  v10 = sub_4FA1EF(a2, (unsigned int)\"cfvdt123456789qzs\", a3, a4, a5, a6);\n  if ( (v10 & 0x18) != 0 )\n    return sub_4A891B(a1, a2, a2, v6, v7, v8);\n  v11 = (unsigned __int8)(v10 >> 5) | 0x100;\n  byte_75B300 = 1;\n  while ( (v11 & 1) == 0 )\n  {\n    ++byte_75B300;\n    v11 >>= 1;\n  }\n  dword_75D450 &= 7u;\n  return sub_4A8417(\n           (char **)(8LL * optind + a2),\n           (const char *)sub_4ADB07,\n           (__int64 (__fastcall *)(char *, __int64))sub_4A83EB,\n           (__int64)\"bz2\");\n}\n",
        "baseline_code_debug": "int __cdecl bzip2_main(int argc, char **argv)\n{\n  unsigned int opt; // [rsp+1Ch] [rbp-4h]\n  unsigned int opta; // [rsp+1Ch] [rbp-4h]\n\n  opt_complementary = \"s2\";\n  opt = getopt32(argv, \"cfvdt123456789qzs\");\n  if ( (opt & 0x18) != 0 )\n    return bunzip2_main(argc, argv);\n  opta = (unsigned __int8)(opt >> 5) | 0x100;\n  level = 1;\n  while ( (opta & 1) == 0 )\n  {\n    ++level;\n    opta >>= 1;\n  }\n  option_mask32 &= 7u;\n  return bbunpack(\n           &argv[optind],\n           (__int64 (*)(transformer_aux_data_t_0 *))compressStream,\n           (char *(*)(char *, const char *))append_ext,\n           \"bz2\");\n}\n",
        "similarity_score_unixcoder": 0.5754304528236389,
        "similarity_score_baseline_stripped": 0.5557436347007751,
        "similarity_score_baseline_debug": 0.8256049156188965
    },
    {
        "func_name": "and",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl private_RC4_set_key(RC4_KEY *key, int len, const unsigned __int8 *data)\n{\n  unsigned __int8 *v3; // r12\n  int v4; // ebx\n  int v5; // r13d\n  unsigned __int8 v6; // r14\n  int v7; // ebx\n  int v8; // r13d\n  unsigned __int8 v9; // r14\n  int v10; // ebx\n  int v11; // r13d\n  unsigned __int8 v12; // r14\n  int v13; // ebx\n  int v14; // r13d\n  unsigned __int8 v15; // r14\n  unsigned int i; // [rsp+24h] [rbp-24h]\n  unsigned int ia; // [rsp+24h] [rbp-24h]\n\n  v3 = key->data;\n  key->x = 0;\n  key->y = 0;\n  LOBYTE(v4) = 0;\n  v5 = 0;\n  for ( i = 0; i <= 0xFF; ++i )\n    v3[i] = i;\n  for ( ia = 0; ia <= 0xFF; ia += 4 )\n  {\n    v6 = v3[ia];\n    v7 = (unsigned __int8)(v4 + data[v5] + v6);\n    v8 = v5 + 1;\n    if ( v8 == len )\n      v8 = 0;\n    v3[ia] = v3[v7];\n    v3[v7] = v6;\n    v9 = v3[ia + 1];\n    v10 = (unsigned __int8)(v7 + data[v8] + v9);\n    v11 = v8 + 1;\n    if ( v11 == len )\n      v11 = 0;\n    v3[ia + 1] = v3[v10];\n    v3[v10] = v9;\n    v12 = v3[ia + 2];\n    v13 = (unsigned __int8)(v10 + data[v11] + v12);\n    v14 = v11 + 1;\n    if ( v14 == len )\n      v14 = 0;\n    v3[ia + 2] = v3[v13];\n    v3[v13] = v12;\n    v15 = v3[ia + 3];\n    v4 = (unsigned __int8)(v13 + data[v14] + v15);\n    v5 = v14 + 1;\n    if ( v5 == len )\n      v5 = 0;\n    v3[ia + 3] = v3[v4];\n    v3[v4] = v15;\n  }\n}\n\n\n Revised code:\nvoid private_RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)\n{\n    register RC4_INT tmp;\n    register int id1, id2;\n    register RC4_INT *d;\n    unsigned int i;\n\n    d = &(key->data[0]);\n    key->x = 0;\n    key->y = 0;\n    id1 = id2 = 0;\n\n#define SK_LOOP(d,n) { \\\n                tmp=d[(n)]; \\\n                id2 = (data[id1] + tmp + id2) & 0xff; \\\n                if (++id1 == len) id1=0; \\\n                d[(n)]=d[id2]; \\\n                d[id2]=tmp; }\n\n    for (i = 0; i < 256; i++)\n        d[i] = i;\n    for (i = 0; i < 256; i += 4) {\n        SK_LOOP(d, i + 0);\n        SK_LOOP(d, i + 1);\n        SK_LOOP(d, i + 2);\n        SK_LOOP(d, i + 3);\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl RC2_decrypt(unsigned __int64 *d, RC2_KEY *key)\n{\n  unsigned int v2; // r12d\n  unsigned int v3; // r14d\n  unsigned int v4; // ebx\n  unsigned int v5; // r13d\n  unsigned int *v6; // r15\n  unsigned int *v7; // rax\n  int v8; // eax\n  unsigned __int64 l; // [rsp+10h] [rbp-38h]\n  int n; // [rsp+18h] [rbp-30h]\n  int i; // [rsp+1Ch] [rbp-2Ch]\n\n  v2 = (unsigned __int16)*d;\n  v3 = *d >> 16;\n  l = d[1];\n  v4 = (unsigned __int16)l;\n  v5 = l >> 16;\n  n = 3;\n  i = 5;\n  v6 = &key->data[63];\n  while ( 1 )\n  {\n    do\n    {\n      v5 = (unsigned __int16)((((_WORD)v5 << 11) | (v5 >> 5)) - (v2 & ~(_WORD)v4) - (v4 & v3) - *v6);\n      LOWORD(v4) = (((_WORD)v4 << 13) | (v4 >> 3)) - (v5 & ~(_WORD)v3) - (v3 & v2) - *(v6 - 1);\n      v3 = (unsigned __int16)((((_WORD)v3 << 14) | (v3 >> 2)) - (v4 & ~(_WORD)v2) - (v2 & v5) - *(v6 - 2));\n      v7 = v6 - 3;\n      v6 -= 4;\n      LOWORD(v2) = (((_WORD)v2 << 15) | (v2 >> 1)) - (v3 & ~(_WORD)v5) - (v5 & v4) - *(_WORD *)v7;\n      --i;\n    }\n    while ( i );\n    if ( !--n )\n      break;\n    if ( n == 2 )\n      v8 = 6;\n    else\n      v8 = 5;\n    i = v8;\n    v5 = (unsigned __int16)(v5 - key->data[v4 & 0x3F]);\n    v4 = (unsigned __int16)(v4 - key->data[v3 & 0x3F]);\n    v3 = (unsigned __int16)(v3 - key->data[v2 & 0x3F]);\n    v2 = (unsigned __int16)(v2 - key->data[v5 & 0x3F]);\n  }\n  *d = (unsigned __int16)v2 | (unsigned __int64)(v3 << 16);\n  d[1] = (v5 << 16) | (unsigned __int64)(unsigned __int16)v4;\n}\n\n\n Revised code:\nvoid RC2_decrypt(unsigned long *d, RC2_KEY *key)\n{\n    int i, n;\n    register RC2_INT *p0, *p1;\n    register RC2_INT x0, x1, x2, x3, t;\n    unsigned long l;\n\n    l = d[0];\n    x0 = (RC2_INT) l & 0xffff;\n    x1 = (RC2_INT) (l >> 16L);\n    l = d[1];\n    x2 = (RC2_INT) l & 0xffff;\n    x3 = (RC2_INT) (l >> 16L);\n\n    n = 3;\n    i = 5;\n\n    p0 = &(key->data[63]);\n    p1 = &(key->data[0]);\n    for (;;) {\n        t = ((x3 << 11) | (x3 >> 5)) & 0xffff;\n        x3 = (t - (x0 & ~x2) - (x1 & x2) - *(p0--)) & 0xffff;\n        t = ((x2 << 13) | (x2 >> 3)) & 0xffff;\n        x2 = (t - (x3 & ~x1) - (x0 & x1) - *(p0--)) & 0xffff;\n        t = ((x1 << 14) | (x1 >> 2)) & 0xffff;\n        x1 = (t - (x2 & ~x0) - (x3 & x0) - *(p0--)) & 0xffff;\n        t = ((x0 << 15) | (x0 >> 1)) & 0xffff;\n        x0 = (t - (x1 & ~x3) - (x2 & x3) - *(p0--)) & 0xffff;\n\n        if (--i == 0) {\n            if (--n == 0)\n                break;\n            i = (n == 2) ? 6 : 5;\n\n            x3 = (x3 - p1[x2 & 0x3f]) & 0xffff;\n            x2 = (x2 - p1[x1 & 0x3f]) & 0xffff;\n            x1 = (x1 - p1[x0 & 0x3f]) & 0xffff;\n            x0 = (x0 - p1[x3 & 0x3f]) & 0xffff;\n        }\n    }\n\n    d[0] =\n        (unsigned long)(x0 & 0xffff) | ((unsigned long)(x1 & 0xffff) << 16L);\n    d[1] =\n        (unsigned long)(x2 & 0xffff) | ((unsigned long)(x3 & 0xffff) << 16L);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_416213(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  double v10; // xmm0_8\n  unsigned __int64 v11; // rbx\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  double v16; // xmm0_8\n  unsigned __int64 v17; // rax\n  __int64 v18; // rax\n  double v19; // xmm0_8\n\n  v10 = sub_416051(a1, a2, a3, a4, a5, a6);\n  if ( v10 >= 9.223372036854776e18 )\n    v11 = (unsigned int)(int)(v10 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v11 = (unsigned int)(int)v10;\n  v16 = sub_416051(a1, a2, v6, v7, v8, v9);\n  if ( v16 >= 9.223372036854776e18 )\n  {\n    v12 = 0x8000000000000000LL;\n    v17 = (unsigned int)(int)(v16 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  }\n  else\n  {\n    v17 = (unsigned int)(int)v16;\n  }\n  v18 = v11 & v17;\n  if ( v18 < 0 )\n  {\n    v12 = v18 & 1 | ((unsigned __int64)v18 >> 1);\n    v19 = (double)(int)v12 + (double)(int)v12;\n  }\n  else\n  {\n    v19 = (double)(int)v18;\n  }\n  return sub_416006(v19, a1, a2, v12, v13, v14, v15);\n}\n",
        "output": "```c\ndouble sub_416213(double a1, double a2, double a3, double a4, double a5, double a6)\n{\n    double result1, result2, finalResult;\n    unsigned __int64 intResult1, intResult2, intFinalResult;\n    double intermediate;\n\n    result1 = sub_416051(a1, a2, a3, a4, a5, a6);\n    if (result1 >= 9.223372036854776e18)\n        intResult1 = (unsigned int)(int)(result1 - 9.223372036854776e18) ^ 0x8000000000000000ULL;\n    else\n        intResult1 = (unsigned int)(int)result1;\n\n    result2 = sub_416051(a1, a2, a3, a4, a5, a6);\n    if (result2 >= 9.223372036854776e18)\n        intResult2 = (unsigned int)(int)(result2 - 9.223372036854776e18) ^ 0x8000000000000000ULL;\n    else\n        intResult2 = (unsigned int)(int)result2;\n\n    intFinalResult = intResult1 & intResult2;\n    if ((int)intFinalResult < 0)\n    {\n        intermediate = (double)((int)(intFinalResult & 1 | (intFinalResult >> 1)));\n        finalResult = intermediate + intermediate;\n    }\n    else\n    {\n        finalResult = (double)(int)intFinalResult;\n    }\n\n    return sub_416006(finalResult, a1, a2, a3, a4, a5, a6);\n}\n```",
        "source_code": "static void and(void)\n{\n\tpush((data_t) pop() & (data_t) pop());\n}",
        "parsed_output": "double sub_416213(double a1, double a2, double a3, double a4, double a5, double a6)\n{\n    double result1, result2, finalResult;\n    unsigned __int64 intResult1, intResult2, intFinalResult;\n    double intermediate;\n\n    result1 = sub_416051(a1, a2, a3, a4, a5, a6);\n    if (result1 >= 9.223372036854776e18)\n        intResult1 = (unsigned int)(int)(result1 - 9.223372036854776e18) ^ 0x8000000000000000ULL;\n    else\n        intResult1 = (unsigned int)(int)result1;\n\n    result2 = sub_416051(a1, a2, a3, a4, a5, a6);\n    if (result2 >= 9.223372036854776e18)\n        intResult2 = (unsigned int)(int)(result2 - 9.223372036854776e18) ^ 0x8000000000000000ULL;\n    else\n        intResult2 = (unsigned int)(int)result2;\n\n    intFinalResult = intResult1 & intResult2;\n    if ((int)intFinalResult < 0)\n    {\n        intermediate = (double)((int)(intFinalResult & 1 | (intFinalResult >> 1)));\n        finalResult = intermediate + intermediate;\n    }\n    else\n    {\n        finalResult = (double)(int)intFinalResult;\n    }\n\n    return sub_416006(finalResult, a1, a2, a3, a4, a5, a6);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_416213(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  double v10; // xmm0_8\n  unsigned __int64 v11; // rbx\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  double v16; // xmm0_8\n  unsigned __int64 v17; // rax\n  __int64 v18; // rax\n  double v19; // xmm0_8\n\n  v10 = sub_416051(a1, a2, a3, a4, a5, a6);\n  if ( v10 >= 9.223372036854776e18 )\n    v11 = (unsigned int)(int)(v10 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v11 = (unsigned int)(int)v10;\n  v16 = sub_416051(a1, a2, v6, v7, v8, v9);\n  if ( v16 >= 9.223372036854776e18 )\n  {\n    v12 = 0x8000000000000000LL;\n    v17 = (unsigned int)(int)(v16 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  }\n  else\n  {\n    v17 = (unsigned int)(int)v16;\n  }\n  v18 = v11 & v17;\n  if ( v18 < 0 )\n  {\n    v12 = v18 & 1 | ((unsigned __int64)v18 >> 1);\n    v19 = (double)(int)v12 + (double)(int)v12;\n  }\n  else\n  {\n    v19 = (double)(int)v18;\n  }\n  return sub_416006(v19, a1, a2, v12, v13, v14, v15);\n}\n",
        "baseline_code_debug": "void __cdecl and()\n{\n  double v0; // xmm0_8\n  unsigned __int64 v1; // rbx\n  double v2; // xmm0_8\n  unsigned __int64 v3; // rax\n  __int64 v4; // rax\n  double v5; // xmm0_8\n\n  v0 = pop();\n  if ( v0 >= 9.223372036854776e18 )\n    v1 = (unsigned int)(int)(v0 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v1 = (unsigned int)(int)v0;\n  v2 = pop();\n  if ( v2 >= 9.223372036854776e18 )\n    v3 = (unsigned int)(int)(v2 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v3 = (unsigned int)(int)v2;\n  v4 = v1 & v3;\n  if ( v4 < 0 )\n    v5 = (double)(int)(v4 & 1 | ((unsigned __int64)v4 >> 1)) + (double)(int)(v4 & 1 | ((unsigned __int64)v4 >> 1));\n  else\n    v5 = (double)(int)v4;\n  push(v5);\n}\n",
        "similarity_score_unixcoder": 0.39070355892181396,
        "similarity_score_baseline_stripped": 0.39724287390708923,
        "similarity_score_baseline_debug": 0.5733987092971802
    },
    {
        "func_name": "msort",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl make_kn(unsigned __int8 *k1_0, unsigned __int8 *l, int bl_0)\n{\n  unsigned __int8 v3; // dl\n  char v4; // al\n  int i; // [rsp+20h] [rbp-4h]\n\n  for ( i = 0; i < bl_0; ++i )\n  {\n    k1_0[i] = 2 * l[i];\n    if ( i < bl_0 - 1 && (l[i + 1] & 0x80u) != 0 )\n      k1_0[i] |= 1u;\n  }\n  if ( (*l & 0x80u) != 0 )\n  {\n    v3 = k1_0[bl_0 - 1];\n    if ( bl_0 == 16 )\n      v4 = -121;\n    else\n      v4 = 27;\n    k1_0[bl_0 - 1] = v3 ^ v4;\n  }\n}\n\n\n Revised code:\nstatic void make_kn(unsigned char *k1, unsigned char *l, int bl)\n{\n    int i;\n    /* Shift block to left, including carry */\n    for (i = 0; i < bl; i++) {\n        k1[i] = l[i] << 1;\n        if (i < bl - 1 && l[i + 1] & 0x80)\n            k1[i] |= 1;\n    }\n    /* If MSB set fixup with R */\n    if (l[0] & 0x80)\n        k1[bl - 1] ^= bl == 16 ? 0x87 : 0x1b;\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4765B8(__int64 a1, int a2)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h] BYREF\n  unsigned int v4; // [rsp+10h] [rbp-20h]\n  int v5; // [rsp+14h] [rbp-1Ch]\n  __int64 *v6; // [rsp+18h] [rbp-18h]\n  __int64 v7; // [rsp+20h] [rbp-10h]\n  __int64 v8; // [rsp+28h] [rbp-8h]\n\n  v3 = a1;\n  v7 = 0LL;\n  if ( a2 <= 1 )\n    return v3;\n  v4 = a2 >> 1;\n  v8 = v3;\n  v5 = a2 >> 1;\n  while ( --v5 >= 0 )\n  {\n    v7 = v8;\n    v8 = *(_QWORD *)v8;\n  }\n  *(_QWORD *)v7 = 0LL;\n  v7 = sub_4765B8(v3, v4);\n  v8 = sub_4765B8(v8, a2 - v4);\n  v6 = &v3;\n  do\n  {\n    while ( strcmp(*(const char **)(v8 + 8), *(const char **)(v7 + 8)) < 0 )\n    {\n      *v6 = v8;\n      v6 = (__int64 *)v8;\n      v8 = *(_QWORD *)v8;\n      if ( !v8 )\n      {\n        *v6 = v7;\n        return v3;\n      }\n    }\n    *v6 = v7;\n    v6 = (__int64 *)v7;\n    v7 = *(_QWORD *)v7;\n  }\n  while ( v7 );\n  *v6 = v8;\n  return v3;\n}\n",
        "output": "```c\nstatic __int64 sub_4765B8(__int64 head, int count)\n{\n    __int64 midNode, *prevNode, *currentNode;\n    __int64 leftList, rightList;\n    unsigned int middleIndex;\n\n    if (count <= 1)\n        return head;\n\n    middleIndex = count >> 1;\n    midNode = head;\n    prevNode = &midNode;\n\n    for (int i = 0; i < middleIndex; ++i) {\n        prevNode = (__int64 *)*prevNode;\n        midNode = *prevNode;\n    }\n\n    *prevNode = 0LL; // Split the list into two halves\n    leftList = sub_4765B8(head, middleIndex);\n    rightList = sub_4765B8(midNode, count - middleIndex);\n\n    currentNode = &head;\n    while (leftList && rightList) {\n        if (strcmp(*(const char **)(rightList + 8), *(const char **)(leftList + 8)) < 0) {\n            *currentNode = rightList;\n            currentNode = (__int64 *)rightList;\n            rightList = *(_QWORD *)rightList;\n        } else {\n            *currentNode = leftList;\n            currentNode = (__int64 *)leftList;\n            leftList = *(_QWORD *)leftList;\n        }\n    }\n\n    // Append the remaining list\n    *currentNode = (leftList == 0) ? rightList : leftList;\n\n    return head;\n}\n```",
        "source_code": "static struct strlist *\nmsort(struct strlist *list, int len)\n{\n\tstruct strlist *p, *q = NULL;\n\tstruct strlist **lpp;\n\tint half;\n\tint n;\n\n\tif (len <= 1)\n\t\treturn list;\n\thalf = len >> 1;\n\tp = list;\n\tfor (n = half; --n >= 0;) {\n\t\tq = p;\n\t\tp = p->next;\n\t}\n\tq->next = NULL;                 /* terminate first half of list */\n\tq = msort(list, half);          /* sort first half of list */\n\tp = msort(p, len - half);               /* sort second half */\n\tlpp = &list;\n\tfor (;;) {\n#if ENABLE_LOCALE_SUPPORT\n\t\tif (strcoll(p->text, q->text) < 0)\n#else\n\t\tif (strcmp(p->text, q->text) < 0)\n#endif\n\t\t\t\t\t\t{\n\t\t\t*lpp = p;\n\t\t\tlpp = &p->next;\n\t\t\tp = *lpp;\n\t\t\tif (p == NULL) {\n\t\t\t\t*lpp = q;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t*lpp = q;\n\t\t\tlpp = &q->next;\n\t\t\tq = *lpp;\n\t\t\tif (q == NULL) {\n\t\t\t\t*lpp = p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn list;\n}",
        "parsed_output": "static __int64 sub_4765B8(__int64 head, int count)\n{\n    __int64 midNode, *prevNode, *currentNode;\n    __int64 leftList, rightList;\n    unsigned int middleIndex;\n\n    if (count <= 1)\n        return head;\n\n    middleIndex = count >> 1;\n    midNode = head;\n    prevNode = &midNode;\n\n    for (int i = 0; i < middleIndex; ++i) {\n        prevNode = (__int64 *)*prevNode;\n        midNode = *prevNode;\n    }\n\n    *prevNode = 0LL; // Split the list into two halves\n    leftList = sub_4765B8(head, middleIndex);\n    rightList = sub_4765B8(midNode, count - middleIndex);\n\n    currentNode = &head;\n    while (leftList && rightList) {\n        if (strcmp(*(const char **)(rightList + 8), *(const char **)(leftList + 8)) < 0) {\n            *currentNode = rightList;\n            currentNode = (__int64 *)rightList;\n            rightList = *(_QWORD *)rightList;\n        } else {\n            *currentNode = leftList;\n            currentNode = (__int64 *)leftList;\n            leftList = *(_QWORD *)leftList;\n        }\n    }\n\n    // Append the remaining list\n    *currentNode = (leftList == 0) ? rightList : leftList;\n\n    return head;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4765B8(__int64 a1, int a2)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h] BYREF\n  unsigned int v4; // [rsp+10h] [rbp-20h]\n  int v5; // [rsp+14h] [rbp-1Ch]\n  __int64 *v6; // [rsp+18h] [rbp-18h]\n  __int64 v7; // [rsp+20h] [rbp-10h]\n  __int64 v8; // [rsp+28h] [rbp-8h]\n\n  v3 = a1;\n  v7 = 0LL;\n  if ( a2 <= 1 )\n    return v3;\n  v4 = a2 >> 1;\n  v8 = v3;\n  v5 = a2 >> 1;\n  while ( --v5 >= 0 )\n  {\n    v7 = v8;\n    v8 = *(_QWORD *)v8;\n  }\n  *(_QWORD *)v7 = 0LL;\n  v7 = sub_4765B8(v3, v4);\n  v8 = sub_4765B8(v8, a2 - v4);\n  v6 = &v3;\n  do\n  {\n    while ( strcmp(*(const char **)(v8 + 8), *(const char **)(v7 + 8)) < 0 )\n    {\n      *v6 = v8;\n      v6 = (__int64 *)v8;\n      v8 = *(_QWORD *)v8;\n      if ( !v8 )\n      {\n        *v6 = v7;\n        return v3;\n      }\n    }\n    *v6 = v7;\n    v6 = (__int64 *)v7;\n    v7 = *(_QWORD *)v7;\n  }\n  while ( v7 );\n  *v6 = v8;\n  return v3;\n}\n",
        "baseline_code_debug": "strlist *__cdecl msort(strlist *list, int len)\n{\n  strlist *lista; // [rsp+8h] [rbp-28h] BYREF\n  int half; // [rsp+10h] [rbp-20h]\n  int n; // [rsp+14h] [rbp-1Ch]\n  strlist **lpp; // [rsp+18h] [rbp-18h]\n  strlist *q; // [rsp+20h] [rbp-10h]\n  strlist *p; // [rsp+28h] [rbp-8h]\n\n  lista = list;\n  q = 0LL;\n  if ( len <= 1 )\n    return lista;\n  half = len >> 1;\n  p = lista;\n  n = len >> 1;\n  while ( --n >= 0 )\n  {\n    q = p;\n    p = p->next;\n  }\n  q->next = 0LL;\n  q = msort(lista, half);\n  p = msort(p, len - half);\n  lpp = &lista;\n  do\n  {\n    while ( strcmp(p->text, q->text) < 0 )\n    {\n      *lpp = p;\n      lpp = &p->next;\n      p = p->next;\n      if ( !p )\n      {\n        *lpp = q;\n        return lista;\n      }\n    }\n    *lpp = q;\n    lpp = &q->next;\n    q = q->next;\n  }\n  while ( q );\n  *lpp = p;\n  return lista;\n}\n",
        "similarity_score_unixcoder": 0.6039949655532837,
        "similarity_score_baseline_stripped": 0.5225478410720825,
        "similarity_score_baseline_debug": 0.8608744740486145
    },
    {
        "func_name": "alloc_dumper",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl longswap(void *_ptr, size_t len)\n{\n  unsigned __int8 c; // [rsp+1Fh] [rbp-11h]\n  unsigned __int8 ca; // [rsp+1Fh] [rbp-11h]\n  size_t i; // [rsp+28h] [rbp-8h]\n\n  for ( i = 0LL; i < len; i += 4LL )\n  {\n    c = *(_BYTE *)_ptr;\n    *(_BYTE *)_ptr = *((_BYTE *)_ptr + 3);\n    *((_BYTE *)_ptr + 3) = c;\n    ca = *((_BYTE *)_ptr + 1);\n    *((_BYTE *)_ptr + 1) = *((_BYTE *)_ptr + 2);\n    *((_BYTE *)_ptr + 2) = ca;\n  }\n}\n\n\n Revised code:\nstatic void longswap(void *_ptr, size_t len)\n{\n    const union {\n        long one;\n        char little;\n    } is_endian = {\n        1\n    };\n\n    if (is_endian.little) {\n        size_t i;\n        unsigned char *p = _ptr, c;\n\n        for (i = 0; i < len; i += 4) {\n            c = p[0], p[0] = p[3], p[3] = c;\n            c = p[1], p[1] = p[2], p[2] = c;\n        }\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl der_cmp(const void *a, const void *b)\n{\n  int v2; // eax\n  int i; // [rsp+18h] [rbp-18h]\n\n  v2 = *((_DWORD *)a + 2);\n  if ( *((_DWORD *)b + 2) <= v2 )\n    v2 = *((_DWORD *)b + 2);\n  i = memcmp(*(const void **)a, *(const void **)b, v2);\n  if ( i )\n    return i;\n  else\n    return *((_DWORD *)a + 2) - *((_DWORD *)b + 2);\n}\n\n\n Revised code:\nstatic int der_cmp(const void *a, const void *b)\n{\n    const DER_ENC *d1 = a, *d2 = b;\n    int cmplen, i;\n    cmplen = (d1->length < d2->length) ? d1->length : d2->length;\n    i = memcmp(d1->data, d2->data, cmplen);\n    if (i)\n        return i;\n    return d1->length - d2->length;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_DWORD *__fastcall sub_4F76DC(__int64 a1, __int64 a2)\n{\n  _DWORD *result; // rax\n\n  result = sub_40A0E8(0x58uLL, a2);\n  result[2] = -1;\n  *((_BYTE *)result + 12) = 2;\n  *((_BYTE *)result + 70) = 1;\n  return result;\n}\n",
        "output": "```c\nstatic unsigned int *sub_4F76DC(long a1, long a2)\n{\n    unsigned int *result;\n\n    result = sub_40A0E8(88, a2);\n    result[2] = -1;\n    result[3] = 2;\n    result[17] = 1;\n    return result;\n}\n```",
        "source_code": "FAST_FUNC alloc_dumper(void)\n{\n\tpriv_dumper_t *dumper = xzalloc(sizeof(*dumper));\n\tdumper->pub.dump_length = -1;\n\tdumper->pub.dump_vflag = FIRST;\n\tdumper->get__ateof = 1;\n\treturn &dumper->pub;\n}",
        "parsed_output": "static unsigned int *sub_4F76DC(long a1, long a2)\n{\n    unsigned int *result;\n\n    result = sub_40A0E8(88, a2);\n    result[2] = -1;\n    result[3] = 2;\n    result[17] = 1;\n    return result;\n}",
        "baseline_code_stripped": "_DWORD *__fastcall sub_4F76DC(__int64 a1, __int64 a2)\n{\n  _DWORD *result; // rax\n\n  result = sub_40A0E8(0x58uLL, a2);\n  result[2] = -1;\n  *((_BYTE *)result + 12) = 2;\n  *((_BYTE *)result + 70) = 1;\n  return result;\n}\n",
        "baseline_code_debug": "dumper_t_0 *__cdecl alloc_dumper()\n{\n  dumper_t_0 *result; // rax\n\n  result = (dumper_t_0 *)xzalloc(0x58uLL);\n  result->dump_length = -1;\n  result->dump_vflag = 2;\n  BYTE6(result[2].fshead) = 1;\n  return result;\n}\n",
        "similarity_score_unixcoder": 0.41991594433784485,
        "similarity_score_baseline_stripped": 0.43467000126838684,
        "similarity_score_baseline_debug": 0.7627012729644775
    },
    {
        "func_name": "set_shell",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\n__int64 __cdecl fd_ctrl(BIO *b, int cmd, __int64 num, void *ptr)\n{\n  __int64 numa; // [rsp+8h] [rbp-28h]\n  __int64 ret; // [rsp+28h] [rbp-8h]\n\n  numa = num;\n  ret = 1LL;\n  if ( cmd <= 12 )\n  {\n    if ( cmd >= 11 )\n      return 1LL;\n    if ( cmd == 8 )\n      return b->shutdown;\n    if ( cmd <= 8 )\n    {\n      if ( cmd != 1 )\n      {\n        if ( cmd != 3 )\n          return 0LL;\n        return lseek(b->num, 0LL, 1);\n      }\n      numa = 0LL;\n      return lseek(b->num, numa, 0);\n    }\n    if ( cmd == 9 )\n    {\n      b->shutdown = num;\n      return ret;\n    }\n    return 0LL;\n  }\n  if ( cmd == 105 )\n  {\n    if ( b->init )\n    {\n      if ( ptr )\n        *(_DWORD *)ptr = b->num;\n      return b->num;\n    }\n    else\n    {\n      return -1LL;\n    }\n  }\n  else\n  {\n    if ( cmd > 105 )\n    {\n      if ( cmd != 128 )\n      {\n        if ( cmd != 133 )\n          return 0LL;\n        return lseek(b->num, 0LL, 1);\n      }\n      return lseek(b->num, numa, 0);\n    }\n    if ( cmd == 13 )\n      return 0LL;\n    if ( cmd != 104 )\n      return 0LL;\n    fd_free(b);\n    b->num = *(_DWORD *)ptr;\n    b->shutdown = numa;\n    b->init = 1;\n  }\n  return ret;\n}\n\n\n Revised code:\nstatic long fd_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    long ret = 1;\n    int *ip;\n\n    switch (cmd) {\n    case BIO_CTRL_RESET:\n        num = 0;\n    case BIO_C_FILE_SEEK:\n        ret = (long)UP_lseek(b->num, num, 0);\n        break;\n    case BIO_C_FILE_TELL:\n    case BIO_CTRL_INFO:\n        ret = (long)UP_lseek(b->num, 0, 1);\n        break;\n    case BIO_C_SET_FD:\n        fd_free(b);\n        b->num = *((int *)ptr);\n        b->shutdown = (int)num;\n        b->init = 1;\n        break;\n    case BIO_C_GET_FD:\n        if (b->init) {\n            ip = (int *)ptr;\n            if (ip != NULL)\n                *ip = b->num;\n            ret = b->num;\n        } else\n            ret = -1;\n        break;\n    case BIO_CTRL_GET_CLOSE:\n        ret = b->shutdown;\n        break;\n    case BIO_CTRL_SET_CLOSE:\n        b->shutdown = (int)num;\n        break;\n    case BIO_CTRL_PENDING:\n    case BIO_CTRL_WPENDING:\n        ret = 0;\n        break;\n    case BIO_CTRL_DUP:\n    case BIO_CTRL_FLUSH:\n        ret = 1;\n        break;\n    default:\n        ret = 0;\n        break;\n    }\n    return (ret);\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_499ADE(const char *a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  int v5; // eax\n\n  if ( strcmp(a1, \"bash\") && strcmp(a1, \"sh\") )\n  {\n    if ( !strcmp(a1, \"tcsh\") || !strcmp(a1, \"csh\") )\n    {\n      v5 = dword_75D450;\n      BYTE1(v5) = BYTE1(dword_75D450) | 0x80;\n      dword_75D450 = v5;\n    }\n    else\n    {\n      sub_409747(\"unknown shell '%s', assuming bash\", (__int64)a1, v1, v2, v3, v4);\n    }\n  }\n}\n",
        "output": "```c\nvoid set_shell_mode(const char *shell)\n{\n    if (strcmp(shell, \"bash\") != 0 && strcmp(shell, \"sh\") != 0) {\n        if (strcmp(shell, \"tcsh\") == 0 || strcmp(shell, \"csh\") == 0) {\n            // Set a specific flag in the global variable when using tcsh or csh\n            dword_75D450 |= 0x8000;\n        } else {\n            // Log an error message if the shell is unknown, assuming bash\n            log_error(\"unknown shell '%s', assuming bash\", shell);\n        }\n    }\n}\n```",
        "source_code": "endif\n\nstatic void set_shell(const char *new_shell)\n{\n\tif (!strcmp(new_shell, \"bash\") || !strcmp(new_shell, \"sh\"))\n\t\treturn;\n\tif (!strcmp(new_shell, \"tcsh\") || !strcmp(new_shell, \"csh\"))\n\t\toption_mask32 |= SHELL_IS_TCSH;\n\telse\n\t\tbb_error_msg(\"unknown shell '%s', assuming bash\", new_shell);\n}",
        "parsed_output": "void set_shell_mode(const char *shell)\n{\n    if (strcmp(shell, \"bash\") != 0 && strcmp(shell, \"sh\") != 0) {\n        if (strcmp(shell, \"tcsh\") == 0 || strcmp(shell, \"csh\") == 0) {\n            // Set a specific flag in the global variable when using tcsh or csh\n            dword_75D450 |= 0x8000;\n        } else {\n            // Log an error message if the shell is unknown, assuming bash\n            log_error(\"unknown shell '%s', assuming bash\", shell);\n        }\n    }\n}",
        "baseline_code_stripped": "void __fastcall sub_499ADE(const char *a1)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  int v5; // eax\n\n  if ( strcmp(a1, \"bash\") && strcmp(a1, \"sh\") )\n  {\n    if ( !strcmp(a1, \"tcsh\") || !strcmp(a1, \"csh\") )\n    {\n      v5 = dword_75D450;\n      BYTE1(v5) = BYTE1(dword_75D450) | 0x80;\n      dword_75D450 = v5;\n    }\n    else\n    {\n      sub_409747(\"unknown shell '%s', assuming bash\", (__int64)a1, v1, v2, v3, v4);\n    }\n  }\n}\n",
        "baseline_code_debug": "void __cdecl set_shell(const char *new_shell)\n{\n  uint32_t v1; // eax\n\n  if ( strcmp(new_shell, \"bash\") && strcmp(new_shell, \"sh\") )\n  {\n    if ( !strcmp(new_shell, \"tcsh\") || !strcmp(new_shell, \"csh\") )\n    {\n      v1 = option_mask32;\n      BYTE1(v1) = BYTE1(option_mask32) | 0x80;\n      option_mask32 = v1;\n    }\n    else\n    {\n      bb_error_msg(\"unknown shell '%s', assuming bash\", new_shell);\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.8332570195198059,
        "similarity_score_baseline_stripped": 0.6911394596099854,
        "similarity_score_baseline_debug": 0.88873291015625
    },
    {
        "func_name": "restore_state_and_exit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl noecho_console(UI *ui)\n{\n  int v1; // eax\n  int result; // eax\n\n  tty_new = tty_orig;\n  tty_new.c_lflag = tty_orig.c_lflag & 0xFFF7;\n  result = 1;\n  if ( is_a_tty )\n  {\n    v1 = fileno(tty_in);\n    if ( ioctl(v1, 0x5406uLL, &tty_new) == -1 )\n      return 0;\n  }\n  return result;\n}\n\n\n Revised code:\nstatic int noecho_console(UI *ui)\n{\n#ifdef TTY_FLAGS\n    memcpy(&(tty_new), &(tty_orig), sizeof(tty_orig));\n    tty_new.TTY_FLAGS &= ~ECHO;\n#endif\n\n#if defined(TTY_set) && !defined(OPENSSL_SYS_VMS)\n    if (is_a_tty && (TTY_set(fileno(tty_in), &tty_new) == -1))\n        return 0;\n#endif\n#ifdef OPENSSL_SYS_VMS\n    tty_new[0] = tty_orig[0];\n    tty_new[1] = tty_orig[1] | TT$M_NOECHO;\n    tty_new[2] = tty_orig[2];\n    status =\n        sys$qiow(0, channel, IO$_SETMODE, &iosb, 0, 0, tty_new, 12, 0, 0, 0,\n                 0);\n    if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))\n        return 0;\n#endif\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl open_console(UI *ui)\n{\n  int v1; // eax\n\n  CRYPTO_lock(9, 31, \"ui_openssl.c\", 484);\n  is_a_tty = 1;\n  tty_in = fopen(\"/dev/tty\", \"r\");\n  if ( !tty_in )\n    tty_in = stdin;\n  tty_out = fopen(\"/dev/tty\", \"w\");\n  if ( !tty_out )\n    tty_out = stderr;\n  v1 = fileno(tty_in);\n  if ( ioctl(v1, 0x5405uLL, &tty_orig) == -1 )\n  {\n    if ( *__errno_location() == 25 )\n    {\n      is_a_tty = 0;\n    }\n    else\n    {\n      if ( *__errno_location() != 22 )\n        return 0;\n      is_a_tty = 0;\n    }\n  }\n  return 1;\n}\n\n\n Revised code:\nstatic int open_console(UI *ui)\n{\n    CRYPTO_w_lock(CRYPTO_LOCK_UI);\n    is_a_tty = 1;\n\n#if defined(OPENSSL_SYS_MACINTOSH_CLASSIC) || defined(OPENSSL_SYS_VXWORKS) || defined(OPENSSL_SYS_NETWARE) || defined(OPENSSL_SYS_BEOS)\n    tty_in = stdin;\n    tty_out = stderr;\n#else\n# ifdef OPENSSL_SYS_MSDOS\n#  define DEV_TTY \"con\"\n# else\n#  define DEV_TTY \"/dev/tty\"\n# endif\n    if ((tty_in = fopen(DEV_TTY, \"r\")) == NULL)\n        tty_in = stdin;\n    if ((tty_out = fopen(DEV_TTY, \"w\")) == NULL)\n        tty_out = stderr;\n#endif\n\n#if defined(TTY_get) && !defined(OPENSSL_SYS_VMS)\n    if (TTY_get(fileno(tty_in), &tty_orig) == -1) {\n# ifdef ENOTTY\n        if (errno == ENOTTY)\n            is_a_tty = 0;\n        else\n# endif\n# ifdef EINVAL\n            /*\n             * Ariel Glenn ariel@columbia.edu reports that solaris can return\n             * EINVAL instead.  This should be ok\n             */\n        if (errno == EINVAL)\n            is_a_tty = 0;\n        else\n# endif\n            return 0;\n    }\n#endif\n#ifdef OPENSSL_SYS_VMS\n    status = sys$assign(&terminal, &channel, 0, 0);\n    if (status != SS$_NORMAL)\n        return 0;\n    status =\n        sys$qiow(0, channel, IO$_SENSEMODE, &iosb, 0, 0, tty_orig, 12, 0, 0,\n                 0, 0);\n    if ((status != SS$_NORMAL) || (iosb.iosb$w_value != SS$_NORMAL))\n        return 0;\n#endif\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl dgram_adjust_rcv_timeout(BIO *b)\n{\n  __suseconds_t tv_usec; // rdx\n  timeval timeleft; // [rsp+10h] [rbp-30h] BYREF\n  timeval timenow; // [rsp+20h] [rbp-20h] BYREF\n  dgram_adjust_rcv_timeout::$501C32854E4BEFE2951E5304B55857B5 sz; // [rsp+30h] [rbp-10h] BYREF\n  bio_dgram_data *data; // [rsp+38h] [rbp-8h]\n\n  data = (bio_dgram_data *)b->ptr;\n  sz.s = 0LL;\n  if ( data->next_timeout.tv_sec > 0 || data->next_timeout.tv_usec > 0 )\n  {\n    sz.i = 16;\n    if ( getsockopt(b->num, 1, 20, &data->socket_timeout, (socklen_t *)&sz) >= 0 )\n    {\n      if ( !sz.i && sz.s > 0x10 )\n        OpenSSLDie(\"bss_dgram.c\", 294, \"sz.s<=sizeof(data->socket_timeout)\");\n    }\n    else\n    {\n      perror(\"getsockopt\");\n    }\n    get_current_time(&timenow);\n    tv_usec = data->next_timeout.tv_usec;\n    timeleft.tv_sec = data->next_timeout.tv_sec - timenow.tv_sec;\n    timeleft.tv_usec = tv_usec - timenow.tv_usec;\n    if ( tv_usec - timenow.tv_usec < 0 )\n    {\n      --timeleft.tv_sec;\n      timeleft.tv_usec += 1000000LL;\n    }\n    if ( timeleft.tv_sec < 0 )\n    {\n      timeleft.tv_sec = 0LL;\n      timeleft.tv_usec = 1LL;\n    }\n    if ( (!data->socket_timeout.tv_sec && !data->socket_timeout.tv_usec\n       || data->socket_timeout.tv_sec > timeleft.tv_sec\n       || data->socket_timeout.tv_sec == timeleft.tv_sec && data->socket_timeout.tv_usec >= timeleft.tv_usec)\n      && setsockopt(b->num, 1, 20, &timeleft, 0x10u) < 0 )\n    {\n      perror(\"setsockopt\");\n    }\n  }\n}\n\n\n Revised code:\nstatic void dgram_adjust_rcv_timeout(BIO *b)\n{\n# if defined(SO_RCVTIMEO)\n    bio_dgram_data *data = (bio_dgram_data *)b->ptr;\n    union {\n        size_t s;\n        int i;\n    } sz = {\n        0\n    };\n\n    /* Is a timer active? */\n    if (data->next_timeout.tv_sec > 0 || data->next_timeout.tv_usec > 0) {\n        struct timeval timenow, timeleft;\n\n        /* Read current socket timeout */\n#  ifdef OPENSSL_SYS_WINDOWS\n        int timeout;\n\n        sz.i = sizeof(timeout);\n        if (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,\n                       (void *)&timeout, &sz.i) < 0) {\n            perror(\"getsockopt\");\n        } else {\n            data->socket_timeout.tv_sec = timeout / 1000;\n            data->socket_timeout.tv_usec = (timeout % 1000) * 1000;\n        }\n#  else\n        sz.i = sizeof(data->socket_timeout);\n        if (getsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,\n                       &(data->socket_timeout), (void *)&sz) < 0) {\n            perror(\"getsockopt\");\n        } else if (sizeof(sz.s) != sizeof(sz.i) && sz.i == 0)\n            OPENSSL_assert(sz.s <= sizeof(data->socket_timeout));\n#  endif\n\n        /* Get current time */\n        get_current_time(&timenow);\n\n        /* Calculate time left until timer expires */\n        memcpy(&timeleft, &(data->next_timeout), sizeof(struct timeval));\n        if (timeleft.tv_usec < timenow.tv_usec) {\n            timeleft.tv_usec = 1000000 - timenow.tv_usec + timeleft.tv_usec;\n            timeleft.tv_sec--;\n        } else {\n            timeleft.tv_usec -= timenow.tv_usec;\n        }\n        if (timeleft.tv_sec < timenow.tv_sec) {\n            timeleft.tv_sec = 0;\n            timeleft.tv_usec = 1;\n        } else {\n            timeleft.tv_sec -= timenow.tv_sec;\n        }\n\n        /*\n         * Adjust socket timeout if next handhake message timer will expire\n         * earlier.\n         */\n        if ((data->socket_timeout.tv_sec == 0\n             && data->socket_timeout.tv_usec == 0)\n            || (data->socket_timeout.tv_sec > timeleft.tv_sec)\n            || (data->socket_timeout.tv_sec == timeleft.tv_sec\n                && data->socket_timeout.tv_usec >= timeleft.tv_usec)) {\n#  ifdef OPENSSL_SYS_WINDOWS\n            timeout = timeleft.tv_sec * 1000 + timeleft.tv_usec / 1000;\n            if (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO,\n                           (void *)&timeout, sizeof(timeout)) < 0) {\n                perror(\"setsockopt\");\n            }\n#  else\n            if (setsockopt(b->num, SOL_SOCKET, SO_RCVTIMEO, &timeleft,\n                           sizeof(struct timeval)) < 0) {\n                perror(\"setsockopt\");\n            }\n#  endif\n        }\n    }\n# endif\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall __noreturn sub_44076F(int a1)\n{\n  __int64 v1; // rcx\n  __int64 v2; // rcx\n  __int64 v3; // rcx\n  struct termios termios_p; // [rsp+10h] [rbp-40h] BYREF\n\n  if ( (int)sub_40AD08(dest.c_iflag, 0x5423u, 7713788LL, (__int64)\"TIOCSETD\") < 0 )\n    a1 = 1;\n  v1 = *(_QWORD *)&dest.c_line;\n  *(_QWORD *)&termios_p.c_iflag = *(_QWORD *)&dest.c_cflag;\n  *(_QWORD *)&termios_p.c_cflag = v1;\n  v2 = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&termios_p.c_line = *(_QWORD *)&dest.c_cc[7];\n  *(_QWORD *)&termios_p.c_cc[7] = v2;\n  v3 = *(_QWORD *)&dest.c_cc[31];\n  *(_QWORD *)&termios_p.c_cc[15] = *(_QWORD *)&dest.c_cc[23];\n  *(_QWORD *)&termios_p.c_cc[23] = v3;\n  *(_QWORD *)&termios_p.c_cc[31] = *(_QWORD *)&dest.c_ospeed;\n  termios_p.c_ospeed = *((_DWORD *)&dest + 16);\n  cfsetispeed(&termios_p, 0);\n  cfsetospeed(&termios_p, 0);\n  if ( (unsigned int)sub_440726(&termios_p) )\n    a1 = 1;\n  sleep(1u);\n  if ( (unsigned int)sub_440726((const struct termios *)&dest.c_cflag) )\n    exit(1);\n  exit(a1);\n}\n",
        "output": "```c\nstatic void sub_44076F(int exit_code)\n{\n    struct termios termios_p;\n\n    if (sub_40AD08(dest.c_iflag, TIOCSETD, \"TIOCSETD\") < 0)\n        exit_code = 1;\n\n    // Copying termios settings from 'dest' to 'termios_p' with rearranged fields\n    memcpy(&termios_p, &dest, sizeof(struct termios));\n    termios_p.c_iflag = dest.c_cflag;\n    termios_p.c_cflag = dest.c_line;\n    memcpy(&termios_p.c_line, &dest.c_cc[7], sizeof(dest.c_cc) - 7);\n    termios_p.c_ospeed = dest.c_ispeed;\n\n    // Set input and output baud rate to 0\n    cfsetispeed(&termios_p, B0);\n    cfsetospeed(&termios_p, B0);\n\n    // Attempt to apply the new settings\n    if (sub_440726(&termios_p))\n        exit_code = 1;\n\n    sleep(1);\n\n    // Attempt to revert to the original settings\n    if (sub_440726((const struct termios *)&dest.c_cflag))\n        exit(1);\n\n    exit(exit_code);\n}\n```",
        "source_code": "static void restore_state_and_exit(int exitcode)\n{\n\tstruct termios state;\n\n\t/* Restore line discipline */\n\tif (ioctl_or_warn(handle, TIOCSETD, &saved_disc) < 0) {\n\t\texitcode = 1;\n\t}\n\n\t/* Hangup */\n\tmemcpy(&state, &saved_state, sizeof(state));\n\tcfsetispeed(&state, B0);\n\tcfsetospeed(&state, B0);\n\tif (set_termios_state_or_warn(&state))\n\t\texitcode = 1;\n\tsleep(1);\n\n\t/* Restore line status */\n\tif (set_termios_state_or_warn(&saved_state))\n\t\texit(EXIT_FAILURE);\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tclose(handle);\n\n\texit(exitcode);\n}",
        "parsed_output": "static void sub_44076F(int exit_code)\n{\n    struct termios termios_p;\n\n    if (sub_40AD08(dest.c_iflag, TIOCSETD, \"TIOCSETD\") < 0)\n        exit_code = 1;\n\n    // Copying termios settings from 'dest' to 'termios_p' with rearranged fields\n    memcpy(&termios_p, &dest, sizeof(struct termios));\n    termios_p.c_iflag = dest.c_cflag;\n    termios_p.c_cflag = dest.c_line;\n    memcpy(&termios_p.c_line, &dest.c_cc[7], sizeof(dest.c_cc) - 7);\n    termios_p.c_ospeed = dest.c_ispeed;\n\n    // Set input and output baud rate to 0\n    cfsetispeed(&termios_p, B0);\n    cfsetospeed(&termios_p, B0);\n\n    // Attempt to apply the new settings\n    if (sub_440726(&termios_p))\n        exit_code = 1;\n\n    sleep(1);\n\n    // Attempt to revert to the original settings\n    if (sub_440726((const struct termios *)&dest.c_cflag))\n        exit(1);\n\n    exit(exit_code);\n}",
        "baseline_code_stripped": "void __fastcall __noreturn sub_44076F(int a1)\n{\n  __int64 v1; // rcx\n  __int64 v2; // rcx\n  __int64 v3; // rcx\n  struct termios termios_p; // [rsp+10h] [rbp-40h] BYREF\n\n  if ( (int)sub_40AD08(dest.c_iflag, 0x5423u, 7713788LL, (__int64)\"TIOCSETD\") < 0 )\n    a1 = 1;\n  v1 = *(_QWORD *)&dest.c_line;\n  *(_QWORD *)&termios_p.c_iflag = *(_QWORD *)&dest.c_cflag;\n  *(_QWORD *)&termios_p.c_cflag = v1;\n  v2 = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&termios_p.c_line = *(_QWORD *)&dest.c_cc[7];\n  *(_QWORD *)&termios_p.c_cc[7] = v2;\n  v3 = *(_QWORD *)&dest.c_cc[31];\n  *(_QWORD *)&termios_p.c_cc[15] = *(_QWORD *)&dest.c_cc[23];\n  *(_QWORD *)&termios_p.c_cc[23] = v3;\n  *(_QWORD *)&termios_p.c_cc[31] = *(_QWORD *)&dest.c_ospeed;\n  termios_p.c_ospeed = *((_DWORD *)&dest + 16);\n  cfsetispeed(&termios_p, 0);\n  cfsetospeed(&termios_p, 0);\n  if ( (unsigned int)sub_440726(&termios_p) )\n    a1 = 1;\n  sleep(1u);\n  if ( (unsigned int)sub_440726((const struct termios *)&dest.c_cflag) )\n    exit(1);\n  exit(a1);\n}\n",
        "baseline_code_debug": "void __cdecl __noreturn restore_state_and_exit(int exitcode)\n{\n  termios state; // [rsp+10h] [rbp-40h] BYREF\n\n  if ( bb_ioctl_or_warn(bb_common_bufsiz1.c_iflag, 0x5423u, &bb_common_bufsiz1.c_oflag, \"TIOCSETD\") < 0 )\n    exitcode = 1;\n  *(_QWORD *)&state.c_iflag = *(_QWORD *)&bb_common_bufsiz1.c_cflag;\n  *(_QWORD *)&state.c_cflag = *(_QWORD *)&bb_common_bufsiz1.c_line;\n  *(_QWORD *)&state.c_line = *(_QWORD *)&bb_common_bufsiz1.c_cc[7];\n  *(_QWORD *)&state.c_cc[7] = *(_QWORD *)&bb_common_bufsiz1.c_cc[15];\n  *(_QWORD *)&state.c_cc[15] = *(_QWORD *)&bb_common_bufsiz1.c_cc[23];\n  *(_QWORD *)&state.c_cc[23] = *(_QWORD *)&bb_common_bufsiz1.c_cc[31];\n  *(_QWORD *)&state.c_cc[31] = *(_QWORD *)&bb_common_bufsiz1.c_ospeed;\n  state.c_ospeed = dst.data[0];\n  cfsetispeed(&state, 0);\n  cfsetospeed(&state, 0);\n  if ( set_termios_state_or_warn(&state) )\n    exitcode = 1;\n  sleep(1u);\n  if ( set_termios_state_or_warn((termios *)&bb_common_bufsiz1.c_cflag) )\n    exit(1);\n  exit(exitcode);\n}\n",
        "similarity_score_unixcoder": 0.7158139944076538,
        "similarity_score_baseline_stripped": 0.5837101936340332,
        "similarity_score_baseline_debug": 0.7493524551391602
    },
    {
        "func_name": "pick_sighandler",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl make_kn(unsigned __int8 *k1_0, unsigned __int8 *l, int bl_0)\n{\n  unsigned __int8 v3; // dl\n  char v4; // al\n  int i; // [rsp+20h] [rbp-4h]\n\n  for ( i = 0; i < bl_0; ++i )\n  {\n    k1_0[i] = 2 * l[i];\n    if ( i < bl_0 - 1 && (l[i + 1] & 0x80u) != 0 )\n      k1_0[i] |= 1u;\n  }\n  if ( (*l & 0x80u) != 0 )\n  {\n    v3 = k1_0[bl_0 - 1];\n    if ( bl_0 == 16 )\n      v4 = -121;\n    else\n      v4 = 27;\n    k1_0[bl_0 - 1] = v3 ^ v4;\n  }\n}\n\n\n Revised code:\nstatic void make_kn(unsigned char *k1, unsigned char *l, int bl)\n{\n    int i;\n    /* Shift block to left, including carry */\n    for (i = 0; i < bl; i++) {\n        k1[i] = l[i] << 1;\n        if (i < bl - 1 && l[i + 1] & 0x80)\n            k1[i] |= 1;\n    }\n    /* If MSB set fixup with R */\n    if (l[0] & 0x80)\n        k1[bl - 1] ^= bl == 16 ? 0x87 : 0x1b;\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid (__fastcall __noreturn *__fastcall sub_4803D0(unsigned int a1))(int a1)\n{\n  int v2; // [rsp+8h] [rbp-Ch]\n  int (__fastcall *v3)(int); // [rsp+Ch] [rbp-8h]\n\n  v3 = 0LL;\n  if ( a1 <= 0x1F )\n  {\n    v2 = 1 << a1;\n    if ( ((1 << a1) & *((_DWORD *)qword_75D408 + 40)) != 0 )\n    {\n      return sub_480360;\n    }\n    else if ( (v2 & *((_DWORD *)qword_75D408 + 39)) != 0 )\n    {\n      v3 = sub_4802DC;\n      if ( (v2 & 0x700000) != 0 )\n        return (void (__fastcall __noreturn *)(int))1;\n    }\n  }\n  return (void (__fastcall __noreturn *)(int))v3;\n}\n",
        "output": "```c\nstatic void (__fastcall *__fastcall sub_4803D0(unsigned int a1))(int)\n{\n    void (__fastcall *result)(int) = NULL;\n    unsigned int mask;\n\n    if (a1 <= 0x1F) {\n        mask = 1 << a1;\n        if ((mask & *((unsigned int *)qword_75D408 + 40)) != 0) {\n            return sub_480360;\n        } else if ((mask & *((unsigned int *)qword_75D408 + 39)) != 0) {\n            result = sub_4802DC;\n            if ((mask & 0x700000) != 0)\n                return (void (__fastcall *)(int))1;\n        }\n    }\n    return result;\n}\n```",
        "source_code": "endif\n\nstatic sighandler_t pick_sighandler(unsigned sig)\n{\n\tsighandler_t handler = SIG_DFL;\n\tif (sig < sizeof(unsigned)*8) {\n\t\tunsigned sigmask = (1 << sig);\n\n#if ENABLE_HUSH_JOB\n\t\t/* is sig fatal? */\n\t\tif (G_fatal_sig_mask & sigmask)\n\t\t\thandler = sigexit;\n\t\telse\n#endif\n\t\t/* sig has special handling? */\n\t\tif (G.special_sig_mask & sigmask) {\n\t\t\thandler = record_pending_signo;\n\t\t\t/* TTIN/TTOU/TSTP can't be set to record_pending_signo\n\t\t\t * in order to ignore them: they will be raised\n\t\t\t * in an endless loop when we try to do some\n\t\t\t * terminal ioctls! We do have to _ignore_ these.\n\t\t\t */\n\t\t\tif (SPECIAL_JOBSTOP_SIGS & sigmask)\n\t\t\t\thandler = SIG_IGN;\n\t\t}\n\t}\n\treturn handler;\n}",
        "parsed_output": "static void (__fastcall *__fastcall sub_4803D0(unsigned int a1))(int)\n{\n    void (__fastcall *result)(int) = NULL;\n    unsigned int mask;\n\n    if (a1 <= 0x1F) {\n        mask = 1 << a1;\n        if ((mask & *((unsigned int *)qword_75D408 + 40)) != 0) {\n            return sub_480360;\n        } else if ((mask & *((unsigned int *)qword_75D408 + 39)) != 0) {\n            result = sub_4802DC;\n            if ((mask & 0x700000) != 0)\n                return (void (__fastcall *)(int))1;\n        }\n    }\n    return result;\n}",
        "baseline_code_stripped": "void (__fastcall __noreturn *__fastcall sub_4803D0(unsigned int a1))(int a1)\n{\n  int v2; // [rsp+8h] [rbp-Ch]\n  int (__fastcall *v3)(int); // [rsp+Ch] [rbp-8h]\n\n  v3 = 0LL;\n  if ( a1 <= 0x1F )\n  {\n    v2 = 1 << a1;\n    if ( ((1 << a1) & *((_DWORD *)qword_75D408 + 40)) != 0 )\n    {\n      return sub_480360;\n    }\n    else if ( (v2 & *((_DWORD *)qword_75D408 + 39)) != 0 )\n    {\n      v3 = sub_4802DC;\n      if ( (v2 & 0x700000) != 0 )\n        return (void (__fastcall __noreturn *)(int))1;\n    }\n  }\n  return (void (__fastcall __noreturn *)(int))v3;\n}\n",
        "baseline_code_debug": "sighandler_t __cdecl pick_sighandler(unsigned int sig)\n{\n  unsigned int sigmask; // [rsp+8h] [rbp-Ch]\n  void (*handler)(int); // [rsp+Ch] [rbp-8h]\n\n  handler = 0LL;\n  if ( sig <= 0x1F )\n  {\n    sigmask = 1 << sig;\n    if ( ((1 << sig) & *(_DWORD *)&ptr_to_globals->line_buf[4]) != 0 )\n    {\n      return (sighandler_t)sigexit;\n    }\n    else if ( (sigmask & *(_DWORD *)ptr_to_globals->line_buf) != 0 )\n    {\n      handler = (void (*)(int))record_pending_signo;\n      if ( (sigmask & 0x700000) != 0 )\n        return (sighandler_t)1;\n    }\n  }\n  return handler;\n}\n",
        "similarity_score_unixcoder": 0.43110790848731995,
        "similarity_score_baseline_stripped": 0.470350444316864,
        "similarity_score_baseline_debug": 0.8141953349113464
    },
    {
        "func_name": "new_group",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n\n## Example:\n\n Input code:\nint __cdecl ipv4_from_asc(unsigned __int8 *v4, const char *in)\n{\n  int a3; // [rsp+10h] [rbp-10h] BYREF\n  int a2; // [rsp+14h] [rbp-Ch] BYREF\n  int a1; // [rsp+18h] [rbp-8h] BYREF\n  int a0; // [rsp+1Ch] [rbp-4h] BYREF\n\n  if ( (unsigned int)__isoc99_sscanf(in, \"%d.%d.%d.%d\", &a0, &a1, &a2, &a3) != 4 )\n    return 0;\n  if ( (unsigned int)a0 > 0xFF || (unsigned int)a1 > 0xFF || (unsigned int)a2 > 0xFF || (unsigned int)a3 >= 0x100 )\n    return 0;\n  *v4 = a0;\n  v4[1] = a1;\n  v4[2] = a2;\n  v4[3] = a3;\n  return 1;\n}\n\n\n Revised code:\nstatic int ipv4_from_asc(unsigned char *v4, const char *in)\n{\n    int a0, a1, a2, a3;\n    if (sscanf(in, \"%d.%d.%d.%d\", &a0, &a1, &a2, &a3) != 4)\n        return 0;\n    if ((a0 < 0) || (a0 > 255) || (a1 < 0) || (a1 > 255)\n        || (a2 < 0) || (a2 > 255) || (a3 < 0) || (a3 > 255))\n        return 0;\n    v4[0] = a0;\n    v4[1] = a1;\n    v4[2] = a2;\n    v4[3] = a3;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40D471(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v7; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v8; // [rsp+20h] [rbp-20h]\n  char *v9; // [rsp+38h] [rbp-8h]\n\n  v8 = a2;\n  v7 = a1;\n  sub_40D371((__int64)&v7, a2);\n  v9 = sub_40A6B3(\"x:%u:\", v8, v2, v3, v4, v5);\n  if ( (int)sub_50967B(\"/etc/group\", a1, v9, 0LL) < 0 )\n    exit(1);\n  return sub_50967B(\"/etc/gshadow\", a1, \"!::\", 0LL);\n}\n",
        "output": "```c\nint update_group_and_gshadow_files(long group_id, long group_name)\n{\n    unsigned int group_name_length;\n    char *group_entry_format;\n    long group_info[2];\n\n    group_name_length = group_name;\n    group_info[0] = group_id;\n    group_info[1] = group_name_length;\n\n    // Prepare the group entry\n    prepare_group_entry(group_info, group_name_length);\n\n    // Format the group entry string\n    group_entry_format = format_group_entry(\"x:%u:\", group_name_length);\n\n    // Update /etc/group file with the new group entry\n    if (update_file(\"/etc/group\", group_id, group_entry_format, 0) < 0)\n        exit(1); // Exit if updating /etc/group fails\n\n    // Update /etc/gshadow file with the new group entry\n    return update_file(\"/etc/gshadow\", group_id, \"!::\", 0);\n}\n```",
        "source_code": "static void new_group(char *group, gid_t gid)\n{\n\tstruct group gr;\n\tchar *p;\n\n\t/* make sure gid and group haven't already been allocated */\n\tgr.gr_gid = gid;\n\tgr.gr_name = group;\n\txgroup_study(&gr);\n\n\t/* add entry to group */\n\tp = xasprintf(\"x:%u:\", (unsigned) gr.gr_gid);\n\tif (update_passwd(bb_path_group_file, group, p, NULL) < 0)\n\t\texit(EXIT_FAILURE);\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tfree(p);\n#if ENABLE_FEATURE_SHADOWPASSWDS\n\t/* /etc/gshadow fields:\n\t * 1. Group name.\n\t * 2. Encrypted password.\n\t *    If set, non-members of the group can join the group\n\t *    by typing the password for that group using the newgrp command.\n\t *    If the value is of this field ! then no user is allowed\n\t *    to access the group using the newgrp command. A value of !!\n\t *    is treated the same as a value of ! only it indicates\n\t *    that a password has never been set before. If the value is null,\n\t *    only group members can log into the group.\n\t * 3. Group administrators (comma delimited list).\n\t *    Group members listed here can add or remove group members\n\t *    using the gpasswd command.\n\t * 4. Group members (comma delimited list).\n\t */\n\t/* Ignore errors: if file is missing we assume admin doesn't want it */\n\tupdate_passwd(bb_path_gshadow_file, group, \"!::\", NULL);\n#endif\n}",
        "parsed_output": "int update_group_and_gshadow_files(long group_id, long group_name)\n{\n    unsigned int group_name_length;\n    char *group_entry_format;\n    long group_info[2];\n\n    group_name_length = group_name;\n    group_info[0] = group_id;\n    group_info[1] = group_name_length;\n\n    // Prepare the group entry\n    prepare_group_entry(group_info, group_name_length);\n\n    // Format the group entry string\n    group_entry_format = format_group_entry(\"x:%u:\", group_name_length);\n\n    // Update /etc/group file with the new group entry\n    if (update_file(\"/etc/group\", group_id, group_entry_format, 0) < 0)\n        exit(1); // Exit if updating /etc/group fails\n\n    // Update /etc/gshadow file with the new group entry\n    return update_file(\"/etc/gshadow\", group_id, \"!::\", 0);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40D471(__int64 a1, __int64 a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v7; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v8; // [rsp+20h] [rbp-20h]\n  char *v9; // [rsp+38h] [rbp-8h]\n\n  v8 = a2;\n  v7 = a1;\n  sub_40D371((__int64)&v7, a2);\n  v9 = sub_40A6B3(\"x:%u:\", v8, v2, v3, v4, v5);\n  if ( (int)sub_50967B(\"/etc/group\", a1, v9, 0LL) < 0 )\n    exit(1);\n  return sub_50967B(\"/etc/gshadow\", a1, \"!::\", 0LL);\n}\n",
        "baseline_code_debug": "void __cdecl new_group(char *group, gid_t gid)\n{\n  group gr; // [rsp+10h] [rbp-30h] BYREF\n  char *p; // [rsp+38h] [rbp-8h]\n\n  gr.gr_gid = gid;\n  gr.gr_name = group;\n  xgroup_study(&gr);\n  p = xasprintf(\"x:%u:\", gr.gr_gid);\n  if ( update_passwd(\"/etc/group\", group, p, 0LL) < 0 )\n    exit(1);\n  update_passwd(\"/etc/gshadow\", group, \"!::\", 0LL);\n}\n",
        "similarity_score_unixcoder": 0.7636374235153198,
        "similarity_score_baseline_stripped": 0.5368414521217346,
        "similarity_score_baseline_debug": 0.8370885252952576
    },
    {
        "func_name": "xid_expire",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl BUF_reverse(unsigned __int8 *out, const unsigned __int8 *in, size_t size)\n{\n  const unsigned __int8 *v3; // rdx\n  unsigned __int8 *v4; // rax\n  unsigned __int8 *v5; // rax\n  char *v6; // rax\n  const unsigned __int8 *ina; // [rsp+8h] [rbp-30h]\n  unsigned __int8 *outa; // [rsp+10h] [rbp-28h]\n  unsigned __int8 *outb; // [rsp+10h] [rbp-28h]\n  char c; // [rsp+27h] [rbp-11h]\n  unsigned __int8 *q; // [rsp+28h] [rbp-10h]\n  size_t i; // [rsp+30h] [rbp-8h]\n  size_t ia; // [rsp+30h] [rbp-8h]\n\n  outa = out;\n  ina = in;\n  if ( in )\n  {\n    outb = &out[size - 1];\n    for ( i = 0LL; i < size; ++i )\n    {\n      v3 = ina++;\n      v4 = outb--;\n      *v4 = *v3;\n    }\n  }\n  else\n  {\n    q = &out[size - 1];\n    for ( ia = 0LL; ia < size >> 1; ++ia )\n    {\n      c = *q;\n      v5 = q--;\n      *v5 = *outa;\n      v6 = (char *)outa++;\n      *v6 = c;\n    }\n  }\n}\n\n\n Revised code:\nvoid BUF_reverse(unsigned char *out, const unsigned char *in, size_t size)\n{\n    size_t i;\n    if (in) {\n        out += size - 1;\n        for (i = 0; i < size; i++)\n            *out-- = *in++;\n    } else {\n        unsigned char *q;\n        char c;\n        q = out + size - 1;\n        for (i = 0; i < size / 2; i++) {\n            c = *q;\n            *q-- = *out;\n            *out++ = c;\n        }\n    }\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl BUF_strlcpy(char *dst, const char *src, size_t size)\n{\n  const char *v3; // rdx\n  char *v4; // rax\n  size_t l; // [rsp+28h] [rbp-8h]\n\n  l = 0LL;\n  while ( size > 1 && *src )\n  {\n    v3 = src++;\n    v4 = dst++;\n    *v4 = *v3;\n    ++l;\n    --size;\n  }\n  if ( size )\n    *dst = 0;\n  return strlen(src) + l;\n}\n\n\n Revised code:\nsize_t BUF_strlcpy(char *dst, const char *src, size_t size)\n{\n    size_t l = 0;\n    for (; size > 1 && *src; size--) {\n        *dst++ = *src++;\n        l++;\n    }\n    if (size)\n        *dst = '\\0';\n    return l + strlen(src);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl longswap(void *_ptr, size_t len)\n{\n  unsigned __int8 c; // [rsp+1Fh] [rbp-11h]\n  unsigned __int8 ca; // [rsp+1Fh] [rbp-11h]\n  size_t i; // [rsp+28h] [rbp-8h]\n\n  for ( i = 0LL; i < len; i += 4LL )\n  {\n    c = *(_BYTE *)_ptr;\n    *(_BYTE *)_ptr = *((_BYTE *)_ptr + 3);\n    *((_BYTE *)_ptr + 3) = c;\n    ca = *((_BYTE *)_ptr + 1);\n    *((_BYTE *)_ptr + 1) = *((_BYTE *)_ptr + 2);\n    *((_BYTE *)_ptr + 2) = ca;\n  }\n}\n\n\n Revised code:\nstatic void longswap(void *_ptr, size_t len)\n{\n    const union {\n        long one;\n        char little;\n    } is_endian = {\n        1\n    };\n\n    if (is_endian.little) {\n        size_t i;\n        unsigned char *p = _ptr, c;\n\n        for (i = 0; i < len; i += 4) {\n            c = p[0], p[0] = p[3], p[3] = c;\n            c = p[1], p[1] = p[2], p[2] = c;\n        }\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\ntime_t sub_456B9C()\n{\n  time_t result; // rax\n  int v1; // [rsp+Ch] [rbp-14h]\n  struct termios *v2; // [rsp+10h] [rbp-10h]\n  struct termios *ptr; // [rsp+18h] [rbp-8h]\n\n  ptr = *(struct termios **)&dest.c_cc[15];\n  v2 = &dest;\n  result = sub_40BCE2();\n  v1 = result;\n  while ( ptr )\n  {\n    if ( v1 - ptr->c_iflag <= 0x78 )\n    {\n      v2 = ptr;\n      result = *(_QWORD *)&ptr->c_cc[15];\n    }\n    else\n    {\n      *(_QWORD *)&v2->c_cc[15] = *(_QWORD *)&ptr->c_cc[15];\n      free(ptr);\n      result = *(_QWORD *)&v2->c_cc[15];\n    }\n    ptr = (struct termios *)result;\n  }\n  return result;\n}\n",
        "output": "```c\ntime_t update_terminal_settings()\n{\n    time_t currentTime;\n    struct termios *currentTermios;\n    struct termios *nextTermios;\n\n    currentTermios = (struct termios *)&dest.c_cc[15];\n    currentTime = get_current_time();\n    while (currentTermios)\n    {\n        if (currentTime - currentTermios->c_iflag <= 120)\n        {\n            dest = *currentTermios;\n            nextTermios = *(struct termios **)&currentTermios->c_cc[15];\n        }\n        else\n        {\n            *(struct termios **)&dest.c_cc[15] = *(struct termios **)&currentTermios->c_cc[15];\n            free(currentTermios);\n            nextTermios = *(struct termios **)&dest.c_cc[15];\n        }\n        currentTermios = nextTermios;\n    }\n    return currentTime;\n}\n```",
        "source_code": "static void xid_expire(void)\n{\n\tstruct xid_item *item = dhcprelay_xid_list.next;\n\tstruct xid_item *last = &dhcprelay_xid_list;\n\tunsigned current_time = monotonic_sec();\n\n\twhile (item != NULL) {\n\t\tif ((current_time - item->timestamp) > MAX_LIFETIME) {\n\t\t\tlast->next = item->next;\n\t\t\tfree(item);\n\t\t\titem = last->next;\n\t\t} else {\n\t\t\tlast = item;\n\t\t\titem = item->next;\n\t\t}\n\t}\n}",
        "parsed_output": "time_t update_terminal_settings()\n{\n    time_t currentTime;\n    struct termios *currentTermios;\n    struct termios *nextTermios;\n\n    currentTermios = (struct termios *)&dest.c_cc[15];\n    currentTime = get_current_time();\n    while (currentTermios)\n    {\n        if (currentTime - currentTermios->c_iflag <= 120)\n        {\n            dest = *currentTermios;\n            nextTermios = *(struct termios **)&currentTermios->c_cc[15];\n        }\n        else\n        {\n            *(struct termios **)&dest.c_cc[15] = *(struct termios **)&currentTermios->c_cc[15];\n            free(currentTermios);\n            nextTermios = *(struct termios **)&dest.c_cc[15];\n        }\n        currentTermios = nextTermios;\n    }\n    return currentTime;\n}",
        "baseline_code_stripped": "time_t sub_456B9C()\n{\n  time_t result; // rax\n  int v1; // [rsp+Ch] [rbp-14h]\n  struct termios *v2; // [rsp+10h] [rbp-10h]\n  struct termios *ptr; // [rsp+18h] [rbp-8h]\n\n  ptr = *(struct termios **)&dest.c_cc[15];\n  v2 = &dest;\n  result = sub_40BCE2();\n  v1 = result;\n  while ( ptr )\n  {\n    if ( v1 - ptr->c_iflag <= 0x78 )\n    {\n      v2 = ptr;\n      result = *(_QWORD *)&ptr->c_cc[15];\n    }\n    else\n    {\n      *(_QWORD *)&v2->c_cc[15] = *(_QWORD *)&ptr->c_cc[15];\n      free(ptr);\n      result = *(_QWORD *)&v2->c_cc[15];\n    }\n    ptr = (struct termios *)result;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl xid_expire()\n{\n  unsigned int current_time; // [rsp+Ch] [rbp-14h]\n  xid_item *last; // [rsp+10h] [rbp-10h]\n  xid_item *item; // [rsp+18h] [rbp-8h]\n\n  item = *(xid_item **)&bb_common_bufsiz1.c_cc[15];\n  last = (xid_item *)&bb_common_bufsiz1;\n  current_time = monotonic_sec();\n  while ( item )\n  {\n    if ( current_time - item->timestamp <= 0x78 )\n    {\n      last = item;\n      item = item->next;\n    }\n    else\n    {\n      last->next = item->next;\n      free(item);\n      item = last->next;\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.5196322798728943,
        "similarity_score_baseline_stripped": 0.4869289994239807,
        "similarity_score_baseline_debug": 0.7836233377456665
    },
    {
        "func_name": "nvalloc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl RC2_decrypt(unsigned __int64 *d, RC2_KEY *key)\n{\n  unsigned int v2; // r12d\n  unsigned int v3; // r14d\n  unsigned int v4; // ebx\n  unsigned int v5; // r13d\n  unsigned int *v6; // r15\n  unsigned int *v7; // rax\n  int v8; // eax\n  unsigned __int64 l; // [rsp+10h] [rbp-38h]\n  int n; // [rsp+18h] [rbp-30h]\n  int i; // [rsp+1Ch] [rbp-2Ch]\n\n  v2 = (unsigned __int16)*d;\n  v3 = *d >> 16;\n  l = d[1];\n  v4 = (unsigned __int16)l;\n  v5 = l >> 16;\n  n = 3;\n  i = 5;\n  v6 = &key->data[63];\n  while ( 1 )\n  {\n    do\n    {\n      v5 = (unsigned __int16)((((_WORD)v5 << 11) | (v5 >> 5)) - (v2 & ~(_WORD)v4) - (v4 & v3) - *v6);\n      LOWORD(v4) = (((_WORD)v4 << 13) | (v4 >> 3)) - (v5 & ~(_WORD)v3) - (v3 & v2) - *(v6 - 1);\n      v3 = (unsigned __int16)((((_WORD)v3 << 14) | (v3 >> 2)) - (v4 & ~(_WORD)v2) - (v2 & v5) - *(v6 - 2));\n      v7 = v6 - 3;\n      v6 -= 4;\n      LOWORD(v2) = (((_WORD)v2 << 15) | (v2 >> 1)) - (v3 & ~(_WORD)v5) - (v5 & v4) - *(_WORD *)v7;\n      --i;\n    }\n    while ( i );\n    if ( !--n )\n      break;\n    if ( n == 2 )\n      v8 = 6;\n    else\n      v8 = 5;\n    i = v8;\n    v5 = (unsigned __int16)(v5 - key->data[v4 & 0x3F]);\n    v4 = (unsigned __int16)(v4 - key->data[v3 & 0x3F]);\n    v3 = (unsigned __int16)(v3 - key->data[v2 & 0x3F]);\n    v2 = (unsigned __int16)(v2 - key->data[v5 & 0x3F]);\n  }\n  *d = (unsigned __int16)v2 | (unsigned __int64)(v3 << 16);\n  d[1] = (v5 << 16) | (unsigned __int64)(unsigned __int16)v4;\n}\n\n\n Revised code:\nvoid RC2_decrypt(unsigned long *d, RC2_KEY *key)\n{\n    int i, n;\n    register RC2_INT *p0, *p1;\n    register RC2_INT x0, x1, x2, x3, t;\n    unsigned long l;\n\n    l = d[0];\n    x0 = (RC2_INT) l & 0xffff;\n    x1 = (RC2_INT) (l >> 16L);\n    l = d[1];\n    x2 = (RC2_INT) l & 0xffff;\n    x3 = (RC2_INT) (l >> 16L);\n\n    n = 3;\n    i = 5;\n\n    p0 = &(key->data[63]);\n    p1 = &(key->data[0]);\n    for (;;) {\n        t = ((x3 << 11) | (x3 >> 5)) & 0xffff;\n        x3 = (t - (x0 & ~x2) - (x1 & x2) - *(p0--)) & 0xffff;\n        t = ((x2 << 13) | (x2 >> 3)) & 0xffff;\n        x2 = (t - (x3 & ~x1) - (x0 & x1) - *(p0--)) & 0xffff;\n        t = ((x1 << 14) | (x1 >> 2)) & 0xffff;\n        x1 = (t - (x2 & ~x0) - (x3 & x0) - *(p0--)) & 0xffff;\n        t = ((x0 << 15) | (x0 >> 1)) & 0xffff;\n        x0 = (t - (x1 & ~x3) - (x2 & x3) - *(p0--)) & 0xffff;\n\n        if (--i == 0) {\n            if (--n == 0)\n                break;\n            i = (n == 2) ? 6 : 5;\n\n            x3 = (x3 - p1[x2 & 0x3f]) & 0xffff;\n            x2 = (x2 - p1[x1 & 0x3f]) & 0xffff;\n            x1 = (x1 - p1[x0 & 0x3f]) & 0xffff;\n            x0 = (x0 - p1[x3 & 0x3f]) & 0xffff;\n        }\n    }\n\n    d[0] =\n        (unsigned long)(x0 & 0xffff) | ((unsigned long)(x1 & 0xffff) << 16L);\n    d[1] =\n        (unsigned long)(x2 & 0xffff) | ((unsigned long)(x3 & 0xffff) << 16L);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl private_RC4_set_key(RC4_KEY *key, int len, const unsigned __int8 *data)\n{\n  unsigned __int8 *v3; // r12\n  int v4; // ebx\n  int v5; // r13d\n  unsigned __int8 v6; // r14\n  int v7; // ebx\n  int v8; // r13d\n  unsigned __int8 v9; // r14\n  int v10; // ebx\n  int v11; // r13d\n  unsigned __int8 v12; // r14\n  int v13; // ebx\n  int v14; // r13d\n  unsigned __int8 v15; // r14\n  unsigned int i; // [rsp+24h] [rbp-24h]\n  unsigned int ia; // [rsp+24h] [rbp-24h]\n\n  v3 = key->data;\n  key->x = 0;\n  key->y = 0;\n  LOBYTE(v4) = 0;\n  v5 = 0;\n  for ( i = 0; i <= 0xFF; ++i )\n    v3[i] = i;\n  for ( ia = 0; ia <= 0xFF; ia += 4 )\n  {\n    v6 = v3[ia];\n    v7 = (unsigned __int8)(v4 + data[v5] + v6);\n    v8 = v5 + 1;\n    if ( v8 == len )\n      v8 = 0;\n    v3[ia] = v3[v7];\n    v3[v7] = v6;\n    v9 = v3[ia + 1];\n    v10 = (unsigned __int8)(v7 + data[v8] + v9);\n    v11 = v8 + 1;\n    if ( v11 == len )\n      v11 = 0;\n    v3[ia + 1] = v3[v10];\n    v3[v10] = v9;\n    v12 = v3[ia + 2];\n    v13 = (unsigned __int8)(v10 + data[v11] + v12);\n    v14 = v11 + 1;\n    if ( v14 == len )\n      v14 = 0;\n    v3[ia + 2] = v3[v13];\n    v3[v13] = v12;\n    v15 = v3[ia + 3];\n    v4 = (unsigned __int8)(v13 + data[v14] + v15);\n    v5 = v14 + 1;\n    if ( v5 == len )\n      v5 = 0;\n    v3[ia + 3] = v3[v4];\n    v3[v4] = v15;\n  }\n}\n\n\n Revised code:\nvoid private_RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)\n{\n    register RC4_INT tmp;\n    register int id1, id2;\n    register RC4_INT *d;\n    unsigned int i;\n\n    d = &(key->data[0]);\n    key->x = 0;\n    key->y = 0;\n    id1 = id2 = 0;\n\n#define SK_LOOP(d,n) { \\\n                tmp=d[(n)]; \\\n                id2 = (data[id1] + tmp + id2) & 0xff; \\\n                if (++id1 == len) id1=0; \\\n                d[(n)]=d[id2]; \\\n                d[id2]=tmp; }\n\n    for (i = 0; i < 256; i++)\n        d[i] = i;\n    for (i = 0; i < 256; i += 4) {\n        SK_LOOP(d, i + 0);\n        SK_LOOP(d, i + 1);\n        SK_LOOP(d, i + 2);\n        SK_LOOP(d, i + 3);\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nunsigned __int64 __fastcall sub_4DCDF7(int a1, __int64 a2)\n{\n  int v2; // eax\n  char *v3; // rbx\n  unsigned __int64 v5; // [rsp+10h] [rbp-30h]\n  int v6; // [rsp+1Ch] [rbp-24h]\n  unsigned __int64 v7; // [rsp+20h] [rbp-20h]\n  int *v8; // [rsp+28h] [rbp-18h]\n\n  v8 = 0LL;\n  while ( *((_QWORD *)qword_75D408 - 4) )\n  {\n    v8 = (int *)*((_QWORD *)qword_75D408 - 4);\n    if ( a1 + ((__int64)(*((_QWORD *)v8 + 1) - (_QWORD)(v8 + 8)) >> 5) <= *v8 )\n      break;\n    *((_QWORD *)qword_75D408 - 4) = *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 24LL);\n  }\n  if ( !*((_QWORD *)qword_75D408 - 4) )\n  {\n    v2 = 64;\n    if ( a1 >= 64 )\n      v2 = a1;\n    v6 = v2;\n    v3 = (char *)qword_75D408 - 208;\n    *((_QWORD *)v3 + 22) = sub_40A0E8(32 * (v2 + 1LL), a2);\n    **((_DWORD **)qword_75D408 - 4) = v6;\n    *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) = *((_QWORD *)qword_75D408 - 4) + 32LL;\n    *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 16LL) = v8;\n    if ( v8 )\n      *((_QWORD *)v8 + 3) = *((_QWORD *)qword_75D408 - 4);\n  }\n  v5 = *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL);\n  v7 = v5;\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) = 32LL * a1 + v5;\n  while ( v7 < *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) )\n  {\n    *(_DWORD *)v7 = 0;\n    *(_QWORD *)(v7 + 16) = 0LL;\n    v7 += 32LL;\n  }\n  return v5;\n}\n",
        "output": "```c\nunsigned long long sub_4DCDF7(int count, long long allocator)\n{\n    int *current_block;\n    unsigned long long allocated_address;\n    int block_size;\n    unsigned long long next_block_address;\n    int *prev_block;\n\n    prev_block = NULL;\n    while (*(unsigned long long *)(qword_75D408 - 32))\n    {\n        current_block = (int *)*(unsigned long long *)(qword_75D408 - 32);\n        if (count + (((long long)(*(current_block + 2) - (unsigned long long)(current_block + 2))) >> 5) <= *current_block)\n            break;\n        *(unsigned long long *)(qword_75D408 - 32) = *(unsigned long long *)(*(unsigned long long *)(qword_75D408 - 32) + 24);\n    }\n    if (!*(unsigned long long *)(qword_75D408 - 32))\n    {\n        block_size = (count >= 64) ? count : 64;\n        char *base_ptr = (char *)qword_75D408 - 208;\n        *(unsigned long long *)(base_ptr + 176) = sub_40A0E8(32 * (block_size + 1), allocator);\n        **(int **)(qword_75D408 - 32) = block_size;\n        *(unsigned long long *)(*(unsigned long long *)(qword_75D408 - 32) + 8) = *(unsigned long long *)(qword_75D408 - 32) + 32;\n        *(unsigned long long *)(*(unsigned long long *)(qword_75D408 - 32) + 16) = prev_block;\n        if (prev_block)\n            *(unsigned long long *)(prev_block + 3) = *(unsigned long long *)(qword_75D408 - 32);\n    }\n    allocated_address = *(unsigned long long *)(*(unsigned long long *)(qword_75D408 - 32) + 8);\n    next_block_address = allocated_address;\n    *(unsigned long long *)(*(unsigned long long *)(qword_75D408 - 32) + 8) = 32 * count + allocated_address;\n    while (next_block_address < *(unsigned long long *)(*(unsigned long long *)(qword_75D408 - 32) + 8))\n    {\n        *(int *)next_block_address = 0;\n        *(unsigned long long *)(next_block_address + 16) = 0;\n        next_block_address += 32;\n    }\n    return allocated_address;\n}\n```",
        "source_code": "static var *nvalloc(int n)\n{\n\tnvblock *pb = NULL;\n\tvar *v, *r;\n\tint size;\n\n\twhile (g_cb) {\n\t\tpb = g_cb;\n\t\tif ((g_cb->pos - g_cb->nv) + n <= g_cb->size)\n\t\t\tbreak;\n\t\tg_cb = g_cb->next;\n\t}\n\n\tif (!g_cb) {\n\t\tsize = (n <= MINNVBLOCK) ? MINNVBLOCK : n;\n\t\tg_cb = xzalloc(sizeof(nvblock) + size * sizeof(var));\n\t\tg_cb->size = size;\n\t\tg_cb->pos = g_cb->nv;\n\t\tg_cb->prev = pb;\n\t\t/*g_cb->next = NULL; - xzalloc did it */\n\t\tif (pb)\n\t\t\tpb->next = g_cb;\n\t}\n\n\tv = r = g_cb->pos;\n\tg_cb->pos += n;\n\n\twhile (v < g_cb->pos) {\n\t\tv->type = 0;\n\t\tv->string = NULL;\n\t\tv++;\n\t}\n\n\treturn r;\n}",
        "parsed_output": "unsigned long long sub_4DCDF7(int count, long long allocator)\n{\n    int *current_block;\n    unsigned long long allocated_address;\n    int block_size;\n    unsigned long long next_block_address;\n    int *prev_block;\n\n    prev_block = NULL;\n    while (*(unsigned long long *)(qword_75D408 - 32))\n    {\n        current_block = (int *)*(unsigned long long *)(qword_75D408 - 32);\n        if (count + (((long long)(*(current_block + 2) - (unsigned long long)(current_block + 2))) >> 5) <= *current_block)\n            break;\n        *(unsigned long long *)(qword_75D408 - 32) = *(unsigned long long *)(*(unsigned long long *)(qword_75D408 - 32) + 24);\n    }\n    if (!*(unsigned long long *)(qword_75D408 - 32))\n    {\n        block_size = (count >= 64) ? count : 64;\n        char *base_ptr = (char *)qword_75D408 - 208;\n        *(unsigned long long *)(base_ptr + 176) = sub_40A0E8(32 * (block_size + 1), allocator);\n        **(int **)(qword_75D408 - 32) = block_size;\n        *(unsigned long long *)(*(unsigned long long *)(qword_75D408 - 32) + 8) = *(unsigned long long *)(qword_75D408 - 32) + 32;\n        *(unsigned long long *)(*(unsigned long long *)(qword_75D408 - 32) + 16) = prev_block;\n        if (prev_block)\n            *(unsigned long long *)(prev_block + 3) = *(unsigned long long *)(qword_75D408 - 32);\n    }\n    allocated_address = *(unsigned long long *)(*(unsigned long long *)(qword_75D408 - 32) + 8);\n    next_block_address = allocated_address;\n    *(unsigned long long *)(*(unsigned long long *)(qword_75D408 - 32) + 8) = 32 * count + allocated_address;\n    while (next_block_address < *(unsigned long long *)(*(unsigned long long *)(qword_75D408 - 32) + 8))\n    {\n        *(int *)next_block_address = 0;\n        *(unsigned long long *)(next_block_address + 16) = 0;\n        next_block_address += 32;\n    }\n    return allocated_address;\n}",
        "baseline_code_stripped": "unsigned __int64 __fastcall sub_4DCDF7(int a1, __int64 a2)\n{\n  int v2; // eax\n  char *v3; // rbx\n  unsigned __int64 v5; // [rsp+10h] [rbp-30h]\n  int v6; // [rsp+1Ch] [rbp-24h]\n  unsigned __int64 v7; // [rsp+20h] [rbp-20h]\n  int *v8; // [rsp+28h] [rbp-18h]\n\n  v8 = 0LL;\n  while ( *((_QWORD *)qword_75D408 - 4) )\n  {\n    v8 = (int *)*((_QWORD *)qword_75D408 - 4);\n    if ( a1 + ((__int64)(*((_QWORD *)v8 + 1) - (_QWORD)(v8 + 8)) >> 5) <= *v8 )\n      break;\n    *((_QWORD *)qword_75D408 - 4) = *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 24LL);\n  }\n  if ( !*((_QWORD *)qword_75D408 - 4) )\n  {\n    v2 = 64;\n    if ( a1 >= 64 )\n      v2 = a1;\n    v6 = v2;\n    v3 = (char *)qword_75D408 - 208;\n    *((_QWORD *)v3 + 22) = sub_40A0E8(32 * (v2 + 1LL), a2);\n    **((_DWORD **)qword_75D408 - 4) = v6;\n    *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) = *((_QWORD *)qword_75D408 - 4) + 32LL;\n    *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 16LL) = v8;\n    if ( v8 )\n      *((_QWORD *)v8 + 3) = *((_QWORD *)qword_75D408 - 4);\n  }\n  v5 = *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL);\n  v7 = v5;\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) = 32LL * a1 + v5;\n  while ( v7 < *(_QWORD *)(*((_QWORD *)qword_75D408 - 4) + 8LL) )\n  {\n    *(_DWORD *)v7 = 0;\n    *(_QWORD *)(v7 + 16) = 0LL;\n    v7 += 32LL;\n  }\n  return v5;\n}\n",
        "baseline_code_debug": "var_0 *__cdecl nvalloc(int n)\n{\n  int v1; // eax\n  int *v2; // rbx\n  var_0 *r; // [rsp+10h] [rbp-30h]\n  int size; // [rsp+1Ch] [rbp-24h]\n  var_0 *v; // [rsp+20h] [rbp-20h]\n  nvblock *pb; // [rsp+28h] [rbp-18h]\n\n  pb = 0LL;\n  while ( *(_QWORD *)&ptr_to_globals[-1].line_buf[100] )\n  {\n    pb = *(nvblock **)&ptr_to_globals[-1].line_buf[100];\n    if ( n + pb->pos - pb->nv <= pb->size )\n      break;\n    *(_QWORD *)&ptr_to_globals[-1].line_buf[100] = *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 24LL);\n  }\n  if ( !*(_QWORD *)&ptr_to_globals[-1].line_buf[100] )\n  {\n    v1 = 64;\n    if ( n >= 64 )\n      v1 = n;\n    size = v1;\n    v2 = &ptr_to_globals[-1].speeds[7];\n    *((_QWORD *)v2 + 22) = xzalloc(32 * (v1 + 1LL));\n    **(_DWORD **)&ptr_to_globals[-1].line_buf[100] = size;\n    *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 8LL) = *(_QWORD *)&ptr_to_globals[-1].line_buf[100]\n                                                                    + 32LL;\n    *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 16LL) = pb;\n    if ( pb )\n      pb->next = *(nvblock_s **)&ptr_to_globals[-1].line_buf[100];\n  }\n  r = *(var_0 **)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 8LL);\n  v = r;\n  *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 8LL) = &r[n];\n  while ( (unsigned __int64)v < *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[100] + 8LL) )\n  {\n    v->type = 0;\n    v->string = 0LL;\n    ++v;\n  }\n  return r;\n}\n",
        "similarity_score_unixcoder": 0.505478024482727,
        "similarity_score_baseline_stripped": 0.4669768214225769,
        "similarity_score_baseline_debug": 0.7178249359130859
    },
    {
        "func_name": "open_read_close",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __cdecl slg_ctrl(BIO *b, int cmd, __int64 num, void *ptr)\n{\n  int numa; // [rsp+8h] [rbp-18h]\n\n  numa = num;\n  if ( cmd == 4 )\n  {\n    xcloselog(b);\n    xopenlog(b, (char *)ptr, numa);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic long MS_CALLBACK slg_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    switch (cmd) {\n    case BIO_CTRL_SET:\n        xcloselog(b);\n        xopenlog(b, ptr, num);\n        break;\n    default:\n        break;\n    }\n    return (0);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl ctr64_add(unsigned __int8 *counter, size_t inc)\n{\n  unsigned __int64 v2; // rdx\n  unsigned __int8 *countera; // [rsp+8h] [rbp-18h]\n  size_t val; // [rsp+10h] [rbp-10h]\n  size_t n; // [rsp+18h] [rbp-8h]\n\n  n = 8LL;\n  val = 0LL;\n  countera = counter + 8;\n  do\n  {\n    v2 = countera[--n] + (unsigned __int64)(unsigned __int8)inc + val;\n    countera[n] = v2;\n    val = v2 >> 8;\n    inc >>= 8;\n  }\n  while ( n && (inc || val) );\n}\n\n\n Revised code:\nstatic void ctr64_add(unsigned char *counter, size_t inc)\n{\n    size_t n = 8, val = 0;\n\n    counter += 8;\n    do {\n        --n;\n        val += counter[n] + (inc & 0xff);\n        counter[n] = (unsigned char)val;\n        val >>= 8;              /* carry bit */\n        inc >>= 8;\n    } while (n && (inc || val));\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nssize_t __fastcall sub_40B501(const char *a1, char *a2, size_t a3)\n{\n  int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = open64(a1, 0);\n  if ( v5 >= 0 )\n    return sub_40B4C5(v5, a2, a3);\n  else\n    return v5;\n}\n",
        "output": "```c\nstatic ssize_t open_and_read(const char *filename, char *buffer, size_t length)\n{\n    int fd = open(filename, O_RDONLY);\n    if (fd >= 0)\n        return read(fd, buffer, length);\n    else\n        return fd;\n}\n```",
        "source_code": "ssize_t FAST_FUNC open_read_close(const char *filename, void *buf, size_t size)\n{\n\tint fd = open(filename, O_RDONLY);\n\tif (fd < 0)\n\t\treturn fd;\n\treturn read_close(fd, buf, size);\n}",
        "parsed_output": "static ssize_t open_and_read(const char *filename, char *buffer, size_t length)\n{\n    int fd = open(filename, O_RDONLY);\n    if (fd >= 0)\n        return read(fd, buffer, length);\n    else\n        return fd;\n}",
        "baseline_code_stripped": "ssize_t __fastcall sub_40B501(const char *a1, char *a2, size_t a3)\n{\n  int v5; // [rsp+2Ch] [rbp-4h]\n\n  v5 = open64(a1, 0);\n  if ( v5 >= 0 )\n    return sub_40B4C5(v5, a2, a3);\n  else\n    return v5;\n}\n",
        "baseline_code_debug": "ssize_t __cdecl open_read_close(const char *filename, void *buf, size_t size)\n{\n  int fd; // [rsp+2Ch] [rbp-4h]\n\n  fd = open64(filename, 0);\n  if ( fd >= 0 )\n    return read_close(fd, buf, size);\n  else\n    return fd;\n}\n",
        "similarity_score_unixcoder": 0.9057700037956238,
        "similarity_score_baseline_stripped": 0.5384160280227661,
        "similarity_score_baseline_debug": 0.8004591464996338
    },
    {
        "func_name": "do_lzo_decompress",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4B363F(__int64 a1, __int64 a2)\n{\n  unsigned __int8 v3[304]; // [rsp+0h] [rbp-130h] BYREF\n\n  sub_4B30FE();\n  sub_4B34DF(v3);\n  return sub_4B2DF3((__int64)v3, a2);\n}\n",
        "output": "```c\nvoid sub_4B363F(void *a1, void *a2)\n{\n    unsigned char buffer[304];\n\n    sub_4B30FE();\n    sub_4B34DF(buffer);\n    sub_4B2DF3(buffer, a2);\n}\n```",
        "source_code": "static smallint do_lzo_decompress(void)\n{\n\theader_t header;\n\n\tcheck_magic();\n\tp_header(&header);\n\treturn lzo_decompress(&header);\n}",
        "parsed_output": "void sub_4B363F(void *a1, void *a2)\n{\n    unsigned char buffer[304];\n\n    sub_4B30FE();\n    sub_4B34DF(buffer);\n    sub_4B2DF3(buffer, a2);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4B363F(__int64 a1, __int64 a2)\n{\n  unsigned __int8 v3[304]; // [rsp+0h] [rbp-130h] BYREF\n\n  sub_4B30FE();\n  sub_4B34DF(v3);\n  return sub_4B2DF3((__int64)v3, a2);\n}\n",
        "baseline_code_debug": "smallint __cdecl do_lzo_decompress()\n{\n  header_t_0 header; // [rsp+0h] [rbp-130h] BYREF\n\n  check_magic();\n  p_header(&header);\n  return lzo_decompress(&header);\n}\n",
        "similarity_score_unixcoder": 0.30201008915901184,
        "similarity_score_baseline_stripped": 0.3258238434791565,
        "similarity_score_baseline_debug": 0.8164466619491577
    },
    {
        "func_name": "eor",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl private_RC4_set_key(RC4_KEY *key, int len, const unsigned __int8 *data)\n{\n  unsigned __int8 *v3; // r12\n  int v4; // ebx\n  int v5; // r13d\n  unsigned __int8 v6; // r14\n  int v7; // ebx\n  int v8; // r13d\n  unsigned __int8 v9; // r14\n  int v10; // ebx\n  int v11; // r13d\n  unsigned __int8 v12; // r14\n  int v13; // ebx\n  int v14; // r13d\n  unsigned __int8 v15; // r14\n  unsigned int i; // [rsp+24h] [rbp-24h]\n  unsigned int ia; // [rsp+24h] [rbp-24h]\n\n  v3 = key->data;\n  key->x = 0;\n  key->y = 0;\n  LOBYTE(v4) = 0;\n  v5 = 0;\n  for ( i = 0; i <= 0xFF; ++i )\n    v3[i] = i;\n  for ( ia = 0; ia <= 0xFF; ia += 4 )\n  {\n    v6 = v3[ia];\n    v7 = (unsigned __int8)(v4 + data[v5] + v6);\n    v8 = v5 + 1;\n    if ( v8 == len )\n      v8 = 0;\n    v3[ia] = v3[v7];\n    v3[v7] = v6;\n    v9 = v3[ia + 1];\n    v10 = (unsigned __int8)(v7 + data[v8] + v9);\n    v11 = v8 + 1;\n    if ( v11 == len )\n      v11 = 0;\n    v3[ia + 1] = v3[v10];\n    v3[v10] = v9;\n    v12 = v3[ia + 2];\n    v13 = (unsigned __int8)(v10 + data[v11] + v12);\n    v14 = v11 + 1;\n    if ( v14 == len )\n      v14 = 0;\n    v3[ia + 2] = v3[v13];\n    v3[v13] = v12;\n    v15 = v3[ia + 3];\n    v4 = (unsigned __int8)(v13 + data[v14] + v15);\n    v5 = v14 + 1;\n    if ( v5 == len )\n      v5 = 0;\n    v3[ia + 3] = v3[v4];\n    v3[v4] = v15;\n  }\n}\n\n\n Revised code:\nvoid private_RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)\n{\n    register RC4_INT tmp;\n    register int id1, id2;\n    register RC4_INT *d;\n    unsigned int i;\n\n    d = &(key->data[0]);\n    key->x = 0;\n    key->y = 0;\n    id1 = id2 = 0;\n\n#define SK_LOOP(d,n) { \\\n                tmp=d[(n)]; \\\n                id2 = (data[id1] + tmp + id2) & 0xff; \\\n                if (++id1 == len) id1=0; \\\n                d[(n)]=d[id2]; \\\n                d[id2]=tmp; }\n\n    for (i = 0; i < 256; i++)\n        d[i] = i;\n    for (i = 0; i < 256; i += 4) {\n        SK_LOOP(d, i + 0);\n        SK_LOOP(d, i + 1);\n        SK_LOOP(d, i + 2);\n        SK_LOOP(d, i + 3);\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl RC2_decrypt(unsigned __int64 *d, RC2_KEY *key)\n{\n  unsigned int v2; // r12d\n  unsigned int v3; // r14d\n  unsigned int v4; // ebx\n  unsigned int v5; // r13d\n  unsigned int *v6; // r15\n  unsigned int *v7; // rax\n  int v8; // eax\n  unsigned __int64 l; // [rsp+10h] [rbp-38h]\n  int n; // [rsp+18h] [rbp-30h]\n  int i; // [rsp+1Ch] [rbp-2Ch]\n\n  v2 = (unsigned __int16)*d;\n  v3 = *d >> 16;\n  l = d[1];\n  v4 = (unsigned __int16)l;\n  v5 = l >> 16;\n  n = 3;\n  i = 5;\n  v6 = &key->data[63];\n  while ( 1 )\n  {\n    do\n    {\n      v5 = (unsigned __int16)((((_WORD)v5 << 11) | (v5 >> 5)) - (v2 & ~(_WORD)v4) - (v4 & v3) - *v6);\n      LOWORD(v4) = (((_WORD)v4 << 13) | (v4 >> 3)) - (v5 & ~(_WORD)v3) - (v3 & v2) - *(v6 - 1);\n      v3 = (unsigned __int16)((((_WORD)v3 << 14) | (v3 >> 2)) - (v4 & ~(_WORD)v2) - (v2 & v5) - *(v6 - 2));\n      v7 = v6 - 3;\n      v6 -= 4;\n      LOWORD(v2) = (((_WORD)v2 << 15) | (v2 >> 1)) - (v3 & ~(_WORD)v5) - (v5 & v4) - *(_WORD *)v7;\n      --i;\n    }\n    while ( i );\n    if ( !--n )\n      break;\n    if ( n == 2 )\n      v8 = 6;\n    else\n      v8 = 5;\n    i = v8;\n    v5 = (unsigned __int16)(v5 - key->data[v4 & 0x3F]);\n    v4 = (unsigned __int16)(v4 - key->data[v3 & 0x3F]);\n    v3 = (unsigned __int16)(v3 - key->data[v2 & 0x3F]);\n    v2 = (unsigned __int16)(v2 - key->data[v5 & 0x3F]);\n  }\n  *d = (unsigned __int16)v2 | (unsigned __int64)(v3 << 16);\n  d[1] = (v5 << 16) | (unsigned __int64)(unsigned __int16)v4;\n}\n\n\n Revised code:\nvoid RC2_decrypt(unsigned long *d, RC2_KEY *key)\n{\n    int i, n;\n    register RC2_INT *p0, *p1;\n    register RC2_INT x0, x1, x2, x3, t;\n    unsigned long l;\n\n    l = d[0];\n    x0 = (RC2_INT) l & 0xffff;\n    x1 = (RC2_INT) (l >> 16L);\n    l = d[1];\n    x2 = (RC2_INT) l & 0xffff;\n    x3 = (RC2_INT) (l >> 16L);\n\n    n = 3;\n    i = 5;\n\n    p0 = &(key->data[63]);\n    p1 = &(key->data[0]);\n    for (;;) {\n        t = ((x3 << 11) | (x3 >> 5)) & 0xffff;\n        x3 = (t - (x0 & ~x2) - (x1 & x2) - *(p0--)) & 0xffff;\n        t = ((x2 << 13) | (x2 >> 3)) & 0xffff;\n        x2 = (t - (x3 & ~x1) - (x0 & x1) - *(p0--)) & 0xffff;\n        t = ((x1 << 14) | (x1 >> 2)) & 0xffff;\n        x1 = (t - (x2 & ~x0) - (x3 & x0) - *(p0--)) & 0xffff;\n        t = ((x0 << 15) | (x0 >> 1)) & 0xffff;\n        x0 = (t - (x1 & ~x3) - (x2 & x3) - *(p0--)) & 0xffff;\n\n        if (--i == 0) {\n            if (--n == 0)\n                break;\n            i = (n == 2) ? 6 : 5;\n\n            x3 = (x3 - p1[x2 & 0x3f]) & 0xffff;\n            x2 = (x2 - p1[x1 & 0x3f]) & 0xffff;\n            x1 = (x1 - p1[x0 & 0x3f]) & 0xffff;\n            x0 = (x0 - p1[x3 & 0x3f]) & 0xffff;\n        }\n    }\n\n    d[0] =\n        (unsigned long)(x0 & 0xffff) | ((unsigned long)(x1 & 0xffff) << 16L);\n    d[1] =\n        (unsigned long)(x2 & 0xffff) | ((unsigned long)(x3 & 0xffff) << 16L);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_416357(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  double v10; // xmm0_8\n  unsigned __int64 v11; // rbx\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  double v16; // xmm0_8\n  unsigned __int64 v17; // rax\n  __int64 v18; // rax\n  double v19; // xmm0_8\n\n  v10 = sub_416051(a1, a2, a3, a4, a5, a6);\n  if ( v10 >= 9.223372036854776e18 )\n    v11 = (unsigned int)(int)(v10 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v11 = (unsigned int)(int)v10;\n  v16 = sub_416051(a1, a2, v6, v7, v8, v9);\n  if ( v16 >= 9.223372036854776e18 )\n  {\n    v12 = 0x8000000000000000LL;\n    v17 = (unsigned int)(int)(v16 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  }\n  else\n  {\n    v17 = (unsigned int)(int)v16;\n  }\n  v18 = v11 ^ v17;\n  if ( v18 < 0 )\n  {\n    v12 = v18 & 1 | ((unsigned __int64)v18 >> 1);\n    v19 = (double)(int)v12 + (double)(int)v12;\n  }\n  else\n  {\n    v19 = (double)(int)v18;\n  }\n  return sub_416006(v19, a1, a2, v12, v13, v14, v15);\n}\n",
        "output": "double sub_416357(double a1, double a2, double a3, double a4, double a5, double a6)\n{\n    double result1, result2, finalResult;\n    unsigned __int64 temp1, temp2;\n    __int64 combined;\n\n    result1 = sub_416051(a1, a2, a3, a4, a5, a6);\n    if (result1 >= 9.223372036854776e18)\n        temp1 = (unsigned int)(int)(result1 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n    else\n        temp1 = (unsigned int)(int)result1;\n\n    result2 = sub_416051(a1, a2, a3, a4, a5, a6);\n    if (result2 >= 9.223372036854776e18)\n        temp2 = (unsigned int)(int)(result2 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n    else\n        temp2 = (unsigned int)(int)result2;\n\n    combined = temp1 ^ temp2;\n    if (combined < 0)\n        finalResult = (double)(combined & 1 | (combined >> 1)) * 2.0;\n    else\n        finalResult = (double)combined;\n\n    return sub_416006(finalResult, a1, a2, a3, a4, a5, a6);\n}",
        "source_code": "static void eor(void)\n{\n\tpush((data_t) pop() ^ (data_t) pop());\n}",
        "parsed_output": "double sub_416357(double a1, double a2, double a3, double a4, double a5, double a6)\n{\n    double result1, result2, finalResult;\n    unsigned __int64 temp1, temp2;\n    __int64 combined;\n\n    result1 = sub_416051(a1, a2, a3, a4, a5, a6);\n    if (result1 >= 9.223372036854776e18)\n        temp1 = (unsigned int)(int)(result1 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n    else\n        temp1 = (unsigned int)(int)result1;\n\n    result2 = sub_416051(a1, a2, a3, a4, a5, a6);\n    if (result2 >= 9.223372036854776e18)\n        temp2 = (unsigned int)(int)(result2 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n    else\n        temp2 = (unsigned int)(int)result2;\n\n    combined = temp1 ^ temp2;\n    if (combined < 0)\n        finalResult = (double)(combined & 1 | (combined >> 1)) * 2.0;\n    else\n        finalResult = (double)combined;\n\n    return sub_416006(finalResult, a1, a2, a3, a4, a5, a6);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_416357(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  double v10; // xmm0_8\n  unsigned __int64 v11; // rbx\n  __int64 v12; // rdx\n  __int64 v13; // rcx\n  __int64 v14; // r8\n  __int64 v15; // r9\n  double v16; // xmm0_8\n  unsigned __int64 v17; // rax\n  __int64 v18; // rax\n  double v19; // xmm0_8\n\n  v10 = sub_416051(a1, a2, a3, a4, a5, a6);\n  if ( v10 >= 9.223372036854776e18 )\n    v11 = (unsigned int)(int)(v10 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v11 = (unsigned int)(int)v10;\n  v16 = sub_416051(a1, a2, v6, v7, v8, v9);\n  if ( v16 >= 9.223372036854776e18 )\n  {\n    v12 = 0x8000000000000000LL;\n    v17 = (unsigned int)(int)(v16 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  }\n  else\n  {\n    v17 = (unsigned int)(int)v16;\n  }\n  v18 = v11 ^ v17;\n  if ( v18 < 0 )\n  {\n    v12 = v18 & 1 | ((unsigned __int64)v18 >> 1);\n    v19 = (double)(int)v12 + (double)(int)v12;\n  }\n  else\n  {\n    v19 = (double)(int)v18;\n  }\n  return sub_416006(v19, a1, a2, v12, v13, v14, v15);\n}\n",
        "baseline_code_debug": "void __cdecl eor()\n{\n  double v0; // xmm0_8\n  unsigned __int64 v1; // rbx\n  double v2; // xmm0_8\n  unsigned __int64 v3; // rax\n  __int64 v4; // rax\n  double v5; // xmm0_8\n\n  v0 = pop();\n  if ( v0 >= 9.223372036854776e18 )\n    v1 = (unsigned int)(int)(v0 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v1 = (unsigned int)(int)v0;\n  v2 = pop();\n  if ( v2 >= 9.223372036854776e18 )\n    v3 = (unsigned int)(int)(v2 - 9.223372036854776e18) ^ 0x8000000000000000LL;\n  else\n    v3 = (unsigned int)(int)v2;\n  v4 = v1 ^ v3;\n  if ( v4 < 0 )\n    v5 = (double)(int)(v4 & 1 | ((unsigned __int64)v4 >> 1)) + (double)(int)(v4 & 1 | ((unsigned __int64)v4 >> 1));\n  else\n    v5 = (double)(int)v4;\n  push(v5);\n}\n",
        "similarity_score_unixcoder": 0.4321706295013428,
        "similarity_score_baseline_stripped": 0.4363482892513275,
        "similarity_score_baseline_debug": 0.6281893253326416
    },
    {
        "func_name": "addgroup_wrapper",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint BIO_printf(BIO *bio, const char *format, ...)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list args; // [rsp+10h] [rbp-D0h] BYREF\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(args, format);\n  v2 = va_arg(args, _QWORD);\n  v3 = va_arg(args, _QWORD);\n  v4 = va_arg(args, _QWORD);\n  v5 = va_arg(args, _QWORD);\n  v8 = v2;\n  v9 = v3;\n  v10 = v4;\n  v11 = v5;\n  args[0].gp_offset = 16;\n  return BIO_vprintf(bio, format, args);\n}\n\n\n Revised code:\nint BIO_printf(BIO *bio, const char *format, ...)\n{\n    va_list args;\n    int ret;\n\n    va_start(args, format);\n\n    ret = BIO_vprintf(bio, format, args);\n\n    va_end(args);\n    return (ret);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40D7F2(__int64 a1, const char *a2)\n{\n  const char *v3; // [rsp+10h] [rbp-30h] BYREF\n  const char *v4; // [rsp+18h] [rbp-28h]\n  _BYTE *v5; // [rsp+20h] [rbp-20h]\n  const char *v6; // [rsp+28h] [rbp-18h]\n  _BYTE *v7; // [rsp+30h] [rbp-10h]\n  __int64 v8; // [rsp+38h] [rbp-8h]\n\n  v3 = \"addgroup\";\n  if ( a2 )\n  {\n    v4 = \"--\";\n    v5 = *(_BYTE **)a1;\n    v6 = a2;\n    v7 = 0LL;\n  }\n  else\n  {\n    v4 = \"--gid\";\n    v5 = sub_409B63(*(_DWORD *)(a1 + 20));\n    v6 = \"--\";\n    v7 = *(_BYTE **)a1;\n    v8 = 0LL;\n  }\n  return sub_50A624(&v3);\n}\n",
        "output": "```c\n__int64 __fastcall add_group_or_gid(__int64 user_data, const char *group_name)\n{\n    const char *command = \"addgroup\";\n    const char *arg1;\n    const char *arg2;\n    const char *arg3;\n    const char *arg4 = NULL;\n    const char *arg5 = NULL;\n\n    if (group_name)\n    {\n        arg1 = \"--\";\n        arg2 = group_name;\n    }\n    else\n    {\n        arg1 = \"--gid\";\n        arg2 = get_gid_string(*(_DWORD *)(user_data + 20));\n        arg3 = \"--\";\n        arg4 = (const char *)(*(_BYTE **)user_data);\n    }\n\n    return execute_command(&command, arg1, arg2, arg3, arg4, arg5);\n}\n```",
        "source_code": "static int addgroup_wrapper(struct passwd *p, const char *group_name)\n{\n\tchar *argv[6];\n\n\targv[0] = (char*)\"addgroup\";\n\tif (group_name) {\n\t\t/* Add user to existing group */\n\t\targv[1] = (char*)\"--\";\n\t\targv[2] = p->pw_name;\n\t\targv[3] = (char*)group_name;\n\t\targv[4] = NULL;\n\t} else {\n\t\t/* Add user to his own group with the first free gid\n\t\t * found in passwd_study.\n\t\t */\n#if ENABLE_FEATURE_ADDGROUP_LONG_OPTIONS || !ENABLE_ADDGROUP\n\t\t/* We try to use --gid, not -g, because \"standard\" addgroup\n\t\t * has no short option -g, it has only long --gid.\n\t\t */\n\t\targv[1] = (char*)\"--gid\";\n#else\n\t\t/* Breaks if system in fact does NOT use busybox addgroup */\n\t\targv[1] = (char*)\"-g\";\n#endif\n\t\targv[2] = utoa(p->pw_gid);\n\t\targv[3] = (char*)\"--\";\n\t\targv[4] = p->pw_name;\n\t\targv[5] = NULL;\n\t}\n\n\treturn spawn_and_wait(argv);\n}",
        "parsed_output": "__int64 __fastcall add_group_or_gid(__int64 user_data, const char *group_name)\n{\n    const char *command = \"addgroup\";\n    const char *arg1;\n    const char *arg2;\n    const char *arg3;\n    const char *arg4 = NULL;\n    const char *arg5 = NULL;\n\n    if (group_name)\n    {\n        arg1 = \"--\";\n        arg2 = group_name;\n    }\n    else\n    {\n        arg1 = \"--gid\";\n        arg2 = get_gid_string(*(_DWORD *)(user_data + 20));\n        arg3 = \"--\";\n        arg4 = (const char *)(*(_BYTE **)user_data);\n    }\n\n    return execute_command(&command, arg1, arg2, arg3, arg4, arg5);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40D7F2(__int64 a1, const char *a2)\n{\n  const char *v3; // [rsp+10h] [rbp-30h] BYREF\n  const char *v4; // [rsp+18h] [rbp-28h]\n  _BYTE *v5; // [rsp+20h] [rbp-20h]\n  const char *v6; // [rsp+28h] [rbp-18h]\n  _BYTE *v7; // [rsp+30h] [rbp-10h]\n  __int64 v8; // [rsp+38h] [rbp-8h]\n\n  v3 = \"addgroup\";\n  if ( a2 )\n  {\n    v4 = \"--\";\n    v5 = *(_BYTE **)a1;\n    v6 = a2;\n    v7 = 0LL;\n  }\n  else\n  {\n    v4 = \"--gid\";\n    v5 = sub_409B63(*(_DWORD *)(a1 + 20));\n    v6 = \"--\";\n    v7 = *(_BYTE **)a1;\n    v8 = 0LL;\n  }\n  return sub_50A624(&v3);\n}\n",
        "baseline_code_debug": "int __cdecl addgroup_wrapper(passwd *p, const char *group_name)\n{\n  char *argv[6]; // [rsp+10h] [rbp-30h] BYREF\n\n  argv[0] = \"addgroup\";\n  if ( group_name )\n  {\n    argv[1] = \"--\";\n    argv[2] = p->pw_name;\n    argv[3] = (char *)group_name;\n    argv[4] = 0LL;\n  }\n  else\n  {\n    argv[1] = \"--gid\";\n    argv[2] = utoa(p->pw_gid);\n    argv[3] = \"--\";\n    argv[4] = p->pw_name;\n    argv[5] = 0LL;\n  }\n  return spawn_and_wait(argv);\n}\n",
        "similarity_score_unixcoder": 0.7216399908065796,
        "similarity_score_baseline_stripped": 0.5966931581497192,
        "similarity_score_baseline_debug": 0.8558531403541565
    },
    {
        "func_name": "pivot_root_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl bn_sqr_words(unsigned __int64 *r, const unsigned __int64 *a, int n)\n{\n  int na; // [rsp+0h] [rbp-44h]\n\n  na = n;\n  if ( n > 0 )\n  {\n    while ( (na & 0xFFFFFFFC) != 0 )\n    {\n      *(_OWORD *)r = *a * (unsigned __int128)*a;\n      *((_OWORD *)r + 1) = a[1] * (unsigned __int128)a[1];\n      *((_OWORD *)r + 2) = a[2] * (unsigned __int128)a[2];\n      *((_OWORD *)r + 3) = a[3] * (unsigned __int128)a[3];\n      a += 4;\n      r += 8;\n      na -= 4;\n    }\n    while ( na )\n    {\n      *(_OWORD *)r = *a * (unsigned __int128)*a;\n      ++a;\n      r += 2;\n      --na;\n    }\n  }\n}\n\n\n Revised code:\nvoid bn_sqr_words(BN_ULONG *r, const BN_ULONG *a, int n)\n{\n    assert(n >= 0);\n    if (n <= 0)\n        return;\n\n# ifndef OPENSSL_SMALL_FOOTPRINT\n    while (n & ~3) {\n        sqr(r[0], r[1], a[0]);\n        sqr(r[2], r[3], a[1]);\n        sqr(r[4], r[5], a[2]);\n        sqr(r[6], r[7], a[3]);\n        a += 4;\n        r += 8;\n        n -= 4;\n    }\n# endif\n    while (n) {\n        sqr(r[0], r[1], a[0]);\n        a++;\n        r += 2;\n        n--;\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl bn_cmp_words(const unsigned __int64 *a, const unsigned __int64 *b, int n)\n{\n  unsigned __int64 bb; // [rsp+1Ch] [rbp-18h]\n  unsigned __int64 bba; // [rsp+1Ch] [rbp-18h]\n  unsigned __int64 aa; // [rsp+24h] [rbp-10h]\n  unsigned __int64 aaa; // [rsp+24h] [rbp-10h]\n  int i; // [rsp+30h] [rbp-4h]\n\n  aa = a[n - 1];\n  bb = b[n - 1];\n  if ( aa == bb )\n  {\n    for ( i = n - 2; ; --i )\n    {\n      if ( i < 0 )\n        return 0;\n      aaa = a[i];\n      bba = b[i];\n      if ( aaa != bba )\n        break;\n    }\n    if ( aaa <= bba )\n      return -1;\n    else\n      return 1;\n  }\n  else if ( aa <= bb )\n  {\n    return -1;\n  }\n  else\n  {\n    return 1;\n  }\n}\n\n\n Revised code:\nint bn_cmp_words(const BN_ULONG *a, const BN_ULONG *b, int n)\n{\n    int i;\n    BN_ULONG aa, bb;\n\n    aa = a[n - 1];\n    bb = b[n - 1];\n    if (aa != bb)\n        return ((aa > bb) ? 1 : -1);\n    for (i = n - 2; i >= 0; i--) {\n        aa = a[i];\n        bb = b[i];\n        if (aa != bb)\n            return ((aa > bb) ? 1 : -1);\n    }\n    return (0);\n}\n\n## Example:\n\n Input code:\nint __cdecl BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)\n{\n  int (__cdecl *v5)(BIGNUM *, const BIGNUM *, const BIGNUM *); // r8\n\n  if ( !BN_div(0LL, r, m, d, ctx) )\n    return 0;\n  if ( !r->neg )\n    return 1;\n  if ( d->neg )\n    v5 = BN_sub;\n  else\n    v5 = BN_add;\n  return ((__int64 (__fastcall *)(BIGNUM *, BIGNUM *, const BIGNUM *))v5)(r, r, d);\n}\n\n\n Revised code:\nendif\n\nint BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx)\n{\n    /*\n     * like BN_mod, but returns non-negative remainder (i.e., 0 <= r < |d|\n     * always holds)\n     */\n\n    if (!(BN_mod(r, m, d, ctx)))\n        return 0;\n    if (!r->neg)\n        return 1;\n    /* now   -|d| < r < 0,  so we have to set  r := r + |d| */\n    return (d->neg ? BN_sub : BN_add) (r, r, d);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4A32AA(__int64 a1, __int64 a2)\n{\n  if ( (_DWORD)a1 != 3 )\n    sub_407F64(a1);\n  if ( (int)pivot_root(*(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16)) < 0 )\n    sub_502D54();\n  return 0LL;\n}\n",
        "output": "int change_root(const char *new_root, const char *put_old)\n{\n    if (new_root == NULL)\n        handle_error(\"new_root is NULL\");\n    if (pivot_root(new_root, put_old) < 0)\n        handle_error(\"pivot_root failed\");\n    return 0;\n}",
        "source_code": "int pivot_root_main(int argc, char **argv)\n{\n\tif (argc != 3)\n\t\tbb_show_usage();\n\n\tif (pivot_root(argv[1], argv[2]) < 0) {\n\t\t/* prints \"pivot_root: <strerror text>\" */\n\t\tbb_perror_nomsg_and_die();\n\t}\n\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "int change_root(const char *new_root, const char *put_old)\n{\n    if (new_root == NULL)\n        handle_error(\"new_root is NULL\");\n    if (pivot_root(new_root, put_old) < 0)\n        handle_error(\"pivot_root failed\");\n    return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4A32AA(__int64 a1, __int64 a2)\n{\n  if ( (_DWORD)a1 != 3 )\n    sub_407F64(a1);\n  if ( (int)pivot_root(*(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16)) < 0 )\n    sub_502D54();\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl pivot_root_main(int argc, char **argv)\n{\n  if ( argc != 3 )\n    bb_show_usage();\n  if ( (int)pivot_root(argv[1], argv[2]) < 0 )\n    bb_perror_nomsg_and_die();\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.6918190717697144,
        "similarity_score_baseline_stripped": 0.5956843495368958,
        "similarity_score_baseline_debug": 0.885185718536377
    },
    {
        "func_name": "make_new_name_generic",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl get_ip(const char *str, unsigned __int8 *ip_0)\n{\n  const char *v2; // rax\n  unsigned int tmp[4]; // [rsp+10h] [rbp-20h]\n  int c; // [rsp+24h] [rbp-Ch]\n  int ok; // [rsp+28h] [rbp-8h]\n  int num; // [rsp+2Ch] [rbp-4h]\n\n  num = 0;\n  ok = 0;\n  tmp[3] = 0;\n  tmp[2] = 0;\n  tmp[1] = 0;\n  tmp[0] = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v2 = str++;\n      c = *v2;\n      if ( c <= 47 || c > 57 )\n        break;\n      ok = 1;\n      tmp[num] = 10 * tmp[num] + c - 48;\n      if ( tmp[num] > 0xFF )\n        return 0;\n    }\n    if ( c != 46 )\n      break;\n    if ( !ok )\n      return -1;\n    if ( num == 3 )\n      return 0;\n    ++num;\n    ok = 0;\n  }\n  if ( c || num != 3 || !ok )\n    return 0;\n  *ip_0 = tmp[0];\n  ip_0[1] = tmp[1];\n  ip_0[2] = tmp[2];\n  ip_0[3] = tmp[3];\n  return 1;\n}\n\n\n Revised code:\nstatic int get_ip(const char *str, unsigned char ip[4])\n{\n    unsigned int tmp[4];\n    int num = 0, c, ok = 0;\n\n    tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;\n\n    for (;;) {\n        c = *(str++);\n        if ((c >= '0') && (c <= '9')) {\n            ok = 1;\n            tmp[num] = tmp[num] * 10 + c - '0';\n            if (tmp[num] > 255)\n                return (0);\n        } else if (c == '.') {\n            if (!ok)\n                return (-1);\n            if (num == 3)\n                return (0);\n            num++;\n            ok = 0;\n        } else if (c == '\\0' && (num == 3) && ok)\n            break;\n        else\n            return (0);\n    }\n    ip[0] = tmp[0];\n    ip[1] = tmp[1];\n    ip[2] = tmp[2];\n    ip[3] = tmp[3];\n    return (1);\n}\n\n## Example:\n\n Input code:\nint __cdecl ASN1_put_eoc(unsigned __int8 **pp)\n{\n  unsigned __int8 *p; // [rsp+10h] [rbp-8h]\n\n  p = *pp + 1;\n  **pp = 0;\n  *p = 0;\n  *pp = p + 1;\n  return 2;\n}\n\n\n Revised code:\nint ASN1_put_eoc(unsigned char **pp)\n{\n    unsigned char *p = *pp;\n    *p++ = 0;\n    *p++ = 0;\n    *pp = p;\n    return 2;\n}\n\n## Example:\n\n Input code:\nint __cdecl bn_cmp_words(const unsigned __int64 *a, const unsigned __int64 *b, int n)\n{\n  unsigned __int64 bb; // [rsp+1Ch] [rbp-18h]\n  unsigned __int64 bba; // [rsp+1Ch] [rbp-18h]\n  unsigned __int64 aa; // [rsp+24h] [rbp-10h]\n  unsigned __int64 aaa; // [rsp+24h] [rbp-10h]\n  int i; // [rsp+30h] [rbp-4h]\n\n  aa = a[n - 1];\n  bb = b[n - 1];\n  if ( aa == bb )\n  {\n    for ( i = n - 2; ; --i )\n    {\n      if ( i < 0 )\n        return 0;\n      aaa = a[i];\n      bba = b[i];\n      if ( aaa != bba )\n        break;\n    }\n    if ( aaa <= bba )\n      return -1;\n    else\n      return 1;\n  }\n  else if ( aa <= bb )\n  {\n    return -1;\n  }\n  else\n  {\n    return 1;\n  }\n}\n\n\n Revised code:\nint bn_cmp_words(const BN_ULONG *a, const BN_ULONG *b, int n)\n{\n    int i;\n    BN_ULONG aa, bb;\n\n    aa = a[n - 1];\n    bb = b[n - 1];\n    if (aa != bb)\n        return ((aa > bb) ? 1 : -1);\n    for (i = n - 2; i >= 0; i--) {\n        aa = a[i];\n        bb = b[i];\n        if (aa != bb)\n            return ((aa > bb) ? 1 : -1);\n    }\n    return (0);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_4A872C(const char *a1, const char *a2)\n{\n  char *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = strrchr(a1, 46);\n  if ( !v3 || strcmp(v3 + 1, a2) )\n    return 0LL;\n  *v3 = 0;\n  return a1;\n}\n",
        "output": "const char *strip_file_extension(const char *filename, const char *extension)\n{\n    char *last_dot = strrchr(filename, '.');\n    if (!last_dot || strcmp(last_dot + 1, extension) != 0)\n        return NULL;\n    *last_dot = '\\0';\n    return filename;\n}",
        "source_code": "FAST_FUNC make_new_name_generic(char *filename, const char *expected_ext)\n{\n\tchar *extension = strrchr(filename, '.');\n\tif (!extension || strcmp(extension + 1, expected_ext) != 0) {\n\t\t/* Mimic GNU gunzip - \"real\" bunzip2 tries to */\n\t\t/* unpack file anyway, to file.out */\n\t\treturn NULL;\n\t}\n\t*extension = '\\0';\n\treturn filename;\n}",
        "parsed_output": "const char *strip_file_extension(const char *filename, const char *extension)\n{\n    char *last_dot = strrchr(filename, '.');\n    if (!last_dot || strcmp(last_dot + 1, extension) != 0)\n        return NULL;\n    *last_dot = '\\0';\n    return filename;\n}",
        "baseline_code_stripped": "const char *__fastcall sub_4A872C(const char *a1, const char *a2)\n{\n  char *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = strrchr(a1, 46);\n  if ( !v3 || strcmp(v3 + 1, a2) )\n    return 0LL;\n  *v3 = 0;\n  return a1;\n}\n",
        "baseline_code_debug": "char *__cdecl make_new_name_generic(char *filename, const char *expected_ext)\n{\n  char *extension; // [rsp+18h] [rbp-8h]\n\n  extension = strrchr(filename, 46);\n  if ( !extension || strcmp(extension + 1, expected_ext) )\n    return 0LL;\n  *extension = 0;\n  return filename;\n}\n",
        "similarity_score_unixcoder": 0.6371126174926758,
        "similarity_score_baseline_stripped": 0.5035704970359802,
        "similarity_score_baseline_debug": 0.7739710807800293
    },
    {
        "func_name": "free_instance",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl mem_free(BIO *a)\n{\n  BUF_MEM *b; // [rsp+18h] [rbp-8h]\n\n  if ( !a )\n    return 0;\n  if ( a->shutdown && a->init && a->ptr )\n  {\n    b = (BUF_MEM *)a->ptr;\n    if ( (a->flags & 0x200) != 0 )\n      b->data = 0LL;\n    BUF_MEM_free(b);\n    a->ptr = 0LL;\n  }\n  return 1;\n}\n\n\n Revised code:\nstatic int mem_free(BIO *a)\n{\n    if (a == NULL)\n        return (0);\n    if (a->shutdown) {\n        if ((a->init) && (a->ptr != NULL)) {\n            BUF_MEM *b;\n            b = (BUF_MEM *)a->ptr;\n            if (a->flags & BIO_FLAGS_MEM_RDONLY)\n                b->data = NULL;\n            BUF_MEM_free(b);\n            a->ptr = NULL;\n        }\n    }\n    return (1);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl BN_clear_free(BIGNUM *a)\n{\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  if ( a )\n  {\n    if ( a->d )\n    {\n      OPENSSL_cleanse(a->d, 8LL * a->dmax);\n      if ( (a->flags & 2) == 0 )\n        CRYPTO_free(a->d);\n    }\n    i = a->flags & 1;\n    OPENSSL_cleanse(a, 0x18uLL);\n    if ( i )\n      CRYPTO_free(a);\n  }\n}\n\n\n Revised code:\nvoid BN_clear_free(BIGNUM *a)\n{\n    int i;\n\n    if (a == NULL)\n        return;\n    bn_check_top(a);\n    if (a->d != NULL) {\n        OPENSSL_cleanse(a->d, a->dmax * sizeof(a->d[0]));\n        if (!(BN_get_flags(a, BN_FLG_STATIC_DATA)))\n            OPENSSL_free(a->d);\n    }\n    i = BN_get_flags(a, BN_FLG_MALLOCED);\n    OPENSSL_cleanse(a, sizeof(BIGNUM));\n    if (i)\n        OPENSSL_free(a);\n}\n\n## Example:\n\n Input code:\nvoid *__cdecl CRYPTO_remalloc(void *a, int num, const char *file, int line)\n{\n  if ( a )\n    CRYPTO_free(a);\n  return CRYPTO_malloc(num, \"mem.c\", 405);\n}\n\n\n Revised code:\nvoid *CRYPTO_remalloc(void *a, int num, const char *file, int line)\n{\n    if (a != NULL)\n        OPENSSL_free(a);\n    a = (char *)OPENSSL_malloc(num);\n    return (a);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_4DA7BB(void **a1)\n{\n  free(a1[2]);\n  free(a1[3]);\n  free(a1[4]);\n  free(a1);\n}\n",
        "output": "void free_resources(void **resources)\n{\n    if (resources != NULL) {\n        free(resources[2]);\n        free(resources[3]);\n        free(resources[4]);\n        free(resources);\n    }\n}",
        "source_code": "static void free_instance(struct fsck_instance *p)\n{\n\tfree(p->prog);\n\tfree(p->device);\n\tfree(p->base_device);\n\tfree(p);\n}",
        "parsed_output": "void free_resources(void **resources)\n{\n    if (resources != NULL) {\n        free(resources[2]);\n        free(resources[3]);\n        free(resources[4]);\n        free(resources);\n    }\n}",
        "baseline_code_stripped": "void __fastcall sub_4DA7BB(void **a1)\n{\n  free(a1[2]);\n  free(a1[3]);\n  free(a1[4]);\n  free(a1);\n}\n",
        "baseline_code_debug": "void __cdecl free_instance(fsck_instance *p)\n{\n  free(p->prog);\n  free(p->device);\n  free(p->base_device);\n  free(p);\n}\n",
        "similarity_score_unixcoder": 0.637330949306488,
        "similarity_score_baseline_stripped": 0.5425723791122437,
        "similarity_score_baseline_debug": 0.929505467414856
    },
    {
        "func_name": "print_queuelen",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nint __cdecl SRP_user_pwd_set_sv(SRP_user_pwd *vinfo, const char *s, const char *v)\n{\n  unsigned __int8 tmp[2500]; // [rsp+20h] [rbp-9D0h] BYREF\n  int len; // [rsp+9ECh] [rbp-4h]\n\n  if ( strlen(s) > 0x9C4 || strlen(v) > 0x9C4 )\n    return 0;\n  len = t_fromb64(tmp, v);\n  vinfo->v = BN_bin2bn(tmp, len, 0LL);\n  if ( !vinfo->v )\n    return 0;\n  len = t_fromb64(tmp, s);\n  vinfo->s = BN_bin2bn(tmp, len, 0LL);\n  return vinfo->s != 0LL;\n}\n\n\n Revised code:\nstatic int SRP_user_pwd_set_sv(SRP_user_pwd *vinfo, const char *s,\n                               const char *v)\n{\n    unsigned char tmp[MAX_LEN];\n    int len;\n\n    if (strlen(s) > MAX_LEN || strlen(v) > MAX_LEN)\n        return 0;\n    len = t_fromb64(tmp, v);\n    if (NULL == (vinfo->v = BN_bin2bn(tmp, len, NULL)))\n        return 0;\n    len = t_fromb64(tmp, s);\n    return ((vinfo->s = BN_bin2bn(tmp, len, NULL)) != NULL);\n}\n\n## Example:\n\n Input code:\n__int64 __cdecl dtls1_ctrl(SSL *s, int cmd, __int64 larg, void *parg)\n{\n  int ret; // [rsp+2Ch] [rbp-4h]\n\n  ret = 0;\n  switch ( cmd )\n  {\n    case 'J':\n      return dtls1_handle_timeout(s);\n    case 'K':\n      return dtls1_listen(s, (sockaddr *)parg);\n    case 'I':\n      if ( dtls1_get_timeout(s, (timeval *)parg) )\n        return 1;\n      break;\n    default:\n      return (int)ssl3_ctrl(s, cmd, larg, parg);\n  }\n  return ret;\n}\n\n\n Revised code:\nlong dtls1_ctrl(SSL *s, int cmd, long larg, void *parg)\n{\n    int ret = 0;\n\n    switch (cmd) {\n    case DTLS_CTRL_GET_TIMEOUT:\n        if (dtls1_get_timeout(s, (struct timeval *)parg) != NULL) {\n            ret = 1;\n        }\n        break;\n    case DTLS_CTRL_HANDLE_TIMEOUT:\n        ret = dtls1_handle_timeout(s);\n        break;\n    case DTLS_CTRL_LISTEN:\n        ret = dtls1_listen(s, parg);\n        break;\n    case SSL_CTRL_CHECK_PROTO_VERSION:\n        /*\n         * For library-internal use; checks that the current protocol is the\n         * highest enabled version (according to s->ctx->method, as version\n         * negotiation may have changed s->method).\n         */\n#if DTLS_MAX_VERSION != DTLS1_VERSION\n# error Code needs update for DTLS_method() support beyond DTLS1_VERSION.\n#endif\n        /*\n         * Just one protocol version is supported so far; fail closed if the\n         * version is not as expected.\n         */\n        return s->version == DTLS_MAX_VERSION;\n    case DTLS_CTRL_SET_LINK_MTU:\n        if (larg < (long)dtls1_link_min_mtu())\n            return 0;\n        s->d1->link_mtu = larg;\n        return 1;\n    case DTLS_CTRL_GET_LINK_MIN_MTU:\n        return (long)dtls1_link_min_mtu();\n    case SSL_CTRL_SET_MTU:\n        /*\n         *  We may not have a BIO set yet so can't call dtls1_min_mtu()\n         *  We'll have to make do with dtls1_link_min_mtu() and max overhead\n         */\n        if (larg < (long)dtls1_link_min_mtu() - DTLS1_MAX_MTU_OVERHEAD)\n            return 0;\n        s->d1->mtu = larg;\n        return larg;\n    default:\n        ret = ssl3_ctrl(s, cmd, larg, parg);\n        break;\n    }\n    return (ret);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_449C97(const char *a1)\n{\n  int result; // eax\n  char s[16]; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v3; // [rsp+20h] [rbp-20h]\n  int fd; // [rsp+3Ch] [rbp-4h]\n\n  result = socket(2, 1, 0);\n  fd = result;\n  if ( result >= 0 )\n  {\n    memset(s, 0, 0x28uLL);\n    sub_409A52(s, a1);\n    if ( (int)sub_40AD08(fd, 0x8942u, (__int64)s, (__int64)\"SIOCGIFTXQLEN\") >= 0 )\n    {\n      close(fd);\n      result = v3;\n      if ( v3 )\n        return printf(\"qlen %d\", v3);\n    }\n    else\n    {\n      return close(fd);\n    }\n  }\n  return result;\n}\n",
        "output": "```c\nint sub_449C97(const char *interface_name)\n{\n    int socket_fd;\n    char ifreq_buffer[16] = {0};\n    unsigned int tx_queue_len;\n\n    socket_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (socket_fd >= 0)\n    {\n        memset(ifreq_buffer, 0, sizeof(ifreq_buffer));\n        prepare_ifreq(ifreq_buffer, interface_name);\n        if (ioctl(socket_fd, SIOCGIFTXQLEN, ifreq_buffer) >= 0)\n        {\n            close(socket_fd);\n            tx_queue_len = *(unsigned int *)(ifreq_buffer + 16);\n            if (tx_queue_len)\n                return printf(\"qlen %u\", tx_queue_len);\n        }\n        else\n        {\n            close(socket_fd);\n        }\n    }\n    return socket_fd;\n}\n```",
        "source_code": "static void print_queuelen(char *name)\n{\n\tstruct ifreq ifr;\n\tint s;\n\n\ts = socket(AF_INET, SOCK_STREAM, 0);\n\tif (s < 0)\n\t\treturn;\n\n\tmemset(&ifr, 0, sizeof(ifr));\n\tstrncpy_IFNAMSIZ(ifr.ifr_name, name);\n\tif (ioctl_or_warn(s, SIOCGIFTXQLEN, &ifr) < 0) {\n\t\tclose(s);\n\t\treturn;\n\t}\n\tclose(s);\n\n\tif (ifr.ifr_qlen)\n\t\tprintf(\"qlen %d\", ifr.ifr_qlen);\n}",
        "parsed_output": "int sub_449C97(const char *interface_name)\n{\n    int socket_fd;\n    char ifreq_buffer[16] = {0};\n    unsigned int tx_queue_len;\n\n    socket_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (socket_fd >= 0)\n    {\n        memset(ifreq_buffer, 0, sizeof(ifreq_buffer));\n        prepare_ifreq(ifreq_buffer, interface_name);\n        if (ioctl(socket_fd, SIOCGIFTXQLEN, ifreq_buffer) >= 0)\n        {\n            close(socket_fd);\n            tx_queue_len = *(unsigned int *)(ifreq_buffer + 16);\n            if (tx_queue_len)\n                return printf(\"qlen %u\", tx_queue_len);\n        }\n        else\n        {\n            close(socket_fd);\n        }\n    }\n    return socket_fd;\n}",
        "baseline_code_stripped": "int __fastcall sub_449C97(const char *a1)\n{\n  int result; // eax\n  char s[16]; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v3; // [rsp+20h] [rbp-20h]\n  int fd; // [rsp+3Ch] [rbp-4h]\n\n  result = socket(2, 1, 0);\n  fd = result;\n  if ( result >= 0 )\n  {\n    memset(s, 0, 0x28uLL);\n    sub_409A52(s, a1);\n    if ( (int)sub_40AD08(fd, 0x8942u, (__int64)s, (__int64)\"SIOCGIFTXQLEN\") >= 0 )\n    {\n      close(fd);\n      result = v3;\n      if ( v3 )\n        return printf(\"qlen %d\", v3);\n    }\n    else\n    {\n      return close(fd);\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl print_queuelen(char *name)\n{\n  ifreq ifr; // [rsp+10h] [rbp-30h] BYREF\n  int s; // [rsp+3Ch] [rbp-4h]\n\n  s = socket(2, 1, 0);\n  if ( s >= 0 )\n  {\n    memset(&ifr, 0, sizeof(ifr));\n    strncpy_IFNAMSIZ(ifr.ifr_ifrn.ifrn_name, name);\n    if ( bb_ioctl_or_warn(s, 0x8942u, &ifr, \"SIOCGIFTXQLEN\") >= 0 )\n    {\n      close(s);\n      if ( ifr.ifr_ifru.ifru_ivalue )\n        printf(\"qlen %d\", (unsigned int)ifr.ifr_ifru.ifru_ivalue);\n    }\n    else\n    {\n      close(s);\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.8109346628189087,
        "similarity_score_baseline_stripped": 0.5541179776191711,
        "similarity_score_baseline_debug": 0.8101906180381775
    },
    {
        "func_name": "colon_process",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl make_kn(unsigned __int8 *k1_0, unsigned __int8 *l, int bl_0)\n{\n  unsigned __int8 v3; // dl\n  char v4; // al\n  int i; // [rsp+20h] [rbp-4h]\n\n  for ( i = 0; i < bl_0; ++i )\n  {\n    k1_0[i] = 2 * l[i];\n    if ( i < bl_0 - 1 && (l[i + 1] & 0x80u) != 0 )\n      k1_0[i] |= 1u;\n  }\n  if ( (*l & 0x80u) != 0 )\n  {\n    v3 = k1_0[bl_0 - 1];\n    if ( bl_0 == 16 )\n      v4 = -121;\n    else\n      v4 = 27;\n    k1_0[bl_0 - 1] = v3 ^ v4;\n  }\n}\n\n\n Revised code:\nstatic void make_kn(unsigned char *k1, unsigned char *l, int bl)\n{\n    int i;\n    /* Shift block to left, including carry */\n    for (i = 0; i < bl; i++) {\n        k1[i] = l[i] << 1;\n        if (i < bl - 1 && l[i + 1] & 0x80)\n            k1[i] |= 1;\n    }\n    /* If MSB set fixup with R */\n    if (l[0] & 0x80)\n        k1[bl - 1] ^= bl == 16 ? 0x87 : 0x1b;\n}\n\n## Example:\n\n Input code:\nint __cdecl t_fromb64(unsigned __int8 *a, const char *src)\n{\n  int v2; // eax\n  unsigned __int8 *v3; // rcx\n  int v4; // eax\n  char *loc; // [rsp+18h] [rbp-18h]\n  int size; // [rsp+24h] [rbp-Ch]\n  int sizea; // [rsp+24h] [rbp-Ch]\n  int j; // [rsp+28h] [rbp-8h]\n  int i; // [rsp+2Ch] [rbp-4h]\n  int ia; // [rsp+2Ch] [rbp-4h]\n  int ib; // [rsp+2Ch] [rbp-4h]\n  int ic; // [rsp+2Ch] [rbp-4h]\n  int id; // [rsp+2Ch] [rbp-4h]\n  int ie; // [rsp+2Ch] [rbp-4h]\n\n  while ( *src && (*src == 32 || *src == 9 || *src == 10) )\n    ++src;\n  size = strlen(src);\n  for ( i = 0; i < size; ++i )\n  {\n    loc = strchr(b64table, src[i]);\n    if ( !loc )\n      break;\n    a[i] = loc - b64table;\n  }\n  sizea = i;\n  ia = i - 1;\n  j = sizea;\n  do\n  {\n    a[j] = a[ia];\n    ib = ia - 1;\n    if ( ib < 0 )\n      break;\n    a[j--] |= a[ib] << 6;\n    a[j] = ((int)a[ib] >> 2) & 0xF;\n    ic = ib - 1;\n    if ( ic < 0 )\n      break;\n    a[j--] |= 16 * a[ic];\n    a[j] = ((int)a[ic] >> 4) & 3;\n    id = ic - 1;\n    if ( id < 0 )\n      break;\n    a[j--] |= 4 * a[id];\n    a[j] = 0;\n    ia = id - 1;\n  }\n  while ( ia >= 0 );\n  while ( !a[j] && j <= sizea )\n    ++j;\n  ie = 0;\n  while ( j <= sizea )\n  {\n    v2 = j++;\n    v3 = &a[v2];\n    v4 = ie++;\n    a[v4] = *v3;\n  }\n  return ie;\n}\n\n\n Revised code:\nstatic int t_fromb64(unsigned char *a, const char *src)\n{\n    char *loc;\n    int i, j;\n    int size;\n\n    while (*src && (*src == ' ' || *src == '\\t' || *src == '\\n'))\n        ++src;\n    size = strlen(src);\n    i = 0;\n    while (i < size) {\n        loc = strchr(b64table, src[i]);\n        if (loc == (char *)0)\n            break;\n        else\n            a[i] = loc - b64table;\n        ++i;\n    }\n    /* if nothing valid to process we have a zero length response */\n    if (i == 0)\n        return 0;\n    size = i;\n    i = size - 1;\n    j = size;\n    while (1) {\n        a[j] = a[i];\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] & 3) << 6;\n        --j;\n        a[j] = (unsigned char)((a[i] & 0x3c) >> 2);\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] & 0xf) << 4;\n        --j;\n        a[j] = (unsigned char)((a[i] & 0x30) >> 4);\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] << 2);\n\n        a[--j] = 0;\n        if (--i < 0)\n            break;\n    }\n    while (a[j] == 0 && j <= size)\n        ++j;\n    i = 0;\n    while (j <= size)\n        a[i++] = a[j++];\n    return i;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_41E736(__int64 a1, size_t a2)\n{\n  sub_41CB0F(\" :\");\n  switch ( (unsigned int)sub_41E32F(2) )\n  {\n    case 'd':\n      sub_41E610(2LL, a2);\n      break;\n    case 'e':\n      sub_41E48A(2LL, a2);\n      break;\n    case 'f':\n      sub_41D49C();\n      break;\n    case 'n':\n      sub_41E546(1, a2);\n      break;\n    case 'p':\n      sub_41E546(-1, a2);\n      break;\n    case 'q':\n      sub_41CB48(0);\n    case 'x':\n      sub_41E546(0, a2);\n      break;\n    default:\n      return;\n  }\n}\n",
        "output": "```c\nstatic void process_command(__int64 context, size_t arg)\n{\n    set_delimiters(\" :\");\n    switch (get_command_type(2))\n    {\n        case 'd':\n            handle_command_d(2LL, arg);\n            break;\n        case 'e':\n            handle_command_e(2LL, arg);\n            break;\n        case 'f':\n            handle_command_f();\n            break;\n        case 'n':\n            handle_command_n(1, arg);\n            break;\n        case 'p':\n            handle_command_p(-1, arg);\n            break;\n        case 'q':\n            exit_command(0);\n            // Fallthrough intended\n        case 'x':\n            handle_command_x(0, arg);\n            break;\n        default:\n            // No action for unrecognized command\n            break;\n    }\n}\n```",
        "source_code": "static void colon_process(void)\n{\n\tint keypress;\n\n\t/* Clear the current line and print a prompt */\n\tprint_statusline(\" :\");\n\n\tkeypress = less_getch(2);\n\tswitch (keypress) {\n\tcase 'd':\n\t\tremove_current_file();\n\t\tbreak;\n\tcase 'e':\n\t\texamine_file();\n\t\tbreak;\n#if ENABLE_FEATURE_LESS_FLAGS\n\tcase 'f':\n\t\tm_status_print();\n\t\tbreak;\n#endif\n\tcase 'n':\n\t\tchange_file(1);\n\t\tbreak;\n\tcase 'p':\n\t\tchange_file(-1);\n\t\tbreak;\n\tcase 'q':\n\t\tless_exit(EXIT_SUCCESS);\n\t\tbreak;\n\tcase 'x':\n\t\tchange_file(0);\n\t\tbreak;\n\t}\n}",
        "parsed_output": "static void process_command(__int64 context, size_t arg)\n{\n    set_delimiters(\" :\");\n    switch (get_command_type(2))\n    {\n        case 'd':\n            handle_command_d(2LL, arg);\n            break;\n        case 'e':\n            handle_command_e(2LL, arg);\n            break;\n        case 'f':\n            handle_command_f();\n            break;\n        case 'n':\n            handle_command_n(1, arg);\n            break;\n        case 'p':\n            handle_command_p(-1, arg);\n            break;\n        case 'q':\n            exit_command(0);\n            // Fallthrough intended\n        case 'x':\n            handle_command_x(0, arg);\n            break;\n        default:\n            // No action for unrecognized command\n            break;\n    }\n}",
        "baseline_code_stripped": "void __fastcall sub_41E736(__int64 a1, size_t a2)\n{\n  sub_41CB0F(\" :\");\n  switch ( (unsigned int)sub_41E32F(2) )\n  {\n    case 'd':\n      sub_41E610(2LL, a2);\n      break;\n    case 'e':\n      sub_41E48A(2LL, a2);\n      break;\n    case 'f':\n      sub_41D49C();\n      break;\n    case 'n':\n      sub_41E546(1, a2);\n      break;\n    case 'p':\n      sub_41E546(-1, a2);\n      break;\n    case 'q':\n      sub_41CB48(0);\n    case 'x':\n      sub_41E546(0, a2);\n      break;\n    default:\n      return;\n  }\n}\n",
        "baseline_code_debug": "void __cdecl colon_process()\n{\n  print_statusline(\" :\");\n  switch ( (unsigned int)less_getch(2) )\n  {\n    case 'd':\n      remove_current_file();\n      break;\n    case 'e':\n      examine_file();\n      break;\n    case 'f':\n      m_status_print();\n      break;\n    case 'n':\n      change_file(1);\n      break;\n    case 'p':\n      change_file(-1);\n      break;\n    case 'q':\n      less_exit(0);\n      return;\n    case 'x':\n      change_file(0);\n      break;\n    default:\n      return;\n  }\n}\n",
        "similarity_score_unixcoder": 0.7002297043800354,
        "similarity_score_baseline_stripped": 0.5506695508956909,
        "similarity_score_baseline_debug": 0.8896037340164185
    },
    {
        "func_name": "xfopen_stdin",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __cdecl roundv(double value)\n{\n  __int64 intpart; // [rsp+10h] [rbp-8h]\n\n  intpart = (unsigned int)(int)value;\n  if ( value - (double)(int)value >= 0.5 )\n    ++intpart;\n  return intpart;\n}\n\n\n Revised code:\nstatic long roundv(LDOUBLE value)\n{\n    long intpart;\n    intpart = (long)value;\n    value = value - intpart;\n    if (value >= 0.5)\n        intpart++;\n    return intpart;\n}\n\n## Example:\n\n Input code:\ndouble __cdecl abs_val(double value)\n{\n  double result; // [rsp+10h] [rbp-8h]\n\n  result = value;\n  if ( value < 0.0 )\n    return -value;\n  return result;\n}\n\n\n Revised code:\nstatic LDOUBLE abs_val(LDOUBLE value)\n{\n    LDOUBLE result = value;\n    if (value < 0)\n        result = -value;\n    return result;\n}\n\n## Example:\n\n Input code:\nint __cdecl der_cmp(const void *a, const void *b)\n{\n  int v2; // eax\n  int i; // [rsp+18h] [rbp-18h]\n\n  v2 = *((_DWORD *)a + 2);\n  if ( *((_DWORD *)b + 2) <= v2 )\n    v2 = *((_DWORD *)b + 2);\n  i = memcmp(*(const void **)a, *(const void **)b, v2);\n  if ( i )\n    return i;\n  else\n    return *((_DWORD *)a + 2) - *((_DWORD *)b + 2);\n}\n\n\n Revised code:\nstatic int der_cmp(const void *a, const void *b)\n{\n    const DER_ENC *d1 = a, *d2 = b;\n    int cmplen, i;\n    cmplen = (d1->length < d2->length) ? d1->length : d2->length;\n    i = memcmp(d1->data, d2->data, cmplen);\n    if (i)\n        return i;\n    return d1->length - d2->length;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nFILE *__fastcall sub_50A7F5(__int64 a1)\n{\n  FILE *v2; // [rsp+18h] [rbp-8h]\n\n  v2 = sub_50A79F(a1);\n  if ( !v2 )\n    sub_40992F();\n  return v2;\n}\n",
        "output": "```c\nstatic FILE *open_file(__int64 file_id)\n{\n    FILE *file = get_file_pointer(file_id);\n    if (!file)\n        handle_file_error();\n    return file;\n}\n```",
        "source_code": "FAST_FUNC xfopen_stdin(const char *filename)\n{\n\tFILE *fp = fopen_or_warn_stdin(filename);\n\tif (fp)\n\t\treturn fp;\n\txfunc_die();  /* We already output an error message. */\n}",
        "parsed_output": "static FILE *open_file(__int64 file_id)\n{\n    FILE *file = get_file_pointer(file_id);\n    if (!file)\n        handle_file_error();\n    return file;\n}",
        "baseline_code_stripped": "FILE *__fastcall sub_50A7F5(__int64 a1)\n{\n  FILE *v2; // [rsp+18h] [rbp-8h]\n\n  v2 = sub_50A79F(a1);\n  if ( !v2 )\n    sub_40992F();\n  return v2;\n}\n",
        "baseline_code_debug": "FILE *__cdecl xfopen_stdin(const char *filename)\n{\n  FILE *fp; // [rsp+18h] [rbp-8h]\n\n  fp = fopen_or_warn_stdin(filename);\n  if ( !fp )\n    xfunc_die();\n  return fp;\n}\n",
        "similarity_score_unixcoder": 0.6173005104064941,
        "similarity_score_baseline_stripped": 0.4857487380504608,
        "similarity_score_baseline_debug": 0.8808138966560364
    },
    {
        "func_name": "setprompt_if",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_46FD3E(unsigned int a1, __int64 a2)\n{\n  __int64 result; // rax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  const char *v7; // rax\n  _QWORD v8[5]; // [rsp+10h] [rbp-30h] BYREF\n  __int64 v9; // [rsp+38h] [rbp-8h]\n\n  result = a1;\n  if ( (_BYTE)a1 )\n  {\n    byte_75AF79 = 0;\n    if ( (_DWORD)a2 == 1 )\n    {\n      v9 = *(_QWORD *)(qword_75D420 + 432) + 4LL;\n    }\n    else if ( (_DWORD)a2 == 2 )\n    {\n      v9 = *(_QWORD *)(qword_75D420 + 464) + 4LL;\n    }\n    else\n    {\n      v9 = qword_75D418 + 56;\n    }\n    sub_46E8A1(v8);\n    sub_46E6A8(*(_QWORD *)(qword_75D428 + 32), a2, v3, v4, v5, v6);\n    v7 = (const char *)sub_47DDA0(v9);\n    sub_46FD0D(v7, a2);\n    return sub_46E905(v8, a2);\n  }\n  return result;\n}\n",
        "output": "```c\nstatic __int64 sub_46FD3E(unsigned int a1, __int64 a2)\n{\n    __int64 result;\n    __int64 offset;\n\n    result = a1;\n    if (a1 & 0xFF) // Check if the least significant byte is non-zero\n    {\n        byte_75AF79 = 0;\n        switch (a2)\n        {\n            case 1:\n                offset = *(_QWORD *)(qword_75D420 + 432) + 4;\n                break;\n            case 2:\n                offset = *(_QWORD *)(qword_75D420 + 464) + 4;\n                break;\n            default:\n                offset = qword_75D418 + 56;\n                break;\n        }\n        _QWORD v8[5]; // Temporary buffer\n        sub_46E8A1(v8); // Initialize buffer\n        sub_46E6A8(*(_QWORD *)(qword_75D428 + 32), a2); // Perform some operation\n        const char *v7 = (const char *)sub_47DDA0(offset); // Get some string based on the offset\n        sub_46FD0D(v7, a2); // Perform another operation with the string\n        result = sub_46E905(v8, a2); // Finalize operation with buffer and return result\n    }\n    return result;\n}\n```",
        "source_code": "endif\n\nstatic void\nsetprompt_if(smallint do_set, int whichprompt)\n{\n\tconst char *prompt;\n\tIF_ASH_EXPAND_PRMT(struct stackmark smark;)\n\n\tif (!do_set)\n\t\treturn;\n\n\tneedprompt = 0;\n\n\tswitch (whichprompt) {\n\tcase 1:\n\t\tprompt = ps1val();\n\t\tbreak;\n\tcase 2:\n\t\tprompt = ps2val();\n\t\tbreak;\n\tdefault:                        /* 0 */\n\t\tprompt = nullstr;\n\t}\n#if ENABLE_ASH_EXPAND_PRMT\n\tsetstackmark(&smark);\n\tstalloc(stackblocksize());\n#endif\n\tputprompt(expandstr(prompt));\n#if ENABLE_ASH_EXPAND_PRMT\n\tpopstackmark(&smark);\n#endif\n}",
        "parsed_output": "static __int64 sub_46FD3E(unsigned int a1, __int64 a2)\n{\n    __int64 result;\n    __int64 offset;\n\n    result = a1;\n    if (a1 & 0xFF) // Check if the least significant byte is non-zero\n    {\n        byte_75AF79 = 0;\n        switch (a2)\n        {\n            case 1:\n                offset = *(_QWORD *)(qword_75D420 + 432) + 4;\n                break;\n            case 2:\n                offset = *(_QWORD *)(qword_75D420 + 464) + 4;\n                break;\n            default:\n                offset = qword_75D418 + 56;\n                break;\n        }\n        _QWORD v8[5]; // Temporary buffer\n        sub_46E8A1(v8); // Initialize buffer\n        sub_46E6A8(*(_QWORD *)(qword_75D428 + 32), a2); // Perform some operation\n        const char *v7 = (const char *)sub_47DDA0(offset); // Get some string based on the offset\n        sub_46FD0D(v7, a2); // Perform another operation with the string\n        result = sub_46E905(v8, a2); // Finalize operation with buffer and return result\n    }\n    return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_46FD3E(unsigned int a1, __int64 a2)\n{\n  __int64 result; // rax\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  const char *v7; // rax\n  _QWORD v8[5]; // [rsp+10h] [rbp-30h] BYREF\n  __int64 v9; // [rsp+38h] [rbp-8h]\n\n  result = a1;\n  if ( (_BYTE)a1 )\n  {\n    byte_75AF79 = 0;\n    if ( (_DWORD)a2 == 1 )\n    {\n      v9 = *(_QWORD *)(qword_75D420 + 432) + 4LL;\n    }\n    else if ( (_DWORD)a2 == 2 )\n    {\n      v9 = *(_QWORD *)(qword_75D420 + 464) + 4LL;\n    }\n    else\n    {\n      v9 = qword_75D418 + 56;\n    }\n    sub_46E8A1(v8);\n    sub_46E6A8(*(_QWORD *)(qword_75D428 + 32), a2, v3, v4, v5, v6);\n    v7 = (const char *)sub_47DDA0(v9);\n    sub_46FD0D(v7, a2);\n    return sub_46E905(v8, a2);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl setprompt_if(smallint do_set, int whichprompt)\n{\n  const char *v2; // rax\n  stackmark smark; // [rsp+10h] [rbp-30h] BYREF\n  const char *prompt; // [rsp+38h] [rbp-8h]\n\n  if ( do_set )\n  {\n    needprompt[0] = 0;\n    if ( whichprompt == 1 )\n    {\n      prompt = ash_ptr_to_globals_var->varinit[2].var_text + 4;\n    }\n    else if ( whichprompt == 2 )\n    {\n      prompt = ash_ptr_to_globals_var->varinit[3].var_text + 4;\n    }\n    else\n    {\n      prompt = ash_ptr_to_globals_misc->nullstr;\n    }\n    setstackmark(&smark);\n    stalloc(ash_ptr_to_globals_memstack->g_stacknleft);\n    v2 = expandstr(prompt);\n    putprompt(v2);\n    popstackmark(&smark);\n  }\n}\n",
        "similarity_score_unixcoder": 0.46621042490005493,
        "similarity_score_baseline_stripped": 0.43186479806900024,
        "similarity_score_baseline_debug": 0.7888777256011963
    },
    {
        "func_name": "send_NAK",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_456160(__int64 a1)\n{\n  int v1; // edx\n  int v2; // ecx\n  int v3; // r8d\n  int v4; // r9d\n  char v6[640]; // [rsp+10h] [rbp-280h] BYREF\n\n  sub_455D51((__int64)v6, a1, 6);\n  if ( dword_75D460 )\n    sub_4FDABC((unsigned int)\"Sending NAK\", a1, v1, v2, v3, v4);\n  return sub_455D15((__int64)v6, 1, v1, v2, v3, v4);\n}\n",
        "output": "```c\n__int64 sub_456160(__int64 a1)\n{\n    char buffer[640];\n\n    sub_455D51((long long)buffer, a1, 6);\n    if (dword_75D460)\n        sub_4FDABC(\"Sending NAK\", a1);\n    return sub_455D15((long long)buffer, 1);\n}\n```",
        "source_code": "static NOINLINE void send_NAK(struct dhcp_packet *oldpacket)\n{\n\tstruct dhcp_packet packet;\n\n\tinit_packet(&packet, oldpacket, DHCPNAK);\n\n\tlog1(\"Sending NAK\");\n\tsend_packet(&packet, /*force_bcast:*/ 1);\n}",
        "parsed_output": "__int64 sub_456160(__int64 a1)\n{\n    char buffer[640];\n\n    sub_455D51((long long)buffer, a1, 6);\n    if (dword_75D460)\n        sub_4FDABC(\"Sending NAK\", a1);\n    return sub_455D15((long long)buffer, 1);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_456160(__int64 a1)\n{\n  int v1; // edx\n  int v2; // ecx\n  int v3; // r8d\n  int v4; // r9d\n  char v6[640]; // [rsp+10h] [rbp-280h] BYREF\n\n  sub_455D51((__int64)v6, a1, 6);\n  if ( dword_75D460 )\n    sub_4FDABC((unsigned int)\"Sending NAK\", a1, v1, v2, v3, v4);\n  return sub_455D15((__int64)v6, 1, v1, v2, v3, v4);\n}\n",
        "baseline_code_debug": "void __cdecl send_NAK(dhcp_packet *oldpacket)\n{\n  dhcp_packet packet; // [rsp+10h] [rbp-280h] BYREF\n\n  init_packet_0(&packet, oldpacket, 6);\n  if ( dhcp_verbose )\n    bb_info_msg(\"Sending NAK\");\n  send_packet(&packet, 1);\n}\n",
        "similarity_score_unixcoder": 0.467952698469162,
        "similarity_score_baseline_stripped": 0.41566652059555054,
        "similarity_score_baseline_debug": 0.8072834610939026
    },
    {
        "func_name": "do_ioctl_get_iftype",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\n__int64 __cdecl slg_ctrl(BIO *b, int cmd, __int64 num, void *ptr)\n{\n  int numa; // [rsp+8h] [rbp-18h]\n\n  numa = num;\n  if ( cmd == 4 )\n  {\n    xcloselog(b);\n    xopenlog(b, (char *)ptr, numa);\n  }\n  return 0LL;\n}\n\n\n Revised code:\nstatic long MS_CALLBACK slg_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    switch (cmd) {\n    case BIO_CTRL_SET:\n        xcloselog(b);\n        xopenlog(b, ptr, num);\n        break;\n    default:\n        break;\n    }\n    return (0);\n}\n\n## Example:\n\n Input code:\nint __cdecl ipv4_from_asc(unsigned __int8 *v4, const char *in)\n{\n  int a3; // [rsp+10h] [rbp-10h] BYREF\n  int a2; // [rsp+14h] [rbp-Ch] BYREF\n  int a1; // [rsp+18h] [rbp-8h] BYREF\n  int a0; // [rsp+1Ch] [rbp-4h] BYREF\n\n  if ( (unsigned int)__isoc99_sscanf(in, \"%d.%d.%d.%d\", &a0, &a1, &a2, &a3) != 4 )\n    return 0;\n  if ( (unsigned int)a0 > 0xFF || (unsigned int)a1 > 0xFF || (unsigned int)a2 > 0xFF || (unsigned int)a3 >= 0x100 )\n    return 0;\n  *v4 = a0;\n  v4[1] = a1;\n  v4[2] = a2;\n  v4[3] = a3;\n  return 1;\n}\n\n\n Revised code:\nstatic int ipv4_from_asc(unsigned char *v4, const char *in)\n{\n    int a0, a1, a2, a3;\n    if (sscanf(in, \"%d.%d.%d.%d\", &a0, &a1, &a2, &a3) != 4)\n        return 0;\n    if ((a0 < 0) || (a0 > 255) || (a1 < 0) || (a1 > 255)\n        || (a2 < 0) || (a2 > 255) || (a3 < 0) || (a3 > 255))\n        return 0;\n    v4[0] = a0;\n    v4[1] = a1;\n    v4[2] = a2;\n    v4[3] = a3;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_44F653(const char *a1)\n{\n  char v2[16]; // [rsp+10h] [rbp-30h] BYREF\n  unsigned __int16 v3; // [rsp+20h] [rbp-20h]\n  int v4; // [rsp+38h] [rbp-8h]\n  int fd; // [rsp+3Ch] [rbp-4h]\n\n  sub_409A52(v2, a1);\n  fd = sub_40A999(2, 2u, 0);\n  v4 = sub_40AD08(fd, 0x8927u, (__int64)v2, (__int64)\"SIOCGIFHWADDR\");\n  close(fd);\n  if ( v4 )\n    return 0xFFFFFFFFLL;\n  else\n    return v3;\n}\n",
        "output": "```c\nstatic long get_interface_hwaddr(const char *interface_name)\n{\n    char hwaddr[16];\n    unsigned short hwaddr_short;\n    int result;\n    int fd;\n\n    get_interface_index(hwaddr, interface_name);\n    fd = create_socket(AF_INET, SOCK_DGRAM, 0);\n    result = ioctl(fd, SIOCGIFHWADDR, hwaddr);\n    close(fd);\n    if (result != 0)\n        return -1;\n    else\n        return hwaddr_short;\n}\n```",
        "source_code": "static int do_ioctl_get_iftype(char *dev)\n{\n\tstruct ifreq ifr;\n\tint fd;\n\tint err;\n\n\tstrncpy_IFNAMSIZ(ifr.ifr_name, dev);\n\tfd = xsocket(AF_INET, SOCK_DGRAM, 0);\n\terr = ioctl_or_warn(fd, SIOCGIFHWADDR, &ifr);\n\tclose(fd);\n\treturn err ? -1 : ifr.ifr_addr.sa_family;\n}",
        "parsed_output": "static long get_interface_hwaddr(const char *interface_name)\n{\n    char hwaddr[16];\n    unsigned short hwaddr_short;\n    int result;\n    int fd;\n\n    get_interface_index(hwaddr, interface_name);\n    fd = create_socket(AF_INET, SOCK_DGRAM, 0);\n    result = ioctl(fd, SIOCGIFHWADDR, hwaddr);\n    close(fd);\n    if (result != 0)\n        return -1;\n    else\n        return hwaddr_short;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_44F653(const char *a1)\n{\n  char v2[16]; // [rsp+10h] [rbp-30h] BYREF\n  unsigned __int16 v3; // [rsp+20h] [rbp-20h]\n  int v4; // [rsp+38h] [rbp-8h]\n  int fd; // [rsp+3Ch] [rbp-4h]\n\n  sub_409A52(v2, a1);\n  fd = sub_40A999(2, 2u, 0);\n  v4 = sub_40AD08(fd, 0x8927u, (__int64)v2, (__int64)\"SIOCGIFHWADDR\");\n  close(fd);\n  if ( v4 )\n    return 0xFFFFFFFFLL;\n  else\n    return v3;\n}\n",
        "baseline_code_debug": "int __cdecl do_ioctl_get_iftype(char *dev)\n{\n  ifreq ifr; // [rsp+10h] [rbp-30h] BYREF\n  int err; // [rsp+38h] [rbp-8h]\n  int fd; // [rsp+3Ch] [rbp-4h]\n\n  strncpy_IFNAMSIZ(ifr.ifr_ifrn.ifrn_name, dev);\n  fd = xsocket(2, 2, 0);\n  err = bb_ioctl_or_warn(fd, 0x8927u, &ifr, \"SIOCGIFHWADDR\");\n  close(fd);\n  if ( err )\n    return -1;\n  else\n    return ifr.ifr_ifru.ifru_addr.sa_family;\n}\n",
        "similarity_score_unixcoder": 0.7858826518058777,
        "similarity_score_baseline_stripped": 0.4420697093009949,
        "similarity_score_baseline_debug": 0.807101309299469
    },
    {
        "func_name": "init_handle",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_QWORD *__fastcall sub_4C1B39(__int64 a1, __int64 a2)\n{\n  _QWORD *v3; // [rsp+8h] [rbp-8h]\n\n  v3 = sub_40A0E8(0x90uLL, a2);\n  v3[5] = sub_40A0E8(0x48uLL, a2);\n  v3[6] = sub_4C353C;\n  v3[7] = sub_4B74BA;\n  v3[1] = sub_4C3516;\n  v3[8] = sub_4C341A;\n  return v3;\n}\n",
        "output": "```c\nvoid *(*sub_4C1B39)(size_t size, __int64 a2)\n{\n    void *(*v3)(size_t size, __int64 a2);\n\n    v3 = sub_40A0E8(0x90, a2);\n    *((void (**)(void))v3 + 5) = sub_40A0E8(0x48, a2);\n    *((void (**)(void))v3 + 6) = sub_4C353C;\n    *((void (**)(void))v3 + 7) = sub_4B74BA;\n    *((void (**)(void))v3 + 1) = sub_4C3516;\n    *((void (**)(void))v3 + 8) = sub_4C341A;\n    return v3;\n}\n```",
        "source_code": "FAST_FUNC init_handle(void)\n{\n\tarchive_handle_t *archive_handle;\n\n\t/* Initialize default values */\n\tarchive_handle = xzalloc(sizeof(archive_handle_t));\n\tarchive_handle->file_header = xzalloc(sizeof(file_header_t));\n\tarchive_handle->action_header = header_skip;\n\tarchive_handle->action_data = data_skip;\n\tarchive_handle->filter = filter_accept_all;\n\tarchive_handle->seek = seek_by_jump;\n\n\treturn archive_handle;\n}",
        "parsed_output": "void *(*sub_4C1B39)(size_t size, __int64 a2)\n{\n    void *(*v3)(size_t size, __int64 a2);\n\n    v3 = sub_40A0E8(0x90, a2);\n    *((void (**)(void))v3 + 5) = sub_40A0E8(0x48, a2);\n    *((void (**)(void))v3 + 6) = sub_4C353C;\n    *((void (**)(void))v3 + 7) = sub_4B74BA;\n    *((void (**)(void))v3 + 1) = sub_4C3516;\n    *((void (**)(void))v3 + 8) = sub_4C341A;\n    return v3;\n}",
        "baseline_code_stripped": "_QWORD *__fastcall sub_4C1B39(__int64 a1, __int64 a2)\n{\n  _QWORD *v3; // [rsp+8h] [rbp-8h]\n\n  v3 = sub_40A0E8(0x90uLL, a2);\n  v3[5] = sub_40A0E8(0x48uLL, a2);\n  v3[6] = sub_4C353C;\n  v3[7] = sub_4B74BA;\n  v3[1] = sub_4C3516;\n  v3[8] = sub_4C341A;\n  return v3;\n}\n",
        "baseline_code_debug": "archive_handle_t_0 *__cdecl init_handle()\n{\n  archive_handle_t_0 *archive_handle; // [rsp+8h] [rbp-8h]\n\n  archive_handle = (archive_handle_t_0 *)xzalloc(0x90uLL);\n  archive_handle->file_header = (file_header_t_0 *)xzalloc(0x48uLL);\n  archive_handle->action_header = (void (*)(const file_header_t_0 *))header_skip;\n  archive_handle->action_data = (void (*)(archive_handle_t *))data_skip;\n  archive_handle->filter = (char (*)(archive_handle_t *))filter_accept_all;\n  archive_handle->seek = (void (*)(int, off_t))seek_by_jump;\n  return archive_handle;\n}\n",
        "similarity_score_unixcoder": 0.4186094105243683,
        "similarity_score_baseline_stripped": 0.3482397794723511,
        "similarity_score_baseline_debug": 0.8778550624847412
    },
    {
        "func_name": "run_shutdown_and_kill_processes",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl private_RC4_set_key(RC4_KEY *key, int len, const unsigned __int8 *data)\n{\n  unsigned __int8 *v3; // r12\n  int v4; // ebx\n  int v5; // r13d\n  unsigned __int8 v6; // r14\n  int v7; // ebx\n  int v8; // r13d\n  unsigned __int8 v9; // r14\n  int v10; // ebx\n  int v11; // r13d\n  unsigned __int8 v12; // r14\n  int v13; // ebx\n  int v14; // r13d\n  unsigned __int8 v15; // r14\n  unsigned int i; // [rsp+24h] [rbp-24h]\n  unsigned int ia; // [rsp+24h] [rbp-24h]\n\n  v3 = key->data;\n  key->x = 0;\n  key->y = 0;\n  LOBYTE(v4) = 0;\n  v5 = 0;\n  for ( i = 0; i <= 0xFF; ++i )\n    v3[i] = i;\n  for ( ia = 0; ia <= 0xFF; ia += 4 )\n  {\n    v6 = v3[ia];\n    v7 = (unsigned __int8)(v4 + data[v5] + v6);\n    v8 = v5 + 1;\n    if ( v8 == len )\n      v8 = 0;\n    v3[ia] = v3[v7];\n    v3[v7] = v6;\n    v9 = v3[ia + 1];\n    v10 = (unsigned __int8)(v7 + data[v8] + v9);\n    v11 = v8 + 1;\n    if ( v11 == len )\n      v11 = 0;\n    v3[ia + 1] = v3[v10];\n    v3[v10] = v9;\n    v12 = v3[ia + 2];\n    v13 = (unsigned __int8)(v10 + data[v11] + v12);\n    v14 = v11 + 1;\n    if ( v14 == len )\n      v14 = 0;\n    v3[ia + 2] = v3[v13];\n    v3[v13] = v12;\n    v15 = v3[ia + 3];\n    v4 = (unsigned __int8)(v13 + data[v14] + v15);\n    v5 = v14 + 1;\n    if ( v5 == len )\n      v5 = 0;\n    v3[ia + 3] = v3[v4];\n    v3[v4] = v15;\n  }\n}\n\n\n Revised code:\nvoid private_RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)\n{\n    register RC4_INT tmp;\n    register int id1, id2;\n    register RC4_INT *d;\n    unsigned int i;\n\n    d = &(key->data[0]);\n    key->x = 0;\n    key->y = 0;\n    id1 = id2 = 0;\n\n#define SK_LOOP(d,n) { \\\n                tmp=d[(n)]; \\\n                id2 = (data[id1] + tmp + id2) & 0xff; \\\n                if (++id1 == len) id1=0; \\\n                d[(n)]=d[id2]; \\\n                d[id2]=tmp; }\n\n    for (i = 0; i < 256; i++)\n        d[i] = i;\n    for (i = 0; i < 256; i += 4) {\n        SK_LOOP(d, i + 0);\n        SK_LOOP(d, i + 1);\n        SK_LOOP(d, i + 2);\n        SK_LOOP(d, i + 3);\n    }\n}\n\n## Example:\n\n Input code:\nint BIO_printf(BIO *bio, const char *format, ...)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list args; // [rsp+10h] [rbp-D0h] BYREF\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(args, format);\n  v2 = va_arg(args, _QWORD);\n  v3 = va_arg(args, _QWORD);\n  v4 = va_arg(args, _QWORD);\n  v5 = va_arg(args, _QWORD);\n  v8 = v2;\n  v9 = v3;\n  v10 = v4;\n  v11 = v5;\n  args[0].gp_offset = 16;\n  return BIO_vprintf(bio, format, args);\n}\n\n\n Revised code:\nint BIO_printf(BIO *bio, const char *format, ...)\n{\n    va_list args;\n    int ret;\n\n    va_start(args, format);\n\n    ret = BIO_vprintf(bio, format, args);\n\n    va_end(args);\n    return (ret);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid sub_4F5713()\n{\n  __int64 v0; // rdx\n  __int64 v1; // rcx\n  __int64 v2; // r8\n  __int64 v3; // r9\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n\n  sub_4F5345(0x40u);\n  sub_4F4BC2(3, \"The system is going down NOW!\", v0, v1, v2, v3);\n  kill(-1, 15);\n  sub_4F4BC2(3, \"Sent SIG%s to all processes\", (__int64)\"TERM\", v4, v5, v6);\n  sync();\n  sleep(1u);\n  kill(-1, 9);\n  sub_4F4BC2(2, \"Sent SIG%s to all processes\", (__int64)\"KILL\", v7, v8, v9);\n  sync();\n}\n",
        "output": "void shutdown_system()\n{\n    sub_4F5345(0x40u);\n    sub_4F4BC2(3, \"The system is going down NOW!\");\n    kill(-1, SIGTERM);\n    sub_4F4BC2(3, \"Sent SIGTERM to all processes\");\n    sync();\n    sleep(1u);\n    kill(-1, SIGKILL);\n    sub_4F4BC2(2, \"Sent SIGKILL to all processes\");\n    sync();\n}",
        "source_code": "static void run_shutdown_and_kill_processes(void)\n{\n\t/* Run everything to be run at \"shutdown\".  This is done _prior_\n\t * to killing everything, in case people wish to use scripts to\n\t * shut things down gracefully... */\n\trun_actions(SHUTDOWN);\n\n\tmessage(L_CONSOLE | L_LOG, \"The system is going down NOW!\");\n\n\t/* Send signals to every process _except_ pid 1 */\n\tkill(-1, SIGTERM);\n\tmessage(L_CONSOLE | L_LOG, \"Sent SIG%s to all processes\", \"TERM\");\n\tsync();\n\tsleep(1);\n\n\tkill(-1, SIGKILL);\n\tmessage(L_CONSOLE, \"Sent SIG%s to all processes\", \"KILL\");\n\tsync();\n\t/*sleep(1); - callers take care about making a pause */\n}",
        "parsed_output": "void shutdown_system()\n{\n    sub_4F5345(0x40u);\n    sub_4F4BC2(3, \"The system is going down NOW!\");\n    kill(-1, SIGTERM);\n    sub_4F4BC2(3, \"Sent SIGTERM to all processes\");\n    sync();\n    sleep(1u);\n    kill(-1, SIGKILL);\n    sub_4F4BC2(2, \"Sent SIGKILL to all processes\");\n    sync();\n}",
        "baseline_code_stripped": "void sub_4F5713()\n{\n  __int64 v0; // rdx\n  __int64 v1; // rcx\n  __int64 v2; // r8\n  __int64 v3; // r9\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n\n  sub_4F5345(0x40u);\n  sub_4F4BC2(3, \"The system is going down NOW!\", v0, v1, v2, v3);\n  kill(-1, 15);\n  sub_4F4BC2(3, \"Sent SIG%s to all processes\", (__int64)\"TERM\", v4, v5, v6);\n  sync();\n  sleep(1u);\n  kill(-1, 9);\n  sub_4F4BC2(2, \"Sent SIG%s to all processes\", (__int64)\"KILL\", v7, v8, v9);\n  sync();\n}\n",
        "baseline_code_debug": "void __cdecl run_shutdown_and_kill_processes()\n{\n  run_actions(64);\n  message(3, \"The system is going down NOW!\");\n  kill(-1, 15);\n  message(3, \"Sent SIG%s to all processes\", \"TERM\");\n  sync();\n  sleep(1u);\n  kill(-1, 9);\n  message(2, \"Sent SIG%s to all processes\", \"KILL\");\n  sync();\n}\n",
        "similarity_score_unixcoder": 0.8365863561630249,
        "similarity_score_baseline_stripped": 0.6970184445381165,
        "similarity_score_baseline_debug": 0.9116796851158142
    },
    {
        "func_name": "make_new_name_gunzip",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl get_ip(const char *str, unsigned __int8 *ip_0)\n{\n  const char *v2; // rax\n  unsigned int tmp[4]; // [rsp+10h] [rbp-20h]\n  int c; // [rsp+24h] [rbp-Ch]\n  int ok; // [rsp+28h] [rbp-8h]\n  int num; // [rsp+2Ch] [rbp-4h]\n\n  num = 0;\n  ok = 0;\n  tmp[3] = 0;\n  tmp[2] = 0;\n  tmp[1] = 0;\n  tmp[0] = 0;\n  while ( 1 )\n  {\n    while ( 1 )\n    {\n      v2 = str++;\n      c = *v2;\n      if ( c <= 47 || c > 57 )\n        break;\n      ok = 1;\n      tmp[num] = 10 * tmp[num] + c - 48;\n      if ( tmp[num] > 0xFF )\n        return 0;\n    }\n    if ( c != 46 )\n      break;\n    if ( !ok )\n      return -1;\n    if ( num == 3 )\n      return 0;\n    ++num;\n    ok = 0;\n  }\n  if ( c || num != 3 || !ok )\n    return 0;\n  *ip_0 = tmp[0];\n  ip_0[1] = tmp[1];\n  ip_0[2] = tmp[2];\n  ip_0[3] = tmp[3];\n  return 1;\n}\n\n\n Revised code:\nstatic int get_ip(const char *str, unsigned char ip[4])\n{\n    unsigned int tmp[4];\n    int num = 0, c, ok = 0;\n\n    tmp[0] = tmp[1] = tmp[2] = tmp[3] = 0;\n\n    for (;;) {\n        c = *(str++);\n        if ((c >= '0') && (c <= '9')) {\n            ok = 1;\n            tmp[num] = tmp[num] * 10 + c - '0';\n            if (tmp[num] > 255)\n                return (0);\n        } else if (c == '.') {\n            if (!ok)\n                return (-1);\n            if (num == 3)\n                return (0);\n            num++;\n            ok = 0;\n        } else if (c == '\\0' && (num == 3) && ok)\n            break;\n        else\n            return (0);\n    }\n    ip[0] = tmp[0];\n    ip[1] = tmp[1];\n    ip[2] = tmp[2];\n    ip[3] = tmp[3];\n    return (1);\n}\n\n## Example:\n\n Input code:\nint __cdecl asn1_get_length(const unsigned __int8 **pp, int *inf, __int64 *rl, int max)\n{\n  char *v5; // rax\n  const unsigned __int8 *v6; // rax\n  int maxa; // [rsp+0h] [rbp-3Ch]\n  unsigned int i; // [rsp+28h] [rbp-14h]\n  __int64 ret; // [rsp+2Ch] [rbp-10h]\n  const unsigned __int8 *p; // [rsp+34h] [rbp-8h]\n  const unsigned __int8 *pa; // [rsp+34h] [rbp-8h]\n\n  p = *pp;\n  ret = 0LL;\n  if ( max <= 0 )\n    return 0;\n  if ( *p == 0x80 )\n  {\n    *inf = 1;\n    ret = 0LL;\n    pa = p + 1;\n  }\n  else\n  {\n    *inf = 0;\n    i = *p & 0x7F;\n    v5 = (char *)p;\n    pa = p + 1;\n    if ( *v5 >= 0 )\n    {\n      ret = i;\n    }\n    else\n    {\n      if ( i > 8 )\n        return 0;\n      maxa = max - 2;\n      if ( max == 1 )\n        return 0;\n      while ( i-- )\n      {\n        v6 = pa++;\n        ret = *v6 | (unsigned __int64)(ret << 8);\n        LODWORD(v6) = maxa--;\n        if ( !(_DWORD)v6 )\n          return 0;\n      }\n    }\n  }\n  if ( ret < 0 )\n    return 0;\n  *pp = pa;\n  *rl = ret;\n  return 1;\n}\n\n\n Revised code:\nstatic int asn1_get_length(const unsigned char **pp, int *inf, long *rl,\n                           long max)\n{\n    const unsigned char *p = *pp;\n    unsigned long ret = 0;\n    unsigned long i;\n\n    if (max-- < 1)\n        return 0;\n    if (*p == 0x80) {\n        *inf = 1;\n        ret = 0;\n        p++;\n    } else {\n        *inf = 0;\n        i = *p & 0x7f;\n        if (*(p++) & 0x80) {\n            if (i > sizeof(ret) || max < (long)i)\n                return 0;\n            while (i-- > 0) {\n                ret <<= 8L;\n                ret |= *(p++);\n            }\n        } else\n            ret = i;\n    }\n    if (ret > LONG_MAX)\n        return 0;\n    *pp = p;\n    *rl = (long)ret;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl parse_http_line1(char *line)\n{\n  char *v2; // rax\n  size_t v3; // rax\n  char *r; // [rsp+10h] [rbp-20h] BYREF\n  int retcode; // [rsp+1Ch] [rbp-14h]\n  char *q; // [rsp+20h] [rbp-10h]\n  char *p; // [rsp+28h] [rbp-8h]\n\n  for ( p = line; *p && ((*__ctype_b_loc())[(unsigned __int8)*p] & 0x2000) == 0; ++p )\n    ;\n  if ( *p )\n  {\n    while ( *p && ((*__ctype_b_loc())[(unsigned __int8)*p] & 0x2000) != 0 )\n      ++p;\n    if ( *p )\n    {\n      for ( q = p; *q && ((*__ctype_b_loc())[(unsigned __int8)*q] & 0x2000) == 0; ++q )\n        ;\n      if ( *q )\n      {\n        v2 = q++;\n        *v2 = 0;\n        retcode = strtoul(p, &r, 10);\n        if ( *r )\n        {\n          return 0;\n        }\n        else\n        {\n          while ( *q && ((*__ctype_b_loc())[(unsigned __int8)*q] & 0x2000) != 0 )\n            ++q;\n          if ( *q )\n          {\n            v3 = strlen(q);\n            for ( r = &q[v3 - 1]; ((*__ctype_b_loc())[(unsigned __int8)*r] & 0x2000) != 0; --r )\n              *r = 0;\n          }\n          if ( retcode == 200 )\n          {\n            return 1;\n          }\n          else\n          {\n            ERR_put_error(39, 118, 114, \"ocsp_ht.c\", 250);\n            if ( *q )\n              ERR_add_error_data(4, \"Code=\", p, \",Reason=\", q);\n            else\n              ERR_add_error_data(2, \"Code=\", p);\n            return 0;\n          }\n        }\n      }\n      else\n      {\n        ERR_put_error(39, 118, 115, \"ocsp_ht.c\", 222);\n        return 0;\n      }\n    }\n    else\n    {\n      ERR_put_error(39, 118, 115, \"ocsp_ht.c\", 211);\n      return 0;\n    }\n  }\n  else\n  {\n    ERR_put_error(39, 118, 115, \"ocsp_ht.c\", 200);\n    return 0;\n  }\n}\n\n\n Revised code:\nstatic int parse_http_line1(char *line)\n{\n    int retcode;\n    char *p, *q, *r;\n    /* Skip to first white space (passed protocol info) */\n\n    for (p = line; *p && !isspace((unsigned char)*p); p++)\n        continue;\n    if (!*p) {\n        OCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_PARSE_ERROR);\n        return 0;\n    }\n\n    /* Skip past white space to start of response code */\n    while (*p && isspace((unsigned char)*p))\n        p++;\n\n    if (!*p) {\n        OCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_PARSE_ERROR);\n        return 0;\n    }\n\n    /* Find end of response code: first whitespace after start of code */\n    for (q = p; *q && !isspace((unsigned char)*q); q++)\n        continue;\n\n    if (!*q) {\n        OCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_PARSE_ERROR);\n        return 0;\n    }\n\n    /* Set end of response code and start of message */\n    *q++ = 0;\n\n    /* Attempt to parse numeric code */\n    retcode = strtoul(p, &r, 10);\n\n    if (*r)\n        return 0;\n\n    /* Skip over any leading white space in message */\n    while (*q && isspace((unsigned char)*q))\n        q++;\n\n    if (*q) {\n        /*\n         * Finally zap any trailing white space in message (include CRLF)\n         */\n\n        /* We know q has a non white space character so this is OK */\n        for (r = q + strlen(q) - 1; isspace((unsigned char)*r); r--)\n            *r = 0;\n    }\n    if (retcode != 200) {\n        OCSPerr(OCSP_F_PARSE_HTTP_LINE1, OCSP_R_SERVER_RESPONSE_ERROR);\n        if (!*q)\n            ERR_add_error_data(2, \"Code=\", p);\n        else\n            ERR_add_error_data(4, \"Code=\", p, \",Reason=\", q);\n        return 0;\n    }\n\n    return 1;\n\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_4A8787(const char *a1)\n{\n  char *v2; // rax\n  const char *s; // [rsp+8h] [rbp-18h]\n  char *s1; // [rsp+18h] [rbp-8h]\n  char *s1a; // [rsp+18h] [rbp-8h]\n\n  s = a1;\n  s1 = strrchr(a1, 46);\n  if ( !s1 )\n    return 0LL;\n  s1a = s1 + 1;\n  if ( !strcmp(s1a, \"gz\") || *s1a == 90 && !s1a[1] )\n  {\n    *(s1a - 1) = 0;\n  }\n  else\n  {\n    if ( strcmp(s1a, \"tgz\") )\n      return 0LL;\n    s = sub_40A11F(a1, (__int64)\"tgz\");\n    v2 = strrchr(s, 46);\n    v2[2] = 97;\n    v2[3] = 114;\n  }\n  return s;\n}\n",
        "output": "static const char *get_file_extension(const char *filename)\n{\n    char *last_dot;\n    const char *extension;\n\n    last_dot = strrchr(filename, '.');\n    if (!last_dot)\n        return NULL;\n\n    extension = last_dot + 1;\n    if (!strcmp(extension, \"gz\") || (*extension == 'Z' && extension[1] == '\\0')) {\n        *(extension - 1) = '\\0';\n    } else if (!strcmp(extension, \"tgz\")) {\n        filename = change_extension(filename, \"tgz\");\n        last_dot = strrchr(filename, '.');\n        last_dot[1] = 't';\n        last_dot[2] = 'a';\n        last_dot[3] = 'r';\n    } else {\n        return NULL;\n    }\n    return filename;\n}",
        "source_code": "FAST_FUNC make_new_name_gunzip(char *filename, const char *expected_ext UNUSED_PARAM)\n{\n\tchar *extension = strrchr(filename, '.');\n\n\tif (!extension)\n\t\treturn NULL;\n\n\textension++;\n\tif (strcmp(extension, \"tgz\" + 1) == 0\n#if ENABLE_FEATURE_SEAMLESS_Z\n\t || (extension[0] == 'Z' && extension[1] == '\\0')\n#endif\n\t) {\n\t\textension[-1] = '\\0';\n\t} else if (strcmp(extension, \"tgz\") == 0) {\n\t\tfilename = xstrdup(filename);\n\t\textension = strrchr(filename, '.');\n\t\textension[2] = 'a';\n\t\textension[3] = 'r';\n\t} else {\n\t\treturn NULL;\n\t}\n\treturn filename;\n}",
        "parsed_output": "static const char *get_file_extension(const char *filename)\n{\n    char *last_dot;\n    const char *extension;\n\n    last_dot = strrchr(filename, '.');\n    if (!last_dot)\n        return NULL;\n\n    extension = last_dot + 1;\n    if (!strcmp(extension, \"gz\") || (*extension == 'Z' && extension[1] == '\\0')) {\n        *(extension - 1) = '\\0';\n    } else if (!strcmp(extension, \"tgz\")) {\n        filename = change_extension(filename, \"tgz\");\n        last_dot = strrchr(filename, '.');\n        last_dot[1] = 't';\n        last_dot[2] = 'a';\n        last_dot[3] = 'r';\n    } else {\n        return NULL;\n    }\n    return filename;\n}",
        "baseline_code_stripped": "const char *__fastcall sub_4A8787(const char *a1)\n{\n  char *v2; // rax\n  const char *s; // [rsp+8h] [rbp-18h]\n  char *s1; // [rsp+18h] [rbp-8h]\n  char *s1a; // [rsp+18h] [rbp-8h]\n\n  s = a1;\n  s1 = strrchr(a1, 46);\n  if ( !s1 )\n    return 0LL;\n  s1a = s1 + 1;\n  if ( !strcmp(s1a, \"gz\") || *s1a == 90 && !s1a[1] )\n  {\n    *(s1a - 1) = 0;\n  }\n  else\n  {\n    if ( strcmp(s1a, \"tgz\") )\n      return 0LL;\n    s = sub_40A11F(a1, (__int64)\"tgz\");\n    v2 = strrchr(s, 46);\n    v2[2] = 97;\n    v2[3] = 114;\n  }\n  return s;\n}\n",
        "baseline_code_debug": "char *__cdecl make_new_name_gunzip(char *filename, const char *expected_ext)\n{\n  char *v3; // rax\n  const char *filenamea; // [rsp+8h] [rbp-18h]\n  char *extension; // [rsp+18h] [rbp-8h]\n  char *extensiona; // [rsp+18h] [rbp-8h]\n\n  filenamea = filename;\n  extension = strrchr(filename, 46);\n  if ( !extension )\n    return 0LL;\n  extensiona = extension + 1;\n  if ( !strcmp(extensiona, \"gz\") || *extensiona == 90 && !extensiona[1] )\n  {\n    *(extensiona - 1) = 0;\n  }\n  else\n  {\n    if ( strcmp(extensiona, \"tgz\") )\n      return 0LL;\n    filenamea = xstrdup(filename);\n    v3 = strrchr(filenamea, 46);\n    v3[2] = 97;\n    v3[3] = 114;\n  }\n  return (char *)filenamea;\n}\n",
        "similarity_score_unixcoder": 0.816418468952179,
        "similarity_score_baseline_stripped": 0.5554924607276917,
        "similarity_score_baseline_debug": 0.8413436412811279
    },
    {
        "func_name": "handle_errors",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\n__int64 __cdecl null_ctrl(BIO *b, int cmd, __int64 num, void *ptr)\n{\n  __int64 ret; // [rsp+28h] [rbp-8h]\n\n  switch ( cmd )\n  {\n    case 1:\n    case 2:\n    case 4:\n    case 9:\n    case 11:\n    case 12:\n      ret = 1LL;\n      break;\n    default:\n      ret = 0LL;\n      break;\n  }\n  return ret;\n}\n\n\n Revised code:\nstatic long null_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    long ret = 1;\n\n    switch (cmd) {\n    case BIO_CTRL_RESET:\n    case BIO_CTRL_EOF:\n    case BIO_CTRL_SET:\n    case BIO_CTRL_SET_CLOSE:\n    case BIO_CTRL_FLUSH:\n    case BIO_CTRL_DUP:\n        ret = 1;\n        break;\n    case BIO_CTRL_GET_CLOSE:\n    case BIO_CTRL_INFO:\n    case BIO_CTRL_GET:\n    case BIO_CTRL_PENDING:\n    case BIO_CTRL_WPENDING:\n    default:\n        ret = 0;\n        break;\n    }\n    return (ret);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40BD4A(__int64 a1, unsigned __int8 **a2)\n{\n  unsigned __int8 v3; // [rsp+1Fh] [rbp-1h]\n\n  v3 = **a2;\n  if ( v3 )\n  {\n    if ( sub_40BCF2(v3) || *(_DWORD *)qword_75D400 )\n      return sub_40BD30(v3);\n    *(_DWORD *)qword_75D400 = 22;\n  }\n  return a1;\n}\n",
        "output": "```c\nstatic long sub_40BD4A(long a1, unsigned char **a2)\n{\n    unsigned char v3;\n\n    v3 = **a2;\n    if (v3) {\n        if (sub_40BCF2(v3) || *(_DWORD *)qword_75D400) {\n            return sub_40BD30(v3);\n        }\n        *(_DWORD *)qword_75D400 = 22;\n    }\n    return a1;\n}\n```",
        "source_code": "static unsigned long long handle_errors(unsigned long long v, char **endp)\n{\n\tchar next_ch = **endp;\n\n\t/* errno is already set to ERANGE by strtoXXX if value overflowed */\n\tif (next_ch) {\n\t\t/* \"1234abcg\" or out-of-range? */\n\t\tif (isalnum(next_ch) || errno)\n\t\t\treturn ret_ERANGE();\n\t\t/* good number, just suspicious terminator */\n\t\terrno = EINVAL;\n\t}\n\treturn v;\n}",
        "parsed_output": "static long sub_40BD4A(long a1, unsigned char **a2)\n{\n    unsigned char v3;\n\n    v3 = **a2;\n    if (v3) {\n        if (sub_40BCF2(v3) || *(_DWORD *)qword_75D400) {\n            return sub_40BD30(v3);\n        }\n        *(_DWORD *)qword_75D400 = 22;\n    }\n    return a1;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40BD4A(__int64 a1, unsigned __int8 **a2)\n{\n  unsigned __int8 v3; // [rsp+1Fh] [rbp-1h]\n\n  v3 = **a2;\n  if ( v3 )\n  {\n    if ( sub_40BCF2(v3) || *(_DWORD *)qword_75D400 )\n      return sub_40BD30(v3);\n    *(_DWORD *)qword_75D400 = 22;\n  }\n  return a1;\n}\n",
        "baseline_code_debug": "unsigned __int64 __cdecl handle_errors(unsigned __int64 v, char **endp)\n{\n  unsigned __int8 next_ch; // [rsp+1Fh] [rbp-1h]\n\n  next_ch = **endp;\n  if ( next_ch )\n  {\n    if ( bb_ascii_isalnum(next_ch) || *bb_errno )\n      return ret_ERANGE();\n    *bb_errno = 22;\n  }\n  return v;\n}\n",
        "similarity_score_unixcoder": 0.5091160535812378,
        "similarity_score_baseline_stripped": 0.4332294762134552,
        "similarity_score_baseline_debug": 0.7914387583732605
    },
    {
        "func_name": "is_cleared_partition",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl write_lebn(unsigned __int8 **out, const BIGNUM *bn, int len)\n{\n  unsigned __int8 *v3; // rax\n  unsigned __int8 *v4; // rax\n  int lenb; // [rsp+Ch] [rbp-34h]\n  unsigned __int8 c; // [rsp+23h] [rbp-1Dh]\n  int nb; // [rsp+24h] [rbp-1Ch]\n  unsigned __int8 *q; // [rsp+28h] [rbp-18h]\n  unsigned __int8 *p; // [rsp+30h] [rbp-10h]\n  int i; // [rsp+3Ch] [rbp-4h]\n\n  p = *out;\n  nb = (BN_num_bits(bn) + 7) / 8;\n  BN_bn2bin(bn, p);\n  q = &p[nb - 1];\n  for ( i = 0; i < nb / 2; ++i )\n  {\n    c = *p;\n    v3 = p++;\n    *v3 = *q;\n    v4 = q--;\n    *v4 = c;\n  }\n  *out += nb;\n  if ( len > 0 )\n  {\n    lenb = len - nb;\n    if ( lenb > 0 )\n    {\n      memset(*out, 0, lenb);\n      *out += lenb;\n    }\n  }\n}\n\n\n Revised code:\nstatic void write_lebn(unsigned char **out, const BIGNUM *bn, int len)\n{\n    int nb, i;\n    unsigned char *p = *out, *q, c;\n    nb = BN_num_bytes(bn);\n    BN_bn2bin(bn, p);\n    q = p + nb - 1;\n    /* In place byte order reversal */\n    for (i = 0; i < nb / 2; i++) {\n        c = *p;\n        *p++ = *q;\n        *q-- = c;\n    }\n    *out += nb;\n    /* Pad with zeroes if we have to */\n    if (len > 0) {\n        len -= nb;\n        if (len > 0) {\n            memset(*out, 0, len);\n            *out += len;\n        }\n    }\n}\n\n## Example:\n\n Input code:\nvoid __cdecl make_kn(unsigned __int8 *k1_0, unsigned __int8 *l, int bl_0)\n{\n  unsigned __int8 v3; // dl\n  char v4; // al\n  int i; // [rsp+20h] [rbp-4h]\n\n  for ( i = 0; i < bl_0; ++i )\n  {\n    k1_0[i] = 2 * l[i];\n    if ( i < bl_0 - 1 && (l[i + 1] & 0x80u) != 0 )\n      k1_0[i] |= 1u;\n  }\n  if ( (*l & 0x80u) != 0 )\n  {\n    v3 = k1_0[bl_0 - 1];\n    if ( bl_0 == 16 )\n      v4 = -121;\n    else\n      v4 = 27;\n    k1_0[bl_0 - 1] = v3 ^ v4;\n  }\n}\n\n\n Revised code:\nstatic void make_kn(unsigned char *k1, unsigned char *l, int bl)\n{\n    int i;\n    /* Shift block to left, including carry */\n    for (i = 0; i < bl; i++) {\n        k1[i] = l[i] << 1;\n        if (i < bl - 1 && l[i + 1] & 0x80)\n            k1[i] |= 1;\n    }\n    /* If MSB set fixup with R */\n    if (l[0] & 0x80)\n        k1[bl - 1] ^= bl == 16 ? 0x87 : 0x1b;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BOOL8 __fastcall sub_490BFC(_BYTE *a1)\n{\n  _BYTE *v1; // rax\n  char i; // [rsp+Bh] [rbp-Dh]\n  int v4; // [rsp+Ch] [rbp-Ch]\n\n  v4 = 16;\n  for ( i = 0; --v4 >= 0; i |= *v1 )\n    v1 = a1++;\n  return i == 0;\n}\n",
        "output": "```c\nbool sub_490BFC(unsigned char *a1)\n{\n    unsigned char result = 0;\n    for (int i = 0; i < 16; ++i)\n        result |= a1[i];\n    return result == 0;\n}\n```",
        "source_code": "static int\nis_cleared_partition(const struct partition *p)\n{\n\t/* We consider partition \"cleared\" only if it has only zeros */\n\tconst char *cp = (const char *)p;\n\tint cnt = sizeof(*p);\n\tchar bits = 0;\n\twhile (--cnt >= 0)\n\t\tbits |= *cp++;\n\treturn (bits == 0);\n}",
        "parsed_output": "bool sub_490BFC(unsigned char *a1)\n{\n    unsigned char result = 0;\n    for (int i = 0; i < 16; ++i)\n        result |= a1[i];\n    return result == 0;\n}",
        "baseline_code_stripped": "_BOOL8 __fastcall sub_490BFC(_BYTE *a1)\n{\n  _BYTE *v1; // rax\n  char i; // [rsp+Bh] [rbp-Dh]\n  int v4; // [rsp+Ch] [rbp-Ch]\n\n  v4 = 16;\n  for ( i = 0; --v4 >= 0; i |= *v1 )\n    v1 = a1++;\n  return i == 0;\n}\n",
        "baseline_code_debug": "int __cdecl is_cleared_partition(const partition *p)\n{\n  const partition *v1; // rax\n  char bits; // [rsp+Bh] [rbp-Dh]\n  int cnt; // [rsp+Ch] [rbp-Ch]\n\n  cnt = 16;\n  for ( bits = 0; --cnt >= 0; bits |= v1->boot_ind )\n  {\n    v1 = p;\n    p = (const partition *)((char *)p + 1);\n  }\n  return bits == 0;\n}\n",
        "similarity_score_unixcoder": 0.5526557564735413,
        "similarity_score_baseline_stripped": 0.4695984721183777,
        "similarity_score_baseline_debug": 0.7557775974273682
    },
    {
        "func_name": "poplocalvars",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl private_RC4_set_key(RC4_KEY *key, int len, const unsigned __int8 *data)\n{\n  unsigned __int8 *v3; // r12\n  int v4; // ebx\n  int v5; // r13d\n  unsigned __int8 v6; // r14\n  int v7; // ebx\n  int v8; // r13d\n  unsigned __int8 v9; // r14\n  int v10; // ebx\n  int v11; // r13d\n  unsigned __int8 v12; // r14\n  int v13; // ebx\n  int v14; // r13d\n  unsigned __int8 v15; // r14\n  unsigned int i; // [rsp+24h] [rbp-24h]\n  unsigned int ia; // [rsp+24h] [rbp-24h]\n\n  v3 = key->data;\n  key->x = 0;\n  key->y = 0;\n  LOBYTE(v4) = 0;\n  v5 = 0;\n  for ( i = 0; i <= 0xFF; ++i )\n    v3[i] = i;\n  for ( ia = 0; ia <= 0xFF; ia += 4 )\n  {\n    v6 = v3[ia];\n    v7 = (unsigned __int8)(v4 + data[v5] + v6);\n    v8 = v5 + 1;\n    if ( v8 == len )\n      v8 = 0;\n    v3[ia] = v3[v7];\n    v3[v7] = v6;\n    v9 = v3[ia + 1];\n    v10 = (unsigned __int8)(v7 + data[v8] + v9);\n    v11 = v8 + 1;\n    if ( v11 == len )\n      v11 = 0;\n    v3[ia + 1] = v3[v10];\n    v3[v10] = v9;\n    v12 = v3[ia + 2];\n    v13 = (unsigned __int8)(v10 + data[v11] + v12);\n    v14 = v11 + 1;\n    if ( v14 == len )\n      v14 = 0;\n    v3[ia + 2] = v3[v13];\n    v3[v13] = v12;\n    v15 = v3[ia + 3];\n    v4 = (unsigned __int8)(v13 + data[v14] + v15);\n    v5 = v14 + 1;\n    if ( v5 == len )\n      v5 = 0;\n    v3[ia + 3] = v3[v4];\n    v3[v4] = v15;\n  }\n}\n\n\n Revised code:\nvoid private_RC4_set_key(RC4_KEY *key, int len, const unsigned char *data)\n{\n    register RC4_INT tmp;\n    register int id1, id2;\n    register RC4_INT *d;\n    unsigned int i;\n\n    d = &(key->data[0]);\n    key->x = 0;\n    key->y = 0;\n    id1 = id2 = 0;\n\n#define SK_LOOP(d,n) { \\\n                tmp=d[(n)]; \\\n                id2 = (data[id1] + tmp + id2) & 0xff; \\\n                if (++id1 == len) id1=0; \\\n                d[(n)]=d[id2]; \\\n                d[id2]=tmp; }\n\n    for (i = 0; i < 256; i++)\n        d[i] = i;\n    for (i = 0; i < 256; i += 4) {\n        SK_LOOP(d, i + 0);\n        SK_LOOP(d, i + 1);\n        SK_LOOP(d, i + 2);\n        SK_LOOP(d, i + 3);\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_478DC3()\n{\n  void (__fastcall *v0)(_BYTE *); // rbx\n  _BYTE *v1; // rax\n  __int64 result; // rax\n  __int64 v3; // [rsp+0h] [rbp-20h]\n  void *ptr; // [rsp+8h] [rbp-18h]\n\n  while ( 1 )\n  {\n    result = qword_75B050;\n    ptr = (void *)qword_75B050;\n    if ( !qword_75B050 )\n      break;\n    qword_75B050 = *(_QWORD *)qword_75B050;\n    v3 = *((_QWORD *)ptr + 1);\n    if ( v3 )\n    {\n      if ( (*((_DWORD *)ptr + 4) & 0x24) == 32 )\n      {\n        sub_46F900(*(unsigned __int8 **)(v3 + 16));\n      }\n      else\n      {\n        if ( *(_QWORD *)(v3 + 24) )\n        {\n          v0 = *(void (__fastcall **)(_BYTE *))(v3 + 24);\n          v1 = sub_46DF3E(*((_BYTE **)ptr + 3));\n          v0(v1);\n        }\n        if ( (*(_DWORD *)(v3 + 8) & 0x18) == 0 )\n          free(*(void **)(v3 + 16));\n        *(_DWORD *)(v3 + 8) = *((_DWORD *)ptr + 4);\n        *(_QWORD *)(v3 + 16) = *((_QWORD *)ptr + 3);\n      }\n    }\n    else\n    {\n      memcpy((void *)(qword_75D418 + 57), *((const void **)ptr + 3), 0xFuLL);\n      free(*((void **)ptr + 3));\n      sub_478D87();\n    }\n    free(ptr);\n  }\n  return result;\n}\n",
        "output": "```c\nvoid process_queue()\n{\n    while (queue_head)\n    {\n        void *current = queue_head;\n        queue_head = *(void **)queue_head;\n        void *data = *((void **)current + 1);\n\n        if (data)\n        {\n            unsigned int flags = *((unsigned int *)current + 4);\n            if ((flags & 0x24) == 32)\n            {\n                cleanup_function(*(unsigned char **)(data + 16));\n            }\n            else\n            {\n                if (*(void **)(data + 24))\n                {\n                    void (*callback)(_BYTE *) = *(void (**)(_BYTE *))(data + 24);\n                    _BYTE *buffer = allocate_buffer(*((_BYTE **)current + 3));\n                    callback(buffer);\n                }\n                if ((*(_DWORD *)(data + 8) & 0x18) == 0)\n                    free(*(void **)(data + 16));\n\n                *(_DWORD *)(data + 8) = flags;\n                *(_QWORD *)(data + 16) = *((_QWORD *)current + 3);\n            }\n        }\n        else\n        {\n            memcpy((void *)(global_buffer + 57), *((const void **)current + 3), 15);\n            free(*((void **)current + 3));\n            update_global_state();\n        }\n        free(current);\n    }\n}\n```",
        "source_code": "static void\npoplocalvars(void)\n{\n\tstruct localvar *lvp;\n\tstruct var *vp;\n\n\twhile ((lvp = localvars) != NULL) {\n\t\tlocalvars = lvp->next;\n\t\tvp = lvp->vp;\n\t\tTRACE((\"poplocalvar %s\\n\", vp ? vp->var_text : \"-\"));\n\t\tif (vp == NULL) {       /* $- saved */\n\t\t\tmemcpy(optlist, lvp->text, sizeof(optlist));\n\t\t\tfree((char*)lvp->text);\n\t\t\toptschanged();\n\t\t} else if ((lvp->flags & (VUNSET|VSTRFIXED)) == VUNSET) {\n\t\t\tunsetvar(vp->var_text);\n\t\t} else {\n\t\t\tif (vp->var_func)\n\t\t\t\tvp->var_func(var_end(lvp->text));\n\t\t\tif ((vp->flags & (VTEXTFIXED|VSTACK)) == 0)\n\t\t\t\tfree((char*)vp->var_text);\n\t\t\tvp->flags = lvp->flags;\n\t\t\tvp->var_text = lvp->text;\n\t\t}\n\t\tfree(lvp);\n\t}\n}",
        "parsed_output": "void process_queue()\n{\n    while (queue_head)\n    {\n        void *current = queue_head;\n        queue_head = *(void **)queue_head;\n        void *data = *((void **)current + 1);\n\n        if (data)\n        {\n            unsigned int flags = *((unsigned int *)current + 4);\n            if ((flags & 0x24) == 32)\n            {\n                cleanup_function(*(unsigned char **)(data + 16));\n            }\n            else\n            {\n                if (*(void **)(data + 24))\n                {\n                    void (*callback)(_BYTE *) = *(void (**)(_BYTE *))(data + 24);\n                    _BYTE *buffer = allocate_buffer(*((_BYTE **)current + 3));\n                    callback(buffer);\n                }\n                if ((*(_DWORD *)(data + 8) & 0x18) == 0)\n                    free(*(void **)(data + 16));\n\n                *(_DWORD *)(data + 8) = flags;\n                *(_QWORD *)(data + 16) = *((_QWORD *)current + 3);\n            }\n        }\n        else\n        {\n            memcpy((void *)(global_buffer + 57), *((const void **)current + 3), 15);\n            free(*((void **)current + 3));\n            update_global_state();\n        }\n        free(current);\n    }\n}",
        "baseline_code_stripped": "__int64 sub_478DC3()\n{\n  void (__fastcall *v0)(_BYTE *); // rbx\n  _BYTE *v1; // rax\n  __int64 result; // rax\n  __int64 v3; // [rsp+0h] [rbp-20h]\n  void *ptr; // [rsp+8h] [rbp-18h]\n\n  while ( 1 )\n  {\n    result = qword_75B050;\n    ptr = (void *)qword_75B050;\n    if ( !qword_75B050 )\n      break;\n    qword_75B050 = *(_QWORD *)qword_75B050;\n    v3 = *((_QWORD *)ptr + 1);\n    if ( v3 )\n    {\n      if ( (*((_DWORD *)ptr + 4) & 0x24) == 32 )\n      {\n        sub_46F900(*(unsigned __int8 **)(v3 + 16));\n      }\n      else\n      {\n        if ( *(_QWORD *)(v3 + 24) )\n        {\n          v0 = *(void (__fastcall **)(_BYTE *))(v3 + 24);\n          v1 = sub_46DF3E(*((_BYTE **)ptr + 3));\n          v0(v1);\n        }\n        if ( (*(_DWORD *)(v3 + 8) & 0x18) == 0 )\n          free(*(void **)(v3 + 16));\n        *(_DWORD *)(v3 + 8) = *((_DWORD *)ptr + 4);\n        *(_QWORD *)(v3 + 16) = *((_QWORD *)ptr + 3);\n      }\n    }\n    else\n    {\n      memcpy((void *)(qword_75D418 + 57), *((const void **)ptr + 3), 0xFuLL);\n      free(*((void **)ptr + 3));\n      sub_478D87();\n    }\n    free(ptr);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl poplocalvars()\n{\n  void (*var_func)(const char *); // rbx\n  const char *v1; // rax\n  var *vp; // [rsp+0h] [rbp-20h]\n  localvar *lvp; // [rsp+8h] [rbp-18h]\n\n  while ( 1 )\n  {\n    lvp = localvars;\n    if ( !localvars )\n      break;\n    localvars = localvars->next;\n    vp = lvp->vp;\n    if ( vp )\n    {\n      if ( (lvp->flags & 0x24) == 32 )\n      {\n        unsetvar(vp->var_text);\n      }\n      else\n      {\n        if ( vp->var_func )\n        {\n          var_func = vp->var_func;\n          v1 = var_end(lvp->text);\n          var_func(v1);\n        }\n        if ( (vp->flags & 0x18) == 0 )\n          free((void *)vp->var_text);\n        vp->flags = lvp->flags;\n        vp->var_text = lvp->text;\n      }\n    }\n    else\n    {\n      memcpy(ash_ptr_to_globals_misc->optlist, lvp->text, sizeof(ash_ptr_to_globals_misc->optlist));\n      free((void *)lvp->text);\n      optschanged();\n    }\n    free(lvp);\n  }\n}\n",
        "similarity_score_unixcoder": 0.5158421397209167,
        "similarity_score_baseline_stripped": 0.4376852512359619,
        "similarity_score_baseline_debug": 0.9075888395309448
    },
    {
        "func_name": "test_eaccess",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl print_bin(BIO *fp, const char *name, const unsigned __int8 *buf, size_t len, int off)\n{\n  const char *v6; // rax\n  int offa; // [rsp+Ch] [rbp-B4h]\n  char str[128]; // [rsp+30h] [rbp-90h] BYREF\n  size_t i; // [rsp+B8h] [rbp-8h]\n\n  offa = off;\n  if ( !buf )\n    return 1;\n  if ( !off )\n    goto LABEL_8;\n  if ( off > 128 )\n    offa = 128;\n  memset(str, 32, offa);\n  if ( BIO_write(fp, str, offa) <= 0 )\n    return 0;\nLABEL_8:\n  if ( BIO_printf(fp, \"%s\", name) <= 0 )\n    return 0;\n  for ( i = 0LL; i < len; ++i )\n  {\n    if ( !(i % 0xF) )\n    {\n      str[0] = 10;\n      memset(&str[1], 32, offa + 4);\n      if ( BIO_write(fp, str, offa + 5) <= 0 )\n        return 0;\n    }\n    if ( len == i + 1 )\n      v6 = (const char *)&unk_1A5A15;\n    else\n      v6 = \":\";\n    if ( BIO_printf(fp, \"%02x%s\", buf[i], v6) <= 0 )\n      return 0;\n  }\n  return BIO_write(fp, \"\\n\", 1) > 0;\n}\n\n\n Revised code:\nstatic int print_bin(BIO *fp, const char *name, const unsigned char *buf,\n                     size_t len, int off)\n{\n    size_t i;\n    char str[128];\n\n    if (buf == NULL)\n        return 1;\n    if (off > 0) {\n        if (off > 128)\n            off = 128;\n        memset(str, ' ', off);\n        if (BIO_write(fp, str, off) <= 0)\n            return 0;\n    } else {\n        off = 0;\n    }\n\n    if (BIO_printf(fp, \"%s\", name) <= 0)\n        return 0;\n\n    for (i = 0; i < len; i++) {\n        if ((i % 15) == 0) {\n            str[0] = '\\n';\n            memset(&(str[1]), ' ', off + 4);\n            if (BIO_write(fp, str, off + 1 + 4) <= 0)\n                return 0;\n        }\n        if (BIO_printf(fp, \"%02x%s\", buf[i], ((i + 1) == len) ? \"\" : \":\") <=\n            0)\n            return 0;\n    }\n    if (BIO_write(fp, \"\\n\", 1) <= 0)\n        return 0;\n\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl RAND_write_file(const char *file)\n{\n  int v2; // eax\n  stat sb; // [rsp+10h] [rbp-4B0h] BYREF\n  unsigned __int8 buf[1024]; // [rsp+A0h] [rbp-420h] BYREF\n  int i; // [rsp+4A8h] [rbp-18h]\n  int n; // [rsp+4ACh] [rbp-14h]\n  FILE *out; // [rsp+4B0h] [rbp-10h]\n  int rand_err; // [rsp+4B8h] [rbp-8h]\n  int ret; // [rsp+4BCh] [rbp-4h]\n\n  ret = 0;\n  rand_err = 0;\n  out = 0LL;\n  i = stat_0(file, (stat_0 *)&sb);\n  if ( i != -1 && ((sb.st_mode & 0xF000) == 24576 || (sb.st_mode & 0xF000) == 0x2000) )\n    return 1;\n  if ( !out )\n    out = fopen(file, \"wb\");\n  if ( out )\n  {\n    chmod(file, 0x180u);\n    n = 1024;\n    while ( 1 )\n    {\n      v2 = 1024;\n      if ( n <= 1024 )\n        v2 = n;\n      i = v2;\n      n -= 1024;\n      if ( RAND_bytes(buf, v2) <= 0 )\n        rand_err = 1;\n      i = fwrite(buf, 1uLL, i, out);\n      if ( i <= 0 )\n        break;\n      ret += i;\n      if ( n <= 0 )\n        goto LABEL_16;\n    }\n    ret = 0;\nLABEL_16:\n    fclose(out);\n    OPENSSL_cleanse(buf, 0x400uLL);\n  }\n  if ( rand_err )\n    return -1;\n  else\n    return ret;\n}\n\n\n Revised code:\nint RAND_write_file(const char *file)\n{\n    unsigned char buf[BUFSIZE];\n    int i, ret = 0, rand_err = 0;\n    FILE *out = NULL;\n    int n;\n#ifndef OPENSSL_NO_POSIX_IO\n    struct stat sb;\n\n    i = stat(file, &sb);\n    if (i != -1) {\n# if defined(S_ISBLK) && defined(S_ISCHR)\n        if (S_ISBLK(sb.st_mode) || S_ISCHR(sb.st_mode)) {\n            /*\n             * this file is a device. we don't write back to it. we\n             * \"succeed\" on the assumption this is some sort of random\n             * device. Otherwise attempting to write to and chmod the device\n             * causes problems.\n             */\n            return (1);\n        }\n# endif\n    }\n#endif\n\n#if defined(O_CREAT) && !defined(OPENSSL_NO_POSIX_IO) && !defined(OPENSSL_SYS_VMS)\n    {\n# ifndef O_BINARY\n#  define O_BINARY 0\n# endif\n        /*\n         * chmod(..., 0600) is too late to protect the file, permissions\n         * should be restrictive from the start\n         */\n        int fd = open(file, O_WRONLY | O_CREAT | O_BINARY, 0600);\n        if (fd != -1)\n            out = fdopen(fd, \"wb\");\n    }\n#endif\n\n#ifdef OPENSSL_SYS_VMS\n    /*\n     * VMS NOTE: Prior versions of this routine created a _new_ version of\n     * the rand file for each call into this routine, then deleted all\n     * existing versions named ;-1, and finally renamed the current version\n     * as ';1'. Under concurrent usage, this resulted in an RMS race\n     * condition in rename() which could orphan files (see vms message help\n     * for RMS$_REENT). With the fopen() calls below, openssl/VMS now shares\n     * the top-level version of the rand file. Note that there may still be\n     * conditions where the top-level rand file is locked. If so, this code\n     * will then create a new version of the rand file. Without the delete\n     * and rename code, this can result in ascending file versions that stop\n     * at version 32767, and this routine will then return an error. The\n     * remedy for this is to recode the calling application to avoid\n     * concurrent use of the rand file, or synchronize usage at the\n     * application level. Also consider whether or not you NEED a persistent\n     * rand file in a concurrent use situation.\n     */\n\n    out = vms_fopen(file, \"rb+\", VMS_OPEN_ATTRS);\n    if (out == NULL)\n        out = vms_fopen(file, \"wb\", VMS_OPEN_ATTRS);\n#else\n    if (out == NULL)\n        out = fopen(file, \"wb\");\n#endif\n    if (out == NULL)\n        goto err;\n\n#ifndef NO_CHMOD\n    chmod(file, 0600);\n#endif\n    n = RAND_DATA;\n    for (;;) {\n        i = (n > BUFSIZE) ? BUFSIZE : n;\n        n -= BUFSIZE;\n        if (RAND_bytes(buf, i) <= 0)\n            rand_err = 1;\n        i = fwrite(buf, 1, i, out);\n        if (i <= 0) {\n            ret = 0;\n            break;\n        }\n        ret += i;\n        if (n <= 0)\n            break;\n    }\n\n    fclose(out);\n    OPENSSL_cleanse(buf, BUFSIZE);\n err:\n    return (rand_err ? -1 : ret);\n}\n\n## Example:\n\n Input code:\nvoid *__cdecl ASN1_dup(i2d_of_void *i2d, d2i_of_void *d2i, void *x)\n{\n  const unsigned __int8 *p2; // [rsp+28h] [rbp-28h] BYREF\n  unsigned __int8 *p; // [rsp+30h] [rbp-20h] BYREF\n  char *ret; // [rsp+38h] [rbp-18h]\n  unsigned __int8 *b; // [rsp+40h] [rbp-10h]\n  int i; // [rsp+4Ch] [rbp-4h]\n\n  if ( !x )\n    return 0LL;\n  i = i2d(x, 0LL);\n  b = (unsigned __int8 *)CRYPTO_malloc(i + 10, \"a_dup.c\", 75);\n  if ( b )\n  {\n    p = b;\n    i = i2d(x, &p);\n    p2 = b;\n    ret = (char *)d2i(0LL, &p2, i);\n    CRYPTO_free(b);\n    return ret;\n  }\n  else\n  {\n    ERR_put_error(13, 111, 65, \"a_dup.c\", 77);\n    return 0LL;\n  }\n}\n\n\n Revised code:\nifndef NO_OLD_ASN1\n\nvoid *ASN1_dup(i2d_of_void *i2d, d2i_of_void *d2i, void *x)\n{\n    unsigned char *b, *p;\n    const unsigned char *p2;\n    int i;\n    char *ret;\n\n    if (x == NULL)\n        return (NULL);\n\n    i = i2d(x, NULL);\n    b = OPENSSL_malloc(i + 10);\n    if (b == NULL) {\n        ASN1err(ASN1_F_ASN1_DUP, ERR_R_MALLOC_FAILURE);\n        return (NULL);\n    }\n    p = b;\n    i = i2d(x, &p);\n    p2 = b;\n    ret = d2i(NULL, &p2, i);\n    OPENSSL_free(b);\n    return (ret);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4D6448(char *a1, int a2)\n{\n  int v3; // [rsp+4h] [rbp-ACh]\n  struct stat64 stat_buf; // [rsp+10h] [rbp-A0h] BYREF\n  __uid_t v5; // [rsp+ACh] [rbp-4h]\n\n  v3 = a2;\n  v5 = geteuid();\n  if ( sub_407DF0(a1, &stat_buf) < 0 )\n    return 0xFFFFFFFFLL;\n  if ( v5 )\n    goto LABEL_8;\n  if ( a2 != 1 )\n    return 0LL;\n  if ( (stat_buf.st_mode & 0x49) != 0 )\n    return 0LL;\nLABEL_8:\n  if ( v5 == stat_buf.st_uid )\n  {\n    v3 = a2 << 6;\n  }\n  else if ( (unsigned int)sub_4D63C6(stat_buf.st_gid) )\n  {\n    v3 = 8 * a2;\n  }\n  if ( (stat_buf.st_mode & v3) != 0 )\n    return 0LL;\n  else\n    return 0xFFFFFFFFLL;\n}\n",
        "output": "```c\nint check_file_permission(const char *filename, int permission)\n{\n    struct stat64 stat_buf;\n    __uid_t effective_uid;\n    int required_perm;\n\n    effective_uid = geteuid();\n    if (stat64(filename, &stat_buf) < 0)\n        return -1;\n\n    if (effective_uid == 0) {\n        // Root user, only check if permission is 1 (execute)\n        if (permission == 1 && (stat_buf.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) != 0)\n            return 0;\n    } else {\n        if (effective_uid == stat_buf.st_uid) {\n            // File owner\n            required_perm = permission << 6; // Shift to owner bits\n        } else if (is_group_member(stat_buf.st_gid)) {\n            // Group member\n            required_perm = permission << 3; // Shift to group bits\n        } else {\n            // Others\n            required_perm = permission; // No shift needed\n        }\n\n        if ((stat_buf.st_mode & required_perm) != 0)\n            return 0;\n    }\n\n    return -1;\n}\n```",
        "source_code": "static int test_eaccess(char *path, int mode)\n{\n\tstruct stat st;\n\tunsigned int euid = geteuid();\n\n\tif (stat(path, &st) < 0)\n\t\treturn -1;\n\n\tif (euid == 0) {\n\t\t/* Root can read or write any file. */\n\t\tif (mode != X_OK)\n\t\t\treturn 0;\n\n\t\t/* Root can execute any file that has any one of the execute\n\t\t * bits set. */\n\t\tif (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))\n\t\t\treturn 0;\n\t}\n\n\tif (st.st_uid == euid)  /* owner */\n\t\tmode <<= 6;\n\telse if (is_a_group_member(st.st_gid))\n\t\tmode <<= 3;\n\n\tif (st.st_mode & mode)\n\t\treturn 0;\n\n\treturn -1;\n}",
        "parsed_output": "int check_file_permission(const char *filename, int permission)\n{\n    struct stat64 stat_buf;\n    __uid_t effective_uid;\n    int required_perm;\n\n    effective_uid = geteuid();\n    if (stat64(filename, &stat_buf) < 0)\n        return -1;\n\n    if (effective_uid == 0) {\n        // Root user, only check if permission is 1 (execute)\n        if (permission == 1 && (stat_buf.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) != 0)\n            return 0;\n    } else {\n        if (effective_uid == stat_buf.st_uid) {\n            // File owner\n            required_perm = permission << 6; // Shift to owner bits\n        } else if (is_group_member(stat_buf.st_gid)) {\n            // Group member\n            required_perm = permission << 3; // Shift to group bits\n        } else {\n            // Others\n            required_perm = permission; // No shift needed\n        }\n\n        if ((stat_buf.st_mode & required_perm) != 0)\n            return 0;\n    }\n\n    return -1;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4D6448(char *a1, int a2)\n{\n  int v3; // [rsp+4h] [rbp-ACh]\n  struct stat64 stat_buf; // [rsp+10h] [rbp-A0h] BYREF\n  __uid_t v5; // [rsp+ACh] [rbp-4h]\n\n  v3 = a2;\n  v5 = geteuid();\n  if ( sub_407DF0(a1, &stat_buf) < 0 )\n    return 0xFFFFFFFFLL;\n  if ( v5 )\n    goto LABEL_8;\n  if ( a2 != 1 )\n    return 0LL;\n  if ( (stat_buf.st_mode & 0x49) != 0 )\n    return 0LL;\nLABEL_8:\n  if ( v5 == stat_buf.st_uid )\n  {\n    v3 = a2 << 6;\n  }\n  else if ( (unsigned int)sub_4D63C6(stat_buf.st_gid) )\n  {\n    v3 = 8 * a2;\n  }\n  if ( (stat_buf.st_mode & v3) != 0 )\n    return 0LL;\n  else\n    return 0xFFFFFFFFLL;\n}\n",
        "baseline_code_debug": "int __cdecl test_eaccess(char *path, int mode)\n{\n  int modea; // [rsp+4h] [rbp-ACh]\n  stat st; // [rsp+10h] [rbp-A0h] BYREF\n  unsigned int euid; // [rsp+ACh] [rbp-4h]\n\n  modea = mode;\n  euid = geteuid();\n  if ( stat64_0(path, (stat64 *)&st) < 0 )\n    return -1;\n  if ( euid )\n    goto LABEL_8;\n  if ( mode != 1 )\n    return 0;\n  if ( (st.st_mode & 0x49) != 0 )\n    return 0;\nLABEL_8:\n  if ( euid == st.st_uid )\n  {\n    modea = mode << 6;\n  }\n  else if ( is_a_group_member(st.st_gid) )\n  {\n    modea = 8 * mode;\n  }\n  if ( (st.st_mode & modea) != 0 )\n    return 0;\n  else\n    return -1;\n}\n",
        "similarity_score_unixcoder": 0.8364337682723999,
        "similarity_score_baseline_stripped": 0.6791883707046509,
        "similarity_score_baseline_debug": 0.8403198719024658
    },
    {
        "func_name": "jiffies_diff",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\n__int64 __cdecl ASN1_INTEGER_get(const ASN1_INTEGER *a)\n{\n  __int64 r; // [rsp+8h] [rbp-10h]\n  int i; // [rsp+10h] [rbp-8h]\n  int ia; // [rsp+10h] [rbp-8h]\n  int neg; // [rsp+14h] [rbp-4h]\n\n  neg = 0;\n  r = 0LL;\n  if ( !a )\n    return 0LL;\n  i = a->type;\n  if ( i == 258 )\n  {\n    neg = 1;\n  }\n  else if ( i != 2 )\n  {\n    return -1LL;\n  }\n  if ( a->length > 8 )\n    return -1LL;\n  if ( !a->data )\n    return 0LL;\n  for ( ia = 0; ia < a->length; ++ia )\n    r = a->data[ia] | (unsigned __int64)(r << 8);\n  if ( neg )\n    return -r;\n  return r;\n}\n\n\n Revised code:\nlong ASN1_INTEGER_get(const ASN1_INTEGER *a)\n{\n    int neg = 0, i;\n    long r = 0;\n\n    if (a == NULL)\n        return (0L);\n    i = a->type;\n    if (i == V_ASN1_NEG_INTEGER)\n        neg = 1;\n    else if (i != V_ASN1_INTEGER)\n        return -1;\n\n    if (a->length > (int)sizeof(long)) {\n        /* hmm... a bit ugly, return all ones */\n        return -1;\n    }\n    if (a->data == NULL)\n        return 0;\n\n    for (i = 0; i < a->length; i++) {\n        r <<= 8;\n        r |= (unsigned char)a->data[i];\n    }\n    if (neg)\n        r = -r;\n    return (r);\n}\n\n## Example:\n\n Input code:\nint __cdecl BN_sub_word(BIGNUM *a, unsigned __int64 w)\n{\n  int result; // eax\n  unsigned __int64 wa; // [rsp+0h] [rbp-20h]\n  int i; // [rsp+1Ch] [rbp-4h]\n  int ia; // [rsp+1Ch] [rbp-4h]\n\n  wa = w;\n  if ( !w )\n    return 1;\n  if ( a->top )\n  {\n    if ( a->neg )\n    {\n      a->neg = 0;\n      result = BN_add_word(a, w);\n      a->neg = 1;\n    }\n    else if ( a->top == 1 && w > *a->d )\n    {\n      *a->d = w - *a->d;\n      a->neg = 1;\n      return 1;\n    }\n    else\n    {\n      for ( ia = 0; wa > a->d[ia]; ++ia )\n      {\n        a->d[ia] -= wa;\n        wa = 1LL;\n      }\n      a->d[ia] -= wa;\n      if ( !a->d[ia] && ia == a->top - 1 )\n        --a->top;\n      return 1;\n    }\n  }\n  else\n  {\n    i = BN_set_word(a, w);\n    if ( i )\n      BN_set_negative(a, 1);\n    return i;\n  }\n  return result;\n}\n\n\n Revised code:\nint BN_sub_word(BIGNUM *a, BN_ULONG w)\n{\n    int i;\n\n    bn_check_top(a);\n    w &= BN_MASK2;\n\n    /* degenerate case: w is zero */\n    if (!w)\n        return 1;\n    /* degenerate case: a is zero */\n    if (BN_is_zero(a)) {\n        i = BN_set_word(a, w);\n        if (i != 0)\n            BN_set_negative(a, 1);\n        return i;\n    }\n    /* handle 'a' when negative */\n    if (a->neg) {\n        a->neg = 0;\n        i = BN_add_word(a, w);\n        a->neg = 1;\n        return (i);\n    }\n\n    if ((a->top == 1) && (a->d[0] < w)) {\n        a->d[0] = w - a->d[0];\n        a->neg = 1;\n        return (1);\n    }\n    i = 0;\n    for (;;) {\n        if (a->d[i] >= w) {\n            a->d[i] -= w;\n            break;\n        } else {\n            a->d[i] = (a->d[i] - w) & BN_MASK2;\n            i++;\n            w = 1;\n        }\n    }\n    if ((a->d[i] == 0) && (i == (a->top - 1)))\n        a->top--;\n    bn_check_top(a);\n    return (1);\n}\n\n## Example:\n\n Input code:\nint __cdecl bn_cmp_part_words(const unsigned __int64 *a, const unsigned __int64 *b, int cl_0, int dl_0)\n{\n  int n; // [rsp+28h] [rbp-8h]\n  int i; // [rsp+2Ch] [rbp-4h]\n  int ia; // [rsp+2Ch] [rbp-4h]\n\n  n = cl_0 - 1;\n  if ( dl_0 < 0 )\n  {\n    for ( i = dl_0; i < 0; ++i )\n    {\n      if ( b[n - i] )\n        return -1;\n    }\n  }\n  if ( dl_0 > 0 )\n  {\n    for ( ia = dl_0; ia > 0; --ia )\n    {\n      if ( a[n + ia] )\n        return 1;\n    }\n  }\n  return bn_cmp_words(a, b, cl_0);\n}\n\n\n Revised code:\nint bn_cmp_part_words(const BN_ULONG *a, const BN_ULONG *b, int cl, int dl)\n{\n    int n, i;\n    n = cl - 1;\n\n    if (dl < 0) {\n        for (i = dl; i < 0; i++) {\n            if (b[n - i] != 0)\n                return -1;      /* a < b */\n        }\n    }\n    if (dl > 0) {\n        for (i = dl; i > 0; i--) {\n            if (a[n + i] != 0)\n                return 1;       /* a > b */\n        }\n    }\n    return bn_cmp_words(a, b, cl);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_45D449(__int64 a1, __int64 a2)\n{\n  if ( a2 == a1 )\n    return 1LL;\n  else\n    return a2 - a1;\n}\n",
        "output": "long sub(long a1, long a2)\n{\n    if (a1 == a2)\n        return 1;\n    else\n        return a2 - a1;\n}",
        "source_code": "static ALWAYS_INLINE data_t jiffies_diff(data_t old, data_t new)\n{\n\tdata_t diff = new - old;\n\treturn (diff == 0) ? 1 : diff;\n}",
        "parsed_output": "long sub(long a1, long a2)\n{\n    if (a1 == a2)\n        return 1;\n    else\n        return a2 - a1;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_45D449(__int64 a1, __int64 a2)\n{\n  if ( a2 == a1 )\n    return 1LL;\n  else\n    return a2 - a1;\n}\n",
        "baseline_code_debug": "data_t __cdecl jiffies_diff(data_t old, data_t a2)\n{\n  if ( a2 == old )\n    return 1LL;\n  else\n    return a2 - old;\n}\n",
        "similarity_score_unixcoder": 0.538820207118988,
        "similarity_score_baseline_stripped": 0.45378172397613525,
        "similarity_score_baseline_debug": 0.841335654258728
    },
    {
        "func_name": "monotonic_ns",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl dtls1_is_timer_expired(SSL *s)\n{\n  timeval timeleft; // [rsp+10h] [rbp-10h] BYREF\n\n  if ( !dtls1_get_timeout(s, &timeleft) )\n    return 0;\n  return timeleft.tv_sec <= 0 && timeleft.tv_usec <= 0;\n}\n\n\n Revised code:\nint dtls1_is_timer_expired(SSL *s)\n{\n    struct timeval timeleft;\n\n    /* Get time left until timeout, return false if no timer running */\n    if (dtls1_get_timeout(s, &timeleft) == NULL) {\n        return 0;\n    }\n\n    /* Return false if timer is not expired yet */\n    if (timeleft.tv_sec > 0 || timeleft.tv_usec > 0) {\n        return 0;\n    }\n\n    /* Timer expired, so return true */\n    return 1;\n}\n\n## Example:\n\n Input code:\ntimeval *__cdecl dtls1_get_timeout(SSL *s, timeval *timeleft)\n{\n  __suseconds_t tv_usec; // rdx\n  timeval timenow; // [rsp+10h] [rbp-10h] BYREF\n\n  if ( !s->d1->next_timeout.tv_sec && !s->d1->next_timeout.tv_usec )\n    return 0LL;\n  get_current_time(&timenow);\n  if ( s->d1->next_timeout.tv_sec < timenow.tv_sec\n    || s->d1->next_timeout.tv_sec == timenow.tv_sec && s->d1->next_timeout.tv_usec <= timenow.tv_usec )\n  {\n    memset(timeleft, 0, sizeof(timeval));\n    return timeleft;\n  }\n  else\n  {\n    tv_usec = s->d1->next_timeout.tv_usec;\n    timeleft->tv_sec = s->d1->next_timeout.tv_sec;\n    timeleft->tv_usec = tv_usec;\n    timeleft->tv_sec -= timenow.tv_sec;\n    timeleft->tv_usec -= timenow.tv_usec;\n    if ( timeleft->tv_usec < 0 )\n    {\n      --timeleft->tv_sec;\n      timeleft->tv_usec += 1000000LL;\n    }\n    if ( !timeleft->tv_sec && timeleft->tv_usec <= 14999 )\n      memset(timeleft, 0, sizeof(timeval));\n    return timeleft;\n  }\n}\n\n\n Revised code:\nstruct timeval *dtls1_get_timeout(SSL *s, struct timeval *timeleft)\n{\n    struct timeval timenow;\n\n    /* If no timeout is set, just return NULL */\n    if (s->d1->next_timeout.tv_sec == 0 && s->d1->next_timeout.tv_usec == 0) {\n        return NULL;\n    }\n\n    /* Get current time */\n    get_current_time(&timenow);\n\n    /* If timer already expired, set remaining time to 0 */\n    if (s->d1->next_timeout.tv_sec < timenow.tv_sec ||\n        (s->d1->next_timeout.tv_sec == timenow.tv_sec &&\n         s->d1->next_timeout.tv_usec <= timenow.tv_usec)) {\n        memset(timeleft, 0, sizeof(struct timeval));\n        return timeleft;\n    }\n\n    /* Calculate time left until timer expires */\n    memcpy(timeleft, &(s->d1->next_timeout), sizeof(struct timeval));\n    timeleft->tv_sec -= timenow.tv_sec;\n    timeleft->tv_usec -= timenow.tv_usec;\n    if (timeleft->tv_usec < 0) {\n        timeleft->tv_sec--;\n        timeleft->tv_usec += 1000000;\n    }\n\n    /*\n     * If remaining time is less than 15 ms, set it to 0 to prevent issues\n     * because of small devergences with socket timeouts.\n     */\n    if (timeleft->tv_sec == 0 && timeleft->tv_usec < 15000) {\n        memset(timeleft, 0, sizeof(struct timeval));\n    }\n\n    return timeleft;\n}\n\n## Example:\n\n Input code:\nint __cdecl def_time_cb(TS_resp_ctx *ctx, void *data, __int64 *sec, __int64 *usec)\n{\n  timeval tv; // [rsp+20h] [rbp-10h] BYREF\n\n  if ( gettimeofday(&tv, 0LL) )\n  {\n    ERR_put_error(47, 111, 122, \"ts_rsp_sign.c\", 117);\n    TS_RESP_CTX_set_status_info(ctx, 2, \"Time is not available.\");\n    TS_RESP_CTX_add_failure_info(ctx, 14);\n    return 0;\n  }\n  else\n  {\n    *sec = tv.tv_sec;\n    *usec = tv.tv_usec;\n    return 1;\n  }\n}\n\n\n Revised code:\nstatic int def_time_cb(struct TS_resp_ctx *ctx, void *data,\n                       long *sec, long *usec)\n{\n    struct timeval tv;\n    if (gettimeofday(&tv, NULL) != 0) {\n        TSerr(TS_F_DEF_TIME_CB, TS_R_TIME_SYSCALL_ERROR);\n        TS_RESP_CTX_set_status_info(ctx, TS_STATUS_REJECTION,\n                                    \"Time is not available.\");\n        TS_RESP_CTX_add_failure_info(ctx, TS_INFO_TIME_NOT_AVAILABLE);\n        return 0;\n    }\n    /* Return time to caller. */\n    *sec = tv.tv_sec;\n    *usec = tv.tv_usec;\n\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__suseconds_t sub_40BC33()\n{\n  struct timeval tv; // [rsp+0h] [rbp-10h] BYREF\n\n  gettimeofday(&tv, 0LL);\n  return 1000 * tv.tv_usec + 1000000000 * tv.tv_sec;\n}\n",
        "output": "__suseconds_t get_time_in_nanoseconds()\n{\n    struct timeval tv;\n\n    /* Get the current time */\n    gettimeofday(&tv, NULL);\n\n    /* Convert time to nanoseconds */\n    return (tv.tv_sec * 1000000000) + (tv.tv_usec * 1000);\n}",
        "source_code": "unsigned long long FAST_FUNC monotonic_ns(void)\n{\n\tstruct timespec ts;\n\tget_mono(&ts);\n\treturn ts.tv_sec * 1000000000ULL + ts.tv_nsec;\n}",
        "parsed_output": "__suseconds_t get_time_in_nanoseconds()\n{\n    struct timeval tv;\n\n    /* Get the current time */\n    gettimeofday(&tv, NULL);\n\n    /* Convert time to nanoseconds */\n    return (tv.tv_sec * 1000000000) + (tv.tv_usec * 1000);\n}",
        "baseline_code_stripped": "__suseconds_t sub_40BC33()\n{\n  struct timeval tv; // [rsp+0h] [rbp-10h] BYREF\n\n  gettimeofday(&tv, 0LL);\n  return 1000 * tv.tv_usec + 1000000000 * tv.tv_sec;\n}\n",
        "baseline_code_debug": "unsigned __int64 __cdecl monotonic_ns()\n{\n  timeval tv; // [rsp+0h] [rbp-10h] BYREF\n\n  gettimeofday(&tv, 0LL);\n  return 1000 * tv.tv_usec + 1000000000 * tv.tv_sec;\n}\n",
        "similarity_score_unixcoder": 0.7468851804733276,
        "similarity_score_baseline_stripped": 0.5797103643417358,
        "similarity_score_baseline_debug": 0.7561351656913757
    },
    {
        "func_name": "bb__parsegrent",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl t_fromb64(unsigned __int8 *a, const char *src)\n{\n  int v2; // eax\n  unsigned __int8 *v3; // rcx\n  int v4; // eax\n  char *loc; // [rsp+18h] [rbp-18h]\n  int size; // [rsp+24h] [rbp-Ch]\n  int sizea; // [rsp+24h] [rbp-Ch]\n  int j; // [rsp+28h] [rbp-8h]\n  int i; // [rsp+2Ch] [rbp-4h]\n  int ia; // [rsp+2Ch] [rbp-4h]\n  int ib; // [rsp+2Ch] [rbp-4h]\n  int ic; // [rsp+2Ch] [rbp-4h]\n  int id; // [rsp+2Ch] [rbp-4h]\n  int ie; // [rsp+2Ch] [rbp-4h]\n\n  while ( *src && (*src == 32 || *src == 9 || *src == 10) )\n    ++src;\n  size = strlen(src);\n  for ( i = 0; i < size; ++i )\n  {\n    loc = strchr(b64table, src[i]);\n    if ( !loc )\n      break;\n    a[i] = loc - b64table;\n  }\n  sizea = i;\n  ia = i - 1;\n  j = sizea;\n  do\n  {\n    a[j] = a[ia];\n    ib = ia - 1;\n    if ( ib < 0 )\n      break;\n    a[j--] |= a[ib] << 6;\n    a[j] = ((int)a[ib] >> 2) & 0xF;\n    ic = ib - 1;\n    if ( ic < 0 )\n      break;\n    a[j--] |= 16 * a[ic];\n    a[j] = ((int)a[ic] >> 4) & 3;\n    id = ic - 1;\n    if ( id < 0 )\n      break;\n    a[j--] |= 4 * a[id];\n    a[j] = 0;\n    ia = id - 1;\n  }\n  while ( ia >= 0 );\n  while ( !a[j] && j <= sizea )\n    ++j;\n  ie = 0;\n  while ( j <= sizea )\n  {\n    v2 = j++;\n    v3 = &a[v2];\n    v4 = ie++;\n    a[v4] = *v3;\n  }\n  return ie;\n}\n\n\n Revised code:\nstatic int t_fromb64(unsigned char *a, const char *src)\n{\n    char *loc;\n    int i, j;\n    int size;\n\n    while (*src && (*src == ' ' || *src == '\\t' || *src == '\\n'))\n        ++src;\n    size = strlen(src);\n    i = 0;\n    while (i < size) {\n        loc = strchr(b64table, src[i]);\n        if (loc == (char *)0)\n            break;\n        else\n            a[i] = loc - b64table;\n        ++i;\n    }\n    /* if nothing valid to process we have a zero length response */\n    if (i == 0)\n        return 0;\n    size = i;\n    i = size - 1;\n    j = size;\n    while (1) {\n        a[j] = a[i];\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] & 3) << 6;\n        --j;\n        a[j] = (unsigned char)((a[i] & 0x3c) >> 2);\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] & 0xf) << 4;\n        --j;\n        a[j] = (unsigned char)((a[i] & 0x30) >> 4);\n        if (--i < 0)\n            break;\n        a[j] |= (a[i] << 2);\n\n        a[--j] = 0;\n        if (--i < 0)\n            break;\n    }\n    while (a[j] == 0 && j <= size)\n        ++j;\n    i = 0;\n    while (j <= size)\n        a[i++] = a[j++];\n    return i;\n}\n\n## Example:\n\n Input code:\nint __cdecl i2c_ASN1_INTEGER(ASN1_INTEGER *a, unsigned __int8 **pp)\n{\n  unsigned __int8 *v3; // rax\n  unsigned __int8 *v4; // rax\n  unsigned __int8 v5; // cl\n  unsigned __int8 *v6; // rax\n  unsigned __int8 *v7; // rax\n  unsigned __int8 v8; // cl\n  unsigned __int8 *v9; // rax\n  int neg; // [rsp+18h] [rbp-28h]\n  unsigned __int8 pb; // [rsp+1Fh] [rbp-21h]\n  unsigned __int8 *n; // [rsp+20h] [rbp-20h]\n  unsigned __int8 *na; // [rsp+20h] [rbp-20h]\n  unsigned __int8 *p; // [rsp+28h] [rbp-18h]\n  unsigned __int8 *pa; // [rsp+28h] [rbp-18h]\n  unsigned __int8 *pc; // [rsp+28h] [rbp-18h]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int ib; // [rsp+34h] [rbp-Ch]\n  int ret; // [rsp+38h] [rbp-8h]\n  int pad; // [rsp+3Ch] [rbp-4h]\n\n  pad = 0;\n  pb = 0;\n  if ( !a )\n    return 0;\n  neg = a->type & 0x100;\n  if ( a->length )\n  {\n    if ( neg || *a->data <= 0x7Fu )\n    {\n      if ( neg )\n      {\n        if ( *a->data <= 0x80u )\n        {\n          if ( *a->data == 128 )\n          {\n            for ( i = 1; i < a->length; ++i )\n            {\n              if ( a->data[i] )\n              {\n                pad = 1;\n                pb = -1;\n                break;\n              }\n            }\n          }\n        }\n        else\n        {\n          pad = 1;\n          pb = -1;\n        }\n      }\n    }\n    else\n    {\n      pad = 1;\n      pb = 0;\n    }\n    ret = pad + a->length;\n  }\n  else\n  {\n    ret = 1;\n  }\n  if ( !pp )\n    return ret;\n  p = *pp;\n  if ( pad )\n  {\n    ++p;\n    **pp = pb;\n  }\n  if ( a->length )\n  {\n    if ( neg )\n    {\n      n = &a->data[a->length - 1];\n      pa = &p[a->length - 1];\n      ia = a->length;\n      while ( !*n )\n      {\n        v3 = pa--;\n        *v3 = 0;\n        --n;\n        --ia;\n      }\n      v4 = n;\n      na = n - 1;\n      v5 = *v4;\n      v6 = pa;\n      pc = pa - 1;\n      *v6 = -v5;\n      for ( ib = ia - 1; ib > 0; --ib )\n      {\n        v7 = na--;\n        v8 = *v7;\n        v9 = pc--;\n        *v9 = ~v8;\n      }\n    }\n    else\n    {\n      memcpy(p, a->data, (unsigned int)a->length);\n    }\n  }\n  else\n  {\n    *p = 0;\n  }\n  *pp += ret;\n  return ret;\n}\n\n\n Revised code:\nint i2c_ASN1_INTEGER(ASN1_INTEGER *a, unsigned char **pp)\n{\n    int pad = 0, ret, i, neg;\n    unsigned char *p, *n, pb = 0;\n\n    if (a == NULL)\n        return (0);\n    neg = a->type & V_ASN1_NEG;\n    if (a->length == 0)\n        ret = 1;\n    else {\n        ret = a->length;\n        i = a->data[0];\n        if (ret == 1 && i == 0)\n            neg = 0;\n        if (!neg && (i > 127)) {\n            pad = 1;\n            pb = 0;\n        } else if (neg) {\n            if (i > 128) {\n                pad = 1;\n                pb = 0xFF;\n            } else if (i == 128) {\n                /*\n                 * Special case: if any other bytes non zero we pad:\n                 * otherwise we don't.\n                 */\n                for (i = 1; i < a->length; i++)\n                    if (a->data[i]) {\n                        pad = 1;\n                        pb = 0xFF;\n                        break;\n                    }\n            }\n        }\n        ret += pad;\n    }\n    if (pp == NULL)\n        return (ret);\n    p = *pp;\n\n    if (pad)\n        *(p++) = pb;\n    if (a->length == 0)\n        *(p++) = 0;\n    else if (!neg)\n        memcpy(p, a->data, (unsigned int)a->length);\n    else {\n        /* Begin at the end of the encoding */\n        n = a->data + a->length - 1;\n        p += a->length - 1;\n        i = a->length;\n        /* Copy zeros to destination as long as source is zero */\n        while (!*n && i > 1) {\n            *(p--) = 0;\n            n--;\n            i--;\n        }\n        /* Complement and increment next octet */\n        *(p--) = ((*(n--)) ^ 0xff) + 1;\n        i--;\n        /* Complement any octets left */\n        for (; i > 0; i--)\n            *(p--) = *(n--) ^ 0xff;\n    }\n\n    *pp += ret;\n    return (ret);\n}\n\n## Example:\n\n Input code:\nchar *__cdecl t_tob64(char *dst, const unsigned __int8 *src, int size)\n{\n  char *v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  int v7; // eax\n  char *dsta; // [rsp+Ch] [rbp-28h]\n  int c; // [rsp+20h] [rbp-14h]\n  int ca; // [rsp+20h] [rbp-14h]\n  unsigned __int8 notleading; // [rsp+2Ch] [rbp-8h]\n  unsigned __int8 b2; // [rsp+2Dh] [rbp-7h]\n  unsigned __int8 b1; // [rsp+2Eh] [rbp-6h]\n  unsigned __int8 b0; // [rsp+2Fh] [rbp-5h]\n  int pos; // [rsp+30h] [rbp-4h]\n\n  dsta = dst;\n  pos = size % 3;\n  b0 = 0;\n  b1 = 0;\n  b2 = 0;\n  notleading = 0;\n  if ( size % 3 == 1 )\n  {\n    b2 = *src;\n  }\n  else if ( pos == 2 )\n  {\n    b1 = *src;\n    b2 = src[1];\n  }\n  while ( 1 )\n  {\n    if ( notleading || b0 >> 2 )\n    {\n      v3 = dsta++;\n      *v3 = b64table[b0 >> 2];\n      notleading = 1;\n    }\n    c = (16 * b0) & 0x30 | (b1 >> 4);\n    if ( notleading || c )\n    {\n      v4 = dsta++;\n      *v4 = b64table[c];\n      notleading = 1;\n    }\n    ca = (4 * b1) & 0x3C | (b2 >> 6);\n    if ( notleading || ca )\n    {\n      v5 = dsta++;\n      *v5 = b64table[ca];\n      notleading = 1;\n    }\n    if ( notleading || (b2 & 0x3F) != 0 )\n    {\n      v6 = dsta++;\n      *v6 = b64table[b2 & 0x3F];\n      notleading = 1;\n    }\n    if ( pos >= size )\n      break;\n    b0 = src[pos];\n    b1 = src[pos + 1];\n    v7 = pos + 2;\n    pos += 3;\n    b2 = src[v7];\n  }\n  *dsta = 0;\n  return dst;\n}\n\n\n Revised code:\nstatic char *t_tob64(char *dst, const unsigned char *src, int size)\n{\n    int c, pos = size % 3;\n    unsigned char b0 = 0, b1 = 0, b2 = 0, notleading = 0;\n    char *olddst = dst;\n\n    switch (pos) {\n    case 1:\n        b2 = src[0];\n        break;\n    case 2:\n        b1 = src[0];\n        b2 = src[1];\n        break;\n    }\n\n    while (1) {\n        c = (b0 & 0xfc) >> 2;\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = ((b0 & 3) << 4) | ((b1 & 0xf0) >> 4);\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = ((b1 & 0xf) << 2) | ((b2 & 0xc0) >> 6);\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        c = b2 & 0x3f;\n        if (notleading || c != 0) {\n            *dst++ = b64table[c];\n            notleading = 1;\n        }\n        if (pos >= size)\n            break;\n        else {\n            b0 = src[pos++];\n            b1 = src[pos++];\n            b2 = src[pos++];\n        }\n    }\n\n    *dst++ = '\\0';\n    return olddst;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40CAB7(__int64 *a1, const char *a2)\n{\n  char *v2; // rax\n  int v3; // eax\n  char **v5; // rax\n  char *sa; // [rsp+0h] [rbp-40h]\n  char *endptr; // [rsp+10h] [rbp-30h] BYREF\n  unsigned __int8 v10; // [rsp+1Fh] [rbp-21h]\n  unsigned __int64 v11; // [rsp+20h] [rbp-20h]\n  char **v12; // [rsp+28h] [rbp-18h]\n  int i; // [rsp+34h] [rbp-Ch]\n  char *v14; // [rsp+38h] [rbp-8h]\n\n  v11 = *a1;\n  for ( i = 0; ; ++i )\n  {\n    v14 = (char *)a1 + (unsigned __int8)byte_5350AE[i];\n    if ( i > 1 )\n      break;\n    *(_QWORD *)v14 = a2;\n    sa = strchr(a2, 58);\n    if ( !sa )\n      return 0xFFFFFFFFLL;\n    v2 = sa;\n    a2 = sa + 1;\n    *v2 = 0;\n  }\n  v3 = strtoul(a2, &endptr, 10);\n  *(_DWORD *)v14 = v3;\n  if ( a2 == endptr || *endptr != 58 )\n    return 0xFFFFFFFFLL;\n  i = 1;\n  v14 = endptr;\n  if ( endptr[1] )\n  {\n    *v14 = 44;\n    do\n    {\n      if ( *v14 == 44 )\n      {\n        ++i;\n        *v14 = 0;\n        if ( !*++v14 || *v14 == 44 )\n          return 0xFFFFFFFFLL;\n        v10 = *v14 - 9;\n        if ( v10 == 23 || v10 <= 4u )\n          return 0xFFFFFFFFLL;\n      }\n    }\n    while ( *++v14 );\n  }\n  v12 = (char **)((unsigned __int64)(v14 + 8) & 0xFFFFFFFFFFFFFFF8LL);\n  if ( v11 < (unsigned __int64)&v12[i] )\n    return 0xFFFFFFFFLL;\n  a1[3] = (__int64)v12;\n  if ( --i )\n  {\n    v14 = endptr;\n    while ( 1 )\n    {\n      ++v14;\n      v5 = v12++;\n      *v5 = v14;\n      if ( !--i )\n        break;\n      do\n        ++v14;\n      while ( *v14 );\n    }\n  }\n  *v12 = 0LL;\n  return 0LL;\n}\n",
        "output": "```c\nlong long sub_40CAB7(long long *a1, const char *a2)\n{\n    char *colon_ptr;\n    char *endptr;\n    unsigned long port;\n    char **argv;\n    int argc = 0;\n    char *current_arg;\n\n    for (int i = 0; i < 2; ++i) {\n        current_arg = (char *)a1 + byte_5350AE[i];\n        *(__int64 *)current_arg = a2;\n        colon_ptr = strchr(a2, ':');\n        if (!colon_ptr)\n            return -1;\n        *colon_ptr = '\\0';\n        a2 = colon_ptr + 1;\n    }\n    port = strtoul(a2, &endptr, 10);\n    *(__int32 *)current_arg = (int)port;\n    if (a2 == endptr || *endptr != ':')\n        return -1;\n    current_arg = endptr;\n    if (endptr[1]) {\n        *current_arg = '\\0';\n        ++current_arg;\n        if (!*current_arg || *current_arg == ',')\n            return -1;\n        unsigned char next_char = *current_arg - 9;\n        if (next_char == 23 || next_char <= 4)\n            return -1;\n        while (*current_arg) {\n            if (*current_arg == ',') {\n                ++argc;\n                *current_arg = '\\0';\n                if (!*(++current_arg) || *current_arg == ',')\n                    return -1;\n            }\n            ++current_arg;\n        }\n    }\n    argv = (char **)(((unsigned long long)(current_arg + 8)) & ~7ULL);\n    if ((unsigned long long)a1[0] < (unsigned long long)(argv + argc))\n        return -1;\n    a1[3] = (long long)argv;\n    if (argc) {\n        current_arg = endptr;\n        while (1) {\n            ++current_arg;\n            *argv++ = current_arg;\n            if (!--argc)\n                break;\n            while (*current_arg)\n                ++current_arg;\n        }\n    }\n    *argv = NULL;\n    return 0;\n}\n```",
        "source_code": "static int FAST_FUNC bb__parsegrent(void *data, char *line)\n{\n\tchar *endptr;\n\tchar *p;\n\tint i;\n\tchar **members;\n\tchar *end_of_buf;\n\n\tend_of_buf = ((struct group *) data)->gr_name; /* Evil hack! */\n\ti = 0;\n\twhile (1) {\n\t\tp = (char *) data + gr_off[i];\n\n\t\tif (i < 2) {\n\t\t\t*((char **) p) = line;\n\t\t\tline = strchr(line, ':');\n\t\t\tif (!line) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*line++ = '\\0';\n\t\t\ti++;\n\t\t} else {\n\t\t\t*((gid_t *) p) = strtoul(line, &endptr, 10);\n\n\t\t\t/* NOTE: glibc difference - glibc allows omission of the\n\t\t\t * trailing colon when there is no member list.  We treat\n\t\t\t * this as an error. */\n\n\t\t\t/* Make sure we had at least one digit, and that the\n\t\t\t * failing char is the next field seperator ':'.  See\n\t\t\t * glibc difference note above. */\n\t\t\tif ((endptr == line) || (*endptr != ':')) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ti = 1;\t\t\t\t/* Count terminating NULL ptr. */\n\t\t\tp = endptr;\n\n\t\t\tif (p[1]) { /* We have a member list to process. */\n\t\t\t\t/* Overwrite the last ':' with a ',' before counting.\n\t\t\t\t * This allows us to (1) test for initial ','\n\t\t\t\t * and (2) adds one ',' so that the number of commas\n\t\t\t\t * equals the member count. */\n\t\t\t\t*p = ',';\n\t\t\t\tdo {\n\t\t\t\t\t/* NOTE: glibc difference - glibc allows and trims leading\n\t\t\t\t\t * (but not trailing) space.  We treat this as an error. */\n\t\t\t\t\t/* NOTE: glibc difference - glibc allows consecutive and\n\t\t\t\t\t * trailing commas, and ignores \"empty string\" users.  We\n\t\t\t\t\t * treat this as an error. */\n\t\t\t\t\tif (*p == ',') {\n\t\t\t\t\t\t++i;\n\t\t\t\t\t\t*p = 0;\t/* nul-terminate each member string. */\n\t\t\t\t\t\tif (!*++p || (*p == ',') || isspace(*p)) {\n\t\t\t\t\t\t\tgoto ERR;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (*++p);\n\t\t\t}\n\n\t\t\t/* Now align (p+1), rounding up. */\n\t\t\t/* Assumes sizeof(char **) is a power of 2. */\n\t\t\tmembers = (char **)( (((intptr_t) p) + sizeof(char **))\n\t\t\t\t\t\t\t\t & ~((intptr_t)(sizeof(char **) - 1)) );\n\n\t\t\tif (((char *)(members + i)) > end_of_buf) {\t/* No space. */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t((struct group *) data)->gr_mem = members;\n\n\t\t\tif (--i) {\n\t\t\t\tp = endptr;\t/* Pointing to char prior to first member. */\n\t\t\t\twhile (1) {\n\t\t\t\t\t*members++ = ++p;\n\t\t\t\t\tif (!--i)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\twhile (*++p)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\t*members = NULL;\n\n\t\t\treturn 0;\n\t\t}\n\t} /* while (1) */\n\n ERR:\n\treturn -1;\n}",
        "parsed_output": "long long sub_40CAB7(long long *a1, const char *a2)\n{\n    char *colon_ptr;\n    char *endptr;\n    unsigned long port;\n    char **argv;\n    int argc = 0;\n    char *current_arg;\n\n    for (int i = 0; i < 2; ++i) {\n        current_arg = (char *)a1 + byte_5350AE[i];\n        *(__int64 *)current_arg = a2;\n        colon_ptr = strchr(a2, ':');\n        if (!colon_ptr)\n            return -1;\n        *colon_ptr = '\\0';\n        a2 = colon_ptr + 1;\n    }\n    port = strtoul(a2, &endptr, 10);\n    *(__int32 *)current_arg = (int)port;\n    if (a2 == endptr || *endptr != ':')\n        return -1;\n    current_arg = endptr;\n    if (endptr[1]) {\n        *current_arg = '\\0';\n        ++current_arg;\n        if (!*current_arg || *current_arg == ',')\n            return -1;\n        unsigned char next_char = *current_arg - 9;\n        if (next_char == 23 || next_char <= 4)\n            return -1;\n        while (*current_arg) {\n            if (*current_arg == ',') {\n                ++argc;\n                *current_arg = '\\0';\n                if (!*(++current_arg) || *current_arg == ',')\n                    return -1;\n            }\n            ++current_arg;\n        }\n    }\n    argv = (char **)(((unsigned long long)(current_arg + 8)) & ~7ULL);\n    if ((unsigned long long)a1[0] < (unsigned long long)(argv + argc))\n        return -1;\n    a1[3] = (long long)argv;\n    if (argc) {\n        current_arg = endptr;\n        while (1) {\n            ++current_arg;\n            *argv++ = current_arg;\n            if (!--argc)\n                break;\n            while (*current_arg)\n                ++current_arg;\n        }\n    }\n    *argv = NULL;\n    return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40CAB7(__int64 *a1, const char *a2)\n{\n  char *v2; // rax\n  int v3; // eax\n  char **v5; // rax\n  char *sa; // [rsp+0h] [rbp-40h]\n  char *endptr; // [rsp+10h] [rbp-30h] BYREF\n  unsigned __int8 v10; // [rsp+1Fh] [rbp-21h]\n  unsigned __int64 v11; // [rsp+20h] [rbp-20h]\n  char **v12; // [rsp+28h] [rbp-18h]\n  int i; // [rsp+34h] [rbp-Ch]\n  char *v14; // [rsp+38h] [rbp-8h]\n\n  v11 = *a1;\n  for ( i = 0; ; ++i )\n  {\n    v14 = (char *)a1 + (unsigned __int8)byte_5350AE[i];\n    if ( i > 1 )\n      break;\n    *(_QWORD *)v14 = a2;\n    sa = strchr(a2, 58);\n    if ( !sa )\n      return 0xFFFFFFFFLL;\n    v2 = sa;\n    a2 = sa + 1;\n    *v2 = 0;\n  }\n  v3 = strtoul(a2, &endptr, 10);\n  *(_DWORD *)v14 = v3;\n  if ( a2 == endptr || *endptr != 58 )\n    return 0xFFFFFFFFLL;\n  i = 1;\n  v14 = endptr;\n  if ( endptr[1] )\n  {\n    *v14 = 44;\n    do\n    {\n      if ( *v14 == 44 )\n      {\n        ++i;\n        *v14 = 0;\n        if ( !*++v14 || *v14 == 44 )\n          return 0xFFFFFFFFLL;\n        v10 = *v14 - 9;\n        if ( v10 == 23 || v10 <= 4u )\n          return 0xFFFFFFFFLL;\n      }\n    }\n    while ( *++v14 );\n  }\n  v12 = (char **)((unsigned __int64)(v14 + 8) & 0xFFFFFFFFFFFFFFF8LL);\n  if ( v11 < (unsigned __int64)&v12[i] )\n    return 0xFFFFFFFFLL;\n  a1[3] = (__int64)v12;\n  if ( --i )\n  {\n    v14 = endptr;\n    while ( 1 )\n    {\n      ++v14;\n      v5 = v12++;\n      *v5 = v14;\n      if ( !--i )\n        break;\n      do\n        ++v14;\n      while ( *v14 );\n    }\n  }\n  *v12 = 0LL;\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl bb__parsegrent(void *data, char *line)\n{\n  char *v2; // rax\n  int v3; // eax\n  char **v5; // rax\n  char *lineb; // [rsp+0h] [rbp-40h]\n  char *endptr; // [rsp+10h] [rbp-30h] BYREF\n  unsigned __int8 bb__isspace; // [rsp+1Fh] [rbp-21h]\n  char *end_of_buf; // [rsp+20h] [rbp-20h]\n  char **members; // [rsp+28h] [rbp-18h]\n  int i; // [rsp+34h] [rbp-Ch]\n  char *p; // [rsp+38h] [rbp-8h]\n\n  end_of_buf = *(char **)data;\n  for ( i = 0; ; ++i )\n  {\n    p = (char *)data + gr_off[i];\n    if ( i > 1 )\n      break;\n    *(_QWORD *)p = line;\n    lineb = strchr(line, 58);\n    if ( !lineb )\n      return -1;\n    v2 = lineb;\n    line = lineb + 1;\n    *v2 = 0;\n  }\n  v3 = strtoul(line, &endptr, 10);\n  *(_DWORD *)p = v3;\n  if ( line == endptr || *endptr != 58 )\n    return -1;\n  i = 1;\n  p = endptr;\n  if ( endptr[1] )\n  {\n    *p = 44;\n    do\n    {\n      if ( *p == 44 )\n      {\n        ++i;\n        *p = 0;\n        if ( !*++p || *p == 44 )\n          return -1;\n        bb__isspace = *p - 9;\n        if ( bb__isspace == 23 || bb__isspace <= 4u )\n          return -1;\n      }\n    }\n    while ( *++p );\n  }\n  members = (char **)((unsigned __int64)(p + 8) & 0xFFFFFFFFFFFFFFF8LL);\n  if ( end_of_buf < (char *)&members[i] )\n    return -1;\n  *((_QWORD *)data + 3) = members;\n  if ( --i )\n  {\n    p = endptr;\n    while ( 1 )\n    {\n      ++p;\n      v5 = members++;\n      *v5 = p;\n      if ( !--i )\n        break;\n      do\n        ++p;\n      while ( *p );\n    }\n  }\n  *members = 0LL;\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.6816747188568115,
        "similarity_score_baseline_stripped": 0.6606450080871582,
        "similarity_score_baseline_debug": 0.8270959854125977
    },
    {
        "func_name": "put_cur_glyph_and_inc_cursor",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl satsub64be(const unsigned __int8 *v1, const unsigned __int8 *v2)\n{\n  int result; // eax\n  int ret; // [rsp+24h] [rbp-1Ch]\n  int i; // [rsp+34h] [rbp-Ch]\n  int ia; // [rsp+34h] [rbp-Ch]\n  int brw; // [rsp+38h] [rbp-8h]\n  int brwb; // [rsp+38h] [rbp-8h]\n  int brwc; // [rsp+38h] [rbp-8h]\n  int brwa; // [rsp+38h] [rbp-8h]\n  char sat; // [rsp+3Ch] [rbp-4h]\n\n  ret = v1[7] - v2[7];\n  sat = 0;\n  brw = ret >> 8;\n  if ( (ret & 0x80) != 0 )\n  {\n    for ( i = 6; i >= 0; --i )\n    {\n      brwb = v1[i] - v2[i] + brw;\n      sat |= ~(_BYTE)brwb;\n      brw = brwb >> 8;\n    }\n  }\n  else\n  {\n    for ( ia = 6; ia >= 0; --ia )\n    {\n      brwc = v1[ia] - v2[ia] + brw;\n      sat |= brwc;\n      brw = brwc >> 8;\n    }\n  }\n  brwa = brw << 8;\n  if ( !sat )\n    return (unsigned __int8)ret + brwa;\n  result = brwa;\n  LOBYTE(result) = brwa | 0x80;\n  return result;\n}\n\n\n Revised code:\nstatic int satsub64be(const unsigned char *v1, const unsigned char *v2)\n{\n    int ret, sat, brw, i;\n\n    if (sizeof(long) == 8)\n        do {\n            const union {\n                long one;\n                char little;\n            } is_endian = {\n                1\n            };\n            long l;\n\n            if (is_endian.little)\n                break;\n            /* not reached on little-endians */\n            /*\n             * following test is redundant, because input is always aligned,\n             * but I take no chances...\n             */\n            if (((size_t)v1 | (size_t)v2) & 0x7)\n                break;\n\n            l = *((long *)v1);\n            l -= *((long *)v2);\n            if (l > 128)\n                return 128;\n            else if (l < -128)\n                return -128;\n            else\n                return (int)l;\n        } while (0);\n\n    ret = (int)v1[7] - (int)v2[7];\n    sat = 0;\n    brw = ret >> 8;             /* brw is either 0 or -1 */\n    if (ret & 0x80) {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= ~brw;\n            brw >>= 8;\n        }\n    } else {\n        for (i = 6; i >= 0; i--) {\n            brw += (int)v1[i] - (int)v2[i];\n            sat |= brw;\n            brw >>= 8;\n        }\n    }\n    brw <<= 8;                  /* brw is either 0 or -256 */\n\n    if (sat & 0xff)\n        return brw | 0x80;\n    else\n        return brw + (ret & 0xFF);\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n\n## Example:\n\n Input code:\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // rsi\n  __int64 v4; // r8\n  __int64 v5; // r9\n  va_list ap; // [rsp+18h] [rbp-C8h] BYREF\n  __int64 v7; // [rsp+38h] [rbp-A8h]\n  __int64 v8; // [rsp+40h] [rbp-A0h]\n  __int64 v9; // [rsp+48h] [rbp-98h]\n  __int64 v10; // [rsp+50h] [rbp-90h]\n  __int64 v11; // [rsp+58h] [rbp-88h]\n\n  va_start(ap, fmta);\n  v3 = va_arg(ap, _QWORD);\n  v1 = va_arg(ap, _QWORD);\n  v2 = va_arg(ap, _QWORD);\n  v4 = va_arg(ap, _QWORD);\n  v5 = va_arg(ap, _QWORD);\n  v7 = v3;\n  v8 = v1;\n  v9 = v2;\n  v10 = v4;\n  v11 = v5;\n  ap[0].gp_offset = 8;\n  vfprintf(stderr, fmta, ap);\n}\n\n\n Revised code:\nendif\n\nvoid OPENSSL_showfatal(const char *fmta, ...)\n{\n    va_list ap;\n    TCHAR buf[256];\n    const TCHAR *fmt;\n# ifdef STD_ERROR_HANDLE        /* what a dirty trick! */\n    HANDLE h;\n\n    if ((h = GetStdHandle(STD_ERROR_HANDLE)) != NULL &&\n        GetFileType(h) != FILE_TYPE_UNKNOWN) {\n        /* must be console application */\n        va_start(ap, fmta);\n        vfprintf(stderr, fmta, ap);\n        va_end(ap);\n        return;\n    }\n# endif\n\n    if (sizeof(TCHAR) == sizeof(char))\n        fmt = (const TCHAR *)fmta;\n    else\n        do {\n            int keepgoing;\n            size_t len_0 = strlen(fmta) + 1, i;\n            WCHAR *fmtw;\n\n            fmtw = (WCHAR *)alloca(len_0 * sizeof(WCHAR));\n            if (fmtw == NULL) {\n                fmt = (const TCHAR *)L\"no stack?\";\n                break;\n            }\n# ifndef OPENSSL_NO_MULTIBYTE\n            if (!MultiByteToWideChar(CP_ACP, 0, fmta, len_0, fmtw, len_0))\n# endif\n                for (i = 0; i < len_0; i++)\n                    fmtw[i] = (WCHAR)fmta[i];\n\n            for (i = 0; i < len_0; i++) {\n                if (fmtw[i] == L'%')\n                    do {\n                        keepgoing = 0;\n                        switch (fmtw[i + 1]) {\n                        case L'0':\n                        case L'1':\n                        case L'2':\n                        case L'3':\n                        case L'4':\n                        case L'5':\n                        case L'6':\n                        case L'7':\n                        case L'8':\n                        case L'9':\n                        case L'.':\n                        case L'*':\n                        case L'-':\n                            i++;\n                            keepgoing = 1;\n                            break;\n                        case L's':\n                            fmtw[i + 1] = L'S';\n                            break;\n                        case L'S':\n                            fmtw[i + 1] = L's';\n                            break;\n                        case L'c':\n                            fmtw[i + 1] = L'C';\n                            break;\n                        case L'C':\n                            fmtw[i + 1] = L'c';\n                            break;\n                        }\n                    } while (keepgoing);\n            }\n            fmt = (const TCHAR *)fmtw;\n        } while (0);\n\n    va_start(ap, fmta);\n    _vsntprintf(buf, sizeof(buf) / sizeof(TCHAR) - 1, fmt, ap);\n    buf[sizeof(buf) / sizeof(TCHAR) - 1] = _T('\\0');\n    va_end(ap);\n\n# if defined(_WIN32_WINNT) && _WIN32_WINNT>=0x0333\n    /* this -------------v--- guards NT-specific calls */\n    if (check_winnt() && OPENSSL_isservice() > 0) {\n        HANDLE hEventLog = RegisterEventSource(NULL, _T(\"OpenSSL\"));\n\n        if (hEventLog != NULL) {\n            const TCHAR *pmsg = buf;\n\n            if (!ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL,\n                             1, 0, &pmsg, NULL)) {\n#if defined(DEBUG)\n                /*\n                 * We are in a situation where we tried to report a critical\n                 * error and this failed for some reason. As a last resort,\n                 * in debug builds, send output to the debugger or any other\n                 * tool like DebugView which can monitor the output.\n                 */\n                OutputDebugString(pmsg);\n#endif\n            }\n\n            (void)DeregisterEventSource(hEventLog);\n        }\n    } else\n# endif\n        MessageBox(NULL, buf, _T(\"OpenSSL: FATAL\"), MB_OK | MB_ICONERROR);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint sub_4FE1E5()\n{\n  int result; // eax\n  int v1; // [rsp+4h] [rbp-Ch]\n  int v2; // [rsp+Ch] [rbp-4h]\n  unsigned int v3; // [rsp+Ch] [rbp-4h]\n\n  v2 = *(_DWORD *)(*((_QWORD *)qword_75D458 + 6) + 4LL * *((unsigned int *)qword_75D458 + 9));\n  if ( v2 )\n  {\n    ++*((_DWORD *)qword_75D458 + 9);\n    ++*((_DWORD *)qword_75D458 + 6);\n    v3 = sub_4FE198(v2);\n  }\n  else\n  {\n    v3 = 32;\n  }\n  v1 = *((_DWORD *)qword_75D458 + 6) - *((_DWORD *)qword_75D458 + 2);\n  result = sub_4FE142(v3);\n  if ( v1 >= 0 )\n  {\n    puts(\"\\r\");\n    ++*((_DWORD *)qword_75D458 + 7);\n    result = (int)qword_75D458;\n    *((_DWORD *)qword_75D458 + 6) = 0;\n  }\n  return result;\n}\n",
        "output": "```c\nint sub_4FE1E5()\n{\n    int result;\n    int v1;\n    unsigned int v2;\n\n    int *global_data = (int *)qword_75D458;\n    int index = global_data[9];\n    int value = *((int *)(global_data[6] + 4 * index));\n\n    if (value)\n    {\n        global_data[9]++;\n        global_data[6]++;\n        v2 = sub_4FE198(value);\n    }\n    else\n    {\n        v2 = 32;\n    }\n\n    v1 = global_data[6] - global_data[2];\n    result = sub_4FE142(v2);\n\n    if (v1 >= 0)\n    {\n        puts(\"\\r\");\n        global_data[7]++;\n        result = (int)qword_75D458;\n        global_data[6] = 0;\n    }\n\n    return result;\n}\n```",
        "source_code": "define HACK_FOR_WRONG_WIDTH 1\nstatic void put_cur_glyph_and_inc_cursor(void)\n{\n\tCHAR_T c = command_ps[cursor];\n\tunsigned width = 0;\n\tint ofs_to_right;\n\n\tif (c == BB_NUL) {\n\t\t/* erase character after end of input string */\n\t\tc = ' ';\n\t} else {\n\t\t/* advance cursor only if we aren't at the end yet */\n\t\tcursor++;\n\t\tif (unicode_status == UNICODE_ON) {\n\t\t\tIF_UNICODE_WIDE_WCHARS(width = cmdedit_x;)\n\t\t\tc = adjust_width_and_validate_wc(&cmdedit_x, c);\n\t\t\tIF_UNICODE_WIDE_WCHARS(width = cmdedit_x - width;)\n\t\t} else {\n\t\t\tcmdedit_x++;\n\t\t}\n\t}\n\n\tofs_to_right = cmdedit_x - cmdedit_termw;\n\tif (!ENABLE_UNICODE_WIDE_WCHARS || ofs_to_right <= 0) {\n\t\t/* c fits on this line */\n\t\tBB_PUTCHAR(c);\n\t}\n\n\tif (ofs_to_right >= 0) {\n\t\t/* we go to the next line */\n#if HACK_FOR_WRONG_WIDTH\n\t\t/* This works better if our idea of term width is wrong\n\t\t * and it is actually wider (often happens on serial lines).\n\t\t * Printing CR,LF *forces* cursor to next line.\n\t\t * OTOH if terminal width is correct AND terminal does NOT\n\t\t * have automargin (IOW: it is moving cursor to next line\n\t\t * by itself (which is wrong for VT-10x terminals)),\n\t\t * this will break things: there will be one extra empty line */\n\t\tputs(\"\\r\"); /* + implicit '\\n' */\n#else\n\t\t/* VT-10x terminals don't wrap cursor to next line when last char\n\t\t * on the line is printed - cursor stays \"over\" this char.\n\t\t * Need to print _next_ char too (first one to appear on next line)\n\t\t * to make cursor move down to next line.\n\t\t */\n\t\t/* Works ok only if cmdedit_termw is correct. */\n\t\tc = command_ps[cursor];\n\t\tif (c == BB_NUL)\n\t\t\tc = ' ';\n\t\tBB_PUTCHAR(c);\n\t\tbb_putchar('\\b');\n#endif\n\t\tcmdedit_y++;\n\t\tif (!ENABLE_UNICODE_WIDE_WCHARS || ofs_to_right == 0) {\n\t\t\twidth = 0;\n\t\t} else { /* ofs_to_right > 0 */\n\t\t\t/* wide char c didn't fit on prev line */\n\t\t\tBB_PUTCHAR(c);\n\t\t}\n\t\tcmdedit_x = width;\n\t}\n}",
        "parsed_output": "int sub_4FE1E5()\n{\n    int result;\n    int v1;\n    unsigned int v2;\n\n    int *global_data = (int *)qword_75D458;\n    int index = global_data[9];\n    int value = *((int *)(global_data[6] + 4 * index));\n\n    if (value)\n    {\n        global_data[9]++;\n        global_data[6]++;\n        v2 = sub_4FE198(value);\n    }\n    else\n    {\n        v2 = 32;\n    }\n\n    v1 = global_data[6] - global_data[2];\n    result = sub_4FE142(v2);\n\n    if (v1 >= 0)\n    {\n        puts(\"\\r\");\n        global_data[7]++;\n        result = (int)qword_75D458;\n        global_data[6] = 0;\n    }\n\n    return result;\n}",
        "baseline_code_stripped": "int sub_4FE1E5()\n{\n  int result; // eax\n  int v1; // [rsp+4h] [rbp-Ch]\n  int v2; // [rsp+Ch] [rbp-4h]\n  unsigned int v3; // [rsp+Ch] [rbp-4h]\n\n  v2 = *(_DWORD *)(*((_QWORD *)qword_75D458 + 6) + 4LL * *((unsigned int *)qword_75D458 + 9));\n  if ( v2 )\n  {\n    ++*((_DWORD *)qword_75D458 + 9);\n    ++*((_DWORD *)qword_75D458 + 6);\n    v3 = sub_4FE198(v2);\n  }\n  else\n  {\n    v3 = 32;\n  }\n  v1 = *((_DWORD *)qword_75D458 + 6) - *((_DWORD *)qword_75D458 + 2);\n  result = sub_4FE142(v3);\n  if ( v1 >= 0 )\n  {\n    puts(\"\\r\");\n    ++*((_DWORD *)qword_75D458 + 7);\n    result = (int)qword_75D458;\n    *((_DWORD *)qword_75D458 + 6) = 0;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl put_cur_glyph_and_inc_cursor()\n{\n  int ofs_to_right; // [rsp+4h] [rbp-Ch]\n  wchar_t c; // [rsp+Ch] [rbp-4h]\n  wchar_t ca; // [rsp+Ch] [rbp-4h]\n\n  c = lineedit_ptr_to_statics->command_ps[lineedit_ptr_to_statics->cursor];\n  if ( c )\n  {\n    ++lineedit_ptr_to_statics->cursor;\n    ++lineedit_ptr_to_statics->cmdedit_x;\n    ca = adjust_width_and_validate_wc(c);\n  }\n  else\n  {\n    ca = 32;\n  }\n  ofs_to_right = lineedit_ptr_to_statics->cmdedit_x - lineedit_ptr_to_statics->cmdedit_termw;\n  BB_PUTCHAR(ca);\n  if ( ofs_to_right >= 0 )\n  {\n    puts(\"\\r\");\n    ++lineedit_ptr_to_statics->cmdedit_y;\n    lineedit_ptr_to_statics->cmdedit_x = 0;\n  }\n}\n",
        "similarity_score_unixcoder": 0.48264583945274353,
        "similarity_score_baseline_stripped": 0.46878230571746826,
        "similarity_score_baseline_debug": 0.8566358089447021
    },
    {
        "func_name": "bb__parsepwent",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl interleaved_array_to_bn_512(BIGNUM *b, UINT64 *array)\n{\n  int v2; // eax\n  unsigned __int8 tmp[64]; // [rsp+10h] [rbp-50h] BYREF\n  int i; // [rsp+58h] [rbp-8h]\n  int n; // [rsp+5Ch] [rbp-4h]\n\n  n = 8;\n  while ( 1 )\n  {\n    v2 = n--;\n    if ( v2 <= 0 )\n      break;\n    for ( i = 7; i >= 0; --i )\n      tmp[63 - (8 * n + i)] = array[n] >> (8 * (unsigned __int8)i);\n  }\n  BN_bin2bn(tmp, 64, b);\n  return 0;\n}\n\n\n Revised code:\nstatic int interleaved_array_to_bn_512(BIGNUM *b, UINT64 *array)\n{\n    unsigned char tmp[64];\n    int n = 8;\n    int i;\n    while (n-- > 0) {\n        for (i = 7; i >= 0; i--) {\n            tmp[63 - (n * 8 + i)] = (unsigned char)(array[n] >> (8 * i));\n    }}\n    BN_bin2bn(tmp, 64, b);\n    return 0;\n}\n\n## Example:\n\n Input code:\nint __cdecl asn1_get_length(const unsigned __int8 **pp, int *inf, __int64 *rl, int max)\n{\n  char *v5; // rax\n  const unsigned __int8 *v6; // rax\n  int maxa; // [rsp+0h] [rbp-3Ch]\n  unsigned int i; // [rsp+28h] [rbp-14h]\n  __int64 ret; // [rsp+2Ch] [rbp-10h]\n  const unsigned __int8 *p; // [rsp+34h] [rbp-8h]\n  const unsigned __int8 *pa; // [rsp+34h] [rbp-8h]\n\n  p = *pp;\n  ret = 0LL;\n  if ( max <= 0 )\n    return 0;\n  if ( *p == 0x80 )\n  {\n    *inf = 1;\n    ret = 0LL;\n    pa = p + 1;\n  }\n  else\n  {\n    *inf = 0;\n    i = *p & 0x7F;\n    v5 = (char *)p;\n    pa = p + 1;\n    if ( *v5 >= 0 )\n    {\n      ret = i;\n    }\n    else\n    {\n      if ( i > 8 )\n        return 0;\n      maxa = max - 2;\n      if ( max == 1 )\n        return 0;\n      while ( i-- )\n      {\n        v6 = pa++;\n        ret = *v6 | (unsigned __int64)(ret << 8);\n        LODWORD(v6) = maxa--;\n        if ( !(_DWORD)v6 )\n          return 0;\n      }\n    }\n  }\n  if ( ret < 0 )\n    return 0;\n  *pp = pa;\n  *rl = ret;\n  return 1;\n}\n\n\n Revised code:\nstatic int asn1_get_length(const unsigned char **pp, int *inf, long *rl,\n                           long max)\n{\n    const unsigned char *p = *pp;\n    unsigned long ret = 0;\n    unsigned long i;\n\n    if (max-- < 1)\n        return 0;\n    if (*p == 0x80) {\n        *inf = 1;\n        ret = 0;\n        p++;\n    } else {\n        *inf = 0;\n        i = *p & 0x7f;\n        if (*(p++) & 0x80) {\n            if (i > sizeof(ret) || max < (long)i)\n                return 0;\n            while (i-- > 0) {\n                ret <<= 8L;\n                ret |= *(p++);\n            }\n        } else\n            ret = i;\n    }\n    if (ret > LONG_MAX)\n        return 0;\n    *pp = p;\n    *rl = (long)ret;\n    return 1;\n}\n\n## Example:\n\n Input code:\nint __cdecl i2a_ASN1_ENUMERATED(BIO *bp_0, ASN1_ENUMERATED *a)\n{\n  char buf[2]; // [rsp+16h] [rbp-Ah] BYREF\n  int n; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  n = 0;\n  if ( !a )\n    return 0;\n  if ( a->length )\n  {\n    for ( i = 0; i < a->length; ++i )\n    {\n      if ( i && !(i % 35) )\n      {\n        if ( BIO_write(bp_0, \"\\\\\\n\", 2) != 2 )\n          return -1;\n        n += 2;\n      }\n      buf[0] = h_6777_0[(a->data[i] >> 4) & 0xF];\n      buf[1] = h_6777_0[a->data[i] & 0xF];\n      if ( BIO_write(bp_0, buf, 2) != 2 )\n        return -1;\n      n += 2;\n    }\n    return n;\n  }\n  if ( BIO_write(bp_0, \"00\", 2) == 2 )\n    return 2;\n  return -1;\n}\n\n\n Revised code:\nint i2a_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *a)\n{\n    int i, n = 0;\n    static const char *h = \"0123456789ABCDEF\";\n    char buf[2];\n\n    if (a == NULL)\n        return (0);\n\n    if (a->length == 0) {\n        if (BIO_write(bp, \"00\", 2) != 2)\n            goto err;\n        n = 2;\n    } else {\n        for (i = 0; i < a->length; i++) {\n            if ((i != 0) && (i % 35 == 0)) {\n                if (BIO_write(bp, \"\\\\\\n\", 2) != 2)\n                    goto err;\n                n += 2;\n            }\n            buf[0] = h[((unsigned char)a->data[i] >> 4) & 0x0f];\n            buf[1] = h[((unsigned char)a->data[i]) & 0x0f];\n            if (BIO_write(bp, buf, 2) != 2)\n                goto err;\n            n += 2;\n        }\n    }\n    return (n);\n err:\n    return (-1);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40C9C5(__int64 a1, const char *a2)\n{\n  char *v3; // rax\n  char *sa; // [rsp+0h] [rbp-30h]\n  char *endptr; // [rsp+10h] [rbp-20h] BYREF\n  unsigned __int64 v7; // [rsp+18h] [rbp-18h]\n  _DWORD *v8; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  for ( i = 0; ; ++i )\n  {\n    v8 = (_DWORD *)((unsigned __int8)byte_5350A7[i] + a1);\n    if ( i <= 1 || i > 3 )\n      break;\n    v7 = strtoul(a2, &endptr, 10);\n    if ( a2 == endptr || *endptr != 58 )\n      return 0xFFFFFFFFLL;\n    sa = endptr;\n    *v8 = v7;\nLABEL_11:\n    v3 = sa;\n    a2 = sa + 1;\n    *v3 = 0;\n  }\n  *(_QWORD *)v8 = a2;\n  if ( i == 6 )\n    return 0LL;\n  sa = strchr(a2, 58);\n  if ( sa )\n    goto LABEL_11;\n  return 0xFFFFFFFFLL;\n}\n",
        "output": "```c\nlong sub_40C9C5(long a1, const char *a2)\n{\n    char *endptr;\n    unsigned long value;\n    unsigned int *target;\n    int i;\n    char *next;\n\n    for (i = 0; i < 7; ++i) {\n        target = (unsigned int *)(a1 + (unsigned char)byte_5350A7[i]);\n        if (i >= 2 && i <= 3) {\n            value = strtoul(a2, &endptr, 10);\n            if (a2 == endptr || *endptr != ':')\n                return -1;\n            next = endptr;\n            *target = (unsigned int)value;\n            *next = '\\0';\n            a2 = next + 1;\n        }\n    }\n    *(const char **)target = a2;\n    if (i == 6)\n        return 0;\n    next = strchr(a2, ':');\n    if (next)\n        goto LABEL_11;\n    return -1;\n}\n```",
        "source_code": "static int FAST_FUNC bb__parsepwent(void *data, char *line)\n{\n\tchar *endptr;\n\tchar *p;\n\tint i;\n\n\ti = 0;\n\twhile (1) {\n\t\tp = (char *) data + pw_off[i];\n\n\t\tif (i < 2 || i > 3) {\n\t\t\t*((char **) p) = line;\n\t\t\tif (i == 6) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t/* NOTE: glibc difference - glibc allows omission of\n\t\t\t * ':' seperators after the gid field if all remaining\n\t\t\t * entries are empty.  We require all separators. */\n\t\t\tline = strchr(line, ':');\n\t\t\tif (!line) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned long t = strtoul(line, &endptr, 10);\n\t\t\t/* Make sure we had at least one digit, and that the\n\t\t\t * failing char is the next field seperator ':'.  See\n\t\t\t * glibc difference note above. */\n\t\t\t/* TODO: Also check for leading whitespace? */\n\t\t\tif ((endptr == line) || (*endptr != ':')) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tline = endptr;\n\t\t\tif (i & 1) {\t\t/* i == 3 -- gid */\n\t\t\t\t*((gid_t *) p) = t;\n\t\t\t} else {\t\t\t/* i == 2 -- uid */\n\t\t\t\t*((uid_t *) p) = t;\n\t\t\t}\n\t\t}\n\n\t\t*line++ = '\\0';\n\t\ti++;\n\t} /* while (1) */\n\n\treturn -1;\n}",
        "parsed_output": "long sub_40C9C5(long a1, const char *a2)\n{\n    char *endptr;\n    unsigned long value;\n    unsigned int *target;\n    int i;\n    char *next;\n\n    for (i = 0; i < 7; ++i) {\n        target = (unsigned int *)(a1 + (unsigned char)byte_5350A7[i]);\n        if (i >= 2 && i <= 3) {\n            value = strtoul(a2, &endptr, 10);\n            if (a2 == endptr || *endptr != ':')\n                return -1;\n            next = endptr;\n            *target = (unsigned int)value;\n            *next = '\\0';\n            a2 = next + 1;\n        }\n    }\n    *(const char **)target = a2;\n    if (i == 6)\n        return 0;\n    next = strchr(a2, ':');\n    if (next)\n        goto LABEL_11;\n    return -1;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40C9C5(__int64 a1, const char *a2)\n{\n  char *v3; // rax\n  char *sa; // [rsp+0h] [rbp-30h]\n  char *endptr; // [rsp+10h] [rbp-20h] BYREF\n  unsigned __int64 v7; // [rsp+18h] [rbp-18h]\n  _DWORD *v8; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  for ( i = 0; ; ++i )\n  {\n    v8 = (_DWORD *)((unsigned __int8)byte_5350A7[i] + a1);\n    if ( i <= 1 || i > 3 )\n      break;\n    v7 = strtoul(a2, &endptr, 10);\n    if ( a2 == endptr || *endptr != 58 )\n      return 0xFFFFFFFFLL;\n    sa = endptr;\n    *v8 = v7;\nLABEL_11:\n    v3 = sa;\n    a2 = sa + 1;\n    *v3 = 0;\n  }\n  *(_QWORD *)v8 = a2;\n  if ( i == 6 )\n    return 0LL;\n  sa = strchr(a2, 58);\n  if ( sa )\n    goto LABEL_11;\n  return 0xFFFFFFFFLL;\n}\n",
        "baseline_code_debug": "int __cdecl bb__parsepwent(void *data, char *line)\n{\n  char *v3; // rax\n  char *lineb; // [rsp+0h] [rbp-30h]\n  char *endptr; // [rsp+10h] [rbp-20h] BYREF\n  unsigned __int64 t; // [rsp+18h] [rbp-18h]\n  char *p; // [rsp+20h] [rbp-10h]\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  for ( i = 0; ; ++i )\n  {\n    p = (char *)data + pw_off[i];\n    if ( i <= 1 || i > 3 )\n      break;\n    t = strtoul(line, &endptr, 10);\n    if ( line == endptr || *endptr != 58 )\n      return -1;\n    lineb = endptr;\n    *(_DWORD *)p = t;\nLABEL_11:\n    v3 = lineb;\n    line = lineb + 1;\n    *v3 = 0;\n  }\n  *(_QWORD *)p = line;\n  if ( i == 6 )\n    return 0;\n  lineb = strchr(line, 58);\n  if ( lineb )\n    goto LABEL_11;\n  return -1;\n}\n",
        "similarity_score_unixcoder": 0.6938880681991577,
        "similarity_score_baseline_stripped": 0.633026123046875,
        "similarity_score_baseline_debug": 0.7289348244667053
    },
    {
        "func_name": "warn_geometry",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl type_str(unsigned __int64 value, void *arg)\n{\n  unsigned __int64 types; // [rsp+18h] [rbp-8h]\n\n  types = *(_QWORD *)arg;\n  if ( (*(_QWORD *)arg & 2) != 0 && !is_printable(value) )\n    types &= ~2uLL;\n  if ( (types & 0x10) != 0 && value > 0x7F )\n    types &= ~0x10uLL;\n  if ( (types & 4) != 0 && value > 0xFF )\n    types &= ~4uLL;\n  if ( (types & 0x800) != 0 && value > 0xFFFF )\n    types &= ~0x800uLL;\n  if ( !types )\n    return -1;\n  *(_QWORD *)arg = types;\n  return 1;\n}\n\n\n Revised code:\nstatic int type_str(unsigned long value, void *arg)\n{\n    unsigned long types;\n    types = *((unsigned long *)arg);\n    if ((types & B_ASN1_PRINTABLESTRING) && !is_printable(value))\n        types &= ~B_ASN1_PRINTABLESTRING;\n    if ((types & B_ASN1_IA5STRING) && (value > 127))\n        types &= ~B_ASN1_IA5STRING;\n    if ((types & B_ASN1_T61STRING) && (value > 0xff))\n        types &= ~B_ASN1_T61STRING;\n    if ((types & B_ASN1_BMPSTRING) && (value > 0xffff))\n        types &= ~B_ASN1_BMPSTRING;\n    if (!types)\n        return -1;\n    *((unsigned long *)arg) = types;\n    return 1;\n}\n\n## Example:\n\n Input code:\n__int64 __cdecl null_ctrl(BIO *b, int cmd, __int64 num, void *ptr)\n{\n  __int64 ret; // [rsp+28h] [rbp-8h]\n\n  switch ( cmd )\n  {\n    case 1:\n    case 2:\n    case 4:\n    case 9:\n    case 11:\n    case 12:\n      ret = 1LL;\n      break;\n    default:\n      ret = 0LL;\n      break;\n  }\n  return ret;\n}\n\n\n Revised code:\nstatic long null_ctrl(BIO *b, int cmd, long num, void *ptr)\n{\n    long ret = 1;\n\n    switch (cmd) {\n    case BIO_CTRL_RESET:\n    case BIO_CTRL_EOF:\n    case BIO_CTRL_SET:\n    case BIO_CTRL_SET_CLOSE:\n    case BIO_CTRL_FLUSH:\n    case BIO_CTRL_DUP:\n        ret = 1;\n        break;\n    case BIO_CTRL_GET_CLOSE:\n    case BIO_CTRL_INFO:\n    case BIO_CTRL_GET:\n    case BIO_CTRL_PENDING:\n    case BIO_CTRL_WPENDING:\n    default:\n        ret = 0;\n        break;\n    }\n    return (ret);\n}\n\n## Example:\n\n Input code:\nint __cdecl cpy_univ(unsigned __int64 value, void *arg)\n{\n  unsigned __int8 *q; // [rsp+10h] [rbp-10h]\n\n  q = (unsigned __int8 *)(*(_QWORD *)arg + 1LL);\n  **(_BYTE **)arg = BYTE3(value);\n  *q = BYTE2(value);\n  q[1] = BYTE1(value);\n  q[2] = value;\n  *(_QWORD *)arg += 4LL;\n  return 1;\n}\n\n\n Revised code:\nstatic int cpy_univ(unsigned long value, void *arg)\n{\n    unsigned char **p, *q;\n    p = arg;\n    q = *p;\n    *q++ = (unsigned char)((value >> 24) & 0xff);\n    *q++ = (unsigned char)((value >> 16) & 0xff);\n    *q++ = (unsigned char)((value >> 8) & 0xff);\n    *q = (unsigned char)(value & 0xff);\n    *p += 4;\n    return 1;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_4910F4()\n{\n  if ( *((_DWORD *)qword_75D408 + 9) && *((_DWORD *)qword_75D408 + 10) && *((_DWORD *)qword_75D408 + 11) )\n    return 0LL;\n  printf(\"Unknown value(s) for:\");\n  if ( !*((_DWORD *)qword_75D408 + 9) )\n    printf(\" heads\");\n  if ( !*((_DWORD *)qword_75D408 + 10) )\n    printf(\" sectors\");\n  if ( !*((_DWORD *)qword_75D408 + 11) )\n    printf(\" cylinders\");\n  puts(\" (settable in the extra functions menu)\");\n  return 1LL;\n}\n",
        "output": "```c\nstatic long check_disk_parameters()\n{\n    if (disk_parameters.heads && disk_parameters.sectors && disk_parameters.cylinders)\n        return 0;\n    printf(\"Unknown value(s) for:\");\n    if (!disk_parameters.heads)\n        printf(\" heads\");\n    if (!disk_parameters.sectors)\n        printf(\" sectors\");\n    if (!disk_parameters.cylinders)\n        printf(\" cylinders\");\n    puts(\" (settable in the extra functions menu)\");\n    return 1;\n}\n```",
        "source_code": "endif\n\nstatic int\nwarn_geometry(void)\n{\n\tif (g_heads && g_sectors && g_cylinders)\n\t\treturn 0;\n\n\tprintf(\"Unknown value(s) for:\");\n\tif (!g_heads)\n\t\tprintf(\" heads\");\n\tif (!g_sectors)\n\t\tprintf(\" sectors\");\n\tif (!g_cylinders)\n\t\tprintf(\" cylinders\");\n\tprintf(\n#if ENABLE_FEATURE_FDISK_WRITABLE\n\t\t\" (settable in the extra functions menu)\"\n#endif\n\t\t\"\\n\");\n\treturn 1;\n}",
        "parsed_output": "static long check_disk_parameters()\n{\n    if (disk_parameters.heads && disk_parameters.sectors && disk_parameters.cylinders)\n        return 0;\n    printf(\"Unknown value(s) for:\");\n    if (!disk_parameters.heads)\n        printf(\" heads\");\n    if (!disk_parameters.sectors)\n        printf(\" sectors\");\n    if (!disk_parameters.cylinders)\n        printf(\" cylinders\");\n    puts(\" (settable in the extra functions menu)\");\n    return 1;\n}",
        "baseline_code_stripped": "__int64 sub_4910F4()\n{\n  if ( *((_DWORD *)qword_75D408 + 9) && *((_DWORD *)qword_75D408 + 10) && *((_DWORD *)qword_75D408 + 11) )\n    return 0LL;\n  printf(\"Unknown value(s) for:\");\n  if ( !*((_DWORD *)qword_75D408 + 9) )\n    printf(\" heads\");\n  if ( !*((_DWORD *)qword_75D408 + 10) )\n    printf(\" sectors\");\n  if ( !*((_DWORD *)qword_75D408 + 11) )\n    printf(\" cylinders\");\n  puts(\" (settable in the extra functions menu)\");\n  return 1LL;\n}\n",
        "baseline_code_debug": "int __cdecl warn_geometry()\n{\n  if ( HIDWORD(ptr_to_globals->initstring) && LODWORD(ptr_to_globals->issue) && HIDWORD(ptr_to_globals->issue) )\n    return 0;\n  printf(\"Unknown value(s) for:\");\n  if ( !HIDWORD(ptr_to_globals->initstring) )\n    printf(\" heads\");\n  if ( !LODWORD(ptr_to_globals->issue) )\n    printf(\" sectors\");\n  if ( !HIDWORD(ptr_to_globals->issue) )\n    printf(\" cylinders\");\n  puts(\" (settable in the extra functions menu)\");\n  return 1;\n}\n",
        "similarity_score_unixcoder": 0.7820168733596802,
        "similarity_score_baseline_stripped": 0.6506518125534058,
        "similarity_score_baseline_debug": 0.7454807758331299
    }
]
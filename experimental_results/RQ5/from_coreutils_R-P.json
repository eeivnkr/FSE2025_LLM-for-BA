[
    {
        "func_name": "win_changed",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_occurs(const void *void_first, const void *void_second)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h]\n  int value; // [rsp+1Ch] [rbp-14h]\n\n  value = compare_words(void_first, void_second);\n  if ( value )\n    LODWORD(v3) = value;\n  else\n    return *(_QWORD *)void_first - *(_QWORD *)void_second;\n  return v3;\n}\n\n\n Revised code:\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return value == 0 ? first->key.start - second->key.start : value;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_5007B9(int a1)\n{\n  unsigned int v1; // [rsp+18h] [rbp-8h] BYREF\n  int v2; // [rsp+1Ch] [rbp-4h]\n\n  v2 = *(_DWORD *)qword_75D400;\n  sub_409E70(0, &v1, 0LL);\n  sub_500738(v1, a1);\n  *(_DWORD *)qword_75D400 = v2;\n}\n",
        "output": "```c\nstatic void\nsub_5007B9 (int a1)\n{\n  unsigned int saved_value;\n  int original_value;\n\n  original_value = *(_DWORD *)qword_75D400;\n  sub_409E70(0, &saved_value, 0LL);\n  sub_500738(saved_value, a1);\n  *(_DWORD *)qword_75D400 = original_value;\n}\n```",
        "source_code": "static void win_changed(int nsig)\n{\n\tint sv_errno = errno;\n\tunsigned width;\n\n\tget_terminal_width_height(0, &width, NULL);\n//FIXME: cmdedit_setwidth() -> redraw() -> printf() -> KABOOM! (we are in signal handler!)\n\tcmdedit_setwidth(width, /*redraw_flg:*/ nsig);\n\n\terrno = sv_errno;\n}",
        "parsed_output": "static void\nsub_5007B9 (int a1)\n{\n  unsigned int saved_value;\n  int original_value;\n\n  original_value = *(_DWORD *)qword_75D400;\n  sub_409E70(0, &saved_value, 0LL);\n  sub_500738(saved_value, a1);\n  *(_DWORD *)qword_75D400 = original_value;\n}",
        "baseline_code_stripped": "void __fastcall sub_5007B9(int a1)\n{\n  unsigned int v1; // [rsp+18h] [rbp-8h] BYREF\n  int v2; // [rsp+1Ch] [rbp-4h]\n\n  v2 = *(_DWORD *)qword_75D400;\n  sub_409E70(0, &v1, 0LL);\n  sub_500738(v1, a1);\n  *(_DWORD *)qword_75D400 = v2;\n}\n",
        "baseline_code_debug": "void __cdecl win_changed(int nsig)\n{\n  unsigned int width; // [rsp+18h] [rbp-8h] BYREF\n  int sv_errno; // [rsp+1Ch] [rbp-4h]\n\n  sv_errno = *bb_errno;\n  get_terminal_width_height(0, &width, 0LL);\n  cmdedit_setwidth(width, nsig);\n  *bb_errno = sv_errno;\n}\n",
        "similarity_score_unixcoder": 0.3898239731788635,
        "similarity_score_baseline_stripped": 0.4333323538303375,
        "similarity_score_baseline_debug": 0.8228780031204224
    },
    {
        "func_name": "resize_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl recover_mode(const char *arg, termios *mode)\n{\n  unsigned __int64 lflag; // [rsp+10h] [rbp-50h] BYREF\n  unsigned __int64 cflag; // [rsp+18h] [rbp-48h] BYREF\n  unsigned __int64 oflag; // [rsp+20h] [rbp-40h] BYREF\n  unsigned __int64 iflag; // [rsp+28h] [rbp-38h] BYREF\n  unsigned __int64 chr; // [rsp+30h] [rbp-30h] BYREF\n  int n; // [rsp+3Ch] [rbp-24h] BYREF\n  size_t i; // [rsp+40h] [rbp-20h]\n  termios *modea; // [rsp+48h] [rbp-18h]\n  const char *arga; // [rsp+50h] [rbp-10h]\n\n  arga = arg;\n  modea = mode;\n  if ( sscanf(arg, \"%lx:%lx:%lx:%lx%n\", &iflag, &oflag, &cflag, &lflag, &n) == 4 )\n  {\n    modea->c_iflag = iflag;\n    modea->c_oflag = oflag;\n    modea->c_cflag = cflag;\n    modea->c_lflag = lflag;\n    if ( modea->c_iflag == iflag && modea->c_oflag == oflag && modea->c_cflag == cflag && modea->c_lflag == lflag )\n    {\n      arga += n;\n      for ( i = 0LL; i < 0x20; ++i )\n      {\n        if ( sscanf(arga, \":%lx%n\", &chr, &n) != 1 )\n          return 0;\n        modea->c_cc[i] = chr;\n        if ( modea->c_cc[i] != chr )\n          return 0;\n        arga += n;\n      }\n      return *arga == 0;\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  else\n  {\n    return 0;\n  }\n}\n\n\n Revised code:\nstatic bool\nrecover_mode (char const *arg, struct termios *mode)\n{\n  size_t i;\n  int n;\n  unsigned long int chr;\n  unsigned long int iflag, oflag, cflag, lflag;\n\n  /* Scan into temporaries since it is too much trouble to figure out\n     the right format for `tcflag_t'.  */\n  if (sscanf (arg, \"%lx:%lx:%lx:%lx%n\",\n\t      &iflag, &oflag, &cflag, &lflag, &n) != 4)\n    return false;\n  mode->c_iflag = iflag;\n  mode->c_oflag = oflag;\n  mode->c_cflag = cflag;\n  mode->c_lflag = lflag;\n  if (mode->c_iflag != iflag\n      || mode->c_oflag != oflag\n      || mode->c_cflag != cflag\n      || mode->c_lflag != lflag)\n    return false;\n  arg += n;\n  for (i = 0; i < NCCS; ++i)\n    {\n      if (sscanf (arg, \":%lx%n\", &chr, &n) != 1)\n\treturn false;\n      mode->c_cc[i] = chr;\n      if (mode->c_cc[i] != chr)\n\treturn false;\n      arg += n;\n    }\n\n  /* Fail if there are too many fields.  */\n  if (*arg != '\\0')\n    return false;\n\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl sysv_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  int *v5; // rax\n  char *v6; // rax\n  size_t bytes_read; // [rsp+20h] [rbp-22E0h]\n  size_t i; // [rsp+28h] [rbp-22D8h]\n  _BYTE is_stdin[5]; // [rsp+33h] [rbp-22CDh]\n  char hbuf[652]; // [rsp+40h] [rbp-22C0h] BYREF\n  uintmax_t total_bytes; // [rsp+2D8h] [rbp-2028h]\n  unsigned __int8 buf[8192]; // [rsp+2E0h] [rbp-2020h] BYREF\n  int fd; // [rsp+22E8h] [rbp-18h]\n  int print_namea; // [rsp+22ECh] [rbp-14h]\n  const char *filea; // [rsp+22F0h] [rbp-10h]\n  char v17; // [rsp+22FFh] [rbp-1h]\n\n  filea = file;\n  print_namea = print_name;\n  total_bytes = 0LL;\n  is_stdin[4] = 0;\n  v2 = strcmp(file, \"-\");\n  *(_DWORD *)is_stdin = v2 == 0;\n  if ( !v2 )\n  {\n    fd = 0;\n    have_read_stdin = 1;\n    goto LABEL_5;\n  }\n  fd = open(filea, 0);\n  if ( fd == -1 )\n  {\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    v17 = 0;\n  }\n  else\n  {\nLABEL_5:\n    while ( 1 )\n    {\n      bytes_read = safe_read(fd, buf, 0x2000uLL);\n      if ( !bytes_read )\n        break;\n      if ( bytes_read == -1LL )\n      {\n        v4 = __errno_location();\n        error(0, *v4, \"%s\", filea);\n        if ( (is_stdin[0] & 1) == 0 )\n          close(fd);\n        v17 = 0;\n        return v17 & 1;\n      }\n      for ( i = 0LL; i < bytes_read; ++i )\n        *(_DWORD *)&is_stdin[1] += buf[i];\n      total_bytes += bytes_read;\n    }\n    if ( (is_stdin[0] & 1) != 0 || !close(fd) )\n    {\n      v6 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x200uLL);\n      printf(\n        \"%d %s\",\n        ((HIWORD(*(_DWORD *)&is_stdin[1]) + *(unsigned __int16 *)&is_stdin[1]) >> 16)\n      + (unsigned int)(unsigned __int16)(*(_WORD *)&is_stdin[3] + *(_WORD *)&is_stdin[1]),\n        v6);\n      if ( print_namea )\n        printf(\" %s\", filea);\n      putchar_unlocked(10);\n      v17 = 1;\n    }\n    else\n    {\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filea);\n      v17 = 0;\n    }\n  }\n  return v17 & 1;\n}\n\n\n Revised code:\nstatic bool\nsysv_sum_file (const char *file, int print_name)\n{\n  int fd;\n  unsigned char buf[8192];\n  uintmax_t total_bytes = 0;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int r;\n  int checksum;\n\n  /* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n  unsigned int s = 0;\n\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fd = STDIN_FILENO;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while (1)\n    {\n      size_t i;\n      size_t bytes_read = safe_read (fd, buf, sizeof buf);\n\n      if (bytes_read == 0)\n\tbreak;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  if (!is_stdin)\n\t    close (fd);\n\t  return false;\n\t}\n\n      for (i = 0; i < bytes_read; i++)\n\ts += buf[i];\n      total_bytes += bytes_read;\n    }\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  checksum = (r & 0xffff) + (r >> 16);\n\n  printf (\"%d %s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 512));\n  if (print_name)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl head_lines(const char *filename, int fd, uintmax_t lines_to_write)\n{\n  const char *v3; // rax\n  size_t v4; // rax\n  const char *v5; // rax\n  size_t v6; // rax\n  char *v7; // rax\n  int v9; // [rsp+Ch] [rbp-20F4h]\n  const char *v10; // [rsp+10h] [rbp-20F0h]\n  int v11; // [rsp+1Ch] [rbp-20E4h]\n  const char *format; // [rsp+20h] [rbp-20E0h]\n  int errnum; // [rsp+2Ch] [rbp-20D4h]\n  stat st; // [rsp+30h] [rbp-20D0h] BYREF\n  int e; // [rsp+C4h] [rbp-203Ch]\n  off_t n_bytes_past_EOL; // [rsp+C8h] [rbp-2038h]\n  size_t bytes_to_write; // [rsp+D0h] [rbp-2030h]\n  size_t bytes_read; // [rsp+D8h] [rbp-2028h]\n  char buffer[8192]; // [rsp+E0h] [rbp-2020h] BYREF\n  uintmax_t lines_to_writea; // [rsp+20E0h] [rbp-20h]\n  int fda; // [rsp+20ECh] [rbp-14h]\n  const char *filenamea; // [rsp+20F0h] [rbp-10h]\n\n  filenamea = filename;\n  fda = fd;\n  lines_to_writea = lines_to_write;\n  while ( lines_to_writea )\n  {\n    bytes_read = safe_read(fda, buffer, 0x2000uLL);\n    bytes_to_write = 0LL;\n    if ( bytes_read == -1LL )\n    {\n      errnum = *__errno_location();\n      format = gettext(\"error reading %s\");\n      v3 = quote(filenamea);\n      error(0, errnum, format, v3);\n      return 0;\n    }\n    if ( !bytes_read )\n      break;\n    while ( bytes_to_write < bytes_read )\n    {\n      v4 = bytes_to_write++;\n      if ( buffer[v4] == 10 && !--lines_to_writea )\n      {\n        n_bytes_past_EOL = bytes_read - bytes_to_write;\n        if ( lseek(fda, bytes_to_write - bytes_read, 1) < 0 )\n        {\n          e = *__errno_location();\n          if ( (unsigned int)fstat(fda, &st) || (st.st_mode & 0xF000) == 0x8000 )\n          {\n            v11 = e;\n            v10 = gettext(\"cannot reposition file pointer for %s\");\n            v5 = quote(filenamea);\n            error(0, v11, v10, v5);\n          }\n        }\n        break;\n      }\n    }\n    v6 = fwrite_unlocked(buffer, 1uLL, bytes_to_write, stdout);\n    if ( v6 < bytes_to_write )\n    {\n      v9 = *__errno_location();\n      v7 = gettext(\"write error\");\n      error(1, v9, v7);\n    }\n  }\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nhead_lines (const char *filename, int fd, uintmax_t lines_to_write)\n{\n  char buffer[BUFSIZ];\n\n  while (lines_to_write)\n    {\n      size_t bytes_read = safe_read (fd, buffer, BUFSIZ);\n      size_t bytes_to_write = 0;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, _(\"error reading %s\"), quote (filename));\n\t  return false;\n\t}\n      if (bytes_read == 0)\n\tbreak;\n      while (bytes_to_write < bytes_read)\n\tif (buffer[bytes_to_write++] == '\\n' && --lines_to_write == 0)\n\t  {\n\t    off_t n_bytes_past_EOL = bytes_read - bytes_to_write;\n\t    /* If we have read more data than that on the specified number\n\t       of lines, try to seek back to the position we would have\n\t       gotten to had we been reading one byte at a time.  */\n\t    if (lseek (fd, -n_bytes_past_EOL, SEEK_CUR) < 0)\n\t      {\n\t\tint e = errno;\n\t\tstruct stat st;\n\t\tif (fstat (fd, &st) != 0 || S_ISREG (st.st_mode))\n\t\t  error (0, e, _(\"cannot reposition file pointer for %s\"),\n\t\t\t quote (filename));\n\t      }\n\t    break;\n\t  }\n      if (fwrite (buffer, 1, bytes_to_write, stdout) < bytes_to_write)\n\terror (EXIT_FAILURE, errno, _(\"write error\"));\n    }\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_4C46BB()\n{\n  unsigned __int16 v1; // [rsp+18h] [rbp-48h] BYREF\n  unsigned __int16 v2; // [rsp+1Ah] [rbp-46h] BYREF\n  __int16 v3; // [rsp+1Ch] [rbp-44h]\n  __int16 v4; // [rsp+1Eh] [rbp-42h]\n  struct termios termios_p; // [rsp+20h] [rbp-40h] BYREF\n  unsigned int v6; // [rsp+5Ch] [rbp-4h]\n\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  tcgetattr(2, &dest);\n  *(_QWORD *)&termios_p.c_iflag = *(_QWORD *)&dest.c_iflag;\n  *(_QWORD *)&termios_p.c_line = *(_QWORD *)&dest.c_line;\n  *(_QWORD *)&termios_p.c_cc[7] = *(_QWORD *)&dest.c_cc[7];\n  *(_QWORD *)&termios_p.c_cc[15] = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&termios_p.c_cc[23] = *(_QWORD *)&dest.c_cc[23];\n  *(_QWORD *)&termios_p.c_cc[31] = *(_QWORD *)&dest.c_cc[31];\n  termios_p.c_ospeed = dest.c_ospeed;\n  termios_p.c_cflag = dest.c_cflag | 0x880;\n  termios_p.c_lflag = dest.c_lflag & 0xFFFFFFE4;\n  sub_508201(49164LL, sub_4C4692);\n  tcsetattr(2, 0, &termios_p);\n  fwrite(\"\\x1B7\\x1B[r\\x1B[999;999H\\x1B[6n\", 1uLL, 0x13uLL, stderr);\n  alarm(3u);\n  scanf(\"\\x1B[%hu;%huR\", &v1, &v2);\n  fwrite(\"\\x1B8\", 1uLL, 2uLL, stderr);\n  v6 = ioctl(2, 0x5414uLL, &v1);\n  tcsetattr(2, 0, &dest);\n  printf(\"COLUMNS=%d;LINES=%d;export COLUMNS LINES;\\n\", v2, v1);\n  return v6;\n}\n",
        "output": "```c\n#include <termios.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n\nstatic void setup_terminal(struct termios *original_settings)\n{\n  struct termios new_settings;\n\n  // Get the current terminal settings\n  tcgetattr(STDERR_FILENO, original_settings);\n\n  // Copy the original settings to new settings\n  new_settings = *original_settings;\n\n  // Modify the new settings\n  new_settings.c_cflag |= 0x880; // Set specific control flags\n  new_settings.c_lflag &= 0xFFFFFFE4; // Clear specific local flags\n\n  // Apply the new settings to the terminal\n  tcsetattr(STDERR_FILENO, TCSANOW, &new_settings);\n}\n\nstatic void restore_terminal(struct termios *original_settings)\n{\n  // Restore the original terminal settings\n  tcsetattr(STDERR_FILENO, TCSANOW, original_settings);\n}\n\nstatic void get_terminal_size(unsigned short *rows, unsigned short *cols)\n{\n  // Write escape sequence to terminal to get cursor position\n  fwrite(\"\\x1B7\\x1B[r\\x1B[999;999H\\x1B[6n\", 1, 0x13, stderr);\n\n  // Set an alarm to avoid blocking indefinitely\n  alarm(3);\n\n  // Read the cursor position response\n  scanf(\"\\x1B[%hu;%huR\", rows, cols);\n\n  // Restore the cursor position\n  fwrite(\"\\x1B8\", 1, 2, stderr);\n}\n\nstatic void print_terminal_size(unsigned short rows, unsigned short cols)\n{\n  // Print the terminal size in a format that can be evaluated by a shell\n  printf(\"COLUMNS=%d;LINES=%d;export COLUMNS LINES;\\n\", cols, rows);\n}\n\nint main()\n{\n  struct termios original_settings;\n  unsigned short rows, cols;\n  int ioctl_result;\n\n  // Setup the terminal\n  setup_terminal(&original_settings);\n\n  // Get the terminal size\n  get_terminal_size(&rows, &cols);\n\n  // Restore the terminal to its original settings\n  restore_terminal(&original_settings);\n\n  // Get the window size using ioctl\n  ioctl_result = ioctl(STDERR_FILENO, TIOCGWINSZ, &rows);\n\n  // Print the terminal size\n  print_terminal_size(rows, cols);\n\n  return ioctl_result;\n}\n```",
        "source_code": "int resize_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tstruct termios new;\n\tstruct winsize w = { 0, 0, 0, 0 };\n\tint ret;\n\n\t/* We use _stderr_ in order to make resize usable\n\t * in shell backticks (those redirect stdout away from tty).\n\t * NB: other versions of resize open \"/dev/tty\"\n\t * and operate on it - should we do the same?\n\t */\n\n\ttcgetattr(STDERR_FILENO, old_termios_p); /* fiddle echo */\n\tmemcpy(&new, old_termios_p, sizeof(new));\n\tnew.c_cflag |= (CLOCAL | CREAD);\n\tnew.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);\n\tbb_signals(0\n\t\t+ (1 << SIGINT)\n\t\t+ (1 << SIGQUIT)\n\t\t+ (1 << SIGTERM)\n\t\t+ (1 << SIGALRM)\n\t\t, onintr);\n\ttcsetattr(STDERR_FILENO, TCSANOW, &new);\n\n\t/* save_cursor_pos 7\n\t * scroll_whole_screen [r\n\t * put_cursor_waaaay_off [$x;$yH\n\t * get_cursor_pos [6n\n\t * restore_cursor_pos 8\n\t */\n\tfprintf(stderr, ESC\"7\" ESC\"[r\" ESC\"[999;999H\" ESC\"[6n\");\n\talarm(3); /* Just in case terminal won't answer */\n//BUG: death by signal won't restore termios\n\tscanf(ESC\"[%hu;%huR\", &w.ws_row, &w.ws_col);\n\tfprintf(stderr, ESC\"8\");\n\n\t/* BTW, other versions of resize recalculate w.ws_xpixel, ws.ws_ypixel\n\t * by calculating character cell HxW from old values\n\t * (gotten via TIOCGWINSZ) and recomputing *pixel values */\n\tret = ioctl(STDERR_FILENO, TIOCSWINSZ, &w);\n\n\ttcsetattr(STDERR_FILENO, TCSANOW, old_termios_p);\n\n\tif (ENABLE_FEATURE_RESIZE_PRINT)\n\t\tprintf(\"COLUMNS=%d;LINES=%d;export COLUMNS LINES;\\n\",\n\t\t\tw.ws_col, w.ws_row);\n\n\treturn ret;\n}",
        "parsed_output": "#include <termios.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/ioctl.h>\n\nstatic void setup_terminal(struct termios *original_settings)\n{\n  struct termios new_settings;\n\n  // Get the current terminal settings\n  tcgetattr(STDERR_FILENO, original_settings);\n\n  // Copy the original settings to new settings\n  new_settings = *original_settings;\n\n  // Modify the new settings\n  new_settings.c_cflag |= 0x880; // Set specific control flags\n  new_settings.c_lflag &= 0xFFFFFFE4; // Clear specific local flags\n\n  // Apply the new settings to the terminal\n  tcsetattr(STDERR_FILENO, TCSANOW, &new_settings);\n}\n\nstatic void restore_terminal(struct termios *original_settings)\n{\n  // Restore the original terminal settings\n  tcsetattr(STDERR_FILENO, TCSANOW, original_settings);\n}\n\nstatic void get_terminal_size(unsigned short *rows, unsigned short *cols)\n{\n  // Write escape sequence to terminal to get cursor position\n  fwrite(\"\\x1B7\\x1B[r\\x1B[999;999H\\x1B[6n\", 1, 0x13, stderr);\n\n  // Set an alarm to avoid blocking indefinitely\n  alarm(3);\n\n  // Read the cursor position response\n  scanf(\"\\x1B[%hu;%huR\", rows, cols);\n\n  // Restore the cursor position\n  fwrite(\"\\x1B8\", 1, 2, stderr);\n}\n\nstatic void print_terminal_size(unsigned short rows, unsigned short cols)\n{\n  // Print the terminal size in a format that can be evaluated by a shell\n  printf(\"COLUMNS=%d;LINES=%d;export COLUMNS LINES;\\n\", cols, rows);\n}\n\nint main()\n{\n  struct termios original_settings;\n  unsigned short rows, cols;\n  int ioctl_result;\n\n  // Setup the terminal\n  setup_terminal(&original_settings);\n\n  // Get the terminal size\n  get_terminal_size(&rows, &cols);\n\n  // Restore the terminal to its original settings\n  restore_terminal(&original_settings);\n\n  // Get the window size using ioctl\n  ioctl_result = ioctl(STDERR_FILENO, TIOCGWINSZ, &rows);\n\n  // Print the terminal size\n  print_terminal_size(rows, cols);\n\n  return ioctl_result;\n}",
        "baseline_code_stripped": "__int64 sub_4C46BB()\n{\n  unsigned __int16 v1; // [rsp+18h] [rbp-48h] BYREF\n  unsigned __int16 v2; // [rsp+1Ah] [rbp-46h] BYREF\n  __int16 v3; // [rsp+1Ch] [rbp-44h]\n  __int16 v4; // [rsp+1Eh] [rbp-42h]\n  struct termios termios_p; // [rsp+20h] [rbp-40h] BYREF\n  unsigned int v6; // [rsp+5Ch] [rbp-4h]\n\n  v1 = 0;\n  v2 = 0;\n  v3 = 0;\n  v4 = 0;\n  tcgetattr(2, &dest);\n  *(_QWORD *)&termios_p.c_iflag = *(_QWORD *)&dest.c_iflag;\n  *(_QWORD *)&termios_p.c_line = *(_QWORD *)&dest.c_line;\n  *(_QWORD *)&termios_p.c_cc[7] = *(_QWORD *)&dest.c_cc[7];\n  *(_QWORD *)&termios_p.c_cc[15] = *(_QWORD *)&dest.c_cc[15];\n  *(_QWORD *)&termios_p.c_cc[23] = *(_QWORD *)&dest.c_cc[23];\n  *(_QWORD *)&termios_p.c_cc[31] = *(_QWORD *)&dest.c_cc[31];\n  termios_p.c_ospeed = dest.c_ospeed;\n  termios_p.c_cflag = dest.c_cflag | 0x880;\n  termios_p.c_lflag = dest.c_lflag & 0xFFFFFFE4;\n  sub_508201(49164LL, sub_4C4692);\n  tcsetattr(2, 0, &termios_p);\n  fwrite(\"\\x1B7\\x1B[r\\x1B[999;999H\\x1B[6n\", 1uLL, 0x13uLL, stderr);\n  alarm(3u);\n  scanf(\"\\x1B[%hu;%huR\", &v1, &v2);\n  fwrite(\"\\x1B8\", 1uLL, 2uLL, stderr);\n  v6 = ioctl(2, 0x5414uLL, &v1);\n  tcsetattr(2, 0, &dest);\n  printf(\"COLUMNS=%d;LINES=%d;export COLUMNS LINES;\\n\", v2, v1);\n  return v6;\n}\n",
        "baseline_code_debug": "int __cdecl resize_main(int argc, char **argv)\n{\n  winsize w; // [rsp+18h] [rbp-48h] BYREF\n  termios newa; // [rsp+20h] [rbp-40h] BYREF\n  int ret; // [rsp+5Ch] [rbp-4h]\n\n  w.ws_row = 0;\n  w.ws_col = 0;\n  w.ws_xpixel = 0;\n  w.ws_ypixel = 0;\n  tcgetattr(2, &bb_common_bufsiz1);\n  *(_QWORD *)&newa.c_iflag = *(_QWORD *)&bb_common_bufsiz1.c_iflag;\n  *(_QWORD *)&newa.c_line = *(_QWORD *)&bb_common_bufsiz1.c_line;\n  *(_QWORD *)&newa.c_cc[7] = *(_QWORD *)&bb_common_bufsiz1.c_cc[7];\n  *(_QWORD *)&newa.c_cc[15] = *(_QWORD *)&bb_common_bufsiz1.c_cc[15];\n  *(inet_prefix *)&newa.c_cc[23] = *(inet_prefix *)&bb_common_bufsiz1.c_cc[23];\n  newa.c_cflag = bb_common_bufsiz1.c_cflag | 0x880;\n  newa.c_lflag = bb_common_bufsiz1.c_lflag & 0xFFFFFFE4;\n  bb_signals(49164, (void (*)(int))onintr);\n  tcsetattr(2, 0, &newa);\n  fwrite(\"\\x1B7\\x1B[r\\x1B[999;999H\\x1B[6n\", 1uLL, 0x13uLL, stderr);\n  alarm(3u);\n  scanf(\"\\x1B[%hu;%huR\", &w, &w.ws_col);\n  fwrite(\"\\x1B8\", 1uLL, 2uLL, stderr);\n  ret = ioctl(2, 0x5414uLL, &w);\n  tcsetattr(2, 0, &bb_common_bufsiz1);\n  printf(\"COLUMNS=%d;LINES=%d;export COLUMNS LINES;\\n\", w.ws_col, w.ws_row);\n  return ret;\n}\n",
        "similarity_score_unixcoder": 0.8574590682983398,
        "similarity_score_baseline_stripped": 0.6940641403198242,
        "similarity_score_baseline_debug": 0.801334023475647
    },
    {
        "func_name": "x_list_table",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  unsigned __int8 *v3; // rax\n  const char *v4; // rdi\n  char buf[5]; // [rsp+33h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+38h] [rbp-38h]\n  unsigned __int8 c; // [rsp+47h] [rbp-29h]\n  size_t i; // [rsp+48h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+50h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+58h] [rbp-18h]\n  const void *blocka; // [rsp+60h] [rbp-10h]\n  size_t n_bytesa; // [rsp+68h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = (unsigned __int8 *)p++;\n    c = *v3;\n    switch ( c )\n    {\n      case 0u:\n        s = \" \\\\0\";\n        break;\n      case 7u:\n        s = (const char *)&unk_409AA8;\n        break;\n      case 8u:\n        s = (const char *)&unk_409AAC;\n        break;\n      case 9u:\n        s = (const char *)&unk_409ABC;\n        break;\n      case 0xAu:\n        s = (const char *)&unk_409AB4;\n        break;\n      case 0xBu:\n        s = (const char *)&unk_409AC0;\n        break;\n      case 0xCu:\n        s = (const char *)&unk_409AB0;\n        break;\n      case 0xDu:\n        s = (const char *)&unk_409AB8;\n        break;\n      default:\n        v4 = \"%03o\";\n        if ( ((*__ctype_b_loc())[c] & 0x4000) != 0 )\n          v4 = \"  %c\";\n        sprintf(buf, v4, c);\n        s = buf;\n        break;\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_ascii (size_t n_bytes, void const *block,\n\t     const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      unsigned char c = *p++;\n      const char *s;\n      char buf[5];\n\n      switch (c)\n\t{\n\tcase '\\0':\n\t  s = \" \\\\0\";\n\t  break;\n\n\tcase '\\a':\n\t  s = \" \\\\a\";\n\t  break;\n\n\tcase '\\b':\n\t  s = \" \\\\b\";\n\t  break;\n\n\tcase '\\f':\n\t  s = \" \\\\f\";\n\t  break;\n\n\tcase '\\n':\n\t  s = \" \\\\n\";\n\t  break;\n\n\tcase '\\r':\n\t  s = \" \\\\r\";\n\t  break;\n\n\tcase '\\t':\n\t  s = \" \\\\t\";\n\t  break;\n\n\tcase '\\v':\n\t  s = \" \\\\v\";\n\t  break;\n\n\tdefault:\n\t  sprintf (buf, (isprint (c) ? \"  %c\" : \"%03o\"), c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  char *v5; // rax\n  unsigned int v7; // [rsp+14h] [rbp-2CCh]\n  bool is_stdin; // [rsp+1Fh] [rbp-2C1h]\n  char hbuf[652]; // [rsp+20h] [rbp-2C0h] BYREF\n  int ch_0; // [rsp+2ACh] [rbp-34h]\n  uintmax_t total_bytes; // [rsp+2B0h] [rbp-30h]\n  int checksum; // [rsp+2BCh] [rbp-24h]\n  FILE *fp; // [rsp+2C0h] [rbp-20h]\n  int print_namea; // [rsp+2CCh] [rbp-14h]\n  const char *filea; // [rsp+2D0h] [rbp-10h]\n\n  filea = file;\n  print_namea = print_name;\n  checksum = 0;\n  total_bytes = 0LL;\n  v2 = strcmp(file, \"-\");\n  is_stdin = v2 == 0;\n  if ( v2 )\n  {\n    fp = fopen(filea, \"r\");\n    if ( !fp )\n      goto LABEL_4;\n  }\n  else\n  {\n    fp = stdin;\n    have_read_stdin = 1;\n  }\n  while ( 1 )\n  {\n    ch_0 = getc_unlocked(fp);\n    if ( ch_0 == -1 )\n      break;\n    ++total_bytes;\n    checksum = (unsigned __int16)(((checksum & 1) << 15) + (checksum >> 1) + ch_0);\n  }\n  if ( ferror_unlocked(fp) )\n  {\n    v4 = __errno_location();\n    error(0, *v4, \"%s\", filea);\n    if ( !is_stdin )\n      fclose(fp);\n    return 0;\n  }\n  if ( !is_stdin && fclose(fp) )\n  {\nLABEL_4:\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    return 0;\n  }\n  v7 = checksum;\n  v5 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x400uLL);\n  printf(\"%05d %5s\", v7, v5);\n  if ( print_namea > 1 )\n    printf(\" %s\", filea);\n  putchar_unlocked(10);\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_sum_file (const char *file, int print_name)\n{\n  FILE *fp;\n  int checksum = 0;\t/* The checksum mod 2^16. */\n  uintmax_t total_bytes = 0;\t/* The number of bytes. */\n  int ch;\t\t/* Each character read. */\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fp = stdin;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fp = fopen (file, (O_BINARY ? \"rb\" : \"r\"));\n      if (fp == NULL)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while ((ch = getc (fp)) != EOF)\n    {\n      total_bytes++;\n      checksum = (checksum >> 1) + ((checksum & 1) << 15);\n      checksum += ch;\n      checksum &= 0xffff;\t/* Keep it within bounds. */\n    }\n\n  if (ferror (fp))\n    {\n      error (0, errno, \"%s\", file);\n      if (!is_stdin)\n\tfclose (fp);\n      return false;\n    }\n\n  if (!is_stdin && fclose (fp) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  printf (\"%05d %5s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 1024));\n  if (print_name > 1)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_49374D(int a1)\n{\n  __int64 v1; // rax\n  __int64 v2; // rbx\n  __int64 v3; // r12\n  unsigned int v4; // eax\n  __int64 result; // rax\n  unsigned __int8 *v6; // [rsp+18h] [rbp-28h]\n  int i; // [rsp+2Ch] [rbp-14h]\n\n  printf(\n    \"\\nDisk %s: %u heads, %u sectors, %u cylinders\\n\\n\",\n    *((const char **)qword_75D408 + 1),\n    *((unsigned int *)qword_75D408 + 9),\n    *((unsigned int *)qword_75D408 + 10),\n    *((unsigned int *)qword_75D408 + 11));\n  puts(\"Nr AF  Hd Sec  Cyl  Hd Sec  Cyl      Start       Size ID\");\n  for ( i = 0; ; ++i )\n  {\n    result = *((unsigned int *)qword_75D408 + 4);\n    if ( i >= (int)result )\n      break;\n    if ( a1 )\n      v1 = *((_QWORD *)qword_75D408 + 5 * i + 314);\n    else\n      v1 = *((_QWORD *)qword_75D408 + 5 * i + 313);\n    v6 = (unsigned __int8 *)v1;\n    if ( v1 )\n    {\n      v2 = *(unsigned __int8 *)(v1 + 4);\n      v3 = (unsigned int)sub_4908E3(v1);\n      v4 = sub_4908C5((__int64)v6);\n      printf(\n        \"%2u %02x%4u%4u%5u%4u%4u%5u%11u%11u %02x\\n\",\n        (unsigned int)(i + 1),\n        *v6,\n        v6[1],\n        v6[2] & 0x3F,\n        (4 * v6[2]) & 0x300 | (unsigned int)v6[3],\n        v6[5],\n        v6[6] & 0x3F,\n        (4 * v6[6]) & 0x300 | (unsigned int)v6[7],\n        v4,\n        v3,\n        v2);\n      if ( v6[4] )\n        sub_4929DD(v6, i);\n    }\n  }\n  return result;\n}\n",
        "output": "```c\nstatic void\nprint_partition_table (int option)\n{\n  unsigned int heads, sectors, cylinders, num_entries, i;\n  unsigned __int8 *entry;\n  unsigned int start_sector, size_sector, partition_id;\n  __int64 partition_info;\n\n  // Assuming qword_75D408 points to a structure with disk information\n  heads = *((unsigned int *)qword_75D408 + 9);\n  sectors = *((unsigned int *)qword_75D408 + 10);\n  cylinders = *((unsigned int *)qword_75D408 + 11);\n  printf(\"\\nDisk %s: %u heads, %u sectors, %u cylinders\\n\\n\",\n         *((const char **)qword_75D408 + 1), heads, sectors, cylinders);\n\n  puts(\"Nr AF  Hd Sec  Cyl  Hd Sec  Cyl      Start       Size ID\");\n\n  num_entries = *((unsigned int *)qword_75D408 + 4);\n  for (i = 0; i < num_entries; ++i)\n  {\n    partition_info = option ? *((_QWORD *)qword_75D408 + 5 * i + 314)\n                            : *((_QWORD *)qword_75D408 + 5 * i + 313);\n    entry = (unsigned __int8 *)partition_info;\n\n    if (entry)\n    {\n      partition_id = entry[4];\n      size_sector = (unsigned int)get_partition_size(entry);\n      start_sector = get_partition_start(entry);\n      printf(\"%2u %02x%4u%4u%5u%4u%4u%5u%11u%11u %02x\\n\",\n             i + 1,\n             entry[0],\n             entry[1],\n             entry[2] & 0x3F,\n             ((entry[2] & 0xC0) << 2) | entry[3],\n             entry[5],\n             entry[6] & 0x3F,\n             ((entry[6] & 0xC0) << 2) | entry[7],\n             start_sector,\n             size_sector,\n             partition_id);\n\n      if (partition_id)\n        display_partition_type(entry, i);\n    }\n  }\n}\n```",
        "source_code": "if ENABLE_FEATURE_FDISK_ADVANCED\nstatic void\nx_list_table(int extend)\n{\n\tconst struct pte *pe;\n\tconst struct partition *p;\n\tint i;\n\n\tprintf(\"\\nDisk %s: %u heads, %u sectors, %u cylinders\\n\\n\",\n\t\tdisk_device, g_heads, g_sectors, g_cylinders);\n\tprintf(\"Nr AF  Hd Sec  Cyl  Hd Sec  Cyl      Start       Size ID\\n\");\n\tfor (i = 0; i < g_partitions; i++) {\n\t\tpe = &ptes[i];\n\t\tp = (extend ? pe->ext_pointer : pe->part_table);\n\t\tif (p != NULL) {\n\t\t\tprintf(\"%2u %02x%4u%4u%5u%4u%4u%5u%11\"SECT_FMT\"u%11\"SECT_FMT\"u %02x\\n\",\n\t\t\t\ti + 1, p->boot_ind, p->head,\n\t\t\t\tsector(p->sector),\n\t\t\t\tcylinder(p->sector, p->cyl), p->end_head,\n\t\t\t\tsector(p->end_sector),\n\t\t\t\tcylinder(p->end_sector, p->end_cyl),\n\t\t\t\tget_start_sect(p), get_nr_sects(p),\n\t\t\t\tp->sys_ind);\n\t\t\tif (p->sys_ind)\n\t\t\t\tcheck_consistency(p, i);\n\t\t}\n\t}\n}",
        "parsed_output": "static void\nprint_partition_table (int option)\n{\n  unsigned int heads, sectors, cylinders, num_entries, i;\n  unsigned __int8 *entry;\n  unsigned int start_sector, size_sector, partition_id;\n  __int64 partition_info;\n\n  // Assuming qword_75D408 points to a structure with disk information\n  heads = *((unsigned int *)qword_75D408 + 9);\n  sectors = *((unsigned int *)qword_75D408 + 10);\n  cylinders = *((unsigned int *)qword_75D408 + 11);\n  printf(\"\\nDisk %s: %u heads, %u sectors, %u cylinders\\n\\n\",\n         *((const char **)qword_75D408 + 1), heads, sectors, cylinders);\n\n  puts(\"Nr AF  Hd Sec  Cyl  Hd Sec  Cyl      Start       Size ID\");\n\n  num_entries = *((unsigned int *)qword_75D408 + 4);\n  for (i = 0; i < num_entries; ++i)\n  {\n    partition_info = option ? *((_QWORD *)qword_75D408 + 5 * i + 314)\n                            : *((_QWORD *)qword_75D408 + 5 * i + 313);\n    entry = (unsigned __int8 *)partition_info;\n\n    if (entry)\n    {\n      partition_id = entry[4];\n      size_sector = (unsigned int)get_partition_size(entry);\n      start_sector = get_partition_start(entry);\n      printf(\"%2u %02x%4u%4u%5u%4u%4u%5u%11u%11u %02x\\n\",\n             i + 1,\n             entry[0],\n             entry[1],\n             entry[2] & 0x3F,\n             ((entry[2] & 0xC0) << 2) | entry[3],\n             entry[5],\n             entry[6] & 0x3F,\n             ((entry[6] & 0xC0) << 2) | entry[7],\n             start_sector,\n             size_sector,\n             partition_id);\n\n      if (partition_id)\n        display_partition_type(entry, i);\n    }\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_49374D(int a1)\n{\n  __int64 v1; // rax\n  __int64 v2; // rbx\n  __int64 v3; // r12\n  unsigned int v4; // eax\n  __int64 result; // rax\n  unsigned __int8 *v6; // [rsp+18h] [rbp-28h]\n  int i; // [rsp+2Ch] [rbp-14h]\n\n  printf(\n    \"\\nDisk %s: %u heads, %u sectors, %u cylinders\\n\\n\",\n    *((const char **)qword_75D408 + 1),\n    *((unsigned int *)qword_75D408 + 9),\n    *((unsigned int *)qword_75D408 + 10),\n    *((unsigned int *)qword_75D408 + 11));\n  puts(\"Nr AF  Hd Sec  Cyl  Hd Sec  Cyl      Start       Size ID\");\n  for ( i = 0; ; ++i )\n  {\n    result = *((unsigned int *)qword_75D408 + 4);\n    if ( i >= (int)result )\n      break;\n    if ( a1 )\n      v1 = *((_QWORD *)qword_75D408 + 5 * i + 314);\n    else\n      v1 = *((_QWORD *)qword_75D408 + 5 * i + 313);\n    v6 = (unsigned __int8 *)v1;\n    if ( v1 )\n    {\n      v2 = *(unsigned __int8 *)(v1 + 4);\n      v3 = (unsigned int)sub_4908E3(v1);\n      v4 = sub_4908C5((__int64)v6);\n      printf(\n        \"%2u %02x%4u%4u%5u%4u%4u%5u%11u%11u %02x\\n\",\n        (unsigned int)(i + 1),\n        *v6,\n        v6[1],\n        v6[2] & 0x3F,\n        (4 * v6[2]) & 0x300 | (unsigned int)v6[3],\n        v6[5],\n        v6[6] & 0x3F,\n        (4 * v6[6]) & 0x300 | (unsigned int)v6[7],\n        v4,\n        v3,\n        v2);\n      if ( v6[4] )\n        sub_4929DD(v6, i);\n    }\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl x_list_table(int extend)\n{\n  const partition *v1; // rax\n  __int64 sys_ind; // rbx\n  __int64 nr_sects; // r12\n  sector_t start_sect; // eax\n  const partition *p; // [rsp+18h] [rbp-28h]\n  int i; // [rsp+2Ch] [rbp-14h]\n\n  printf(\n    \"\\nDisk %s: %u heads, %u sectors, %u cylinders\\n\\n\",\n    ptr_to_globals->login,\n    HIDWORD(ptr_to_globals->initstring),\n    LODWORD(ptr_to_globals->issue),\n    HIDWORD(ptr_to_globals->issue));\n  puts(\"Nr AF  Hd Sec  Cyl  Hd Sec  Cyl      Start       Size ID\");\n  for ( i = 0; i < SLODWORD(ptr_to_globals->fakehost); ++i )\n  {\n    if ( extend )\n      v1 = *(const partition **)&ptr_to_globals[8].line_buf[40 * i + 52];\n    else\n      v1 = *(const partition **)&ptr_to_globals[8].line_buf[40 * i + 44];\n    p = v1;\n    if ( v1 )\n    {\n      sys_ind = v1->sys_ind;\n      nr_sects = get_nr_sects(v1);\n      start_sect = get_start_sect(p);\n      printf(\n        \"%2u %02x%4u%4u%5u%4u%4u%5u%11u%11u %02x\\n\",\n        (unsigned int)(i + 1),\n        p->boot_ind,\n        p->head,\n        p->sector & 0x3F,\n        (4 * p->sector) & 0x300 | (unsigned int)p->cyl,\n        p->end_head,\n        p->end_sector & 0x3F,\n        (4 * p->end_sector) & 0x300 | (unsigned int)p->end_cyl,\n        start_sect,\n        nr_sects,\n        sys_ind);\n      if ( p->sys_ind )\n        check_consistency(p, i);\n    }\n  }\n}\n",
        "similarity_score_unixcoder": 0.7629662752151489,
        "similarity_score_baseline_stripped": 0.6203235387802124,
        "similarity_score_baseline_debug": 0.8221296668052673
    },
    {
        "func_name": "place_cursor",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl hextobin(unsigned __int8 c)\n{\n  int v2; // [rsp+10h] [rbp-4h]\n\n  switch ( c )\n  {\n    case 'A':\n    case 'a':\n      v2 = 10;\n      break;\n    case 'B':\n    case 'b':\n      v2 = 11;\n      break;\n    case 'C':\n    case 'c':\n      v2 = 12;\n      break;\n    case 'D':\n    case 'd':\n      v2 = 13;\n      break;\n    case 'E':\n    case 'e':\n      v2 = 14;\n      break;\n    case 'F':\n    case 'f':\n      v2 = 15;\n      break;\n    default:\n      v2 = c - 48;\n      break;\n  }\n  return v2;\n}\n\n\n Revised code:\nstatic int\nhextobin (unsigned char c)\n{\n  switch (c)\n    {\n    default: return c - '0';\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    }\n}\n\n## Example:\n\n Input code:\nvoid __cdecl format_address_std(uintmax_t address, char c)\n{\n  char *v2; // rax\n  char *v3; // rcx\n  char *v4; // rax\n  char *v5; // rax\n  const char *pbound; // [rsp+20h] [rbp-40h]\n  char *p; // [rsp+28h] [rbp-38h]\n  char buf[25]; // [rsp+30h] [rbp-30h] BYREF\n  char ca; // [rsp+57h] [rbp-9h]\n  uintmax_t addressa; // [rsp+58h] [rbp-8h]\n\n  addressa = address;\n  ca = c;\n  buf[24] = 0;\n  p = &buf[23];\n  buf[23] = c;\n  pbound = &buf[-address_pad_len + 23];\n  switch ( address_base )\n  {\n    case 8:\n      do\n      {\n        v2 = p--;\n        *(v2 - 1) = (addressa & 7) + 48;\n        addressa >>= 3;\n      }\n      while ( addressa );\n      break;\n    case 10:\n      do\n      {\n        v3 = p--;\n        *(v3 - 1) = addressa % 0xA + 48;\n        addressa /= 0xAuLL;\n      }\n      while ( addressa );\n      break;\n    case 16:\n      do\n      {\n        v4 = p--;\n        *(v4 - 1) = byte_4097D0[addressa & 0xF];\n        addressa >>= 4;\n      }\n      while ( addressa );\n      break;\n  }\n  while ( pbound < p )\n  {\n    v5 = p--;\n    *(v5 - 1) = 48;\n  }\n  fputs_unlocked(p, _bss_start);\n}\n\n\n Revised code:\nstatic void\nformat_address_std (uintmax_t address, char c)\n{\n  char buf[MAX_ADDRESS_LENGTH + 2];\n  char *p = buf + sizeof buf;\n  char const *pbound;\n\n  *--p = '\\0';\n  *--p = c;\n  pbound = p - address_pad_len;\n\n  /* Use a special case of the code for each base.  This is measurably\n     faster than generic code.  */\n  switch (address_base)\n    {\n    case 8:\n      do\n\t*--p = '0' + (address & 7);\n      while ((address >>= 3) != 0);\n      break;\n\n    case 10:\n      do\n\t*--p = '0' + (address % 10);\n      while ((address /= 10) != 0);\n      break;\n\n    case 16:\n      do\n\t*--p = \"0123456789abcdef\"[address & 15];\n      while ((address >>= 4) != 0);\n      break;\n    }\n\n  while (pbound < p)\n    *--p = '0';\n\n  fputs (p, stdout);\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_4EFB8B(int a1, int a2)\n{\n  unsigned int v3; // [rsp+8h] [rbp-38h]\n  unsigned int v4; // [rsp+Ch] [rbp-34h]\n  char s[48]; // [rsp+10h] [rbp-30h] BYREF\n\n  v4 = a1;\n  v3 = a2;\n  if ( a1 < 0 )\n    v4 = 0;\n  if ( *((_DWORD *)qword_75D408 + 12) <= v4 )\n    v4 = *((_DWORD *)qword_75D408 + 12) - 1;\n  if ( a2 < 0 )\n    v3 = 0;\n  if ( *((_DWORD *)qword_75D408 + 13) <= v3 )\n    v3 = *((_DWORD *)qword_75D408 + 13) - 1;\n  sprintf(s, \"\\x1B[%u;%uH\", v4 + 1, v3 + 1);\n  return sub_4EB2D6(s);\n}\n",
        "output": "```c\nstatic int\nmove_cursor(int row, int col)\n{\n  unsigned int safe_row, safe_col;\n  char command[48];\n\n  safe_row = (row < 0) ? 0 : row;\n  safe_col = (col < 0) ? 0 : col;\n\n  if (safe_row >= *((unsigned int *)qword_75D408 + 12))\n    safe_row = *((unsigned int *)qword_75D408 + 12) - 1;\n\n  if (safe_col >= *((unsigned int *)qword_75D408 + 13))\n    safe_col = *((unsigned int *)qword_75D408 + 13) - 1;\n\n  sprintf(command, \"\\x1B[%u;%uH\", safe_row + 1, safe_col + 1);\n  return sub_4EB2D6(command);\n}\n```",
        "source_code": "static void place_cursor(int row, int col)\n{\n\tchar cm1[sizeof(ESC_SET_CURSOR_POS) + sizeof(int)*3 * 2];\n\n\tif (row < 0) row = 0;\n\tif (row >= rows) row = rows - 1;\n\tif (col < 0) col = 0;\n\tif (col >= columns) col = columns - 1;\n\n\tsprintf(cm1, ESC_SET_CURSOR_POS, row + 1, col + 1);\n\twrite1(cm1);\n}",
        "parsed_output": "static int\nmove_cursor(int row, int col)\n{\n  unsigned int safe_row, safe_col;\n  char command[48];\n\n  safe_row = (row < 0) ? 0 : row;\n  safe_col = (col < 0) ? 0 : col;\n\n  if (safe_row >= *((unsigned int *)qword_75D408 + 12))\n    safe_row = *((unsigned int *)qword_75D408 + 12) - 1;\n\n  if (safe_col >= *((unsigned int *)qword_75D408 + 13))\n    safe_col = *((unsigned int *)qword_75D408 + 13) - 1;\n\n  sprintf(command, \"\\x1B[%u;%uH\", safe_row + 1, safe_col + 1);\n  return sub_4EB2D6(command);\n}",
        "baseline_code_stripped": "int __fastcall sub_4EFB8B(int a1, int a2)\n{\n  unsigned int v3; // [rsp+8h] [rbp-38h]\n  unsigned int v4; // [rsp+Ch] [rbp-34h]\n  char s[48]; // [rsp+10h] [rbp-30h] BYREF\n\n  v4 = a1;\n  v3 = a2;\n  if ( a1 < 0 )\n    v4 = 0;\n  if ( *((_DWORD *)qword_75D408 + 12) <= v4 )\n    v4 = *((_DWORD *)qword_75D408 + 12) - 1;\n  if ( a2 < 0 )\n    v3 = 0;\n  if ( *((_DWORD *)qword_75D408 + 13) <= v3 )\n    v3 = *((_DWORD *)qword_75D408 + 13) - 1;\n  sprintf(s, \"\\x1B[%u;%uH\", v4 + 1, v3 + 1);\n  return sub_4EB2D6(s);\n}\n",
        "baseline_code_debug": "void __cdecl place_cursor(int row, int col)\n{\n  unsigned int cola; // [rsp+8h] [rbp-38h]\n  unsigned int rowa; // [rsp+Ch] [rbp-34h]\n  char cm1[33]; // [rsp+10h] [rbp-30h] BYREF\n\n  rowa = row;\n  cola = col;\n  if ( row < 0 )\n    rowa = 0;\n  if ( ptr_to_globals->numspeed <= rowa )\n    rowa = ptr_to_globals->numspeed - 1;\n  if ( col < 0 )\n    cola = 0;\n  if ( ptr_to_globals->speeds[0] <= cola )\n    cola = ptr_to_globals->speeds[0] - 1;\n  sprintf(cm1, \"\\x1B[%u;%uH\", rowa + 1, cola + 1);\n  write1(cm1);\n}\n",
        "similarity_score_unixcoder": 0.7103310823440552,
        "similarity_score_baseline_stripped": 0.43151557445526123,
        "similarity_score_baseline_debug": 0.7162870764732361
    },
    {
        "func_name": "send_headers_and_exit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl triple_compare(const void *x, const void *y)\n{\n  bool v3; // [rsp+Fh] [rbp-21h]\n\n  v3 = 0;\n  if ( *((_QWORD *)x + 1) == *((_QWORD *)y + 1) )\n  {\n    v3 = 0;\n    if ( *((_QWORD *)x + 2) == *((_QWORD *)y + 2) )\n      return same_name(*(const char **)x, *(const char **)y);\n  }\n  return v3;\n}\n\n\n Revised code:\nstatic bool\ntriple_compare (void const *x, void const *y)\n{\n  struct F_triple const *a = x;\n  struct F_triple const *b = y;\n  return (SAME_INODE (*a, *b) && same_name (a->name, b->name)) ? true : false;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_occurs(const void *void_first, const void *void_second)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h]\n  int value; // [rsp+1Ch] [rbp-14h]\n\n  value = compare_words(void_first, void_second);\n  if ( value )\n    LODWORD(v3) = value;\n  else\n    return *(_QWORD *)void_first - *(_QWORD *)void_second;\n  return v3;\n}\n\n\n Revised code:\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return value == 0 ? first->key.start - second->key.start : value;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl src_to_dest_compare(const void *x, const void *y)\n{\n  bool v3; // [rsp+1h] [rbp-21h]\n\n  v3 = 0;\n  if ( *(_QWORD *)x == *(_QWORD *)y )\n    return *((_QWORD *)x + 1) == *((_QWORD *)y + 1);\n  return v3;\n}\n\n\n Revised code:\nstatic bool\nsrc_to_dest_compare (void const *x, void const *y)\n{\n  struct Src_to_dest const *a = x;\n  struct Src_to_dest const *b = y;\n  return SAME_INODE (*a, *b) ? true : false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall __noreturn sub_42C9D5(unsigned int a1)\n{\n  *((_BYTE *)qword_75D408 + 320) = 0;\n  sub_42C4BD(a1);\n  sub_42C47C();\n}\n",
        "output": "```c\nstatic void\nsub_42C9D5 (unsigned int a1)\n{\n  qword_75D408->field_320 = 0;\n  sub_42C4BD (a1);\n  sub_42C47C ();\n  __builtin_unreachable ();\n}\n```",
        "source_code": "static void send_headers_and_exit(int responseNum)\n{\n\tIF_FEATURE_HTTPD_GZIP(content_gzip = 0;)\n\tsend_headers(responseNum);\n\tlog_and_exit();\n}",
        "parsed_output": "static void\nsub_42C9D5 (unsigned int a1)\n{\n  qword_75D408->field_320 = 0;\n  sub_42C4BD (a1);\n  sub_42C47C ();\n  __builtin_unreachable ();\n}",
        "baseline_code_stripped": "void __fastcall __noreturn sub_42C9D5(unsigned int a1)\n{\n  *((_BYTE *)qword_75D408 + 320) = 0;\n  sub_42C4BD(a1);\n  sub_42C47C();\n}\n",
        "baseline_code_debug": "void __cdecl __noreturn send_headers_and_exit(int responseNum)\n{\n  LOBYTE(ptr_to_globals[1].initstring) = 0;\n  send_headers(responseNum);\n  log_and_exit();\n}\n",
        "similarity_score_unixcoder": 0.3370606005191803,
        "similarity_score_baseline_stripped": 0.3648204505443573,
        "similarity_score_baseline_debug": 0.751465380191803
    },
    {
        "func_name": "stop_handler",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl is_colored(indicator_no type)\n{\n  bool v2; // [rsp+6h] [rbp-1Ah]\n  char v3; // [rsp+7h] [rbp-19h]\n  const char *s; // [rsp+8h] [rbp-18h]\n  size_t len; // [rsp+10h] [rbp-10h]\n\n  len = color_indicator[type].len;\n  s = color_indicator[type].string;\n  v3 = 1;\n  if ( len )\n  {\n    if ( len != 1 || (v3 = 1, strncmp(s, \"0\", 1uLL)) )\n    {\n      v2 = 0;\n      if ( len == 2 )\n        v2 = strncmp(s, \"00\", 2uLL) == 0;\n      v3 = v2;\n    }\n  }\n  return (v3 & 1) == 0;\n}\n\n\n Revised code:\nstatic bool\nis_colored (enum indicator_no type)\n{\n  size_t len = color_indicator[type].len;\n  char const *s = color_indicator[type].string;\n  return ! (len == 0\n\t    || (len == 1 && strncmp (s, \"0\", 1) == 0)\n\t    || (len == 2 && strncmp (s, \"00\", 2) == 0));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_4F588E()\n{\n  __int64 result; // rax\n  int v1; // [rsp+14h] [rbp-Ch]\n  int v2; // [rsp+18h] [rbp-8h]\n  unsigned __int8 v3; // [rsp+1Fh] [rbp-1h]\n\n  v3 = byte_75D468;\n  v2 = *(_DWORD *)qword_75D400;\n  signal(18, sub_50818F);\n  while ( byte_75D468 != 18 )\n  {\n    v1 = sub_409F8A(0LL);\n    sub_4F528F(v1);\n    sleep(1u);\n  }\n  signal(18, 0LL);\n  *(_DWORD *)qword_75D400 = v2;\n  result = v3;\n  byte_75D468 = v3;\n  return result;\n}\n",
        "output": "```c\nstatic void signal_handler(int signum)\n{\n  byte_75D468 = signum;\n}\n\nstatic __int64 my_function()\n{\n  __int64 original_state;\n  int previous_value;\n  unsigned __int8 original_signal;\n\n  original_signal = byte_75D468;\n  previous_value = *(_DWORD *)qword_75D400;\n  signal(SIGCONT, signal_handler);\n\n  while (byte_75D468 != SIGCONT)\n  {\n    int value = sub_409F8A(0LL);\n    sub_4F528F(value);\n    sleep(1);\n  }\n\n  signal(SIGCONT, SIG_DFL);\n  *(_DWORD *)qword_75D400 = previous_value;\n  byte_75D468 = original_signal;\n\n  return original_signal;\n}\n```",
        "source_code": "static void stop_handler(int sig UNUSED_PARAM)\n{\n\tsmallint saved_bb_got_signal;\n\tint saved_errno;\n\n\tsaved_bb_got_signal = bb_got_signal;\n\tsaved_errno = errno;\n\tsignal(SIGCONT, record_signo);\n\n\twhile (1) {\n\t\tpid_t wpid;\n\n\t\tif (bb_got_signal == SIGCONT)\n\t\t\tbreak;\n\t\t/* NB: this can accidentally wait() for a process\n\t\t * which we waitfor() elsewhere! waitfor() must have\n\t\t * code which is resilient against this.\n\t\t */\n\t\twpid = wait_any_nohang(NULL);\n\t\tmark_terminated(wpid);\n\t\tsleep(1);\n\t}\n\n\tsignal(SIGCONT, SIG_DFL);\n\terrno = saved_errno;\n\tbb_got_signal = saved_bb_got_signal;\n}",
        "parsed_output": "static void signal_handler(int signum)\n{\n  byte_75D468 = signum;\n}\n\nstatic __int64 my_function()\n{\n  __int64 original_state;\n  int previous_value;\n  unsigned __int8 original_signal;\n\n  original_signal = byte_75D468;\n  previous_value = *(_DWORD *)qword_75D400;\n  signal(SIGCONT, signal_handler);\n\n  while (byte_75D468 != SIGCONT)\n  {\n    int value = sub_409F8A(0LL);\n    sub_4F528F(value);\n    sleep(1);\n  }\n\n  signal(SIGCONT, SIG_DFL);\n  *(_DWORD *)qword_75D400 = previous_value;\n  byte_75D468 = original_signal;\n\n  return original_signal;\n}",
        "baseline_code_stripped": "__int64 sub_4F588E()\n{\n  __int64 result; // rax\n  int v1; // [rsp+14h] [rbp-Ch]\n  int v2; // [rsp+18h] [rbp-8h]\n  unsigned __int8 v3; // [rsp+1Fh] [rbp-1h]\n\n  v3 = byte_75D468;\n  v2 = *(_DWORD *)qword_75D400;\n  signal(18, sub_50818F);\n  while ( byte_75D468 != 18 )\n  {\n    v1 = sub_409F8A(0LL);\n    sub_4F528F(v1);\n    sleep(1u);\n  }\n  signal(18, 0LL);\n  *(_DWORD *)qword_75D400 = v2;\n  result = v3;\n  byte_75D468 = v3;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl stop_handler(int sig)\n{\n  pid_t wpid; // [rsp+14h] [rbp-Ch]\n  int saved_errno; // [rsp+18h] [rbp-8h]\n  smallint saved_bb_got_signal; // [rsp+1Fh] [rbp-1h]\n\n  saved_bb_got_signal = bb_got_signal[0];\n  saved_errno = *bb_errno;\n  signal(18, (__sighandler_t)record_signo);\n  while ( bb_got_signal[0] != 18 )\n  {\n    wpid = wait_any_nohang(0LL);\n    mark_terminated(wpid);\n    sleep(1u);\n  }\n  signal(18, 0LL);\n  *bb_errno = saved_errno;\n  bb_got_signal[0] = saved_bb_got_signal;\n}\n",
        "similarity_score_unixcoder": 0.7090902924537659,
        "similarity_score_baseline_stripped": 0.5296855568885803,
        "similarity_score_baseline_debug": 0.9212341904640198
    },
    {
        "func_name": "set_partition",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_occurs(const void *void_first, const void *void_second)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h]\n  int value; // [rsp+1Ch] [rbp-14h]\n\n  value = compare_words(void_first, void_second);\n  if ( value )\n    LODWORD(v3) = value;\n  else\n    return *(_QWORD *)void_first - *(_QWORD *)void_second;\n  return v3;\n}\n\n\n Revised code:\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return value == 0 ? first->key.start - second->key.start : value;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_490FCA(int a1, int a2, unsigned int a3, unsigned int a4, char a5)\n{\n  _BYTE *result; // rax\n  int v8; // [rsp+1Ch] [rbp-Ch]\n  _BYTE *v9; // [rsp+20h] [rbp-8h]\n\n  if ( a2 )\n  {\n    v9 = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * a1 + 314);\n    v8 = *((_DWORD *)qword_75D408 + 22);\n  }\n  else\n  {\n    v9 = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * a1 + 313);\n    v8 = *((_DWORD *)qword_75D408 + 10 * a1 + 630);\n  }\n  *v9 = 0;\n  v9[4] = a5;\n  sub_49091E((__int64)v9, a3 - v8);\n  sub_490945((__int64)v9, a4 - a3 + 1);\n  sub_490DE1(v9, a3, a4);\n  result = (char *)qword_75D408 + 40 * a1 + 2536;\n  *result = 1;\n  return result;\n}\n",
        "output": "```c\nstatic _BYTE *\nsub_490FCA(int index, int flag, unsigned int start, unsigned int end, char value)\n{\n  _BYTE *result;\n  _BYTE *buffer;\n  int offset;\n\n  if (flag)\n  {\n    buffer = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * index + 314);\n    offset = *((_DWORD *)qword_75D408 + 22);\n  }\n  else\n  {\n    buffer = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * index + 313);\n    offset = *((_DWORD *)qword_75D408 + 10 * index + 630);\n  }\n\n  *buffer = 0;\n  buffer[4] = value;\n  sub_49091E((__int64)buffer, start - offset);\n  sub_490945((__int64)buffer, end - start + 1);\n  sub_490DE1(buffer, start, end);\n\n  result = (_BYTE *)qword_75D408 + 40 * index + 2536;\n  *result = 1;\n\n  return result;\n}\n```",
        "source_code": "static void\nset_partition(int i, int doext, sector_t start, sector_t stop, int sysid)\n{\n\tstruct partition *p;\n\tsector_t offset;\n\n\tif (doext) {\n\t\tp = ptes[i].ext_pointer;\n\t\toffset = extended_offset;\n\t} else {\n\t\tp = ptes[i].part_table;\n\t\toffset = ptes[i].offset_from_dev_start;\n\t}\n\tp->boot_ind = 0;\n\tp->sys_ind = sysid;\n\tset_start_sect(p, start - offset);\n\tset_nr_sects(p, stop - start + 1);\n\tset_hsc_start_end(p, start, stop);\n\tptes[i].changed = 1;\n}",
        "parsed_output": "static _BYTE *\nsub_490FCA(int index, int flag, unsigned int start, unsigned int end, char value)\n{\n  _BYTE *result;\n  _BYTE *buffer;\n  int offset;\n\n  if (flag)\n  {\n    buffer = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * index + 314);\n    offset = *((_DWORD *)qword_75D408 + 22);\n  }\n  else\n  {\n    buffer = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * index + 313);\n    offset = *((_DWORD *)qword_75D408 + 10 * index + 630);\n  }\n\n  *buffer = 0;\n  buffer[4] = value;\n  sub_49091E((__int64)buffer, start - offset);\n  sub_490945((__int64)buffer, end - start + 1);\n  sub_490DE1(buffer, start, end);\n\n  result = (_BYTE *)qword_75D408 + 40 * index + 2536;\n  *result = 1;\n\n  return result;\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_490FCA(int a1, int a2, unsigned int a3, unsigned int a4, char a5)\n{\n  _BYTE *result; // rax\n  int v8; // [rsp+1Ch] [rbp-Ch]\n  _BYTE *v9; // [rsp+20h] [rbp-8h]\n\n  if ( a2 )\n  {\n    v9 = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * a1 + 314);\n    v8 = *((_DWORD *)qword_75D408 + 22);\n  }\n  else\n  {\n    v9 = (_BYTE *)*((_QWORD *)qword_75D408 + 5 * a1 + 313);\n    v8 = *((_DWORD *)qword_75D408 + 10 * a1 + 630);\n  }\n  *v9 = 0;\n  v9[4] = a5;\n  sub_49091E((__int64)v9, a3 - v8);\n  sub_490945((__int64)v9, a4 - a3 + 1);\n  sub_490DE1(v9, a3, a4);\n  result = (char *)qword_75D408 + 40 * a1 + 2536;\n  *result = 1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl set_partition(int i, int doext, sector_t start, sector_t stop, int sysid)\n{\n  sector_t offset; // [rsp+1Ch] [rbp-Ch]\n  partition *p; // [rsp+20h] [rbp-8h]\n\n  if ( doext )\n  {\n    p = *(partition **)&ptr_to_globals[8].line_buf[40 * i + 52];\n    offset = ptr_to_globals->speeds[9];\n  }\n  else\n  {\n    p = *(partition **)&ptr_to_globals[8].line_buf[40 * i + 44];\n    offset = *(_DWORD *)&ptr_to_globals[8].line_buf[40 * i + 60];\n  }\n  p->boot_ind = 0;\n  p->sys_ind = sysid;\n  set_start_sect(p, start - offset);\n  set_nr_sects(p, stop - start + 1);\n  set_hsc_start_end(p, start, stop);\n  ptr_to_globals[8].line_buf[40 * i + 76] = 1;\n}\n",
        "similarity_score_unixcoder": 0.4281576871871948,
        "similarity_score_baseline_stripped": 0.3952065110206604,
        "similarity_score_baseline_debug": 0.7750954627990723
    },
    {
        "func_name": "hostname_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl print_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  unsigned __int8 *v3; // rax\n  const char *v4; // rdi\n  char buf[5]; // [rsp+33h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+38h] [rbp-38h]\n  unsigned __int8 c; // [rsp+47h] [rbp-29h]\n  size_t i; // [rsp+48h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+50h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+58h] [rbp-18h]\n  const void *blocka; // [rsp+60h] [rbp-10h]\n  size_t n_bytesa; // [rsp+68h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = (unsigned __int8 *)p++;\n    c = *v3;\n    switch ( c )\n    {\n      case 0u:\n        s = \" \\\\0\";\n        break;\n      case 7u:\n        s = (const char *)&unk_409AA8;\n        break;\n      case 8u:\n        s = (const char *)&unk_409AAC;\n        break;\n      case 9u:\n        s = (const char *)&unk_409ABC;\n        break;\n      case 0xAu:\n        s = (const char *)&unk_409AB4;\n        break;\n      case 0xBu:\n        s = (const char *)&unk_409AC0;\n        break;\n      case 0xCu:\n        s = (const char *)&unk_409AB0;\n        break;\n      case 0xDu:\n        s = (const char *)&unk_409AB8;\n        break;\n      default:\n        v4 = \"%03o\";\n        if ( ((*__ctype_b_loc())[c] & 0x4000) != 0 )\n          v4 = \"  %c\";\n        sprintf(buf, v4, c);\n        s = buf;\n        break;\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_ascii (size_t n_bytes, void const *block,\n\t     const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      unsigned char c = *p++;\n      const char *s;\n      char buf[5];\n\n      switch (c)\n\t{\n\tcase '\\0':\n\t  s = \" \\\\0\";\n\t  break;\n\n\tcase '\\a':\n\t  s = \" \\\\a\";\n\t  break;\n\n\tcase '\\b':\n\t  s = \" \\\\b\";\n\t  break;\n\n\tcase '\\f':\n\t  s = \" \\\\f\";\n\t  break;\n\n\tcase '\\n':\n\t  s = \" \\\\n\";\n\t  break;\n\n\tcase '\\r':\n\t  s = \" \\\\r\";\n\t  break;\n\n\tcase '\\t':\n\t  s = \" \\\\t\";\n\t  break;\n\n\tcase '\\v':\n\t  s = \" \\\\v\";\n\t  break;\n\n\tdefault:\n\t  sprintf (buf, (isprint (c) ? \"  %c\" : \"%03o\"), c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n\n## Example:\n\n Input code:\nbool __cdecl sysv_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  int *v5; // rax\n  char *v6; // rax\n  size_t bytes_read; // [rsp+20h] [rbp-22E0h]\n  size_t i; // [rsp+28h] [rbp-22D8h]\n  _BYTE is_stdin[5]; // [rsp+33h] [rbp-22CDh]\n  char hbuf[652]; // [rsp+40h] [rbp-22C0h] BYREF\n  uintmax_t total_bytes; // [rsp+2D8h] [rbp-2028h]\n  unsigned __int8 buf[8192]; // [rsp+2E0h] [rbp-2020h] BYREF\n  int fd; // [rsp+22E8h] [rbp-18h]\n  int print_namea; // [rsp+22ECh] [rbp-14h]\n  const char *filea; // [rsp+22F0h] [rbp-10h]\n  char v17; // [rsp+22FFh] [rbp-1h]\n\n  filea = file;\n  print_namea = print_name;\n  total_bytes = 0LL;\n  is_stdin[4] = 0;\n  v2 = strcmp(file, \"-\");\n  *(_DWORD *)is_stdin = v2 == 0;\n  if ( !v2 )\n  {\n    fd = 0;\n    have_read_stdin = 1;\n    goto LABEL_5;\n  }\n  fd = open(filea, 0);\n  if ( fd == -1 )\n  {\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    v17 = 0;\n  }\n  else\n  {\nLABEL_5:\n    while ( 1 )\n    {\n      bytes_read = safe_read(fd, buf, 0x2000uLL);\n      if ( !bytes_read )\n        break;\n      if ( bytes_read == -1LL )\n      {\n        v4 = __errno_location();\n        error(0, *v4, \"%s\", filea);\n        if ( (is_stdin[0] & 1) == 0 )\n          close(fd);\n        v17 = 0;\n        return v17 & 1;\n      }\n      for ( i = 0LL; i < bytes_read; ++i )\n        *(_DWORD *)&is_stdin[1] += buf[i];\n      total_bytes += bytes_read;\n    }\n    if ( (is_stdin[0] & 1) != 0 || !close(fd) )\n    {\n      v6 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x200uLL);\n      printf(\n        \"%d %s\",\n        ((HIWORD(*(_DWORD *)&is_stdin[1]) + *(unsigned __int16 *)&is_stdin[1]) >> 16)\n      + (unsigned int)(unsigned __int16)(*(_WORD *)&is_stdin[3] + *(_WORD *)&is_stdin[1]),\n        v6);\n      if ( print_namea )\n        printf(\" %s\", filea);\n      putchar_unlocked(10);\n      v17 = 1;\n    }\n    else\n    {\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filea);\n      v17 = 0;\n    }\n  }\n  return v17 & 1;\n}\n\n\n Revised code:\nstatic bool\nsysv_sum_file (const char *file, int print_name)\n{\n  int fd;\n  unsigned char buf[8192];\n  uintmax_t total_bytes = 0;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int r;\n  int checksum;\n\n  /* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n  unsigned int s = 0;\n\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fd = STDIN_FILENO;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while (1)\n    {\n      size_t i;\n      size_t bytes_read = safe_read (fd, buf, sizeof buf);\n\n      if (bytes_read == 0)\n\tbreak;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  if (!is_stdin)\n\t    close (fd);\n\t  return false;\n\t}\n\n      for (i = 0; i < bytes_read; i++)\n\ts += buf[i];\n      total_bytes += bytes_read;\n    }\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  checksum = (r & 0xffff) + (r >> 16);\n\n  printf (\"%d %s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 512));\n  if (print_name)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  char *v5; // rax\n  unsigned int v7; // [rsp+14h] [rbp-2CCh]\n  bool is_stdin; // [rsp+1Fh] [rbp-2C1h]\n  char hbuf[652]; // [rsp+20h] [rbp-2C0h] BYREF\n  int ch_0; // [rsp+2ACh] [rbp-34h]\n  uintmax_t total_bytes; // [rsp+2B0h] [rbp-30h]\n  int checksum; // [rsp+2BCh] [rbp-24h]\n  FILE *fp; // [rsp+2C0h] [rbp-20h]\n  int print_namea; // [rsp+2CCh] [rbp-14h]\n  const char *filea; // [rsp+2D0h] [rbp-10h]\n\n  filea = file;\n  print_namea = print_name;\n  checksum = 0;\n  total_bytes = 0LL;\n  v2 = strcmp(file, \"-\");\n  is_stdin = v2 == 0;\n  if ( v2 )\n  {\n    fp = fopen(filea, \"r\");\n    if ( !fp )\n      goto LABEL_4;\n  }\n  else\n  {\n    fp = stdin;\n    have_read_stdin = 1;\n  }\n  while ( 1 )\n  {\n    ch_0 = getc_unlocked(fp);\n    if ( ch_0 == -1 )\n      break;\n    ++total_bytes;\n    checksum = (unsigned __int16)(((checksum & 1) << 15) + (checksum >> 1) + ch_0);\n  }\n  if ( ferror_unlocked(fp) )\n  {\n    v4 = __errno_location();\n    error(0, *v4, \"%s\", filea);\n    if ( !is_stdin )\n      fclose(fp);\n    return 0;\n  }\n  if ( !is_stdin && fclose(fp) )\n  {\nLABEL_4:\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    return 0;\n  }\n  v7 = checksum;\n  v5 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x400uLL);\n  printf(\"%05d %5s\", v7, v5);\n  if ( print_namea > 1 )\n    printf(\" %s\", filea);\n  putchar_unlocked(10);\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_sum_file (const char *file, int print_name)\n{\n  FILE *fp;\n  int checksum = 0;\t/* The checksum mod 2^16. */\n  uintmax_t total_bytes = 0;\t/* The number of bytes. */\n  int ch;\t\t/* Each character read. */\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fp = stdin;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fp = fopen (file, (O_BINARY ? \"rb\" : \"r\"));\n      if (fp == NULL)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while ((ch = getc (fp)) != EOF)\n    {\n      total_bytes++;\n      checksum = (checksum >> 1) + ((checksum & 1) << 15);\n      checksum += ch;\n      checksum &= 0xffff;\t/* Keep it within bounds. */\n    }\n\n  if (ferror (fp))\n    {\n      error (0, errno, \"%s\", file);\n      if (!is_stdin)\n\tfclose (fp);\n      return false;\n    }\n\n  if (!is_stdin && fclose (fp) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  printf (\"%05d %5s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 1024));\n  if (print_name > 1)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_42B489(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  char *v6; // rdx\n  char **v8; // [rsp+0h] [rbp-40h]\n  char *v9; // [rsp+10h] [rbp-30h] BYREF\n  char *v10; // [rsp+18h] [rbp-28h]\n  __int64 v11; // [rsp+20h] [rbp-20h]\n  char *s; // [rsp+28h] [rbp-18h]\n  __int64 i; // [rsp+30h] [rbp-10h]\n  int v14; // [rsp+3Ch] [rbp-4h]\n\n  qword_75D448 = (__int64)\"domain\";\n  v14 = sub_4FA1EF(a2, (unsigned int)\"dfisF:v\", (unsigned int)&v9, a4, a5, a6);\n  v8 = (char **)(8LL * optind + a2);\n  s = (char *)sub_507F01();\n  if ( *ident == 100 )\n    v14 = 1;\n  if ( (v14 & 0xF) != 0 )\n  {\n    v11 = sub_50C0A2(s);\n    v10 = strchrnul(*(const char **)v11, 46);\n    if ( (v14 & 2) != 0 )\n    {\n      puts(*(const char **)v11);\n    }\n    else if ( (v14 & 8) != 0 )\n    {\n      *v10 = 0;\n      puts(*(const char **)v11);\n    }\n    else if ( (v14 & 1) != 0 )\n    {\n      if ( *v10 )\n        puts(v10 + 1);\n    }\n    else if ( *(_DWORD *)(v11 + 20) == 4 )\n    {\n      for ( i = *(_QWORD *)(v11 + 24); *(_QWORD *)i; i += 8LL )\n      {\n        v6 = inet_ntoa((struct in_addr)(*(struct in_addr **)i)->s_addr);\n        if ( *(_QWORD *)(i + 8) )\n          printf(\"%s \", v6);\n        else\n          printf(\"%s\", v6);\n      }\n      sub_40A659(10);\n    }\n  }\n  else if ( (v14 & 0x10) != 0 )\n  {\n    sub_42B3F8(v9, 1);\n  }\n  else if ( *v8 )\n  {\n    sub_42B3F8(*v8, 0);\n  }\n  else\n  {\n    puts(s);\n  }\n  return 0LL;\n}\n",
        "output": "```c\nstatic int64_t\nsub_42B489(int64_t a1, int64_t a2, int64_t a3, int a4, int a5, int a6)\n{\n  char **argv; // [rsp+0h] [rbp-40h]\n  char *v9; // [rsp+10h] [rbp-30h] BYREF\n  char *v10; // [rsp+18h] [rbp-28h]\n  int64_t v11; // [rsp+20h] [rbp-20h]\n  char *hostname; // [rsp+28h] [rbp-18h]\n  int64_t i; // [rsp+30h] [rbp-10h]\n  int flags; // [rsp+3Ch] [rbp-4h]\n\n  qword_75D448 = \"domain\";\n  flags = sub_4FA1EF(a2, \"dfisF:v\", &v9, a4, a5, a6);\n  argv = (char **)(8 * optind + a2);\n  hostname = (char *)sub_507F01();\n  if (*ident == 'd')\n    flags = 1;\n  if (flags & 0xF)\n  {\n    v11 = sub_50C0A2(hostname);\n    v10 = strchrnul(*(const char **)v11, '.');\n    if (flags & 2)\n    {\n      puts(*(const char **)v11);\n    }\n    else if (flags & 8)\n    {\n      *v10 = '\\0';\n      puts(*(const char **)v11);\n    }\n    else if (flags & 1)\n    {\n      if (*v10)\n        puts(v10 + 1);\n    }\n    else if (*(_DWORD *)(v11 + 20) == 4)\n    {\n      for (i = *(_QWORD *)(v11 + 24); *(_QWORD *)i; i += 8)\n      {\n        char *ip_str = inet_ntoa(*(struct in_addr *)i);\n        printf(\"%s%s\", ip_str, *(_QWORD *)(i + 8) ? \" \" : \"\");\n      }\n      putchar('\\n');\n    }\n  }\n  else if (flags & 0x10)\n  {\n    sub_42B3F8(v9, 1);\n  }\n  else if (*argv)\n  {\n    sub_42B3F8(*argv, 0);\n  }\n  else\n  {\n    puts(hostname);\n  }\n  return 0;\n}\n```",
        "source_code": "int hostname_main(int argc UNUSED_PARAM, char **argv)\n{\n\tenum {\n\t\tOPT_d = 0x1,\n\t\tOPT_f = 0x2,\n\t\tOPT_i = 0x4,\n\t\tOPT_s = 0x8,\n\t\tOPT_F = 0x10,\n\t\tOPT_dfis = 0xf,\n\t};\n\n\tunsigned opts;\n\tchar *buf;\n\tchar *hostname_str;\n\n#if ENABLE_LONG_OPTS\n\tapplet_long_options =\n\t\t\"domain\\0\"     No_argument \"d\"\n\t\t\"fqdn\\0\"       No_argument \"f\"\n\t//Enable if seen in active use in some distro:\n\t//\t\"long\\0\"       No_argument \"f\"\n\t//\t\"ip-address\\0\" No_argument \"i\"\n\t//\t\"short\\0\"      No_argument \"s\"\n\t//\t\"verbose\\0\"    No_argument \"v\"\n\t\t\"file\\0\"       No_argument \"F\"\n\t\t;\n\n#endif\n\t/* dnsdomainname from net-tools 1.60, hostname 1.100 (2001-04-14),\n\t * supports hostname's options too (not just -v as manpage says) */\n\topts = getopt32(argv, \"dfisF:v\", &hostname_str);\n\targv += optind;\n\tbuf = safe_gethostname();\n\tif (applet_name[0] == 'd') /* dnsdomainname? */\n\t\topts = OPT_d;\n\n\tif (opts & OPT_dfis) {\n\t\t/* Cases when we need full hostname (or its part) */\n\t\tstruct hostent *hp;\n\t\tchar *p;\n\n\t\thp = xgethostbyname(buf);\n\t\tp = strchrnul(hp->h_name, '.');\n\t\tif (opts & OPT_f) {\n\t\t\tputs(hp->h_name);\n\t\t} else if (opts & OPT_s) {\n\t\t\t*p = '\\0';\n\t\t\tputs(hp->h_name);\n\t\t} else if (opts & OPT_d) {\n\t\t\tif (*p)\n\t\t\t\tputs(p + 1);\n\t\t} else /*if (opts & OPT_i)*/ {\n\t\t\tif (hp->h_length == sizeof(struct in_addr)) {\n\t\t\t\tstruct in_addr **h_addr_list = (struct in_addr **)hp->h_addr_list;\n\t\t\t\twhile (*h_addr_list) {\n\t\t\t\t\tprintf(h_addr_list[1] ? \"%s \" : \"%s\", inet_ntoa(**h_addr_list));\n\t\t\t\t\th_addr_list++;\n\t\t\t\t}\n\t\t\t\tbb_putchar('\\n');\n\t\t\t}\n\t\t}\n\t} else if (opts & OPT_F) {\n\t\t/* Set the hostname */\n\t\tdo_sethostname(hostname_str, 1);\n\t} else if (argv[0]) {\n\t\t/* Set the hostname */\n\t\tdo_sethostname(argv[0], 0);\n\t} else {\n\t\t/* Just print the current hostname */\n\t\tputs(buf);\n\t}\n\n\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\tfree(buf);\n\treturn EXIT_SUCCESS;\n}",
        "parsed_output": "static int64_t\nsub_42B489(int64_t a1, int64_t a2, int64_t a3, int a4, int a5, int a6)\n{\n  char **argv; // [rsp+0h] [rbp-40h]\n  char *v9; // [rsp+10h] [rbp-30h] BYREF\n  char *v10; // [rsp+18h] [rbp-28h]\n  int64_t v11; // [rsp+20h] [rbp-20h]\n  char *hostname; // [rsp+28h] [rbp-18h]\n  int64_t i; // [rsp+30h] [rbp-10h]\n  int flags; // [rsp+3Ch] [rbp-4h]\n\n  qword_75D448 = \"domain\";\n  flags = sub_4FA1EF(a2, \"dfisF:v\", &v9, a4, a5, a6);\n  argv = (char **)(8 * optind + a2);\n  hostname = (char *)sub_507F01();\n  if (*ident == 'd')\n    flags = 1;\n  if (flags & 0xF)\n  {\n    v11 = sub_50C0A2(hostname);\n    v10 = strchrnul(*(const char **)v11, '.');\n    if (flags & 2)\n    {\n      puts(*(const char **)v11);\n    }\n    else if (flags & 8)\n    {\n      *v10 = '\\0';\n      puts(*(const char **)v11);\n    }\n    else if (flags & 1)\n    {\n      if (*v10)\n        puts(v10 + 1);\n    }\n    else if (*(_DWORD *)(v11 + 20) == 4)\n    {\n      for (i = *(_QWORD *)(v11 + 24); *(_QWORD *)i; i += 8)\n      {\n        char *ip_str = inet_ntoa(*(struct in_addr *)i);\n        printf(\"%s%s\", ip_str, *(_QWORD *)(i + 8) ? \" \" : \"\");\n      }\n      putchar('\\n');\n    }\n  }\n  else if (flags & 0x10)\n  {\n    sub_42B3F8(v9, 1);\n  }\n  else if (*argv)\n  {\n    sub_42B3F8(*argv, 0);\n  }\n  else\n  {\n    puts(hostname);\n  }\n  return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_42B489(__int64 a1, __int64 a2, __int64 a3, int a4, int a5, int a6)\n{\n  char *v6; // rdx\n  char **v8; // [rsp+0h] [rbp-40h]\n  char *v9; // [rsp+10h] [rbp-30h] BYREF\n  char *v10; // [rsp+18h] [rbp-28h]\n  __int64 v11; // [rsp+20h] [rbp-20h]\n  char *s; // [rsp+28h] [rbp-18h]\n  __int64 i; // [rsp+30h] [rbp-10h]\n  int v14; // [rsp+3Ch] [rbp-4h]\n\n  qword_75D448 = (__int64)\"domain\";\n  v14 = sub_4FA1EF(a2, (unsigned int)\"dfisF:v\", (unsigned int)&v9, a4, a5, a6);\n  v8 = (char **)(8LL * optind + a2);\n  s = (char *)sub_507F01();\n  if ( *ident == 100 )\n    v14 = 1;\n  if ( (v14 & 0xF) != 0 )\n  {\n    v11 = sub_50C0A2(s);\n    v10 = strchrnul(*(const char **)v11, 46);\n    if ( (v14 & 2) != 0 )\n    {\n      puts(*(const char **)v11);\n    }\n    else if ( (v14 & 8) != 0 )\n    {\n      *v10 = 0;\n      puts(*(const char **)v11);\n    }\n    else if ( (v14 & 1) != 0 )\n    {\n      if ( *v10 )\n        puts(v10 + 1);\n    }\n    else if ( *(_DWORD *)(v11 + 20) == 4 )\n    {\n      for ( i = *(_QWORD *)(v11 + 24); *(_QWORD *)i; i += 8LL )\n      {\n        v6 = inet_ntoa((struct in_addr)(*(struct in_addr **)i)->s_addr);\n        if ( *(_QWORD *)(i + 8) )\n          printf(\"%s \", v6);\n        else\n          printf(\"%s\", v6);\n      }\n      sub_40A659(10);\n    }\n  }\n  else if ( (v14 & 0x10) != 0 )\n  {\n    sub_42B3F8(v9, 1);\n  }\n  else if ( *v8 )\n  {\n    sub_42B3F8(*v8, 0);\n  }\n  else\n  {\n    puts(s);\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl hostname_main(int argc, char **argv)\n{\n  char *v2; // rdx\n  char **argva; // [rsp+0h] [rbp-40h]\n  char *hostname_str; // [rsp+10h] [rbp-30h] BYREF\n  char *p; // [rsp+18h] [rbp-28h]\n  hostent *hp; // [rsp+20h] [rbp-20h]\n  char *buf; // [rsp+28h] [rbp-18h]\n  in_addr **h_addr_list; // [rsp+30h] [rbp-10h]\n  unsigned int opts; // [rsp+3Ch] [rbp-4h]\n\n  applet_long_options = \"domain\";\n  opts = getopt32(argv, \"dfisF:v\", &hostname_str);\n  argva = &argv[optind];\n  buf = safe_gethostname();\n  if ( *applet_name == 100 )\n    opts = 1;\n  if ( (opts & 0xF) != 0 )\n  {\n    hp = xgethostbyname(buf);\n    p = strchrnul(hp->h_name, 46);\n    if ( (opts & 2) != 0 )\n    {\n      puts(hp->h_name);\n    }\n    else if ( (opts & 8) != 0 )\n    {\n      *p = 0;\n      puts(hp->h_name);\n    }\n    else if ( (opts & 1) != 0 )\n    {\n      if ( *p )\n        puts(p + 1);\n    }\n    else if ( hp->h_length == 4 )\n    {\n      for ( h_addr_list = (in_addr **)hp->h_addr_list; *h_addr_list; ++h_addr_list )\n      {\n        v2 = inet_ntoa((struct in_addr)(*h_addr_list)->s_addr);\n        if ( h_addr_list[1] )\n          printf(\"%s \", v2);\n        else\n          printf(\"%s\", v2);\n      }\n      bb_putchar(10);\n    }\n  }\n  else if ( (opts & 0x10) != 0 )\n  {\n    do_sethostname(hostname_str, 1);\n  }\n  else if ( *argva )\n  {\n    do_sethostname(*argva, 0);\n  }\n  else\n  {\n    puts(buf);\n  }\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.7649465203285217,
        "similarity_score_baseline_stripped": 0.6286060810089111,
        "similarity_score_baseline_debug": 0.8877220749855042
    },
    {
        "func_name": "good_hostname",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl component_len(const char *f)\n{\n  bool v2; // [rsp+1h] [rbp-11h]\n  size_t len; // [rsp+2h] [rbp-10h]\n\n  for ( len = 1LL; ; ++len )\n  {\n    v2 = 0;\n    if ( f[len] != 47 )\n      v2 = f[len] != 0;\n    if ( !v2 )\n      break;\n  }\n  return len;\n}\n\n\n Revised code:\nstatic size_t\ncomponent_len (char const *f)\n{\n  size_t len;\n  for (len = 1; f[len] != '/' && f[len]; len++)\n    continue;\n  return len;\n}\n\n## Example:\n\n Input code:\nbool __cdecl simple_strtoul(const char *s, const char **p, unsigned __int64 *val)\n{\n  const char *v3; // rsi\n  int c; // [rsp+0h] [rbp-2Ch]\n  unsigned __int64 sum; // [rsp+4h] [rbp-28h]\n\n  sum = 0LL;\n  while ( (unsigned int)(*s - 48) <= 9 )\n  {\n    v3 = s++;\n    c = *v3 - 48;\n    if ( sum > (-1LL - c) / 0xAuLL )\n      return 0;\n    sum = c + 10 * sum;\n  }\n  *p = s;\n  *val = sum;\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nsimple_strtoul (const char *s, const char **p, unsigned long int *val)\n{\n  unsigned long int sum;\n\n  sum = 0;\n  while (ISDIGIT (*s))\n    {\n      int c = *s++ - '0';\n      if (sum > (ULONG_MAX - c) / 10)\n\treturn false;\n      sum = sum * 10 + c;\n    }\n  *p = s;\n  *val = sum;\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_453547(unsigned __int8 *a1)\n{\n  unsigned __int8 *v3; // [rsp+0h] [rbp-8h]\n\n  while ( 1 )\n  {\n    v3 = sub_4534CD(a1);\n    if ( !v3 )\n      return 0LL;\n    if ( !*v3 )\n      break;\n    a1 = v3 + 1;\n  }\n  return 1LL;\n}\n",
        "output": "```c\nstatic bool\nsub_453547 (unsigned char *a1)\n{\n  unsigned char *next;\n\n  while (true)\n    {\n      next = sub_4534CD(a1);\n      if (!next)\n\treturn false;\n      if (!*next)\n\tbreak;\n      a1 = next + 1;\n    }\n  return true;\n}\n```",
        "source_code": "static int good_hostname(const char *name)\n{\n\t//const char *start = name;\n\n\tfor (;;) {\n\t\tname = valid_domain_label(name);\n\t\tif (!name)\n\t\t\treturn 0;\n\t\tif (!name[0])\n\t\t\treturn 1;\n\t\t\t//Do we want this?\n\t\t\t//return ((name - start) < 1025); /* NS_MAXDNAME */\n\t\tname++;\n\t}\n}",
        "parsed_output": "static bool\nsub_453547 (unsigned char *a1)\n{\n  unsigned char *next;\n\n  while (true)\n    {\n      next = sub_4534CD(a1);\n      if (!next)\n\treturn false;\n      if (!*next)\n\tbreak;\n      a1 = next + 1;\n    }\n  return true;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_453547(unsigned __int8 *a1)\n{\n  unsigned __int8 *v3; // [rsp+0h] [rbp-8h]\n\n  while ( 1 )\n  {\n    v3 = sub_4534CD(a1);\n    if ( !v3 )\n      return 0LL;\n    if ( !*v3 )\n      break;\n    a1 = v3 + 1;\n  }\n  return 1LL;\n}\n",
        "baseline_code_debug": "int __cdecl good_hostname(const char *name)\n{\n  const char *nameb; // [rsp+0h] [rbp-8h]\n\n  while ( 1 )\n  {\n    nameb = valid_domain_label(name);\n    if ( !nameb )\n      return 0;\n    if ( !*nameb )\n      break;\n    name = nameb + 1;\n  }\n  return 1;\n}\n",
        "similarity_score_unixcoder": 0.6061724424362183,
        "similarity_score_baseline_stripped": 0.4720306396484375,
        "similarity_score_baseline_debug": 0.8140092492103577
    },
    {
        "func_name": "peektoken",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl hextobin(unsigned __int8 c)\n{\n  int v2; // [rsp+10h] [rbp-4h]\n\n  switch ( c )\n  {\n    case 'A':\n    case 'a':\n      v2 = 10;\n      break;\n    case 'B':\n    case 'b':\n      v2 = 11;\n      break;\n    case 'C':\n    case 'c':\n      v2 = 12;\n      break;\n    case 'D':\n    case 'd':\n      v2 = 13;\n      break;\n    case 'E':\n    case 'e':\n      v2 = 14;\n      break;\n    case 'F':\n    case 'f':\n      v2 = 15;\n      break;\n    default:\n      v2 = c - 48;\n      break;\n  }\n  return v2;\n}\n\n\n Revised code:\nstatic int\nhextobin (unsigned char c)\n{\n  switch (c)\n    {\n    default: return c - '0';\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    }\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl component_len(const char *f)\n{\n  bool v2; // [rsp+1h] [rbp-11h]\n  size_t len; // [rsp+2h] [rbp-10h]\n\n  for ( len = 1LL; ; ++len )\n  {\n    v2 = 0;\n    if ( f[len] != 47 )\n      v2 = f[len] != 0;\n    if ( !v2 )\n      break;\n  }\n  return len;\n}\n\n\n Revised code:\nstatic size_t\ncomponent_len (char const *f)\n{\n  size_t len;\n  for (len = 1; f[len] != '/' && f[len]; len++)\n    continue;\n  return len;\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_47DC18()\n{\n  int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_47DB13();\n  byte_75B059 = 1;\n  return *(unsigned __int8 *)*(&off_51D220 + v1);\n}\n",
        "output": "```c\nstatic unsigned char\nsub_47DC18(void)\n{\n  int index = sub_47DB13();\n  byte_75B059 = 1;\n  return *((unsigned char *)(&off_51D220 + index));\n}\n```",
        "source_code": "static char\npeektoken(void)\n{\n\tint t;\n\n\tt = readtoken();\n\ttokpushback = 1;\n\treturn tokname_array[t][0];\n}",
        "parsed_output": "static unsigned char\nsub_47DC18(void)\n{\n  int index = sub_47DB13();\n  byte_75B059 = 1;\n  return *((unsigned char *)(&off_51D220 + index));\n}",
        "baseline_code_stripped": "__int64 sub_47DC18()\n{\n  int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_47DB13();\n  byte_75B059 = 1;\n  return *(unsigned __int8 *)*(&off_51D220 + v1);\n}\n",
        "baseline_code_debug": "char __cdecl peektoken()\n{\n  int t; // [rsp+Ch] [rbp-4h]\n\n  t = readtoken();\n  tokpushback = 1;\n  return *tokname_array[t];\n}\n",
        "similarity_score_unixcoder": 0.48807772994041443,
        "similarity_score_baseline_stripped": 0.4183512330055237,
        "similarity_score_baseline_debug": 0.8403681516647339
    },
    {
        "func_name": "ftp_login",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl sysv_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  int *v5; // rax\n  char *v6; // rax\n  size_t bytes_read; // [rsp+20h] [rbp-22E0h]\n  size_t i; // [rsp+28h] [rbp-22D8h]\n  _BYTE is_stdin[5]; // [rsp+33h] [rbp-22CDh]\n  char hbuf[652]; // [rsp+40h] [rbp-22C0h] BYREF\n  uintmax_t total_bytes; // [rsp+2D8h] [rbp-2028h]\n  unsigned __int8 buf[8192]; // [rsp+2E0h] [rbp-2020h] BYREF\n  int fd; // [rsp+22E8h] [rbp-18h]\n  int print_namea; // [rsp+22ECh] [rbp-14h]\n  const char *filea; // [rsp+22F0h] [rbp-10h]\n  char v17; // [rsp+22FFh] [rbp-1h]\n\n  filea = file;\n  print_namea = print_name;\n  total_bytes = 0LL;\n  is_stdin[4] = 0;\n  v2 = strcmp(file, \"-\");\n  *(_DWORD *)is_stdin = v2 == 0;\n  if ( !v2 )\n  {\n    fd = 0;\n    have_read_stdin = 1;\n    goto LABEL_5;\n  }\n  fd = open(filea, 0);\n  if ( fd == -1 )\n  {\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    v17 = 0;\n  }\n  else\n  {\nLABEL_5:\n    while ( 1 )\n    {\n      bytes_read = safe_read(fd, buf, 0x2000uLL);\n      if ( !bytes_read )\n        break;\n      if ( bytes_read == -1LL )\n      {\n        v4 = __errno_location();\n        error(0, *v4, \"%s\", filea);\n        if ( (is_stdin[0] & 1) == 0 )\n          close(fd);\n        v17 = 0;\n        return v17 & 1;\n      }\n      for ( i = 0LL; i < bytes_read; ++i )\n        *(_DWORD *)&is_stdin[1] += buf[i];\n      total_bytes += bytes_read;\n    }\n    if ( (is_stdin[0] & 1) != 0 || !close(fd) )\n    {\n      v6 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x200uLL);\n      printf(\n        \"%d %s\",\n        ((HIWORD(*(_DWORD *)&is_stdin[1]) + *(unsigned __int16 *)&is_stdin[1]) >> 16)\n      + (unsigned int)(unsigned __int16)(*(_WORD *)&is_stdin[3] + *(_WORD *)&is_stdin[1]),\n        v6);\n      if ( print_namea )\n        printf(\" %s\", filea);\n      putchar_unlocked(10);\n      v17 = 1;\n    }\n    else\n    {\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filea);\n      v17 = 0;\n    }\n  }\n  return v17 & 1;\n}\n\n\n Revised code:\nstatic bool\nsysv_sum_file (const char *file, int print_name)\n{\n  int fd;\n  unsigned char buf[8192];\n  uintmax_t total_bytes = 0;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int r;\n  int checksum;\n\n  /* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n  unsigned int s = 0;\n\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fd = STDIN_FILENO;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while (1)\n    {\n      size_t i;\n      size_t bytes_read = safe_read (fd, buf, sizeof buf);\n\n      if (bytes_read == 0)\n\tbreak;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  if (!is_stdin)\n\t    close (fd);\n\t  return false;\n\t}\n\n      for (i = 0; i < bytes_read; i++)\n\ts += buf[i];\n      total_bytes += bytes_read;\n    }\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  checksum = (r & 0xffff) + (r >> 16);\n\n  printf (\"%d %s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 512));\n  if (print_name)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  char *v5; // rax\n  unsigned int v7; // [rsp+14h] [rbp-2CCh]\n  bool is_stdin; // [rsp+1Fh] [rbp-2C1h]\n  char hbuf[652]; // [rsp+20h] [rbp-2C0h] BYREF\n  int ch_0; // [rsp+2ACh] [rbp-34h]\n  uintmax_t total_bytes; // [rsp+2B0h] [rbp-30h]\n  int checksum; // [rsp+2BCh] [rbp-24h]\n  FILE *fp; // [rsp+2C0h] [rbp-20h]\n  int print_namea; // [rsp+2CCh] [rbp-14h]\n  const char *filea; // [rsp+2D0h] [rbp-10h]\n\n  filea = file;\n  print_namea = print_name;\n  checksum = 0;\n  total_bytes = 0LL;\n  v2 = strcmp(file, \"-\");\n  is_stdin = v2 == 0;\n  if ( v2 )\n  {\n    fp = fopen(filea, \"r\");\n    if ( !fp )\n      goto LABEL_4;\n  }\n  else\n  {\n    fp = stdin;\n    have_read_stdin = 1;\n  }\n  while ( 1 )\n  {\n    ch_0 = getc_unlocked(fp);\n    if ( ch_0 == -1 )\n      break;\n    ++total_bytes;\n    checksum = (unsigned __int16)(((checksum & 1) << 15) + (checksum >> 1) + ch_0);\n  }\n  if ( ferror_unlocked(fp) )\n  {\n    v4 = __errno_location();\n    error(0, *v4, \"%s\", filea);\n    if ( !is_stdin )\n      fclose(fp);\n    return 0;\n  }\n  if ( !is_stdin && fclose(fp) )\n  {\nLABEL_4:\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    return 0;\n  }\n  v7 = checksum;\n  v5 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x400uLL);\n  printf(\"%05d %5s\", v7, v5);\n  if ( print_namea > 1 )\n    printf(\" %s\", filea);\n  putchar_unlocked(10);\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_sum_file (const char *file, int print_name)\n{\n  FILE *fp;\n  int checksum = 0;\t/* The checksum mod 2^16. */\n  uintmax_t total_bytes = 0;\t/* The number of bytes. */\n  int ch;\t\t/* Each character read. */\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fp = stdin;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fp = fopen (file, (O_BINARY ? \"rb\" : \"r\"));\n      if (fp == NULL)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while ((ch = getc (fp)) != EOF)\n    {\n      total_bytes++;\n      checksum = (checksum >> 1) + ((checksum & 1) << 15);\n      checksum += ch;\n      checksum &= 0xffff;\t/* Keep it within bounds. */\n    }\n\n  if (ferror (fp))\n    {\n      error (0, errno, \"%s\", file);\n      if (!is_stdin)\n\tfclose (fp);\n      return false;\n    }\n\n  if (!is_stdin && fclose (fp) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  printf (\"%05d %5s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 1024));\n  if (print_name > 1)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl do_decode(FILE *in, FILE *out, bool ignore_garbage)\n{\n  char *v3; // rax\n  size_t v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  int v7; // [rsp+Ch] [rbp-1C64h]\n  char v8; // [rsp+13h] [rbp-1C5Dh]\n  int errnum; // [rsp+14h] [rbp-1C5Ch]\n  bool v10; // [rsp+27h] [rbp-1C49h]\n  size_t v11; // [rsp+30h] [rbp-1C40h]\n  size_t outlen; // [rsp+38h] [rbp-1C38h] BYREF\n  bool v13; // [rsp+47h] [rbp-1C29h]\n  size_t inlen; // [rsp+48h] [rbp-1C28h]\n  char outa[3072]; // [rsp+50h] [rbp-1C20h] BYREF\n  char ina[4111]; // [rsp+C50h] [rbp-1020h] BYREF\n  bool v17; // [rsp+1C5Fh] [rbp-11h]\n  FILE *v18; // [rsp+1C60h] [rbp-10h]\n  FILE *v19; // [rsp+1C68h] [rbp-8h]\n\n  v19 = in;\n  v18 = out;\n  v17 = ignore_garbage;\n  do\n  {\n    inlen = 0LL;\n    do\n    {\n      outlen = fread_unlocked(&ina[inlen], 1uLL, 4096 - inlen, v19);\n      if ( v17 )\n      {\n        v11 = 0LL;\n        while ( 1 )\n        {\n          v10 = 0;\n          if ( outlen )\n            v10 = v11 < outlen;\n          if ( !v10 )\n            break;\n          if ( isbase64(ina[v11 + inlen]) || ina[v11 + inlen] == 61 )\n            ++v11;\n          else\n            memmove(&ina[inlen + v11], &ina[inlen + 1 + v11], --outlen - v11);\n        }\n      }\n      inlen += outlen;\n      if ( ferror_unlocked(v19) )\n      {\n        errnum = *__errno_location();\n        v3 = gettext(\"read error\");\n        error(1, errnum, v3);\n      }\n      v8 = 0;\n      if ( inlen < 0x1000 )\n        v8 = ~(feof_unlocked(v19) != 0);\n    }\n    while ( (v8 & 1) != 0 );\n    outlen = 3072LL;\n    v13 = base64_decode(ina, inlen, outa, &outlen);\n    v4 = fwrite_unlocked(outa, 1uLL, outlen, v18);\n    if ( v4 < outlen )\n    {\n      v7 = *__errno_location();\n      v5 = gettext(\"write error\");\n      error(1, v7, v5);\n    }\n    if ( !v13 )\n    {\n      v6 = gettext(\"invalid input\");\n      error(1, 0, v6);\n    }\n  }\n  while ( !feof_unlocked(v19) );\n}\n\n\n Revised code:\nstatic void\ndo_decode (FILE *in, FILE *out, bool ignore_garbage)\n{\n  char inbuf[B64BLOCKSIZE];\n  char outbuf[BLOCKSIZE];\n  size_t sum;\n\n  do\n    {\n      bool ok;\n      size_t n;\n\n      sum = 0;\n      do\n\t{\n\t  n = fread (inbuf + sum, 1, B64BLOCKSIZE - sum, in);\n\n\t  if (ignore_garbage)\n\t    {\n\t      size_t i;\n\t      for (i = 0; n > 0 && i < n;)\n\t\tif (isbase64 (inbuf[sum + i]) || inbuf[sum + i] == '=')\n\t\t  i++;\n\t\telse\n\t\t  memmove (inbuf + sum + i, inbuf + sum + i + 1, --n - i);\n\t    }\n\n\t  sum += n;\n\n\t  if (ferror (in))\n\t    error (EXIT_FAILURE, errno, _(\"read error\"));\n\t}\n      while (sum < B64BLOCKSIZE && !feof (in));\n\n      n = BLOCKSIZE;\n      ok = base64_decode (inbuf, sum, outbuf, &n);\n\n      if (fwrite (outbuf, 1, n, out) < n)\n\terror (EXIT_FAILURE, errno, _(\"write error\"));\n\n      if (!ok)\n\terror (EXIT_FAILURE, 0, _(\"invalid input\"));\n    }\n  while (!feof (in));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_42AE28()\n{\n  int v0; // eax\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  __int64 v5; // rdx\n  __int64 v6; // rcx\n  __int64 v7; // r8\n  __int64 v8; // r9\n  __int64 v9; // rsi\n  int v10; // eax\n  __int64 v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  __int64 v14; // r9\n  __int64 v15; // rsi\n\n  v0 = sub_50BDEA(*(_QWORD *)&dest.c_line);\n  *(_QWORD *)&dest.c_cc[7] = fdopen(v0, \"r+\");\n  if ( !*(_QWORD *)&dest.c_cc[7] )\n    sub_502D54();\n  if ( (unsigned int)sub_42AD2D(0LL, 0LL, v1, v2, v3, v4) != 220 )\n    sub_42ACB6(0LL, 0LL, v5, v6, v7, v8);\n  v9 = *(_QWORD *)&dest.c_iflag;\n  v10 = sub_42AD2D((__int64)\"USER\", *(__int64 *)&dest.c_iflag, v5, v6, v7, v8);\n  if ( v10 != 230 )\n  {\n    if ( v10 != 331 )\n      sub_42ACB6(\"USER\", v9, v11, v12, v13, v14);\n    v15 = *(_QWORD *)&dest.c_cflag;\n    if ( (unsigned int)sub_42AD2D((__int64)\"PASS\", v15, v11, v12, v13, v14) != 230 )\n      sub_42ACB6(\"PASS\", v15, v11, v12, v13, v14);\n  }\n  return sub_42AD2D((__int64)\"TYPE I\", 0LL, v11, v12, v13, v14);\n}\n",
        "output": "```c\nint ftp_login()\n{\n  int socket_fd;\n  FILE *control_stream;\n  int response_code;\n\n  socket_fd = create_control_connection(control_line);\n  control_stream = fdopen(socket_fd, \"r+\");\n  if (!control_stream)\n    fatal_error();\n\n  response_code = get_ftp_response(NULL);\n  if (response_code != FTP_READY)\n    ftp_error(NULL);\n\n  const char *username = control_flags;\n  response_code = send_ftp_command(\"USER\", username);\n  if (response_code != FTP_USER_LOGGED_IN)\n  {\n    if (response_code != FTP_NEED_PASSWORD)\n      ftp_error(\"USER\");\n\n    const char *password = control_flags;\n    response_code = send_ftp_command(\"PASS\", password);\n    if (response_code != FTP_USER_LOGGED_IN)\n      ftp_error(\"PASS\");\n  }\n\n  return send_ftp_command(\"TYPE I\", NULL);\n}\n```",
        "source_code": "static void ftp_login(void)\n{\n\t/* Connect to the command socket */\n\tcontrol_stream = fdopen(xconnect_stream(lsa), \"r+\");\n\tif (control_stream == NULL) {\n\t\t/* fdopen failed - extremely unlikely */\n\t\tbb_perror_nomsg_and_die();\n\t}\n\n\tif (ftpcmd(NULL, NULL) != 220) {\n\t\tftp_die(NULL);\n\t}\n\n\t/*  Login to the server */\n\tswitch (ftpcmd(\"USER\", user)) {\n\tcase 230:\n\t\tbreak;\n\tcase 331:\n\t\tif (ftpcmd(\"PASS\", password) != 230) {\n\t\t\tftp_die(\"PASS\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tftp_die(\"USER\");\n\t}\n\n\tftpcmd(\"TYPE I\", NULL);\n}",
        "parsed_output": "int ftp_login()\n{\n  int socket_fd;\n  FILE *control_stream;\n  int response_code;\n\n  socket_fd = create_control_connection(control_line);\n  control_stream = fdopen(socket_fd, \"r+\");\n  if (!control_stream)\n    fatal_error();\n\n  response_code = get_ftp_response(NULL);\n  if (response_code != FTP_READY)\n    ftp_error(NULL);\n\n  const char *username = control_flags;\n  response_code = send_ftp_command(\"USER\", username);\n  if (response_code != FTP_USER_LOGGED_IN)\n  {\n    if (response_code != FTP_NEED_PASSWORD)\n      ftp_error(\"USER\");\n\n    const char *password = control_flags;\n    response_code = send_ftp_command(\"PASS\", password);\n    if (response_code != FTP_USER_LOGGED_IN)\n      ftp_error(\"PASS\");\n  }\n\n  return send_ftp_command(\"TYPE I\", NULL);\n}",
        "baseline_code_stripped": "__int64 sub_42AE28()\n{\n  int v0; // eax\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  __int64 v5; // rdx\n  __int64 v6; // rcx\n  __int64 v7; // r8\n  __int64 v8; // r9\n  __int64 v9; // rsi\n  int v10; // eax\n  __int64 v11; // rdx\n  __int64 v12; // rcx\n  __int64 v13; // r8\n  __int64 v14; // r9\n  __int64 v15; // rsi\n\n  v0 = sub_50BDEA(*(_QWORD *)&dest.c_line);\n  *(_QWORD *)&dest.c_cc[7] = fdopen(v0, \"r+\");\n  if ( !*(_QWORD *)&dest.c_cc[7] )\n    sub_502D54();\n  if ( (unsigned int)sub_42AD2D(0LL, 0LL, v1, v2, v3, v4) != 220 )\n    sub_42ACB6(0LL, 0LL, v5, v6, v7, v8);\n  v9 = *(_QWORD *)&dest.c_iflag;\n  v10 = sub_42AD2D((__int64)\"USER\", *(__int64 *)&dest.c_iflag, v5, v6, v7, v8);\n  if ( v10 != 230 )\n  {\n    if ( v10 != 331 )\n      sub_42ACB6(\"USER\", v9, v11, v12, v13, v14);\n    v15 = *(_QWORD *)&dest.c_cflag;\n    if ( (unsigned int)sub_42AD2D((__int64)\"PASS\", v15, v11, v12, v13, v14) != 230 )\n      sub_42ACB6(\"PASS\", v15, v11, v12, v13, v14);\n  }\n  return sub_42AD2D((__int64)\"TYPE I\", 0LL, v11, v12, v13, v14);\n}\n",
        "baseline_code_debug": "void __cdecl ftp_login()\n{\n  int v0; // eax\n  int v1; // eax\n\n  v0 = xconnect_stream(*(const len_and_sockaddr_0 **)&bb_common_bufsiz1.c_line);\n  *(_QWORD *)&bb_common_bufsiz1.c_cc[7] = fdopen(v0, \"r+\");\n  if ( !*(_QWORD *)&bb_common_bufsiz1.c_cc[7] )\n    bb_perror_nomsg_and_die();\n  if ( ftpcmd(0LL, 0LL) != 220 )\n    ftp_die(0LL);\n  v1 = ftpcmd(\"USER\", *(const char **)&bb_common_bufsiz1.c_iflag);\n  if ( v1 != 230 )\n  {\n    if ( v1 != 331 )\n      ftp_die(\"USER\");\n    if ( ftpcmd(\"PASS\", *(const char **)&bb_common_bufsiz1.c_cflag) != 230 )\n      ftp_die(\"PASS\");\n  }\n  ftpcmd(\"TYPE I\", 0LL);\n}\n",
        "similarity_score_unixcoder": 0.8625494837760925,
        "similarity_score_baseline_stripped": 0.4293871521949768,
        "similarity_score_baseline_debug": 0.8456766605377197
    },
    {
        "func_name": "init_packet",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nvoid __cdecl format_address_std(uintmax_t address, char c)\n{\n  char *v2; // rax\n  char *v3; // rcx\n  char *v4; // rax\n  char *v5; // rax\n  const char *pbound; // [rsp+20h] [rbp-40h]\n  char *p; // [rsp+28h] [rbp-38h]\n  char buf[25]; // [rsp+30h] [rbp-30h] BYREF\n  char ca; // [rsp+57h] [rbp-9h]\n  uintmax_t addressa; // [rsp+58h] [rbp-8h]\n\n  addressa = address;\n  ca = c;\n  buf[24] = 0;\n  p = &buf[23];\n  buf[23] = c;\n  pbound = &buf[-address_pad_len + 23];\n  switch ( address_base )\n  {\n    case 8:\n      do\n      {\n        v2 = p--;\n        *(v2 - 1) = (addressa & 7) + 48;\n        addressa >>= 3;\n      }\n      while ( addressa );\n      break;\n    case 10:\n      do\n      {\n        v3 = p--;\n        *(v3 - 1) = addressa % 0xA + 48;\n        addressa /= 0xAuLL;\n      }\n      while ( addressa );\n      break;\n    case 16:\n      do\n      {\n        v4 = p--;\n        *(v4 - 1) = byte_4097D0[addressa & 0xF];\n        addressa >>= 4;\n      }\n      while ( addressa );\n      break;\n  }\n  while ( pbound < p )\n  {\n    v5 = p--;\n    *(v5 - 1) = 48;\n  }\n  fputs_unlocked(p, _bss_start);\n}\n\n\n Revised code:\nstatic void\nformat_address_std (uintmax_t address, char c)\n{\n  char buf[MAX_ADDRESS_LENGTH + 2];\n  char *p = buf + sizeof buf;\n  char const *pbound;\n\n  *--p = '\\0';\n  *--p = c;\n  pbound = p - address_pad_len;\n\n  /* Use a special case of the code for each base.  This is measurably\n     faster than generic code.  */\n  switch (address_base)\n    {\n    case 8:\n      do\n\t*--p = '0' + (address & 7);\n      while ((address >>= 3) != 0);\n      break;\n\n    case 10:\n      do\n\t*--p = '0' + (address % 10);\n      while ((address /= 10) != 0);\n      break;\n\n    case 16:\n      do\n\t*--p = \"0123456789abcdef\"[address & 15];\n      while ((address >>= 4) != 0);\n      break;\n    }\n\n  while (pbound < p)\n    *--p = '0';\n\n  fputs (p, stdout);\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_454080(__int64 a1, char a2)\n{\n  __int64 result; // rax\n\n  sub_458844(a1, (unsigned int)a2);\n  *(_DWORD *)(a1 + 4) = sub_454075();\n  *((_WORD *)&unk_75C3F8 + 57) = sub_40BCE2();\n  if ( !*((_WORD *)&unk_75C3F8 + 56) )\n    *((_WORD *)&unk_75C3F8 + 56) = *((_WORD *)&unk_75C3F8 + 57);\n  *(_WORD *)(a1 + 8) = htons(*((_WORD *)&unk_75C3F8 + 57) - *((_WORD *)&unk_75C3F8 + 56));\n  memcpy((void *)(a1 + 28), &unk_75C3F8, 6uLL);\n  result = *((_QWORD *)&unk_75C3F8 + 10);\n  if ( result )\n    return sub_459B82(a1, *((_QWORD *)&unk_75C3F8 + 10));\n  return result;\n}\n",
        "output": "```c\nstatic __int64\nsub_454080(__int64 a1, char a2)\n{\n  __int64 result;\n\n  sub_458844(a1, (unsigned int)a2);\n  *(_DWORD *)(a1 + 4) = sub_454075();\n  static _WORD global_value = sub_40BCE2();\n  if (!global_value)\n    global_value = sub_40BCE2();\n  *(_WORD *)(a1 + 8) = htons(global_value - global_value);\n  memcpy((void *)(a1 + 28), &global_data, sizeof(global_data));\n  result = global_data_ptr;\n  if (result)\n    return sub_459B82(a1, global_data_ptr);\n  return result;\n}\n```",
        "source_code": "static void init_packet(struct dhcp_packet *packet, char type)\n{\n\tuint16_t secs;\n\n\t/* Fill in: op, htype, hlen, cookie fields; message type option: */\n\tudhcp_init_header(packet, type);\n\n\tpacket->xid = random_xid();\n\n\tclient_config.last_secs = monotonic_sec();\n\tif (client_config.first_secs == 0)\n\t\tclient_config.first_secs = client_config.last_secs;\n\tsecs = client_config.last_secs - client_config.first_secs;\n\tpacket->secs = htons(secs);\n\n\tmemcpy(packet->chaddr, client_config.client_mac, 6);\n\tif (client_config.clientid)\n\t\tudhcp_add_binary_option(packet, client_config.clientid);\n}",
        "parsed_output": "static __int64\nsub_454080(__int64 a1, char a2)\n{\n  __int64 result;\n\n  sub_458844(a1, (unsigned int)a2);\n  *(_DWORD *)(a1 + 4) = sub_454075();\n  static _WORD global_value = sub_40BCE2();\n  if (!global_value)\n    global_value = sub_40BCE2();\n  *(_WORD *)(a1 + 8) = htons(global_value - global_value);\n  memcpy((void *)(a1 + 28), &global_data, sizeof(global_data));\n  result = global_data_ptr;\n  if (result)\n    return sub_459B82(a1, global_data_ptr);\n  return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_454080(__int64 a1, char a2)\n{\n  __int64 result; // rax\n\n  sub_458844(a1, (unsigned int)a2);\n  *(_DWORD *)(a1 + 4) = sub_454075();\n  *((_WORD *)&unk_75C3F8 + 57) = sub_40BCE2();\n  if ( !*((_WORD *)&unk_75C3F8 + 56) )\n    *((_WORD *)&unk_75C3F8 + 56) = *((_WORD *)&unk_75C3F8 + 57);\n  *(_WORD *)(a1 + 8) = htons(*((_WORD *)&unk_75C3F8 + 57) - *((_WORD *)&unk_75C3F8 + 56));\n  memcpy((void *)(a1 + 28), &unk_75C3F8, 6uLL);\n  result = *((_QWORD *)&unk_75C3F8 + 10);\n  if ( result )\n    return sub_459B82(a1, *((_QWORD *)&unk_75C3F8 + 10));\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl init_packet(dhcp_packet *packet, char type)\n{\n  udhcp_init_header(packet, type);\n  packet->xid = random_xid();\n  unk_75C46A = monotonic_sec();\n  if ( !unk_75C468 )\n    unk_75C468 = unk_75C46A;\n  packet->secs = htons(unk_75C46A - unk_75C468);\n  memcpy(packet->chaddr, &from_mac, 6uLL);\n  if ( unk_75C448 )\n    udhcp_add_binary_option(packet, unk_75C448);\n}\n",
        "similarity_score_unixcoder": 0.44413840770721436,
        "similarity_score_baseline_stripped": 0.45018520951271057,
        "similarity_score_baseline_debug": 0.8708961009979248
    },
    {
        "func_name": "tac_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl do_decode(FILE *in, FILE *out, bool ignore_garbage)\n{\n  char *v3; // rax\n  size_t v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  int v7; // [rsp+Ch] [rbp-1C64h]\n  char v8; // [rsp+13h] [rbp-1C5Dh]\n  int errnum; // [rsp+14h] [rbp-1C5Ch]\n  bool v10; // [rsp+27h] [rbp-1C49h]\n  size_t v11; // [rsp+30h] [rbp-1C40h]\n  size_t outlen; // [rsp+38h] [rbp-1C38h] BYREF\n  bool v13; // [rsp+47h] [rbp-1C29h]\n  size_t inlen; // [rsp+48h] [rbp-1C28h]\n  char outa[3072]; // [rsp+50h] [rbp-1C20h] BYREF\n  char ina[4111]; // [rsp+C50h] [rbp-1020h] BYREF\n  bool v17; // [rsp+1C5Fh] [rbp-11h]\n  FILE *v18; // [rsp+1C60h] [rbp-10h]\n  FILE *v19; // [rsp+1C68h] [rbp-8h]\n\n  v19 = in;\n  v18 = out;\n  v17 = ignore_garbage;\n  do\n  {\n    inlen = 0LL;\n    do\n    {\n      outlen = fread_unlocked(&ina[inlen], 1uLL, 4096 - inlen, v19);\n      if ( v17 )\n      {\n        v11 = 0LL;\n        while ( 1 )\n        {\n          v10 = 0;\n          if ( outlen )\n            v10 = v11 < outlen;\n          if ( !v10 )\n            break;\n          if ( isbase64(ina[v11 + inlen]) || ina[v11 + inlen] == 61 )\n            ++v11;\n          else\n            memmove(&ina[inlen + v11], &ina[inlen + 1 + v11], --outlen - v11);\n        }\n      }\n      inlen += outlen;\n      if ( ferror_unlocked(v19) )\n      {\n        errnum = *__errno_location();\n        v3 = gettext(\"read error\");\n        error(1, errnum, v3);\n      }\n      v8 = 0;\n      if ( inlen < 0x1000 )\n        v8 = ~(feof_unlocked(v19) != 0);\n    }\n    while ( (v8 & 1) != 0 );\n    outlen = 3072LL;\n    v13 = base64_decode(ina, inlen, outa, &outlen);\n    v4 = fwrite_unlocked(outa, 1uLL, outlen, v18);\n    if ( v4 < outlen )\n    {\n      v7 = *__errno_location();\n      v5 = gettext(\"write error\");\n      error(1, v7, v5);\n    }\n    if ( !v13 )\n    {\n      v6 = gettext(\"invalid input\");\n      error(1, 0, v6);\n    }\n  }\n  while ( !feof_unlocked(v19) );\n}\n\n\n Revised code:\nstatic void\ndo_decode (FILE *in, FILE *out, bool ignore_garbage)\n{\n  char inbuf[B64BLOCKSIZE];\n  char outbuf[BLOCKSIZE];\n  size_t sum;\n\n  do\n    {\n      bool ok;\n      size_t n;\n\n      sum = 0;\n      do\n\t{\n\t  n = fread (inbuf + sum, 1, B64BLOCKSIZE - sum, in);\n\n\t  if (ignore_garbage)\n\t    {\n\t      size_t i;\n\t      for (i = 0; n > 0 && i < n;)\n\t\tif (isbase64 (inbuf[sum + i]) || inbuf[sum + i] == '=')\n\t\t  i++;\n\t\telse\n\t\t  memmove (inbuf + sum + i, inbuf + sum + i + 1, --n - i);\n\t    }\n\n\t  sum += n;\n\n\t  if (ferror (in))\n\t    error (EXIT_FAILURE, errno, _(\"read error\"));\n\t}\n      while (sum < B64BLOCKSIZE && !feof (in));\n\n      n = BLOCKSIZE;\n      ok = base64_decode (inbuf, sum, outbuf, &n);\n\n      if (fwrite (outbuf, 1, n, out) < n)\n\terror (EXIT_FAILURE, errno, _(\"write error\"));\n\n      if (!ok)\n\terror (EXIT_FAILURE, 0, _(\"invalid input\"));\n    }\n  while (!feof (in));\n}\n\n## Example:\n\n Input code:\nbool __cdecl sysv_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  int *v5; // rax\n  char *v6; // rax\n  size_t bytes_read; // [rsp+20h] [rbp-22E0h]\n  size_t i; // [rsp+28h] [rbp-22D8h]\n  _BYTE is_stdin[5]; // [rsp+33h] [rbp-22CDh]\n  char hbuf[652]; // [rsp+40h] [rbp-22C0h] BYREF\n  uintmax_t total_bytes; // [rsp+2D8h] [rbp-2028h]\n  unsigned __int8 buf[8192]; // [rsp+2E0h] [rbp-2020h] BYREF\n  int fd; // [rsp+22E8h] [rbp-18h]\n  int print_namea; // [rsp+22ECh] [rbp-14h]\n  const char *filea; // [rsp+22F0h] [rbp-10h]\n  char v17; // [rsp+22FFh] [rbp-1h]\n\n  filea = file;\n  print_namea = print_name;\n  total_bytes = 0LL;\n  is_stdin[4] = 0;\n  v2 = strcmp(file, \"-\");\n  *(_DWORD *)is_stdin = v2 == 0;\n  if ( !v2 )\n  {\n    fd = 0;\n    have_read_stdin = 1;\n    goto LABEL_5;\n  }\n  fd = open(filea, 0);\n  if ( fd == -1 )\n  {\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    v17 = 0;\n  }\n  else\n  {\nLABEL_5:\n    while ( 1 )\n    {\n      bytes_read = safe_read(fd, buf, 0x2000uLL);\n      if ( !bytes_read )\n        break;\n      if ( bytes_read == -1LL )\n      {\n        v4 = __errno_location();\n        error(0, *v4, \"%s\", filea);\n        if ( (is_stdin[0] & 1) == 0 )\n          close(fd);\n        v17 = 0;\n        return v17 & 1;\n      }\n      for ( i = 0LL; i < bytes_read; ++i )\n        *(_DWORD *)&is_stdin[1] += buf[i];\n      total_bytes += bytes_read;\n    }\n    if ( (is_stdin[0] & 1) != 0 || !close(fd) )\n    {\n      v6 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x200uLL);\n      printf(\n        \"%d %s\",\n        ((HIWORD(*(_DWORD *)&is_stdin[1]) + *(unsigned __int16 *)&is_stdin[1]) >> 16)\n      + (unsigned int)(unsigned __int16)(*(_WORD *)&is_stdin[3] + *(_WORD *)&is_stdin[1]),\n        v6);\n      if ( print_namea )\n        printf(\" %s\", filea);\n      putchar_unlocked(10);\n      v17 = 1;\n    }\n    else\n    {\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filea);\n      v17 = 0;\n    }\n  }\n  return v17 & 1;\n}\n\n\n Revised code:\nstatic bool\nsysv_sum_file (const char *file, int print_name)\n{\n  int fd;\n  unsigned char buf[8192];\n  uintmax_t total_bytes = 0;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int r;\n  int checksum;\n\n  /* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n  unsigned int s = 0;\n\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fd = STDIN_FILENO;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while (1)\n    {\n      size_t i;\n      size_t bytes_read = safe_read (fd, buf, sizeof buf);\n\n      if (bytes_read == 0)\n\tbreak;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  if (!is_stdin)\n\t    close (fd);\n\t  return false;\n\t}\n\n      for (i = 0; i < bytes_read; i++)\n\ts += buf[i];\n      total_bytes += bytes_read;\n    }\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  checksum = (r & 0xffff) + (r >> 16);\n\n  printf (\"%d %s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 512));\n  if (print_name)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  unsigned __int8 *v3; // rax\n  const char *v4; // rdi\n  char buf[5]; // [rsp+33h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+38h] [rbp-38h]\n  unsigned __int8 c; // [rsp+47h] [rbp-29h]\n  size_t i; // [rsp+48h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+50h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+58h] [rbp-18h]\n  const void *blocka; // [rsp+60h] [rbp-10h]\n  size_t n_bytesa; // [rsp+68h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = (unsigned __int8 *)p++;\n    c = *v3;\n    switch ( c )\n    {\n      case 0u:\n        s = \" \\\\0\";\n        break;\n      case 7u:\n        s = (const char *)&unk_409AA8;\n        break;\n      case 8u:\n        s = (const char *)&unk_409AAC;\n        break;\n      case 9u:\n        s = (const char *)&unk_409ABC;\n        break;\n      case 0xAu:\n        s = (const char *)&unk_409AB4;\n        break;\n      case 0xBu:\n        s = (const char *)&unk_409AC0;\n        break;\n      case 0xCu:\n        s = (const char *)&unk_409AB0;\n        break;\n      case 0xDu:\n        s = (const char *)&unk_409AB8;\n        break;\n      default:\n        v4 = \"%03o\";\n        if ( ((*__ctype_b_loc())[c] & 0x4000) != 0 )\n          v4 = \"  %c\";\n        sprintf(buf, v4, c);\n        s = buf;\n        break;\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_ascii (size_t n_bytes, void const *block,\n\t     const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      unsigned char c = *p++;\n      const char *s;\n      char buf[5];\n\n      switch (c)\n\t{\n\tcase '\\0':\n\t  s = \" \\\\0\";\n\t  break;\n\n\tcase '\\a':\n\t  s = \" \\\\a\";\n\t  break;\n\n\tcase '\\b':\n\t  s = \" \\\\b\";\n\t  break;\n\n\tcase '\\f':\n\t  s = \" \\\\f\";\n\t  break;\n\n\tcase '\\n':\n\t  s = \" \\\\n\";\n\t  break;\n\n\tcase '\\r':\n\t  s = \" \\\\r\";\n\t  break;\n\n\tcase '\\t':\n\t  s = \" \\\\t\";\n\t  break;\n\n\tcase '\\v':\n\t  s = \" \\\\v\";\n\t  break;\n\n\tdefault:\n\t  sprintf (buf, (isprint (c) ? \"  %c\" : \"%03o\"), c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4D504C(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int v6; // eax\n  void *v7; // rsi\n  __int64 v8; // rdx\n  __int64 v9; // rcx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  int v12; // eax\n  __int64 *v15; // [rsp+0h] [rbp-40h]\n  __int64 *v16; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v17; // [rsp+1Ch] [rbp-24h]\n  FILE *stream; // [rsp+20h] [rbp-20h]\n  int v19; // [rsp+28h] [rbp-18h]\n  unsigned int v20; // [rsp+2Ch] [rbp-14h]\n  int *v21; // [rsp+30h] [rbp-10h]\n  __int64 *i; // [rsp+38h] [rbp-8h]\n\n  v21 = 0LL;\n  v16 = 0LL;\n  v20 = 0;\n  v6 = a2;\n  v7 = &unk_536F0D;\n  sub_4FA1EF(v6, (unsigned int)&unk_536F0D, a3, a4, a5, a6);\n  v15 = (__int64 *)(8LL * optind + a2);\n  if ( !*v15 )\n    *--v15 = (__int64)\"-\";\n  for ( i = v15; *i; ++i )\n    ;\n  do\n  {\n    stream = (FILE *)sub_50A79F(*--i);\n    if ( stream )\n    {\n      v19 = 0;\n      *(_DWORD *)qword_75D400 = 0;\n      do\n      {\n        v17 = getc_unlocked(stream);\n        if ( v17 != -1 )\n        {\n          if ( (v19 & 0x7F) == 0 )\n          {\n            v7 = (void *)(v19 + 127 + 5LL);\n            v21 = (int *)sub_40A09E(v21, (size_t)v7);\n          }\n          v12 = v19++;\n          v9 = v17;\n          v8 = (__int64)v21;\n          *((_BYTE *)v21 + v12 + 4) = v17;\n        }\n        if ( v17 == 10 || v17 == -1 && v19 )\n        {\n          v21 = (int *)sub_40A09E(v21, v19 + 4LL);\n          *v21 = v19;\n          v7 = v21;\n          sub_408FD2(&v16, (__int64)v21);\n          v21 = 0LL;\n          v19 = 0;\n        }\n      }\n      while ( v17 != -1 );\n      if ( *(_DWORD *)qword_75D400 && *(_DWORD *)qword_75D400 != 2 )\n      {\n        sub_40936D(*i, (__int64)v7, v8, v9, v10, v11);\n        v20 = 1;\n      }\n    }\n    else\n    {\n      v20 = 1;\n    }\n  }\n  while ( i != v15 );\n  while ( v16 )\n  {\n    v21 = (int *)v16[1];\n    sub_40A4AB(1u, (__int64)(v21 + 1), *v21);\n    v16 = (__int64 *)*v16;\n  }\n  return v20;\n}\n",
        "output": "```c\nstatic int\nprocess_files (char **file_list, size_t file_count, bool print_name)\n{\n  bool status = false;\n  FILE *stream;\n  char *line = NULL;\n  size_t line_allocated = 0;\n  size_t line_length;\n  int c;\n  struct line_node *line_list_head = NULL;\n  struct line_node **line_list_tail = &line_list_head;\n  size_t i;\n\n  for (i = 0; i < file_count; i++)\n    {\n      if (file_list[i] == NULL)\n        file_list[i] = \"-\";\n\n      stream = fopen (file_list[i], \"r\");\n\n      if (stream)\n        {\n          size_t line_number = 0;\n          clearerr (stream);\n\n          while (1)\n            {\n              c = getc_unlocked (stream);\n\n              if (c != EOF)\n                {\n                  if ((line_number & 0x7F) == 0)\n                    {\n                      line = xrealloc (line, line_number + 128);\n                      line_allocated = line_number + 127;\n                    }\n                  line[line_number++] = c;\n                }\n\n              if (c == '\\n' || (c == EOF && line_number > 0))\n                {\n                  line = xrealloc (line, line_number + 1);\n                  line[line_number] = '\\0';\n                  add_line_to_list (&line_list_tail, line, line_number);\n                  line = NULL;\n                  line_allocated = 0;\n                  line_number = 0;\n                }\n\n              if (c == EOF)\n                break;\n            }\n\n          if (ferror (stream))\n            {\n              error (0, errno, \"%s\", file_list[i]);\n              status = true;\n            }\n\n          fclose (stream);\n        }\n      else\n        {\n          error (0, errno, \"%s\", file_list[i]);\n          status = true;\n        }\n    }\n\n  for (struct line_node *ln = line_list_head; ln; ln = ln->next)\n    {\n      fwrite (ln->line_data, 1, ln->line_length, stdout);\n      free (ln->line_data);\n    }\n\n  free_line_list (line_list_head);\n\n  return status;\n}\n```",
        "source_code": "int tac_main(int argc UNUSED_PARAM, char **argv)\n{\n\tchar **name;\n\tFILE *f;\n\tstruct lstring *line = NULL;\n\tllist_t *list = NULL;\n\tint retval = EXIT_SUCCESS;\n\n#if ENABLE_DESKTOP\n/* tac from coreutils 6.9 supports:\n       -b, --before\n              attach the separator before instead of after\n       -r, --regex\n              interpret the separator as a regular expression\n       -s, --separator=STRING\n              use STRING as the separator instead of newline\nWe support none, but at least we will complain or handle \"--\":\n*/\n\tgetopt32(argv, \"\");\n\targv += optind;\n#else\n\targv++;\n#endif\n\tif (!*argv)\n\t\t*--argv = (char *)\"-\";\n\t/* We will read from last file to first */\n\tname = argv;\n\twhile (*name)\n\t\tname++;\n\n\tdo {\n\t\tint ch, i;\n\n\t\tname--;\n\t\tf = fopen_or_warn_stdin(*name);\n\t\tif (f == NULL) {\n\t\t\t/* error message is printed by fopen_or_warn_stdin */\n\t\t\tretval = EXIT_FAILURE;\n\t\t\tcontinue;\n\t\t}\n\n\t\terrno = i = 0;\n\t\tdo {\n\t\t\tch = fgetc(f);\n\t\t\tif (ch != EOF) {\n\t\t\t\tif (!(i & 0x7f))\n\t\t\t\t\t/* Grow on every 128th char */\n\t\t\t\t\tline = xrealloc(line, i + 0x7f + sizeof(int) + 1);\n\t\t\t\tline->buf[i++] = ch;\n\t\t\t}\n\t\t\tif (ch == '\\n' || (ch == EOF && i != 0)) {\n\t\t\t\tline = xrealloc(line, i + sizeof(int));\n\t\t\t\tline->size = i;\n\t\t\t\tllist_add_to(&list, line);\n\t\t\t\tline = NULL;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t} while (ch != EOF);\n\t\t/* fgetc sets errno to ENOENT on EOF, we don't want\n\t\t * to warn on this non-error! */\n\t\tif (errno && errno != ENOENT) {\n\t\t\tbb_simple_perror_msg(*name);\n\t\t\tretval = EXIT_FAILURE;\n\t\t}\n\t} while (name != argv);\n\n\twhile (list) {\n\t\tline = (struct lstring *)list->data;\n\t\txwrite(STDOUT_FILENO, line->buf, line->size);\n\t\tif (ENABLE_FEATURE_CLEAN_UP) {\n\t\t\tfree(llist_pop(&list));\n\t\t} else {\n\t\t\tlist = list->link;\n\t\t}\n\t}\n\n\treturn retval;\n}",
        "parsed_output": "static int\nprocess_files (char **file_list, size_t file_count, bool print_name)\n{\n  bool status = false;\n  FILE *stream;\n  char *line = NULL;\n  size_t line_allocated = 0;\n  size_t line_length;\n  int c;\n  struct line_node *line_list_head = NULL;\n  struct line_node **line_list_tail = &line_list_head;\n  size_t i;\n\n  for (i = 0; i < file_count; i++)\n    {\n      if (file_list[i] == NULL)\n        file_list[i] = \"-\";\n\n      stream = fopen (file_list[i], \"r\");\n\n      if (stream)\n        {\n          size_t line_number = 0;\n          clearerr (stream);\n\n          while (1)\n            {\n              c = getc_unlocked (stream);\n\n              if (c != EOF)\n                {\n                  if ((line_number & 0x7F) == 0)\n                    {\n                      line = xrealloc (line, line_number + 128);\n                      line_allocated = line_number + 127;\n                    }\n                  line[line_number++] = c;\n                }\n\n              if (c == '\\n' || (c == EOF && line_number > 0))\n                {\n                  line = xrealloc (line, line_number + 1);\n                  line[line_number] = '\\0';\n                  add_line_to_list (&line_list_tail, line, line_number);\n                  line = NULL;\n                  line_allocated = 0;\n                  line_number = 0;\n                }\n\n              if (c == EOF)\n                break;\n            }\n\n          if (ferror (stream))\n            {\n              error (0, errno, \"%s\", file_list[i]);\n              status = true;\n            }\n\n          fclose (stream);\n        }\n      else\n        {\n          error (0, errno, \"%s\", file_list[i]);\n          status = true;\n        }\n    }\n\n  for (struct line_node *ln = line_list_head; ln; ln = ln->next)\n    {\n      fwrite (ln->line_data, 1, ln->line_length, stdout);\n      free (ln->line_data);\n    }\n\n  free_line_list (line_list_head);\n\n  return status;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4D504C(__int64 a1, __int64 a2, int a3, int a4, int a5, int a6)\n{\n  int v6; // eax\n  void *v7; // rsi\n  __int64 v8; // rdx\n  __int64 v9; // rcx\n  __int64 v10; // r8\n  __int64 v11; // r9\n  int v12; // eax\n  __int64 *v15; // [rsp+0h] [rbp-40h]\n  __int64 *v16; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v17; // [rsp+1Ch] [rbp-24h]\n  FILE *stream; // [rsp+20h] [rbp-20h]\n  int v19; // [rsp+28h] [rbp-18h]\n  unsigned int v20; // [rsp+2Ch] [rbp-14h]\n  int *v21; // [rsp+30h] [rbp-10h]\n  __int64 *i; // [rsp+38h] [rbp-8h]\n\n  v21 = 0LL;\n  v16 = 0LL;\n  v20 = 0;\n  v6 = a2;\n  v7 = &unk_536F0D;\n  sub_4FA1EF(v6, (unsigned int)&unk_536F0D, a3, a4, a5, a6);\n  v15 = (__int64 *)(8LL * optind + a2);\n  if ( !*v15 )\n    *--v15 = (__int64)\"-\";\n  for ( i = v15; *i; ++i )\n    ;\n  do\n  {\n    stream = (FILE *)sub_50A79F(*--i);\n    if ( stream )\n    {\n      v19 = 0;\n      *(_DWORD *)qword_75D400 = 0;\n      do\n      {\n        v17 = getc_unlocked(stream);\n        if ( v17 != -1 )\n        {\n          if ( (v19 & 0x7F) == 0 )\n          {\n            v7 = (void *)(v19 + 127 + 5LL);\n            v21 = (int *)sub_40A09E(v21, (size_t)v7);\n          }\n          v12 = v19++;\n          v9 = v17;\n          v8 = (__int64)v21;\n          *((_BYTE *)v21 + v12 + 4) = v17;\n        }\n        if ( v17 == 10 || v17 == -1 && v19 )\n        {\n          v21 = (int *)sub_40A09E(v21, v19 + 4LL);\n          *v21 = v19;\n          v7 = v21;\n          sub_408FD2(&v16, (__int64)v21);\n          v21 = 0LL;\n          v19 = 0;\n        }\n      }\n      while ( v17 != -1 );\n      if ( *(_DWORD *)qword_75D400 && *(_DWORD *)qword_75D400 != 2 )\n      {\n        sub_40936D(*i, (__int64)v7, v8, v9, v10, v11);\n        v20 = 1;\n      }\n    }\n    else\n    {\n      v20 = 1;\n    }\n  }\n  while ( i != v15 );\n  while ( v16 )\n  {\n    v21 = (int *)v16[1];\n    sub_40A4AB(1u, (__int64)(v21 + 1), *v21);\n    v16 = (__int64 *)*v16;\n  }\n  return v20;\n}\n",
        "baseline_code_debug": "int __cdecl tac_main(int argc, char **argv)\n{\n  int v2; // eax\n  char **argva; // [rsp+0h] [rbp-40h]\n  llist_t_0 *list; // [rsp+10h] [rbp-30h] BYREF\n  int ch_0; // [rsp+1Ch] [rbp-24h]\n  FILE *f; // [rsp+20h] [rbp-20h]\n  int i; // [rsp+28h] [rbp-18h]\n  int retval; // [rsp+2Ch] [rbp-14h]\n  lstring *line; // [rsp+30h] [rbp-10h]\n  char **name; // [rsp+38h] [rbp-8h]\n\n  line = 0LL;\n  list = 0LL;\n  retval = 0;\n  getopt32(argv, &byte_536F0D);\n  argva = &argv[optind];\n  if ( !*argva )\n    *--argva = \"-\";\n  for ( name = argva; *name; ++name )\n    ;\n  do\n  {\n    f = fopen_or_warn_stdin(*--name);\n    if ( f )\n    {\n      i = 0;\n      *bb_errno = 0;\n      do\n      {\n        ch_0 = getc_unlocked(f);\n        if ( ch_0 != -1 )\n        {\n          if ( (i & 0x7F) == 0 )\n            line = (lstring *)xrealloc(line, i + 127 + 5LL);\n          v2 = i++;\n          line->buf[v2] = ch_0;\n        }\n        if ( ch_0 == 10 || ch_0 == -1 && i )\n        {\n          line = (lstring *)xrealloc(line, i + 4LL);\n          line->size = i;\n          llist_add_to(&list, line);\n          line = 0LL;\n          i = 0;\n        }\n      }\n      while ( ch_0 != -1 );\n      if ( *bb_errno && *bb_errno != 2 )\n      {\n        bb_simple_perror_msg(*name);\n        retval = 1;\n      }\n    }\n    else\n    {\n      retval = 1;\n    }\n  }\n  while ( name != argva );\n  while ( list )\n  {\n    line = (lstring *)list->data;\n    xwrite(1, line->buf, line->size);\n    list = list->link;\n  }\n  return retval;\n}\n",
        "similarity_score_unixcoder": 0.8515474200248718,
        "similarity_score_baseline_stripped": 0.5838368535041809,
        "similarity_score_baseline_debug": 0.8584400415420532
    },
    {
        "func_name": "fetch_heredocs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nvoid __cdecl fillpattern(int type, unsigned __int8 *r, size_t size)\n{\n  size_t i; // [rsp+10h] [rbp-20h]\n  size_t ia; // [rsp+10h] [rbp-20h]\n\n  *r = (type & 0xFFF | ((type & 0xFFFu) << 12)) >> 4;\n  r[1] = (unsigned __int16)(type & 0xFFF | ((type & 0xFFF) << 12)) >> 8;\n  r[2] = type;\n  for ( i = 3LL; i < size >> 1; i *= 2LL )\n    memcpy(&r[i], r, i);\n  if ( i < size )\n    memcpy(&r[i], r, size - i);\n  if ( (type & 0x1000) != 0 )\n  {\n    for ( ia = 0LL; ia < size; ia += 512LL )\n      r[ia] ^= 0x80u;\n  }\n}\n\n\n Revised code:\nstatic void\nfillpattern (int type, unsigned char *r, size_t size)\n{\n  size_t i;\n  unsigned int bits = type & 0xfff;\n\n  bits |= bits << 12;\n  r[0] = (bits >> 4) & 255;\n  r[1] = (bits >> 8) & 255;\n  r[2] = bits & 255;\n  for (i = 3; i < size / 2; i *= 2)\n    memcpy (r + i, r, i);\n  if (i < size)\n    memcpy (r + i, r, size - i);\n\n  /* Invert the first bit of every sector. */\n  if (type & 0x1000)\n    for (i = 0; i < size; i += SECTOR_SIZE)\n      r[i] ^= 0x80;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_482E12(int a1, __int64 **a2, __int64 a3)\n{\n  const char *v3; // rsi\n  __int64 v4; // rdx\n  __int64 v5; // rcx\n  __int64 v6; // r8\n  __int64 v7; // r9\n  const char *v11; // [rsp+28h] [rbp-28h]\n  __int64 *k; // [rsp+30h] [rbp-20h]\n  __int64 v13; // [rsp+38h] [rbp-18h]\n  int j; // [rsp+44h] [rbp-Ch]\n  __int64 *i; // [rsp+48h] [rbp-8h]\n\n  for ( i = *a2; i && a1; i = (__int64 *)*i )\n  {\n    v13 = i[5];\n    for ( j = 0; j < *((_DWORD *)i + 2); ++j )\n    {\n      for ( k = *(__int64 **)(v13 + 40); k; k = (__int64 *)*k )\n      {\n        if ( *((_BYTE *)k + 24) == 4 )\n        {\n          *((_BYTE *)k + 24) = 5;\n          v3 = (const char *)k[1];\n          v11 = sub_482CE1(a3, v3, *((_DWORD *)k + 5));\n          if ( !v11 )\n          {\n            sub_47FE8C((__int64)\"unexpected EOF in here document\", (__int64)v3, v4, v5, v6, v7);\n            return 1LL;\n          }\n          free((void *)k[1]);\n          k[1] = (__int64)v11;\n          --a1;\n        }\n      }\n      v13 += 48LL;\n    }\n  }\n  return 0LL;\n}\n",
        "output": "```c\nstatic int64_t\nprocess_heredocs(int count, int64_t **doc_list, int64_t context)\n{\n  const char *doc_content;\n  int64_t *current_doc;\n  int64_t *current_entry;\n  const char *new_content;\n  int entry_index;\n  int64_t *entry_list;\n\n  for (current_doc = *doc_list; current_doc && count; current_doc = (int64_t *)*current_doc)\n  {\n    entry_list = current_doc[5];\n    for (entry_index = 0; entry_index < *((int *)current_doc + 2); ++entry_index)\n    {\n      for (current_entry = *(int64_t **)(entry_list + 40); current_entry; current_entry = (int64_t *)*current_entry)\n      {\n        if (*((char *)current_entry + 24) == 4)\n        {\n          *((char *)current_entry + 24) = 5;\n          doc_content = (const char *)current_entry[1];\n          new_content = get_new_content(context, doc_content, *((int *)current_entry + 5));\n          if (!new_content)\n          {\n            report_error(\"unexpected EOF in here document\", doc_content);\n            return 1;\n          }\n          free((void *)current_entry[1]);\n          current_entry[1] = (int64_t)new_content;\n          --count;\n        }\n      }\n      entry_list += 48;\n    }\n  }\n  return 0;\n}\n```",
        "source_code": "static int fetch_heredocs(int heredoc_cnt, struct parse_context *ctx, struct in_str *input)\n{\n\tstruct pipe *pi = ctx->list_head;\n\n\twhile (pi && heredoc_cnt) {\n\t\tint i;\n\t\tstruct command *cmd = pi->cmds;\n\n\t\tdebug_printf_parse(\"fetch_heredocs: num_cmds:%d cmd argv0:'%s'\\n\",\n\t\t\t\tpi->num_cmds,\n\t\t\t\tcmd->argv ? cmd->argv[0] : \"NONE\");\n\t\tfor (i = 0; i < pi->num_cmds; i++) {\n\t\t\tstruct redir_struct *redir = cmd->redirects;\n\n\t\t\tdebug_printf_parse(\"fetch_heredocs: %d cmd argv0:'%s'\\n\",\n\t\t\t\t\ti, cmd->argv ? cmd->argv[0] : \"NONE\");\n\t\t\twhile (redir) {\n\t\t\t\tif (redir->rd_type == REDIRECT_HEREDOC) {\n\t\t\t\t\tchar *p;\n\n\t\t\t\t\tredir->rd_type = REDIRECT_HEREDOC2;\n\t\t\t\t\t/* redir->rd_dup is (ab)used to indicate <<- */\n\t\t\t\t\tp = fetch_till_str(&ctx->as_string, input,\n\t\t\t\t\t\t\tredir->rd_filename, redir->rd_dup);\n\t\t\t\t\tif (!p) {\n\t\t\t\t\t\tsyntax_error(\"unexpected EOF in here document\");\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t\tfree(redir->rd_filename);\n\t\t\t\t\tredir->rd_filename = p;\n\t\t\t\t\theredoc_cnt--;\n\t\t\t\t}\n\t\t\t\tredir = redir->next;\n\t\t\t}\n\t\t\tcmd++;\n\t\t}\n\t\tpi = pi->next;\n\t}\n#if 0\n\t/* Should be 0. If it isn't, it's a parse error */\n\tif (heredoc_cnt)\n\t\tbb_error_msg_and_die(\"heredoc BUG 2\");\n#endif\n\treturn 0;\n}",
        "parsed_output": "static int64_t\nprocess_heredocs(int count, int64_t **doc_list, int64_t context)\n{\n  const char *doc_content;\n  int64_t *current_doc;\n  int64_t *current_entry;\n  const char *new_content;\n  int entry_index;\n  int64_t *entry_list;\n\n  for (current_doc = *doc_list; current_doc && count; current_doc = (int64_t *)*current_doc)\n  {\n    entry_list = current_doc[5];\n    for (entry_index = 0; entry_index < *((int *)current_doc + 2); ++entry_index)\n    {\n      for (current_entry = *(int64_t **)(entry_list + 40); current_entry; current_entry = (int64_t *)*current_entry)\n      {\n        if (*((char *)current_entry + 24) == 4)\n        {\n          *((char *)current_entry + 24) = 5;\n          doc_content = (const char *)current_entry[1];\n          new_content = get_new_content(context, doc_content, *((int *)current_entry + 5));\n          if (!new_content)\n          {\n            report_error(\"unexpected EOF in here document\", doc_content);\n            return 1;\n          }\n          free((void *)current_entry[1]);\n          current_entry[1] = (int64_t)new_content;\n          --count;\n        }\n      }\n      entry_list += 48;\n    }\n  }\n  return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_482E12(int a1, __int64 **a2, __int64 a3)\n{\n  const char *v3; // rsi\n  __int64 v4; // rdx\n  __int64 v5; // rcx\n  __int64 v6; // r8\n  __int64 v7; // r9\n  const char *v11; // [rsp+28h] [rbp-28h]\n  __int64 *k; // [rsp+30h] [rbp-20h]\n  __int64 v13; // [rsp+38h] [rbp-18h]\n  int j; // [rsp+44h] [rbp-Ch]\n  __int64 *i; // [rsp+48h] [rbp-8h]\n\n  for ( i = *a2; i && a1; i = (__int64 *)*i )\n  {\n    v13 = i[5];\n    for ( j = 0; j < *((_DWORD *)i + 2); ++j )\n    {\n      for ( k = *(__int64 **)(v13 + 40); k; k = (__int64 *)*k )\n      {\n        if ( *((_BYTE *)k + 24) == 4 )\n        {\n          *((_BYTE *)k + 24) = 5;\n          v3 = (const char *)k[1];\n          v11 = sub_482CE1(a3, v3, *((_DWORD *)k + 5));\n          if ( !v11 )\n          {\n            sub_47FE8C((__int64)\"unexpected EOF in here document\", (__int64)v3, v4, v5, v6, v7);\n            return 1LL;\n          }\n          free((void *)k[1]);\n          k[1] = (__int64)v11;\n          --a1;\n        }\n      }\n      v13 += 48LL;\n    }\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl fetch_heredocs(int heredoc_cnt, parse_context *ctx, in_str *input)\n{\n  char *p; // [rsp+28h] [rbp-28h]\n  redir_struct *redir; // [rsp+30h] [rbp-20h]\n  command *cmd; // [rsp+38h] [rbp-18h]\n  int i; // [rsp+44h] [rbp-Ch]\n  pipe *pi; // [rsp+48h] [rbp-8h]\n\n  for ( pi = ctx->list_head; pi && heredoc_cnt; pi = pi->next )\n  {\n    cmd = pi->cmds;\n    for ( i = 0; i < pi->num_cmds; ++i )\n    {\n      for ( redir = cmd->redirects; redir; redir = redir->next )\n      {\n        if ( redir->rd_type == 4 )\n        {\n          redir->rd_type = 5;\n          p = fetch_till_str(input, redir->rd_filename, redir->rd_dup);\n          if ( !p )\n          {\n            syntax_error(\"unexpected EOF in here document\");\n            return 1;\n          }\n          free(redir->rd_filename);\n          redir->rd_filename = p;\n          --heredoc_cnt;\n        }\n      }\n      ++cmd;\n    }\n  }\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.6023579835891724,
        "similarity_score_baseline_stripped": 0.4830864667892456,
        "similarity_score_baseline_debug": 0.9334545731544495
    },
    {
        "func_name": "to_echo",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl is_char_class_member(Char_class char_class, unsigned __int8 c)\n{\n  int result; // [rsp+14h] [rbp-Ch]\n\n  switch ( char_class )\n  {\n    case CC_ALNUM:\n      result = (*__ctype_b_loc())[c] & 8;\n      break;\n    case CC_ALPHA:\n      result = (*__ctype_b_loc())[c] & 0x400;\n      break;\n    case CC_BLANK:\n      result = (*__ctype_b_loc())[c] & 1;\n      break;\n    case CC_CNTRL:\n      result = (*__ctype_b_loc())[c] & 2;\n      break;\n    case CC_DIGIT:\n      result = (*__ctype_b_loc())[c] & 0x800;\n      break;\n    case CC_GRAPH:\n      result = (*__ctype_b_loc())[c] & 0x8000;\n      break;\n    case CC_LOWER:\n      result = (*__ctype_b_loc())[c] & 0x200;\n      break;\n    case CC_PRINT:\n      result = (*__ctype_b_loc())[c] & 0x4000;\n      break;\n    case CC_PUNCT:\n      result = (*__ctype_b_loc())[c] & 4;\n      break;\n    case CC_SPACE:\n      result = (*__ctype_b_loc())[c] & 0x2000;\n      break;\n    case CC_UPPER:\n      result = (*__ctype_b_loc())[c] & 0x100;\n      break;\n    case CC_XDIGIT:\n      result = (*__ctype_b_loc())[c] & 0x1000;\n      break;\n    default:\n      abort();\n  }\n  return result != 0;\n}\n\n\n Revised code:\nstatic bool\nis_char_class_member (enum Char_class char_class, unsigned char c)\n{\n  int result;\n\n  switch (char_class)\n    {\n    case CC_ALNUM:\n      result = isalnum (c);\n      break;\n    case CC_ALPHA:\n      result = isalpha (c);\n      break;\n    case CC_BLANK:\n      result = isblank (c);\n      break;\n    case CC_CNTRL:\n      result = iscntrl (c);\n      break;\n    case CC_DIGIT:\n      result = isdigit (c);\n      break;\n    case CC_GRAPH:\n      result = isgraph (c);\n      break;\n    case CC_LOWER:\n      result = islower (c);\n      break;\n    case CC_PRINT:\n      result = isprint (c);\n      break;\n    case CC_PUNCT:\n      result = ispunct (c);\n      break;\n    case CC_SPACE:\n      result = isspace (c);\n      break;\n    case CC_UPPER:\n      result = isupper (c);\n      break;\n    case CC_XDIGIT:\n      result = isxdigit (c);\n      break;\n    default:\n      abort ();\n      break;\n    }\n\n  return !! result;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl format_address_std(uintmax_t address, char c)\n{\n  char *v2; // rax\n  char *v3; // rcx\n  char *v4; // rax\n  char *v5; // rax\n  const char *pbound; // [rsp+20h] [rbp-40h]\n  char *p; // [rsp+28h] [rbp-38h]\n  char buf[25]; // [rsp+30h] [rbp-30h] BYREF\n  char ca; // [rsp+57h] [rbp-9h]\n  uintmax_t addressa; // [rsp+58h] [rbp-8h]\n\n  addressa = address;\n  ca = c;\n  buf[24] = 0;\n  p = &buf[23];\n  buf[23] = c;\n  pbound = &buf[-address_pad_len + 23];\n  switch ( address_base )\n  {\n    case 8:\n      do\n      {\n        v2 = p--;\n        *(v2 - 1) = (addressa & 7) + 48;\n        addressa >>= 3;\n      }\n      while ( addressa );\n      break;\n    case 10:\n      do\n      {\n        v3 = p--;\n        *(v3 - 1) = addressa % 0xA + 48;\n        addressa /= 0xAuLL;\n      }\n      while ( addressa );\n      break;\n    case 16:\n      do\n      {\n        v4 = p--;\n        *(v4 - 1) = byte_4097D0[addressa & 0xF];\n        addressa >>= 4;\n      }\n      while ( addressa );\n      break;\n  }\n  while ( pbound < p )\n  {\n    v5 = p--;\n    *(v5 - 1) = 48;\n  }\n  fputs_unlocked(p, _bss_start);\n}\n\n\n Revised code:\nstatic void\nformat_address_std (uintmax_t address, char c)\n{\n  char buf[MAX_ADDRESS_LENGTH + 2];\n  char *p = buf + sizeof buf;\n  char const *pbound;\n\n  *--p = '\\0';\n  *--p = c;\n  pbound = p - address_pad_len;\n\n  /* Use a special case of the code for each base.  This is measurably\n     faster than generic code.  */\n  switch (address_base)\n    {\n    case 8:\n      do\n\t*--p = '0' + (address & 7);\n      while ((address >>= 3) != 0);\n      break;\n\n    case 10:\n      do\n\t*--p = '0' + (address % 10);\n      while ((address /= 10) != 0);\n      break;\n\n    case 16:\n      do\n\t*--p = \"0123456789abcdef\"[address & 15];\n      while ((address >>= 4) != 0);\n      break;\n    }\n\n  while (pbound < p)\n    *--p = '0';\n\n  fputs (p, stdout);\n}\n\n## Example:\n\n Input code:\nint __cdecl hextobin(unsigned __int8 c)\n{\n  int v2; // [rsp+10h] [rbp-4h]\n\n  switch ( c )\n  {\n    case 'A':\n    case 'a':\n      v2 = 10;\n      break;\n    case 'B':\n    case 'b':\n      v2 = 11;\n      break;\n    case 'C':\n    case 'c':\n      v2 = 12;\n      break;\n    case 'D':\n    case 'd':\n      v2 = 13;\n      break;\n    case 'E':\n    case 'e':\n      v2 = 14;\n      break;\n    case 'F':\n    case 'f':\n      v2 = 15;\n      break;\n    default:\n      v2 = c - 48;\n      break;\n  }\n  return v2;\n}\n\n\n Revised code:\nstatic int\nhextobin (unsigned char c)\n{\n  switch (c)\n    {\n    default: return c - '0';\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_44223D()\n{\n  __int64 result; // rax\n\n  if ( BYTE1(dest.c_oflag) == 0xFD )\n    return sub_441E67(252, 1);\n  result = BYTE1(dest.c_oflag);\n  if ( (_BYTE)result != 0xFE )\n  {\n    if ( (dest.c_oflag & 0x1000000) != 0 )\n    {\n      result = BYTE1(dest.c_oflag);\n      if ( (_BYTE)result == 0xFB )\n        return result;\n    }\n    else\n    {\n      result = BYTE1(dest.c_oflag);\n      if ( (_BYTE)result == 0xFC )\n        return result;\n    }\n    if ( BYTE2(dest.c_oflag) != 2 )\n      HIBYTE(dest.c_oflag) ^= 1u;\n    if ( (dest.c_oflag & 0x1000000) != 0 )\n      sub_441E67(253, 1);\n    else\n      sub_441E67(254, 1);\n    sub_4420CF();\n    return sub_409DAE(\"\\r\\n\");\n  }\n  return result;\n}\n",
        "output": "```c\nint process_output_flags()\n{\n  int result;\n\n  if ((dest.c_oflag >> 8) & 0xFF == 0xFD)\n    return call_function_A(252, 1);\n  result = (dest.c_oflag >> 8) & 0xFF;\n  if (result != 0xFE)\n  {\n    if (dest.c_oflag & 0x1000000)\n    {\n      if (result == 0xFB)\n        return result;\n    }\n    else\n    {\n      if (result == 0xFC)\n        return result;\n    }\n    if (((dest.c_oflag >> 16) & 0xFF) != 2)\n      dest.c_oflag ^= 0x1000000;\n    if (dest.c_oflag & 0x1000000)\n      call_function_A(253, 1);\n    else\n      call_function_A(254, 1);\n    call_function_B();\n    return call_function_C(\"\\r\\n\");\n  }\n  return result;\n}\n```",
        "source_code": "static void to_echo(void)\n{\n\t/* if server requests ECHO, don't agree */\n\tif (G.telwish == DO) {\n\t\tput_iac2(WONT, TELOPT_ECHO);\n\t\treturn;\n\t}\n\tif (G.telwish == DONT)\n\t\treturn;\n\n\tif (G.telflags & UF_ECHO) {\n\t\tif (G.telwish == WILL)\n\t\t\treturn;\n\t} else if (G.telwish == WONT)\n\t\treturn;\n\n\tif (G.charmode != CHM_OFF)\n\t\tG.telflags ^= UF_ECHO;\n\n\tif (G.telflags & UF_ECHO)\n\t\tput_iac2(DO, TELOPT_ECHO);\n\telse\n\t\tput_iac2(DONT, TELOPT_ECHO);\n\n\tsetConMode();\n\tfull_write1_str(\"\\r\\n\");  /* sudden modec */\n}",
        "parsed_output": "int process_output_flags()\n{\n  int result;\n\n  if ((dest.c_oflag >> 8) & 0xFF == 0xFD)\n    return call_function_A(252, 1);\n  result = (dest.c_oflag >> 8) & 0xFF;\n  if (result != 0xFE)\n  {\n    if (dest.c_oflag & 0x1000000)\n    {\n      if (result == 0xFB)\n        return result;\n    }\n    else\n    {\n      if (result == 0xFC)\n        return result;\n    }\n    if (((dest.c_oflag >> 16) & 0xFF) != 2)\n      dest.c_oflag ^= 0x1000000;\n    if (dest.c_oflag & 0x1000000)\n      call_function_A(253, 1);\n    else\n      call_function_A(254, 1);\n    call_function_B();\n    return call_function_C(\"\\r\\n\");\n  }\n  return result;\n}",
        "baseline_code_stripped": "__int64 sub_44223D()\n{\n  __int64 result; // rax\n\n  if ( BYTE1(dest.c_oflag) == 0xFD )\n    return sub_441E67(252, 1);\n  result = BYTE1(dest.c_oflag);\n  if ( (_BYTE)result != 0xFE )\n  {\n    if ( (dest.c_oflag & 0x1000000) != 0 )\n    {\n      result = BYTE1(dest.c_oflag);\n      if ( (_BYTE)result == 0xFB )\n        return result;\n    }\n    else\n    {\n      result = BYTE1(dest.c_oflag);\n      if ( (_BYTE)result == 0xFC )\n        return result;\n    }\n    if ( BYTE2(dest.c_oflag) != 2 )\n      HIBYTE(dest.c_oflag) ^= 1u;\n    if ( (dest.c_oflag & 0x1000000) != 0 )\n      sub_441E67(253, 1);\n    else\n      sub_441E67(254, 1);\n    sub_4420CF();\n    return sub_409DAE(\"\\r\\n\");\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl to_echo()\n{\n  if ( BYTE1(bb_common_bufsiz1.c_oflag) == 0xFD )\n  {\n    put_iac2(0xFCu, 1u);\n    return;\n  }\n  if ( BYTE1(bb_common_bufsiz1.c_oflag) != 0xFE )\n  {\n    if ( (bb_common_bufsiz1.c_oflag & 0x1000000) != 0 )\n    {\n      if ( BYTE1(bb_common_bufsiz1.c_oflag) == 0xFB )\n        return;\n    }\n    else if ( BYTE1(bb_common_bufsiz1.c_oflag) == 0xFC )\n    {\n      return;\n    }\n    if ( BYTE2(bb_common_bufsiz1.c_oflag) != 2 )\n      HIBYTE(bb_common_bufsiz1.c_oflag) ^= 1u;\n    if ( (bb_common_bufsiz1.c_oflag & 0x1000000) != 0 )\n      put_iac2(0xFDu, 1u);\n    else\n      put_iac2(0xFEu, 1u);\n    setConMode();\n    full_write1_str(\"\\r\\n\");\n  }\n}\n",
        "similarity_score_unixcoder": 0.5044278502464294,
        "similarity_score_baseline_stripped": 0.5056790709495544,
        "similarity_score_baseline_debug": 0.7075676918029785
    },
    {
        "func_name": "get_wait",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl detect_loop(item *k)\n{\n  item *tmp_0; // [rsp+8h] [rbp-28h]\n  item *tmp; // [rsp+10h] [rbp-20h]\n  successor **p; // [rsp+18h] [rbp-18h]\n\n  if ( k->count )\n  {\n    if ( loop )\n    {\n      for ( p = &k->top; *p; p = &(*p)->next )\n      {\n        if ( (*p)->suc == loop )\n        {\n          if ( !k->qlink )\n          {\n            k->qlink = loop;\n            loop = k;\n            return 0;\n          }\n          while ( loop )\n          {\n            tmp = loop->qlink;\n            fprintf(stderr, \"%s: %s\\n\", program_name, loop->str);\n            if ( loop == k )\n            {\n              --(*p)->suc->count;\n              *p = (*p)->next;\n              break;\n            }\n            loop->qlink = 0LL;\n            loop = tmp;\n          }\n          while ( loop )\n          {\n            tmp_0 = loop->qlink;\n            loop->qlink = 0LL;\n            loop = tmp_0;\n          }\n          return 1;\n        }\n      }\n    }\n    else\n    {\n      loop = k;\n    }\n  }\n  return 0;\n}\n\n\n Revised code:\nstatic bool\ndetect_loop (struct item *k)\n{\n  if (k->count > 0)\n    {\n      /* K does not have to be part of a cycle.  It is however part of\n\t a graph that contains a cycle.  */\n\n      if (loop == NULL)\n\t/* Start traversing the graph at K.  */\n\tloop = k;\n      else\n\t{\n\t  struct successor **p = &k->top;\n\n\t  while (*p)\n\t    {\n\t      if ((*p)->suc == loop)\n\t\t{\n\t\t  if (k->qlink)\n\t\t    {\n\t\t      /* We have found a loop.  Retrace our steps.  */\n\t\t      while (loop)\n\t\t\t{\n\t\t\t  struct item *tmp = loop->qlink;\n\n\t\t\t  fprintf (stderr, \"%s: %s\\n\", program_name,\n\t\t\t\t   loop->str);\n\n\t\t\t  /* Until we encounter K again.  */\n\t\t\t  if (loop == k)\n\t\t\t    {\n\t\t\t      /* Remove relation.  */\n\t\t\t      (*p)->suc->count--;\n\t\t\t      *p = (*p)->next;\n\t\t\t      break;\n\t\t\t    }\n\n\t\t\t  /* Tidy things up since we might have to\n                             detect another loop.  */\n\t\t\t  loop->qlink = NULL;\n\t\t\t  loop = tmp;\n\t\t\t}\n\n\t\t      while (loop)\n\t\t\t{\n\t\t\t  struct item *tmp = loop->qlink;\n\n\t\t\t  loop->qlink = NULL;\n\t\t\t  loop = tmp;\n\t\t\t}\n\n\t\t      /* Since we have found the loop, stop walking\n                         the tree.  */\n\t\t      return true;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      k->qlink = loop;\n\t\t      loop = k;\n\t\t      break;\n\t\t    }\n\t\t}\n\n\t      p = &(*p)->next;\n\t    }\n\t}\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_numbers(const char *fmt, long double first, long double step, long double last)\n{\n  long double x; // [rsp+20h] [rbp-60h]\n  long double i; // [rsp+30h] [rbp-50h]\n\n  for ( i = 0.0; ; i = i + 1.0 )\n  {\n    x = i * step + first;\n    if ( step >= 0.0 )\n      break;\n    if ( last > x )\n      goto LABEL_10;\nLABEL_7:\n    if ( i != 0.0 )\n      fputs_unlocked(separator, stdout);\n    printf(fmt);\n  }\n  if ( x <= last )\n    goto LABEL_7;\nLABEL_10:\n  if ( i != 0.0 )\n    fputs_unlocked(\"\\n\", stdout);\n}\n\n\n Revised code:\nstatic void\nprint_numbers (char const *fmt,\n\t       long double first, long double step, long double last)\n{\n  long double i;\n\n  for (i = 0; /* empty */; i++)\n    {\n      long double x = first + i * step;\n      if (step < 0 ? x < last : last < x)\n\tbreak;\n      if (i)\n\tfputs (separator, stdout);\n      printf (fmt, x);\n    }\n\n  if (i)\n    fputs (terminator, stdout);\n}\n\n## Example:\n\n Input code:\nbool __cdecl toarith(VALUE *v)\n{\n  intmax_t value; // [rsp+18h] [rbp-18h] BYREF\n  VALUE *va; // [rsp+20h] [rbp-10h]\n\n  va = v;\n  if ( v->type == integer )\n    return 1;\n  if ( v->type != string )\n    abort();\n  if ( !looks_like_integer(va->u.s) )\n    return 0;\n  if ( xstrtoimax(va->u.s, 0LL, 10, &value, 0LL) )\n    error(3, 34, \"%s\", va->u.s);\n  free(va->u.s);\n  va->u.i = value;\n  va->type = integer;\n  return 1;\n}\n\n\n Revised code:\nstatic bool\ntoarith (VALUE *v)\n{\n  switch (v->type)\n    {\n    case integer:\n      return true;\n    case string:\n      {\n\tintmax_t value;\n\n\tif (! looks_like_integer (v->u.s))\n\t  return false;\n\tif (xstrtoimax (v->u.s, NULL, 10, &value, NULL) != LONGINT_OK)\n\t  error (EXPR_FAILURE, ERANGE, \"%s\", v->u.s);\n\tfree (v->u.s);\n\tv->u.i = value;\n\tv->type = integer;\n\treturn true;\n      }\n    default:\n      abort ();\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_422081(const char *a1)\n{\n  if ( !strcasecmp(a1, \"none\") )\n    return 0xFFFFLL;\n  if ( !strcasecmp(a1, \"infinite\") )\n    return 0LL;\n  return sub_42205D((__int64)a1);\n}\n",
        "output": "static unsigned long\nparse_special_value (const char *str)\n{\n  if (strcasecmp (str, \"none\") == 0)\n    return ULONG_MAX;\n  if (strcasecmp (str, \"infinite\") == 0)\n    return 0;\n  return parse_value (str);\n}",
        "source_code": "static int get_wait(const char *arg)\n{\n\tif (strcasecmp(arg, STR_NONE) == 0)\n\t\treturn ASYNC_CLOSING_WAIT_NONE;\n\n\tif (strcasecmp(arg, STR_INFINITE) == 0)\n\t\treturn ASYNC_CLOSING_WAIT_INF;\n\n\treturn get_numeric(arg);\n}",
        "parsed_output": "static unsigned long\nparse_special_value (const char *str)\n{\n  if (strcasecmp (str, \"none\") == 0)\n    return ULONG_MAX;\n  if (strcasecmp (str, \"infinite\") == 0)\n    return 0;\n  return parse_value (str);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_422081(const char *a1)\n{\n  if ( !strcasecmp(a1, \"none\") )\n    return 0xFFFFLL;\n  if ( !strcasecmp(a1, \"infinite\") )\n    return 0LL;\n  return sub_42205D((__int64)a1);\n}\n",
        "baseline_code_debug": "int __cdecl get_wait(const char *arg)\n{\n  if ( !strcasecmp(arg, \"none\") )\n    return 0xFFFF;\n  if ( !strcasecmp(arg, \"infinite\") )\n    return 0;\n  return get_numeric(arg);\n}\n",
        "similarity_score_unixcoder": 0.5672760605812073,
        "similarity_score_baseline_stripped": 0.5291314721107483,
        "similarity_score_baseline_debug": 0.7402573227882385
    },
    {
        "func_name": "next_word",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl put_word(WORD *w)\n{\n  const char *v1; // rax\n  int n; // [rsp+Ch] [rbp-14h]\n  const char *s; // [rsp+10h] [rbp-10h]\n\n  s = w->text;\n  for ( n = w->length; n; --n )\n  {\n    v1 = s++;\n    putchar_unlocked(*v1);\n  }\n  out_column += w->length;\n}\n\n\n Revised code:\nstatic void\nput_word (WORD *w)\n{\n  const char *s;\n  int n;\n\n  s = w->text;\n  for (n = w->length; n != 0; n--)\n    putchar (*s++);\n  out_column += w->length;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl next_line_num()\n{\n  char v0; // cl\n  char *v1; // rax\n  char *v2; // rax\n  char *endp; // [rsp+0h] [rbp-8h]\n\n  endp = line_num_end;\n  while ( 1 )\n  {\n    v0 = (*endp)++;\n    if ( v0 < 57 )\n      break;\n    v1 = endp--;\n    *v1 = 48;\n    if ( endp < line_num_start )\n    {\n      if ( line_num_start <= line_buf )\n      {\n        line_buf[0] = 62;\n      }\n      else\n      {\n        v2 = line_num_start--;\n        *(v2 - 1) = 49;\n      }\n      if ( line_num_start < line_num_print )\n        --line_num_print;\n      return;\n    }\n  }\n}\n\n\n Revised code:\nstatic void\nnext_line_num (void)\n{\n  char *endp = line_num_end;\n  do\n    {\n      if ((*endp)++ < '9')\n\treturn;\n      *endp-- = '0';\n    }\n  while (endp >= line_num_start);\n  if (line_num_start > line_buf)\n    *--line_num_start = '1';\n  else\n    *line_buf = '>';\n  if (line_num_start < line_num_print)\n    line_num_print--;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl prfield(size_t n, const line *line)\n{\n  size_t len; // [rsp+18h] [rbp-18h]\n\n  if ( n >= line->nfields )\n  {\n    if ( empty_filler )\n      fputs_unlocked(empty_filler, stdout);\n  }\n  else\n  {\n    len = line->fields[n].len;\n    if ( len )\n    {\n      fwrite_unlocked(line->fields[n].beg, 1uLL, len, stdout);\n    }\n    else if ( empty_filler )\n    {\n      fputs_unlocked(empty_filler, stdout);\n    }\n  }\n}\n\n\n Revised code:\nstatic void\nprfield (size_t n, struct line const *line)\n{\n  size_t len;\n\n  if (n < line->nfields)\n    {\n      len = line->fields[n].len;\n      if (len)\n\tfwrite (line->fields[n].beg, 1, len, stdout);\n      else if (empty_filler)\n\tfputs (empty_filler, stdout);\n    }\n  else if (empty_filler)\n    fputs (empty_filler, stdout);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_432276(_BYTE **a1)\n{\n  int v2; // eax\n  char *s; // [rsp+10h] [rbp-10h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  s = sub_4093B4(*a1);\n  if ( !*s )\n    return 0LL;\n  v4 = strcspn(s, \" \\t\\n\");\n  if ( s[v4] )\n  {\n    v2 = v4++;\n    s[v2] = 0;\n  }\n  *a1 = sub_4093B4(&s[v4]);\n  return s;\n}\n",
        "output": "```c\nstatic char *\nsub_432276 (char **a1)\n{\n  char *s;\n  int length;\n\n  s = sub_4093B4(*a1);\n  if (!*s)\n    return NULL;\n  length = strcspn(s, \" \\t\\n\");\n  if (s[length])\n    s[length++] = '\\0';\n  *a1 = sub_4093B4(s + length);\n  return s;\n}\n```",
        "source_code": "static char *next_word(char **buf)\n{\n\tunsigned length;\n\tchar *word;\n\n\t/* Skip over leading whitespace */\n\tword = skip_whitespace(*buf);\n\n\t/* Stop on EOL */\n\tif (*word == '\\0')\n\t\treturn NULL;\n\n\t/* Find the length of this word (can't be 0) */\n\tlength = strcspn(word, \" \\t\\n\");\n\n\t/* Unless we are already at NUL, store NUL and advance */\n\tif (word[length] != '\\0')\n\t\tword[length++] = '\\0';\n\n\t*buf = skip_whitespace(word + length);\n\n\treturn word;\n}",
        "parsed_output": "static char *\nsub_432276 (char **a1)\n{\n  char *s;\n  int length;\n\n  s = sub_4093B4(*a1);\n  if (!*s)\n    return NULL;\n  length = strcspn(s, \" \\t\\n\");\n  if (s[length])\n    s[length++] = '\\0';\n  *a1 = sub_4093B4(s + length);\n  return s;\n}",
        "baseline_code_stripped": "char *__fastcall sub_432276(_BYTE **a1)\n{\n  int v2; // eax\n  char *s; // [rsp+10h] [rbp-10h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  s = sub_4093B4(*a1);\n  if ( !*s )\n    return 0LL;\n  v4 = strcspn(s, \" \\t\\n\");\n  if ( s[v4] )\n  {\n    v2 = v4++;\n    s[v2] = 0;\n  }\n  *a1 = sub_4093B4(&s[v4]);\n  return s;\n}\n",
        "baseline_code_debug": "char *__cdecl next_word(char **buf)\n{\n  unsigned int v2; // eax\n  char *word; // [rsp+10h] [rbp-10h]\n  unsigned int length; // [rsp+1Ch] [rbp-4h]\n\n  word = skip_whitespace(*buf);\n  if ( !*word )\n    return 0LL;\n  length = strcspn(word, \" \\t\\n\");\n  if ( word[length] )\n  {\n    v2 = length++;\n    word[v2] = 0;\n  }\n  *buf = skip_whitespace(&word[length]);\n  return word;\n}\n",
        "similarity_score_unixcoder": 0.6525688171386719,
        "similarity_score_baseline_stripped": 0.5629516243934631,
        "similarity_score_baseline_debug": 0.7935235500335693
    },
    {
        "func_name": "get_dhcp_packet_type",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl component_len(const char *f)\n{\n  bool v2; // [rsp+1h] [rbp-11h]\n  size_t len; // [rsp+2h] [rbp-10h]\n\n  for ( len = 1LL; ; ++len )\n  {\n    v2 = 0;\n    if ( f[len] != 47 )\n      v2 = f[len] != 0;\n    if ( !v2 )\n      break;\n  }\n  return len;\n}\n\n\n Revised code:\nstatic size_t\ncomponent_len (char const *f)\n{\n  size_t len;\n  for (len = 1; f[len] != '/' && f[len]; len++)\n    continue;\n  return len;\n}\n\n## Example:\n\n Input code:\nint __cdecl hextobin(unsigned __int8 c)\n{\n  int v2; // [rsp+10h] [rbp-4h]\n\n  switch ( c )\n  {\n    case 'A':\n    case 'a':\n      v2 = 10;\n      break;\n    case 'B':\n    case 'b':\n      v2 = 11;\n      break;\n    case 'C':\n    case 'c':\n      v2 = 12;\n      break;\n    case 'D':\n    case 'd':\n      v2 = 13;\n      break;\n    case 'E':\n    case 'e':\n      v2 = 14;\n      break;\n    case 'F':\n    case 'f':\n      v2 = 15;\n      break;\n    default:\n      v2 = c - 48;\n      break;\n  }\n  return v2;\n}\n\n\n Revised code:\nstatic int\nhextobin (unsigned char c)\n{\n  switch (c)\n    {\n    default: return c - '0';\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_456CD1(_BYTE *a1)\n{\n  unsigned __int8 *v2; // [rsp+18h] [rbp-8h]\n\n  if ( *a1 != 1 && *a1 != 2 )\n    return 0xFFFFFFFFLL;\n  v2 = (unsigned __int8 *)sub_4599BC(a1, 53LL);\n  if ( v2 )\n    return *v2;\n  else\n    return 0xFFFFFFFFLL;\n}\n",
        "output": "static __int64\nsub_456CD1 (unsigned char *a1)\n{\n  if (*a1 != 1 && *a1 != 2)\n    return -1;\n\n  unsigned char *result = sub_4599BC(a1, 53);\n  if (result)\n    return *result;\n  else\n    return -1;\n}",
        "source_code": "static int get_dhcp_packet_type(struct dhcp_packet *p)\n{\n\tuint8_t *op;\n\n\t/* it must be either a BOOTREQUEST or a BOOTREPLY */\n\tif (p->op != BOOTREQUEST && p->op != BOOTREPLY)\n\t\treturn -1;\n\t/* get message type option */\n\top = udhcp_get_option(p, DHCP_MESSAGE_TYPE);\n\tif (op != NULL)\n\t\treturn op[0];\n\treturn -1;\n}",
        "parsed_output": "static __int64\nsub_456CD1 (unsigned char *a1)\n{\n  if (*a1 != 1 && *a1 != 2)\n    return -1;\n\n  unsigned char *result = sub_4599BC(a1, 53);\n  if (result)\n    return *result;\n  else\n    return -1;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_456CD1(_BYTE *a1)\n{\n  unsigned __int8 *v2; // [rsp+18h] [rbp-8h]\n\n  if ( *a1 != 1 && *a1 != 2 )\n    return 0xFFFFFFFFLL;\n  v2 = (unsigned __int8 *)sub_4599BC(a1, 53LL);\n  if ( v2 )\n    return *v2;\n  else\n    return 0xFFFFFFFFLL;\n}\n",
        "baseline_code_debug": "int __cdecl get_dhcp_packet_type(dhcp_packet *p)\n{\n  uint8_t *op; // [rsp+18h] [rbp-8h]\n\n  if ( p->op != 1 && p->op != 2 )\n    return -1;\n  op = udhcp_get_option(p, 53);\n  if ( op )\n    return *op;\n  else\n    return -1;\n}\n",
        "similarity_score_unixcoder": 0.43078917264938354,
        "similarity_score_baseline_stripped": 0.4489782154560089,
        "similarity_score_baseline_debug": 0.80520099401474
    },
    {
        "func_name": "get_var",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_long_long(size_t n_bytes, const void *block, const char *fmt_string)\n{\n  _QWORD *v3; // rax\n  size_t i; // [rsp+8h] [rbp-28h]\n\n  for ( i = n_bytes >> 3; i; --i )\n  {\n    v3 = block;\n    block = (char *)block + 8;\n    printf(fmt_string, *v3);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_long_long (size_t n_bytes, void const *block, char const *fmt_string)\n{\n  unsigned_long_long_int const *p = block;\n  size_t i;\n  for (i = n_bytes / sizeof *p; i != 0; i--)\n    printf (fmt_string, *p++);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_long(size_t n_bytes, const void *block, const char *fmt_string)\n{\n  _QWORD *v3; // rax\n  size_t i; // [rsp+8h] [rbp-28h]\n\n  for ( i = n_bytes >> 3; i; --i )\n  {\n    v3 = block;\n    block = (char *)block + 8;\n    printf(fmt_string, *v3);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_long (size_t n_bytes, void const *block, char const *fmt_string)\n{\n  unsigned long int const *p = block;\n  size_t i;\n  for (i = n_bytes / sizeof *p; i != 0; i--)\n    printf (fmt_string, *p++);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4317F6(const char *a1, size_t a2, __int64 a3)\n{\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  if ( !(unsigned int)sub_4317A8(a1, \"iface\", a2) )\n    return *(_QWORD *)(a3 + 16);\n  if ( !(unsigned int)sub_4317A8(a1, \"label\", a2) )\n    return *(_QWORD *)(a3 + 16);\n  for ( i = 0; i < *(_DWORD *)(a3 + 24); ++i )\n  {\n    if ( !(unsigned int)sub_4317A8(a1, *(const char **)(16LL * i + *(_QWORD *)(a3 + 32)), a2) )\n      return *(_QWORD *)(16LL * i + *(_QWORD *)(a3 + 32) + 8);\n  }\n  return 0LL;\n}\n",
        "output": "```c\nstatic __int64\nget_interface_property(const char *property_name, size_t name_length, __int64 interface_descriptor)\n{\n  int i;\n  __int64 default_value = *(__int64 *)(interface_descriptor + 16);\n  __int64 *properties = *(__int64 **)(interface_descriptor + 32);\n  int property_count = *(__int32 *)(interface_descriptor + 24);\n\n  if (!compare_strings(property_name, \"iface\", name_length))\n    return default_value;\n  if (!compare_strings(property_name, \"label\", name_length))\n    return default_value;\n\n  for (i = 0; i < property_count; ++i)\n  {\n    const char *current_property_name = *(const char **)(properties + 2 * i);\n    if (!compare_strings(property_name, current_property_name, name_length))\n      return *(properties + 2 * i + 1);\n  }\n\n  return 0;\n}\n```",
        "source_code": "static char *get_var(const char *id, size_t idlen, struct interface_defn_t *ifd)\n{\n\tint i;\n\n\tif (strncmpz(id, \"iface\", idlen) == 0) {\n\t\t// ubuntu's ifup doesn't do this:\n\t\t//static char *label_buf;\n\t\t//char *result;\n\t\t//free(label_buf);\n\t\t//label_buf = xstrdup(ifd->iface);\n\t\t// Remove virtual iface suffix\n\t\t//result = strchrnul(label_buf, ':');\n\t\t//*result = '\\0';\n\t\t//return label_buf;\n\n\t\treturn ifd->iface;\n\t}\n\tif (strncmpz(id, \"label\", idlen) == 0) {\n\t\treturn ifd->iface;\n\t}\n\tfor (i = 0; i < ifd->n_options; i++) {\n\t\tif (strncmpz(id, ifd->option[i].name, idlen) == 0) {\n\t\t\treturn ifd->option[i].value;\n\t\t}\n\t}\n\treturn NULL;\n}",
        "parsed_output": "static __int64\nget_interface_property(const char *property_name, size_t name_length, __int64 interface_descriptor)\n{\n  int i;\n  __int64 default_value = *(__int64 *)(interface_descriptor + 16);\n  __int64 *properties = *(__int64 **)(interface_descriptor + 32);\n  int property_count = *(__int32 *)(interface_descriptor + 24);\n\n  if (!compare_strings(property_name, \"iface\", name_length))\n    return default_value;\n  if (!compare_strings(property_name, \"label\", name_length))\n    return default_value;\n\n  for (i = 0; i < property_count; ++i)\n  {\n    const char *current_property_name = *(const char **)(properties + 2 * i);\n    if (!compare_strings(property_name, current_property_name, name_length))\n      return *(properties + 2 * i + 1);\n  }\n\n  return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4317F6(const char *a1, size_t a2, __int64 a3)\n{\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  if ( !(unsigned int)sub_4317A8(a1, \"iface\", a2) )\n    return *(_QWORD *)(a3 + 16);\n  if ( !(unsigned int)sub_4317A8(a1, \"label\", a2) )\n    return *(_QWORD *)(a3 + 16);\n  for ( i = 0; i < *(_DWORD *)(a3 + 24); ++i )\n  {\n    if ( !(unsigned int)sub_4317A8(a1, *(const char **)(16LL * i + *(_QWORD *)(a3 + 32)), a2) )\n      return *(_QWORD *)(16LL * i + *(_QWORD *)(a3 + 32) + 8);\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "char *__cdecl get_var(const char *id, size_t idlen, interface_defn_t *ifd)\n{\n  int i; // [rsp+2Ch] [rbp-4h]\n\n  if ( !strncmpz(id, \"iface\", idlen) )\n    return ifd->iface;\n  if ( !strncmpz(id, \"label\", idlen) )\n    return ifd->iface;\n  for ( i = 0; i < ifd->n_options; ++i )\n  {\n    if ( !strncmpz(id, ifd->option[i].name, idlen) )\n      return ifd->option[i].value;\n  }\n  return 0LL;\n}\n",
        "similarity_score_unixcoder": 0.6400763392448425,
        "similarity_score_baseline_stripped": 0.5055967569351196,
        "similarity_score_baseline_debug": 0.8993756175041199
    },
    {
        "func_name": "fix_partition_table_order",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nvoid __cdecl do_decode(FILE *in, FILE *out, bool ignore_garbage)\n{\n  char *v3; // rax\n  size_t v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  int v7; // [rsp+Ch] [rbp-1C64h]\n  char v8; // [rsp+13h] [rbp-1C5Dh]\n  int errnum; // [rsp+14h] [rbp-1C5Ch]\n  bool v10; // [rsp+27h] [rbp-1C49h]\n  size_t v11; // [rsp+30h] [rbp-1C40h]\n  size_t outlen; // [rsp+38h] [rbp-1C38h] BYREF\n  bool v13; // [rsp+47h] [rbp-1C29h]\n  size_t inlen; // [rsp+48h] [rbp-1C28h]\n  char outa[3072]; // [rsp+50h] [rbp-1C20h] BYREF\n  char ina[4111]; // [rsp+C50h] [rbp-1020h] BYREF\n  bool v17; // [rsp+1C5Fh] [rbp-11h]\n  FILE *v18; // [rsp+1C60h] [rbp-10h]\n  FILE *v19; // [rsp+1C68h] [rbp-8h]\n\n  v19 = in;\n  v18 = out;\n  v17 = ignore_garbage;\n  do\n  {\n    inlen = 0LL;\n    do\n    {\n      outlen = fread_unlocked(&ina[inlen], 1uLL, 4096 - inlen, v19);\n      if ( v17 )\n      {\n        v11 = 0LL;\n        while ( 1 )\n        {\n          v10 = 0;\n          if ( outlen )\n            v10 = v11 < outlen;\n          if ( !v10 )\n            break;\n          if ( isbase64(ina[v11 + inlen]) || ina[v11 + inlen] == 61 )\n            ++v11;\n          else\n            memmove(&ina[inlen + v11], &ina[inlen + 1 + v11], --outlen - v11);\n        }\n      }\n      inlen += outlen;\n      if ( ferror_unlocked(v19) )\n      {\n        errnum = *__errno_location();\n        v3 = gettext(\"read error\");\n        error(1, errnum, v3);\n      }\n      v8 = 0;\n      if ( inlen < 0x1000 )\n        v8 = ~(feof_unlocked(v19) != 0);\n    }\n    while ( (v8 & 1) != 0 );\n    outlen = 3072LL;\n    v13 = base64_decode(ina, inlen, outa, &outlen);\n    v4 = fwrite_unlocked(outa, 1uLL, outlen, v18);\n    if ( v4 < outlen )\n    {\n      v7 = *__errno_location();\n      v5 = gettext(\"write error\");\n      error(1, v7, v5);\n    }\n    if ( !v13 )\n    {\n      v6 = gettext(\"invalid input\");\n      error(1, 0, v6);\n    }\n  }\n  while ( !feof_unlocked(v19) );\n}\n\n\n Revised code:\nstatic void\ndo_decode (FILE *in, FILE *out, bool ignore_garbage)\n{\n  char inbuf[B64BLOCKSIZE];\n  char outbuf[BLOCKSIZE];\n  size_t sum;\n\n  do\n    {\n      bool ok;\n      size_t n;\n\n      sum = 0;\n      do\n\t{\n\t  n = fread (inbuf + sum, 1, B64BLOCKSIZE - sum, in);\n\n\t  if (ignore_garbage)\n\t    {\n\t      size_t i;\n\t      for (i = 0; n > 0 && i < n;)\n\t\tif (isbase64 (inbuf[sum + i]) || inbuf[sum + i] == '=')\n\t\t  i++;\n\t\telse\n\t\t  memmove (inbuf + sum + i, inbuf + sum + i + 1, --n - i);\n\t    }\n\n\t  sum += n;\n\n\t  if (ferror (in))\n\t    error (EXIT_FAILURE, errno, _(\"read error\"));\n\t}\n      while (sum < B64BLOCKSIZE && !feof (in));\n\n      n = BLOCKSIZE;\n      ok = base64_decode (inbuf, sum, outbuf, &n);\n\n      if (fwrite (outbuf, 1, n, out) < n)\n\terror (EXIT_FAILURE, errno, _(\"write error\"));\n\n      if (!ok)\n\terror (EXIT_FAILURE, 0, _(\"invalid input\"));\n    }\n  while (!feof (in));\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint sub_4932AD()\n{\n  char *v1; // rax\n  __int64 v2; // rdx\n  _QWORD *v3; // rcx\n  _QWORD *v4; // rcx\n  __int64 v5; // [rsp+0h] [rbp-50h]\n  __int64 v6; // [rsp+8h] [rbp-48h]\n  int v7; // [rsp+1Ch] [rbp-34h] BYREF\n  _QWORD *v8; // [rsp+20h] [rbp-30h]\n  _QWORD *v9; // [rsp+28h] [rbp-28h]\n  __int64 v10; // [rsp+30h] [rbp-20h]\n  char *v11; // [rsp+38h] [rbp-18h]\n  __int64 v12; // [rsp+40h] [rbp-10h]\n  int v13; // [rsp+4Ch] [rbp-4h]\n\n  if ( !(unsigned int)sub_492E03(0LL) )\n    return puts(\"Ordering is already correct\\n\");\n  while ( 1 )\n  {\n    v13 = sub_492E03(&v7);\n    if ( !v13 || v13 > 3 )\n      break;\n    v12 = (__int64)qword_75D408 + 40 * v13 + 2504;\n    v1 = (char *)qword_75D408 + 40 * v7 + 2496;\n    v11 = v1 + 8;\n    v10 = *((_QWORD *)qword_75D408 + 5 * v13 + 314);\n    *((_QWORD *)qword_75D408 + 5 * v13 + 314) = *((_QWORD *)v1 + 2);\n    *((_QWORD *)v11 + 1) = v10;\n    v9 = *(_QWORD **)v12;\n    v8 = *(_QWORD **)v11;\n    v5 = *v9;\n    v6 = v9[1];\n    v2 = v8[1];\n    v3 = v9;\n    *v9 = *v8;\n    v3[1] = v2;\n    v4 = v8;\n    *v8 = v5;\n    v4[1] = v6;\n    v11[32] = 1;\n    *(_BYTE *)(v12 + 32) = v11[32];\n  }\n  if ( v13 )\n    sub_492ED3();\n  return puts(\"Done.\");\n}\n",
        "output": "```c\nstatic int\nswap_elements()\n{\n  int index; // Temporary variable to hold an index\n  int *p_index; // Pointer to an index\n  __int64 *p_element; // Pointer to an element\n  __int64 temp_element; // Temporary variable to hold an element\n  int result; // Result of the sub_492E03 function\n  int swapped; // Flag to indicate if a swap occurred\n\n  if (!sub_492E03(0LL))\n    return puts(\"Ordering is already correct\\n\");\n\n  while (1)\n  {\n    result = sub_492E03(&index);\n    if (!result || result > 3)\n      break;\n\n    p_index = &array_base[result];\n    p_element = &array_base[index];\n\n    // Swap the elements\n    temp_element = p_element[0];\n    p_element[0] = p_index[0];\n    p_index[0] = temp_element;\n\n    temp_element = p_element[1];\n    p_element[1] = p_index[1];\n    p_index[1] = temp_element;\n\n    // Set the swapped flag\n    p_element[4] = 1;\n    p_index[4] = p_element[4];\n  }\n\n  if (result)\n    sub_492ED3();\n\n  return puts(\"Done.\");\n}\n```",
        "source_code": "static void\nfix_partition_table_order(void)\n{\n\tstruct pte *pei, *pek;\n\tint i,k;\n\n\tif (!wrong_p_order(NULL)) {\n\t\tprintf(\"Ordering is already correct\\n\\n\");\n\t\treturn;\n\t}\n\n\twhile ((i = wrong_p_order(&k)) != 0 && i < 4) {\n\t\t/* partition i should have come earlier, move it */\n\t\t/* We have to move data in the MBR */\n\t\tstruct partition *pi, *pk, *pe, pbuf;\n\t\tpei = &ptes[i];\n\t\tpek = &ptes[k];\n\n\t\tpe = pei->ext_pointer;\n\t\tpei->ext_pointer = pek->ext_pointer;\n\t\tpek->ext_pointer = pe;\n\n\t\tpi = pei->part_table;\n\t\tpk = pek->part_table;\n\n\t\tmemmove(&pbuf, pi, sizeof(struct partition));\n\t\tmemmove(pi, pk, sizeof(struct partition));\n\t\tmemmove(pk, &pbuf, sizeof(struct partition));\n\n\t\tpei->changed = pek->changed = 1;\n\t}\n\n\tif (i)\n\t\tfix_chain_of_logicals();\n\n\tprintf(\"Done.\\n\");\n}",
        "parsed_output": "static int\nswap_elements()\n{\n  int index; // Temporary variable to hold an index\n  int *p_index; // Pointer to an index\n  __int64 *p_element; // Pointer to an element\n  __int64 temp_element; // Temporary variable to hold an element\n  int result; // Result of the sub_492E03 function\n  int swapped; // Flag to indicate if a swap occurred\n\n  if (!sub_492E03(0LL))\n    return puts(\"Ordering is already correct\\n\");\n\n  while (1)\n  {\n    result = sub_492E03(&index);\n    if (!result || result > 3)\n      break;\n\n    p_index = &array_base[result];\n    p_element = &array_base[index];\n\n    // Swap the elements\n    temp_element = p_element[0];\n    p_element[0] = p_index[0];\n    p_index[0] = temp_element;\n\n    temp_element = p_element[1];\n    p_element[1] = p_index[1];\n    p_index[1] = temp_element;\n\n    // Set the swapped flag\n    p_element[4] = 1;\n    p_index[4] = p_element[4];\n  }\n\n  if (result)\n    sub_492ED3();\n\n  return puts(\"Done.\");\n}",
        "baseline_code_stripped": "int sub_4932AD()\n{\n  char *v1; // rax\n  __int64 v2; // rdx\n  _QWORD *v3; // rcx\n  _QWORD *v4; // rcx\n  __int64 v5; // [rsp+0h] [rbp-50h]\n  __int64 v6; // [rsp+8h] [rbp-48h]\n  int v7; // [rsp+1Ch] [rbp-34h] BYREF\n  _QWORD *v8; // [rsp+20h] [rbp-30h]\n  _QWORD *v9; // [rsp+28h] [rbp-28h]\n  __int64 v10; // [rsp+30h] [rbp-20h]\n  char *v11; // [rsp+38h] [rbp-18h]\n  __int64 v12; // [rsp+40h] [rbp-10h]\n  int v13; // [rsp+4Ch] [rbp-4h]\n\n  if ( !(unsigned int)sub_492E03(0LL) )\n    return puts(\"Ordering is already correct\\n\");\n  while ( 1 )\n  {\n    v13 = sub_492E03(&v7);\n    if ( !v13 || v13 > 3 )\n      break;\n    v12 = (__int64)qword_75D408 + 40 * v13 + 2504;\n    v1 = (char *)qword_75D408 + 40 * v7 + 2496;\n    v11 = v1 + 8;\n    v10 = *((_QWORD *)qword_75D408 + 5 * v13 + 314);\n    *((_QWORD *)qword_75D408 + 5 * v13 + 314) = *((_QWORD *)v1 + 2);\n    *((_QWORD *)v11 + 1) = v10;\n    v9 = *(_QWORD **)v12;\n    v8 = *(_QWORD **)v11;\n    v5 = *v9;\n    v6 = v9[1];\n    v2 = v8[1];\n    v3 = v9;\n    *v9 = *v8;\n    v3[1] = v2;\n    v4 = v8;\n    *v8 = v5;\n    v4[1] = v6;\n    v11[32] = 1;\n    *(_BYTE *)(v12 + 32) = v11[32];\n  }\n  if ( v13 )\n    sub_492ED3();\n  return puts(\"Done.\");\n}\n",
        "baseline_code_debug": "void __cdecl fix_partition_table_order()\n{\n  char *v0; // rax\n  __int64 v1; // rdx\n  partition *v2; // rcx\n  partition pbuf; // [rsp+0h] [rbp-50h]\n  int k; // [rsp+1Ch] [rbp-34h] BYREF\n  partition *pk; // [rsp+20h] [rbp-30h]\n  partition *pi; // [rsp+28h] [rbp-28h]\n  partition *pe; // [rsp+30h] [rbp-20h]\n  pte *pek; // [rsp+38h] [rbp-18h]\n  pte *pei; // [rsp+40h] [rbp-10h]\n  int i; // [rsp+4Ch] [rbp-4h]\n\n  if ( wrong_p_order(0LL) )\n  {\n    while ( 1 )\n    {\n      i = wrong_p_order(&k);\n      if ( !i || i > 3 )\n        break;\n      pei = (pte *)&ptr_to_globals[8].line_buf[40 * i + 44];\n      v0 = &ptr_to_globals[8].line_buf[40 * k + 36];\n      pek = (pte *)(v0 + 8);\n      pe = *(partition **)&ptr_to_globals[8].line_buf[40 * i + 52];\n      *(_QWORD *)&ptr_to_globals[8].line_buf[40 * i + 52] = *((_QWORD *)v0 + 2);\n      pek->ext_pointer = pe;\n      pi = pei->part_table;\n      pk = pek->part_table;\n      pbuf = *pi;\n      v1 = *(_QWORD *)pk->start4;\n      v2 = pi;\n      *(_QWORD *)&pi->boot_ind = *(_QWORD *)&pk->boot_ind;\n      *(_QWORD *)v2->start4 = v1;\n      *pk = pbuf;\n      pek->changed = 1;\n      pei->changed = pek->changed;\n    }\n    if ( i )\n      fix_chain_of_logicals();\n    puts(\"Done.\");\n  }\n  else\n  {\n    puts(\"Ordering is already correct\\n\");\n  }\n}\n",
        "similarity_score_unixcoder": 0.6602740287780762,
        "similarity_score_baseline_stripped": 0.46154457330703735,
        "similarity_score_baseline_debug": 0.7745316028594971
    },
    {
        "func_name": "raise_error_unexpected_syntax",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl getoptarg(char *arg, char switch_char, char *character, int *number)\n{\n  char *v4; // rax\n  const char *v5; // rax\n  unsigned int v6; // [rsp+Ch] [rbp-34h]\n  const char *format; // [rsp+10h] [rbp-30h]\n  __int64 tmp_long; // [rsp+18h] [rbp-28h] BYREF\n  int *numbera; // [rsp+20h] [rbp-20h]\n  char *charactera; // [rsp+28h] [rbp-18h]\n  char switch_chara; // [rsp+37h] [rbp-9h]\n  char *arga; // [rsp+38h] [rbp-8h]\n\n  arga = arg;\n  switch_chara = switch_char;\n  charactera = character;\n  numbera = number;\n  if ( (unsigned int)(*arg - 48) > 9 )\n  {\n    v4 = arga++;\n    *charactera = *v4;\n  }\n  if ( *arga )\n  {\n    if ( xstrtol(arga, 0LL, 10, &tmp_long, \"\") || tmp_long <= 0 || tmp_long > 0x7FFFFFFF )\n    {\n      format = gettext(\"`-%c' extra characters or invalid number in the argument: %s\");\n      v6 = switch_chara;\n      v5 = quote(arga);\n      error(0, 0, format, v6, v5);\n      usage(1);\n    }\n    *numbera = tmp_long;\n  }\n}\n\n\n Revised code:\nstatic void\ngetoptarg (char *arg, char switch_char, char *character, int *number)\n{\n  if (!ISDIGIT (*arg))\n    *character = *arg++;\n  if (*arg)\n    {\n      long int tmp_long;\n      if (xstrtol (arg, NULL, 10, &tmp_long, \"\") != LONGINT_OK\n\t  || tmp_long <= 0 || tmp_long > INT_MAX)\n\t{\n\t  error (0, 0,\n\t     _(\"`-%c' extra characters or invalid number in the argument: %s\"),\n\t\t switch_char, quote (arg));\n\t  usage (EXIT_FAILURE);\n\t}\n      *number = tmp_long;\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall __noreturn sub_47B5AB(int a1)\n{\n  char *v1; // rax\n  const char *v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // rax\n  char v8[16]; // [rsp+10h] [rbp-60h] BYREF\n  char s[76]; // [rsp+20h] [rbp-50h] BYREF\n  int v10; // [rsp+6Ch] [rbp-4h]\n\n  v1 = sub_47B556(v8, byte_75B05C);\n  v2 = \"unexpected %s\";\n  v10 = sprintf(s, \"unexpected %s\", v1);\n  if ( a1 >= 0 )\n  {\n    v7 = sub_47B556(v8, a1);\n    v2 = \" (expecting %s)\";\n    sprintf(&s[v10], \" (expecting %s)\", v7);\n  }\n  sub_46E514((__int64)s, (__int64)v2, v3, v4, v5, v6);\n}\n",
        "output": "```c\nstatic void\nfatal_error_with_context (int context)\n{\n  char context_str[16];\n  char error_message[76];\n  int message_length;\n\n  sub_47B556(context_str, byte_75B05C);\n  message_length = sprintf(error_message, \"unexpected %s\", context_str);\n  if (context >= 0)\n    {\n      char *context_desc = sub_47B556(context_str, context);\n      sprintf(&error_message[message_length], \" (expecting %s)\", context_desc);\n    }\n  sub_46E514(error_message);\n}\n```",
        "source_code": "static void\nraise_error_unexpected_syntax(int token)\n{\n\tchar msg[64];\n\tchar buf[16];\n\tint l;\n\n\tl = sprintf(msg, \"unexpected %s\", tokname(buf, lasttoken));\n\tif (token >= 0)\n\t\tsprintf(msg + l, \" (expecting %s)\", tokname(buf, token));\n\traise_error_syntax(msg);\n\t/* NOTREACHED */\n}",
        "parsed_output": "static void\nfatal_error_with_context (int context)\n{\n  char context_str[16];\n  char error_message[76];\n  int message_length;\n\n  sub_47B556(context_str, byte_75B05C);\n  message_length = sprintf(error_message, \"unexpected %s\", context_str);\n  if (context >= 0)\n    {\n      char *context_desc = sub_47B556(context_str, context);\n      sprintf(&error_message[message_length], \" (expecting %s)\", context_desc);\n    }\n  sub_46E514(error_message);\n}",
        "baseline_code_stripped": "void __fastcall __noreturn sub_47B5AB(int a1)\n{\n  char *v1; // rax\n  const char *v2; // rsi\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // rax\n  char v8[16]; // [rsp+10h] [rbp-60h] BYREF\n  char s[76]; // [rsp+20h] [rbp-50h] BYREF\n  int v10; // [rsp+6Ch] [rbp-4h]\n\n  v1 = sub_47B556(v8, byte_75B05C);\n  v2 = \"unexpected %s\";\n  v10 = sprintf(s, \"unexpected %s\", v1);\n  if ( a1 >= 0 )\n  {\n    v7 = sub_47B556(v8, a1);\n    v2 = \" (expecting %s)\";\n    sprintf(&s[v10], \" (expecting %s)\", v7);\n  }\n  sub_46E514((__int64)s, (__int64)v2, v3, v4, v5, v6);\n}\n",
        "baseline_code_debug": "void __cdecl __noreturn raise_error_unexpected_syntax(int token)\n{\n  const char *v1; // rax\n  const char *v2; // rax\n  char buf[16]; // [rsp+10h] [rbp-60h] BYREF\n  char msg[64]; // [rsp+20h] [rbp-50h] BYREF\n  int l; // [rsp+6Ch] [rbp-4h]\n\n  v1 = tokname(buf, lasttoken[0]);\n  l = sprintf(msg, \"unexpected %s\", v1);\n  if ( token >= 0 )\n  {\n    v2 = tokname(buf, token);\n    sprintf(&msg[l], \" (expecting %s)\", v2);\n  }\n  raise_error_syntax(msg);\n}\n",
        "similarity_score_unixcoder": 0.6319774389266968,
        "similarity_score_baseline_stripped": 0.4870107173919678,
        "similarity_score_baseline_debug": 0.797203004360199
    },
    {
        "func_name": "nextword",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl print_double(size_t n_bytes, const void *block, const char *fmt_string)\n{\n  double *v3; // rax\n  size_t i; // [rsp+8h] [rbp-28h]\n\n  for ( i = n_bytes >> 3; i; --i )\n  {\n    v3 = (double *)block;\n    block = (char *)block + 8;\n    printf(fmt_string, *v3);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_double (size_t n_bytes, void const *block, char const *fmt_string)\n{\n  double const *p = block;\n  size_t i;\n  for (i = n_bytes / sizeof *p; i != 0; i--)\n    printf (fmt_string, *p++);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_int(size_t n_bytes, const void *block, const char *fmt_string)\n{\n  unsigned int *v3; // rax\n  size_t i; // [rsp+8h] [rbp-28h]\n\n  for ( i = n_bytes >> 2; i; --i )\n  {\n    v3 = (unsigned int *)block;\n    block = (char *)block + 4;\n    printf(fmt_string, *v3);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_int (size_t n_bytes, void const *block, char const *fmt_string)\n{\n  unsigned int const *p = block;\n  size_t i;\n  for (i = n_bytes / sizeof *p; i != 0; i--)\n    printf (fmt_string, *p++);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_long(size_t n_bytes, const void *block, const char *fmt_string)\n{\n  _QWORD *v3; // rax\n  size_t i; // [rsp+8h] [rbp-28h]\n\n  for ( i = n_bytes >> 3; i; --i )\n  {\n    v3 = block;\n    block = (char *)block + 8;\n    printf(fmt_string, *v3);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_long (size_t n_bytes, void const *block, char const *fmt_string)\n{\n  unsigned long int const *p = block;\n  size_t i;\n  for (i = n_bytes / sizeof *p; i != 0; i--)\n    printf (fmt_string, *p++);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4DC55F(__int64 *a1)\n{\n  _BYTE *v1; // rax\n  __int64 v3; // [rsp+10h] [rbp-8h]\n\n  v3 = *a1;\n  do\n    v1 = (_BYTE *)(*a1)++;\n  while ( *v1 );\n  return v3;\n}\n",
        "output": "```c\nstatic size_t\nsub_4DC55F(char *str)\n{\n  char *start = str;\n  while (*str)\n    str++;\n  return str - start;\n}\n```",
        "source_code": "static char *nextword(char **s)\n{\n\tchar *p = *s;\n\twhile (*(*s)++ != '\\0')\n\t\tcontinue;\n\treturn p;\n}",
        "parsed_output": "static size_t\nsub_4DC55F(char *str)\n{\n  char *start = str;\n  while (*str)\n    str++;\n  return str - start;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4DC55F(__int64 *a1)\n{\n  _BYTE *v1; // rax\n  __int64 v3; // [rsp+10h] [rbp-8h]\n\n  v3 = *a1;\n  do\n    v1 = (_BYTE *)(*a1)++;\n  while ( *v1 );\n  return v3;\n}\n",
        "baseline_code_debug": "char *__cdecl nextword(char **s)\n{\n  char *v1; // rax\n  char *p; // [rsp+10h] [rbp-8h]\n\n  p = *s;\n  do\n    v1 = (*s)++;\n  while ( *v1 );\n  return p;\n}\n",
        "similarity_score_unixcoder": 0.5974034070968628,
        "similarity_score_baseline_stripped": 0.4702625572681427,
        "similarity_score_baseline_debug": 0.7108122110366821
    },
    {
        "func_name": "recordregion",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_occurs(const void *void_first, const void *void_second)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h]\n  int value; // [rsp+1Ch] [rbp-14h]\n\n  value = compare_words(void_first, void_second);\n  if ( value )\n    LODWORD(v3) = value;\n  else\n    return *(_QWORD *)void_first - *(_QWORD *)void_second;\n  return v3;\n}\n\n\n Revised code:\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return value == 0 ? first->key.start - second->key.start : value;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nvoid __cdecl fillpattern(int type, unsigned __int8 *r, size_t size)\n{\n  size_t i; // [rsp+10h] [rbp-20h]\n  size_t ia; // [rsp+10h] [rbp-20h]\n\n  *r = (type & 0xFFF | ((type & 0xFFFu) << 12)) >> 4;\n  r[1] = (unsigned __int16)(type & 0xFFF | ((type & 0xFFF) << 12)) >> 8;\n  r[2] = type;\n  for ( i = 3LL; i < size >> 1; i *= 2LL )\n    memcpy(&r[i], r, i);\n  if ( i < size )\n    memcpy(&r[i], r, size - i);\n  if ( (type & 0x1000) != 0 )\n  {\n    for ( ia = 0LL; ia < size; ia += 512LL )\n      r[ia] ^= 0x80u;\n  }\n}\n\n\n Revised code:\nstatic void\nfillpattern (int type, unsigned char *r, size_t size)\n{\n  size_t i;\n  unsigned int bits = type & 0xfff;\n\n  bits |= bits << 12;\n  r[0] = (bits >> 4) & 255;\n  r[1] = (bits >> 8) & 255;\n  r[2] = bits & 255;\n  for (i = 3; i < size / 2; i *= 2)\n    memcpy (r + i, r, i);\n  if (i < size)\n    memcpy (r + i, r, size - i);\n\n  /* Invert the first bit of every sector. */\n  if (type & 0x1000)\n    for (i = 0; i < size; i += SECTOR_SIZE)\n      r[i] ^= 0x80;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_474038(int a1, __int64 a2, int a3)\n{\n  __int64 result; // rax\n  void **v5; // [rsp+18h] [rbp-8h]\n\n  if ( qword_75AFF8 )\n  {\n    ++*(_DWORD *)(qword_75D418 + 48);\n    v5 = (void **)sub_40A0E8(0x18uLL, a2);\n    *(_QWORD *)qword_75AFF8 = v5;\n    sub_46E03F(24LL, a2);\n  }\n  else\n  {\n    v5 = &qword_75AFE0;\n  }\n  qword_75AFF8 = (__int64)v5;\n  *((_DWORD *)v5 + 2) = a1;\n  *(_DWORD *)(qword_75AFF8 + 12) = a2;\n  result = qword_75AFF8;\n  *(_DWORD *)(qword_75AFF8 + 16) = a3;\n  return result;\n}\n",
        "output": "```c\nstatic __int64\nadd_entry(int value, __int64 data, int flag)\n{\n  __int64 new_entry; // Pointer to the new entry\n  void **entry_ptr; // Pointer to the location where the new entry will be linked\n\n  if (global_entry_list)\n  {\n    ++*(_DWORD *)(global_list_counter + 48);\n    entry_ptr = (void **)allocate_memory(0x18uLL, data);\n    *(_QWORD *)global_entry_list = entry_ptr;\n    log_allocation(24LL, data);\n  }\n  else\n  {\n    entry_ptr = &first_entry;\n  }\n  global_entry_list = (__int64)entry_ptr;\n  *((_DWORD *)entry_ptr + 2) = value;\n  *(_DWORD *)(global_entry_list + 12) = data;\n  new_entry = global_entry_list;\n  *(_DWORD *)(global_entry_list + 16) = flag;\n  return new_entry;\n}\n```",
        "source_code": "static void\nrecordregion(int start, int end, int nulonly)\n{\n\tstruct ifsregion *ifsp;\n\n\tif (ifslastp == NULL) {\n\t\tifsp = &ifsfirst;\n\t} else {\n\t\tINT_OFF;\n\t\tifsp = ckzalloc(sizeof(*ifsp));\n\t\t/*ifsp->next = NULL; - ckzalloc did it */\n\t\tifslastp->next = ifsp;\n\t\tINT_ON;\n\t}\n\tifslastp = ifsp;\n\tifslastp->begoff = start;\n\tifslastp->endoff = end;\n\tifslastp->nulonly = nulonly;\n}",
        "parsed_output": "static __int64\nadd_entry(int value, __int64 data, int flag)\n{\n  __int64 new_entry; // Pointer to the new entry\n  void **entry_ptr; // Pointer to the location where the new entry will be linked\n\n  if (global_entry_list)\n  {\n    ++*(_DWORD *)(global_list_counter + 48);\n    entry_ptr = (void **)allocate_memory(0x18uLL, data);\n    *(_QWORD *)global_entry_list = entry_ptr;\n    log_allocation(24LL, data);\n  }\n  else\n  {\n    entry_ptr = &first_entry;\n  }\n  global_entry_list = (__int64)entry_ptr;\n  *((_DWORD *)entry_ptr + 2) = value;\n  *(_DWORD *)(global_entry_list + 12) = data;\n  new_entry = global_entry_list;\n  *(_DWORD *)(global_entry_list + 16) = flag;\n  return new_entry;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_474038(int a1, __int64 a2, int a3)\n{\n  __int64 result; // rax\n  void **v5; // [rsp+18h] [rbp-8h]\n\n  if ( qword_75AFF8 )\n  {\n    ++*(_DWORD *)(qword_75D418 + 48);\n    v5 = (void **)sub_40A0E8(0x18uLL, a2);\n    *(_QWORD *)qword_75AFF8 = v5;\n    sub_46E03F(24LL, a2);\n  }\n  else\n  {\n    v5 = &qword_75AFE0;\n  }\n  qword_75AFF8 = (__int64)v5;\n  *((_DWORD *)v5 + 2) = a1;\n  *(_DWORD *)(qword_75AFF8 + 12) = a2;\n  result = qword_75AFF8;\n  *(_DWORD *)(qword_75AFF8 + 16) = a3;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl recordregion(int start, int end, int nulonly)\n{\n  ifsregion *ifsp; // [rsp+18h] [rbp-8h]\n\n  if ( ifslastp )\n  {\n    ++ash_ptr_to_globals_misc->suppress_int;\n    ifsp = (ifsregion *)xzalloc(0x18uLL);\n    ifslastp->next = ifsp;\n    int_on();\n  }\n  else\n  {\n    ifsp = &ifsfirst;\n  }\n  ifslastp = ifsp;\n  ifsp->begoff = start;\n  ifslastp->endoff = end;\n  ifslastp->nulonly = nulonly;\n}\n",
        "similarity_score_unixcoder": 0.5731264352798462,
        "similarity_score_baseline_stripped": 0.42085450887680054,
        "similarity_score_baseline_debug": 0.8764182329177856
    },
    {
        "func_name": "scanright",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl component_len(const char *f)\n{\n  bool v2; // [rsp+1h] [rbp-11h]\n  size_t len; // [rsp+2h] [rbp-10h]\n\n  for ( len = 1LL; ; ++len )\n  {\n    v2 = 0;\n    if ( f[len] != 47 )\n      v2 = f[len] != 0;\n    if ( !v2 )\n      break;\n  }\n  return len;\n}\n\n\n Revised code:\nstatic size_t\ncomponent_len (char const *f)\n{\n  size_t len;\n  for (len = 1; f[len] != '/' && f[len]; len++)\n    continue;\n  return len;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl remove_suffix(char *name, const char *suffix)\n{\n  char *v2; // rax\n  int v3; // edx\n  const char *v4; // rax\n  bool v5; // [rsp+Fh] [rbp-31h]\n  const char *sp_0; // [rsp+20h] [rbp-20h]\n  char *np; // [rsp+28h] [rbp-18h]\n\n  np = &name[strlen(name)];\n  sp_0 = &suffix[strlen(suffix)];\n  while ( 1 )\n  {\n    v5 = 0;\n    if ( np > name )\n      v5 = sp_0 > suffix;\n    if ( !v5 )\n      break;\n    v2 = np--;\n    v3 = *(v2 - 1);\n    v4 = sp_0--;\n    if ( v3 != *(v4 - 1) )\n      return;\n  }\n  if ( np > name )\n    *np = 0;\n}\n\n\n Revised code:\nstatic void\nremove_suffix (char *name, const char *suffix)\n{\n  char *np;\n  const char *sp;\n\n  np = name + strlen (name);\n  sp = suffix + strlen (suffix);\n\n  while (np > name && sp > suffix)\n    if (*--np != *--sp)\n      return;\n  if (np > name)\n    *np = '\\0';\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nunsigned __int64 __fastcall sub_474B63(unsigned __int64 a1, char *a2, char *a3, const char *a4, int a5, int a6)\n{\n  _BOOL4 v10; // [rsp+38h] [rbp-28h]\n  char v11; // [rsp+3Fh] [rbp-21h]\n  char *name; // [rsp+40h] [rbp-20h]\n  unsigned __int64 v14; // [rsp+50h] [rbp-10h]\n  int v15; // [rsp+5Ch] [rbp-4h]\n\n  v15 = 0;\n  v14 = (unsigned __int64)(a4 - 1);\n  while ( v14 >= a1 )\n  {\n    v11 = *a3;\n    name = a3;\n    if ( a6 )\n    {\n      *a3 = 0;\n      name = a2;\n    }\n    v10 = fnmatch(a4, name, 0) == 0;\n    *a3 = v11;\n    if ( v10 )\n      return v14;\n    --v14;\n    if ( a5 )\n    {\n      if ( --v15 < 0 )\n        v15 = sub_473C97(a1, v14);\n      if ( (v15 & 1) != 0 )\n      {\n        --v15;\n        --v14;\n      }\n    }\n    --a3;\n  }\n  return 0LL;\n}\n",
        "output": "```c\nstatic unsigned long long\nsub_match_pattern(unsigned long long start, char *buffer, char *current, const char *pattern, int flag1, int flag2)\n{\n  bool match;\n  char original_char;\n  char *name;\n  unsigned long long position;\n  int counter;\n\n  counter = 0;\n  position = (unsigned long long)(pattern - 1);\n  while (position >= start)\n  {\n    original_char = *current;\n    name = current;\n    if (flag2)\n    {\n      *current = '\\0';\n      name = buffer;\n    }\n    match = (fnmatch(pattern, name, 0) == 0);\n    *current = original_char;\n    if (match)\n      return position;\n    --position;\n    if (flag1)\n    {\n      if (--counter < 0)\n        counter = sub_473C97(start, position);\n      if (counter & 1)\n      {\n        --counter;\n        --position;\n      }\n    }\n    --current;\n  }\n  return 0;\n}\n```",
        "source_code": "static char *\nscanright(char *startp, char *rmesc, char *rmescend,\n\t\tchar *pattern, int quotes, int match_at_start)\n{\n#if !ENABLE_ASH_OPTIMIZE_FOR_SIZE\n\tint try2optimize = match_at_start;\n#endif\n\tint esc = 0;\n\tchar *loc;\n\tchar *loc2;\n\n\t/* If we called by \"${v/pattern/repl}\" or \"${v//pattern/repl}\":\n\t * startp=\"escaped_value_of_v\" rmesc=\"raw_value_of_v\"\n\t * rmescend=\"\"(ptr to NUL in rmesc) pattern=\"pattern\" quotes=match_at_start=1\n\t * Logic:\n\t * loc starts at NUL at the end of startp, loc2 starts at the end of rmesc,\n\t * and on each iteration they go back two/one char until they reach the beginning.\n\t * We try to find a match in \"raw_value_of_v\", \"raw_value_of_\", \"raw_value_of\" etc.\n\t */\n\t/* TODO: document in what other circumstances we are called. */\n\n\tfor (loc = pattern - 1, loc2 = rmescend; loc >= startp; loc2--) {\n\t\tint match;\n\t\tchar c = *loc2;\n\t\tconst char *s = loc2;\n\t\tif (match_at_start) {\n\t\t\t*loc2 = '\\0';\n\t\t\ts = rmesc;\n\t\t}\n\t\tmatch = pmatch(pattern, s);\n\t\t//bb_error_msg(\"pmatch(pattern:'%s',s:'%s'):%d\", pattern, s, match);\n\t\t*loc2 = c;\n\t\tif (match)\n\t\t\treturn loc;\n#if !ENABLE_ASH_OPTIMIZE_FOR_SIZE\n\t\tif (try2optimize) {\n\t\t\t/* Maybe we can optimize this:\n\t\t\t * if pattern ends with unescaped *, we can avoid checking\n\t\t\t * shorter strings: if \"foo*\" doesnt match \"raw_value_of_v\",\n\t\t\t * it wont match truncated \"raw_value_of_\" strings too.\n\t\t\t */\n\t\t\tunsigned plen = strlen(pattern);\n\t\t\t/* Does it end with \"*\"? */\n\t\t\tif (plen != 0 && pattern[--plen] == '*') {\n\t\t\t\t/* \"xxxx*\" is not escaped */\n\t\t\t\t/* \"xxx\\*\" is escaped */\n\t\t\t\t/* \"xx\\\\*\" is not escaped */\n\t\t\t\t/* \"x\\\\\\*\" is escaped */\n\t\t\t\tint slashes = 0;\n\t\t\t\twhile (plen != 0 && pattern[--plen] == '\\\\')\n\t\t\t\t\tslashes++;\n\t\t\t\tif (!(slashes & 1))\n\t\t\t\t\tbreak; /* ends with unescaped \"*\" */\n\t\t\t}\n\t\t\ttry2optimize = 0;\n\t\t}\n#endif\n\t\tloc--;\n\t\tif (quotes) {\n\t\t\tif (--esc < 0) {\n\t\t\t\tesc = esclen(startp, loc);\n\t\t\t}\n\t\t\tif (esc % 2) {\n\t\t\t\tesc--;\n\t\t\t\tloc--;\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}",
        "parsed_output": "static unsigned long long\nsub_match_pattern(unsigned long long start, char *buffer, char *current, const char *pattern, int flag1, int flag2)\n{\n  bool match;\n  char original_char;\n  char *name;\n  unsigned long long position;\n  int counter;\n\n  counter = 0;\n  position = (unsigned long long)(pattern - 1);\n  while (position >= start)\n  {\n    original_char = *current;\n    name = current;\n    if (flag2)\n    {\n      *current = '\\0';\n      name = buffer;\n    }\n    match = (fnmatch(pattern, name, 0) == 0);\n    *current = original_char;\n    if (match)\n      return position;\n    --position;\n    if (flag1)\n    {\n      if (--counter < 0)\n        counter = sub_473C97(start, position);\n      if (counter & 1)\n      {\n        --counter;\n        --position;\n      }\n    }\n    --current;\n  }\n  return 0;\n}",
        "baseline_code_stripped": "unsigned __int64 __fastcall sub_474B63(unsigned __int64 a1, char *a2, char *a3, const char *a4, int a5, int a6)\n{\n  _BOOL4 v10; // [rsp+38h] [rbp-28h]\n  char v11; // [rsp+3Fh] [rbp-21h]\n  char *name; // [rsp+40h] [rbp-20h]\n  unsigned __int64 v14; // [rsp+50h] [rbp-10h]\n  int v15; // [rsp+5Ch] [rbp-4h]\n\n  v15 = 0;\n  v14 = (unsigned __int64)(a4 - 1);\n  while ( v14 >= a1 )\n  {\n    v11 = *a3;\n    name = a3;\n    if ( a6 )\n    {\n      *a3 = 0;\n      name = a2;\n    }\n    v10 = fnmatch(a4, name, 0) == 0;\n    *a3 = v11;\n    if ( v10 )\n      return v14;\n    --v14;\n    if ( a5 )\n    {\n      if ( --v15 < 0 )\n        v15 = sub_473C97(a1, v14);\n      if ( (v15 & 1) != 0 )\n      {\n        --v15;\n        --v14;\n      }\n    }\n    --a3;\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "char *__cdecl scanright(char *startp, char *rmesc, char *rmescend, char *pattern, int quotes, int match_at_start)\n{\n  int match; // [rsp+38h] [rbp-28h]\n  char c; // [rsp+3Fh] [rbp-21h]\n  char *s; // [rsp+40h] [rbp-20h]\n  char *loc; // [rsp+50h] [rbp-10h]\n  int esc; // [rsp+5Ch] [rbp-4h]\n\n  esc = 0;\n  loc = pattern - 1;\n  while ( loc >= startp )\n  {\n    c = *rmescend;\n    s = rmescend;\n    if ( match_at_start )\n    {\n      *rmescend = 0;\n      s = rmesc;\n    }\n    match = fnmatch(pattern, s, 0) == 0;\n    *rmescend = c;\n    if ( match )\n      return loc;\n    --loc;\n    if ( quotes )\n    {\n      if ( --esc < 0 )\n        esc = esclen(startp, loc);\n      if ( (esc & 1) != 0 )\n      {\n        --esc;\n        --loc;\n      }\n    }\n    --rmescend;\n  }\n  return 0LL;\n}\n",
        "similarity_score_unixcoder": 0.6777604818344116,
        "similarity_score_baseline_stripped": 0.5493896007537842,
        "similarity_score_baseline_debug": 0.7987684011459351
    },
    {
        "func_name": "add_to_ino_dev_hashtable",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_occurs(const void *void_first, const void *void_second)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h]\n  int value; // [rsp+1Ch] [rbp-14h]\n\n  value = compare_words(void_first, void_second);\n  if ( value )\n    LODWORD(v3) = value;\n  else\n    return *(_QWORD *)void_first - *(_QWORD *)void_second;\n  return v3;\n}\n\n\n Revised code:\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return value == 0 ? first->key.start - second->key.start : value;\n#undef first\n#undef second\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_4FDCC8(_QWORD *a1, __int64 a2)\n{\n  size_t v2; // rax\n  void *result; // rax\n  char *s; // [rsp+0h] [rbp-20h]\n  void *v5; // [rsp+10h] [rbp-10h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  s = (char *)a2;\n  v6 = a1[1] % 0x137uLL;\n  if ( !a2 )\n    s = (char *)&unk_537316;\n  v2 = strlen(s);\n  v5 = sub_40A05F(v2 + 32, a2);\n  *((_QWORD *)v5 + 1) = a1[1];\n  *((_QWORD *)v5 + 2) = *a1;\n  strcpy((char *)v5 + 24, s);\n  if ( !qword_75B2D0 )\n    qword_75B2D0 = sub_40A0E8(0x9B8uLL, (__int64)s);\n  *(_QWORD *)v5 = *((_QWORD *)qword_75B2D0 + v6);\n  result = v5;\n  *((_QWORD *)qword_75B2D0 + v6) = v5;\n  return result;\n}\n",
        "output": "```c\nstatic void *\nsub_4FDCC8 (uint64_t *context, const char *input_str)\n{\n  size_t input_len;\n  void *new_node;\n  uint64_t hash_index;\n\n  if (!input_str)\n    input_str = &unk_537316; // Default string if input is NULL\n\n  hash_index = context[1] % 0x137; // Calculate hash index\n  input_len = strlen(input_str); // Get length of input string\n  new_node = sub_40A05F(input_len + 32, input_str); // Allocate memory for new node\n\n  // Set values in new node\n  *((uint64_t *)new_node + 1) = context[1];\n  *((uint64_t *)new_node + 2) = *context;\n  strcpy((char *)new_node + 24, input_str); // Copy input string into new node\n\n  // Initialize global hash table if not already initialized\n  if (!qword_75B2D0)\n    qword_75B2D0 = sub_40A0E8(0x9B8, input_str);\n\n  // Insert new node into hash table\n  *(_QWORD *)new_node = *((_QWORD *)qword_75B2D0 + hash_index);\n  *((_QWORD *)qword_75B2D0 + hash_index) = new_node;\n\n  return new_node;\n}\n```",
        "source_code": "void FAST_FUNC add_to_ino_dev_hashtable(const struct stat *statbuf, const char *name)\n{\n\tint i;\n\tino_dev_hashtable_bucket_t *bucket;\n\n\ti = hash_inode(statbuf->st_ino);\n\tif (!name)\n\t\tname = \"\";\n\tbucket = xmalloc(sizeof(ino_dev_hashtable_bucket_t) + strlen(name));\n\tbucket->ino = statbuf->st_ino;\n\tbucket->dev = statbuf->st_dev;\n\tstrcpy(bucket->name, name);\n\n\tif (!ino_dev_hashtable)\n\t\tino_dev_hashtable = xzalloc(HASH_SIZE * sizeof(*ino_dev_hashtable));\n\n\tbucket->next = ino_dev_hashtable[i];\n\tino_dev_hashtable[i] = bucket;\n}",
        "parsed_output": "static void *\nsub_4FDCC8 (uint64_t *context, const char *input_str)\n{\n  size_t input_len;\n  void *new_node;\n  uint64_t hash_index;\n\n  if (!input_str)\n    input_str = &unk_537316; // Default string if input is NULL\n\n  hash_index = context[1] % 0x137; // Calculate hash index\n  input_len = strlen(input_str); // Get length of input string\n  new_node = sub_40A05F(input_len + 32, input_str); // Allocate memory for new node\n\n  // Set values in new node\n  *((uint64_t *)new_node + 1) = context[1];\n  *((uint64_t *)new_node + 2) = *context;\n  strcpy((char *)new_node + 24, input_str); // Copy input string into new node\n\n  // Initialize global hash table if not already initialized\n  if (!qword_75B2D0)\n    qword_75B2D0 = sub_40A0E8(0x9B8, input_str);\n\n  // Insert new node into hash table\n  *(_QWORD *)new_node = *((_QWORD *)qword_75B2D0 + hash_index);\n  *((_QWORD *)qword_75B2D0 + hash_index) = new_node;\n\n  return new_node;\n}",
        "baseline_code_stripped": "void *__fastcall sub_4FDCC8(_QWORD *a1, __int64 a2)\n{\n  size_t v2; // rax\n  void *result; // rax\n  char *s; // [rsp+0h] [rbp-20h]\n  void *v5; // [rsp+10h] [rbp-10h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  s = (char *)a2;\n  v6 = a1[1] % 0x137uLL;\n  if ( !a2 )\n    s = (char *)&unk_537316;\n  v2 = strlen(s);\n  v5 = sub_40A05F(v2 + 32, a2);\n  *((_QWORD *)v5 + 1) = a1[1];\n  *((_QWORD *)v5 + 2) = *a1;\n  strcpy((char *)v5 + 24, s);\n  if ( !qword_75B2D0 )\n    qword_75B2D0 = sub_40A0E8(0x9B8uLL, (__int64)s);\n  *(_QWORD *)v5 = *((_QWORD *)qword_75B2D0 + v6);\n  result = v5;\n  *((_QWORD *)qword_75B2D0 + v6) = v5;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl add_to_ino_dev_hashtable(const stat *statbuf, const char *name)\n{\n  size_t v2; // rax\n  const char *namea; // [rsp+0h] [rbp-20h]\n  ino_dev_hashtable_bucket_t *bucket; // [rsp+10h] [rbp-10h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  namea = name;\n  i = statbuf->st_ino % 0x137;\n  if ( !name )\n    namea = (const char *)&unk_537316;\n  v2 = strlen(namea);\n  bucket = (ino_dev_hashtable_bucket_t *)xmalloc(v2 + 32);\n  bucket->ino = statbuf->st_ino;\n  bucket->dev = statbuf->st_dev;\n  strcpy(bucket->name, namea);\n  if ( !ino_dev_hashtable )\n    ino_dev_hashtable = (ino_dev_hashtable_bucket_t **)xzalloc(0x9B8uLL);\n  bucket->next = ino_dev_hashtable[i];\n  ino_dev_hashtable[i] = bucket;\n}\n",
        "similarity_score_unixcoder": 0.5364449620246887,
        "similarity_score_baseline_stripped": 0.4104539752006531,
        "similarity_score_baseline_debug": 0.8617991209030151
    },
    {
        "func_name": "open_zipped",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nbool __cdecl binop(const char *s)\n{\n  bool v2; // [rsp+16h] [rbp-Ah]\n\n  v2 = 1;\n  if ( strcmp(s, (const char *)(unsigned int)\"=\") )\n  {\n    v2 = 1;\n    if ( strcmp(s, (const char *)(unsigned int)\"!=\") )\n    {\n      v2 = 1;\n      if ( strcmp(s, (const char *)(unsigned int)\"-nt\") )\n      {\n        v2 = 1;\n        if ( strcmp(s, (const char *)(unsigned int)\"-ot\") )\n        {\n          v2 = 1;\n          if ( strcmp(s, (const char *)(unsigned int)\"-ef\") )\n          {\n            v2 = 1;\n            if ( strcmp(s, (const char *)(unsigned int)\"-eq\") )\n            {\n              v2 = 1;\n              if ( strcmp(s, (const char *)(unsigned int)\"-ne\") )\n              {\n                v2 = 1;\n                if ( strcmp(s, (const char *)(unsigned int)\"-lt\") )\n                {\n                  v2 = 1;\n                  if ( strcmp(s, (const char *)(unsigned int)\"-le\") )\n                  {\n                    v2 = 1;\n                    if ( strcmp(s, (const char *)(unsigned int)\"-gt\") )\n                      return strcmp(s, (const char *)(unsigned int)\"-ge\") == 0;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return v2;\n}\n\n\n Revised code:\nstatic bool\nbinop (char const *s)\n{\n  return ((STREQ (s,   \"=\")) || (STREQ (s,  \"!=\")) || (STREQ (s, \"-nt\")) ||\n\t  (STREQ (s, \"-ot\")) || (STREQ (s, \"-ef\")) || (STREQ (s, \"-eq\")) ||\n\t  (STREQ (s, \"-ne\")) || (STREQ (s, \"-lt\")) || (STREQ (s, \"-le\")) ||\n\t  (STREQ (s, \"-gt\")) || (STREQ (s, \"-ge\")));\n}\n\n## Example:\n\n Input code:\nbool __cdecl dev_ino_compare(const void *x, const void *y)\n{\n  bool v3; // [rsp+1h] [rbp-21h]\n\n  v3 = 0;\n  if ( *(_QWORD *)x == *(_QWORD *)y )\n    return *((_QWORD *)x + 1) == *((_QWORD *)y + 1);\n  return v3;\n}\n\n\n Revised code:\nstatic bool\ndev_ino_compare (void const *x, void const *y)\n{\n  struct dev_ino const *a = x;\n  struct dev_ino const *b = y;\n  return SAME_INODE (*a, *b) ? true : false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4C32DA(const char *a1)\n{\n  char *s1; // [rsp+10h] [rbp-10h]\n  char *s1a; // [rsp+10h] [rbp-10h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  v4 = open64(a1, 0);\n  if ( v4 < 0 )\n    return (unsigned int)v4;\n  s1 = strrchr(a1, 46);\n  if ( s1 )\n  {\n    s1a = s1 + 1;\n    if ( !strcmp(s1a, \"lzma\") )\n    {\n      sub_4C317A(v4, 1LL, (void (__fastcall *)(char *, _QWORD, _QWORD))sub_4BB637);\n    }\n    else if ( !strcmp(s1a, \"gz\") || !strcmp(s1a, \"bz2\") || !strcmp(s1a, \"xz\") )\n    {\n      sub_4C31FB(v4, 1);\n    }\n  }\n  return (unsigned int)v4;\n}\n",
        "output": "```c\nstatic int\nsub_4C32DA (char const *filename)\n{\n  int fd = open64(filename, O_RDONLY);\n  if (fd < 0)\n    return fd;\n\n  char *extension = strrchr(filename, '.');\n  if (extension)\n  {\n    extension++; // Move past the dot to the actual extension\n    if (strcmp(extension, \"lzma\") == 0)\n    {\n      sub_4C317A(fd, 1LL, sub_4BB637);\n    }\n    else if (strcmp(extension, \"gz\") == 0 || strcmp(extension, \"bz2\") == 0 || strcmp(extension, \"xz\") == 0)\n    {\n      sub_4C31FB(fd, 1);\n    }\n  }\n  return fd;\n}\n```",
        "source_code": "int FAST_FUNC open_zipped(const char *fname)\n{\n\tchar *sfx;\n\tint fd;\n\n\tfd = open(fname, O_RDONLY);\n\tif (fd < 0)\n\t\treturn fd;\n\n\tsfx = strrchr(fname, '.');\n\tif (sfx) {\n\t\tsfx++;\n\t\tif (ENABLE_FEATURE_SEAMLESS_LZMA && strcmp(sfx, \"lzma\") == 0)\n\t\t\t/* .lzma has no header/signature, just trust it */\n\t\t\topen_transformer_with_sig(fd, unpack_lzma_stream, \"unlzma\");\n\t\telse\n\t\tif ((ENABLE_FEATURE_SEAMLESS_GZ && strcmp(sfx, \"gz\") == 0)\n\t\t || (ENABLE_FEATURE_SEAMLESS_BZ2 && strcmp(sfx, \"bz2\") == 0)\n\t\t || (ENABLE_FEATURE_SEAMLESS_XZ && strcmp(sfx, \"xz\") == 0)\n\t\t) {\n\t\t\tsetup_unzip_on_fd(fd, /*fail_if_not_detected:*/ 1);\n\t\t}\n\t}\n\n\treturn fd;\n}",
        "parsed_output": "static int\nsub_4C32DA (char const *filename)\n{\n  int fd = open64(filename, O_RDONLY);\n  if (fd < 0)\n    return fd;\n\n  char *extension = strrchr(filename, '.');\n  if (extension)\n  {\n    extension++; // Move past the dot to the actual extension\n    if (strcmp(extension, \"lzma\") == 0)\n    {\n      sub_4C317A(fd, 1LL, sub_4BB637);\n    }\n    else if (strcmp(extension, \"gz\") == 0 || strcmp(extension, \"bz2\") == 0 || strcmp(extension, \"xz\") == 0)\n    {\n      sub_4C31FB(fd, 1);\n    }\n  }\n  return fd;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4C32DA(const char *a1)\n{\n  char *s1; // [rsp+10h] [rbp-10h]\n  char *s1a; // [rsp+10h] [rbp-10h]\n  int v4; // [rsp+1Ch] [rbp-4h]\n\n  v4 = open64(a1, 0);\n  if ( v4 < 0 )\n    return (unsigned int)v4;\n  s1 = strrchr(a1, 46);\n  if ( s1 )\n  {\n    s1a = s1 + 1;\n    if ( !strcmp(s1a, \"lzma\") )\n    {\n      sub_4C317A(v4, 1LL, (void (__fastcall *)(char *, _QWORD, _QWORD))sub_4BB637);\n    }\n    else if ( !strcmp(s1a, \"gz\") || !strcmp(s1a, \"bz2\") || !strcmp(s1a, \"xz\") )\n    {\n      sub_4C31FB(v4, 1);\n    }\n  }\n  return (unsigned int)v4;\n}\n",
        "baseline_code_debug": "int __cdecl open_zipped(const char *fname)\n{\n  char *sfx; // [rsp+10h] [rbp-10h]\n  char *sfxa; // [rsp+10h] [rbp-10h]\n  int fd; // [rsp+1Ch] [rbp-4h]\n\n  fd = open64(fname, 0);\n  if ( fd < 0 )\n    return fd;\n  sfx = strrchr(fname, 46);\n  if ( sfx )\n  {\n    sfxa = sfx + 1;\n    if ( !strcmp(sfxa, \"lzma\") )\n    {\n      open_transformer(fd, 1, (__int64 (*)(transformer_aux_data_t_0 *, int, int))unpack_lzma_stream);\n    }\n    else if ( !strcmp(sfxa, \"gz\") || !strcmp(sfxa, \"bz2\") || !strcmp(sfxa, \"xz\") )\n    {\n      setup_unzip_on_fd(fd, 1);\n    }\n  }\n  return fd;\n}\n",
        "similarity_score_unixcoder": 0.6931872367858887,
        "similarity_score_baseline_stripped": 0.5893514752388,
        "similarity_score_baseline_debug": 0.8475003838539124
    },
    {
        "func_name": "telopt",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl hextobin(unsigned __int8 c)\n{\n  int v2; // [rsp+10h] [rbp-4h]\n\n  switch ( c )\n  {\n    case 'A':\n    case 'a':\n      v2 = 10;\n      break;\n    case 'B':\n    case 'b':\n      v2 = 11;\n      break;\n    case 'C':\n    case 'c':\n      v2 = 12;\n      break;\n    case 'D':\n    case 'd':\n      v2 = 13;\n      break;\n    case 'E':\n    case 'e':\n      v2 = 14;\n      break;\n    case 'F':\n    case 'f':\n      v2 = 15;\n      break;\n    default:\n      v2 = c - 48;\n      break;\n  }\n  return v2;\n}\n\n\n Revised code:\nstatic int\nhextobin (unsigned char c)\n{\n  switch (c)\n    {\n    default: return c - '0';\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    }\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl adjust_column(size_t column, char c)\n{\n  size_t columna; // [rsp+2h] [rbp-8h]\n\n  columna = column;\n  if ( count_bytes )\n    return column + 1;\n  switch ( c )\n  {\n    case 8:\n      if ( column )\n        return column - 1;\n      break;\n    case 13:\n      return 0LL;\n    case 9:\n      return column + 8 - (column & 7);\n    default:\n      return column + 1;\n  }\n  return columna;\n}\n\n\n Revised code:\nstatic size_t\nadjust_column (size_t column, char c)\n{\n  if (!count_bytes)\n    {\n      if (c == '\\b')\n\t{\n\t  if (column > 0)\n\t    column--;\n\t}\n      else if (c == '\\r')\n\tcolumn = 0;\n      else if (c == '\\t')\n\tcolumn += TAB_WIDTH - column % TAB_WIDTH;\n      else /* if (isprint (c)) */\n\tcolumn++;\n    }\n  else\n    column++;\n  return column;\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_44240C(char a1)\n{\n  __int64 result; // rax\n\n  switch ( a1 )\n  {\n    case 1:\n      result = sub_44223D();\n      break;\n    case 3:\n      result = sub_44230D();\n      break;\n    case 24:\n      result = sub_44238C();\n      break;\n    case 31:\n      sub_4423F6();\n      result = sub_44203B(a1, *(_DWORD *)&dest.c_cc[15], *(_DWORD *)&dest.c_cc[19]);\n      break;\n    case 39:\n      result = sub_4423C1();\n      break;\n    default:\n      result = sub_4421EB(a1);\n      break;\n  }\n  return result;\n}\n",
        "output": "```c\nstatic __int64\nsub_44240C(char a1)\n{\n  switch (a1)\n    {\n    case 1:\n      return sub_44223D();\n    case 3:\n      return sub_44230D();\n    case 24:\n      return sub_44238C();\n    case 31:\n      sub_4423F6();\n      return sub_44203B(a1, *(_DWORD *)&dest.c_cc[15], *(_DWORD *)&dest.c_cc[19]);\n    case 39:\n      return sub_4423C1();\n    default:\n      return sub_4421EB(a1);\n    }\n}\n```",
        "source_code": "endif\n\nstatic void telopt(byte c)\n{\n\tswitch (c) {\n\tcase TELOPT_ECHO:\n\t\tto_echo(); break;\n\tcase TELOPT_SGA:\n\t\tto_sga(); break;\n#if ENABLE_FEATURE_TELNET_TTYPE\n\tcase TELOPT_TTYPE:\n\t\tto_ttype(); break;\n#endif\n#if ENABLE_FEATURE_TELNET_AUTOLOGIN\n\tcase TELOPT_NEW_ENVIRON:\n\t\tto_new_environ(); break;\n#endif\n#if ENABLE_FEATURE_AUTOWIDTH\n\tcase TELOPT_NAWS:\n\t\tto_naws();\n\t\tput_iac_naws(c, G.win_width, G.win_height);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tto_notsup(c);\n\t\tbreak;\n\t}\n}",
        "parsed_output": "static __int64\nsub_44240C(char a1)\n{\n  switch (a1)\n    {\n    case 1:\n      return sub_44223D();\n    case 3:\n      return sub_44230D();\n    case 24:\n      return sub_44238C();\n    case 31:\n      sub_4423F6();\n      return sub_44203B(a1, *(_DWORD *)&dest.c_cc[15], *(_DWORD *)&dest.c_cc[19]);\n    case 39:\n      return sub_4423C1();\n    default:\n      return sub_4421EB(a1);\n    }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_44240C(char a1)\n{\n  __int64 result; // rax\n\n  switch ( a1 )\n  {\n    case 1:\n      result = sub_44223D();\n      break;\n    case 3:\n      result = sub_44230D();\n      break;\n    case 24:\n      result = sub_44238C();\n      break;\n    case 31:\n      sub_4423F6();\n      result = sub_44203B(a1, *(_DWORD *)&dest.c_cc[15], *(_DWORD *)&dest.c_cc[19]);\n      break;\n    case 39:\n      result = sub_4423C1();\n      break;\n    default:\n      result = sub_4421EB(a1);\n      break;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl telopt(byte c)\n{\n  switch ( c )\n  {\n    case 1u:\n      to_echo();\n      break;\n    case 3u:\n      to_sga();\n      break;\n    case 0x18u:\n      to_ttype();\n      break;\n    case 0x1Fu:\n      to_naws();\n      put_iac_naws(c, *(_DWORD *)&bb_common_bufsiz1.c_cc[15], *(_DWORD *)&bb_common_bufsiz1.c_cc[19]);\n      break;\n    case 0x27u:\n      to_new_environ();\n      break;\n    default:\n      to_notsup(c);\n      break;\n  }\n}\n",
        "similarity_score_unixcoder": 0.48405352234840393,
        "similarity_score_baseline_stripped": 0.46247902512550354,
        "similarity_score_baseline_debug": 0.7851196527481079
    },
    {
        "func_name": "rc_reset",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nsize_t __cdecl adjust_column(size_t column, char c)\n{\n  size_t columna; // [rsp+2h] [rbp-8h]\n\n  columna = column;\n  if ( count_bytes )\n    return column + 1;\n  switch ( c )\n  {\n    case 8:\n      if ( column )\n        return column - 1;\n      break;\n    case 13:\n      return 0LL;\n    case 9:\n      return column + 8 - (column & 7);\n    default:\n      return column + 1;\n  }\n  return columna;\n}\n\n\n Revised code:\nstatic size_t\nadjust_column (size_t column, char c)\n{\n  if (!count_bytes)\n    {\n      if (c == '\\b')\n\t{\n\t  if (column > 0)\n\t    column--;\n\t}\n      else if (c == '\\r')\n\tcolumn = 0;\n      else if (c == '\\t')\n\tcolumn += TAB_WIDTH - column % TAB_WIDTH;\n      else /* if (isprint (c)) */\n\tcolumn++;\n    }\n  else\n    column++;\n  return column;\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_occurs(const void *void_first, const void *void_second)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h]\n  int value; // [rsp+1Ch] [rbp-14h]\n\n  value = compare_words(void_first, void_second);\n  if ( value )\n    LODWORD(v3) = value;\n  else\n    return *(_QWORD *)void_first - *(_QWORD *)void_second;\n  return v3;\n}\n\n\n Revised code:\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return value == 0 ? first->key.start - second->key.start : value;\n#undef first\n#undef second\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_DWORD *__fastcall sub_4BC598(_DWORD *a1)\n{\n  _DWORD *result; // rax\n\n  *a1 = -1;\n  a1[1] = 0;\n  result = a1;\n  a1[2] = 5;\n  return result;\n}\n",
        "output": "```c\nstatic void\ninitialize_array(int *array)\n{\n  array[0] = -1;\n  array[1] = 0;\n  array[2] = 5;\n}\n```",
        "source_code": "static void XZ_FUNC rc_reset(struct rc_dec *rc)\n{\n\trc->range = (uint32_t)-1;\n\trc->code = 0;\n\trc->init_bytes_left = RC_INIT_BYTES;\n}",
        "parsed_output": "static void\ninitialize_array(int *array)\n{\n  array[0] = -1;\n  array[1] = 0;\n  array[2] = 5;\n}",
        "baseline_code_stripped": "_DWORD *__fastcall sub_4BC598(_DWORD *a1)\n{\n  _DWORD *result; // rax\n\n  *a1 = -1;\n  a1[1] = 0;\n  result = a1;\n  a1[2] = 5;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl rc_reset(rc_dec *rc)\n{\n  rc->range = -1;\n  rc->code = 0;\n  rc->init_bytes_left = 5;\n}\n",
        "similarity_score_unixcoder": 0.5565785765647888,
        "similarity_score_baseline_stripped": 0.48825761675834656,
        "similarity_score_baseline_debug": 0.8901900053024292
    },
    {
        "func_name": "openServer",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_occurs(const void *void_first, const void *void_second)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h]\n  int value; // [rsp+1Ch] [rbp-14h]\n\n  value = compare_words(void_first, void_second);\n  if ( value )\n    LODWORD(v3) = value;\n  else\n    return *(_QWORD *)void_first - *(_QWORD *)void_second;\n  return v3;\n}\n\n\n Revised code:\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return value == 0 ? first->key.start - second->key.start : value;\n#undef first\n#undef second\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_42C3F5()\n{\n  unsigned int v1; // [rsp+Ch] [rbp-4h]\n  unsigned int v2; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_40BECF(*((const char **)qword_75D408 + 4), 0LL, 10);\n  if ( *(_DWORD *)qword_75D400 || !v1 || v1 > 0xFFFF )\n  {\n    v2 = sub_50BD23(*((_QWORD *)qword_75D408 + 4), 80LL);\n    sub_40AA15(v2, 9u);\n  }\n  else\n  {\n    v2 = sub_50BD23(0LL, v1);\n    sub_40AA15(v2, 9u);\n  }\n  return v2;\n}\n",
        "output": "```c\nstatic unsigned int\nprocess_value()\n{\n  unsigned int value;\n  unsigned int result;\n\n  value = parse_uint(*(const char **)(config_ptr + 4), 0, 10);\n  if (*(int *)config_flag || !value || value > 0xFFFF)\n  {\n    result = calculate_value(*(uint64_t *)(config_ptr + 4), 80);\n    perform_action(result, 9);\n  }\n  else\n  {\n    result = calculate_value(0, value);\n    perform_action(result, 9);\n  }\n  return result;\n}\n```",
        "source_code": "static int openServer(void)\n{\n\tunsigned n = bb_strtou(bind_addr_or_port, NULL, 10);\n\tif (!errno && n && n <= 0xffff)\n\t\tn = create_and_bind_stream_or_die(NULL, n);\n\telse\n\t\tn = create_and_bind_stream_or_die(bind_addr_or_port, 80);\n\txlisten(n, 9);\n\treturn n;\n}",
        "parsed_output": "static unsigned int\nprocess_value()\n{\n  unsigned int value;\n  unsigned int result;\n\n  value = parse_uint(*(const char **)(config_ptr + 4), 0, 10);\n  if (*(int *)config_flag || !value || value > 0xFFFF)\n  {\n    result = calculate_value(*(uint64_t *)(config_ptr + 4), 80);\n    perform_action(result, 9);\n  }\n  else\n  {\n    result = calculate_value(0, value);\n    perform_action(result, 9);\n  }\n  return result;\n}",
        "baseline_code_stripped": "__int64 sub_42C3F5()\n{\n  unsigned int v1; // [rsp+Ch] [rbp-4h]\n  unsigned int v2; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_40BECF(*((const char **)qword_75D408 + 4), 0LL, 10);\n  if ( *(_DWORD *)qword_75D400 || !v1 || v1 > 0xFFFF )\n  {\n    v2 = sub_50BD23(*((_QWORD *)qword_75D408 + 4), 80LL);\n    sub_40AA15(v2, 9u);\n  }\n  else\n  {\n    v2 = sub_50BD23(0LL, v1);\n    sub_40AA15(v2, 9u);\n  }\n  return v2;\n}\n",
        "baseline_code_debug": "int __cdecl openServer()\n{\n  unsigned int n; // [rsp+Ch] [rbp-4h]\n  unsigned int na; // [rsp+Ch] [rbp-4h]\n\n  n = bb_strtou(ptr_to_globals->initstring, 0LL, 10);\n  if ( *bb_errno || !n || n > 0xFFFF )\n  {\n    na = create_and_bind_stream_or_die(ptr_to_globals->initstring, 80);\n    xlisten(na, 9);\n  }\n  else\n  {\n    na = create_and_bind_stream_or_die(0LL, n);\n    xlisten(na, 9);\n  }\n  return na;\n}\n",
        "similarity_score_unixcoder": 0.47389495372772217,
        "similarity_score_baseline_stripped": 0.3680471181869507,
        "similarity_score_baseline_debug": 0.8696680068969727
    },
    {
        "func_name": "print_raw",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_long(size_t n_bytes, const void *block, const char *fmt_string)\n{\n  _QWORD *v3; // rax\n  size_t i; // [rsp+8h] [rbp-28h]\n\n  for ( i = n_bytes >> 3; i; --i )\n  {\n    v3 = block;\n    block = (char *)block + 8;\n    printf(fmt_string, *v3);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_long (size_t n_bytes, void const *block, char const *fmt_string)\n{\n  unsigned long int const *p = block;\n  size_t i;\n  for (i = n_bytes / sizeof *p; i != 0; i--)\n    printf (fmt_string, *p++);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_long_long(size_t n_bytes, const void *block, const char *fmt_string)\n{\n  _QWORD *v3; // rax\n  size_t i; // [rsp+8h] [rbp-28h]\n\n  for ( i = n_bytes >> 3; i; --i )\n  {\n    v3 = block;\n    block = (char *)block + 8;\n    printf(fmt_string, *v3);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_long_long (size_t n_bytes, void const *block, char const *fmt_string)\n{\n  unsigned_long_long_int const *p = block;\n  size_t i;\n  for (i = n_bytes / sizeof *p; i != 0; i--)\n    printf (fmt_string, *p++);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_494F95()\n{\n  __int64 result; // rax\n  int i; // [rsp+Ch] [rbp-4h]\n\n  printf(\"Device: %s\\n\", *((const char **)qword_75D408 + 1));\n  for ( i = 3; ; ++i )\n  {\n    result = *((unsigned int *)qword_75D408 + 4);\n    if ( i >= (int)result )\n      break;\n    sub_494EEE(*((_QWORD *)qword_75D408 + 5 * i + 316));\n  }\n  return result;\n}\n",
        "output": "```c\nstatic __int64\nprint_device_info()\n{\n  __int64 device_count;\n  int i;\n\n  printf(\"Device: %s\\n\", *((const char **)qword_75D408 + 1));\n  device_count = *((unsigned int *)qword_75D408 + 4);\n  for (i = 3; i < device_count; ++i)\n  {\n    print_device_details(*((_QWORD *)qword_75D408 + 5 * i + 316));\n  }\n  return device_count;\n}\n```",
        "source_code": "static void\nprint_raw(void)\n{\n\tint i;\n\n\tprintf(\"Device: %s\\n\", disk_device);\n\tif (LABEL_IS_SGI || LABEL_IS_SUN)\n\t\tprint_buffer(MBRbuffer);\n\telse {\n\t\tfor (i = 3; i < g_partitions; i++)\n\t\t\tprint_buffer(ptes[i].sectorbuffer);\n\t}\n}",
        "parsed_output": "static __int64\nprint_device_info()\n{\n  __int64 device_count;\n  int i;\n\n  printf(\"Device: %s\\n\", *((const char **)qword_75D408 + 1));\n  device_count = *((unsigned int *)qword_75D408 + 4);\n  for (i = 3; i < device_count; ++i)\n  {\n    print_device_details(*((_QWORD *)qword_75D408 + 5 * i + 316));\n  }\n  return device_count;\n}",
        "baseline_code_stripped": "__int64 sub_494F95()\n{\n  __int64 result; // rax\n  int i; // [rsp+Ch] [rbp-4h]\n\n  printf(\"Device: %s\\n\", *((const char **)qword_75D408 + 1));\n  for ( i = 3; ; ++i )\n  {\n    result = *((unsigned int *)qword_75D408 + 4);\n    if ( i >= (int)result )\n      break;\n    sub_494EEE(*((_QWORD *)qword_75D408 + 5 * i + 316));\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl print_raw()\n{\n  int i; // [rsp+Ch] [rbp-4h]\n\n  printf(\"Device: %s\\n\", ptr_to_globals->login);\n  for ( i = 3; i < SLODWORD(ptr_to_globals->fakehost); ++i )\n    print_buffer(*(char **)&ptr_to_globals[8].line_buf[40 * i + 68]);\n}\n",
        "similarity_score_unixcoder": 0.5978492498397827,
        "similarity_score_baseline_stripped": 0.5267550349235535,
        "similarity_score_baseline_debug": 0.5742130279541016
    },
    {
        "func_name": "fb_pixel_value",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nvoid __cdecl fillpattern(int type, unsigned __int8 *r, size_t size)\n{\n  size_t i; // [rsp+10h] [rbp-20h]\n  size_t ia; // [rsp+10h] [rbp-20h]\n\n  *r = (type & 0xFFF | ((type & 0xFFFu) << 12)) >> 4;\n  r[1] = (unsigned __int16)(type & 0xFFF | ((type & 0xFFF) << 12)) >> 8;\n  r[2] = type;\n  for ( i = 3LL; i < size >> 1; i *= 2LL )\n    memcpy(&r[i], r, i);\n  if ( i < size )\n    memcpy(&r[i], r, size - i);\n  if ( (type & 0x1000) != 0 )\n  {\n    for ( ia = 0LL; ia < size; ia += 512LL )\n      r[ia] ^= 0x80u;\n  }\n}\n\n\n Revised code:\nstatic void\nfillpattern (int type, unsigned char *r, size_t size)\n{\n  size_t i;\n  unsigned int bits = type & 0xfff;\n\n  bits |= bits << 12;\n  r[0] = (bits >> 4) & 255;\n  r[1] = (bits >> 8) & 255;\n  r[2] = bits & 255;\n  for (i = 3; i < size / 2; i *= 2)\n    memcpy (r + i, r, i);\n  if (i < size)\n    memcpy (r + i, r, size - i);\n\n  /* Invert the first bit of every sector. */\n  if (type & 0x1000)\n    for (i = 0; i < size; i += SECTOR_SIZE)\n      r[i] ^= 0x80;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_occurs(const void *void_first, const void *void_second)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h]\n  int value; // [rsp+1Ch] [rbp-14h]\n\n  value = compare_words(void_first, void_second);\n  if ( value )\n    LODWORD(v3) = value;\n  else\n    return *(_QWORD *)void_first - *(_QWORD *)void_second;\n  return v3;\n}\n\n\n Revised code:\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return value == 0 ? first->key.start - second->key.start : value;\n#undef first\n#undef second\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_417020(unsigned int a1, unsigned int a2, unsigned int a3)\n{\n  if ( *((_DWORD *)qword_75D408 + 72) == 1 )\n    return ((a2 >> 3) & 0x1C) + (a1 & 0xE0) + (a3 >> 6);\n  if ( *((_DWORD *)qword_75D408 + 72) == 2 )\n    return (a2 >> *((_DWORD *)qword_75D408 + 74) << *((_DWORD *)qword_75D408 + 23))\n         + (a1 >> *((_DWORD *)qword_75D408 + 73) << *((_DWORD *)qword_75D408 + 20))\n         + (a3 >> *((_DWORD *)qword_75D408 + 75) << *((_DWORD *)qword_75D408 + 26));\n  return a3 + (a2 << 8) + (a1 << 16);\n}\n",
        "output": "```c\nstatic unsigned int\nsub_417020(unsigned int a1, unsigned int a2, unsigned int a3)\n{\n  unsigned int mode = *((unsigned int *)qword_75D408 + 72);\n\n  switch (mode)\n    {\n    case 1:\n      return ((a2 >> 3) & 0x1C) + (a1 & 0xE0) + (a3 >> 6);\n    case 2:\n      return (a2 >> *((unsigned int *)qword_75D408 + 74) << *((unsigned int *)qword_75D408 + 23))\n           + (a1 >> *((unsigned int *)qword_75D408 + 73) << *((unsigned int *)qword_75D408 + 20))\n           + (a3 >> *((unsigned int *)qword_75D408 + 75) << *((unsigned int *)qword_75D408 + 26));\n    default:\n      return a3 + (a2 << 8) + (a1 << 16);\n    }\n}\n```",
        "source_code": "static unsigned fb_pixel_value(unsigned r, unsigned g, unsigned b)\n{\n\t/* We assume that the r,g,b values are <= 255 */\n\n\tif (G.bytes_per_pixel == 1) {\n\t\tr = r        & 0xe0; // 3-bit red\n\t\tg = (g >> 3) & 0x1c; // 3-bit green\n\t\tb =  b >> 6;         // 2-bit blue\n\t\treturn r + g + b;\n\t}\n\tif (G.bytes_per_pixel == 2) {\n\t\t// ARM PL110 on Integrator/CP has RGBA5551 bit arrangement.\n\t\t// We want to support bit locations like that.\n\t\t//\n\t\t// First shift out unused bits\n\t\tr = r >> G.red_shift;\n\t\tg = g >> G.green_shift;\n\t\tb = b >> G.blue_shift;\n\t\t// Then shift the remaining bits to their offset\n\t\treturn (r << G.scr_var.red.offset) +\n\t\t\t(g << G.scr_var.green.offset) +\n\t\t\t(b << G.scr_var.blue.offset);\n\t}\n\t// RGB 888\n\treturn b + (g << 8) + (r << 16);\n}",
        "parsed_output": "static unsigned int\nsub_417020(unsigned int a1, unsigned int a2, unsigned int a3)\n{\n  unsigned int mode = *((unsigned int *)qword_75D408 + 72);\n\n  switch (mode)\n    {\n    case 1:\n      return ((a2 >> 3) & 0x1C) + (a1 & 0xE0) + (a3 >> 6);\n    case 2:\n      return (a2 >> *((unsigned int *)qword_75D408 + 74) << *((unsigned int *)qword_75D408 + 23))\n           + (a1 >> *((unsigned int *)qword_75D408 + 73) << *((unsigned int *)qword_75D408 + 20))\n           + (a3 >> *((unsigned int *)qword_75D408 + 75) << *((unsigned int *)qword_75D408 + 26));\n    default:\n      return a3 + (a2 << 8) + (a1 << 16);\n    }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_417020(unsigned int a1, unsigned int a2, unsigned int a3)\n{\n  if ( *((_DWORD *)qword_75D408 + 72) == 1 )\n    return ((a2 >> 3) & 0x1C) + (a1 & 0xE0) + (a3 >> 6);\n  if ( *((_DWORD *)qword_75D408 + 72) == 2 )\n    return (a2 >> *((_DWORD *)qword_75D408 + 74) << *((_DWORD *)qword_75D408 + 23))\n         + (a1 >> *((_DWORD *)qword_75D408 + 73) << *((_DWORD *)qword_75D408 + 20))\n         + (a3 >> *((_DWORD *)qword_75D408 + 75) << *((_DWORD *)qword_75D408 + 26));\n  return a3 + (a2 << 8) + (a1 << 16);\n}\n",
        "baseline_code_debug": "unsigned int __cdecl fb_pixel_value(unsigned int r, unsigned int g, unsigned int b)\n{\n  if ( ptr_to_globals[1].timeout == 1 )\n    return ((g >> 3) & 0x1C) + (r & 0xE0) + (b >> 6);\n  if ( ptr_to_globals[1].timeout == 2 )\n    return (g >> LODWORD(ptr_to_globals[1].login) << *(_DWORD *)&ptr_to_globals->eol)\n         + (r >> *(&ptr_to_globals[1].timeout + 1) << ptr_to_globals->speeds[7])\n         + (b >> HIDWORD(ptr_to_globals[1].login) << ptr_to_globals->tty_attrs.c_cflag);\n  return b + (g << 8) + (r << 16);\n}\n",
        "similarity_score_unixcoder": 0.6304429173469543,
        "similarity_score_baseline_stripped": 0.5855668783187866,
        "similarity_score_baseline_debug": 0.6600219011306763
    },
    {
        "func_name": "replace_pattern",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  unsigned __int8 *v3; // rax\n  const char *v4; // rdi\n  char buf[5]; // [rsp+33h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+38h] [rbp-38h]\n  unsigned __int8 c; // [rsp+47h] [rbp-29h]\n  size_t i; // [rsp+48h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+50h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+58h] [rbp-18h]\n  const void *blocka; // [rsp+60h] [rbp-10h]\n  size_t n_bytesa; // [rsp+68h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = (unsigned __int8 *)p++;\n    c = *v3;\n    switch ( c )\n    {\n      case 0u:\n        s = \" \\\\0\";\n        break;\n      case 7u:\n        s = (const char *)&unk_409AA8;\n        break;\n      case 8u:\n        s = (const char *)&unk_409AAC;\n        break;\n      case 9u:\n        s = (const char *)&unk_409ABC;\n        break;\n      case 0xAu:\n        s = (const char *)&unk_409AB4;\n        break;\n      case 0xBu:\n        s = (const char *)&unk_409AC0;\n        break;\n      case 0xCu:\n        s = (const char *)&unk_409AB0;\n        break;\n      case 0xDu:\n        s = (const char *)&unk_409AB8;\n        break;\n      default:\n        v4 = \"%03o\";\n        if ( ((*__ctype_b_loc())[c] & 0x4000) != 0 )\n          v4 = \"  %c\";\n        sprintf(buf, v4, c);\n        s = buf;\n        break;\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_ascii (size_t n_bytes, void const *block,\n\t     const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      unsigned char c = *p++;\n      const char *s;\n      char buf[5];\n\n      switch (c)\n\t{\n\tcase '\\0':\n\t  s = \" \\\\0\";\n\t  break;\n\n\tcase '\\a':\n\t  s = \" \\\\a\";\n\t  break;\n\n\tcase '\\b':\n\t  s = \" \\\\b\";\n\t  break;\n\n\tcase '\\f':\n\t  s = \" \\\\f\";\n\t  break;\n\n\tcase '\\n':\n\t  s = \" \\\\n\";\n\t  break;\n\n\tcase '\\r':\n\t  s = \" \\\\r\";\n\t  break;\n\n\tcase '\\t':\n\t  s = \" \\\\t\";\n\t  break;\n\n\tcase '\\v':\n\t  s = \" \\\\v\";\n\t  break;\n\n\tdefault:\n\t  sprintf (buf, (isprint (c) ? \"  %c\" : \"%03o\"), c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_484AC9(_BYTE *a1, _BYTE *a2, const char *a3, char a4)\n{\n  __int64 v4; // rbx\n  size_t v5; // rax\n  int v10; // [rsp+24h] [rbp-2Ch] BYREF\n  _BYTE *v11; // [rsp+28h] [rbp-28h]\n  unsigned int v12; // [rsp+30h] [rbp-20h]\n  unsigned int v13; // [rsp+34h] [rbp-1Ch]\n  char *v14; // [rsp+38h] [rbp-18h]\n\n  v14 = 0LL;\n  v13 = 0;\n  v12 = strlen(a3);\n  do\n  {\n    v11 = sub_484A4F(a1, a2, &v10);\n    if ( !v11 )\n      break;\n    v14 = (char *)sub_40A09E(v14, v11 - a1 + v13 + v12 + 1);\n    memcpy(&v14[v13], a1, v11 - a1);\n    v13 += (_DWORD)v11 - (_DWORD)a1;\n    strcpy(&v14[v13], a3);\n    v13 += v12;\n    a1 = &v11[v10];\n  }\n  while ( a4 != 47 );\n  if ( *a1 && v14 )\n  {\n    v4 = v13;\n    v5 = strlen(a1);\n    v14 = (char *)sub_40A09E(v14, v4 + v5 + 1);\n    strcpy(&v14[v13], a1);\n  }\n  return v14;\n}\n",
        "output": "```c\nstatic char *\nsub_484AC9(unsigned char *start, unsigned char *end, const char *delimiter, char terminator)\n{\n  size_t delimiter_length; // Length of the delimiter\n  unsigned int result_length; // Current length of the result string\n  unsigned int total_length; // Total length needed for the result string\n  char *result; // Resulting string\n  unsigned char *substring; // Substring from start to end\n  int substring_length; // Length of the substring\n\n  result = NULL;\n  result_length = 0;\n  delimiter_length = strlen(delimiter);\n  \n  while (1)\n  {\n    substring = sub_484A4F(start, end, &substring_length);\n    if (!substring)\n      break;\n\n    // Calculate the new total length needed for the result string\n    total_length = (substring - start) + result_length + delimiter_length + 1;\n    result = (char *)sub_40A09E(result, total_length);\n\n    // Copy the substring to the result\n    memcpy(&result[result_length], start, substring - start);\n    result_length += (substring - start);\n\n    // Append the delimiter to the result\n    strcpy(&result[result_length], delimiter);\n    result_length += delimiter_length;\n\n    // Move the start pointer to the end of the processed substring\n    start = substring + substring_length;\n  }\n\n  // If the terminator is not found and there is remaining text, append it\n  if (*start && result)\n  {\n    size_t remaining_length = strlen(start);\n    total_length = result_length + remaining_length + 1;\n    result = (char *)sub_40A09E(result, total_length);\n    strcpy(&result[result_length], start);\n  }\n\n  return result;\n}\n```",
        "source_code": "static char *replace_pattern(char *val, const char *pattern, const char *repl, char exp_op)\n{\n\tchar *result = NULL;\n\tunsigned res_len = 0;\n\tunsigned repl_len = strlen(repl);\n\n\twhile (1) {\n\t\tint size;\n\t\tchar *s = strstr_pattern(val, pattern, &size);\n\t\tif (!s)\n\t\t\tbreak;\n\n\t\tresult = xrealloc(result, res_len + (s - val) + repl_len + 1);\n\t\tmemcpy(result + res_len, val, s - val);\n\t\tres_len += s - val;\n\t\tstrcpy(result + res_len, repl);\n\t\tres_len += repl_len;\n\t\tdebug_printf_varexp(\"val:'%s' s:'%s' result:'%s'\\n\", val, s, result);\n\n\t\tval = s + size;\n\t\tif (exp_op == '/')\n\t\t\tbreak;\n\t}\n\tif (val[0] && result) {\n\t\tresult = xrealloc(result, res_len + strlen(val) + 1);\n\t\tstrcpy(result + res_len, val);\n\t\tdebug_printf_varexp(\"val:'%s' result:'%s'\\n\", val, result);\n\t}\n\tdebug_printf_varexp(\"result:'%s'\\n\", result);\n\treturn result;\n}",
        "parsed_output": "static char *\nsub_484AC9(unsigned char *start, unsigned char *end, const char *delimiter, char terminator)\n{\n  size_t delimiter_length; // Length of the delimiter\n  unsigned int result_length; // Current length of the result string\n  unsigned int total_length; // Total length needed for the result string\n  char *result; // Resulting string\n  unsigned char *substring; // Substring from start to end\n  int substring_length; // Length of the substring\n\n  result = NULL;\n  result_length = 0;\n  delimiter_length = strlen(delimiter);\n  \n  while (1)\n  {\n    substring = sub_484A4F(start, end, &substring_length);\n    if (!substring)\n      break;\n\n    // Calculate the new total length needed for the result string\n    total_length = (substring - start) + result_length + delimiter_length + 1;\n    result = (char *)sub_40A09E(result, total_length);\n\n    // Copy the substring to the result\n    memcpy(&result[result_length], start, substring - start);\n    result_length += (substring - start);\n\n    // Append the delimiter to the result\n    strcpy(&result[result_length], delimiter);\n    result_length += delimiter_length;\n\n    // Move the start pointer to the end of the processed substring\n    start = substring + substring_length;\n  }\n\n  // If the terminator is not found and there is remaining text, append it\n  if (*start && result)\n  {\n    size_t remaining_length = strlen(start);\n    total_length = result_length + remaining_length + 1;\n    result = (char *)sub_40A09E(result, total_length);\n    strcpy(&result[result_length], start);\n  }\n\n  return result;\n}",
        "baseline_code_stripped": "char *__fastcall sub_484AC9(_BYTE *a1, _BYTE *a2, const char *a3, char a4)\n{\n  __int64 v4; // rbx\n  size_t v5; // rax\n  int v10; // [rsp+24h] [rbp-2Ch] BYREF\n  _BYTE *v11; // [rsp+28h] [rbp-28h]\n  unsigned int v12; // [rsp+30h] [rbp-20h]\n  unsigned int v13; // [rsp+34h] [rbp-1Ch]\n  char *v14; // [rsp+38h] [rbp-18h]\n\n  v14 = 0LL;\n  v13 = 0;\n  v12 = strlen(a3);\n  do\n  {\n    v11 = sub_484A4F(a1, a2, &v10);\n    if ( !v11 )\n      break;\n    v14 = (char *)sub_40A09E(v14, v11 - a1 + v13 + v12 + 1);\n    memcpy(&v14[v13], a1, v11 - a1);\n    v13 += (_DWORD)v11 - (_DWORD)a1;\n    strcpy(&v14[v13], a3);\n    v13 += v12;\n    a1 = &v11[v10];\n  }\n  while ( a4 != 47 );\n  if ( *a1 && v14 )\n  {\n    v4 = v13;\n    v5 = strlen(a1);\n    v14 = (char *)sub_40A09E(v14, v4 + v5 + 1);\n    strcpy(&v14[v13], a1);\n  }\n  return v14;\n}\n",
        "baseline_code_debug": "char *__cdecl replace_pattern(char *val, const char *pattern, const char *repl, char exp_op)\n{\n  __int64 v4; // rbx\n  size_t v5; // rax\n  int size; // [rsp+24h] [rbp-2Ch] BYREF\n  char *s; // [rsp+28h] [rbp-28h]\n  unsigned int repl_len; // [rsp+30h] [rbp-20h]\n  unsigned int res_len; // [rsp+34h] [rbp-1Ch]\n  char *result; // [rsp+38h] [rbp-18h]\n\n  result = 0LL;\n  res_len = 0;\n  repl_len = strlen(repl);\n  do\n  {\n    s = strstr_pattern(val, pattern, &size);\n    if ( !s )\n      break;\n    result = (char *)xrealloc(result, s - val + res_len + repl_len + 1);\n    memcpy(&result[res_len], val, s - val);\n    res_len += (_DWORD)s - (_DWORD)val;\n    strcpy(&result[res_len], repl);\n    res_len += repl_len;\n    val = &s[size];\n  }\n  while ( exp_op != 47 );\n  if ( *val && result )\n  {\n    v4 = res_len;\n    v5 = strlen(val);\n    result = (char *)xrealloc(result, v4 + v5 + 1);\n    strcpy(&result[res_len], val);\n  }\n  return result;\n}\n",
        "similarity_score_unixcoder": 0.6547317504882812,
        "similarity_score_baseline_stripped": 0.6157146096229553,
        "similarity_score_baseline_debug": 0.8986181020736694
    },
    {
        "func_name": "skip_header",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n\n## Example:\n\n Input code:\nint __cdecl hextobin(unsigned __int8 c)\n{\n  int v2; // [rsp+10h] [rbp-4h]\n\n  switch ( c )\n  {\n    case 'A':\n    case 'a':\n      v2 = 10;\n      break;\n    case 'B':\n    case 'b':\n      v2 = 11;\n      break;\n    case 'C':\n    case 'c':\n      v2 = 12;\n      break;\n    case 'D':\n    case 'd':\n      v2 = 13;\n      break;\n    case 'E':\n    case 'e':\n      v2 = 14;\n      break;\n    case 'F':\n    case 'f':\n      v2 = 15;\n      break;\n    default:\n      v2 = c - 48;\n      break;\n  }\n  return v2;\n}\n\n\n Revised code:\nstatic int\nhextobin (unsigned char c)\n{\n  switch (c)\n    {\n    default: return c - '0';\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_4B43ED()\n{\n  int v0; // ebx\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  uint32_t v5; // ebx\n  int v7[7]; // [rsp+0h] [rbp-30h] BYREF\n  unsigned int v8; // [rsp+1Ch] [rbp-14h]\n\n  sub_507452(0LL, v7, 16LL);\n  v0 = v7[0];\n  if ( v0 != htonl(0x8EADE801) )\n    sub_40969E(\"invalid RPM header magic or unsupported version\", (__int64)v7, v1, v2, v3, v4);\n  v5 = 16 * ntohl(v7[2]);\n  v8 = v5 + ntohl(v7[3]);\n  sub_4C341A(0LL, v8);\n  return v8 + 16;\n}\n",
        "output": "```c\nstatic uint32_t\nsub_4B43ED()\n{\n  int header[7]; // Buffer to store header\n  uint32_t header_size; // Size of the header\n  uint32_t total_size; // Total size including header\n\n  // Read the RPM header\n  sub_507452(0LL, header, 16LL);\n\n  // Check for RPM header magic number and version\n  if (header[0] != htonl(0x8EADE801))\n    sub_40969E(\"invalid RPM header magic or unsupported version\");\n\n  // Calculate the size of the header\n  header_size = 16 * ntohl(header[2]);\n\n  // Calculate the total size including the header\n  total_size = header_size + ntohl(header[3]);\n\n  // Perform some operation with the total size\n  sub_4C341A(0LL, total_size);\n\n  // Return the total size including the fixed 16-byte header\n  return total_size + 16;\n}\n```",
        "source_code": "static unsigned skip_header(void)\n{\n\tstruct rpm_header header;\n\tunsigned len;\n\n\txread(rpm_fd, &header, sizeof(header));\n//\tif (strncmp((char *) &header.magic, RPM_HEADER_MAGIC_STR, 3) != 0) {\n//\t\tbb_error_msg_and_die(\"invalid RPM header magic\");\n//\t}\n//\tif (header.version != 1) {\n//\t\tbb_error_msg_and_die(\"unsupported RPM header version\");\n//\t}\n\tif (header.magic_and_ver != htonl(RPM_HEADER_MAGICnVER)) {\n\t\tbb_error_msg_and_die(\"invalid RPM header magic or unsupported version\");\n\t\t// \": %x != %x\", header.magic_and_ver, htonl(RPM_HEADER_MAGICnVER));\n\t}\n\n\t/* Seek past index entries, and past store */\n\tlen = 16 * ntohl(header.entries) + ntohl(header.size);\n\tseek_by_jump(rpm_fd, len);\n\n\treturn sizeof(header) + len;\n}",
        "parsed_output": "static uint32_t\nsub_4B43ED()\n{\n  int header[7]; // Buffer to store header\n  uint32_t header_size; // Size of the header\n  uint32_t total_size; // Total size including header\n\n  // Read the RPM header\n  sub_507452(0LL, header, 16LL);\n\n  // Check for RPM header magic number and version\n  if (header[0] != htonl(0x8EADE801))\n    sub_40969E(\"invalid RPM header magic or unsupported version\");\n\n  // Calculate the size of the header\n  header_size = 16 * ntohl(header[2]);\n\n  // Calculate the total size including the header\n  total_size = header_size + ntohl(header[3]);\n\n  // Perform some operation with the total size\n  sub_4C341A(0LL, total_size);\n\n  // Return the total size including the fixed 16-byte header\n  return total_size + 16;\n}",
        "baseline_code_stripped": "__int64 sub_4B43ED()\n{\n  int v0; // ebx\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  uint32_t v5; // ebx\n  int v7[7]; // [rsp+0h] [rbp-30h] BYREF\n  unsigned int v8; // [rsp+1Ch] [rbp-14h]\n\n  sub_507452(0LL, v7, 16LL);\n  v0 = v7[0];\n  if ( v0 != htonl(0x8EADE801) )\n    sub_40969E(\"invalid RPM header magic or unsupported version\", (__int64)v7, v1, v2, v3, v4);\n  v5 = 16 * ntohl(v7[2]);\n  v8 = v5 + ntohl(v7[3]);\n  sub_4C341A(0LL, v8);\n  return v8 + 16;\n}\n",
        "baseline_code_debug": "unsigned int __cdecl skip_header()\n{\n  uint32_t magic_and_ver; // ebx\n  uint32_t v1; // ebx\n  rpm_header header; // [rsp+0h] [rbp-30h] BYREF\n  unsigned int len; // [rsp+1Ch] [rbp-14h]\n\n  xread(0, &header, 0x10uLL);\n  magic_and_ver = header.magic_and_ver;\n  if ( magic_and_ver != htonl(0x8EADE801) )\n    bb_error_msg_and_die(\"invalid RPM header magic or unsupported version\");\n  v1 = 16 * ntohl(header.entries);\n  len = v1 + ntohl(header.size);\n  seek_by_jump(0, len);\n  return len + 16;\n}\n",
        "similarity_score_unixcoder": 0.706896185874939,
        "similarity_score_baseline_stripped": 0.5757800340652466,
        "similarity_score_baseline_debug": 0.8326693773269653
    },
    {
        "func_name": "ttysize_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl format_address_std(uintmax_t address, char c)\n{\n  char *v2; // rax\n  char *v3; // rcx\n  char *v4; // rax\n  char *v5; // rax\n  const char *pbound; // [rsp+20h] [rbp-40h]\n  char *p; // [rsp+28h] [rbp-38h]\n  char buf[25]; // [rsp+30h] [rbp-30h] BYREF\n  char ca; // [rsp+57h] [rbp-9h]\n  uintmax_t addressa; // [rsp+58h] [rbp-8h]\n\n  addressa = address;\n  ca = c;\n  buf[24] = 0;\n  p = &buf[23];\n  buf[23] = c;\n  pbound = &buf[-address_pad_len + 23];\n  switch ( address_base )\n  {\n    case 8:\n      do\n      {\n        v2 = p--;\n        *(v2 - 1) = (addressa & 7) + 48;\n        addressa >>= 3;\n      }\n      while ( addressa );\n      break;\n    case 10:\n      do\n      {\n        v3 = p--;\n        *(v3 - 1) = addressa % 0xA + 48;\n        addressa /= 0xAuLL;\n      }\n      while ( addressa );\n      break;\n    case 16:\n      do\n      {\n        v4 = p--;\n        *(v4 - 1) = byte_4097D0[addressa & 0xF];\n        addressa >>= 4;\n      }\n      while ( addressa );\n      break;\n  }\n  while ( pbound < p )\n  {\n    v5 = p--;\n    *(v5 - 1) = 48;\n  }\n  fputs_unlocked(p, _bss_start);\n}\n\n\n Revised code:\nstatic void\nformat_address_std (uintmax_t address, char c)\n{\n  char buf[MAX_ADDRESS_LENGTH + 2];\n  char *p = buf + sizeof buf;\n  char const *pbound;\n\n  *--p = '\\0';\n  *--p = c;\n  pbound = p - address_pad_len;\n\n  /* Use a special case of the code for each base.  This is measurably\n     faster than generic code.  */\n  switch (address_base)\n    {\n    case 8:\n      do\n\t*--p = '0' + (address & 7);\n      while ((address >>= 3) != 0);\n      break;\n\n    case 10:\n      do\n\t*--p = '0' + (address % 10);\n      while ((address /= 10) != 0);\n      break;\n\n    case 16:\n      do\n\t*--p = \"0123456789abcdef\"[address & 15];\n      while ((address >>= 4) != 0);\n      break;\n    }\n\n  while (pbound < p)\n    *--p = '0';\n\n  fputs (p, stdout);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  unsigned __int8 *v3; // rax\n  const char *v4; // rdi\n  char buf[5]; // [rsp+33h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+38h] [rbp-38h]\n  unsigned __int8 c; // [rsp+47h] [rbp-29h]\n  size_t i; // [rsp+48h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+50h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+58h] [rbp-18h]\n  const void *blocka; // [rsp+60h] [rbp-10h]\n  size_t n_bytesa; // [rsp+68h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = (unsigned __int8 *)p++;\n    c = *v3;\n    switch ( c )\n    {\n      case 0u:\n        s = \" \\\\0\";\n        break;\n      case 7u:\n        s = (const char *)&unk_409AA8;\n        break;\n      case 8u:\n        s = (const char *)&unk_409AAC;\n        break;\n      case 9u:\n        s = (const char *)&unk_409ABC;\n        break;\n      case 0xAu:\n        s = (const char *)&unk_409AB4;\n        break;\n      case 0xBu:\n        s = (const char *)&unk_409AC0;\n        break;\n      case 0xCu:\n        s = (const char *)&unk_409AB0;\n        break;\n      case 0xDu:\n        s = (const char *)&unk_409AB8;\n        break;\n      default:\n        v4 = \"%03o\";\n        if ( ((*__ctype_b_loc())[c] & 0x4000) != 0 )\n          v4 = \"  %c\";\n        sprintf(buf, v4, c);\n        s = buf;\n        break;\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_ascii (size_t n_bytes, void const *block,\n\t     const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      unsigned char c = *p++;\n      const char *s;\n      char buf[5];\n\n      switch (c)\n\t{\n\tcase '\\0':\n\t  s = \" \\\\0\";\n\t  break;\n\n\tcase '\\a':\n\t  s = \" \\\\a\";\n\t  break;\n\n\tcase '\\b':\n\t  s = \" \\\\b\";\n\t  break;\n\n\tcase '\\f':\n\t  s = \" \\\\f\";\n\t  break;\n\n\tcase '\\n':\n\t  s = \" \\\\n\";\n\t  break;\n\n\tcase '\\r':\n\t  s = \" \\\\r\";\n\t  break;\n\n\tcase '\\t':\n\t  s = \" \\\\t\";\n\t  break;\n\n\tcase '\\v':\n\t  s = \" \\\\v\";\n\t  break;\n\n\tdefault:\n\t  sprintf (buf, (isprint (c) ? \"  %c\" : \"%03o\"), c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl get_format_width(char **format_ptr)\n{\n  char *v1; // rax\n  unsigned __int64 val; // [rsp+10h] [rbp-10h] BYREF\n  char **format_ptra; // [rsp+18h] [rbp-8h]\n\n  format_ptra = format_ptr;\n  val = 0LL;\n  if ( (unsigned int)(**format_ptr - 48) <= 9 && xstrtoul(*format_ptra, format_ptra, 10, &val, 0LL) )\n  {\n    v1 = gettext(\"invalid format width\");\n    error(1, 0, v1);\n  }\n  if ( val <= 0xB )\n    return 11LL;\n  else\n    return val;\n}\n\n\n Revised code:\nstatic size_t\nget_format_width (char **format_ptr)\n{\n  unsigned long int val = 0;\n\n  if (ISDIGIT (**format_ptr)\n      && (xstrtoul (*format_ptr, format_ptr, 10, &val, NULL) != LONGINT_OK\n\t  || SIZE_MAX < val))\n    error (EXIT_FAILURE, 0, _(\"invalid format width\"));\n\n  /* Allow for enough octal digits to represent the value of UINT_MAX,\n     even if the field width is less than that.  */\n  return MAX (val, (sizeof (unsigned int) * CHAR_BIT + 2) / 3);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4239A3(__int64 a1, __int64 *a2)\n{\n  __int64 *v3; // [rsp+0h] [rbp-40h]\n  __int16 v4[4]; // [rsp+1Eh] [rbp-22h] BYREF\n  char v5; // [rsp+27h] [rbp-19h]\n  char *v6; // [rsp+28h] [rbp-18h]\n  char *format; // [rsp+30h] [rbp-10h]\n  unsigned int v8; // [rsp+38h] [rbp-8h]\n  unsigned int v9; // [rsp+3Ch] [rbp-4h]\n\n  v3 = a2;\n  v9 = 80;\n  v8 = 24;\n  if ( !ioctl(0, 0x5413uLL, v4) )\n  {\n    v9 = (unsigned __int16)v4[1];\n    v8 = (unsigned __int16)v4[0];\n  }\n  if ( a2[1] )\n  {\n    for ( format = (_BYTE *)(\"%u %u\" + 3); ; format = (_BYTE *)(\"%u %u\" + 2) )\n    {\n      v6 = (char *)*++v3;\n      if ( !v6 )\n        break;\n      v5 = *v6;\n      if ( v5 == 119 )\n        printf(format, v9);\n      if ( v5 == 104 )\n        printf(format, v8);\n    }\n  }\n  else\n  {\n    printf(\"%u %u\", v9, v8);\n  }\n  sub_40A659(10);\n  return 0LL;\n}\n",
        "output": "```c\nstatic void sub_4239A3(int fd, char **args)\n{\n  unsigned short winsize[2]; // [rows, cols]\n  unsigned int width = 80;   // Default width\n  unsigned int height = 24;  // Default height\n\n  // Try to get window size\n  if (!ioctl(fd, TIOCGWINSZ, winsize))\n  {\n    height = winsize[0];\n    width = winsize[1];\n  }\n\n  // If there are additional arguments\n  if (args[1])\n  {\n    for (args++; *args; args++)\n    {\n      char firstChar = **args;\n      if (firstChar == 'w') // Check for 'w' to print width\n        printf(\"%u \", width);\n      if (firstChar == 'h') // Check for 'h' to print height\n        printf(\"%u \", height);\n    }\n  }\n  else\n  {\n    // Print default width and height\n    printf(\"%u %u\", width, height);\n  }\n\n  // Call another function (presumably to print a newline)\n  sub_40A659(10);\n}\n```",
        "source_code": "int ttysize_main(int argc UNUSED_PARAM, char **argv)\n{\n\tunsigned w, h;\n\tstruct winsize wsz;\n\n\tw = 80;\n\th = 24;\n\tif (!ioctl(0, TIOCGWINSZ, &wsz)) {\n\t\tw = wsz.ws_col;\n\t\th = wsz.ws_row;\n\t}\n\n\tif (!argv[1]) {\n\t\tprintf(\"%u %u\", w, h);\n\t} else {\n\t\tconst char *fmt, *arg;\n\n\t\tfmt = \"%u %u\" + 3; /* \"%u\" */\n\t\twhile ((arg = *++argv) != NULL) {\n\t\t\tchar c = arg[0];\n\t\t\tif (c == 'w')\n\t\t\t\tprintf(fmt, w);\n\t\t\tif (c == 'h')\n\t\t\t\tprintf(fmt, h);\n\t\t\tfmt = \"%u %u\" + 2; /* \" %u\" */\n\t\t}\n\t}\n\tbb_putchar('\\n');\n\treturn 0;\n}",
        "parsed_output": "static void sub_4239A3(int fd, char **args)\n{\n  unsigned short winsize[2]; // [rows, cols]\n  unsigned int width = 80;   // Default width\n  unsigned int height = 24;  // Default height\n\n  // Try to get window size\n  if (!ioctl(fd, TIOCGWINSZ, winsize))\n  {\n    height = winsize[0];\n    width = winsize[1];\n  }\n\n  // If there are additional arguments\n  if (args[1])\n  {\n    for (args++; *args; args++)\n    {\n      char firstChar = **args;\n      if (firstChar == 'w') // Check for 'w' to print width\n        printf(\"%u \", width);\n      if (firstChar == 'h') // Check for 'h' to print height\n        printf(\"%u \", height);\n    }\n  }\n  else\n  {\n    // Print default width and height\n    printf(\"%u %u\", width, height);\n  }\n\n  // Call another function (presumably to print a newline)\n  sub_40A659(10);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4239A3(__int64 a1, __int64 *a2)\n{\n  __int64 *v3; // [rsp+0h] [rbp-40h]\n  __int16 v4[4]; // [rsp+1Eh] [rbp-22h] BYREF\n  char v5; // [rsp+27h] [rbp-19h]\n  char *v6; // [rsp+28h] [rbp-18h]\n  char *format; // [rsp+30h] [rbp-10h]\n  unsigned int v8; // [rsp+38h] [rbp-8h]\n  unsigned int v9; // [rsp+3Ch] [rbp-4h]\n\n  v3 = a2;\n  v9 = 80;\n  v8 = 24;\n  if ( !ioctl(0, 0x5413uLL, v4) )\n  {\n    v9 = (unsigned __int16)v4[1];\n    v8 = (unsigned __int16)v4[0];\n  }\n  if ( a2[1] )\n  {\n    for ( format = (_BYTE *)(\"%u %u\" + 3); ; format = (_BYTE *)(\"%u %u\" + 2) )\n    {\n      v6 = (char *)*++v3;\n      if ( !v6 )\n        break;\n      v5 = *v6;\n      if ( v5 == 119 )\n        printf(format, v9);\n      if ( v5 == 104 )\n        printf(format, v8);\n    }\n  }\n  else\n  {\n    printf(\"%u %u\", v9, v8);\n  }\n  sub_40A659(10);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl ttysize_main(int argc, char **argv)\n{\n  char **argva; // [rsp+0h] [rbp-40h]\n  winsize wsz; // [rsp+1Eh] [rbp-22h] BYREF\n  char c; // [rsp+27h] [rbp-19h]\n  const char *arg; // [rsp+28h] [rbp-18h]\n  const char *fmt; // [rsp+30h] [rbp-10h]\n  unsigned int h; // [rsp+38h] [rbp-8h]\n  unsigned int w; // [rsp+3Ch] [rbp-4h]\n\n  argva = argv;\n  w = 80;\n  h = 24;\n  if ( !ioctl(0, 0x5413uLL, &wsz) )\n  {\n    w = wsz.ws_col;\n    h = wsz.ws_row;\n  }\n  if ( argv[1] )\n  {\n    for ( fmt = \"%u %u\" + 3; ; fmt = \"%u %u\" + 2 )\n    {\n      arg = *++argva;\n      if ( !arg )\n        break;\n      c = *arg;\n      if ( c == 119 )\n        printf(fmt, w);\n      if ( c == 104 )\n        printf(fmt, h);\n    }\n  }\n  else\n  {\n    printf(\"%u %u\", w, h);\n  }\n  bb_putchar(10);\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.8056212067604065,
        "similarity_score_baseline_stripped": 0.5537450313568115,
        "similarity_score_baseline_debug": 0.8687199354171753
    },
    {
        "func_name": "concat_subpath_file",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl hex_digits(const unsigned __int8 *s)\n{\n  while ( *s )\n  {\n    if ( ((*__ctype_b_loc())[*s] & 0x1000) == 0 )\n      return 0;\n    ++s;\n  }\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nhex_digits (unsigned char const *s)\n{\n  while (*s)\n    {\n      if (!isxdigit (*s))\n        return false;\n      ++s;\n    }\n  return true;\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl adjust_column(size_t column, char c)\n{\n  size_t columna; // [rsp+2h] [rbp-8h]\n\n  columna = column;\n  if ( count_bytes )\n    return column + 1;\n  switch ( c )\n  {\n    case 8:\n      if ( column )\n        return column - 1;\n      break;\n    case 13:\n      return 0LL;\n    case 9:\n      return column + 8 - (column & 7);\n    default:\n      return column + 1;\n  }\n  return columna;\n}\n\n\n Revised code:\nstatic size_t\nadjust_column (size_t column, char c)\n{\n  if (!count_bytes)\n    {\n      if (c == '\\b')\n\t{\n\t  if (column > 0)\n\t    column--;\n\t}\n      else if (c == '\\r')\n\tcolumn = 0;\n      else if (c == '\\t')\n\tcolumn += TAB_WIDTH - column % TAB_WIDTH;\n      else /* if (isprint (c)) */\n\tcolumn++;\n    }\n  else\n    column++;\n  return column;\n}\n\n## Example:\n\n Input code:\nbool __cdecl apply_suffix(double *x, char suffix_char)\n{\n  int multiplier; // [rsp+14h] [rbp-18h]\n\n  switch ( suffix_char )\n  {\n    case 0:\n      goto LABEL_6;\n    case 100:\n      multiplier = 86400;\n      goto LABEL_11;\n    case 104:\n      multiplier = 3600;\n      goto LABEL_11;\n    case 109:\n      multiplier = 60;\n      goto LABEL_11;\n    case 115:\nLABEL_6:\n      multiplier = 1;\nLABEL_11:\n      *x = (double)multiplier * *x;\n      return 1;\n  }\n  return 0;\n}\n\n\n Revised code:\nstatic bool\napply_suffix (double *x, char suffix_char)\n{\n  int multiplier;\n\n  switch (suffix_char)\n    {\n    case 0:\n    case 's':\n      multiplier = 1;\n      break;\n    case 'm':\n      multiplier = 60;\n      break;\n    case 'h':\n      multiplier = 60 * 60;\n      break;\n    case 'd':\n      multiplier = 60 * 60 * 24;\n      break;\n    default:\n      return false;\n    }\n\n  *x *= multiplier;\n\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4F67A0(void *a1, _BYTE *a2)\n{\n  if ( a2 && *a2 == 46 && (!a2[1] || a2[1] == 46 && !a2[2]) )\n    return 0LL;\n  else\n    return sub_408E19(a1, a2);\n}\n",
        "output": "```c\nstatic bool\nis_valid_filename(void *context, unsigned char *filename)\n{\n  if (filename && filename[0] == '.' &&\n      (filename[1] == '\\0' || (filename[1] == '.' && filename[2] == '\\0')))\n    return false;\n  else\n    return process_filename(context, filename);\n}\n```",
        "source_code": "FAST_FUNC concat_subpath_file(const char *path, const char *f)\n{\n\tif (f && DOT_OR_DOTDOT(f))\n\t\treturn NULL;\n\treturn concat_path_file(path, f);\n}",
        "parsed_output": "static bool\nis_valid_filename(void *context, unsigned char *filename)\n{\n  if (filename && filename[0] == '.' &&\n      (filename[1] == '\\0' || (filename[1] == '.' && filename[2] == '\\0')))\n    return false;\n  else\n    return process_filename(context, filename);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4F67A0(void *a1, _BYTE *a2)\n{\n  if ( a2 && *a2 == 46 && (!a2[1] || a2[1] == 46 && !a2[2]) )\n    return 0LL;\n  else\n    return sub_408E19(a1, a2);\n}\n",
        "baseline_code_debug": "char *__cdecl concat_subpath_file(const char *path, const char *f)\n{\n  if ( f && *f == 46 && (!f[1] || f[1] == 46 && !f[2]) )\n    return 0LL;\n  else\n    return concat_path_file(path, f);\n}\n",
        "similarity_score_unixcoder": 0.5593864917755127,
        "similarity_score_baseline_stripped": 0.493225634098053,
        "similarity_score_baseline_debug": 0.8297860622406006
    },
    {
        "func_name": "my_xstrtoll",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nsize_t __cdecl get_format_width(char **format_ptr)\n{\n  char *v1; // rax\n  unsigned __int64 val; // [rsp+10h] [rbp-10h] BYREF\n  char **format_ptra; // [rsp+18h] [rbp-8h]\n\n  format_ptra = format_ptr;\n  val = 0LL;\n  if ( (unsigned int)(**format_ptr - 48) <= 9 && xstrtoul(*format_ptra, format_ptra, 10, &val, 0LL) )\n  {\n    v1 = gettext(\"invalid format width\");\n    error(1, 0, v1);\n  }\n  if ( val <= 0xB )\n    return 11LL;\n  else\n    return val;\n}\n\n\n Revised code:\nstatic size_t\nget_format_width (char **format_ptr)\n{\n  unsigned long int val = 0;\n\n  if (ISDIGIT (**format_ptr)\n      && (xstrtoul (*format_ptr, format_ptr, 10, &val, NULL) != LONGINT_OK\n\t  || SIZE_MAX < val))\n    error (EXIT_FAILURE, 0, _(\"invalid format width\"));\n\n  /* Allow for enough octal digits to represent the value of UINT_MAX,\n     even if the field width is less than that.  */\n  return MAX (val, (sizeof (unsigned int) * CHAR_BIT + 2) / 3);\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl get_format_prec(char **format_ptr)\n{\n  char *v1; // rax\n  unsigned __int64 val; // [rsp+8h] [rbp-18h] BYREF\n  char **format_ptra; // [rsp+10h] [rbp-10h]\n\n  format_ptra = format_ptr;\n  if ( **format_ptr != 46 )\n    return 0LL;\n  if ( (unsigned int)(*++*format_ptra - 48) > 9 )\n    return 0LL;\n  if ( xstrtoul(*format_ptra, format_ptra, 10, &val, 0LL) )\n  {\n    v1 = gettext(\"invalid format precision\");\n    error(1, 0, v1);\n  }\n  return val;\n}\n\n\n Revised code:\nstatic size_t\nget_format_prec (char **format_ptr)\n{\n  if (**format_ptr != '.')\n    return 0;\n  (*format_ptr)++;\n\n  if (! ISDIGIT (**format_ptr))\n    return 0;\n  else\n    {\n      unsigned long int val;\n      if (xstrtoul (*format_ptr, format_ptr, 10, &val, NULL) != LONGINT_OK\n\t  || SIZE_MAX < val)\n\terror (EXIT_FAILURE, 0, _(\"invalid format precision\"));\n      return val;\n    }\n}\n\n## Example:\n\n Input code:\nvoid __cdecl format_address_std(uintmax_t address, char c)\n{\n  char *v2; // rax\n  char *v3; // rcx\n  char *v4; // rax\n  char *v5; // rax\n  const char *pbound; // [rsp+20h] [rbp-40h]\n  char *p; // [rsp+28h] [rbp-38h]\n  char buf[25]; // [rsp+30h] [rbp-30h] BYREF\n  char ca; // [rsp+57h] [rbp-9h]\n  uintmax_t addressa; // [rsp+58h] [rbp-8h]\n\n  addressa = address;\n  ca = c;\n  buf[24] = 0;\n  p = &buf[23];\n  buf[23] = c;\n  pbound = &buf[-address_pad_len + 23];\n  switch ( address_base )\n  {\n    case 8:\n      do\n      {\n        v2 = p--;\n        *(v2 - 1) = (addressa & 7) + 48;\n        addressa >>= 3;\n      }\n      while ( addressa );\n      break;\n    case 10:\n      do\n      {\n        v3 = p--;\n        *(v3 - 1) = addressa % 0xA + 48;\n        addressa /= 0xAuLL;\n      }\n      while ( addressa );\n      break;\n    case 16:\n      do\n      {\n        v4 = p--;\n        *(v4 - 1) = byte_4097D0[addressa & 0xF];\n        addressa >>= 4;\n      }\n      while ( addressa );\n      break;\n  }\n  while ( pbound < p )\n  {\n    v5 = p--;\n    *(v5 - 1) = 48;\n  }\n  fputs_unlocked(p, _bss_start);\n}\n\n\n Revised code:\nstatic void\nformat_address_std (uintmax_t address, char c)\n{\n  char buf[MAX_ADDRESS_LENGTH + 2];\n  char *p = buf + sizeof buf;\n  char const *pbound;\n\n  *--p = '\\0';\n  *--p = c;\n  pbound = p - address_pad_len;\n\n  /* Use a special case of the code for each base.  This is measurably\n     faster than generic code.  */\n  switch (address_base)\n    {\n    case 8:\n      do\n\t*--p = '0' + (address & 7);\n      while ((address >>= 3) != 0);\n      break;\n\n    case 10:\n      do\n\t*--p = '0' + (address % 10);\n      while ((address /= 10) != 0);\n      break;\n\n    case 16:\n      do\n\t*--p = \"0123456789abcdef\"[address & 15];\n      while ((address >>= 4) != 0);\n      break;\n    }\n\n  while (pbound < p)\n    *--p = '0';\n\n  fputs (p, stdout);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4CFB56(_BYTE *a1)\n{\n  __int64 v2; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( (unsigned int)sub_4CF9A2(a1, (__int64)&v2, (void (__fastcall *)(_BYTE *, __int64))sub_4CFA97) )\n    return 0LL;\n  return v2;\n}\n",
        "output": "```c\nstatic int64_t\nsub_4CFB56 (uint8_t *a1)\n{\n  int64_t result;\n\n  if (sub_4CF9A2 (a1, &result, sub_4CFA97) != 0)\n    return 0;\n  return result;\n}\n```",
        "source_code": "static long long my_xstrtoll(const char *arg)\n{\n\tlong long result;\n\tif (multiconvert(arg, &result, conv_strtoll))\n\t\tresult = 0;\n\treturn result;\n}",
        "parsed_output": "static int64_t\nsub_4CFB56 (uint8_t *a1)\n{\n  int64_t result;\n\n  if (sub_4CF9A2 (a1, &result, sub_4CFA97) != 0)\n    return 0;\n  return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4CFB56(_BYTE *a1)\n{\n  __int64 v2; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( (unsigned int)sub_4CF9A2(a1, (__int64)&v2, (void (__fastcall *)(_BYTE *, __int64))sub_4CFA97) )\n    return 0LL;\n  return v2;\n}\n",
        "baseline_code_debug": "__int64 __cdecl my_xstrtoll(const char *arg)\n{\n  __int64 result; // [rsp+18h] [rbp-8h] BYREF\n\n  if ( multiconvert(arg, &result, (converter)conv_strtoll) )\n    return 0LL;\n  return result;\n}\n",
        "similarity_score_unixcoder": 0.421734094619751,
        "similarity_score_baseline_stripped": 0.3933054208755493,
        "similarity_score_baseline_debug": 0.7716063857078552
    },
    {
        "func_name": "finalize",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl sysv_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  int *v5; // rax\n  char *v6; // rax\n  size_t bytes_read; // [rsp+20h] [rbp-22E0h]\n  size_t i; // [rsp+28h] [rbp-22D8h]\n  _BYTE is_stdin[5]; // [rsp+33h] [rbp-22CDh]\n  char hbuf[652]; // [rsp+40h] [rbp-22C0h] BYREF\n  uintmax_t total_bytes; // [rsp+2D8h] [rbp-2028h]\n  unsigned __int8 buf[8192]; // [rsp+2E0h] [rbp-2020h] BYREF\n  int fd; // [rsp+22E8h] [rbp-18h]\n  int print_namea; // [rsp+22ECh] [rbp-14h]\n  const char *filea; // [rsp+22F0h] [rbp-10h]\n  char v17; // [rsp+22FFh] [rbp-1h]\n\n  filea = file;\n  print_namea = print_name;\n  total_bytes = 0LL;\n  is_stdin[4] = 0;\n  v2 = strcmp(file, \"-\");\n  *(_DWORD *)is_stdin = v2 == 0;\n  if ( !v2 )\n  {\n    fd = 0;\n    have_read_stdin = 1;\n    goto LABEL_5;\n  }\n  fd = open(filea, 0);\n  if ( fd == -1 )\n  {\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    v17 = 0;\n  }\n  else\n  {\nLABEL_5:\n    while ( 1 )\n    {\n      bytes_read = safe_read(fd, buf, 0x2000uLL);\n      if ( !bytes_read )\n        break;\n      if ( bytes_read == -1LL )\n      {\n        v4 = __errno_location();\n        error(0, *v4, \"%s\", filea);\n        if ( (is_stdin[0] & 1) == 0 )\n          close(fd);\n        v17 = 0;\n        return v17 & 1;\n      }\n      for ( i = 0LL; i < bytes_read; ++i )\n        *(_DWORD *)&is_stdin[1] += buf[i];\n      total_bytes += bytes_read;\n    }\n    if ( (is_stdin[0] & 1) != 0 || !close(fd) )\n    {\n      v6 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x200uLL);\n      printf(\n        \"%d %s\",\n        ((HIWORD(*(_DWORD *)&is_stdin[1]) + *(unsigned __int16 *)&is_stdin[1]) >> 16)\n      + (unsigned int)(unsigned __int16)(*(_WORD *)&is_stdin[3] + *(_WORD *)&is_stdin[1]),\n        v6);\n      if ( print_namea )\n        printf(\" %s\", filea);\n      putchar_unlocked(10);\n      v17 = 1;\n    }\n    else\n    {\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filea);\n      v17 = 0;\n    }\n  }\n  return v17 & 1;\n}\n\n\n Revised code:\nstatic bool\nsysv_sum_file (const char *file, int print_name)\n{\n  int fd;\n  unsigned char buf[8192];\n  uintmax_t total_bytes = 0;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int r;\n  int checksum;\n\n  /* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n  unsigned int s = 0;\n\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fd = STDIN_FILENO;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while (1)\n    {\n      size_t i;\n      size_t bytes_read = safe_read (fd, buf, sizeof buf);\n\n      if (bytes_read == 0)\n\tbreak;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  if (!is_stdin)\n\t    close (fd);\n\t  return false;\n\t}\n\n      for (i = 0; i < bytes_read; i++)\n\ts += buf[i];\n      total_bytes += bytes_read;\n    }\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  checksum = (r & 0xffff) + (r >> 16);\n\n  printf (\"%d %s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 512));\n  if (print_name)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_runlevel(const STRUCT_UTMP *utmp_ent)\n{\n  char *v1; // rax\n  size_t v2; // rax\n  char *v3; // rax\n  char *v4; // rax\n  size_t v5; // rax\n  const char *v6; // rax\n  char *line; // [rsp+30h] [rbp-40h]\n  unsigned int v8; // [rsp+3Ch] [rbp-34h]\n  char *v9; // [rsp+40h] [rbp-30h]\n  char *v10; // [rsp+48h] [rbp-28h]\n  char *s; // [rsp+58h] [rbp-18h]\n  unsigned __int8 curr; // [rsp+66h] [rbp-Ah]\n  unsigned __int8 last; // [rsp+67h] [rbp-9h]\n\n  last = utmp_ent->ut_pid / 256;\n  curr = utmp_ent->ut_pid % 256;\n  if ( !print_runlevel_runlevline )\n  {\n    v1 = gettext(\"run-level\");\n    v2 = strlen(v1);\n    print_runlevel_runlevline = (char *)xmalloc(v2 + 3);\n  }\n  s = print_runlevel_runlevline;\n  v3 = gettext(\"run-level\");\n  sprintf(s, \"%s %c\", v3, curr);\n  if ( !print_runlevel_comment )\n  {\n    v4 = gettext(\"last=\");\n    v5 = strlen(v4);\n    print_runlevel_comment = (char *)xmalloc(v5 + 2);\n  }\n  v10 = print_runlevel_comment;\n  v9 = gettext(\"last=\");\n  if ( last == 78 )\n    v8 = 83;\n  else\n    v8 = last;\n  sprintf(v10, \"%s%c\", v9, v8);\n  line = print_runlevel_runlevline;\n  v6 = time_string(utmp_ent);\n  print_line(-1, \"\", 32, -1, line, v6, \"\", \"\", print_runlevel_comment, \"\");\n}\n\n\n Revised code:\nstatic void\nprint_runlevel (const STRUCT_UTMP *utmp_ent)\n{\n  static char *runlevline, *comment;\n  unsigned char last = UT_PID (utmp_ent) / 256;\n  unsigned char curr = UT_PID (utmp_ent) % 256;\n\n  if (!runlevline)\n    runlevline = xmalloc (strlen (_(\"run-level\")) + 3);\n  sprintf (runlevline, \"%s %c\", _(\"run-level\"), curr);\n\n  if (!comment)\n    comment = xmalloc (strlen (_(\"last=\")) + 2);\n  sprintf (comment, \"%s%c\", _(\"last=\"), (last == 'N') ? 'S' : last);\n\n  print_line (-1, \"\", ' ', -1, runlevline, time_string (utmp_ent),\n\t      \"\", \"\", comment, \"\");\n\n  return;\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  char *v5; // rax\n  unsigned int v7; // [rsp+14h] [rbp-2CCh]\n  bool is_stdin; // [rsp+1Fh] [rbp-2C1h]\n  char hbuf[652]; // [rsp+20h] [rbp-2C0h] BYREF\n  int ch_0; // [rsp+2ACh] [rbp-34h]\n  uintmax_t total_bytes; // [rsp+2B0h] [rbp-30h]\n  int checksum; // [rsp+2BCh] [rbp-24h]\n  FILE *fp; // [rsp+2C0h] [rbp-20h]\n  int print_namea; // [rsp+2CCh] [rbp-14h]\n  const char *filea; // [rsp+2D0h] [rbp-10h]\n\n  filea = file;\n  print_namea = print_name;\n  checksum = 0;\n  total_bytes = 0LL;\n  v2 = strcmp(file, \"-\");\n  is_stdin = v2 == 0;\n  if ( v2 )\n  {\n    fp = fopen(filea, \"r\");\n    if ( !fp )\n      goto LABEL_4;\n  }\n  else\n  {\n    fp = stdin;\n    have_read_stdin = 1;\n  }\n  while ( 1 )\n  {\n    ch_0 = getc_unlocked(fp);\n    if ( ch_0 == -1 )\n      break;\n    ++total_bytes;\n    checksum = (unsigned __int16)(((checksum & 1) << 15) + (checksum >> 1) + ch_0);\n  }\n  if ( ferror_unlocked(fp) )\n  {\n    v4 = __errno_location();\n    error(0, *v4, \"%s\", filea);\n    if ( !is_stdin )\n      fclose(fp);\n    return 0;\n  }\n  if ( !is_stdin && fclose(fp) )\n  {\nLABEL_4:\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    return 0;\n  }\n  v7 = checksum;\n  v5 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x400uLL);\n  printf(\"%05d %5s\", v7, v5);\n  if ( print_namea > 1 )\n    printf(\" %s\", filea);\n  putchar_unlocked(10);\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_sum_file (const char *file, int print_name)\n{\n  FILE *fp;\n  int checksum = 0;\t/* The checksum mod 2^16. */\n  uintmax_t total_bytes = 0;\t/* The number of bytes. */\n  int ch;\t\t/* Each character read. */\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fp = stdin;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fp = fopen (file, (O_BINARY ? \"rb\" : \"r\"));\n      if (fp == NULL)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while ((ch = getc (fp)) != EOF)\n    {\n      total_bytes++;\n      checksum = (checksum >> 1) + ((checksum & 1) << 15);\n      checksum += ch;\n      checksum &= 0xffff;\t/* Keep it within bounds. */\n    }\n\n  if (ferror (fp))\n    {\n      error (0, errno, \"%s\", file);\n      if (!is_stdin)\n\tfclose (fp);\n      return false;\n    }\n\n  if (!is_stdin && fclose (fp) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  printf (\"%05d %5s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 1024));\n  if (print_name > 1)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_4F4459(const char *a1, const char *a2, int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  const char *v7; // rax\n  char *v8; // rax\n  int result; // eax\n  struct tm tp; // [rsp+20h] [rbp-230h] BYREF\n  char s[64]; // [rsp+60h] [rbp-1F0h] BYREF\n  struct utsname name; // [rsp+A0h] [rbp-1B0h] BYREF\n  time_t timer; // [rsp+230h] [rbp-20h] BYREF\n  const char *v15; // [rsp+238h] [rbp-18h]\n  const char *v16; // [rsp+240h] [rbp-10h]\n  FILE *stream; // [rsp+248h] [rbp-8h]\n\n  stream = sub_40A1FC(\"header\", \"w\");\n  if ( a3 )\n    acct(0LL);\n  if ( a2 )\n    fprintf(stream, \"profile.process = %s\\n\", a2);\n  fwrite_unlocked(\"version = 0.8\\n\", 1uLL, 0xEuLL, stream);\n  v16 = (const char *)sub_507F01();\n  time(&timer);\n  localtime_r(&timer, &tp);\n  strftime(s, 0x3CuLL, \"%a %b %e %H:%M:%S %Z %Y\", &tp);\n  fprintf(stream, \"title = Boot chart for %s (%s)\\n\", v16, s);\n  uname(&name);\n  fprintf(stream, \"system.uname = %s %s %s %s\\n\", name.sysname, name.release, name.version, name.machine);\n  v15 = (const char *)sub_5073F7(\"/proc/cmdline\", 0LL);\n  fprintf(stream, \"system.kernel.options = %s\", v15);\n  fclose(stream);\n  if ( a3 )\n    v7 = \"kernel_pacct\";\n  else\n    v7 = (const char *)&unk_527CFA;\n  v8 = sub_40A6B3(\"tar -zcf /var/log/bootlog.tgz header %s *.log\", (__int64)v7, v3, v4, v5, v6);\n  result = system(v8);\n  if ( a1 )\n  {\n    unlink(\"header\");\n    unlink(\"proc_stat.log\");\n    unlink(\"proc_diskstats.log\");\n    unlink(\"proc_ps.log\");\n    if ( a3 )\n      unlink(\"kernel_pacct\");\n    return rmdir(a1);\n  }\n  return result;\n}\n",
        "output": "```c\nstatic int\ncreate_bootchart(const char *output_dir, const char *process_name, int enable_accounting)\n{\n  time_t timer;\n  struct tm tp;\n  char timestamp[64];\n  struct utsname system_info;\n  FILE *header_file;\n  const char *bootchart_version = \"0.8\";\n  const char *system_id;\n  const char *kernel_options;\n  char *tar_command;\n  int result;\n\n  header_file = fopen(\"header\", \"w\");\n  if (enable_accounting)\n    acct(NULL);\n\n  if (process_name)\n    fprintf(header_file, \"profile.process = %s\\n\", process_name);\n\n  fprintf(header_file, \"version = %s\\n\", bootchart_version);\n\n  system_id = get_system_id();\n  time(&timer);\n  localtime_r(&timer, &tp);\n  strftime(timestamp, sizeof(timestamp), \"%a %b %e %H:%M:%S %Z %Y\", &tp);\n  fprintf(header_file, \"title = Boot chart for %s (%s)\\n\", system_id, timestamp);\n\n  uname(&system_info);\n  fprintf(header_file, \"system.uname = %s %s %s %s\\n\",\n          system_info.sysname, system_info.release, system_info.version, system_info.machine);\n\n  kernel_options = get_kernel_options(\"/proc/cmdline\");\n  fprintf(header_file, \"system.kernel.options = %s\", kernel_options);\n\n  fclose(header_file);\n\n  const char *pacct_file = enable_accounting ? \"kernel_pacct\" : \"\";\n  tar_command = create_tar_command(\"tar -zcf /var/log/bootlog.tgz header %s *.log\", pacct_file);\n  result = system(tar_command);\n\n  if (output_dir)\n  {\n    unlink(\"header\");\n    unlink(\"proc_stat.log\");\n    unlink(\"proc_diskstats.log\");\n    unlink(\"proc_ps.log\");\n    if (enable_accounting)\n      unlink(\"kernel_pacct\");\n    return rmdir(output_dir);\n  }\n\n  return result;\n}\n```",
        "source_code": "static void finalize(char *tempdir, const char *prog, int process_accounting)\n{\n\t//# Stop process accounting if configured\n\t//local pacct=\n\t//[ -e kernel_pacct ] && pacct=kernel_pacct\n\n\tFILE *header_fp = xfopen(\"header\", \"w\");\n\n\tif (process_accounting)\n\t\tacct(NULL);\n\n\tif (prog)\n\t\tfprintf(header_fp, \"profile.process = %s\\n\", prog);\n\n\tfputs(\"version = \"BC_VERSION_STR\"\\n\", header_fp);\n\tif (ENABLE_FEATURE_BOOTCHARTD_BLOATED_HEADER) {\n\t\tchar *hostname;\n\t\tchar *kcmdline;\n\t\ttime_t t;\n\t\tstruct tm tm_time;\n\t\t/* x2 for possible localized weekday/month names */\n\t\tchar date_buf[sizeof(\"Mon Jun 21 05:29:03 CEST 2010\") * 2];\n\t\tstruct utsname unamebuf;\n\n\t\thostname = safe_gethostname();\n\t\ttime(&t);\n\t\tlocaltime_r(&t, &tm_time);\n\t\tstrftime(date_buf, sizeof(date_buf), \"%a %b %e %H:%M:%S %Z %Y\", &tm_time);\n\t\tfprintf(header_fp, \"title = Boot chart for %s (%s)\\n\", hostname, date_buf);\n\t\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\t\tfree(hostname);\n\n\t\tuname(&unamebuf); /* never fails */\n\t\t/* same as uname -srvm */\n\t\tfprintf(header_fp, \"system.uname = %s %s %s %s\\n\",\n\t\t\t\tunamebuf.sysname,\n\t\t\t\tunamebuf.release,\n\t\t\t\tunamebuf.version,\n\t\t\t\tunamebuf.machine\n\t\t);\n\n\t\t//system.release = `cat /etc/DISTRO-release`\n\t\t//system.cpu = `grep '^model name' /proc/cpuinfo | head -1` ($cpucount)\n\n\t\tkcmdline = xmalloc_open_read_close(\"/proc/cmdline\", NULL);\n\t\t/* kcmdline includes trailing \"\\n\" */\n\t\tfprintf(header_fp, \"system.kernel.options = %s\", kcmdline);\n\t\tif (ENABLE_FEATURE_CLEAN_UP)\n\t\t\tfree(kcmdline);\n\t}\n\tfclose(header_fp);\n\n\t/* Package log files */\n\tsystem(xasprintf(\"tar -zcf /var/log/bootlog.tgz header %s *.log\", process_accounting ? \"kernel_pacct\" : \"\"));\n\t/* Clean up (if we are not in detached tmpfs) */\n\tif (tempdir) {\n\t\tunlink(\"header\");\n\t\tunlink(\"proc_stat.log\");\n\t\tunlink(\"proc_diskstats.log\");\n\t\t//unlink(\"proc_netdev.log\");\n\t\tunlink(\"proc_ps.log\");\n\t\tif (process_accounting)\n\t\t\tunlink(\"kernel_pacct\");\n\t\trmdir(tempdir);\n\t}\n\n\t/* shell-based bootchartd tries to run /usr/bin/bootchart if $AUTO_RENDER=yes:\n\t * /usr/bin/bootchart -o \"$AUTO_RENDER_DIR\" -f $AUTO_RENDER_FORMAT \"$BOOTLOG_DEST\"\n\t */\n}",
        "parsed_output": "static int\ncreate_bootchart(const char *output_dir, const char *process_name, int enable_accounting)\n{\n  time_t timer;\n  struct tm tp;\n  char timestamp[64];\n  struct utsname system_info;\n  FILE *header_file;\n  const char *bootchart_version = \"0.8\";\n  const char *system_id;\n  const char *kernel_options;\n  char *tar_command;\n  int result;\n\n  header_file = fopen(\"header\", \"w\");\n  if (enable_accounting)\n    acct(NULL);\n\n  if (process_name)\n    fprintf(header_file, \"profile.process = %s\\n\", process_name);\n\n  fprintf(header_file, \"version = %s\\n\", bootchart_version);\n\n  system_id = get_system_id();\n  time(&timer);\n  localtime_r(&timer, &tp);\n  strftime(timestamp, sizeof(timestamp), \"%a %b %e %H:%M:%S %Z %Y\", &tp);\n  fprintf(header_file, \"title = Boot chart for %s (%s)\\n\", system_id, timestamp);\n\n  uname(&system_info);\n  fprintf(header_file, \"system.uname = %s %s %s %s\\n\",\n          system_info.sysname, system_info.release, system_info.version, system_info.machine);\n\n  kernel_options = get_kernel_options(\"/proc/cmdline\");\n  fprintf(header_file, \"system.kernel.options = %s\", kernel_options);\n\n  fclose(header_file);\n\n  const char *pacct_file = enable_accounting ? \"kernel_pacct\" : \"\";\n  tar_command = create_tar_command(\"tar -zcf /var/log/bootlog.tgz header %s *.log\", pacct_file);\n  result = system(tar_command);\n\n  if (output_dir)\n  {\n    unlink(\"header\");\n    unlink(\"proc_stat.log\");\n    unlink(\"proc_diskstats.log\");\n    unlink(\"proc_ps.log\");\n    if (enable_accounting)\n      unlink(\"kernel_pacct\");\n    return rmdir(output_dir);\n  }\n\n  return result;\n}",
        "baseline_code_stripped": "int __fastcall sub_4F4459(const char *a1, const char *a2, int a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  const char *v7; // rax\n  char *v8; // rax\n  int result; // eax\n  struct tm tp; // [rsp+20h] [rbp-230h] BYREF\n  char s[64]; // [rsp+60h] [rbp-1F0h] BYREF\n  struct utsname name; // [rsp+A0h] [rbp-1B0h] BYREF\n  time_t timer; // [rsp+230h] [rbp-20h] BYREF\n  const char *v15; // [rsp+238h] [rbp-18h]\n  const char *v16; // [rsp+240h] [rbp-10h]\n  FILE *stream; // [rsp+248h] [rbp-8h]\n\n  stream = sub_40A1FC(\"header\", \"w\");\n  if ( a3 )\n    acct(0LL);\n  if ( a2 )\n    fprintf(stream, \"profile.process = %s\\n\", a2);\n  fwrite_unlocked(\"version = 0.8\\n\", 1uLL, 0xEuLL, stream);\n  v16 = (const char *)sub_507F01();\n  time(&timer);\n  localtime_r(&timer, &tp);\n  strftime(s, 0x3CuLL, \"%a %b %e %H:%M:%S %Z %Y\", &tp);\n  fprintf(stream, \"title = Boot chart for %s (%s)\\n\", v16, s);\n  uname(&name);\n  fprintf(stream, \"system.uname = %s %s %s %s\\n\", name.sysname, name.release, name.version, name.machine);\n  v15 = (const char *)sub_5073F7(\"/proc/cmdline\", 0LL);\n  fprintf(stream, \"system.kernel.options = %s\", v15);\n  fclose(stream);\n  if ( a3 )\n    v7 = \"kernel_pacct\";\n  else\n    v7 = (const char *)&unk_527CFA;\n  v8 = sub_40A6B3(\"tar -zcf /var/log/bootlog.tgz header %s *.log\", (__int64)v7, v3, v4, v5, v6);\n  result = system(v8);\n  if ( a1 )\n  {\n    unlink(\"header\");\n    unlink(\"proc_stat.log\");\n    unlink(\"proc_diskstats.log\");\n    unlink(\"proc_ps.log\");\n    if ( a3 )\n      unlink(\"kernel_pacct\");\n    return rmdir(a1);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl finalize(char *tempdir, const char *prog, int process_accounting)\n{\n  const char *v3; // rax\n  char *v4; // rax\n  tm tm_time; // [rsp+20h] [rbp-230h] BYREF\n  char date_buf[60]; // [rsp+60h] [rbp-1F0h] BYREF\n  utsname unamebuf; // [rsp+A0h] [rbp-1B0h] BYREF\n  time_t t; // [rsp+230h] [rbp-20h] BYREF\n  char *kcmdline; // [rsp+238h] [rbp-18h]\n  char *hostname; // [rsp+240h] [rbp-10h]\n  FILE *header_fp; // [rsp+248h] [rbp-8h]\n\n  header_fp = xfopen(\"header\", \"w\");\n  if ( process_accounting )\n    acct(0LL);\n  if ( prog )\n    fprintf(header_fp, \"profile.process = %s\\n\", prog);\n  fwrite_unlocked(\"version = 0.8\\n\", 1uLL, 0xEuLL, header_fp);\n  hostname = safe_gethostname();\n  time(&t);\n  localtime_r(&t, &tm_time);\n  strftime(date_buf, 0x3CuLL, \"%a %b %e %H:%M:%S %Z %Y\", &tm_time);\n  fprintf(header_fp, \"title = Boot chart for %s (%s)\\n\", hostname, date_buf);\n  uname(&unamebuf);\n  fprintf(\n    header_fp,\n    \"system.uname = %s %s %s %s\\n\",\n    unamebuf.sysname,\n    unamebuf.release,\n    unamebuf.version,\n    unamebuf.machine);\n  kcmdline = (char *)xmalloc_open_read_close(\"/proc/cmdline\", 0LL);\n  fprintf(header_fp, \"system.kernel.options = %s\", kcmdline);\n  fclose(header_fp);\n  if ( process_accounting )\n    v3 = \"kernel_pacct\";\n  else\n    v3 = (const char *)&unk_527CFA;\n  v4 = xasprintf(\"tar -zcf /var/log/bootlog.tgz header %s *.log\", v3);\n  system(v4);\n  if ( tempdir )\n  {\n    unlink(\"header\");\n    unlink(\"proc_stat.log\");\n    unlink(\"proc_diskstats.log\");\n    unlink(\"proc_ps.log\");\n    if ( process_accounting )\n      unlink(\"kernel_pacct\");\n    rmdir(tempdir);\n  }\n}\n",
        "similarity_score_unixcoder": 0.8869178295135498,
        "similarity_score_baseline_stripped": 0.7741391658782959,
        "similarity_score_baseline_debug": 0.8960679769515991
    },
    {
        "func_name": "expand",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl print_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  unsigned __int8 *v3; // rax\n  const char *v4; // rdi\n  char buf[5]; // [rsp+33h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+38h] [rbp-38h]\n  unsigned __int8 c; // [rsp+47h] [rbp-29h]\n  size_t i; // [rsp+48h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+50h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+58h] [rbp-18h]\n  const void *blocka; // [rsp+60h] [rbp-10h]\n  size_t n_bytesa; // [rsp+68h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = (unsigned __int8 *)p++;\n    c = *v3;\n    switch ( c )\n    {\n      case 0u:\n        s = \" \\\\0\";\n        break;\n      case 7u:\n        s = (const char *)&unk_409AA8;\n        break;\n      case 8u:\n        s = (const char *)&unk_409AAC;\n        break;\n      case 9u:\n        s = (const char *)&unk_409ABC;\n        break;\n      case 0xAu:\n        s = (const char *)&unk_409AB4;\n        break;\n      case 0xBu:\n        s = (const char *)&unk_409AC0;\n        break;\n      case 0xCu:\n        s = (const char *)&unk_409AB0;\n        break;\n      case 0xDu:\n        s = (const char *)&unk_409AB8;\n        break;\n      default:\n        v4 = \"%03o\";\n        if ( ((*__ctype_b_loc())[c] & 0x4000) != 0 )\n          v4 = \"  %c\";\n        sprintf(buf, v4, c);\n        s = buf;\n        break;\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_ascii (size_t n_bytes, void const *block,\n\t     const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      unsigned char c = *p++;\n      const char *s;\n      char buf[5];\n\n      switch (c)\n\t{\n\tcase '\\0':\n\t  s = \" \\\\0\";\n\t  break;\n\n\tcase '\\a':\n\t  s = \" \\\\a\";\n\t  break;\n\n\tcase '\\b':\n\t  s = \" \\\\b\";\n\t  break;\n\n\tcase '\\f':\n\t  s = \" \\\\f\";\n\t  break;\n\n\tcase '\\n':\n\t  s = \" \\\\n\";\n\t  break;\n\n\tcase '\\r':\n\t  s = \" \\\\r\";\n\t  break;\n\n\tcase '\\t':\n\t  s = \" \\\\t\";\n\t  break;\n\n\tcase '\\v':\n\t  s = \" \\\\v\";\n\t  break;\n\n\tdefault:\n\t  sprintf (buf, (isprint (c) ? \"  %c\" : \"%03o\"), c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n\n## Example:\n\n Input code:\noperand_0 *__cdecl scan_arg(operand_0 *retstr, const char *arg)\n{\n  char *v2; // rax\n  const char *v3; // rsi\n  char v5; // [rsp+3h] [rbp-6Dh]\n  int v6; // [rsp+4h] [rbp-6Ch]\n  size_t fraction_len; // [rsp+30h] [rbp-40h]\n  char *decimal_point; // [rsp+38h] [rbp-38h]\n  operand_0 ret; // [rsp+40h] [rbp-30h] BYREF\n  const char *arga; // [rsp+68h] [rbp-8h]\n\n  arga = arg;\n  if ( !xstrtold(arg, 0LL, &ret.value, (long double (*)(const char *, char **))c_strtold) )\n  {\n    v2 = gettext(\"invalid floating point argument: %s\");\n    error(0, 0, v2, arga);\n    usage(1);\n  }\n  ret.width = strlen(arga);\n  ret.precision = 0x7FFFFFFF;\n  v3 = arga;\n  if ( !v3[strcspn(arga, \"eExX\")] && ret.value * 0.0 == 0.0 )\n  {\n    decimal_point = strchr(arga, 46);\n    if ( decimal_point )\n    {\n      fraction_len = strlen(decimal_point + 1);\n      if ( fraction_len <= 0x7FFFFFFF )\n        ret.precision = fraction_len;\n      if ( fraction_len )\n      {\n        v5 = 1;\n        if ( decimal_point != arga )\n          v5 = ~((unsigned int)(*(decimal_point - 1) - 48) <= 9);\n        v6 = v5 & 1;\n      }\n      else\n      {\n        v6 = -1;\n      }\n      ret.width += v6;\n    }\n    else\n    {\n      ret.precision = 0;\n    }\n  }\n  *retstr = ret;\n  return retstr;\n}\n\n\n Revised code:\nstatic operand\nscan_arg (const char *arg)\n{\n  operand ret;\n\n  if (! xstrtold (arg, NULL, &ret.value, c_strtold))\n    {\n      error (0, 0, _(\"invalid floating point argument: %s\"), arg);\n      usage (EXIT_FAILURE);\n    }\n\n  ret.width = strlen (arg);\n  ret.precision = INT_MAX;\n\n  if (! arg[strcspn (arg, \"eExX\")] && isfinite (ret.value))\n    {\n      char const *decimal_point = strchr (arg, '.');\n      if (! decimal_point)\n\tret.precision = 0;\n      else\n\t{\n\t  size_t fraction_len = strlen (decimal_point + 1);\n\t  if (fraction_len <= INT_MAX)\n\t    ret.precision = fraction_len;\n\t  ret.width += (fraction_len == 0\n\t\t\t? -1\n\t\t\t: (decimal_point == arg\n\t\t\t   || ! ISDIGIT (decimal_point[-1])));\n\t}\n    }\n\n  return ret;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_4C8E1A(__int64 a1, unsigned int a2, char a3)\n{\n  void *result; // rax\n  char v6[8]; // [rsp+14h] [rbp-2Ch] BYREF\n  unsigned int v7; // [rsp+1Ch] [rbp-24h]\n  int v8; // [rsp+20h] [rbp-20h]\n  char v9; // [rsp+26h] [rbp-1Ah]\n  char v10; // [rsp+27h] [rbp-19h]\n  void *ptr; // [rsp+28h] [rbp-18h]\n  char *s; // [rsp+30h] [rbp-10h]\n  char *i; // [rsp+38h] [rbp-8h]\n\n  for ( result = (void *)sub_4F9FD0(a1); ; result = (void *)sub_4F9FD0(a1) )\n  {\n    ptr = result;\n    if ( !result )\n      break;\n    s = (char *)ptr;\n    for ( i = (char *)ptr; ; ++i )\n    {\n      v10 = *i;\n      if ( !v10 )\n        break;\n      if ( (a3 & 1) != 0 )\n      {\n        v9 = v10;\n        if ( v10 != 32 && v9 != 9 )\n          break;\n      }\n      if ( v10 == 9 )\n      {\n        *i = 0;\n        sub_502FB1(v6, s);\n        v8 = a2 - v7 % a2;\n        printf(\"%s%*s\", s, v8, (const char *)&unk_536BFE);\n        s = i + 1;\n      }\n    }\n    fputs_unlocked(s, stdout);\n    free(ptr);\n  }\n  return result;\n}\n",
        "output": "```c\nstatic void *\nsub_4C8E1A (long long a1, unsigned int a2, char a3)\n{\n  void *result;\n  char buffer[8];\n  unsigned int offset;\n  int padding;\n  char current_char;\n  char next_char;\n  void *ptr;\n  char *start;\n  char *iter;\n\n  while ((result = sub_4F9FD0(a1)) != NULL)\n    {\n      ptr = result;\n      start = (char *)ptr;\n      for (iter = start; ; ++iter)\n        {\n          next_char = *iter;\n          if (next_char == '\\0')\n            break;\n\n          if ((a3 & 1) != 0)\n            {\n              current_char = next_char;\n              if (current_char != ' ' && current_char != '\\t')\n                break;\n            }\n\n          if (next_char == '\\t')\n            {\n              *iter = '\\0';\n              sub_502FB1(buffer, start);\n              padding = a2 - offset % a2;\n              printf(\"%s%*s\", start, padding, &unk_536BFE);\n              start = iter + 1;\n            }\n        }\n      fputs_unlocked(start, stdout);\n      free(ptr);\n    }\n  return result;\n}\n```",
        "source_code": "if ENABLE_EXPAND\nstatic void expand(FILE *file, unsigned tab_size, unsigned opt)\n{\n\tchar *line;\n\n\twhile ((line = xmalloc_fgets(file)) != NULL) {\n\t\tunsigned char c;\n\t\tchar *ptr;\n\t\tchar *ptr_strbeg;\n\n\t\tptr = ptr_strbeg = line;\n\t\twhile ((c = *ptr) != '\\0') {\n\t\t\tif ((opt & OPT_INITIAL) && !isblank(c)) {\n\t\t\t\t/* not space or tab */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (c == '\\t') {\n\t\t\t\tunsigned len;\n\t\t\t\t*ptr = '\\0';\n# if ENABLE_UNICODE_SUPPORT\n\t\t\t\t{\n\t\t\t\t\tuni_stat_t uni_stat;\n\t\t\t\t\tprintable_string(&uni_stat, ptr_strbeg);\n\t\t\t\t\tlen = uni_stat.unicode_width;\n\t\t\t\t}\n# else\n\t\t\t\tlen = ptr - ptr_strbeg;\n# endif\n\t\t\t\tlen = tab_size - (len % tab_size);\n\t\t\t\t/*while (ptr[1] == '\\t') { ptr++; len += tab_size; } - can handle many tabs at once */\n\t\t\t\tprintf(\"%s%*s\", ptr_strbeg, len, \"\");\n\t\t\t\tptr_strbeg = ptr + 1;\n\t\t\t}\n\t\t\tptr++;\n\t\t}\n\t\tfputs(ptr_strbeg, stdout);\n\t\tfree(line);\n\t}\n}",
        "parsed_output": "static void *\nsub_4C8E1A (long long a1, unsigned int a2, char a3)\n{\n  void *result;\n  char buffer[8];\n  unsigned int offset;\n  int padding;\n  char current_char;\n  char next_char;\n  void *ptr;\n  char *start;\n  char *iter;\n\n  while ((result = sub_4F9FD0(a1)) != NULL)\n    {\n      ptr = result;\n      start = (char *)ptr;\n      for (iter = start; ; ++iter)\n        {\n          next_char = *iter;\n          if (next_char == '\\0')\n            break;\n\n          if ((a3 & 1) != 0)\n            {\n              current_char = next_char;\n              if (current_char != ' ' && current_char != '\\t')\n                break;\n            }\n\n          if (next_char == '\\t')\n            {\n              *iter = '\\0';\n              sub_502FB1(buffer, start);\n              padding = a2 - offset % a2;\n              printf(\"%s%*s\", start, padding, &unk_536BFE);\n              start = iter + 1;\n            }\n        }\n      fputs_unlocked(start, stdout);\n      free(ptr);\n    }\n  return result;\n}",
        "baseline_code_stripped": "void *__fastcall sub_4C8E1A(__int64 a1, unsigned int a2, char a3)\n{\n  void *result; // rax\n  char v6[8]; // [rsp+14h] [rbp-2Ch] BYREF\n  unsigned int v7; // [rsp+1Ch] [rbp-24h]\n  int v8; // [rsp+20h] [rbp-20h]\n  char v9; // [rsp+26h] [rbp-1Ah]\n  char v10; // [rsp+27h] [rbp-19h]\n  void *ptr; // [rsp+28h] [rbp-18h]\n  char *s; // [rsp+30h] [rbp-10h]\n  char *i; // [rsp+38h] [rbp-8h]\n\n  for ( result = (void *)sub_4F9FD0(a1); ; result = (void *)sub_4F9FD0(a1) )\n  {\n    ptr = result;\n    if ( !result )\n      break;\n    s = (char *)ptr;\n    for ( i = (char *)ptr; ; ++i )\n    {\n      v10 = *i;\n      if ( !v10 )\n        break;\n      if ( (a3 & 1) != 0 )\n      {\n        v9 = v10;\n        if ( v10 != 32 && v9 != 9 )\n          break;\n      }\n      if ( v10 == 9 )\n      {\n        *i = 0;\n        sub_502FB1(v6, s);\n        v8 = a2 - v7 % a2;\n        printf(\"%s%*s\", s, v8, (const char *)&unk_536BFE);\n        s = i + 1;\n      }\n    }\n    fputs_unlocked(s, stdout);\n    free(ptr);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl expand(FILE *file, unsigned int tab_size, unsigned int opt)\n{\n  char opta; // [rsp+0h] [rbp-40h]\n  uni_stat_t_0 uni_stat; // [rsp+14h] [rbp-2Ch] BYREF\n  unsigned int len; // [rsp+20h] [rbp-20h]\n  unsigned __int8 bb__isblank; // [rsp+26h] [rbp-1Ah]\n  unsigned __int8 c; // [rsp+27h] [rbp-19h]\n  char *line; // [rsp+28h] [rbp-18h]\n  char *ptr_strbeg; // [rsp+30h] [rbp-10h]\n  char *ptr; // [rsp+38h] [rbp-8h]\n\n  opta = opt;\n  while ( 1 )\n  {\n    line = xmalloc_fgets(file);\n    if ( !line )\n      break;\n    ptr_strbeg = line;\n    for ( ptr = line; ; ++ptr )\n    {\n      c = *ptr;\n      if ( !c )\n        break;\n      if ( (opta & 1) != 0 )\n      {\n        bb__isblank = c;\n        if ( c != 32 && bb__isblank != 9 )\n          break;\n      }\n      if ( c == 9 )\n      {\n        *ptr = 0;\n        printable_string(&uni_stat, ptr_strbeg);\n        len = tab_size - uni_stat.unicode_width % tab_size;\n        printf(\"%s%*s\", ptr_strbeg, len, (const char *)&unk_536BFE);\n        ptr_strbeg = ptr + 1;\n      }\n    }\n    fputs_unlocked(ptr_strbeg, stdout);\n    free(line);\n  }\n}\n",
        "similarity_score_unixcoder": 0.7067463397979736,
        "similarity_score_baseline_stripped": 0.5718011260032654,
        "similarity_score_baseline_debug": 0.8162072896957397
    },
    {
        "func_name": "pick",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl looks_like_integer(const char *cp)\n{\n  const char *v1; // rax\n  const char *cpa; // [rsp+0h] [rbp-10h]\n\n  cpa = &cp[*cp == 45];\n  do\n  {\n    if ( (unsigned int)(*cpa - 48) > 9 )\n      return 0;\n    v1 = cpa++;\n  }\n  while ( v1[1] );\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nlooks_like_integer (char const *cp)\n{\n  cp += (*cp == '-');\n\n  do\n    if (! ISDIGIT (*cp))\n      return false;\n  while (*++cp);\n\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_short(size_t n_bytes, const void *block, const char *fmt_string)\n{\n  unsigned __int16 *v3; // rax\n  size_t i; // [rsp+8h] [rbp-28h]\n\n  for ( i = n_bytes >> 1; i; --i )\n  {\n    v3 = (unsigned __int16 *)block;\n    block = (char *)block + 2;\n    printf(fmt_string, *v3);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_short (size_t n_bytes, void const *block, char const *fmt_string)\n{\n  unsigned short int const *p = block;\n  size_t i;\n  for (i = n_bytes / sizeof *p; i != 0; i--)\n    printf (fmt_string, *p++);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nuint32_t sub_448370()\n{\n  unsigned int v1; // [rsp+Ch] [rbp-4h]\n\n  do\n    v1 = (unsigned __int16)rand();\n  while ( v1 > 0xFDFF );\n  return htonl(v1 - 1442971392);\n}\n",
        "output": "```c\nstatic uint32_t\ngenerate_random_number()\n{\n  uint32_t random_number;\n\n  do\n  {\n    random_number = (uint16_t)rand();\n  }\n  while (random_number > 0xFDFF);\n\n  return htonl(random_number - 1442971392);\n}\n```",
        "source_code": "static uint32_t pick(void)\n{\n\tunsigned tmp;\n\n\tdo {\n\t\ttmp = rand() & IN_CLASSB_HOST;\n\t} while (tmp > (IN_CLASSB_HOST - 0x0200));\n\treturn htonl((LINKLOCAL_ADDR + 0x0100) + tmp);\n}",
        "parsed_output": "static uint32_t\ngenerate_random_number()\n{\n  uint32_t random_number;\n\n  do\n  {\n    random_number = (uint16_t)rand();\n  }\n  while (random_number > 0xFDFF);\n\n  return htonl(random_number - 1442971392);\n}",
        "baseline_code_stripped": "uint32_t sub_448370()\n{\n  unsigned int v1; // [rsp+Ch] [rbp-4h]\n\n  do\n    v1 = (unsigned __int16)rand();\n  while ( v1 > 0xFDFF );\n  return htonl(v1 - 1442971392);\n}\n",
        "baseline_code_debug": "uint32_t __cdecl pick()\n{\n  unsigned int tmp; // [rsp+Ch] [rbp-4h]\n\n  do\n    tmp = (unsigned __int16)rand();\n  while ( tmp > 0xFDFF );\n  return htonl(tmp - 1442971392);\n}\n",
        "similarity_score_unixcoder": 0.7286529541015625,
        "similarity_score_baseline_stripped": 0.5700578689575195,
        "similarity_score_baseline_debug": 0.6875134110450745
    },
    {
        "func_name": "volume_id_probe_ntfs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, int *binary, char **file_name)\n{\n  size_t v5; // rcx\n  size_t v6; // rcx\n  size_t v7; // rcx\n  char *v8; // rax\n  char *v9; // rax\n  size_t v10; // rcx\n  char *v11; // rax\n  bool v13; // [rsp+2Fh] [rbp-51h]\n  char *dst; // [rsp+30h] [rbp-50h]\n  bool escaped_filename; // [rsp+47h] [rbp-39h]\n  size_t i; // [rsp+48h] [rbp-38h]\n  size_t ia; // [rsp+48h] [rbp-38h]\n  size_t ib; // [rsp+48h] [rbp-38h]\n  size_t ic; // [rsp+48h] [rbp-38h]\n\n  escaped_filename = 0;\n  for ( i = 0LL; ; ++i )\n  {\n    v13 = 1;\n    if ( s[i] != 32 )\n      v13 = s[i] == 9;\n    if ( !v13 )\n      break;\n  }\n  if ( !strncmp(&s[i], \"MD5\", 3uLL) && !strncmp(&s[i + 3], \" (\", 2uLL) )\n  {\n    *binary = 0;\n    return bsd_split_3(&s[i + 5], s_len - (i + 5), hex_digest, file_name);\n  }\n  else if ( s_len - i >= (s[i] == 92) + min_digest_line_length )\n  {\n    if ( s[i] == 92 )\n    {\n      ++i;\n      escaped_filename = 1;\n    }\n    *hex_digest = (unsigned __int8 *)&s[i];\n    ia = i + digest_hex_bytes;\n    if ( s[ia] == 32 || s[ia] == 9 )\n    {\n      v5 = ia;\n      ib = ia + 1;\n      s[v5] = 0;\n      if ( s[ib] == 32 || s[ib] == 42 )\n      {\n        v6 = ib;\n        ic = ib + 1;\n        *binary = s[v6] == 42;\n        *file_name = &s[ic];\n        if ( escaped_filename )\n        {\n          dst = &s[ic];\n          while ( ic < s_len )\n          {\n            if ( !s[ic] )\n              return 0;\n            if ( s[ic] == 92 )\n            {\n              if ( ic == s_len - 1 )\n                return 0;\n              v7 = ic + 1;\n              ic += 2LL;\n              if ( s[v7] == 92 )\n              {\n                v9 = dst++;\n                *v9 = 92;\n              }\n              else\n              {\n                if ( s[v7] != 110 )\n                  return 0;\n                v8 = dst++;\n                *v8 = 10;\n              }\n            }\n            else\n            {\n              v10 = ic++;\n              v11 = dst++;\n              *v11 = s[v10];\n            }\n          }\n          *dst = 0;\n        }\n        return 1;\n      }\n      else\n      {\n        return 0;\n      }\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  else\n  {\n    return 0;\n  }\n}\n\n\n Revised code:\nstatic bool\nsplit_3 (char *s, size_t s_len,\n\t unsigned char **hex_digest, int *binary, char **file_name)\n{\n  size_t i;\n  bool escaped_filename = false;\n  size_t algo_name_len;\n\n  i = 0;\n  while (ISWHITE (s[i]))\n    ++i;\n\n  /* Check for BSD-style checksum line. */\n  algo_name_len = strlen (DIGEST_TYPE_STRING);\n  if (strncmp (s + i, DIGEST_TYPE_STRING, algo_name_len) == 0)\n    {\n      if (strncmp (s + i + algo_name_len, \" (\", 2) == 0)\n\t{\n\t  *binary = 0;\n\t  return bsd_split_3 (s +      i + algo_name_len + 2,\n\t\t\t      s_len - (i + algo_name_len + 2),\n\t\t\t      hex_digest, file_name);\n\t}\n    }\n\n  /* Ignore this line if it is too short.\n     Each line must have at least `min_digest_line_length - 1' (or one more, if\n     the first is a backslash) more characters to contain correct message digest\n     information.  */\n  if (s_len - i < min_digest_line_length + (s[i] == '\\\\'))\n    return false;\n\n  if (s[i] == '\\\\')\n    {\n      ++i;\n      escaped_filename = true;\n    }\n  *hex_digest = (unsigned char *) &s[i];\n\n  /* The first field has to be the n-character hexadecimal\n     representation of the message digest.  If it is not followed\n     immediately by a white space it's an error.  */\n  i += digest_hex_bytes;\n  if (!ISWHITE (s[i]))\n    return false;\n\n  s[i++] = '\\0';\n\n  if (s[i] != ' ' && s[i] != '*')\n    return false;\n  *binary = (s[i++] == '*');\n\n  /* All characters between the type indicator and end of line are\n     significant -- that includes leading and trailing white space.  */\n  *file_name = &s[i];\n\n  if (escaped_filename)\n    {\n      /* Translate each `\\n' string in the file name to a NEWLINE,\n\t and each `\\\\' string to a backslash.  */\n\n      char *dst = &s[i];\n\n      while (i < s_len)\n\t{\n\t  switch (s[i])\n\t    {\n\t    case '\\\\':\n\t      if (i == s_len - 1)\n\t\t{\n\t\t  /* A valid line does not end with a backslash.  */\n\t\t  return false;\n\t\t}\n\t      ++i;\n\t      switch (s[i++])\n\t\t{\n\t\tcase 'n':\n\t\t  *dst++ = '\\n';\n\t\t  break;\n\t\tcase '\\\\':\n\t\t  *dst++ = '\\\\';\n\t\t  break;\n\t\tdefault:\n\t\t  /* Only `\\' or `n' may follow a backslash.  */\n\t\t  return false;\n\t\t}\n\t      break;\n\n\t    case '\\0':\n\t      /* The file name may not contain a NUL.  */\n\t      return false;\n\t      break;\n\n\t    default:\n\t      *dst++ = s[i++];\n\t      break;\n\t    }\n\t}\n      *dst = '\\0';\n    }\n  return true;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl do_decode(FILE *in, FILE *out, bool ignore_garbage)\n{\n  char *v3; // rax\n  size_t v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  int v7; // [rsp+Ch] [rbp-1C64h]\n  char v8; // [rsp+13h] [rbp-1C5Dh]\n  int errnum; // [rsp+14h] [rbp-1C5Ch]\n  bool v10; // [rsp+27h] [rbp-1C49h]\n  size_t v11; // [rsp+30h] [rbp-1C40h]\n  size_t outlen; // [rsp+38h] [rbp-1C38h] BYREF\n  bool v13; // [rsp+47h] [rbp-1C29h]\n  size_t inlen; // [rsp+48h] [rbp-1C28h]\n  char outa[3072]; // [rsp+50h] [rbp-1C20h] BYREF\n  char ina[4111]; // [rsp+C50h] [rbp-1020h] BYREF\n  bool v17; // [rsp+1C5Fh] [rbp-11h]\n  FILE *v18; // [rsp+1C60h] [rbp-10h]\n  FILE *v19; // [rsp+1C68h] [rbp-8h]\n\n  v19 = in;\n  v18 = out;\n  v17 = ignore_garbage;\n  do\n  {\n    inlen = 0LL;\n    do\n    {\n      outlen = fread_unlocked(&ina[inlen], 1uLL, 4096 - inlen, v19);\n      if ( v17 )\n      {\n        v11 = 0LL;\n        while ( 1 )\n        {\n          v10 = 0;\n          if ( outlen )\n            v10 = v11 < outlen;\n          if ( !v10 )\n            break;\n          if ( isbase64(ina[v11 + inlen]) || ina[v11 + inlen] == 61 )\n            ++v11;\n          else\n            memmove(&ina[inlen + v11], &ina[inlen + 1 + v11], --outlen - v11);\n        }\n      }\n      inlen += outlen;\n      if ( ferror_unlocked(v19) )\n      {\n        errnum = *__errno_location();\n        v3 = gettext(\"read error\");\n        error(1, errnum, v3);\n      }\n      v8 = 0;\n      if ( inlen < 0x1000 )\n        v8 = ~(feof_unlocked(v19) != 0);\n    }\n    while ( (v8 & 1) != 0 );\n    outlen = 3072LL;\n    v13 = base64_decode(ina, inlen, outa, &outlen);\n    v4 = fwrite_unlocked(outa, 1uLL, outlen, v18);\n    if ( v4 < outlen )\n    {\n      v7 = *__errno_location();\n      v5 = gettext(\"write error\");\n      error(1, v7, v5);\n    }\n    if ( !v13 )\n    {\n      v6 = gettext(\"invalid input\");\n      error(1, 0, v6);\n    }\n  }\n  while ( !feof_unlocked(v19) );\n}\n\n\n Revised code:\nstatic void\ndo_decode (FILE *in, FILE *out, bool ignore_garbage)\n{\n  char inbuf[B64BLOCKSIZE];\n  char outbuf[BLOCKSIZE];\n  size_t sum;\n\n  do\n    {\n      bool ok;\n      size_t n;\n\n      sum = 0;\n      do\n\t{\n\t  n = fread (inbuf + sum, 1, B64BLOCKSIZE - sum, in);\n\n\t  if (ignore_garbage)\n\t    {\n\t      size_t i;\n\t      for (i = 0; n > 0 && i < n;)\n\t\tif (isbase64 (inbuf[sum + i]) || inbuf[sum + i] == '=')\n\t\t  i++;\n\t\telse\n\t\t  memmove (inbuf + sum + i, inbuf + sum + i + 1, --n - i);\n\t    }\n\n\t  sum += n;\n\n\t  if (ferror (in))\n\t    error (EXIT_FAILURE, errno, _(\"read error\"));\n\t}\n      while (sum < B64BLOCKSIZE && !feof (in));\n\n      n = BLOCKSIZE;\n      ok = base64_decode (inbuf, sum, outbuf, &n);\n\n      if (fwrite (outbuf, 1, n, out) < n)\n\terror (EXIT_FAILURE, errno, _(\"write error\"));\n\n      if (!ok)\n\terror (EXIT_FAILURE, 0, _(\"invalid input\"));\n    }\n  while (!feof (in));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4A72A0(__int64 a1)\n{\n  int v2; // [rsp+20h] [rbp-50h]\n  int v3; // [rsp+24h] [rbp-4Ch]\n  char *v4; // [rsp+28h] [rbp-48h]\n  unsigned __int16 *v5; // [rsp+38h] [rbp-38h]\n  unsigned int v6; // [rsp+50h] [rbp-20h]\n  __int64 v7; // [rsp+58h] [rbp-18h]\n  unsigned int v8; // [rsp+64h] [rbp-Ch]\n  unsigned int v9; // [rsp+68h] [rbp-8h]\n  unsigned int v10; // [rsp+6Ch] [rbp-4h]\n\n  v7 = sub_4A8163(a1, 0LL, 512LL);\n  if ( !v7 )\n    return 0xFFFFFFFFLL;\n  if ( memcmp((const void *)(v7 + 3), \"NTFS\", 4uLL) )\n    return 0xFFFFFFFFLL;\n  sub_4A7E7E(a1, v7 + 72, 1LL);\n  v6 = *(unsigned __int16 *)(v7 + 11) * *(unsigned __int8 *)(v7 + 13);\n  if ( *(char *)(v7 + 64) >= 0 )\n    v10 = v6 * *(char *)(v7 + 64);\n  else\n    v10 = 1 << -*(_BYTE *)(v7 + 64);\n  v5 = (unsigned __int16 *)sub_4A8163(a1, 3 * v10 + *(_QWORD *)(v7 + 48) * v6, v10);\n  if ( v5 && !memcmp(v5, \"FILE\", 4uLL) )\n  {\n    v9 = v5[10];\n    while ( 1 )\n    {\n      v4 = (char *)v5 + v9;\n      v3 = *(_DWORD *)v4;\n      v2 = *((_DWORD *)v4 + 1);\n      v8 = *((_DWORD *)v4 + 4);\n      v9 += v2;\n      if ( !v2 || v9 >= v10 || v3 == -1 )\n        break;\n      if ( v3 == 96 )\n      {\n        if ( v8 > 0x40 )\n          v8 = 64;\n        sub_4A7E3F(a1, &v4[*((unsigned __int16 *)v4 + 10)], 0LL, v8);\n      }\n    }\n  }\n  return 0LL;\n}\n",
        "output": "```c\nstatic uint64_t\nsub_4A72A0(uint64_t a1)\n{\n  int attribute_type;\n  int attribute_length;\n  char *attribute_data;\n  uint16_t *file_record;\n  unsigned int bytes_per_sector;\n  uint64_t base_address;\n  unsigned int bytes_per_file_record;\n  unsigned int file_record_size;\n  unsigned int next_attribute_offset;\n\n  base_address = sub_4A8163(a1, 0, 512);\n  if (!base_address)\n    return 0xFFFFFFFF;\n\n  if (memcmp((const void *)(base_address + 3), \"NTFS\", 4))\n    return 0xFFFFFFFF;\n\n  sub_4A7E7E(a1, base_address + 72, 1);\n  bytes_per_sector = *(uint16_t *)(base_address + 11) * *(uint8_t *)(base_address + 13);\n  if (*(int8_t *)(base_address + 64) >= 0)\n    bytes_per_file_record = bytes_per_sector * *(uint8_t *)(base_address + 64);\n  else\n    bytes_per_file_record = 1 << -*(int8_t *)(base_address + 64);\n\n  file_record = (uint16_t *)sub_4A8163(a1, 3 * bytes_per_file_record + *(uint64_t *)(base_address + 48) * bytes_per_sector, bytes_per_file_record);\n  if (file_record && !memcmp(file_record, \"FILE\", 4))\n  {\n    next_attribute_offset = file_record[10];\n    while (1)\n    {\n      attribute_data = (char *)file_record + next_attribute_offset;\n      attribute_type = *(int32_t *)attribute_data;\n      attribute_length = *(int32_t *)(attribute_data + 4);\n      file_record_size = *(uint32_t *)(attribute_data + 16);\n      next_attribute_offset += attribute_length;\n      if (!attribute_length || next_attribute_offset >= bytes_per_file_record || attribute_type == -1)\n        break;\n      if (attribute_type == 96)\n      {\n        if (file_record_size > 0x40)\n          file_record_size = 64;\n        sub_4A7E3F(a1, &attribute_data[*(uint16_t *)(attribute_data + 20)], 0, file_record_size);\n      }\n    }\n  }\n  return 0;\n}\n```",
        "source_code": "define MFT_RECORD_ATTR_END\t\t\t0xffffffffu\n\nint FAST_FUNC volume_id_probe_ntfs(struct volume_id *id /*,uint64_t off*/)\n{\n#define off ((uint64_t)0)\n\tunsigned sector_size;\n\tunsigned cluster_size;\n\tuint64_t mft_cluster;\n\tuint64_t mft_off;\n\tunsigned mft_record_size;\n\tunsigned attr_type;\n\tunsigned attr_off;\n\tunsigned attr_len;\n\tunsigned val_off;\n\tunsigned val_len;\n\tstruct master_file_table_record *mftr;\n\tstruct ntfs_super_block *ns;\n\tconst uint8_t *buf;\n\tconst uint8_t *val;\n\n\tdbg(\"probing at offset 0x%llx\", (unsigned long long) off);\n\n\tns = volume_id_get_buffer(id, off, 0x200);\n\tif (ns == NULL)\n\t\treturn -1;\n\n\tif (memcmp(ns->oem_id, \"NTFS\", 4) != 0)\n\t\treturn -1;\n\n\tvolume_id_set_uuid(id, ns->volume_serial, UUID_NTFS);\n\n\tsector_size = le16_to_cpu(ns->bytes_per_sector);\n\tcluster_size = ns->sectors_per_cluster * sector_size;\n\tmft_cluster = le64_to_cpu(ns->mft_cluster_location);\n\tmft_off = mft_cluster * cluster_size;\n\n\tif (ns->cluster_per_mft_record < 0)\n\t\t/* size = -log2(mft_record_size); normally 1024 Bytes */\n\t\tmft_record_size = 1 << -ns->cluster_per_mft_record;\n\telse\n\t\tmft_record_size = ns->cluster_per_mft_record * cluster_size;\n\n\tdbg(\"sectorsize  0x%x\", sector_size);\n\tdbg(\"clustersize 0x%x\", cluster_size);\n\tdbg(\"mftcluster  %llu\", (unsigned long long) mft_cluster);\n\tdbg(\"mftoffset  0x%llx\", (unsigned long long) mft_off);\n\tdbg(\"cluster per mft_record  %i\", ns->cluster_per_mft_record);\n\tdbg(\"mft record size  %i\", mft_record_size);\n\n\tbuf = volume_id_get_buffer(id, off + mft_off + (MFT_RECORD_VOLUME * mft_record_size),\n\t\t\tmft_record_size);\n\tif (buf == NULL)\n\t\tgoto found;\n\n\tmftr = (struct master_file_table_record*) buf;\n\n\tdbg(\"mftr->magic '%c%c%c%c'\", mftr->magic[0], mftr->magic[1], mftr->magic[2], mftr->magic[3]);\n\tif (memcmp(mftr->magic, \"FILE\", 4) != 0)\n\t\tgoto found;\n\n\tattr_off = le16_to_cpu(mftr->attrs_offset);\n\tdbg(\"file $Volume's attributes are at offset %i\", attr_off);\n\n\twhile (1) {\n\t\tstruct file_attribute *attr;\n\n\t\tattr = (struct file_attribute*) &buf[attr_off];\n\t\tattr_type = le32_to_cpu(attr->type);\n\t\tattr_len = le32_to_cpu(attr->len);\n\t\tval_off = le16_to_cpu(attr->value_offset);\n\t\tval_len = le32_to_cpu(attr->value_len);\n\t\tattr_off += attr_len;\n\n\t\tif (attr_len == 0)\n\t\t\tbreak;\n\n\t\tif (attr_off >= mft_record_size)\n\t\t\tbreak;\n\n\t\tif (attr_type == MFT_RECORD_ATTR_END)\n\t\t\tbreak;\n\n\t\tdbg(\"found attribute type 0x%x, len %i, at offset %i\",\n\t\t\tattr_type, attr_len, attr_off);\n\n//\t\tif (attr_type == MFT_RECORD_ATTR_VOLUME_INFO) {\n//\t\t\tstruct volume_info *info;\n//\t\t\tdbg(\"found info, len %i\", val_len);\n//\t\t\tinfo = (struct volume_info*) (((uint8_t *) attr) + val_off);\n//\t\t\tsnprintf(id->type_version, sizeof(id->type_version)-1,\n//\t\t\t\t \"%u.%u\", info->major_ver, info->minor_ver);\n//\t\t}\n\n\t\tif (attr_type == MFT_RECORD_ATTR_VOLUME_NAME) {\n\t\t\tdbg(\"found label, len %i\", val_len);\n\t\t\tif (val_len > VOLUME_ID_LABEL_SIZE)\n\t\t\t\tval_len = VOLUME_ID_LABEL_SIZE;\n\n\t\t\tval = ((uint8_t *) attr) + val_off;\n//\t\t\tvolume_id_set_label_raw(id, val, val_len);\n\t\t\tvolume_id_set_label_unicode16(id, val, LE, val_len);\n\t\t}\n\t}\n\n found:\n//\tvolume_id_set_usage(id, VOLUME_ID_FILESYSTEM);\n\tIF_FEATURE_BLKID_TYPE(id->type = \"ntfs\";)\n\n\treturn 0;\n}",
        "parsed_output": "static uint64_t\nsub_4A72A0(uint64_t a1)\n{\n  int attribute_type;\n  int attribute_length;\n  char *attribute_data;\n  uint16_t *file_record;\n  unsigned int bytes_per_sector;\n  uint64_t base_address;\n  unsigned int bytes_per_file_record;\n  unsigned int file_record_size;\n  unsigned int next_attribute_offset;\n\n  base_address = sub_4A8163(a1, 0, 512);\n  if (!base_address)\n    return 0xFFFFFFFF;\n\n  if (memcmp((const void *)(base_address + 3), \"NTFS\", 4))\n    return 0xFFFFFFFF;\n\n  sub_4A7E7E(a1, base_address + 72, 1);\n  bytes_per_sector = *(uint16_t *)(base_address + 11) * *(uint8_t *)(base_address + 13);\n  if (*(int8_t *)(base_address + 64) >= 0)\n    bytes_per_file_record = bytes_per_sector * *(uint8_t *)(base_address + 64);\n  else\n    bytes_per_file_record = 1 << -*(int8_t *)(base_address + 64);\n\n  file_record = (uint16_t *)sub_4A8163(a1, 3 * bytes_per_file_record + *(uint64_t *)(base_address + 48) * bytes_per_sector, bytes_per_file_record);\n  if (file_record && !memcmp(file_record, \"FILE\", 4))\n  {\n    next_attribute_offset = file_record[10];\n    while (1)\n    {\n      attribute_data = (char *)file_record + next_attribute_offset;\n      attribute_type = *(int32_t *)attribute_data;\n      attribute_length = *(int32_t *)(attribute_data + 4);\n      file_record_size = *(uint32_t *)(attribute_data + 16);\n      next_attribute_offset += attribute_length;\n      if (!attribute_length || next_attribute_offset >= bytes_per_file_record || attribute_type == -1)\n        break;\n      if (attribute_type == 96)\n      {\n        if (file_record_size > 0x40)\n          file_record_size = 64;\n        sub_4A7E3F(a1, &attribute_data[*(uint16_t *)(attribute_data + 20)], 0, file_record_size);\n      }\n    }\n  }\n  return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4A72A0(__int64 a1)\n{\n  int v2; // [rsp+20h] [rbp-50h]\n  int v3; // [rsp+24h] [rbp-4Ch]\n  char *v4; // [rsp+28h] [rbp-48h]\n  unsigned __int16 *v5; // [rsp+38h] [rbp-38h]\n  unsigned int v6; // [rsp+50h] [rbp-20h]\n  __int64 v7; // [rsp+58h] [rbp-18h]\n  unsigned int v8; // [rsp+64h] [rbp-Ch]\n  unsigned int v9; // [rsp+68h] [rbp-8h]\n  unsigned int v10; // [rsp+6Ch] [rbp-4h]\n\n  v7 = sub_4A8163(a1, 0LL, 512LL);\n  if ( !v7 )\n    return 0xFFFFFFFFLL;\n  if ( memcmp((const void *)(v7 + 3), \"NTFS\", 4uLL) )\n    return 0xFFFFFFFFLL;\n  sub_4A7E7E(a1, v7 + 72, 1LL);\n  v6 = *(unsigned __int16 *)(v7 + 11) * *(unsigned __int8 *)(v7 + 13);\n  if ( *(char *)(v7 + 64) >= 0 )\n    v10 = v6 * *(char *)(v7 + 64);\n  else\n    v10 = 1 << -*(_BYTE *)(v7 + 64);\n  v5 = (unsigned __int16 *)sub_4A8163(a1, 3 * v10 + *(_QWORD *)(v7 + 48) * v6, v10);\n  if ( v5 && !memcmp(v5, \"FILE\", 4uLL) )\n  {\n    v9 = v5[10];\n    while ( 1 )\n    {\n      v4 = (char *)v5 + v9;\n      v3 = *(_DWORD *)v4;\n      v2 = *((_DWORD *)v4 + 1);\n      v8 = *((_DWORD *)v4 + 4);\n      v9 += v2;\n      if ( !v2 || v9 >= v10 || v3 == -1 )\n        break;\n      if ( v3 == 96 )\n      {\n        if ( v8 > 0x40 )\n          v8 = 64;\n        sub_4A7E3F(a1, &v4[*((unsigned __int16 *)v4 + 10)], 0LL, v8);\n      }\n    }\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl volume_id_probe_ntfs(volume_id *id)\n{\n  unsigned int attr_len; // [rsp+20h] [rbp-50h]\n  unsigned int attr_type; // [rsp+24h] [rbp-4Ch]\n  file_attribute *attr; // [rsp+28h] [rbp-48h]\n  unsigned __int16 *buf; // [rsp+38h] [rbp-38h]\n  unsigned int cluster_size; // [rsp+50h] [rbp-20h]\n  ntfs_super_block *ns; // [rsp+58h] [rbp-18h]\n  unsigned int val_len; // [rsp+64h] [rbp-Ch]\n  unsigned int attr_off; // [rsp+68h] [rbp-8h]\n  unsigned int mft_record_size; // [rsp+6Ch] [rbp-4h]\n\n  ns = (ntfs_super_block *)volume_id_get_buffer(id, 0LL, 0x200uLL);\n  if ( !ns )\n    return -1;\n  if ( memcmp(ns->oem_id, \"NTFS\", 4uLL) )\n    return -1;\n  volume_id_set_uuid(id, ns->volume_serial, UUID_NTFS);\n  cluster_size = ns->bytes_per_sector * ns->sectors_per_cluster;\n  if ( ns->cluster_per_mft_record >= 0 )\n    mft_record_size = cluster_size * ns->cluster_per_mft_record;\n  else\n    mft_record_size = 1 << -ns->cluster_per_mft_record;\n  buf = (unsigned __int16 *)volume_id_get_buffer(\n                              id,\n                              3 * mft_record_size + ns->mft_cluster_location * cluster_size,\n                              mft_record_size);\n  if ( buf && !memcmp(buf, \"FILE\", 4uLL) )\n  {\n    attr_off = buf[10];\n    while ( 1 )\n    {\n      attr = (file_attribute *)((char *)buf + attr_off);\n      attr_type = attr->type;\n      attr_len = attr->len;\n      val_len = attr->value_len;\n      attr_off += attr_len;\n      if ( !attr_len || attr_off >= mft_record_size || attr_type == -1 )\n        break;\n      if ( attr_type == 96 )\n      {\n        if ( val_len > 0x40 )\n          val_len = 64;\n        volume_id_set_label_unicode16(id, (const uint8_t *)attr + attr->value_offset, LE, val_len);\n      }\n    }\n  }\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.7204561233520508,
        "similarity_score_baseline_stripped": 0.5880292654037476,
        "similarity_score_baseline_debug": 0.8898218274116516
    },
    {
        "func_name": "ct_tally",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n\n## Example:\n\n Input code:\nint __cdecl get_line(FILE *f, int c)\n{\n  char *v2; // rdx\n  int v3; // edx\n  int v4; // eax\n  bool v6; // [rsp+4h] [rbp-2Ch]\n  bool v7; // [rsp+5h] [rbp-2Bh]\n  char v8; // [rsp+6h] [rbp-2Ah]\n  char v9; // [rsp+7h] [rbp-29h]\n  int start; // [rsp+18h] [rbp-18h]\n  int ca; // [rsp+1Ch] [rbp-14h]\n\n  LOBYTE(ca) = c;\n  do\n  {\n    word_limit->text = wptr;\n    do\n    {\n      if ( wptr == &parabuf[5000] )\n      {\n        set_other_indent(1);\n        flush_paragraph();\n      }\n      v2 = wptr++;\n      *v2 = ca;\n      ca = getc_unlocked(f);\n      v9 = 0;\n      if ( ca != -1 )\n        v9 = ~(((*__ctype_b_loc())[ca] & 0x2000) != 0);\n    }\n    while ( (v9 & 1) != 0 );\n    v3 = (_DWORD)wptr - (unsigned __int64)word_limit->text;\n    word_limit->length = v3;\n    in_column += v3;\n    check_punctuation(word_limit);\n    start = in_column;\n    ca = get_space(f, ca);\n    word_limit->space = in_column - start;\n    v8 = 1;\n    if ( ca != -1 )\n    {\n      v7 = 0;\n      if ( (*((_BYTE *)word_limit + 16) & 2) != 0 )\n      {\n        v6 = 1;\n        if ( ca != 10 )\n          v6 = word_limit->space > 1;\n        v7 = v6;\n      }\n      v8 = v7;\n    }\n    *((_BYTE *)word_limit + 16) = (8 * (v8 & 1)) | *((_BYTE *)word_limit + 16) & 0xF7;\n    if ( ca == 10 || ca == -1 || uniform )\n    {\n      v4 = 1;\n      if ( (*((_BYTE *)word_limit + 16) & 8) != 0 )\n        v4 = 2;\n      word_limit->space = v4;\n    }\n    if ( word_limit == &unused_word_type[998] )\n    {\n      set_other_indent(1);\n      flush_paragraph();\n    }\n    ++word_limit;\n    if ( ca == -1 )\n      return -1;\n  }\n  while ( ca != 10 );\n  return get_prefix(f);\n}\n\n\n Revised code:\nstatic int\nget_line (FILE *f, int c)\n{\n  int start;\n  char *end_of_parabuf;\n  WORD *end_of_word;\n\n  end_of_parabuf = &parabuf[MAXCHARS];\n  end_of_word = &word[MAXWORDS - 2];\n\n  do\n    {\t\t\t\t/* for each word in a line */\n\n      /* Scan word.  */\n\n      word_limit->text = wptr;\n      do\n\t{\n\t  if (wptr == end_of_parabuf)\n\t    {\n\t      set_other_indent (true);\n\t      flush_paragraph ();\n\t    }\n\t  *wptr++ = c;\n\t  c = getc (f);\n\t}\n      while (c != EOF && !isspace (c));\n      in_column += word_limit->length = wptr - word_limit->text;\n      check_punctuation (word_limit);\n\n      /* Scan inter-word space.  */\n\n      start = in_column;\n      c = get_space (f, c);\n      word_limit->space = in_column - start;\n      word_limit->final = (c == EOF\n\t\t\t   || (word_limit->period\n\t\t\t       && (c == '\\n' || word_limit->space > 1)));\n      if (c == '\\n' || c == EOF || uniform)\n\tword_limit->space = word_limit->final ? 2 : 1;\n      if (word_limit == end_of_word)\n\t{\n\t  set_other_indent (true);\n\t  flush_paragraph ();\n\t}\n      word_limit++;\n      if (c == EOF)\n\treturn EOF;\n    }\n  while (c != '\\n');\n  return get_prefix (f);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BOOL8 __fastcall sub_4B034E(int a1, int a2)\n{\n  __int64 v2; // rsi\n  unsigned int v3; // edx\n  int v4; // edx\n  int v5; // eax\n  __int64 v6; // rsi\n  unsigned int v7; // edx\n  _BYTE *v8; // rsi\n  _BYTE *v9; // rcx\n  int v10; // edx\n  int v13; // [rsp+4h] [rbp-14h]\n  int i; // [rsp+10h] [rbp-8h]\n  unsigned int v15; // [rsp+14h] [rbp-4h]\n  unsigned int v16; // [rsp+14h] [rbp-4h]\n\n  v2 = *((_QWORD *)qword_75D408 - 8);\n  v3 = *((_DWORD *)qword_75D408 + 1969);\n  *((_DWORD *)qword_75D408 + 1969) = v3 + 1;\n  *(_BYTE *)(v2 + v3) = a2;\n  if ( a1 )\n  {\n    v13 = a1 - 1;\n    v4 = *((unsigned __int8 *)qword_75D408 + a2 + 5845) + 257;\n    ++*((_WORD *)qword_75D408 + 2 * v4 + 578);\n    if ( a1 - 1 > 255 )\n      v5 = *((unsigned __int8 *)qword_75D408 + (v13 >> 7) + 6357);\n    else\n      v5 = *((unsigned __int8 *)qword_75D408 + v13 + 6101);\n    ++*((_WORD *)qword_75D408 + 2 * v5 + 1724);\n    v6 = *((_QWORD *)qword_75D408 - 7);\n    v7 = *((_DWORD *)qword_75D408 + 1970);\n    *((_DWORD *)qword_75D408 + 1970) = v7 + 1;\n    *(_WORD *)(v6 + 2LL * v7) = v13;\n    *((_BYTE *)qword_75D408 + 7888) |= *((_BYTE *)qword_75D408 + 7889);\n  }\n  else\n  {\n    ++*((_WORD *)qword_75D408 + 2 * a2 + 578);\n  }\n  *((_BYTE *)qword_75D408 + 7889) *= 2;\n  if ( (*((_DWORD *)qword_75D408 + 1969) & 7) == 0 )\n  {\n    v8 = qword_75D408;\n    v9 = qword_75D408;\n    v10 = *((_DWORD *)qword_75D408 + 1971);\n    *((_DWORD *)qword_75D408 + 1971) = v10 + 1;\n    v9[v10 + 6852] = v8[7888];\n    *((_BYTE *)qword_75D408 + 7888) = 0;\n    *((_BYTE *)qword_75D408 + 7889) = 1;\n  }\n  if ( (*((_DWORD *)qword_75D408 + 1969) & 0xFFF) == 0 )\n  {\n    v15 = 8 * *((_DWORD *)qword_75D408 + 1969);\n    for ( i = 0; i <= 29; ++i )\n      v15 += *((unsigned __int16 *)qword_75D408 + 2 * i + 1724) * ((unsigned __int8)byte_5367A5[i] + 5);\n    v16 = v15 >> 3;\n    if ( *((_DWORD *)qword_75D408 + 1970) < *((_DWORD *)qword_75D408 + 1969) >> 1\n      && v16 < (unsigned int)(*((_DWORD *)qword_75D408 - 19) - *((_DWORD *)qword_75D408 - 22)) >> 1 )\n    {\n      return 1LL;\n    }\n  }\n  return *((_DWORD *)qword_75D408 + 1969) == 0x1FFF || *((_DWORD *)qword_75D408 + 1970) == 0x2000;\n}\n",
        "output": "```c\nstatic bool\nupdate_statistics(int symbol, int prev_symbol)\n{\n  uint8_t *data_buffer;\n  uint16_t *freq_table;\n  uint16_t *prev_freq_table;\n  uint8_t *flags;\n  int freq_index;\n  int prev_freq_index;\n  int buffer_index;\n  int i;\n  unsigned int bit_count;\n  unsigned int threshold;\n\n  data_buffer = global_data_buffer - 8;\n  freq_table = global_freq_table + 1969;\n  *freq_table += 1;\n  data_buffer[*freq_table] = symbol;\n\n  if (prev_symbol)\n  {\n    prev_freq_index = prev_symbol - 1;\n    freq_index = global_freq_table[symbol + 5845] + 257;\n    global_freq_table[freq_index * 2 + 578]++;\n    \n    if (prev_freq_index > 255)\n      prev_freq_index = global_freq_table[(prev_freq_index >> 7) + 6357];\n    else\n      prev_freq_index = global_freq_table[prev_freq_index + 6101];\n    \n    prev_freq_table = global_freq_table + 1724;\n    prev_freq_table[prev_freq_index * 2]++;\n    \n    flags = global_flags - 7;\n    buffer_index = global_freq_table[1970]++;\n    *((uint16_t *)(flags + buffer_index * 2)) = prev_freq_index;\n    global_flags[7888] |= global_flags[7889];\n  }\n  else\n  {\n    global_freq_table[symbol * 2 + 578]++;\n  }\n\n  global_flags[7889] <<= 1;\n\n  if ((*freq_table & 7) == 0)\n  {\n    global_flags[6852 + (*global_freq_table + 1971)++] = global_flags[7888];\n    global_flags[7888] = 0;\n    global_flags[7889] = 1;\n  }\n\n  if ((*freq_table & 0xFFF) == 0)\n  {\n    bit_count = *freq_table << 3;\n    for (i = 0; i <= 29; ++i)\n      bit_count += global_freq_table[i * 2 + 1724] * (global_cost_table[i] + 5);\n    \n    threshold = bit_count >> 3;\n    if (global_freq_table[1970] < (*freq_table >> 1) &&\n        threshold < (unsigned int)(global_thresholds[-19] - global_thresholds[-22]) >> 1)\n    {\n      return true;\n    }\n  }\n\n  return *freq_table == 0x1FFF || global_freq_table[1970] == 0x2000;\n}\n```",
        "source_code": "static int ct_tally(int dist, int lc)\n{\n\tG1.l_buf[G2.last_lit++] = lc;\n\tif (dist == 0) {\n\t\t/* lc is the unmatched char */\n\t\tG2.dyn_ltree[lc].Freq++;\n\t} else {\n\t\t/* Here, lc is the match length - MIN_MATCH */\n\t\tdist--;\t\t\t/* dist = match distance - 1 */\n\t\tAssert((ush) dist < (ush) MAX_DIST\n\t\t && (ush) lc <= (ush) (MAX_MATCH - MIN_MATCH)\n\t\t && (ush) D_CODE(dist) < (ush) D_CODES, \"ct_tally: bad match\"\n\t\t);\n\n\t\tG2.dyn_ltree[G2.length_code[lc] + LITERALS + 1].Freq++;\n\t\tG2.dyn_dtree[D_CODE(dist)].Freq++;\n\n\t\tG1.d_buf[G2.last_dist++] = dist;\n\t\tG2.flags |= G2.flag_bit;\n\t}\n\tG2.flag_bit <<= 1;\n\n\t/* Output the flags if they fill a byte: */\n\tif ((G2.last_lit & 7) == 0) {\n\t\tG2.flag_buf[G2.last_flags++] = G2.flags;\n\t\tG2.flags = 0;\n\t\tG2.flag_bit = 1;\n\t}\n\t/* Try to guess if it is profitable to stop the current block here */\n\tif ((G2.last_lit & 0xfff) == 0) {\n\t\t/* Compute an upper bound for the compressed length */\n\t\tulg out_length = G2.last_lit * 8L;\n\t\tulg in_length = (ulg) G1.strstart - G1.block_start;\n\t\tint dcode;\n\n\t\tfor (dcode = 0; dcode < D_CODES; dcode++) {\n\t\t\tout_length += G2.dyn_dtree[dcode].Freq * (5L + extra_dbits[dcode]);\n\t\t}\n\t\tout_length >>= 3;\n\t\tTrace((stderr,\n\t\t\t\t\"\\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) \",\n\t\t\t\tG2.last_lit, G2.last_dist, in_length, out_length,\n\t\t\t\t100L - out_length * 100L / in_length));\n\t\tif (G2.last_dist < G2.last_lit / 2 && out_length < in_length / 2)\n\t\t\treturn 1;\n\t}\n\treturn (G2.last_lit == LIT_BUFSIZE - 1 || G2.last_dist == DIST_BUFSIZE);\n\t/* We avoid equality with LIT_BUFSIZE because of wraparound at 64K\n\t * on 16 bit machines and because stored blocks are restricted to\n\t * 64K-1 bytes.\n\t */\n}",
        "parsed_output": "static bool\nupdate_statistics(int symbol, int prev_symbol)\n{\n  uint8_t *data_buffer;\n  uint16_t *freq_table;\n  uint16_t *prev_freq_table;\n  uint8_t *flags;\n  int freq_index;\n  int prev_freq_index;\n  int buffer_index;\n  int i;\n  unsigned int bit_count;\n  unsigned int threshold;\n\n  data_buffer = global_data_buffer - 8;\n  freq_table = global_freq_table + 1969;\n  *freq_table += 1;\n  data_buffer[*freq_table] = symbol;\n\n  if (prev_symbol)\n  {\n    prev_freq_index = prev_symbol - 1;\n    freq_index = global_freq_table[symbol + 5845] + 257;\n    global_freq_table[freq_index * 2 + 578]++;\n    \n    if (prev_freq_index > 255)\n      prev_freq_index = global_freq_table[(prev_freq_index >> 7) + 6357];\n    else\n      prev_freq_index = global_freq_table[prev_freq_index + 6101];\n    \n    prev_freq_table = global_freq_table + 1724;\n    prev_freq_table[prev_freq_index * 2]++;\n    \n    flags = global_flags - 7;\n    buffer_index = global_freq_table[1970]++;\n    *((uint16_t *)(flags + buffer_index * 2)) = prev_freq_index;\n    global_flags[7888] |= global_flags[7889];\n  }\n  else\n  {\n    global_freq_table[symbol * 2 + 578]++;\n  }\n\n  global_flags[7889] <<= 1;\n\n  if ((*freq_table & 7) == 0)\n  {\n    global_flags[6852 + (*global_freq_table + 1971)++] = global_flags[7888];\n    global_flags[7888] = 0;\n    global_flags[7889] = 1;\n  }\n\n  if ((*freq_table & 0xFFF) == 0)\n  {\n    bit_count = *freq_table << 3;\n    for (i = 0; i <= 29; ++i)\n      bit_count += global_freq_table[i * 2 + 1724] * (global_cost_table[i] + 5);\n    \n    threshold = bit_count >> 3;\n    if (global_freq_table[1970] < (*freq_table >> 1) &&\n        threshold < (unsigned int)(global_thresholds[-19] - global_thresholds[-22]) >> 1)\n    {\n      return true;\n    }\n  }\n\n  return *freq_table == 0x1FFF || global_freq_table[1970] == 0x2000;\n}",
        "baseline_code_stripped": "_BOOL8 __fastcall sub_4B034E(int a1, int a2)\n{\n  __int64 v2; // rsi\n  unsigned int v3; // edx\n  int v4; // edx\n  int v5; // eax\n  __int64 v6; // rsi\n  unsigned int v7; // edx\n  _BYTE *v8; // rsi\n  _BYTE *v9; // rcx\n  int v10; // edx\n  int v13; // [rsp+4h] [rbp-14h]\n  int i; // [rsp+10h] [rbp-8h]\n  unsigned int v15; // [rsp+14h] [rbp-4h]\n  unsigned int v16; // [rsp+14h] [rbp-4h]\n\n  v2 = *((_QWORD *)qword_75D408 - 8);\n  v3 = *((_DWORD *)qword_75D408 + 1969);\n  *((_DWORD *)qword_75D408 + 1969) = v3 + 1;\n  *(_BYTE *)(v2 + v3) = a2;\n  if ( a1 )\n  {\n    v13 = a1 - 1;\n    v4 = *((unsigned __int8 *)qword_75D408 + a2 + 5845) + 257;\n    ++*((_WORD *)qword_75D408 + 2 * v4 + 578);\n    if ( a1 - 1 > 255 )\n      v5 = *((unsigned __int8 *)qword_75D408 + (v13 >> 7) + 6357);\n    else\n      v5 = *((unsigned __int8 *)qword_75D408 + v13 + 6101);\n    ++*((_WORD *)qword_75D408 + 2 * v5 + 1724);\n    v6 = *((_QWORD *)qword_75D408 - 7);\n    v7 = *((_DWORD *)qword_75D408 + 1970);\n    *((_DWORD *)qword_75D408 + 1970) = v7 + 1;\n    *(_WORD *)(v6 + 2LL * v7) = v13;\n    *((_BYTE *)qword_75D408 + 7888) |= *((_BYTE *)qword_75D408 + 7889);\n  }\n  else\n  {\n    ++*((_WORD *)qword_75D408 + 2 * a2 + 578);\n  }\n  *((_BYTE *)qword_75D408 + 7889) *= 2;\n  if ( (*((_DWORD *)qword_75D408 + 1969) & 7) == 0 )\n  {\n    v8 = qword_75D408;\n    v9 = qword_75D408;\n    v10 = *((_DWORD *)qword_75D408 + 1971);\n    *((_DWORD *)qword_75D408 + 1971) = v10 + 1;\n    v9[v10 + 6852] = v8[7888];\n    *((_BYTE *)qword_75D408 + 7888) = 0;\n    *((_BYTE *)qword_75D408 + 7889) = 1;\n  }\n  if ( (*((_DWORD *)qword_75D408 + 1969) & 0xFFF) == 0 )\n  {\n    v15 = 8 * *((_DWORD *)qword_75D408 + 1969);\n    for ( i = 0; i <= 29; ++i )\n      v15 += *((unsigned __int16 *)qword_75D408 + 2 * i + 1724) * ((unsigned __int8)byte_5367A5[i] + 5);\n    v16 = v15 >> 3;\n    if ( *((_DWORD *)qword_75D408 + 1970) < *((_DWORD *)qword_75D408 + 1969) >> 1\n      && v16 < (unsigned int)(*((_DWORD *)qword_75D408 - 19) - *((_DWORD *)qword_75D408 - 22)) >> 1 )\n    {\n      return 1LL;\n    }\n  }\n  return *((_DWORD *)qword_75D408 + 1969) == 0x1FFF || *((_DWORD *)qword_75D408 + 1970) == 0x2000;\n}\n",
        "baseline_code_debug": "int __cdecl ct_tally(int dist, int lc)\n{\n  __int64 v2; // rsi\n  tcflag_t c_oflag; // edx\n  int v4; // edx\n  int v5; // eax\n  __int64 v6; // rsi\n  tcflag_t c_cflag; // edx\n  globals *v8; // rsi\n  globals *v9; // rcx\n  tcflag_t c_lflag; // edx\n  int dista; // [rsp+4h] [rbp-14h]\n  int dcode; // [rsp+10h] [rbp-8h]\n  ulg out_length; // [rsp+14h] [rbp-4h]\n  unsigned int out_lengtha; // [rsp+14h] [rbp-4h]\n\n  v2 = *(_QWORD *)&ptr_to_globals[-1].line_buf[68];\n  c_oflag = ptr_to_globals[27].tty_attrs.c_oflag;\n  ptr_to_globals[27].tty_attrs.c_oflag = c_oflag + 1;\n  *(_BYTE *)(v2 + c_oflag) = lc;\n  if ( dist )\n  {\n    dista = dist - 1;\n    v4 = *((unsigned __int8 *)&ptr_to_globals[20].speeds[8] + lc + 1) + 257;\n    ++*((_WORD *)&ptr_to_globals[4].timeout + 2 * v4 + 2);\n    if ( dist - 1 > 255 )\n      v5 = *((unsigned __int8 *)&ptr_to_globals[22].fakehost + (dista >> 7) + 5);\n    else\n      v5 = *((unsigned __int8 *)ptr_to_globals[21].speeds + dista + 1);\n    ++*(_WORD *)&ptr_to_globals[11].line_buf[4 * v5 + 124];\n    v6 = *(_QWORD *)&ptr_to_globals[-1].line_buf[76];\n    c_cflag = ptr_to_globals[27].tty_attrs.c_cflag;\n    ptr_to_globals[27].tty_attrs.c_cflag = c_cflag + 1;\n    *(_WORD *)(v6 + 2LL * c_cflag) = dista;\n    ptr_to_globals[27].tty_attrs.c_line |= ptr_to_globals[27].tty_attrs.c_cc[0];\n  }\n  else\n  {\n    ++*((_WORD *)&ptr_to_globals[4].timeout + 2 * lc + 2);\n  }\n  ptr_to_globals[27].tty_attrs.c_cc[0] *= 2;\n  if ( (ptr_to_globals[27].tty_attrs.c_oflag & 7) == 0 )\n  {\n    v8 = ptr_to_globals;\n    v9 = ptr_to_globals;\n    c_lflag = ptr_to_globals[27].tty_attrs.c_lflag;\n    ptr_to_globals[27].tty_attrs.c_lflag = c_lflag + 1;\n    v9[23].line_buf[c_lflag + 72] = v8[27].tty_attrs.c_line;\n    ptr_to_globals[27].tty_attrs.c_line = 0;\n    ptr_to_globals[27].tty_attrs.c_cc[0] = 1;\n  }\n  if ( (ptr_to_globals[27].tty_attrs.c_oflag & 0xFFF) == 0 )\n  {\n    out_length = 8 * ptr_to_globals[27].tty_attrs.c_oflag;\n    for ( dcode = 0; dcode <= 29; ++dcode )\n      out_length += *(unsigned __int16 *)&ptr_to_globals[11].line_buf[4 * dcode + 124] * (extra_dbits[dcode] + 5);\n    out_lengtha = out_length >> 3;\n    if ( ptr_to_globals[27].tty_attrs.c_cflag < ptr_to_globals[27].tty_attrs.c_oflag >> 1\n      && out_lengtha < (unsigned int)(*(_DWORD *)&ptr_to_globals[-1].line_buf[56]\n                                    - *(_DWORD *)&ptr_to_globals[-1].line_buf[44]) >> 1 )\n    {\n      return 1;\n    }\n  }\n  return ptr_to_globals[27].tty_attrs.c_oflag == 0x1FFF || ptr_to_globals[27].tty_attrs.c_cflag == 0x2000;\n}\n",
        "similarity_score_unixcoder": 0.5769903659820557,
        "similarity_score_baseline_stripped": 0.47555428743362427,
        "similarity_score_baseline_debug": 0.6079074740409851
    },
    {
        "func_name": "setenv1",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl xsetenv(const char *name, const char *val)\n{\n  char *string; // [rsp+18h] [rbp-28h]\n  size_t vallen; // [rsp+20h] [rbp-20h]\n  size_t namelen; // [rsp+28h] [rbp-18h]\n\n  namelen = strlen(name);\n  vallen = strlen(val);\n  string = (char *)xmalloc(vallen + namelen + 1 + 1);\n  strcpy(string, name);\n  string[namelen] = 61;\n  strcpy(&string[namelen + 1], val);\n  if ( putenv(string) )\n    xalloc_die();\n}\n\n\n Revised code:\nstatic void\nxsetenv (char const *name, char const *val)\n{\n  size_t namelen = strlen (name);\n  size_t vallen = strlen (val);\n  char *string = xmalloc (namelen + 1 + vallen + 1);\n  strcpy (string, name);\n  string[namelen] = '=';\n  strcpy (string + namelen + 1, val);\n  if (putenv (string) != 0)\n    xalloc_die ();\n}\n\n## Example:\n\n Input code:\nbool __cdecl different(char *old, char *a2, size_t oldlen, size_t newlen)\n{\n  bool v5; // [rsp+6h] [rbp-2Ah]\n  bool v6; // [rsp+7h] [rbp-29h]\n  size_t newlena; // [rsp+8h] [rbp-28h]\n  size_t oldlena; // [rsp+10h] [rbp-20h]\n\n  oldlena = oldlen;\n  newlena = newlen;\n  if ( check_chars < oldlen )\n    oldlena = check_chars;\n  if ( check_chars < newlen )\n    newlena = check_chars;\n  if ( ignore_case )\n  {\n    v6 = 1;\n    if ( oldlena == newlena )\n      return memcasecmp(old, a2, oldlena) != 0;\n    return v6;\n  }\n  else if ( hard_LC_COLLATE )\n  {\n    return xmemcoll(old, oldlena, a2, newlena) != 0;\n  }\n  else\n  {\n    v5 = 1;\n    if ( oldlena == newlena )\n      return memcmp(old, a2, oldlena) != 0;\n    return v5;\n  }\n}\n\n\n Revised code:\nstatic bool\ndifferent (char *old, char *new, size_t oldlen, size_t newlen)\n{\n  if (check_chars < oldlen)\n    oldlen = check_chars;\n  if (check_chars < newlen)\n    newlen = check_chars;\n\n  if (ignore_case)\n    {\n      /* FIXME: This should invoke strcoll somehow.  */\n      return oldlen != newlen || memcasecmp (old, new, oldlen);\n    }\n  else if (hard_LC_COLLATE)\n    return xmemcoll (old, oldlen, new, newlen) != 0;\n  else\n    return oldlen != newlen || memcmp (old, new, oldlen);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl attach(char *dest, const char *dirname, const char *name)\n{\n  char *v3; // rax\n  char v4; // dl\n  char *v5; // rax\n  char *v6; // rax\n  const char *v7; // rax\n  char v8; // dl\n  char *v9; // rax\n  const char *dirnamep; // [rsp+0h] [rbp-20h]\n\n  dirnamep = dirname;\n  if ( *dirname != 46 || dirname[1] )\n  {\n    while ( *dirnamep )\n    {\n      v3 = (char *)dirnamep++;\n      v4 = *v3;\n      v5 = dest++;\n      *v5 = v4;\n    }\n    if ( dirnamep > dirname && *(dirnamep - 1) != 47 )\n    {\n      v6 = dest++;\n      *v6 = 47;\n    }\n  }\n  while ( *name )\n  {\n    v7 = name++;\n    v8 = *v7;\n    v9 = dest++;\n    *v9 = v8;\n  }\n  *dest = 0;\n}\n\n\n Revised code:\nstatic void\nattach (char *dest, const char *dirname, const char *name)\n{\n  const char *dirnamep = dirname;\n\n  /* Copy dirname if it is not \".\".  */\n  if (dirname[0] != '.' || dirname[1] != 0)\n    {\n      while (*dirnamep)\n\t*dest++ = *dirnamep++;\n      /* Add '/' if `dirname' doesn't already end with it.  */\n      if (dirnamep > dirname && dirnamep[-1] != '/')\n\t*dest++ = '/';\n    }\n  while (*name)\n    *dest++ = *name++;\n  *dest = 0;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_42CE6B(const char *a1, const char *a2)\n{\n  const char *v2; // rax\n\n  if ( a2 )\n    v2 = a2;\n  else\n    v2 = (const char *)&unk_5179FC;\n  return setenv(a1, v2, 1);\n}\n",
        "output": "```c\nstatic int\nset_env_variable (const char *name, const char *value)\n{\n  if (!value)\n    value = DEFAULT_VALUE; // DEFAULT_VALUE should be defined elsewhere, e.g., as a macro or a global constant\n\n  return setenv(name, value, 1);\n}\n```",
        "source_code": "if ENABLE_FEATURE_HTTPD_CGI\n\nstatic void setenv1(const char *name, const char *value)\n{\n\tsetenv(name, value ? value : \"\", 1);\n}",
        "parsed_output": "static int\nset_env_variable (const char *name, const char *value)\n{\n  if (!value)\n    value = DEFAULT_VALUE; // DEFAULT_VALUE should be defined elsewhere, e.g., as a macro or a global constant\n\n  return setenv(name, value, 1);\n}",
        "baseline_code_stripped": "int __fastcall sub_42CE6B(const char *a1, const char *a2)\n{\n  const char *v2; // rax\n\n  if ( a2 )\n    v2 = a2;\n  else\n    v2 = (const char *)&unk_5179FC;\n  return setenv(a1, v2, 1);\n}\n",
        "baseline_code_debug": "void __cdecl setenv1(const char *name, const char *value)\n{\n  const char *v2; // rax\n\n  if ( value )\n    v2 = value;\n  else\n    v2 = &user_and_passwd;\n  setenv(name, v2, 1);\n}\n",
        "similarity_score_unixcoder": 0.7725441455841064,
        "similarity_score_baseline_stripped": 0.44557350873947144,
        "similarity_score_baseline_debug": 0.7002410888671875
    },
    {
        "func_name": "rmescapes",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl print_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  unsigned __int8 *v3; // rax\n  const char *v4; // rdi\n  char buf[5]; // [rsp+33h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+38h] [rbp-38h]\n  unsigned __int8 c; // [rsp+47h] [rbp-29h]\n  size_t i; // [rsp+48h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+50h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+58h] [rbp-18h]\n  const void *blocka; // [rsp+60h] [rbp-10h]\n  size_t n_bytesa; // [rsp+68h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = (unsigned __int8 *)p++;\n    c = *v3;\n    switch ( c )\n    {\n      case 0u:\n        s = \" \\\\0\";\n        break;\n      case 7u:\n        s = (const char *)&unk_409AA8;\n        break;\n      case 8u:\n        s = (const char *)&unk_409AAC;\n        break;\n      case 9u:\n        s = (const char *)&unk_409ABC;\n        break;\n      case 0xAu:\n        s = (const char *)&unk_409AB4;\n        break;\n      case 0xBu:\n        s = (const char *)&unk_409AC0;\n        break;\n      case 0xCu:\n        s = (const char *)&unk_409AB0;\n        break;\n      case 0xDu:\n        s = (const char *)&unk_409AB8;\n        break;\n      default:\n        v4 = \"%03o\";\n        if ( ((*__ctype_b_loc())[c] & 0x4000) != 0 )\n          v4 = \"  %c\";\n        sprintf(buf, v4, c);\n        s = buf;\n        break;\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_ascii (size_t n_bytes, void const *block,\n\t     const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      unsigned char c = *p++;\n      const char *s;\n      char buf[5];\n\n      switch (c)\n\t{\n\tcase '\\0':\n\t  s = \" \\\\0\";\n\t  break;\n\n\tcase '\\a':\n\t  s = \" \\\\a\";\n\t  break;\n\n\tcase '\\b':\n\t  s = \" \\\\b\";\n\t  break;\n\n\tcase '\\f':\n\t  s = \" \\\\f\";\n\t  break;\n\n\tcase '\\n':\n\t  s = \" \\\\n\";\n\t  break;\n\n\tcase '\\r':\n\t  s = \" \\\\r\";\n\t  break;\n\n\tcase '\\t':\n\t  s = \" \\\\t\";\n\t  break;\n\n\tcase '\\v':\n\t  s = \" \\\\v\";\n\t  break;\n\n\tdefault:\n\t  sprintf (buf, (isprint (c) ? \"  %c\" : \"%03o\"), c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n\n## Example:\n\n Input code:\nbool __cdecl unquote(const char *s, E_string *es_0)\n{\n  char *v2; // rax\n  size_t v3; // rdx\n  size_t v4; // rcx\n  __int64 v6; // [rsp+0h] [rbp-70h]\n  __int64 v7; // [rsp+8h] [rbp-68h]\n  __int64 v8; // [rsp+10h] [rbp-60h]\n  unsigned int oct_digit; // [rsp+38h] [rbp-38h]\n  unsigned int oct_digita; // [rsp+38h] [rbp-38h]\n  unsigned __int8 c; // [rsp+3Fh] [rbp-31h]\n  size_t len; // [rsp+40h] [rbp-30h]\n  size_t j; // [rsp+48h] [rbp-28h]\n  size_t i; // [rsp+50h] [rbp-20h]\n\n  len = strlen(s);\n  es_0->s = (char *)xmalloc(len);\n  es_0->escaped = (bool *)xcalloc(len, 1uLL);\n  j = 0LL;\n  for ( i = 0LL; s[i]; ++i )\n  {\n    if ( s[i] == 92 )\n    {\n      es_0->escaped[j] = 1;\n      switch ( s[i + 1] )\n      {\n        case 0:\n          es_0->escaped[j] = 0;\n          --i;\n          c = 92;\n          break;\n        case 0x30:\n        case 0x31:\n        case 0x32:\n        case 0x33:\n        case 0x34:\n        case 0x35:\n        case 0x36:\n        case 0x37:\n          c = s[i + 1] - 48;\n          oct_digit = s[i + 2] - 48;\n          if ( oct_digit <= 7 )\n          {\n            c = oct_digit + 8 * c;\n            oct_digita = s[++i + 2] - 48;\n            if ( oct_digita <= 7 )\n            {\n              if ( (int)(oct_digita + 8 * c) >= 256 )\n              {\n                v2 = gettext(\n                       \"warning: the ambiguous octal escape \\\\%c%c%c is being\\n\"\n                       \"\\tinterpreted as the 2-byte sequence \\\\0%c%c, %c\");\n                LODWORD(v6) = s[i];\n                LODWORD(v7) = s[i + 1];\n                LODWORD(v8) = s[i + 2];\n                error(0, 0, v2, (unsigned int)v6, (unsigned int)v7, (unsigned int)v8, v6, v7, v8);\n              }\n              else\n              {\n                c = oct_digita + 8 * c;\n                ++i;\n              }\n            }\n          }\n          break;\n        case 0x5C:\n          c = 92;\n          break;\n        case 0x61:\n          c = 7;\n          break;\n        case 0x62:\n          c = 8;\n          break;\n        case 0x66:\n          c = 12;\n          break;\n        case 0x6E:\n          c = 10;\n          break;\n        case 0x72:\n          c = 13;\n          break;\n        case 0x74:\n          c = 9;\n          break;\n        case 0x76:\n          c = 11;\n          break;\n        default:\n          c = s[i + 1];\n          break;\n      }\n      ++i;\n      v3 = j++;\n      es_0->s[v3] = c;\n    }\n    else\n    {\n      v4 = j++;\n      es_0->s[v4] = s[i];\n    }\n  }\n  es_0->len = j;\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nunquote (char const *s, struct E_string *es)\n{\n  size_t i, j;\n  size_t len = strlen (s);\n\n  es->s = xmalloc (len);\n  es->escaped = xcalloc (len, sizeof es->escaped[0]);\n\n  j = 0;\n  for (i = 0; s[i]; i++)\n    {\n      unsigned char c;\n      int oct_digit;\n\n      switch (s[i])\n\t{\n\tcase '\\\\':\n\t  es->escaped[j] = true;\n\t  switch (s[i + 1])\n\t    {\n\t    case '\\\\':\n\t      c = '\\\\';\n\t      break;\n\t    case 'a':\n\t      c = '\\a';\n\t      break;\n\t    case 'b':\n\t      c = '\\b';\n\t      break;\n\t    case 'f':\n\t      c = '\\f';\n\t      break;\n\t    case 'n':\n\t      c = '\\n';\n\t      break;\n\t    case 'r':\n\t      c = '\\r';\n\t      break;\n\t    case 't':\n\t      c = '\\t';\n\t      break;\n\t    case 'v':\n\t      c = '\\v';\n\t      break;\n\t    case '0':\n\t    case '1':\n\t    case '2':\n\t    case '3':\n\t    case '4':\n\t    case '5':\n\t    case '6':\n\t    case '7':\n\t      c = s[i + 1] - '0';\n\t      oct_digit = s[i + 2] - '0';\n\t      if (0 <= oct_digit && oct_digit <= 7)\n\t\t{\n\t\t  c = 8 * c + oct_digit;\n\t\t  ++i;\n\t\t  oct_digit = s[i + 2] - '0';\n\t\t  if (0 <= oct_digit && oct_digit <= 7)\n\t\t    {\n\t\t      if (8 * c + oct_digit < N_CHARS)\n\t\t\t{\n\t\t\t  c = 8 * c + oct_digit;\n\t\t\t  ++i;\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  /* A 3-digit octal number larger than \\377 won't\n\t\t\t     fit in 8 bits.  So we stop when adding the\n\t\t\t     next digit would put us over the limit and\n\t\t\t     give a warning about the ambiguity.  POSIX\n\t\t\t     isn't clear on this, and we interpret this\n\t\t\t     lack of clarity as meaning the resulting behavior\n\t\t\t     is undefined, which means we're allowed to issue\n\t\t\t     a warning.  */\n\t\t\t  error (0, 0, _(\"warning: the ambiguous octal escape \\\n\\\\%c%c%c is being\\n\\tinterpreted as the 2-byte sequence \\\\0%c%c, %c\"),\n\t\t\t\t s[i], s[i + 1], s[i + 2],\n\t\t\t\t s[i], s[i + 1], s[i + 2]);\n\t\t\t}\n\t\t    }\n\t\t}\n\t      break;\n\t    case '\\0':\n\t      /* POSIX seems to require that a trailing backslash must\n\t\t stand for itself.  Weird.  */\n\t      es->escaped[j] = false;\n\t      i--;\n\t      c = '\\\\';\n\t      break;\n\t    default:\n\t      c = s[i + 1];\n\t      break;\n\t    }\n\t  ++i;\n\t  es->s[j++] = c;\n\t  break;\n\tdefault:\n\t  es->s[j++] = s[i];\n\t  break;\n\t}\n    }\n  es->len = j;\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_473CD2(const char *a1, char a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // rax\n  const char *v8; // rdx\n  char *v9; // rax\n  char *s; // [rsp+8h] [rbp-48h]\n  int v11; // [rsp+1Ch] [rbp-34h]\n  __int64 v12; // [rsp+20h] [rbp-30h]\n  size_t n; // [rsp+28h] [rbp-28h]\n  int v14; // [rsp+30h] [rbp-20h]\n  int v15; // [rsp+34h] [rbp-1Ch]\n  char *v16; // [rsp+38h] [rbp-18h]\n  const char *dest; // [rsp+40h] [rbp-10h]\n  const char *v18; // [rsp+48h] [rbp-8h]\n\n  s = (char *)a1;\n  v18 = strpbrk(a1, &byte_51DF10);\n  if ( !v18 )\n    return a1;\n  dest = v18;\n  v16 = (char *)a1;\n  if ( (a2 & 1) != 0 )\n  {\n    n = v18 - a1;\n    v3 = strlen(v18);\n    v12 = v3 + v18 - a1 + 1;\n    if ( (a2 & 8) != 0 )\n    {\n      v11 = (_DWORD)a1 - *(_QWORD *)(qword_75D428 + 16);\n      v16 = (char *)sub_46ECB9(v12, qword_75AFC8, qword_75AFC8, v4, v5, v6);\n      s = (char *)(*(_QWORD *)(qword_75D428 + 16) + v11);\n      v18 = &s[n];\n    }\n    else\n    {\n      v16 = (a2 & 0x10) != 0\n          ? (char *)sub_40A05F(v12, (__int64)&byte_51DF10)\n          : (char *)sub_46E6A8(v12, (__int64)&byte_51DF10, v3, v4, v5, v6);\n    }\n    dest = v16;\n    if ( n )\n      dest = (char *)memcpy(v16, s, n) + n;\n  }\n  v15 = ~a2 & 4;\n  v14 = a2 & 2;\n  while ( *v18 )\n  {\n    if ( *v18 == -120 )\n    {\n      v15 = ~v15;\n      ++v18;\n      v14 = a2 & 2;\n    }\n    else\n    {\n      if ( *v18 == 92 )\n      {\n        v14 = 0;\n      }\n      else\n      {\n        if ( *v18 == -127 )\n        {\n          ++v18;\n          if ( v14 )\n          {\n            if ( v15 && *v18 != 47 )\n            {\n              v7 = (char *)dest++;\n              *v7 = 92;\n            }\n          }\n        }\n        v14 = a2 & 2;\n      }\n      v8 = v18++;\n      v9 = (char *)dest++;\n      *v9 = *v8;\n    }\n  }\n  *dest = 0;\n  if ( (a2 & 8) != 0 )\n    qword_75AFC8 = (__int64)(dest + 1);\n  return v16;\n}\n",
        "output": "```c\nstatic const char *\nsub_473CD2 (const char *input, char flags)\n{\n  const char *special_chars_ptr;\n  char *output;\n  size_t prefix_len;\n  size_t total_len;\n  int escape_next_char = 0;\n  int escape_slash = flags & 2;\n  int escape_special = ~(flags & 4);\n  const char *src;\n  char *dst;\n\n  special_chars_ptr = strpbrk(input, special_chars);\n  if (!special_chars_ptr)\n    return input;\n\n  if (flags & 1)\n    {\n      prefix_len = special_chars_ptr - input;\n      total_len = strlen(special_chars_ptr) + prefix_len + 1;\n\n      if (flags & 8)\n        {\n          output = custom_alloc(total_len);\n          input = update_input_pointer(input);\n          special_chars_ptr = update_special_chars_ptr(input, prefix_len);\n        }\n      else\n        {\n          output = (flags & 0x10) ? custom_alloc2(total_len) : custom_alloc3(total_len);\n        }\n\n      if (prefix_len)\n        output = (char *)memcpy(output, input, prefix_len) + prefix_len;\n    }\n  else\n    {\n      output = (char *)input;\n    }\n\n  src = special_chars_ptr;\n  dst = output;\n\n  while (*src)\n    {\n      if (*src == escape_char_1)\n        {\n          escape_special = ~escape_special;\n          src++;\n          escape_slash = flags & 2;\n        }\n      else\n        {\n          if (*src == '\\\\')\n            {\n              escape_slash = 0;\n            }\n          else\n            {\n              if (*src == escape_char_2)\n                {\n                  src++;\n                  if (escape_slash)\n                    {\n                      if (escape_special && *src != '/')\n                        {\n                          *dst++ = '\\\\';\n                        }\n                    }\n                }\n              escape_slash = flags & 2;\n            }\n          *dst++ = *src++;\n        }\n    }\n  *dst = '\\0';\n\n  if (flags & 8)\n    update_global_pointer(dst + 1);\n\n  return output;\n}\n```",
        "source_code": "static char *\nrmescapes(char *str, int flag)\n{\n\tstatic const char qchars[] ALIGN1 = { CTLESC, CTLQUOTEMARK, '\\0' };\n\n\tchar *p, *q, *r;\n\tunsigned inquotes;\n\tunsigned protect_against_glob;\n\tunsigned globbing;\n\n\tp = strpbrk(str, qchars);\n\tif (!p)\n\t\treturn str;\n\n\tq = p;\n\tr = str;\n\tif (flag & RMESCAPE_ALLOC) {\n\t\tsize_t len = p - str;\n\t\tsize_t fulllen = len + strlen(p) + 1;\n\n\t\tif (flag & RMESCAPE_GROW) {\n\t\t\tint strloc = str - (char *)stackblock();\n\t\t\tr = makestrspace(fulllen, expdest);\n\t\t\t/* p and str may be invalidated by makestrspace */\n\t\t\tstr = (char *)stackblock() + strloc;\n\t\t\tp = str + len;\n\t\t} else if (flag & RMESCAPE_HEAP) {\n\t\t\tr = ckmalloc(fulllen);\n\t\t} else {\n\t\t\tr = stalloc(fulllen);\n\t\t}\n\t\tq = r;\n\t\tif (len > 0) {\n\t\t\tq = (char *)memcpy(q, str, len) + len;\n\t\t}\n\t}\n\n\tinquotes = (flag & RMESCAPE_QUOTED) ^ RMESCAPE_QUOTED;\n\tglobbing = flag & RMESCAPE_GLOB;\n\tprotect_against_glob = globbing;\n\twhile (*p) {\n\t\tif ((unsigned char)*p == CTLQUOTEMARK) {\n// TODO: if no RMESCAPE_QUOTED in flags, inquotes never becomes 0\n// (alternates between RMESCAPE_QUOTED and ~RMESCAPE_QUOTED). Is it ok?\n// Note: both inquotes and protect_against_glob only affect whether\n// CTLESC,<ch> gets converted to <ch> or to \\<ch>\n\t\t\tinquotes = ~inquotes;\n\t\t\tp++;\n\t\t\tprotect_against_glob = globbing;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*p == '\\\\') {\n\t\t\t/* naked back slash */\n\t\t\tprotect_against_glob = 0;\n\t\t\tgoto copy;\n\t\t}\n\t\tif ((unsigned char)*p == CTLESC) {\n\t\t\tp++;\n\t\t\tif (protect_against_glob && inquotes && *p != '/') {\n\t\t\t\t*q++ = '\\\\';\n\t\t\t}\n\t\t}\n\t\tprotect_against_glob = globbing;\n copy:\n\t\t*q++ = *p++;\n\t}\n\t*q = '\\0';\n\tif (flag & RMESCAPE_GROW) {\n\t\texpdest = r;\n\t\tSTADJUST(q - r + 1, expdest);\n\t}\n\treturn r;\n}",
        "parsed_output": "static const char *\nsub_473CD2 (const char *input, char flags)\n{\n  const char *special_chars_ptr;\n  char *output;\n  size_t prefix_len;\n  size_t total_len;\n  int escape_next_char = 0;\n  int escape_slash = flags & 2;\n  int escape_special = ~(flags & 4);\n  const char *src;\n  char *dst;\n\n  special_chars_ptr = strpbrk(input, special_chars);\n  if (!special_chars_ptr)\n    return input;\n\n  if (flags & 1)\n    {\n      prefix_len = special_chars_ptr - input;\n      total_len = strlen(special_chars_ptr) + prefix_len + 1;\n\n      if (flags & 8)\n        {\n          output = custom_alloc(total_len);\n          input = update_input_pointer(input);\n          special_chars_ptr = update_special_chars_ptr(input, prefix_len);\n        }\n      else\n        {\n          output = (flags & 0x10) ? custom_alloc2(total_len) : custom_alloc3(total_len);\n        }\n\n      if (prefix_len)\n        output = (char *)memcpy(output, input, prefix_len) + prefix_len;\n    }\n  else\n    {\n      output = (char *)input;\n    }\n\n  src = special_chars_ptr;\n  dst = output;\n\n  while (*src)\n    {\n      if (*src == escape_char_1)\n        {\n          escape_special = ~escape_special;\n          src++;\n          escape_slash = flags & 2;\n        }\n      else\n        {\n          if (*src == '\\\\')\n            {\n              escape_slash = 0;\n            }\n          else\n            {\n              if (*src == escape_char_2)\n                {\n                  src++;\n                  if (escape_slash)\n                    {\n                      if (escape_special && *src != '/')\n                        {\n                          *dst++ = '\\\\';\n                        }\n                    }\n                }\n              escape_slash = flags & 2;\n            }\n          *dst++ = *src++;\n        }\n    }\n  *dst = '\\0';\n\n  if (flags & 8)\n    update_global_pointer(dst + 1);\n\n  return output;\n}",
        "baseline_code_stripped": "const char *__fastcall sub_473CD2(const char *a1, char a2)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  char *v7; // rax\n  const char *v8; // rdx\n  char *v9; // rax\n  char *s; // [rsp+8h] [rbp-48h]\n  int v11; // [rsp+1Ch] [rbp-34h]\n  __int64 v12; // [rsp+20h] [rbp-30h]\n  size_t n; // [rsp+28h] [rbp-28h]\n  int v14; // [rsp+30h] [rbp-20h]\n  int v15; // [rsp+34h] [rbp-1Ch]\n  char *v16; // [rsp+38h] [rbp-18h]\n  const char *dest; // [rsp+40h] [rbp-10h]\n  const char *v18; // [rsp+48h] [rbp-8h]\n\n  s = (char *)a1;\n  v18 = strpbrk(a1, &byte_51DF10);\n  if ( !v18 )\n    return a1;\n  dest = v18;\n  v16 = (char *)a1;\n  if ( (a2 & 1) != 0 )\n  {\n    n = v18 - a1;\n    v3 = strlen(v18);\n    v12 = v3 + v18 - a1 + 1;\n    if ( (a2 & 8) != 0 )\n    {\n      v11 = (_DWORD)a1 - *(_QWORD *)(qword_75D428 + 16);\n      v16 = (char *)sub_46ECB9(v12, qword_75AFC8, qword_75AFC8, v4, v5, v6);\n      s = (char *)(*(_QWORD *)(qword_75D428 + 16) + v11);\n      v18 = &s[n];\n    }\n    else\n    {\n      v16 = (a2 & 0x10) != 0\n          ? (char *)sub_40A05F(v12, (__int64)&byte_51DF10)\n          : (char *)sub_46E6A8(v12, (__int64)&byte_51DF10, v3, v4, v5, v6);\n    }\n    dest = v16;\n    if ( n )\n      dest = (char *)memcpy(v16, s, n) + n;\n  }\n  v15 = ~a2 & 4;\n  v14 = a2 & 2;\n  while ( *v18 )\n  {\n    if ( *v18 == -120 )\n    {\n      v15 = ~v15;\n      ++v18;\n      v14 = a2 & 2;\n    }\n    else\n    {\n      if ( *v18 == 92 )\n      {\n        v14 = 0;\n      }\n      else\n      {\n        if ( *v18 == -127 )\n        {\n          ++v18;\n          if ( v14 )\n          {\n            if ( v15 && *v18 != 47 )\n            {\n              v7 = (char *)dest++;\n              *v7 = 92;\n            }\n          }\n        }\n        v14 = a2 & 2;\n      }\n      v8 = v18++;\n      v9 = (char *)dest++;\n      *v9 = *v8;\n    }\n  }\n  *dest = 0;\n  if ( (a2 & 8) != 0 )\n    qword_75AFC8 = (__int64)(dest + 1);\n  return v16;\n}\n",
        "baseline_code_debug": "char *__cdecl rmescapes(char *str, int flag)\n{\n  char *v3; // rax\n  const char *v4; // rdx\n  char *v5; // rax\n  char *stra; // [rsp+8h] [rbp-48h]\n  int strloc; // [rsp+1Ch] [rbp-34h]\n  size_t fulllen; // [rsp+20h] [rbp-30h]\n  size_t len; // [rsp+28h] [rbp-28h]\n  int protect_against_glob; // [rsp+30h] [rbp-20h]\n  int inquotes; // [rsp+34h] [rbp-1Ch]\n  char *r; // [rsp+38h] [rbp-18h]\n  char *q; // [rsp+40h] [rbp-10h]\n  const char *p; // [rsp+48h] [rbp-8h]\n\n  stra = str;\n  p = strpbrk(str, qchars_9544);\n  if ( !p )\n    return str;\n  q = (char *)p;\n  r = str;\n  if ( (flag & 1) != 0 )\n  {\n    len = p - str;\n    fulllen = strlen(p) + p - str + 1;\n    if ( (flag & 8) != 0 )\n    {\n      strloc = (_DWORD)str - (unsigned __int64)ash_ptr_to_globals_memstack->g_stacknxt;\n      r = makestrspace(fulllen, expdest);\n      stra = &ash_ptr_to_globals_memstack->g_stacknxt[strloc];\n      p = &stra[len];\n    }\n    else\n    {\n      r = (char *)((flag & 0x10) != 0 ? xmalloc(fulllen) : stalloc(fulllen));\n    }\n    q = r;\n    if ( len )\n      q = (char *)memcpy(r, stra, len) + len;\n  }\n  inquotes = ~(_BYTE)flag & 4;\n  protect_against_glob = flag & 2;\n  while ( *p )\n  {\n    if ( *p == -120 )\n    {\n      inquotes = ~inquotes;\n      ++p;\n      protect_against_glob = flag & 2;\n    }\n    else\n    {\n      if ( *p == 92 )\n      {\n        protect_against_glob = 0;\n      }\n      else\n      {\n        if ( *p == -127 )\n        {\n          ++p;\n          if ( protect_against_glob )\n          {\n            if ( inquotes && *p != 47 )\n            {\n              v3 = q++;\n              *v3 = 92;\n            }\n          }\n        }\n        protect_against_glob = flag & 2;\n      }\n      v4 = p++;\n      v5 = q++;\n      *v5 = *v4;\n    }\n  }\n  *q = 0;\n  if ( (flag & 8) != 0 )\n    expdest = q + 1;\n  return r;\n}\n",
        "similarity_score_unixcoder": 0.7038188576698303,
        "similarity_score_baseline_stripped": 0.6050715446472168,
        "similarity_score_baseline_debug": 0.8785691261291504
    },
    {
        "func_name": "run_script",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl __noreturn run_shell(\n        const char *shell,\n        const char *command,\n        char **additional_args,\n        size_t n_additional_args)\n{\n  size_t v4; // rax\n  size_t v5; // rdx\n  int *v6; // rax\n  int v7; // r8d\n  int *v8; // rax\n  int exit_status; // [rsp+14h] [rbp-4Ch]\n  const char *shell_basename; // [rsp+18h] [rbp-48h]\n  char *arg0; // [rsp+20h] [rbp-40h]\n  size_t argno; // [rsp+28h] [rbp-38h]\n  const char **args; // [rsp+30h] [rbp-30h]\n\n  args = (const char **)xnmalloc(n_additional_args + 2 * (command != 0LL) + fast_startup + 1 + 1, 8uLL);\n  argno = 1LL;\n  if ( simulate_login )\n  {\n    shell_basename = last_component(shell);\n    v4 = strlen(shell_basename);\n    arg0 = (char *)xmalloc(v4 + 2);\n    *arg0 = 45;\n    strcpy(arg0 + 1, shell_basename);\n    *args = arg0;\n  }\n  else\n  {\n    *args = last_component(shell);\n  }\n  if ( fast_startup )\n  {\n    argno = 2LL;\n    args[1] = \"-f\";\n  }\n  if ( command )\n  {\n    args[argno] = \"-c\";\n    v5 = argno + 1;\n    argno += 2LL;\n    args[v5] = command;\n  }\n  memcpy(&args[argno], additional_args, 8 * n_additional_args);\n  (&args[n_additional_args])[argno] = 0LL;\n  execv(shell, (char *const *)args);\n  v6 = __errno_location();\n  v7 = 126;\n  if ( *v6 == 2 )\n    v7 = 127;\n  exit_status = v7;\n  v8 = __errno_location();\n  error(0, *v8, \"%s\", shell);\n  exit(exit_status);\n}\n\n\n Revised code:\nstatic void\nrun_shell (char const *shell, char const *command, char **additional_args,\n\t   size_t n_additional_args)\n{\n  size_t n_args = 1 + fast_startup + 2 * !!command + n_additional_args + 1;\n  char const **args = xnmalloc (n_args, sizeof *args);\n  size_t argno = 1;\n\n  if (simulate_login)\n    {\n      char *arg0;\n      char *shell_basename;\n\n      shell_basename = last_component (shell);\n      arg0 = xmalloc (strlen (shell_basename) + 2);\n      arg0[0] = '-';\n      strcpy (arg0 + 1, shell_basename);\n      args[0] = arg0;\n    }\n  else\n    args[0] = last_component (shell);\n  if (fast_startup)\n    args[argno++] = \"-f\";\n  if (command)\n    {\n      args[argno++] = \"-c\";\n      args[argno++] = command;\n    }\n  memcpy (args + argno, additional_args, n_additional_args * sizeof *args);\n  args[argno + n_additional_args] = NULL;\n  execv (shell, (char **) args);\n\n  {\n    int exit_status = (errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE);\n    error (0, errno, \"%s\", shell);\n    exit (exit_status);\n  }\n}\n\n## Example:\n\n Input code:\nbool __cdecl sysv_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  int *v5; // rax\n  char *v6; // rax\n  size_t bytes_read; // [rsp+20h] [rbp-22E0h]\n  size_t i; // [rsp+28h] [rbp-22D8h]\n  _BYTE is_stdin[5]; // [rsp+33h] [rbp-22CDh]\n  char hbuf[652]; // [rsp+40h] [rbp-22C0h] BYREF\n  uintmax_t total_bytes; // [rsp+2D8h] [rbp-2028h]\n  unsigned __int8 buf[8192]; // [rsp+2E0h] [rbp-2020h] BYREF\n  int fd; // [rsp+22E8h] [rbp-18h]\n  int print_namea; // [rsp+22ECh] [rbp-14h]\n  const char *filea; // [rsp+22F0h] [rbp-10h]\n  char v17; // [rsp+22FFh] [rbp-1h]\n\n  filea = file;\n  print_namea = print_name;\n  total_bytes = 0LL;\n  is_stdin[4] = 0;\n  v2 = strcmp(file, \"-\");\n  *(_DWORD *)is_stdin = v2 == 0;\n  if ( !v2 )\n  {\n    fd = 0;\n    have_read_stdin = 1;\n    goto LABEL_5;\n  }\n  fd = open(filea, 0);\n  if ( fd == -1 )\n  {\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    v17 = 0;\n  }\n  else\n  {\nLABEL_5:\n    while ( 1 )\n    {\n      bytes_read = safe_read(fd, buf, 0x2000uLL);\n      if ( !bytes_read )\n        break;\n      if ( bytes_read == -1LL )\n      {\n        v4 = __errno_location();\n        error(0, *v4, \"%s\", filea);\n        if ( (is_stdin[0] & 1) == 0 )\n          close(fd);\n        v17 = 0;\n        return v17 & 1;\n      }\n      for ( i = 0LL; i < bytes_read; ++i )\n        *(_DWORD *)&is_stdin[1] += buf[i];\n      total_bytes += bytes_read;\n    }\n    if ( (is_stdin[0] & 1) != 0 || !close(fd) )\n    {\n      v6 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x200uLL);\n      printf(\n        \"%d %s\",\n        ((HIWORD(*(_DWORD *)&is_stdin[1]) + *(unsigned __int16 *)&is_stdin[1]) >> 16)\n      + (unsigned int)(unsigned __int16)(*(_WORD *)&is_stdin[3] + *(_WORD *)&is_stdin[1]),\n        v6);\n      if ( print_namea )\n        printf(\" %s\", filea);\n      putchar_unlocked(10);\n      v17 = 1;\n    }\n    else\n    {\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filea);\n      v17 = 0;\n    }\n  }\n  return v17 & 1;\n}\n\n\n Revised code:\nstatic bool\nsysv_sum_file (const char *file, int print_name)\n{\n  int fd;\n  unsigned char buf[8192];\n  uintmax_t total_bytes = 0;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int r;\n  int checksum;\n\n  /* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n  unsigned int s = 0;\n\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fd = STDIN_FILENO;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while (1)\n    {\n      size_t i;\n      size_t bytes_read = safe_read (fd, buf, sizeof buf);\n\n      if (bytes_read == 0)\n\tbreak;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  if (!is_stdin)\n\t    close (fd);\n\t  return false;\n\t}\n\n      for (i = 0; i < bytes_read; i++)\n\ts += buf[i];\n      total_bytes += bytes_read;\n    }\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  checksum = (r & 0xffff) + (r >> 16);\n\n  printf (\"%d %s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 512));\n  if (print_name)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_430974(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  const char *v6; // rax\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  const char *v10; // rax\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  __int64 v13; // r9\n  __int64 v14; // rdx\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  __int64 v17; // r9\n  __int64 v19[5]; // [rsp+10h] [rbp-40h] BYREF\n  unsigned int v20; // [rsp+3Ch] [rbp-14h]\n  char *v21; // [rsp+40h] [rbp-10h]\n  char *string; // [rsp+48h] [rbp-8h]\n\n  sub_409747(\"executing '%s %s %s'\", *((_QWORD *)qword_75D408 + 4), *((_QWORD *)qword_75D408 + 2), a1, a5, a6);\n  v19[0] = *((_QWORD *)qword_75D408 + 4);\n  v19[1] = *((_QWORD *)qword_75D408 + 2);\n  v19[2] = a1;\n  v19[3] = *((_QWORD *)qword_75D408 + 5);\n  v19[4] = 0LL;\n  v6 = sub_43094C(*((char *)qword_75D408 + 1));\n  string = sub_40A6B3(\"%s=%s\", (__int64)\"IFPLUGD_PREVIOUS\", (__int64)v6, v7, v8, v9);\n  putenv(string);\n  v10 = sub_43094C(*(char *)qword_75D408);\n  v21 = sub_40A6B3(\"%s=%s\", (__int64)\"IFPLUGD_CURRENT\", (__int64)v10, v11, v12, v13);\n  putenv(v21);\n  v20 = sub_50A624(v19);\n  unsetenv(\"IFPLUGD_PREVIOUS\");\n  unsetenv(\"IFPLUGD_CURRENT\");\n  free(string);\n  free(v21);\n  sub_409747(\"exit code: %d\", (unsigned __int8)v20, v14, v15, v16, v17);\n  if ( (dword_75D450 & 0x80) != 0 )\n    return 0LL;\n  else\n    return v20;\n}\n",
        "output": "```c\nstatic unsigned int\nrun_command_with_env_vars(const char *arg1, const char *arg2, const char *arg3, const char *arg4, const char *arg5)\n{\n  const char *previous_env_value;\n  const char *current_env_value;\n  char *previous_env_str;\n  char *current_env_str;\n  unsigned int exit_code;\n  const char *env_var_names[5];\n\n  log_message(\"executing '%s %s %s'\", global_var_1, global_var_2, arg1);\n  env_var_names[0] = global_var_1;\n  env_var_names[1] = global_var_2;\n  env_var_names[2] = arg1;\n  env_var_names[3] = global_var_3;\n  env_var_names[4] = NULL;\n\n  previous_env_value = get_env_value(global_flag + 1);\n  previous_env_str = format_string(\"%s=%s\", \"IFPLUGD_PREVIOUS\", previous_env_value);\n  putenv(previous_env_str);\n\n  current_env_value = get_env_value(*global_flag);\n  current_env_str = format_string(\"%s=%s\", \"IFPLUGD_CURRENT\", current_env_value);\n  putenv(current_env_str);\n\n  exit_code = execute_command(env_var_names);\n\n  unsetenv(\"IFPLUGD_PREVIOUS\");\n  unsetenv(\"IFPLUGD_CURRENT\");\n\n  free(previous_env_str);\n  free(current_env_str);\n\n  log_message(\"exit code: %d\", exit_code);\n\n  if (global_options & OPTION_MASK)\n    return 0;\n  else\n    return exit_code;\n}\n```",
        "source_code": "static int run_script(const char *action)\n{\n\tchar *env_PREVIOUS, *env_CURRENT;\n\tchar *argv[5];\n\tint r;\n\n\tbb_error_msg(\"executing '%s %s %s'\", G.script_name, G.iface, action);\n\n\targv[0] = (char*) G.script_name;\n\targv[1] = (char*) G.iface;\n\targv[2] = (char*) action;\n\targv[3] = (char*) G.extra_arg;\n\targv[4] = NULL;\n\n\tenv_PREVIOUS = xasprintf(\"%s=%s\", IFPLUGD_ENV_PREVIOUS, strstatus(G.iface_prev_status));\n\tputenv(env_PREVIOUS);\n\tenv_CURRENT = xasprintf(\"%s=%s\", IFPLUGD_ENV_CURRENT, strstatus(G.iface_last_status));\n\tputenv(env_CURRENT);\n\n\t/* r < 0 - can't exec, 0 <= r < 0x180 - exited, >=0x180 - killed by sig (r-0x180) */\n\tr = spawn_and_wait(argv);\n\n\tunsetenv(IFPLUGD_ENV_PREVIOUS);\n\tunsetenv(IFPLUGD_ENV_CURRENT);\n\tfree(env_PREVIOUS);\n\tfree(env_CURRENT);\n\n\tbb_error_msg(\"exit code: %d\", r & 0xff);\n\treturn (option_mask32 & FLAG_IGNORE_RETVAL) ? 0 : r;\n}",
        "parsed_output": "static unsigned int\nrun_command_with_env_vars(const char *arg1, const char *arg2, const char *arg3, const char *arg4, const char *arg5)\n{\n  const char *previous_env_value;\n  const char *current_env_value;\n  char *previous_env_str;\n  char *current_env_str;\n  unsigned int exit_code;\n  const char *env_var_names[5];\n\n  log_message(\"executing '%s %s %s'\", global_var_1, global_var_2, arg1);\n  env_var_names[0] = global_var_1;\n  env_var_names[1] = global_var_2;\n  env_var_names[2] = arg1;\n  env_var_names[3] = global_var_3;\n  env_var_names[4] = NULL;\n\n  previous_env_value = get_env_value(global_flag + 1);\n  previous_env_str = format_string(\"%s=%s\", \"IFPLUGD_PREVIOUS\", previous_env_value);\n  putenv(previous_env_str);\n\n  current_env_value = get_env_value(*global_flag);\n  current_env_str = format_string(\"%s=%s\", \"IFPLUGD_CURRENT\", current_env_value);\n  putenv(current_env_str);\n\n  exit_code = execute_command(env_var_names);\n\n  unsetenv(\"IFPLUGD_PREVIOUS\");\n  unsetenv(\"IFPLUGD_CURRENT\");\n\n  free(previous_env_str);\n  free(current_env_str);\n\n  log_message(\"exit code: %d\", exit_code);\n\n  if (global_options & OPTION_MASK)\n    return 0;\n  else\n    return exit_code;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_430974(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  const char *v6; // rax\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  const char *v10; // rax\n  __int64 v11; // rcx\n  __int64 v12; // r8\n  __int64 v13; // r9\n  __int64 v14; // rdx\n  __int64 v15; // rcx\n  __int64 v16; // r8\n  __int64 v17; // r9\n  __int64 v19[5]; // [rsp+10h] [rbp-40h] BYREF\n  unsigned int v20; // [rsp+3Ch] [rbp-14h]\n  char *v21; // [rsp+40h] [rbp-10h]\n  char *string; // [rsp+48h] [rbp-8h]\n\n  sub_409747(\"executing '%s %s %s'\", *((_QWORD *)qword_75D408 + 4), *((_QWORD *)qword_75D408 + 2), a1, a5, a6);\n  v19[0] = *((_QWORD *)qword_75D408 + 4);\n  v19[1] = *((_QWORD *)qword_75D408 + 2);\n  v19[2] = a1;\n  v19[3] = *((_QWORD *)qword_75D408 + 5);\n  v19[4] = 0LL;\n  v6 = sub_43094C(*((char *)qword_75D408 + 1));\n  string = sub_40A6B3(\"%s=%s\", (__int64)\"IFPLUGD_PREVIOUS\", (__int64)v6, v7, v8, v9);\n  putenv(string);\n  v10 = sub_43094C(*(char *)qword_75D408);\n  v21 = sub_40A6B3(\"%s=%s\", (__int64)\"IFPLUGD_CURRENT\", (__int64)v10, v11, v12, v13);\n  putenv(v21);\n  v20 = sub_50A624(v19);\n  unsetenv(\"IFPLUGD_PREVIOUS\");\n  unsetenv(\"IFPLUGD_CURRENT\");\n  free(string);\n  free(v21);\n  sub_409747(\"exit code: %d\", (unsigned __int8)v20, v14, v15, v16, v17);\n  if ( (dword_75D450 & 0x80) != 0 )\n    return 0LL;\n  else\n    return v20;\n}\n",
        "baseline_code_debug": "int __cdecl run_script(const char *action)\n{\n  const char *v1; // rax\n  const char *v2; // rax\n  char *argv[5]; // [rsp+10h] [rbp-40h] BYREF\n  int r; // [rsp+3Ch] [rbp-14h]\n  char *env_CURRENT; // [rsp+40h] [rbp-10h]\n  char *env_PREVIOUS; // [rsp+48h] [rbp-8h]\n\n  bb_error_msg(\"executing '%s %s %s'\", ptr_to_globals->initstring, ptr_to_globals->fakehost, action);\n  argv[0] = ptr_to_globals->initstring;\n  argv[1] = (char *)ptr_to_globals->fakehost;\n  argv[2] = (char *)action;\n  argv[3] = (char *)ptr_to_globals->issue;\n  argv[4] = 0LL;\n  v1 = strstatus(SBYTE1(ptr_to_globals->timeout));\n  env_PREVIOUS = xasprintf(\"%s=%s\", \"IFPLUGD_PREVIOUS\", v1);\n  putenv(env_PREVIOUS);\n  v2 = strstatus(SLOBYTE(ptr_to_globals->timeout));\n  env_CURRENT = xasprintf(\"%s=%s\", \"IFPLUGD_CURRENT\", v2);\n  putenv(env_CURRENT);\n  r = spawn_and_wait(argv);\n  unsetenv(\"IFPLUGD_PREVIOUS\");\n  unsetenv(\"IFPLUGD_CURRENT\");\n  free(env_PREVIOUS);\n  free(env_CURRENT);\n  bb_error_msg(\"exit code: %d\", (unsigned __int8)r);\n  if ( (option_mask32 & 0x80) != 0 )\n    return 0;\n  else\n    return r;\n}\n",
        "similarity_score_unixcoder": 0.8225736618041992,
        "similarity_score_baseline_stripped": 0.6035875082015991,
        "similarity_score_baseline_debug": 0.8448228240013123
    },
    {
        "func_name": "tokname",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl print_named_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  const unsigned __int8 *v3; // rax\n  char buf[5]; // [rsp+13h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+18h] [rbp-38h]\n  int masked_c; // [rsp+24h] [rbp-2Ch]\n  size_t i; // [rsp+28h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+30h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+38h] [rbp-18h]\n  const void *blocka; // [rsp+40h] [rbp-10h]\n  size_t n_bytesa; // [rsp+48h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = p++;\n    masked_c = *v3 & 0x7F;\n    if ( masked_c == 127 )\n    {\n      s = \"del\";\n    }\n    else if ( masked_c > 32 )\n    {\n      sprintf(buf, \"  %c\", (unsigned int)masked_c);\n      s = buf;\n    }\n    else\n    {\n      s = charname[masked_c];\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_named_ascii (size_t n_bytes, void const *block,\n\t\t   const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      int masked_c = *p++ & 0x7f;\n      const char *s;\n      char buf[5];\n\n      if (masked_c == 127)\n\ts = \"del\";\n      else if (masked_c <= 040)\n\ts = charname[masked_c];\n      else\n\t{\n\t  sprintf (buf, \"  %c\", masked_c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl adjust_column(size_t column, char c)\n{\n  size_t columna; // [rsp+2h] [rbp-8h]\n\n  columna = column;\n  if ( count_bytes )\n    return column + 1;\n  switch ( c )\n  {\n    case 8:\n      if ( column )\n        return column - 1;\n      break;\n    case 13:\n      return 0LL;\n    case 9:\n      return column + 8 - (column & 7);\n    default:\n      return column + 1;\n  }\n  return columna;\n}\n\n\n Revised code:\nstatic size_t\nadjust_column (size_t column, char c)\n{\n  if (!count_bytes)\n    {\n      if (c == '\\b')\n\t{\n\t  if (column > 0)\n\t    column--;\n\t}\n      else if (c == '\\r')\n\tcolumn = 0;\n      else if (c == '\\t')\n\tcolumn += TAB_WIDTH - column % TAB_WIDTH;\n      else /* if (isprint (c)) */\n\tcolumn++;\n    }\n  else\n    column++;\n  return column;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_char(size_t n_bytes, const void *block, const char *fmt_string)\n{\n  unsigned __int8 *v3; // rax\n\n  while ( n_bytes )\n  {\n    v3 = (unsigned __int8 *)block;\n    block = (char *)block + 1;\n    printf(fmt_string, *v3);\n    --n_bytes;\n  }\n}\n\n\n Revised code:\nstatic void\nprint_char (size_t n_bytes, void const *block, char const *fmt_string)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes / sizeof *p; i != 0; i--)\n    printf (fmt_string, *p++);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_47B556(char *a1, int a2)\n{\n  if ( a2 <= 3 )\n    return (char *)*(&off_51D220 + a2) + 1;\n  sprintf(a1, \"\\\"%s\\\"\", (const char *)*(&off_51D220 + a2) + 1);\n  return a1;\n}\n",
        "output": "```c\nstatic char *\nget_error_message (char *buffer, int error_code)\n{\n  static const char *error_messages[] = {\n    /* Assuming off_51D220 is an array of error messages */\n    error_message_0,\n    error_message_1,\n    error_message_2,\n    error_message_3,\n    /* ... additional error messages ... */\n  };\n\n  if (error_code <= 3)\n    return error_messages[error_code] + 1;\n  else\n    {\n      sprintf(buffer, \"\\\"%s\\\"\", error_messages[error_code] + 1);\n      return buffer;\n    }\n}\n```",
        "source_code": "static const char *\ntokname(char *buf, int tok)\n{\n\tif (tok < TSEMI)\n\t\treturn tokname_array[tok] + 1;\n\tsprintf(buf, \"\\\"%s\\\"\", tokname_array[tok] + 1);\n\treturn buf;\n}",
        "parsed_output": "static char *\nget_error_message (char *buffer, int error_code)\n{\n  static const char *error_messages[] = {\n    /* Assuming off_51D220 is an array of error messages */\n    error_message_0,\n    error_message_1,\n    error_message_2,\n    error_message_3,\n    /* ... additional error messages ... */\n  };\n\n  if (error_code <= 3)\n    return error_messages[error_code] + 1;\n  else\n    {\n      sprintf(buffer, \"\\\"%s\\\"\", error_messages[error_code] + 1);\n      return buffer;\n    }\n}",
        "baseline_code_stripped": "char *__fastcall sub_47B556(char *a1, int a2)\n{\n  if ( a2 <= 3 )\n    return (char *)*(&off_51D220 + a2) + 1;\n  sprintf(a1, \"\\\"%s\\\"\", (const char *)*(&off_51D220 + a2) + 1);\n  return a1;\n}\n",
        "baseline_code_debug": "const char *__cdecl tokname(char *buf, int tok)\n{\n  if ( tok <= 3 )\n    return tokname_array[tok] + 1;\n  sprintf(buf, \"\\\"%s\\\"\", (const char *)tokname_array[tok] + 1);\n  return buf;\n}\n",
        "similarity_score_unixcoder": 0.5800705552101135,
        "similarity_score_baseline_stripped": 0.5869812369346619,
        "similarity_score_baseline_debug": 0.896073043346405
    },
    {
        "func_name": "print_stats_cpu_struct",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  char *v5; // rax\n  unsigned int v7; // [rsp+14h] [rbp-2CCh]\n  bool is_stdin; // [rsp+1Fh] [rbp-2C1h]\n  char hbuf[652]; // [rsp+20h] [rbp-2C0h] BYREF\n  int ch_0; // [rsp+2ACh] [rbp-34h]\n  uintmax_t total_bytes; // [rsp+2B0h] [rbp-30h]\n  int checksum; // [rsp+2BCh] [rbp-24h]\n  FILE *fp; // [rsp+2C0h] [rbp-20h]\n  int print_namea; // [rsp+2CCh] [rbp-14h]\n  const char *filea; // [rsp+2D0h] [rbp-10h]\n\n  filea = file;\n  print_namea = print_name;\n  checksum = 0;\n  total_bytes = 0LL;\n  v2 = strcmp(file, \"-\");\n  is_stdin = v2 == 0;\n  if ( v2 )\n  {\n    fp = fopen(filea, \"r\");\n    if ( !fp )\n      goto LABEL_4;\n  }\n  else\n  {\n    fp = stdin;\n    have_read_stdin = 1;\n  }\n  while ( 1 )\n  {\n    ch_0 = getc_unlocked(fp);\n    if ( ch_0 == -1 )\n      break;\n    ++total_bytes;\n    checksum = (unsigned __int16)(((checksum & 1) << 15) + (checksum >> 1) + ch_0);\n  }\n  if ( ferror_unlocked(fp) )\n  {\n    v4 = __errno_location();\n    error(0, *v4, \"%s\", filea);\n    if ( !is_stdin )\n      fclose(fp);\n    return 0;\n  }\n  if ( !is_stdin && fclose(fp) )\n  {\nLABEL_4:\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    return 0;\n  }\n  v7 = checksum;\n  v5 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x400uLL);\n  printf(\"%05d %5s\", v7, v5);\n  if ( print_namea > 1 )\n    printf(\" %s\", filea);\n  putchar_unlocked(10);\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_sum_file (const char *file, int print_name)\n{\n  FILE *fp;\n  int checksum = 0;\t/* The checksum mod 2^16. */\n  uintmax_t total_bytes = 0;\t/* The number of bytes. */\n  int ch;\t\t/* Each character read. */\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fp = stdin;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fp = fopen (file, (O_BINARY ? \"rb\" : \"r\"));\n      if (fp == NULL)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while ((ch = getc (fp)) != EOF)\n    {\n      total_bytes++;\n      checksum = (checksum >> 1) + ((checksum & 1) << 15);\n      checksum += ch;\n      checksum &= 0xffff;\t/* Keep it within bounds. */\n    }\n\n  if (ferror (fp))\n    {\n      error (0, errno, \"%s\", file);\n      if (!is_stdin)\n\tfclose (fp);\n      return false;\n    }\n\n  if (!is_stdin && fclose (fp) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  printf (\"%05d %5s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 1024));\n  if (print_name > 1)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_stats()\n{\n  char *v0; // rax\n  unsigned __int64 v1; // rax\n  char *v2; // rax\n  unsigned __int64 v3; // rax\n  char *v4; // rax\n  char *v5; // rax\n  __m128i v6; // xmm1\n  char *v7; // rax\n  FILE *v8; // [rsp+8h] [rbp-318h]\n  char *format; // [rsp+18h] [rbp-308h]\n  uintmax_t v10; // [rsp+28h] [rbp-2F8h]\n  FILE *v11; // [rsp+30h] [rbp-2F0h]\n  FILE *v12; // [rsp+40h] [rbp-2E0h]\n  FILE *stream; // [rsp+50h] [rbp-2D0h]\n  uintmax_t delta_xtime; // [rsp+58h] [rbp-2C8h] BYREF\n  double XTIME_PRECISIONe0; // [rsp+60h] [rbp-2C0h]\n  const char *bytes_per_second; // [rsp+68h] [rbp-2B8h]\n  double delta_s; // [rsp+70h] [rbp-2B0h]\n  int human_opts; // [rsp+7Ch] [rbp-2A4h]\n  char hbuf[652]; // [rsp+80h] [rbp-2A0h] BYREF\n  xtime_t now; // [rsp+318h] [rbp-8h]\n\n  now = gethrxtime();\n  human_opts = 465;\n  stream = stderr;\n  v0 = gettext(\"%lu+%lu records in\\n%lu+%lu records out\\n\");\n  fprintf(stream, v0, r_full, r_partial, w_full, w_partial);\n  if ( r_truncate )\n  {\n    v12 = stderr;\n    v1 = select_plural(r_truncate);\n    v2 = ngettext(\"%lu truncated record\\n\", \"%lu truncated records\\n\", v1);\n    fprintf(v12, v2, r_truncate);\n  }\n  if ( (status_flags & 1) == 0 )\n  {\n    v11 = stderr;\n    v3 = select_plural(w_bytes);\n    v4 = ngettext(\"%lu byte (%s) copied\", \"%lu bytes (%s) copied\", v3);\n    v10 = w_bytes;\n    format = v4;\n    v5 = human_readable(w_bytes, hbuf, human_opts, 1uLL, 1uLL);\n    fprintf(v11, format, v10, v5);\n    if ( start_time >= now )\n    {\n      delta_s = 0.0;\n      bytes_per_second = gettext(\"Infinity B\");\n    }\n    else\n    {\n      XTIME_PRECISIONe0 = 1000000000.0;\n      delta_xtime = now - start_time;\n      v6 = (__m128i)_mm_sub_pd(\n                      (__m128d)_mm_unpacklo_epi32(\n                                 _mm_loadl_epi64((const __m128i *)&delta_xtime),\n                                 (__m128i)xmmword_408EF0),\n                      (__m128d)xmmword_408F00);\n      delta_s = (*(double *)_mm_shuffle_epi32(v6, 78).m128i_i64 + *(double *)v6.m128i_i64) / 1000000000.0;\n      bytes_per_second = human_readable(w_bytes, hbuf, human_opts, 0x3B9ACA00uLL, now - start_time);\n    }\n    v8 = stderr;\n    v7 = gettext(\", %g s, %s/s\\n\");\n    fprintf(v8, v7, bytes_per_second, delta_s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_stats (void)\n{\n  xtime_t now = gethrxtime ();\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int human_opts =\n    (human_autoscale | human_round_to_nearest\n     | human_space_before_unit | human_SI | human_B);\n  double delta_s;\n  char const *bytes_per_second;\n\n  fprintf (stderr,\n\t   _(\"%\"PRIuMAX\"+%\"PRIuMAX\" records in\\n\"\n\t     \"%\"PRIuMAX\"+%\"PRIuMAX\" records out\\n\"),\n\t   r_full, r_partial, w_full, w_partial);\n\n  if (r_truncate != 0)\n    fprintf (stderr,\n\t     ngettext (\"%\"PRIuMAX\" truncated record\\n\",\n\t\t       \"%\"PRIuMAX\" truncated records\\n\",\n\t\t       select_plural (r_truncate)),\n\t     r_truncate);\n\n  if (status_flags & STATUS_NOXFER)\n    return;\n\n  /* Use integer arithmetic to compute the transfer rate,\n     since that makes it easy to use SI abbreviations.  */\n\n  fprintf (stderr,\n\t   ngettext (\"%\"PRIuMAX\" byte (%s) copied\",\n\t\t     \"%\"PRIuMAX\" bytes (%s) copied\",\n\t\t     select_plural (w_bytes)),\n\t   w_bytes,\n\t   human_readable (w_bytes, hbuf, human_opts, 1, 1));\n\n  if (start_time < now)\n    {\n      double XTIME_PRECISIONe0 = XTIME_PRECISION;\n      uintmax_t delta_xtime = now;\n      delta_xtime -= start_time;\n      delta_s = delta_xtime / XTIME_PRECISIONe0;\n      bytes_per_second = human_readable (w_bytes, hbuf, human_opts,\n\t\t\t\t\t XTIME_PRECISION, delta_xtime);\n    }\n  else\n    {\n      delta_s = 0;\n      bytes_per_second = _(\"Infinity B\");\n    }\n\n  /* TRANSLATORS: The two instances of \"s\" in this string are the SI\n     symbol \"s\" (meaning second), and should not be translated.\n\n     This format used to be:\n\n     ngettext (\", %g second, %s/s\\n\", \", %g seconds, %s/s\\n\", delta_s == 1)\n\n     but that was incorrect for languages like Polish.  To fix this\n     bug we now use SI symbols even though they're a bit more\n     confusing in English.  */\n  fprintf (stderr, _(\", %g s, %s/s\\n\"), delta_s, bytes_per_second);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_45C05F(unsigned __int64 **a1)\n{\n  double v1; // xmm0_8\n  double v3; // [rsp+0h] [rbp-40h]\n  double v4; // [rsp+8h] [rbp-38h]\n  double v5; // [rsp+10h] [rbp-30h]\n  double v6; // [rsp+18h] [rbp-28h]\n  double v7; // [rsp+20h] [rbp-20h]\n  __int64 *v8; // [rsp+30h] [rbp-10h]\n  unsigned __int64 *v9; // [rsp+38h] [rbp-8h]\n\n  v9 = *a1;\n  v8 = (__int64 *)a1[1];\n  v7 = sub_45BFDC((*a1)[3], v8[3], (__int64)a1[2]);\n  v6 = sub_45BFDC(v9[7], v8[7], (__int64)a1[2]);\n  v5 = sub_45BFDC(v9[4], v8[4], (__int64)a1[2]);\n  v4 = sub_45BFDC(v9[5] + v9[6] + v9[2], v8[6] + v8[2] + v8[5], (__int64)a1[2]);\n  v3 = sub_45BFDC(v9[1], v8[1], (__int64)a1[2]);\n  v1 = sub_45BFDC(*v9, *v8, (__int64)a1[2]);\n  return printf(\"        %7.2f %7.2f %7.2f %7.2f %7.2f %7.2f\\n\", v1, v3, v4, v5, v6, v7);\n}\n",
        "output": "```c\nstatic int\nprint_statistics (double **data)\n{\n  double *current = *data;\n  double *previous = *(data + 1);\n  double *weights = *(data + 2);\n  double user_time = calculate_difference(current[3], previous[3], (__int64)weights);\n  double system_time = calculate_difference(current[7], previous[7], (__int64)weights);\n  double idle_time = calculate_difference(current[4], previous[4], (__int64)weights);\n  double iowait_time = calculate_difference(current[5] + current[6] + current[2],\n                                            previous[5] + previous[6] + previous[2],\n                                            (__int64)weights);\n  double irq_time = calculate_difference(current[1], previous[1], (__int64)weights);\n  double softirq_time = calculate_difference(*current, *previous, (__int64)weights);\n\n  return printf(\"        %7.2f %7.2f %7.2f %7.2f %7.2f %7.2f\\n\",\n                softirq_time, irq_time, iowait_time, idle_time, system_time, user_time);\n}\n```",
        "source_code": "static void print_stats_cpu_struct(stats_cpu_pair_t *stats)\n{\n\tcputime_t *p = stats->prev->vector;\n\tcputime_t *c = stats->curr->vector;\n\tprintf(\"        %7.2f %7.2f %7.2f %7.2f %7.2f %7.2f\\n\",\n\t\tpercent_value(p[STATS_CPU_USER]  , c[STATS_CPU_USER]  , stats->itv),\n\t\tpercent_value(p[STATS_CPU_NICE]  , c[STATS_CPU_NICE]  , stats->itv),\n\t\tpercent_value(p[STATS_CPU_SYSTEM] + p[STATS_CPU_SOFTIRQ] + p[STATS_CPU_IRQ],\n\t\t\tc[STATS_CPU_SYSTEM] + c[STATS_CPU_SOFTIRQ] + c[STATS_CPU_IRQ], stats->itv),\n\t\tpercent_value(p[STATS_CPU_IOWAIT], c[STATS_CPU_IOWAIT], stats->itv),\n\t\tpercent_value(p[STATS_CPU_STEAL] , c[STATS_CPU_STEAL] , stats->itv),\n\t\tpercent_value(p[STATS_CPU_IDLE]  , c[STATS_CPU_IDLE]  , stats->itv)\n\t);\n}",
        "parsed_output": "static int\nprint_statistics (double **data)\n{\n  double *current = *data;\n  double *previous = *(data + 1);\n  double *weights = *(data + 2);\n  double user_time = calculate_difference(current[3], previous[3], (__int64)weights);\n  double system_time = calculate_difference(current[7], previous[7], (__int64)weights);\n  double idle_time = calculate_difference(current[4], previous[4], (__int64)weights);\n  double iowait_time = calculate_difference(current[5] + current[6] + current[2],\n                                            previous[5] + previous[6] + previous[2],\n                                            (__int64)weights);\n  double irq_time = calculate_difference(current[1], previous[1], (__int64)weights);\n  double softirq_time = calculate_difference(*current, *previous, (__int64)weights);\n\n  return printf(\"        %7.2f %7.2f %7.2f %7.2f %7.2f %7.2f\\n\",\n                softirq_time, irq_time, iowait_time, idle_time, system_time, user_time);\n}",
        "baseline_code_stripped": "int __fastcall sub_45C05F(unsigned __int64 **a1)\n{\n  double v1; // xmm0_8\n  double v3; // [rsp+0h] [rbp-40h]\n  double v4; // [rsp+8h] [rbp-38h]\n  double v5; // [rsp+10h] [rbp-30h]\n  double v6; // [rsp+18h] [rbp-28h]\n  double v7; // [rsp+20h] [rbp-20h]\n  __int64 *v8; // [rsp+30h] [rbp-10h]\n  unsigned __int64 *v9; // [rsp+38h] [rbp-8h]\n\n  v9 = *a1;\n  v8 = (__int64 *)a1[1];\n  v7 = sub_45BFDC((*a1)[3], v8[3], (__int64)a1[2]);\n  v6 = sub_45BFDC(v9[7], v8[7], (__int64)a1[2]);\n  v5 = sub_45BFDC(v9[4], v8[4], (__int64)a1[2]);\n  v4 = sub_45BFDC(v9[5] + v9[6] + v9[2], v8[6] + v8[2] + v8[5], (__int64)a1[2]);\n  v3 = sub_45BFDC(v9[1], v8[1], (__int64)a1[2]);\n  v1 = sub_45BFDC(*v9, *v8, (__int64)a1[2]);\n  return printf(\"        %7.2f %7.2f %7.2f %7.2f %7.2f %7.2f\\n\", v1, v3, v4, v5, v6, v7);\n}\n",
        "baseline_code_debug": "void __cdecl print_stats_cpu_struct(stats_cpu_pair_t *stats)\n{\n  double v1; // xmm0_8\n  double v2; // [rsp+0h] [rbp-40h]\n  double v3; // [rsp+8h] [rbp-38h]\n  double v4; // [rsp+10h] [rbp-30h]\n  double v5; // [rsp+18h] [rbp-28h]\n  double v6; // [rsp+20h] [rbp-20h]\n  stats_cpu_t *c; // [rsp+30h] [rbp-10h]\n  stats_cpu_t *p; // [rsp+38h] [rbp-8h]\n\n  p = stats->prev;\n  c = stats->curr;\n  v6 = percent_value(stats->prev->vector[3], c->vector[3], stats->itv);\n  v5 = percent_value(p->vector[7], c->vector[7], stats->itv);\n  v4 = percent_value(p->vector[4], c->vector[4], stats->itv);\n  v3 = percent_value(p->vector[5] + p->vector[6] + p->vector[2], c->vector[6] + c->vector[2] + c->vector[5], stats->itv);\n  v2 = percent_value(p->vector[1], c->vector[1], stats->itv);\n  v1 = percent_value(p->vector[0], c->vector[0], stats->itv);\n  printf(\"        %7.2f %7.2f %7.2f %7.2f %7.2f %7.2f\\n\", v1, v2, v3, v4, v5, v6);\n}\n",
        "similarity_score_unixcoder": 0.725572943687439,
        "similarity_score_baseline_stripped": 0.4353327751159668,
        "similarity_score_baseline_debug": 0.7128154635429382
    },
    {
        "func_name": "find_list_entry2",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl remove_suffix(char *name, const char *suffix)\n{\n  char *v2; // rax\n  int v3; // edx\n  const char *v4; // rax\n  bool v5; // [rsp+Fh] [rbp-31h]\n  const char *sp_0; // [rsp+20h] [rbp-20h]\n  char *np; // [rsp+28h] [rbp-18h]\n\n  np = &name[strlen(name)];\n  sp_0 = &suffix[strlen(suffix)];\n  while ( 1 )\n  {\n    v5 = 0;\n    if ( np > name )\n      v5 = sp_0 > suffix;\n    if ( !v5 )\n      break;\n    v2 = np--;\n    v3 = *(v2 - 1);\n    v4 = sp_0--;\n    if ( v3 != *(v4 - 1) )\n      return;\n  }\n  if ( np > name )\n    *np = 0;\n}\n\n\n Revised code:\nstatic void\nremove_suffix (char *name, const char *suffix)\n{\n  char *np;\n  const char *sp;\n\n  np = name + strlen (name);\n  sp = suffix + strlen (suffix);\n\n  while (np > name && sp > suffix)\n    if (*--np != *--sp)\n      return;\n  if (np > name)\n    *np = '\\0';\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl get_format_width(char **format_ptr)\n{\n  char *v1; // rax\n  unsigned __int64 val; // [rsp+10h] [rbp-10h] BYREF\n  char **format_ptra; // [rsp+18h] [rbp-8h]\n\n  format_ptra = format_ptr;\n  val = 0LL;\n  if ( (unsigned int)(**format_ptr - 48) <= 9 && xstrtoul(*format_ptra, format_ptra, 10, &val, 0LL) )\n  {\n    v1 = gettext(\"invalid format width\");\n    error(1, 0, v1);\n  }\n  if ( val <= 0xB )\n    return 11LL;\n  else\n    return val;\n}\n\n\n Revised code:\nstatic size_t\nget_format_width (char **format_ptr)\n{\n  unsigned long int val = 0;\n\n  if (ISDIGIT (**format_ptr)\n      && (xstrtoul (*format_ptr, format_ptr, 10, &val, NULL) != LONGINT_OK\n\t  || SIZE_MAX < val))\n    error (EXIT_FAILURE, 0, _(\"invalid format width\"));\n\n  /* Allow for enough octal digits to represent the value of UINT_MAX,\n     even if the field width is less than that.  */\n  return MAX (val, (sizeof (unsigned int) * CHAR_BIT + 2) / 3);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 **__fastcall sub_4C0408(__int64 **a1, char *a2)\n{\n  char *v2; // rax\n  char *v3; // rdx\n  char *v4; // rax\n  char name[4095]; // [rsp+10h] [rbp-1020h] BYREF\n  char v8; // [rsp+100Fh] [rbp-21h] BYREF\n  char *v9; // [rsp+1018h] [rbp-18h]\n  char *v10; // [rsp+1020h] [rbp-10h]\n  int v11; // [rsp+102Ch] [rbp-4h]\n\n  while ( a1 )\n  {\n    v10 = (char *)a1[1];\n    v11 = 0;\n    while ( *v10 )\n    {\n      v2 = v10++;\n      if ( *v2 == 47 )\n        ++v11;\n    }\n    v10 = a2;\n    v9 = name;\n    while ( *v10 )\n    {\n      if ( v9 == &v8 )\n        break;\n      if ( *v10 == 47 && --v11 < 0 )\n        break;\n      v3 = v10++;\n      v4 = v9++;\n      *v4 = *v3;\n    }\n    *v9 = 0;\n    if ( !fnmatch((const char *)a1[1], name, 0) )\n      return a1;\n    a1 = (__int64 **)*a1;\n  }\n  return 0LL;\n}\n",
        "output": "```c\nstatic __int64 **sub_4C0408(__int64 **list, char *path)\n{\n  char name[4095];\n  char *current_char;\n  char *name_ptr;\n  int slash_count;\n\n  while (list)\n  {\n    current_char = (char *)list[1];\n    slash_count = 0;\n    while (*current_char)\n    {\n      if (*current_char++ == '/')\n        ++slash_count;\n    }\n\n    current_char = path;\n    name_ptr = name;\n    while (*current_char)\n    {\n      if (name_ptr == name + sizeof(name) - 1)\n        break;\n      if (*current_char == '/' && --slash_count < 0)\n        break;\n      *name_ptr++ = *current_char++;\n    }\n    *name_ptr = '\\0';\n\n    if (!fnmatch((const char *)list[1], name, 0))\n      return list;\n\n    list = (__int64 **)*list;\n  }\n  return NULL;\n}\n```",
        "source_code": "FAST_FUNC find_list_entry2(const llist_t *list, const char *filename)\n{\n\tchar buf[PATH_MAX];\n\tint pattern_slash_cnt;\n\tconst char *c;\n\tchar *d;\n\n\twhile (list) {\n\t\tc = list->data;\n\t\tpattern_slash_cnt = 0;\n\t\twhile (*c)\n\t\t\tif (*c++ == '/') pattern_slash_cnt++;\n\t\tc = filename;\n\t\td = buf;\n\t\t/* paranoia is better than buffer overflows */\n\t\twhile (*c && d != buf + sizeof(buf)-1) {\n\t\t\tif (*c == '/' && --pattern_slash_cnt < 0)\n\t\t\t\tbreak;\n\t\t\t*d++ = *c++;\n\t\t}\n\t\t*d = '\\0';\n\t\tif (fnmatch(list->data, buf, 0) == 0) {\n\t\t\treturn list;\n\t\t}\n\t\tlist = list->link;\n\t}\n\treturn NULL;\n}",
        "parsed_output": "static __int64 **sub_4C0408(__int64 **list, char *path)\n{\n  char name[4095];\n  char *current_char;\n  char *name_ptr;\n  int slash_count;\n\n  while (list)\n  {\n    current_char = (char *)list[1];\n    slash_count = 0;\n    while (*current_char)\n    {\n      if (*current_char++ == '/')\n        ++slash_count;\n    }\n\n    current_char = path;\n    name_ptr = name;\n    while (*current_char)\n    {\n      if (name_ptr == name + sizeof(name) - 1)\n        break;\n      if (*current_char == '/' && --slash_count < 0)\n        break;\n      *name_ptr++ = *current_char++;\n    }\n    *name_ptr = '\\0';\n\n    if (!fnmatch((const char *)list[1], name, 0))\n      return list;\n\n    list = (__int64 **)*list;\n  }\n  return NULL;\n}",
        "baseline_code_stripped": "__int64 **__fastcall sub_4C0408(__int64 **a1, char *a2)\n{\n  char *v2; // rax\n  char *v3; // rdx\n  char *v4; // rax\n  char name[4095]; // [rsp+10h] [rbp-1020h] BYREF\n  char v8; // [rsp+100Fh] [rbp-21h] BYREF\n  char *v9; // [rsp+1018h] [rbp-18h]\n  char *v10; // [rsp+1020h] [rbp-10h]\n  int v11; // [rsp+102Ch] [rbp-4h]\n\n  while ( a1 )\n  {\n    v10 = (char *)a1[1];\n    v11 = 0;\n    while ( *v10 )\n    {\n      v2 = v10++;\n      if ( *v2 == 47 )\n        ++v11;\n    }\n    v10 = a2;\n    v9 = name;\n    while ( *v10 )\n    {\n      if ( v9 == &v8 )\n        break;\n      if ( *v10 == 47 && --v11 < 0 )\n        break;\n      v3 = v10++;\n      v4 = v9++;\n      *v4 = *v3;\n    }\n    *v9 = 0;\n    if ( !fnmatch((const char *)a1[1], name, 0) )\n      return a1;\n    a1 = (__int64 **)*a1;\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "const llist_t_0 *__cdecl find_list_entry2(const llist_t_0 *list, const char *filename)\n{\n  const char *v2; // rax\n  const char *v3; // rdx\n  char *v4; // rax\n  char buf[4096]; // [rsp+10h] [rbp-1020h] BYREF\n  char *d; // [rsp+1018h] [rbp-18h]\n  const char *c; // [rsp+1020h] [rbp-10h]\n  int pattern_slash_cnt; // [rsp+102Ch] [rbp-4h]\n\n  while ( list )\n  {\n    c = list->data;\n    pattern_slash_cnt = 0;\n    while ( *c )\n    {\n      v2 = c++;\n      if ( *v2 == 47 )\n        ++pattern_slash_cnt;\n    }\n    c = filename;\n    d = buf;\n    while ( *c )\n    {\n      if ( d == &buf[4095] )\n        break;\n      if ( *c == 47 && --pattern_slash_cnt < 0 )\n        break;\n      v3 = c++;\n      v4 = d++;\n      *v4 = *v3;\n    }\n    *d = 0;\n    if ( !fnmatch(list->data, buf, 0) )\n      return list;\n    list = list->link;\n  }\n  return 0LL;\n}\n",
        "similarity_score_unixcoder": 0.8062831163406372,
        "similarity_score_baseline_stripped": 0.5454690456390381,
        "similarity_score_baseline_debug": 0.8565468192100525
    },
    {
        "func_name": "syntax_error_unexpected_ch",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\noperand_0 *__cdecl scan_arg(operand_0 *retstr, const char *arg)\n{\n  char *v2; // rax\n  const char *v3; // rsi\n  char v5; // [rsp+3h] [rbp-6Dh]\n  int v6; // [rsp+4h] [rbp-6Ch]\n  size_t fraction_len; // [rsp+30h] [rbp-40h]\n  char *decimal_point; // [rsp+38h] [rbp-38h]\n  operand_0 ret; // [rsp+40h] [rbp-30h] BYREF\n  const char *arga; // [rsp+68h] [rbp-8h]\n\n  arga = arg;\n  if ( !xstrtold(arg, 0LL, &ret.value, (long double (*)(const char *, char **))c_strtold) )\n  {\n    v2 = gettext(\"invalid floating point argument: %s\");\n    error(0, 0, v2, arga);\n    usage(1);\n  }\n  ret.width = strlen(arga);\n  ret.precision = 0x7FFFFFFF;\n  v3 = arga;\n  if ( !v3[strcspn(arga, \"eExX\")] && ret.value * 0.0 == 0.0 )\n  {\n    decimal_point = strchr(arga, 46);\n    if ( decimal_point )\n    {\n      fraction_len = strlen(decimal_point + 1);\n      if ( fraction_len <= 0x7FFFFFFF )\n        ret.precision = fraction_len;\n      if ( fraction_len )\n      {\n        v5 = 1;\n        if ( decimal_point != arga )\n          v5 = ~((unsigned int)(*(decimal_point - 1) - 48) <= 9);\n        v6 = v5 & 1;\n      }\n      else\n      {\n        v6 = -1;\n      }\n      ret.width += v6;\n    }\n    else\n    {\n      ret.precision = 0;\n    }\n  }\n  *retstr = ret;\n  return retstr;\n}\n\n\n Revised code:\nstatic operand\nscan_arg (const char *arg)\n{\n  operand ret;\n\n  if (! xstrtold (arg, NULL, &ret.value, c_strtold))\n    {\n      error (0, 0, _(\"invalid floating point argument: %s\"), arg);\n      usage (EXIT_FAILURE);\n    }\n\n  ret.width = strlen (arg);\n  ret.precision = INT_MAX;\n\n  if (! arg[strcspn (arg, \"eExX\")] && isfinite (ret.value))\n    {\n      char const *decimal_point = strchr (arg, '.');\n      if (! decimal_point)\n\tret.precision = 0;\n      else\n\t{\n\t  size_t fraction_len = strlen (decimal_point + 1);\n\t  if (fraction_len <= INT_MAX)\n\t    ret.precision = fraction_len;\n\t  ret.width += (fraction_len == 0\n\t\t\t? -1\n\t\t\t: (decimal_point == arg\n\t\t\t   || ! ISDIGIT (decimal_point[-1])));\n\t}\n    }\n\n  return ret;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_47FF3A(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  char *v6; // rax\n  char v7[2]; // [rsp+1Eh] [rbp-2h] BYREF\n\n  v7[0] = a1;\n  v7[1] = 0;\n  if ( a1 == -1 )\n    v6 = (char *)&off_51E5E9;\n  else\n    v6 = v7;\n  sub_409747(\"syntax error: unexpected %s\", (__int64)v6, a3, a4, a5, a6);\n}\n",
        "output": "```c\nstatic void\nsyntax_error_unexpected(int token, const char *message)\n{\n  const char *token_str;\n\n  if (token == -1)\n    token_str = \"end of file\";\n  else\n  {\n    char token_char[2] = {token, '\\0'};\n    token_str = token_char;\n  }\n\n  error(message, token_str);\n}\n```",
        "source_code": "static void syntax_error_unexpected_ch(unsigned lineno UNUSED_PARAM, int ch)\n{\n\tchar msg[2];\n\tmsg[0] = ch;\n\tmsg[1] = '\\0';\n\tbb_error_msg(\"syntax error: unexpected %s\", ch == EOF ? \"EOF\" : msg);\n}",
        "parsed_output": "static void\nsyntax_error_unexpected(int token, const char *message)\n{\n  const char *token_str;\n\n  if (token == -1)\n    token_str = \"end of file\";\n  else\n  {\n    char token_char[2] = {token, '\\0'};\n    token_str = token_char;\n  }\n\n  error(message, token_str);\n}",
        "baseline_code_stripped": "void __fastcall sub_47FF3A(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  char *v6; // rax\n  char v7[2]; // [rsp+1Eh] [rbp-2h] BYREF\n\n  v7[0] = a1;\n  v7[1] = 0;\n  if ( a1 == -1 )\n    v6 = (char *)&off_51E5E9;\n  else\n    v6 = v7;\n  sub_409747(\"syntax error: unexpected %s\", (__int64)v6, a3, a4, a5, a6);\n}\n",
        "baseline_code_debug": "void __cdecl syntax_error_unexpected_ch(int ch_0)\n{\n  char *v1; // rax\n  char msg[2]; // [rsp+1Eh] [rbp-2h] BYREF\n\n  msg[0] = ch_0;\n  msg[1] = 0;\n  if ( ch_0 == -1 )\n    v1 = (char *)&off_51E5E9;\n  else\n    v1 = msg;\n  bb_error_msg(\"syntax error: unexpected %s\", v1);\n}\n",
        "similarity_score_unixcoder": 0.7902796864509583,
        "similarity_score_baseline_stripped": 0.4428666830062866,
        "similarity_score_baseline_debug": 0.7315594553947449
    },
    {
        "func_name": "p_header",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nvoid __cdecl get_format_conv_type(char **format_ptr)\n{\n  char *v1; // rax\n  char *v2; // rax\n  char *v3; // rax\n  int v4; // [rsp+20h] [rbp-10h]\n  unsigned __int8 ch_0; // [rsp+27h] [rbp-9h]\n\n  v1 = (*format_ptr)++;\n  ch_0 = *v1;\n  v4 = (unsigned __int8)*v1;\n  if ( *v1 )\n  {\n    if ( v4 != 88 && v4 != 100 && v4 != 105 && v4 != 111 && v4 != 117 && v4 != 120 )\n    {\n      if ( ((*__ctype_b_loc())[ch_0] & 0x4000) != 0 )\n        v3 = gettext(\"invalid conversion specifier in suffix: %c\");\n      else\n        v3 = gettext(\"invalid conversion specifier in suffix: \\\\%.3o\");\n      error(1, 0, v3, ch_0);\n    }\n  }\n  else\n  {\n    v2 = gettext(\"missing conversion specifier in suffix\");\n    error(1, 0, v2);\n  }\n}\n\n\n Revised code:\nstatic void\nget_format_conv_type (char **format_ptr)\n{\n  unsigned char ch = *(*format_ptr)++;\n\n  switch (ch)\n    {\n    case 'd':\n    case 'i':\n    case 'o':\n    case 'u':\n    case 'x':\n    case 'X':\n      break;\n\n    case 0:\n      error (EXIT_FAILURE, 0, _(\"missing conversion specifier in suffix\"));\n      break;\n\n    default:\n      if (isprint (ch))\n        error (EXIT_FAILURE, 0,\n\t       _(\"invalid conversion specifier in suffix: %c\"), ch);\n      else\n\terror (EXIT_FAILURE, 0,\n\t       _(\"invalid conversion specifier in suffix: \\\\%.3o\"), ch);\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4B34DF(unsigned __int8 *a1)\n{\n  __int64 result; // rax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n\n  result = sub_4B325C(a1);\n  if ( (_DWORD)result )\n    sub_40969E(\"header_error %d\", (unsigned int)result, v2, v3, v4, v5);\n  return result;\n}\n",
        "output": "```c\nstatic __int64\nsub_4B34DF (unsigned __int8 *a1)\n{\n  __int64 result = sub_4B325C (a1);\n  if ((int)result != 0)\n    sub_40969E (\"header_error %d\", (unsigned int)result);\n  return result;\n}\n```",
        "source_code": "static void p_header(header_t *h)\n{\n\tint r;\n\n\tr = read_header(h);\n\tif (r == 0)\n\t\treturn;\n\tbb_error_msg_and_die(\"header_error %d\", r);\n}",
        "parsed_output": "static __int64\nsub_4B34DF (unsigned __int8 *a1)\n{\n  __int64 result = sub_4B325C (a1);\n  if ((int)result != 0)\n    sub_40969E (\"header_error %d\", (unsigned int)result);\n  return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4B34DF(unsigned __int8 *a1)\n{\n  __int64 result; // rax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n\n  result = sub_4B325C(a1);\n  if ( (_DWORD)result )\n    sub_40969E(\"header_error %d\", (unsigned int)result, v2, v3, v4, v5);\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl p_header(header_t_0 *h)\n{\n  unsigned int r; // [rsp+1Ch] [rbp-4h]\n\n  r = read_header(h);\n  if ( r )\n    bb_error_msg_and_die(\"header_error %d\", r);\n}\n",
        "similarity_score_unixcoder": 0.5635355710983276,
        "similarity_score_baseline_stripped": 0.5605089664459229,
        "similarity_score_baseline_debug": 0.8238546252250671
    },
    {
        "func_name": "get_signame",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl apply_suffix(double *x, char suffix_char)\n{\n  int multiplier; // [rsp+14h] [rbp-18h]\n\n  switch ( suffix_char )\n  {\n    case 0:\n      goto LABEL_6;\n    case 100:\n      multiplier = 86400;\n      goto LABEL_11;\n    case 104:\n      multiplier = 3600;\n      goto LABEL_11;\n    case 109:\n      multiplier = 60;\n      goto LABEL_11;\n    case 115:\nLABEL_6:\n      multiplier = 1;\nLABEL_11:\n      *x = (double)multiplier * *x;\n      return 1;\n  }\n  return 0;\n}\n\n\n Revised code:\nstatic bool\napply_suffix (double *x, char suffix_char)\n{\n  int multiplier;\n\n  switch (suffix_char)\n    {\n    case 0:\n    case 's':\n      multiplier = 1;\n      break;\n    case 'm':\n      multiplier = 60;\n      break;\n    case 'h':\n      multiplier = 60 * 60;\n      break;\n    case 'd':\n      multiplier = 60 * 60 * 24;\n      break;\n    default:\n      return false;\n    }\n\n  *x *= multiplier;\n\n  return true;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl attach(char *dest, const char *dirname, const char *name)\n{\n  char *v3; // rax\n  char v4; // dl\n  char *v5; // rax\n  char *v6; // rax\n  const char *v7; // rax\n  char v8; // dl\n  char *v9; // rax\n  const char *dirnamep; // [rsp+0h] [rbp-20h]\n\n  dirnamep = dirname;\n  if ( *dirname != 46 || dirname[1] )\n  {\n    while ( *dirnamep )\n    {\n      v3 = (char *)dirnamep++;\n      v4 = *v3;\n      v5 = dest++;\n      *v5 = v4;\n    }\n    if ( dirnamep > dirname && *(dirnamep - 1) != 47 )\n    {\n      v6 = dest++;\n      *v6 = 47;\n    }\n  }\n  while ( *name )\n  {\n    v7 = name++;\n    v8 = *v7;\n    v9 = dest++;\n    *v9 = v8;\n  }\n  *dest = 0;\n}\n\n\n Revised code:\nstatic void\nattach (char *dest, const char *dirname, const char *name)\n{\n  const char *dirnamep = dirname;\n\n  /* Copy dirname if it is not \".\".  */\n  if (dirname[0] != '.' || dirname[1] != 0)\n    {\n      while (*dirnamep)\n\t*dest++ = *dirnamep++;\n      /* Add '/' if `dirname' doesn't already end with it.  */\n      if (dirnamep > dirname && dirnamep[-1] != '/')\n\t*dest++ = '/';\n    }\n  while (*name)\n    *dest++ = *name++;\n  *dest = 0;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl writeline(const linebuffer *line, FILE *stream, int a3)\n{\n  switch ( a3 )\n  {\n    case 1:\n      if ( !only_file_1 )\n        return;\n      break;\n    case 2:\n      if ( !only_file_2 )\n        return;\n      if ( only_file_1 )\n        putc_unlocked(9, stream);\n      break;\n    case 3:\n      if ( !both )\n        return;\n      if ( only_file_1 )\n        putc_unlocked(9, stream);\n      if ( only_file_2 )\n        putc_unlocked(9, stream);\n      break;\n  }\n  fwrite_unlocked(line->buffer, 1uLL, line->length, stream);\n}\n\n\n Revised code:\nstatic void\nwriteline (const struct linebuffer *line, FILE *stream, int class)\n{\n  switch (class)\n    {\n    case 1:\n      if (!only_file_1)\n\treturn;\n      break;\n\n    case 2:\n      if (!only_file_2)\n\treturn;\n      /* Print a TAB if we are printing lines from file 1.  */\n      if (only_file_1)\n\tputc ('\\t', stream);\n      break;\n\n    case 3:\n      if (!both)\n\treturn;\n      /* Print a TAB if we are printing lines from file 1.  */\n      if (only_file_1)\n\tputc ('\\t', stream);\n      /* Print a TAB if we are printing lines from file 2.  */\n      if (only_file_2)\n\tputc ('\\t', stream);\n      break;\n    }\n\n  fwrite (line->buffer, sizeof (char), line->length, stream);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_508B55(int a1)\n{\n  if ( (unsigned int)a1 <= 0x20 && aExit_2[7 * a1] )\n    return (_BYTE *)(7LL * a1 + 5396000);\n  else\n    return sub_409B8C(a1);\n}\n",
        "output": "```c\nstatic unsigned char *\nsub_508B55 (int a1)\n{\n  if (a1 >= 0 && a1 <= 0x20 && aExit_2[a1 * 7])\n    return &aExit_2[a1 * 7];\n  else\n    return sub_409B8C (a1);\n}\n```",
        "source_code": "FAST_FUNC get_signame(int number)\n{\n\tif ((unsigned)number < ARRAY_SIZE(signals)) {\n\t\tif (signals[number][0]) /* if it's not an empty str */\n\t\t\treturn signals[number];\n\t}\n\n\treturn itoa(number);\n}",
        "parsed_output": "static unsigned char *\nsub_508B55 (int a1)\n{\n  if (a1 >= 0 && a1 <= 0x20 && aExit_2[a1 * 7])\n    return &aExit_2[a1 * 7];\n  else\n    return sub_409B8C (a1);\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_508B55(int a1)\n{\n  if ( (unsigned int)a1 <= 0x20 && aExit_2[7 * a1] )\n    return (_BYTE *)(7LL * a1 + 5396000);\n  else\n    return sub_409B8C(a1);\n}\n",
        "baseline_code_debug": "const char *__cdecl get_signame(int number)\n{\n  if ( (unsigned int)number <= 0x20 && signals[7 * number] )\n    return (const char *)(7LL * number + 5396000);\n  else\n    return itoa(number);\n}\n",
        "similarity_score_unixcoder": 0.46970421075820923,
        "similarity_score_baseline_stripped": 0.4864834249019623,
        "similarity_score_baseline_debug": 0.8184228539466858
    },
    {
        "func_name": "do_pidfile",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl wc_file(const char *file, fstatus *fstatus)\n{\n  int *v2; // rax\n  bool ok; // [rsp+3h] [rbp-1Dh]\n  int fd; // [rsp+4h] [rbp-1Ch]\n\n  if ( file && strcmp(file, (const char *)(unsigned int)\"-\") )\n  {\n    fd = open(file, 0);\n    if ( fd == -1 || (ok = wc(fd, file, fstatus), close(fd)) )\n    {\n      v2 = __errno_location();\n      error(0, *v2, \"%s\", file);\n      return 0;\n    }\n    else\n    {\n      return ok;\n    }\n  }\n  else\n  {\n    have_read_stdin = 1;\n    return wc(0, file, fstatus);\n  }\n}\n\n\n Revised code:\nstatic bool\nwc_file (char const *file, struct fstatus *fstatus)\n{\n  if (! file || STREQ (file, \"-\"))\n    {\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n      return wc (STDIN_FILENO, file, fstatus);\n    }\n  else\n    {\n      int fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n      else\n\t{\n\t  bool ok = wc (fd, file, fstatus);\n\t  if (close (fd) != 0)\n\t    {\n\t      error (0, errno, \"%s\", file);\n\t      return false;\n\t    }\n\t  return ok;\n\t}\n    }\n}\n\n## Example:\n\n Input code:\nbool __cdecl nl_file(const char *file)\n{\n  int *v1; // rax\n  FILE *stream; // [rsp+8h] [rbp-18h]\n\n  if ( !strcmp(file, (const char *)(unsigned int)\"-\") )\n  {\n    have_read_stdin = 1;\n    stream = stdin;\n    process_file(stdin);\n  }\n  else\n  {\n    stream = fopen(file, \"r\");\n    if ( !stream )\n      goto LABEL_10;\n    process_file(stream);\n  }\n  if ( !ferror_unlocked(stream) )\n  {\n    if ( !strcmp(file, (const char *)(unsigned int)\"-\") )\n    {\n      clearerr_unlocked(stream);\n      return 1;\n    }\n    if ( fclose(stream) != -1 )\n      return 1;\n  }\nLABEL_10:\n  v1 = __errno_location();\n  error(0, *v1, \"%s\", file);\n  return 0;\n}\n\n\n Revised code:\nstatic bool\nnl_file (char const *file)\n{\n  FILE *stream;\n\n  if (STREQ (file, \"-\"))\n    {\n      have_read_stdin = true;\n      stream = stdin;\n    }\n  else\n    {\n      stream = fopen (file, \"r\");\n      if (stream == NULL)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  process_file (stream);\n\n  if (ferror (stream))\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n  if (STREQ (file, \"-\"))\n    clearerr (stream);\t\t/* Also clear EOF. */\n  else if (fclose (stream) == EOF)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n  return true;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl cwrite(bool new_file_flag, const char *bp_0, size_t bytes)\n{\n  int *v3; // rax\n  const char *v4; // rax\n  int *v5; // rax\n  int *v6; // rax\n  const char *format; // [rsp+8h] [rbp-28h]\n  FILE *stream; // [rsp+10h] [rbp-20h]\n\n  if ( new_file_flag )\n  {\n    if ( output_desc >= 0 && close(output_desc) < 0 )\n    {\n      v3 = __errno_location();\n      error(1, *v3, \"%s\", outfile);\n    }\n    next_file_name();\n    if ( verbose )\n    {\n      stream = stderr;\n      format = gettext(\"creating file %s\\n\");\n      v4 = quote(outfile);\n      fprintf(stream, format, v4);\n    }\n    output_desc = open_safer(outfile, 577, 438LL);\n    if ( output_desc < 0 )\n    {\n      v5 = __errno_location();\n      error(1, *v5, \"%s\", outfile);\n    }\n  }\n  if ( full_write(output_desc, bp_0, bytes) != bytes )\n  {\n    v6 = __errno_location();\n    error(1, *v6, \"%s\", outfile);\n  }\n}\n\n\n Revised code:\nstatic void\ncwrite (bool new_file_flag, const char *bp, size_t bytes)\n{\n  if (new_file_flag)\n    {\n      if (output_desc >= 0 && close (output_desc) < 0)\n\terror (EXIT_FAILURE, errno, \"%s\", outfile);\n\n      next_file_name ();\n      if (verbose)\n\tfprintf (stderr, _(\"creating file %s\\n\"), quote (outfile));\n      output_desc = open (outfile,\n\t\t\t  O_WRONLY | O_CREAT | O_TRUNC | O_BINARY,\n\t\t\t  (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP\n\t\t\t   | S_IROTH | S_IWOTH));\n      if (output_desc < 0)\n\terror (EXIT_FAILURE, errno, \"%s\", outfile);\n    }\n  if (full_write (output_desc, bp, bytes) != bytes)\n    error (EXIT_FAILURE, errno, \"%s\", outfile);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint sub_4D9525()\n{\n  __int64 v0; // rdx\n  __int64 v1; // rcx\n  __int64 v2; // r8\n  __int64 v3; // r9\n  int result; // eax\n  unsigned int v5; // [rsp+4h] [rbp-Ch] BYREF\n  FILE *stream; // [rsp+8h] [rbp-8h]\n\n  stream = sub_40982E(*(const char **)&dest.c_cc[15]);\n  if ( stream )\n  {\n    if ( fscanf(stream, \"%u\", &v5) == 1 )\n      sub_4D9488(v5, (__int64)\"%u\");\n    return fclose(stream);\n  }\n  else\n  {\n    result = *(_DWORD *)qword_75D400;\n    if ( *(_DWORD *)qword_75D400 != 2 )\n      sub_4092A2((__int64)\"open pidfile %s\", *(_QWORD *)&dest.c_cc[15], v0, v1, v2, v3);\n  }\n  return result;\n}\n",
        "output": "```c\nstatic int\nread_pidfile ()\n{\n  unsigned int pid;\n  FILE *stream = open_pidfile ((char const *) &dest.c_cc[15]);\n  if (!stream)\n    {\n      if (errno != ENOENT)\n\topen_failure (errno, (char const *) &dest.c_cc[15]);\n      return 1;\n    }\n\n  if (fscanf (stream, \"%u\", &pid) == 1)\n    kill_pidfile (pid, sig_name (signum));\n  else\n    error (0, errno, _(\"cannot read pidfile %s\"), (char const *) &dest.c_cc[15]);\n\n  return fclose (stream);\n}\n```",
        "source_code": "static void do_pidfile(void)\n{\n\tFILE *f;\n\tunsigned pid;\n\n\tf = fopen_for_read(pidfile);\n\tif (f) {\n\t\tif (fscanf(f, \"%u\", &pid) == 1)\n\t\t\tcheck(pid);\n\t\tfclose(f);\n\t} else if (errno != ENOENT)\n\t\tbb_perror_msg_and_die(\"open pidfile %s\", pidfile);\n}",
        "parsed_output": "static int\nread_pidfile ()\n{\n  unsigned int pid;\n  FILE *stream = open_pidfile ((char const *) &dest.c_cc[15]);\n  if (!stream)\n    {\n      if (errno != ENOENT)\n\topen_failure (errno, (char const *) &dest.c_cc[15]);\n      return 1;\n    }\n\n  if (fscanf (stream, \"%u\", &pid) == 1)\n    kill_pidfile (pid, sig_name (signum));\n  else\n    error (0, errno, _(\"cannot read pidfile %s\"), (char const *) &dest.c_cc[15]);\n\n  return fclose (stream);\n}",
        "baseline_code_stripped": "int sub_4D9525()\n{\n  __int64 v0; // rdx\n  __int64 v1; // rcx\n  __int64 v2; // r8\n  __int64 v3; // r9\n  int result; // eax\n  unsigned int v5; // [rsp+4h] [rbp-Ch] BYREF\n  FILE *stream; // [rsp+8h] [rbp-8h]\n\n  stream = sub_40982E(*(const char **)&dest.c_cc[15]);\n  if ( stream )\n  {\n    if ( fscanf(stream, \"%u\", &v5) == 1 )\n      sub_4D9488(v5, (__int64)\"%u\");\n    return fclose(stream);\n  }\n  else\n  {\n    result = *(_DWORD *)qword_75D400;\n    if ( *(_DWORD *)qword_75D400 != 2 )\n      sub_4092A2((__int64)\"open pidfile %s\", *(_QWORD *)&dest.c_cc[15], v0, v1, v2, v3);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl do_pidfile()\n{\n  unsigned int pid; // [rsp+4h] [rbp-Ch] BYREF\n  FILE *f; // [rsp+8h] [rbp-8h]\n\n  f = fopen_for_read(*(const char **)&bb_common_bufsiz1.c_cc[15]);\n  if ( f )\n  {\n    if ( fscanf(f, \"%u\", &pid) == 1 )\n      check_3(pid);\n    fclose(f);\n  }\n  else if ( *bb_errno != 2 )\n  {\n    bb_perror_msg_and_die(\"open pidfile %s\", *(const char **)&bb_common_bufsiz1.c_cc[15]);\n  }\n}\n",
        "similarity_score_unixcoder": 0.7002982497215271,
        "similarity_score_baseline_stripped": 0.47941747307777405,
        "similarity_score_baseline_debug": 0.7618370056152344
    },
    {
        "func_name": "set_state",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl recover_mode(const char *arg, termios *mode)\n{\n  unsigned __int64 lflag; // [rsp+10h] [rbp-50h] BYREF\n  unsigned __int64 cflag; // [rsp+18h] [rbp-48h] BYREF\n  unsigned __int64 oflag; // [rsp+20h] [rbp-40h] BYREF\n  unsigned __int64 iflag; // [rsp+28h] [rbp-38h] BYREF\n  unsigned __int64 chr; // [rsp+30h] [rbp-30h] BYREF\n  int n; // [rsp+3Ch] [rbp-24h] BYREF\n  size_t i; // [rsp+40h] [rbp-20h]\n  termios *modea; // [rsp+48h] [rbp-18h]\n  const char *arga; // [rsp+50h] [rbp-10h]\n\n  arga = arg;\n  modea = mode;\n  if ( sscanf(arg, \"%lx:%lx:%lx:%lx%n\", &iflag, &oflag, &cflag, &lflag, &n) == 4 )\n  {\n    modea->c_iflag = iflag;\n    modea->c_oflag = oflag;\n    modea->c_cflag = cflag;\n    modea->c_lflag = lflag;\n    if ( modea->c_iflag == iflag && modea->c_oflag == oflag && modea->c_cflag == cflag && modea->c_lflag == lflag )\n    {\n      arga += n;\n      for ( i = 0LL; i < 0x20; ++i )\n      {\n        if ( sscanf(arga, \":%lx%n\", &chr, &n) != 1 )\n          return 0;\n        modea->c_cc[i] = chr;\n        if ( modea->c_cc[i] != chr )\n          return 0;\n        arga += n;\n      }\n      return *arga == 0;\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  else\n  {\n    return 0;\n  }\n}\n\n\n Revised code:\nstatic bool\nrecover_mode (char const *arg, struct termios *mode)\n{\n  size_t i;\n  int n;\n  unsigned long int chr;\n  unsigned long int iflag, oflag, cflag, lflag;\n\n  /* Scan into temporaries since it is too much trouble to figure out\n     the right format for `tcflag_t'.  */\n  if (sscanf (arg, \"%lx:%lx:%lx:%lx%n\",\n\t      &iflag, &oflag, &cflag, &lflag, &n) != 4)\n    return false;\n  mode->c_iflag = iflag;\n  mode->c_oflag = oflag;\n  mode->c_cflag = cflag;\n  mode->c_lflag = lflag;\n  if (mode->c_iflag != iflag\n      || mode->c_oflag != oflag\n      || mode->c_cflag != cflag\n      || mode->c_lflag != lflag)\n    return false;\n  arg += n;\n  for (i = 0; i < NCCS; ++i)\n    {\n      if (sscanf (arg, \":%lx%n\", &chr, &n) != 1)\n\treturn false;\n      mode->c_cc[i] = chr;\n      if (mode->c_cc[i] != chr)\n\treturn false;\n      arg += n;\n    }\n\n  /* Fail if there are too many fields.  */\n  if (*arg != '\\0')\n    return false;\n\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl tac_nonseekable(int input_fd, const char *file)\n{\n  int v2; // eax\n  bool v4; // [rsp+7h] [rbp-29h]\n  char *tmp_file; // [rsp+10h] [rbp-20h] BYREF\n  FILE *tmp_stream; // [rsp+18h] [rbp-18h] BYREF\n  const char *filea; // [rsp+20h] [rbp-10h]\n  int input_fda; // [rsp+2Ch] [rbp-4h]\n\n  input_fda = input_fd;\n  filea = file;\n  v4 = 0;\n  if ( copy_to_temp(&tmp_stream, &tmp_file, input_fd, file) )\n  {\n    v2 = fileno(tmp_stream);\n    return tac_seekable(v2, tmp_file);\n  }\n  return v4;\n}\n\n\n Revised code:\nstatic bool\ntac_nonseekable (int input_fd, const char *file)\n{\n  FILE *tmp_stream;\n  char *tmp_file;\n  return (copy_to_temp (&tmp_stream, &tmp_file, input_fd, file)\n\t  && tac_seekable (fileno (tmp_stream), tmp_file));\n}\n\n## Example:\n\n Input code:\nvoid __cdecl set_fd_flags(int fd, int add_flags, const char *name)\n{\n  const char *v3; // rax\n  const char *format; // [rsp+0h] [rbp-C0h]\n  int errnum; // [rsp+Ch] [rbp-B4h]\n  stat st; // [rsp+10h] [rbp-B0h] BYREF\n  bool ok; // [rsp+A7h] [rbp-19h]\n  int new_flags; // [rsp+A8h] [rbp-18h]\n  int old_flags; // [rsp+ACh] [rbp-14h]\n  const char *namea; // [rsp+B0h] [rbp-10h]\n  int add_flagsa; // [rsp+B8h] [rbp-8h]\n  int fda; // [rsp+BCh] [rbp-4h]\n\n  fda = fd;\n  namea = name;\n  add_flagsa = add_flags & 0xFFFDFEFF;\n  if ( (add_flags & 0xFFFDFEFF) != 0 )\n  {\n    old_flags = fcntl(fda, 3);\n    new_flags = add_flagsa | old_flags;\n    ok = 1;\n    if ( old_flags >= 0 )\n    {\n      if ( old_flags != new_flags )\n      {\n        if ( (new_flags & 0x10000) != 0 )\n        {\n          if ( (unsigned int)fstat(fda, &st) )\n          {\n            ok = 0;\n          }\n          else if ( (new_flags & 0x10000) != 0 && (st.st_mode & 0xF000) != 0x4000 )\n          {\n            *__errno_location() = 20;\n            ok = 0;\n          }\n          new_flags &= ~0x10000u;\n        }\n        if ( ok && old_flags != new_flags && fcntl(fda, 4, (unsigned int)new_flags) == -1 )\n          ok = 0;\n      }\n    }\n    else\n    {\n      ok = 0;\n    }\n    if ( !ok )\n    {\n      errnum = *__errno_location();\n      format = gettext(\"setting flags for %s\");\n      v3 = quote(namea);\n      error(1, errnum, format, v3);\n    }\n  }\n}\n\n\n Revised code:\nstatic void\nset_fd_flags (int fd, int add_flags, char const *name)\n{\n  /* Ignore file creation flags that are no-ops on file descriptors.  */\n  add_flags &= ~ (O_NOCTTY | O_NOFOLLOW);\n\n  if (add_flags)\n    {\n      int old_flags = fcntl (fd, F_GETFL);\n      int new_flags = old_flags | add_flags;\n      bool ok = true;\n      if (old_flags < 0)\n\tok = false;\n      else if (old_flags != new_flags)\n\t{\n\t  if (new_flags & (O_DIRECTORY | O_NOLINKS))\n\t    {\n\t      /* NEW_FLAGS contains at least one file creation flag that\n\t\t requires some checking of the open file descriptor.  */\n\t      struct stat st;\n\t      if (fstat (fd, &st) != 0)\n\t\tok = false;\n\t      else if ((new_flags & O_DIRECTORY) && ! S_ISDIR (st.st_mode))\n\t\t{\n\t\t  errno = ENOTDIR;\n\t\t  ok = false;\n\t\t}\n\t      else if ((new_flags & O_NOLINKS) && 1 < st.st_nlink)\n\t\t{\n\t\t  errno = EMLINK;\n\t\t  ok = false;\n\t\t}\n\t      new_flags &= ~ (O_DIRECTORY | O_NOLINKS);\n\t    }\n\n\t  if (ok && old_flags != new_flags\n\t      && fcntl (fd, F_SETFL, new_flags) == -1)\n\t    ok = false;\n\t}\n\n      if (!ok)\n\terror (EXIT_FAILURE, errno, _(\"setting flags for %s\"), quote (name));\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_44084C(const struct termios *a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+4h] [rbp-1Ch] BYREF\n  const struct termios *v4; // [rsp+8h] [rbp-18h]\n  int v5; // [rsp+1Ch] [rbp-4h] BYREF\n\n  v4 = a1;\n  v3 = a2;\n  if ( (unsigned int)sub_440726(a1)\n    || (v5 = 1, (int)sub_40AD08(dest.c_iflag, 0x5423u, (__int64)&v5, (__int64)\"TIOCSETD\") < 0)\n    || (result = sub_40AD08(dest.c_iflag, 0x8926u, (__int64)&v3, (__int64)\"SIOCSIFENCAP\"), (int)result < 0) )\n  {\n    sub_44076F(1);\n  }\n  return result;\n}\n",
        "output": "```c\nstatic int\nset_discipline_and_encap (struct termios const *tp, int encap)\n{\n  int discipline = encap;\n  int one = 1;\n\n  if (ioctl (STDIN_FILENO, TIOCSETD, &one) < 0\n      || ioctl (STDIN_FILENO, SIOCSIFENCAP, &discipline) < 0)\n    {\n      error (EXIT_FAILURE, errno, _(\"cannot set line discipline or encapsulation\"));\n    }\n\n  return 0;\n}\n```",
        "source_code": "static void set_state(struct termios *state, int encap)\n{\n\tint disc;\n\n\t/* Set line status */\n\tif (set_termios_state_or_warn(state))\n\t\tgoto bad;\n\t/* Set line discliple (N_SLIP always) */\n\tdisc = N_SLIP;\n\tif (ioctl_or_warn(handle, TIOCSETD, &disc) < 0) {\n\t\tgoto bad;\n\t}\n\n\t/* Set encapsulation (SLIP, CSLIP, etc) */\n\tif (ioctl_or_warn(handle, SIOCSIFENCAP, &encap) < 0) {\n bad:\n\t\trestore_state_and_exit(EXIT_FAILURE);\n\t}\n}",
        "parsed_output": "static int\nset_discipline_and_encap (struct termios const *tp, int encap)\n{\n  int discipline = encap;\n  int one = 1;\n\n  if (ioctl (STDIN_FILENO, TIOCSETD, &one) < 0\n      || ioctl (STDIN_FILENO, SIOCSIFENCAP, &discipline) < 0)\n    {\n      error (EXIT_FAILURE, errno, _(\"cannot set line discipline or encapsulation\"));\n    }\n\n  return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_44084C(const struct termios *a1, int a2)\n{\n  __int64 result; // rax\n  int v3; // [rsp+4h] [rbp-1Ch] BYREF\n  const struct termios *v4; // [rsp+8h] [rbp-18h]\n  int v5; // [rsp+1Ch] [rbp-4h] BYREF\n\n  v4 = a1;\n  v3 = a2;\n  if ( (unsigned int)sub_440726(a1)\n    || (v5 = 1, (int)sub_40AD08(dest.c_iflag, 0x5423u, (__int64)&v5, (__int64)\"TIOCSETD\") < 0)\n    || (result = sub_40AD08(dest.c_iflag, 0x8926u, (__int64)&v3, (__int64)\"SIOCSIFENCAP\"), (int)result < 0) )\n  {\n    sub_44076F(1);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl set_state(termios *state, int encap)\n{\n  int encapa; // [rsp+4h] [rbp-1Ch] BYREF\n  termios *statea; // [rsp+8h] [rbp-18h]\n  int disc; // [rsp+1Ch] [rbp-4h] BYREF\n\n  statea = state;\n  encapa = encap;\n  if ( set_termios_state_or_warn(state)\n    || (disc = 1, bb_ioctl_or_warn(bb_common_bufsiz1.c_iflag, 0x5423u, &disc, \"TIOCSETD\") < 0)\n    || bb_ioctl_or_warn(bb_common_bufsiz1.c_iflag, 0x8926u, &encapa, \"SIOCSIFENCAP\") < 0 )\n  {\n    restore_state_and_exit(1);\n  }\n}\n",
        "similarity_score_unixcoder": 0.8062292337417603,
        "similarity_score_baseline_stripped": 0.5121652483940125,
        "similarity_score_baseline_debug": 0.7445535659790039
    },
    {
        "func_name": "open_or_warn_stdin",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nbool __cdecl looks_like_integer(const char *cp)\n{\n  const char *v1; // rax\n  const char *cpa; // [rsp+0h] [rbp-10h]\n\n  cpa = &cp[*cp == 45];\n  do\n  {\n    if ( (unsigned int)(*cpa - 48) > 9 )\n      return 0;\n    v1 = cpa++;\n  }\n  while ( v1[1] );\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nlooks_like_integer (char const *cp)\n{\n  cp += (*cp == '-');\n\n  do\n    if (! ISDIGIT (*cp))\n      return false;\n  while (*++cp);\n\n  return true;\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl adjust_column(size_t column, char c)\n{\n  size_t columna; // [rsp+2h] [rbp-8h]\n\n  columna = column;\n  if ( count_bytes )\n    return column + 1;\n  switch ( c )\n  {\n    case 8:\n      if ( column )\n        return column - 1;\n      break;\n    case 13:\n      return 0LL;\n    case 9:\n      return column + 8 - (column & 7);\n    default:\n      return column + 1;\n  }\n  return columna;\n}\n\n\n Revised code:\nstatic size_t\nadjust_column (size_t column, char c)\n{\n  if (!count_bytes)\n    {\n      if (c == '\\b')\n\t{\n\t  if (column > 0)\n\t    column--;\n\t}\n      else if (c == '\\r')\n\tcolumn = 0;\n      else if (c == '\\t')\n\tcolumn += TAB_WIDTH - column % TAB_WIDTH;\n      else /* if (isprint (c)) */\n\tcolumn++;\n    }\n  else\n    column++;\n  return column;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_50A825(__int64 a1)\n{\n  unsigned int v2; // [rsp+1Ch] [rbp-4h]\n\n  v2 = 0;\n  if ( (char *)a1 != \"standard input\" && (*(_BYTE *)a1 != 45 || *(_BYTE *)(a1 + 1)) )\n    return (unsigned int)sub_40A32A((const char *)a1, 0);\n  return v2;\n}\n",
        "output": "```c\nstatic unsigned int\nsub_50A825 (const char *input)\n{\n  if (strcmp(input, \"standard input\") != 0 && (input[0] != '-' || input[1] != '\\0'))\n    return sub_40A32A(input, 0);\n  return 0;\n}\n```",
        "source_code": "int FAST_FUNC open_or_warn_stdin(const char *filename)\n{\n\tint fd = STDIN_FILENO;\n\n\tif (filename != bb_msg_standard_input\n\t && NOT_LONE_DASH(filename)\n\t) {\n\t\tfd = open_or_warn(filename, O_RDONLY);\n\t}\n\n\treturn fd;\n}",
        "parsed_output": "static unsigned int\nsub_50A825 (const char *input)\n{\n  if (strcmp(input, \"standard input\") != 0 && (input[0] != '-' || input[1] != '\\0'))\n    return sub_40A32A(input, 0);\n  return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_50A825(__int64 a1)\n{\n  unsigned int v2; // [rsp+1Ch] [rbp-4h]\n\n  v2 = 0;\n  if ( (char *)a1 != \"standard input\" && (*(_BYTE *)a1 != 45 || *(_BYTE *)(a1 + 1)) )\n    return (unsigned int)sub_40A32A((const char *)a1, 0);\n  return v2;\n}\n",
        "baseline_code_debug": "int __cdecl open_or_warn_stdin(const char *filename)\n{\n  int fd; // [rsp+1Ch] [rbp-4h]\n\n  fd = 0;\n  if ( filename != \"standard input\" && (*filename != 45 || filename[1]) )\n    return open_or_warn(filename, 0);\n  return fd;\n}\n",
        "similarity_score_unixcoder": 0.502036988735199,
        "similarity_score_baseline_stripped": 0.4332447350025177,
        "similarity_score_baseline_debug": 0.7606860399246216
    },
    {
        "func_name": "pwdcmd",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_occurs(const void *void_first, const void *void_second)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h]\n  int value; // [rsp+1Ch] [rbp-14h]\n\n  value = compare_words(void_first, void_second);\n  if ( value )\n    LODWORD(v3) = value;\n  else\n    return *(_QWORD *)void_first - *(_QWORD *)void_second;\n  return v3;\n}\n\n\n Revised code:\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return value == 0 ? first->key.start - second->key.start : value;\n#undef first\n#undef second\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_470439(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  char *v11; // [rsp+18h] [rbp-8h]\n\n  v11 = *(char **)(qword_75D418 + 16);\n  if ( (unsigned int)sub_46FDFE(a1, a2, a3, a4, a5, a6) )\n  {\n    v6 = qword_75D418 + 56;\n    if ( *(_QWORD *)(qword_75D418 + 24) == qword_75D418 + 56 )\n      sub_470099(v11, 0LL);\n    v11 = *(char **)(qword_75D418 + 24);\n  }\n  sub_46E137(\"%s\\n\", (__int64)v11, v6, v7, v8, v9, a2);\n  return 0LL;\n}\n",
        "output": "```c\nstatic void\nlog_message_if_condition_met(__int64 param1, __int64 param2, __int64 param3, __int64 param4, __int64 param5, __int64 param6)\n{\n  char *message;\n\n  message = *(char **)(global_var_75D418 + 16);\n  if (check_condition(param1, param2, param3, param4, param5, param6))\n  {\n    if (*(_QWORD *)(global_var_75D418 + 24) == global_var_75D418 + 56)\n      handle_edge_case(message, 0LL);\n    message = *(char **)(global_var_75D418 + 24);\n  }\n  print_formatted_message(\"%s\\n\", message);\n}\n```",
        "source_code": "static int FAST_FUNC\npwdcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tint flags;\n\tconst char *dir = curdir;\n\n\tflags = cdopt();\n\tif (flags) {\n\t\tif (physdir == nullstr)\n\t\t\tsetpwd(dir, 0);\n\t\tdir = physdir;\n\t}\n\tout1fmt(\"%s\\n\", dir);\n\treturn 0;\n}",
        "parsed_output": "static void\nlog_message_if_condition_met(__int64 param1, __int64 param2, __int64 param3, __int64 param4, __int64 param5, __int64 param6)\n{\n  char *message;\n\n  message = *(char **)(global_var_75D418 + 16);\n  if (check_condition(param1, param2, param3, param4, param5, param6))\n  {\n    if (*(_QWORD *)(global_var_75D418 + 24) == global_var_75D418 + 56)\n      handle_edge_case(message, 0LL);\n    message = *(char **)(global_var_75D418 + 24);\n  }\n  print_formatted_message(\"%s\\n\", message);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_470439(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  char *v11; // [rsp+18h] [rbp-8h]\n\n  v11 = *(char **)(qword_75D418 + 16);\n  if ( (unsigned int)sub_46FDFE(a1, a2, a3, a4, a5, a6) )\n  {\n    v6 = qword_75D418 + 56;\n    if ( *(_QWORD *)(qword_75D418 + 24) == qword_75D418 + 56 )\n      sub_470099(v11, 0LL);\n    v11 = *(char **)(qword_75D418 + 24);\n  }\n  sub_46E137(\"%s\\n\", (__int64)v11, v6, v7, v8, v9, a2);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl pwdcmd(int argc, char **argv)\n{\n  char *dir; // [rsp+18h] [rbp-8h]\n\n  dir = ash_ptr_to_globals_misc->curdir;\n  if ( cdopt() )\n  {\n    if ( ash_ptr_to_globals_misc->physdir == ash_ptr_to_globals_misc->nullstr )\n      setpwd(dir, 0);\n    dir = ash_ptr_to_globals_misc->physdir;\n  }\n  out1fmt(\"%s\\n\", dir);\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.436625212430954,
        "similarity_score_baseline_stripped": 0.3761879503726959,
        "similarity_score_baseline_debug": 0.8010432720184326
    },
    {
        "func_name": "change_user",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl __noreturn run_shell(\n        const char *shell,\n        const char *command,\n        char **additional_args,\n        size_t n_additional_args)\n{\n  size_t v4; // rax\n  size_t v5; // rdx\n  int *v6; // rax\n  int v7; // r8d\n  int *v8; // rax\n  int exit_status; // [rsp+14h] [rbp-4Ch]\n  const char *shell_basename; // [rsp+18h] [rbp-48h]\n  char *arg0; // [rsp+20h] [rbp-40h]\n  size_t argno; // [rsp+28h] [rbp-38h]\n  const char **args; // [rsp+30h] [rbp-30h]\n\n  args = (const char **)xnmalloc(n_additional_args + 2 * (command != 0LL) + fast_startup + 1 + 1, 8uLL);\n  argno = 1LL;\n  if ( simulate_login )\n  {\n    shell_basename = last_component(shell);\n    v4 = strlen(shell_basename);\n    arg0 = (char *)xmalloc(v4 + 2);\n    *arg0 = 45;\n    strcpy(arg0 + 1, shell_basename);\n    *args = arg0;\n  }\n  else\n  {\n    *args = last_component(shell);\n  }\n  if ( fast_startup )\n  {\n    argno = 2LL;\n    args[1] = \"-f\";\n  }\n  if ( command )\n  {\n    args[argno] = \"-c\";\n    v5 = argno + 1;\n    argno += 2LL;\n    args[v5] = command;\n  }\n  memcpy(&args[argno], additional_args, 8 * n_additional_args);\n  (&args[n_additional_args])[argno] = 0LL;\n  execv(shell, (char *const *)args);\n  v6 = __errno_location();\n  v7 = 126;\n  if ( *v6 == 2 )\n    v7 = 127;\n  exit_status = v7;\n  v8 = __errno_location();\n  error(0, *v8, \"%s\", shell);\n  exit(exit_status);\n}\n\n\n Revised code:\nstatic void\nrun_shell (char const *shell, char const *command, char **additional_args,\n\t   size_t n_additional_args)\n{\n  size_t n_args = 1 + fast_startup + 2 * !!command + n_additional_args + 1;\n  char const **args = xnmalloc (n_args, sizeof *args);\n  size_t argno = 1;\n\n  if (simulate_login)\n    {\n      char *arg0;\n      char *shell_basename;\n\n      shell_basename = last_component (shell);\n      arg0 = xmalloc (strlen (shell_basename) + 2);\n      arg0[0] = '-';\n      strcpy (arg0 + 1, shell_basename);\n      args[0] = arg0;\n    }\n  else\n    args[0] = last_component (shell);\n  if (fast_startup)\n    args[argno++] = \"-f\";\n  if (command)\n    {\n      args[argno++] = \"-c\";\n      args[argno++] = command;\n    }\n  memcpy (args + argno, additional_args, n_additional_args * sizeof *args);\n  args[argno + n_additional_args] = NULL;\n  execv (shell, (char **) args);\n\n  {\n    int exit_status = (errno == ENOENT ? EXIT_ENOENT : EXIT_CANNOT_INVOKE);\n    error (0, errno, \"%s\", shell);\n    exit (exit_status);\n  }\n}\n\n## Example:\n\n Input code:\nRM_status __cdecl rm_1(Dirstack_state *ds_0, const char *filename, const rm_options *x, int *cwd_errno)\n{\n  const char *v4; // rax\n  const char *v5; // rax\n  int *v6; // rax\n  const char *v7; // rax\n  const char *v8; // rax\n  const char *v10; // [rsp+8h] [rbp-108h]\n  const char *v11; // [rsp+10h] [rbp-100h]\n  int v12; // [rsp+1Ch] [rbp-F4h]\n  rm_options *v13; // [rsp+20h] [rbp-F0h]\n  const char *v14; // [rsp+38h] [rbp-D8h]\n  const char *format; // [rsp+40h] [rbp-D0h]\n  RM_status status; // [rsp+4Ch] [rbp-C4h]\n  stat st; // [rsp+50h] [rbp-C0h] BYREF\n  const char *base; // [rsp+E0h] [rbp-30h]\n  int *cwd_errnoa; // [rsp+E8h] [rbp-28h]\n  const rm_options *xa; // [rsp+F0h] [rbp-20h]\n  const char *filenamea; // [rsp+F8h] [rbp-18h]\n  Dirstack_state *ds_0a; // [rsp+100h] [rbp-10h]\n\n  ds_0a = ds_0;\n  filenamea = filename;\n  xa = x;\n  cwd_errnoa = cwd_errno;\n  base = last_component(filename);\n  if ( dot_or_dotdot_0(base) )\n  {\n    v4 = \"cannot remove %s directory %s\";\n    if ( base == filenamea )\n      v4 = \"cannot remove directory %s\";\n    format = gettext(v4);\n    v14 = quote_n(0, base);\n    v5 = quote_n(1, filenamea);\n    error(0, 0, format, v14, v5);\n    return 4;\n  }\n  else\n  {\n    cache_stat_init(&st);\n    cycle_check_init(&ds_0a->cycle_check_state);\n    if ( xa->root_dev_ino )\n    {\n      if ( cache_fstatat(-100, filenamea, &st, 256) )\n      {\n        v13 = (rm_options *)xa;\n        v6 = __errno_location();\n        if ( ignorable_missing(v13, *v6) )\n          return 2;\n        v12 = *__errno_location();\n        v11 = gettext(\"cannot remove %s\");\n        v7 = quote(filenamea);\n        error(0, v12, v11, v7);\n        return 4;\n      }\n      if ( st.st_ino == xa->root_dev_ino->st_ino && st.st_dev == xa->root_dev_ino->st_dev )\n      {\n        v10 = gettext(\"cannot remove root directory %s\");\n        v8 = quote(filenamea);\n        error(0, 0, v10, v8);\n        return 4;\n      }\n    }\n    AD_push_initial(ds_0a);\n    AD_stack_top(ds_0a)->status = RM_OK;\n    status = remove_entry(-100, ds_0a, filenamea, &st, xa, 0LL);\n    if ( status == RM_NONEMPTY_DIR )\n    {\n      if ( _setjmp(ds_0a->current_arg_jumpbuf) )\n        status = RM_ERROR;\n      else\n        status = remove_dir(-100, ds_0a, filenamea, &st, xa, cwd_errnoa);\n      AD_stack_clear(ds_0a);\n    }\n    ds_clear(ds_0a);\n    return status;\n  }\n}\n\n\n Revised code:\nstatic enum RM_status\nrm_1 (Dirstack_state *ds, char const *filename,\n      struct rm_options const *x, int *cwd_errno)\n{\n  char const *base = last_component (filename);\n  if (dot_or_dotdot (base))\n    {\n      error (0, 0, _(base == filename\n\t\t     ? \"cannot remove directory %s\"\n\t\t     : \"cannot remove %s directory %s\"),\n\t     quote_n (0, base), quote_n (1, filename));\n      return RM_ERROR;\n    }\n\n  struct stat st;\n  cache_stat_init (&st);\n  if (x->root_dev_ino)\n    {\n      if (cache_fstatat (AT_FDCWD, filename, &st, AT_SYMLINK_NOFOLLOW) != 0)\n\t{\n\t  if (ignorable_missing (x, errno))\n\t    return RM_OK;\n\t  error (0, errno, _(\"cannot remove %s\"), quote (filename));\n\t  return RM_ERROR;\n\t}\n      if (SAME_INODE (st, *(x->root_dev_ino)))\n\t{\n\t  error (0, 0, _(\"cannot remove root directory %s\"), quote (filename));\n\t  return RM_ERROR;\n\t}\n    }\n\n  AD_push_initial (ds);\n  AD_INIT_OTHER_MEMBERS ();\n\n  int fd_cwd = AT_FDCWD;\n  enum RM_status status = remove_entry (fd_cwd, ds, filename, &st, x, NULL);\n  if (status == RM_NONEMPTY_DIR)\n    {\n      /* In the event that remove_dir->remove_cwd_entries detects\n\t a directory cycle, arrange to fail, give up on this FILE, but\n\t continue on with any other arguments.  */\n      if (setjmp (ds->current_arg_jumpbuf))\n\tstatus = RM_ERROR;\n      else\n\tstatus = remove_dir (fd_cwd, ds, filename, &st, x, cwd_errno);\n\n      AD_stack_clear (ds);\n    }\n\n  ds_clear (ds);\n\n  return status;\n}\n\n## Example:\n\n Input code:\nbool __cdecl sysv_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  int *v5; // rax\n  char *v6; // rax\n  size_t bytes_read; // [rsp+20h] [rbp-22E0h]\n  size_t i; // [rsp+28h] [rbp-22D8h]\n  _BYTE is_stdin[5]; // [rsp+33h] [rbp-22CDh]\n  char hbuf[652]; // [rsp+40h] [rbp-22C0h] BYREF\n  uintmax_t total_bytes; // [rsp+2D8h] [rbp-2028h]\n  unsigned __int8 buf[8192]; // [rsp+2E0h] [rbp-2020h] BYREF\n  int fd; // [rsp+22E8h] [rbp-18h]\n  int print_namea; // [rsp+22ECh] [rbp-14h]\n  const char *filea; // [rsp+22F0h] [rbp-10h]\n  char v17; // [rsp+22FFh] [rbp-1h]\n\n  filea = file;\n  print_namea = print_name;\n  total_bytes = 0LL;\n  is_stdin[4] = 0;\n  v2 = strcmp(file, \"-\");\n  *(_DWORD *)is_stdin = v2 == 0;\n  if ( !v2 )\n  {\n    fd = 0;\n    have_read_stdin = 1;\n    goto LABEL_5;\n  }\n  fd = open(filea, 0);\n  if ( fd == -1 )\n  {\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    v17 = 0;\n  }\n  else\n  {\nLABEL_5:\n    while ( 1 )\n    {\n      bytes_read = safe_read(fd, buf, 0x2000uLL);\n      if ( !bytes_read )\n        break;\n      if ( bytes_read == -1LL )\n      {\n        v4 = __errno_location();\n        error(0, *v4, \"%s\", filea);\n        if ( (is_stdin[0] & 1) == 0 )\n          close(fd);\n        v17 = 0;\n        return v17 & 1;\n      }\n      for ( i = 0LL; i < bytes_read; ++i )\n        *(_DWORD *)&is_stdin[1] += buf[i];\n      total_bytes += bytes_read;\n    }\n    if ( (is_stdin[0] & 1) != 0 || !close(fd) )\n    {\n      v6 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x200uLL);\n      printf(\n        \"%d %s\",\n        ((HIWORD(*(_DWORD *)&is_stdin[1]) + *(unsigned __int16 *)&is_stdin[1]) >> 16)\n      + (unsigned int)(unsigned __int16)(*(_WORD *)&is_stdin[3] + *(_WORD *)&is_stdin[1]),\n        v6);\n      if ( print_namea )\n        printf(\" %s\", filea);\n      putchar_unlocked(10);\n      v17 = 1;\n    }\n    else\n    {\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filea);\n      v17 = 0;\n    }\n  }\n  return v17 & 1;\n}\n\n\n Revised code:\nstatic bool\nsysv_sum_file (const char *file, int print_name)\n{\n  int fd;\n  unsigned char buf[8192];\n  uintmax_t total_bytes = 0;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int r;\n  int checksum;\n\n  /* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n  unsigned int s = 0;\n\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fd = STDIN_FILENO;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while (1)\n    {\n      size_t i;\n      size_t bytes_read = safe_read (fd, buf, sizeof buf);\n\n      if (bytes_read == 0)\n\tbreak;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  if (!is_stdin)\n\t    close (fd);\n\t  return false;\n\t}\n\n      for (i = 0; i < bytes_read; i++)\n\ts += buf[i];\n      total_bytes += bytes_read;\n    }\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  checksum = (r & 0xffff) + (r >> 16);\n\n  printf (\"%d %s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 512));\n  if (print_name)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_414F2F(__int64 a1)\n{\n  int result; // eax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n\n  sub_4F6569(a1);\n  result = chdir(*(const char **)(a1 + 32));\n  if ( result < 0 )\n  {\n    sub_414377(\"Ichdir(%s)\", *(_QWORD *)(a1 + 32), v2, v3, v4, v5);\n    result = chdir(\"/var/spool/cron\");\n    if ( result < 0 )\n      return sub_414377(byte_528D20, (__int64)\"/var/spool/cron\", v6, v7, v8, v9);\n  }\n  return result;\n}\n",
        "output": "```c\nstatic int\nchange_directory (const char *directory)\n{\n  int result;\n\n  prepare_directory_change ();\n  result = chdir (directory);\n  if (result < 0)\n    {\n      log_error (\"chdir(%s)\", directory);\n      result = chdir (\"/var/spool/cron\");\n      if (result < 0)\n        log_error (\"chdir(%s)\", \"/var/spool/cron\");\n    }\n\n  return result;\n}\n```",
        "source_code": "static void change_user(struct passwd *pas)\n{\n\t/* careful: we're after vfork! */\n\tchange_identity(pas); /* - initgroups, setgid, setuid */\n\tif (chdir(pas->pw_dir) < 0) {\n\t\tcrondlog(WARN9 \"chdir(%s)\", pas->pw_dir);\n\t\tif (chdir(TMPDIR) < 0) {\n\t\t\tcrondlog(DIE9 \"chdir(%s)\", TMPDIR); /* exits */\n\t\t}\n\t}\n}",
        "parsed_output": "static int\nchange_directory (const char *directory)\n{\n  int result;\n\n  prepare_directory_change ();\n  result = chdir (directory);\n  if (result < 0)\n    {\n      log_error (\"chdir(%s)\", directory);\n      result = chdir (\"/var/spool/cron\");\n      if (result < 0)\n        log_error (\"chdir(%s)\", \"/var/spool/cron\");\n    }\n\n  return result;\n}",
        "baseline_code_stripped": "int __fastcall sub_414F2F(__int64 a1)\n{\n  int result; // eax\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  __int64 v6; // rdx\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n\n  sub_4F6569(a1);\n  result = chdir(*(const char **)(a1 + 32));\n  if ( result < 0 )\n  {\n    sub_414377(\"Ichdir(%s)\", *(_QWORD *)(a1 + 32), v2, v3, v4, v5);\n    result = chdir(\"/var/spool/cron\");\n    if ( result < 0 )\n      return sub_414377(byte_528D20, (__int64)\"/var/spool/cron\", v6, v7, v8, v9);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl change_user(passwd *pas)\n{\n  change_identity(pas);\n  if ( chdir(pas->pw_dir) < 0 )\n  {\n    crondlog(\"Ichdir(%s)\", pas->pw_dir);\n    if ( chdir(\"/var/spool/cron\") < 0 )\n      crondlog(&byte_528D20, \"/var/spool/cron\");\n  }\n}\n",
        "similarity_score_unixcoder": 0.6739124059677124,
        "similarity_score_baseline_stripped": 0.5718674063682556,
        "similarity_score_baseline_debug": 0.8898484110832214
    },
    {
        "func_name": "str_value",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_occurs(const void *void_first, const void *void_second)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h]\n  int value; // [rsp+1Ch] [rbp-14h]\n\n  value = compare_words(void_first, void_second);\n  if ( value )\n    LODWORD(v3) = value;\n  else\n    return *(_QWORD *)void_first - *(_QWORD *)void_second;\n  return v3;\n}\n\n\n Revised code:\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return value == 0 ? first->key.start - second->key.start : value;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nint __cdecl hextobin(unsigned __int8 c)\n{\n  int v2; // [rsp+10h] [rbp-4h]\n\n  switch ( c )\n  {\n    case 'A':\n    case 'a':\n      v2 = 10;\n      break;\n    case 'B':\n    case 'b':\n      v2 = 11;\n      break;\n    case 'C':\n    case 'c':\n      v2 = 12;\n      break;\n    case 'D':\n    case 'd':\n      v2 = 13;\n      break;\n    case 'E':\n    case 'e':\n      v2 = 14;\n      break;\n    case 'F':\n    case 'f':\n      v2 = 15;\n      break;\n    default:\n      v2 = c - 48;\n      break;\n  }\n  return v2;\n}\n\n\n Revised code:\nstatic int\nhextobin (unsigned char c)\n{\n  switch (c)\n    {\n    default: return c - '0';\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_QWORD *__fastcall sub_4C92D7(const char *a1, __int64 a2)\n{\n  _QWORD *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40A0E8(0x10uLL, a2);\n  *(_BYTE *)v3 = 1;\n  v3[1] = sub_40A11F(a1, a2);\n  return v3;\n}\n",
        "output": "```c\nstatic _QWORD *\nsub_4C92D7 (const char *a1, __int64 a2)\n{\n  _QWORD *result;\n\n  result = sub_40A0E8 (0x10uLL, a2);\n  *((_BYTE *)result) = 1;\n  result[1] = sub_40A11F (a1, a2);\n  return result;\n}\n```",
        "source_code": "static VALUE *str_value(const char *s)\n{\n\tVALUE *v;\n\n\tv = xzalloc(sizeof(VALUE));\n\tif (STRING) /* otherwise xzaaloc did it already */\n\t\tv->type = STRING;\n\tv->u.s = xstrdup(s);\n\treturn v;\n}",
        "parsed_output": "static _QWORD *\nsub_4C92D7 (const char *a1, __int64 a2)\n{\n  _QWORD *result;\n\n  result = sub_40A0E8 (0x10uLL, a2);\n  *((_BYTE *)result) = 1;\n  result[1] = sub_40A11F (a1, a2);\n  return result;\n}",
        "baseline_code_stripped": "_QWORD *__fastcall sub_4C92D7(const char *a1, __int64 a2)\n{\n  _QWORD *v3; // [rsp+18h] [rbp-8h]\n\n  v3 = sub_40A0E8(0x10uLL, a2);\n  *(_BYTE *)v3 = 1;\n  v3[1] = sub_40A11F(a1, a2);\n  return v3;\n}\n",
        "baseline_code_debug": "VALUE *__cdecl str_value(const char *s)\n{\n  VALUE *v; // [rsp+18h] [rbp-8h]\n\n  v = (VALUE *)xzalloc(0x10uLL);\n  v->type = 1;\n  v->u.i = (arith_t_0)xstrdup(s);\n  return v;\n}\n",
        "similarity_score_unixcoder": 0.46419045329093933,
        "similarity_score_baseline_stripped": 0.4493058919906616,
        "similarity_score_baseline_debug": 0.7117202281951904
    },
    {
        "func_name": "save_command_ps_at_cur_history",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_occurs(const void *void_first, const void *void_second)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h]\n  int value; // [rsp+1Ch] [rbp-14h]\n\n  value = compare_words(void_first, void_second);\n  if ( value )\n    LODWORD(v3) = value;\n  else\n    return *(_QWORD *)void_first - *(_QWORD *)void_second;\n  return v3;\n}\n\n\n Revised code:\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return value == 0 ? first->key.start - second->key.start : value;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_long_long(size_t n_bytes, const void *block, const char *fmt_string)\n{\n  _QWORD *v3; // rax\n  size_t i; // [rsp+8h] [rbp-28h]\n\n  for ( i = n_bytes >> 3; i; --i )\n  {\n    v3 = block;\n    block = (char *)block + 8;\n    printf(fmt_string, *v3);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_long_long (size_t n_bytes, void const *block, char const *fmt_string)\n{\n  unsigned_long_long_int const *p = block;\n  size_t i;\n  for (i = n_bytes / sizeof *p; i != 0; i--)\n    printf (fmt_string, *p++);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_4FF998()\n{\n  __int64 result; // rax\n  __int64 v1; // rbx\n  char *v2; // rdx\n  char v3[1036]; // [rsp+0h] [rbp-420h] BYREF\n  int v4; // [rsp+40Ch] [rbp-14h]\n\n  result = **((unsigned int **)qword_75D458 + 6);\n  if ( (_DWORD)result )\n  {\n    v4 = *(_DWORD *)(*(_QWORD *)qword_75D458 + 20LL);\n    free(*(void **)(*(_QWORD *)qword_75D458 + 8 * (v4 + 4LL) + 8));\n    sub_4FE0EA((__int64)v3, 1024);\n    v1 = *(_QWORD *)qword_75D458;\n    v2 = sub_40A11F(v3, 1024LL);\n    result = v4 + 4LL;\n    *(_QWORD *)(v1 + 8 * result + 8) = v2;\n  }\n  return result;\n}\n",
        "output": "```c\nstatic __int64 update_data_structure()\n{\n  __int64 result;\n  __int64 data_ptr;\n  char buffer[1036];\n  int index;\n\n  result = **((unsigned int **)global_data + 6);\n  if (result != 0)\n  {\n    index = *(_DWORD *)(*(_QWORD *)global_data + 20);\n    free(*(void **)(*(_QWORD *)global_data + 8 * (index + 4) + 8));\n    initialize_buffer(buffer, 1024);\n    data_ptr = *(_QWORD *)global_data;\n    char *new_data = allocate_and_copy_data(buffer, 1024);\n    result = index + 4;\n    *(_QWORD *)(data_ptr + 8 * result + 8) = new_data;\n  }\n  return result;\n}\n```",
        "source_code": "static void save_command_ps_at_cur_history(void)\n{\n\tif (command_ps[0] != BB_NUL) {\n\t\tint cur = state->cur_history;\n\t\tfree(state->history[cur]);\n\n# if ENABLE_UNICODE_SUPPORT\n\t\t{\n\t\t\tchar tbuf[MAX_LINELEN];\n\t\t\tsave_string(tbuf, sizeof(tbuf));\n\t\t\tstate->history[cur] = xstrdup(tbuf);\n\t\t}\n# else\n\t\tstate->history[cur] = xstrdup(command_ps);\n# endif\n\t}\n}",
        "parsed_output": "static __int64 update_data_structure()\n{\n  __int64 result;\n  __int64 data_ptr;\n  char buffer[1036];\n  int index;\n\n  result = **((unsigned int **)global_data + 6);\n  if (result != 0)\n  {\n    index = *(_DWORD *)(*(_QWORD *)global_data + 20);\n    free(*(void **)(*(_QWORD *)global_data + 8 * (index + 4) + 8));\n    initialize_buffer(buffer, 1024);\n    data_ptr = *(_QWORD *)global_data;\n    char *new_data = allocate_and_copy_data(buffer, 1024);\n    result = index + 4;\n    *(_QWORD *)(data_ptr + 8 * result + 8) = new_data;\n  }\n  return result;\n}",
        "baseline_code_stripped": "__int64 sub_4FF998()\n{\n  __int64 result; // rax\n  __int64 v1; // rbx\n  char *v2; // rdx\n  char v3[1036]; // [rsp+0h] [rbp-420h] BYREF\n  int v4; // [rsp+40Ch] [rbp-14h]\n\n  result = **((unsigned int **)qword_75D458 + 6);\n  if ( (_DWORD)result )\n  {\n    v4 = *(_DWORD *)(*(_QWORD *)qword_75D458 + 20LL);\n    free(*(void **)(*(_QWORD *)qword_75D458 + 8 * (v4 + 4LL) + 8));\n    sub_4FE0EA((__int64)v3, 1024);\n    v1 = *(_QWORD *)qword_75D458;\n    v2 = sub_40A11F(v3, 1024LL);\n    result = v4 + 4LL;\n    *(_QWORD *)(v1 + 8 * result + 8) = v2;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl save_command_ps_at_cur_history()\n{\n  line_input_t_0 *state; // rbx\n  char *v1; // rax\n  char tbuf[1024]; // [rsp+0h] [rbp-420h] BYREF\n  int cur; // [rsp+40Ch] [rbp-14h]\n\n  if ( *lineedit_ptr_to_statics->command_ps )\n  {\n    cur = lineedit_ptr_to_statics->state->cur_history;\n    free(lineedit_ptr_to_statics->state->history[cur]);\n    save_string(tbuf, 0x400u);\n    state = lineedit_ptr_to_statics->state;\n    v1 = xstrdup(tbuf);\n    state->history[cur] = v1;\n  }\n}\n",
        "similarity_score_unixcoder": 0.45452967286109924,
        "similarity_score_baseline_stripped": 0.40605127811431885,
        "similarity_score_baseline_debug": 0.8291019797325134
    },
    {
        "func_name": "new_init_action",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl set_prefix(char *p)\n{\n  bool v1; // [rsp+Fh] [rbp-11h]\n  char *s; // [rsp+10h] [rbp-10h]\n\n  prefix_lead_space = 0;\n  while ( *p == 32 )\n  {\n    ++prefix_lead_space;\n    ++p;\n  }\n  prefix = p;\n  prefix_full_length = strlen(p);\n  for ( s = &p[prefix_full_length]; ; --s )\n  {\n    v1 = 0;\n    if ( s > p )\n      v1 = *(s - 1) == 32;\n    if ( !v1 )\n      break;\n  }\n  *s = 0;\n  prefix_length = (_DWORD)s - (_DWORD)p;\n}\n\n\n Revised code:\nstatic void\nset_prefix (char *p)\n{\n  char *s;\n\n  prefix_lead_space = 0;\n  while (*p == ' ')\n    {\n      prefix_lead_space++;\n      p++;\n    }\n  prefix = p;\n  prefix_full_length = strlen (p);\n  s = p + prefix_full_length;\n  while (s > p && s[-1] == ' ')\n    s--;\n  *s = '\\0';\n  prefix_length = s - p;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_named_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  const unsigned __int8 *v3; // rax\n  char buf[5]; // [rsp+13h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+18h] [rbp-38h]\n  int masked_c; // [rsp+24h] [rbp-2Ch]\n  size_t i; // [rsp+28h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+30h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+38h] [rbp-18h]\n  const void *blocka; // [rsp+40h] [rbp-10h]\n  size_t n_bytesa; // [rsp+48h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = p++;\n    masked_c = *v3 & 0x7F;\n    if ( masked_c == 127 )\n    {\n      s = \"del\";\n    }\n    else if ( masked_c > 32 )\n    {\n      sprintf(buf, \"  %c\", (unsigned int)masked_c);\n      s = buf;\n    }\n    else\n    {\n      s = charname[masked_c];\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_named_ascii (size_t n_bytes, void const *block,\n\t\t   const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      int masked_c = *p++ & 0x7f;\n      const char *s;\n      char buf[5];\n\n      if (masked_c == 127)\n\ts = \"del\";\n      else if (masked_c <= 040)\n\ts = charname[masked_c];\n      else\n\t{\n\t  sprintf (buf, \"  %c\", masked_c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n\n## Example:\n\n Input code:\nunsigned int __cdecl get_format_flags(char **format_ptr)\n{\n  unsigned int count; // [rsp+10h] [rbp-14h]\n\n  count = 0;\n  while ( 2 )\n  {\n    if ( **format_ptr )\n    {\n      switch ( **format_ptr )\n      {\n        case ' ':\n        case '+':\n          count |= 1u;\n          goto LABEL_7;\n        case '#':\n          count |= 2u;\n          goto LABEL_7;\n        case '-':\nLABEL_7:\n          ++*format_ptr;\n          continue;\n        default:\n          return count;\n      }\n    }\n    return count;\n  }\n}\n\n\n Revised code:\nstatic unsigned int\nget_format_flags (char **format_ptr)\n{\n  unsigned int count = 0;\n\n  for (; **format_ptr; (*format_ptr)++)\n    {\n      switch (**format_ptr)\n\t{\n\tcase '-':\n\t  break;\n\n\tcase '+':\n\tcase ' ':\n\t  count |= 1;\n\t  break;\n\n\tcase '#':\n\t  count |= 2;\t/* Allow for 0x prefix preceding an `x' conversion.  */\n\t  break;\n\n\tdefault:\n\t  return count;\n\t}\n    }\n  return count;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4F53FD(char a1, __int64 a2, const char *a3)\n{\n  char *s2; // [rsp+10h] [rbp-20h]\n  void **i; // [rsp+20h] [rbp-10h]\n  char *v7; // [rsp+28h] [rbp-8h]\n\n  s2 = (char *)a2;\n  for ( i = (void **)&qword_75B2B0; ; i = (void **)v7 )\n  {\n    v7 = (char *)*i;\n    if ( !*i )\n    {\n      v7 = (char *)sub_40A0E8(0x130uLL, a2);\n      goto LABEL_11;\n    }\n    a2 = (__int64)s2;\n    if ( !strcmp(v7 + 45, s2) )\n    {\n      a2 = (__int64)a3;\n      if ( !strcmp(v7 + 13, a3) )\n        break;\n    }\n  }\n  for ( *i = *(void **)v7; *i; i = (void **)*i )\n    ;\n  *(_QWORD *)v7 = 0LL;\nLABEL_11:\n  *i = v7;\n  v7[12] = a1;\n  sub_507FC0(v7 + 45, s2, 256LL);\n  return sub_507FC0(v7 + 13, a3, 32LL);\n}\n",
        "output": "```c\nstatic __int64\nsub_4F53FD (char a1, __int64 a2, const char *a3)\n{\n  char *s2 = (char *)a2;\n  void **i;\n  char *v7;\n\n  for (i = (void **)&qword_75B2B0; ; i = (void **)v7)\n    {\n      v7 = (char *)*i;\n      if (!v7)\n\t{\n\t  v7 = (char *)sub_40A0E8 (0x130uLL, a2);\n\t  goto LABEL_11;\n\t}\n      if (!strcmp (v7 + 45, s2) && !strcmp (v7 + 13, a3))\n\tbreak;\n    }\n  for (*i = *(void **)v7; *i; i = (void **)*i)\n    ;\n  *(_QWORD *)v7 = 0LL;\nLABEL_11:\n  *i = v7;\n  v7[12] = a1;\n  sub_507FC0 (v7 + 45, s2, 256LL);\n  return sub_507FC0 (v7 + 13, a3, 32LL);\n}\n```",
        "source_code": "static void new_init_action(uint8_t action_type, const char *command, const char *cons)\n{\n\tstruct init_action *a, **nextp;\n\n\t/* Scenario:\n\t * old inittab:\n\t * ::shutdown:umount -a -r\n\t * ::shutdown:swapoff -a\n\t * new inittab:\n\t * ::shutdown:swapoff -a\n\t * ::shutdown:umount -a -r\n\t * On reload, we must ensure entries end up in correct order.\n\t * To achieve that, if we find a matching entry, we move it\n\t * to the end.\n\t */\n\tnextp = &init_action_list;\n\twhile ((a = *nextp) != NULL) {\n\t\t/* Don't enter action if it's already in the list.\n\t\t * This prevents losing running RESPAWNs.\n\t\t */\n\t\tif (strcmp(a->command, command) == 0\n\t\t && strcmp(a->terminal, cons) == 0\n\t\t) {\n\t\t\t/* Remove from list */\n\t\t\t*nextp = a->next;\n\t\t\t/* Find the end of the list */\n\t\t\twhile (*nextp != NULL)\n\t\t\t\tnextp = &(*nextp)->next;\n\t\t\ta->next = NULL;\n\t\t\tgoto append;\n\t\t}\n\t\tnextp = &a->next;\n\t}\n\n\ta = xzalloc(sizeof(*a));\n\n\t/* Append to the end of the list */\n append:\n\t*nextp = a;\n\ta->action_type = action_type;\n\tsafe_strncpy(a->command, command, sizeof(a->command));\n\tsafe_strncpy(a->terminal, cons, sizeof(a->terminal));\n\tdbg_message(L_LOG | L_CONSOLE, \"command='%s' action=%d tty='%s'\\n\",\n\t\ta->command, a->action_type, a->terminal);\n}",
        "parsed_output": "static __int64\nsub_4F53FD (char a1, __int64 a2, const char *a3)\n{\n  char *s2 = (char *)a2;\n  void **i;\n  char *v7;\n\n  for (i = (void **)&qword_75B2B0; ; i = (void **)v7)\n    {\n      v7 = (char *)*i;\n      if (!v7)\n\t{\n\t  v7 = (char *)sub_40A0E8 (0x130uLL, a2);\n\t  goto LABEL_11;\n\t}\n      if (!strcmp (v7 + 45, s2) && !strcmp (v7 + 13, a3))\n\tbreak;\n    }\n  for (*i = *(void **)v7; *i; i = (void **)*i)\n    ;\n  *(_QWORD *)v7 = 0LL;\nLABEL_11:\n  *i = v7;\n  v7[12] = a1;\n  sub_507FC0 (v7 + 45, s2, 256LL);\n  return sub_507FC0 (v7 + 13, a3, 32LL);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4F53FD(char a1, __int64 a2, const char *a3)\n{\n  char *s2; // [rsp+10h] [rbp-20h]\n  void **i; // [rsp+20h] [rbp-10h]\n  char *v7; // [rsp+28h] [rbp-8h]\n\n  s2 = (char *)a2;\n  for ( i = (void **)&qword_75B2B0; ; i = (void **)v7 )\n  {\n    v7 = (char *)*i;\n    if ( !*i )\n    {\n      v7 = (char *)sub_40A0E8(0x130uLL, a2);\n      goto LABEL_11;\n    }\n    a2 = (__int64)s2;\n    if ( !strcmp(v7 + 45, s2) )\n    {\n      a2 = (__int64)a3;\n      if ( !strcmp(v7 + 13, a3) )\n        break;\n    }\n  }\n  for ( *i = *(void **)v7; *i; i = (void **)*i )\n    ;\n  *(_QWORD *)v7 = 0LL;\nLABEL_11:\n  *i = v7;\n  v7[12] = a1;\n  sub_507FC0(v7 + 45, s2, 256LL);\n  return sub_507FC0(v7 + 13, a3, 32LL);\n}\n",
        "baseline_code_debug": "void __cdecl new_init_action(uint8_t action_type, const char *command, const char *cons)\n{\n  init_action **nextp; // [rsp+20h] [rbp-10h]\n  init_action *a; // [rsp+28h] [rbp-8h]\n\n  for ( nextp = &init_action_list; ; nextp = &a->next )\n  {\n    a = *nextp;\n    if ( !*nextp )\n    {\n      a = (init_action *)xzalloc(0x130uLL);\n      goto append;\n    }\n    if ( !strcmp(a->command, command) && !strcmp(a->terminal, cons) )\n      break;\n  }\n  for ( *nextp = a->next; *nextp; nextp = (init_action **)*nextp )\n    ;\n  a->next = 0LL;\nappend:\n  *nextp = a;\n  a->action_type = action_type;\n  safe_strncpy(a->command, command, 0x100uLL);\n  safe_strncpy(a->terminal, cons, 0x20uLL);\n}\n",
        "similarity_score_unixcoder": 0.49413353204727173,
        "similarity_score_baseline_stripped": 0.5266780257225037,
        "similarity_score_baseline_debug": 0.8429151773452759
    },
    {
        "func_name": "out_char",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl next_line_num()\n{\n  char v0; // cl\n  char *v1; // rax\n  char *v2; // rax\n  char *endp; // [rsp+0h] [rbp-8h]\n\n  endp = line_num_end;\n  while ( 1 )\n  {\n    v0 = (*endp)++;\n    if ( v0 < 57 )\n      break;\n    v1 = endp--;\n    *v1 = 48;\n    if ( endp < line_num_start )\n    {\n      if ( line_num_start <= line_buf )\n      {\n        line_buf[0] = 62;\n      }\n      else\n      {\n        v2 = line_num_start--;\n        *(v2 - 1) = 49;\n      }\n      if ( line_num_start < line_num_print )\n        --line_num_print;\n      return;\n    }\n  }\n}\n\n\n Revised code:\nstatic void\nnext_line_num (void)\n{\n  char *endp = line_num_end;\n  do\n    {\n      if ((*endp)++ < '9')\n\treturn;\n      *endp-- = '0';\n    }\n  while (endp >= line_num_start);\n  if (line_num_start > line_buf)\n    *--line_num_start = '1';\n  else\n    *line_buf = '>';\n  if (line_num_start < line_num_print)\n    line_num_print--;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nunsigned int __fastcall sub_463DD5(char a1)\n{\n  unsigned int result; // eax\n\n  ++*(_DWORD *)qword_75D408;\n  result = *((_DWORD *)qword_75D408 + 1);\n  if ( *(_DWORD *)qword_75D408 <= result )\n  {\n    if ( *(_DWORD *)qword_75D408 == *((_DWORD *)qword_75D408 + 1) )\n      a1 = 43;\n    return putchar_unlocked(a1);\n  }\n  return result;\n}\n",
        "output": "static unsigned int\nincrement_and_print(char character)\n{\n  unsigned int *counter = (unsigned int *)qword_75D408;\n  unsigned int limit = counter[1];\n\n  ++(*counter);\n\n  if (*counter <= limit)\n  {\n    if (*counter == limit)\n      character = '+';\n    return putchar_unlocked(character);\n  }\n\n  return limit;\n}",
        "source_code": "static void out_char(char c)\n{\n\tG.cur_x++;\n\tif (G.cur_x > G.output_width)\n\t\treturn;\n\tif (G.cur_x == G.output_width)\n\t\tc = '+';\n\tputchar(c);\n}",
        "parsed_output": "static unsigned int\nincrement_and_print(char character)\n{\n  unsigned int *counter = (unsigned int *)qword_75D408;\n  unsigned int limit = counter[1];\n\n  ++(*counter);\n\n  if (*counter <= limit)\n  {\n    if (*counter == limit)\n      character = '+';\n    return putchar_unlocked(character);\n  }\n\n  return limit;\n}",
        "baseline_code_stripped": "unsigned int __fastcall sub_463DD5(char a1)\n{\n  unsigned int result; // eax\n\n  ++*(_DWORD *)qword_75D408;\n  result = *((_DWORD *)qword_75D408 + 1);\n  if ( *(_DWORD *)qword_75D408 <= result )\n  {\n    if ( *(_DWORD *)qword_75D408 == *((_DWORD *)qword_75D408 + 1) )\n      a1 = 43;\n    return putchar_unlocked(a1);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl out_char(char c)\n{\n  if ( ++ptr_to_globals->timeout <= *(&ptr_to_globals->timeout + 1) )\n  {\n    if ( ptr_to_globals->timeout == *(&ptr_to_globals->timeout + 1) )\n      c = 43;\n    putchar_unlocked(c);\n  }\n}\n",
        "similarity_score_unixcoder": 0.6994199156761169,
        "similarity_score_baseline_stripped": 0.5732336044311523,
        "similarity_score_baseline_debug": 0.5746316313743591
    },
    {
        "func_name": "rtnl_dsfield_n2a",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl adjust_column(size_t column, char c)\n{\n  size_t columna; // [rsp+2h] [rbp-8h]\n\n  columna = column;\n  if ( count_bytes )\n    return column + 1;\n  switch ( c )\n  {\n    case 8:\n      if ( column )\n        return column - 1;\n      break;\n    case 13:\n      return 0LL;\n    case 9:\n      return column + 8 - (column & 7);\n    default:\n      return column + 1;\n  }\n  return columna;\n}\n\n\n Revised code:\nstatic size_t\nadjust_column (size_t column, char c)\n{\n  if (!count_bytes)\n    {\n      if (c == '\\b')\n\t{\n\t  if (column > 0)\n\t    column--;\n\t}\n      else if (c == '\\r')\n\tcolumn = 0;\n      else if (c == '\\t')\n\tcolumn += TAB_WIDTH - column % TAB_WIDTH;\n      else /* if (isprint (c)) */\n\tcolumn++;\n    }\n  else\n    column++;\n  return column;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl get_format_conv_type(char **format_ptr)\n{\n  char *v1; // rax\n  char *v2; // rax\n  char *v3; // rax\n  int v4; // [rsp+20h] [rbp-10h]\n  unsigned __int8 ch_0; // [rsp+27h] [rbp-9h]\n\n  v1 = (*format_ptr)++;\n  ch_0 = *v1;\n  v4 = (unsigned __int8)*v1;\n  if ( *v1 )\n  {\n    if ( v4 != 88 && v4 != 100 && v4 != 105 && v4 != 111 && v4 != 117 && v4 != 120 )\n    {\n      if ( ((*__ctype_b_loc())[ch_0] & 0x4000) != 0 )\n        v3 = gettext(\"invalid conversion specifier in suffix: %c\");\n      else\n        v3 = gettext(\"invalid conversion specifier in suffix: \\\\%.3o\");\n      error(1, 0, v3, ch_0);\n    }\n  }\n  else\n  {\n    v2 = gettext(\"missing conversion specifier in suffix\");\n    error(1, 0, v2);\n  }\n}\n\n\n Revised code:\nstatic void\nget_format_conv_type (char **format_ptr)\n{\n  unsigned char ch = *(*format_ptr)++;\n\n  switch (ch)\n    {\n    case 'd':\n    case 'i':\n    case 'o':\n    case 'u':\n    case 'x':\n    case 'X':\n      break;\n\n    case 0:\n      error (EXIT_FAILURE, 0, _(\"missing conversion specifier in suffix\"));\n      break;\n\n    default:\n      if (isprint (ch))\n        error (EXIT_FAILURE, 0,\n\t       _(\"invalid conversion specifier in suffix: %c\"), ch);\n      else\n\terror (EXIT_FAILURE, 0,\n\t       _(\"invalid conversion specifier in suffix: \\\\%.3o\"), ch);\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_4527BD(__int64 a1, char *a2)\n{\n  if ( (unsigned int)a1 < 0x100 )\n  {\n    sub_452770(a1, (__int64)a2);\n    if ( *(_QWORD *)(qword_75B1D0 + 8 * ((int)a1 + 2LL)) )\n    {\n      return *(char **)(qword_75B1D0 + 8 * ((int)a1 + 2LL));\n    }\n    else\n    {\n      sprintf(a2, \"0x%02x\", (unsigned int)a1);\n      return a2;\n    }\n  }\n  else\n  {\n    sprintf(a2, \"%d\", (unsigned int)a1);\n    return a2;\n  }\n}\n",
        "output": "```c\nstatic char *\nformat_value (unsigned int value, char *buffer)\n{\n  if (value < 0x100)\n    {\n      perform_initialization(value, buffer);\n      char **lookup_result = get_lookup_result(value);\n      if (*lookup_result)\n        {\n          return *lookup_result;\n        }\n      else\n        {\n          sprintf(buffer, \"0x%02x\", value);\n          return buffer;\n        }\n    }\n  else\n    {\n      sprintf(buffer, \"%d\", value);\n      return buffer;\n    }\n}\n```",
        "source_code": "FAST_FUNC rtnl_dsfield_n2a(int id, char *buf)\n{\n\tif (id < 0 || id >= 256) {\n\t\tsprintf(buf, \"%d\", id);\n\t\treturn buf;\n\t}\n\n\trtnl_rtdsfield_initialize();\n\n\tif (rtnl_rtdsfield_tab->tab[id])\n\t\treturn rtnl_rtdsfield_tab->tab[id];\n\t/* buf is SPRINT_BSIZE big */\n\tsprintf(buf, \"0x%02x\", id);\n\treturn buf;\n}",
        "parsed_output": "static char *\nformat_value (unsigned int value, char *buffer)\n{\n  if (value < 0x100)\n    {\n      perform_initialization(value, buffer);\n      char **lookup_result = get_lookup_result(value);\n      if (*lookup_result)\n        {\n          return *lookup_result;\n        }\n      else\n        {\n          sprintf(buffer, \"0x%02x\", value);\n          return buffer;\n        }\n    }\n  else\n    {\n      sprintf(buffer, \"%d\", value);\n      return buffer;\n    }\n}",
        "baseline_code_stripped": "char *__fastcall sub_4527BD(__int64 a1, char *a2)\n{\n  if ( (unsigned int)a1 < 0x100 )\n  {\n    sub_452770(a1, (__int64)a2);\n    if ( *(_QWORD *)(qword_75B1D0 + 8 * ((int)a1 + 2LL)) )\n    {\n      return *(char **)(qword_75B1D0 + 8 * ((int)a1 + 2LL));\n    }\n    else\n    {\n      sprintf(a2, \"0x%02x\", (unsigned int)a1);\n      return a2;\n    }\n  }\n  else\n  {\n    sprintf(a2, \"%d\", (unsigned int)a1);\n    return a2;\n  }\n}\n",
        "baseline_code_debug": "const char *__cdecl rtnl_dsfield_n2a(int id, char *buf)\n{\n  if ( (unsigned int)id < 0x100 )\n  {\n    rtnl_rtdsfield_initialize();\n    if ( rtnl_rtdsfield_tab->tab[id] )\n    {\n      return rtnl_rtdsfield_tab->tab[id];\n    }\n    else\n    {\n      sprintf(buf, \"0x%02x\", (unsigned int)id);\n      return buf;\n    }\n  }\n  else\n  {\n    sprintf(buf, \"%d\", (unsigned int)id);\n    return buf;\n  }\n}\n",
        "similarity_score_unixcoder": 0.6407042741775513,
        "similarity_score_baseline_stripped": 0.5922929048538208,
        "similarity_score_baseline_debug": 0.9382304549217224
    },
    {
        "func_name": "unsetvar",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nvoid __cdecl fillpattern(int type, unsigned __int8 *r, size_t size)\n{\n  size_t i; // [rsp+10h] [rbp-20h]\n  size_t ia; // [rsp+10h] [rbp-20h]\n\n  *r = (type & 0xFFF | ((type & 0xFFFu) << 12)) >> 4;\n  r[1] = (unsigned __int16)(type & 0xFFF | ((type & 0xFFF) << 12)) >> 8;\n  r[2] = type;\n  for ( i = 3LL; i < size >> 1; i *= 2LL )\n    memcpy(&r[i], r, i);\n  if ( i < size )\n    memcpy(&r[i], r, size - i);\n  if ( (type & 0x1000) != 0 )\n  {\n    for ( ia = 0LL; ia < size; ia += 512LL )\n      r[ia] ^= 0x80u;\n  }\n}\n\n\n Revised code:\nstatic void\nfillpattern (int type, unsigned char *r, size_t size)\n{\n  size_t i;\n  unsigned int bits = type & 0xfff;\n\n  bits |= bits << 12;\n  r[0] = (bits >> 4) & 255;\n  r[1] = (bits >> 8) & 255;\n  r[2] = bits & 255;\n  for (i = 3; i < size / 2; i *= 2)\n    memcpy (r + i, r, i);\n  if (i < size)\n    memcpy (r + i, r, size - i);\n\n  /* Invert the first bit of every sector. */\n  if (type & 0x1000)\n    for (i = 0; i < size; i += SECTOR_SIZE)\n      r[i] ^= 0x80;\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_46F900(unsigned __int8 *a1)\n{\n  __int64 *v1; // rax\n  int v2; // eax\n  int v4; // [rsp+14h] [rbp-1Ch]\n  void *ptr; // [rsp+18h] [rbp-18h]\n  __int64 *v6; // [rsp+20h] [rbp-10h]\n  unsigned int v7; // [rsp+2Ch] [rbp-4h]\n\n  v1 = (__int64 *)sub_46F2C1(a1);\n  v6 = sub_46F3E8(v1, (char *)a1);\n  ptr = (void *)*v6;\n  v7 = 2;\n  if ( *v6 )\n  {\n    v4 = *((_DWORD *)ptr + 2);\n    v7 = 1;\n    if ( (v4 & 2) == 0 )\n    {\n      v2 = *((_DWORD *)ptr + 2);\n      BYTE1(v2) &= ~2u;\n      *((_DWORD *)ptr + 2) = v2;\n      if ( (v4 & 0x20) == 0 )\n      {\n        if ( (v4 & 4) != 0 )\n        {\n          sub_46F6BF((char *)a1, 0LL, 0);\n          *((_DWORD *)ptr + 2) &= ~1u;\n        }\n        else\n        {\n          ++*(_DWORD *)(qword_75D418 + 48);\n          if ( (v4 & 0x18) == 0 )\n            free(*((void **)ptr + 2));\n          *v6 = *(_QWORD *)ptr;\n          free(ptr);\n          sub_46E03F(ptr, a1);\n        }\n      }\n      return 0;\n    }\n  }\n  return v7;\n}\n",
        "output": "```c\nstatic unsigned int\nsub_46F900(unsigned char *a1)\n{\n  __int64 *v1;\n  int flags;\n  void *ptr;\n  __int64 *v6;\n  unsigned int result = 2;\n\n  v1 = (__int64 *)sub_46F2C1(a1);\n  v6 = sub_46F3E8(v1, (char *)a1);\n  ptr = (void *)*v6;\n\n  if (ptr)\n  {\n    flags = *((int *)ptr + 2);\n    result = 1;\n    if ((flags & 2) == 0)\n    {\n      *((int *)ptr + 2) &= ~2;\n\n      if ((flags & 0x20) == 0)\n      {\n        if ((flags & 4) != 0)\n        {\n          sub_46F6BF((char *)a1, 0, 0);\n          *((int *)ptr + 2) &= ~1;\n        }\n        else\n        {\n          ++*(_DWORD *)(qword_75D418 + 48);\n          if ((flags & 0x18) == 0)\n            free(*((void **)ptr + 2));\n          *v6 = *(_QWORD *)ptr;\n          free(ptr);\n          sub_46E03F(ptr, a1);\n        }\n      }\n      return 0;\n    }\n  }\n  return result;\n}\n```",
        "source_code": "static int\nunsetvar(const char *s)\n{\n\tstruct var **vpp;\n\tstruct var *vp;\n\tint retval;\n\n\tvpp = findvar(hashvar(s), s);\n\tvp = *vpp;\n\tretval = 2;\n\tif (vp) {\n\t\tint flags = vp->flags;\n\n\t\tretval = 1;\n\t\tif (flags & VREADONLY)\n\t\t\tgoto out;\n#if ENABLE_ASH_RANDOM_SUPPORT\n\t\tvp->flags &= ~VDYNAMIC;\n#endif\n\t\tif (flags & VUNSET)\n\t\t\tgoto ok;\n\t\tif ((flags & VSTRFIXED) == 0) {\n\t\t\tINT_OFF;\n\t\t\tif ((flags & (VTEXTFIXED|VSTACK)) == 0)\n\t\t\t\tfree((char*)vp->var_text);\n\t\t\t*vpp = vp->next;\n\t\t\tfree(vp);\n\t\t\tINT_ON;\n\t\t} else {\n\t\t\tsetvar(s, 0, 0);\n\t\t\tvp->flags &= ~VEXPORT;\n\t\t}\n ok:\n\t\tretval = 0;\n\t}\n out:\n\treturn retval;\n}",
        "parsed_output": "static unsigned int\nsub_46F900(unsigned char *a1)\n{\n  __int64 *v1;\n  int flags;\n  void *ptr;\n  __int64 *v6;\n  unsigned int result = 2;\n\n  v1 = (__int64 *)sub_46F2C1(a1);\n  v6 = sub_46F3E8(v1, (char *)a1);\n  ptr = (void *)*v6;\n\n  if (ptr)\n  {\n    flags = *((int *)ptr + 2);\n    result = 1;\n    if ((flags & 2) == 0)\n    {\n      *((int *)ptr + 2) &= ~2;\n\n      if ((flags & 0x20) == 0)\n      {\n        if ((flags & 4) != 0)\n        {\n          sub_46F6BF((char *)a1, 0, 0);\n          *((int *)ptr + 2) &= ~1;\n        }\n        else\n        {\n          ++*(_DWORD *)(qword_75D418 + 48);\n          if ((flags & 0x18) == 0)\n            free(*((void **)ptr + 2));\n          *v6 = *(_QWORD *)ptr;\n          free(ptr);\n          sub_46E03F(ptr, a1);\n        }\n      }\n      return 0;\n    }\n  }\n  return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_46F900(unsigned __int8 *a1)\n{\n  __int64 *v1; // rax\n  int v2; // eax\n  int v4; // [rsp+14h] [rbp-1Ch]\n  void *ptr; // [rsp+18h] [rbp-18h]\n  __int64 *v6; // [rsp+20h] [rbp-10h]\n  unsigned int v7; // [rsp+2Ch] [rbp-4h]\n\n  v1 = (__int64 *)sub_46F2C1(a1);\n  v6 = sub_46F3E8(v1, (char *)a1);\n  ptr = (void *)*v6;\n  v7 = 2;\n  if ( *v6 )\n  {\n    v4 = *((_DWORD *)ptr + 2);\n    v7 = 1;\n    if ( (v4 & 2) == 0 )\n    {\n      v2 = *((_DWORD *)ptr + 2);\n      BYTE1(v2) &= ~2u;\n      *((_DWORD *)ptr + 2) = v2;\n      if ( (v4 & 0x20) == 0 )\n      {\n        if ( (v4 & 4) != 0 )\n        {\n          sub_46F6BF((char *)a1, 0LL, 0);\n          *((_DWORD *)ptr + 2) &= ~1u;\n        }\n        else\n        {\n          ++*(_DWORD *)(qword_75D418 + 48);\n          if ( (v4 & 0x18) == 0 )\n            free(*((void **)ptr + 2));\n          *v6 = *(_QWORD *)ptr;\n          free(ptr);\n          sub_46E03F(ptr, a1);\n        }\n      }\n      return 0;\n    }\n  }\n  return v7;\n}\n",
        "baseline_code_debug": "int __cdecl unsetvar(const char *s)\n{\n  var **v1; // rdx\n  int v2; // eax\n  int flags; // [rsp+14h] [rbp-1Ch]\n  var *vp; // [rsp+18h] [rbp-18h]\n  var **vpp; // [rsp+20h] [rbp-10h]\n  int retval; // [rsp+2Ch] [rbp-4h]\n\n  v1 = hashvar(s);\n  vpp = findvar(v1, s);\n  vp = *vpp;\n  retval = 2;\n  if ( *vpp )\n  {\n    flags = vp->flags;\n    retval = 1;\n    if ( (flags & 2) == 0 )\n    {\n      v2 = vp->flags;\n      BYTE1(v2) &= ~2u;\n      vp->flags = v2;\n      if ( (flags & 0x20) == 0 )\n      {\n        if ( (flags & 4) != 0 )\n        {\n          setvar(s, 0LL, 0);\n          vp->flags &= ~1u;\n        }\n        else\n        {\n          ++ash_ptr_to_globals_misc->suppress_int;\n          if ( (flags & 0x18) == 0 )\n            free((void *)vp->var_text);\n          *vpp = vp->next;\n          free(vp);\n          int_on();\n        }\n      }\n      return 0;\n    }\n  }\n  return retval;\n}\n",
        "similarity_score_unixcoder": 0.5977992415428162,
        "similarity_score_baseline_stripped": 0.5272387862205505,
        "similarity_score_baseline_debug": 0.8391988277435303
    },
    {
        "func_name": "timeout_handler",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl cwrite(bool new_file_flag, const char *bp_0, size_t bytes)\n{\n  int *v3; // rax\n  const char *v4; // rax\n  int *v5; // rax\n  int *v6; // rax\n  const char *format; // [rsp+8h] [rbp-28h]\n  FILE *stream; // [rsp+10h] [rbp-20h]\n\n  if ( new_file_flag )\n  {\n    if ( output_desc >= 0 && close(output_desc) < 0 )\n    {\n      v3 = __errno_location();\n      error(1, *v3, \"%s\", outfile);\n    }\n    next_file_name();\n    if ( verbose )\n    {\n      stream = stderr;\n      format = gettext(\"creating file %s\\n\");\n      v4 = quote(outfile);\n      fprintf(stream, format, v4);\n    }\n    output_desc = open_safer(outfile, 577, 438LL);\n    if ( output_desc < 0 )\n    {\n      v5 = __errno_location();\n      error(1, *v5, \"%s\", outfile);\n    }\n  }\n  if ( full_write(output_desc, bp_0, bytes) != bytes )\n  {\n    v6 = __errno_location();\n    error(1, *v6, \"%s\", outfile);\n  }\n}\n\n\n Revised code:\nstatic void\ncwrite (bool new_file_flag, const char *bp, size_t bytes)\n{\n  if (new_file_flag)\n    {\n      if (output_desc >= 0 && close (output_desc) < 0)\n\terror (EXIT_FAILURE, errno, \"%s\", outfile);\n\n      next_file_name ();\n      if (verbose)\n\tfprintf (stderr, _(\"creating file %s\\n\"), quote (outfile));\n      output_desc = open (outfile,\n\t\t\t  O_WRONLY | O_CREAT | O_TRUNC | O_BINARY,\n\t\t\t  (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP\n\t\t\t   | S_IROTH | S_IWOTH));\n      if (output_desc < 0)\n\terror (EXIT_FAILURE, errno, \"%s\", outfile);\n    }\n  if (full_write (output_desc, bp, bytes) != bytes)\n    error (EXIT_FAILURE, errno, \"%s\", outfile);\n}\n\n## Example:\n\n Input code:\nbool __cdecl sysv_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  int *v5; // rax\n  char *v6; // rax\n  size_t bytes_read; // [rsp+20h] [rbp-22E0h]\n  size_t i; // [rsp+28h] [rbp-22D8h]\n  _BYTE is_stdin[5]; // [rsp+33h] [rbp-22CDh]\n  char hbuf[652]; // [rsp+40h] [rbp-22C0h] BYREF\n  uintmax_t total_bytes; // [rsp+2D8h] [rbp-2028h]\n  unsigned __int8 buf[8192]; // [rsp+2E0h] [rbp-2020h] BYREF\n  int fd; // [rsp+22E8h] [rbp-18h]\n  int print_namea; // [rsp+22ECh] [rbp-14h]\n  const char *filea; // [rsp+22F0h] [rbp-10h]\n  char v17; // [rsp+22FFh] [rbp-1h]\n\n  filea = file;\n  print_namea = print_name;\n  total_bytes = 0LL;\n  is_stdin[4] = 0;\n  v2 = strcmp(file, \"-\");\n  *(_DWORD *)is_stdin = v2 == 0;\n  if ( !v2 )\n  {\n    fd = 0;\n    have_read_stdin = 1;\n    goto LABEL_5;\n  }\n  fd = open(filea, 0);\n  if ( fd == -1 )\n  {\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    v17 = 0;\n  }\n  else\n  {\nLABEL_5:\n    while ( 1 )\n    {\n      bytes_read = safe_read(fd, buf, 0x2000uLL);\n      if ( !bytes_read )\n        break;\n      if ( bytes_read == -1LL )\n      {\n        v4 = __errno_location();\n        error(0, *v4, \"%s\", filea);\n        if ( (is_stdin[0] & 1) == 0 )\n          close(fd);\n        v17 = 0;\n        return v17 & 1;\n      }\n      for ( i = 0LL; i < bytes_read; ++i )\n        *(_DWORD *)&is_stdin[1] += buf[i];\n      total_bytes += bytes_read;\n    }\n    if ( (is_stdin[0] & 1) != 0 || !close(fd) )\n    {\n      v6 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x200uLL);\n      printf(\n        \"%d %s\",\n        ((HIWORD(*(_DWORD *)&is_stdin[1]) + *(unsigned __int16 *)&is_stdin[1]) >> 16)\n      + (unsigned int)(unsigned __int16)(*(_WORD *)&is_stdin[3] + *(_WORD *)&is_stdin[1]),\n        v6);\n      if ( print_namea )\n        printf(\" %s\", filea);\n      putchar_unlocked(10);\n      v17 = 1;\n    }\n    else\n    {\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filea);\n      v17 = 0;\n    }\n  }\n  return v17 & 1;\n}\n\n\n Revised code:\nstatic bool\nsysv_sum_file (const char *file, int print_name)\n{\n  int fd;\n  unsigned char buf[8192];\n  uintmax_t total_bytes = 0;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int r;\n  int checksum;\n\n  /* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n  unsigned int s = 0;\n\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fd = STDIN_FILENO;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while (1)\n    {\n      size_t i;\n      size_t bytes_read = safe_read (fd, buf, sizeof buf);\n\n      if (bytes_read == 0)\n\tbreak;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  if (!is_stdin)\n\t    close (fd);\n\t  return false;\n\t}\n\n      for (i = 0; i < bytes_read; i++)\n\ts += buf[i];\n      total_bytes += bytes_read;\n    }\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  checksum = (r & 0xffff) + (r >> 16);\n\n  printf (\"%d %s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 512));\n  if (print_name)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl recover_mode(const char *arg, termios *mode)\n{\n  unsigned __int64 lflag; // [rsp+10h] [rbp-50h] BYREF\n  unsigned __int64 cflag; // [rsp+18h] [rbp-48h] BYREF\n  unsigned __int64 oflag; // [rsp+20h] [rbp-40h] BYREF\n  unsigned __int64 iflag; // [rsp+28h] [rbp-38h] BYREF\n  unsigned __int64 chr; // [rsp+30h] [rbp-30h] BYREF\n  int n; // [rsp+3Ch] [rbp-24h] BYREF\n  size_t i; // [rsp+40h] [rbp-20h]\n  termios *modea; // [rsp+48h] [rbp-18h]\n  const char *arga; // [rsp+50h] [rbp-10h]\n\n  arga = arg;\n  modea = mode;\n  if ( sscanf(arg, \"%lx:%lx:%lx:%lx%n\", &iflag, &oflag, &cflag, &lflag, &n) == 4 )\n  {\n    modea->c_iflag = iflag;\n    modea->c_oflag = oflag;\n    modea->c_cflag = cflag;\n    modea->c_lflag = lflag;\n    if ( modea->c_iflag == iflag && modea->c_oflag == oflag && modea->c_cflag == cflag && modea->c_lflag == lflag )\n    {\n      arga += n;\n      for ( i = 0LL; i < 0x20; ++i )\n      {\n        if ( sscanf(arga, \":%lx%n\", &chr, &n) != 1 )\n          return 0;\n        modea->c_cc[i] = chr;\n        if ( modea->c_cc[i] != chr )\n          return 0;\n        arga += n;\n      }\n      return *arga == 0;\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  else\n  {\n    return 0;\n  }\n}\n\n\n Revised code:\nstatic bool\nrecover_mode (char const *arg, struct termios *mode)\n{\n  size_t i;\n  int n;\n  unsigned long int chr;\n  unsigned long int iflag, oflag, cflag, lflag;\n\n  /* Scan into temporaries since it is too much trouble to figure out\n     the right format for `tcflag_t'.  */\n  if (sscanf (arg, \"%lx:%lx:%lx:%lx%n\",\n\t      &iflag, &oflag, &cflag, &lflag, &n) != 4)\n    return false;\n  mode->c_iflag = iflag;\n  mode->c_oflag = oflag;\n  mode->c_cflag = cflag;\n  mode->c_lflag = lflag;\n  if (mode->c_iflag != iflag\n      || mode->c_oflag != oflag\n      || mode->c_cflag != cflag\n      || mode->c_lflag != lflag)\n    return false;\n  arg += n;\n  for (i = 0; i < NCCS; ++i)\n    {\n      if (sscanf (arg, \":%lx%n\", &chr, &n) != 1)\n\treturn false;\n      mode->c_cc[i] = chr;\n      if (mode->c_cc[i] != chr)\n\treturn false;\n      arg += n;\n    }\n\n  /* Fail if there are too many fields.  */\n  if (*arg != '\\0')\n    return false;\n\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid sub_4295F1()\n{\n  __off64_t v0; // [rsp+10h] [rbp-10h]\n  int v1; // [rsp+1Ch] [rbp-4h]\n\n  v1 = *(_DWORD *)qword_75D400;\n  if ( (int)(sub_40BCE2() - dest.c_cflag) >= 0\n    || !dest.c_oflag\n    || (v0 = sub_40A557(dest.c_oflag, 0LL, 1), v0 == *(_QWORD *)&dest.c_cc[7]) )\n  {\n    sub_4295B8(\"421 Timeout\\r\\n\");\n    exit(1);\n  }\n  *(_QWORD *)&dest.c_cc[7] = v0;\n  alarm(dest.c_lflag);\n  *(_DWORD *)qword_75D400 = v1;\n}\n",
        "output": "```c\nstatic void\nhandle_timeout()\n{\n  __off64_t current_time;\n  int previous_alarm;\n\n  previous_alarm = alarm_value;\n  current_time = get_current_time();\n\n  if ((current_time - last_activity_time) >= 0\n      || !timeout_interval\n      || (current_time = get_elapsed_time(last_activity_time, 0, 1),\n          current_time == last_checked_time))\n  {\n    send_response(\"421 Timeout\\r\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  last_checked_time = current_time;\n  alarm(timeout_interval);\n  alarm_value = previous_alarm;\n}\n```",
        "source_code": "static void\ntimeout_handler(int sig UNUSED_PARAM)\n{\n\toff_t pos;\n\tint sv_errno = errno;\n\n\tif ((int)(monotonic_sec() - G.end_time) >= 0)\n\t\tgoto timed_out;\n\n\tif (!G.local_file_fd)\n\t\tgoto timed_out;\n\n\tpos = xlseek(G.local_file_fd, 0, SEEK_CUR);\n\tif (pos == G.local_file_pos)\n\t\tgoto timed_out;\n\tG.local_file_pos = pos;\n\n\talarm(G.timeout);\n\terrno = sv_errno;\n\treturn;\n\n timed_out:\n\tcmdio_write_raw(STR(FTP_TIMEOUT)\" Timeout\\r\\n\");\n/* TODO: do we need to abort (as opposed to usual shutdown) data transfer? */\n\texit(1);\n}",
        "parsed_output": "static void\nhandle_timeout()\n{\n  __off64_t current_time;\n  int previous_alarm;\n\n  previous_alarm = alarm_value;\n  current_time = get_current_time();\n\n  if ((current_time - last_activity_time) >= 0\n      || !timeout_interval\n      || (current_time = get_elapsed_time(last_activity_time, 0, 1),\n          current_time == last_checked_time))\n  {\n    send_response(\"421 Timeout\\r\\n\");\n    exit(EXIT_FAILURE);\n  }\n\n  last_checked_time = current_time;\n  alarm(timeout_interval);\n  alarm_value = previous_alarm;\n}",
        "baseline_code_stripped": "void sub_4295F1()\n{\n  __off64_t v0; // [rsp+10h] [rbp-10h]\n  int v1; // [rsp+1Ch] [rbp-4h]\n\n  v1 = *(_DWORD *)qword_75D400;\n  if ( (int)(sub_40BCE2() - dest.c_cflag) >= 0\n    || !dest.c_oflag\n    || (v0 = sub_40A557(dest.c_oflag, 0LL, 1), v0 == *(_QWORD *)&dest.c_cc[7]) )\n  {\n    sub_4295B8(\"421 Timeout\\r\\n\");\n    exit(1);\n  }\n  *(_QWORD *)&dest.c_cc[7] = v0;\n  alarm(dest.c_lflag);\n  *(_DWORD *)qword_75D400 = v1;\n}\n",
        "baseline_code_debug": "void __cdecl timeout_handler(int sig)\n{\n  off_t pos; // [rsp+10h] [rbp-10h]\n  int sv_errno; // [rsp+1Ch] [rbp-4h]\n\n  sv_errno = *bb_errno;\n  if ( (int)(monotonic_sec() - bb_common_bufsiz1.c_cflag) >= 0\n    || !bb_common_bufsiz1.c_oflag\n    || (pos = xlseek(bb_common_bufsiz1.c_oflag, 0LL, 1), pos == *(_QWORD *)&bb_common_bufsiz1.c_cc[7]) )\n  {\n    cmdio_write_raw(\"421 Timeout\\r\\n\");\n    exit(1);\n  }\n  *(_QWORD *)&bb_common_bufsiz1.c_cc[7] = pos;\n  alarm(bb_common_bufsiz1.c_lflag);\n  *bb_errno = sv_errno;\n}\n",
        "similarity_score_unixcoder": 0.657428503036499,
        "similarity_score_baseline_stripped": 0.4990291893482208,
        "similarity_score_baseline_debug": 0.6576257348060608
    },
    {
        "func_name": "open_as_user",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl send_signals(int signum, char *const *argv)\n{\n  pid_t v2; // eax\n  char *v3; // rax\n  int *v4; // rax\n  char *const *v5; // rax\n  pid_t pid; // [rsp+Ch] [rbp-34h]\n  intmax_t n; // [rsp+10h] [rbp-30h]\n  char *endp; // [rsp+18h] [rbp-28h] BYREF\n  const char *arg; // [rsp+20h] [rbp-20h]\n  int status; // [rsp+2Ch] [rbp-14h]\n  char *const *argva; // [rsp+30h] [rbp-10h]\n  int signuma; // [rsp+3Ch] [rbp-4h]\n\n  signuma = signum;\n  argva = argv;\n  status = 0;\n  arg = *argv;\n  do\n  {\n    *__errno_location() = 0;\n    v2 = strtoimax(arg, &endp, 10);\n    n = v2;\n    pid = v2;\n    if ( *__errno_location() == 34 || pid != n || arg == endp || *endp )\n    {\n      v3 = gettext(\"%s: invalid process id\");\n      error(0, 0, v3, arg);\n      status = 1;\n    }\n    else if ( kill(pid, signuma) )\n    {\n      v4 = __errno_location();\n      error(0, *v4, \"%s\", arg);\n      status = 1;\n    }\n    v5 = argva++;\n    arg = (const char *)*((_QWORD *)v5 + 1);\n  }\n  while ( arg );\n  return status;\n}\n\n\n Revised code:\nstatic int\nsend_signals (int signum, char *const *argv)\n{\n  int status = EXIT_SUCCESS;\n  char const *arg = *argv;\n\n  do\n    {\n      char *endp;\n      intmax_t n = (errno = 0, strtoimax (arg, &endp, 10));\n      pid_t pid = n;\n\n      if (errno == ERANGE || pid != n || arg == endp || *endp)\n\t{\n\t  error (0, 0, _(\"%s: invalid process id\"), arg);\n\t  status = EXIT_FAILURE;\n\t}\n      else if (kill (pid, signum) != 0)\n\t{\n\t  error (0, errno, \"%s\", arg);\n\t  status = EXIT_FAILURE;\n\t}\n    }\n  while ((arg = *++argv));\n\n  return status;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl strip(const char *name)\n{\n  char *v1; // rax\n  char *v2; // rax\n  char *v3; // rax\n  int v4; // [rsp+4h] [rbp-2Ch]\n  int errnum; // [rsp+Ch] [rbp-24h]\n  pid_t pid; // [rsp+20h] [rbp-10h]\n  int status; // [rsp+24h] [rbp-Ch] BYREF\n  const char *namea; // [rsp+28h] [rbp-8h]\n\n  namea = name;\n  pid = fork();\n  if ( pid == -1 )\n  {\n    errnum = *__errno_location();\n    v1 = gettext(\"fork system call failed\");\n    error(1, errnum, v1);\n  }\n  else if ( pid )\n  {\n    while ( pid != wait((__WAIT_STATUS)&status) )\n      ;\n    if ( status )\n    {\n      v3 = gettext(\"strip failed\");\n      error(1, 0, v3);\n    }\n  }\n  else\n  {\n    execlp(\"strip\", \"strip\", namea, 0LL);\n    v4 = *__errno_location();\n    v2 = gettext(\"cannot run strip\");\n    error(1, v4, v2);\n  }\n}\n\n\n Revised code:\nstatic void\nstrip (char const *name)\n{\n  int status;\n  pid_t pid = fork ();\n\n  switch (pid)\n    {\n    case -1:\n      error (EXIT_FAILURE, errno, _(\"fork system call failed\"));\n      break;\n    case 0:\t\t\t/* Child. */\n      execlp (\"strip\", \"strip\", name, NULL);\n      error (EXIT_FAILURE, errno, _(\"cannot run strip\"));\n      break;\n    default:\t\t\t/* Parent. */\n      /* Parent process. */\n      while (pid != wait (&status))\t/* Wait for kid to finish. */\n\t/* Do nothing. */ ;\n      if (status)\n\terror (EXIT_FAILURE, 0, _(\"strip failed\"));\n      break;\n    }\n}\n\n## Example:\n\n Input code:\nbool __cdecl sysv_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  int *v5; // rax\n  char *v6; // rax\n  size_t bytes_read; // [rsp+20h] [rbp-22E0h]\n  size_t i; // [rsp+28h] [rbp-22D8h]\n  _BYTE is_stdin[5]; // [rsp+33h] [rbp-22CDh]\n  char hbuf[652]; // [rsp+40h] [rbp-22C0h] BYREF\n  uintmax_t total_bytes; // [rsp+2D8h] [rbp-2028h]\n  unsigned __int8 buf[8192]; // [rsp+2E0h] [rbp-2020h] BYREF\n  int fd; // [rsp+22E8h] [rbp-18h]\n  int print_namea; // [rsp+22ECh] [rbp-14h]\n  const char *filea; // [rsp+22F0h] [rbp-10h]\n  char v17; // [rsp+22FFh] [rbp-1h]\n\n  filea = file;\n  print_namea = print_name;\n  total_bytes = 0LL;\n  is_stdin[4] = 0;\n  v2 = strcmp(file, \"-\");\n  *(_DWORD *)is_stdin = v2 == 0;\n  if ( !v2 )\n  {\n    fd = 0;\n    have_read_stdin = 1;\n    goto LABEL_5;\n  }\n  fd = open(filea, 0);\n  if ( fd == -1 )\n  {\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    v17 = 0;\n  }\n  else\n  {\nLABEL_5:\n    while ( 1 )\n    {\n      bytes_read = safe_read(fd, buf, 0x2000uLL);\n      if ( !bytes_read )\n        break;\n      if ( bytes_read == -1LL )\n      {\n        v4 = __errno_location();\n        error(0, *v4, \"%s\", filea);\n        if ( (is_stdin[0] & 1) == 0 )\n          close(fd);\n        v17 = 0;\n        return v17 & 1;\n      }\n      for ( i = 0LL; i < bytes_read; ++i )\n        *(_DWORD *)&is_stdin[1] += buf[i];\n      total_bytes += bytes_read;\n    }\n    if ( (is_stdin[0] & 1) != 0 || !close(fd) )\n    {\n      v6 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x200uLL);\n      printf(\n        \"%d %s\",\n        ((HIWORD(*(_DWORD *)&is_stdin[1]) + *(unsigned __int16 *)&is_stdin[1]) >> 16)\n      + (unsigned int)(unsigned __int16)(*(_WORD *)&is_stdin[3] + *(_WORD *)&is_stdin[1]),\n        v6);\n      if ( print_namea )\n        printf(\" %s\", filea);\n      putchar_unlocked(10);\n      v17 = 1;\n    }\n    else\n    {\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filea);\n      v17 = 0;\n    }\n  }\n  return v17 & 1;\n}\n\n\n Revised code:\nstatic bool\nsysv_sum_file (const char *file, int print_name)\n{\n  int fd;\n  unsigned char buf[8192];\n  uintmax_t total_bytes = 0;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int r;\n  int checksum;\n\n  /* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n  unsigned int s = 0;\n\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fd = STDIN_FILENO;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while (1)\n    {\n      size_t i;\n      size_t bytes_read = safe_read (fd, buf, sizeof buf);\n\n      if (bytes_read == 0)\n\tbreak;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  if (!is_stdin)\n\t    close (fd);\n\t  return false;\n\t}\n\n      for (i = 0; i < bytes_read; i++)\n\ts += buf[i];\n      total_bytes += bytes_read;\n    }\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  checksum = (r & 0xffff) + (r >> 16);\n\n  printf (\"%d %s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 512));\n  if (print_name)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_415BB6(__int64 a1, const char *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  int v7; // eax\n  ssize_t v8; // rax\n  char v9; // [rsp+17h] [rbp-9h] BYREF\n  __pid_t v10; // [rsp+18h] [rbp-8h]\n  __pid_t v11; // [rsp+1Ch] [rbp-4h]\n\n  v11 = vfork();\n  if ( v11 < 0 )\n    sub_4092A2((__int64)\"vfork\", (__int64)a2, v2, v3, v4, v5);\n  v10 = v11;\n  if ( !v11 )\n  {\n    sub_4F6569(a1);\n    v7 = sub_40A295(a2, 0);\n    v8 = sub_40B3FF(v7, &v9, 1uLL);\n    _exit(v8 < 0);\n  }\n  if ( (unsigned int)sub_409FAE(v10) )\n    return -1;\n  else\n    return open64(a2, 0);\n}\n",
        "output": "```c\nstatic int\nsub_415BB6 (int file_descriptor, const char *file_path)\n{\n  pid_t child_pid;\n  pid_t wait_pid;\n  int exit_status;\n  char single_byte;\n  ssize_t read_result;\n\n  child_pid = vfork();\n  if (child_pid < 0)\n    {\n      error_handling_function(\"vfork\", file_path);\n    }\n\n  if (child_pid == 0) // Child process\n    {\n      close_file_descriptors(file_descriptor);\n      int fd = open_file(file_path, O_RDONLY);\n      read_result = read_from_file(fd, &single_byte, 1);\n      _exit(read_result < 0); // Exit with failure if read is unsuccessful\n    }\n\n  wait_pid = wait_for_child(child_pid);\n  if (wait_pid == -1)\n    {\n      return -1; // Error occurred while waiting for child process\n    }\n  else\n    {\n      return open_file(file_path, O_RDONLY); // Open file for reading and return file descriptor\n    }\n}\n```",
        "source_code": "static int open_as_user(const struct passwd *pas, const char *file)\n{\n\tpid_t pid;\n\tchar c;\n\n\tpid = xvfork();\n\tif (pid) { /* PARENT */\n\t\tif (wait4pid(pid) == 0) {\n\t\t\t/* exitcode 0: child says it can read */\n\t\t\treturn open(file, O_RDONLY);\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/* CHILD */\n\t/* initgroups, setgid, setuid */\n\tchange_identity(pas);\n\t/* We just try to read one byte. If it works, file is readable\n\t * under this user. We signal that by exiting with 0. */\n\t_exit(safe_read(xopen(file, O_RDONLY), &c, 1) < 0);\n}",
        "parsed_output": "static int\nsub_415BB6 (int file_descriptor, const char *file_path)\n{\n  pid_t child_pid;\n  pid_t wait_pid;\n  int exit_status;\n  char single_byte;\n  ssize_t read_result;\n\n  child_pid = vfork();\n  if (child_pid < 0)\n    {\n      error_handling_function(\"vfork\", file_path);\n    }\n\n  if (child_pid == 0) // Child process\n    {\n      close_file_descriptors(file_descriptor);\n      int fd = open_file(file_path, O_RDONLY);\n      read_result = read_from_file(fd, &single_byte, 1);\n      _exit(read_result < 0); // Exit with failure if read is unsuccessful\n    }\n\n  wait_pid = wait_for_child(child_pid);\n  if (wait_pid == -1)\n    {\n      return -1; // Error occurred while waiting for child process\n    }\n  else\n    {\n      return open_file(file_path, O_RDONLY); // Open file for reading and return file descriptor\n    }\n}",
        "baseline_code_stripped": "int __fastcall sub_415BB6(__int64 a1, const char *a2)\n{\n  __int64 v2; // rdx\n  __int64 v3; // rcx\n  __int64 v4; // r8\n  __int64 v5; // r9\n  int v7; // eax\n  ssize_t v8; // rax\n  char v9; // [rsp+17h] [rbp-9h] BYREF\n  __pid_t v10; // [rsp+18h] [rbp-8h]\n  __pid_t v11; // [rsp+1Ch] [rbp-4h]\n\n  v11 = vfork();\n  if ( v11 < 0 )\n    sub_4092A2((__int64)\"vfork\", (__int64)a2, v2, v3, v4, v5);\n  v10 = v11;\n  if ( !v11 )\n  {\n    sub_4F6569(a1);\n    v7 = sub_40A295(a2, 0);\n    v8 = sub_40B3FF(v7, &v9, 1uLL);\n    _exit(v8 < 0);\n  }\n  if ( (unsigned int)sub_409FAE(v10) )\n    return -1;\n  else\n    return open64(a2, 0);\n}\n",
        "baseline_code_debug": "int __cdecl open_as_user(const passwd *pas, const char *file)\n{\n  int v3; // eax\n  ssize_t v4; // rax\n  char c; // [rsp+17h] [rbp-9h] BYREF\n  pid_t pid; // [rsp+18h] [rbp-8h]\n  pid_t bb__xvfork_pid; // [rsp+1Ch] [rbp-4h]\n\n  bb__xvfork_pid = vfork();\n  if ( bb__xvfork_pid < 0 )\n    bb_perror_msg_and_die(\"vfork\");\n  pid = bb__xvfork_pid;\n  if ( !bb__xvfork_pid )\n  {\n    change_identity(pas);\n    v3 = xopen(file, 0);\n    v4 = safe_read(v3, &c, 1uLL);\n    _exit(v4 < 0);\n  }\n  if ( wait4pid(pid) )\n    return -1;\n  else\n    return open64(file, 0);\n}\n",
        "similarity_score_unixcoder": 0.7791153788566589,
        "similarity_score_baseline_stripped": 0.6169637441635132,
        "similarity_score_baseline_debug": 0.8045257925987244
    },
    {
        "func_name": "eval4",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  unsigned __int8 *v3; // rax\n  const char *v4; // rdi\n  char buf[5]; // [rsp+33h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+38h] [rbp-38h]\n  unsigned __int8 c; // [rsp+47h] [rbp-29h]\n  size_t i; // [rsp+48h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+50h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+58h] [rbp-18h]\n  const void *blocka; // [rsp+60h] [rbp-10h]\n  size_t n_bytesa; // [rsp+68h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = (unsigned __int8 *)p++;\n    c = *v3;\n    switch ( c )\n    {\n      case 0u:\n        s = \" \\\\0\";\n        break;\n      case 7u:\n        s = (const char *)&unk_409AA8;\n        break;\n      case 8u:\n        s = (const char *)&unk_409AAC;\n        break;\n      case 9u:\n        s = (const char *)&unk_409ABC;\n        break;\n      case 0xAu:\n        s = (const char *)&unk_409AB4;\n        break;\n      case 0xBu:\n        s = (const char *)&unk_409AC0;\n        break;\n      case 0xCu:\n        s = (const char *)&unk_409AB0;\n        break;\n      case 0xDu:\n        s = (const char *)&unk_409AB8;\n        break;\n      default:\n        v4 = \"%03o\";\n        if ( ((*__ctype_b_loc())[c] & 0x4000) != 0 )\n          v4 = \"  %c\";\n        sprintf(buf, v4, c);\n        s = buf;\n        break;\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_ascii (size_t n_bytes, void const *block,\n\t     const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      unsigned char c = *p++;\n      const char *s;\n      char buf[5];\n\n      switch (c)\n\t{\n\tcase '\\0':\n\t  s = \" \\\\0\";\n\t  break;\n\n\tcase '\\a':\n\t  s = \" \\\\a\";\n\t  break;\n\n\tcase '\\b':\n\t  s = \" \\\\b\";\n\t  break;\n\n\tcase '\\f':\n\t  s = \" \\\\f\";\n\t  break;\n\n\tcase '\\n':\n\t  s = \" \\\\n\";\n\t  break;\n\n\tcase '\\r':\n\t  s = \" \\\\r\";\n\t  break;\n\n\tcase '\\t':\n\t  s = \" \\\\t\";\n\t  break;\n\n\tcase '\\v':\n\t  s = \" \\\\v\";\n\t  break;\n\n\tdefault:\n\t  sprintf (buf, (isprint (c) ? \"  %c\" : \"%03o\"), c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid **__fastcall sub_4C9C06(const char *a1, void **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  const char *v6; // rdi\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  __int64 v11; // [rsp+0h] [rbp-20h]\n  int v12; // [rsp+14h] [rbp-Ch]\n  void **i; // [rsp+18h] [rbp-8h]\n\n  for ( i = sub_4C9B90(a1, a2, a3, a4, a5, a6); ; i = (void **)sub_4C92AB(v11, (__int64)a2) )\n  {\n    v6 = \"*\";\n    v12 = sub_4C947A(\"*\");\n    if ( !v12 )\n    {\n      v6 = \"/\";\n      v12 = sub_4C947A(\"/\");\n      if ( !v12 )\n      {\n        v6 = \"%\";\n        v12 = sub_4C947A(\"%\");\n        if ( !v12 )\n          break;\n      }\n    }\n    *(_QWORD *)&dest.c_iflag += 8LL;\n    a2 = sub_4C9B90(v6, a2, *(__int64 *)&dest.c_iflag, v7, v8, v9);\n    v11 = sub_4C95DD((__int64)i, (__int64)a2, v12);\n    sub_4C9315(i);\n    sub_4C9315(a2);\n  }\n  return i;\n}\n",
        "output": "```c\nstatic void **\nfind_and_replace_special_chars(const char *input_str, void **output_array,\n                               __int64 arg3, __int64 arg4, __int64 arg5, __int64 arg6)\n{\n  const char *special_char;\n  __int64 special_char_len;\n  void **current_output;\n\n  current_output = initial_processing(input_str, output_array, arg3, arg4, arg5, arg6);\n\n  while (true)\n  {\n    special_char = \"*\";\n    special_char_len = get_length(special_char);\n    if (!special_char_len)\n    {\n      special_char = \"/\";\n      special_char_len = get_length(special_char);\n      if (!special_char_len)\n      {\n        special_char = \"%\";\n        special_char_len = get_length(special_char);\n        if (!special_char_len)\n          break;\n      }\n    }\n\n    increment_dest_offset(8);\n    output_array = initial_processing(special_char, output_array, get_dest_offset(), arg3, arg4, arg5);\n\n    __int64 replacement_result = replace_sequence(current_output, output_array, special_char_len);\n    free_memory(current_output);\n    free_memory(output_array);\n\n    current_output = (void **)replacement_result;\n  }\n\n  return current_output;\n}\n```",
        "source_code": "static VALUE *eval4(void)\n{\n\tVALUE *l, *r;\n\tint op;\n\tarith_t val;\n\n\tl = eval5();\n\twhile (1) {\n\t\top = nextarg(\"*\");\n\t\tif (!op) { op = nextarg(\"/\");\n\t\t if (!op) { op = nextarg(\"%\");\n\t\t  if (!op) return l;\n\t\t}}\n\t\tG.args++;\n\t\tr = eval5();\n\t\tval = arithmetic_common(l, r, op);\n\t\tfreev(l);\n\t\tfreev(r);\n\t\tl = int_value(val);\n\t}\n}",
        "parsed_output": "static void **\nfind_and_replace_special_chars(const char *input_str, void **output_array,\n                               __int64 arg3, __int64 arg4, __int64 arg5, __int64 arg6)\n{\n  const char *special_char;\n  __int64 special_char_len;\n  void **current_output;\n\n  current_output = initial_processing(input_str, output_array, arg3, arg4, arg5, arg6);\n\n  while (true)\n  {\n    special_char = \"*\";\n    special_char_len = get_length(special_char);\n    if (!special_char_len)\n    {\n      special_char = \"/\";\n      special_char_len = get_length(special_char);\n      if (!special_char_len)\n      {\n        special_char = \"%\";\n        special_char_len = get_length(special_char);\n        if (!special_char_len)\n          break;\n      }\n    }\n\n    increment_dest_offset(8);\n    output_array = initial_processing(special_char, output_array, get_dest_offset(), arg3, arg4, arg5);\n\n    __int64 replacement_result = replace_sequence(current_output, output_array, special_char_len);\n    free_memory(current_output);\n    free_memory(output_array);\n\n    current_output = (void **)replacement_result;\n  }\n\n  return current_output;\n}",
        "baseline_code_stripped": "void **__fastcall sub_4C9C06(const char *a1, void **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  const char *v6; // rdi\n  __int64 v7; // rcx\n  __int64 v8; // r8\n  __int64 v9; // r9\n  __int64 v11; // [rsp+0h] [rbp-20h]\n  int v12; // [rsp+14h] [rbp-Ch]\n  void **i; // [rsp+18h] [rbp-8h]\n\n  for ( i = sub_4C9B90(a1, a2, a3, a4, a5, a6); ; i = (void **)sub_4C92AB(v11, (__int64)a2) )\n  {\n    v6 = \"*\";\n    v12 = sub_4C947A(\"*\");\n    if ( !v12 )\n    {\n      v6 = \"/\";\n      v12 = sub_4C947A(\"/\");\n      if ( !v12 )\n      {\n        v6 = \"%\";\n        v12 = sub_4C947A(\"%\");\n        if ( !v12 )\n          break;\n      }\n    }\n    *(_QWORD *)&dest.c_iflag += 8LL;\n    a2 = sub_4C9B90(v6, a2, *(__int64 *)&dest.c_iflag, v7, v8, v9);\n    v11 = sub_4C95DD((__int64)i, (__int64)a2, v12);\n    sub_4C9315(i);\n    sub_4C9315(a2);\n  }\n  return i;\n}\n",
        "baseline_code_debug": "VALUE *__cdecl eval4()\n{\n  arith_t_0 val; // [rsp+0h] [rbp-20h]\n  VALUE *r; // [rsp+8h] [rbp-18h]\n  int op; // [rsp+14h] [rbp-Ch]\n  VALUE *l; // [rsp+18h] [rbp-8h]\n\n  for ( l = eval5(); ; l = int_value(val) )\n  {\n    op = nextarg(\"*\");\n    if ( !op )\n    {\n      op = nextarg(\"/\");\n      if ( !op )\n      {\n        op = nextarg(\"%\");\n        if ( !op )\n          break;\n      }\n    }\n    *(_QWORD *)&bb_common_bufsiz1.c_iflag += 8LL;\n    r = eval5();\n    val = arithmetic_common(l, r, op);\n    freev(l);\n    freev(r);\n  }\n  return l;\n}\n",
        "similarity_score_unixcoder": 0.46459561586380005,
        "similarity_score_baseline_stripped": 0.5682089328765869,
        "similarity_score_baseline_debug": 0.7493178844451904
    },
    {
        "func_name": "pipe_progress_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl do_decode(FILE *in, FILE *out, bool ignore_garbage)\n{\n  char *v3; // rax\n  size_t v4; // rax\n  char *v5; // rax\n  char *v6; // rax\n  int v7; // [rsp+Ch] [rbp-1C64h]\n  char v8; // [rsp+13h] [rbp-1C5Dh]\n  int errnum; // [rsp+14h] [rbp-1C5Ch]\n  bool v10; // [rsp+27h] [rbp-1C49h]\n  size_t v11; // [rsp+30h] [rbp-1C40h]\n  size_t outlen; // [rsp+38h] [rbp-1C38h] BYREF\n  bool v13; // [rsp+47h] [rbp-1C29h]\n  size_t inlen; // [rsp+48h] [rbp-1C28h]\n  char outa[3072]; // [rsp+50h] [rbp-1C20h] BYREF\n  char ina[4111]; // [rsp+C50h] [rbp-1020h] BYREF\n  bool v17; // [rsp+1C5Fh] [rbp-11h]\n  FILE *v18; // [rsp+1C60h] [rbp-10h]\n  FILE *v19; // [rsp+1C68h] [rbp-8h]\n\n  v19 = in;\n  v18 = out;\n  v17 = ignore_garbage;\n  do\n  {\n    inlen = 0LL;\n    do\n    {\n      outlen = fread_unlocked(&ina[inlen], 1uLL, 4096 - inlen, v19);\n      if ( v17 )\n      {\n        v11 = 0LL;\n        while ( 1 )\n        {\n          v10 = 0;\n          if ( outlen )\n            v10 = v11 < outlen;\n          if ( !v10 )\n            break;\n          if ( isbase64(ina[v11 + inlen]) || ina[v11 + inlen] == 61 )\n            ++v11;\n          else\n            memmove(&ina[inlen + v11], &ina[inlen + 1 + v11], --outlen - v11);\n        }\n      }\n      inlen += outlen;\n      if ( ferror_unlocked(v19) )\n      {\n        errnum = *__errno_location();\n        v3 = gettext(\"read error\");\n        error(1, errnum, v3);\n      }\n      v8 = 0;\n      if ( inlen < 0x1000 )\n        v8 = ~(feof_unlocked(v19) != 0);\n    }\n    while ( (v8 & 1) != 0 );\n    outlen = 3072LL;\n    v13 = base64_decode(ina, inlen, outa, &outlen);\n    v4 = fwrite_unlocked(outa, 1uLL, outlen, v18);\n    if ( v4 < outlen )\n    {\n      v7 = *__errno_location();\n      v5 = gettext(\"write error\");\n      error(1, v7, v5);\n    }\n    if ( !v13 )\n    {\n      v6 = gettext(\"invalid input\");\n      error(1, 0, v6);\n    }\n  }\n  while ( !feof_unlocked(v19) );\n}\n\n\n Revised code:\nstatic void\ndo_decode (FILE *in, FILE *out, bool ignore_garbage)\n{\n  char inbuf[B64BLOCKSIZE];\n  char outbuf[BLOCKSIZE];\n  size_t sum;\n\n  do\n    {\n      bool ok;\n      size_t n;\n\n      sum = 0;\n      do\n\t{\n\t  n = fread (inbuf + sum, 1, B64BLOCKSIZE - sum, in);\n\n\t  if (ignore_garbage)\n\t    {\n\t      size_t i;\n\t      for (i = 0; n > 0 && i < n;)\n\t\tif (isbase64 (inbuf[sum + i]) || inbuf[sum + i] == '=')\n\t\t  i++;\n\t\telse\n\t\t  memmove (inbuf + sum + i, inbuf + sum + i + 1, --n - i);\n\t    }\n\n\t  sum += n;\n\n\t  if (ferror (in))\n\t    error (EXIT_FAILURE, errno, _(\"read error\"));\n\t}\n      while (sum < B64BLOCKSIZE && !feof (in));\n\n      n = BLOCKSIZE;\n      ok = base64_decode (inbuf, sum, outbuf, &n);\n\n      if (fwrite (outbuf, 1, n, out) < n)\n\terror (EXIT_FAILURE, errno, _(\"write error\"));\n\n      if (!ok)\n\terror (EXIT_FAILURE, 0, _(\"invalid input\"));\n    }\n  while (!feof (in));\n}\n\n## Example:\n\n Input code:\nint __cdecl long_time_expected_width()\n{\n  size_t len; // [rsp+8h] [rbp-408h]\n  char buf[1001]; // [rsp+10h] [rbp-400h] BYREF\n  const tm *tm; // [rsp+400h] [rbp-10h]\n  time_t epoch; // [rsp+408h] [rbp-8h] BYREF\n\n  if ( long_time_expected_width_width < 0 )\n  {\n    epoch = 0LL;\n    tm = localtime(&epoch);\n    if ( tm )\n    {\n      len = nstrftime(buf, 0x3E9uLL, long_time_format[0], tm, 0, 0);\n      if ( len )\n        long_time_expected_width_width = mbsnwidth(buf, len, 0);\n    }\n    if ( long_time_expected_width_width < 0 )\n      long_time_expected_width_width = 0;\n  }\n  return long_time_expected_width_width;\n}\n\n\n Revised code:\nstatic int\nlong_time_expected_width (void)\n{\n  static int width = -1;\n\n  if (width < 0)\n    {\n      time_t epoch = 0;\n      struct tm const *tm = localtime (&epoch);\n      char buf[TIME_STAMP_LEN_MAXIMUM + 1];\n\n      /* In case you're wondering if localtime can fail with an input time_t\n\t value of 0, let's just say it's very unlikely, but not inconceivable.\n\t The TZ environment variable would have to specify a time zone that\n\t is 2**31-1900 years or more ahead of UTC.  This could happen only on\n\t a 64-bit system that blindly accepts e.g., TZ=UTC+20000000000000.\n\t However, this is not possible with Solaris 10 or glibc-2.3.5, since\n\t their implementations limit the offset to 167:59 and 24:00, resp.  */\n      if (tm)\n\t{\n\t  size_t len =\n\t    nstrftime (buf, sizeof buf, long_time_format[0], tm, 0, 0);\n\t  if (len != 0)\n\t    width = mbsnwidth (buf, len, 0);\n\t}\n\n      if (width < 0)\n\twidth = 0;\n    }\n\n  return width;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_4D8DE0()\n{\n  char v1[4104]; // [rsp+10h] [rbp-1020h] BYREF\n  time_t v2; // [rsp+1018h] [rbp-18h]\n  int v3; // [rsp+1024h] [rbp-Ch]\n  time_t v4; // [rsp+1028h] [rbp-8h]\n\n  v4 = time(0LL);\n  while ( 1 )\n  {\n    v3 = sub_40B3FF(0, v1, 0x1000uLL);\n    if ( v3 <= 0 )\n      break;\n    v2 = time(0LL);\n    if ( v2 != v4 )\n    {\n      v4 = v2;\n      sub_409D89(46);\n    }\n    sub_40B38A(1u, (__int64)v1, v3);\n  }\n  sub_409D89(10);\n  return 0LL;\n}\n",
        "output": "```c\nstatic void\nlog_activity_with_timestamps(void)\n{\n  char buffer[4096];\n  time_t last_timestamp;\n  int bytes_read;\n  time_t current_timestamp;\n\n  last_timestamp = time(NULL);\n  while (1)\n  {\n    bytes_read = read_input(0, buffer, sizeof(buffer));\n    if (bytes_read <= 0)\n      break;\n    current_timestamp = time(NULL);\n    if (current_timestamp != last_timestamp)\n    {\n      last_timestamp = current_timestamp;\n      print_character('.');\n    }\n    write_output(1, buffer, bytes_read);\n  }\n  print_character('\\n');\n}\n```",
        "source_code": "int pipe_progress_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)\n{\n\tchar buf[PIPE_PROGRESS_SIZE];\n\ttime_t t = time(NULL);\n\tint len;\n\n\twhile ((len = safe_read(STDIN_FILENO, buf, PIPE_PROGRESS_SIZE)) > 0) {\n\t\ttime_t new_time = time(NULL);\n\t\tif (new_time != t) {\n\t\t\tt = new_time;\n\t\t\tbb_putchar_stderr('.');\n\t\t}\n\t\tfull_write(STDOUT_FILENO, buf, len);\n\t}\n\n\tbb_putchar_stderr('\\n');\n\n\treturn 0;\n}",
        "parsed_output": "static void\nlog_activity_with_timestamps(void)\n{\n  char buffer[4096];\n  time_t last_timestamp;\n  int bytes_read;\n  time_t current_timestamp;\n\n  last_timestamp = time(NULL);\n  while (1)\n  {\n    bytes_read = read_input(0, buffer, sizeof(buffer));\n    if (bytes_read <= 0)\n      break;\n    current_timestamp = time(NULL);\n    if (current_timestamp != last_timestamp)\n    {\n      last_timestamp = current_timestamp;\n      print_character('.');\n    }\n    write_output(1, buffer, bytes_read);\n  }\n  print_character('\\n');\n}",
        "baseline_code_stripped": "__int64 sub_4D8DE0()\n{\n  char v1[4104]; // [rsp+10h] [rbp-1020h] BYREF\n  time_t v2; // [rsp+1018h] [rbp-18h]\n  int v3; // [rsp+1024h] [rbp-Ch]\n  time_t v4; // [rsp+1028h] [rbp-8h]\n\n  v4 = time(0LL);\n  while ( 1 )\n  {\n    v3 = sub_40B3FF(0, v1, 0x1000uLL);\n    if ( v3 <= 0 )\n      break;\n    v2 = time(0LL);\n    if ( v2 != v4 )\n    {\n      v4 = v2;\n      sub_409D89(46);\n    }\n    sub_40B38A(1u, (__int64)v1, v3);\n  }\n  sub_409D89(10);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl pipe_progress_main(int argc, char **argv)\n{\n  char buf[4096]; // [rsp+10h] [rbp-1020h] BYREF\n  time_t new_time; // [rsp+1018h] [rbp-18h]\n  int len; // [rsp+1024h] [rbp-Ch]\n  time_t t; // [rsp+1028h] [rbp-8h]\n\n  t = time(0LL);\n  while ( 1 )\n  {\n    len = safe_read(0, buf, 0x1000uLL);\n    if ( len <= 0 )\n      break;\n    new_time = time(0LL);\n    if ( new_time != t )\n    {\n      t = new_time;\n      bb_putchar_stderr(46);\n    }\n    full_write(1, buf, len);\n  }\n  bb_putchar_stderr(10);\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.6885826587677002,
        "similarity_score_baseline_stripped": 0.45870086550712585,
        "similarity_score_baseline_debug": 0.8111569881439209
    },
    {
        "func_name": "get_uptime",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl get_current_time()\n{\n  timeval timeval; // [rsp+10h] [rbp-20h] BYREF\n  timespec timespec; // [rsp+20h] [rbp-10h] BYREF\n\n  if ( clock_gettime(0, &timespec) )\n  {\n    gettimeofday(&timeval, 0LL);\n    current_time = timeval.tv_sec;\n    current_time_ns = 1000 * LODWORD(timeval.tv_usec) + 999;\n  }\n  else\n  {\n    current_time = timespec.tv_sec;\n    current_time_ns = timespec.tv_nsec;\n  }\n}\n\n\n Revised code:\nstatic void\nget_current_time (void)\n{\n#if HAVE_CLOCK_GETTIME && defined CLOCK_REALTIME\n  {\n    struct timespec timespec;\n    if (clock_gettime (CLOCK_REALTIME, &timespec) == 0)\n      {\n\tcurrent_time = timespec.tv_sec;\n\tcurrent_time_ns = timespec.tv_nsec;\n\treturn;\n      }\n  }\n#endif\n\n  /* The clock does not have nanosecond resolution, so get the maximum\n     possible value for the current time that is consistent with the\n     reported clock.  That way, files are not considered to be in the\n     future merely because their time stamps have higher resolution\n     than the clock resolution.  */\n\n#if HAVE_GETTIMEOFDAY\n  {\n    struct timeval timeval;\n    gettimeofday (&timeval, NULL);\n    current_time = timeval.tv_sec;\n    current_time_ns = timeval.tv_usec * 1000 + 999;\n  }\n#else\n  current_time = time (NULL);\n  current_time_ns = 999999999;\n#endif\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl get_format_prec(char **format_ptr)\n{\n  char *v1; // rax\n  unsigned __int64 val; // [rsp+8h] [rbp-18h] BYREF\n  char **format_ptra; // [rsp+10h] [rbp-10h]\n\n  format_ptra = format_ptr;\n  if ( **format_ptr != 46 )\n    return 0LL;\n  if ( (unsigned int)(*++*format_ptra - 48) > 9 )\n    return 0LL;\n  if ( xstrtoul(*format_ptra, format_ptra, 10, &val, 0LL) )\n  {\n    v1 = gettext(\"invalid format precision\");\n    error(1, 0, v1);\n  }\n  return val;\n}\n\n\n Revised code:\nstatic size_t\nget_format_prec (char **format_ptr)\n{\n  if (**format_ptr != '.')\n    return 0;\n  (*format_ptr)++;\n\n  if (! ISDIGIT (**format_ptr))\n    return 0;\n  else\n    {\n      unsigned long int val;\n      if (xstrtoul (*format_ptr, format_ptr, 10, &val, NULL) != LONGINT_OK\n\t  || SIZE_MAX < val)\n\terror (EXIT_FAILURE, 0, _(\"invalid format precision\"));\n      return val;\n    }\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_login(const STRUCT_UTMP *utmp_ent)\n{\n  const char *v1; // rax\n  const char *line; // [rsp+40h] [rbp-30h]\n  char pidstr[12]; // [rsp+4Ch] [rbp-24h] BYREF\n  char *comment; // [rsp+58h] [rbp-18h]\n  const STRUCT_UTMP *utmp_enta; // [rsp+60h] [rbp-10h]\n\n  utmp_enta = utmp_ent;\n  comment = make_id_equals_comment(utmp_ent);\n  sprintf(pidstr, \"%ld\", utmp_ent->ut_pid);\n  line = utmp_enta->ut_line;\n  v1 = time_string(utmp_enta);\n  print_line(-1, \"LOGIN\", 32, 32, line, v1, \"\", pidstr, comment, \"\");\n  free(comment);\n}\n\n\n Revised code:\nstatic void\nprint_login (const STRUCT_UTMP *utmp_ent)\n{\n  char *comment = make_id_equals_comment (utmp_ent);\n  PIDSTR_DECL_AND_INIT (pidstr, utmp_ent);\n\n  /* FIXME: add idle time? */\n\n  print_line (-1, \"LOGIN\", ' ', sizeof utmp_ent->ut_line, utmp_ent->ut_line,\n\t      time_string (utmp_ent), \"\", pidstr, comment, \"\");\n  free (comment);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_45E87C(_QWORD *a1)\n{\n  FILE *v1; // rax\n  __int64 v3; // [rsp+10h] [rbp-50h] BYREF\n  __int64 v4; // [rsp+18h] [rbp-48h] BYREF\n  char s[56]; // [rsp+20h] [rbp-40h] BYREF\n  FILE *stream; // [rsp+58h] [rbp-8h]\n\n  v1 = sub_40982E(\"/proc/uptime\");\n  stream = v1;\n  if ( v1 )\n  {\n    if ( fgets_unlocked(s, 52, stream) && sscanf(s, \"%lu.%lu\", &v4, &v3) == 2 )\n      *a1 = v4 * *((unsigned int *)qword_75D408 + 6) + (unsigned __int64)*((unsigned int *)qword_75D408 + 6) * v3 / 0x64;\n    LODWORD(v1) = fclose(stream);\n  }\n  return (int)v1;\n}\n",
        "output": "```c\nstatic unsigned long long\nget_uptime(void)\n{\n  FILE *uptime_file;\n  unsigned long uptime_seconds;\n  unsigned long uptime_fraction;\n  unsigned long long total_ticks;\n\n  uptime_file = fopen(\"/proc/uptime\", \"r\");\n  if (uptime_file)\n  {\n    char uptime_string[56];\n    if (fgets(uptime_string, sizeof(uptime_string), uptime_file) &&\n        sscanf(uptime_string, \"%lu.%lu\", &uptime_seconds, &uptime_fraction) == 2)\n    {\n      unsigned long long ticks_per_second = sysconf(_SC_CLK_TCK);\n      total_ticks = uptime_seconds * ticks_per_second +\n                    (uptime_fraction * ticks_per_second) / 100;\n    }\n    fclose(uptime_file);\n  }\n  return total_ticks;\n}\n```",
        "source_code": "static void get_uptime(data_t *uptime)\n{\n\tFILE *fp;\n\tchar buf[sizeof(long)*3 * 2 + 4]; /* enough for long.long */\n\tunsigned long uptime_sec, decimal;\n\n\tfp = fopen_for_read(PROCFS_UPTIME);\n\tif (!fp)\n\t\treturn;\n\tif (fgets(buf, sizeof(buf), fp)) {\n\t\tif (sscanf(buf, \"%lu.%lu\", &uptime_sec, &decimal) == 2) {\n\t\t\t*uptime = (data_t)uptime_sec * G.hz + decimal * G.hz / 100;\n\t\t}\n\t}\n\n\tfclose(fp);\n}",
        "parsed_output": "static unsigned long long\nget_uptime(void)\n{\n  FILE *uptime_file;\n  unsigned long uptime_seconds;\n  unsigned long uptime_fraction;\n  unsigned long long total_ticks;\n\n  uptime_file = fopen(\"/proc/uptime\", \"r\");\n  if (uptime_file)\n  {\n    char uptime_string[56];\n    if (fgets(uptime_string, sizeof(uptime_string), uptime_file) &&\n        sscanf(uptime_string, \"%lu.%lu\", &uptime_seconds, &uptime_fraction) == 2)\n    {\n      unsigned long long ticks_per_second = sysconf(_SC_CLK_TCK);\n      total_ticks = uptime_seconds * ticks_per_second +\n                    (uptime_fraction * ticks_per_second) / 100;\n    }\n    fclose(uptime_file);\n  }\n  return total_ticks;\n}",
        "baseline_code_stripped": "int __fastcall sub_45E87C(_QWORD *a1)\n{\n  FILE *v1; // rax\n  __int64 v3; // [rsp+10h] [rbp-50h] BYREF\n  __int64 v4; // [rsp+18h] [rbp-48h] BYREF\n  char s[56]; // [rsp+20h] [rbp-40h] BYREF\n  FILE *stream; // [rsp+58h] [rbp-8h]\n\n  v1 = sub_40982E(\"/proc/uptime\");\n  stream = v1;\n  if ( v1 )\n  {\n    if ( fgets_unlocked(s, 52, stream) && sscanf(s, \"%lu.%lu\", &v4, &v3) == 2 )\n      *a1 = v4 * *((unsigned int *)qword_75D408 + 6) + (unsigned __int64)*((unsigned int *)qword_75D408 + 6) * v3 / 0x64;\n    LODWORD(v1) = fclose(stream);\n  }\n  return (int)v1;\n}\n",
        "baseline_code_debug": "void __cdecl get_uptime(data_t *uptime)\n{\n  unsigned __int64 decimal; // [rsp+10h] [rbp-50h] BYREF\n  unsigned __int64 uptime_sec; // [rsp+18h] [rbp-48h] BYREF\n  char buf[52]; // [rsp+20h] [rbp-40h] BYREF\n  FILE *fp; // [rsp+58h] [rbp-8h]\n\n  fp = fopen_for_read(\"/proc/uptime\");\n  if ( fp )\n  {\n    if ( fgets_unlocked(buf, 52, fp) )\n    {\n      if ( sscanf(buf, \"%lu.%lu\", &uptime_sec, &decimal) == 2 )\n        *uptime = uptime_sec * LODWORD(ptr_to_globals->tty_name) + LODWORD(ptr_to_globals->tty_name) * decimal / 0x64;\n    }\n    fclose(fp);\n  }\n}\n",
        "similarity_score_unixcoder": 0.8389615416526794,
        "similarity_score_baseline_stripped": 0.613937497138977,
        "similarity_score_baseline_debug": 0.8015474677085876
    },
    {
        "func_name": "hash_search",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl entry_compare(const void *x, const void *y)\n{\n  bool v3; // [rsp+1h] [rbp-21h]\n\n  v3 = 0;\n  if ( *(_QWORD *)x == *(_QWORD *)y )\n    return *((_QWORD *)x + 1) == *((_QWORD *)y + 1);\n  return v3;\n}\n\n\n Revised code:\nstatic bool\nentry_compare (void const *x, void const *y)\n{\n  struct entry const *a = x;\n  struct entry const *b = y;\n  return SAME_INODE (*a, *b) ? true : false;\n}\n\n## Example:\n\n Input code:\nbool __cdecl binop(const char *s)\n{\n  bool v2; // [rsp+16h] [rbp-Ah]\n\n  v2 = 1;\n  if ( strcmp(s, (const char *)(unsigned int)\"=\") )\n  {\n    v2 = 1;\n    if ( strcmp(s, (const char *)(unsigned int)\"!=\") )\n    {\n      v2 = 1;\n      if ( strcmp(s, (const char *)(unsigned int)\"-nt\") )\n      {\n        v2 = 1;\n        if ( strcmp(s, (const char *)(unsigned int)\"-ot\") )\n        {\n          v2 = 1;\n          if ( strcmp(s, (const char *)(unsigned int)\"-ef\") )\n          {\n            v2 = 1;\n            if ( strcmp(s, (const char *)(unsigned int)\"-eq\") )\n            {\n              v2 = 1;\n              if ( strcmp(s, (const char *)(unsigned int)\"-ne\") )\n              {\n                v2 = 1;\n                if ( strcmp(s, (const char *)(unsigned int)\"-lt\") )\n                {\n                  v2 = 1;\n                  if ( strcmp(s, (const char *)(unsigned int)\"-le\") )\n                  {\n                    v2 = 1;\n                    if ( strcmp(s, (const char *)(unsigned int)\"-gt\") )\n                      return strcmp(s, (const char *)(unsigned int)\"-ge\") == 0;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return v2;\n}\n\n\n Revised code:\nstatic bool\nbinop (char const *s)\n{\n  return ((STREQ (s,   \"=\")) || (STREQ (s,  \"!=\")) || (STREQ (s, \"-nt\")) ||\n\t  (STREQ (s, \"-ot\")) || (STREQ (s, \"-ef\")) || (STREQ (s, \"-eq\")) ||\n\t  (STREQ (s, \"-ne\")) || (STREQ (s, \"-lt\")) || (STREQ (s, \"-le\")) ||\n\t  (STREQ (s, \"-gt\")) || (STREQ (s, \"-ge\")));\n}\n\n## Example:\n\n Input code:\nbool __cdecl dev_ino_compare(const void *x, const void *y)\n{\n  bool v3; // [rsp+1h] [rbp-21h]\n\n  v3 = 0;\n  if ( *(_QWORD *)x == *(_QWORD *)y )\n    return *((_QWORD *)x + 1) == *((_QWORD *)y + 1);\n  return v3;\n}\n\n\n Revised code:\nstatic bool\ndev_ino_compare (void const *x, void const *y)\n{\n  struct dev_ino const *a = x;\n  struct dev_ino const *b = y;\n  return SAME_INODE (*a, *b) ? true : false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4DC162(__int64 a1, char *a2)\n{\n  __int64 v2; // rbx\n  __int64 i; // [rsp+18h] [rbp-18h]\n\n  v2 = *(_QWORD *)(a1 + 16);\n  for ( i = *(_QWORD *)(v2 + 8LL * ((unsigned int)sub_4DC0E5(a2) % *(_DWORD *)(a1 + 4))); i; i = *(_QWORD *)(i + 32) )\n  {\n    if ( !strcmp((const char *)(i + 40), a2) )\n      return i;\n  }\n  return 0LL;\n}\n",
        "output": "```c\nstatic __int64\nfind_entry(__int64 hashtable, char *key)\n{\n  __int64 bucket_head;\n  __int64 entry;\n\n  bucket_head = *(_QWORD *)(hashtable + 16);\n  entry = *(_QWORD *)(bucket_head + 8 * (hash_function(key) % *(_DWORD *)(hashtable + 4)));\n  while (entry != 0)\n  {\n    if (strcmp((const char *)(entry + 40), key) == 0)\n      return entry;\n    entry = *(_QWORD *)(entry + 32);\n  }\n  return 0;\n}\n```",
        "source_code": "static void *hash_search(xhash *hash, const char *name)\n{\n\thash_item *hi;\n\n\thi = hash->items[hashidx(name) % hash->csize];\n\twhile (hi) {\n\t\tif (strcmp(hi->name, name) == 0)\n\t\t\treturn &hi->data;\n\t\thi = hi->next;\n\t}\n\treturn NULL;\n}",
        "parsed_output": "static __int64\nfind_entry(__int64 hashtable, char *key)\n{\n  __int64 bucket_head;\n  __int64 entry;\n\n  bucket_head = *(_QWORD *)(hashtable + 16);\n  entry = *(_QWORD *)(bucket_head + 8 * (hash_function(key) % *(_DWORD *)(hashtable + 4)));\n  while (entry != 0)\n  {\n    if (strcmp((const char *)(entry + 40), key) == 0)\n      return entry;\n    entry = *(_QWORD *)(entry + 32);\n  }\n  return 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4DC162(__int64 a1, char *a2)\n{\n  __int64 v2; // rbx\n  __int64 i; // [rsp+18h] [rbp-18h]\n\n  v2 = *(_QWORD *)(a1 + 16);\n  for ( i = *(_QWORD *)(v2 + 8LL * ((unsigned int)sub_4DC0E5(a2) % *(_DWORD *)(a1 + 4))); i; i = *(_QWORD *)(i + 32) )\n  {\n    if ( !strcmp((const char *)(i + 40), a2) )\n      return i;\n  }\n  return 0LL;\n}\n",
        "baseline_code_debug": "void *__cdecl hash_search(xhash *hash, const char *name)\n{\n  hash_item_s **items; // rbx\n  hash_item *hi; // [rsp+18h] [rbp-18h]\n\n  items = hash->items;\n  for ( hi = items[hashidx(name) % hash->csize]; hi; hi = hi->next )\n  {\n    if ( !strcmp(hi->name, name) )\n      return hi;\n  }\n  return 0LL;\n}\n",
        "similarity_score_unixcoder": 0.7245599031448364,
        "similarity_score_baseline_stripped": 0.5490822792053223,
        "similarity_score_baseline_debug": 0.870049774646759
    },
    {
        "func_name": "do_if_fetch",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl dosync(int fd, const char *qname)\n{\n  char *v2; // rax\n  char *v3; // rax\n  int err; // [rsp+1Ch] [rbp-14h]\n  int erra; // [rsp+1Ch] [rbp-14h]\n\n  if ( !fdatasync(fd) )\n    return 0;\n  err = *__errno_location();\n  if ( err == 22 || err == 9 )\n  {\n    if ( fsync(fd) )\n    {\n      erra = *__errno_location();\n      if ( erra == 22 || erra == 9 )\n      {\n        sync();\n        return 0;\n      }\n      else\n      {\n        v3 = gettext(\"%s: fsync failed\");\n        error(0, erra, v3, qname);\n        *__errno_location() = erra;\n        return -1;\n      }\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  else\n  {\n    v2 = gettext(\"%s: fdatasync failed\");\n    error(0, err, v2, qname);\n    *__errno_location() = err;\n    return -1;\n  }\n}\n\n\n Revised code:\nstatic int\ndosync (int fd, char const *qname)\n{\n  int err;\n\n#if HAVE_FDATASYNC\n  if (fdatasync (fd) == 0)\n    return 0;\n  err = errno;\n  if (err != EINVAL && err != EBADF)\n    {\n      error (0, err, _(\"%s: fdatasync failed\"), qname);\n      errno = err;\n      return -1;\n    }\n#endif\n\n  if (fsync (fd) == 0)\n    return 0;\n  err = errno;\n  if (err != EINVAL && err != EBADF)\n    {\n      error (0, err, _(\"%s: fsync failed\"), qname);\n      errno = err;\n      return -1;\n    }\n\n  sync ();\n  return 0;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl get_format_conv_type(char **format_ptr)\n{\n  char *v1; // rax\n  char *v2; // rax\n  char *v3; // rax\n  int v4; // [rsp+20h] [rbp-10h]\n  unsigned __int8 ch_0; // [rsp+27h] [rbp-9h]\n\n  v1 = (*format_ptr)++;\n  ch_0 = *v1;\n  v4 = (unsigned __int8)*v1;\n  if ( *v1 )\n  {\n    if ( v4 != 88 && v4 != 100 && v4 != 105 && v4 != 111 && v4 != 117 && v4 != 120 )\n    {\n      if ( ((*__ctype_b_loc())[ch_0] & 0x4000) != 0 )\n        v3 = gettext(\"invalid conversion specifier in suffix: %c\");\n      else\n        v3 = gettext(\"invalid conversion specifier in suffix: \\\\%.3o\");\n      error(1, 0, v3, ch_0);\n    }\n  }\n  else\n  {\n    v2 = gettext(\"missing conversion specifier in suffix\");\n    error(1, 0, v2);\n  }\n}\n\n\n Revised code:\nstatic void\nget_format_conv_type (char **format_ptr)\n{\n  unsigned char ch = *(*format_ptr)++;\n\n  switch (ch)\n    {\n    case 'd':\n    case 'i':\n    case 'o':\n    case 'u':\n    case 'x':\n    case 'X':\n      break;\n\n    case 0:\n      error (EXIT_FAILURE, 0, _(\"missing conversion specifier in suffix\"));\n      break;\n\n    default:\n      if (isprint (ch))\n        error (EXIT_FAILURE, 0,\n\t       _(\"invalid conversion specifier in suffix: %c\"), ch);\n      else\n\terror (EXIT_FAILURE, 0,\n\t       _(\"invalid conversion specifier in suffix: \\\\%.3o\"), ch);\n    }\n}\n\n## Example:\n\n Input code:\nbool __cdecl nl_file(const char *file)\n{\n  int *v1; // rax\n  FILE *stream; // [rsp+8h] [rbp-18h]\n\n  if ( !strcmp(file, (const char *)(unsigned int)\"-\") )\n  {\n    have_read_stdin = 1;\n    stream = stdin;\n    process_file(stdin);\n  }\n  else\n  {\n    stream = fopen(file, \"r\");\n    if ( !stream )\n      goto LABEL_10;\n    process_file(stream);\n  }\n  if ( !ferror_unlocked(stream) )\n  {\n    if ( !strcmp(file, (const char *)(unsigned int)\"-\") )\n    {\n      clearerr_unlocked(stream);\n      return 1;\n    }\n    if ( fclose(stream) != -1 )\n      return 1;\n  }\nLABEL_10:\n  v1 = __errno_location();\n  error(0, *v1, \"%s\", file);\n  return 0;\n}\n\n\n Revised code:\nstatic bool\nnl_file (char const *file)\n{\n  FILE *stream;\n\n  if (STREQ (file, \"-\"))\n    {\n      have_read_stdin = true;\n      stream = stdin;\n    }\n  else\n    {\n      stream = fopen (file, \"r\");\n      if (stream == NULL)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  process_file (stream);\n\n  if (ferror (stream))\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n  if (STREQ (file, \"-\"))\n    clearerr (stream);\t\t/* Also clear EOF. */\n  else if (fclose (stream) == EOF)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_437470(const char *a1)\n{\n  __int64 v1; // r8\n  __int64 v2; // r9\n  __int64 v3; // r8\n  __int64 v4; // r9\n  char *v6; // [rsp+18h] [rbp-8h]\n\n  if ( (int)sub_4370B6(a1) >= 0 )\n    return 0LL;\n  if ( *(_DWORD *)qword_75D400 == 19 )\n  {\n    sub_409747(\n      \"%s: error fetching interface information: %s\",\n      (__int64)(a1 + 16),\n      (__int64)\"Device not found\",\n      (__int64)(a1 + 16),\n      v1,\n      v2);\n  }\n  else\n  {\n    v6 = strerror(*(_DWORD *)qword_75D400);\n    sub_409747(\n      \"%s: error fetching interface information: %s\",\n      (__int64)(a1 + 16),\n      (__int64)v6,\n      (__int64)(a1 + 16),\n      v3,\n      v4);\n  }\n  return 0xFFFFFFFFLL;\n}\n",
        "output": "```c\nstatic int64_t\nsub_437470 (const char *a1)\n{\n  if (sub_4370B6 (a1) >= 0)\n    return 0;\n\n  int error_code = *(int *)qword_75D400;\n  const char *error_message;\n\n  if (error_code == ENODEV) // ENODEV is typically 19 on POSIX systems\n    error_message = \"Device not found\";\n  else\n    error_message = strerror (error_code);\n\n  sub_409747 (\"%s: error fetching interface information: %s\",\n              a1 + 16, error_message);\n\n  return -1;\n}\n```",
        "source_code": "static int do_if_fetch(struct interface *ife)\n{\n\tif (if_fetch(ife) < 0) {\n\t\tconst char *errmsg;\n\n\t\tif (errno == ENODEV) {\n\t\t\t/* Give better error message for this case. */\n\t\t\terrmsg = \"Device not found\";\n\t\t} else {\n\t\t\terrmsg = strerror(errno);\n\t\t}\n\t\tbb_error_msg(\"%s: error fetching interface information: %s\",\n\t\t\t\tife->name, errmsg);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
        "parsed_output": "static int64_t\nsub_437470 (const char *a1)\n{\n  if (sub_4370B6 (a1) >= 0)\n    return 0;\n\n  int error_code = *(int *)qword_75D400;\n  const char *error_message;\n\n  if (error_code == ENODEV) // ENODEV is typically 19 on POSIX systems\n    error_message = \"Device not found\";\n  else\n    error_message = strerror (error_code);\n\n  sub_409747 (\"%s: error fetching interface information: %s\",\n              a1 + 16, error_message);\n\n  return -1;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_437470(const char *a1)\n{\n  __int64 v1; // r8\n  __int64 v2; // r9\n  __int64 v3; // r8\n  __int64 v4; // r9\n  char *v6; // [rsp+18h] [rbp-8h]\n\n  if ( (int)sub_4370B6(a1) >= 0 )\n    return 0LL;\n  if ( *(_DWORD *)qword_75D400 == 19 )\n  {\n    sub_409747(\n      \"%s: error fetching interface information: %s\",\n      (__int64)(a1 + 16),\n      (__int64)\"Device not found\",\n      (__int64)(a1 + 16),\n      v1,\n      v2);\n  }\n  else\n  {\n    v6 = strerror(*(_DWORD *)qword_75D400);\n    sub_409747(\n      \"%s: error fetching interface information: %s\",\n      (__int64)(a1 + 16),\n      (__int64)v6,\n      (__int64)(a1 + 16),\n      v3,\n      v4);\n  }\n  return 0xFFFFFFFFLL;\n}\n",
        "baseline_code_debug": "int __cdecl do_if_fetch(interface *ife)\n{\n  char *errmsg; // [rsp+18h] [rbp-8h]\n\n  if ( if_fetch(ife) >= 0 )\n    return 0;\n  if ( *bb_errno == 19 )\n  {\n    bb_error_msg(\"%s: error fetching interface information: %s\", ife->name, \"Device not found\");\n  }\n  else\n  {\n    errmsg = strerror(*bb_errno);\n    bb_error_msg(\"%s: error fetching interface information: %s\", ife->name, errmsg);\n  }\n  return -1;\n}\n",
        "similarity_score_unixcoder": 0.7388578057289124,
        "similarity_score_baseline_stripped": 0.5915240049362183,
        "similarity_score_baseline_debug": 0.8595781326293945
    },
    {
        "func_name": "generate_uuid",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nmd5_ctx *__cdecl random_state(md5_ctx *retstr, size_t i)\n{\n  unsigned __int8 buf[16]; // [rsp+10h] [rbp-20h] BYREF\n  md5_ctx *s; // [rsp+20h] [rbp-10h]\n  size_t ia; // [rsp+28h] [rbp-8h]\n\n  ia = i;\n  s = &random_state_state[i];\n  if ( random_state_used <= i )\n  {\n    ++random_state_used;\n    if ( random_state_allocated <= ia )\n    {\n      random_state_state = (md5_ctx *)x2nrealloc(random_state_state, &random_state_allocated, 0x9CuLL);\n      s = &random_state_state[ia];\n    }\n    randread(randread_source_0, buf, 0x10uLL);\n    md5_init_ctx(s);\n    md5_process_bytes(buf, 0x10uLL, s);\n  }\n  memcpy(retstr, s, sizeof(md5_ctx));\n  return retstr;\n}\n\n\n Revised code:\nstatic struct md5_ctx\nrandom_state (size_t i)\n{\n  /* An array of states resulting from the random data, and counts of\n     its used and allocated members.  */\n  static struct md5_ctx *state;\n  static size_t used;\n  static size_t allocated;\n\n  struct md5_ctx *s = &state[i];\n\n  if (used <= i)\n    {\n      unsigned char buf[MD5_DIGEST_SIZE];\n\n      used++;\n\n      if (allocated <= i)\n\t{\n\t  state = X2NREALLOC (state, &allocated);\n\t  s = &state[i];\n\t}\n\n      randread (randread_source, buf, sizeof buf);\n      md5_init_ctx (s);\n      md5_process_bytes (buf, sizeof buf, s);\n    }\n\n  return *s;\n}\n\n## Example:\n\n Input code:\nbool __cdecl digest_file(const char *filename, int *binary, unsigned __int8 *bin_result)\n{\n  int v3; // eax\n  int v4; // eax\n  int *v5; // rax\n  int *v6; // rax\n  bool is_stdin; // [rsp+13h] [rbp-2Dh]\n  FILE *fp; // [rsp+18h] [rbp-28h]\n\n  v3 = strcmp(filename, (const char *)(unsigned int)\"-\");\n  is_stdin = v3 == 0;\n  if ( v3 )\n  {\n    fp = fopen_safer(filename, \"r\");\n    if ( !fp )\n    {\nLABEL_4:\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filename);\n      return 0;\n    }\n    v4 = md5_stream(fp, bin_result);\n  }\n  else\n  {\n    have_read_stdin = 1;\n    fp = stdin;\n    v4 = md5_stream(stdin, bin_result);\n  }\n  if ( !v4 )\n  {\n    if ( is_stdin || !fclose(fp) )\n      return 1;\n    goto LABEL_4;\n  }\n  v6 = __errno_location();\n  error(0, *v6, \"%s\", filename);\n  if ( fp != stdin )\n    fclose(fp);\n  return 0;\n}\n\n\n Revised code:\nstatic bool\ndigest_file (const char *filename, int *binary, unsigned char *bin_result)\n{\n  FILE *fp;\n  int err;\n  bool is_stdin = STREQ (filename, \"-\");\n\n  if (is_stdin)\n    {\n      have_read_stdin = true;\n      fp = stdin;\n      if (O_BINARY && *binary)\n\t{\n\t  if (*binary < 0)\n\t    *binary = ! isatty (STDIN_FILENO);\n\t  if (*binary)\n\t    freopen (NULL, \"rb\", stdin);\n\t}\n    }\n  else\n    {\n      fp = fopen (filename, (O_BINARY && *binary ? \"rb\" : \"r\"));\n      if (fp == NULL)\n\t{\n\t  error (0, errno, \"%s\", filename);\n\t  return false;\n\t}\n    }\n\n  err = DIGEST_STREAM (fp, bin_result);\n  if (err)\n    {\n      error (0, errno, \"%s\", filename);\n      if (fp != stdin)\n\tfclose (fp);\n      return false;\n    }\n\n  if (!is_stdin && fclose (fp) != 0)\n    {\n      error (0, errno, \"%s\", filename);\n      return false;\n    }\n\n  return true;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl genpattern(int *dest, size_t num, randint_source *s)\n{\n  int *v3; // rax\n  int *v4; // rax\n  size_t v5; // rcx\n  int k; // [rsp+Ch] [rbp-54h]\n  int ka; // [rsp+Ch] [rbp-54h]\n  int kb; // [rsp+Ch] [rbp-54h]\n  size_t swap; // [rsp+10h] [rbp-50h]\n  size_t top; // [rsp+18h] [rbp-48h]\n  size_t accum; // [rsp+20h] [rbp-40h]\n  randint n; // [rsp+28h] [rbp-38h]\n  size_t na; // [rsp+28h] [rbp-38h]\n  int *d; // [rsp+30h] [rbp-30h]\n  const int *p; // [rsp+38h] [rbp-28h]\n  size_t randpasses; // [rsp+40h] [rbp-20h]\n  size_t randpassesa; // [rsp+40h] [rbp-20h]\n\n  if ( num )\n  {\n    p = patterns;\n    randpasses = 0LL;\n    d = dest;\n    for ( n = num; ; n -= k )\n    {\n      while ( 1 )\n      {\n        while ( 1 )\n        {\n          v3 = (int *)p++;\n          k = *v3;\n          if ( *v3 )\n            break;\n          p = patterns;\n        }\n        if ( k >= 0 )\n          break;\n        ka = -k;\n        if ( ka >= n )\n        {\n          randpasses += n;\n          goto LABEL_18;\n        }\n        randpasses += ka;\n        n -= ka;\n      }\n      if ( k > n )\n        break;\n      memcpy(d, p, 4LL * k);\n      p += k;\n      d += k;\n    }\n    if ( n >= 2 && 3 * n >= k )\n    {\n      do\n      {\n        if ( n == k || randint_choose(s, k) < n )\n        {\n          v4 = d++;\n          *v4 = *p;\n          --n;\n        }\n        ++p;\n      }\n      while ( n );\n    }\n    else\n    {\n      randpasses += n;\n    }\nLABEL_18:\n    top = num - randpasses;\n    randpassesa = randpasses - 1;\n    accum = randpassesa;\n    for ( na = 0LL; na < num; ++na )\n    {\n      if ( accum > randpassesa )\n      {\n        swap = randint_choose(s, top - na) + na;\n        kb = dest[na];\n        dest[na] = dest[swap];\n        dest[swap] = kb;\n      }\n      else\n      {\n        accum += num - 1;\n        v5 = top++;\n        dest[v5] = dest[na];\n        dest[na] = -1;\n      }\n      accum -= randpassesa;\n    }\n  }\n}\n\n\n Revised code:\nstatic void\ngenpattern (int *dest, size_t num, struct randint_source *s)\n{\n  size_t randpasses;\n  int const *p;\n  int *d;\n  size_t n;\n  size_t accum, top, swap;\n  int k;\n\n  if (!num)\n    return;\n\n  /* Stage 1: choose the passes to use */\n  p = patterns;\n  randpasses = 0;\n  d = dest;\t\t\t/* Destination for generated pass list */\n  n = num;\t\t\t/* Passes remaining to fill */\n\n  for (;;)\n    {\n      k = *p++;\t\t\t/* Block descriptor word */\n      if (!k)\n\t{\t\t\t/* Loop back to the beginning */\n\t  p = patterns;\n\t}\n      else if (k < 0)\n\t{\t\t\t/* -k random passes */\n\t  k = -k;\n\t  if ((size_t) k >= n)\n\t    {\n\t      randpasses += n;\n\t      n = 0;\n\t      break;\n\t    }\n\t  randpasses += k;\n\t  n -= k;\n\t}\n      else if ((size_t) k <= n)\n\t{\t\t\t/* Full block of patterns */\n\t  memcpy (d, p, k * sizeof (int));\n\t  p += k;\n\t  d += k;\n\t  n -= k;\n\t}\n      else if (n < 2 || 3 * n < (size_t) k)\n\t{\t\t\t/* Finish with random */\n\t  randpasses += n;\n\t  break;\n\t}\n      else\n\t{\t\t\t/* Pad out with k of the n available */\n\t  do\n\t    {\n\t      if (n == (size_t) k || randint_choose (s, k) < n)\n\t\t{\n\t\t  *d++ = *p;\n\t\t  n--;\n\t\t}\n\t      p++;\n\t    }\n\t  while (n);\n\t  break;\n\t}\n    }\n  top = num - randpasses;\t/* Top of initialized data */\n  /* assert (d == dest+top); */\n\n  /*\n   * We now have fixed patterns in the dest buffer up to\n   * \"top\", and we need to scramble them, with \"randpasses\"\n   * random passes evenly spaced among them.\n   *\n   * We want one at the beginning, one at the end, and\n   * evenly spaced in between.  To do this, we basically\n   * use Bresenham's line draw (a.k.a DDA) algorithm\n   * to draw a line with slope (randpasses-1)/(num-1).\n   * (We use a positive accumulator and count down to\n   * do this.)\n   *\n   * So for each desired output value, we do the following:\n   * - If it should be a random pass, copy the pass type\n   *   to top++, out of the way of the other passes, and\n   *   set the current pass to -1 (random).\n   * - If it should be a normal pattern pass, choose an\n   *   entry at random between here and top-1 (inclusive)\n   *   and swap the current entry with that one.\n   */\n  randpasses--;\t\t\t/* To speed up later math */\n  accum = randpasses;\t\t/* Bresenham DDA accumulator */\n  for (n = 0; n < num; n++)\n    {\n      if (accum <= randpasses)\n\t{\n\t  accum += num - 1;\n\t  dest[top++] = dest[n];\n\t  dest[n] = -1;\n\t}\n      else\n\t{\n\t  swap = n + randint_choose (s, top - n);\n\t  k = dest[n];\n\t  dest[n] = dest[swap];\n\t  dest[swap] = k;\n\t}\n      accum -= randpasses;\n    }\n  /* assert (top == num); */\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_40ADEC(_BYTE *a1)\n{\n  unsigned int v1; // eax\n  _BYTE *result; // rax\n  int fd; // [rsp+18h] [rbp-8h]\n  int fda; // [rsp+18h] [rbp-8h]\n  __pid_t seed; // [rsp+1Ch] [rbp-4h]\n\n  fd = open64(\"/dev/urandom\", 0);\n  if ( fd >= 0 )\n  {\n    read(fd, a1, 0x10uLL);\n    close(fd);\n  }\n  v1 = sub_40BC67();\n  srand(v1);\n  for ( seed = getpid(); ; seed = 0 )\n  {\n    for ( fda = 0; fda <= 15; ++fda )\n      a1[fda] ^= rand() >> 5;\n    if ( !seed )\n      break;\n    srand(seed);\n  }\n  a1[6] = a1[6] & 0xF | 0x40;\n  result = a1 + 8;\n  a1[8] = a1[8] & 0x3F | 0x80;\n  return result;\n}\n",
        "output": "```c\nstatic void\ninitialize_random_bytes (unsigned char *buffer)\n{\n  int fd;\n  unsigned int seed;\n  pid_t pid;\n\n  /* Attempt to read from /dev/urandom */\n  fd = open (\"/dev/urandom\", O_RDONLY);\n  if (fd >= 0)\n    {\n      read (fd, buffer, 16);\n      close (fd);\n    }\n\n  /* Fallback on srand/rand if /dev/urandom read fails */\n  seed = get_random_seed ();\n  srand (seed);\n\n  /* XOR each byte with a random value */\n  pid = getpid();\n  do\n    {\n      for (int i = 0; i < 16; ++i)\n        buffer[i] ^= rand() >> 5;\n\n      if (pid)\n        {\n          srand (pid);\n          pid = 0;\n        }\n    }\n  while (pid);\n\n  /* Set the UUID version to 4 (random) */\n  buffer[6] = (buffer[6] & 0x0F) | 0x40;\n\n  /* Set the UUID variant to 1 (RFC 4122) */\n  buffer[8] = (buffer[8] & 0x3F) | 0x80;\n}\n```",
        "source_code": "void FAST_FUNC generate_uuid(uint8_t *buf)\n{\n\t/* http://www.ietf.org/rfc/rfc4122.txt\n\t *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t * |                          time_low                             |\n\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t * |       time_mid                |         time_hi_and_version   |\n\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t * |clk_seq_and_variant            |         node (0-1)            |\n\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t * |                         node (2-5)                            |\n\t * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\t * IOW, uuid has this layout:\n\t * uint32_t time_low (big endian)\n\t * uint16_t time_mid (big endian)\n\t * uint16_t time_hi_and_version (big endian)\n\t *  version is a 4-bit field:\n\t *   1 Time-based\n\t *   2 DCE Security, with embedded POSIX UIDs\n\t *   3 Name-based (MD5)\n\t *   4 Randomly generated\n\t *   5 Name-based (SHA-1)\n\t * uint16_t clk_seq_and_variant (big endian)\n\t *  variant is a 3-bit field:\n\t *   0xx Reserved, NCS backward compatibility\n\t *   10x The variant specified in rfc4122\n\t *   110 Reserved, Microsoft backward compatibility\n\t *   111 Reserved for future definition\n\t * uint8_t node[6]\n\t *\n\t * For version 4, these bits are set/cleared:\n\t * time_hi_and_version & 0x0fff | 0x4000\n\t * clk_seq_and_variant & 0x3fff | 0x8000\n\t */\n\tpid_t pid;\n\tint i;\n\n\ti = open(\"/dev/urandom\", O_RDONLY);\n\tif (i >= 0) {\n\t\tread(i, buf, 16);\n\t\tclose(i);\n\t}\n\t/* Paranoia. /dev/urandom may be missing.\n\t * rand() is guaranteed to generate at least [0, 2^15) range,\n\t * but lowest bits in some libc are not so \"random\".  */\n\tsrand(monotonic_us()); /* pulls in printf */\n\tpid = getpid();\n\twhile (1) {\n\t\tfor (i = 0; i < 16; i++)\n\t\t\tbuf[i] ^= rand() >> 5;\n\t\tif (pid == 0)\n\t\t\tbreak;\n\t\tsrand(pid);\n\t\tpid = 0;\n\t}\n\n\t/* version = 4 */\n\tbuf[4 + 2    ] = (buf[4 + 2    ] & 0x0f) | 0x40;\n\t/* variant = 10x */\n\tbuf[4 + 2 + 2] = (buf[4 + 2 + 2] & 0x3f) | 0x80;\n}",
        "parsed_output": "static void\ninitialize_random_bytes (unsigned char *buffer)\n{\n  int fd;\n  unsigned int seed;\n  pid_t pid;\n\n  /* Attempt to read from /dev/urandom */\n  fd = open (\"/dev/urandom\", O_RDONLY);\n  if (fd >= 0)\n    {\n      read (fd, buffer, 16);\n      close (fd);\n    }\n\n  /* Fallback on srand/rand if /dev/urandom read fails */\n  seed = get_random_seed ();\n  srand (seed);\n\n  /* XOR each byte with a random value */\n  pid = getpid();\n  do\n    {\n      for (int i = 0; i < 16; ++i)\n        buffer[i] ^= rand() >> 5;\n\n      if (pid)\n        {\n          srand (pid);\n          pid = 0;\n        }\n    }\n  while (pid);\n\n  /* Set the UUID version to 4 (random) */\n  buffer[6] = (buffer[6] & 0x0F) | 0x40;\n\n  /* Set the UUID variant to 1 (RFC 4122) */\n  buffer[8] = (buffer[8] & 0x3F) | 0x80;\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_40ADEC(_BYTE *a1)\n{\n  unsigned int v1; // eax\n  _BYTE *result; // rax\n  int fd; // [rsp+18h] [rbp-8h]\n  int fda; // [rsp+18h] [rbp-8h]\n  __pid_t seed; // [rsp+1Ch] [rbp-4h]\n\n  fd = open64(\"/dev/urandom\", 0);\n  if ( fd >= 0 )\n  {\n    read(fd, a1, 0x10uLL);\n    close(fd);\n  }\n  v1 = sub_40BC67();\n  srand(v1);\n  for ( seed = getpid(); ; seed = 0 )\n  {\n    for ( fda = 0; fda <= 15; ++fda )\n      a1[fda] ^= rand() >> 5;\n    if ( !seed )\n      break;\n    srand(seed);\n  }\n  a1[6] = a1[6] & 0xF | 0x40;\n  result = a1 + 8;\n  a1[8] = a1[8] & 0x3F | 0x80;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl generate_uuid(uint8_t *buf)\n{\n  unsigned int v1; // eax\n  int i; // [rsp+18h] [rbp-8h]\n  int ia; // [rsp+18h] [rbp-8h]\n  unsigned int pid; // [rsp+1Ch] [rbp-4h]\n\n  i = open64(\"/dev/urandom\", 0);\n  if ( i >= 0 )\n  {\n    read(i, buf, 0x10uLL);\n    close(i);\n  }\n  v1 = monotonic_us();\n  srand(v1);\n  for ( pid = getpid(); ; pid = 0 )\n  {\n    for ( ia = 0; ia <= 15; ++ia )\n      buf[ia] ^= rand() >> 5;\n    if ( !pid )\n      break;\n    srand(pid);\n  }\n  buf[6] = buf[6] & 0xF | 0x40;\n  buf[8] = buf[8] & 0x3F | 0x80;\n}\n",
        "similarity_score_unixcoder": 0.8022662401199341,
        "similarity_score_baseline_stripped": 0.6479687094688416,
        "similarity_score_baseline_debug": 0.8473597168922424
    },
    {
        "func_name": "conv_u",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl print_named_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  const unsigned __int8 *v3; // rax\n  char buf[5]; // [rsp+13h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+18h] [rbp-38h]\n  int masked_c; // [rsp+24h] [rbp-2Ch]\n  size_t i; // [rsp+28h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+30h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+38h] [rbp-18h]\n  const void *blocka; // [rsp+40h] [rbp-10h]\n  size_t n_bytesa; // [rsp+48h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = p++;\n    masked_c = *v3 & 0x7F;\n    if ( masked_c == 127 )\n    {\n      s = \"del\";\n    }\n    else if ( masked_c > 32 )\n    {\n      sprintf(buf, \"  %c\", (unsigned int)masked_c);\n      s = buf;\n    }\n    else\n    {\n      s = charname[masked_c];\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_named_ascii (size_t n_bytes, void const *block,\n\t\t   const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      int masked_c = *p++ & 0x7f;\n      const char *s;\n      char buf[5];\n\n      if (masked_c == 127)\n\ts = \"del\";\n      else if (masked_c <= 040)\n\ts = charname[masked_c];\n      else\n\t{\n\t  sprintf (buf, \"  %c\", masked_c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  unsigned __int8 *v3; // rax\n  const char *v4; // rdi\n  char buf[5]; // [rsp+33h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+38h] [rbp-38h]\n  unsigned __int8 c; // [rsp+47h] [rbp-29h]\n  size_t i; // [rsp+48h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+50h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+58h] [rbp-18h]\n  const void *blocka; // [rsp+60h] [rbp-10h]\n  size_t n_bytesa; // [rsp+68h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = (unsigned __int8 *)p++;\n    c = *v3;\n    switch ( c )\n    {\n      case 0u:\n        s = \" \\\\0\";\n        break;\n      case 7u:\n        s = (const char *)&unk_409AA8;\n        break;\n      case 8u:\n        s = (const char *)&unk_409AAC;\n        break;\n      case 9u:\n        s = (const char *)&unk_409ABC;\n        break;\n      case 0xAu:\n        s = (const char *)&unk_409AB4;\n        break;\n      case 0xBu:\n        s = (const char *)&unk_409AC0;\n        break;\n      case 0xCu:\n        s = (const char *)&unk_409AB0;\n        break;\n      case 0xDu:\n        s = (const char *)&unk_409AB8;\n        break;\n      default:\n        v4 = \"%03o\";\n        if ( ((*__ctype_b_loc())[c] & 0x4000) != 0 )\n          v4 = \"  %c\";\n        sprintf(buf, v4, c);\n        s = buf;\n        break;\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_ascii (size_t n_bytes, void const *block,\n\t     const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      unsigned char c = *p++;\n      const char *s;\n      char buf[5];\n\n      switch (c)\n\t{\n\tcase '\\0':\n\t  s = \" \\\\0\";\n\t  break;\n\n\tcase '\\a':\n\t  s = \" \\\\a\";\n\t  break;\n\n\tcase '\\b':\n\t  s = \" \\\\b\";\n\t  break;\n\n\tcase '\\f':\n\t  s = \" \\\\f\";\n\t  break;\n\n\tcase '\\n':\n\t  s = \" \\\\n\";\n\t  break;\n\n\tcase '\\r':\n\t  s = \" \\\\r\";\n\t  break;\n\n\tcase '\\t':\n\t  s = \" \\\\t\";\n\t  break;\n\n\tcase '\\v':\n\t  s = \" \\\\v\";\n\t  break;\n\n\tdefault:\n\t  sprintf (buf, (isprint (c) ? \"  %c\" : \"%03o\"), c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nint __fastcall sub_4F86EE(__int64 a1, unsigned __int8 *a2)\n{\n  if ( *a2 > 0x1Fu )\n  {\n    if ( *a2 == 127 )\n    {\n      **(_BYTE **)(a1 + 16) = 115;\n      return printf(*(const char **)(a1 + 24), \"del\");\n    }\n    else\n    {\n      if ( *a2 > 0x7Eu )\n        **(_BYTE **)(a1 + 16) = 120;\n      else\n        **(_BYTE **)(a1 + 16) = 99;\n      return printf(*(const char **)(a1 + 24), *a2);\n    }\n  }\n  else\n  {\n    **(_BYTE **)(a1 + 16) = 115;\n    return printf(*(const char **)(a1 + 24), &aNul[4 * *a2]);\n  }\n}\n",
        "output": "```c\nstatic int\nprint_character_representation (__int64 context, unsigned char *character)\n{\n  if (*character > 0x1F)\n    {\n      if (*character == 127)\n        {\n          **(char **)(context + 16) = 's';\n          return printf (*(const char **)(context + 24), \"del\");\n        }\n      else\n        {\n          **(char **)(context + 16) = (*character > 0x7E) ? 'x' : 'c';\n          return printf (*(const char **)(context + 24), *character);\n        }\n    }\n  else\n    {\n      **(char **)(context + 16) = 's';\n      return printf (*(const char **)(context + 24), &aNul[4 * *character]);\n    }\n}\n```",
        "source_code": "static void conv_u(PR *pr, unsigned char *p)\n{\n\tstatic const char list[] ALIGN1 =\n\t\t\"nul\\0soh\\0stx\\0etx\\0eot\\0enq\\0ack\\0bel\\0\"\n\t\t\"bs\\0_ht\\0_lf\\0_vt\\0_ff\\0_cr\\0_so\\0_si\\0_\"\n\t\t\"dle\\0dcl\\0dc2\\0dc3\\0dc4\\0nak\\0syn\\0etb\\0\"\n\t\t\"can\\0em\\0_sub\\0esc\\0fs\\0_gs\\0_rs\\0_us\";\n\n\t/* od used nl, not lf */\n\tif (*p <= 0x1f) {\n\t\t*pr->cchar = 's';\n\t\tprintf(pr->fmt, list + (4 * (int)*p));\n\t} else if (*p == 0x7f) {\n\t\t*pr->cchar = 's';\n\t\tprintf(pr->fmt, \"del\");\n\t} else if (*p < 0x7f) { /* isprint() */\n\t\t*pr->cchar = 'c';\n\t\tprintf(pr->fmt, *p);\n\t} else {\n\t\t*pr->cchar = 'x';\n\t\tprintf(pr->fmt, (int) *p);\n\t}\n}",
        "parsed_output": "static int\nprint_character_representation (__int64 context, unsigned char *character)\n{\n  if (*character > 0x1F)\n    {\n      if (*character == 127)\n        {\n          **(char **)(context + 16) = 's';\n          return printf (*(const char **)(context + 24), \"del\");\n        }\n      else\n        {\n          **(char **)(context + 16) = (*character > 0x7E) ? 'x' : 'c';\n          return printf (*(const char **)(context + 24), *character);\n        }\n    }\n  else\n    {\n      **(char **)(context + 16) = 's';\n      return printf (*(const char **)(context + 24), &aNul[4 * *character]);\n    }\n}",
        "baseline_code_stripped": "int __fastcall sub_4F86EE(__int64 a1, unsigned __int8 *a2)\n{\n  if ( *a2 > 0x1Fu )\n  {\n    if ( *a2 == 127 )\n    {\n      **(_BYTE **)(a1 + 16) = 115;\n      return printf(*(const char **)(a1 + 24), \"del\");\n    }\n    else\n    {\n      if ( *a2 > 0x7Eu )\n        **(_BYTE **)(a1 + 16) = 120;\n      else\n        **(_BYTE **)(a1 + 16) = 99;\n      return printf(*(const char **)(a1 + 24), *a2);\n    }\n  }\n  else\n  {\n    **(_BYTE **)(a1 + 16) = 115;\n    return printf(*(const char **)(a1 + 24), &aNul[4 * *a2]);\n  }\n}\n",
        "baseline_code_debug": "void __cdecl conv_u(PR_0 *pr, unsigned __int8 *p)\n{\n  if ( *p > 0x1Fu )\n  {\n    if ( *p == 127 )\n    {\n      *pr->cchar = 115;\n      printf(pr->fmt, \"del\");\n    }\n    else\n    {\n      if ( *p > 0x7Eu )\n        *pr->cchar = 120;\n      else\n        *pr->cchar = 99;\n      printf(pr->fmt, *p);\n    }\n  }\n  else\n  {\n    *pr->cchar = 115;\n    printf(pr->fmt, &list_8306[4 * *p]);\n  }\n}\n",
        "similarity_score_unixcoder": 0.6903071999549866,
        "similarity_score_baseline_stripped": 0.642969012260437,
        "similarity_score_baseline_debug": 0.836890697479248
    },
    {
        "func_name": "regex_process",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl sysv_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  int *v5; // rax\n  char *v6; // rax\n  size_t bytes_read; // [rsp+20h] [rbp-22E0h]\n  size_t i; // [rsp+28h] [rbp-22D8h]\n  _BYTE is_stdin[5]; // [rsp+33h] [rbp-22CDh]\n  char hbuf[652]; // [rsp+40h] [rbp-22C0h] BYREF\n  uintmax_t total_bytes; // [rsp+2D8h] [rbp-2028h]\n  unsigned __int8 buf[8192]; // [rsp+2E0h] [rbp-2020h] BYREF\n  int fd; // [rsp+22E8h] [rbp-18h]\n  int print_namea; // [rsp+22ECh] [rbp-14h]\n  const char *filea; // [rsp+22F0h] [rbp-10h]\n  char v17; // [rsp+22FFh] [rbp-1h]\n\n  filea = file;\n  print_namea = print_name;\n  total_bytes = 0LL;\n  is_stdin[4] = 0;\n  v2 = strcmp(file, \"-\");\n  *(_DWORD *)is_stdin = v2 == 0;\n  if ( !v2 )\n  {\n    fd = 0;\n    have_read_stdin = 1;\n    goto LABEL_5;\n  }\n  fd = open(filea, 0);\n  if ( fd == -1 )\n  {\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    v17 = 0;\n  }\n  else\n  {\nLABEL_5:\n    while ( 1 )\n    {\n      bytes_read = safe_read(fd, buf, 0x2000uLL);\n      if ( !bytes_read )\n        break;\n      if ( bytes_read == -1LL )\n      {\n        v4 = __errno_location();\n        error(0, *v4, \"%s\", filea);\n        if ( (is_stdin[0] & 1) == 0 )\n          close(fd);\n        v17 = 0;\n        return v17 & 1;\n      }\n      for ( i = 0LL; i < bytes_read; ++i )\n        *(_DWORD *)&is_stdin[1] += buf[i];\n      total_bytes += bytes_read;\n    }\n    if ( (is_stdin[0] & 1) != 0 || !close(fd) )\n    {\n      v6 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x200uLL);\n      printf(\n        \"%d %s\",\n        ((HIWORD(*(_DWORD *)&is_stdin[1]) + *(unsigned __int16 *)&is_stdin[1]) >> 16)\n      + (unsigned int)(unsigned __int16)(*(_WORD *)&is_stdin[3] + *(_WORD *)&is_stdin[1]),\n        v6);\n      if ( print_namea )\n        printf(\" %s\", filea);\n      putchar_unlocked(10);\n      v17 = 1;\n    }\n    else\n    {\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filea);\n      v17 = 0;\n    }\n  }\n  return v17 & 1;\n}\n\n\n Revised code:\nstatic bool\nsysv_sum_file (const char *file, int print_name)\n{\n  int fd;\n  unsigned char buf[8192];\n  uintmax_t total_bytes = 0;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int r;\n  int checksum;\n\n  /* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n  unsigned int s = 0;\n\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fd = STDIN_FILENO;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while (1)\n    {\n      size_t i;\n      size_t bytes_read = safe_read (fd, buf, sizeof buf);\n\n      if (bytes_read == 0)\n\tbreak;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  if (!is_stdin)\n\t    close (fd);\n\t  return false;\n\t}\n\n      for (i = 0; i < bytes_read; i++)\n\ts += buf[i];\n      total_bytes += bytes_read;\n    }\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  checksum = (r & 0xffff) + (r >> 16);\n\n  printf (\"%d %s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 512));\n  if (print_name)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nint __cdecl get_line(FILE *f, int c)\n{\n  char *v2; // rdx\n  int v3; // edx\n  int v4; // eax\n  bool v6; // [rsp+4h] [rbp-2Ch]\n  bool v7; // [rsp+5h] [rbp-2Bh]\n  char v8; // [rsp+6h] [rbp-2Ah]\n  char v9; // [rsp+7h] [rbp-29h]\n  int start; // [rsp+18h] [rbp-18h]\n  int ca; // [rsp+1Ch] [rbp-14h]\n\n  LOBYTE(ca) = c;\n  do\n  {\n    word_limit->text = wptr;\n    do\n    {\n      if ( wptr == &parabuf[5000] )\n      {\n        set_other_indent(1);\n        flush_paragraph();\n      }\n      v2 = wptr++;\n      *v2 = ca;\n      ca = getc_unlocked(f);\n      v9 = 0;\n      if ( ca != -1 )\n        v9 = ~(((*__ctype_b_loc())[ca] & 0x2000) != 0);\n    }\n    while ( (v9 & 1) != 0 );\n    v3 = (_DWORD)wptr - (unsigned __int64)word_limit->text;\n    word_limit->length = v3;\n    in_column += v3;\n    check_punctuation(word_limit);\n    start = in_column;\n    ca = get_space(f, ca);\n    word_limit->space = in_column - start;\n    v8 = 1;\n    if ( ca != -1 )\n    {\n      v7 = 0;\n      if ( (*((_BYTE *)word_limit + 16) & 2) != 0 )\n      {\n        v6 = 1;\n        if ( ca != 10 )\n          v6 = word_limit->space > 1;\n        v7 = v6;\n      }\n      v8 = v7;\n    }\n    *((_BYTE *)word_limit + 16) = (8 * (v8 & 1)) | *((_BYTE *)word_limit + 16) & 0xF7;\n    if ( ca == 10 || ca == -1 || uniform )\n    {\n      v4 = 1;\n      if ( (*((_BYTE *)word_limit + 16) & 8) != 0 )\n        v4 = 2;\n      word_limit->space = v4;\n    }\n    if ( word_limit == &unused_word_type[998] )\n    {\n      set_other_indent(1);\n      flush_paragraph();\n    }\n    ++word_limit;\n    if ( ca == -1 )\n      return -1;\n  }\n  while ( ca != 10 );\n  return get_prefix(f);\n}\n\n\n Revised code:\nstatic int\nget_line (FILE *f, int c)\n{\n  int start;\n  char *end_of_parabuf;\n  WORD *end_of_word;\n\n  end_of_parabuf = &parabuf[MAXCHARS];\n  end_of_word = &word[MAXWORDS - 2];\n\n  do\n    {\t\t\t\t/* for each word in a line */\n\n      /* Scan word.  */\n\n      word_limit->text = wptr;\n      do\n\t{\n\t  if (wptr == end_of_parabuf)\n\t    {\n\t      set_other_indent (true);\n\t      flush_paragraph ();\n\t    }\n\t  *wptr++ = c;\n\t  c = getc (f);\n\t}\n      while (c != EOF && !isspace (c));\n      in_column += word_limit->length = wptr - word_limit->text;\n      check_punctuation (word_limit);\n\n      /* Scan inter-word space.  */\n\n      start = in_column;\n      c = get_space (f, c);\n      word_limit->space = in_column - start;\n      word_limit->final = (c == EOF\n\t\t\t   || (word_limit->period\n\t\t\t       && (c == '\\n' || word_limit->space > 1)));\n      if (c == '\\n' || c == EOF || uniform)\n\tword_limit->space = word_limit->final ? 2 : 1;\n      if (word_limit == end_of_word)\n\t{\n\t  set_other_indent (true);\n\t  flush_paragraph ();\n\t}\n      word_limit++;\n      if (c == EOF)\n\treturn EOF;\n    }\n  while (c != '\\n');\n  return get_prefix (f);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall sub_41E9F5(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  char *v3; // [rsp+0h] [rbp-10h]\n  _BYTE *ptr; // [rsp+8h] [rbp-8h]\n\n  free(*((void **)qword_75D408 + 31));\n  *((_QWORD *)qword_75D408 + 31) = 0LL;\n  *((_DWORD *)qword_75D408 + 64) = 0;\n  *((_DWORD *)qword_75D408 + 66) = 0;\n  if ( *((_BYTE *)qword_75D408 + 336) )\n  {\n    regfree((regex_t *)((char *)qword_75D408 + 272));\n    *((_BYTE *)qword_75D408 + 336) = 0;\n  }\n  sub_41CAC5();\n  if ( (dword_75D450 & 0x8000) != 0 )\n    v2 = 63;\n  else\n    v2 = 47;\n  sub_40A659(v2);\n  ptr = sub_41E385(1, a2);\n  if ( *ptr )\n  {\n    v3 = (char *)sub_50C16B((char *)qword_75D408 + 272, ptr, ((unsigned int)dword_75D450 >> 4) & 2);\n    free(ptr);\n    if ( v3 )\n    {\n      sub_41CB0F(v3);\n      free(v3);\n    }\n    else\n    {\n      *((_BYTE *)qword_75D408 + 336) = 1;\n      *((_DWORD *)qword_75D408 + 64) = 0;\n      sub_41E8BD(0);\n      while ( *((_DWORD *)qword_75D408 + 64) < *((_DWORD *)qword_75D408 + 66)\n           && *(_DWORD *)(*((_QWORD *)qword_75D408 + 31) + 4LL * *((int *)qword_75D408 + 64)) <= *(_DWORD *)qword_75D408 )\n        ++*((_DWORD *)qword_75D408 + 64);\n      if ( (dword_75D450 & 0x8000) != 0 )\n        --*((_DWORD *)qword_75D408 + 64);\n      sub_41E7FF(*((unsigned int *)qword_75D408 + 64), (size_t)ptr);\n    }\n  }\n  else\n  {\n    free(ptr);\n    sub_41DC9A();\n  }\n}\n",
        "output": "```c\nstatic void\nreset_and_process_data(__int64 data_ptr, __int64 input_size)\n{\n  int delimiter;\n  char *regex_error;\n  _BYTE *buffer;\n\n  // Reset the data structure\n  free(*(void **)(global_data + 248)); // Assuming qword_75D408 is a global data pointer\n  *(void **)(global_data + 248) = NULL;\n  *(int *)(global_data + 256) = 0;\n  *(int *)(global_data + 264) = 0;\n  if (*(char *)(global_data + 336))\n  {\n    regfree((regex_t *)(global_data + 272));\n    *(char *)(global_data + 336) = 0;\n  }\n  cleanup_function(); // Assuming sub_41CAC5 is a cleanup function\n\n  // Determine delimiter based on a flag\n  delimiter = (global_flag & 0x8000) ? 63 : 47; // Assuming dword_75D450 is a global flag\n  set_delimiter(delimiter); // Assuming sub_40A659 sets a delimiter\n\n  // Process input\n  buffer = allocate_and_copy_input(1, input_size); // Assuming sub_41E385 allocates and copies input\n  if (*buffer)\n  {\n    regex_error = compile_regex(global_data + 272, buffer, (global_flag >> 4) & 2); // Assuming sub_50C16B compiles regex\n    free(buffer);\n    if (regex_error)\n    {\n      handle_regex_error(regex_error); // Assuming sub_41CB0F handles regex error\n      free(regex_error);\n    }\n    else\n    {\n      *(char *)(global_data + 336) = 1;\n      *(int *)(global_data + 256) = 0;\n      handle_no_match(); // Assuming sub_41E8BD handles no match case\n      while (*(int *)(global_data + 256) < *(int *)(global_data + 264)\n             && *(int *)(*(void **)(global_data + 248) + 4 * *(int *)(global_data + 256)) <= *(int *)global_data)\n      {\n        (*(int *)(global_data + 256))++;\n      }\n      if (global_flag & 0x8000)\n        (*(int *)(global_data + 256))--;\n      process_match(*(unsigned int *)(global_data + 256), (size_t)buffer); // Assuming sub_41E7FF processes a match\n    }\n  }\n  else\n  {\n    free(buffer);\n    handle_empty_input(); // Assuming sub_41DC9A handles empty input\n  }\n}\n```",
        "source_code": "static void regex_process(void)\n{\n\tchar *uncomp_regex, *err;\n\n\t/* Reset variables */\n\tfree(match_lines);\n\tmatch_lines = NULL;\n\tmatch_pos = 0;\n\tnum_matches = 0;\n\tif (pattern_valid) {\n\t\tregfree(&pattern);\n\t\tpattern_valid = 0;\n\t}\n\n\t/* Get the uncompiled regular expression from the user */\n\tclear_line();\n\tbb_putchar((option_mask32 & LESS_STATE_MATCH_BACKWARDS) ? '?' : '/');\n\tuncomp_regex = less_gets(1);\n\tif (!uncomp_regex[0]) {\n\t\tfree(uncomp_regex);\n\t\tbuffer_print();\n\t\treturn;\n\t}\n\n\t/* Compile the regex and check for errors */\n\terr = regcomp_or_errmsg(&pattern, uncomp_regex,\n\t\t\t\t(option_mask32 & FLAG_I) ? REG_ICASE : 0);\n\tfree(uncomp_regex);\n\tif (err) {\n\t\tprint_statusline(err);\n\t\tfree(err);\n\t\treturn;\n\t}\n\n\tpattern_valid = 1;\n\tmatch_pos = 0;\n\tfill_match_lines(0);\n\twhile (match_pos < num_matches) {\n\t\tif ((int)match_lines[match_pos] > cur_fline)\n\t\t\tbreak;\n\t\tmatch_pos++;\n\t}\n\tif (option_mask32 & LESS_STATE_MATCH_BACKWARDS)\n\t\tmatch_pos--;\n\n\t/* It's possible that no matches are found yet.\n\t * goto_match() will read input looking for match,\n\t * if needed */\n\tgoto_match(match_pos);\n}",
        "parsed_output": "static void\nreset_and_process_data(__int64 data_ptr, __int64 input_size)\n{\n  int delimiter;\n  char *regex_error;\n  _BYTE *buffer;\n\n  // Reset the data structure\n  free(*(void **)(global_data + 248)); // Assuming qword_75D408 is a global data pointer\n  *(void **)(global_data + 248) = NULL;\n  *(int *)(global_data + 256) = 0;\n  *(int *)(global_data + 264) = 0;\n  if (*(char *)(global_data + 336))\n  {\n    regfree((regex_t *)(global_data + 272));\n    *(char *)(global_data + 336) = 0;\n  }\n  cleanup_function(); // Assuming sub_41CAC5 is a cleanup function\n\n  // Determine delimiter based on a flag\n  delimiter = (global_flag & 0x8000) ? 63 : 47; // Assuming dword_75D450 is a global flag\n  set_delimiter(delimiter); // Assuming sub_40A659 sets a delimiter\n\n  // Process input\n  buffer = allocate_and_copy_input(1, input_size); // Assuming sub_41E385 allocates and copies input\n  if (*buffer)\n  {\n    regex_error = compile_regex(global_data + 272, buffer, (global_flag >> 4) & 2); // Assuming sub_50C16B compiles regex\n    free(buffer);\n    if (regex_error)\n    {\n      handle_regex_error(regex_error); // Assuming sub_41CB0F handles regex error\n      free(regex_error);\n    }\n    else\n    {\n      *(char *)(global_data + 336) = 1;\n      *(int *)(global_data + 256) = 0;\n      handle_no_match(); // Assuming sub_41E8BD handles no match case\n      while (*(int *)(global_data + 256) < *(int *)(global_data + 264)\n             && *(int *)(*(void **)(global_data + 248) + 4 * *(int *)(global_data + 256)) <= *(int *)global_data)\n      {\n        (*(int *)(global_data + 256))++;\n      }\n      if (global_flag & 0x8000)\n        (*(int *)(global_data + 256))--;\n      process_match(*(unsigned int *)(global_data + 256), (size_t)buffer); // Assuming sub_41E7FF processes a match\n    }\n  }\n  else\n  {\n    free(buffer);\n    handle_empty_input(); // Assuming sub_41DC9A handles empty input\n  }\n}",
        "baseline_code_stripped": "void __fastcall sub_41E9F5(__int64 a1, __int64 a2)\n{\n  int v2; // eax\n  char *v3; // [rsp+0h] [rbp-10h]\n  _BYTE *ptr; // [rsp+8h] [rbp-8h]\n\n  free(*((void **)qword_75D408 + 31));\n  *((_QWORD *)qword_75D408 + 31) = 0LL;\n  *((_DWORD *)qword_75D408 + 64) = 0;\n  *((_DWORD *)qword_75D408 + 66) = 0;\n  if ( *((_BYTE *)qword_75D408 + 336) )\n  {\n    regfree((regex_t *)((char *)qword_75D408 + 272));\n    *((_BYTE *)qword_75D408 + 336) = 0;\n  }\n  sub_41CAC5();\n  if ( (dword_75D450 & 0x8000) != 0 )\n    v2 = 63;\n  else\n    v2 = 47;\n  sub_40A659(v2);\n  ptr = sub_41E385(1, a2);\n  if ( *ptr )\n  {\n    v3 = (char *)sub_50C16B((char *)qword_75D408 + 272, ptr, ((unsigned int)dword_75D450 >> 4) & 2);\n    free(ptr);\n    if ( v3 )\n    {\n      sub_41CB0F(v3);\n      free(v3);\n    }\n    else\n    {\n      *((_BYTE *)qword_75D408 + 336) = 1;\n      *((_DWORD *)qword_75D408 + 64) = 0;\n      sub_41E8BD(0);\n      while ( *((_DWORD *)qword_75D408 + 64) < *((_DWORD *)qword_75D408 + 66)\n           && *(_DWORD *)(*((_QWORD *)qword_75D408 + 31) + 4LL * *((int *)qword_75D408 + 64)) <= *(_DWORD *)qword_75D408 )\n        ++*((_DWORD *)qword_75D408 + 64);\n      if ( (dword_75D450 & 0x8000) != 0 )\n        --*((_DWORD *)qword_75D408 + 64);\n      sub_41E7FF(*((unsigned int *)qword_75D408 + 64), (size_t)ptr);\n    }\n  }\n  else\n  {\n    free(ptr);\n    sub_41DC9A();\n  }\n}\n",
        "baseline_code_debug": "void __cdecl regex_process()\n{\n  int v0; // eax\n  char *err; // [rsp+0h] [rbp-10h]\n  char *uncomp_regex; // [rsp+8h] [rbp-8h]\n\n  free(*(void **)&ptr_to_globals->line_buf[92]);\n  *(_QWORD *)&ptr_to_globals->line_buf[92] = 0LL;\n  *(_DWORD *)&ptr_to_globals->line_buf[100] = 0;\n  *(_DWORD *)&ptr_to_globals->line_buf[108] = 0;\n  if ( LOBYTE(ptr_to_globals[1].numspeed) )\n  {\n    regfree((regex_t *)&ptr_to_globals->line_buf[116]);\n    LOBYTE(ptr_to_globals[1].numspeed) = 0;\n  }\n  clear_line();\n  if ( (option_mask32 & 0x8000) != 0 )\n    v0 = 63;\n  else\n    v0 = 47;\n  bb_putchar(v0);\n  uncomp_regex = less_gets(1);\n  if ( *uncomp_regex )\n  {\n    err = regcomp_or_errmsg((regex_t *)&ptr_to_globals->line_buf[116], uncomp_regex, (option_mask32 >> 4) & 2);\n    free(uncomp_regex);\n    if ( err )\n    {\n      print_statusline(err);\n      free(err);\n    }\n    else\n    {\n      LOBYTE(ptr_to_globals[1].numspeed) = 1;\n      *(_DWORD *)&ptr_to_globals->line_buf[100] = 0;\n      fill_match_lines(0);\n      while ( *(_DWORD *)&ptr_to_globals->line_buf[100] < *(_DWORD *)&ptr_to_globals->line_buf[108]\n           && *(_DWORD *)(*(_QWORD *)&ptr_to_globals->line_buf[92] + 4LL * *(int *)&ptr_to_globals->line_buf[100]) <= (signed int)ptr_to_globals->timeout )\n        ++*(_DWORD *)&ptr_to_globals->line_buf[100];\n      if ( (option_mask32 & 0x8000) != 0 )\n        --*(_DWORD *)&ptr_to_globals->line_buf[100];\n      goto_match(*(_DWORD *)&ptr_to_globals->line_buf[100]);\n    }\n  }\n  else\n  {\n    free(uncomp_regex);\n    buffer_print();\n  }\n}\n",
        "similarity_score_unixcoder": 0.5994459986686707,
        "similarity_score_baseline_stripped": 0.44485458731651306,
        "similarity_score_baseline_debug": 0.7301834225654602
    },
    {
        "func_name": "stzalloc",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nvoid __cdecl remove_suffix(char *name, const char *suffix)\n{\n  char *v2; // rax\n  int v3; // edx\n  const char *v4; // rax\n  bool v5; // [rsp+Fh] [rbp-31h]\n  const char *sp_0; // [rsp+20h] [rbp-20h]\n  char *np; // [rsp+28h] [rbp-18h]\n\n  np = &name[strlen(name)];\n  sp_0 = &suffix[strlen(suffix)];\n  while ( 1 )\n  {\n    v5 = 0;\n    if ( np > name )\n      v5 = sp_0 > suffix;\n    if ( !v5 )\n      break;\n    v2 = np--;\n    v3 = *(v2 - 1);\n    v4 = sp_0--;\n    if ( v3 != *(v4 - 1) )\n      return;\n  }\n  if ( np > name )\n    *np = 0;\n}\n\n\n Revised code:\nstatic void\nremove_suffix (char *name, const char *suffix)\n{\n  char *np;\n  const char *sp;\n\n  np = name + strlen (name);\n  sp = suffix + strlen (suffix);\n\n  while (np > name && sp > suffix)\n    if (*--np != *--sp)\n      return;\n  if (np > name)\n    *np = '\\0';\n}\n\n## Example:\n\n Input code:\nbool __cdecl different(char *old, char *a2, size_t oldlen, size_t newlen)\n{\n  bool v5; // [rsp+6h] [rbp-2Ah]\n  bool v6; // [rsp+7h] [rbp-29h]\n  size_t newlena; // [rsp+8h] [rbp-28h]\n  size_t oldlena; // [rsp+10h] [rbp-20h]\n\n  oldlena = oldlen;\n  newlena = newlen;\n  if ( check_chars < oldlen )\n    oldlena = check_chars;\n  if ( check_chars < newlen )\n    newlena = check_chars;\n  if ( ignore_case )\n  {\n    v6 = 1;\n    if ( oldlena == newlena )\n      return memcasecmp(old, a2, oldlena) != 0;\n    return v6;\n  }\n  else if ( hard_LC_COLLATE )\n  {\n    return xmemcoll(old, oldlena, a2, newlena) != 0;\n  }\n  else\n  {\n    v5 = 1;\n    if ( oldlena == newlena )\n      return memcmp(old, a2, oldlena) != 0;\n    return v5;\n  }\n}\n\n\n Revised code:\nstatic bool\ndifferent (char *old, char *new, size_t oldlen, size_t newlen)\n{\n  if (check_chars < oldlen)\n    oldlen = check_chars;\n  if (check_chars < newlen)\n    newlen = check_chars;\n\n  if (ignore_case)\n    {\n      /* FIXME: This should invoke strcoll somehow.  */\n      return oldlen != newlen || memcasecmp (old, new, oldlen);\n    }\n  else if (hard_LC_COLLATE)\n    return xmemcoll (old, oldlen, new, newlen) != 0;\n  else\n    return oldlen != newlen || memcmp (old, new, oldlen);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *__fastcall sub_46E7E7(size_t a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  void *v6; // rax\n\n  v6 = (void *)sub_46E6A8(a1, a2, a3, a4, a5, a6);\n  return memset(v6, 0, a1);\n}\n",
        "output": "```c\nstatic void *\ninitialize_memory(size_t size, __int64 arg1, __int64 arg2, __int64 arg3, __int64 arg4, __int64 arg5)\n{\n  void *memory = allocate_memory(size, arg1, arg2, arg3, arg4, arg5);\n  return memset(memory, 0, size);\n}\n```",
        "source_code": "static void *\nstzalloc(size_t nbytes)\n{\n\treturn memset(stalloc(nbytes), 0, nbytes);\n}",
        "parsed_output": "static void *\ninitialize_memory(size_t size, __int64 arg1, __int64 arg2, __int64 arg3, __int64 arg4, __int64 arg5)\n{\n  void *memory = allocate_memory(size, arg1, arg2, arg3, arg4, arg5);\n  return memset(memory, 0, size);\n}",
        "baseline_code_stripped": "void *__fastcall sub_46E7E7(size_t a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  void *v6; // rax\n\n  v6 = (void *)sub_46E6A8(a1, a2, a3, a4, a5, a6);\n  return memset(v6, 0, a1);\n}\n",
        "baseline_code_debug": "void *__cdecl stzalloc(size_t nbytes)\n{\n  void *v1; // rcx\n\n  v1 = stalloc(nbytes);\n  return memset(v1, 0, nbytes);\n}\n",
        "similarity_score_unixcoder": 0.6226469278335571,
        "similarity_score_baseline_stripped": 0.540249764919281,
        "similarity_score_baseline_debug": 0.8589975237846375
    },
    {
        "func_name": "if_readlist",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl looks_like_integer(const char *cp)\n{\n  const char *v1; // rax\n  const char *cpa; // [rsp+0h] [rbp-10h]\n\n  cpa = &cp[*cp == 45];\n  do\n  {\n    if ( (unsigned int)(*cpa - 48) > 9 )\n      return 0;\n    v1 = cpa++;\n  }\n  while ( v1[1] );\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nlooks_like_integer (char const *cp)\n{\n  cp += (*cp == '-');\n\n  do\n    if (! ISDIGIT (*cp))\n      return false;\n  while (*++cp);\n\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nbool __cdecl entry_compare(const void *x, const void *y)\n{\n  bool v3; // [rsp+1h] [rbp-21h]\n\n  v3 = 0;\n  if ( *(_QWORD *)x == *(_QWORD *)y )\n    return *((_QWORD *)x + 1) == *((_QWORD *)y + 1);\n  return v3;\n}\n\n\n Revised code:\nstatic bool\nentry_compare (void const *x, void const *y)\n{\n  struct entry const *a = x;\n  struct entry const *b = y;\n  return SAME_INODE (*a, *b) ? true : false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_43708E()\n{\n  unsigned int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_436F0A(0LL);\n  if ( !v1 )\n    return (unsigned int)sub_436DF6();\n  return v1;\n}\n",
        "output": "```c\nstatic unsigned int\nsub_43708E(void)\n{\n  unsigned int result = sub_436F0A(0);\n\n  if (result == 0)\n    result = sub_436DF6();\n\n  return result;\n}\n```",
        "source_code": "static int if_readlist(void)\n{\n\tint err = if_readlist_proc(NULL);\n\t/* Needed in order to get ethN:M aliases */\n\tif (!err)\n\t\terr = if_readconf();\n\treturn err;\n}",
        "parsed_output": "static unsigned int\nsub_43708E(void)\n{\n  unsigned int result = sub_436F0A(0);\n\n  if (result == 0)\n    result = sub_436DF6();\n\n  return result;\n}",
        "baseline_code_stripped": "__int64 sub_43708E()\n{\n  unsigned int v1; // [rsp+Ch] [rbp-4h]\n\n  v1 = sub_436F0A(0LL);\n  if ( !v1 )\n    return (unsigned int)sub_436DF6();\n  return v1;\n}\n",
        "baseline_code_debug": "int __cdecl if_readlist()\n{\n  int err; // [rsp+Ch] [rbp-4h]\n\n  err = if_readlist_proc(0LL);\n  if ( !err )\n    return if_readconf();\n  return err;\n}\n",
        "similarity_score_unixcoder": 0.51307213306427,
        "similarity_score_baseline_stripped": 0.3653564453125,
        "similarity_score_baseline_debug": 0.6973474025726318
    },
    {
        "func_name": "get_label_uuid",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4A558D(unsigned int a1, _QWORD *a2, void **a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  void *v7; // rax\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  __int64 v13; // [rsp+28h] [rbp-18h] BYREF\n  __int64 v14; // [rsp+30h] [rbp-10h]\n  unsigned int v15; // [rsp+3Ch] [rbp-4h]\n\n  v15 = 1;\n  v14 = sub_4A5BC2(a1);\n  if ( ioctl(a1, 0x80081272uLL, &v13) )\n    v13 = 0LL;\n  if ( !(unsigned int)sub_4A5A83(v14, v13) && (*(_BYTE *)(v14 + 48) || *(_BYTE *)(v14 + 113)) )\n  {\n    v7 = sub_40A165((_BYTE *)(v14 + 48), 65LL, v3, v4, v5, v6);\n    *a2 = v7;\n    *a3 = sub_40A165((_BYTE *)(v14 + 113), 37LL, (__int64)v7, v8, v9, v10);\n    v15 = 0;\n  }\n  sub_4A5BEA(v14);\n  return v15;\n}\n",
        "output": "```c\nstatic unsigned int\nsub_4A558D(unsigned int a1, void **a2, void **a3)\n{\n  __int64 ioctl_data; // Used for ioctl call\n  __int64 resource_handle; // Handle to the resource\n  unsigned int result; // Result to return\n\n  result = 1; // Default to 1 (failure)\n  resource_handle = sub_4A5BC2(a1); // Get resource handle\n\n  // Attempt to get data via ioctl; if it fails, set ioctl_data to 0\n  if (ioctl(a1, 0x80081272uLL, &ioctl_data))\n    ioctl_data = 0LL;\n\n  // Check if the resource is valid and certain flags are set\n  if (!sub_4A5A83(resource_handle, ioctl_data) &&\n      (*(_BYTE *)(resource_handle + 48) || *(_BYTE *)(resource_handle + 113)))\n  {\n    // If valid, get pointers to specific data within the resource\n    *a2 = sub_40A165((_BYTE *)(resource_handle + 48), 65LL);\n    *a3 = sub_40A165((_BYTE *)(resource_handle + 113), 37LL);\n    result = 0; // Success\n  }\n\n  // Clean up the resource\n  sub_4A5BEA(resource_handle);\n\n  return result; // Return the result\n}\n```",
        "source_code": "static int\nget_label_uuid(int fd, char **label, char **uuid, const char **type)\n{\n\tint rv = 1;\n\tuint64_t size;\n\tstruct volume_id *vid;\n\n\t/* fd is owned by vid now */\n\tvid = volume_id_open_node(fd);\n\n\tif (ioctl(/*vid->*/fd, BLKGETSIZE64, &size) != 0)\n\t\tsize = 0;\n\n\tif (volume_id_probe_all(vid, /*0,*/ size) != 0)\n\t\tgoto ret;\n\n\tif (vid->label[0] != '\\0' || vid->uuid[0] != '\\0'\n#if ENABLE_FEATURE_BLKID_TYPE\n\t || vid->type != NULL\n#endif\n\t) {\n\t\t*label = xstrndup(vid->label, sizeof(vid->label));\n\t\t*uuid  = xstrndup(vid->uuid, sizeof(vid->uuid));\n#if ENABLE_FEATURE_BLKID_TYPE\n\t\t*type = vid->type;\n\t\tdbg(\"found label '%s', uuid '%s', type '%s'\", *label, *uuid, *type);\n#else\n\t\tdbg(\"found label '%s', uuid '%s'\", *label, *uuid);\n#endif\n\t\trv = 0;\n\t}\n ret:\n\tfree_volume_id(vid); /* also closes fd */\n\treturn rv;\n}",
        "parsed_output": "static unsigned int\nsub_4A558D(unsigned int a1, void **a2, void **a3)\n{\n  __int64 ioctl_data; // Used for ioctl call\n  __int64 resource_handle; // Handle to the resource\n  unsigned int result; // Result to return\n\n  result = 1; // Default to 1 (failure)\n  resource_handle = sub_4A5BC2(a1); // Get resource handle\n\n  // Attempt to get data via ioctl; if it fails, set ioctl_data to 0\n  if (ioctl(a1, 0x80081272uLL, &ioctl_data))\n    ioctl_data = 0LL;\n\n  // Check if the resource is valid and certain flags are set\n  if (!sub_4A5A83(resource_handle, ioctl_data) &&\n      (*(_BYTE *)(resource_handle + 48) || *(_BYTE *)(resource_handle + 113)))\n  {\n    // If valid, get pointers to specific data within the resource\n    *a2 = sub_40A165((_BYTE *)(resource_handle + 48), 65LL);\n    *a3 = sub_40A165((_BYTE *)(resource_handle + 113), 37LL);\n    result = 0; // Success\n  }\n\n  // Clean up the resource\n  sub_4A5BEA(resource_handle);\n\n  return result; // Return the result\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4A558D(unsigned int a1, _QWORD *a2, void **a3)\n{\n  __int64 v3; // rdx\n  __int64 v4; // rcx\n  __int64 v5; // r8\n  __int64 v6; // r9\n  void *v7; // rax\n  __int64 v8; // rcx\n  __int64 v9; // r8\n  __int64 v10; // r9\n  __int64 v13; // [rsp+28h] [rbp-18h] BYREF\n  __int64 v14; // [rsp+30h] [rbp-10h]\n  unsigned int v15; // [rsp+3Ch] [rbp-4h]\n\n  v15 = 1;\n  v14 = sub_4A5BC2(a1);\n  if ( ioctl(a1, 0x80081272uLL, &v13) )\n    v13 = 0LL;\n  if ( !(unsigned int)sub_4A5A83(v14, v13) && (*(_BYTE *)(v14 + 48) || *(_BYTE *)(v14 + 113)) )\n  {\n    v7 = sub_40A165((_BYTE *)(v14 + 48), 65LL, v3, v4, v5, v6);\n    *a2 = v7;\n    *a3 = sub_40A165((_BYTE *)(v14 + 113), 37LL, (__int64)v7, v8, v9, v10);\n    v15 = 0;\n  }\n  sub_4A5BEA(v14);\n  return v15;\n}\n",
        "baseline_code_debug": "int __cdecl get_label_uuid(int fd, char **label, char **uuid)\n{\n  uint64_t size; // [rsp+28h] [rbp-18h] BYREF\n  volume_id *vid; // [rsp+30h] [rbp-10h]\n  int rv; // [rsp+3Ch] [rbp-4h]\n\n  rv = 1;\n  vid = volume_id_open_node(fd);\n  if ( ioctl(fd, 0x80081272uLL, &size) )\n    size = 0LL;\n  if ( !volume_id_probe_all(vid, size) && (vid->label[0] || vid->uuid[0]) )\n  {\n    *label = xstrndup(vid->label, 65);\n    *uuid = xstrndup(vid->uuid, 37);\n    rv = 0;\n  }\n  free_volume_id(vid);\n  return rv;\n}\n",
        "similarity_score_unixcoder": 0.6039668917655945,
        "similarity_score_baseline_stripped": 0.5187649726867676,
        "similarity_score_baseline_debug": 0.9008561968803406
    },
    {
        "func_name": "start_dep_bb_writeout",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl cwrite(bool new_file_flag, const char *bp_0, size_t bytes)\n{\n  int *v3; // rax\n  const char *v4; // rax\n  int *v5; // rax\n  int *v6; // rax\n  const char *format; // [rsp+8h] [rbp-28h]\n  FILE *stream; // [rsp+10h] [rbp-20h]\n\n  if ( new_file_flag )\n  {\n    if ( output_desc >= 0 && close(output_desc) < 0 )\n    {\n      v3 = __errno_location();\n      error(1, *v3, \"%s\", outfile);\n    }\n    next_file_name();\n    if ( verbose )\n    {\n      stream = stderr;\n      format = gettext(\"creating file %s\\n\");\n      v4 = quote(outfile);\n      fprintf(stream, format, v4);\n    }\n    output_desc = open_safer(outfile, 577, 438LL);\n    if ( output_desc < 0 )\n    {\n      v5 = __errno_location();\n      error(1, *v5, \"%s\", outfile);\n    }\n  }\n  if ( full_write(output_desc, bp_0, bytes) != bytes )\n  {\n    v6 = __errno_location();\n    error(1, *v6, \"%s\", outfile);\n  }\n}\n\n\n Revised code:\nstatic void\ncwrite (bool new_file_flag, const char *bp, size_t bytes)\n{\n  if (new_file_flag)\n    {\n      if (output_desc >= 0 && close (output_desc) < 0)\n\terror (EXIT_FAILURE, errno, \"%s\", outfile);\n\n      next_file_name ();\n      if (verbose)\n\tfprintf (stderr, _(\"creating file %s\\n\"), quote (outfile));\n      output_desc = open (outfile,\n\t\t\t  O_WRONLY | O_CREAT | O_TRUNC | O_BINARY,\n\t\t\t  (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP\n\t\t\t   | S_IROTH | S_IWOTH));\n      if (output_desc < 0)\n\terror (EXIT_FAILURE, errno, \"%s\", outfile);\n    }\n  if (full_write (output_desc, bp, bytes) != bytes)\n    error (EXIT_FAILURE, errno, \"%s\", outfile);\n}\n\n## Example:\n\n Input code:\nbool __cdecl mode_changed(const char *file, mode_t old_mode, mode_t new_mode)\n{\n  const char *v3; // rax\n  const char *format; // [rsp+8h] [rbp-B8h]\n  int errnum; // [rsp+14h] [rbp-ACh]\n  stat new_stats; // [rsp+18h] [rbp-A8h] BYREF\n  mode_t new_modea; // [rsp+A8h] [rbp-18h]\n  mode_t old_modea; // [rsp+ACh] [rbp-14h]\n  const char *filea; // [rsp+B0h] [rbp-10h]\n\n  filea = file;\n  old_modea = old_mode;\n  new_modea = new_mode;\n  if ( (new_mode & 0xE00) == 0 )\n    return (((unsigned __int16)new_modea ^ (unsigned __int16)old_modea) & 0xFFF) != 0;\n  if ( !(unsigned int)stat_0((char *)filea, &new_stats) )\n  {\n    new_modea = new_stats.st_mode;\n    return (((unsigned __int16)new_modea ^ (unsigned __int16)old_modea) & 0xFFF) != 0;\n  }\n  if ( !force_silent )\n  {\n    errnum = *__errno_location();\n    format = gettext(\"getting new attributes of %s\");\n    v3 = quote(filea);\n    error(0, errnum, format, v3);\n  }\n  return 0;\n}\n\n\n Revised code:\nstatic bool\nmode_changed (char const *file, mode_t old_mode, mode_t new_mode)\n{\n  if (new_mode & (S_ISUID | S_ISGID | S_ISVTX))\n    {\n      /* The new mode contains unusual bits that the call to chmod may\n\t have silently cleared.  Check whether they actually changed.  */\n\n      struct stat new_stats;\n\n      if (stat (file, &new_stats) != 0)\n\t{\n\t  if (!force_silent)\n\t    error (0, errno, _(\"getting new attributes of %s\"), quote (file));\n\t  return false;\n\t}\n\n      new_mode = new_stats.st_mode;\n    }\n\n  return ((old_mode ^ new_mode) & CHMOD_MODE_BITS) != 0;\n}\n\n## Example:\n\n Input code:\nbool __cdecl wipefile(char *name, const char *qname, randint_source *s, const Options *flags)\n{\n  char *v4; // rax\n  char *v5; // rax\n  int v7; // [rsp+8h] [rbp-38h]\n  int errnum; // [rsp+Ch] [rbp-34h]\n  int fd; // [rsp+10h] [rbp-30h]\n  bool ok; // [rsp+17h] [rbp-29h]\n\n  fd = open_safer(name, 257);\n  if ( fd < 0 && *__errno_location() == 13 && flags->force && !chmod(name, 0x80u) )\n    fd = open_safer(name, 257);\n  if ( fd >= 0 )\n  {\n    ok = do_wipefd(fd, qname, s, flags);\n    if ( close(fd) )\n    {\n      v7 = *__errno_location();\n      v5 = gettext(\"%s: failed to close\");\n      error(0, v7, v5, qname);\n      ok = 0;\n    }\n    if ( ok && flags->remove_file )\n      return wipename(name, qname, flags);\n    return ok;\n  }\n  else\n  {\n    errnum = *__errno_location();\n    v4 = gettext(\"%s: failed to open for writing\");\n    error(0, errnum, v4, qname);\n    return 0;\n  }\n}\n\n\n Revised code:\nstatic bool\nwipefile (char *name, char const *qname,\n\t  struct randint_source *s, struct Options const *flags)\n{\n  bool ok;\n  int fd;\n\n  fd = open (name, O_WRONLY | O_NOCTTY | O_BINARY);\n  if (fd < 0\n      && (errno == EACCES && flags->force)\n      && chmod (name, S_IWUSR) == 0)\n    fd = open (name, O_WRONLY | O_NOCTTY | O_BINARY);\n  if (fd < 0)\n    {\n      error (0, errno, _(\"%s: failed to open for writing\"), qname);\n      return false;\n    }\n\n  ok = do_wipefd (fd, qname, s, flags);\n  if (close (fd) != 0)\n    {\n      error (0, errno, _(\"%s: failed to close\"), qname);\n      ok = false;\n    }\n  if (ok && flags->remove_file)\n    ok = wipename (name, qname, flags);\n  return ok;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_42522B()\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  int v5; // [rsp+8h] [rbp-8h]\n  int v6; // [rsp+Ch] [rbp-4h]\n\n  if ( *ident == 100 && (dword_75D450 & 1) != 0 )\n    return 1LL;\n  v6 = open64(\"modules.dep.bb.new\", 705, 420LL);\n  if ( v6 < 0 && *(_DWORD *)qword_75D400 == 17 )\n  {\n    v5 = 100;\n    do\n    {\n      usleep(0xC350u);\n      if ( (unsigned int)sub_42500D() )\n        return 4294967294LL;\n      --v5;\n    }\n    while ( v5 );\n    sub_409747(\"deleting stale %s\", (__int64)\"modules.dep.bb.new\", v1, v2, v3, v4);\n    return (unsigned int)sub_40A32A(\"modules.dep.bb.new\", 577);\n  }\n  return (unsigned int)v6;\n}\n",
        "output": "```c\nstatic int\nopen_new_module_dep(void)\n{\n  if (*ident == IDENT_VALUE && (flags & FLAG_CHECK) != 0)\n    return SUCCESS;\n\n  int fd = open(\"modules.dep.bb.new\", O_WRONLY | O_CREAT | O_TRUNC, 0644);\n  if (fd < 0 && errno == EBUSY)\n    {\n      int retries = MAX_RETRIES;\n      while (retries--)\n        {\n          usleep(RETRY_DELAY);\n          if (check_for_interrupt())\n            return INTERRUPTED;\n        }\n      log_error(\"deleting stale %s\", \"modules.dep.bb.new\");\n      return remove_file(\"modules.dep.bb.new\");\n    }\n  return fd;\n}\n```",
        "source_code": "static int start_dep_bb_writeout(void)\n{\n\tint fd;\n\n\t/* depmod -n: write result to stdout */\n\tif (applet_name[0] == 'd' && (option_mask32 & 1))\n\t\treturn STDOUT_FILENO;\n\n\tfd = open(DEPFILE_BB\".new\", O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0644);\n\tif (fd < 0) {\n\t\tif (errno == EEXIST) {\n\t\t\tint count = 5 * 20;\n\t\t\tdbg1_error_msg(DEPFILE_BB\".new exists, waiting for \"DEPFILE_BB);\n\t\t\twhile (1) {\n\t\t\t\tusleep(1000*1000 / 20);\n\t\t\t\tif (load_dep_bb()) {\n\t\t\t\t\tdbg1_error_msg(DEPFILE_BB\" appeared\");\n\t\t\t\t\treturn -2; /* magic number */\n\t\t\t\t}\n\t\t\t\tif (!--count)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbb_error_msg(\"deleting stale %s\", DEPFILE_BB\".new\");\n\t\t\tfd = open_or_warn(DEPFILE_BB\".new\", O_WRONLY | O_CREAT | O_TRUNC);\n\t\t}\n\t}\n\tdbg1_error_msg(\"opened \"DEPFILE_BB\".new:%d\", fd);\n\treturn fd;\n}",
        "parsed_output": "static int\nopen_new_module_dep(void)\n{\n  if (*ident == IDENT_VALUE && (flags & FLAG_CHECK) != 0)\n    return SUCCESS;\n\n  int fd = open(\"modules.dep.bb.new\", O_WRONLY | O_CREAT | O_TRUNC, 0644);\n  if (fd < 0 && errno == EBUSY)\n    {\n      int retries = MAX_RETRIES;\n      while (retries--)\n        {\n          usleep(RETRY_DELAY);\n          if (check_for_interrupt())\n            return INTERRUPTED;\n        }\n      log_error(\"deleting stale %s\", \"modules.dep.bb.new\");\n      return remove_file(\"modules.dep.bb.new\");\n    }\n  return fd;\n}",
        "baseline_code_stripped": "__int64 sub_42522B()\n{\n  __int64 v1; // rdx\n  __int64 v2; // rcx\n  __int64 v3; // r8\n  __int64 v4; // r9\n  int v5; // [rsp+8h] [rbp-8h]\n  int v6; // [rsp+Ch] [rbp-4h]\n\n  if ( *ident == 100 && (dword_75D450 & 1) != 0 )\n    return 1LL;\n  v6 = open64(\"modules.dep.bb.new\", 705, 420LL);\n  if ( v6 < 0 && *(_DWORD *)qword_75D400 == 17 )\n  {\n    v5 = 100;\n    do\n    {\n      usleep(0xC350u);\n      if ( (unsigned int)sub_42500D() )\n        return 4294967294LL;\n      --v5;\n    }\n    while ( v5 );\n    sub_409747(\"deleting stale %s\", (__int64)\"modules.dep.bb.new\", v1, v2, v3, v4);\n    return (unsigned int)sub_40A32A(\"modules.dep.bb.new\", 577);\n  }\n  return (unsigned int)v6;\n}\n",
        "baseline_code_debug": "int __cdecl start_dep_bb_writeout()\n{\n  int count; // [rsp+8h] [rbp-8h]\n  int fd; // [rsp+Ch] [rbp-4h]\n\n  if ( *applet_name == 100 && (option_mask32 & 1) != 0 )\n    return 1;\n  fd = open64(\"modules.dep.bb.new\", 705, 420LL);\n  if ( fd < 0 && *bb_errno == 17 )\n  {\n    count = 100;\n    do\n    {\n      usleep(0xC350u);\n      if ( load_dep_bb() )\n        return -2;\n      --count;\n    }\n    while ( count );\n    bb_error_msg(\"deleting stale %s\", \"modules.dep.bb.new\");\n    return open_or_warn(\"modules.dep.bb.new\", 577);\n  }\n  return fd;\n}\n",
        "similarity_score_unixcoder": 0.8380919098854065,
        "similarity_score_baseline_stripped": 0.7001581192016602,
        "similarity_score_baseline_debug": 0.85032057762146
    },
    {
        "func_name": "readtoken",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl component_len(const char *f)\n{\n  bool v2; // [rsp+1h] [rbp-11h]\n  size_t len; // [rsp+2h] [rbp-10h]\n\n  for ( len = 1LL; ; ++len )\n  {\n    v2 = 0;\n    if ( f[len] != 47 )\n      v2 = f[len] != 0;\n    if ( !v2 )\n      break;\n  }\n  return len;\n}\n\n\n Revised code:\nstatic size_t\ncomponent_len (char const *f)\n{\n  size_t len;\n  for (len = 1; f[len] != '/' && f[len]; len++)\n    continue;\n  return len;\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 sub_47DB13()\n{\n  __int64 v1; // [rsp+8h] [rbp-18h]\n  _BYTE *v2; // [rsp+10h] [rbp-10h]\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n\n  while ( 1 )\n  {\n    v3 = sub_47D959();\n    if ( (byte_75B058 & 4) != 0 )\n    {\n      while ( v3 == 1 )\n      {\n        sub_47DCB7();\n        v3 = sub_47D959();\n      }\n    }\n    if ( v3 != 3 || byte_75B05B )\n      break;\n    if ( (byte_75B058 & 2) != 0 )\n    {\n      v2 = sub_4774FB(qword_75B068);\n      if ( v2 )\n      {\n        v3 = (v2 - (_BYTE *)&off_51D220) >> 3;\n        byte_75B05C = (v2 - (_BYTE *)&off_51D220) >> 3;\n        break;\n      }\n    }\n    if ( (byte_75B058 & 1) == 0 )\n      break;\n    v1 = sub_47061E(qword_75B068, 1);\n    if ( !v1 )\n      break;\n    if ( **(_BYTE **)(v1 + 16) )\n      sub_479F0F(*(_QWORD *)(v1 + 16), v1);\n  }\n  byte_75B058 = 0;\n  return v3;\n}\n",
        "output": "```c\nstatic unsigned int\nprocess_input()\n{\n  unsigned int result;\n  _BYTE *pointer;\n  __int64 offset;\n\n  while (1)\n  {\n    result = get_next_input();\n    if (global_flags & FLAG_PROCESS)\n    {\n      while (result == INPUT_CONTINUE)\n      {\n        process_data();\n        result = get_next_input();\n      }\n    }\n    if (result != INPUT_END || global_condition)\n      break;\n    if (global_flags & FLAG_SPECIAL)\n    {\n      pointer = get_special_data(global_data_pointer);\n      if (pointer)\n      {\n        result = (pointer - BASE_ADDRESS) >> 3;\n        global_index = result;\n        break;\n      }\n    }\n    if (!(global_flags & FLAG_DEFAULT))\n      break;\n    offset = get_offset(global_data_pointer, 1);\n    if (!offset)\n      break;\n    if (**(_BYTE **)(offset + 16))\n      special_processing(*(_QWORD *)(offset + 16), offset);\n  }\n  global_flags = 0;\n  return result;\n}\n```",
        "source_code": "static int\nreadtoken(void)\n{\n\tint t;\n#if DEBUG\n\tsmallint alreadyseen = tokpushback;\n#endif\n\n#if ENABLE_ASH_ALIAS\n top:\n#endif\n\n\tt = xxreadtoken();\n\n\t/*\n\t * eat newlines\n\t */\n\tif (checkkwd & CHKNL) {\n\t\twhile (t == TNL) {\n\t\t\tparseheredoc();\n\t\t\tt = xxreadtoken();\n\t\t}\n\t}\n\n\tif (t != TWORD || quoteflag) {\n\t\tgoto out;\n\t}\n\n\t/*\n\t * check for keywords\n\t */\n\tif (checkkwd & CHKKWD) {\n\t\tconst char *const *pp;\n\n\t\tpp = findkwd(wordtext);\n\t\tif (pp) {\n\t\t\tlasttoken = t = pp - tokname_array;\n\t\t\tTRACE((\"keyword '%s' recognized\\n\", tokname_array[t] + 1));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (checkkwd & CHKALIAS) {\n#if ENABLE_ASH_ALIAS\n\t\tstruct alias *ap;\n\t\tap = lookupalias(wordtext, 1);\n\t\tif (ap != NULL) {\n\t\t\tif (*ap->val) {\n\t\t\t\tpushstring(ap->val, ap);\n\t\t\t}\n\t\t\tgoto top;\n\t\t}\n#endif\n\t}\n out:\n\tcheckkwd = 0;\n#if DEBUG\n\tif (!alreadyseen)\n\t\tTRACE((\"token '%s' %s\\n\", tokname_array[t] + 1, t == TWORD ? wordtext : \"\"));\n\telse\n\t\tTRACE((\"reread token '%s' %s\\n\", tokname_array[t] + 1, t == TWORD ? wordtext : \"\"));\n#endif\n\treturn t;\n}",
        "parsed_output": "static unsigned int\nprocess_input()\n{\n  unsigned int result;\n  _BYTE *pointer;\n  __int64 offset;\n\n  while (1)\n  {\n    result = get_next_input();\n    if (global_flags & FLAG_PROCESS)\n    {\n      while (result == INPUT_CONTINUE)\n      {\n        process_data();\n        result = get_next_input();\n      }\n    }\n    if (result != INPUT_END || global_condition)\n      break;\n    if (global_flags & FLAG_SPECIAL)\n    {\n      pointer = get_special_data(global_data_pointer);\n      if (pointer)\n      {\n        result = (pointer - BASE_ADDRESS) >> 3;\n        global_index = result;\n        break;\n      }\n    }\n    if (!(global_flags & FLAG_DEFAULT))\n      break;\n    offset = get_offset(global_data_pointer, 1);\n    if (!offset)\n      break;\n    if (**(_BYTE **)(offset + 16))\n      special_processing(*(_QWORD *)(offset + 16), offset);\n  }\n  global_flags = 0;\n  return result;\n}",
        "baseline_code_stripped": "__int64 sub_47DB13()\n{\n  __int64 v1; // [rsp+8h] [rbp-18h]\n  _BYTE *v2; // [rsp+10h] [rbp-10h]\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n\n  while ( 1 )\n  {\n    v3 = sub_47D959();\n    if ( (byte_75B058 & 4) != 0 )\n    {\n      while ( v3 == 1 )\n      {\n        sub_47DCB7();\n        v3 = sub_47D959();\n      }\n    }\n    if ( v3 != 3 || byte_75B05B )\n      break;\n    if ( (byte_75B058 & 2) != 0 )\n    {\n      v2 = sub_4774FB(qword_75B068);\n      if ( v2 )\n      {\n        v3 = (v2 - (_BYTE *)&off_51D220) >> 3;\n        byte_75B05C = (v2 - (_BYTE *)&off_51D220) >> 3;\n        break;\n      }\n    }\n    if ( (byte_75B058 & 1) == 0 )\n      break;\n    v1 = sub_47061E(qword_75B068, 1);\n    if ( !v1 )\n      break;\n    if ( **(_BYTE **)(v1 + 16) )\n      sub_479F0F(*(_QWORD *)(v1 + 16), v1);\n  }\n  byte_75B058 = 0;\n  return v3;\n}\n",
        "baseline_code_debug": "int __cdecl readtoken()\n{\n  alias *ap; // [rsp+8h] [rbp-18h]\n  const char *const *pp; // [rsp+10h] [rbp-10h]\n  int t; // [rsp+1Ch] [rbp-4h]\n\n  while ( 1 )\n  {\n    t = xxreadtoken();\n    if ( (checkkwd & 4) != 0 )\n    {\n      while ( t == 1 )\n      {\n        parseheredoc();\n        t = xxreadtoken();\n      }\n    }\n    if ( t != 3 || quoteflag )\n      break;\n    if ( (checkkwd & 2) != 0 )\n    {\n      pp = findkwd(wordtext);\n      if ( pp )\n      {\n        t = pp - tokname_array;\n        lasttoken[0] = pp - tokname_array;\n        break;\n      }\n    }\n    if ( (checkkwd & 1) == 0 )\n      break;\n    ap = lookupalias(wordtext, 1);\n    if ( !ap )\n      break;\n    if ( *ap->val )\n      pushstring(ap->val, ap);\n  }\n  checkkwd = 0;\n  return t;\n}\n",
        "similarity_score_unixcoder": 0.5511916279792786,
        "similarity_score_baseline_stripped": 0.5126530528068542,
        "similarity_score_baseline_debug": 0.8936251401901245
    },
    {
        "func_name": "check_header_gzip",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl sysv_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  int *v5; // rax\n  char *v6; // rax\n  size_t bytes_read; // [rsp+20h] [rbp-22E0h]\n  size_t i; // [rsp+28h] [rbp-22D8h]\n  _BYTE is_stdin[5]; // [rsp+33h] [rbp-22CDh]\n  char hbuf[652]; // [rsp+40h] [rbp-22C0h] BYREF\n  uintmax_t total_bytes; // [rsp+2D8h] [rbp-2028h]\n  unsigned __int8 buf[8192]; // [rsp+2E0h] [rbp-2020h] BYREF\n  int fd; // [rsp+22E8h] [rbp-18h]\n  int print_namea; // [rsp+22ECh] [rbp-14h]\n  const char *filea; // [rsp+22F0h] [rbp-10h]\n  char v17; // [rsp+22FFh] [rbp-1h]\n\n  filea = file;\n  print_namea = print_name;\n  total_bytes = 0LL;\n  is_stdin[4] = 0;\n  v2 = strcmp(file, \"-\");\n  *(_DWORD *)is_stdin = v2 == 0;\n  if ( !v2 )\n  {\n    fd = 0;\n    have_read_stdin = 1;\n    goto LABEL_5;\n  }\n  fd = open(filea, 0);\n  if ( fd == -1 )\n  {\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    v17 = 0;\n  }\n  else\n  {\nLABEL_5:\n    while ( 1 )\n    {\n      bytes_read = safe_read(fd, buf, 0x2000uLL);\n      if ( !bytes_read )\n        break;\n      if ( bytes_read == -1LL )\n      {\n        v4 = __errno_location();\n        error(0, *v4, \"%s\", filea);\n        if ( (is_stdin[0] & 1) == 0 )\n          close(fd);\n        v17 = 0;\n        return v17 & 1;\n      }\n      for ( i = 0LL; i < bytes_read; ++i )\n        *(_DWORD *)&is_stdin[1] += buf[i];\n      total_bytes += bytes_read;\n    }\n    if ( (is_stdin[0] & 1) != 0 || !close(fd) )\n    {\n      v6 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x200uLL);\n      printf(\n        \"%d %s\",\n        ((HIWORD(*(_DWORD *)&is_stdin[1]) + *(unsigned __int16 *)&is_stdin[1]) >> 16)\n      + (unsigned int)(unsigned __int16)(*(_WORD *)&is_stdin[3] + *(_WORD *)&is_stdin[1]),\n        v6);\n      if ( print_namea )\n        printf(\" %s\", filea);\n      putchar_unlocked(10);\n      v17 = 1;\n    }\n    else\n    {\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filea);\n      v17 = 0;\n    }\n  }\n  return v17 & 1;\n}\n\n\n Revised code:\nstatic bool\nsysv_sum_file (const char *file, int print_name)\n{\n  int fd;\n  unsigned char buf[8192];\n  uintmax_t total_bytes = 0;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int r;\n  int checksum;\n\n  /* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n  unsigned int s = 0;\n\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fd = STDIN_FILENO;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while (1)\n    {\n      size_t i;\n      size_t bytes_read = safe_read (fd, buf, sizeof buf);\n\n      if (bytes_read == 0)\n\tbreak;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  if (!is_stdin)\n\t    close (fd);\n\t  return false;\n\t}\n\n      for (i = 0; i < bytes_read; i++)\n\ts += buf[i];\n      total_bytes += bytes_read;\n    }\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  checksum = (r & 0xffff) + (r >> 16);\n\n  printf (\"%d %s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 512));\n  if (print_name)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4BA779(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rsi\n  unsigned int v4; // eax\n  __int64 v6; // [rsp+14h] [rbp-Ch]\n  int v7; // [rsp+1Ch] [rbp-4h]\n\n  *(_DWORD *)(a1 + 68) -= *(_DWORD *)(a1 + 64);\n  memmove(\n    *(void **)(a1 + 48),\n    (const void *)(*(_QWORD *)(a1 + 48) + *(unsigned int *)(a1 + 64)),\n    *(unsigned int *)(a1 + 68));\n  *(_DWORD *)(a1 + 64) = 0;\n  if ( !sub_4BA61D(a1, 8) )\n    return 0LL;\n  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + *(unsigned int *)(a1 + 64));\n  *(_DWORD *)(a1 + 64) += 8;\n  if ( (_BYTE)v6 != 8 )\n    return 0LL;\n  if ( (v6 & 0x400) != 0 )\n  {\n    if ( !sub_4BA61D(a1, 2) )\n      return 0LL;\n    v7 = (unsigned __int16)sub_4BA708(a1);\n    if ( !sub_4BA61D(a1, v7) )\n      return 0LL;\n    *(_DWORD *)(a1 + 64) += v7;\n  }\n  if ( (v6 & 0x1800) != 0 )\n  {\n    while ( sub_4BA61D(a1, 1) )\n    {\n      v3 = *(_QWORD *)(a1 + 48);\n      v4 = *(_DWORD *)(a1 + 64);\n      *(_DWORD *)(a1 + 64) = v4 + 1;\n      if ( !*(_BYTE *)(v3 + v4) )\n      {\n        if ( (BYTE1(v6) & 0x18) != 24 )\n          goto LABEL_17;\n        BYTE1(v6) &= 0xE7u;\n      }\n    }\n    return 0LL;\n  }\n  else\n  {\nLABEL_17:\n    if ( a2 )\n      *(_QWORD *)(a2 + 32) = *(unsigned int *)((char *)&v6 + 2);\n    if ( (v6 & 0x200) != 0 )\n    {\n      if ( !sub_4BA61D(a1, 2) )\n        return 0LL;\n      *(_DWORD *)(a1 + 64) += 2;\n    }\n    return 1LL;\n  }\n}\n",
        "output": "```c\nbool process_packet_header(__int64 packet, __int64 header_info)\n{\n  __int64 header_data; // rsi\n  unsigned int header_length; // eax\n  unsigned int flags; // [rsp+1Ch] [rbp-4h]\n\n  // Adjust the buffer by the already processed length\n  *(_DWORD *)(packet + 68) -= *(_DWORD *)(packet + 64);\n  memmove(\n    *(void **)(packet + 48),\n    (const void *)(*(_QWORD *)(packet + 48) + *(unsigned int *)(packet + 64)),\n    *(unsigned int *)(packet + 68));\n  *(_DWORD *)(packet + 64) = 0;\n\n  // Ensure there's at least 8 bytes to process the header\n  if (!sub_4BA61D(packet, 8))\n    return false;\n\n  // Read the header data and increment processed length\n  header_data = *(_QWORD *)(*(_QWORD *)(packet + 48) + *(unsigned int *)(packet + 64));\n  *(_DWORD *)(packet + 64) += 8;\n\n  // Check if the header type is correct\n  if ((unsigned char)header_data != 8)\n    return false;\n\n  // Extract flags from the header\n  flags = (unsigned int)header_data;\n\n  // If the 'extra header' flag is set, process the extra header\n  if ((flags & 0x400) != 0)\n  {\n    if (!sub_4BA61D(packet, 2))\n      return false;\n\n    header_length = (unsigned __int16)sub_4BA708(packet);\n    if (!sub_4BA61D(packet, header_length))\n      return false;\n\n    *(_DWORD *)(packet + 64) += header_length;\n  }\n\n  // If the 'name' or 'comment' flags are set, skip them\n  if ((flags & 0x1800) != 0)\n  {\n    while (sub_4BA61D(packet, 1))\n    {\n      header_data = *(_QWORD *)(packet + 48);\n      header_length = *(_DWORD *)(packet + 64);\n      *(_DWORD *)(packet + 64) = header_length + 1;\n\n      if (!*(_BYTE *)(header_data + header_length))\n      {\n        // If both 'name' and 'comment' flags are set, clear them\n        if ((BYTE1(flags) & 0x18) == 24)\n          BYTE1(flags) &= 0xE7u;\n        else\n          break;\n      }\n    }\n\n    // If we exited the loop without clearing the flags, it's an error\n    if ((BYTE1(flags) & 0x18) != 0)\n      return false;\n  }\n\n  // If header_info is provided, store the 'part number' from the header\n  if (header_info)\n    *(_QWORD *)(header_info + 32) = *(unsigned int *)((char *)&header_data + 2);\n\n  // If the 'original file size' flag is set, skip the next 2 bytes\n  if ((flags & 0x200) != 0)\n  {\n    if (!sub_4BA61D(packet, 2))\n      return false;\n\n    *(_DWORD *)(packet + 64) += 2;\n  }\n\n  return true;\n}\n```",
        "source_code": "static int check_header_gzip(STATE_PARAM transformer_aux_data_t *aux)\n{\n\tunion {\n\t\tunsigned char raw[8];\n\t\tstruct {\n\t\t\tuint8_t gz_method;\n\t\t\tuint8_t flags;\n\t\t\tuint32_t mtime;\n\t\t\tuint8_t xtra_flags_UNUSED;\n\t\t\tuint8_t os_flags_UNUSED;\n\t\t} PACKED formatted;\n\t} header;\n\tstruct BUG_header {\n\t\tchar BUG_header[sizeof(header) == 8 ? 1 : -1];\n\t};\n\n\t/*\n\t * Rewind bytebuffer. We use the beginning because the header has 8\n\t * bytes, leaving enough for unwinding afterwards.\n\t */\n\tbytebuffer_size -= bytebuffer_offset;\n\tmemmove(bytebuffer, &bytebuffer[bytebuffer_offset], bytebuffer_size);\n\tbytebuffer_offset = 0;\n\n\tif (!top_up(PASS_STATE 8))\n\t\treturn 0;\n\tmemcpy(header.raw, &bytebuffer[bytebuffer_offset], 8);\n\tbytebuffer_offset += 8;\n\n\t/* Check the compression method */\n\tif (header.formatted.gz_method != 8) {\n\t\treturn 0;\n\t}\n\n\tif (header.formatted.flags & 0x04) {\n\t\t/* bit 2 set: extra field present */\n\t\tunsigned extra_short;\n\n\t\tif (!top_up(PASS_STATE 2))\n\t\t\treturn 0;\n\t\textra_short = buffer_read_le_u16(PASS_STATE_ONLY);\n\t\tif (!top_up(PASS_STATE extra_short))\n\t\t\treturn 0;\n\t\t/* Ignore extra field */\n\t\tbytebuffer_offset += extra_short;\n\t}\n\n\t/* Discard original name and file comment if any */\n\t/* bit 3 set: original file name present */\n\t/* bit 4 set: file comment present */\n\tif (header.formatted.flags & 0x18) {\n\t\twhile (1) {\n\t\t\tdo {\n\t\t\t\tif (!top_up(PASS_STATE 1))\n\t\t\t\t\treturn 0;\n\t\t\t} while (bytebuffer[bytebuffer_offset++] != 0);\n\t\t\tif ((header.formatted.flags & 0x18) != 0x18)\n\t\t\t\tbreak;\n\t\t\theader.formatted.flags &= ~0x18;\n\t\t}\n\t}\n\n\tif (aux)\n\t\taux->mtime = SWAP_LE32(header.formatted.mtime);\n\n\t/* Read the header checksum */\n\tif (header.formatted.flags & 0x02) {\n\t\tif (!top_up(PASS_STATE 2))\n\t\t\treturn 0;\n\t\tbytebuffer_offset += 2;\n\t}\n\treturn 1;\n}",
        "parsed_output": "bool process_packet_header(__int64 packet, __int64 header_info)\n{\n  __int64 header_data; // rsi\n  unsigned int header_length; // eax\n  unsigned int flags; // [rsp+1Ch] [rbp-4h]\n\n  // Adjust the buffer by the already processed length\n  *(_DWORD *)(packet + 68) -= *(_DWORD *)(packet + 64);\n  memmove(\n    *(void **)(packet + 48),\n    (const void *)(*(_QWORD *)(packet + 48) + *(unsigned int *)(packet + 64)),\n    *(unsigned int *)(packet + 68));\n  *(_DWORD *)(packet + 64) = 0;\n\n  // Ensure there's at least 8 bytes to process the header\n  if (!sub_4BA61D(packet, 8))\n    return false;\n\n  // Read the header data and increment processed length\n  header_data = *(_QWORD *)(*(_QWORD *)(packet + 48) + *(unsigned int *)(packet + 64));\n  *(_DWORD *)(packet + 64) += 8;\n\n  // Check if the header type is correct\n  if ((unsigned char)header_data != 8)\n    return false;\n\n  // Extract flags from the header\n  flags = (unsigned int)header_data;\n\n  // If the 'extra header' flag is set, process the extra header\n  if ((flags & 0x400) != 0)\n  {\n    if (!sub_4BA61D(packet, 2))\n      return false;\n\n    header_length = (unsigned __int16)sub_4BA708(packet);\n    if (!sub_4BA61D(packet, header_length))\n      return false;\n\n    *(_DWORD *)(packet + 64) += header_length;\n  }\n\n  // If the 'name' or 'comment' flags are set, skip them\n  if ((flags & 0x1800) != 0)\n  {\n    while (sub_4BA61D(packet, 1))\n    {\n      header_data = *(_QWORD *)(packet + 48);\n      header_length = *(_DWORD *)(packet + 64);\n      *(_DWORD *)(packet + 64) = header_length + 1;\n\n      if (!*(_BYTE *)(header_data + header_length))\n      {\n        // If both 'name' and 'comment' flags are set, clear them\n        if ((BYTE1(flags) & 0x18) == 24)\n          BYTE1(flags) &= 0xE7u;\n        else\n          break;\n      }\n    }\n\n    // If we exited the loop without clearing the flags, it's an error\n    if ((BYTE1(flags) & 0x18) != 0)\n      return false;\n  }\n\n  // If header_info is provided, store the 'part number' from the header\n  if (header_info)\n    *(_QWORD *)(header_info + 32) = *(unsigned int *)((char *)&header_data + 2);\n\n  // If the 'original file size' flag is set, skip the next 2 bytes\n  if ((flags & 0x200) != 0)\n  {\n    if (!sub_4BA61D(packet, 2))\n      return false;\n\n    *(_DWORD *)(packet + 64) += 2;\n  }\n\n  return true;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4BA779(__int64 a1, __int64 a2)\n{\n  __int64 v3; // rsi\n  unsigned int v4; // eax\n  __int64 v6; // [rsp+14h] [rbp-Ch]\n  int v7; // [rsp+1Ch] [rbp-4h]\n\n  *(_DWORD *)(a1 + 68) -= *(_DWORD *)(a1 + 64);\n  memmove(\n    *(void **)(a1 + 48),\n    (const void *)(*(_QWORD *)(a1 + 48) + *(unsigned int *)(a1 + 64)),\n    *(unsigned int *)(a1 + 68));\n  *(_DWORD *)(a1 + 64) = 0;\n  if ( !sub_4BA61D(a1, 8) )\n    return 0LL;\n  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + *(unsigned int *)(a1 + 64));\n  *(_DWORD *)(a1 + 64) += 8;\n  if ( (_BYTE)v6 != 8 )\n    return 0LL;\n  if ( (v6 & 0x400) != 0 )\n  {\n    if ( !sub_4BA61D(a1, 2) )\n      return 0LL;\n    v7 = (unsigned __int16)sub_4BA708(a1);\n    if ( !sub_4BA61D(a1, v7) )\n      return 0LL;\n    *(_DWORD *)(a1 + 64) += v7;\n  }\n  if ( (v6 & 0x1800) != 0 )\n  {\n    while ( sub_4BA61D(a1, 1) )\n    {\n      v3 = *(_QWORD *)(a1 + 48);\n      v4 = *(_DWORD *)(a1 + 64);\n      *(_DWORD *)(a1 + 64) = v4 + 1;\n      if ( !*(_BYTE *)(v3 + v4) )\n      {\n        if ( (BYTE1(v6) & 0x18) != 24 )\n          goto LABEL_17;\n        BYTE1(v6) &= 0xE7u;\n      }\n    }\n    return 0LL;\n  }\n  else\n  {\nLABEL_17:\n    if ( a2 )\n      *(_QWORD *)(a2 + 32) = *(unsigned int *)((char *)&v6 + 2);\n    if ( (v6 & 0x200) != 0 )\n    {\n      if ( !sub_4BA61D(a1, 2) )\n        return 0LL;\n      *(_DWORD *)(a1 + 64) += 2;\n    }\n    return 1LL;\n  }\n}\n",
        "baseline_code_debug": "int __cdecl check_header_gzip(state_t_0 *state, transformer_aux_data_t_0 *aux)\n{\n  unsigned __int8 *bytebuffer; // rsi\n  unsigned int bytebuffer_offset; // eax\n  check_header_gzip::$25A85A0CAE023EA00841DC82EB010241 header; // [rsp+14h] [rbp-Ch]\n  unsigned int extra_short; // [rsp+1Ch] [rbp-4h]\n\n  state->bytebuffer_size -= state->bytebuffer_offset;\n  memmove(state->bytebuffer, &state->bytebuffer[state->bytebuffer_offset], state->bytebuffer_size);\n  state->bytebuffer_offset = 0;\n  if ( !top_up(state, 8u) )\n    return 0;\n  header = *(check_header_gzip::$25A85A0CAE023EA00841DC82EB010241 *)&state->bytebuffer[state->bytebuffer_offset];\n  state->bytebuffer_offset += 8;\n  if ( header.raw[0] != 8 )\n    return 0;\n  if ( (header.raw[1] & 4) != 0 )\n  {\n    if ( !top_up(state, 2u) )\n      return 0;\n    extra_short = buffer_read_le_u16(state);\n    if ( !top_up(state, extra_short) )\n      return 0;\n    state->bytebuffer_offset += extra_short;\n  }\n  if ( (header.raw[1] & 0x18) != 0 )\n  {\n    while ( top_up(state, 1u) )\n    {\n      bytebuffer = state->bytebuffer;\n      bytebuffer_offset = state->bytebuffer_offset;\n      state->bytebuffer_offset = bytebuffer_offset + 1;\n      if ( !bytebuffer[bytebuffer_offset] )\n      {\n        if ( (header.raw[1] & 0x18) != 24 )\n          goto LABEL_17;\n        header.raw[1] &= 0xE7u;\n      }\n    }\n    return 0;\n  }\n  else\n  {\nLABEL_17:\n    if ( aux )\n      aux->mtime = header.formatted.mtime;\n    if ( (header.raw[1] & 2) != 0 )\n    {\n      if ( !top_up(state, 2u) )\n        return 0;\n      state->bytebuffer_offset += 2;\n    }\n    return 1;\n  }\n}\n",
        "similarity_score_unixcoder": 0.7445107698440552,
        "similarity_score_baseline_stripped": 0.5617088079452515,
        "similarity_score_baseline_debug": 0.8584650754928589
    },
    {
        "func_name": "xmalloc_fgets_str_len",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl bsd_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  char *v5; // rax\n  unsigned int v7; // [rsp+14h] [rbp-2CCh]\n  bool is_stdin; // [rsp+1Fh] [rbp-2C1h]\n  char hbuf[652]; // [rsp+20h] [rbp-2C0h] BYREF\n  int ch_0; // [rsp+2ACh] [rbp-34h]\n  uintmax_t total_bytes; // [rsp+2B0h] [rbp-30h]\n  int checksum; // [rsp+2BCh] [rbp-24h]\n  FILE *fp; // [rsp+2C0h] [rbp-20h]\n  int print_namea; // [rsp+2CCh] [rbp-14h]\n  const char *filea; // [rsp+2D0h] [rbp-10h]\n\n  filea = file;\n  print_namea = print_name;\n  checksum = 0;\n  total_bytes = 0LL;\n  v2 = strcmp(file, \"-\");\n  is_stdin = v2 == 0;\n  if ( v2 )\n  {\n    fp = fopen(filea, \"r\");\n    if ( !fp )\n      goto LABEL_4;\n  }\n  else\n  {\n    fp = stdin;\n    have_read_stdin = 1;\n  }\n  while ( 1 )\n  {\n    ch_0 = getc_unlocked(fp);\n    if ( ch_0 == -1 )\n      break;\n    ++total_bytes;\n    checksum = (unsigned __int16)(((checksum & 1) << 15) + (checksum >> 1) + ch_0);\n  }\n  if ( ferror_unlocked(fp) )\n  {\n    v4 = __errno_location();\n    error(0, *v4, \"%s\", filea);\n    if ( !is_stdin )\n      fclose(fp);\n    return 0;\n  }\n  if ( !is_stdin && fclose(fp) )\n  {\nLABEL_4:\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    return 0;\n  }\n  v7 = checksum;\n  v5 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x400uLL);\n  printf(\"%05d %5s\", v7, v5);\n  if ( print_namea > 1 )\n    printf(\" %s\", filea);\n  putchar_unlocked(10);\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_sum_file (const char *file, int print_name)\n{\n  FILE *fp;\n  int checksum = 0;\t/* The checksum mod 2^16. */\n  uintmax_t total_bytes = 0;\t/* The number of bytes. */\n  int ch;\t\t/* Each character read. */\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fp = stdin;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fp = fopen (file, (O_BINARY ? \"rb\" : \"r\"));\n      if (fp == NULL)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while ((ch = getc (fp)) != EOF)\n    {\n      total_bytes++;\n      checksum = (checksum >> 1) + ((checksum & 1) << 15);\n      checksum += ch;\n      checksum &= 0xffff;\t/* Keep it within bounds. */\n    }\n\n  if (ferror (fp))\n    {\n      error (0, errno, \"%s\", file);\n      if (!is_stdin)\n\tfclose (fp);\n      return false;\n    }\n\n  if (!is_stdin && fclose (fp) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  printf (\"%05d %5s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 1024));\n  if (print_name > 1)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\noperand_0 *__cdecl scan_arg(operand_0 *retstr, const char *arg)\n{\n  char *v2; // rax\n  const char *v3; // rsi\n  char v5; // [rsp+3h] [rbp-6Dh]\n  int v6; // [rsp+4h] [rbp-6Ch]\n  size_t fraction_len; // [rsp+30h] [rbp-40h]\n  char *decimal_point; // [rsp+38h] [rbp-38h]\n  operand_0 ret; // [rsp+40h] [rbp-30h] BYREF\n  const char *arga; // [rsp+68h] [rbp-8h]\n\n  arga = arg;\n  if ( !xstrtold(arg, 0LL, &ret.value, (long double (*)(const char *, char **))c_strtold) )\n  {\n    v2 = gettext(\"invalid floating point argument: %s\");\n    error(0, 0, v2, arga);\n    usage(1);\n  }\n  ret.width = strlen(arga);\n  ret.precision = 0x7FFFFFFF;\n  v3 = arga;\n  if ( !v3[strcspn(arga, \"eExX\")] && ret.value * 0.0 == 0.0 )\n  {\n    decimal_point = strchr(arga, 46);\n    if ( decimal_point )\n    {\n      fraction_len = strlen(decimal_point + 1);\n      if ( fraction_len <= 0x7FFFFFFF )\n        ret.precision = fraction_len;\n      if ( fraction_len )\n      {\n        v5 = 1;\n        if ( decimal_point != arga )\n          v5 = ~((unsigned int)(*(decimal_point - 1) - 48) <= 9);\n        v6 = v5 & 1;\n      }\n      else\n      {\n        v6 = -1;\n      }\n      ret.width += v6;\n    }\n    else\n    {\n      ret.precision = 0;\n    }\n  }\n  *retstr = ret;\n  return retstr;\n}\n\n\n Revised code:\nstatic operand\nscan_arg (const char *arg)\n{\n  operand ret;\n\n  if (! xstrtold (arg, NULL, &ret.value, c_strtold))\n    {\n      error (0, 0, _(\"invalid floating point argument: %s\"), arg);\n      usage (EXIT_FAILURE);\n    }\n\n  ret.width = strlen (arg);\n  ret.precision = INT_MAX;\n\n  if (! arg[strcspn (arg, \"eExX\")] && isfinite (ret.value))\n    {\n      char const *decimal_point = strchr (arg, '.');\n      if (! decimal_point)\n\tret.precision = 0;\n      else\n\t{\n\t  size_t fraction_len = strlen (decimal_point + 1);\n\t  if (fraction_len <= INT_MAX)\n\t    ret.precision = fraction_len;\n\t  ret.width += (fraction_len == 0\n\t\t\t? -1\n\t\t\t: (decimal_point == arg\n\t\t\t   || ! ISDIGIT (decimal_point[-1])));\n\t}\n    }\n\n  return ret;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_4F9594(FILE *a1, const char *a2, unsigned __int64 *a3)\n{\n  unsigned __int64 *v4; // [rsp+8h] [rbp-28h]\n  __int64 v5; // [rsp+28h] [rbp-8h] BYREF\n\n  v4 = a3;\n  if ( !a3 )\n  {\n    v5 = 2147479552LL;\n    v4 = (unsigned __int64 *)&v5;\n  }\n  return sub_4F9400(a1, a2, 0, v4);\n}\n",
        "output": "```c\nstatic char *\nread_line (FILE *stream, const char *delimiters, unsigned __int64 *length_ptr)\n{\n  unsigned __int64 default_length = 2147479552; // Default length if length_ptr is NULL\n  if (!length_ptr)\n    length_ptr = &default_length;\n\n  return get_line_from_stream (stream, delimiters, 0, length_ptr);\n}\n```",
        "source_code": "FAST_FUNC xmalloc_fgets_str_len(FILE *file, const char *terminating_string, size_t *maxsz_p)\n{\n\tsize_t maxsz;\n\n\tif (!maxsz_p) {\n\t\tmaxsz = INT_MAX - 4095;\n\t\tmaxsz_p = &maxsz;\n\t}\n\treturn xmalloc_fgets_internal(file, terminating_string, 0, maxsz_p);\n}",
        "parsed_output": "static char *\nread_line (FILE *stream, const char *delimiters, unsigned __int64 *length_ptr)\n{\n  unsigned __int64 default_length = 2147479552; // Default length if length_ptr is NULL\n  if (!length_ptr)\n    length_ptr = &default_length;\n\n  return get_line_from_stream (stream, delimiters, 0, length_ptr);\n}",
        "baseline_code_stripped": "char *__fastcall sub_4F9594(FILE *a1, const char *a2, unsigned __int64 *a3)\n{\n  unsigned __int64 *v4; // [rsp+8h] [rbp-28h]\n  __int64 v5; // [rsp+28h] [rbp-8h] BYREF\n\n  v4 = a3;\n  if ( !a3 )\n  {\n    v5 = 2147479552LL;\n    v4 = (unsigned __int64 *)&v5;\n  }\n  return sub_4F9400(a1, a2, 0, v4);\n}\n",
        "baseline_code_debug": "char *__cdecl xmalloc_fgets_str_len(FILE *file, const char *terminating_string, size_t *maxsz_p)\n{\n  size_t *maxsz_pa; // [rsp+8h] [rbp-28h]\n  size_t maxsz; // [rsp+28h] [rbp-8h] BYREF\n\n  maxsz_pa = maxsz_p;\n  if ( !maxsz_p )\n  {\n    maxsz = 2147479552LL;\n    maxsz_pa = &maxsz;\n  }\n  return xmalloc_fgets_internal(file, terminating_string, 0, maxsz_pa);\n}\n",
        "similarity_score_unixcoder": 0.6347833275794983,
        "similarity_score_baseline_stripped": 0.4208265542984009,
        "similarity_score_baseline_debug": 0.8513042330741882
    },
    {
        "func_name": "if_print",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nbool __cdecl simple_strtoul(const char *s, const char **p, unsigned __int64 *val)\n{\n  const char *v3; // rsi\n  int c; // [rsp+0h] [rbp-2Ch]\n  unsigned __int64 sum; // [rsp+4h] [rbp-28h]\n\n  sum = 0LL;\n  while ( (unsigned int)(*s - 48) <= 9 )\n  {\n    v3 = s++;\n    c = *v3 - 48;\n    if ( sum > (-1LL - c) / 0xAuLL )\n      return 0;\n    sum = c + 10 * sum;\n  }\n  *p = s;\n  *val = sum;\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nsimple_strtoul (const char *s, const char **p, unsigned long int *val)\n{\n  unsigned long int sum;\n\n  sum = 0;\n  while (ISDIGIT (*s))\n    {\n      int c = *s++ - '0';\n      if (sum > (ULONG_MAX - c) / 10)\n\treturn false;\n      sum = sum * 10 + c;\n    }\n  *p = s;\n  *val = sum;\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_438102(const char *a1, __int64 a2)\n{\n  int v3; // [rsp+10h] [rbp-10h]\n  unsigned int v4; // [rsp+14h] [rbp-Ch]\n  _QWORD *i; // [rsp+18h] [rbp-8h]\n  char *v6; // [rsp+18h] [rbp-8h]\n\n  if ( a1 )\n  {\n    v6 = sub_4380C1(a1, a2);\n    v3 = sub_437470(v6);\n    if ( v3 >= 0 )\n      sub_437AA4((__int64)v6);\n    return (unsigned int)v3;\n  }\n  else if ( qword_75B170 || (int)sub_43708E() >= 0 )\n  {\n    for ( i = (_QWORD *)qword_75B170; i; i = (_QWORD *)*i )\n    {\n      v4 = sub_438074((__int64)i);\n      if ( v4 )\n        return v4;\n    }\n    return 0LL;\n  }\n  else\n  {\n    return 0xFFFFFFFFLL;\n  }\n}\n",
        "output": "```c\nstatic unsigned int\nprocess_input(const char *input, __int64 arg)\n{\n  int result;\n  unsigned int error_code;\n  char *processed_input;\n  _QWORD *current;\n\n  if (input)\n  {\n    processed_input = preprocess_input(input, arg);\n    result = perform_operation(processed_input);\n    if (result >= 0)\n      cleanup(processed_input);\n    return (unsigned int)result;\n  }\n  else if (global_flag || perform_initial_check() >= 0)\n  {\n    for (current = (_QWORD *)global_list; current; current = (_QWORD *)*current)\n    {\n      error_code = check_entry((__int64)current);\n      if (error_code)\n        return error_code;\n    }\n    return 0;\n  }\n  else\n  {\n    return (unsigned int)-1;\n  }\n}\n```",
        "source_code": "static int if_print(char *ifname)\n{\n\tstruct interface *ife;\n\tint res;\n\n\tif (!ifname) {\n\t\t/*res = for_all_interfaces(do_if_print, &interface_opt_a);*/\n\t\tif (!int_list && (if_readlist() < 0))\n\t\t\treturn -1;\n\t\tfor (ife = int_list; ife; ife = ife->next) {\n\t\t\tint err = do_if_print(ife); /*, &interface_opt_a);*/\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\tife = lookup_interface(ifname);\n\tres = do_if_fetch(ife);\n\tif (res >= 0)\n\t\tife_print(ife);\n\treturn res;\n}",
        "parsed_output": "static unsigned int\nprocess_input(const char *input, __int64 arg)\n{\n  int result;\n  unsigned int error_code;\n  char *processed_input;\n  _QWORD *current;\n\n  if (input)\n  {\n    processed_input = preprocess_input(input, arg);\n    result = perform_operation(processed_input);\n    if (result >= 0)\n      cleanup(processed_input);\n    return (unsigned int)result;\n  }\n  else if (global_flag || perform_initial_check() >= 0)\n  {\n    for (current = (_QWORD *)global_list; current; current = (_QWORD *)*current)\n    {\n      error_code = check_entry((__int64)current);\n      if (error_code)\n        return error_code;\n    }\n    return 0;\n  }\n  else\n  {\n    return (unsigned int)-1;\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_438102(const char *a1, __int64 a2)\n{\n  int v3; // [rsp+10h] [rbp-10h]\n  unsigned int v4; // [rsp+14h] [rbp-Ch]\n  _QWORD *i; // [rsp+18h] [rbp-8h]\n  char *v6; // [rsp+18h] [rbp-8h]\n\n  if ( a1 )\n  {\n    v6 = sub_4380C1(a1, a2);\n    v3 = sub_437470(v6);\n    if ( v3 >= 0 )\n      sub_437AA4((__int64)v6);\n    return (unsigned int)v3;\n  }\n  else if ( qword_75B170 || (int)sub_43708E() >= 0 )\n  {\n    for ( i = (_QWORD *)qword_75B170; i; i = (_QWORD *)*i )\n    {\n      v4 = sub_438074((__int64)i);\n      if ( v4 )\n        return v4;\n    }\n    return 0LL;\n  }\n  else\n  {\n    return 0xFFFFFFFFLL;\n  }\n}\n",
        "baseline_code_debug": "int __cdecl if_print(char *ifname)\n{\n  int res; // [rsp+10h] [rbp-10h]\n  int err; // [rsp+14h] [rbp-Ch]\n  interface *ife; // [rsp+18h] [rbp-8h]\n  interface *ifea; // [rsp+18h] [rbp-8h]\n\n  if ( ifname )\n  {\n    ifea = lookup_interface(ifname);\n    res = do_if_fetch(ifea);\n    if ( res >= 0 )\n      ife_print(ifea);\n    return res;\n  }\n  else if ( int_list || if_readlist() >= 0 )\n  {\n    for ( ife = int_list; ife; ife = ife->next )\n    {\n      err = do_if_print(ife);\n      if ( err )\n        return err;\n    }\n    return 0;\n  }\n  else\n  {\n    return -1;\n  }\n}\n",
        "similarity_score_unixcoder": 0.5129526257514954,
        "similarity_score_baseline_stripped": 0.45179006457328796,
        "similarity_score_baseline_debug": 0.8385350108146667
    },
    {
        "func_name": "recursive_check",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nbool __cdecl du_files(char **files, int bit_flags)\n{\n  char *v2; // rax\n  char *v3; // rax\n  int errnum; // [rsp+Ch] [rbp-24h]\n  FTSENT *ent; // [rsp+10h] [rbp-20h]\n  FTS *fts; // [rsp+18h] [rbp-18h]\n  bool ok; // [rsp+23h] [rbp-Dh]\n\n  ok = 1;\n  if ( *files )\n  {\n    for ( fts = xfts_open(files, bit_flags, 0LL); ; ok = process_file(fts, ent) && ok )\n    {\n      ent = fts_read(fts);\n      if ( !ent )\n        break;\n    }\n    if ( *__errno_location() )\n    {\n      errnum = *__errno_location();\n      v2 = gettext(\"fts_read failed\");\n      error(0, errnum, v2);\n      ok = 0;\n    }\n    fts_close(fts);\n  }\n  if ( print_grand_total )\n  {\n    v3 = gettext(\"total\");\n    print_size(&tot_dui, v3);\n  }\n  return ok;\n}\n\n\n Revised code:\nstatic bool\ndu_files (char **files, int bit_flags)\n{\n  bool ok = true;\n\n  if (*files)\n    {\n      FTS *fts = xfts_open (files, bit_flags, NULL);\n\n      while (1)\n\t{\n\t  FTSENT *ent;\n\n\t  ent = fts_read (fts);\n\t  if (ent == NULL)\n\t    {\n\t      if (errno != 0)\n\t\t{\n\t\t  /* FIXME: try to give a better message  */\n\t\t  error (0, errno, _(\"fts_read failed\"));\n\t\t  ok = false;\n\t\t}\n\t      break;\n\t    }\n\t  FTS_CROSS_CHECK (fts);\n\n\t  ok &= process_file (fts, ent);\n\t}\n\n      /* Ignore failure, since the only way it can do so is in failing to\n\t return to the original directory, and since we're about to exit,\n\t that doesn't matter.  */\n      fts_close (fts);\n    }\n\n  if (print_grand_total)\n    print_size (&tot_dui, _(\"total\"));\n\n  return ok;\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl component_len(const char *f)\n{\n  bool v2; // [rsp+1h] [rbp-11h]\n  size_t len; // [rsp+2h] [rbp-10h]\n\n  for ( len = 1LL; ; ++len )\n  {\n    v2 = 0;\n    if ( f[len] != 47 )\n      v2 = f[len] != 0;\n    if ( !v2 )\n      break;\n  }\n  return len;\n}\n\n\n Revised code:\nstatic size_t\ncomponent_len (char const *f)\n{\n  size_t len;\n  for (len = 1; f[len] != '/' && f[len]; len++)\n    continue;\n  return len;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_49828D(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 result; // rax\n  __int64 v8; // [rsp+10h] [rbp-10h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  v6 = 32LL * a1 - 32;\n  v8 = v6 + *((_QWORD *)qword_75D408 + 6);\n  if ( (*(_WORD *)v8 & 0xF000) != 0x4000 )\n    sub_495EC2((__int64)\"internal error\", a2, v6, a4, a5, a6);\n  if ( *(_DWORD *)(v8 + 4) < (unsigned int)(2 * *((char *)qword_75D408 + 4)) )\n  {\n    printf(\"%s: bad directory: size<32\", (const char *)qword_75D408 + 5540);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  for ( i = 0; ; i += *((char *)qword_75D408 + 4) )\n  {\n    result = *(unsigned int *)(v8 + 4);\n    if ( i >= (unsigned int)result )\n      break;\n    sub_497D29(v8, i);\n  }\n  return result;\n}\n",
        "output": "```c\nstatic __int64\nsub_49828D(unsigned int index, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 entry_offset;\n  __int64 result;\n  __int64 entry_ptr;\n  unsigned int i;\n\n  entry_offset = 32LL * index - 32;\n  entry_ptr = entry_offset + *((_QWORD *)qword_75D408 + 6);\n  if ((*(_WORD *)entry_ptr & 0xF000) != 0x4000)\n    sub_495EC2(\"internal error\", a2, entry_offset, a4, a5, a6);\n\n  if (*(_DWORD *)(entry_ptr + 4) < (unsigned int)(2 * *((char *)qword_75D408 + 4)))\n  {\n    printf(\"%s: bad directory: size<32\", (const char *)qword_75D408 + 5540);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n\n  for (i = 0; ; i += *((char *)qword_75D408 + 4))\n  {\n    result = *(unsigned int *)(entry_ptr + 4);\n    if (i >= (unsigned int)result)\n      break;\n    sub_497D29(entry_ptr, i);\n  }\n\n  return result;\n}\n```",
        "source_code": "endif\n\nstatic void recursive_check(unsigned ino)\n{\n\tstruct minix1_inode *dir;\n\tunsigned offset;\n\n\tdir = Inode1 + ino;\n\tif (!S_ISDIR(dir->i_mode))\n\t\tdie(\"internal error\");\n\tif (dir->i_size < 2 * dirsize) {\n\t\tprintf(\"%s: bad directory: size<32\", current_name);\n\t\terrors_uncorrected = 1;\n\t}\n\tfor (offset = 0; offset < dir->i_size; offset += dirsize)\n\t\tcheck_file(dir, offset);\n}",
        "parsed_output": "static __int64\nsub_49828D(unsigned int index, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 entry_offset;\n  __int64 result;\n  __int64 entry_ptr;\n  unsigned int i;\n\n  entry_offset = 32LL * index - 32;\n  entry_ptr = entry_offset + *((_QWORD *)qword_75D408 + 6);\n  if ((*(_WORD *)entry_ptr & 0xF000) != 0x4000)\n    sub_495EC2(\"internal error\", a2, entry_offset, a4, a5, a6);\n\n  if (*(_DWORD *)(entry_ptr + 4) < (unsigned int)(2 * *((char *)qword_75D408 + 4)))\n  {\n    printf(\"%s: bad directory: size<32\", (const char *)qword_75D408 + 5540);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n\n  for (i = 0; ; i += *((char *)qword_75D408 + 4))\n  {\n    result = *(unsigned int *)(entry_ptr + 4);\n    if (i >= (unsigned int)result)\n      break;\n    sub_497D29(entry_ptr, i);\n  }\n\n  return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_49828D(unsigned int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)\n{\n  __int64 v6; // rdx\n  __int64 result; // rax\n  __int64 v8; // [rsp+10h] [rbp-10h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  v6 = 32LL * a1 - 32;\n  v8 = v6 + *((_QWORD *)qword_75D408 + 6);\n  if ( (*(_WORD *)v8 & 0xF000) != 0x4000 )\n    sub_495EC2((__int64)\"internal error\", a2, v6, a4, a5, a6);\n  if ( *(_DWORD *)(v8 + 4) < (unsigned int)(2 * *((char *)qword_75D408 + 4)) )\n  {\n    printf(\"%s: bad directory: size<32\", (const char *)qword_75D408 + 5540);\n    *((_BYTE *)qword_75D408 + 2) = 1;\n  }\n  for ( i = 0; ; i += *((char *)qword_75D408 + 4) )\n  {\n    result = *(unsigned int *)(v8 + 4);\n    if ( i >= (unsigned int)result )\n      break;\n    sub_497D29(v8, i);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl recursive_check(unsigned int ino)\n{\n  minix1_inode *dir; // [rsp+10h] [rbp-10h]\n  unsigned int offset; // [rsp+1Ch] [rbp-4h]\n\n  dir = (minix1_inode *)(32LL * ino - 32 + *(_QWORD *)&ptr_to_globals->numspeed);\n  if ( (dir->i_mode & 0xF000) != 0x4000 )\n    die(\"internal error\");\n  if ( dir->i_size < 2 * *((char *)&ptr_to_globals->timeout + 4) )\n  {\n    printf(\"%s: bad directory: size<32\", (const char *)&ptr_to_globals[19].speeds[4]);\n    BYTE2(ptr_to_globals->timeout) = 1;\n  }\n  for ( offset = 0; offset < dir->i_size; offset += *((char *)&ptr_to_globals->timeout + 4) )\n    check_file(dir, offset);\n}\n",
        "similarity_score_unixcoder": 0.6341172456741333,
        "similarity_score_baseline_stripped": 0.5752251744270325,
        "similarity_score_baseline_debug": 0.7596282958984375
    },
    {
        "func_name": "rtnl_rtscope_n2a",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl adjust_column(size_t column, char c)\n{\n  size_t columna; // [rsp+2h] [rbp-8h]\n\n  columna = column;\n  if ( count_bytes )\n    return column + 1;\n  switch ( c )\n  {\n    case 8:\n      if ( column )\n        return column - 1;\n      break;\n    case 13:\n      return 0LL;\n    case 9:\n      return column + 8 - (column & 7);\n    default:\n      return column + 1;\n  }\n  return columna;\n}\n\n\n Revised code:\nstatic size_t\nadjust_column (size_t column, char c)\n{\n  if (!count_bytes)\n    {\n      if (c == '\\b')\n\t{\n\t  if (column > 0)\n\t    column--;\n\t}\n      else if (c == '\\r')\n\tcolumn = 0;\n      else if (c == '\\t')\n\tcolumn += TAB_WIDTH - column % TAB_WIDTH;\n      else /* if (isprint (c)) */\n\tcolumn++;\n    }\n  else\n    column++;\n  return column;\n}\n\n## Example:\n\n Input code:\nbool __cdecl simple_strtoul(const char *s, const char **p, unsigned __int64 *val)\n{\n  const char *v3; // rsi\n  int c; // [rsp+0h] [rbp-2Ch]\n  unsigned __int64 sum; // [rsp+4h] [rbp-28h]\n\n  sum = 0LL;\n  while ( (unsigned int)(*s - 48) <= 9 )\n  {\n    v3 = s++;\n    c = *v3 - 48;\n    if ( sum > (-1LL - c) / 0xAuLL )\n      return 0;\n    sum = c + 10 * sum;\n  }\n  *p = s;\n  *val = sum;\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nsimple_strtoul (const char *s, const char **p, unsigned long int *val)\n{\n  unsigned long int sum;\n\n  sum = 0;\n  while (ISDIGIT (*s))\n    {\n      int c = *s++ - '0';\n      if (sum > (ULONG_MAX - c) / 10)\n\treturn false;\n      sum = sum * 10 + c;\n    }\n  *p = s;\n  *val = sum;\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_452599(__int64 a1, char *a2)\n{\n  if ( (unsigned int)a1 < 0x100 )\n  {\n    sub_452500(a1, (__int64)a2);\n    if ( *(_QWORD *)(qword_75B1C0 + 8 * ((int)a1 + 2LL)) )\n      return *(char **)(qword_75B1C0 + 8 * ((int)a1 + 2LL));\n  }\n  sprintf(a2, \"%d\", (unsigned int)a1);\n  return a2;\n}\n",
        "output": "```c\nstatic char *\nformat_error_code (unsigned int error_code, char *buffer)\n{\n  if (error_code < 256)\n    {\n      log_error_code(error_code);\n      char **error_message_ptr = (char **)(error_table + 8 * (error_code + 2));\n      if (*error_message_ptr)\n        return *error_message_ptr;\n    }\n  sprintf(buffer, \"%u\", error_code);\n  return buffer;\n}\n```",
        "source_code": "FAST_FUNC rtnl_rtscope_n2a(int id, char *buf)\n{\n\tif (id < 0 || id >= 256) {\n\t\tsprintf(buf, \"%d\", id);\n\t\treturn buf;\n\t}\n\n\trtnl_rtscope_initialize();\n\n\tif (rtnl_rtscope_tab->tab[id])\n\t\treturn rtnl_rtscope_tab->tab[id];\n\t/* buf is SPRINT_BSIZE big */\n\tsprintf(buf, \"%d\", id);\n\treturn buf;\n}",
        "parsed_output": "static char *\nformat_error_code (unsigned int error_code, char *buffer)\n{\n  if (error_code < 256)\n    {\n      log_error_code(error_code);\n      char **error_message_ptr = (char **)(error_table + 8 * (error_code + 2));\n      if (*error_message_ptr)\n        return *error_message_ptr;\n    }\n  sprintf(buffer, \"%u\", error_code);\n  return buffer;\n}",
        "baseline_code_stripped": "char *__fastcall sub_452599(__int64 a1, char *a2)\n{\n  if ( (unsigned int)a1 < 0x100 )\n  {\n    sub_452500(a1, (__int64)a2);\n    if ( *(_QWORD *)(qword_75B1C0 + 8 * ((int)a1 + 2LL)) )\n      return *(char **)(qword_75B1C0 + 8 * ((int)a1 + 2LL));\n  }\n  sprintf(a2, \"%d\", (unsigned int)a1);\n  return a2;\n}\n",
        "baseline_code_debug": "const char *__cdecl rtnl_rtscope_n2a(int id, char *buf)\n{\n  if ( (unsigned int)id < 0x100 )\n  {\n    rtnl_rtscope_initialize();\n    if ( rtnl_rtscope_tab->tab[id] )\n      return rtnl_rtscope_tab->tab[id];\n  }\n  sprintf(buf, \"%d\", (unsigned int)id);\n  return buf;\n}\n",
        "similarity_score_unixcoder": 0.5424962043762207,
        "similarity_score_baseline_stripped": 0.5590986013412476,
        "similarity_score_baseline_debug": 0.9341627359390259
    },
    {
        "func_name": "make_new_name_gunzip",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl no_leading_hyphen(const char *file)\n{\n  const char *v1; // rax\n  const char *format; // [rsp+0h] [rbp-20h]\n  const char *p; // [rsp+8h] [rbp-18h]\n  char *pa; // [rsp+8h] [rbp-18h]\n\n  for ( p = file; ; p = pa + 1 )\n  {\n    pa = strchr(p, 45);\n    if ( !pa )\n      break;\n    if ( pa == file || *(pa - 1) == 47 )\n    {\n      format = gettext(\"leading `-' in a component of file name %s\");\n      v1 = quote(file);\n      error(0, 0, format, v1);\n      return 0;\n    }\n  }\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nno_leading_hyphen (char const *file)\n{\n  char const *p;\n\n  for (p = file;  (p = strchr (p, '-'));  p++)\n    if (p == file || p[-1] == '/')\n      {\n\terror (0, 0, _(\"leading `-' in a component of file name %s\"),\n\t       quote (file));\n\treturn false;\n      }\n\n  return true;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl get_format_conv_type(char **format_ptr)\n{\n  char *v1; // rax\n  char *v2; // rax\n  char *v3; // rax\n  int v4; // [rsp+20h] [rbp-10h]\n  unsigned __int8 ch_0; // [rsp+27h] [rbp-9h]\n\n  v1 = (*format_ptr)++;\n  ch_0 = *v1;\n  v4 = (unsigned __int8)*v1;\n  if ( *v1 )\n  {\n    if ( v4 != 88 && v4 != 100 && v4 != 105 && v4 != 111 && v4 != 117 && v4 != 120 )\n    {\n      if ( ((*__ctype_b_loc())[ch_0] & 0x4000) != 0 )\n        v3 = gettext(\"invalid conversion specifier in suffix: %c\");\n      else\n        v3 = gettext(\"invalid conversion specifier in suffix: \\\\%.3o\");\n      error(1, 0, v3, ch_0);\n    }\n  }\n  else\n  {\n    v2 = gettext(\"missing conversion specifier in suffix\");\n    error(1, 0, v2);\n  }\n}\n\n\n Revised code:\nstatic void\nget_format_conv_type (char **format_ptr)\n{\n  unsigned char ch = *(*format_ptr)++;\n\n  switch (ch)\n    {\n    case 'd':\n    case 'i':\n    case 'o':\n    case 'u':\n    case 'x':\n    case 'X':\n      break;\n\n    case 0:\n      error (EXIT_FAILURE, 0, _(\"missing conversion specifier in suffix\"));\n      break;\n\n    default:\n      if (isprint (ch))\n        error (EXIT_FAILURE, 0,\n\t       _(\"invalid conversion specifier in suffix: %c\"), ch);\n      else\n\terror (EXIT_FAILURE, 0,\n\t       _(\"invalid conversion specifier in suffix: \\\\%.3o\"), ch);\n    }\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nconst char *__fastcall sub_4A8787(const char *a1)\n{\n  char *v2; // rax\n  const char *s; // [rsp+8h] [rbp-18h]\n  char *s1; // [rsp+18h] [rbp-8h]\n  char *s1a; // [rsp+18h] [rbp-8h]\n\n  s = a1;\n  s1 = strrchr(a1, 46);\n  if ( !s1 )\n    return 0LL;\n  s1a = s1 + 1;\n  if ( !strcmp(s1a, \"gz\") || *s1a == 90 && !s1a[1] )\n  {\n    *(s1a - 1) = 0;\n  }\n  else\n  {\n    if ( strcmp(s1a, \"tgz\") )\n      return 0LL;\n    s = sub_40A11F(a1, (__int64)\"tgz\");\n    v2 = strrchr(s, 46);\n    v2[2] = 97;\n    v2[3] = 114;\n  }\n  return s;\n}\n",
        "output": "```c\nstatic const char *\nget_compressed_filename_extension(const char *filename)\n{\n  char *last_dot;\n  const char *extension;\n\n  last_dot = strrchr(filename, '.');\n  if (!last_dot)\n    return NULL;\n\n  extension = last_dot + 1;\n  if (!strcmp(extension, \"gz\") || (*extension == 'Z' && extension[1] == '\\0'))\n  {\n    *last_dot = '\\0';\n  }\n  else if (!strcmp(extension, \"tgz\"))\n  {\n    filename = replace_extension(filename, \"tgz\");\n    last_dot = strrchr(filename, '.');\n    last_dot[1] = 't';\n    last_dot[2] = 'a';\n    last_dot[3] = 'r';\n  }\n  else\n  {\n    return NULL;\n  }\n\n  return filename;\n}\n```",
        "source_code": "FAST_FUNC make_new_name_gunzip(char *filename, const char *expected_ext UNUSED_PARAM)\n{\n\tchar *extension = strrchr(filename, '.');\n\n\tif (!extension)\n\t\treturn NULL;\n\n\textension++;\n\tif (strcmp(extension, \"tgz\" + 1) == 0\n#if ENABLE_FEATURE_SEAMLESS_Z\n\t || (extension[0] == 'Z' && extension[1] == '\\0')\n#endif\n\t) {\n\t\textension[-1] = '\\0';\n\t} else if (strcmp(extension, \"tgz\") == 0) {\n\t\tfilename = xstrdup(filename);\n\t\textension = strrchr(filename, '.');\n\t\textension[2] = 'a';\n\t\textension[3] = 'r';\n\t} else {\n\t\treturn NULL;\n\t}\n\treturn filename;\n}",
        "parsed_output": "static const char *\nget_compressed_filename_extension(const char *filename)\n{\n  char *last_dot;\n  const char *extension;\n\n  last_dot = strrchr(filename, '.');\n  if (!last_dot)\n    return NULL;\n\n  extension = last_dot + 1;\n  if (!strcmp(extension, \"gz\") || (*extension == 'Z' && extension[1] == '\\0'))\n  {\n    *last_dot = '\\0';\n  }\n  else if (!strcmp(extension, \"tgz\"))\n  {\n    filename = replace_extension(filename, \"tgz\");\n    last_dot = strrchr(filename, '.');\n    last_dot[1] = 't';\n    last_dot[2] = 'a';\n    last_dot[3] = 'r';\n  }\n  else\n  {\n    return NULL;\n  }\n\n  return filename;\n}",
        "baseline_code_stripped": "const char *__fastcall sub_4A8787(const char *a1)\n{\n  char *v2; // rax\n  const char *s; // [rsp+8h] [rbp-18h]\n  char *s1; // [rsp+18h] [rbp-8h]\n  char *s1a; // [rsp+18h] [rbp-8h]\n\n  s = a1;\n  s1 = strrchr(a1, 46);\n  if ( !s1 )\n    return 0LL;\n  s1a = s1 + 1;\n  if ( !strcmp(s1a, \"gz\") || *s1a == 90 && !s1a[1] )\n  {\n    *(s1a - 1) = 0;\n  }\n  else\n  {\n    if ( strcmp(s1a, \"tgz\") )\n      return 0LL;\n    s = sub_40A11F(a1, (__int64)\"tgz\");\n    v2 = strrchr(s, 46);\n    v2[2] = 97;\n    v2[3] = 114;\n  }\n  return s;\n}\n",
        "baseline_code_debug": "char *__cdecl make_new_name_gunzip(char *filename, const char *expected_ext)\n{\n  char *v3; // rax\n  const char *filenamea; // [rsp+8h] [rbp-18h]\n  char *extension; // [rsp+18h] [rbp-8h]\n  char *extensiona; // [rsp+18h] [rbp-8h]\n\n  filenamea = filename;\n  extension = strrchr(filename, 46);\n  if ( !extension )\n    return 0LL;\n  extensiona = extension + 1;\n  if ( !strcmp(extensiona, \"gz\") || *extensiona == 90 && !extensiona[1] )\n  {\n    *(extensiona - 1) = 0;\n  }\n  else\n  {\n    if ( strcmp(extensiona, \"tgz\") )\n      return 0LL;\n    filenamea = xstrdup(filename);\n    v3 = strrchr(filenamea, 46);\n    v3[2] = 97;\n    v3[3] = 114;\n  }\n  return (char *)filenamea;\n}\n",
        "similarity_score_unixcoder": 0.7939198613166809,
        "similarity_score_baseline_stripped": 0.5554924607276917,
        "similarity_score_baseline_debug": 0.8413436412811279
    },
    {
        "func_name": "translate_xfermode",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nsize_t __cdecl component_len(const char *f)\n{\n  bool v2; // [rsp+1h] [rbp-11h]\n  size_t len; // [rsp+2h] [rbp-10h]\n\n  for ( len = 1LL; ; ++len )\n  {\n    v2 = 0;\n    if ( f[len] != 47 )\n      v2 = f[len] != 0;\n    if ( !v2 )\n      break;\n  }\n  return len;\n}\n\n\n Revised code:\nstatic size_t\ncomponent_len (char const *f)\n{\n  size_t len;\n  for (len = 1; f[len] != '/' && f[len]; len++)\n    continue;\n  return len;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl format_address_std(uintmax_t address, char c)\n{\n  char *v2; // rax\n  char *v3; // rcx\n  char *v4; // rax\n  char *v5; // rax\n  const char *pbound; // [rsp+20h] [rbp-40h]\n  char *p; // [rsp+28h] [rbp-38h]\n  char buf[25]; // [rsp+30h] [rbp-30h] BYREF\n  char ca; // [rsp+57h] [rbp-9h]\n  uintmax_t addressa; // [rsp+58h] [rbp-8h]\n\n  addressa = address;\n  ca = c;\n  buf[24] = 0;\n  p = &buf[23];\n  buf[23] = c;\n  pbound = &buf[-address_pad_len + 23];\n  switch ( address_base )\n  {\n    case 8:\n      do\n      {\n        v2 = p--;\n        *(v2 - 1) = (addressa & 7) + 48;\n        addressa >>= 3;\n      }\n      while ( addressa );\n      break;\n    case 10:\n      do\n      {\n        v3 = p--;\n        *(v3 - 1) = addressa % 0xA + 48;\n        addressa /= 0xAuLL;\n      }\n      while ( addressa );\n      break;\n    case 16:\n      do\n      {\n        v4 = p--;\n        *(v4 - 1) = byte_4097D0[addressa & 0xF];\n        addressa >>= 4;\n      }\n      while ( addressa );\n      break;\n  }\n  while ( pbound < p )\n  {\n    v5 = p--;\n    *(v5 - 1) = 48;\n  }\n  fputs_unlocked(p, _bss_start);\n}\n\n\n Revised code:\nstatic void\nformat_address_std (uintmax_t address, char c)\n{\n  char buf[MAX_ADDRESS_LENGTH + 2];\n  char *p = buf + sizeof buf;\n  char const *pbound;\n\n  *--p = '\\0';\n  *--p = c;\n  pbound = p - address_pad_len;\n\n  /* Use a special case of the code for each base.  This is measurably\n     faster than generic code.  */\n  switch (address_base)\n    {\n    case 8:\n      do\n\t*--p = '0' + (address & 7);\n      while ((address >>= 3) != 0);\n      break;\n\n    case 10:\n      do\n\t*--p = '0' + (address % 10);\n      while ((address /= 10) != 0);\n      break;\n\n    case 16:\n      do\n\t*--p = \"0123456789abcdef\"[address & 15];\n      while ((address >>= 4) != 0);\n      break;\n    }\n\n  while (pbound < p)\n    *--p = '0';\n\n  fputs (p, stdout);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl set_prefix(char *p)\n{\n  bool v1; // [rsp+Fh] [rbp-11h]\n  char *s; // [rsp+10h] [rbp-10h]\n\n  prefix_lead_space = 0;\n  while ( *p == 32 )\n  {\n    ++prefix_lead_space;\n    ++p;\n  }\n  prefix = p;\n  prefix_full_length = strlen(p);\n  for ( s = &p[prefix_full_length]; ; --s )\n  {\n    v1 = 0;\n    if ( s > p )\n      v1 = *(s - 1) == 32;\n    if ( !v1 )\n      break;\n  }\n  *s = 0;\n  prefix_length = (_DWORD)s - (_DWORD)p;\n}\n\n\n Revised code:\nstatic void\nset_prefix (char *p)\n{\n  char *s;\n\n  prefix_lead_space = 0;\n  while (*p == ' ')\n    {\n      prefix_lead_space++;\n      p++;\n    }\n  prefix = p;\n  prefix_full_length = strlen (p);\n  s = p + prefix_full_length;\n  while (s > p && s[-1] == ' ')\n    s--;\n  *s = '\\0';\n  prefix_length = s - p;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_41A5C1(char *a1)\n{\n  unsigned int v2; // [rsp+18h] [rbp-8h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; i <= 0x1F; ++i )\n  {\n    if ( !strncmp(a1, &aPio0_0[5 * i], 5uLL) && strlen(a1) <= 5 )\n      return (unsigned __int8)byte_516A37[i];\n  }\n  v2 = sub_40BF66((unsigned __int8 *)a1, 0LL, 10);\n  if ( *(_DWORD *)qword_75D400 )\n    return 0xFFFFFFFFLL;\n  else\n    return v2;\n}\n",
        "output": "```c\nstatic uint64_t\nsub_41A5C1(char *a1)\n{\n  unsigned int i;\n  unsigned int value;\n\n  for (i = 0; i <= 0x1F; ++i)\n  {\n    if (!strncmp(a1, &aPio0_0[5 * i], 5) && strlen(a1) <= 5)\n      return (unsigned char)byte_516A37[i];\n  }\n  value = sub_40BF66((unsigned char *)a1, 0, 10);\n  if (*(_DWORD *)qword_75D400)\n    return 0xFFFFFFFF;\n  else\n    return value;\n}\n```",
        "source_code": "static int translate_xfermode(const char *name)\n{\n\tint val;\n\tunsigned i;\n\n\tfor (i = 0; i < ARRAY_SIZE(xfermode_val); i++) {\n\t\tif (!strncmp(name, xfermode_name[i], 5))\n\t\t\tif (strlen(name) <= 5)\n\t\t\t\treturn xfermode_val[i];\n\t}\n\t/* Negative numbers are invalid and are caught later */\n\tval = bb_strtoi(name, NULL, 10);\n\tif (!errno)\n\t\treturn val;\n\treturn -1;\n}",
        "parsed_output": "static uint64_t\nsub_41A5C1(char *a1)\n{\n  unsigned int i;\n  unsigned int value;\n\n  for (i = 0; i <= 0x1F; ++i)\n  {\n    if (!strncmp(a1, &aPio0_0[5 * i], 5) && strlen(a1) <= 5)\n      return (unsigned char)byte_516A37[i];\n  }\n  value = sub_40BF66((unsigned char *)a1, 0, 10);\n  if (*(_DWORD *)qword_75D400)\n    return 0xFFFFFFFF;\n  else\n    return value;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_41A5C1(char *a1)\n{\n  unsigned int v2; // [rsp+18h] [rbp-8h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; i <= 0x1F; ++i )\n  {\n    if ( !strncmp(a1, &aPio0_0[5 * i], 5uLL) && strlen(a1) <= 5 )\n      return (unsigned __int8)byte_516A37[i];\n  }\n  v2 = sub_40BF66((unsigned __int8 *)a1, 0LL, 10);\n  if ( *(_DWORD *)qword_75D400 )\n    return 0xFFFFFFFFLL;\n  else\n    return v2;\n}\n",
        "baseline_code_debug": "int __cdecl translate_xfermode(const char *name)\n{\n  int val; // [rsp+18h] [rbp-8h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n\n  for ( i = 0; i <= 0x1F; ++i )\n  {\n    if ( !strncmp(name, &xfermode_name[5 * i], 5uLL) && strlen(name) <= 5 )\n      return xfermode_val[i];\n  }\n  val = bb_strtoi(name, 0LL, 10);\n  if ( *bb_errno )\n    return -1;\n  else\n    return val;\n}\n",
        "similarity_score_unixcoder": 0.579383373260498,
        "similarity_score_baseline_stripped": 0.5198232531547546,
        "similarity_score_baseline_debug": 0.8561960458755493
    },
    {
        "func_name": "chain_loop",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl default_sort_size()\n{\n  __m128i v0; // xmm2\n  unsigned __int64 v1; // rax\n  double v4; // [rsp+8h] [rbp-38h]\n  size_t size; // [rsp+10h] [rbp-30h] BYREF\n  rlimit rlimit; // [rsp+18h] [rbp-28h] BYREF\n  double mem; // [rsp+28h] [rbp-18h]\n  double total; // [rsp+30h] [rbp-10h]\n  double avail; // [rsp+38h] [rbp-8h]\n\n  avail = physmem_available();\n  total = physmem_total();\n  if ( avail <= total / 8.0 )\n    v4 = total / 8.0;\n  else\n    v4 = avail;\n  mem = v4;\n  size = -1LL;\n  v0 = (__m128i)_mm_sub_pd(\n                  (__m128d)_mm_unpacklo_epi32(_mm_loadl_epi64((const __m128i *)&size), (__m128i)xmmword_40F3E0),\n                  (__m128d)xmmword_40F3F0);\n  if ( *(double *)_mm_shuffle_epi32(v0, 78).m128i_i64 + *(double *)v0.m128i_i64 > v4 )\n  {\n    v1 = (unsigned int)(int)(mem - 9.223372036854776e18) ^ 0x8000000000000000LL;\n    if ( mem < 9.223372036854776e18 )\n      v1 = (unsigned int)(int)mem;\n    size = v1;\n  }\n  if ( !getrlimit(RLIMIT_DATA, &rlimit) && rlimit.rlim_cur < size )\n    size = rlimit.rlim_cur;\n  if ( !getrlimit(RLIMIT_AS, &rlimit) && rlimit.rlim_cur < size )\n    size = rlimit.rlim_cur;\n  size >>= 1;\n  if ( !getrlimit(__RLIMIT_RSS, &rlimit) && 15 * (rlimit.rlim_cur >> 4) < size )\n    size = 15 * (rlimit.rlim_cur >> 4);\n  if ( size <= 0x220 )\n    return 544LL;\n  else\n    return size;\n}\n\n\n Revised code:\nstatic size_t\ndefault_sort_size (void)\n{\n  /* Let MEM be available memory or 1/8 of total memory, whichever\n     is greater.  */\n  double avail = physmem_available ();\n  double total = physmem_total ();\n  double mem = MAX (avail, total / 8);\n  struct rlimit rlimit;\n\n  /* Let SIZE be MEM, but no more than the maximum object size or\n     system resource limits.  Avoid the MIN macro here, as it is not\n     quite right when only one argument is floating point.  Don't\n     bother to check for values like RLIM_INFINITY since in practice\n     they are not much less than SIZE_MAX.  */\n  size_t size = SIZE_MAX;\n  if (mem < size)\n    size = mem;\n  if (getrlimit (RLIMIT_DATA, &rlimit) == 0 && rlimit.rlim_cur < size)\n    size = rlimit.rlim_cur;\n#ifdef RLIMIT_AS\n  if (getrlimit (RLIMIT_AS, &rlimit) == 0 && rlimit.rlim_cur < size)\n    size = rlimit.rlim_cur;\n#endif\n\n  /* Leave a large safety margin for the above limits, as failure can\n     occur when they are exceeded.  */\n  size /= 2;\n\n#ifdef RLIMIT_RSS\n  /* Leave a 1/16 margin for RSS to leave room for code, stack, etc.\n     Exceeding RSS is not fatal, but can be quite slow.  */\n  if (getrlimit (RLIMIT_RSS, &rlimit) == 0 && rlimit.rlim_cur / 16 * 15 < size)\n    size = rlimit.rlim_cur / 16 * 15;\n#endif\n\n  /* Use no less than the minimum.  */\n  return MAX (size, MIN_SORT_SIZE);\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_occurs(const void *void_first, const void *void_second)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h]\n  int value; // [rsp+1Ch] [rbp-14h]\n\n  value = compare_words(void_first, void_second);\n  if ( value )\n    LODWORD(v3) = value;\n  else\n    return *(_QWORD *)void_first - *(_QWORD *)void_second;\n  return v3;\n}\n\n\n Revised code:\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return value == 0 ? first->key.start - second->key.start : value;\n#undef first\n#undef second\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4DDFDB(__int64 a1, __int64 a2)\n{\n  char *v2; // rbx\n  char *v3; // rbx\n  __int64 v4; // rax\n  __int64 v6; // [rsp+18h] [rbp-28h]\n  __int64 v7; // [rsp+20h] [rbp-20h]\n  __int64 v8; // [rsp+28h] [rbp-18h]\n\n  v8 = *((_QWORD *)qword_75D408 - 15);\n  v7 = *((_QWORD *)qword_75D408 - 14);\n  v6 = sub_4DDE4A(67328, a2);\n  v2 = (char *)qword_75D408 - 208;\n  *((_QWORD *)v2 + 12) = sub_4DD854(512, a2);\n  v3 = (char *)qword_75D408 - 208;\n  *((_QWORD *)v3 + 11) = sub_4DD854(512, a2);\n  sub_4DE10D();\n  v4 = sub_4DDE4A(66048, a2);\n  *(_QWORD *)(v4 + 8) = a1;\n  *(_QWORD *)(v4 + 24) = v6;\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 14) + 24LL) = v4;\n  *(_QWORD *)(v6 + 16) = *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 8LL);\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 15) + 24LL) = *(_QWORD *)(v6 + 16);\n  *((_QWORD *)qword_75D408 - 14) = v7;\n  *((_QWORD *)qword_75D408 - 15) = v8;\n  return v6;\n}\n",
        "output": "```c\nstatic __int64\nsub_4DDFDB(__int64 a1, __int64 a2)\n{\n  __int64 allocated_memory1;\n  __int64 allocated_memory2;\n  __int64 new_node;\n  __int64 *global_ptr1;\n  __int64 *global_ptr2;\n\n  global_ptr1 = &qword_75D408[-15];\n  global_ptr2 = &qword_75D408[-14];\n  allocated_memory1 = sub_4DDE4A(67328, a2);\n  qword_75D408[-26] = sub_4DD854(512, a2);\n  qword_75D408[-27] = sub_4DD854(512, a2);\n  sub_4DE10D();\n  new_node = sub_4DDE4A(66048, a2);\n  *(_QWORD *)(new_node + 8) = a1;\n  *(_QWORD *)(new_node + 24) = allocated_memory1;\n  *(_QWORD *)(*global_ptr2 + 24) = new_node;\n  *(_QWORD *)(allocated_memory1 + 16) = qword_75D408[-16][2];\n  *(_QWORD *)(*global_ptr1 + 24) = *(_QWORD *)(allocated_memory1 + 16);\n  *global_ptr2 = qword_75D408[-14];\n  *global_ptr1 = qword_75D408[-15];\n  return allocated_memory1;\n}\n```",
        "source_code": "static node *chain_loop(node *nn)\n{\n\tnode *n, *n2, *save_brk, *save_cont;\n\n\tsave_brk = break_ptr;\n\tsave_cont = continue_ptr;\n\n\tn = chain_node(OC_BR | Vx);\n\tcontinue_ptr = new_node(OC_EXEC);\n\tbreak_ptr = new_node(OC_EXEC);\n\tchain_group();\n\tn2 = chain_node(OC_EXEC | Vx);\n\tn2->l.n = nn;\n\tn2->a.n = n;\n\tcontinue_ptr->a.n = n2;\n\tbreak_ptr->a.n = n->r.n = seq->last;\n\n\tcontinue_ptr = save_cont;\n\tbreak_ptr = save_brk;\n\n\treturn n;\n}",
        "parsed_output": "static __int64\nsub_4DDFDB(__int64 a1, __int64 a2)\n{\n  __int64 allocated_memory1;\n  __int64 allocated_memory2;\n  __int64 new_node;\n  __int64 *global_ptr1;\n  __int64 *global_ptr2;\n\n  global_ptr1 = &qword_75D408[-15];\n  global_ptr2 = &qword_75D408[-14];\n  allocated_memory1 = sub_4DDE4A(67328, a2);\n  qword_75D408[-26] = sub_4DD854(512, a2);\n  qword_75D408[-27] = sub_4DD854(512, a2);\n  sub_4DE10D();\n  new_node = sub_4DDE4A(66048, a2);\n  *(_QWORD *)(new_node + 8) = a1;\n  *(_QWORD *)(new_node + 24) = allocated_memory1;\n  *(_QWORD *)(*global_ptr2 + 24) = new_node;\n  *(_QWORD *)(allocated_memory1 + 16) = qword_75D408[-16][2];\n  *(_QWORD *)(*global_ptr1 + 24) = *(_QWORD *)(allocated_memory1 + 16);\n  *global_ptr2 = qword_75D408[-14];\n  *global_ptr1 = qword_75D408[-15];\n  return allocated_memory1;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4DDFDB(__int64 a1, __int64 a2)\n{\n  char *v2; // rbx\n  char *v3; // rbx\n  __int64 v4; // rax\n  __int64 v6; // [rsp+18h] [rbp-28h]\n  __int64 v7; // [rsp+20h] [rbp-20h]\n  __int64 v8; // [rsp+28h] [rbp-18h]\n\n  v8 = *((_QWORD *)qword_75D408 - 15);\n  v7 = *((_QWORD *)qword_75D408 - 14);\n  v6 = sub_4DDE4A(67328, a2);\n  v2 = (char *)qword_75D408 - 208;\n  *((_QWORD *)v2 + 12) = sub_4DD854(512, a2);\n  v3 = (char *)qword_75D408 - 208;\n  *((_QWORD *)v3 + 11) = sub_4DD854(512, a2);\n  sub_4DE10D();\n  v4 = sub_4DDE4A(66048, a2);\n  *(_QWORD *)(v4 + 8) = a1;\n  *(_QWORD *)(v4 + 24) = v6;\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 14) + 24LL) = v4;\n  *(_QWORD *)(v6 + 16) = *(_QWORD *)(*((_QWORD *)qword_75D408 - 16) + 8LL);\n  *(_QWORD *)(*((_QWORD *)qword_75D408 - 15) + 24LL) = *(_QWORD *)(v6 + 16);\n  *((_QWORD *)qword_75D408 - 14) = v7;\n  *((_QWORD *)qword_75D408 - 15) = v8;\n  return v6;\n}\n",
        "baseline_code_debug": "node_0 *__cdecl chain_loop(node_0 *nn)\n{\n  int *v1; // rbx\n  int *v2; // rbx\n  node_0 *v3; // rax\n  node_0 *n; // [rsp+18h] [rbp-28h]\n  node_0 *save_cont; // [rsp+20h] [rbp-20h]\n  node_0 *save_brk; // [rsp+28h] [rbp-18h]\n\n  save_brk = *(node_0 **)&ptr_to_globals[-1].line_buf[12];\n  save_cont = *(node_0 **)&ptr_to_globals[-1].line_buf[20];\n  n = chain_node(0x10700u);\n  v1 = &ptr_to_globals[-1].speeds[7];\n  *((_QWORD *)v1 + 12) = new_node(0x200u);\n  v2 = &ptr_to_globals[-1].speeds[7];\n  *((_QWORD *)v2 + 11) = new_node(0x200u);\n  chain_group();\n  v3 = chain_node(0x10200u);\n  v3->l.n = nn;\n  v3->a.n = n;\n  *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[20] + 24LL) = v3;\n  n->r.n = *(node_s **)(*(_QWORD *)&ptr_to_globals[-1].line_buf[4] + 8LL);\n  *(_QWORD *)(*(_QWORD *)&ptr_to_globals[-1].line_buf[12] + 24LL) = n->r.n;\n  *(_QWORD *)&ptr_to_globals[-1].line_buf[20] = save_cont;\n  *(_QWORD *)&ptr_to_globals[-1].line_buf[12] = save_brk;\n  return n;\n}\n",
        "similarity_score_unixcoder": 0.47227609157562256,
        "similarity_score_baseline_stripped": 0.4664490222930908,
        "similarity_score_baseline_debug": 0.7447726726531982
    },
    {
        "func_name": "finalize_tty_attrs",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl sysv_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  int *v5; // rax\n  char *v6; // rax\n  size_t bytes_read; // [rsp+20h] [rbp-22E0h]\n  size_t i; // [rsp+28h] [rbp-22D8h]\n  _BYTE is_stdin[5]; // [rsp+33h] [rbp-22CDh]\n  char hbuf[652]; // [rsp+40h] [rbp-22C0h] BYREF\n  uintmax_t total_bytes; // [rsp+2D8h] [rbp-2028h]\n  unsigned __int8 buf[8192]; // [rsp+2E0h] [rbp-2020h] BYREF\n  int fd; // [rsp+22E8h] [rbp-18h]\n  int print_namea; // [rsp+22ECh] [rbp-14h]\n  const char *filea; // [rsp+22F0h] [rbp-10h]\n  char v17; // [rsp+22FFh] [rbp-1h]\n\n  filea = file;\n  print_namea = print_name;\n  total_bytes = 0LL;\n  is_stdin[4] = 0;\n  v2 = strcmp(file, \"-\");\n  *(_DWORD *)is_stdin = v2 == 0;\n  if ( !v2 )\n  {\n    fd = 0;\n    have_read_stdin = 1;\n    goto LABEL_5;\n  }\n  fd = open(filea, 0);\n  if ( fd == -1 )\n  {\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    v17 = 0;\n  }\n  else\n  {\nLABEL_5:\n    while ( 1 )\n    {\n      bytes_read = safe_read(fd, buf, 0x2000uLL);\n      if ( !bytes_read )\n        break;\n      if ( bytes_read == -1LL )\n      {\n        v4 = __errno_location();\n        error(0, *v4, \"%s\", filea);\n        if ( (is_stdin[0] & 1) == 0 )\n          close(fd);\n        v17 = 0;\n        return v17 & 1;\n      }\n      for ( i = 0LL; i < bytes_read; ++i )\n        *(_DWORD *)&is_stdin[1] += buf[i];\n      total_bytes += bytes_read;\n    }\n    if ( (is_stdin[0] & 1) != 0 || !close(fd) )\n    {\n      v6 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x200uLL);\n      printf(\n        \"%d %s\",\n        ((HIWORD(*(_DWORD *)&is_stdin[1]) + *(unsigned __int16 *)&is_stdin[1]) >> 16)\n      + (unsigned int)(unsigned __int16)(*(_WORD *)&is_stdin[3] + *(_WORD *)&is_stdin[1]),\n        v6);\n      if ( print_namea )\n        printf(\" %s\", filea);\n      putchar_unlocked(10);\n      v17 = 1;\n    }\n    else\n    {\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filea);\n      v17 = 0;\n    }\n  }\n  return v17 & 1;\n}\n\n\n Revised code:\nstatic bool\nsysv_sum_file (const char *file, int print_name)\n{\n  int fd;\n  unsigned char buf[8192];\n  uintmax_t total_bytes = 0;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int r;\n  int checksum;\n\n  /* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n  unsigned int s = 0;\n\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fd = STDIN_FILENO;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while (1)\n    {\n      size_t i;\n      size_t bytes_read = safe_read (fd, buf, sizeof buf);\n\n      if (bytes_read == 0)\n\tbreak;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  if (!is_stdin)\n\t    close (fd);\n\t  return false;\n\t}\n\n      for (i = 0; i < bytes_read; i++)\n\ts += buf[i];\n      total_bytes += bytes_read;\n    }\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  checksum = (r & 0xffff) + (r >> 16);\n\n  printf (\"%d %s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 512));\n  if (print_name)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_occurs(const void *void_first, const void *void_second)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h]\n  int value; // [rsp+1Ch] [rbp-14h]\n\n  value = compare_words(void_first, void_second);\n  if ( value )\n    LODWORD(v3) = value;\n  else\n    return *(_QWORD *)void_first - *(_QWORD *)void_second;\n  return v3;\n}\n\n\n Revised code:\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return value == 0 ? first->key.start - second->key.start : value;\n#undef first\n#undef second\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_40E5E6(__int64 a1, __int64 a2)\n{\n  int v2; // edx\n  int v3; // edx\n\n  v2 = *((_DWORD *)qword_75D408 + 24);\n  BYTE1(v2) |= 0x14u;\n  *((_DWORD *)qword_75D408 + 24) = v2;\n  if ( *((_BYTE *)qword_75D408 + 92) == 13 )\n  {\n    v3 = *((_DWORD *)qword_75D408 + 24);\n    BYTE1(v3) |= 1u;\n    *((_DWORD *)qword_75D408 + 24) = v3;\n  }\n  *((_DWORD *)qword_75D408 + 27) |= 0x83Bu;\n  *((_BYTE *)qword_75D408 + 113) = 3;\n  *((_BYTE *)qword_75D408 + 114) = 28;\n  *((_BYTE *)qword_75D408 + 117) = 4;\n  *((_BYTE *)qword_75D408 + 124) = 10;\n  *((_BYTE *)qword_75D408 + 120) = 0;\n  *((_BYTE *)qword_75D408 + 116) = 21;\n  sub_40E482(a1, a2);\n  return sub_40B38A(1u, (__int64)\"\\n\", 1LL);\n}\n",
        "output": "```c\nvoid update_global_config()\n{\n  int value;\n\n  // Update the 24th DWORD in global configuration\n  value = global_config[24];\n  value |= 0x1400; // Set bits 10 and 12\n  global_config[24] = value;\n\n  // If the 93rd BYTE in global configuration is 13, set bit 8 of the 24th DWORD\n  if (global_config[92] == 13)\n  {\n    value = global_config[24];\n    value |= 0x100; // Set bit 8\n    global_config[24] = value;\n  }\n\n  // Set bits 0, 1, 4, 5, 6, 7, 10, and 11 of the 27th DWORD in global configuration\n  global_config[27] |= 0x83B;\n\n  // Set specific bytes in global configuration\n  global_config[113] = 3;\n  global_config[114] = 28;\n  global_config[117] = 4;\n  global_config[124] = 10;\n  global_config[120] = 0;\n  global_config[116] = 21;\n\n  // Call other functions with the provided arguments\n  sub_40E482(a1, a2);\n  sub_40B38A(1, \"\\n\", 1);\n}\n```",
        "source_code": "static void finalize_tty_attrs(void)\n{\n\t/* software flow control on output (stop sending if XOFF is recvd);\n\t * and on input (send XOFF when buffer is full)\n\t */\n\tG.tty_attrs.c_iflag |= IXON | IXOFF;\n\tif (G.eol == '\\r') {\n\t\tG.tty_attrs.c_iflag |= ICRNL; /* map CR on input to NL */\n\t}\n\t/* Other bits in c_iflag:\n\t * IXANY   Any recvd char enables output (any char is also a XON)\n\t * INPCK   Enable parity check\n\t * IGNPAR  Ignore parity errors (drop bad bytes)\n\t * PARMRK  Mark parity errors with 0xff, 0x00 prefix\n\t *         (else bad byte is received as 0x00)\n\t * ISTRIP  Strip parity bit\n\t * IGNBRK  Ignore break condition\n\t * BRKINT  Send SIGINT on break - maybe set this?\n\t * INLCR   Map NL to CR\n\t * IGNCR   Ignore CR\n\t * ICRNL   Map CR to NL\n\t * IUCLC   Map uppercase to lowercase\n\t * IMAXBEL Echo BEL on input line too long\n\t * IUTF8   Appears to affect tty's idea of char widths,\n\t *         observed to improve backspacing through Unicode chars\n\t */\n\n\t/* line buffered input (NL or EOL or EOF chars end a line);\n\t * recognize INT/QUIT/SUSP chars;\n\t * echo input chars;\n\t * echo BS-SP-BS on erase character;\n\t * echo kill char specially, not as ^c (ECHOKE controls how exactly);\n\t * erase all input via BS-SP-BS on kill char (else go to next line)\n\t */\n\tG.tty_attrs.c_lflag |= ICANON | ISIG | ECHO | ECHOE | ECHOK | ECHOKE;\n\t/* Other bits in c_lflag:\n\t * XCASE   Map uppercase to \\lowercase [tried, doesn't work]\n\t * ECHONL  Echo NL even if ECHO is not set\n\t * ECHOCTL Echo ctrl chars as ^c (else don't echo) - maybe set this?\n\t * ECHOPRT On erase, echo erased chars\n\t *         [qwe<BS><BS><BS> input looks like \"qwe\\ewq/\" on screen]\n\t * NOFLSH  Don't flush input buffer after interrupt or quit chars\n\t * IEXTEN  Enable extended functions (??)\n\t *         [glibc says it enables c_cc[LNEXT] \"enter literal char\"\n\t *         and c_cc[VDISCARD] \"toggle discard buffered output\" chars]\n\t * FLUSHO  Output being flushed (c_cc[VDISCARD] is in effect)\n\t * PENDIN  Retype pending input at next read or input char\n\t *         (c_cc[VREPRINT] is being processed)\n\t * TOSTOP  Send SIGTTOU for background output\n\t *         (why \"stty sane\" unsets this bit?)\n\t */\n\n\tG.tty_attrs.c_cc[VINTR] = CTL('C');\n\tG.tty_attrs.c_cc[VQUIT] = CTL('\\\\');\n\tG.tty_attrs.c_cc[VEOF] = CTL('D');\n\tG.tty_attrs.c_cc[VEOL] = '\\n';\n#ifdef VSWTC\n\tG.tty_attrs.c_cc[VSWTC] = 0;\n#endif\n#ifdef VSWTCH\n\tG.tty_attrs.c_cc[VSWTCH] = 0;\n#endif\n\tG.tty_attrs.c_cc[VKILL] = CTL('U');\n\t/* Other control chars:\n\t * VEOL2\n\t * VERASE, VWERASE - (word) erase. we may set VERASE in get_logname\n\t * VREPRINT - reprint current input buffer\n\t * VLNEXT, VDISCARD, VSTATUS\n\t * VSUSP, VDSUSP - send (delayed) SIGTSTP\n\t * VSTART, VSTOP - chars used for IXON/IXOFF\n\t */\n\n\tset_tty_attrs();\n\n\t/* Now the newline character should be properly written */\n\tfull_write(STDOUT_FILENO, \"\\n\", 1);\n}",
        "parsed_output": "void update_global_config()\n{\n  int value;\n\n  // Update the 24th DWORD in global configuration\n  value = global_config[24];\n  value |= 0x1400; // Set bits 10 and 12\n  global_config[24] = value;\n\n  // If the 93rd BYTE in global configuration is 13, set bit 8 of the 24th DWORD\n  if (global_config[92] == 13)\n  {\n    value = global_config[24];\n    value |= 0x100; // Set bit 8\n    global_config[24] = value;\n  }\n\n  // Set bits 0, 1, 4, 5, 6, 7, 10, and 11 of the 27th DWORD in global configuration\n  global_config[27] |= 0x83B;\n\n  // Set specific bytes in global configuration\n  global_config[113] = 3;\n  global_config[114] = 28;\n  global_config[117] = 4;\n  global_config[124] = 10;\n  global_config[120] = 0;\n  global_config[116] = 21;\n\n  // Call other functions with the provided arguments\n  sub_40E482(a1, a2);\n  sub_40B38A(1, \"\\n\", 1);\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_40E5E6(__int64 a1, __int64 a2)\n{\n  int v2; // edx\n  int v3; // edx\n\n  v2 = *((_DWORD *)qword_75D408 + 24);\n  BYTE1(v2) |= 0x14u;\n  *((_DWORD *)qword_75D408 + 24) = v2;\n  if ( *((_BYTE *)qword_75D408 + 92) == 13 )\n  {\n    v3 = *((_DWORD *)qword_75D408 + 24);\n    BYTE1(v3) |= 1u;\n    *((_DWORD *)qword_75D408 + 24) = v3;\n  }\n  *((_DWORD *)qword_75D408 + 27) |= 0x83Bu;\n  *((_BYTE *)qword_75D408 + 113) = 3;\n  *((_BYTE *)qword_75D408 + 114) = 28;\n  *((_BYTE *)qword_75D408 + 117) = 4;\n  *((_BYTE *)qword_75D408 + 124) = 10;\n  *((_BYTE *)qword_75D408 + 120) = 0;\n  *((_BYTE *)qword_75D408 + 116) = 21;\n  sub_40E482(a1, a2);\n  return sub_40B38A(1u, (__int64)\"\\n\", 1LL);\n}\n",
        "baseline_code_debug": "void __cdecl finalize_tty_attrs()\n{\n  tcflag_t c_iflag; // edx\n  tcflag_t v1; // edx\n\n  c_iflag = ptr_to_globals->tty_attrs.c_iflag;\n  BYTE1(c_iflag) |= 0x14u;\n  ptr_to_globals->tty_attrs.c_iflag = c_iflag;\n  if ( ptr_to_globals->eol == 13 )\n  {\n    v1 = ptr_to_globals->tty_attrs.c_iflag;\n    BYTE1(v1) |= 1u;\n    ptr_to_globals->tty_attrs.c_iflag = v1;\n  }\n  ptr_to_globals->tty_attrs.c_lflag |= 0x83Bu;\n  ptr_to_globals->tty_attrs.c_cc[0] = 3;\n  ptr_to_globals->tty_attrs.c_cc[1] = 28;\n  ptr_to_globals->tty_attrs.c_cc[4] = 4;\n  ptr_to_globals->tty_attrs.c_cc[11] = 10;\n  ptr_to_globals->tty_attrs.c_cc[7] = 0;\n  ptr_to_globals->tty_attrs.c_cc[3] = 21;\n  set_tty_attrs();\n  full_write(1, \"\\n\", 1uLL);\n}\n",
        "similarity_score_unixcoder": 0.47428393363952637,
        "similarity_score_baseline_stripped": 0.3966674208641052,
        "similarity_score_baseline_debug": 0.6933220624923706
    },
    {
        "func_name": "extract_socket_inode",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl parse_old_offset(const char *s, uintmax_t *offset)\n{\n  strtol_error_0 v2; // eax\n  const char *sa; // [rsp+10h] [rbp-10h]\n\n  sa = s;\n  if ( *s )\n  {\n    if ( *s == 43 )\n      sa = s + 1;\n    if ( strchr(sa, 46) )\n    {\n      v2 = xstrtoumax(sa, 0LL, 10, offset, \"Bb\");\n    }\n    else if ( *sa == 48 && (sa[1] == 120 || sa[1] == 88) )\n    {\n      v2 = xstrtoumax(sa, 0LL, 16, offset, \"Bb\");\n    }\n    else\n    {\n      v2 = xstrtoumax(sa, 0LL, 8, offset, \"Bb\");\n    }\n    return v2 == LONGINT_OK;\n  }\n  else\n  {\n    return 0;\n  }\n}\n\n\n Revised code:\nstatic bool\nparse_old_offset (const char *s, uintmax_t *offset)\n{\n  int radix;\n\n  if (*s == '\\0')\n    return false;\n\n  /* Skip over any leading '+'. */\n  if (s[0] == '+')\n    ++s;\n\n  /* Determine the radix we'll use to interpret S.  If there is a `.',\n     it's decimal, otherwise, if the string begins with `0X'or `0x',\n     it's hexadecimal, else octal.  */\n  if (strchr (s, '.') != NULL)\n    radix = 10;\n  else\n    {\n      if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))\n\tradix = 16;\n      else\n\tradix = 8;\n    }\n\n  return xstrtoumax (s, NULL, radix, offset, \"Bb\") == LONGINT_OK;\n}\n\n## Example:\n\n Input code:\nbool __cdecl is_colored(indicator_no type)\n{\n  bool v2; // [rsp+6h] [rbp-1Ah]\n  char v3; // [rsp+7h] [rbp-19h]\n  const char *s; // [rsp+8h] [rbp-18h]\n  size_t len; // [rsp+10h] [rbp-10h]\n\n  len = color_indicator[type].len;\n  s = color_indicator[type].string;\n  v3 = 1;\n  if ( len )\n  {\n    if ( len != 1 || (v3 = 1, strncmp(s, \"0\", 1uLL)) )\n    {\n      v2 = 0;\n      if ( len == 2 )\n        v2 = strncmp(s, \"00\", 2uLL) == 0;\n      v3 = v2;\n    }\n  }\n  return (v3 & 1) == 0;\n}\n\n\n Revised code:\nstatic bool\nis_colored (enum indicator_no type)\n{\n  size_t len = color_indicator[type].len;\n  char const *s = color_indicator[type].string;\n  return ! (len == 0\n\t    || (len == 1 && strncmp (s, \"0\", 1) == 0)\n\t    || (len == 2 && strncmp (s, \"00\", 2) == 0));\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_439D55(char *a1)\n{\n  char *s1; // [rsp+8h] [rbp-18h] BYREF\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  s1 = a1;\n  v3 = -1LL;\n  if ( !strncmp(a1, \"socket:[\", 8uLL) )\n  {\n    v3 = sub_439BE4(s1 + 8, &s1, 0);\n    if ( *s1 != 93 )\n      return -1LL;\n  }\n  else if ( !strncmp(s1, \"[0000]:\", 7uLL) )\n  {\n    v3 = sub_439BE4(s1 + 7, 0LL, 0);\n    if ( *(_DWORD *)qword_75D400 )\n      return -1LL;\n  }\n  return v3;\n}\n",
        "output": "```c\nstatic int64_t\nparse_socket_info (char *str)\n{\n  char *endptr;\n  int64_t result = -1;\n\n  if (strncmp(str, \"socket:[\", 8) == 0)\n  {\n    result = parse_integer(str + 8, &endptr, 10);\n    if (*endptr != ']')\n      return -1;\n  }\n  else if (strncmp(str, \"[0000]:\", 7) == 0)\n  {\n    result = parse_integer(str + 7, NULL, 10);\n    if (global_flag != 0)\n      return -1;\n  }\n\n  return result;\n}\n```",
        "source_code": "endif\n\nstatic long extract_socket_inode(const char *lname)\n{\n\tlong inode = -1;\n\n\tif (strncmp(lname, \"socket:[\", sizeof(\"socket:[\")-1) == 0) {\n\t\t/* \"socket:[12345]\", extract the \"12345\" as inode */\n\t\tinode = bb_strtoul(lname + sizeof(\"socket:[\")-1, (char**)&lname, 0);\n\t\tif (*lname != ']')\n\t\t\tinode = -1;\n\t} else if (strncmp(lname, \"[0000]:\", sizeof(\"[0000]:\")-1) == 0) {\n\t\t/* \"[0000]:12345\", extract the \"12345\" as inode */\n\t\tinode = bb_strtoul(lname + sizeof(\"[0000]:\")-1, NULL, 0);\n\t\tif (errno) /* not NUL terminated? */\n\t\t\tinode = -1;\n\t}\n\n#if 0 /* bb_strtol returns all-ones bit pattern on ERANGE anyway */\n\tif (errno == ERANGE)\n\t\tinode = -1;\n#endif\n\treturn inode;\n}",
        "parsed_output": "static int64_t\nparse_socket_info (char *str)\n{\n  char *endptr;\n  int64_t result = -1;\n\n  if (strncmp(str, \"socket:[\", 8) == 0)\n  {\n    result = parse_integer(str + 8, &endptr, 10);\n    if (*endptr != ']')\n      return -1;\n  }\n  else if (strncmp(str, \"[0000]:\", 7) == 0)\n  {\n    result = parse_integer(str + 7, NULL, 10);\n    if (global_flag != 0)\n      return -1;\n  }\n\n  return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_439D55(char *a1)\n{\n  char *s1; // [rsp+8h] [rbp-18h] BYREF\n  __int64 v3; // [rsp+18h] [rbp-8h]\n\n  s1 = a1;\n  v3 = -1LL;\n  if ( !strncmp(a1, \"socket:[\", 8uLL) )\n  {\n    v3 = sub_439BE4(s1 + 8, &s1, 0);\n    if ( *s1 != 93 )\n      return -1LL;\n  }\n  else if ( !strncmp(s1, \"[0000]:\", 7uLL) )\n  {\n    v3 = sub_439BE4(s1 + 7, 0LL, 0);\n    if ( *(_DWORD *)qword_75D400 )\n      return -1LL;\n  }\n  return v3;\n}\n",
        "baseline_code_debug": "__int64 __cdecl extract_socket_inode(const char *lname)\n{\n  const char *lnamea; // [rsp+8h] [rbp-18h] BYREF\n  __int64 inode; // [rsp+18h] [rbp-8h]\n\n  lnamea = lname;\n  inode = -1LL;\n  if ( !strncmp(lname, \"socket:[\", 8uLL) )\n  {\n    inode = bb_strtoul_1(lnamea + 8, (char **)&lnamea, 0);\n    if ( *lnamea != 93 )\n      return -1LL;\n  }\n  else if ( !strncmp(lnamea, \"[0000]:\", 7uLL) )\n  {\n    inode = bb_strtoul_1(lnamea + 7, 0LL, 0);\n    if ( *bb_errno )\n      return -1LL;\n  }\n  return inode;\n}\n",
        "similarity_score_unixcoder": 0.7293385863304138,
        "similarity_score_baseline_stripped": 0.5855307579040527,
        "similarity_score_baseline_debug": 0.859821617603302
    },
    {
        "func_name": "do_del",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_named_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  const unsigned __int8 *v3; // rax\n  char buf[5]; // [rsp+13h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+18h] [rbp-38h]\n  int masked_c; // [rsp+24h] [rbp-2Ch]\n  size_t i; // [rsp+28h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+30h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+38h] [rbp-18h]\n  const void *blocka; // [rsp+40h] [rbp-10h]\n  size_t n_bytesa; // [rsp+48h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = p++;\n    masked_c = *v3 & 0x7F;\n    if ( masked_c == 127 )\n    {\n      s = \"del\";\n    }\n    else if ( masked_c > 32 )\n    {\n      sprintf(buf, \"  %c\", (unsigned int)masked_c);\n      s = buf;\n    }\n    else\n    {\n      s = charname[masked_c];\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_named_ascii (size_t n_bytes, void const *block,\n\t\t   const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      int masked_c = *p++ & 0x7f;\n      const char *s;\n      char buf[5];\n\n      if (masked_c == 127)\n\ts = \"del\";\n      else if (masked_c <= 040)\n\ts = charname[masked_c];\n      else\n\t{\n\t  sprintf (buf, \"  %c\", masked_c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n\n## Example:\n\n Input code:\nbool __cdecl toarith(VALUE *v)\n{\n  intmax_t value; // [rsp+18h] [rbp-18h] BYREF\n  VALUE *va; // [rsp+20h] [rbp-10h]\n\n  va = v;\n  if ( v->type == integer )\n    return 1;\n  if ( v->type != string )\n    abort();\n  if ( !looks_like_integer(va->u.s) )\n    return 0;\n  if ( xstrtoimax(va->u.s, 0LL, 10, &value, 0LL) )\n    error(3, 34, \"%s\", va->u.s);\n  free(va->u.s);\n  va->u.i = value;\n  va->type = integer;\n  return 1;\n}\n\n\n Revised code:\nstatic bool\ntoarith (VALUE *v)\n{\n  switch (v->type)\n    {\n    case integer:\n      return true;\n    case string:\n      {\n\tintmax_t value;\n\n\tif (! looks_like_integer (v->u.s))\n\t  return false;\n\tif (xstrtoimax (v->u.s, NULL, 10, &value, NULL) != LONGINT_OK)\n\t  error (EXPR_FAILURE, ERANGE, \"%s\", v->u.s);\n\tfree (v->u.s);\n\tv->u.i = value;\n\tv->type = integer;\n\treturn true;\n      }\n    default:\n      abort ();\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_450504(const char **a1)\n{\n  uint32_t v2[10]; // [rsp+10h] [rbp-40h] BYREF\n  char v3; // [rsp+39h] [rbp-17h]\n\n  sub_44F8E2(a1, 35314, v2);\n  switch ( v3 )\n  {\n    case 41:\n      return sub_44F857(\"sit0\", (const char *)v2);\n    case 47:\n      return sub_44F857(\"gre0\", (const char *)v2);\n    case 4:\n      return sub_44F857(\"tunl0\", (const char *)v2);\n  }\n  return sub_44F857((const char *)v2, (const char *)v2);\n}\n",
        "output": "```c\nstatic __int64\nsub_450504 (const char **a1)\n{\n  uint32_t v2[10];\n  char v3;\n\n  sub_44F8E2 (a1, 35314, v2);\n  switch (v3)\n    {\n    case ')':\n      return sub_44F857 (\"sit0\", (const char *)v2);\n    case '/':\n      return sub_44F857 (\"gre0\", (const char *)v2);\n    case 4:\n      return sub_44F857 (\"tunl0\", (const char *)v2);\n    default:\n      return sub_44F857 ((const char *)v2, (const char *)v2);\n    }\n}\n```",
        "source_code": "static int do_del(char **argv)\n{\n\tstruct ip_tunnel_parm p;\n\n\tparse_args(argv, SIOCDELTUNNEL, &p);\n\n\tswitch (p.iph.protocol) {\n\tcase IPPROTO_IPIP:\n\t\treturn do_del_ioctl(\"tunl0\", &p);\n\tcase IPPROTO_GRE:\n\t\treturn do_del_ioctl(\"gre0\", &p);\n\tcase IPPROTO_IPV6:\n\t\treturn do_del_ioctl(\"sit0\", &p);\n\tdefault:\n\t\treturn do_del_ioctl(p.name, &p);\n\t}\n}",
        "parsed_output": "static __int64\nsub_450504 (const char **a1)\n{\n  uint32_t v2[10];\n  char v3;\n\n  sub_44F8E2 (a1, 35314, v2);\n  switch (v3)\n    {\n    case ')':\n      return sub_44F857 (\"sit0\", (const char *)v2);\n    case '/':\n      return sub_44F857 (\"gre0\", (const char *)v2);\n    case 4:\n      return sub_44F857 (\"tunl0\", (const char *)v2);\n    default:\n      return sub_44F857 ((const char *)v2, (const char *)v2);\n    }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_450504(const char **a1)\n{\n  uint32_t v2[10]; // [rsp+10h] [rbp-40h] BYREF\n  char v3; // [rsp+39h] [rbp-17h]\n\n  sub_44F8E2(a1, 35314, v2);\n  switch ( v3 )\n  {\n    case 41:\n      return sub_44F857(\"sit0\", (const char *)v2);\n    case 47:\n      return sub_44F857(\"gre0\", (const char *)v2);\n    case 4:\n      return sub_44F857(\"tunl0\", (const char *)v2);\n  }\n  return sub_44F857((const char *)v2, (const char *)v2);\n}\n",
        "baseline_code_debug": "int __cdecl do_del(char **argv)\n{\n  ip_tunnel_parm p; // [rsp+10h] [rbp-40h] BYREF\n\n  parse_args_0(argv, 35314, &p);\n  switch ( p.iph.protocol )\n  {\n    case 0x29u:\n      return do_del_ioctl(\"sit0\", &p);\n    case 0x2Fu:\n      return do_del_ioctl(\"gre0\", &p);\n    case 4u:\n      return do_del_ioctl(\"tunl0\", &p);\n  }\n  return do_del_ioctl(p.name, &p);\n}\n",
        "similarity_score_unixcoder": 0.5238110423088074,
        "similarity_score_baseline_stripped": 0.48289430141448975,
        "similarity_score_baseline_debug": 0.886375904083252
    },
    {
        "func_name": "get_username_or_die",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl get_format_conv_type(char **format_ptr)\n{\n  char *v1; // rax\n  char *v2; // rax\n  char *v3; // rax\n  int v4; // [rsp+20h] [rbp-10h]\n  unsigned __int8 ch_0; // [rsp+27h] [rbp-9h]\n\n  v1 = (*format_ptr)++;\n  ch_0 = *v1;\n  v4 = (unsigned __int8)*v1;\n  if ( *v1 )\n  {\n    if ( v4 != 88 && v4 != 100 && v4 != 105 && v4 != 111 && v4 != 117 && v4 != 120 )\n    {\n      if ( ((*__ctype_b_loc())[ch_0] & 0x4000) != 0 )\n        v3 = gettext(\"invalid conversion specifier in suffix: %c\");\n      else\n        v3 = gettext(\"invalid conversion specifier in suffix: \\\\%.3o\");\n      error(1, 0, v3, ch_0);\n    }\n  }\n  else\n  {\n    v2 = gettext(\"missing conversion specifier in suffix\");\n    error(1, 0, v2);\n  }\n}\n\n\n Revised code:\nstatic void\nget_format_conv_type (char **format_ptr)\n{\n  unsigned char ch = *(*format_ptr)++;\n\n  switch (ch)\n    {\n    case 'd':\n    case 'i':\n    case 'o':\n    case 'u':\n    case 'x':\n    case 'X':\n      break;\n\n    case 0:\n      error (EXIT_FAILURE, 0, _(\"missing conversion specifier in suffix\"));\n      break;\n\n    default:\n      if (isprint (ch))\n        error (EXIT_FAILURE, 0,\n\t       _(\"invalid conversion specifier in suffix: %c\"), ch);\n      else\n\terror (EXIT_FAILURE, 0,\n\t       _(\"invalid conversion specifier in suffix: \\\\%.3o\"), ch);\n    }\n}\n\n## Example:\n\n Input code:\nint __cdecl get_prefix(FILE *f)\n{\n  int v1; // eax\n  int v3; // [rsp+Ch] [rbp-34h]\n  const char *p; // [rsp+20h] [rbp-20h]\n  int c; // [rsp+2Ch] [rbp-14h]\n\n  in_column = 0;\n  v1 = getc_unlocked(f);\n  c = get_space(f, v1);\n  if ( prefix_length )\n  {\n    next_prefix_indent = in_column;\n    for ( p = prefix; *p; ++p )\n    {\n      if ( c != *(unsigned __int8 *)p )\n        return c;\n      ++in_column;\n      c = getc_unlocked(f);\n    }\n    return get_space(f, c);\n  }\n  else\n  {\n    if ( prefix_lead_space >= in_column )\n      v3 = in_column;\n    else\n      v3 = prefix_lead_space;\n    next_prefix_indent = v3;\n  }\n  return c;\n}\n\n\n Revised code:\nstatic int\nget_prefix (FILE *f)\n{\n  int c;\n\n  in_column = 0;\n  c = get_space (f, getc (f));\n  if (prefix_length == 0)\n    next_prefix_indent = prefix_lead_space < in_column ?\n      prefix_lead_space : in_column;\n  else\n    {\n      const char *p;\n      next_prefix_indent = in_column;\n      for (p = prefix; *p != '\\0'; p++)\n\t{\n\t  unsigned char pc = *p;\n\t  if (c != pc)\n\t    return c;\n\t  in_column++;\n\t  c = getc (f);\n\t}\n      c = get_space (f, c);\n    }\n  return c;\n}\n\n## Example:\n\n Input code:\nint __cdecl copy_rest(FILE *f, int c)\n{\n  const char *v2; // rax\n  bool v4; // [rsp+Fh] [rbp-21h]\n  bool v5; // [rsp+17h] [rbp-19h]\n  const char *s; // [rsp+18h] [rbp-18h]\n  int ca; // [rsp+24h] [rbp-Ch]\n\n  ca = c;\n  out_column = 0;\n  if ( in_column > next_prefix_indent && c != 10 && c != -1 )\n  {\n    put_space(next_prefix_indent);\n    for ( s = prefix; ; ++s )\n    {\n      v5 = 0;\n      if ( out_column != in_column )\n        v5 = *s != 0;\n      if ( !v5 )\n        break;\n      v2 = s;\n      putchar_unlocked(*v2);\n      ++out_column;\n    }\n    put_space(in_column - out_column);\n  }\n  while ( 1 )\n  {\n    v4 = 0;\n    if ( ca != 10 )\n      v4 = ca != -1;\n    if ( !v4 )\n      break;\n    putchar_unlocked(ca);\n    ca = getc_unlocked(f);\n  }\n  return ca;\n}\n\n\n Revised code:\nstatic int\ncopy_rest (FILE *f, int c)\n{\n  const char *s;\n\n  out_column = 0;\n  if (in_column > next_prefix_indent && c != '\\n' && c != EOF)\n    {\n      put_space (next_prefix_indent);\n      for (s = prefix; out_column != in_column && *s; out_column++)\n\tputchar (*s++);\n      put_space (in_column - out_column);\n    }\n  while (c != '\\n' && c != EOF)\n    {\n      putchar (c);\n      c = getc (f);\n    }\n  return c;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nchar *__fastcall sub_40EFC0(_BYTE *a1, int a2)\n{\n  char *result; // rax\n  char *s; // [rsp+8h] [rbp-18h]\n  int v5; // [rsp+18h] [rbp-8h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  v6 = 10;\nLABEL_2:\n  sub_5017B3();\n  do\n  {\n    v5 = getchar_unlocked();\n    if ( v5 == -1 )\n      exit(1);\n    if ( v5 == 10 )\n    {\n      if ( !--v6 )\n        exit(1);\n      goto LABEL_2;\n    }\n  }\n  while ( (_BYTE)v5 == 32 || (unsigned __int8)(v5 - 9) <= 4u );\n  s = a1 + 1;\n  *a1 = v5;\n  if ( !fgets_unlocked(a1 + 1, a2 - 2, stdin) )\n    exit(1);\n  if ( !strchr(s, 10) )\n    exit(1);\n  while ( (unsigned __int8)*s > 0x20u )\n    ++s;\n  result = s;\n  *s = 0;\n  return result;\n}\n",
        "output": "```c\nstatic char *\nsub_40EFC0 (char *buffer, int buffer_size)\n{\n  int max_newlines = 10;\n  int ch;\n\n  while (1)\n    {\n      sub_5017B3(); // Some external function call, purpose unknown from this context\n      do\n        {\n          ch = getchar_unlocked();\n          if (ch == EOF)\n            exit(EXIT_FAILURE);\n          if (ch == '\\n')\n            {\n              if (--max_newlines == 0)\n                exit(EXIT_FAILURE);\n              break; // Go to the next iteration of the outer while loop\n            }\n        }\n      while (isspace((unsigned char)ch));\n\n      if (ch != '\\n') // If we didn't break from the loop due to a newline\n        {\n          buffer[0] = ch;\n          if (!fgets_unlocked(buffer + 1, buffer_size - 2, stdin))\n            exit(EXIT_FAILURE);\n          char *newline = strchr(buffer, '\\n');\n          if (!newline)\n            exit(EXIT_FAILURE);\n          char *s = buffer;\n          while ((unsigned char)*s > ' ')\n            s++;\n          *s = '\\0'; // Terminate the string at the first whitespace character\n          return s; // Return the pointer to the terminated position\n        }\n    }\n}\n```",
        "source_code": "static void get_username_or_die(char *buf, int size_buf)\n{\n\tint c, cntdown;\n\n\tcntdown = EMPTY_USERNAME_COUNT;\n prompt:\n\tprint_login_prompt();\n\t/* skip whitespace */\n\tdo {\n\t\tc = getchar();\n\t\tif (c == EOF)\n\t\t\texit(EXIT_FAILURE);\n\t\tif (c == '\\n') {\n\t\t\tif (!--cntdown)\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\tgoto prompt;\n\t\t}\n\t} while (isspace(c)); /* maybe isblank? */\n\n\t*buf++ = c;\n\tif (!fgets(buf, size_buf-2, stdin))\n\t\texit(EXIT_FAILURE);\n\tif (!strchr(buf, '\\n'))\n\t\texit(EXIT_FAILURE);\n\twhile ((unsigned char)*buf > ' ')\n\t\tbuf++;\n\t*buf = '\\0';\n}",
        "parsed_output": "static char *\nsub_40EFC0 (char *buffer, int buffer_size)\n{\n  int max_newlines = 10;\n  int ch;\n\n  while (1)\n    {\n      sub_5017B3(); // Some external function call, purpose unknown from this context\n      do\n        {\n          ch = getchar_unlocked();\n          if (ch == EOF)\n            exit(EXIT_FAILURE);\n          if (ch == '\\n')\n            {\n              if (--max_newlines == 0)\n                exit(EXIT_FAILURE);\n              break; // Go to the next iteration of the outer while loop\n            }\n        }\n      while (isspace((unsigned char)ch));\n\n      if (ch != '\\n') // If we didn't break from the loop due to a newline\n        {\n          buffer[0] = ch;\n          if (!fgets_unlocked(buffer + 1, buffer_size - 2, stdin))\n            exit(EXIT_FAILURE);\n          char *newline = strchr(buffer, '\\n');\n          if (!newline)\n            exit(EXIT_FAILURE);\n          char *s = buffer;\n          while ((unsigned char)*s > ' ')\n            s++;\n          *s = '\\0'; // Terminate the string at the first whitespace character\n          return s; // Return the pointer to the terminated position\n        }\n    }\n}",
        "baseline_code_stripped": "char *__fastcall sub_40EFC0(_BYTE *a1, int a2)\n{\n  char *result; // rax\n  char *s; // [rsp+8h] [rbp-18h]\n  int v5; // [rsp+18h] [rbp-8h]\n  int v6; // [rsp+1Ch] [rbp-4h]\n\n  v6 = 10;\nLABEL_2:\n  sub_5017B3();\n  do\n  {\n    v5 = getchar_unlocked();\n    if ( v5 == -1 )\n      exit(1);\n    if ( v5 == 10 )\n    {\n      if ( !--v6 )\n        exit(1);\n      goto LABEL_2;\n    }\n  }\n  while ( (_BYTE)v5 == 32 || (unsigned __int8)(v5 - 9) <= 4u );\n  s = a1 + 1;\n  *a1 = v5;\n  if ( !fgets_unlocked(a1 + 1, a2 - 2, stdin) )\n    exit(1);\n  if ( !strchr(s, 10) )\n    exit(1);\n  while ( (unsigned __int8)*s > 0x20u )\n    ++s;\n  result = s;\n  *s = 0;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl get_username_or_die(char *buf, int size_buf)\n{\n  char *bufa; // [rsp+8h] [rbp-18h]\n  int c; // [rsp+18h] [rbp-8h]\n  int cntdown; // [rsp+1Ch] [rbp-4h]\n\n  cntdown = 10;\nprompt:\n  print_login_prompt();\n  do\n  {\n    c = getchar_unlocked();\n    if ( c == -1 )\n      exit(1);\n    if ( c == 10 )\n    {\n      if ( !--cntdown )\n        exit(1);\n      goto prompt;\n    }\n  }\n  while ( (_BYTE)c == 32 || (unsigned __int8)(c - 9) <= 4u );\n  bufa = buf + 1;\n  *buf = c;\n  if ( !fgets_unlocked(buf + 1, size_buf - 2, stdin) )\n    exit(1);\n  if ( !strchr(bufa, 10) )\n    exit(1);\n  while ( (unsigned __int8)*bufa > 0x20u )\n    ++bufa;\n  *bufa = 0;\n}\n",
        "similarity_score_unixcoder": 0.7796513438224792,
        "similarity_score_baseline_stripped": 0.5990216732025146,
        "similarity_score_baseline_debug": 0.900750994682312
    },
    {
        "func_name": "end_cmd_q",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl entry_compare(const void *x, const void *y)\n{\n  bool v3; // [rsp+1h] [rbp-21h]\n\n  v3 = 0;\n  if ( *(_QWORD *)x == *(_QWORD *)y )\n    return *((_QWORD *)x + 1) == *((_QWORD *)y + 1);\n  return v3;\n}\n\n\n Revised code:\nstatic bool\nentry_compare (void const *x, void const *y)\n{\n  struct entry const *a = x;\n  struct entry const *b = y;\n  return SAME_INODE (*a, *b) ? true : false;\n}\n\n## Example:\n\n Input code:\nbool __cdecl src_to_dest_compare(const void *x, const void *y)\n{\n  bool v3; // [rsp+1h] [rbp-21h]\n\n  v3 = 0;\n  if ( *(_QWORD *)x == *(_QWORD *)y )\n    return *((_QWORD *)x + 1) == *((_QWORD *)y + 1);\n  return v3;\n}\n\n\n Revised code:\nstatic bool\nsrc_to_dest_compare (void const *x, void const *y)\n{\n  struct Src_to_dest const *a = x;\n  struct Src_to_dest const *b = y;\n  return SAME_INODE (*a, *b) ? true : false;\n}\n\n## Example:\n\n Input code:\nbool __cdecl triple_compare(const void *x, const void *y)\n{\n  bool v3; // [rsp+Fh] [rbp-21h]\n\n  v3 = 0;\n  if ( *((_QWORD *)x + 1) == *((_QWORD *)y + 1) )\n  {\n    v3 = 0;\n    if ( *((_QWORD *)x + 2) == *((_QWORD *)y + 2) )\n      return same_name(*(const char **)x, *(const char **)y);\n  }\n  return v3;\n}\n\n\n Revised code:\nstatic bool\ntriple_compare (void const *x, void const *y)\n{\n  struct F_triple const *a = x;\n  struct F_triple const *b = y;\n  return (SAME_INODE (*a, *b) && same_name (a->name, b->name)) ? true : false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid *sub_4EEE98()\n{\n  void *result; // rax\n\n  *((_DWORD *)qword_75D408 + 44) = 26;\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 118) = 0;\n  return result;\n}\n",
        "output": "```c\nstatic void *\ninitialize_global_structure(void)\n{\n  struct GlobalStruct *global = (struct GlobalStruct *)qword_75D408;\n  global->field_44 = 26;\n  global->field_118 = 0;\n  return global;\n}\n```",
        "source_code": "static void end_cmd_q(void)\n{\n#if ENABLE_FEATURE_VI_YANKMARK\n\tYDreg = 26;\t\t\t// go back to default Yank/Delete reg\n#endif\n\tadding2q = 0;\n}",
        "parsed_output": "static void *\ninitialize_global_structure(void)\n{\n  struct GlobalStruct *global = (struct GlobalStruct *)qword_75D408;\n  global->field_44 = 26;\n  global->field_118 = 0;\n  return global;\n}",
        "baseline_code_stripped": "void *sub_4EEE98()\n{\n  void *result; // rax\n\n  *((_DWORD *)qword_75D408 + 44) = 26;\n  result = qword_75D408;\n  *((_BYTE *)qword_75D408 + 118) = 0;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl end_cmd_q()\n{\n  *(_DWORD *)&ptr_to_globals->line_buf[20] = 26;\n  ptr_to_globals->tty_attrs.c_cc[5] = 0;\n}\n",
        "similarity_score_unixcoder": 0.4208746552467346,
        "similarity_score_baseline_stripped": 0.505116879940033,
        "similarity_score_baseline_debug": 0.5100896954536438
    },
    {
        "func_name": "print_long_double",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl print_int(size_t n_bytes, const void *block, const char *fmt_string)\n{\n  unsigned int *v3; // rax\n  size_t i; // [rsp+8h] [rbp-28h]\n\n  for ( i = n_bytes >> 2; i; --i )\n  {\n    v3 = (unsigned int *)block;\n    block = (char *)block + 4;\n    printf(fmt_string, *v3);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_int (size_t n_bytes, void const *block, char const *fmt_string)\n{\n  unsigned int const *p = block;\n  size_t i;\n  for (i = n_bytes / sizeof *p; i != 0; i--)\n    printf (fmt_string, *p++);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_short(size_t n_bytes, const void *block, const char *fmt_string)\n{\n  unsigned __int16 *v3; // rax\n  size_t i; // [rsp+8h] [rbp-28h]\n\n  for ( i = n_bytes >> 1; i; --i )\n  {\n    v3 = (unsigned __int16 *)block;\n    block = (char *)block + 2;\n    printf(fmt_string, *v3);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_short (size_t n_bytes, void const *block, char const *fmt_string)\n{\n  unsigned short int const *p = block;\n  size_t i;\n  for (i = n_bytes / sizeof *p; i != 0; i--)\n    printf (fmt_string, *p++);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_s_short(size_t n_bytes, const void *block, const char *fmt_string)\n{\n  __int16 *v3; // rax\n  size_t i; // [rsp+8h] [rbp-28h]\n\n  for ( i = n_bytes >> 1; i; --i )\n  {\n    v3 = (__int16 *)block;\n    block = (char *)block + 2;\n    printf(fmt_string, (unsigned int)*v3);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_s_short (size_t n_bytes, void const *block, char const *fmt_string)\n{\n  short int const *p = block;\n  size_t i;\n  for (i = n_bytes / sizeof *p; i != 0; i--)\n    printf (fmt_string, *p++);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4CDE0F(unsigned __int64 a1, __int64 a2, const char *a3)\n{\n  __int64 result; // rax\n  unsigned __int64 v6; // [rsp+18h] [rbp-18h]\n\n  v6 = a1 >> 4;\n  while ( 1 )\n  {\n    result = v6--;\n    if ( !result )\n      break;\n    printf(a3);\n    a2 += 16LL;\n  }\n  return result;\n}\n",
        "output": "static void\nsub_4CDE0F (unsigned long long count, void const *ptr, char const *fmt_string)\n{\n  unsigned long long const *p = ptr;\n  while (count--)\n  {\n    printf (fmt_string);\n    p++;\n  }\n}",
        "source_code": "static void\nprint_long_double(size_t n_bytes, const char *block, const char *fmt_string)\n{\n\tn_bytes /= sizeof(longdouble_t);\n\twhile (n_bytes--) {\n\t\tlongdouble_t tmp = *(longdouble_t *) block;\n\t\tprintf(fmt_string, tmp);\n\t\tblock += sizeof(longdouble_t);\n\t}\n}",
        "parsed_output": "static void\nsub_4CDE0F (unsigned long long count, void const *ptr, char const *fmt_string)\n{\n  unsigned long long const *p = ptr;\n  while (count--)\n  {\n    printf (fmt_string);\n    p++;\n  }\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4CDE0F(unsigned __int64 a1, __int64 a2, const char *a3)\n{\n  __int64 result; // rax\n  unsigned __int64 v6; // [rsp+18h] [rbp-18h]\n\n  v6 = a1 >> 4;\n  while ( 1 )\n  {\n    result = v6--;\n    if ( !result )\n      break;\n    printf(a3);\n    a2 += 16LL;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl print_long_double(size_t n_bytes, const char *block, const char *fmt_string)\n{\n  size_t n_bytesa; // [rsp+18h] [rbp-18h]\n\n  n_bytesa = n_bytes >> 4;\n  while ( n_bytesa-- )\n  {\n    printf(fmt_string);\n    block += 16;\n  }\n}\n",
        "similarity_score_unixcoder": 0.6756944060325623,
        "similarity_score_baseline_stripped": 0.5972620248794556,
        "similarity_score_baseline_debug": 0.8329004049301147
    },
    {
        "func_name": "pid_is_exec",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nbool __cdecl sysv_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  int *v5; // rax\n  char *v6; // rax\n  size_t bytes_read; // [rsp+20h] [rbp-22E0h]\n  size_t i; // [rsp+28h] [rbp-22D8h]\n  _BYTE is_stdin[5]; // [rsp+33h] [rbp-22CDh]\n  char hbuf[652]; // [rsp+40h] [rbp-22C0h] BYREF\n  uintmax_t total_bytes; // [rsp+2D8h] [rbp-2028h]\n  unsigned __int8 buf[8192]; // [rsp+2E0h] [rbp-2020h] BYREF\n  int fd; // [rsp+22E8h] [rbp-18h]\n  int print_namea; // [rsp+22ECh] [rbp-14h]\n  const char *filea; // [rsp+22F0h] [rbp-10h]\n  char v17; // [rsp+22FFh] [rbp-1h]\n\n  filea = file;\n  print_namea = print_name;\n  total_bytes = 0LL;\n  is_stdin[4] = 0;\n  v2 = strcmp(file, \"-\");\n  *(_DWORD *)is_stdin = v2 == 0;\n  if ( !v2 )\n  {\n    fd = 0;\n    have_read_stdin = 1;\n    goto LABEL_5;\n  }\n  fd = open(filea, 0);\n  if ( fd == -1 )\n  {\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    v17 = 0;\n  }\n  else\n  {\nLABEL_5:\n    while ( 1 )\n    {\n      bytes_read = safe_read(fd, buf, 0x2000uLL);\n      if ( !bytes_read )\n        break;\n      if ( bytes_read == -1LL )\n      {\n        v4 = __errno_location();\n        error(0, *v4, \"%s\", filea);\n        if ( (is_stdin[0] & 1) == 0 )\n          close(fd);\n        v17 = 0;\n        return v17 & 1;\n      }\n      for ( i = 0LL; i < bytes_read; ++i )\n        *(_DWORD *)&is_stdin[1] += buf[i];\n      total_bytes += bytes_read;\n    }\n    if ( (is_stdin[0] & 1) != 0 || !close(fd) )\n    {\n      v6 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x200uLL);\n      printf(\n        \"%d %s\",\n        ((HIWORD(*(_DWORD *)&is_stdin[1]) + *(unsigned __int16 *)&is_stdin[1]) >> 16)\n      + (unsigned int)(unsigned __int16)(*(_WORD *)&is_stdin[3] + *(_WORD *)&is_stdin[1]),\n        v6);\n      if ( print_namea )\n        printf(\" %s\", filea);\n      putchar_unlocked(10);\n      v17 = 1;\n    }\n    else\n    {\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filea);\n      v17 = 0;\n    }\n  }\n  return v17 & 1;\n}\n\n\n Revised code:\nstatic bool\nsysv_sum_file (const char *file, int print_name)\n{\n  int fd;\n  unsigned char buf[8192];\n  uintmax_t total_bytes = 0;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int r;\n  int checksum;\n\n  /* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n  unsigned int s = 0;\n\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fd = STDIN_FILENO;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while (1)\n    {\n      size_t i;\n      size_t bytes_read = safe_read (fd, buf, sizeof buf);\n\n      if (bytes_read == 0)\n\tbreak;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  if (!is_stdin)\n\t    close (fd);\n\t  return false;\n\t}\n\n      for (i = 0; i < bytes_read; i++)\n\ts += buf[i];\n      total_bytes += bytes_read;\n    }\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  checksum = (r & 0xffff) + (r >> 16);\n\n  printf (\"%d %s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 512));\n  if (print_name)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4D9236(unsigned int a1)\n{\n  _BOOL4 v1; // eax\n  unsigned int v3; // [rsp+Ch] [rbp-44h]\n  char s[32]; // [rsp+10h] [rbp-40h] BYREF\n  ssize_t v5; // [rsp+30h] [rbp-20h]\n  unsigned int v6; // [rsp+3Ch] [rbp-14h]\n  char *s2; // [rsp+40h] [rbp-10h]\n  char *v8; // [rsp+48h] [rbp-8h]\n\n  v3 = a1;\n  v8 = &s[sprintf(s, \"/proc/%u/exe\", a1) - 3];\n  s2 = sub_40AF13(s);\n  v1 = s2 && !strcmp(*(const char **)&dest.c_cc[7], s2);\n  v6 = v1;\n  free(s2);\n  if ( v6 )\n    return v6;\n  *(_QWORD *)v8 = 0x656E696C646D63LL;\n  v5 = sub_40B501(s, *(char **)&dest.c_cc[23], *(unsigned int *)&dest.c_cc[31]);\n  if ( v5 <= 0 )\n    return 0LL;\n  *(_BYTE *)(*(_QWORD *)&dest.c_cc[23] + v5) = 0;\n  return strcmp(*(const char **)&dest.c_cc[7], *(const char **)&dest.c_cc[23]) == 0;\n}\n",
        "output": "```c\nbool check_process_name(unsigned int pid)\n{\n  char proc_path[32];\n  char *resolved_path;\n  char *exe_suffix;\n  ssize_t num_read;\n  bool result;\n\n  // Construct the path to the process executable\n  exe_suffix = &proc_path[sprintf(proc_path, \"/proc/%u/exe\", pid) - 3];\n  resolved_path = resolve_path(proc_path);\n\n  // Check if the resolved path matches the expected process name\n  result = resolved_path && !strcmp(expected_process_name, resolved_path);\n  free(resolved_path);\n\n  if (result)\n    return true;\n\n  // If not matched, modify the path to check for a different name\n  *(uint64_t *)exe_suffix = 0x656E696C646D63LL; // \"cmdline\"\n  num_read = read_link(proc_path, link_buffer, sizeof_link_buffer);\n\n  if (num_read <= 0)\n    return false;\n\n  link_buffer[num_read] = '\\0'; // Null-terminate the read content\n  return strcmp(expected_process_name, link_buffer) == 0;\n}\n```",
        "source_code": "static int pid_is_exec(pid_t pid)\n{\n\tstruct stat st;\n\tchar buf[sizeof(\"/proc/%u/exe\") + sizeof(int)*3];\n\n\tsprintf(buf, \"/proc/%u/exe\", (unsigned)pid);\n\tif (stat(buf, &st) < 0)\n\t\treturn 0;\n\tif (st.st_dev == execstat.st_dev\n\t && st.st_ino == execstat.st_ino)\n\t\treturn 1;\n\treturn 0;\n}",
        "parsed_output": "bool check_process_name(unsigned int pid)\n{\n  char proc_path[32];\n  char *resolved_path;\n  char *exe_suffix;\n  ssize_t num_read;\n  bool result;\n\n  // Construct the path to the process executable\n  exe_suffix = &proc_path[sprintf(proc_path, \"/proc/%u/exe\", pid) - 3];\n  resolved_path = resolve_path(proc_path);\n\n  // Check if the resolved path matches the expected process name\n  result = resolved_path && !strcmp(expected_process_name, resolved_path);\n  free(resolved_path);\n\n  if (result)\n    return true;\n\n  // If not matched, modify the path to check for a different name\n  *(uint64_t *)exe_suffix = 0x656E696C646D63LL; // \"cmdline\"\n  num_read = read_link(proc_path, link_buffer, sizeof_link_buffer);\n\n  if (num_read <= 0)\n    return false;\n\n  link_buffer[num_read] = '\\0'; // Null-terminate the read content\n  return strcmp(expected_process_name, link_buffer) == 0;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4D9236(unsigned int a1)\n{\n  _BOOL4 v1; // eax\n  unsigned int v3; // [rsp+Ch] [rbp-44h]\n  char s[32]; // [rsp+10h] [rbp-40h] BYREF\n  ssize_t v5; // [rsp+30h] [rbp-20h]\n  unsigned int v6; // [rsp+3Ch] [rbp-14h]\n  char *s2; // [rsp+40h] [rbp-10h]\n  char *v8; // [rsp+48h] [rbp-8h]\n\n  v3 = a1;\n  v8 = &s[sprintf(s, \"/proc/%u/exe\", a1) - 3];\n  s2 = sub_40AF13(s);\n  v1 = s2 && !strcmp(*(const char **)&dest.c_cc[7], s2);\n  v6 = v1;\n  free(s2);\n  if ( v6 )\n    return v6;\n  *(_QWORD *)v8 = 0x656E696C646D63LL;\n  v5 = sub_40B501(s, *(char **)&dest.c_cc[23], *(unsigned int *)&dest.c_cc[31]);\n  if ( v5 <= 0 )\n    return 0LL;\n  *(_BYTE *)(*(_QWORD *)&dest.c_cc[23] + v5) = 0;\n  return strcmp(*(const char **)&dest.c_cc[7], *(const char **)&dest.c_cc[23]) == 0;\n}\n",
        "baseline_code_debug": "int __cdecl pid_is_exec(pid_t pid)\n{\n  int v1; // eax\n  pid_t pida; // [rsp+Ch] [rbp-44h]\n  char buf[29]; // [rsp+10h] [rbp-40h] BYREF\n  ssize_t bytes; // [rsp+30h] [rbp-20h]\n  int match; // [rsp+3Ch] [rbp-14h]\n  char *exelink; // [rsp+40h] [rbp-10h]\n  char *procname; // [rsp+48h] [rbp-8h]\n\n  pida = pid;\n  procname = &buf[sprintf(buf, \"/proc/%u/exe\", (unsigned int)pid) - 3];\n  exelink = xmalloc_readlink(buf);\n  v1 = exelink && !strcmp(*(const char **)&bb_common_bufsiz1.c_cc[7], exelink);\n  match = v1;\n  free(exelink);\n  if ( match )\n    return match;\n  *(_QWORD *)procname = 0x656E696C646D63LL;\n  bytes = open_read_close(buf, *(void **)&bb_common_bufsiz1.c_cc[23], *(unsigned int *)&bb_common_bufsiz1.c_cc[31]);\n  if ( bytes <= 0 )\n    return 0;\n  *(_BYTE *)(*(_QWORD *)&bb_common_bufsiz1.c_cc[23] + bytes) = 0;\n  return strcmp(*(const char **)&bb_common_bufsiz1.c_cc[7], *(const char **)&bb_common_bufsiz1.c_cc[23]) == 0;\n}\n",
        "similarity_score_unixcoder": 0.7713907361030579,
        "similarity_score_baseline_stripped": 0.5646306872367859,
        "similarity_score_baseline_debug": 0.7550192475318909
    },
    {
        "func_name": "hush_exit",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  unsigned __int8 *v3; // rax\n  const char *v4; // rdi\n  char buf[5]; // [rsp+33h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+38h] [rbp-38h]\n  unsigned __int8 c; // [rsp+47h] [rbp-29h]\n  size_t i; // [rsp+48h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+50h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+58h] [rbp-18h]\n  const void *blocka; // [rsp+60h] [rbp-10h]\n  size_t n_bytesa; // [rsp+68h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = (unsigned __int8 *)p++;\n    c = *v3;\n    switch ( c )\n    {\n      case 0u:\n        s = \" \\\\0\";\n        break;\n      case 7u:\n        s = (const char *)&unk_409AA8;\n        break;\n      case 8u:\n        s = (const char *)&unk_409AAC;\n        break;\n      case 9u:\n        s = (const char *)&unk_409ABC;\n        break;\n      case 0xAu:\n        s = (const char *)&unk_409AB4;\n        break;\n      case 0xBu:\n        s = (const char *)&unk_409AC0;\n        break;\n      case 0xCu:\n        s = (const char *)&unk_409AB0;\n        break;\n      case 0xDu:\n        s = (const char *)&unk_409AB8;\n        break;\n      default:\n        v4 = \"%03o\";\n        if ( ((*__ctype_b_loc())[c] & 0x4000) != 0 )\n          v4 = \"  %c\";\n        sprintf(buf, v4, c);\n        s = buf;\n        break;\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_ascii (size_t n_bytes, void const *block,\n\t     const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      unsigned char c = *p++;\n      const char *s;\n      char buf[5];\n\n      switch (c)\n\t{\n\tcase '\\0':\n\t  s = \" \\\\0\";\n\t  break;\n\n\tcase '\\a':\n\t  s = \" \\\\a\";\n\t  break;\n\n\tcase '\\b':\n\t  s = \" \\\\b\";\n\t  break;\n\n\tcase '\\f':\n\t  s = \" \\\\f\";\n\t  break;\n\n\tcase '\\n':\n\t  s = \" \\\\n\";\n\t  break;\n\n\tcase '\\r':\n\t  s = \" \\\\r\";\n\t  break;\n\n\tcase '\\t':\n\t  s = \" \\\\t\";\n\t  break;\n\n\tcase '\\v':\n\t  s = \" \\\\v\";\n\t  break;\n\n\tdefault:\n\t  sprintf (buf, (isprint (c) ? \"  %c\" : \"%03o\"), c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nvoid __fastcall __noreturn sub_48044A(unsigned __int8 a1)\n{\n  char v1[8]; // [rsp+10h] [rbp-20h] BYREF\n  __int64 v2; // [rsp+18h] [rbp-18h]\n  __int64 v3; // [rsp+20h] [rbp-10h]\n\n  sub_40A649();\n  if ( *((char *)qword_75D408 + 78) <= 0 && *((_QWORD *)qword_75D408 + 21) && **((_QWORD **)qword_75D408 + 21) )\n  {\n    if ( ***((_BYTE ***)qword_75D408 + 21) )\n    {\n      v2 = **((_QWORD **)qword_75D408 + 21);\n      v3 = 0LL;\n      *((_BYTE *)qword_75D408 + 78) = 1;\n      sub_4891A3(v1);\n    }\n  }\n  sub_40A649();\n  sub_480360(-a1);\n}\n",
        "output": "```c\nstatic void __noreturn sub_48044A(unsigned char a1)\n{\n  char buffer[8]; // Temporary buffer\n  __int64 ptr_value; // Pointer value\n  __int64 zero_value; // Zero value\n\n  sub_40A649();\n  if (global_struct.status <= 0 && global_struct.ptr && *global_struct.ptr)\n  {\n    if (**global_struct.ptr)\n    {\n      ptr_value = *global_struct.ptr;\n      zero_value = 0LL;\n      global_struct.status = 1;\n      sub_4891A3(buffer);\n    }\n  }\n  sub_40A649();\n  sub_480360(-a1);\n}\n```",
        "source_code": "static void hush_exit(int exitcode)\n{\n#if ENABLE_FEATURE_EDITING_SAVE_ON_EXIT\n\tsave_history(G.line_input_state);\n#endif\n\n\tfflush_all();\n\tif (G.exiting <= 0 && G.traps && G.traps[0] && G.traps[0][0]) {\n\t\tchar *argv[3];\n\t\t/* argv[0] is unused */\n\t\targv[1] = G.traps[0];\n\t\targv[2] = NULL;\n\t\tG.exiting = 1; /* prevent EXIT trap recursion */\n\t\t/* Note: G.traps[0] is not cleared!\n\t\t * \"trap\" will still show it, if executed\n\t\t * in the handler */\n\t\tbuiltin_eval(argv);\n\t}\n\n#if ENABLE_FEATURE_CLEAN_UP\n\t{\n\t\tstruct variable *cur_var;\n\t\tif (G.cwd != bb_msg_unknown)\n\t\t\tfree((char*)G.cwd);\n\t\tcur_var = G.top_var;\n\t\twhile (cur_var) {\n\t\t\tstruct variable *tmp = cur_var;\n\t\t\tif (!cur_var->max_len)\n\t\t\t\tfree(cur_var->varstr);\n\t\t\tcur_var = cur_var->next;\n\t\t\tfree(tmp);\n\t\t}\n\t}\n#endif\n\n#if ENABLE_HUSH_JOB\n\tfflush_all();\n\tsigexit(- (exitcode & 0xff));\n#else\n\texit(exitcode);\n#endif\n}",
        "parsed_output": "static void __noreturn sub_48044A(unsigned char a1)\n{\n  char buffer[8]; // Temporary buffer\n  __int64 ptr_value; // Pointer value\n  __int64 zero_value; // Zero value\n\n  sub_40A649();\n  if (global_struct.status <= 0 && global_struct.ptr && *global_struct.ptr)\n  {\n    if (**global_struct.ptr)\n    {\n      ptr_value = *global_struct.ptr;\n      zero_value = 0LL;\n      global_struct.status = 1;\n      sub_4891A3(buffer);\n    }\n  }\n  sub_40A649();\n  sub_480360(-a1);\n}",
        "baseline_code_stripped": "void __fastcall __noreturn sub_48044A(unsigned __int8 a1)\n{\n  char v1[8]; // [rsp+10h] [rbp-20h] BYREF\n  __int64 v2; // [rsp+18h] [rbp-18h]\n  __int64 v3; // [rsp+20h] [rbp-10h]\n\n  sub_40A649();\n  if ( *((char *)qword_75D408 + 78) <= 0 && *((_QWORD *)qword_75D408 + 21) && **((_QWORD **)qword_75D408 + 21) )\n  {\n    if ( ***((_BYTE ***)qword_75D408 + 21) )\n    {\n      v2 = **((_QWORD **)qword_75D408 + 21);\n      v3 = 0LL;\n      *((_BYTE *)qword_75D408 + 78) = 1;\n      sub_4891A3(v1);\n    }\n  }\n  sub_40A649();\n  sub_480360(-a1);\n}\n",
        "baseline_code_debug": "void __cdecl __noreturn hush_exit(int exitcode)\n{\n  char *argv[3]; // [rsp+10h] [rbp-20h] BYREF\n\n  fflush_all();\n  if ( SBYTE2(ptr_to_globals->speeds[6]) <= 0\n    && *(_QWORD *)&ptr_to_globals->line_buf[12]\n    && **(_QWORD **)&ptr_to_globals->line_buf[12] )\n  {\n    if ( ***(_BYTE ***)&ptr_to_globals->line_buf[12] )\n    {\n      argv[1] = **(char ***)&ptr_to_globals->line_buf[12];\n      argv[2] = 0LL;\n      BYTE2(ptr_to_globals->speeds[6]) = 1;\n      builtin_eval(argv);\n    }\n  }\n  fflush_all();\n  sigexit(-(unsigned __int8)exitcode);\n}\n",
        "similarity_score_unixcoder": 0.5407339334487915,
        "similarity_score_baseline_stripped": 0.43171459436416626,
        "similarity_score_baseline_debug": 0.7086278796195984
    },
    {
        "func_name": "opp_bracket",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n\n## Example:\n\n Input code:\nint __cdecl hextobin(unsigned __int8 c)\n{\n  int v2; // [rsp+10h] [rbp-4h]\n\n  switch ( c )\n  {\n    case 'A':\n    case 'a':\n      v2 = 10;\n      break;\n    case 'B':\n    case 'b':\n      v2 = 11;\n      break;\n    case 'C':\n    case 'c':\n      v2 = 12;\n      break;\n    case 'D':\n    case 'd':\n      v2 = 13;\n      break;\n    case 'E':\n    case 'e':\n      v2 = 14;\n      break;\n    case 'F':\n    case 'f':\n      v2 = 15;\n      break;\n    default:\n      v2 = c - 48;\n      break;\n  }\n  return v2;\n}\n\n\n Revised code:\nstatic int\nhextobin (unsigned char c)\n{\n  switch (c)\n    {\n    default: return c - '0';\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    }\n}\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_41F0AA(unsigned __int8 a1)\n{\n  unsigned __int8 v2; // [rsp+0h] [rbp-4h]\n\n  v2 = a1;\n  if ( a1 == 91 )\n    goto LABEL_10;\n  if ( (char)a1 <= 91 )\n  {\n    if ( a1 != 40 )\n    {\n      if ( a1 != 41 )\n        return v2;\n      goto LABEL_13;\n    }\n    goto LABEL_11;\n  }\n  if ( a1 == 123 )\n  {\nLABEL_10:\n    v2 = a1 + 1;\nLABEL_11:\n    ++v2;\n    return v2;\n  }\n  if ( a1 == 125 || a1 == 93 )\n  {\n    v2 = a1 - 1;\nLABEL_13:\n    --v2;\n  }\n  return v2;\n}\n",
        "output": "```c\nstatic unsigned char\nsub_41F0AA (unsigned char a1)\n{\n  if (a1 == '[' || a1 == '{')\n    return a1 + 2;\n  else if (a1 == '(')\n    return a1 + 1;\n  else if (a1 == ']' || a1 == '}')\n    return a1 - 2;\n  else if (a1 == ')')\n    return a1 - 1;\n  else\n    return a1;\n}\n```",
        "source_code": "if ENABLE_FEATURE_LESS_BRACKETS\nstatic char opp_bracket(char bracket)\n{\n\tswitch (bracket) {\n\t\tcase '{': case '[': /* '}' == '{' + 2. Same for '[' */\n\t\t\tbracket++;\n\t\tcase '(':           /* ')' == '(' + 1 */\n\t\t\tbracket++;\n\t\t\tbreak;\n\t\tcase '}': case ']':\n\t\t\tbracket--;\n\t\tcase ')':\n\t\t\tbracket--;\n\t\t\tbreak;\n\t};\n\treturn bracket;\n}",
        "parsed_output": "static unsigned char\nsub_41F0AA (unsigned char a1)\n{\n  if (a1 == '[' || a1 == '{')\n    return a1 + 2;\n  else if (a1 == '(')\n    return a1 + 1;\n  else if (a1 == ']' || a1 == '}')\n    return a1 - 2;\n  else if (a1 == ')')\n    return a1 - 1;\n  else\n    return a1;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_41F0AA(unsigned __int8 a1)\n{\n  unsigned __int8 v2; // [rsp+0h] [rbp-4h]\n\n  v2 = a1;\n  if ( a1 == 91 )\n    goto LABEL_10;\n  if ( (char)a1 <= 91 )\n  {\n    if ( a1 != 40 )\n    {\n      if ( a1 != 41 )\n        return v2;\n      goto LABEL_13;\n    }\n    goto LABEL_11;\n  }\n  if ( a1 == 123 )\n  {\nLABEL_10:\n    v2 = a1 + 1;\nLABEL_11:\n    ++v2;\n    return v2;\n  }\n  if ( a1 == 125 || a1 == 93 )\n  {\n    v2 = a1 - 1;\nLABEL_13:\n    --v2;\n  }\n  return v2;\n}\n",
        "baseline_code_debug": "char __cdecl opp_bracket(char bracket)\n{\n  char bracketa; // [rsp+0h] [rbp-4h]\n\n  bracketa = bracket;\n  if ( bracket == 91 )\n    goto LABEL_10;\n  if ( bracket <= 91 )\n  {\n    if ( bracket != 40 )\n    {\n      if ( bracket != 41 )\n        return bracketa;\n      goto LABEL_13;\n    }\n    goto LABEL_11;\n  }\n  if ( bracket == 123 )\n  {\nLABEL_10:\n    bracketa = bracket + 1;\nLABEL_11:\n    ++bracketa;\n    return bracketa;\n  }\n  if ( bracket == 125 || bracket == 93 )\n  {\n    bracketa = bracket - 1;\nLABEL_13:\n    --bracketa;\n  }\n  return bracketa;\n}\n",
        "similarity_score_unixcoder": 0.6668525338172913,
        "similarity_score_baseline_stripped": 0.49472931027412415,
        "similarity_score_baseline_debug": 0.7837803363800049
    },
    {
        "func_name": "sha512_hash",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl hextobin(unsigned __int8 c)\n{\n  int v2; // [rsp+10h] [rbp-4h]\n\n  switch ( c )\n  {\n    case 'A':\n    case 'a':\n      v2 = 10;\n      break;\n    case 'B':\n    case 'b':\n      v2 = 11;\n      break;\n    case 'C':\n    case 'c':\n      v2 = 12;\n      break;\n    case 'D':\n    case 'd':\n      v2 = 13;\n      break;\n    case 'E':\n    case 'e':\n      v2 = 14;\n      break;\n    case 'F':\n    case 'f':\n      v2 = 15;\n      break;\n    default:\n      v2 = c - 48;\n      break;\n  }\n  return v2;\n}\n\n\n Revised code:\nstatic int\nhextobin (unsigned char c)\n{\n  switch (c)\n    {\n    default: return c - '0';\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    }\n}\n\n## Example:\n\n Input code:\nvoid __cdecl fillpattern(int type, unsigned __int8 *r, size_t size)\n{\n  size_t i; // [rsp+10h] [rbp-20h]\n  size_t ia; // [rsp+10h] [rbp-20h]\n\n  *r = (type & 0xFFF | ((type & 0xFFFu) << 12)) >> 4;\n  r[1] = (unsigned __int16)(type & 0xFFF | ((type & 0xFFF) << 12)) >> 8;\n  r[2] = type;\n  for ( i = 3LL; i < size >> 1; i *= 2LL )\n    memcpy(&r[i], r, i);\n  if ( i < size )\n    memcpy(&r[i], r, size - i);\n  if ( (type & 0x1000) != 0 )\n  {\n    for ( ia = 0LL; ia < size; ia += 512LL )\n      r[ia] ^= 0x80u;\n  }\n}\n\n\n Revised code:\nstatic void\nfillpattern (int type, unsigned char *r, size_t size)\n{\n  size_t i;\n  unsigned int bits = type & 0xfff;\n\n  bits |= bits << 12;\n  r[0] = (bits >> 4) & 255;\n  r[1] = (bits >> 8) & 255;\n  r[2] = bits & 255;\n  for (i = 3; i < size / 2; i *= 2)\n    memcpy (r + i, r, i);\n  if (i < size)\n    memcpy (r + i, r, size - i);\n\n  /* Invert the first bit of every sector. */\n  if (type & 0x1000)\n    for (i = 0; i < size; i += SECTOR_SIZE)\n      r[i] ^= 0x80;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl format_address_std(uintmax_t address, char c)\n{\n  char *v2; // rax\n  char *v3; // rcx\n  char *v4; // rax\n  char *v5; // rax\n  const char *pbound; // [rsp+20h] [rbp-40h]\n  char *p; // [rsp+28h] [rbp-38h]\n  char buf[25]; // [rsp+30h] [rbp-30h] BYREF\n  char ca; // [rsp+57h] [rbp-9h]\n  uintmax_t addressa; // [rsp+58h] [rbp-8h]\n\n  addressa = address;\n  ca = c;\n  buf[24] = 0;\n  p = &buf[23];\n  buf[23] = c;\n  pbound = &buf[-address_pad_len + 23];\n  switch ( address_base )\n  {\n    case 8:\n      do\n      {\n        v2 = p--;\n        *(v2 - 1) = (addressa & 7) + 48;\n        addressa >>= 3;\n      }\n      while ( addressa );\n      break;\n    case 10:\n      do\n      {\n        v3 = p--;\n        *(v3 - 1) = addressa % 0xA + 48;\n        addressa /= 0xAuLL;\n      }\n      while ( addressa );\n      break;\n    case 16:\n      do\n      {\n        v4 = p--;\n        *(v4 - 1) = byte_4097D0[addressa & 0xF];\n        addressa >>= 4;\n      }\n      while ( addressa );\n      break;\n  }\n  while ( pbound < p )\n  {\n    v5 = p--;\n    *(v5 - 1) = 48;\n  }\n  fputs_unlocked(p, _bss_start);\n}\n\n\n Revised code:\nstatic void\nformat_address_std (uintmax_t address, char c)\n{\n  char buf[MAX_ADDRESS_LENGTH + 2];\n  char *p = buf + sizeof buf;\n  char const *pbound;\n\n  *--p = '\\0';\n  *--p = c;\n  pbound = p - address_pad_len;\n\n  /* Use a special case of the code for each base.  This is measurably\n     faster than generic code.  */\n  switch (address_base)\n    {\n    case 8:\n      do\n\t*--p = '0' + (address & 7);\n      while ((address >>= 3) != 0);\n      break;\n\n    case 10:\n      do\n\t*--p = '0' + (address % 10);\n      while ((address /= 10) != 0);\n      break;\n\n    case 16:\n      do\n\t*--p = \"0123456789abcdef\"[address & 15];\n      while ((address >>= 4) != 0);\n      break;\n    }\n\n  while (pbound < p)\n    *--p = '0';\n\n  fputs (p, stdout);\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_4FC3CB(unsigned __int64 *a1, char *a2, unsigned __int64 a3)\n{\n  __int64 result; // rax\n  unsigned __int64 v4; // [rsp+8h] [rbp-28h]\n  unsigned int n; // [rsp+28h] [rbp-8h]\n  unsigned int n_4; // [rsp+2Ch] [rbp-4h]\n\n  v4 = a3;\n  n_4 = *a1 & 0x7F;\n  *a1 += a3;\n  if ( a3 > *a1 )\n    ++a1[1];\n  while ( 1 )\n  {\n    n = 128 - n_4;\n    if ( v4 < 128 - n_4 )\n      n = v4;\n    memcpy((char *)a1 + n_4 + 80, a2, n);\n    v4 -= n;\n    a2 += n;\n    result = n;\n    n_4 = n + n_4 - 128;\n    if ( n_4 )\n      break;\n    sub_4FBEC1(a1);\n  }\n  return result;\n}\n",
        "output": "```c\nstatic uint64_t\nsub_4FC3CB(uint64_t *a1, char *a2, uint64_t a3)\n{\n  uint64_t result;\n  uint64_t remaining = a3;\n  unsigned int n;\n  unsigned int offset = *a1 & 0x7F;\n\n  *a1 += a3;\n  if (a3 > *a1)\n    ++a1[1];\n\n  while (1)\n  {\n    n = 128 - offset;\n    if (remaining < n)\n      n = remaining;\n    memcpy((char *)a1 + offset + 80, a2, n);\n    remaining -= n;\n    a2 += n;\n    result = n;\n    offset = (offset + n) & 0x7F;\n    if (offset == 0)\n    {\n      sub_4FBEC1(a1);\n      break;\n    }\n  }\n  return result;\n}\n```",
        "source_code": "void FAST_FUNC sha512_hash(sha512_ctx_t *ctx, const void *buffer, size_t len)\n{\n\tunsigned bufpos = ctx->total64[0] & 127;\n\tunsigned remaining;\n\n\t/* First increment the byte count.  FIPS 180-2 specifies the possible\n\t   length of the file up to 2^128 _bits_.\n\t   We compute the number of _bytes_ and convert to bits later.  */\n\tctx->total64[0] += len;\n\tif (ctx->total64[0] < len)\n\t\tctx->total64[1]++;\n#if 0\n\tremaining = 128 - bufpos;\n\n\t/* Hash whole blocks */\n\twhile (len >= remaining) {\n\t\tmemcpy(ctx->wbuffer + bufpos, buffer, remaining);\n\t\tbuffer = (const char *)buffer + remaining;\n\t\tlen -= remaining;\n\t\tremaining = 128;\n\t\tbufpos = 0;\n\t\tsha512_process_block128(ctx);\n\t}\n\n\t/* Save last, partial blosk */\n\tmemcpy(ctx->wbuffer + bufpos, buffer, len);\n#else\n\twhile (1) {\n\t\tremaining = 128 - bufpos;\n\t\tif (remaining > len)\n\t\t\tremaining = len;\n\t\t/* Copy data into aligned buffer */\n\t\tmemcpy(ctx->wbuffer + bufpos, buffer, remaining);\n\t\tlen -= remaining;\n\t\tbuffer = (const char *)buffer + remaining;\n\t\tbufpos += remaining;\n\t\t/* Clever way to do \"if (bufpos != N) break; ... ; bufpos = 0;\" */\n\t\tbufpos -= 128;\n\t\tif (bufpos != 0)\n\t\t\tbreak;\n\t\t/* Buffer is filled up, process it */\n\t\tsha512_process_block128(ctx);\n\t\t/*bufpos = 0; - already is */\n\t}\n#endif\n}",
        "parsed_output": "static uint64_t\nsub_4FC3CB(uint64_t *a1, char *a2, uint64_t a3)\n{\n  uint64_t result;\n  uint64_t remaining = a3;\n  unsigned int n;\n  unsigned int offset = *a1 & 0x7F;\n\n  *a1 += a3;\n  if (a3 > *a1)\n    ++a1[1];\n\n  while (1)\n  {\n    n = 128 - offset;\n    if (remaining < n)\n      n = remaining;\n    memcpy((char *)a1 + offset + 80, a2, n);\n    remaining -= n;\n    a2 += n;\n    result = n;\n    offset = (offset + n) & 0x7F;\n    if (offset == 0)\n    {\n      sub_4FBEC1(a1);\n      break;\n    }\n  }\n  return result;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_4FC3CB(unsigned __int64 *a1, char *a2, unsigned __int64 a3)\n{\n  __int64 result; // rax\n  unsigned __int64 v4; // [rsp+8h] [rbp-28h]\n  unsigned int n; // [rsp+28h] [rbp-8h]\n  unsigned int n_4; // [rsp+2Ch] [rbp-4h]\n\n  v4 = a3;\n  n_4 = *a1 & 0x7F;\n  *a1 += a3;\n  if ( a3 > *a1 )\n    ++a1[1];\n  while ( 1 )\n  {\n    n = 128 - n_4;\n    if ( v4 < 128 - n_4 )\n      n = v4;\n    memcpy((char *)a1 + n_4 + 80, a2, n);\n    v4 -= n;\n    a2 += n;\n    result = n;\n    n_4 = n + n_4 - 128;\n    if ( n_4 )\n      break;\n    sub_4FBEC1(a1);\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl sha512_hash(sha512_ctx_t_0 *ctx, const void *buffer, size_t len)\n{\n  unsigned __int64 lena; // [rsp+8h] [rbp-28h]\n  unsigned int remaining; // [rsp+28h] [rbp-8h]\n  unsigned int bufpos; // [rsp+2Ch] [rbp-4h]\n\n  lena = len;\n  bufpos = ctx->total64[0] & 0x7F;\n  ctx->total64[0] += len;\n  if ( len > ctx->total64[0] )\n    ++ctx->total64[1];\n  while ( 1 )\n  {\n    remaining = 128 - bufpos;\n    if ( lena < 128 - bufpos )\n      remaining = lena;\n    memcpy(&ctx->wbuffer[bufpos], buffer, remaining);\n    lena -= remaining;\n    buffer = (char *)buffer + remaining;\n    bufpos = remaining + bufpos - 128;\n    if ( bufpos )\n      break;\n    sha512_process_block128(ctx);\n  }\n}\n",
        "similarity_score_unixcoder": 0.627446711063385,
        "similarity_score_baseline_stripped": 0.5915311574935913,
        "similarity_score_baseline_debug": 0.9095100164413452
    },
    {
        "func_name": "setstackmark",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_occurs(const void *void_first, const void *void_second)\n{\n  __int64 v3; // [rsp+8h] [rbp-28h]\n  int value; // [rsp+1Ch] [rbp-14h]\n\n  value = compare_words(void_first, void_second);\n  if ( value )\n    LODWORD(v3) = value;\n  else\n    return *(_QWORD *)void_first - *(_QWORD *)void_second;\n  return v3;\n}\n\n\n Revised code:\nstatic int\ncompare_occurs (const void *void_first, const void *void_second)\n{\n#define first ((const OCCURS *) void_first)\n#define second ((const OCCURS *) void_second)\n  int value;\n\n  value = compare_words (&first->key, &second->key);\n  return value == 0 ? first->key.start - second->key.start : value;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nbool __cdecl triple_compare(const void *x, const void *y)\n{\n  bool v3; // [rsp+Fh] [rbp-21h]\n\n  v3 = 0;\n  if ( *((_QWORD *)x + 1) == *((_QWORD *)y + 1) )\n  {\n    v3 = 0;\n    if ( *((_QWORD *)x + 2) == *((_QWORD *)y + 2) )\n      return same_name(*(const char **)x, *(const char **)y);\n  }\n  return v3;\n}\n\n\n Revised code:\nstatic bool\ntriple_compare (void const *x, void const *y)\n{\n  struct F_triple const *a = x;\n  struct F_triple const *b = y;\n  return (SAME_INODE (*a, *b) && same_name (a->name, b->name)) ? true : false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_46E8A1(_QWORD *a1)\n{\n  __int64 result; // rax\n\n  *a1 = *(_QWORD *)qword_75D428;\n  a1[1] = *(_QWORD *)(qword_75D428 + 16);\n  a1[2] = *(_QWORD *)(qword_75D428 + 32);\n  a1[3] = *(_QWORD *)(qword_75D428 + 8);\n  result = qword_75D428;\n  *(_QWORD *)(qword_75D428 + 8) = a1;\n  return result;\n}\n",
        "output": "```c\nstatic void\ncopy_structure (_QWORD *destination)\n{\n  extern _QWORD qword_75D428[];\n\n  destination[0] = qword_75D428[0];\n  destination[1] = qword_75D428[2];\n  destination[2] = qword_75D428[4];\n  destination[3] = qword_75D428[1];\n  qword_75D428[1] = destination;\n}\n```",
        "source_code": "static void\nsetstackmark(struct stackmark *mark)\n{\n\tmark->stackp = g_stackp;\n\tmark->stacknxt = g_stacknxt;\n\tmark->stacknleft = g_stacknleft;\n\tmark->marknext = markp;\n\tmarkp = mark;\n}",
        "parsed_output": "static void\ncopy_structure (_QWORD *destination)\n{\n  extern _QWORD qword_75D428[];\n\n  destination[0] = qword_75D428[0];\n  destination[1] = qword_75D428[2];\n  destination[2] = qword_75D428[4];\n  destination[3] = qword_75D428[1];\n  qword_75D428[1] = destination;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_46E8A1(_QWORD *a1)\n{\n  __int64 result; // rax\n\n  *a1 = *(_QWORD *)qword_75D428;\n  a1[1] = *(_QWORD *)(qword_75D428 + 16);\n  a1[2] = *(_QWORD *)(qword_75D428 + 32);\n  a1[3] = *(_QWORD *)(qword_75D428 + 8);\n  result = qword_75D428;\n  *(_QWORD *)(qword_75D428 + 8) = a1;\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl setstackmark(stackmark *mark)\n{\n  mark->stackp = ash_ptr_to_globals_memstack->g_stackp;\n  mark->stacknxt = ash_ptr_to_globals_memstack->g_stacknxt;\n  mark->stacknleft = ash_ptr_to_globals_memstack->g_stacknleft;\n  mark->marknext = ash_ptr_to_globals_memstack->markp;\n  ash_ptr_to_globals_memstack->markp = mark;\n}\n",
        "similarity_score_unixcoder": 0.3851955235004425,
        "similarity_score_baseline_stripped": 0.38715389370918274,
        "similarity_score_baseline_debug": 0.8470549583435059
    },
    {
        "func_name": "obscure",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl correct_password(const passwd *pw)\n{\n  char *v1; // rax\n  char *v2; // rax\n  size_t v3; // rax\n  struct spwd *sp_0; // [rsp+10h] [rbp-30h]\n  const char *correct; // [rsp+18h] [rbp-28h]\n  const char *encrypted; // [rsp+20h] [rbp-20h]\n  char *unencrypted; // [rsp+28h] [rbp-18h]\n\n  sp_0 = getspnam(pw->pw_name);\n  endspent();\n  if ( sp_0 )\n    correct = sp_0->sp_pwdp;\n  else\n    correct = pw->pw_passwd;\n  if ( getuid() && correct && *correct )\n  {\n    v1 = gettext(\"Password:\");\n    unencrypted = gnu_getpass(v1);\n    if ( unencrypted )\n    {\n      encrypted = crypt(unencrypted, correct);\n      v3 = strlen(unencrypted);\n      memset(unencrypted, 0, v3);\n      return strcmp(encrypted, correct) == 0;\n    }\n    else\n    {\n      v2 = gettext(\"getpass: cannot open /dev/tty\");\n      error(0, 0, v2);\n      return 0;\n    }\n  }\n  else\n  {\n    return 1;\n  }\n}\n\n\n Revised code:\nstatic bool\ncorrect_password (const struct passwd *pw)\n{\n  char *unencrypted, *encrypted, *correct;\n#if HAVE_GETSPNAM && HAVE_STRUCT_SPWD_SP_PWDP\n  /* Shadow passwd stuff for SVR3 and maybe other systems.  */\n  struct spwd *sp = getspnam (pw->pw_name);\n\n  endspent ();\n  if (sp)\n    correct = sp->sp_pwdp;\n  else\n#endif\n    correct = pw->pw_passwd;\n\n  if (getuid () == 0 || !correct || correct[0] == '\\0')\n    return true;\n\n  unencrypted = getpass (_(\"Password:\"));\n  if (!unencrypted)\n    {\n      error (0, 0, _(\"getpass: cannot open /dev/tty\"));\n      return false;\n    }\n  encrypted = crypt (unencrypted, correct);\n  memset (unencrypted, 0, strlen (unencrypted));\n  return STREQ (encrypted, correct);\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_named_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  const unsigned __int8 *v3; // rax\n  char buf[5]; // [rsp+13h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+18h] [rbp-38h]\n  int masked_c; // [rsp+24h] [rbp-2Ch]\n  size_t i; // [rsp+28h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+30h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+38h] [rbp-18h]\n  const void *blocka; // [rsp+40h] [rbp-10h]\n  size_t n_bytesa; // [rsp+48h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = p++;\n    masked_c = *v3 & 0x7F;\n    if ( masked_c == 127 )\n    {\n      s = \"del\";\n    }\n    else if ( masked_c > 32 )\n    {\n      sprintf(buf, \"  %c\", (unsigned int)masked_c);\n      s = buf;\n    }\n    else\n    {\n      s = charname[masked_c];\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_named_ascii (size_t n_bytes, void const *block,\n\t\t   const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      int masked_c = *p++ & 0x7f;\n      const char *s;\n      char buf[5];\n\n      if (masked_c == 127)\n\ts = \"del\";\n      else if (masked_c <= 040)\n\ts = charname[masked_c];\n      else\n\t{\n\t  sprintf (buf, \"  %c\", masked_c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n\n## Example:\n\n Input code:\nvoid __cdecl __noreturn badfieldspec(const char *spec, const char *msgid)\n{\n  const char *v2; // rax\n  char *v3; // [rsp+0h] [rbp-20h]\n  const char *format; // [rsp+8h] [rbp-18h]\n\n  format = gettext(\"%s: invalid field specification %s\");\n  v3 = gettext(msgid);\n  v2 = quote(spec);\n  error(2, 0, format, v3, v2);\n  abort();\n}\n\n\n Revised code:\nstatic void\nbadfieldspec (char const *spec, char const *msgid)\n{\n  error (SORT_FAILURE, 0, _(\"%s: invalid field specification %s\"),\n\t _(msgid), quote (spec));\n  abort ();\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_5023F6(const char *a1, const char *a2, const char **a3)\n{\n  const char *v4; // [rsp+28h] [rbp-8h]\n\n  v4 = sub_5021E4(a1, a2, a3);\n  if ( !v4 )\n    return 0LL;\n  printf(\"Bad password: %s\\n\", v4);\n  return 1LL;\n}\n",
        "output": "static int\ncheck_password_error(const char *user, const char *password, const char **error_message)\n{\n  const char *error_detail = get_password_error(user, password, error_message);\n  if (!error_detail)\n    return 0;\n  printf(\"Bad password: %s\\n\", error_detail);\n  return 1;\n}",
        "source_code": "int FAST_FUNC obscure(const char *old, const char *newval, const struct passwd *pw)\n{\n\tconst char *msg;\n\n\tmsg = obscure_msg(old, newval, pw);\n\tif (msg) {\n\t\tprintf(\"Bad password: %s\\n\", msg);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "parsed_output": "static int\ncheck_password_error(const char *user, const char *password, const char **error_message)\n{\n  const char *error_detail = get_password_error(user, password, error_message);\n  if (!error_detail)\n    return 0;\n  printf(\"Bad password: %s\\n\", error_detail);\n  return 1;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_5023F6(const char *a1, const char *a2, const char **a3)\n{\n  const char *v4; // [rsp+28h] [rbp-8h]\n\n  v4 = sub_5021E4(a1, a2, a3);\n  if ( !v4 )\n    return 0LL;\n  printf(\"Bad password: %s\\n\", v4);\n  return 1LL;\n}\n",
        "baseline_code_debug": "int __cdecl obscure(const char *old, const char *newval, const passwd *pw)\n{\n  const char *msg; // [rsp+28h] [rbp-8h]\n\n  msg = obscure_msg(old, newval, pw);\n  if ( !msg )\n    return 0;\n  printf(\"Bad password: %s\\n\", msg);\n  return 1;\n}\n",
        "similarity_score_unixcoder": 0.6617686748504639,
        "similarity_score_baseline_stripped": 0.5820921659469604,
        "similarity_score_baseline_debug": 0.9096794128417969
    },
    {
        "func_name": "dict_uncompressed",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nvoid __cdecl fillpattern(int type, unsigned __int8 *r, size_t size)\n{\n  size_t i; // [rsp+10h] [rbp-20h]\n  size_t ia; // [rsp+10h] [rbp-20h]\n\n  *r = (type & 0xFFF | ((type & 0xFFFu) << 12)) >> 4;\n  r[1] = (unsigned __int16)(type & 0xFFF | ((type & 0xFFF) << 12)) >> 8;\n  r[2] = type;\n  for ( i = 3LL; i < size >> 1; i *= 2LL )\n    memcpy(&r[i], r, i);\n  if ( i < size )\n    memcpy(&r[i], r, size - i);\n  if ( (type & 0x1000) != 0 )\n  {\n    for ( ia = 0LL; ia < size; ia += 512LL )\n      r[ia] ^= 0x80u;\n  }\n}\n\n\n Revised code:\nstatic void\nfillpattern (int type, unsigned char *r, size_t size)\n{\n  size_t i;\n  unsigned int bits = type & 0xfff;\n\n  bits |= bits << 12;\n  r[0] = (bits >> 4) & 255;\n  r[1] = (bits >> 8) & 255;\n  r[2] = bits & 255;\n  for (i = 3; i < size / 2; i *= 2)\n    memcpy (r + i, r, i);\n  if (i < size)\n    memcpy (r + i, r, size - i);\n\n  /* Invert the first bit of every sector. */\n  if (type & 0x1000)\n    for (i = 0; i < size; i += SECTOR_SIZE)\n      r[i] ^= 0x80;\n}\n\n## Example:\n\n Input code:\nint __cdecl compare_words(const void *void_first, const void *void_second)\n{\n  int v2; // esi\n  unsigned __int8 v3; // al\n  int v5; // [rsp+0h] [rbp-30h]\n  int v6; // [rsp+4h] [rbp-2Ch]\n  int v7; // [rsp+8h] [rbp-28h]\n  int counter; // [rsp+10h] [rbp-20h]\n  int countera; // [rsp+10h] [rbp-20h]\n\n  if ( *((__int16 *)void_first + 4) >= *((__int16 *)void_second + 4) )\n    v7 = *((__int16 *)void_second + 4);\n  else\n    v7 = *((__int16 *)void_first + 4);\n  if ( ignore_case )\n  {\n    for ( counter = 0; counter < v7; ++counter )\n    {\n      v6 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_first + counter))];\n      v2 = folded_chars[to_uchar(*(_BYTE *)(*(_QWORD *)void_second + counter))];\n      if ( v6 != v2 )\n        return v6 - v2;\n    }\n  }\n  else\n  {\n    for ( countera = 0; countera < v7; ++countera )\n    {\n      v5 = to_uchar(*(_BYTE *)(*(_QWORD *)void_first + countera));\n      v3 = to_uchar(*(_BYTE *)(*(_QWORD *)void_second + countera));\n      if ( v5 != v3 )\n        return v5 - v3;\n    }\n  }\n  return *((__int16 *)void_first + 4) - *((__int16 *)void_second + 4);\n}\n\n\n Revised code:\nstatic int\ncompare_words (const void *void_first, const void *void_second)\n{\n#define first ((const WORD *) void_first)\n#define second ((const WORD *) void_second)\n  int length;\t\t\t/* minimum of two lengths */\n  int counter;\t\t\t/* cursor in words */\n  int value;\t\t\t/* value of comparison */\n\n  length = first->size < second->size ? first->size : second->size;\n\n  if (ignore_case)\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (folded_chars [to_uchar (first->start[counter])]\n\t\t   - folded_chars [to_uchar (second->start[counter])]);\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n  else\n    {\n      for (counter = 0; counter < length; counter++)\n\t{\n\t  value = (to_uchar (first->start[counter])\n\t\t   - to_uchar (second->start[counter]));\n\t  if (value != 0)\n\t    return value;\n\t}\n    }\n\n  return first->size - second->size;\n#undef first\n#undef second\n}\n\n## Example:\n\n Input code:\nint __cdecl hextobin(unsigned __int8 c)\n{\n  int v2; // [rsp+10h] [rbp-4h]\n\n  switch ( c )\n  {\n    case 'A':\n    case 'a':\n      v2 = 10;\n      break;\n    case 'B':\n    case 'b':\n      v2 = 11;\n      break;\n    case 'C':\n    case 'c':\n      v2 = 12;\n      break;\n    case 'D':\n    case 'd':\n      v2 = 13;\n      break;\n    case 'E':\n    case 'e':\n      v2 = 14;\n      break;\n    case 'F':\n    case 'f':\n      v2 = 15;\n      break;\n    default:\n      v2 = c - 48;\n      break;\n  }\n  return v2;\n}\n\n\n Revised code:\nstatic int\nhextobin (unsigned char c)\n{\n  switch (c)\n    {\n    default: return c - '0';\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\nunsigned __int64 __fastcall sub_4BC2F8(_QWORD *a1, _QWORD *a2, _DWORD *a3)\n{\n  unsigned __int64 v3; // rax\n  unsigned __int64 result; // rax\n  unsigned __int64 n; // [rsp+28h] [rbp-8h]\n\n  while ( 1 )\n  {\n    result = (unsigned int)*a3;\n    if ( !(_DWORD)result )\n      break;\n    result = a2[2];\n    if ( a2[1] >= result )\n      break;\n    result = a2[5];\n    if ( a2[4] >= result )\n      break;\n    v3 = a2[2] - a2[1];\n    if ( a2[5] - a2[4] <= v3 )\n      v3 = a2[5] - a2[4];\n    n = v3;\n    if ( v3 > a1[5] - a1[2] )\n      n = a1[5] - a1[2];\n    if ( n > (unsigned int)*a3 )\n      n = (unsigned int)*a3;\n    *a3 -= n;\n    memcpy((void *)(*a1 + a1[2]), (const void *)(*a2 + a2[1]), n);\n    a1[2] += n;\n    if ( a1[3] < a1[2] )\n      a1[3] = a1[2];\n    if ( a1[2] == a1[5] )\n      a1[2] = 0LL;\n    memcpy((void *)(a2[3] + a2[4]), (const void *)(*a2 + a2[1]), n);\n    a1[1] = a1[2];\n    a2[4] += n;\n    a2[1] += n;\n  }\n  return result;\n}\n",
        "output": "```c\nstatic unsigned long long\nsub_4BC2F8(unsigned long long *src, unsigned long long *dest, unsigned int *len)\n{\n  unsigned long long min_len, bytes_to_copy, result;\n\n  while (*len != 0)\n  {\n    if (dest[1] >= dest[2] || dest[4] >= dest[5])\n      break;\n\n    min_len = dest[2] - dest[1];\n    if (dest[5] - dest[4] < min_len)\n      min_len = dest[5] - dest[4];\n    if (src[5] - src[2] < min_len)\n      min_len = src[5] - src[2];\n    if (*len < min_len)\n      min_len = *len;\n\n    *len -= min_len;\n    memcpy((void *)(src[0] + src[2]), (const void *)(dest[0] + dest[1]), min_len);\n    src[2] += min_len;\n    if (src[3] < src[2])\n      src[3] = src[2];\n    if (src[2] == src[5])\n      src[2] = 0;\n\n    memcpy((void *)(dest[3] + dest[4]), (const void *)(dest[0] + dest[1]), min_len);\n    src[1] = src[2];\n    dest[4] += min_len;\n    dest[1] += min_len;\n  }\n\n  result = *len;\n  return result;\n}\n```",
        "source_code": "static void XZ_FUNC dict_uncompressed(\n\t\tstruct dictionary *dict, struct xz_buf *b, uint32_t *left)\n{\n\tsize_t copy_size;\n\n\twhile (*left > 0 && b->in_pos < b->in_size\n\t\t\t&& b->out_pos < b->out_size) {\n\t\tcopy_size = min(b->in_size - b->in_pos,\n\t\t\t\tb->out_size - b->out_pos);\n\t\tif (copy_size > dict->end - dict->pos)\n\t\t\tcopy_size = dict->end - dict->pos;\n\t\tif (copy_size > *left)\n\t\t\tcopy_size = *left;\n\n\t\t*left -= copy_size;\n\n\t\tmemcpy(dict->buf + dict->pos, b->in + b->in_pos, copy_size);\n\t\tdict->pos += copy_size;\n\n\t\tif (dict->full < dict->pos)\n\t\t\tdict->full = dict->pos;\n\n\t\tif (DEC_IS_MULTI(dict->mode)) {\n\t\t\tif (dict->pos == dict->end)\n\t\t\t\tdict->pos = 0;\n\n\t\t\tmemcpy(b->out + b->out_pos, b->in + b->in_pos,\n\t\t\t\t\tcopy_size);\n\t\t}\n\n\t\tdict->start = dict->pos;\n\n\t\tb->out_pos += copy_size;\n\t\tb->in_pos += copy_size;\n\n\t}\n}",
        "parsed_output": "static unsigned long long\nsub_4BC2F8(unsigned long long *src, unsigned long long *dest, unsigned int *len)\n{\n  unsigned long long min_len, bytes_to_copy, result;\n\n  while (*len != 0)\n  {\n    if (dest[1] >= dest[2] || dest[4] >= dest[5])\n      break;\n\n    min_len = dest[2] - dest[1];\n    if (dest[5] - dest[4] < min_len)\n      min_len = dest[5] - dest[4];\n    if (src[5] - src[2] < min_len)\n      min_len = src[5] - src[2];\n    if (*len < min_len)\n      min_len = *len;\n\n    *len -= min_len;\n    memcpy((void *)(src[0] + src[2]), (const void *)(dest[0] + dest[1]), min_len);\n    src[2] += min_len;\n    if (src[3] < src[2])\n      src[3] = src[2];\n    if (src[2] == src[5])\n      src[2] = 0;\n\n    memcpy((void *)(dest[3] + dest[4]), (const void *)(dest[0] + dest[1]), min_len);\n    src[1] = src[2];\n    dest[4] += min_len;\n    dest[1] += min_len;\n  }\n\n  result = *len;\n  return result;\n}",
        "baseline_code_stripped": "unsigned __int64 __fastcall sub_4BC2F8(_QWORD *a1, _QWORD *a2, _DWORD *a3)\n{\n  unsigned __int64 v3; // rax\n  unsigned __int64 result; // rax\n  unsigned __int64 n; // [rsp+28h] [rbp-8h]\n\n  while ( 1 )\n  {\n    result = (unsigned int)*a3;\n    if ( !(_DWORD)result )\n      break;\n    result = a2[2];\n    if ( a2[1] >= result )\n      break;\n    result = a2[5];\n    if ( a2[4] >= result )\n      break;\n    v3 = a2[2] - a2[1];\n    if ( a2[5] - a2[4] <= v3 )\n      v3 = a2[5] - a2[4];\n    n = v3;\n    if ( v3 > a1[5] - a1[2] )\n      n = a1[5] - a1[2];\n    if ( n > (unsigned int)*a3 )\n      n = (unsigned int)*a3;\n    *a3 -= n;\n    memcpy((void *)(*a1 + a1[2]), (const void *)(*a2 + a2[1]), n);\n    a1[2] += n;\n    if ( a1[3] < a1[2] )\n      a1[3] = a1[2];\n    if ( a1[2] == a1[5] )\n      a1[2] = 0LL;\n    memcpy((void *)(a2[3] + a2[4]), (const void *)(*a2 + a2[1]), n);\n    a1[1] = a1[2];\n    a2[4] += n;\n    a2[1] += n;\n  }\n  return result;\n}\n",
        "baseline_code_debug": "void __cdecl dict_uncompressed(dictionary *dict, xz_buf *b, uint32_t *left)\n{\n  size_t v3; // rax\n  size_t copy_size; // [rsp+28h] [rbp-8h]\n\n  while ( *left && b->in_pos < b->in_size && b->out_pos < b->out_size )\n  {\n    v3 = b->in_size - b->in_pos;\n    if ( b->out_size - b->out_pos <= v3 )\n      v3 = b->out_size - b->out_pos;\n    copy_size = v3;\n    if ( v3 > dict->end - dict->pos )\n      copy_size = dict->end - dict->pos;\n    if ( copy_size > *left )\n      copy_size = *left;\n    *left -= copy_size;\n    memcpy(&dict->buf[dict->pos], &b->in[b->in_pos], copy_size);\n    dict->pos += copy_size;\n    if ( dict->full < dict->pos )\n      dict->full = dict->pos;\n    if ( dict->pos == dict->end )\n      dict->pos = 0LL;\n    memcpy(&b->out[b->out_pos], &b->in[b->in_pos], copy_size);\n    dict->start = dict->pos;\n    b->out_pos += copy_size;\n    b->in_pos += copy_size;\n  }\n}\n",
        "similarity_score_unixcoder": 0.6856303811073303,
        "similarity_score_baseline_stripped": 0.5659118890762329,
        "similarity_score_baseline_debug": 0.8982996344566345
    },
    {
        "func_name": "skip_whitespace",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl hex_digits(const unsigned __int8 *s)\n{\n  while ( *s )\n  {\n    if ( ((*__ctype_b_loc())[*s] & 0x1000) == 0 )\n      return 0;\n    ++s;\n  }\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nhex_digits (unsigned char const *s)\n{\n  while (*s)\n    {\n      if (!isxdigit (*s))\n        return false;\n      ++s;\n    }\n  return true;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_char(size_t n_bytes, const void *block, const char *fmt_string)\n{\n  unsigned __int8 *v3; // rax\n\n  while ( n_bytes )\n  {\n    v3 = (unsigned __int8 *)block;\n    block = (char *)block + 1;\n    printf(fmt_string, *v3);\n    --n_bytes;\n  }\n}\n\n\n Revised code:\nstatic void\nprint_char (size_t n_bytes, void const *block, char const *fmt_string)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes / sizeof *p; i != 0; i--)\n    printf (fmt_string, *p++);\n}\n\n## Example:\n\n Input code:\nsize_t __cdecl adjust_column(size_t column, char c)\n{\n  size_t columna; // [rsp+2h] [rbp-8h]\n\n  columna = column;\n  if ( count_bytes )\n    return column + 1;\n  switch ( c )\n  {\n    case 8:\n      if ( column )\n        return column - 1;\n      break;\n    case 13:\n      return 0LL;\n    case 9:\n      return column + 8 - (column & 7);\n    default:\n      return column + 1;\n  }\n  return columna;\n}\n\n\n Revised code:\nstatic size_t\nadjust_column (size_t column, char c)\n{\n  if (!count_bytes)\n    {\n      if (c == '\\b')\n\t{\n\t  if (column > 0)\n\t    column--;\n\t}\n      else if (c == '\\r')\n\tcolumn = 0;\n      else if (c == '\\t')\n\tcolumn += TAB_WIDTH - column % TAB_WIDTH;\n      else /* if (isprint (c)) */\n\tcolumn++;\n    }\n  else\n    column++;\n  return column;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n_BYTE *__fastcall sub_4093B4(_BYTE *a1)\n{\n  while ( *a1 == 32 || (unsigned __int8)(*a1 - 9) <= 4u )\n    ++a1;\n  return a1;\n}\n",
        "output": "```c\nstatic unsigned char *\nskip_whitespace(unsigned char *str)\n{\n  while (*str == ' ' || (*str >= '\\t' && *str <= '\\r'))\n    str++;\n  return str;\n}\n```",
        "source_code": "FAST_FUNC skip_whitespace(const char *s)\n{\n\t/* In POSIX/C locale (the only locale we care about: do we REALLY want\n\t * to allow Unicode whitespace in, say, .conf files? nuts!)\n\t * isspace is only these chars: \"\\t\\n\\v\\f\\r\" and space.\n\t * \"\\t\\n\\v\\f\\r\" happen to have ASCII codes 9,10,11,12,13.\n\t * Use that.\n\t */\n\twhile (*s == ' ' || (unsigned char)(*s - 9) <= (13 - 9))\n\t\ts++;\n\n\treturn (char *) s;\n}",
        "parsed_output": "static unsigned char *\nskip_whitespace(unsigned char *str)\n{\n  while (*str == ' ' || (*str >= '\\t' && *str <= '\\r'))\n    str++;\n  return str;\n}",
        "baseline_code_stripped": "_BYTE *__fastcall sub_4093B4(_BYTE *a1)\n{\n  while ( *a1 == 32 || (unsigned __int8)(*a1 - 9) <= 4u )\n    ++a1;\n  return a1;\n}\n",
        "baseline_code_debug": "char *__cdecl skip_whitespace(const char *s)\n{\n  while ( *s == 32 || (unsigned __int8)(*s - 9) <= 4u )\n    ++s;\n  return (char *)s;\n}\n",
        "similarity_score_unixcoder": 0.8071090579032898,
        "similarity_score_baseline_stripped": 0.5657549500465393,
        "similarity_score_baseline_debug": 0.7624315023422241
    },
    {
        "func_name": "volname_main",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl bsd_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  char *v5; // rax\n  unsigned int v7; // [rsp+14h] [rbp-2CCh]\n  bool is_stdin; // [rsp+1Fh] [rbp-2C1h]\n  char hbuf[652]; // [rsp+20h] [rbp-2C0h] BYREF\n  int ch_0; // [rsp+2ACh] [rbp-34h]\n  uintmax_t total_bytes; // [rsp+2B0h] [rbp-30h]\n  int checksum; // [rsp+2BCh] [rbp-24h]\n  FILE *fp; // [rsp+2C0h] [rbp-20h]\n  int print_namea; // [rsp+2CCh] [rbp-14h]\n  const char *filea; // [rsp+2D0h] [rbp-10h]\n\n  filea = file;\n  print_namea = print_name;\n  checksum = 0;\n  total_bytes = 0LL;\n  v2 = strcmp(file, \"-\");\n  is_stdin = v2 == 0;\n  if ( v2 )\n  {\n    fp = fopen(filea, \"r\");\n    if ( !fp )\n      goto LABEL_4;\n  }\n  else\n  {\n    fp = stdin;\n    have_read_stdin = 1;\n  }\n  while ( 1 )\n  {\n    ch_0 = getc_unlocked(fp);\n    if ( ch_0 == -1 )\n      break;\n    ++total_bytes;\n    checksum = (unsigned __int16)(((checksum & 1) << 15) + (checksum >> 1) + ch_0);\n  }\n  if ( ferror_unlocked(fp) )\n  {\n    v4 = __errno_location();\n    error(0, *v4, \"%s\", filea);\n    if ( !is_stdin )\n      fclose(fp);\n    return 0;\n  }\n  if ( !is_stdin && fclose(fp) )\n  {\nLABEL_4:\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    return 0;\n  }\n  v7 = checksum;\n  v5 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x400uLL);\n  printf(\"%05d %5s\", v7, v5);\n  if ( print_namea > 1 )\n    printf(\" %s\", filea);\n  putchar_unlocked(10);\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_sum_file (const char *file, int print_name)\n{\n  FILE *fp;\n  int checksum = 0;\t/* The checksum mod 2^16. */\n  uintmax_t total_bytes = 0;\t/* The number of bytes. */\n  int ch;\t\t/* Each character read. */\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fp = stdin;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fp = fopen (file, (O_BINARY ? \"rb\" : \"r\"));\n      if (fp == NULL)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while ((ch = getc (fp)) != EOF)\n    {\n      total_bytes++;\n      checksum = (checksum >> 1) + ((checksum & 1) << 15);\n      checksum += ch;\n      checksum &= 0xffff;\t/* Keep it within bounds. */\n    }\n\n  if (ferror (fp))\n    {\n      error (0, errno, \"%s\", file);\n      if (!is_stdin)\n\tfclose (fp);\n      return false;\n    }\n\n  if (!is_stdin && fclose (fp) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  printf (\"%05d %5s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 1024));\n  if (print_name > 1)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl sysv_sum_file(const char *file, int print_name)\n{\n  int v2; // eax\n  int *v3; // rax\n  int *v4; // rax\n  int *v5; // rax\n  char *v6; // rax\n  size_t bytes_read; // [rsp+20h] [rbp-22E0h]\n  size_t i; // [rsp+28h] [rbp-22D8h]\n  _BYTE is_stdin[5]; // [rsp+33h] [rbp-22CDh]\n  char hbuf[652]; // [rsp+40h] [rbp-22C0h] BYREF\n  uintmax_t total_bytes; // [rsp+2D8h] [rbp-2028h]\n  unsigned __int8 buf[8192]; // [rsp+2E0h] [rbp-2020h] BYREF\n  int fd; // [rsp+22E8h] [rbp-18h]\n  int print_namea; // [rsp+22ECh] [rbp-14h]\n  const char *filea; // [rsp+22F0h] [rbp-10h]\n  char v17; // [rsp+22FFh] [rbp-1h]\n\n  filea = file;\n  print_namea = print_name;\n  total_bytes = 0LL;\n  is_stdin[4] = 0;\n  v2 = strcmp(file, \"-\");\n  *(_DWORD *)is_stdin = v2 == 0;\n  if ( !v2 )\n  {\n    fd = 0;\n    have_read_stdin = 1;\n    goto LABEL_5;\n  }\n  fd = open(filea, 0);\n  if ( fd == -1 )\n  {\n    v3 = __errno_location();\n    error(0, *v3, \"%s\", filea);\n    v17 = 0;\n  }\n  else\n  {\nLABEL_5:\n    while ( 1 )\n    {\n      bytes_read = safe_read(fd, buf, 0x2000uLL);\n      if ( !bytes_read )\n        break;\n      if ( bytes_read == -1LL )\n      {\n        v4 = __errno_location();\n        error(0, *v4, \"%s\", filea);\n        if ( (is_stdin[0] & 1) == 0 )\n          close(fd);\n        v17 = 0;\n        return v17 & 1;\n      }\n      for ( i = 0LL; i < bytes_read; ++i )\n        *(_DWORD *)&is_stdin[1] += buf[i];\n      total_bytes += bytes_read;\n    }\n    if ( (is_stdin[0] & 1) != 0 || !close(fd) )\n    {\n      v6 = human_readable(total_bytes, hbuf, 0, 1uLL, 0x200uLL);\n      printf(\n        \"%d %s\",\n        ((HIWORD(*(_DWORD *)&is_stdin[1]) + *(unsigned __int16 *)&is_stdin[1]) >> 16)\n      + (unsigned int)(unsigned __int16)(*(_WORD *)&is_stdin[3] + *(_WORD *)&is_stdin[1]),\n        v6);\n      if ( print_namea )\n        printf(\" %s\", filea);\n      putchar_unlocked(10);\n      v17 = 1;\n    }\n    else\n    {\n      v5 = __errno_location();\n      error(0, *v5, \"%s\", filea);\n      v17 = 0;\n    }\n  }\n  return v17 & 1;\n}\n\n\n Revised code:\nstatic bool\nsysv_sum_file (const char *file, int print_name)\n{\n  int fd;\n  unsigned char buf[8192];\n  uintmax_t total_bytes = 0;\n  char hbuf[LONGEST_HUMAN_READABLE + 1];\n  int r;\n  int checksum;\n\n  /* The sum of all the input bytes, modulo (UINT_MAX + 1).  */\n  unsigned int s = 0;\n\n  bool is_stdin = STREQ (file, \"-\");\n\n  if (is_stdin)\n    {\n      fd = STDIN_FILENO;\n      have_read_stdin = true;\n      if (O_BINARY && ! isatty (STDIN_FILENO))\n\tfreopen (NULL, \"rb\", stdin);\n    }\n  else\n    {\n      fd = open (file, O_RDONLY | O_BINARY);\n      if (fd == -1)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  return false;\n\t}\n    }\n\n  while (1)\n    {\n      size_t i;\n      size_t bytes_read = safe_read (fd, buf, sizeof buf);\n\n      if (bytes_read == 0)\n\tbreak;\n\n      if (bytes_read == SAFE_READ_ERROR)\n\t{\n\t  error (0, errno, \"%s\", file);\n\t  if (!is_stdin)\n\t    close (fd);\n\t  return false;\n\t}\n\n      for (i = 0; i < bytes_read; i++)\n\ts += buf[i];\n      total_bytes += bytes_read;\n    }\n\n  if (!is_stdin && close (fd) != 0)\n    {\n      error (0, errno, \"%s\", file);\n      return false;\n    }\n\n  r = (s & 0xffff) + ((s & 0xffffffff) >> 16);\n  checksum = (r & 0xffff) + (r >> 16);\n\n  printf (\"%d %s\", checksum,\n\t  human_readable (total_bytes, hbuf, human_ceiling, 1, 512));\n  if (print_name)\n    printf (\" %s\", file);\n  putchar ('\\n');\n\n  return true;\n}\n\n## Example:\n\n Input code:\nvoid __cdecl print_ascii(size_t n_bytes, const void *block, const char *unused_fmt_string)\n{\n  unsigned __int8 *v3; // rax\n  const char *v4; // rdi\n  char buf[5]; // [rsp+33h] [rbp-3Dh] BYREF\n  const char *s; // [rsp+38h] [rbp-38h]\n  unsigned __int8 c; // [rsp+47h] [rbp-29h]\n  size_t i; // [rsp+48h] [rbp-28h]\n  const unsigned __int8 *p; // [rsp+50h] [rbp-20h]\n  const char *unused_fmt_stringa; // [rsp+58h] [rbp-18h]\n  const void *blocka; // [rsp+60h] [rbp-10h]\n  size_t n_bytesa; // [rsp+68h] [rbp-8h]\n\n  n_bytesa = n_bytes;\n  blocka = block;\n  unused_fmt_stringa = unused_fmt_string;\n  p = (const unsigned __int8 *)block;\n  for ( i = n_bytes; i; --i )\n  {\n    v3 = (unsigned __int8 *)p++;\n    c = *v3;\n    switch ( c )\n    {\n      case 0u:\n        s = \" \\\\0\";\n        break;\n      case 7u:\n        s = (const char *)&unk_409AA8;\n        break;\n      case 8u:\n        s = (const char *)&unk_409AAC;\n        break;\n      case 9u:\n        s = (const char *)&unk_409ABC;\n        break;\n      case 0xAu:\n        s = (const char *)&unk_409AB4;\n        break;\n      case 0xBu:\n        s = (const char *)&unk_409AC0;\n        break;\n      case 0xCu:\n        s = (const char *)&unk_409AB0;\n        break;\n      case 0xDu:\n        s = (const char *)&unk_409AB8;\n        break;\n      default:\n        v4 = \"%03o\";\n        if ( ((*__ctype_b_loc())[c] & 0x4000) != 0 )\n          v4 = \"  %c\";\n        sprintf(buf, v4, c);\n        s = buf;\n        break;\n    }\n    printf(\" %3s\", s);\n  }\n}\n\n\n Revised code:\nstatic void\nprint_ascii (size_t n_bytes, void const *block,\n\t     const char *unused_fmt_string ATTRIBUTE_UNUSED)\n{\n  unsigned char const *p = block;\n  size_t i;\n  for (i = n_bytes; i > 0; i--)\n    {\n      unsigned char c = *p++;\n      const char *s;\n      char buf[5];\n\n      switch (c)\n\t{\n\tcase '\\0':\n\t  s = \" \\\\0\";\n\t  break;\n\n\tcase '\\a':\n\t  s = \" \\\\a\";\n\t  break;\n\n\tcase '\\b':\n\t  s = \" \\\\b\";\n\t  break;\n\n\tcase '\\f':\n\t  s = \" \\\\f\";\n\t  break;\n\n\tcase '\\n':\n\t  s = \" \\\\n\";\n\t  break;\n\n\tcase '\\r':\n\t  s = \" \\\\r\";\n\t  break;\n\n\tcase '\\t':\n\t  s = \" \\\\t\";\n\t  break;\n\n\tcase '\\v':\n\t  s = \" \\\\v\";\n\t  break;\n\n\tdefault:\n\t  sprintf (buf, (isprint (c) ? \"  %c\" : \"%03o\"), c);\n\t  s = buf;\n\t}\n\n      printf (\" %3s\", s);\n    }\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_42408D(__int64 a1, __int64 a2)\n{\n  char v3[36]; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v4; // [rsp+34h] [rbp-Ch]\n  const char *v5; // [rsp+38h] [rbp-8h]\n\n  v5 = \"/dev/cdrom\";\n  if ( *(_QWORD *)(a2 + 8) )\n  {\n    v5 = *(const char **)(a2 + 8);\n    if ( *(_QWORD *)(a2 + 16) )\n      sub_407F64(a1);\n  }\n  v4 = sub_40A295(v5, 0);\n  sub_40A557(v4, 32808LL, 0);\n  sub_507452(v4, v3, 32LL);\n  printf(\"%32.32s\\n\", v3);\n  return 0LL;\n}\n",
        "output": "```c\nstatic void\nprint_cdrom_info (__int64 output_stream, __int64 options)\n{\n  char cdrom_info[36]; // Buffer to store CD-ROM information\n  unsigned int cdrom_fd; // File descriptor for CD-ROM\n  const char *cdrom_device = \"/dev/cdrom\"; // Default CD-ROM device path\n\n  // If a device path is provided in options, use it instead of default\n  if (*(_QWORD *)(options + 8))\n    {\n      cdrom_device = *(const char **)(options + 8);\n      // If a flag is set in options, perform additional operation\n      if (*(_QWORD *)(options + 16))\n        perform_additional_operation(output_stream);\n    }\n\n  // Open the CD-ROM device and get the file descriptor\n  cdrom_fd = open_cdrom_device(cdrom_device, 0);\n  // Perform an operation on the CD-ROM device using the file descriptor\n  perform_cdrom_operation(cdrom_fd, 32808LL, 0);\n  // Read CD-ROM information into the buffer\n  read_cdrom_info(cdrom_fd, cdrom_info, 32LL);\n  // Print the CD-ROM information\n  printf(\"%32.32s\\n\", cdrom_info);\n\n  return;\n}\n```",
        "source_code": "int volname_main(int argc UNUSED_PARAM, char **argv)\n{\n\tint fd;\n\tchar buffer[32];\n\tconst char *device;\n\n\tdevice = \"/dev/cdrom\";\n\tif (argv[1]) {\n\t\tdevice = argv[1];\n\t\tif (argv[2])\n\t\t\tbb_show_usage();\n\t}\n\n\tfd = xopen(device, O_RDONLY);\n\txlseek(fd, 32808, SEEK_SET);\n\txread(fd, buffer, 32);\n\tprintf(\"%32.32s\\n\", buffer);\n\tif (ENABLE_FEATURE_CLEAN_UP) {\n\t\tclose(fd);\n\t}\n\treturn 0;\n}",
        "parsed_output": "static void\nprint_cdrom_info (__int64 output_stream, __int64 options)\n{\n  char cdrom_info[36]; // Buffer to store CD-ROM information\n  unsigned int cdrom_fd; // File descriptor for CD-ROM\n  const char *cdrom_device = \"/dev/cdrom\"; // Default CD-ROM device path\n\n  // If a device path is provided in options, use it instead of default\n  if (*(_QWORD *)(options + 8))\n    {\n      cdrom_device = *(const char **)(options + 8);\n      // If a flag is set in options, perform additional operation\n      if (*(_QWORD *)(options + 16))\n        perform_additional_operation(output_stream);\n    }\n\n  // Open the CD-ROM device and get the file descriptor\n  cdrom_fd = open_cdrom_device(cdrom_device, 0);\n  // Perform an operation on the CD-ROM device using the file descriptor\n  perform_cdrom_operation(cdrom_fd, 32808LL, 0);\n  // Read CD-ROM information into the buffer\n  read_cdrom_info(cdrom_fd, cdrom_info, 32LL);\n  // Print the CD-ROM information\n  printf(\"%32.32s\\n\", cdrom_info);\n\n  return;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_42408D(__int64 a1, __int64 a2)\n{\n  char v3[36]; // [rsp+10h] [rbp-30h] BYREF\n  unsigned int v4; // [rsp+34h] [rbp-Ch]\n  const char *v5; // [rsp+38h] [rbp-8h]\n\n  v5 = \"/dev/cdrom\";\n  if ( *(_QWORD *)(a2 + 8) )\n  {\n    v5 = *(const char **)(a2 + 8);\n    if ( *(_QWORD *)(a2 + 16) )\n      sub_407F64(a1);\n  }\n  v4 = sub_40A295(v5, 0);\n  sub_40A557(v4, 32808LL, 0);\n  sub_507452(v4, v3, 32LL);\n  printf(\"%32.32s\\n\", v3);\n  return 0LL;\n}\n",
        "baseline_code_debug": "int __cdecl volname_main(int argc, char **argv)\n{\n  char buffer[32]; // [rsp+10h] [rbp-30h] BYREF\n  int fd; // [rsp+34h] [rbp-Ch]\n  const char *device; // [rsp+38h] [rbp-8h]\n\n  device = \"/dev/cdrom\";\n  if ( argv[1] )\n  {\n    device = argv[1];\n    if ( argv[2] )\n      bb_show_usage();\n  }\n  fd = xopen(device, 0);\n  xlseek(fd, 32808LL, 0);\n  xread(fd, buffer, 0x20uLL);\n  printf(\"%32.32s\\n\", buffer);\n  return 0;\n}\n",
        "similarity_score_unixcoder": 0.6492550373077393,
        "similarity_score_baseline_stripped": 0.5170981287956238,
        "similarity_score_baseline_debug": 0.7889750003814697
    },
    {
        "func_name": "get_signum",
        "input": "# Task Description\n\nYou are a skilled binary reverse engineer. I will provide you with a binary function, with the form of the decompiled C-like pseudocode (e.g., derived from IDA pro or Ghidra). Your task is to comprehend the code, and then revise the code to improve its readability (i.e., make it easier for human to understand).\n\n\n# Input & Output format\n\nYour input data will be a piece of C-like pseudocode, and your output will be the revised code. Remember, your output will only include the revised code and NOTHING ELSE. DO NOT provide any extra text for explanation.\n\n\n# Few-shot examples\n\nI will provide the three examples for your reference. Each example involves the input decompiled code, and the ground-truth source code. These examples are similar to your input, and you should learn how to revise the code from them.\n\n\n\n## Example:\n\n Input code:\nbool __cdecl bsd_split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, char **file_name)\n{\n  size_t v4; // rcx\n  bool v6; // [rsp+1h] [rbp-33h]\n  bool v7; // [rsp+2h] [rbp-32h]\n  bool v8; // [rsp+3h] [rbp-31h]\n  size_t i; // [rsp+4h] [rbp-30h]\n  size_t ia; // [rsp+4h] [rbp-30h]\n  size_t ib; // [rsp+4h] [rbp-30h]\n\n  *file_name = s;\n  for ( i = s_len - 1; ; --i )\n  {\n    v8 = 0;\n    if ( i )\n      v8 = s[i] != 41;\n    if ( !v8 )\n      break;\n  }\n  if ( s[i] != 41 )\n    return 0;\n  v4 = i;\n  ia = i + 1;\n  s[v4] = 0;\n  while ( 1 )\n  {\n    v7 = 1;\n    if ( s[ia] != 32 )\n      v7 = s[ia] == 9;\n    if ( !v7 )\n      break;\n    ++ia;\n  }\n  if ( s[ia] != 61 )\n    return 0;\n  for ( ib = ia + 1; ; ++ib )\n  {\n    v6 = 1;\n    if ( s[ib] != 32 )\n      v6 = s[ib] == 9;\n    if ( !v6 )\n      break;\n  }\n  *hex_digest = (unsigned __int8 *)&s[ib];\n  return 1;\n}\n\n\n Revised code:\nstatic bool\nbsd_split_3 (char *s, size_t s_len, unsigned char **hex_digest, char **file_name)\n{\n  size_t i;\n\n  *file_name = s;\n\n  /* Find end of filename. The BSD 'md5' and 'sha1' commands do not escape\n     filenames, so search backwards for the last ')'. */\n  i = s_len - 1;\n  while (i && s[i] != ')')\n    i--;\n\n  if (s[i] != ')')\n    return false;\n\n  s[i++] = '\\0';\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  if (s[i] != '=')\n    return false;\n\n  i++;\n\n  while (ISWHITE (s[i]))\n    i++;\n\n  *hex_digest = (unsigned char *) &s[i];\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl split_3(char *s, size_t s_len, unsigned __int8 **hex_digest, int *binary, char **file_name)\n{\n  size_t v5; // rcx\n  size_t v6; // rcx\n  size_t v7; // rcx\n  char *v8; // rax\n  char *v9; // rax\n  size_t v10; // rcx\n  char *v11; // rax\n  bool v13; // [rsp+2Fh] [rbp-51h]\n  char *dst; // [rsp+30h] [rbp-50h]\n  bool escaped_filename; // [rsp+47h] [rbp-39h]\n  size_t i; // [rsp+48h] [rbp-38h]\n  size_t ia; // [rsp+48h] [rbp-38h]\n  size_t ib; // [rsp+48h] [rbp-38h]\n  size_t ic; // [rsp+48h] [rbp-38h]\n\n  escaped_filename = 0;\n  for ( i = 0LL; ; ++i )\n  {\n    v13 = 1;\n    if ( s[i] != 32 )\n      v13 = s[i] == 9;\n    if ( !v13 )\n      break;\n  }\n  if ( !strncmp(&s[i], \"MD5\", 3uLL) && !strncmp(&s[i + 3], \" (\", 2uLL) )\n  {\n    *binary = 0;\n    return bsd_split_3(&s[i + 5], s_len - (i + 5), hex_digest, file_name);\n  }\n  else if ( s_len - i >= (s[i] == 92) + min_digest_line_length )\n  {\n    if ( s[i] == 92 )\n    {\n      ++i;\n      escaped_filename = 1;\n    }\n    *hex_digest = (unsigned __int8 *)&s[i];\n    ia = i + digest_hex_bytes;\n    if ( s[ia] == 32 || s[ia] == 9 )\n    {\n      v5 = ia;\n      ib = ia + 1;\n      s[v5] = 0;\n      if ( s[ib] == 32 || s[ib] == 42 )\n      {\n        v6 = ib;\n        ic = ib + 1;\n        *binary = s[v6] == 42;\n        *file_name = &s[ic];\n        if ( escaped_filename )\n        {\n          dst = &s[ic];\n          while ( ic < s_len )\n          {\n            if ( !s[ic] )\n              return 0;\n            if ( s[ic] == 92 )\n            {\n              if ( ic == s_len - 1 )\n                return 0;\n              v7 = ic + 1;\n              ic += 2LL;\n              if ( s[v7] == 92 )\n              {\n                v9 = dst++;\n                *v9 = 92;\n              }\n              else\n              {\n                if ( s[v7] != 110 )\n                  return 0;\n                v8 = dst++;\n                *v8 = 10;\n              }\n            }\n            else\n            {\n              v10 = ic++;\n              v11 = dst++;\n              *v11 = s[v10];\n            }\n          }\n          *dst = 0;\n        }\n        return 1;\n      }\n      else\n      {\n        return 0;\n      }\n    }\n    else\n    {\n      return 0;\n    }\n  }\n  else\n  {\n    return 0;\n  }\n}\n\n\n Revised code:\nstatic bool\nsplit_3 (char *s, size_t s_len,\n\t unsigned char **hex_digest, int *binary, char **file_name)\n{\n  size_t i;\n  bool escaped_filename = false;\n  size_t algo_name_len;\n\n  i = 0;\n  while (ISWHITE (s[i]))\n    ++i;\n\n  /* Check for BSD-style checksum line. */\n  algo_name_len = strlen (DIGEST_TYPE_STRING);\n  if (strncmp (s + i, DIGEST_TYPE_STRING, algo_name_len) == 0)\n    {\n      if (strncmp (s + i + algo_name_len, \" (\", 2) == 0)\n\t{\n\t  *binary = 0;\n\t  return bsd_split_3 (s +      i + algo_name_len + 2,\n\t\t\t      s_len - (i + algo_name_len + 2),\n\t\t\t      hex_digest, file_name);\n\t}\n    }\n\n  /* Ignore this line if it is too short.\n     Each line must have at least `min_digest_line_length - 1' (or one more, if\n     the first is a backslash) more characters to contain correct message digest\n     information.  */\n  if (s_len - i < min_digest_line_length + (s[i] == '\\\\'))\n    return false;\n\n  if (s[i] == '\\\\')\n    {\n      ++i;\n      escaped_filename = true;\n    }\n  *hex_digest = (unsigned char *) &s[i];\n\n  /* The first field has to be the n-character hexadecimal\n     representation of the message digest.  If it is not followed\n     immediately by a white space it's an error.  */\n  i += digest_hex_bytes;\n  if (!ISWHITE (s[i]))\n    return false;\n\n  s[i++] = '\\0';\n\n  if (s[i] != ' ' && s[i] != '*')\n    return false;\n  *binary = (s[i++] == '*');\n\n  /* All characters between the type indicator and end of line are\n     significant -- that includes leading and trailing white space.  */\n  *file_name = &s[i];\n\n  if (escaped_filename)\n    {\n      /* Translate each `\\n' string in the file name to a NEWLINE,\n\t and each `\\\\' string to a backslash.  */\n\n      char *dst = &s[i];\n\n      while (i < s_len)\n\t{\n\t  switch (s[i])\n\t    {\n\t    case '\\\\':\n\t      if (i == s_len - 1)\n\t\t{\n\t\t  /* A valid line does not end with a backslash.  */\n\t\t  return false;\n\t\t}\n\t      ++i;\n\t      switch (s[i++])\n\t\t{\n\t\tcase 'n':\n\t\t  *dst++ = '\\n';\n\t\t  break;\n\t\tcase '\\\\':\n\t\t  *dst++ = '\\\\';\n\t\t  break;\n\t\tdefault:\n\t\t  /* Only `\\' or `n' may follow a backslash.  */\n\t\t  return false;\n\t\t}\n\t      break;\n\n\t    case '\\0':\n\t      /* The file name may not contain a NUL.  */\n\t      return false;\n\t      break;\n\n\t    default:\n\t      *dst++ = s[i++];\n\t      break;\n\t    }\n\t}\n      *dst = '\\0';\n    }\n  return true;\n}\n\n## Example:\n\n Input code:\nbool __cdecl test_unop(const char *op)\n{\n  int v2; // [rsp+28h] [rbp-14h]\n\n  if ( *op != 45 )\n    return 0;\n  v2 = op[1];\n  return v2 == 71\n      || v2 == 76\n      || (unsigned int)(v2 - 78) < 2\n      || v2 == 83\n      || (unsigned int)(v2 - 97) < 8\n      || v2 == 107\n      || (unsigned int)(v2 - 110) < 3\n      || (unsigned int)(v2 - 114) < 4\n      || (unsigned int)(v2 - 119) < 2\n      || v2 == 122;\n}\n\n\n Revised code:\nstatic bool\ntest_unop (char const *op)\n{\n  if (op[0] != '-')\n    return false;\n\n  switch (op[1])\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e':\n    case 'f': case 'g': case 'h': case 'k': case 'n':\n    case 'o': case 'p': case 'r': case 's': case 't':\n    case 'u': case 'w': case 'x': case 'z':\n    case 'G': case 'L': case 'O': case 'S': case 'N':\n      return true;\n    }\n\n  return false;\n}\n# Data to be processed\n\nBelow is the decompiled C-like pseudocode you will process. You will analyze the code and output the revised code:\n__int64 __fastcall sub_508950(const char *a1)\n{\n  char *s1; // [rsp+8h] [rbp-18h]\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n  unsigned int v5; // [rsp+1Ch] [rbp-4h]\n  unsigned int v6; // [rsp+1Ch] [rbp-4h]\n\n  s1 = (char *)a1;\n  v3 = sub_40BECF(a1, 0LL, 10);\n  if ( !*(_DWORD *)qword_75D400 )\n    return v3;\n  if ( !strncasecmp(a1, \"SIG\", 3uLL) )\n    s1 = (char *)(a1 + 3);\n  for ( i = 0; i <= 0x20; ++i )\n  {\n    if ( !strcasecmp(s1, &aExit_2[7 * i]) )\n      return i;\n  }\n  if ( ((unsigned __int8)*s1 | 0x20) == 105 && ((unsigned __int8)s1[1] | 0x20) == 111 )\n  {\n    if ( !s1[2] )\n      return 29LL;\n    if ( ((unsigned __int8)s1[2] | 0x20) == 116 && !s1[3] )\n      return 6LL;\n  }\n  if ( !strncasecmp(s1, \"RTMIN\", 5uLL) )\n  {\n    if ( !s1[5] )\n      return 32LL;\n    if ( s1[5] == 43 )\n    {\n      v5 = sub_40BECF(s1 + 6, 0LL, 10);\n      if ( !*(_DWORD *)qword_75D400 && v5 <= 0x20 )\n        return v5 + 32;\n    }\n  }\n  else if ( !strncasecmp(s1, \"RTMAX\", 5uLL) )\n  {\n    if ( !s1[5] )\n      return 64LL;\n    if ( s1[5] == 45 )\n    {\n      v6 = sub_40BECF(s1 + 6, 0LL, 10);\n      if ( !*(_DWORD *)qword_75D400 && v6 <= 0x20 )\n        return 64 - v6;\n    }\n  }\n  return 0xFFFFFFFFLL;\n}\n",
        "output": "```c\nstatic unsigned long\nsub_508950 (const char *signal_name)\n{\n  const char *name;\n  unsigned int signum;\n  unsigned int i;\n  unsigned int offset;\n\n  name = signal_name;\n  signum = parse_unsigned (signal_name, 10);\n  if (!is_signal_specified ())\n    return signum;\n\n  if (strncasecmp (signal_name, \"SIG\", 3) == 0)\n    name += 3;\n\n  for (i = 0; i <= MAX_SIGNAL_NUMBER; ++i)\n    {\n      if (strcasecmp (name, signal_names[i]) == 0)\n        return i;\n    }\n\n  if (tolower ((unsigned char)name[0]) == 'i' && tolower ((unsigned char)name[1]) == 'o')\n    {\n      if (name[2] == '\\0')\n        return SIGPOLL;\n      if (tolower ((unsigned char)name[2]) == 't' && name[3] == '\\0')\n        return SIGIOT;\n    }\n\n  if (strncasecmp (name, \"RTMIN\", 5) == 0)\n    {\n      if (name[5] == '\\0')\n        return SIGRTMIN;\n      if (name[5] == '+')\n        {\n          offset = parse_unsigned (name + 6, 10);\n          if (!is_signal_specified () && offset <= MAX_RT_OFFSET)\n            return SIGRTMIN + offset;\n        }\n    }\n  else if (strncasecmp (name, \"RTMAX\", 5) == 0)\n    {\n      if (name[5] == '\\0')\n        return SIGRTMAX;\n      if (name[5] == '-')\n        {\n          offset = parse_unsigned (name + 6, 10);\n          if (!is_signal_specified () && offset <= MAX_RT_OFFSET)\n            return SIGRTMAX - offset;\n        }\n    }\n\n  return INVALID_SIGNAL;\n}\n```",
        "source_code": "int FAST_FUNC get_signum(const char *name)\n{\n\tunsigned i;\n\n\ti = bb_strtou(name, NULL, 10);\n\tif (!errno)\n\t\treturn i;\n\tif (strncasecmp(name, \"SIG\", 3) == 0)\n\t\tname += 3;\n\tfor (i = 0; i < ARRAY_SIZE(signals); i++)\n\t\tif (strcasecmp(name, signals[i]) == 0)\n\t\t\treturn i;\n\n#if ENABLE_DESKTOP\n# if defined(SIGIOT) || defined(SIGIO)\n\t/* SIGIO[T] are aliased to other names,\n\t * thus cannot be stored in the signals[] array.\n\t * Need special code to recognize them */\n\tif ((name[0] | 0x20) == 'i' && (name[1] | 0x20) == 'o') {\n#  ifdef SIGIO\n\t\tif (!name[2])\n\t\t\treturn SIGIO;\n#  endif\n#  ifdef SIGIOT\n\t\tif ((name[2] | 0x20) == 't' && !name[3])\n\t\t\treturn SIGIOT;\n#  endif\n\t}\n# endif\n#endif\n\n#if ENABLE_FEATURE_RTMINMAX\n# if defined(SIGRTMIN) && defined(SIGRTMAX)\n/* libc may use some rt sigs for pthreads and therefore \"remap\" SIGRTMIN/MAX,\n * but we want to use \"raw\" SIGRTMIN/MAX. Underscored names, if exist, provide\n * them. If they don't exist, fall back to non-underscored ones: */\n#  if !defined(__SIGRTMIN)\n#   define __SIGRTMIN SIGRTMIN\n#  endif\n#  if !defined(__SIGRTMAX)\n#   define __SIGRTMAX SIGRTMAX\n#  endif\n\tif (strncasecmp(name, \"RTMIN\", 5) == 0) {\n\t\tif (!name[5])\n\t\t\treturn __SIGRTMIN;\n\t\tif (name[5] == '+') {\n\t\t\ti = bb_strtou(name + 6, NULL, 10);\n\t\t\tif (!errno && i <= __SIGRTMAX - __SIGRTMIN)\n\t\t\t\treturn __SIGRTMIN + i;\n\t\t}\n\t}\n\telse if (strncasecmp(name, \"RTMAX\", 5) == 0) {\n\t\tif (!name[5])\n\t\t\treturn __SIGRTMAX;\n\t\tif (name[5] == '-') {\n\t\t\ti = bb_strtou(name + 6, NULL, 10);\n\t\t\tif (!errno && i <= __SIGRTMAX - __SIGRTMIN)\n\t\t\t\treturn __SIGRTMAX - i;\n\t\t}\n\t}\n# endif\n#endif\n\n\treturn -1;\n}",
        "parsed_output": "static unsigned long\nsub_508950 (const char *signal_name)\n{\n  const char *name;\n  unsigned int signum;\n  unsigned int i;\n  unsigned int offset;\n\n  name = signal_name;\n  signum = parse_unsigned (signal_name, 10);\n  if (!is_signal_specified ())\n    return signum;\n\n  if (strncasecmp (signal_name, \"SIG\", 3) == 0)\n    name += 3;\n\n  for (i = 0; i <= MAX_SIGNAL_NUMBER; ++i)\n    {\n      if (strcasecmp (name, signal_names[i]) == 0)\n        return i;\n    }\n\n  if (tolower ((unsigned char)name[0]) == 'i' && tolower ((unsigned char)name[1]) == 'o')\n    {\n      if (name[2] == '\\0')\n        return SIGPOLL;\n      if (tolower ((unsigned char)name[2]) == 't' && name[3] == '\\0')\n        return SIGIOT;\n    }\n\n  if (strncasecmp (name, \"RTMIN\", 5) == 0)\n    {\n      if (name[5] == '\\0')\n        return SIGRTMIN;\n      if (name[5] == '+')\n        {\n          offset = parse_unsigned (name + 6, 10);\n          if (!is_signal_specified () && offset <= MAX_RT_OFFSET)\n            return SIGRTMIN + offset;\n        }\n    }\n  else if (strncasecmp (name, \"RTMAX\", 5) == 0)\n    {\n      if (name[5] == '\\0')\n        return SIGRTMAX;\n      if (name[5] == '-')\n        {\n          offset = parse_unsigned (name + 6, 10);\n          if (!is_signal_specified () && offset <= MAX_RT_OFFSET)\n            return SIGRTMAX - offset;\n        }\n    }\n\n  return INVALID_SIGNAL;\n}",
        "baseline_code_stripped": "__int64 __fastcall sub_508950(const char *a1)\n{\n  char *s1; // [rsp+8h] [rbp-18h]\n  unsigned int v3; // [rsp+1Ch] [rbp-4h]\n  unsigned int i; // [rsp+1Ch] [rbp-4h]\n  unsigned int v5; // [rsp+1Ch] [rbp-4h]\n  unsigned int v6; // [rsp+1Ch] [rbp-4h]\n\n  s1 = (char *)a1;\n  v3 = sub_40BECF(a1, 0LL, 10);\n  if ( !*(_DWORD *)qword_75D400 )\n    return v3;\n  if ( !strncasecmp(a1, \"SIG\", 3uLL) )\n    s1 = (char *)(a1 + 3);\n  for ( i = 0; i <= 0x20; ++i )\n  {\n    if ( !strcasecmp(s1, &aExit_2[7 * i]) )\n      return i;\n  }\n  if ( ((unsigned __int8)*s1 | 0x20) == 105 && ((unsigned __int8)s1[1] | 0x20) == 111 )\n  {\n    if ( !s1[2] )\n      return 29LL;\n    if ( ((unsigned __int8)s1[2] | 0x20) == 116 && !s1[3] )\n      return 6LL;\n  }\n  if ( !strncasecmp(s1, \"RTMIN\", 5uLL) )\n  {\n    if ( !s1[5] )\n      return 32LL;\n    if ( s1[5] == 43 )\n    {\n      v5 = sub_40BECF(s1 + 6, 0LL, 10);\n      if ( !*(_DWORD *)qword_75D400 && v5 <= 0x20 )\n        return v5 + 32;\n    }\n  }\n  else if ( !strncasecmp(s1, \"RTMAX\", 5uLL) )\n  {\n    if ( !s1[5] )\n      return 64LL;\n    if ( s1[5] == 45 )\n    {\n      v6 = sub_40BECF(s1 + 6, 0LL, 10);\n      if ( !*(_DWORD *)qword_75D400 && v6 <= 0x20 )\n        return 64 - v6;\n    }\n  }\n  return 0xFFFFFFFFLL;\n}\n",
        "baseline_code_debug": "int __cdecl get_signum(const char *name)\n{\n  const char *namea; // [rsp+8h] [rbp-18h]\n  int i; // [rsp+1Ch] [rbp-4h]\n  unsigned int ia; // [rsp+1Ch] [rbp-4h]\n  unsigned int ib; // [rsp+1Ch] [rbp-4h]\n  unsigned int ic; // [rsp+1Ch] [rbp-4h]\n\n  namea = name;\n  i = bb_strtou(name, 0LL, 10);\n  if ( !*bb_errno )\n    return i;\n  if ( !strncasecmp(name, \"SIG\", 3uLL) )\n    namea = name + 3;\n  for ( ia = 0; ia <= 0x20; ++ia )\n  {\n    if ( !strcasecmp(namea, &signals[7 * ia]) )\n      return ia;\n  }\n  if ( (*namea | 0x20) == 105 && (namea[1] | 0x20) == 111 )\n  {\n    if ( !namea[2] )\n      return 29;\n    if ( (namea[2] | 0x20) == 116 && !namea[3] )\n      return 6;\n  }\n  if ( !strncasecmp(namea, \"RTMIN\", 5uLL) )\n  {\n    if ( !namea[5] )\n      return 32;\n    if ( namea[5] == 43 )\n    {\n      ib = bb_strtou(namea + 6, 0LL, 10);\n      if ( !*bb_errno && ib <= 0x20 )\n        return ib + 32;\n    }\n  }\n  else if ( !strncasecmp(namea, \"RTMAX\", 5uLL) )\n  {\n    if ( !namea[5] )\n      return 64;\n    if ( namea[5] == 45 )\n    {\n      ic = bb_strtou(namea + 6, 0LL, 10);\n      if ( !*bb_errno && ic <= 0x20 )\n        return 64 - ic;\n    }\n  }\n  return -1;\n}\n",
        "similarity_score_unixcoder": 0.876197338104248,
        "similarity_score_baseline_stripped": 0.6190508008003235,
        "similarity_score_baseline_debug": 0.7888861894607544
    }
]